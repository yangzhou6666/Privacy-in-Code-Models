{"id": 8405, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . tools . doclets . internal . toolkit . util . * ; public abstract class Content { public String toString ( ) { StringBuilder contentBuilder = new StringBuilder ( ) ; write ( contentBuilder ) ; return contentBuilder . toString ( ) ; } public abstract void addContent ( Content content ) ; public abstract void addContent ( String stringContent ) ; public abstract void write ( StringBuilder contentBuilder ) ; public abstract boolean isEmpty ( ) ; public boolean isValid ( ) { return ! isEmpty ( ) ; } protected static < T > T nullCheck ( T t ) { t . getClass ( ) ; return t ; } protected boolean endsWithNewLine ( StringBuilder contentBuilder ) { int contentLength = contentBuilder . length ( ) ; if ( contentLength == 0 ) { return true ; } int nlLength = DocletConstants .", "gt": "NL . length ( ) ;", "prediction": "LINE_LENGTH ;\n", "label": 0}
{"id": 13117, "input": "<s> package org . seage . grammar . iif ; import org . seage . grammar . Grammar ; import org . seage . grammar . NonterminalSymbol ; import java . util . Vector ; public class IifGrammar extends Grammar { public IifGrammar ( Vector < String > varNames ) { super ( new NonterminalSymbol ( \"STATEMENT\" ) ) ; addRule ( new StatementGrammarRule ( 1 ) , - 1 ) ; addRule ( new LValueGrammarRule ( 2 ) , - 1 ) ; addRule ( new TernaryGrammarRule ( 3 ) , - 1 ) ; addRule ( new TernaryDummyGrammarRule ( 4 ) , - 1 ) ; addRule ( new CondLessGrammarRule ( 5 ) , - 1 ) ; addRule ( new CondGreaterGrammarRule ( 6 ) , - 1 ) ; addRule ( new CondEqualGrammarRule ( 7 ) , - 1 ) ; addRule ( new CondNotEqualGrammarRule ( 8 ) , - 1 ) ; addRule ( new CondGreaterEqualGrammarRule ( 9 ) , - 1 ) ; addRule ( new CondLessEqualGrammarRule ( 10 ) , - 1 ) ; addRule ( new EPlusGrammarRule ( 11 ) , 1 ) ;", "gt": "addRule ( new EMinusGrammarRule ( 12 ) , 1 ) ;", "prediction": "addRule ( new EMinusGrammarRule ( 12 ) , - 1 ) ;\n", "label": 1}
{"id": 2219, "input": "<s> package org . jboss . arquillian . android . spi . event ; public class AndroidVirtualDeviceAvailable extends AndroidVirtualDeviceEvent {", "gt": "public AndroidVirtualDeviceAvailable ( String name )", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 13121, "input": "<s> package it . unina . jdbc . access ; import java . net . URL ; import java . sql . * ; public class AccessDemo { static Connection theConn ; public static void main ( String args [ ] ) { try { theConn = MyConnection . getConnection ( ) ; ResultSet rs ; Statement stmt ; String sql ; sql = \"select objet from Email\" ; stmt = theConn . createStatement ( ) ; rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { System . out . println ( rs . getString ( \"objet\" ) ) ; } rs . close ( ) ; stmt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( theConn != null ) theConn . close ( ) ; }", "gt": "catch ( Exception e )", "prediction": "catch ( Exception e )\n", "label": 1}
{"id": 1026, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class AbstractIndexWriter extends HtmlDocletWriter { protected IndexBuilder indexbuilder ; protected AbstractIndexWriter ( ConfigurationImpl configuration , String path , String filename , String relpath , IndexBuilder indexbuilder ) throws IOException { super ( configuration , path , filename , relpath ) ; this . indexbuilder = indexbuilder ; } protected AbstractIndexWriter ( ConfigurationImpl configuration , String filename , IndexBuilder indexbuilder ) throws IOException { super ( configuration , filename ) ; this . indexbuilder = indexbuilder ; } protected Content getNavLinkIndex ( ) { Content li = HtmlTree . LI ( HtmlStyle . navBarCell1Rev , indexLabel ) ; return li ; } protected void addContents ( Character unicode , List < ? extends Doc > memberlist , Content contentTree ) { contentTree . addContent ( getMarkerAnchor ( \"_\" + unicode + \"_\" ) ) ; Content headContent = new StringContent ( unicode . toString ( ) ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . CONTENT_HEADING , false , HtmlStyle . title , headContent ) ; contentTree . addContent ( heading ) ; int memberListSize = memberlist . size ( ) ; if ( memberListSize > 0 ) { Content dl = new HtmlTree ( HtmlTag . DL ) ; for ( int i = 0 ; i < memberListSize ; i ++ ) { Doc element = memberlist . get ( i ) ; if ( element instanceof MemberDoc ) { addDescription ( ( MemberDoc ) element , dl ) ; } else if ( element instanceof ClassDoc ) { addDescription ( ( ClassDoc ) element , dl ) ; } else if ( element instanceof PackageDoc ) { addDescription ( ( PackageDoc ) element , dl ) ; } } contentTree . addContent ( dl ) ; } } protected void addDescription ( PackageDoc pkg , Content dlTree ) { Content link = getPackageLink ( pkg , new StringContent ( Util . getPackageName ( pkg ) ) ) ; Content dt = HtmlTree . DT ( link ) ; dt . addContent ( \" - \" ) ; dt . addContent ( getResource ( \"doclet.package\" ) ) ; dt . addContent ( \" \" + pkg . name ( ) ) ; dlTree . addContent ( dt ) ; Content dd = new HtmlTree ( HtmlTag . DD ) ; addSummaryComment ( pkg , dd ) ; dlTree . addContent ( dd ) ; } protected void addDescription ( ClassDoc cd , Content dlTree ) { Content link = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_INDEX , cd , true ) ) ) ; Content dt = HtmlTree . DT ( link ) ; dt . addContent ( \" - \" ) ; addClassInfo ( cd , dt ) ; dlTree . addContent ( dt ) ; Content dd = new HtmlTree ( HtmlTag . DD ) ; addComment ( cd , dd ) ; dlTree . addContent ( dd ) ; } protected void addClassInfo ( ClassDoc cd , Content contentTree ) { contentTree . addContent ( getResource ( \"doclet.in\" , Util . getTypeName ( configuration , cd , false ) , getPackageLinkString ( cd . containingPackage ( ) , Util . getPackageName ( cd", "gt": ". containingPackage ( ) ) , false ) ) ) ;", "prediction": ") ) ) ) ;\n", "label": 0}
{"id": 13123, "input": "<s> package sk . m217 . actionbarcompatsample ; import sk . m217 . actionbarcompat . ActionBarActivity ; import sk . m217 . actionbarcompat . ActionBarCompat ; import sk . m217 . actionbarcompat . MenuItemCompat ; import android . os . Bundle ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . widget . EditText ; import android . widget . Toast ; public class ActionBarCompatSampleActivity extends ActionBarActivity { private Menu mMenu ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; getActionBarHelper ( ) . initActionBar ( ) ; ActionBarCompat . setDisplayShowHomeEnabled ( this , true ) ; ActionBarCompat . setDisplayHomeAsUpEnabled ( this , false ) ; ActionBarCompat . setHomeButtonEnabled ( this , true ) ; ActionBarCompat . setBackgroundDrawable ( this , getResources ( ) . getDrawable ( R . drawable . actionbar_compat_background ) ) ; ActionBarCompat . setIcon ( this , getResources ( ) . getDrawable ( R . drawable . ic_launcher ) ) ; } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { super . onPostCreate ( savedInstanceState ) ; ActionBarCompat . setDisplayShowTitleEnabled ( this , true ) ; ActionBarCompat . setTitle ( this , R . string . actionbar_custom_title ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater menuInflater = getMenuInflater ( ) ; menuInflater . inflate ( R . menu . options , menu ) ; if ( mMenu != null ) { return super . onCreateOptionsMenu ( menu ) ; } mMenu = menu ; MenuItem item = mMenu . findItem ( R . id . menu_search ) ; if ( item != null ) { MenuItemCompat . setOnActionExpandListener ( item , new MenuItemCompat . OnActionExpandListenerCompat ( ) { @ Override public boolean onMenuItemActionExpand ( MenuItem item ) { Toast . makeText ( ActionBarCompatSampleActivity . this , \"onMenuItemActionExpand()\" , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } @ Override public boolean onMenuItemActionCollapse ( MenuItem item ) { Toast . makeText ( ActionBarCompatSampleActivity . this , \"onMenuItemActionCollapse()\" , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } } ) ; } EditText editText = ( EditText", "gt": ") MenuItemCompat . getActionView ( item ) ;", "prediction": ") findViewById ( R . id . edit_text ) ;\n", "label": 1}
{"id": 4964, "input": "<s> package org . ofbiz . order . test ; import java . math . BigDecimal ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . order . order . OrderChangeHelper ; import org . ofbiz . order . shoppingcart . CheckOutHelper ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class OrderTestServices { public static final String module = OrderTestServices . class . getName ( ) ; public static Map < String , Object > createTestSalesOrders ( DispatchContext dctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Integer numberOfOrders = ( Integer ) context . get ( \"numberOfOrders\" ) ; int numberOfOrdersInt = numberOfOrders . intValue ( ) ; for ( int i = 1 ; i <= numberOfOrdersInt ; i ++ ) { try { ModelService modelService = dctx . getModelService ( \"createTestSalesOrderSingle\" ) ; Map < String , Object > outputMap = dispatcher . runSync ( \"createTestSalesOrderSingle\" , modelService . makeValid ( context , ModelService . IN_PARAM ) ) ; String orderId = ( String ) outputMap . get ( \"orderId\" ) ; Debug . logInfo ( \"Test sales order with id [\" + orderId + \"] has been processed.\" , module ) ; } catch ( GenericServiceException e ) { String errMsg = \"Error calling createTestSalesOrderSingle: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; } } return ServiceUtil . returnSuccess ( ) ; } public static Map < String , Object > createTestSalesOrderSingle ( DispatchContext dctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; String productCategoryId = ( String ) context . get ( \"productCategoryId\" ) ; String productStoreId = ( String ) context . get ( \"productStoreId\" ) ; String currencyUomId = ( String ) context . get ( \"currencyUomId\" ) ; String partyId = ( String ) context . get ( \"partyId\" ) ; String productId = ( String ) context . get ( \"productId\" ) ; Integer numberOfProductsPerOrder = ( Integer ) context . get ( \"numberOfProductsPerOrder\" ) ; String salesChannel = ( String ) context . get ( \"salesChannel\" ) ; if ( UtilValidate . isEmpty ( salesChannel ) ) { salesChannel = \"WEB_SALES_CHANNEL\" ; } List < String > productsList = FastList . newInstance ( ) ; try { if ( UtilValidate . isNotEmpty ( productId ) ) { productsList . add ( productId ) ; numberOfProductsPerOrder = Integer . valueOf ( 1 ) ; } else { Map < String , Object > result = dispatcher . runSync ( \"getProductCategoryMembers\" , UtilMisc . toMap ( \"categoryId\" , productCategoryId ) ) ; if ( result . get ( \"categoryMembers\" ) != null ) { List < GenericValue > productCategoryMembers = UtilGenerics . checkList ( result . get ( \"categoryMembers\" ) ) ; if ( productCategoryMembers != null ) { for ( GenericValue prodCatMemb : productCategoryMembers ) { if ( prodCatMemb != null ) { productsList . add ( prodCatMemb . getString ( \"productId\" ) ) ; } } } } } } catch ( Exception e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } if ( productsList . size ( ) == 0 ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( \"OrderUiLabels\" , \"OrderCreateTestSalesOrderSingleError\" , UtilMisc . toMap ( \"productCategoryId\" , productCategoryId ) , locale ) ) ; } Random r = new Random ( ) ; ShoppingCart cart = new ShoppingCart ( delegator , productStoreId , locale , currencyUomId ) ; cart . setOrderType ( \"SALES_ORDER\" ) ; cart . setChannelType ( salesChannel ) ; cart . setProductStoreId ( productStoreId ) ; cart . setBillToCustomerPartyId ( partyId ) ; cart . setPlacingCustomerPartyId ( partyId ) ; cart . setShipToCustomerPartyId ( partyId ) ; cart . setEndUserCustomerPartyId ( partyId ) ; try { cart . setUserLogin ( userLogin , dispatcher ) ; } catch ( Exception exc ) { Debug . logWarning ( \"Error setting userLogin in the cart: \" + exc . getMessage ( ) , module ) ; } int numberOfProductsPerOrderInt = numberOfProductsPerOrder . intValue ( ) ; for ( int j = 1 ; j <= numberOfProductsPerOrderInt ; j ++ ) { int k = r . nextInt ( productsList . size ( ) ) ; try { cart . addOrIncreaseItem ( productsList . get ( k ) , null , BigDecimal . ONE , null , null , null , null , null , null , null , null , null , null , null , null , dispatcher ) ; } catch ( Exception exc ) { Debug . logWarning ( \"Error adding product with id \" + productsList . get ( k ) + \" to the cart: \" + exc . getMessage ( ) , module ) ; } } cart . setDefaultCheckoutOptions ( dispatcher ) ; CheckOutHelper checkout = new CheckOutHelper ( dispatcher , delegator , cart ) ; Map < String , Object >", "gt": "orderCreateResult = checkout . createOrder ( userLogin ) ;", "prediction": "result = checkout . runSync ( \"getProductCategoryMembers\" , UtilMisc . toMap ( \"categoryId\" , productCategoryId ) ) ;\n", "label": 0}
{"id": 13124, "input": "<s> package org . eclipse . rap . rwt . internal ; import java . util . * ; import org . eclipse . rap . rwt . internal . util . * ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer . IInstanceCreator ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . swt . internal . SerializableCompatibility ; public class SingletonManager implements SerializableCompatibility { private static final String ATTR_SINGLETON_MANAGER = SingletonManager . class . getName ( ) + \"#instance\" ; public static void install ( ISessionStore sessionStore ) { checkNotInstalled ( sessionStore ) ; sessionStore . setAttribute ( ATTR_SINGLETON_MANAGER , new SingletonManager ( ) ) ; } public static SingletonManager getInstance ( ISessionStore sessionStore ) { return ( SingletonManager ) sessionStore . getAttribute ( ATTR_SINGLETON_MANAGER ) ; } private final Map < Class , Object > singletons ; private transient SharedInstanceBuffer < Class , Object > typeLocks ; private SingletonManager ( ) { singletons = Collections . synchronizedMap ( new HashMap < Class , Object > ( ) ) ; initialize ( ) ; } private void initialize ( ) { typeLocks", "gt": "= new SharedInstanceBuffer < Class , Object > ( ) ;", "prediction": "= new SharedInstanceBuffer < Class , Object > ( ) ;\n", "label": 1}
{"id": 10095, "input": "<s> package com . deliciousdroid . client ; import java . io . IOException ; import org . apache . http . HttpException ; import org . apache . http . HttpHost ; import org . apache . http . HttpRequest ; import org . apache . http . HttpRequestInterceptor ; import org . apache . http . auth . AuthScope ; import org . apache . http . auth . AuthState ; import org . apache . http . auth . Credentials ; import org . apache . http . client . CredentialsProvider ; import org . apache . http . client . protocol . ClientContext ; import org . apache . http . impl . auth . BasicScheme ; import org . apache . http . protocol . ExecutionContext ; import org . apache . http . protocol . HttpContext ; public class PreemptiveAuthInterceptor implements HttpRequestInterceptor { public void process ( final HttpRequest request , final HttpContext context ) throws HttpException , IOException { AuthState authState = ( AuthState ) context . getAttribute ( ClientContext . TARGET_AUTH_STATE ) ; CredentialsProvider credsProvider = ( CredentialsProvider ) context . getAttribute ( ClientContext . CREDS_PROVIDER ) ; HttpHost targetHost = ( HttpHost ) context . getAttribute ( ExecutionContext . HTTP_TARGET_HOST ) ; if ( authState . getAuthScheme ( ) == null ) { AuthScope authScope = new AuthScope ( targetHost . getHostName ( ) , targetHost . getPort ( ) ) ; Credentials creds = credsProvider . getCredentials ( authScope ) ; if ( creds != null ) {", "gt": "authState . setAuthScheme ( new BasicScheme ( ) ) ;", "prediction": "context . setAttribute ( ClientContext . TARGET_AUTH_SCOPE , authScope ) ;\n", "label": 0}
{"id": 13127, "input": "<s> package org . apache . lucene . analysis . tokenattributes ; import org . apache . lucene . util . Attribute ; public interface TypeAttribute extends Attribute { public String type ( ) ; public void setType", "gt": "( String type ) ;", "prediction": "( String type ) ;\n", "label": 1}
{"id": 8604, "input": "<s> public class UnderscoreLiterals { public static void main ( String ... args ) throws Exception { new UnderscoreLiterals ( ) . run ( ) ; } public void run ( ) throws Exception { test ( 1 , 1 ) ; test ( 10 , 10 ) ; test ( 1_0 , 10 ) ; test ( 1__0 , 10 ) ; test ( 1_0_0 , 100 ) ; test ( 1__0__0 , 100 ) ; test ( 123_456_789 , 123456789 ) ; test ( 1l , 1l ) ; test ( 10l , 10l ) ; test ( 1_0l , 10l ) ; test ( 1__0l , 10l ) ; test ( 1_0_0l , 100l ) ; test ( 1__0__0l , 100l ) ; test ( 123_456_789l , 123456789l ) ; test ( .1f , .1f ) ; test ( .10f , .10f ) ; test ( .1_0f , .10f ) ; test ( .1__0f , .10f ) ; test ( .1_0_0f , .100f ) ; test ( .1__0__0f , .100f ) ; test ( 1e1 , 1e1 ) ; test ( 1e10 , 1e10 ) ; test ( 1e1_0 , 1e10 ) ; test ( 1e1__0 , 1e10 ) ; test ( 1e1_0_0 , 1e100 ) ; test ( 1e1__0__0 , 1e100 ) ; test ( .123_456_789f , .123456789f ) ; test ( 0.1f , 0.1f ) ; test ( 0.10f , 0.10f ) ; test ( 0.1_0f , 0.10f ) ; test ( 0.1__0f , 0.10f ) ; test ( 0.1_0_0f , 0.100f ) ; test ( 0.1__0__0f , 0.100f ) ; test ( 0.123_456_789f , 0.123456789f ) ; test ( 1_1.1f , 1_1.1f ) ; test ( 1_1.10f , 1_1.10f ) ; test ( 1_1.1_0f , 1_1.10f ) ; test ( 1_1.1__0f , 1_1.10f ) ; test ( 1_1.1_0_0f , 1_1.100f ) ; test ( 1_1.1__0__0f , 1_1.100f ) ; test ( 1_1.123_456_789f , 1_1.123456789f ) ; test ( .1d , .1d ) ; test ( .10d , .10d ) ; test ( .1_0d , .10d ) ; test ( .1__0d , .10d ) ; test ( .1_0_0d , .100d ) ; test ( .1__0__0d , .100d ) ; test ( 1e1 , 1e1 ) ; test ( 1e10 , 1e10 ) ; test ( 1e1_0 , 1e10 ) ; test ( 1e1__0 , 1e10 ) ; test ( 1e1_0_0 , 1e100 ) ; test ( 1e1__0__0 , 1e100 ) ; test ( .123_456_789d , .123456789d ) ; test ( 0.1d , 0.1d ) ; test ( 0.10d , 0.10d ) ; test ( 0.1_0d , 0.10d ) ; test ( 0.1__0d , 0.10d ) ; test ( 0.1_0_0d , 0.100d ) ; test ( 0.1__0__0d , 0.100d ) ; test ( 0.123_456_789d , 0.123456789d ) ; test ( 1_1.1d , 1_1.1d ) ; test ( 1_1.10d , 1_1.10d ) ; test ( 1_1.1_0d , 1_1.10d ) ; test ( 1_1.1__0d , 1_1.10d ) ; test ( 1_1.1_0_0d , 1_1.100d ) ; test ( 1_1.1__0__0d , 1_1.100d ) ; test ( 1_1.123_456_789d , 1_1.123456789d ) ; test ( 0b1 , 1 ) ; test ( 0b10 , 2 ) ; test ( 0b1_0 , 2 ) ; test ( 0b1__0 , 2 ) ; test ( 0b1_0_0 , 4 ) ; test ( 0b1__0__0 , 4 ) ; test ( 0b0001_0010_0011 , 0x123 ) ; test ( 01 , 1 ) ; test ( 010 , 8 ) ; test ( 01_0 , 8 ) ; test ( 01__0 , 8 ) ; test ( 01_0_0 , 64 ) ; test ( 01__0__0 , 64 ) ; test ( 0_1 , 1 ) ; test ( 0_10 , 8 ) ; test ( 0_1_0 , 8 ) ; test ( 0_1__0 , 8 ) ; test ( 0_1_0_0 , 64 ) ; test ( 0_1__0__0 , 64 ) ; test ( 0_001_002_003 , 01002003 ) ; test ( 0x1 , 1 ) ; test ( 0x10 , 16 ) ;", "gt": "test ( 0x1_0 , 16 ) ;", "prediction": "test ( 0x10__0 , 16 ) ;\n", "label": 0}
{"id": 13142, "input": "<s> package br . org . archimedes . io . svg . elements ; import java . io . IOException ; import java . io . OutputStream ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . model . Rectangle ; public class CircleExporter implements ElementExporter < Circle > { public void exportElement ( Circle circle , Object outputObject ) throws IOException { OutputStream output = ( OutputStream ) outputObject ; StringBuilder lineTag = new StringBuilder ( ) ; int x = ( int ) circle . getCenter ( ) . getX ( ) ; int y = ( int ) circle . getCenter ( ) . getY ( ) ; int", "gt": "r = ( int ) circle . getRadius ( ) ;", "prediction": "width = ( int ) circle . getWidth ( ) ;\n", "label": 1}
{"id": 5156, "input": "<s> import java . util . * ; import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . * ; public class TestProcessorFactory implements AnnotationProcessorFactory { public Collection < String > supportedOptions ( ) { return new ArrayList < String > ( ) ; } public Collection < String > supportedAnnotationTypes ( ) { ArrayList < String > res = new ArrayList < String > ( ) ; res . add ( \"Test\" ) ; res . add ( \"Ignore\" ) ; return res ; } public AnnotationProcessor getProcessorFor ( Set < AnnotationTypeDeclaration > as , AnnotationProcessorEnvironment env ) { Tester tester = Tester . activeTester ; try { ClassDeclaration testerDecl = null ; for ( TypeDeclaration decl : env . getSpecifiedTypeDeclarations ( ) ) { if ( decl . getQualifiedName ( ) . equals ( tester . getClass ( ) . getName ( ) ) ) { testerDecl = ( ClassDeclaration ) decl ; break ; } } tester . thisClassDecl = testerDecl ;", "gt": "tester . env = env ;", "prediction": "}\n", "label": 0}
{"id": 13144, "input": "<s> package org . fuzzydb . server . internal . pager ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FilenameFilter ; import java . io . IOException ; import java . util . Arrays ; import java . util . BitSet ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . io . core . ArchInStream ; import org . fuzzydb . io . core . ArchOutStream ; import org . fuzzydb . server . internal . server . CurrentTransactionHolder ; import org . fuzzydb . server . internal . server . DatabaseVersionState ; import org . fuzzydb . server . internal . server . ServerStore ; import org . fuzzydb . server . internal . server . TransactionControl ; import org . fuzzydb . server . internal . server . WorkerThread ; import org . fuzzydb . util . MeteredOutputStream ; import org . slf4j . Logger ; public class Page < T > implements FilenameFilter { @ SuppressWarnings ( \"unused\" ) static private final Logger log = LogFactory . getLogger ( Page . class ) ; @ SuppressWarnings ( \"serial\" ) public static class PagePurgedException extends Exception { } static private final byte eightZeros [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; private final String path ; private final String filterString ; private byte [ ] pageData = null ; private final Element < T > [ ] elements ; private final ExclusiveWrite exclusiveWrite ; private boolean purged = false ; private final long offset ; private final int length ; private long latestDbVersion = - 1L ; private boolean dirty = false ; private final AccessHistory accessedForRead = new AccessHistory ( ) ; private final AccessHistory accessedForWrite = new AccessHistory ( ) ; private final ServerStore store ; private final long loadedTime = System . currentTimeMillis ( ) ; private static final long timeBias = 2000 ; static private final char VERSION_SEPARATOR = '_' ; private BitSet modifiedFlags ; private boolean disableDelete ; private DatabaseVersionState vp ; public static < P > Page < P > blankPage ( int length , String path , PagerContext context , DatabaseVersionState vp , long offset ) { return new Page < P > ( length , path , context , vp , offset ) ; } @ SuppressWarnings ( \"unchecked\" ) private Page ( int length , String path , PagerContext context , DatabaseVersionState vp , long offset ) { this . length = length ; this . path = path ; this . vp = vp ; this . elements = new Element [ length ] ; exclusiveWrite = new ExclusiveWrite ( ) ; this . offset = offset ; this . filterString = path . substring ( path . lastIndexOf ( File . separatorChar ) + 1 ) + VERSION_SEPARATOR ; this . store = context . getStore ( ) ; this . modifiedFlags = new BitSet ( length ) ; this . disableDelete = path . contains ( \"@\" ) && ! path . contains ( \"@Leaves\" ) ; } public float getCostBias ( ) { long elapsedTime = System . currentTimeMillis ( ) - loadedTime ; if ( elapsedTime > timeBias ) return 0 ; return 1.0f - ( ( float ) elapsedTime / ( float ) timeBias ) ; } private long getVersionFromFilename ( String filename ) { String version = filename . substring ( filename . lastIndexOf ( '_' ) + 1 ) ; return Long . parseLong ( version ) ; } public boolean load ( ) { assert ( pageData == null ) ; WorkerThread . beginIO ( ) ; try { File dir = getParentDir ( ) ; File files [ ] = dir . listFiles ( this ) ; if ( files == null || files . length == 0 ) { return false ; } File bestFile = files [ 0 ] ; long bestVersion = getVersionFromFilename ( files [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < files . length ; i ++ ) { long version = getVersionFromFilename ( files", "gt": "[ i ] . getName ( ) ) ;", "prediction": "[ i ] . getName ( ) ) ;\n", "label": 1}
{"id": 6113, "input": "<s> package org . gk . engine . client . event . attrib ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . Layout ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . layout . FitLayout ; public class ObjAttribute implements IAttribute { @ Override public Object getAttributeValue ( Component com ) { com . removeFromParent ( ) ; return com ; } @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof LayoutContainer ) { LayoutContainer c = ( LayoutContainer ) com ; Layout layout = c . getLayout ( ) ;", "gt": "if ( layout instanceof FitLayout )", "prediction": "if ( layout != null )\n", "label": 0}
{"id": 13147, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . ui . IWorkbenchPart ; public class PartPluginAction extends PluginAction { public PartPluginAction ( IConfigurationElement actionElement , String id , int style ) { super ( actionElement , id , style ) ; } protected void registerSelectionListener ( IWorkbenchPart aPart ) { ISelectionProvider selectionProvider = aPart . getSite ( ) . getSelectionProvider ( ) ; if ( selectionProvider != null ) { selectionProvider . addSelectionChangedListener ( this ) ; selectionChanged ( selectionProvider . getSelection ( ) ) ; } } protected void unregisterSelectionListener ( IWorkbenchPart aPart ) { ISelectionProvider selectionProvider = aPart . getSite", "gt": "( ) . getSelectionProvider ( ) ;", "prediction": "( ) . getSelectionProvider ( ) ;\n", "label": 1}
{"id": 6528, "input": "<s> package pkg2 ; public class ClassUseTest1 < T extends Foo & Foo2 > { public ParamTest < Foo > field ; public < T extends Foo & Foo2 >", "gt": "T method ( T t )", "prediction": "ParamTest < Foo2 > field2 ;\n", "label": 0}
{"id": 13149, "input": "<s> package org . eclipse . rap . rwt . osgi . internal ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import java . io . File ; import java . net . URL ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . osgi . service . http . HttpContext ; public class HttpContextWrapper_Test extends TestCase { private HttpContext httpContext ; private HttpContextWrapper contextWrapper ; private File directory ; @ Override protected void setUp ( ) { httpContext = mock ( HttpContext . class ) ; contextWrapper = new HttpContextWrapper ( httpContext ) ; directory = new File ( Fixture . TEMP_DIR , \"directory\" ) ; directory . mkdirs ( ) ; } @ Override protected void tearDown ( ) { Fixture . delete ( directory ) ; } public void testGetResource ( ) throws Exception { File file = new File ( directory , \"test.txt\" ) ; file . createNewFile ( ) ; String fileName = file . getPath ( ) ; URL result = contextWrapper . getResource ( fileName ) ; assertEquals ( file , new File ( result .", "gt": "toURI ( ) ) ) ;", "prediction": "getPath ( ) ) ) ;\n", "label": 1}
{"id": 9983, "input": "<s> package com . pagosoft . plaf . themes ; import com . pagosoft . plaf . PgsTheme ; import javax . swing . plaf . ColorUIResource ; import java . awt . SystemColor ; public class NativeColorTheme extends PgsTheme { public NativeColorTheme ( ) { super ( \"Native Colors\" ) ; setPrimary1 ( new ColorUIResource ( SystemColor . activeCaption ) ) ; setPrimary2 ( new ColorUIResource ( SystemColor . textHighlight ) ) ; setPrimary3 ( new ColorUIResource ( SystemColor . inactiveCaption ) ) ; setSecondary1 ( new ColorUIResource ( SystemColor . controlDkShadow ) ) ; setSecondary2 ( new ColorUIResource ( SystemColor . controlShadow ) ) ; setSecondary3 ( new ColorUIResource ( SystemColor . control ) ) ; setWhite (", "gt": "new ColorUIResource ( SystemColor . text ) ) ;", "prediction": "true ) ;\n", "label": 0}
{"id": 13152, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . search . spans . SpanNotQuery ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . xmlparser . DOMUtils ; import org . apache . lucene . xmlparser . ParserException ; import org . w3c . dom . Element ; public class SpanNotBuilder extends SpanBuilderBase { SpanQueryBuilder factory ; public SpanNotBuilder ( SpanQueryBuilder factory ) { super ( ) ; this . factory = factory ; } public SpanQuery getSpanQuery ( Element e ) throws ParserException { Element includeElem = DOMUtils . getChildByTagOrFail ( e , \"Include\" ) ; includeElem = DOMUtils . getFirstChildOrFail ( includeElem ) ; Element excludeElem = DOMUtils . getChildByTagOrFail ( e , \"Exclude\" ) ; excludeElem = DOMUtils . getFirstChildOrFail ( excludeElem ) ; SpanQuery include = factory . getSpanQuery ( includeElem ) ; SpanQuery", "gt": "exclude = factory . getSpanQuery ( excludeElem ) ;", "prediction": "exclude = factory . getSpanQuery ( excludeElem ) ;\n", "label": 1}
{"id": 8745, "input": "<s> package com . jcraft . jzlib ; final public class Inflater extends ZStream { static final private int MAX_WBITS = 15 ; static final private int DEF_WBITS = MAX_WBITS ; static final private int Z_NO_FLUSH = 0 ; static final private int Z_PARTIAL_FLUSH = 1 ; static final private int Z_SYNC_FLUSH = 2 ; static final private int Z_FULL_FLUSH = 3 ; static final private int Z_FINISH = 4 ; static final private int MAX_MEM_LEVEL = 9 ; static final private int Z_OK = 0 ; static final private int Z_STREAM_END = 1 ; static final private int Z_NEED_DICT = 2 ; static final private int Z_ERRNO = - 1 ; static final private int Z_STREAM_ERROR = - 2 ; static final private int Z_DATA_ERROR = - 3 ; static final private int Z_MEM_ERROR = - 4 ; static final private int Z_BUF_ERROR = - 5 ; static final private int Z_VERSION_ERROR = - 6 ; public Inflater ( ) { super ( ) ; init ( ) ; } public Inflater ( int w ) throws GZIPException { this ( w , false ) ; } public Inflater ( int w , boolean nowrap ) throws GZIPException { super ( ) ; int ret = init ( w , nowrap ) ; if ( ret != Z_OK ) throw new GZIPException ( ret + \": \" + msg ) ; } private boolean finished = false ; public int init ( ) { return init ( DEF_WBITS ) ; } public int init ( boolean nowrap ) { return init ( DEF_WBITS , nowrap ) ; } public int", "gt": "init ( int w )", "prediction": "init ( boolean nowrap )\n", "label": 0}
{"id": 13154, "input": "<s> package org . eclipse . ui . presentations ; import org . eclipse . swt . graphics . Point ; public interface IPartMenu { public void showMenu", "gt": "( Point location ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2688, "input": "<s> class Y extends W { } class W extends Z { } class Z { void", "gt": "m ( Z z )", "prediction": "clear ( )\n", "label": 0}
{"id": 13159, "input": "<s> package com . google . code . microlog4android . integration . tests . microlog ; import junit . framework . TestCase ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . LoggerFactory ; import com . google . code . microlog4android . appender . LogCatAppender ; import com . google . code . microlog4android . integration . tests . appender . JunitTestAppender ; import com . google . code . microlog4android . integration . tests . slf4j . Slf4jIntegrationTest ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; public class MicrologIntegrationTest extends TestCase { private JunitTestAppender testAppender ; public void setUp ( ) { testAppender = new JunitTestAppender ( ) ; } public void tearDown ( ) { DefaultLoggerRepository . INSTANCE . reset ( ) ; } private void setTestAppenders ( final Logger logger ) { logger . addAppender ( testAppender ) ; logger . addAppender ( new LogCatAppender ( ) ) ; } public void testGetLogger ( ) { Logger stdLogger = LoggerFactory . getLogger ( Slf4jIntegrationTest . class ) ; setTestAppenders ( stdLogger ) ; stdLogger . debug ( \"microlog integration test logging\" ) ; assertEquals ( 1 , testAppender . getLoggerList ( ) . size ( ) ) ; } public void testDefaultLogLevel ( ) { Logger logger = LoggerFactory . getLogger ( Slf4jIntegrationTest . class ) ; assertTrue ( logger . isDebugEnabled ( ) ) ; assertTrue", "gt": "( logger . isInfoEnabled ( ) ) ;", "prediction": "( logger . isInfoEnabled ( ) ) ;\n", "label": 1}
{"id": 8057, "input": "<s> package capture5 ; interface R < T extends R < T > > { } class A implements R < A > { } class B < T > implements R < B < T > > { } class C implements R < C > { } class Recursive { < t > t choose ( t x , t y ) { return x ; } void f ( boolean b1 , boolean b2 , boolean b3 , A a , B < String > b , C c ) { R < ? extends R < ? extends R < ? extends R < ? extends R <", "gt": "? > > > > > r = null ;", "prediction": "? ? ? ? ? ? ? ? ? ? > > > x = a ;\n", "label": 0}
{"id": 13160, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import java . util . Collection ; public abstract class Spans { public abstract boolean next ( ) throws IOException ; public abstract boolean skipTo ( int target ) throws IOException ; public abstract int doc ( ) ; public abstract int start ( ) ; public abstract int end ( ) ; public abstract Collection getPayload ( ) throws IOException ; public", "gt": "abstract boolean isPayloadAvailable ( ) ;", "prediction": "abstract int length ( ) ;\n", "label": 1}
{"id": 3497, "input": "<s> package dao ; import java . util . Date ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . Query ; import domain . CourseOccasion ; public class CourseOccasionDao { static public List < CourseOccasion > getCourseOccasionByCodeAndPeriod ( Date startTime , Date endTime , String courseCode ) { EntityManager em = SingletonEntityManager . getInstance ( ) ; Query query = em . createNamedQuery ( \"getCourseOccasionByDateAndCourseCode\" ) ; query . setParameter ( \"start\" , startTime ) ; query . setParameter ( \"end\" , endTime ) ; query . setParameter ( \"code\" , courseCode ) ; return CastList . castList ( CourseOccasion . class , query", "gt": ". getResultList ( ) ) ;", "prediction": ". getResultList ( ) ) ;\n", "label": 0}
{"id": 13171, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class Write10 extends AbstractTransferCDB { public static final int OPERATION_CODE = 0x2A ; private boolean DPO ; private boolean FUA ; private boolean FUA_NV ; private int groupNumber ; public Write10 ( ) { this ( OPERATION_CODE ) ; } protected Write10 ( int operationCode ) { super ( operationCode ) ; } public Write10 ( int groupNumber , boolean dpo , boolean fua , boolean fua_nv , boolean linked , boolean normalACA , long logicalBlockAddress , long transferLength ) { this ( OPERATION_CODE , groupNumber , dpo , fua , fua_nv , linked , normalACA , logicalBlockAddress , transferLength ) ; } protected Write10 ( int operationCode , int groupNumber , boolean dpo , boolean fua , boolean fua_nv , boolean linked , boolean normalACA , long logicalBlockAddress , long transferLength ) { super ( operationCode , linked , normalACA , logicalBlockAddress , transferLength ) ; this . groupNumber = groupNumber ; this . DPO = dpo ; this . FUA = fua ; this . FUA_NV = fua_nv ; } public Write10 ( long logicalBlockAddress , long transferLength ) { this ( 0 , false , false , false , false , false , logicalBlockAddress , transferLength ) ; } protected void decodeByte1 ( int unsignedByte ) throws IllegalArgumentException { if ( ( ( unsignedByte > > > 5 ) & 0x07 ) != 0 ) { throw new IllegalArgumentException ( \"Write protection information is not supported\" ) ; } this . DPO = ( ( unsignedByte > > > 4 ) & 0x01 ) == 1 ; this . FUA = ( ( unsignedByte > > > 3 ) & 0x01 ) == 1 ; this . FUA_NV = ( ( unsignedByte > > > 1 ) & 0x01 ) == 1 ; } protected int encodeByte1 ( ) { int b = 0 ; if ( DPO ) { b |= 0x02 ; } if ( FUA ) { b |= 0x08 ; } if ( FUA_NV ) { b |= 0x10 ; } return b ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int operationCode = in . readUnsignedByte ( ) ; this . decodeByte1 ( in . readUnsignedByte ( ) ) ; long mss = in . readUnsignedShort ( ) ; long lss = in . readUnsignedShort ( ) ; setLogicalBlockAddress ( ( mss << 16 ) | lss ) ; this . groupNumber = in . readUnsignedByte ( ) & 0x1F ; setTransferLength ( in . readUnsignedShort ( ) ) ; super . setControl ( in . readUnsignedByte ( ) ) ; if ( operationCode != OPERATION_CODE ) { throw new IOException ( \"Invalid operation code: \" + Integer . toHexString ( operationCode ) ) ; } } public byte [ ] encode ( ) { ByteArrayOutputStream cdb = new ByteArrayOutputStream ( this . size ( ) ) ; DataOutputStream out = new DataOutputStream ( cdb ) ; try { out . writeByte ( OPERATION_CODE ) ; out . writeByte ( this . encodeByte1 ( ) ) ; out . writeInt ( ( int ) getLogicalBlockAddress ( ) ) ; out . writeByte ( this . groupNumber & 0x1F ) ; out . writeShort ( ( int ) getTransferLength ( ) ) ; out . writeByte ( super . getControl ( ) ) ; return cdb", "gt": ". toByteArray ( ) ;", "prediction": ". toByteArray ( ) ;\n", "label": 1}
{"id": 2385, "input": "<s> package org . ofbiz . service . calendar ; @ SuppressWarnings ( \"serial\" ) public class RecurrenceRuleException extends org . ofbiz . base . util . GeneralException { public RecurrenceRuleException ( ) { super ( ) ; } public RecurrenceRuleException ( String msg ) { super ( msg ) ; } public", "gt": "RecurrenceRuleException ( String msg , Throwable nested )", "prediction": "RecurrenceRuleException ( String msg , Exception e )\n", "label": 0}
{"id": 13176, "input": "<s> package com . emf4sw . owl . examples ; import java . io . IOException ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . resource . impl . ResourceSetImpl ; import com . emf4sw . owl . OWLClass ; import com . emf4sw . owl . Ontology ; import com . emf4sw . owl . resource . impl . OWLXMLResourceFactory ; public class ReadOwlFile { public static void main ( String [ ] args ) throws IOException { Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"owl\" , new OWLXMLResourceFactory ( ) ) ; ResourceSet resourceSet = new ResourceSetImpl ( ) ; Resource onto = resourceSet . createResource ( URI . createURI ( \"src/software.owl\" ) ) ; onto . load ( null ) ; Ontology ontology = ( Ontology ) onto", "gt": ". getContents ( ) . get ( 0 ) ;", "prediction": ". getResource ( Ontology . class ) ;\n", "label": 1}
{"id": 8309, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class UNKRecord extends Record { private static final long serialVersionUID = - 4193583311594626915L ; private byte [ ] data ; UNKRecord ( ) { } Record getObject ( ) { return new UNKRecord ( ) ; } void rrFromWire ( DNSInput in ) throws IOException { data = in . readByteArray ( ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { throw st . exception ( \"invalid unknown RR encoding\" ) ; } String rrToString ( ) { return unknownToString ( data ) ; } public byte [ ] getData ( ) { return data ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) {", "gt": "out . writeByteArray ( data ) ;", "prediction": "throw new UnsupportedOperationException ( ) ;\n", "label": 0}
{"id": 13180, "input": "<s> package com . cloudera . sqoop ; import java . io . IOException ; import java . util . ArrayList ; import org . apache . commons . cli . ParseException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . IOUtils ; import org . apache . hadoop . io . SequenceFile ; import org . apache . hadoop . util . ReflectionUtils ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . orm . CompilationManager ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . HsqldbTestServer ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; import com . cloudera . sqoop . testutil . SeqFileReader ; import com . cloudera . sqoop . tool . ImportTool ; import com . cloudera . sqoop . util . ClassLoaderStack ; public class TestQuery extends ImportJobTestCase { protected String [ ] getArgv ( boolean includeHadoopFlags , String query , String targetDir , boolean allowParallel ) { ArrayList < String > args = new ArrayList < String > ( ) ; if ( includeHadoopFlags ) { CommonArgs . addHadoopFlags ( args ) ; } args . add ( \"--query\" ) ; args . add ( query ) ; args . add ( \"--split-by\" ) ; args . add ( \"INTFIELD1\" ) ; args . add ( \"--connect\" ) ; args . add ( HsqldbTestServer . getUrl ( ) ) ; args . add ( \"--as-sequencefile\" ) ; args . add ( \"--target-dir\" ) ; args . add ( targetDir ) ; args . add ( \"--class-name\" ) ; args . add ( getTableName ( ) ) ; if ( allowParallel ) { args . add ( \"--num-mappers\" ) ; args . add ( \"2\" ) ; } else { args . add ( \"--num-mappers\" ) ; args . add ( \"1\" ) ; } return args . toArray ( new String [ 0 ] ) ; } protected String getTableName ( ) { return HsqldbTestServer . getTableName ( ) ; } private int getFirstInt ( String str ) { String [ ] parts = str . split ( \",\" ) ; return Integer . parseInt ( parts [ 0 ] ) ; } public void runQueryTest ( String query , String firstValStr , int numExpectedResults , int expectedSum , String targetDir ) throws IOException { ClassLoader prevClassLoader = null ; SequenceFile . Reader reader = null ; String [ ] argv = getArgv ( true , query , targetDir , false ) ; runImport ( argv ) ; try { SqoopOptions opts = new ImportTool ( ) . parseArguments ( getArgv ( false , query , targetDir , false ) , null , null , true ) ; CompilationManager compileMgr = new CompilationManager ( opts ) ; String jarFileName = compileMgr . getJarFilename ( ) ; prevClassLoader = ClassLoaderStack . addJarFile ( jarFileName , getTableName ( ) ) ; reader = SeqFileReader . getSeqFileReader ( getDataFilePath ( ) . toString ( ) ) ; Configuration conf = new Configuration ( ) ; Object key = ReflectionUtils . newInstance ( reader . getKeyClass ( ) , conf ) ; Object val = ReflectionUtils . newInstance ( reader . getValueClass ( ) , conf ) ; if ( reader . next ( key ) == null ) { fail ( \"Empty SequenceFile during import\" ) ; } reader . getCurrentValue ( val ) ; assertEquals ( \"Invalid ordering within sorted SeqFile\" , firstValStr , val . toString ( ) ) ; int curSum = getFirstInt ( val . toString ( ) ) ; int totalResults = 1 ; while ( reader . next ( key ) != null ) { reader . getCurrentValue ( val ) ; curSum += getFirstInt ( val . toString ( ) ) ; totalResults ++ ; } assertEquals ( \"Total sum of first db column mismatch\" , expectedSum , curSum ) ; assertEquals ( \"Incorrect number of results for query\" , numExpectedResults , totalResults ) ; } catch ( InvalidOptionsException ioe ) { fail ( ioe . toString ( ) ) ; } catch ( ParseException pe ) { fail ( pe . toString ( ) ) ; } finally { IOUtils .", "gt": "closeStream ( reader ) ;", "prediction": "closeStream ( reader ) ;\n", "label": 1}
{"id": 10094, "input": "<s> package com . sun . tools . javac . util ; public class Names { public static final Context . Key < Names > namesKey = new Context . Key < Names > ( ) ; public static Names instance ( Context context ) { Names instance = context . get ( namesKey ) ; if ( instance == null ) { instance = new Names ( context ) ; context . put ( namesKey , instance ) ; } return instance ; } public final Name slash ; public final Name hyphen ; public final Name T ; public final Name slashequals ; public final Name deprecated ; public final Name init ; public final Name clinit ; public final Name error ; public final Name any ; public final Name empty ; public final Name one ; public final Name period ; public final Name comma ; public final Name semicolon ; public final Name asterisk ; public final Name _this ; public final Name _super ; public final Name _default ; public final Name _class ; public final Name java_lang ; public final Name java_lang_Object ; public final Name java_lang_Class ; public final Name java_lang_Cloneable ; public final Name java_io_Serializable ; public final Name serialVersionUID ; public final Name java_lang_Enum ; public final Name java_lang_invoke_MethodHandle ; public final Name package_info ; public final Name ConstantValue ; public final Name LineNumberTable ; public final Name LocalVariableTable ; public final Name LocalVariableTypeTable ; public final Name CharacterRangeTable ; public final Name StackMap ; public final Name StackMapTable ; public final Name SourceID ; public final Name CompilationID ; public final Name Code ; public final Name Exceptions ; public final Name SourceFile ; public final Name InnerClasses ; public final Name Synthetic ; public final Name Bridge ; public final Name Deprecated ; public final Name Enum ; public final Name _name ; public final Name Signature ; public final Name Varargs ; public final Name Annotation ; public final Name RuntimeVisibleAnnotations ; public final Name RuntimeInvisibleAnnotations ; public final Name RuntimeVisibleTypeAnnotations ; public final Name RuntimeInvisibleTypeAnnotations ; public final Name RuntimeVisibleParameterAnnotations ; public final Name RuntimeInvisibleParameterAnnotations ; public final Name Value ; public final Name EnclosingMethod ; public final Name desiredAssertionStatus ; public final Name append ; public final Name family ; public final Name forName ; public final Name toString ; public final Name length ; public final Name valueOf ; public final Name value ; public final Name getMessage ; public final Name getClass ; public final Name TYPE ; public final Name TYPE_USE ; public final Name TYPE_PARAMETER ; public final Name FIELD ; public final Name METHOD ; public final Name PARAMETER ; public final Name CONSTRUCTOR ; public final Name LOCAL_VARIABLE ; public final Name ANNOTATION_TYPE ; public final Name PACKAGE ; public final Name SOURCE ; public final Name CLASS ; public final Name RUNTIME ; public final Name Array ; public final Name Method ; public final Name Bound ; public final Name clone ; public final Name getComponentType ; public final Name getClassLoader ; public final Name initCause ; public final Name values ; public final Name iterator ; public final Name hasNext ; public final Name next ; public final Name AnnotationDefault ; public final Name ordinal ; public final Name equals ; public final Name hashCode ; public final Name compareTo ; public final Name getDeclaringClass ; public final Name ex ; public final Name finalize ; public final Name java_lang_AutoCloseable ; public final Name close ; public final Name addSuppressed ; public final Name ceylon_language ; public final Name . Table table ; public Names ( Context context ) { Options options = Options . instance ( context ) ; table = createTable ( options ) ; slash = fromString ( \"/\" ) ; hyphen = fromString ( \"-\" ) ; T = fromString ( \"T\" ) ; slashequals = fromString ( \"/=\" ) ; deprecated = fromString ( \"deprecated\" ) ; init = fromString ( \"<init>\" ) ; clinit = fromString ( \"<clinit>\" ) ; error = fromString ( \"<error>\" ) ; any = fromString ( \"<any>\" ) ; empty = fromString ( \"\" ) ; one = fromString ( \"1\" ) ; period = fromString ( \".\" ) ; comma = fromString ( \",\" ) ; semicolon = fromString ( \";\" ) ; asterisk = fromString ( \"*\" ) ; _this = fromString ( \"this\" ) ; _super = fromString ( \"super\" ) ; _default = fromString ( \"default\" ) ; _class = fromString ( \"class\" ) ; java_lang = fromString ( \"java.lang\" ) ; java_lang_Object = fromString ( \"java.lang.Object\" ) ; java_lang_Class = fromString ( \"java.lang.Class\" ) ; java_lang_Cloneable = fromString ( \"java.lang.Cloneable\" ) ; java_io_Serializable = fromString ( \"java.io.Serializable\" ) ; java_lang_Enum = fromString ( \"java.lang.Enum\" ) ; java_lang_invoke_MethodHandle = fromString ( \"java.lang.invoke.MethodHandle\" ) ; package_info = fromString ( \"package-info\" ) ; serialVersionUID = fromString ( \"serialVersionUID\" ) ; ConstantValue = fromString ( \"ConstantValue\" ) ; LineNumberTable = fromString ( \"LineNumberTable\" ) ; LocalVariableTable = fromString ( \"LocalVariableTable\" ) ; LocalVariableTypeTable = fromString ( \"LocalVariableTypeTable\" ) ; CharacterRangeTable = fromString ( \"CharacterRangeTable\" ) ; StackMap = fromString ( \"StackMap\" ) ; StackMapTable = fromString ( \"StackMapTable\" ) ; SourceID = fromString ( \"SourceID\" ) ; CompilationID = fromString ( \"CompilationID\" ) ; Code = fromString ( \"Code\" ) ; Exceptions = fromString ( \"Exceptions\" ) ; SourceFile = fromString ( \"SourceFile\" ) ; InnerClasses = fromString ( \"InnerClasses\" ) ; Synthetic = fromString ( \"Synthetic\" ) ; Bridge = fromString ( \"Bridge\" ) ; Deprecated = fromString ( \"Deprecated\" ) ; Enum = fromString ( \"Enum\" ) ; _name = fromString ( \"name\" ) ; Signature = fromString ( \"Signature\" ) ; Varargs = fromString ( \"Varargs\" ) ; Annotation = fromString ( \"Annotation\" ) ; RuntimeVisibleAnnotations = fromString ( \"RuntimeVisibleAnnotations\" ) ; RuntimeInvisibleAnnotations = fromString ( \"RuntimeInvisibleAnnotations\" ) ; RuntimeVisibleTypeAnnotations = fromString ( \"RuntimeVisibleTypeAnnotations\" ) ; RuntimeInvisibleTypeAnnotations = fromString ( \"RuntimeInvisibleTypeAnnotations\" ) ; RuntimeVisibleParameterAnnotations = fromString ( \"RuntimeVisibleParameterAnnotations\" ) ; RuntimeInvisibleParameterAnnotations = fromString ( \"RuntimeInvisibleParameterAnnotations\" ) ; Value = fromString ( \"Value\" ) ; EnclosingMethod = fromString ( \"EnclosingMethod\" ) ; desiredAssertionStatus = fromString ( \"desiredAssertionStatus\" ) ; append = fromString ( \"append\" ) ; family = fromString ( \"family\" ) ; forName = fromString ( \"forName\" ) ; toString = fromString ( \"toString\" ) ; length = fromString ( \"length\" ) ; valueOf = fromString ( \"valueOf\" ) ; value = fromString ( \"value\" ) ; getMessage = fromString ( \"getMessage\" ) ; getClass = fromString ( \"getClass\" ) ; TYPE = fromString ( \"TYPE\" ) ;", "gt": "TYPE_USE = fromString ( \"TYPE_USE\" ) ;", "prediction": "}\n", "label": 0}
{"id": 13181, "input": "<s> package org . restlet . ext . jaxrs . internal . core ; import java . net . URI ; import java . net . URISyntaxException ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . ws . rs . MatrixParam ; import javax . ws . rs . PathParam ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . Cookie ; import javax . ws . rs . core . EntityTag ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . core . PathSegment ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . Response . ResponseBuilder ; import javax . ws . rs . core . SecurityContext ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriInfo ; import javax . ws . rs . core . Variant ; import org . restlet . Application ; import org . restlet . Request ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . CharacterSet ; import org . restlet . data . Dimension ; import org . restlet . data . Form ; import org . restlet . data . Language ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . data . Tag ; import org . restlet . ext . jaxrs . ExtendedUriBuilder ; import org . restlet . ext . jaxrs . internal . todo . NotYetImplementedException ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . EmptyIterator ; import org . restlet . ext . jaxrs . internal . util . SecurityUtil ; import org . restlet . ext . jaxrs . internal . util . SortedMetadata ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . representation . Representation ; import org . restlet . security . Role ; public class CallContext implements javax . ws . rs . core . Request , HttpHeaders , SecurityContext { private static class MatrixParamEncIter implements Iterator < String > { private Iterator < Map . Entry < String , List < String > > > matrixParamIter ; private final String mpName ; private Iterator < String > mpValueIter ; private String nextMpValue ; private final Iterator < PathSegment > pathSegmentIter ; MatrixParamEncIter ( String mpName , List < PathSegment > pathSegmentsEnc ) { this . pathSegmentIter = pathSegmentsEnc . iterator ( ) ; this . mpName = mpName ; } public boolean hasNext ( ) { if ( this . nextMpValue != null ) { return true ; } while ( ( this . mpValueIter != null ) && ( this . mpValueIter . hasNext ( ) ) ) { this . nextMpValue = this . mpValueIter . next ( ) ; return true ; } while ( ( this . matrixParamIter != null ) && ( matrixParamIter . hasNext ( ) ) ) { final Map . Entry < String , List < String > > entry = matrixParamIter . next ( ) ; if ( entry . getKey ( ) . equals ( this . mpName ) ) { this . mpValueIter = entry . getValue ( ) . iterator ( ) ; return hasNext ( ) ; } } while ( this . pathSegmentIter . hasNext ( ) ) { this . matrixParamIter = this . pathSegmentIter . next ( ) . getMatrixParameters ( ) . entrySet ( ) . iterator ( ) ; return hasNext ( ) ; } return false ; } public String next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } final String nextMpValue = this . nextMpValue ; this . nextMpValue = null ; return nextMpValue ; } public void remove ( ) { throw new UnsupportedOperationException ( \"unmodifiable\" ) ; } } private static final int STATUS_PREC_FAILED = Status . CLIENT_ERROR_PRECONDITION_FAILED . getCode ( ) ; private static final Logger unexpectedLogger = org . restlet . Context . getCurrentLogger ( ) ; private List < Locale > acceptedLanguages ; private List < MediaType > acceptedMediaTypes ; private final SortedMetadata < org . restlet . data . MediaType > accMediaTypes ; private String baseUri ; private Map < String , Cookie > cookies ; private Locale language ; private final LinkedList < Object > matchedResources = new LinkedList < Object > ( ) ; private final LinkedList < String > matchedURIs = new LinkedList < String > ( ) ; private MediaType mediaType ; private MultivaluedMap < String , String > pathParametersDecoded ; private MultivaluedMap < String , String > pathParametersEncoded ; private List < PathSegment > pathSegmentsDecoded = null ; private List < PathSegment > pathSegmentsEncoded = null ; private MultivaluedMap < String , String > queryParametersDecoded ; private MultivaluedMap < String , String > queryParametersEncoded ; private boolean readOnly = false ; private final Reference referenceCut ; private final Reference referenceOriginal ; private final Request request ; private UnmodifiableMultivaluedMap < String , String > requestHeaders ; private final org . restlet . Response response ; public CallContext ( Request request , org . restlet . Response response ) { if ( request == null ) { throw new IllegalArgumentException ( \"The Restlet Request must not be null\" ) ; } if ( response == null ) { throw new IllegalArgumentException ( \"The Restlet Response must not be null\" ) ; } final Reference referenceCut = request . getResourceRef ( ) ; if ( referenceCut == null ) { throw new IllegalArgumentException ( \"The request reference must not be null\" ) ; } if ( referenceCut . getBaseRef ( ) == null ) { throw new IllegalArgumentException ( \"The request reference must contains a baseRef\" ) ; } final Reference referenceOriginal = request . getOriginalRef ( ) ; if ( referenceOriginal == null ) { throw new IllegalArgumentException ( \"The request.originalRef must not be null\" ) ; } final", "gt": "Reference appRootRef = request . getRootRef ( ) ;", "prediction": "Reference referenceFinal = request . getFinalRef ( ) ;\n", "label": 1}
{"id": 1647, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface MonthlyMax extends LimitsAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 13184, "input": "<s> package org . eclipse . swt . accessibility ; import org . eclipse . swt . internal . * ; public class AccessibleTextAttributeEvent extends SWTEventObject { public int offset ; public int start , end ; public String [ ] attributes ; public String result ; static final long serialVersionUID = 7131825608864332802L ; public AccessibleTextAttributeEvent ( Object source ) { super ( source ) ; } public String toString ( ) { return \"AccessibleAttributeEvent {\" + \" offset=\" + offset + \" start=\" + start + \" end=\" + end + \" attributes=\" + toAttributeString ( attributes ) + \" result=\" + result + \"}\" ; } String toAttributeString ( String [ ] attributes ) { if ( attributes == null || attributes . length == 0 ) return \"\" + attributes ; StringBuffer attributeString = new StringBuffer ( ) ; for ( int i = 0 ; i < attributes . length ; i ++ ) { attributeString . append ( attributes [ i ] ) ; attributeString . append ( ( i % 2 == 0 ) ? \":\" : \";\" ) ; } return attributeString", "gt": ". toString ( ) ;", "prediction": ". toString ( ) ;\n", "label": 1}
{"id": 2204, "input": "<s> import java . io . File ; import java . util . * ; import javax . tools . * ; public class T6407066 { public static void main ( String ... args ) throws Exception { String testSrc = System . getProperty ( \"test.src\" , \".\" ) ; String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager jfm = tool . getStandardFileManager ( null , null , null ) ; List < File > path = new ArrayList < File > ( ) ; path . add ( new File ( \"BadDirectory\" ) ) ; path . add ( new File ( testSrc ) ) ; path . add ( new File ( \"BadFile.jar\" ) ) ; jfm . setLocation ( StandardLocation . SOURCE_PATH , path ) ; List < File > path2 = new ArrayList < File > ( ) ; for ( File f : jfm . getLocation ( StandardLocation .", "gt": "SOURCE_PATH ) ) path2 . add ( f ) ;", "prediction": "SOURCE_PATH ) )\n", "label": 0}
{"id": 13188, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . Iterator ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . jface . action . AbstractGroupMarker ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . GroupMarker ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IContributionManager ; import org . eclipse . jface . action . ICoolBarManager ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . internal . provisional . action . IToolBarContributionItem ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . internal . registry . ActionSetRegistry ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . services . IDisposable ; public class PluginActionSetBuilder extends PluginActionBuilder { private PluginActionSet actionSet ; private IWorkbenchWindow window ; private ArrayList adjunctContributions = new ArrayList ( 0 ) ; public static class Binding implements IDisposable { PluginActionSetBuilder builder ; PluginActionSet set ; IWorkbenchWindow window ; IExtensionTracker tracker ; public void dispose ( ) { if ( tracker != null ) { tracker . unregisterObject ( set . getConfigElement ( ) . getDeclaringExtension ( ) , this ) ; tracker = null ; } } } public PluginActionSetBuilder ( ) { } public void buildMenuAndToolBarStructure ( PluginActionSet set , IWorkbenchWindow window ) { this . actionSet = set ; this . window = window ; cache = null ; currentContribution = null ; targetID = null ; targetContributionTag = IWorkbenchRegistryConstants . TAG_ACTION_SET ; readElements ( new IConfigurationElement [ ] { set . getConfigElement ( ) } ) ; if ( cache != null ) { for ( int i = 0 ; i < cache . size ( ) ; i ++ ) { ActionSetContribution contribution = ( ActionSetContribution ) cache . get ( i ) ; contribution . contribute ( actionSet . getBars ( ) , true , true ) ; if ( contribution . isAdjunctContributor ( ) ) { adjunctContributions . add ( contribution ) ; } } } for ( int i = 0 ; i < adjunctContributions . size ( ) ; i ++ ) { ActionSetContribution contribution = ( ActionSetContribution ) adjunctContributions . get ( i ) ; ActionSetActionBars bars = actionSet . getBars ( ) ; for ( int j = 0 ; j < contribution . adjunctActions . size ( ) ; j ++ ) { ActionDescriptor adjunctAction = ( ActionDescriptor ) contribution . adjunctActions . get ( j ) ; contribution . contributeAdjunctCoolbarAction ( adjunctAction , bars ) ; } } registerBinding ( set ) ; } protected ActionDescriptor createActionDescriptor ( IConfigurationElement element ) { boolean pullDownStyle = false ; String style = element . getAttribute ( IWorkbenchRegistryConstants . ATT_STYLE ) ; if ( style != null ) { pullDownStyle = style . equals ( ActionDescriptor . STYLE_PULLDOWN ) ; } else { String pulldown = element . getAttribute ( ActionDescriptor . STYLE_PULLDOWN ) ; pullDownStyle = pulldown != null && pulldown . equals ( \"true\" ) ; } ActionDescriptor desc = null ; if ( pullDownStyle ) { desc = new ActionDescriptor ( element , ActionDescriptor . T_WORKBENCH_PULLDOWN , window ) ; } else { desc = new ActionDescriptor ( element , ActionDescriptor . T_WORKBENCH , window ) ; } WWinPluginAction action = (", "gt": "WWinPluginAction ) desc . getAction ( ) ;", "prediction": "WWinPluginAction ) desc ;\n", "label": 1}
{"id": 4686, "input": "<s> package org . ofbiz . order . task ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . Locale ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . event . EventHandler ; import org . ofbiz . webapp . event . EventHandlerException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; public class TaskEvents { public static final String module = TaskEvents . class . getName ( ) ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static String completeAssignment ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; GenericValue userLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"userLogin\" ) ; Map < String , Object > parameterMap = UtilHttp . getParameterMap ( request ) ; String workEffortId = ( String ) parameterMap . remove ( \"workEffortId\" ) ; String partyId = ( String ) parameterMap . remove ( \"partyId\" ) ; String roleTypeId = ( String ) parameterMap . remove ( \"roleTypeId\" ) ; String fromDateStr = ( String ) parameterMap . remove ( \"fromDate\" ) ; java . sql . Timestamp fromDate = null ; Locale locale = UtilHttp . getLocale ( request ) ; try { fromDate = ( java . sql . Timestamp ) ObjectType . simpleTypeConvert ( fromDateStr , \"java.sql.Timestamp\" , null , null ) ; } catch ( GeneralException e ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , UtilProperties . getMessage ( resource_error , \"OrderInvalidDateFormatForFromDate\" , locale ) ) ; return \"error\" ; } Map < String , Object > result = null ; try { Map < String , ? extends Object > context = UtilMisc . toMap ( \"workEffortId\" , workEffortId , \"partyId\" , partyId , \"roleTypeId\" , roleTypeId , \"fromDate\" , fromDate , \"result\" , parameterMap ,", "gt": "\"userLogin\" , userLogin ) ;", "prediction": "response ) ;\n", "label": 0}
{"id": 13189, "input": "<s> package org . eclipse . jface . internal . util ; import java", "gt": ". io . Serializable ;", "prediction": ". util . ArrayList ;\n", "label": 1}
{"id": 426, "input": "<s> package org . davidsingleton . nnrccar ; import gnu . io . CommPortIdentifier ; import gnu . io . PortInUseException ; import gnu . io . SerialPort ; import gnu . io . SerialPortEvent ; import gnu . io . SerialPortEventListener ; import gnu . io . UnsupportedCommOperationException ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . TooManyListenersException ; public class RxTxSerialWrapper implements SerialWrapper , SerialPortEventListener { private SerialPort port ; private PrintStream ps ; RxTxSerialWrapper ( String portName ) { System . setProperty ( \"gnu.io.rxtx.SerialPorts\" , portName ) ; System . out . println ( \"RxTxSerialWrapper init \" + portName ) ; Enumeration < CommPortIdentifier > ports = CommPortIdentifier . getPortIdentifiers ( ) ; while ( ports . hasMoreElements ( ) ) { CommPortIdentifier id = ports . nextElement ( ) ; System . out . println ( id . getName ( ) ) ; if ( id . getName ( ) . equals ( portName ) ) { try { port = ( SerialPort ) id . open ( \"Driver\" , 1000 ) ; OutputStream os = port . getOutputStream ( ) ; port . setSerialPortParams ( 9600 , SerialPort . DATABITS_8 , SerialPort . STOPBITS_1 , SerialPort . PARITY_NONE ) ; port . notifyOnOutputEmpty ( true ) ; port . addEventListener ( this ) ; ps = new PrintStream ( os ) ; } catch ( PortInUseException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedCommOperationException e ) { e . printStackTrace ( ) ; } catch ( TooManyListenersException e ) { e . printStackTrace ( ) ; } } } } public void print ( char c ) { if ( ps != null ) { ps . print ( c ) ; } } public void close ( ) { ps . flush ( ) ; ps . close ( ) ; port . close ( ) ; } @ Override public void serialEvent ( SerialPortEvent event ) { if ( event . getEventType ( ) == SerialPortEvent . OUTPUT_BUFFER_EMPTY ) { System . out . println", "gt": "( \"Serial write complete\" ) ;", "prediction": "( event . getBuffer ( ) ) ;\n", "label": 0}
{"id": 13190, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; class PngIdatChunk extends PngChunk { static final int HEADER_BYTES_LENGTH = 2 ; static final int ADLER_FIELD_LENGTH = 4 ; static final int HEADER_BYTE1_DATA_OFFSET = DATA_OFFSET + 0 ; static final int HEADER_BYTE2_DATA_OFFSET = DATA_OFFSET + 1 ; static final int ADLER_DATA_OFFSET = DATA_OFFSET + 2 ; PngIdatChunk ( byte headerByte1 , byte headerByte2 , byte [ ] data , int adler ) { super ( data . length + HEADER_BYTES_LENGTH + ADLER_FIELD_LENGTH ) ; setType ( TYPE_IDAT ) ; reference [ HEADER_BYTE1_DATA_OFFSET ] = headerByte1 ; reference [ HEADER_BYTE2_DATA_OFFSET ] = headerByte2 ; System . arraycopy ( data , 0 , reference , DATA_OFFSET , data . length ) ; setInt32 ( ADLER_DATA_OFFSET , adler ) ; setCRC ( computeCRC ( ) ) ; } PngIdatChunk ( byte [ ] reference ) { super ( reference ) ; } int getChunkType ( ) { return CHUNK_IDAT ; } void validate ( PngFileReadState readState , PngIhdrChunk headerChunk ) { if ( ! readState . readIHDR || ( headerChunk . getMustHavePalette ( ) && ! readState . readPLTE ) || readState . readIEND ) { SWT . error ( SWT . ERROR_INVALID_IMAGE ) ; } else { readState", "gt": ". readIDAT = true ;", "prediction": ". readIHDR = true ;\n", "label": 1}
{"id": 4015, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NAPTRRecord extends Record { private static final long serialVersionUID = 5191232392044947002L ; private int order , preference ; private byte [ ] flags , service , regexp ; private Name replacement ; NAPTRRecord ( ) { } Record getObject ( ) { return new NAPTRRecord ( ) ; } public NAPTRRecord ( Name name , int dclass , long ttl , int order , int preference , String flags , String service , String regexp , Name replacement ) { super ( name , Type . NAPTR , dclass , ttl ) ; this . order = checkU16 ( \"order\" , order ) ; this . preference = checkU16 ( \"preference\" , preference ) ; try { this . flags = byteArrayFromString ( flags ) ; this . service = byteArrayFromString ( service ) ; this . regexp = byteArrayFromString ( regexp ) ; } catch ( TextParseException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } this . replacement = checkName ( \"replacement\" , replacement ) ; } void rrFromWire ( DNSInput in ) throws IOException { order = in . readU16 ( ) ; preference = in . readU16 ( ) ; flags = in . readCountedString ( ) ; service = in . readCountedString ( ) ; regexp = in . readCountedString ( ) ; replacement = new Name ( in ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { order = st . getUInt16 ( ) ; preference = st . getUInt16 ( ) ; try { flags = byteArrayFromString ( st . getString ( ) ) ; service = byteArrayFromString ( st . getString ( ) ) ; regexp = byteArrayFromString ( st . getString ( ) ) ; } catch ( TextParseException e ) { throw st . exception", "gt": "( e . getMessage ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13191, "input": "<s> package org . nuxeo . webengine . blogs . models ; import org . nuxeo . theme . models . AbstractModel ; public class BlogPostModel extends AbstractModel { private String title ; private String path ; private String description ; private String content ; private String author ; public BlogPostModel ( String title , String path ) { this . title = title ; this . path = path ; } public BlogPostModel ( String title , String path , String description , String content , String author ) { this ( title , path ) ; this . description = description ; this . content = content ; this . author = author ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getPath ( ) { return path ; } public void setPath ( String path ) { this . path = path ; } public String getAuthor ( ) { return author ; }", "gt": "public void setAuthor ( String author )", "prediction": "public void setAuthor ( String author )\n", "label": 1}
{"id": 3717, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . startup ; import javax . swing . SwingUtilities ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Datum ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . FSK ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Uhrzeit ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Film ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Kino ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Kinosaal ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Vorstellung ; import de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . kasse . KassenWerkzeug ; public class StartupKinoticketverkauf { public static void main ( String [ ] args ) { final Kino kino = erzeugeKinoMitBeispieldaten ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { new KassenWerkzeug ( kino ) ; } } ) ; } private static Kino erzeugeKinoMitBeispieldaten ( ) { final Kinosaal [ ] saele = { new Kinosaal ( \"Saal 1\" , 20 , 25 ) , new Kinosaal ( \"Saal 2\" , 16 , 20 ) , new Kinosaal ( \"Saal 3\" , 10 , 16 ) } ; Film [ ] filme = { new Film ( \"Pirates of the Caribbean - Fremde Gezeiten\" , 136 , FSK . FSK12 , true ) , new Film ( \"Fast & Furious Five\" , 130 , FSK . FSK12 , true ) , new Film ( \"Rio\" , 96 , FSK . FSK0 , false ) , new Film ( \"Wasser f\u00fcr die Elefanten\" , 120 , FSK . FSK12 , false ) , new Film ( \"Thor\" , 115 , FSK . FSK12 , false ) } ; Uhrzeit nachmittag = new Uhrzeit ( 17 , 30 ) ; Uhrzeit abend = new Uhrzeit ( 20 , 0 ) ; Uhrzeit spaet = new Uhrzeit ( 22 , 30 ) ; Uhrzeit nacht = new Uhrzeit ( 1 , 0 ) ; Datum d1 = Datum . heute ( ) ; Datum d2 = d1 . naechsterTag ( ) ; Datum d3 = d2 . naechsterTag ( ) ; final Vorstellung [ ] vorstellungen = { new Vorstellung ( saele [ 0 ] , filme [ 2 ] , nachmittag , abend , d1 , 500 ) , new Vorstellung ( saele [ 0 ] , filme [ 0 ] , abend , spaet , d1 , 700 ) , new Vorstellung ( saele [ 0 ] , filme [ 0 ] , spaet , nacht , d1 , 700 ) , new Vorstellung ( saele [ 1 ] , filme [ 3 ] , nachmittag , abend , d1 , 900 ) , new Vorstellung ( saele [ 1 ] , filme [ 1 ] , spaet , nacht , d1 , 800 ) , new Vorstellung ( saele [ 2 ] , filme [ 3 ] , abend , spaet , d1 , 1000 ) , new Vorstellung ( saele [ 2 ] , filme [ 4 ] , spaet , nacht , d1 , 900 ) , new Vorstellung ( saele [ 0 ] , filme [ 0 ] , abend , spaet , d2 , 500 ) , new Vorstellung ( saele [ 0 ] , filme [ 0 ] , spaet , nacht , d2 , 700 ) , new Vorstellung ( saele [ 1 ] , filme [ 2 ] , nachmittag , abend , d2 , 900 ) , new Vorstellung ( saele [ 1 ] , filme [ 4 ] , abend , nacht , d2 , 800 ) , new Vorstellung ( saele [ 2 ] , filme [ 3 ] , nachmittag , abend , d2 , 1000 ) , new Vorstellung ( saele [ 2 ] , filme [ 1 ] , spaet , nacht , d2 , 900 ) , new Vorstellung ( saele [ 0 ] , filme [ 1 ] , abend , spaet , d3 , 500 ) , new Vorstellung ( saele [ 0 ] , filme [ 1 ] , spaet , nacht , d3 , 700 ) , new Vorstellung ( saele [ 1 ] , filme [ 2 ] , nachmittag , abend , d3 , 900 ) , new Vorstellung ( saele [ 1 ] , filme [ 0 ] , abend , nacht , d3 , 800 ) , new Vorstellung ( saele [ 2 ] , filme [ 3 ] , abend , spaet , d3 , 1000 ) , new Vorstellung ( saele [ 2 ] , filme [ 4 ] , spaet , nacht ,", "gt": "d3 , 900 ) }", "prediction": "d3 , 700 ) }\n", "label": 0}
{"id": 13195, "input": "<s> package org . fuzzydb . attrs . string ; import java . util . TreeSet ; import org . fuzzydb . attrs . internal . BranchConstraint ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; public class StringConstraint extends BranchConstraint { private static final long serialVersionUID = 1L ; private boolean delimited = false ; private char delimiter = ' ' ; private TreeSet < String > values = new TreeSet < String > ( ) ; public TreeSet < String > getValues ( ) { return values ; } @ Override public boolean consistent ( IAttribute attribute ) { if ( attribute == null ) { return isIncludesNotSpecified ( ) ; } return true ; } public StringConstraint ( int attrId , StringValue value ) { super ( attrId ) ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringMultiValue value ) { super ( attrId ) ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringValue value , char delimter ) { super ( attrId ) ; this . delimited = true ; this . delimiter = delimter ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringMultiValue value , char delimter ) { super ( attrId ) ; this . delimited = true ; this . delimiter = delimter ; expandNonNull ( value ) ; } public StringConstraint ( StringConstraint clonee ) { super ( clonee ) ; delimited = clonee . delimited ; delimiter = clonee . delimiter ; values . addAll ( clonee . values ) ; } @ Override protected boolean expandNonNull ( IAttribute value ) { if ( ! delimited ) { return true ; } if ( value instanceof StringValue ) { return expand ( ( ( StringValue ) value ) . getValue ( ) ) ; } else { StringMultiValue val = ( StringMultiValue ) value ; boolean result = false ; for ( String str : val . getValue ( ) ) { if ( expand ( str ) == true ) { result = true ; } } return result ; } } private boolean expand ( String value ) { String start = value . split ( String . valueOf ( delimiter ) , 2 ) [ 0 ] ; if ( ! values . contains ( start ) ) { values . add ( start ) ; return true ; } return false ; } @ Override public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof StringConstraint ) ) { return false ; } StringConstraint val = ( StringConstraint ) rhs ; assert ( getAttrId ( ) == val . getAttrId", "gt": "( ) && super . equals ( val ) ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 6726, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . Map ; import org . gk . ui . client . com . tree . dir . gkTreeDirPanelIC ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . Style . LayoutRegion ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . ContentPanel ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . layout . BorderLayout ; import com . extjs . gxt . ui . client . widget . layout . BorderLayoutData ; public class CollapseAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof ContentPanel ) { boolean isCollapse = Boolean . parseBoolean ( value + \"\" ) ; ContentPanel cp = ( ContentPanel ) com ; Object layoutData = cp . getData ( \"layoutData\" ) ; ContentPanel collpasePanel = cp . getData ( \"collapse\" ) ; if ( layoutData instanceof BorderLayoutData ) { BorderLayoutData bld = ( BorderLayoutData ) layoutData ; if ( bld . getRegion ( ) . equals ( LayoutRegion . CENTER ) ) { cp . setExpanded ( ! isCollapse ) ; } else { if ( isCollapse ) { if ( cp . getParent ( ) == null ) { return ; } LayoutContainer parent = ( LayoutContainer ) cp . getParent ( ) ; BorderLayout parentLayout = ( BorderLayout ) parent . getLayout ( ) ; parentLayout . collapse ( bld . getRegion ( ) ) ; } else { if ( collpasePanel == null || collpasePanel . getParent ( ) == null ) { return ; } bld = ( BorderLayoutData ) collpasePanel . getData ( \"layoutData\" ) ; LayoutContainer parent = ( LayoutContainer ) collpasePanel . getParent ( ) ; BorderLayout parentLayout", "gt": "= ( BorderLayout ) parent . getLayout ( ) ;", "prediction": "= ( BorderLayout ) parent . getLayout ( ) ;\n", "label": 0}
{"id": 13198, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentRef ; public class DocRefToDocModel implements TypeAdapter { public Object getAdaptedValue ( OperationContext ctx , Object objectToAdapt ) throws TypeAdaptException { DocumentRef ref", "gt": "= ( DocumentRef ) objectToAdapt ;", "prediction": "= ( DocumentRef ) objectToAdapt ;\n", "label": 1}
{"id": 6961, "input": "<s> import java . io . Serializable ; class Serial implements Serializable { static class Inner implements Serializable { } @ SuppressWarnings ( \"serial\" ) void m ( ) { class Inner implements Serializable { } } } @ SuppressWarnings ( \"serial\" ) class Serial1 implements Serializable { static class Inner implements Serializable { } } class Serial2 { @ SuppressWarnings ( \"serial\" ) static class Inner implements Serializable { } @", "gt": "SuppressWarnings ( \"serial\" ) void m ( )", "prediction": "SuppressWarnings ( \"serial\" ) static class Serial3 implements Serializable\n", "label": 0}
{"id": 13199, "input": "<s> package org . nuxeo . ecm . automation . core . operations . management ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . impl . blob . ByteArrayBlob ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . management . counters . CounterHistoryStack ; import org . nuxeo . runtime . management . counters . CounterManager ; @ Operation ( id = GetCounters . ID , category = Constants . CAT_SERVICES , label = \"Retrieve counters values\" , description = \"Retrieve data collected by one or more Counters\" ) public class GetCounters { public static final String ID = \"Counters.GET\" ; @ Context protected OperationContext ctx ; @ Param ( name = \"counterNames\" , required = true ) protected StringList counterNames ; @ OperationMethod public Blob run ( ) throws Exception { CounterManager cm = Framework . getLocalService ( CounterManager . class ) ; JSONObject collection = new JSONObject ( ) ; Principal principal = ctx . getPrincipal ( ) ; if ( principal instanceof NuxeoPrincipal ) { NuxeoPrincipal nuxeoUser = ( NuxeoPrincipal ) principal ; if ( nuxeoUser . isAdministrator ( ) ) { for ( String counterName : counterNames ) { CounterHistoryStack stack = cm . getCounterHistory ( counterName ) ; List < long [ ] > valueList = new ArrayList < long [ ] > ( stack . getAsList ( ) ) ; Collections . reverse ( valueList ) ; JSONObject counter = new JSONObject ( ) ; JSONArray valueSerie = new JSONArray ( ) ; JSONArray deltaSerie = new JSONArray ( ) ; JSONArray speedSerie = new JSONArray ( ) ; float lastTS = 0 ; float lastValue = 0 ; long now = System . currentTimeMillis ( ) ; for ( long [ ] values : valueList ) { long ts = values [ 0 ] ; float t = ( now - ts ) / 1000 ; float value = values [ 1 ] ; JSONArray valueArray", "gt": "= new JSONArray ( ) ;", "prediction": "= new JSONArray ( ) ;\n", "label": 1}
{"id": 8239, "input": "<s> package com . benzrf . allocator ; import java . util . List ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . block . Chest ; import org . bukkit . block . Furnace ; import org . bukkit . entity . StorageMinecart ; import org . bukkit . inventory . ItemStack ; public class Output { public void outputAsItemEntities ( Block b , float xAdd , float zAdd , List < ItemStack > input , List < Runnable > removers ) { xAdd = - xAdd + 0.5F ; zAdd = - zAdd + 0.5F ; for ( ItemStack i : input ) { Location l = b . getLocation ( ) . add ( xAdd , 0.0D , zAdd ) ; b . getWorld ( ) . dropItem ( l , i ) ; } for ( Runnable r2 : removers ) { r2 . run ( ) ; } } public void outputToChest ( Block b , int xAdd , int zAdd , List < ItemStack > input , List < Runnable > removers ) { Chest c = ( Chest ) b . getWorld ( ) . getBlockAt ( b . getX ( ) - xAdd , b . getY ( ) , b . getZ ( ) - zAdd ) . getState ( ) ; for ( ItemStack i : input ) { if ( c . getInventory ( ) . addItem ( new ItemStack [ ] { i } ) . containsValue ( i ) ) continue ; ( ( Runnable ) removers . get ( input . indexOf ( i ) ) ) . run ( ) ; } } public void outputToStorageMinecart ( StorageMinecart sm , List < ItemStack > input , List < Runnable > removers ) { for ( ItemStack i : input ) { if ( sm . getInventory ( ) . addItem ( i ) . containsValue ( i ) ) { ( ( Runnable ) removers . get ( input . indexOf ( i ) ) ) . run ( ) ; } } } public void outputToFurnace ( Block b , int xAdd , int zAdd , List < ItemStack > input , List < Runnable > removers ) { Block b2 = b . getWorld ( ) . getBlockAt ( b . getX ( ) - xAdd , b . getY ( ) , b . getZ ( ) - zAdd ) ; int aDir = b", "gt": ". getData ( ) ;", "prediction": "2 . getDir ( ) ;\n", "label": 0}
{"id": 13202, "input": "<s> package Rio ; import java . io . ByteArrayOutputStream ; import java . io . ByteArrayInputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import edu . washington . cs . cse490h . lib . Packet ; import edu . washington . cs . cse490h . lib . Utility ; public class RIOPacket { public static final int MAX_PACKET_SIZE = Packet . MAX_PAYLOAD_SIZE ; public static final int HEADER_SIZE = 5 ; public static final int MAX_PAYLOAD_SIZE = MAX_PACKET_SIZE - HEADER_SIZE ; private int protocol ; private int seqNum ; private byte [ ] payload ; public RIOPacket ( int protocol , int seqNum , byte [ ] payload ) throws IllegalArgumentException { if ( ! Protocol . isRIOProtocolValid ( protocol ) || payload . length > MAX_PAYLOAD_SIZE ) { throw new IllegalArgumentException ( \"Illegal arguments given to RIOPacket\" ) ; } this . protocol = protocol ; this . seqNum = seqNum ; this . payload = payload ; } public int getProtocol ( ) { return this . protocol ; } public int getSeqNum ( ) { return this . seqNum ; } public byte [ ] getPayload ( ) { return this . payload ; } public byte [ ] pack ( ) { try { ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( byteStream ) ; out . writeByte ( protocol ) ; out . writeInt ( seqNum ) ; out . write ( payload , 0 , payload . length ) ; out . flush ( ) ; out . close ( ) ; return byteStream . toByteArray ( ) ; } catch ( IOException e ) { return null ; } } public static RIOPacket unpack (", "gt": "byte [ ] packet )", "prediction": ")\n", "label": 1}
{"id": 2284, "input": "<s> package org . apache . felix . resolver ; public interface Logger { static final int LOG_ERROR = 1 ; static final int LOG_WARNING = 2 ; static final int LOG_INFO = 3 ; static final int LOG_DEBUG = 4 ; void", "gt": "log ( int level , String msg ) ;", "prediction": "setLogger ( Logger logger ) ;\n", "label": 0}
{"id": 13205, "input": "<s> package org . fuzzydb . attrs . internal ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; public class ContainsNotSpecifiedAttrConstraint implements IAttributeConstraint { private static final long serialVersionUID = 425720663301485948L ; private int attrId ; @ SuppressWarnings ( \"unused\" ) private ContainsNotSpecifiedAttrConstraint ( ) { } public ContainsNotSpecifiedAttrConstraint ( int attrId ) { this . attrId = attrId ; } public boolean isIncludesNotSpecified ( ) { return true ; } public void setIncludesNotSpecified ( boolean includesNotSpecified ) { assert ( includesNotSpecified == true ) ; } public int getAttrId ( ) { return attrId ; } public void setAttrId ( int attrId ) { this . attrId = attrId ; } @ Override public IAttributeConstraint clone ( ) { return new ContainsNotSpecifiedAttrConstraint ( attrId ) ; } @ Override public String toString ( ) { return \"incl null = true\" ; } public Object asSimpleAttribute ( ) { return this ; } public boolean expand ( Attribute att ) { throw new UnsupportedOperationException ( ) ; } public boolean isExpandedBy ( IAttribute value ) { return ( value != null ) ; } public boolean consistent ( IAttribute value ) { return ( value == null ) ; } public boolean equals ( IAttributeConstraint rhs ) { throw", "gt": "new UnsupportedOperationException ( ) ;", "prediction": "new UnsupportedOperationException ( ) ;\n", "label": 1}
{"id": 9685, "input": "<s> package pkg2 ; public class Sub extends pkg1 . Base { private class Inner { public void run ( ) { baseMethod ( ) ;", "gt": "Sub . this . baseMethod ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13211, "input": "<s> package org . restlet . ext . gwt ; import com . google . gwt . user . client . rpc . SerializationException ; import com . google . gwt . user . server . rpc . SerializationPolicy ; public class SimpleSerializationPolicy extends SerializationPolicy { private static final SimpleSerializationPolicy instance = new SimpleSerializationPolicy ( ) ; public static SerializationPolicy getInstance ( ) { return instance ; } @ Override public boolean shouldDeserializeFields ( Class < ? > clazz ) { return ( clazz != null ) ; } @ Override public boolean shouldSerializeFields ( Class < ? > clazz ) { return ( clazz != null ) ; } @ Override public void validateDeserialize ( Class <", "gt": "? > clazz ) throws SerializationException", "prediction": "? > clazz )\n", "label": 1}
{"id": 2423, "input": "<s> package org . ofbiz . product . imagemanagement ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; public class ImageManagementHelper { static String module = ImageManagementHelper . class . getName ( ) ; public static String getInternalImageUrl ( HttpServletRequest request , String productId ) { String internalImageUrl = null ; try { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; List < GenericValue > defaultImageList = delegator . findByAnd ( \"ProductContentAndInfo\" , UtilMisc . toMap ( \"productId\" , productId , \"productContentTypeId\" , \"DEFAULT_IMAGE\" , \"statusId\" , \"IM_APPROVED\" , \"drIsPublic\" , \"N\" ) , UtilMisc . toList ( \"sequenceNum\" ) , false ) ; if ( UtilValidate . isNotEmpty ( defaultImageList ) ) { GenericValue productContent = EntityUtil . getFirst ( defaultImageList ) ; if ( UtilValidate . isNotEmpty ( productContent . get ( \"drObjectInfo\" ) ) ) { internalImageUrl = ( String ) productContent . get ( \"drObjectInfo\" ) ; } } else { List < GenericValue > productContentList = delegator . findByAnd ( \"ProductContentAndInfo\" , UtilMisc . toMap ( \"productId\" , productId , \"productContentTypeId\" , \"IMAGE\" , \"statusId\" , \"IM_APPROVED\" , \"drIsPublic\" , \"N\" ) , UtilMisc . toList ( \"sequenceNum\" ) , false ) ;", "gt": "if ( UtilValidate . isNotEmpty ( productContentList ) )", "prediction": "if ( UtilValidate . isNotEmpty ( productContentList ) )\n", "label": 0}
{"id": 13213, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . ToolBarManager ; import org . eclipse . jface . commands . ActionHandler ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . IPreferencePage ; import org . eclipse . jface . preference . PreferenceContentProvider ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceLabelProvider ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . FocusAdapter ; import org . eclipse . swt . events . FocusEvent ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . Sash ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . ActiveShellExpression ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . dialogs . FilteredTree ; import org . eclipse . ui", "gt": ". dialogs . PatternFilter ;", "prediction": ". internal . WorkbenchMessages ;\n", "label": 1}
{"id": 47, "input": "<s> package com . matburt . mobileorg . test . Synchronizers ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . security . cert . CertificateException ; import java . util . HashMap ; import javax . net . ssl . SSLHandshakeException ; import com . matburt . mobileorg . Synchronizers . SynchronizerInterface ; public class SynchronizerStub implements SynchronizerInterface { int putRemoteFileCount = 0 ; int getRemoteFileCount = 0 ; HashMap < String , String > files = new HashMap < String , String > ( ) ; SynchronizerStub ( ) { } @ Override public boolean isConfigured ( ) { return true ; } @ Override public void putRemoteFile ( String filename , String contents ) throws IOException { putRemoteFileCount ++ ; addFile ( filename , contents ) ; } @ Override public BufferedReader getRemoteFile ( String filename ) throws", "gt": "IOException , CertificateException , SSLHandshakeException", "prediction": "IOException\n", "label": 0}
{"id": 13214, "input": "<s> package br . org . archimedes . extend ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . extend . interfaces . Extender ; import br . org . archimedes . extend . rcp . ExtenderEPLoader ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import java . util . Collection ; public class ExtendManager implements br . org . archimedes . interfaces . ExtendManager { private static final Extender NULL_EXTENDER = new NullExtender ( ) ; private ExtenderEPLoader loader ; public ExtendManager ( ) { loader = new ExtenderEPLoader ( ) ; } public ExtendManager ( ExtenderEPLoader loader ) { this . loader = loader ; } public Element extend ( Element element , Collection < Element > references , Point click ) throws NullArgumentException { return getExtenderFor ( element ) . extend ( element , references , click ) ; } private Extender", "gt": "getExtenderFor ( Element element )", "prediction": "EPLoader getExtenderFor ( Element element )\n", "label": 1}
{"id": 8446, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import java . io . * ; public interface NestedClassWriter { public void", "gt": "close ( ) throws IOException ;", "prediction": "write ( NestedClassWriter writer ) ;\n", "label": 0}
{"id": 13219, "input": "<s> package org . eclipse . ui . internal . views . properties ; import org . eclipse . rap . rwt . RWT ; public class PropertiesMessages { private static final String BUNDLE_NAME = \"org.eclipse.ui.internal.views.properties.messages\" ; public String Categories_text ; public String Categories_toolTip ; public String CopyProperty_text ; public String Defaults_text ; public String Defaults_toolTip ; public String Filter_text ; public String Filter_toolTip ; public String PropertyViewer_property ; public String PropertyViewer_value ; public String PropertyViewer_misc ; public String CopyToClipboardProblemDialog_title ; public String CopyToClipboardProblemDialog_message ; public static PropertiesMessages get ( ) { return RWT . NLS . getISO8859_1Encoded", "gt": "( BUNDLE_NAME , PropertiesMessages . class ) ;", "prediction": "( BUNDLE_NAME , Messages . class ) ;\n", "label": 1}
{"id": 3881, "input": "<s> import java . io . * ; public class T6942649 { public static void main ( String ... args ) throws Exception { new T6942649 ( ) . run ( ) ; } void run ( ) throws Exception { test ( \"-XDshowClass\" , \"com.sun.tools.javac.Main\" ) ; test ( \"-XDshowClass=com.sun.tools.javac.util.Log\" , \"com.sun.tools.javac.util.Log\" ) ; } void test ( String opt , String clazz ) throws Exception { System . err . println ( \"test \" + opt ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javac . Main . compile ( new String [ ] { opt } , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; System . err . println ( \"javac rc=\" + rc + \"\\n\" + out ) ; if ( ! out . contains ( clazz ) ) throw new Exception ( \"class name not found in output\" ) ; int lastDot = clazz . lastIndexOf ( \".\" ) ; if ( ! out . contains ( clazz . substring ( lastDot + 1 ) + \".class\" ) ) throw new Exception ( \"location of class not found in output\" ) ; if ( ! out . contains ( \"MD5 checksum: \" ) ) throw new Exception", "gt": "( \"checksum not found in output\" ) ;", "prediction": "( \"location of class not found in output\" ) ;\n", "label": 0}
{"id": 13220, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . swt . graphics . Image ; public class CheckboxTreeViewerMissingTest extends CheckboxTreeViewerTest { private static Image testImage ; public static Image getMissingImage ( ) { if ( testImage == null ) testImage = ImageDescriptor . createFromFile ( TestLabelProvider . class , \"images/missing.gif\" ) . createImage ( ) ; return testImage ; } public static class CheckboxMissingTableTestLabelProvider extends CheckboxTreeViewerTest . CheckboxTableTestLabelProvider implements ITableLabelProvider { public Image getImage ( Object element ) { return getMissingImage ( ) ; } } public CheckboxTreeViewerMissingTest ( String name ) { super ( name ) ; } public IBaseLabelProvider getTestLabelProvider ( ) {", "gt": "return new CheckboxMissingTableTestLabelProvider ( ) ;", "prediction": "return testLabelProvider ;\n", "label": 1}
{"id": 1195, "input": "<s> package org . ofbiz . order . order ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityComparisonOperator ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class OrderLookupServices { public static final String module = OrderLookupServices . class . getName ( ) ; public static Map < String , Object > findOrders ( DispatchContext dctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; Security security = dctx . getSecurity ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Integer viewIndex = ( Integer ) context . get ( \"viewIndex\" ) ; Integer viewSize = ( Integer ) context . get ( \"viewSize\" ) ; String showAll = ( String ) context . get ( \"showAll\" ) ; String useEntryDate = ( String ) context . get ( \"useEntryDate\" ) ; if ( showAll == null ) { showAll = \"N\" ; } List < String > fieldsToSelect = FastList . newInstance ( ) ; fieldsToSelect . add ( \"orderId\" ) ; fieldsToSelect . add ( \"orderName\" ) ; fieldsToSelect . add ( \"statusId\" ) ; fieldsToSelect . add ( \"orderTypeId\" ) ; fieldsToSelect . add ( \"orderDate\" ) ; fieldsToSelect . add ( \"currencyUom\" ) ; fieldsToSelect . add ( \"grandTotal\" ) ; fieldsToSelect . add ( \"remainingSubTotal\" ) ; List < String > orderBy = UtilMisc . toList ( \"-orderDate\" , \"-orderId\" ) ; List < String > paramList = FastList . newInstance ( ) ; List < EntityCondition > conditions = FastList . newInstance ( ) ; boolean canViewPo = security . hasEntityPermission ( \"ORDERMGR\" , \"_PURCHASE_VIEW\" , userLogin ) ; if ( ! canViewPo ) { conditions . add ( EntityCondition . makeCondition ( \"orderTypeId\" , EntityOperator . NOT_EQUAL , \"PURCHASE_ORDER\" ) ) ; } DynamicViewEntity dve = new DynamicViewEntity ( ) ; dve . addMemberEntity ( \"OH\" , \"OrderHeader\" ) ; dve . addAliasAll ( \"OH\" , \"\" , null ) ; dve . addRelation ( \"one-nofk\" , \"\" , \"OrderType\" , UtilMisc . toList ( new ModelKeyMap ( \"orderTypeId\" , \"orderTypeId\" ) ) ) ; dve . addRelation ( \"one-nofk\" , \"\" , \"StatusItem\" , UtilMisc . toList ( new ModelKeyMap ( \"statusId\" , \"statusId\" ) ) ) ; String orderId = ( String ) context . get ( \"orderId\" ) ; if ( UtilValidate . isNotEmpty ( orderId ) ) { paramList . add ( \"orderId=\" + orderId ) ; conditions . add ( makeExpr ( \"orderId\" , orderId ) ) ; } List < String > orderTypeList = UtilGenerics . checkList ( context . get ( \"orderTypeId\" ) ) ; if ( orderTypeList != null ) { List < EntityExpr > orExprs = FastList . newInstance ( ) ; for ( String orderTypeId : orderTypeList ) { paramList . add ( \"orderTypeId=\" + orderTypeId ) ; if ( ! \"PURCHASE_ORDER\" . equals ( orderTypeId ) || ( \"PURCHASE_ORDER\" . equals ( orderTypeId ) && canViewPo ) ) { orExprs . add ( EntityCondition . makeCondition ( \"orderTypeId\" , EntityOperator . EQUALS , orderTypeId ) ) ; } } conditions . add ( EntityCondition . makeCondition ( orExprs , EntityOperator . OR ) ) ; } String orderName = ( String ) context . get ( \"orderName\" ) ; if ( UtilValidate . isNotEmpty ( orderName ) ) { paramList . add ( \"orderName=\" + orderName ) ; conditions . add ( makeExpr ( \"orderName\" , orderName , true ) ) ; } List < String > orderStatusList = UtilGenerics . checkList ( context . get ( \"orderStatusId\" ) ) ; if ( orderStatusList != null ) { List < EntityCondition > orExprs = FastList . newInstance ( ) ; for ( String orderStatusId : orderStatusList ) { paramList . add ( \"orderStatusId=\" + orderStatusId ) ; if ( \"PENDING\" . equals ( orderStatusId ) ) { List < EntityExpr > pendExprs = FastList . newInstance ( ) ; pendExprs . add ( EntityCondition . makeCondition ( \"statusId\" , EntityOperator . EQUALS , \"ORDER_CREATED\" ) ) ; pendExprs . add ( EntityCondition . makeCondition ( \"statusId\" , EntityOperator . EQUALS , \"ORDER_PROCESSING\" ) ) ; pendExprs . add ( EntityCondition . makeCondition ( \"statusId\" , EntityOperator . EQUALS , \"ORDER_APPROVED\" ) ) ; orExprs . add ( EntityCondition . makeCondition ( pendExprs , EntityOperator . OR ) ) ; } else { orExprs . add ( EntityCondition . makeCondition ( \"statusId\" , EntityOperator . EQUALS , orderStatusId ) ) ; } } conditions . add ( EntityCondition . makeCondition ( orExprs , EntityOperator . OR ) ) ; } List < String > productStoreList = UtilGenerics . checkList ( context . get ( \"productStoreId\" ) ) ; if ( productStoreList != null ) { List < EntityExpr > orExprs = FastList", "gt": ". newInstance ( ) ;", "prediction": ". newInstance ( ) ;\n", "label": 0}
{"id": 13227, "input": "<s> package org . eclipse . ui . tests . dynamicplugins ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . dialogs . WorkbenchPreferenceNode ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class PreferencePageTests extends DynamicTestCase { public PreferencePageTests ( String testName ) { super ( testName ) ; } public void testPreferences ( ) { PreferenceManager preferenceManager = PlatformUI . getWorkbench ( ) . getPreferenceManager ( ) ; assertNull ( preferenceManager . find ( \"dynamic.parentPage\" ) ) ; assertNull ( preferenceManager . find ( \"dynamic.parentPage/dynamic.childPage\" ) ) ; getBundle ( ) ; WorkbenchPreferenceNode node = ( WorkbenchPreferenceNode ) preferenceManager . find ( \"dynamic.parentPage\" ) ; assertNotNull ( node ) ; node . createPage ( ) ; node = ( WorkbenchPreferenceNode ) preferenceManager", "gt": ". find ( \"dynamic.parentPage/dynamic.childPage\" ) ;", "prediction": ". find ( \"dynamic.parentPage/dynamic.childPage\" ) ;\n", "label": 1}
{"id": 8556, "input": "<s> package com . matburt . mobileorg . test . Gui ; import android . app . Instrumentation ; import android . content . ContentResolver ; import android . content . Intent ; import android . test . ActivityInstrumentationTestCase2 ; import com . matburt . mobileorg . Gui . Capture . EditActivity ; import com . matburt . mobileorg . Gui . Capture . LocationFragment ; import com . matburt . mobileorg . OrgData . OrgContract . OrgData ; import com . matburt . mobileorg . OrgData . OrgFile ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import com . matburt . mobileorg . test . util . OrgTestUtils ; public class LocationFragmentTest extends ActivityInstrumentationTestCase2 < EditActivity > { private final String LOCATION_FRAGMENT = \"locationFragment\" ; private EditActivity activity ; private ContentResolver resolver ; private Instrumentation instrumentation ; private LocationFragment locationFragment ; private long nodeId = - 1 ; public LocationFragmentTest ( ) { super ( EditActivity . class ) ; } @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; this . instrumentation = getInstrumentation ( ) ; this . resolver = instrumentation . getContext ( ) . getContentResolver ( ) ; } @ Override public void tearDown ( ) throws Exception { if ( nodeId >= 0 ) resolver . delete ( OrgData . buildIdUri ( nodeId ) , null , null ) ; this . nodeId = - 1 ; super . tearDown ( ) ; } private void prepareActivityWithNode ( OrgNode node , String actionMode ) { Intent intent = new Intent ( ) ; intent . putExtra ( EditActivity . ACTIONMODE , actionMode ) ; intent . putExtra ( EditActivity . NODE_ID , node . id ) ; setActivityIntent ( intent ) ; setActivityInitialTouchMode ( false ) ; this . activity = getActivity ( ) ; this . resolver = activity . getContentResolver ( ) ; this . locationFragment = ( ( LocationFragment ) this . activity . getSupportFragmentManager ( ) . findFragmentByTag ( LOCATION_FRAGMENT ) ) ; } public void testSetup ( ) { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; this . nodeId = node . id ; prepareActivityWithNode ( node , EditActivity . ACTIONMODE_EDIT ) ; assertNotNull ( this . activity ) ; assertNotNull ( this . locationFragment ) ; } public void test_Create_Simple ( ) { OrgNode node = new OrgNode ( ) ; prepareActivityWithNode ( node , EditActivity . ACTIONMODE_CREATE ) ; OrgNode locationNode = locationFragment . getLocationSelection ( ) ; OrgNode captureFile = OrgProviderUtils . getOrCreateCaptureFile ( resolver ) . getOrgNode ( resolver ) ; assertEquals ( captureFile . fileId , locationNode . fileId ) ; assertEquals ( captureFile . id , locationNode . id ) ; } public void test_Addchild_ToplevelFile ( ) { OrgFile file = OrgProviderUtils . getOrCreateFile ( \"test file.org\" , \"delete me\" , resolver ) ; OrgNode fileNode = file . getOrgNode ( resolver ) ; prepareActivityWithNode ( fileNode , EditActivity . ACTIONMODE_ADDCHILD ) ; OrgNode locationNode = locationFragment . getLocationSelection ( ) ; assertEquals ( fileNode . name , locationNode . name ) ; assertEquals ( fileNode . id , locationNode . id ) ; assertEquals ( fileNode . fileId , locationNode . fileId ) ; } public void test_Addchild_ToplevelFileWithAddChild ( ) { OrgNode fileNode = OrgProviderUtils . getOrCreateCaptureFile ( resolver ) . getOrgNode ( resolver ) ; prepareActivityWithNode ( fileNode , EditActivity . ACTIONMODE_ADDCHILD ) ; activity . runOnUiThread ( new Runnable ( ) { public void run ( ) { locationFragment . addChild ( null , \"\" ) ; } } ) ; instrumentation . waitForIdleSync ( ) ; OrgNode locationNode = locationFragment . getLocationSelection ( ) ; assertEquals ( fileNode . id , locationNode . id ) ; assertEquals ( fileNode . fileId , locationNode . fileId ) ; } public void test_Addchild_NestedChild ( ) { OrgNode node = OrgTestUtils . setupParentScenario ( resolver ) ; prepareActivityWithNode ( node , EditActivity . ACTIONMODE_ADDCHILD ) ; OrgNode locationNode = locationFragment . getLocationSelection ( ) ; OrgTestUtils . cleanupParentScenario ( resolver ) ; assertEquals ( node . id , locationNode . id ) ; assertEquals ( node . fileId , locationNode . fileId ) ; } public void test_Edit_NestedChild ( ) { OrgNode node = OrgTestUtils . setupParentScenario ( resolver ) ; prepareActivityWithNode ( node", "gt": ", EditActivity . ACTIONMODE_EDIT ) ;", "prediction": ", EditActivity . ACTIONMODE_EDIT ) ;\n", "label": 0}
{"id": 13228, "input": "<s> package org . restlet . ext . wadl ; import java . io . IOException ; import java . util . List ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . converter . ConverterHelper ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; public class WadlConverter extends ConverterHelper { private static final VariantInfo VARIANT_APPLICATION_WADL = new VariantInfo ( MediaType . APPLICATION_WADL ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; if ( VARIANT_APPLICATION_WADL . includes ( source ) ) { result = addObjectClass ( result , ApplicationInfo . class ) ; } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( ApplicationInfo . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_APPLICATION_WADL ) ; } return result ; } @ Override public < T > float score ( Representation source , Class < T > target , Resource resource ) { float result = - 1.0F ; if ( ( source != null ) && ( ApplicationInfo . class . isAssignableFrom ( target ) ) ) { result = 1.0F ; } return result ; } @ Override public float score ( Object source , Variant target , Resource resource ) { if ( source instanceof ApplicationInfo ) { return 1.0f ; } return - 1.0f ; } @ Override public < T > T toObject ( Representation source , Class < T > target , Resource resource ) throws IOException { Object result = null ; if ( ApplicationInfo . class . isAssignableFrom ( target ) ) { if ( source instanceof WadlRepresentation ) { result = ( ( WadlRepresentation ) source ) . getApplication ( ) ; } else { result = new WadlRepresentation ( source ) . getApplication ( ) ; } } return target . cast ( result ) ; } @ Override public Representation toRepresentation ( Object source , Variant target , Resource resource ) throws IOException { if ( source instanceof ApplicationInfo ) { return new WadlRepresentation ( ( ApplicationInfo ) source ) ; } return null ; } @ Override public < T > void updatePreferences ( List < Preference < MediaType > > preferences , Class < T > entity ) {", "gt": "if ( ApplicationInfo . class . isAssignableFrom ( entity ) )", "prediction": "if ( ApplicationInfo . class . isAssignableFrom ( entity ) )\n", "label": 1}
{"id": 6946, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . translate ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . csstudio . swt . xygraph . figures . XYGraph ; import org . dawb . workbench . plotting . system . swtxy . selection . SelectionHandle ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . LayoutManager ; import org . eclipse . draw2d . MouseEvent ; import org . eclipse . draw2d . MouseListener ; import org . eclipse . draw2d . MouseMotionListener ; import org . eclipse . draw2d . UpdateManager ; import org . eclipse . draw2d . geometry . Dimension ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . Rectangle ; public class FigureTranslator implements MouseListener , MouseMotionListener { public enum LockType { NONE , X , Y ; } private LockType lockedDirection = LockType . NONE ; private final IFigure redrawFigure ; private Rectangle bounds ; private XYGraph xyGraph ; private Dimension cumulativeOffset ; private Point startLocation ; private Point location ; private List < IFigure > translations ; private boolean active = true ; public FigureTranslator ( XYGraph xyGraph , IFigure figure ) { this ( xyGraph , figure , figure , Arrays . asList ( new IFigure [ ] { figure } ) ) ; } public FigureTranslator ( XYGraph xyGraph , IFigure redrawFigure , IFigure listenerFigure , List < IFigure > moveFigures ) { this . redrawFigure = redrawFigure ; listenerFigure . addMouseListener ( this ) ; listenerFigure . addMouseMotionListener ( this ) ; this . translations = moveFigures ; this . xyGraph = xyGraph ; } @ Override public void mouseDragged ( MouseEvent event ) { if ( ! active ) return ; try { if ( location == null ) return ; Point newLocation = event . getLocation ( ) ; if ( newLocation == null ) return ; fireBeforeTranslation ( new TranslationEvent ( this ) ) ; this . cumulativeOffset = newLocation . getDifference ( startLocation ) ; Dimension offset = newLocation . getDifference ( location ) ; if ( offset . width == 0 && offset . height == 0 ) return ; location = newLocation ; UpdateManager updateMgr = redrawFigure . getUpdateManager ( ) ; LayoutManager layoutMgr = redrawFigure . getParent ( ) . getLayoutManager ( ) ; bounds = redrawFigure . getBounds ( ) ; updateMgr . addDirtyRegion ( redrawFigure . getParent ( ) , bounds ) ; this . bounds = translate ( bounds . getCopy ( ) , offset . width , offset . height ) ; if ( layoutMgr != null ) layoutMgr . setConstraint ( redrawFigure , bounds ) ; for ( int i = 0 ; i < translations . size ( ) ; i ++ ) { translate ( ( ( IFigure ) translations . get ( i ) )", "gt": ", offset . width , offset . height ) ;", "prediction": ". getX ( ) , ( ( IFigure ) translations . get ( i ) ) . getY ( ) ) ;\n", "label": 0}
{"id": 13234, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . eclipse . xtext . xdoc . xdoc . MarkupInCode ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class MarkupInCodeImpl extends MinimalEObjectImpl . Container implements MarkupInCode { protected MarkupInCodeImpl ( ) { super ( ) ; } @", "gt": "Override protected EClass eStaticClass ( )", "prediction": "Override protected EClass eStaticClass ( )\n", "label": 1}
{"id": 3888, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . helpers ;", "gt": "public class SimpleChildNodeEditHelper extends SimplemapBaseEditHelper", "prediction": "import org . mockito . Mockito . mock ;\n", "label": 0}
{"id": 13239, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import com . emf4sw . owl . DataMinCardinality ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . OWLPackage ; public class DataMinCardinalityImpl extends DataPropertyRestrictionImpl implements DataMinCardinality { protected static final int CARDINALITY_EDEFAULT = 0 ; protected int cardinality = CARDINALITY_EDEFAULT ; protected DataRange dataRange ; protected DataProperty property ; protected DataMinCardinalityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . DATA_MIN_CARDINALITY ; } public int getCardinality ( ) { return cardinality ; } public void setCardinality ( int newCardinality ) { int oldCardinality = cardinality ; cardinality = newCardinality ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY , oldCardinality , cardinality ) ) ; } public DataRange getDataRange ( ) { if ( dataRange != null && dataRange . eIsProxy ( ) ) { InternalEObject oldDataRange = ( InternalEObject ) dataRange ; dataRange = ( DataRange ) eResolveProxy ( oldDataRange ) ; if ( dataRange != oldDataRange ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } } return dataRange ; } public DataRange basicGetDataRange ( ) { return dataRange ; } public void setDataRange ( DataRange newDataRange ) { DataRange oldDataRange = dataRange ; dataRange = newDataRange ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } public DataProperty getProperty ( ) { if ( property != null && property . eIsProxy ( ) ) { InternalEObject oldProperty = ( InternalEObject ) property ; property = ( DataProperty ) eResolveProxy ( oldProperty ) ; if ( property != oldProperty ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } } return property ; } public DataProperty basicGetProperty ( ) { return property ; } public void setProperty ( DataProperty newProperty ) { DataProperty oldProperty = property ; property = newProperty ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : return getCardinality ( ) ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : if ( resolve ) return getDataRange ( ) ; return basicGetDataRange ( ) ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : if ( resolve ) return getProperty ( ) ; return basicGetProperty ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : setCardinality ( ( Integer ) newValue ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : setDataRange ( ( DataRange ) newValue ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : setProperty ( (", "gt": "DataProperty ) newValue ) ;", "prediction": "String ) newValue ) ;\n", "label": 1}
{"id": 3411, "input": "<s> import com . sun . javadoc . * ; import java . io . File ; import static com . sun . tools . javadoc . Main . execute ; public class T6551367 extends com . sun . tools . doclets . standard . Standard { public T6551367 ( ) { } public static void main ( String ... args ) { File testSrc = new File ( System . getProperty ( \"test.src\" , \".\" ) ) ; File destDir = new File ( System . getProperty ( \"user.dir\" , \".\" ) ) ; for ( String file : args ) { File source = new File ( testSrc , file ) ; int rc = execute ( \"javadoc\" , \"T6551367\" , T6551367 . class . getClassLoader ( ) , new String [ ] { source . getPath ( ) , \"-d\" , destDir . getAbsolutePath ( ) } ) ; if ( rc != 0 ) throw new Error ( \"unexpected exit", "gt": "from javadoc: \" + rc ) ;", "prediction": "code: \" + rc ) ;\n", "label": 0}
{"id": 13240, "input": "<s> package org . modelgoon . sequencediagram . ui ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . draw2d . geometry . Point ; public class SequenceDiagramFigure extends FragmentFigure { Map < String , LifelineFigure > lifelinesRegistry = new HashMap < String , LifelineFigure > ( ) ; int preferedWidth = 0 ; public SequenceDiagramFigure ( ) { super ( ) ; setFirstOffset ( 50 ) ; } public void addActor ( final String objectName ) { LifelineFigure lifelineFigure = new LifelineFigure ( ) ; lifelineFigure . setActor ( true ) ; lifelineFigure . setLabel ( objectName ) ; add ( lifelineFigure ) ; this . lifelinesRegistry . put ( objectName , lifelineFigure ) ; } public void addLifeline ( final String objectName ) { LifelineFigure lifelineFigure = new LifelineFigure ( ) ; lifelineFigure . setLabel ( objectName ) ; add ( lifelineFigure ) ; this . lifelinesRegistry . put ( objectName , lifelineFigure ) ; } public void addMessage ( final String message , final String source , final String destination ) { MessageConnection messageConnection = createMessageConnection ( message , source , destination ) ; add ( messageConnection ) ; } public MessageConnection createMessageConnection ( final String message , final String source , final String destination ) { LifelineFigure sourceFigure = this . lifelinesRegistry . get ( source ) ; LifelineFigure destFigure = this . lifelinesRegistry . get ( destination ) ; return new MessageConnection ( message , sourceFigure , destFigure ) ; } @ Override protected void layout ( ) { super", "gt": ". layout ( ) ;", "prediction": ". layout ( ) ;\n", "label": 1}
{"id": 124, "input": "<s> package org . ofbiz . widget ; import java . io . IOException ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . math . BigDecimal ; import java . net . URLEncoder ; import java . nio . charset . Charset ; import java . text . DateFormat ; import java . util . Map ; import java . util . TimeZone ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . taglib . ContentUrlTag ; import org . ofbiz . widget . form . ModelForm ; import org . ofbiz . widget . form . ModelFormField ; import org . w3c . dom . Element ; public class WidgetWorker { public static final String module = WidgetWorker . class . getName ( ) ; public WidgetWorker ( ) { } public static void buildHyperlinkUrl ( Appendable externalWriter , String target , String targetType , Map < String , String > parameterMap , String prefix , boolean fullPath , boolean secure , boolean encode , HttpServletRequest request , HttpServletResponse response , Map < String , Object > context ) throws IOException { String localRequestName = UtilHttp . encodeAmpersands ( target ) ; Appendable localWriter = new StringWriter ( ) ; if ( \"intra-app\" . equals ( targetType ) ) { if ( request != null && response != null ) { ServletContext servletContext = request . getSession ( ) . getServletContext ( ) ; RequestHandler rh = ( RequestHandler ) servletContext . getAttribute ( \"_REQUEST_HANDLER_\" ) ; externalWriter . append ( rh . makeLink ( request , response , \"/\" + localRequestName , fullPath , secure , encode ) ) ; } else if ( prefix != null ) { externalWriter . append ( prefix ) ; externalWriter . append ( localRequestName ) ; } else { externalWriter . append ( localRequestName ) ; } } else if ( \"inter-app\" . equals ( targetType ) ) { String fullTarget = localRequestName ; localWriter . append ( fullTarget ) ; String externalLoginKey = ( String ) request . getAttribute ( \"externalLoginKey\" ) ; if ( UtilValidate . isNotEmpty ( externalLoginKey ) ) { if ( fullTarget . indexOf ( '?' ) == - 1 ) { localWriter . append ( '?' ) ; } else { localWriter . append ( \"&amp;\" ) ; } localWriter . append ( \"externalLoginKey=\" ) ; localWriter . append ( externalLoginKey ) ; } } else if ( \"content\" . equals ( targetType ) ) { appendContentUrl ( localWriter , localRequestName , request ) ; } else if ( \"plain\" . equals ( targetType ) ) { localWriter . append ( localRequestName ) ; } else { localWriter . append ( localRequestName ) ; } if ( UtilValidate . isNotEmpty ( parameterMap ) ) { String localUrl = localWriter . toString ( ) ; externalWriter . append ( localUrl ) ; boolean needsAmp = true ; if ( localUrl . indexOf ( '?' ) == - 1 ) { externalWriter . append ( '?' ) ; needsAmp = false ; } for ( Map . Entry < String , String > parameter : parameterMap . entrySet ( ) ) { String parameterValue = null ; if ( parameter . getValue ( ) instanceof String ) { parameterValue = parameter . getValue ( ) ; } else { Object parameterObject = parameter . getValue ( ) ; if ( parameterObject == null ) continue ; if ( parameterObject instanceof String [ ] ) { String [ ] parameterArray = ( String [ ] ) parameterObject ; parameterValue = parameterArray [ 0 ] ; Debug . logInfo ( \"Found String array value for parameter [\" + parameter . getKey ( ) + \"], using first value: \" + parameterValue , module ) ; } else { parameterValue = parameterObject . toString ( ) ; } } if ( needsAmp ) { externalWriter . append ( \"&amp;\" ) ; } else { needsAmp = true ; } externalWriter . append ( parameter . getKey ( ) ) ; externalWriter . append ( '=' ) ; StringUtil . SimpleEncoder simpleEncoder = ( StringUtil . SimpleEncoder ) context . get ( \"simpleEncoder\" ) ; if ( simpleEncoder != null ) { externalWriter . append ( simpleEncoder . encode ( parameterValue ) ) ; } else { externalWriter . append ( parameterValue ) ; } } } else { externalWriter . append ( localWriter . toString ( ) ) ; } } public static void appendContentUrl ( Appendable writer , String location , HttpServletRequest request ) throws IOException { StringBuilder buffer = new StringBuilder ( ) ; ContentUrlTag . appendContentPrefix ( request , buffer ) ; writer . append ( buffer . toString ( ) ) ; writer . append ( location ) ; } public static void makeHyperlinkByType ( Appendable writer , String linkType , String linkStyle , String targetType , String target , Map < String , String > parameterMap , String description , String targetWindow , String confirmation , ModelFormField modelFormField , HttpServletRequest request , HttpServletResponse response , Map < String , Object > context ) throws IOException { String realLinkType = WidgetWorker . determineAutoLinkType ( linkType , target , targetType , request ) ; if ( \"hidden-form\" . equals ( realLinkType ) ) { if ( modelFormField != null && \"multi\" . equals ( modelFormField . getModelForm ( ) . getType ( ) ) ) { WidgetWorker . makeHiddenFormLinkAnchor ( writer , linkStyle , description , confirmation , modelFormField , request , response , context ) ; Map < String , Object > wholeFormContext = UtilGenerics . checkMap", "gt": "( context . get ( \"wholeFormContext\" ) ) ;", "prediction": "( parameterMap ) ;\n", "label": 0}
{"id": 13242, "input": "<s> package org . fuzzydb . attrs . simple ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . Score . Direction ; import org . fuzzydb . attrs . dimensions . DimensionsRangeConstraint ; import org . fuzzydb . attrs . internal . IConstraintMap ; import org . fuzzydb . attrs . internal . MappedTwoAttrScorer ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; import org . fuzzydb . core . whirlwind . internal . IAttributeMap ; import org . fuzzydb . util . ScoreMapper ; public class FloatRangePreferenceScorer extends MappedTwoAttrScorer { private static final long serialVersionUID = - 2314631712003854132L ; @ SuppressWarnings ( \"unused\" ) private FloatRangePreferenceScorer ( ) { this ( 1 , 1 , null ) ; } public FloatRangePreferenceScorer ( int scoreAttrId , int otherAttrId , ScoreMapper scoreMapper ) { super ( scoreAttrId , otherAttrId , scoreMapper ) ; } @ Override public void scoreSearchToNode ( Score score , Direction d , IConstraintMap c , IAttributeMap < ? extends IAttribute > scoreAttrs ) { IAttribute attr = scoreAttrs . findAttr ( scorerAttrId ) ; if ( attr == null ) { return ; } FloatRangePreference want = ( FloatRangePreference ) attr ; IAttributeConstraint na = c . findAttr ( otherAttrId ) ; if ( na == null ) { score . addNull ( this , d ) ; return ; } float result = 0.0f ; if ( na . isIncludesNotSpecified ( ) ) { if ( isScoreNull ( ) ) { result = getScoreOnNull ( ) ; } } FloatConstraint bc = ( FloatConstraint ) na ; float branchMin = bc . getMin ( ) ; float branchMax = bc . getMax ( ) ; float myPref = want . getPreferred ( ) ; float s ; if ( branchMin <= myPref && myPref <= branchMax ) { s = maxScore ; } else if ( myPref > branchMax ) { s = scoreGap ( want , branchMax ) ; } else { s = scoreGap ( want , branchMin ) ; } result = Math . max ( result , s ) ; score . add ( this , result , d ) ; } @ Override public void scoreNodeToSearch ( Score score , Direction d , IAttributeMap < IAttributeConstraint > c , IAttributeMap < IAttribute > searchAttrs ) { IAttributeConstraint bNa = c . findAttr ( scorerAttrId ) ; if ( bNa == null ) { return ; } FloatValue otherAttr = ( FloatValue ) searchAttrs . findAttr ( otherAttrId ) ; if ( otherAttr == null ) { score . addNull ( this , d ) ; return ; } if ( bNa . isIncludesNotSpecified ( ) ) { score . add ( this , maxScore , d ) ; return ; } DimensionsRangeConstraint want = ( DimensionsRangeConstraint ) bNa ; float scoreFactor = getNodeScoreFactor ( want , otherAttr . getValue ( ) ) ; float scoreVal = getMappedScore ( scoreFactor ) ; score . add ( this , scoreVal , d ) ; } @ Override public void scoreItemToItem ( Score score , Score . Direction d , IAttributeMap < IAttribute > c , IAttributeMap < IAttribute > scoreAttrs ) { IAttribute wantAttr = scoreAttrs . findAttr ( scorerAttrId ) ; if ( wantAttr == null ) { return ; } assert ( wantAttr . getAttrId ( ) == scorerAttrId ) ; FloatValue have = ( FloatValue ) c . findAttr ( otherAttrId ) ; if ( have == null ) { score . addNull ( this , d ) ; return ; } if ( wantAttr instanceof FloatRangePreference ) { IFloatRangePreference want = ( IFloatRangePreference ) wantAttr ; float scoreVal = scoreGap ( want , have . getValue ( ) ) ; score . add ( this , scoreVal , d ) ; } else if ( wantAttr instanceof DimensionsRangeConstraint ) { DimensionsRangeConstraint want = ( DimensionsRangeConstraint ) wantAttr ; float nodeScoreFactor = getNodeScoreFactor ( want , have . getValue ( ) ) ; score . add ( this , getMappedScore ( nodeScoreFactor ) , d ) ; } else { throw new RuntimeException ( \"FloatRangePreferenceScorer doesn't support \" + wantAttr . getClass ( ) . getName ( ) ) ; } } protected float scoreGap ( IFloatRangePreference want , float theirs ) { float low = want . getMin ( ) ; float hi = want . getMax ( ) ; float pref = want . getPreferred ( ) ; return scoreGap ( theirs , low , hi , pref ) ; } protected float scoreGap ( float theirs , float low , float hi , float pref ) { float scoreFactor = getScoreFactor ( low , pref , hi , theirs ) ; return getMappedScore ( scoreFactor ) ; } private float getScoreFactor ( float low , float pref , float hi , float x ) { float scoreFactor ; float prefToVal ; float prefToEdge ; if ( x <= pref ) { prefToVal = pref - x ; prefToEdge = pref - low ; } else { prefToVal = x - pref ; prefToEdge = hi - pref ; } if ( prefToEdge == 0 ) { return - 1e6f ; } scoreFactor = 1.0f - prefToVal / prefToEdge ; return scoreFactor ; } protected float", "gt": "getNodeScoreFactor ( DimensionsRangeConstraint want , float value )", "prediction": "getMappedScore ( float scoreFactor )\n", "label": 1}
{"id": 3950, "input": "<s> package com . midtro . platform . modules . assets . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import com . midtro . platform . modules . assets . Assembler ; import com . midtro . platform . modules . assets . Asset ; import com . midtro . platform . modules . assets . AssetConfig ; public class TextAssembler implements Assembler { @ Override public void assemble ( String assetName , String fileName , AssetConfig config , Map < String , Asset < ? > > store ) throws Exception { List < String > list = null ; switch ( config . getMountType ( ) ) { case FILE : list = readList ( new FileReader ( new File ( config . getFileLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ) ; break ; case CACHE : list = readList ( new FileReader ( new File ( config . getCacheLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ) ; break ; case URL : list = readList ( new InputStreamReader ( new URL ( config . getUrlLocation ( ) + fileName ) . openStream ( ) ) ) ; break ; default : throw new IllegalStateException ( \"Unknown mount type\" ) ; } store . put ( \"text.\" + assetName , new TextAsset ( assetName , list ) ) ; } private List < String > readList ( Reader reader ) throws IOException { final BufferedReader br = new BufferedReader ( reader ) ; final List < String > list = new ArrayList < String > ( ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { if ( line", "gt": ". trim ( ) . length ( ) > 0 )", "prediction": ". length ( ) > 0 )\n", "label": 0}
{"id": 13246, "input": "<s> package org . eclipse . ui . internal . contexts ; import org . eclipse . core . expressions . Expression ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . internal . expressions . ActivePartExpression ; import org . eclipse . ui . internal . expressions . WorkbenchWindowExpression ; import org . eclipse . ui . internal . services . IWorkbenchLocationService ; import org . eclipse . ui . services . AbstractServiceFactory ; import org . eclipse . ui . services . IServiceLocator ; public class ContextServiceFactory extends AbstractServiceFactory { public Object create ( Class serviceInterface , IServiceLocator parentLocator , IServiceLocator locator ) { if ( ! IContextService . class . equals ( serviceInterface ) ) { return null ; } IWorkbenchLocationService wls = ( IWorkbenchLocationService ) locator . getService ( IWorkbenchLocationService . class ) ; final IWorkbench wb = wls", "gt": ". getWorkbench ( ) ;", "prediction": ". getActiveWorkbench ( ) ;\n", "label": 1}
{"id": 4105, "input": "<s> package ar . com . fdvs . dj . domain . constants ; import net . sf . jasperreports . engine . design . JRDesignImage ; public class ImageScaleMode extends BaseDomainConstant { private static final long serialVersionUID = 1L ; private byte value = JRDesignImage . SCALE_IMAGE_RETAIN_SHAPE ; public static ImageScaleMode NO_RESIZE = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_CLIP ) ; public static ImageScaleMode FILL = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_FILL_FRAME ) ; public static ImageScaleMode FILL_PROPORTIONALLY = new ImageScaleMode (", "gt": "JRDesignImage . SCALE_IMAGE_RETAIN_SHAPE ) ;", "prediction": "JRDesignImage . SCALE_IMAGE_FILL_PROPORTIONALLY ) ;\n", "label": 0}
{"id": 13250, "input": "<s> package org . gatein . common . logging ; class SimpleLogger extends Logger { private final org . slf4j . Logger delegate ; public SimpleLogger ( org . slf4j . Logger delegate ) { this . delegate = delegate ; } @ Override protected void doLog ( LogLevel level ,", "gt": "Object msg , Object [ ] argArray , Throwable throwable )", "prediction": "String msg )\n", "label": 1}
{"id": 2337, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import ar . com . fdvs . dj .", "gt": "domain . chart . DJChart ;", "prediction": "domain . chart . Category ;\n", "label": 0}
{"id": 13255, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . old ; import org . nuxeo . ecm . platform . gwt . client . ui . login . LoginCommand ; import com . google . gwt . user . client . ui . Button ; import com . google . gwt . user . client . ui . ClickListener ; import com . google . gwt . user . client . ui . DialogBox ; import com . google . gwt . user . client . ui . FlexTable ; import com . google . gwt . user . client . ui . FlowPanel ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . HasHorizontalAlignment ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . PasswordTextBox ; import com . google . gwt . user . client . ui . TextBox ; import com . google . gwt . user . client . ui . VerticalPanel ; import com . google . gwt . user . client . ui . Widget ; public class LoginDialog2 extends DialogBox implements ClickListener { protected TextBox userBox ; protected PasswordTextBox passBox ; public LoginDialog2 ( ) { this ( \"Authentication Requried\" ) ; setAnimationEnabled ( true ) ; } public LoginDialog2 ( String message ) { super ( ) ; setAnimationEnabled ( true ) ; VerticalPanel dialogContents = new VerticalPanel ( ) ; dialogContents . setSpacing ( 2 ) ; setWidget ( dialogContents ) ; HTML details = new HTML ( message ) ; dialogContents . add ( details ) ; dialogContents . setCellHorizontalAlignment ( details , HasHorizontalAlignment . ALIGN_CENTER ) ; dialogContents . add ( createContent ( ) ) ; } protected Widget createContent ( ) { userBox = new TextBox ( ) ; passBox = new PasswordTextBox ( ) ; Button submit = new Button ( \"Login\" ) ; submit . addClickListener ( this ) ; VerticalPanel panel = new VerticalPanel ( ) ; panel . add ( new Label ( \"Username:\" ) ) ; panel . add ( userBox ) ; panel . add ( new Label ( \"Password:\" ) ) ; panel . add ( passBox ) ; panel . add ( submit ) ; panel . setSpacing ( 2 ) ; FlexTable grid = new FlexTable ( ) ; grid . setWidget ( 0 , 0 , new Label ( \"Username\" ) ) ; grid . setWidget ( 0 , 1 , userBox ) ; grid . setWidget ( 0 , 0 , new Label ( \"Password\" ) ) ; grid", "gt": ". setWidget ( 1 , 1 , passBox ) ;", "prediction": ". setWidget ( 0 , 1 , passBox ) ;\n", "label": 1}
{"id": 1188, "input": "<s> package org . remast . swing ; import java . awt . BorderLayout ; import java . awt . KeyboardFocusManager ; import java . awt . Toolkit ; import java . awt . event . InputEvent ; import java . awt . event . KeyEvent ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . swing . JComponent ; import javax . swing . JScrollPane ; import javax . swing . KeyStroke ; import javax . swing . UIManager ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . text . DefaultEditorKit ; import org . jdesktop . swingx . JXPanel ; import org . jdesktop . swingx . JXTextArea ; import org . remast . util . StringUtils ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public class JTextEditor extends JXPanel { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( JTextEditor . class ) ; public interface TextChangeObserver { void onTextChange ( ) ; } private List < TextChangeObserver > textObservers = new ArrayList < TextChangeObserver > ( ) ; JXTextArea textArea ; private boolean scrollable = false ; private void notifyTextObservers ( ) { for ( TextChangeObserver txtObserver : textObservers ) { txtObserver . onTextChange ( ) ; } } public void addTextObserver ( final TextChangeObserver txtObserver ) { textObservers . add ( txtObserver ) ; } public JTextEditor ( ) { initialize ( ) ; } public JTextEditor ( final boolean scrollable ) { this . scrollable = scrollable ; initialize ( ) ; } private void initialize ( ) { this . setLayout ( new BorderLayout ( ) ) ; UIManager . put ( \"TextArea.font\" , UIManager . get ( \"TextField.font\" ) ) ; textArea = new JXTextArea ( ) ; textArea . setPrompt ( textBundle . textFor ( \"TextEditor.prompt\" ) ) ; textArea . setLineWrap ( true ) ; textArea . setEnabled ( true ) ; textArea . setEditable ( true ) ; setTabBehavior ( ) ; textArea . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void changedUpdate ( final DocumentEvent e ) { notifyTextObservers ( ) ; } public void insertUpdate ( final DocumentEvent e ) { notifyTextObservers ( ) ; } public void removeUpdate ( final DocumentEvent e ) { notifyTextObservers ( ) ; } } ) ; if ( scrollable ) { this . add ( new JScrollPane ( textArea ) , BorderLayout . CENTER ) ; } else { this . add ( textArea , BorderLayout . CENTER ) ; } } private void setTabBehavior ( ) { Set < KeyStroke > key = new HashSet < KeyStroke > ( ) ; key . add ( KeyStroke . getKeyStroke (", "gt": "KeyEvent . VK_TAB , 0 ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 13258, "input": "<s> package org . eclipse . rap . ui . tests . resources ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . IResourceManager . RegisterOptions ; public final class Resource1 implements IResource { public String getCharset ( ) { return \"UTF-8\" ; } public ClassLoader getLoader ( ) { return Resource1 . class . getClassLoader ( ) ; } public String getLocation ( ) { return \"org/eclipse/rap/ui/tests/resources/Resource.js\" ; } public RegisterOptions getOptions ( ) {", "gt": "return RegisterOptions . VERSION_AND_COMPRESS ;", "prediction": "return RegisterOptions . DEFAULT ;\n", "label": 1}
{"id": 3502, "input": "<s> package org . globaleaks . android ; import android . os . Bundle ; import android . preference . PreferenceActivity ; public class Preferences extends PreferenceActivity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R .", "gt": "xml . preferences ) ;", "prediction": "resource . prefs ) ;\n", "label": 0}
{"id": 13260, "input": "<s> package org . eclipse . core . tests . session ; import java . io . PrintStream ; import java . io . PrintWriter ; import junit . framework . AssertionFailedError ; public class RemoteAssertionFailedError extends AssertionFailedError { private static final long serialVersionUID = 1L ; private Object stackText ; private String message ; public RemoteAssertionFailedError ( String message , String stackText ) { this . message = message ;", "gt": "this . stackText = stackText ;", "prediction": "this . stackText = stackText ;\n", "label": 1}
{"id": 1633, "input": "<s> package com . asakusafw . example . direct . batch ; import com . asakusafw . example . direct . jobflow . WordCountJob ; import com . asakusafw . vocabulary . batch . Batch ; import com . asakusafw . vocabulary . batch . BatchDescription ; @ Batch ( name = \"wordcount\" )", "gt": "public class WordCountBatch extends BatchDescription", "prediction": "public class WordCountJob extends Batch\n", "label": 0}
{"id": 13264, "input": "<s> package scenes ; import java . awt . Graphics ; public class Scene { protected GameSystem system ; protected HUD display ; public void start ( ) { } public void stop ( ) { } public void update ( ) { system . update ( ) ; try { Thread . sleep ( 5 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } display . update ( ) ; } public void keyPressed ( int keyCode ) { system .", "gt": "keyPressed ( keyCode ) ;", "prediction": "keyPressed ( keyCode ) ;\n", "label": 1}
{"id": 5835, "input": "<s> package javax . tools ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public final class DiagnosticCollector < S > implements DiagnosticListener < S > { private List < Diagnostic < ? extends S > > diagnostics = Collections . synchronizedList ( new ArrayList < Diagnostic < ? extends S > > ( ) ) ; public void report (", "gt": "Diagnostic < ? extends S > diagnostic )", "prediction": "S s )\n", "label": 0}
{"id": 13268, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . widgets . IDialogAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . widgets . DialogCallback ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; public class Dialog_Test extends TestCase { private static class TestDialog extends Dialog { private TestDialog ( Shell parent ) { super ( parent ) ; } private TestDialog ( Shell parent , int style ) { super ( parent , style ) ; } @ Override protected void prepareOpen ( ) { shell = new Shell ( parent ) ; } } private Display display ; private Shell shell ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConstructorWithNullParent ( ) { try { new TestDialog ( null ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertEquals ( \"Argument cannot be null\" , expected . getMessage ( ) ) ; } } public void testDefaults ( ) { Dialog dialog = new TestDialog ( shell ) ; assertSame ( shell , dialog . getParent ( ) ) ; assertEquals ( \"\" , dialog . getText ( ) ) ; assertEquals ( SWT . PRIMARY_MODAL , dialog . getStyle ( ) ) ; } public void testStyleApplicationModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . APPLICATION_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . APPLICATION_MODAL ) != 0 ) ; } public void testStylePrimaryModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . PRIMARY_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . PRIMARY_MODAL ) != 0 ) ; } public void testStyleSystemModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . SYSTEM_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . SYSTEM_MODAL ) != 0 ) ; } public void testSetText ( ) { Dialog dialog = new TestDialog ( shell ) ; dialog . setText ( \"Test\" ) ; assertEquals ( \"Test\" , dialog . getText ( ) ) ; } public void testSetTextWithNullArgument ( ) { Dialog dialog = new TestDialog ( shell ) ; try { dialog . setText ( null ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertEquals ( \"Argument cannot be null\" , expected . getMessage ( ) ) ; } } public void testConvertHorizontalDLUsToPixels ( ) { int pixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ; assertTrue ( pixels >= 10 ) ; } public void testConvertHorizontalDLUsToPixelsWithDifferentFonts ( ) { shell . setFont ( new Font ( display , \"roman\" , 10 , SWT . NORMAL ) ) ; int smallPixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ; shell . setFont ( new Font ( display , \"roman\" , 22 , SWT . NORMAL ) ) ; int largePixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ;", "gt": "assertTrue ( smallPixels < largePixels ) ;", "prediction": "shell . setFont ( new Font ( display , \"roman\" , 24 , SWT . NORMAL ) ) ;\n", "label": 1}
{"id": 4613, "input": "<s> package tayler ; import java . io . Closeable ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; public class Tailer implements Runnable { private final File file ; private final long delay ; private final boolean end ; private final TailerListener listener ; private volatile boolean run = true ; private volatile char [ ] remaind ; private volatile int remaindIndex ; private final int bufferSize ; private final byte [ ] buffer ; public Tailer ( File file , TailerListener listener ) { this ( file , listener , 1000 ) ; } public Tailer ( File file , TailerListener listener , long delay ) { this ( file , listener , delay , false ) ; } public Tailer ( File file , TailerListener listener , long delay , boolean end ) { this ( file , listener , delay , end , 1024 ) ; } public Tailer ( File file , TailerListener listener , long delay , boolean end , int bufferSize ) { this . file = file ; this . delay = delay ; this . end = end ; this . bufferSize = bufferSize ; this . buffer = new byte [ bufferSize ] ; this . remaind = new char [ bufferSize ] ; this . listener = listener ; listener . init ( this ) ; } public File getFile ( ) { return file ; } public long getDelay ( ) { return delay ; } public void run ( ) { RandomAccessFile reader = null ; try { long position = 0 ; while ( run && reader == null ) { try { reader = new RandomAccessFile ( file , \"r\" ) ; } catch ( FileNotFoundException e ) { listener . fileNotFound ( ) ; } if ( reader == null ) { try { Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { } } else { position = end ? file . length ( ) : 0 ; reader . seek ( position ) ; } } while ( run ) { long length = file . length ( ) ; boolean shorterLength = length < position ; boolean longerLength = length > position ; if ( shorterLength ) { listener . fileRotated ( ) ; try { closeQuietly ( reader ) ; reader = new RandomAccessFile ( file , \"r\" ) ; position = 0 ; } catch ( FileNotFoundException e ) { listener . fileNotFound ( ) ; } continue ; } else if ( longerLength ) { long oldPosition = position ; position = readLines ( reader ) ; if ( position == oldPosition ) { listener . error ( new IllegalStateException ( \"Illegal position, try rotating...\" ) ) ; position = Long . MAX_VALUE ; continue ; } } try { Thread . sleep ( delay ) ; } catch ( InterruptedException e ) { } } listener . stop ( ) ; } catch ( Exception e ) { listener . error ( e ) ; } finally { closeQuietly ( reader ) ; } } public void stop ( ) { this . run = false ; } private long readLines ( RandomAccessFile reader ) throws IOException { int read = reader . read ( buffer ) ; readLinesFromBuffer ( read ) ; return reader . getFilePointer ( ) ; } private void readLinesFromBuffer ( int size ) throws IOException { int read = readLineFromBuffer ( 0 , size ) ; int pos = read ; while ( pos < size ) { read = readLineFromBuffer ( pos , size ) ; pos += read ; } } private int readLineFromBuffer ( int start , int size ) throws IOException { int read = 0 ; int current = start ; int ch = 0 ; boolean eol = false ; boolean seenCR = false ; while ( current < size && ! eol ) { ch = buffer [ current ++ ] ; read ++ ; switch ( ch ) { case '\\n' : eol = true ; break ; case '\\r' : seenCR = true ; break ; default : if ( seenCR ) { remaind [ remaindIndex ++ ] = '\\r' ; seenCR = false ; } remaind [ remaindIndex ++", "gt": "] = ( char ) ch ;", "prediction": "] = '\\n' ;\n", "label": 0}
{"id": 13269, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; public class CorruptIndexException extends IOException {", "gt": "public CorruptIndexException ( String message )", "prediction": "public CorruptIndexException ( String message )\n", "label": 1}
{"id": 8007, "input": "<s> package p ; public class NestedExamples { static class MemberClass1 { } class MemberClass2 { } class Win$$AtVegas { } public Class < ? > [ ] getClasses ( ) { class LocalClass { } Object o = new Object ( ) { @ Override public String toString ( ) { return \"I have no name!\" ; } } ; return new Class < ? > [ ] { NestedExamples . class , MemberClass1 . class , MemberClass2 . class , Win$$AtVegas . class ,", "gt": "LocalClass . class , o . getClass ( ) }", "prediction": "LocalClass . class }\n", "label": 0}
{"id": 13271, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . jface . action . Separator ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . presentations . SystemMenuCloseAll ; import org . eclipse . ui . internal . presentations . SystemMenuCloseOthers ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . presentations . IStackPresentationSite ; public class StandardEditorSystemMenu extends StandardViewSystemMenu { private SystemMenuCloseOthers closeOthers ; private SystemMenuCloseAll closeAll ; private ActionFactory . IWorkbenchAction openAgain ; public StandardEditorSystemMenu ( IStackPresentationSite site ) { super ( site ) ; closeOthers = new SystemMenuCloseOthers ( site ) ; closeAll = new SystemMenuCloseAll ( site ) ; openAgain = ActionFactory . NEW_EDITOR . create ( PlatformUI", "gt": ". getWorkbench ( ) . getActiveWorkbenchWindow ( ) ) ;", "prediction": ". PLUGIN_ID ) ;\n", "label": 1}
{"id": 4218, "input": "<s> package warns ; public class Warnings { public void m0 ( ) { } public void m1 ( ) { } public void m2 ( ) { } public void m3 ( ) { } public void m4 ( ) { } public void m5 ( ) { } public void m6 ( ) { } public void m7 ( ) { } public void m8 ( ) { }", "gt": "public void m9 ( )", "prediction": "public void m9 ( )\n", "label": 0}
{"id": 13280, "input": "<s> package org . seage . aal . reporter ; import java . io . File ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . seage . data . DataNode ; import org . seage . data . xml . XmlHelper ; public class AlgorithmReport extends DataNode { private static Logger _logger = Logger . getLogger ( AlgorithmReport . class . getName ( ) ) ; private static final long serialVersionUID = - 2598529749932239606L ; private int _id ; public AlgorithmReport ( String name ) { super ( name ) ; } public int getId ( ) { return _id ; } public void setId ( int id ) { _id = id ; putValue ( \"id\" , id ) ; } public void save ( String path ) { File f = new File ( path ) ; if ( ! f . getParentFile ( ) . exists ( ) ) f .", "gt": "getParentFile ( ) . mkdirs ( ) ;", "prediction": "getParentFile ( ) . mkdirs ( ) ;\n", "label": 1}
{"id": 5207, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . selection ; import java . util . Iterator ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegionContainer ; import org . dawb . workbench . plotting . system . swtxy . translate . FigureTranslator ; import org . dawb . workbench . plotting . system . swtxy . util . Draw2DUtils ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . MouseListener ; public class RegionFillFigure extends Figure implements IRegionContainer { private IRegion region ; public RegionFillFigure ( AbstractSelectionRegion region ) { this . region = region ; } public void setMobile ( final boolean mobile ) { final FigureTranslator mover = getFigureMover ( ) ; if ( mover == null ) return ; mover . setActive ( mobile ) ; if ( mobile ) { setCursor ( Draw2DUtils . getRoiMoveCursor ( ) ) ; } else { setCursor ( null ) ; } } private FigureTranslator getFigureMover ( ) { final Iterator < ? > it = getListeners ( MouseListener . class ) ; if ( it != null && it . hasNext ( ) ) { MouseListener l = null ; while ( ( l = ( MouseListener ) it . next ( ) ) != null ) { if ( l instanceof FigureTranslator ) return ( FigureTranslator ) l ; } } return null ; } public IRegion getRegion ( ) { return region ; } public void setRegion ( IRegion region ) { this", "gt": ". region = region ;", "prediction": ". region = region ;\n", "label": 0}
{"id": 13283, "input": "<s> package fr . inria . zvtm . tests ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . event . ViewAdapter ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . ViewPanel ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . AdaptiveText ; import fr . inria . zvtm . glyphs . VRectangle ; import fr . inria . zvtm . glyphs . VText ; import java . awt . Color ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . event . MouseWheelEvent ; import java . util . Vector ; public class AdaptiveTextTest { private VirtualSpaceManager vsm = VirtualSpaceManager . INSTANCE ; private Camera cam ; AdaptiveTextTest ( ) { VirtualSpace vs = vsm . addVirtualSpace ( \"testSpace\" ) ; cam = vs . addCamera ( ) ; cam . setZoomFloor ( - 90 ) ; Vector < Camera > cameras = new Vector < Camera > ( ) ; cameras . add ( cam ) ; View view = vsm . addFrameView ( cameras , \"AdaptiveText test\" , View . STD_VIEW , 800 , 600 , false , true , true , null ) ; view . setListener ( new AdaptiveTestEventHandler ( ) ) ; AdaptiveText adt = new AdaptiveText ( 0 , 0 , 0 , Color . BLUE , \"Forty-two is six multiplied by nine.\" , 100 , 27 ) ; vs . addGlyph ( adt ) ; VRectangle rect = new VRectangle ( 0 , 0 , 0 , 100 , 27 , new Color ( 100 , 100 , 100 , 0 ) ) ; rect . setBorderColor ( Color . RED ) ; vs . addGlyph ( rect ) ; view . getGlobalView ( cam , 500 ) ; } public static void main ( String [ ] args ) { new AdaptiveTextTest ( ) ; } class AdaptiveTestEventHandler extends ViewAdapter { float ZOOM_SPEED_COEF = 1.0f / 50.0f ; double PAN_SPEED_COEF = 50.0 ; int lastJPX , lastJPY ; AdaptiveTestEventHandler ( ) { } public void press1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { lastJPX = jpx ; lastJPY = jpy ; v . setDrawDrag ( true ) ; } public void release1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { v . cams [ 0 ] . setXspeed ( 0 ) ; v . cams [ 0 ] . setYspeed ( 0 ) ; v . setDrawDrag ( false ) ; } public void mouseDragged ( ViewPanel v , int mod , int buttonNumber , int", "gt": "jpx , int jpy , MouseEvent e )", "prediction": "x , int y )\n", "label": 1}
{"id": 450, "input": "<s> package com . mobeelizer . mobile . android ; import java . math . BigInteger ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; class MobeelizerInternalDatabase { private static final String FIELD_USER = \"user\" ; private static final String FIELD_INSTANCE = \"instance\" ; private static final String FIELD_PASSWORD = \"password\" ; private static final String FIELD_ROLE = \"role\" ; private static final String FIELD_INSTANCE_GUID = \"instanceGuid\" ; private static final String FIELD_INITIAL_SYNC_REQUIRED = \"initialSyncRequired\" ; private static final String TABLE_NAME = \"roles\" ; private static final String INSTANCE_AND_USER_AND_PASSWORD = \"instance = ? and user = ? and password = ?\" ; private static final String INSTANCE_AND_USER = \"instance = ? and user = ?\" ; private final MobeelizerInternalDatabaseHelper databaseHelper ; public MobeelizerInternalDatabase ( final MobeelizerApplication application ) { this . databaseHelper = new MobeelizerInternalDatabaseHelper ( application ) ; } public boolean isInitialSyncRequired ( final String instance , final String instanceGuid , final String user ) { SQLiteDatabase database = databaseHelper . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_NAME , new String [ ] { FIELD_INITIAL_SYNC_REQUIRED , FIELD_INSTANCE_GUID } , INSTANCE_AND_USER , new String [ ] { instance , user } , null , null , null ) ; boolean initialSyncRequired = true ; if ( cursor . moveToNext ( ) && instanceGuid . equals ( cursor . getString ( cursor . getColumnIndex ( FIELD_INSTANCE_GUID ) ) ) && cursor . getInt ( cursor . getColumnIndex ( FIELD_INITIAL_SYNC_REQUIRED ) ) == 0 ) { initialSyncRequired = false ; } cursor . close ( ) ; database . close ( ) ; return initialSyncRequired ; } public void setInitialSyncAsNotRequired ( final String instance , final String user ) { SQLiteDatabase database = databaseHelper . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( FIELD_INITIAL_SYNC_REQUIRED , 0 ) ; database . update ( TABLE_NAME , values , INSTANCE_AND_USER , new String [ ] { instance , user } ) ; database . close ( ) ; } public void setRoleAndInstanceGuid ( final String instance , final String user , final String password , final String role , final String instanceGuid ) { SQLiteDatabase database = databaseHelper . getWritableDatabase ( ) ; Cursor cursor = database . query ( TABLE_NAME , new String [ ] { FIELD_ROLE } , INSTANCE_AND_USER , new String [ ] { instance , user } , null , null , null ) ; ContentValues values = new ContentValues ( ) ; values . put ( FIELD_ROLE , role ) ; values . put ( FIELD_INSTANCE_GUID , instanceGuid ) ; values . put ( FIELD_PASSWORD , getMd5 ( password ) ) ; if ( cursor . moveToNext ( ) ) { database . update ( TABLE_NAME , values , INSTANCE_AND_USER , new String [ ] { instance , user } ) ; } else { values . put ( FIELD_INSTANCE , instance ) ; values . put ( FIELD_USER , user ) ; values . put ( FIELD_INITIAL_SYNC_REQUIRED , 1 ) ; database . insert ( TABLE_NAME , null , values ) ; } cursor . close ( ) ; database . close ( ) ; } public void clearRoleAndInstanceGuid ( final String instance , final String user ) { SQLiteDatabase database = databaseHelper . getWritableDatabase ( ) ; ContentValues values = new ContentValues ( ) ; values . put ( FIELD_ROLE , ( String ) null ) ; values . put ( FIELD_INSTANCE_GUID , ( String ) null ) ; database . update ( TABLE_NAME", "gt": ", values , INSTANCE_AND_USER , new String [ ]", "prediction": ", values , INSTANCE_AND_USER , new String [ ]\n", "label": 0}
{"id": 13285, "input": "<s> package br . org . archimedes . model ; import java . util . ArrayList ; import java . util . List ; public class Rectangle { private double x ; private double y ; private double width ; private double height ; public Rectangle ( double x1 , double y1 , double x2 , double y2 ) { this . x = Math . min ( x1 , x2 ) ; this . y = Math . min ( y1 , y2 ) ; this . width = Math . abs ( x1 - x2 ) ; this . height = Math . abs ( y1 - y2 ) ; } public List < Point > getPoints ( ) { ArrayList < Point > points = new ArrayList < Point > ( ) ; Point lowerLeft = new Point ( x , y ) ; Point upperLeft = new Point ( x , y + height ) ; Point upperRight = new Point ( x + width , y + height ) ; Point lowerRight = new Point ( x + width , y ) ; points . add ( lowerLeft ) ; points . add ( lowerRight ) ; points . add ( upperRight ) ; points . add ( upperLeft ) ; return points ; } public String toString ( ) { String s = \"(x,y,w,h) = (\" + this . x + \", \" + this . y + \", \" + this . width + \", \" + this . height + \")\" ; return s ; } public boolean equals ( Object object ) { boolean equal = ( object == this ) ; if ( ! equal && object != null && object . getClass ( ) == this . getClass ( ) ) { Rectangle rectangle = ( Rectangle ) object ; equal = getPoints ( ) . equals ( rectangle . getPoints ( ) ) ; } return equal ; } public boolean isInside ( Rectangle rectangle ) { boolean inside = x >= rectangle . x && y >= rectangle . y ; inside = inside && ( ( x - rectangle . x ) + width <= rectangle . width ) ; inside = inside && ( ( y - rectangle . y ) + height <= rectangle . height ) ; return inside ; } public boolean contains ( Point point ) { return point . getX ( ) > this . x && point . getX ( ) < this . x + this . width && point . getY ( ) > this . y && point . getY ( ) < this . y + this . height ; } public Point getLowerLeft ( ) { return new Point ( x , y ) ; } public Point getUpperRight ( ) { return new Point ( x + width , y + height ) ; } public Point getLowerRight ( ) { return new Point", "gt": "( x + width , y ) ;", "prediction": "( x , y + height ) ;\n", "label": 1}
{"id": 6616, "input": "<s> package fake . net ; public class Preferences { private Preferences ( ) { } public static final String SERVER_HOST_NAME = \"localhost\" ;", "gt": "public static final int SERVER_PORT_NO = 3778 ;", "prediction": "private Preferences ( )\n", "label": 0}
{"id": 13287, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec5 . website ; import java . util . ArrayList ; import java . util . List ; import org . restlet . ext . atom . Entry ; import org . restlet . ext . atom . Feed ; import org . restlet . ext . atom . Text ; import org . restlet . resource . Get ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; import com . sun . syndication . feed . synd . SyndContent ; import com . sun . syndication . feed . synd . SyndContentImpl ; import com . sun . syndication . feed . synd . SyndEntry ; import com . sun . syndication . feed . synd . SyndEntryImpl ; import com . sun . syndication . feed . synd . SyndFeed ; import com . sun . syndication . feed . synd . SyndFeedImpl ; public class FeedServerResource extends ServerResource { @ Get ( \"atom\" ) public Feed toAtom ( ) throws ResourceException { Feed result = new Feed ( ) ; result . setTitle ( new Text ( \"Homer's feed\" ) ) ; Entry entry ; for ( int i = 1 ; i < 11 ; i ++ ) { entry = new Entry ( ) ; entry . setTitle ( new Text ( \"Mail n\ufffd\" + i ) ) ; entry . setSummary ( \"Doh! This is the content of mail n\ufffd\" + i ) ; result . getEntries ( ) . add ( entry ) ; } return result ; } @ Get ( \"rss\" ) public SyndFeed toRss ( ) throws ResourceException { SyndFeed result = new SyndFeedImpl ( ) ; result . setTitle ( \"Homer's feed\" ) ; result . setDescription ( \"Homer's feed\" ) ; result . setLink ( getReference ( ) . toString ( ) ) ; List < SyndEntry > entries = new ArrayList < SyndEntry > ( ) ; result . setEntries ( entries ) ; SyndEntry entry ; SyndContent description ; for ( int i = 1 ; i < 11 ; i ++ ) { entry = new SyndEntryImpl ( ) ; entry . setTitle ( \"Mail n\ufffd\" + i ) ; description = new SyndContentImpl ( ) ; description . setValue ( \"Doh! This is the content of mail", "gt": "n\ufffd\" + i ) ;", "prediction": "n\u00ef\u00bf\u00bd\" + i ) ;\n", "label": 1}
{"id": 3136, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; import static com . sirika . httpclienthelpers . DefaultHttpClientFactory . defaultHttpClient ; import org . apache . commons . lang . Validate ; import org . apache . http . client . HttpClient ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . InputStreamSource ; public class HttpGisgraphyServer implements GisgraphyServer { private static final Logger logger = LoggerFactory . getLogger ( HttpGisgraphyServer . class ) ; private UrlGenerator urlGenerator ; private HttpClient httpClient ; public HttpGisgraphyServer ( String baseImageServiceUrl ) { this ( defaultHttpClient ( ) , defaultUrlGeneratorFor ( baseImageServiceUrl ) ) ; } public HttpGisgraphyServer ( UrlGenerator urlGenerator ) { this ( defaultHttpClient ( ) , urlGenerator ) ; } public HttpGisgraphyServer ( HttpClient httpClient , String baseImageServiceUrl ) { this ( httpClient , defaultUrlGeneratorFor ( baseImageServiceUrl ) ) ; } public HttpGisgraphyServer ( HttpClient httpClient , UrlGenerator urlGenerator ) { logger . info ( \"Creating Gisgraphy Server using , HttpClient [{}], URLGenerator [{}]\" , httpClient , urlGenerator ) ; Validate . notNull ( urlGenerator ) ; Validate . notNull ( httpClient ) ; this . urlGenerator = urlGenerator ; this . httpClient = httpClient ; } public InputStreamSource executeSearch ( GisgraphyQuery searchQuery ) { return new GisgraphyQueryCommand ( httpClient , urlGenerator , searchQuery ) . execute ( ) ; } public String generateFullTextSearchQuery ( FullTextQuery searchQuery ) { String url = urlGenerator . generateUrl ( searchQuery ) ; logger . debug ( \"getFullTextSearchQueryUrl: generated URL : {}\" , url ) ; return url ; } public void destroy ( ) throws Exception { this . httpClient . getConnectionManager ( ) . shutdown ( ) ; } private static RestfulUrlGenerator", "gt": "defaultUrlGeneratorFor ( String baseImageServiceUrl )", "prediction": "urlGeneratorFor ( String baseImageServiceUrl )\n", "label": 0}
{"id": 13288, "input": "<s> package org . eclipse . ui . internal . services ; import org . eclipse . ui . services . AbstractServiceFactory ; import org . eclipse . ui . services . IDisposable ; import org . eclipse . ui . services . IServiceLocator ; public class ServiceLocatorCreator implements IServiceLocatorCreator { public IServiceLocator createServiceLocator ( IServiceLocator", "gt": "parent , AbstractServiceFactory factory , IDisposable owner )", "prediction": "serviceLocator )\n", "label": 1}
{"id": 3201, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . OS ; import com . pagosoft . plaf . themes . ElegantGrayTheme ; import com . pagosoft . plaf . themes . SilverTheme ; import com . pagosoft . plaf . themes . VistaTheme ; import com . pagosoft . plaf . themes . NativeColorTheme ; import com . pagosoft . swing . ColorUtils ; import java . awt . Color ; import java . awt . Insets ; import java . io . * ; import java . util . * ; import java . util . regex . * ; public class ThemeFactory { public static final PgsTheme GRAY = createTheme ( \"Gray\" , new Color ( 0x7997D1 ) , new Color ( 0xABABAB ) , Color . black ) ; public static final PgsTheme YELLOW = createTheme ( \"Yellow\" , new Color ( 0xCCAA53 ) , new Color ( 0xABABAB ) , Color . black ) ; public static final PgsTheme RUBY = createTheme ( \"Ruby\" , new Color ( 244 , 10 , 66 ) , new Color ( 0xABABAB ) , Color . black ) ; public static final PgsTheme GOLD = createTheme ( \"Gold\" , new Color ( 0xFFDB29 ) ) ; public static final PgsTheme WIN = new PgsTheme ( \"Win\" , new Color ( 0x6080AC ) , new Color ( 0xFFCF31 ) , new Color ( 0xF9E089 ) , new Color ( 0x666554 ) , new Color ( 0xDCDBCB ) , new Color ( 0xF1F0E3 ) , Color . black , Color . white , getWinCustomEntries ( ) ) ; public static final PgsTheme GREEN = createTheme ( \"Green\" , new Color ( 0x986847 ) , new Color ( 0xEFEBE7 ) , Color . BLACK ) ; private static Object [ ] getWinCustomEntries ( ) { Color s2 = new Color ( 0xDCDBCB ) ; Color s3 = new Color ( 0xF1F0E3 ) ; Color p2 = new Color ( 0xF9E089 ) ; Color p3 = new Color ( 0xFFCF31 ) ; return new Object [ ] { \"Button.rolloverGradientStart\" , Color . white , \"Button.rolloverGradientEnd\" , s2 , \"Button.selectedGradientStart\" , p3 , \"Button.selectedGradientEnd\" , p2 , \"ToggleButton.rolloverGradientStart\" , Color . white , \"ToggleButton.rolloverGradientEnd\" , s2 , \"ToggleButton.selectedGradientStart\" , p3 , \"ToggleButton.selectedGradientEnd\" , p2 , \"ToolBar.gradientStart\" , s3 , \"ToolBar.gradientEnd\" , s2 , \"ToolBarButton.rolloverGradientStart\" , p3 , \"ToolBarButton.rolloverGradientEnd\" , p2 , \"ToolBarButton.selectedGradientStart\" , p2 , \"ToolBarButton.selectedGradientEnd\" , p3 , \"ScrollBar.thumb\" , p3 , \"ScrollBar.thumbHighlight\" , p3 . brighter ( ) , \"ProgressBar.gradientStart\" , p3 , \"ProgressBar.gradientEnd\" , p3 . brighter ( ) } ; } public static PgsTheme createTheme ( Color primary ) { return ThemeFactory . createTheme ( \"PgsTheme\" , primary ) ; } public static PgsTheme createTheme ( String name , Color primary ) { Color [ ] cs = ColorUtils . mixColors ( primary ) ; return new PgsTheme ( name , cs [ 2 ] , cs [ 1 ] , cs [ 0 ] , cs [ 5 ] , cs [ 4 ] , cs [ 3 ] , cs [ 8 ] , cs [ 7 ] ) ; } public static PgsTheme createTheme ( Color primary , Color secondary , Color text ) { return ThemeFactory . createTheme ( \"Custom PgsTheme\" , primary , secondary , text ) ; } public static PgsTheme getDefaultTheme ( ) { return new SilverTheme ( ) ; } public static PgsTheme createTheme ( String name , Color primary , Color secondary , Color text ) { return new PgsTheme ( name , primary . darker ( ) , primary , primary . brighter ( ) , secondary . darker ( ) , secondary , secondary . brighter ( ) , text , ColorUtils . oposite ( text ) ) ; } public static PgsTheme getTheme ( String theme ) { if ( theme == null ) { throw new IllegalArgumentException ( \"theme must not be null!\" ) ; } if ( theme . startsWith ( \"theme:\" ) ) { String name = theme . substring ( 5 ) . trim ( ) ; return ThemeFactory . getThemeByName ( name ) ; } else if ( theme . startsWith ( \"colors:\" ) ) { String colors = theme . substring ( 6 ) . trim ( ) ; return ThemeFactory . getThemeByColors ( colors ) ; } else if ( theme . startsWith ( \"res:\" ) ) { String res = theme . substring ( 4 ) . trim ( ) ; File f = new File ( res ) ; if ( f . exists ( ) ) { Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( f ) ; props . load ( fis ) ; fis . close ( ) ; return ThemeFactory . createTheme ( props ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return getDefaultTheme ( ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } else { return getDefaultTheme ( ) ; } } else if ( theme . length ( ) > 0 ) { return ThemeFactory . getThemeByName ( theme ) ; } return ThemeFactory . getDefaultTheme ( ) ; } public static PgsTheme getThemeByName ( String theme ) { theme = theme . toLowerCase ( ) ; if ( \"ruby\" . equals ( theme ) ) { return ThemeFactory . RUBY ; } else if ( \"win\" . equals ( theme ) ) { return ThemeFactory . WIN ; }", "gt": "else if ( \"yellow\" . equals ( theme ) )", "prediction": "else\n", "label": 0}
{"id": 13290, "input": "<s> package com . design ; import com . datastruct . DCHalfEdge ; import com . math . CompPoint ; import com . math . Geom ; import java . util . Vector ; public class Base extends Part { public String type ; public Base ( double width , double height , String type ) { super ( width , height ) ; this . type = type ; } public void addNotches ( double notchWidth , double notchHeight , double ribNotchOffset , int ribNum , boolean reverse ) { for ( int i = ribNum - 1 ; i >= 0 ; i -- ) { double startTheta = Geom . cartToPolar ( edges . get ( i ) . start . getX ( ) , edges . get ( i ) . start . getY ( ) ) [ 1 ] ; double alpha = 360 / ribNum ; double theta = startTheta + ( i ) * alpha ; Notch notch = new Notch ( notchWidth , notchHeight ) ; notch . rotate ( startTheta + 180 , notch . focus ) ; int after = 0 ; if ( i == 0 ) { after = ribNum - 1 ; } else { after = i - 1 ; } this . setNotch ( notch , i , after , reverse ) ; } } public void largeTabs ( double dist ) { Vector < DCHalfEdge > newEdges = new Vector < DCHalfEdge > ( ) ; for ( int i = 0 ; i < this . edges . size ( ) ; i ++ ) { DCHalfEdge newEdge = this . expandEdge ( this . edges . get ( i ) , dist ) ; DCHalfEdge rightEdge = new DCHalfEdge ( newEdge . end , new CompPoint ( this . edges . get ( i ) . end . getX ( ) , this . edges . get ( i ) . end . getY ( ) ) ) ; DCHalfEdge leftEdge = new DCHalfEdge ( newEdge . start , new CompPoint ( this . edges . get ( i ) . start . getX ( ) , this . edges . get ( i ) . start . getY ( ) ) ) ; newEdges . addElement ( rightEdge ) ; newEdges . addElement ( newEdge ) ; newEdges . addElement ( leftEdge ) ; } this . edges = newEdges ; } public double findRad ( ) { double rad = Geom . cartToPolar ( edges . get ( 0 ) . start . getX ( ) , edges . get ( 0 ) . start . getY ( ) ) [ 0 ] ; return rad ; } private void setNotch ( Notch notch , int edgeNum , int edgeNumAfter , boolean reverse ) { notch . translate ( this . edges . get ( edgeNum ) . start . getX ( ) , this . edges . get ( edgeNum ) . start . getY ( ) ) ; if ( reverse ) { notch . mergeReverse ( this , edgeNumAfter , edgeNum ) ; } else { notch . merge (", "gt": "this , edgeNumAfter , edgeNum ) ;", "prediction": "this , edgeNumAfter , edgeNum ) ;\n", "label": 1}
{"id": 9849, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface BlockTree extends StatementTree { boolean isStatic ( ) ; List < ? extends StatementTree", "gt": "> getStatements ( ) ;", "prediction": "> statements ;\n", "label": 0}
{"id": 13293, "input": "<s> package org . eclipse . rap . rwt . internal . uicallback ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyZeroInteractions ; import static org . mockito . Mockito . when ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import javax . servlet . http . HttpSession ; import javax . servlet . http . HttpSessionBindingListener ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . ServiceContext ; import org . eclipse . rap . rwt . internal . service . ServiceStore ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackManager ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackServiceHandler ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . TestRequest ; import org . eclipse . rap . rwt . testfixture . TestResponse ; import org . eclipse . rap . rwt . testfixture . internal . NoOpRunnable ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . widgets . Display ; public class UICallBackManager_Test extends TestCase { public static final String SYS_PROP_SLEEP_TIME = \"sleepTime\" ; public static final String SYS_PROP_TIMER_EXEC_DELAY = \"timerExecDelay\" ; private static final int SLEEP_TIME ; private static final int TIMER_EXEC_DELAY ; private static final String ID_1 = \"id_1\" ; private static final String ID_2 = \"id_2\" ; private static final String RUN_ASYNC_EXEC = \"run async exec|\" ; private static final Runnable EMPTY_RUNNABLE = new NoOpRunnable ( ) ; static { String sleepTimeProp = System . getProperty ( SYS_PROP_SLEEP_TIME ) ; SLEEP_TIME = sleepTimeProp == null ? 200 : Integer . parseInt ( sleepTimeProp ) ; String timerExecDelayProp = System . getProperty ( SYS_PROP_TIMER_EXEC_DELAY ) ; TIMER_EXEC_DELAY = timerExecDelayProp == null ? 5000 : Integer . parseInt ( timerExecDelayProp ) ; } private volatile String log = \"\" ; private Display display ; private UICallBackManager manager ; private UICallBackServiceHandler uiCallBackServiceHandler ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; log = \"\" ; display = new Display ( ) ; manager = UICallBackManager", "gt": ". getInstance ( ) ;", "prediction": ". getInstance ( ) ;\n", "label": 1}
{"id": 632, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class FieldValue extends StaticValue { private final String fieldName ; private final String tableName ; public FieldValue ( String fieldName ) { this ( null , fieldName ) ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public FieldValue ( String tableName , String fieldName ) { this . tableName = tableName ; this . fieldName = fieldName ; } public final String getTableName ( ) { return tableName ; } public final String getFieldName ( ) { return fieldName ; } @ Override public String getDefaultName ( ) { return fieldName ; } @ Override public boolean equals ( Object o ) { if ( o instanceof FieldValue ) { FieldValue other = ( FieldValue ) o ; return fieldName . equals ( other . fieldName ) && equalsHelper ( tableName , other . tableName ) ; } else { return false ; } } public StringBuilder appendTo ( StringBuilder sb ) { if ( tableName != null ) { sb . append", "gt": "( tableName ) . append ( '.' ) ;", "prediction": "( tableName ) ;\n", "label": 0}
{"id": 13297, "input": "<s> public class Exor extends Gate { public Exor ( int numInputs , int delay ) { super ( numInputs , delay ) ; } public boolean logic ( ) { boolean result = false ; int i = 0 ; for ( Signal s : inputSignals ) { if ( s . getValue ( ) ) { i ++ ; } }", "gt": "if ( i == 1 )", "prediction": "return result ;\n", "label": 1}
{"id": 8798, "input": "<s> public class TestBaseClass extends JavadocTester { private static final String BUG_ID = \"4197513\" ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-sourcepath\" , SRC_DIR , \"-docletpath\" , SRC_DIR , \"-doclet\" , \"BaseClass\" , SRC_DIR + FS + \"Bar.java\" , \"baz\" } ; public static void main ( String [ ] args ) { TestBaseClass tester = new TestBaseClass ( ) ; if ( run ( tester , ARGS , TEST , NEGATED_TEST ) != 0 ) { throw new Error (", "gt": "\"Javadoc failed to execute.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13298, "input": "<s> package org . nuxeo . ecm . automation . server . test ; import java . io . IOException ; import java . io . StringWriter ; import org . codehaus . jackson . JsonGenerator ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; @ Operation ( id = TestDataCapsule . ID , category = \"Test\" ) public class TestDataCapsule { public static final String ID = \"TestDataCapsule\" ; @ OperationMethod public Blob getDataCapsule ( ) throws IOException { StringWriter writer = new StringWriter ( ) ; JsonGenerator generator = JsonWriter . getFactory ( ) . createJsonGenerator ( writer ) ; generator . writeObject ( new MyObject ( ) ) ; writer . close ( ) ; String json = writer . toString ( ) ; Blob blob = new StringBlob ( json , \"application/json\" ) ;", "gt": "blob . setFilename ( ID ) ;", "prediction": "return blob ;\n", "label": 1}
{"id": 5887, "input": "<s> package net . sourceforge . users . shafiul ; public final class R { public static final class attr { } public static final class drawable { public static final int ic_launcher = 0x7f020000 ; public static final int splash_background = 0x7f020001 ; } public static final class id { public static final int analogClock1 = 0x7f060007 ; public static final int bAdd = 0x7f06000d ; public static final int bResults = 0x7f06001a ; public static final int bReturn = 0x7f060017 ; public static final int bSA = 0x7f060009 ; public static final int bSAFR = 0x7f06000a ; public static final int bSentEmail = 0x7f060006 ; public static final int bSetWall = 0x7f060011 ; public static final int bSub = 0x7f06000e ; public static final int etAction = 0x7f060004 ; public static final int etCommands = 0x7f060019 ; public static final int etEmails = 0x7f060000 ; public static final int etIntro = 0x7f060001 ; public static final int etName = 0x7f060002 ; public static final int etOutro = 0x7f060005 ; public static final int etSend = 0x7f060008 ; public static final int etThings = 0x7f060003 ; public static final int ibTakePic = 0x7f060010 ; public static final int ivReturnedPic = 0x7f06000f ; public static final int rBoth = 0x7f060016 ; public static final int rCrazy = 0x7f060014 ; public static final int rSexy = 0x7f060015 ; public static final int rgAnswers = 0x7f060013 ; public static final int tbPassword = 0x7f06001b ; public static final int tvDisplay = 0x7f06000c ; public static final int tvGot = 0x7f06000b ; public static final int tvQuestion = 0x7f060012 ; public static final int tvResults = 0x7f06001c ; public static final int tvText = 0x7f060018 ; } public static final class layout { public static final int email = 0x7f030000 ; public static final int get = 0x7f030001 ; public static final int main = 0x7f030002 ; public static final int photo = 0x7f030003 ; public static final int send = 0x7f030004 ; public static final int splash = 0x7f030005 ; public static final int text = 0x7f030006 ; } public static final class raw { public static final int splashsound = 0x7f040000 ; } public static final class string { public static final int app_name = 0x7f050001 ; public", "gt": "static final int hello = 0x7f050000 ;", "prediction": "static final int app_url = 0x7f050002 ;\n", "label": 0}
{"id": 13301, "input": "<s> package br . org . archimedes . trims ; import java . util . Collection ; import java . util . Collections ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org .", "gt": "archimedes . trims . interfaces . Trimmer ;", "prediction": "archimedes . model . Rectangle ;\n", "label": 1}
{"id": 4354, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Map ; import java . util . Arrays ; import static java . util . Collections . * ; import static com . sun . mirror . util . DeclarationVisitors . * ; public class WarnAPF implements AnnotationProcessorFactory { static class WarnAP implements AnnotationProcessor { AnnotationProcessorEnvironment env ; WarnAP ( AnnotationProcessorEnvironment env ) { this . env = env ; } public void process ( ) { Messager messager = env . getMessager ( ) ; messager . printWarning ( \"Beware the ides of March!\" ) ; for ( TypeDeclaration typeDecl : env . getSpecifiedTypeDeclarations ( ) ) { messager . printNotice ( typeDecl . getPosition ( ) , \"You are about to be warned\" ) ; messager . printWarning ( typeDecl . getPosition ( ) , \"Strange class name\" ) ; for ( AnnotationMirror annotMirror : typeDecl . getAnnotationMirrors ( ) ) { messager . printNotice ( \"MIRROR \" + annotMirror . getPosition ( ) . toString ( ) ) ; Map < AnnotationTypeElementDeclaration , AnnotationValue > map = annotMirror . getElementValues ( ) ; if ( map . keySet ( ) . size ( ) > 0 ) for", "gt": "( AnnotationTypeElementDeclaration key : map . keySet ( ) )", "prediction": "( Map . Entry < AnnotationTypeElementDeclaration , AnnotationValue > entry : map . entrySet ( ) )\n", "label": 0}
{"id": 13303, "input": "<s> package org . fuzzydb . tests . functional ; import org . junit . BeforeClass ; public class TCPBasedCRUDTest extends CRUDTest { @ BeforeClass static", "gt": "public void setNonEmbedded ( )", "prediction": "void setUp ( ) throws Exception\n", "label": 1}
{"id": 6044, "input": "<s> package org . ofbiz . minilang ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . base . util . Debug ; import org . ofbiz . minilang . method . MethodContext ; import org . w3c . dom . Element ; public class MiniLangElement { private static final String module = MiniLangElement . class . getName ( ) ; private final Object lineNumber ; protected final SimpleMethod simpleMethod ; private final String tagName ; public MiniLangElement ( Element element , SimpleMethod simpleMethod ) { this . lineNumber = element . getUserData ( \"startLine\" ) ; this . simpleMethod = simpleMethod ; this . tagName = element . getTagName ( ) . intern ( ) ; } public void gatherArtifactInfo ( ArtifactInfoContext aic ) { } public String getLineNumber ( ) { return this . lineNumber == null ? \"unknown\" : this . lineNumber . toString ( ) ; } public SimpleMethod getSimpleMethod ( ) { return this . simpleMethod ; } public String getTagName ( ) { return this . tagName ; } public void outputTraceMessage ( MethodContext methodContext , String ... messages ) { String lineSep = System . getProperty ( \"line.separator\" ) ; StringBuilder buf = new StringBuilder ( getSimpleMethod ( ) . getFileName ( ) ) ; buf . append ( \", Line \" ) . append ( getLineNumber ( ) ) . append ( \" <\" ) . append ( getTagName ( ) ) . append ( \"> element: \" ) ; for ( int i = 0 ; i < messages . length ; i ++ ) { buf . append", "gt": "( messages [ i ] ) ;", "prediction": "( messages [ i ] ) ;\n", "label": 0}
{"id": 13314, "input": "<s> package org . restlet . ext . xdb . internal ; import java . sql . Connection ; import java . util . List ; import javax . servlet . ServletConfig ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Protocol ; import org . restlet . engine . ClientHelper ; public class XdbServletWarClient extends Client { private volatile ClientHelper helper ; public XdbServletWarClient ( Context parentContext , ServletConfig config , Connection conn ) { super ( parentContext . createChildContext ( ) , ( List < Protocol > ) null ) ; getProtocols ( ) . add ( Protocol . WAR ) ; getProtocols ( ) . add ( Protocol . FILE ) ; this . helper = new XdbServletWarClientHelper ( this , config , conn ) ; } private ClientHelper getHelper ( ) { return this . helper ; } @ Override public void handle ( Request", "gt": "request , Response response )", "prediction": "request , Response response )\n", "label": 1}
{"id": 6560, "input": "<s> package org . ofbiz . minilang . method . conditional ; import java . util . Collections ; import java . util . List ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangUtil ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class CompareCondition extends MethodOperation implements Conditional { private final Compare compare ; private final FlexibleMapAccessor < Object > fieldFma ; private final FlexibleStringExpander formatFse ; private final String operator ; private final Class < ? > targetClass ; private final String type ; private final FlexibleStringExpander valueFse ; private final List < MethodOperation > elseSubOps ; private final List < MethodOperation > subOps ; public CompareCondition ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" , \"format\" , \"operator\" , \"type\" , \"value\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" , \"operator\" , \"value\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"operator\" , \"type\" ) ; MiniLangValidate . constantPlusExpressionAttributes ( simpleMethod , element , \"value\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; this . formatFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"format\" ) ) ; this . operator = element . getAttribute ( \"operator\" ) ; this . compare = Compare . getInstance ( this . operator ) ; if ( this . compare == null ) { MiniLangValidate . handleError ( \"Invalid operator \" + this . operator , simpleMethod , element ) ; } this . type = element . getAttribute ( \"type\" ) ; Class < ? > targetClass = null ; if ( ! this . type . isEmpty ( ) ) { if ( \"contains\" . equals ( this . operator ) ) { MiniLangValidate . handleError ( \"Operator \\\"contains\\\" does not support type conversions (remove the type attribute).\" , simpleMethod , element ) ; targetClass = Object . class ; } else { try { targetClass = ObjectType . loadClass ( this . type ) ; } catch ( ClassNotFoundException e ) { MiniLangValidate . handleError ( \"Invalid type \" + this . type , simpleMethod , element ) ; } } } this . targetClass = targetClass ; this . valueFse = FlexibleStringExpander . getInstance (", "gt": "element . getAttribute ( \"value\" ) ) ;", "prediction": "element . getAttribute ( \"value\" ) ) ;\n", "label": 0}
{"id": 13322, "input": "<s> package org . eclipse . core . tests . session ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketException ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import junit . framework . Test ; import junit . framework . TestResult ; import junit . framework . TestSuite ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . tests . harness . CoreTest ; public class SessionTestRunner { class Result { final static int ERROR = 2 ; final static int FAILURE = 1 ; final static int SUCCESS = 0 ; String message ; String stackTrace ; Test test ; int type ; public Result ( Test test ) { this . test = test ; } } class ResultCollector implements Runnable { private boolean finished ; private Result newResult ; private Map results = new HashMap ( ) ; ServerSocket serverSocket ; private boolean shouldRun = true ; private StringBuffer stack ; private TestResult testResult ; private int testsRun ; ResultCollector ( Test test , TestResult testResult ) throws IOException { serverSocket = new ServerSocket ( 0 ) ; this . testResult = testResult ; initResults ( test ) ; } public int getPort ( ) { return serverSocket . getLocalPort ( ) ; } public int getTestsRun ( ) { return testsRun ; } private void initResults ( Test test ) { if ( test instanceof TestSuite ) { for ( Enumeration e = ( ( TestSuite ) test ) . tests ( ) ; e . hasMoreElements ( ) ; ) initResults ( ( Test ) e . nextElement ( ) ) ; return ; } results . put ( test . toString ( ) , new Result ( test ) ) ; } public synchronized boolean isFinished ( ) { return finished ; } private synchronized void markAsFinished ( ) { finished = true ; notifyAll ( ) ; } private String parseTestId ( String message ) { if ( message . length ( ) == 0 || message . charAt ( 0 ) != '%' ) return null ; int firstComma = message . indexOf ( ',' ) ; if ( firstComma == - 1 ) return null ; int secondComma = message . indexOf ( ',' , firstComma + 1 ) ; if ( secondComma == - 1 ) secondComma = message . length ( ) ; return message . substring ( firstComma + 1 , secondComma ) ; } private void processAvailableMessages ( BufferedReader messageReader ) throws IOException { while ( messageReader . ready ( ) ) { String message = messageReader . readLine ( ) ; processMessage ( message ) ; } } private void processMessage ( String message ) { if ( message . startsWith ( \"%TESTS\" ) ) { String testId = parseTestId ( message ) ; if ( ! results . containsKey ( testId ) ) throw new IllegalStateException (", "gt": "\"Unknown test id: \" + testId ) ;", "prediction": "\"No such test: \" + testId ) ;\n", "label": 1}
{"id": 6543, "input": "<s> package org . ofbiz . pos . screen ; public interface DialogCallback {", "gt": "public void receiveDialogCb ( PosDialog dialog ) ;", "prediction": "}\n", "label": 0}
{"id": 13325, "input": "<s> package com . poetry . model ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; public class PoetryDetail extends Poetry { protected HashSet < String > tags = new HashSet < String > ( ) ; public Collection < String > getTags ( ) {", "gt": "return Collections . unmodifiableCollection ( this . tags ) ;", "prediction": "return tags ;\n", "label": 1}
{"id": 420, "input": "<s> package Liza ; import org . bukkit . entity . Entity ;", "gt": "public interface LizaEntity extends Entity", "prediction": "import org . bukkit . entity . EntityManager ;\n", "label": 0}
{"id": 13335, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Map ; abstract class TermsHashConsumer { abstract int bytesPerPosting ( ) ; abstract void createPostings ( RawPostingList [ ] postings , int start , int count ) ; abstract TermsHashConsumerPerThread addThread ( TermsHashPerThread perThread ) ; abstract void flush ( Map threadsAndFields ,", "gt": "final SegmentWriteState state ) throws IOException ;", "prediction": "int start , int count ) ;\n", "label": 1}
{"id": 670, "input": "<s> package pkg1 ; public class C7 { public UsedClass fieldInC7 ; public UsedClass", "gt": "methodInC7 ( UsedClass p )", "prediction": "fieldInC7 ;\n", "label": 0}
{"id": 13339, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"contentTypeId\" , \"documentUri\" } ) @ XmlRootElement ( name = \"DeleteContentTypeXmlDocument\" ) public class DeleteContentTypeXmlDocument { protected String listName ; protected String contentTypeId ; protected String documentUri ; public String getListName ( ) { return listName ; }", "gt": "public void setListName ( String value )", "prediction": "public String getContentTypeId ( )\n", "label": 1}
{"id": 285, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . AllocateResourceAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class AllocateResourceAttributeImpl extends", "gt": "MinimalEObjectImpl . Container implements AllocateResourceAttribute", "prediction": "MinimalEObjectImpl\n", "label": 0}
{"id": 13343, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . nodes . BoostQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . search . Query ; public class BoostQueryNodeBuilder implements StandardQueryBuilder { public BoostQueryNodeBuilder ( ) { } public Query build ( QueryNode queryNode ) throws QueryNodeException { BoostQueryNode boostNode =", "gt": "( BoostQueryNode ) queryNode ;", "prediction": "( BoostQueryNode ) queryNode ;\n", "label": 1}
{"id": 8336, "input": "<s> class BadTest2 { interface I { } interface J { } static class C implements I , J { } static class D implements I , J { } static class Main { static C c = new C ( ) ; static D d = new D ( ) ; static < A > boolean equals ( A x , A y ) { return x . equals ( y ) ; } public static void main ( String [ ] args ) {", "gt": "equals ( c , d ) ;", "prediction": "try\n", "label": 0}
{"id": 13350, "input": "<s> package io . beancounter . platform ; import com . google . inject . Inject ; import io . beancounter . platform . validation . Validations ; import org . codehaus . jackson . map . ObjectMapper ; import io . beancounter . applications . ApplicationsManager ; import io . beancounter . filter . manager . FilterManager ; import io . beancounter . filter . manager . FilterManagerException ; import io . beancounter . filter . model . Filter ; import io . beancounter . filter . model . pattern . ActivityPattern ; import io . beancounter . platform . responses . FilterPlatformResponse ; import io . beancounter . platform . responses . StringsPlatformResponse ; import javax . ws . rs . * ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . Response ; import java . io . IOException ; import java . util . Collection ; import java . util . Set ; import static io . beancounter . applications . ApplicationsManager . Action . * ; import static io . beancounter . applications . ApplicationsManager . Object . FILTER ; @ Path ( \"rest/filters\" ) @ Produces ( MediaType . APPLICATION_JSON ) public class FilterService extends JsonService { private ApplicationsManager applicationsManager ; private FilterManager filterManager ; @ Inject public FilterService ( ApplicationsManager applicationsManager , FilterManager filterManager ) { this . applicationsManager = applicationsManager ; this . filterManager = filterManager ; } @ POST @ Path ( \"/register/{name}\" ) public Response register ( @ PathParam ( \"name\" ) String name , @ FormParam ( \"description\" ) String description , @ FormParam ( \"pattern\" ) String patternJson , @ FormParam ( \"queue\" ) Set < String > queues , @ QueryParam ( \"apikey\" ) String apiKey ) { try { Validations . checkNotEmpty ( name , \"Filter name must not be empty\" ) ; Validations . checkNotEmpty ( description , \"Missing description parameter\" ) ; Validations . checkNotEmpty ( patternJson , \"Missing filter pattern JSON\" ) ; Validations . checkNotEmpty ( queues , \"You must specify at least one queue\" ) ; Validations . validateApiKey ( apiKey , applicationsManager , CREATE , FILTER ) ; } catch ( Exception ex ) { return error ( ex . getMessage ( ) ) ; } ActivityPattern pattern ; try { pattern = parse ( patternJson ) ; } catch ( IOException e ) { return error ( e , \"Error: cannot parse your input json\" ) ; } String actualName ; try { actualName = filterManager . register ( name , description , queues , pattern ) ; }", "gt": "catch ( FilterManagerException e )", "prediction": "catch ( Exception ex )\n", "label": 1}
{"id": 2218, "input": "<s> package readers ; import java . awt . Color ; import java . io . * ; import tmpimage . TmpImage ; public class PpmReader implements ImageReader { private String identifier ; private int width ; private int height ; private int maxColVal ; private TmpImage tmp ; private int [ ] tmpColors ; public PpmReader ( String pathToImage ) { this . getDatasFromFile ( pathToImage ) ; } private void getDatasFromFile ( String pathToImage ) { try { FileInputStream fstream = new FileInputStream ( pathToImage ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; int i = 0 ; int k = 0 ; while ( ( strLine = br . readLine ( ) ) != null ) { int commentFrom = strLine . indexOf ( \"#\" ) ; if ( commentFrom >= 0 ) { strLine = strLine . substring ( 0 , commentFrom ) ; } if ( strLine . equals ( \"\" ) ) continue ; String data [ ] = strLine . split ( \"\\\\s+\" ) ; if ( i == 0 ) { if ( ! data [ 0 ] . equals ( \"P3\" ) ) { System . out . println ( \"Format error: P3 needed (in \" + pathToImage + \")\" ) ; System . exit ( 1 ) ; } else identifier = data [ 0 ] ; } if ( maxColVal == 0 ) for ( int j = 0 ; j < data . length ; j ++ ) { if ( ( this . width == 0 ) && ( i != 0 ) && ( ! data [ j ] . equals ( \"\" ) ) ) this . width = Integer . parseInt ( data [ j ] ) ; else if ( ( this . height == 0 ) && ( i != 0 ) && ( ! data [ j ] . equals ( \"\" ) ) ) this . height = Integer . parseInt (", "gt": "data [ j ] ) ;", "prediction": "data [ j ] ) ;\n", "label": 0}
{"id": 13365, "input": "<s> package knowevo . myvizster . util ; import java . awt . event . ActionEvent ; import javax . swing . AbstractAction ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . ui . VizsterMenuBar ; public class ColorMapAction extends AbstractAction { private Vizster vizster ; public ColorMapAction ( Vizster vizster ) { this . vizster = vizster ; } public void actionPerformed ( ActionEvent e ) { String cmd = e", "gt": ". getActionCommand ( ) ;", "prediction": ". getActionCommand ( ) ;\n", "label": 1}
{"id": 7031, "input": "<s> package com . example . tutorial . jobflow ; import com . asakusafw . testdriver . JobFlowTestDriver ; import org . junit . Test ; public class TutorialJobFlowTest { @ Test public void testExample ( ) throws Throwable { JobFlowTestDriver driver =", "gt": "new JobFlowTestDriver ( ) ;", "prediction": "new JobFlowTestDriver ( ) ;\n", "label": 0}
{"id": 13368, "input": "<s> package br . org . archimedes . offset ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class Messages { private static final String BUNDLE_NAME = \"br.org.archimedes.offset.messages\" ; private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( BUNDLE_NAME ) ; private Messages ( ) { } public static String getString ( String key ) { try { return RESOURCE_BUNDLE", "gt": ". getString ( key ) ;", "prediction": ". getString ( key ) ;\n", "label": 1}
{"id": 3523, "input": "<s> package org . ofbiz . order . shoppingcart ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . GeneralRuntimeException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . marketing . tracking . TrackingCodeEvents ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . party . party . PartyWorker ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . webapp . stats . VisitHandler ; public class CheckOutEvents { public static final String module = CheckOutEvents . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static String cartNotEmpty ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = ShoppingCartEvents . getCartObject ( request ) ; if ( cart != null && UtilValidate . isNotEmpty ( cart . items ( ) ) ) { return \"success\" ; } else { String errMsg = UtilProperties . getMessage ( resource_error , \"checkevents.cart_empty\" , ( cart != null ? cart . getLocale ( ) : UtilHttp . getLocale ( request ) ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } } public static String setCheckOutPages ( HttpServletRequest request , HttpServletResponse response ) { if ( \"error\" . equals ( CheckOutEvents . cartNotEmpty ( request , response ) ) == true ) { return \"error\" ; } HttpSession session = request . getSession ( ) ; String curPage = request . getParameter ( \"checkoutpage\" ) ; Debug . logInfo ( \"CheckoutPage: \" + curPage , module ) ; ShoppingCart cart = ( ShoppingCart ) session . getAttribute ( \"shoppingCart\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; GenericValue userLogin = cart . getUserLogin ( ) ; if ( userLogin == null ) userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; if ( curPage == null ) { try { cart . createDropShipGroups ( dispatcher ) ; } catch ( CartItemModifyException e ) { Debug . logError ( e , module ) ; } } else if ( \"shippingoptions\" . equals ( curPage ) == true ) { cart . cleanUpShipGroups ( ) ; } CheckOutHelper checkOutHelper = new CheckOutHelper ( dispatcher , delegator , cart ) ; if ( \"shippingaddress\" . equals ( curPage ) == true ) { String shippingContactMechId = request . getParameter ( \"shipping_contact_mech_id\" ) ; String taxAuthPartyGeoIds = request . getParameter ( \"taxAuthPartyGeoIds\" ) ; String partyTaxId = request . getParameter ( \"partyTaxId\" ) ; String isExempt = request . getParameter ( \"isExempt\" ) ; List < String > errorMessages = new ArrayList < String > ( ) ; Map < String , Object > errorMaps = new HashMap < String , Object > ( ) ; for ( int shipGroupIndex = 0 ; shipGroupIndex < cart . getShipGroupSize ( ) ; shipGroupIndex ++ ) { if ( shippingContactMechId == null ) { shippingContactMechId = ( String ) request . getAttribute ( \"contactMechId\" ) ; } String supplierPartyId = ( String ) request . getAttribute ( shipGroupIndex + \"_supplierPartyId\" ) ; Map < String , ? extends Object > callResult = checkOutHelper . finalizeOrderEntryShip ( shipGroupIndex , shippingContactMechId , supplierPartyId ) ; ServiceUtil . addErrors ( errorMessages , errorMaps , callResult ) ; } if ( UtilValidate . isNotEmpty ( taxAuthPartyGeoIds ) ) { try { Map < String , ? extends Object > createCustomerTaxAuthInfoResult = dispatcher . runSync ( \"createCustomerTaxAuthInfo\" , UtilMisc . < String , Object > toMap ( \"partyId\" , cart . getPartyId ( ) , \"taxAuthPartyGeoIds\" , taxAuthPartyGeoIds , \"partyTaxId\" , partyTaxId , \"isExempt\" , isExempt , \"userLogin\" , userLogin ) ) ; ServiceUtil . getMessages ( request , createCustomerTaxAuthInfoResult , null ) ; if ( ServiceUtil . isError ( createCustomerTaxAuthInfoResult ) ) { return \"error\" ; } } catch ( GenericServiceException e ) { String errMsg = \"Error setting customer tax info: \" +", "gt": "e . toString ( ) ;", "prediction": "e . getMessage ( ) ;\n", "label": 0}
{"id": 13377, "input": "<s> package org . restlet . engine . header ; import java . io . IOException ; import java . util . Collection ; import org . restlet . data . Status ; import org . restlet . data . Warning ; import org . restlet . engine . util . DateUtils ; public class WarningReader extends HeaderReader < Warning > { public static void addValues ( Header header , Collection < Warning > collection ) { new WarningReader ( header . getValue ( ) ) . addValues ( collection ) ; } public WarningReader ( String header ) { super ( header ) ; } @ Override public Warning readValue ( ) throws IOException { Warning result = new Warning ( ) ; String code = readToken ( ) ; skipSpaces ( ) ; String agent = readRawText ( ) ; skipSpaces ( ) ; String text = readQuotedString ( ) ; skipSpaces ( ) ; String date = null ; if ( peek ( ) != - 1 ) { date = readQuotedString ( ) ; } if ( ( code == null ) || ( agent == null ) || ( text == null ) ) { throw new IOException ( \"Warning header malformed.\" ) ; } result . setStatus ( Status . valueOf ( Integer . parseInt ( code ) ) ) ;", "gt": "result . setAgent ( agent ) ;", "prediction": "result . setAgent ( agent ) ;\n", "label": 1}
{"id": 712, "input": "<s> package com . redhat . ceylon . compiler . loader . model ; import com . redhat . ceylon . compiler .", "gt": "typechecker . model . Declaration ;", "prediction": "util . * ;\n", "label": 0}
{"id": 13384, "input": "<s> package org . spliffy . server . manager ; import java . util . Date ; public class DefaultCurrentDateService implements CurrentDateService { @ Override", "gt": "public Date getNow ( )", "prediction": "public Date getCurrentDate ( )\n", "label": 1}
{"id": 2327, "input": "<s> package org . parboiled . examples . calculators ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . examples . TestNgParboiledTest ; import org . parboiled . support . ParsingResult ; import org . parboiled . test . ParboiledTest ; import org . parboiled . parserunners . ReportingParseRunner ; import org . testng . annotations . Test ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; import static org . testng . Assert . assertEquals ; public class ReportingParseRunnerTest extends TestNgParboiledTest < Integer > { private CalculatorParser1 parser = Parboiled . createParser ( CalculatorParser1 . class ) ; @ Test public void testSimpleReporting ( ) { test ( \"X1+2\" , \"Invalid input 'X', expected InputLine (line 1, pos 1):\\nX1+2\\n^\\n\" ) ; test ( \"1X+2\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 2):\\n1X+2\\n ^\\n\" ) ; test ( \"1+X2\" , \"Invalid input 'X', expected Term (line 1, pos 3):\\n1+X2\\n  ^\\n\" ) ; test ( \"1+2X\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 4):\\n1+2X\\n   ^\\n\" ) ; test ( \"1+2X*(3-4)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 4):\\n1+2X*(3-4)-5\\n   ^\\n\" ) ; test ( \"1+2*X(3-4)-5\" , \"Invalid input 'X', expected Factor (line 1, pos 5):\\n1+2*X(3-4)-5\\n    ^\\n\" ) ; test ( \"1+2*(X3-4)-5\" , \"Invalid input 'X', expected Expression (line 1, pos 6):\\n1+2*(X3-4)-5\\n     ^\\n\" ) ; test ( \"1+2*(3X-4)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or ')' (line 1, pos 7):\\n1+2*(3X-4)-5\\n      ^\\n\" ) ; test ( \"1+2*(3-X4)-5\" , \"Invalid input 'X', expected Term (line 1, pos 8):\\n1+2*(3-X4)-5\\n       ^\\n\" ) ; test ( \"1+2*(3-4X)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or ')' (line 1, pos 9):\\n1+2*(3-4X)-5\\n        ^\\n\" ) ; test ( \"1+2*(3-4)X-5\" , \"Invalid input 'X', expected '*', '/', '+', '-' or EOI (line 1, pos 10):\\n1+2*(3-4)X-5\\n         ^\\n\" ) ; test ( \"1+2*(3-4)-X5\" , \"Invalid input 'X', expected Term (line 1, pos 11):\\n1+2*(3-4)-X5\\n    ", "gt": "     ^\\n\" ) ;", "prediction": "^\\n\" ) ;\n", "label": 0}
{"id": 13388, "input": "<s> package org . jscsi . initiator . connection . state ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . datasegment . DataSegmentFactory ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . parser . datasegment . IDataSegment ; import org . jscsi . parser . datasegment . IDataSegmentIterator ; import org . jscsi . parser . datasegment . IDataSegmentIterator . IDataSegmentChunk ; import org . jscsi . parser . datasegment . OperationalTextKey ; import org . jscsi . parser . datasegment . SettingsMap ; import org . jscsi . parser . text . TextRequestParser ; public final class GetConnectionsRequestState extends AbstractState { public GetConnectionsRequestState ( final Connection initConnection ) { super ( initConnection ) ; } public final void execute ( ) throws InternetSCSIException { final ProtocolDataUnit protocolDataUnit = protocolDataUnitFactory . create ( false , true , OperationCode . TEXT_REQUEST , connection . getSetting ( OperationalTextKey . HEADER_DIGEST ) , connection . getSetting ( OperationalTextKey", "gt": ". DATA_DIGEST ) ) ;", "prediction": ". DATA_DIGEST ) ) ;\n", "label": 1}
{"id": 5725, "input": "<s> package org . ofbiz . entity . config ; import org . w3c . dom . Element ; public abstract class NamedInfo { public String name ; protected NamedInfo ( String name ) { this . name = name ; } protected", "gt": "NamedInfo ( Element element )", "prediction": "NamedInfo ( String name )\n", "label": 0}
{"id": 13390, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . Connection ; import java . sql . SQLException ; import oracle . jdbc . pool . OracleDataSource ; public class DemoConnectionFactory { public static Connection getHRConnection ( String [ ] args ) throws SQLException { return getConnection ( args , \"hr\" , \"hr\" ) ; } public static Connection getConnection ( String [ ] args , String user , String password ) throws SQLException { String url = \"jdbc:oracle:oci8:@\" ; try {", "gt": "String url1 = System . getProperty ( \"JDBC_URL\" ) ;", "prediction": "return DriverManager . getConnection ( url , user , password ) ;\n", "label": 1}
{"id": 6343, "input": "<s> package org . ofbiz . webapp . ftl ; import java . io . IOException ; import java . io . Reader ; import java . io . Writer ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import freemarker . template . SimpleHash ; import freemarker . template . Template ; import freemarker . template . WrappingTemplateModel ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . jpublish . JPublishContext ; import org . jpublish . Page ; import org . jpublish . SiteContext ; import org . jpublish . page . PageInstance ; import org . jpublish . view . ViewRenderException ; public class FreeMarkerViewRenderer extends org . jpublish . view . freemarker . FreeMarkerViewRenderer { public static final String module = FreeMarkerViewRenderer . class . getName ( ) ; public void init ( ) throws Exception { super . init ( ) ; String id = \"unknown\" ; fmConfig . setCacheStorage ( new OfbizCacheStorage ( id ) ) ; fmConfig . setSetting ( \"datetime_format\" , \"yyyy-MM-dd HH:mm:ss.SSS\" ) ; } protected Object createViewContext ( JPublishContext context , String path ) throws ViewRenderException { HttpServletRequest request = context . getRequest ( ) ; HttpServletResponse response = context . getResponse ( ) ; WrappingTemplateModel . setDefaultObjectWrapper ( FreeMarkerWorker . getDefaultOfbizWrapper ( ) ) ; Map contextMap = new HashMap ( ) ; SimpleHash root = new SimpleHash ( FreeMarkerWorker . getDefaultOfbizWrapper ( ) ) ; try { Object [ ] keys = context . getKeys ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { String key = ( String ) keys [ i ] ; Object value = context . get ( key ) ; if ( value != null ) { contextMap . put ( key , value ) ; root . put ( key , value ) ; } } root . put ( \"context\" , FreeMarkerWorker . getDefaultOfbizWrapper ( ) . wrap ( contextMap ) ) ; root . put ( \"cachedInclude\" , new JpCacheIncludeTransform ( ) ) ; FreeMarkerViewHandler . prepOfbizRoot ( root , request , response ) ; } catch ( Exception e ) { throw new ViewRenderException ( e ) ; } return root ; } public void render ( JPublishContext context , String path , Reader in , Writer out ) throws IOException , ViewRenderException { try { Page page = ( Page ) context . get ( JPublishContext . JPUBLISH_PAGE ) ; Object viewContext = createViewContext ( context , path ) ; Template template = fmConfig . getTemplate ( path , UtilHttp . getLocale ( context . getRequest ( ) ) ) ; template . setObjectWrapper ( FreeMarkerWorker . getDefaultOfbizWrapper ( ) ) ; template . process ( viewContext , out ) ; } catch ( IOException e ) { throw e ; } catch ( Exception e ) { Debug . logError ( e , \"Exception from FreeMarker\" , module ) ; throw new ViewRenderException ( e ) ; } } private Page getPage ( String path , JPublishContext context ) { Page page = null ; try { SiteContext siteContext = ( SiteContext ) context . get ( \"site\" ) ; PageInstance pi = siteContext . getPageManager ( ) . getPage ( path . substring ( path . lastIndexOf ( \":\" ) + 1 ) ) ; if ( pi", "gt": "!= null ) page = new Page ( pi ) ;", "prediction": "!= null )\n", "label": 0}
{"id": 13392, "input": "<s> package org . eclipse . ui . tests . api ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . IParameter ; import org . eclipse . core . commands . Parameterization ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . IEditorActionDelegate ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . IWorkbenchWindowActionDelegate ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . handlers . IHandlerService ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class GenericCommandActionDelegate implements IWorkbenchWindowActionDelegate , IViewActionDelegate , IEditorActionDelegate , IObjectActionDelegate , IExecutableExtension { public static final String PARM_COMMAND_ID = \"commandId\" ; private String commandId = null ; private Map parameterMap = null ; private ParameterizedCommand parameterizedCommand = null ; private IHandlerService handlerService = null ; public void dispose ( ) { handlerService = null ; parameterizedCommand = null ; parameterMap = null ; } public void run ( IAction action ) { if ( handlerService == null ) { return ; } try { if ( commandId != null ) { handlerService . executeCommand ( commandId , null ) ; } else if ( parameterizedCommand != null ) { handlerService . executeCommand ( parameterizedCommand , null ) ; } } catch ( Exception e ) { } } public void selectionChanged ( IAction action , ISelection selection ) { } public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) throws CoreException { String id", "gt": "= config . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ;", "prediction": "= config . getAttribute ( IParserTags . ID ) ;\n", "label": 1}
{"id": 7142, "input": "<s> class Casting5 { static interface Super < P > { } static class Y implements Super < Integer > { } static interface X extends Super < Double > { } static class S < L > extends Y { } static interface T < L > extends X { } public static void main ( String ... args ) { S s = null ; T t = null ; t", "gt": "= ( T ) s ;", "prediction": "= new T ( ) ;\n", "label": 0}
{"id": 13404, "input": "<s> package org . apache . lucene . store . instantiated ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . Token ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermVectorOffsetInfo ; import org . apache . lucene . search . DefaultSimilarity ; import org . apache . lucene . search . Similarity ; import org . apache . lucene . util . StringHelper ; import org . apache . lucene . util . BitVector ; public class InstantiatedIndexWriter { private PrintStream infoStream = null ; private int maxFieldLength = IndexWriter . DEFAULT_MAX_FIELD_LENGTH ; private final InstantiatedIndex index ; private final Analyzer analyzer ; private Similarity similarity = Similarity . getDefault ( ) ; private transient Set < String > fieldNameBuffer ; private Map < InstantiatedDocument , Map < FieldSetting , Map < String , TermDocumentInformationFactory > > > termDocumentInformationFactoryByDocument = new LinkedHashMap < InstantiatedDocument , Map < FieldSetting , Map < String , TermDocumentInformationFactory > > > ( 2000 ) ; private Set < InstantiatedDocument > unflushedDocuments = new HashSet < InstantiatedDocument > ( ) ; public InstantiatedIndexWriter ( InstantiatedIndex index ) throws IOException { this ( index , null ) ; } public InstantiatedIndexWriter ( InstantiatedIndex index , Analyzer analyzer ) throws IOException { this ( index , analyzer , false ) ; } public InstantiatedIndexWriter ( InstantiatedIndex index , Analyzer analyzer , boolean create ) throws IOException { this . index = index ; this . analyzer = analyzer ; fieldNameBuffer = new HashSet < String > ( ) ; if ( create ) { this . index . initialize ( ) ; } } private int mergeFactor = 2500 ; public void setMergeFactor ( int mergeFactor ) { this . mergeFactor = mergeFactor ; } public int getMergeFactor ( ) { return mergeFactor ; } public void setInfoStream ( PrintStream infoStream ) { this . infoStream = infoStream ; } public void abort ( ) throws IOException { } public void addIndexes ( IndexReader [ ] readers ) { throw new RuntimeException ( \"Not implemented\" ) ; } public PrintStream getInfoStream ( ) { return infoStream ; } public void close ( ) throws IOException { commit ( ) ; } public int docCount ( ) { return index . getDocumentsByNumber ( ) . length + unflushedDocuments . size ( ) ; } public void commit ( ) throws IOException { boolean orderedTermsDirty = false ; Set < InstantiatedTerm > dirtyTerms = new HashSet < InstantiatedTerm > ( 1000 ) ; Map < String , FieldSetting > fieldSettingsByFieldName = new HashMap < String , FieldSetting > ( ) ; for ( String fieldName : fieldNameBuffer ) { fieldSettingsByFieldName . put ( fieldName , new FieldSetting ( fieldName ) ) ; } InstantiatedDocument [ ] documentsByNumber = new InstantiatedDocument [ index . getDocumentsByNumber ( ) . length + termDocumentInformationFactoryByDocument . size ( ) ] ; System . arraycopy ( index . getDocumentsByNumber ( ) , 0 , documentsByNumber , 0 , index . getDocumentsByNumber ( ) . length ) ; int documentNumber = index . getDocumentsByNumber ( ) . length ; List < InstantiatedTerm > orderedTerms = new ArrayList < InstantiatedTerm > ( index . getOrderedTerms ( ) . length + 5000 ) ; for ( InstantiatedTerm instantiatedTerm : index . getOrderedTerms ( ) ) { orderedTerms . add ( instantiatedTerm ) ; } Map < String , byte [ ] > normsByFieldNameAndDocumentNumber = new HashMap < String , byte [ ] > ( index . getTermsByFieldAndText ( ) . size ( ) ) ; Set < String > fieldNames = new HashSet < String > ( 20 ) ; fieldNames . addAll ( index . getNormsByFieldNameAndDocumentNumber ( ) . keySet ( ) ) ; fieldNames . addAll ( fieldNameBuffer ) ; for ( String field : index . getTermsByFieldAndText ( ) . keySet ( ) ) { byte [ ] norms = new byte [ index . getDocumentsByNumber ( ) . length + termDocumentInformationFactoryByDocument . size ( ) ] ; byte [ ] oldNorms = index . getNormsByFieldNameAndDocumentNumber ( ) . get ( field ) ; if ( oldNorms != null ) { System . arraycopy ( oldNorms , 0 , norms , 0 , oldNorms . length ) ; Arrays . fill ( norms , oldNorms . length , norms . length , DefaultSimilarity . encodeNorm ( 1.0f ) ) ; } else { Arrays . fill ( norms , 0 , norms . length , DefaultSimilarity . encodeNorm ( 1.0f ) ) ; } normsByFieldNameAndDocumentNumber . put ( field , norms ) ; fieldNames . remove ( field ) ; } for ( String field : fieldNames ) { byte [ ] norms = new byte [ index . getDocumentsByNumber ( ) . length + termDocumentInformationFactoryByDocument . size ( ) ] ; Arrays . fill ( norms , 0 , norms . length , DefaultSimilarity . encodeNorm ( 1.0f ) ) ; normsByFieldNameAndDocumentNumber . put ( field , norms ) ; } fieldNames . clear ( ) ; index . setNormsByFieldNameAndDocumentNumber ( normsByFieldNameAndDocumentNumber ) ; for ( Map . Entry < InstantiatedDocument , Map < FieldSetting , Map < String , TermDocumentInformationFactory > > > eDocumentTermDocInfoByTermTextAndField : termDocumentInformationFactoryByDocument . entrySet ( ) ) { InstantiatedDocument document = eDocumentTermDocInfoByTermTextAndField . getKey ( ) ; document . setDocumentNumber ( documentNumber ++ ) ; documentsByNumber [", "gt": "document . getDocumentNumber ( ) ] = document ;", "prediction": "documentNumber ] = document ;\n", "label": 1}
{"id": 6336, "input": "<s> package com . matburt . mobileorg . test . Synchronizers ; import java . util . ArrayList ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgNodeDate ; import android . test . AndroidTestCase ; public class CalendarSyncServiceTest extends AndroidTestCase { public void testOrgNodePayloadGetDates ( ) { OrgNode node = new OrgNode ( ) ; node . setPayload ( \"<2012-09-13 Thu>\" ) ; ArrayList < OrgNodeDate > dates = node . getOrgNodePayload ( ) . getDates ( ) ; assertEquals ( 1 , dates", "gt": ". size ( ) ) ;", "prediction": ". size ( ) ) ;\n", "label": 0}
{"id": 13410, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . _TestUtil ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . Index ; import org . apache . lucene . document . Field . Store ; import org . apache . lucene . document . Field . TermVector ; import org . apache . lucene . index . IndexWriter . MaxFieldLength ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . store . RAMDirectory ; public class TestParallelReaderEmptyIndex extends LuceneTestCase { public void testEmptyIndex ( ) throws IOException { RAMDirectory rd1 = new MockRAMDirectory ( ) ; IndexWriter iw = new IndexWriter ( rd1 , new SimpleAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; iw . close ( ) ; RAMDirectory rd2 = new MockRAMDirectory ( rd1 ) ; RAMDirectory rdOut = new MockRAMDirectory ( ) ; IndexWriter iwOut = new IndexWriter ( rdOut , new SimpleAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; ParallelReader pr = new ParallelReader ( ) ; pr . add ( IndexReader . open ( rd1 , true ) ) ; pr . add ( IndexReader . open ( rd2 , true ) ) ; iwOut . addIndexes ( new IndexReader [ ] { pr } ) ; iwOut . optimize ( ) ; iwOut . close ( ) ; _TestUtil . checkIndex ( rdOut ) ; rdOut . close ( ) ; rd1 . close ( ) ; rd2 . close ( ) ; } public void testEmptyIndexWithVectors ( ) throws IOException { RAMDirectory rd1 = new MockRAMDirectory ( ) ; { IndexWriter iw = new IndexWriter ( rd1 , new SimpleAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"test\" , \"\" , Store . NO , Index . ANALYZED , TermVector . YES ) ) ; iw . addDocument ( doc ) ; doc . add ( new Field ( \"test\" , \"\" , Store . NO , Index . ANALYZED , TermVector . NO ) ) ; iw . addDocument ( doc ) ; iw . close ( ) ; IndexReader ir = IndexReader . open ( rd1 , false ) ; ir . deleteDocument ( 0 ) ; ir . close ( ) ; iw = new IndexWriter ( rd1 , new SimpleAnalyzer ( ) , false , MaxFieldLength . UNLIMITED ) ; iw . optimize ( ) ; iw . close ( ) ; } RAMDirectory rd2 = new MockRAMDirectory ( ) ; { IndexWriter iw = new IndexWriter ( rd2 , new SimpleAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; Document doc = new Document ( ) ; iw . addDocument ( doc ) ; iw . close ( ) ; } RAMDirectory rdOut = new MockRAMDirectory ( ) ; IndexWriter iwOut = new IndexWriter ( rdOut , new SimpleAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; ParallelReader pr = new ParallelReader ( ) ; pr . add ( IndexReader . open", "gt": "( rd1 , true ) ) ;", "prediction": "( rd1 , true ) ) ;\n", "label": 1}
{"id": 10050, "input": "<s> package com . midtro . platform . io ; public class DataBuffer { byte [ ] data ; int index ; int opcode ; public DataBuffer ( final int size ) { this . data = new byte [ size ] ; } public DataBuffer ( final DataBuffer copy , final boolean cloneData ) { this . data = cloneData ? ( byte [ ] ) copy . data . clone ( ) : copy . data ; } public DataBuffer ( final byte [ ] data , final boolean cloneData ) { this . data = cloneData ? ( byte [ ] ) data . clone ( ) : data ; } public byte [ ] getData ( ) { return data ; } public void setData ( final byte [ ] data ) { this . data = data ; } public int getIndex ( ) { return index ; } public int getSize ( ) { return data . length ; } public int getRemaining ( ) { return data . length - index ; } public DataBuffer copy ( ) { return new DataBuffer ( this , true ) ; }", "gt": "public int getOpcode ( )", "prediction": "}\n", "label": 0}
{"id": 13412, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse . emf . ecore . EObject ; public interface TextPart extends EObject { String getText ( ) ; void setText", "gt": "( String value ) ;", "prediction": "( String text ) ;\n", "label": 1}
{"id": 8582, "input": "<s> package org . ofbiz . order . order ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . content . data . DataResourceWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import javolution . util . FastMap ; public class OrderEvents { public static final String module = OrderEvents . class . getName ( ) ; public static String downloadDigitalProduct ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( ) ; ServletContext application = session . getServletContext ( ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; String dataResourceId = request . getParameter ( \"dataResourceId\" ) ; try { List < GenericValue > orderRoleAndProductContentInfoList = delegator . findByAnd ( \"OrderRoleAndProductContentInfo\" , UtilMisc . toMap ( \"partyId\" , userLogin . get ( \"partyId\" ) , \"dataResourceId\" , dataResourceId , \"productContentTypeId\" , \"DIGITAL_DOWNLOAD\" , \"statusId\" , \"ITEM_COMPLETED\" ) , null , false ) ; if ( orderRoleAndProductContentInfoList . size ( ) == 0 ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , \"No record of purchase for digital download found (dataResourceId=[\" + dataResourceId + \"]).\" ) ; return \"error\" ; } GenericValue orderRoleAndProductContentInfo = orderRoleAndProductContentInfoList . get ( 0 ) ; if ( orderRoleAndProductContentInfo . getString ( \"mimeTypeId\" ) != null ) { response . setContentType ( orderRoleAndProductContentInfo . getString ( \"mimeTypeId\" ) ) ; } OutputStream os = response . getOutputStream ( ) ; DataResourceWorker . streamDataResource ( os , delegator , dataResourceId , \"\" , application . getInitParameter ( \"webSiteId\" ) , UtilHttp . getLocale ( request ) , application . getRealPath ( \"/\" ) ) ; os . flush ( ) ; } catch ( GenericEntityException e ) { String errMsg = \"Error downloading digital product content: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } catch ( GeneralException e ) { String errMsg = \"Error downloading digital product content: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } catch ( IOException e ) { String errMsg = \"Error downloading digital product content: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } return \"success\" ; } public static String cancelSelectedOrderItems ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; Delegator delegator = ( Delegator ) request", "gt": ". getAttribute ( \"delegator\" ) ;", "prediction": ". getAttribute ( \"delegator\" ) ;\n", "label": 0}
{"id": 13413, "input": "<s> package com . google . code . microlog4android ; import static org . junit . Assert . assertTrue ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class StopWatchTest { private StopWatch stopWatch ; @ Before public void setup ( ) { stopWatch = new StopWatch ( ) ; stopWatch . start ( ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } @ After public void teardown ( ) { stopWatch . reset ( ) ; } @ Test public void testStartAndGetCurrentTime ( ) { long returnedTime = stopWatch . getCurrentTime ( ) ; assertTrue ( returnedTime >= 100 ) ; } @ Test", "gt": "public void testStop ( )", "prediction": "public void testGetCurrentTime ( )\n", "label": 1}
{"id": 3468, "input": "<s> package org . stratum0 . statuswidget ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . GregorianCalendar ; import org . apache . http . HttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . DefaultHttpClient ; import org . json . JSONObject ; import android . app . PendingIntent ; import android . appwidget . AppWidgetManager ; import android . appwidget . AppWidgetProvider ; import android . content . Context ; import android . content . Intent ; import android . net . wifi . WifiInfo ; import android . net . wifi . WifiManager ; import android . widget . RemoteViews ; import android . util . Log ; import android . app . NotificationManager ; import android . app . Notification ; public class StratumsphereStatusProvider extends AppWidgetProvider { private static final String TAG = \"Stratum0\" ; private static final String url = \"http://status.stratum0.org/status.json\" ; private static final int nID = 1 ; @ Override public void onUpdate ( Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { WifiManager wifiManager = ( WifiManager ) context . getSystemService ( Context . WIFI_SERVICE ) ; WifiInfo wifiInfo = wifiManager . getConnectionInfo ( ) ; NotificationManager notificationManager = ( NotificationManager ) context . getSystemService ( Context . NOTIFICATION_SERVICE ) ; Notification nNotOpen = new Notification ( ) ; Intent notificationIntent = new Intent ( context , StratumsphereStatusProvider . class ) ; PendingIntent contentIntent = PendingIntent . getActivity ( context , 0 , notificationIntent , 0 ) ; nNotOpen . defaults = Notification . DEFAULT_ALL ; nNotOpen . icon = R . drawable . stratum0_unknown ; nNotOpen . tickerText = context . getText ( R . string . nNotOpen ) ; nNotOpen . when = System . currentTimeMillis ( ) ; nNotOpen . defaults = Notification . DEFAULT_ALL ; nNotOpen . setLatestEventInfo ( context , \"Warnung!\" , \"Schnell den Space im IRC als offen makieren.\" , contentIntent ) ; RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . main ) ; int currentImage = R . drawable . stratum0_unknown ; for ( int i = 0 ; i < appWidgetIds . length ; i ++ ) { int appWidgetId = appWidgetIds [ i ] ; String updatingText = \"updating ...\\n\" ; views . setTextViewText ( R . id . lastUpdateTextView , updatingText ) ; appWidgetManager . updateAppWidget ( appWidgetId , views ) ; } String jsonText = getStatusFromJSON ( ) ; Date now = new GregorianCalendar ( ) . getTime ( ) ; String upTimeText = \"\" ; String text = String . format ( \"Updated:\\n%02d:%02d\" , now . getHours ( ) , now . getMinutes ( ) ) ; if ( jsonText . startsWith ( \"{\" ) && jsonText . endsWith ( \"}\" ) ) { try { JSONObject jsonObject = new JSONObject ( jsonText ) ; String upTime = jsonObject . getString ( \"since\" ) ; SimpleDateFormat", "gt": "f = new SimpleDateFormat ( \"yyyy-MM-dd'T'HH:mm:ss\" ) ;", "prediction": "sdf = new SimpleDateFormat ( \"yyyy-MM-dd HH:mm:ss\" ) ;\n", "label": 0}
{"id": 13414, "input": "<s> package com . yahoo . ycsb . db ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . UnknownHostException ; import java . util . LinkedList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import net . spy . memcached . CASResponse ; import net . spy . memcached . MemcachedClient ; import com . yahoo . ycsb . memcached . Memcached ; public class MembaseClient extends Memcached { MemcachedClient client ; public static final String VERBOSE = \"memcached.verbose\" ; public static final String VERBOSE_DEFAULT = \"true\" ; public static final String SIMULATE_DELAY = \"memcached.simulatedelay\" ; public static final String SIMULATE_DELAY_DEFAULT = \"0\" ; public static final String MEMCACHED_ADDRESS = \"memcached.address\" ; public static final String MEMCACHED_ADDRESS_DEFAULT = \"10.2.1.67\" ; public static final String MEMBASE_BUCKET = \"membase.bucket\" ; public static final String MEMBASE_BUCKET_DEFAULT = \"default\" ; public static final String MEMBASE_PASSWORD = \"membase.password\" ; public static final String MEMBASE_PASSWORD_DEFAULT = \"\" ; public static long endtime ; Random random ; boolean verbose ; int todelay ; public MembaseClient ( ) { random = new Random ( ) ; todelay = 0 ; } public void init ( ) { String address = getProperties ( ) . getProperty ( MEMCACHED_ADDRESS , MEMCACHED_ADDRESS_DEFAULT ) ; String bucketName = getProperties ( ) . getProperty ( MEMBASE_BUCKET , MEMBASE_BUCKET_DEFAULT ) ; String password = getProperties ( ) . getProperty ( MEMBASE_PASSWORD , MEMBASE_PASSWORD_DEFAULT ) ; verbose = Boolean . parseBoolean ( getProperties ( ) . getProperty ( VERBOSE , VERBOSE_DEFAULT ) ) ; todelay = Integer . parseInt ( getProperties ( ) . getProperty ( SIMULATE_DELAY , SIMULATE_DELAY_DEFAULT ) ) ; try { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( new URI ( \"http://\" + address + \":8091/pools\" ) ) ; client = new MemcachedClient ( uris , bucketName , password ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } } public void cleanup ( ) { if ( client . isAlive ( ) ) client . shutdown ( ) ; } @ Override public int add ( String key , Object value ) { try { if ( ! client . add ( key , 0 , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out . println ( \"ADD Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"ADD Execution\" ) ; } catch ( RuntimeException e ) { System . out . println ( \"ADD Runtime\" ) ; } return 0 ; } @ Override public int get ( String key , Object value ) { Future < Object > f = client . asyncGet ( key ) ; try { if ( f . get ( ) == null ) { System . out . println ( \"Error\" ) ; return - 1 ; } } catch ( InterruptedException e ) { System . out . println ( \"GET Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"GET Execution\" ) ; e . printStackTrace ( ) ; return - 2 ; } catch ( RuntimeException e ) { System . out . println ( \"GET Runtime\" ) ; return - 3 ; } return 0 ; } @ Override public int set ( String key , Object value ) { try { if ( ! client . set ( key , 0 , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out . println ( \"SET Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"SET Execution\" ) ; } catch ( RuntimeException e ) { System . out . println ( \"SET Runtime\" ) ; } return 0 ; } private byte [ ] ipv4AddressToByte ( String address ) { byte [ ] b = new byte [ 4 ] ; String [ ] str = address . split ( \"\\\\.\" ) ; b [ 0 ] = Integer . valueOf ( str [ 0 ] ) . byteValue ( ) ; b [ 1 ] = Integer . valueOf ( str [ 1 ] ) . byteValue ( ) ; b [ 2 ] = Integer . valueOf ( str [ 2 ] ) . byteValue ( ) ; b [ 3 ] = Integer . valueOf ( str [ 3 ] ) . byteValue ( ) ; return b ; } @ Override public int append ( String key , long cas , Object value ) { try { if ( ! client . append ( cas , key , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out . println ( \"APPEND Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"APPEND Execution\" ) ; } catch ( RuntimeException e ) { System", "gt": ". out . println ( \"APPEND Runtime\" ) ;", "prediction": ". out . println ( \"APPEND Runtime\" ) ;\n", "label": 1}
{"id": 4787, "input": "<s> package org . msl . simple . gmfmap . simplemappings . util ; import org . eclipse . emf . common . notify . Adapter ; import org . eclipse . emf . common . notify . Notifier ; import org . eclipse . emf . common . notify . impl . AdapterFactoryImpl ; import org . eclipse . emf . ecore . EObject ; import org . msl . simple . gmfmap . simplemappings . * ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimplemappingsAdapterFactory extends AdapterFactoryImpl { protected static SimplemappingsPackage modelPackage ; public SimplemappingsAdapterFactory ( ) { if ( modelPackage == null ) { modelPackage = SimplemappingsPackage . eINSTANCE ; } } @ Override public boolean isFactoryForType ( Object object ) { if ( object == modelPackage ) { return true ; } if ( object instanceof EObject ) { return ( ( EObject ) object ) . eClass ( ) . getEPackage ( ) == modelPackage ; } return false ; } protected SimplemappingsSwitch < Adapter > modelSwitch = new SimplemappingsSwitch < Adapter > ( ) { @ Override public Adapter caseSimpleMapping ( SimpleMapping object ) { return createSimpleMappingAdapter ( ) ; } @ Override public Adapter caseSimpleTopNode ( SimpleTopNode object ) { return createSimpleTopNodeAdapter ( ) ; } @ Override public Adapter caseSimpleCompartment ( SimpleCompartment object ) { return createSimpleCompartmentAdapter ( ) ; } @ Override public Adapter caseSimpleLabelNode ( SimpleLabelNode object ) { return createSimpleLabelNodeAdapter ( ) ; } @ Override public Adapter caseSimpleLinkMapping ( SimpleLinkMapping object ) { return createSimpleLinkMappingAdapter ( ) ; } @ Override public Adapter caseSimpleNode ( SimpleNode object ) { return createSimpleNodeAdapter ( ) ; } @ Override public Adapter caseSimpleParentNode ( SimpleParentNode object ) { return createSimpleParentNodeAdapter ( ) ; } @ Override public Adapter caseSimpleChildNode ( SimpleChildNode object ) { return createSimpleChildNodeAdapter ( ) ; } @ Override public Adapter caseSimpleSubNode ( SimpleSubNode object ) { return createSimpleSubNodeAdapter ( ) ; } @ Override public Adapter caseSimpleMappingElementWithFigure ( SimpleMappingElementWithFigure object ) { return createSimpleMappingElementWithFigureAdapter ( ) ; } @ Override public Adapter caseSimpleChildReference ( SimpleChildReference object ) { return createSimpleChildReferenceAdapter ( ) ; } @ Override public Adapter caseSimpleNodeReference ( SimpleNodeReference object ) { return createSimpleNodeReferenceAdapter ( ) ; } @", "gt": "Override public Adapter defaultCase ( EObject object )", "prediction": "Override public void setAdapter ( SimpleAdapter adapter )\n", "label": 0}
{"id": 13416, "input": "<s> package org . restlet . ext . oauth ; public enum GrantType { assertion ,", "gt": "authorization_code , none , password , refresh_token ;", "prediction": "revoke , revoke_not_allowed }\n", "label": 1}
{"id": 3204, "input": "<s> package com . redhat . ceylon . ceylondoc ; import java . io . IOException ; import com . redhat . ceylon . common . tool . Java7Checker ; public class Main5 { public", "gt": "static void main ( String [ ] args ) throws IOException", "prediction": "static void main ( String [ ] args ) throws Exception\n", "label": 0}
{"id": 13418, "input": "<s> package br . org . archimedes . orto ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.orto.messages\" ; public static String ActivateTooltip ; public static String DeactivateTooltip ; public static String OrtoName ; public static String OrtoOff ; public static String OrtoOn ; static { NLS . initializeMessages ( BUNDLE_NAME", "gt": ", Messages . class ) ;", "prediction": ", Messages . class ) ;\n", "label": 1}
{"id": 6408, "input": "<s> package org . ofbiz . pos . jpos . service ; import java . util . HashMap ; import java . util . Map ; import java . util . Enumeration ; import jpos . JposException ; import jpos . ScannerConst ; import jpos . services . EventCallbacks ; import jpos . events . DataEvent ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . pos . adaptor . KeyboardAdaptor ; import org . ofbiz . pos . adaptor . KeyboardReceiver ; public class ScannerKybService extends BaseService implements jpos . services . ScannerService17 , KeyboardReceiver { public static final String module = ScannerKybService . class . getName ( ) ; private static final int TYPELOC_PREFIX = 50 ; private static final int TYPELOC_SUFFIX = 60 ; private static final int TYPELOC_NONE = 99 ; protected Map < String , Integer > barcodeIdMap = new HashMap < String , Integer > ( ) ; protected byte [ ] scannedDataLabel = new byte [ 0 ] ; protected byte [ ] scannedData = new byte [ 0 ] ; protected String codeId = \"\" ; protected boolean decodeData = true ; protected boolean eventEnabled = true ; protected boolean autoDisable = false ; protected int powerState = 1 ; protected int codeLocation = TYPELOC_PREFIX ; public ScannerKybService ( ) { KeyboardAdaptor . getInstance ( this , KeyboardAdaptor . SCANNER_DATA ) ; } @ Override public void open ( String deviceName , EventCallbacks ecb ) throws JposException { super . open ( deviceName , ecb ) ; this . readCodeMap ( ) ; if ( entry . hasPropertyWithName ( \"BarcodeTypePosition\" ) ) { if ( entry . getProp ( \"BarcodeTypePosition\" ) . getValueAsString ( ) . equalsIgnoreCase ( \"suffix\" ) ) { this . codeLocation = TYPELOC_SUFFIX ; } else if ( entry . getProp ( \"BarcodeTypePosition\" ) . getValueAsString ( ) . equalsIgnoreCase ( \"prefix\" ) ) { this . codeLocation = TYPELOC_PREFIX ; } else { this . codeLocation = TYPELOC_NONE ; } } } public boolean getAutoDisable ( ) throws JposException { return this . autoDisable ; } public void setAutoDisable ( boolean b ) throws JposException { this . autoDisable = b ; } public boolean getDecodeData ( ) throws JposException { return this . decodeData ; } public void setDecodeData ( boolean b ) throws JposException { this . decodeData = b ; } public byte [ ] getScanData ( ) throws JposException { return this . scannedData ; } public byte [ ] getScanDataLabel ( ) throws JposException { if ( this . decodeData ) { return this . scannedDataLabel ; } else { return new byte [ 0 ] ; } } public int getScanDataType ( ) throws JposException { if ( codeId != null && barcodeIdMap . containsKey ( codeId ) ) { return ( barcodeIdMap . get ( codeId ) ) . intValue ( ) ; } return ScannerConst . SCAN_SDT_UNKNOWN ; } public void clearInput ( ) throws JposException { this . scannedDataLabel = new byte [ 0 ] ; this . scannedData = new byte [ 0 ] ; this . codeId = \"\" ; } public int getCapPowerReporting ( ) throws JposException { return 0 ; } public int getPowerNotify ( ) throws JposException { return 0 ; } public void setPowerNotify ( int i ) throws JposException { } public int getPowerState ( ) throws JposException { return 0 ; } public synchronized void receiveData ( int [ ] codes , char [ ] chars ) { String dataStr = new String ( chars ) ; this . parseScannedString ( dataStr ) ; DataEvent event = new DataEvent ( this , 0 ) ; this . fireEvent ( event ) ; } private void parseScannedString ( String str ) { if ( str == null ) { return ; } if ( str != null ) { str = str . trim ( ) ; this . scannedData = str . getBytes ( ) ; if ( this . decodeData ) { if ( this . codeLocation == TYPELOC_PREFIX ) { this . codeId = str . substring ( 0 , 1 ) . toUpperCase ( ) ; this . scannedDataLabel = str . substring ( 1 ) . getBytes ( ) ; } else if ( this . codeLocation == TYPELOC_SUFFIX ) { this . codeId = str . substring ( str . length ( ) - 1 ) ; this . scannedDataLabel = str . substring ( 0 , str . length ( ) - 1 ) . getBytes ( ) ; } else { this . codeId = \"\" ; this . scannedDataLabel = str . getBytes ( ) ; } } } } private void readCodeMap ( ) { if ( barcodeIdMap == null ) { barcodeIdMap = new HashMap < String , Integer > ( ) ; } if ( barcodeIdMap . size ( ) > 0 ) { return ; } Enumeration < String > names = UtilGenerics . cast ( entry . getPropertyNames ( ) ) ; if ( names != null ) { while ( names . hasMoreElements ( ) ) { String codeType = names . nextElement ( ) ; if ( codeType . startsWith ( \"CodeType:\" ) ) { String codeValue = entry . getProp ( codeType ) . getValueAsString ( ) ; if ( \"CodeType:CODE11\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase ( ) , ScannerConst . SCAN_SDT_OTHER ) ; } else if ( \"CodeType:CODE39\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase ( ) , ScannerConst . SCAN_SDT_Code39 ) ; } else if ( \"CodeType:CODE93\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase ( ) , ScannerConst . SCAN_SDT_Code93 ) ; } else if ( \"CodeType:CODE128\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase ( ) , ScannerConst . SCAN_SDT_Code128 ) ; } else if ( \"CodeType:CODABAR\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase ( ) , ScannerConst . SCAN_SDT_Codabar ) ; } else if ( \"CodeType:I2OF5\" . equals ( codeType ) ) { barcodeIdMap . put ( codeValue . toUpperCase", "gt": "( ) , ScannerConst . SCAN_SDT_OTHER ) ;", "prediction": "( ) , ScannerConst . SCAN_SDT_I2OF5 ) ;\n", "label": 0}
{"id": 13419, "input": "<s> package org . eclipse . rap . rwt . internal . client ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import javax . servlet . http . HttpServletRequest ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . client . Client ; import org . eclipse . rap . rwt . client . WebClient ; import org . eclipse . rap . rwt . testfixture . Fixture ; public class ClientSelector_Test extends TestCase { private ClientSelector clientSelector ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; clientSelector = new ClientSelector ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testNoClientSelectedByDefault ( ) { assertNull ( clientSelector . getSelectedClient ( ) ) ; } public void testSelectsMatchingClient ( ) { Client client = mock ( Client . class ) ; clientSelector . addClientProvider ( mockClientProvider ( true , client ) ) ; clientSelector . selectClient ( mockRequest ( ) ) ; assertSame ( client , clientSelector . getSelectedClient ( ) ) ; } public void testSelectFailsWithoutClientProviders ( ) { try { clientSelector . selectClient ( mockRequest ( ) ) ; fail ( ) ; } catch ( IllegalStateException exception ) { assertEquals ( \"No client provider found for request\" , exception . getMessage ( ) ) ; } } public void testSelectFailsWithoutMatchingClientProviders ( ) { clientSelector . addClientProvider ( mockClientProvider ( false , null ) ) ; try { clientSelector . selectClient ( mockRequest ( ) ) ; fail ( ) ; } catch ( Exception exception ) { assertEquals ( \"No client provider found for request\" , exception . getMessage ( ) ) ; } } public void testSelectsFirstMatchingClient ( ) { Client expected = mock ( Client . class ) ; clientSelector . addClientProvider ( mockClientProvider ( false , null ) ) ; clientSelector . addClientProvider ( mockClientProvider ( true , expected ) ) ; clientSelector . addClientProvider ( mockClientProvider ( true , mock ( Client . class ) ) ) ; clientSelector . selectClient ( mockRequest ( ) ) ; assertSame ( expected , clientSelector . getSelectedClient ( ) ) ; } public void testSelectedClientBuffered ( ) { ClientProvider provider = mockClientProvider ( true , mock ( Client . class ) ) ; clientSelector . addClientProvider ( provider ) ; clientSelector . selectClient ( mockRequest ( ) ) ; clientSelector . selectClient ( mockRequest ( ) ) ; verify ( provider , times ( 1 ) ) . accept ( any ( HttpServletRequest . class ) ) ; } public void testActivateInstallsWebClientProvider ( ) { clientSelector . activate ( ) ; clientSelector . selectClient ( mockRequest ( ) ) ; assertTrue ( clientSelector . getSelectedClient ( ) instanceof WebClient ) ; } public void testWebClientDoesNotOverrideOthers ( ) { Client client = mock ( Client . class ) ; clientSelector . addClientProvider ( mockClientProvider ( true , client ) ) ; clientSelector . activate ( ) ; clientSelector . selectClient ( mockRequest ( ) ) ; assertSame ( client , clientSelector . getSelectedClient ( ) ) ; } public void testFallbackToWebClient ( ) { clientSelector . addClientProvider ( mockClientProvider ( false , null ) ) ; clientSelector . activate ( ) ; clientSelector . selectClient ( mockRequest ( ) ) ; assertTrue ( clientSelector . getSelectedClient ( ) instanceof WebClient ) ; } public void testCannotActivateTwice ( ) { clientSelector . activate ( ) ; try { clientSelector . activate ( ) ; fail ( ) ; } catch ( IllegalStateException exception ) { assertEquals (", "gt": "\"ClientSelector already activated\" , exception . getMessage ( ) ) ;", "prediction": "\"No client provider found for request\" , exception . getMessage ( ) ) ;\n", "label": 1}
{"id": 8938, "input": "<s> public class MWCRand { public static void init ( int x ) { int i ; Q [ 0 ] = x ; Q [ 1 ] = x + phi ; Q [ 2 ] = x + phi + phi ; for ( i = 3 ; i < 4096 ; i ++ ) { Q [ i ] = Q [ i - 3 ] ^ Q [ i - 2 ] ^ phi ^ i ; } } public static void init ( int x , int c , int phi ) { MWCRand . c = c ; MWCRand . phi = phi ; int i ; Q [ 0 ] = x ; Q [ 1 ] = x + phi ; Q [ 2 ] = x + phi + phi ; for ( i = 3 ; i < 4096 ; i ++ ) { Q [ i ] = Q [ i - 3 ] ^ Q [ i - 2 ] ^ phi ^ i ; } } public static int rand ( ) { long t , a = 18782L ; int i = 4095 ; int x , r = 0xfffffffe ; i = ( i + 1 ) & 4095 ; t", "gt": "= a * Q [ i ] + c ;", "prediction": "= Math . random ( ) ;\n", "label": 0}
{"id": 13427, "input": "<s> package br . org . archimedes . intersectors ; import br . org . archimedes . Tester ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . intersections . interfaces . Intersector ; import br . org . archimedes . model . Point ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import static org . junit . Assert . fail ; public class ArcArcIntersectorTest extends Tester { Arc baseArc ; Intersector intersector ; @ Before public void setUp ( ) throws NullArgumentException , InvalidArgumentException { intersector = new ArcArcIntersector ( ) ; baseArc = new Arc ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , 1.0 ) , new Point ( 2.0 , 0.0 ) ) ; } @ Test public void nullArgumentsShouldThrowNullArgumentException ( ) { try { intersector . getIntersections ( baseArc , null ) ; fail ( \"The otherElement is null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } try { intersector . getIntersections ( null , baseArc ) ; fail ( \"The element is null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } try { intersector . getIntersections ( null , null ) ; fail ( \"Both elements are null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } Assert . assertTrue ( \"Threw all exceptions it should throw.\" , true ) ; } @ Test public void notIntersectingArcsShouldReturnNoIntersections ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 1.0 , 0.5 ) , new Point ( 2.0 , - 0.5 ) , new Point ( 3.0 , 0.5 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void noIntersectionPointsButWouldIfArcExtendedReturnsNoIntersections ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 4.0 , 0.0 ) , new Point ( 3.0 , 1.0 ) , new Point ( 1.0 , 1.1 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void tangentArcInsideOnLimitReturnsNoIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 1.0 , 0.9 ) , new Point ( 1.9 , 0.1 ) , new Point ( 2.0 , 0.0 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void", "gt": "tangentArcOutsideReturnsOneIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException", "prediction": "tangentArcInsideOnLimitReturnsNoIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException\n", "label": 1}
{"id": 5995, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; class ModulesClassLoader extends ClassLoader { static class CachedTOCJar { File jar ; Set < String > contents = new HashSet < String > ( ) ; Set < String > packages = new HashSet < String > ( ) ; CachedTOCJar ( File jar ) { this . jar = jar ; try { ZipFile zf = new ZipFile ( jar ) ; try { Enumeration < ? extends ZipEntry > entries = zf . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; if ( ! entry . isDirectory ( ) ) { packages . add ( getPackageName ( entry . getName ( ) ) ) ; contents . add ( entry . getName ( ) ) ; } } } finally { zf . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private String getPackageName ( String name ) { int lastSlash = name . lastIndexOf ( '/' ) ; if ( lastSlash == - 1 ) return \"\" ; return name . substring ( 0 , lastSlash ) ; } boolean containsFile ( String path ) { return contents . contains ( path ) ; } boolean containsPackage ( String path ) { return packages . contains ( path ) ; } byte [ ] getContents ( String path ) { try { ZipFile zf = new ZipFile ( jar ) ; try { ZipEntry entry = zf . getEntry ( path ) ; if ( entry != null ) return loadFile ( zf . getInputStream ( entry ) , ( int ) entry . getSize ( ) ) ; } finally { zf . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } throw new RuntimeException ( \"Missing entry: \" + path + \" in jar file: \" + jar . getPath ( ) ) ; } private byte [ ] loadFile ( InputStream inputStream , int size ) throws IOException { byte [ ] buf = new byte [ size ] ; try { int read ; int offset = 0 ; while ( offset != size && ( read = inputStream . read ( buf , offset , size - offset ) ) >= 0 ) { offset += read ; } return buf ; } finally { inputStream . close ( ) ; } } } private List < CachedTOCJar > jars = new LinkedList < CachedTOCJar > ( ) ; @ Override protected Class < ? > findClass ( String name ) throws ClassNotFoundException { String path = name . replace ( '.' , '/' ) . concat ( \".class\" ) ; for ( CachedTOCJar jar : jars ) { if ( jar . containsFile ( path ) ) { byte [ ] contents =", "gt": "jar . getContents ( path ) ;", "prediction": "jar . getContents ( ) ;\n", "label": 0}
{"id": 13430, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . MediaType ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . providers . TextCrazyPersonProvider ; import org . restlet . test . ext . jaxrs . services . resources . OwnProviderTestService ; import org . restlet . test . ext . jaxrs . util . TestUtils ; public class OwnProviderTest extends JaxRsTestCase { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) protected Application getApplication ( ) { final Application appConfig = new Application ( ) { @ Override public Set < Object > getSingletons ( ) { return ( Set ) TestUtils . createSet ( new TextCrazyPersonProvider ( ) ) ; } @ Override public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( OwnProviderTestService . class ) ; } } ; return appConfig ; } public void test1 ( ) throws Exception { final Response response = get ( ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEqualMediaType ( new MediaType ( \"text/crazy-person\" ) , response ) ; final String actualEntity", "gt": "= response . getEntity ( ) . getText ( ) ;", "prediction": "= response . getEntity ( ) . getText ( ) ;\n", "label": 1}
{"id": 5238, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . parts ; import java . util . Collections ; import java . util . List ; import org . eclipse . gef . GraphicalEditPart ; import org . eclipse . gef . Request ; import org . eclipse . gef . commands . Command ; import org . eclipse . gef . editpolicies . NonResizableEditPolicy ; import org . eclipse . gef . handles . MoveHandle ; import org . eclipse . gmf . runtime . diagram . ui . editparts . DiagramEditPart ; import org . eclipse . gmf . runtime . diagram . ui . editpolicies . EditPolicyRoles ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . policies . SimpleMappingCanonicalEditPolicy ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . policies . SimpleMappingItemSemanticEditPolicy ; public class SimpleMappingEditPart extends DiagramEditPart { public final static String MODEL_ID = \"Simplemap\" ; public static final int VISUAL_ID = 79 ; public SimpleMappingEditPart ( View view ) { super ( view ) ; } protected void createDefaultEditPolicies ( ) { super . createDefaultEditPolicies ( ) ; installEditPolicy ( EditPolicyRoles . SEMANTIC_ROLE , new SimpleMappingItemSemanticEditPolicy ( ) ) ; installEditPolicy ( EditPolicyRoles . CANONICAL_ROLE , new SimpleMappingCanonicalEditPolicy ( ) ) ; } static class NodeLabelDragPolicy extends NonResizableEditPolicy { @ SuppressWarnings ( \"rawtypes\" ) protected List createSelectionHandles ( ) { MoveHandle h = new MoveHandle ( ( GraphicalEditPart ) getHost ( ) ) ; h . setBorder ( null ) ; return Collections", "gt": ". singletonList ( h ) ;", "prediction": ". emptyList ( ) ;\n", "label": 0}
{"id": 13431, "input": "<s> package org . eclipse . rap . rwt . internal . protocol ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; import org . eclipse . rap . rwt . internal . theme . JsonArray ; import org . eclipse . rap . rwt . internal . theme . JsonValue ; final class Operation { private final String action ; private final String target ; private final Map < String , Object > details ; private final Map < String , JsonValue > properties ; Operation ( String target , String action ) { this . target = target ; this . action = action ; details = new LinkedHashMap < String , Object > ( ) ; properties = new LinkedHashMap < String , JsonValue > ( ) ; } String getTarget ( ) { return target ; } String getAction ( ) { return action ; } void appendProperty ( String key , JsonValue value ) { if ( properties . containsKey ( key ) ) { throw new IllegalArgumentException ( \"Duplicate property \" + key ) ; } properties . put ( key , value ) ; } void appendProperties ( Map < String , Object > properties ) { if ( properties != null && ! properties . isEmpty ( ) ) { Set < String > keySet = properties . keySet ( ) ; for ( String key : keySet ) { appendProperty ( key , JsonUtil . createJsonValue ( properties . get ( key ) ) ) ; } } } Object getDetail ( String key ) { return details . get ( key ) ; } void appendDetail ( String key , Object value ) { if ( details . containsKey ( key ) ) { throw new IllegalArgumentException ( \"Duplicate detail \" + key ) ; } replaceDetail ( key , value ) ; } void replaceDetail ( String key , Object value ) { details . put", "gt": "( key , value ) ;", "prediction": "( key , value ) ;\n", "label": 1}
{"id": 1254, "input": "<s> import java . awt . AWTEvent ; import java . awt . EventQueue ; import javax . swing . JOptionPane ; public class EventQueueProxy extends EventQueue { @ Override protected void dispatchEvent ( final AWTEvent newEvent ) { try { super . dispatchEvent ( newEvent ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; String message = t . getMessage ( ) ; if ( message == null || message . length ( ) == 0 ) { message = \"Fatal: \" + t . getClass ( ) ; } JOptionPane . showConfirmDialog ( null , \"Something has failed!\\n\" + \"Send crash information to Cybernetic Tiger?\\n\" + \"(This doesn't actually happen", "gt": "yet)\" , \"Uncaught Exception\" , JOptionPane . YES_NO_OPTION ) ;", "prediction": ")\\n\" + message , JOptionPane . ERROR_MESSAGE ) ;\n", "label": 0}
{"id": 13432, "input": "<s> package org . nuxeo . ecm . automation . client . jaxrs . spi ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class AsyncAutomationClient extends AbstractAutomationClient { private static final Log log = LogFactory . getLog ( AsyncAutomationClient . class ) ; protected ExecutorService async ; public AsyncAutomationClient ( String url ) { this ( url , Executors . newCachedThreadPool ( new ThreadFactory ( ) { public Thread newThread ( Runnable r ) { return new Thread ( \"AutomationAsyncExecutor\" ) ; } } ) ) ; } public AsyncAutomationClient ( String url , ExecutorService executor ) { super ( url ) ; async = executor ; } @ Override public void", "gt": "asyncExec ( Runnable runnable )", "prediction": "start ( ) throws Exception\n", "label": 1}
{"id": 4704, "input": "<s> class UseBeforeDeclaration { static { x = 100 ; int v = ( ( x ) ) = 3 ; int z = UseBeforeDeclaration . x * 2 ; Object o = new Object ( ) { void foo ( ) { x ++ ; } { x ++ ; } } ; } { j = 200 ; int n = j = 300 ; int l = this . j * 3 ; Object o = new Object ( ) { void foo ( ) { j ++ ; } {", "gt": "j = j + 1 ;", "prediction": "j ++ ;\n", "label": 0}
{"id": 13434, "input": "<s> package org . apache . lucene . util ; import java . io . Serializable ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; public abstract class AttributeImpl implements Cloneable , Serializable , Attribute { public abstract void clear ( ) ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; Class clazz = this . getClass ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; try { for ( int i = 0 ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; if ( Modifier . isStatic ( f . getModifiers ( ) ) ) continue ; f . setAccessible ( true ) ; Object value = f . get ( this ) ; if ( buffer . length ( ) > 0 ) { buffer . append ( ',' ) ; } if ( value == null ) { buffer . append ( f . getName ( ) + \"=null\" ) ; } else { buffer . append ( f . getName ( ) + \"=\" + value ) ; } } } catch ( IllegalAccessException e ) {", "gt": "throw new RuntimeException ( e ) ;", "prediction": "e . printStackTrace ( ) ;\n", "label": 1}
{"id": 6551, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . common . util . WrappedException ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EOperation ; import org . eclipse . emf . ecore . impl . EObjectImpl ; import org . eclipse . gmf . gmfgraph . Connection ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Figure ; import org . eclipse . gmf . mappings . LinkMapping ; import org . eclipse . gmf . tooldef . AbstractTool ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMappingElementWithFigure ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleLinkMappingImpl extends EObjectImpl implements SimpleLinkMapping { protected SimpleLinkMappingImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING ; } @ Override protected int eStaticFeatureCount ( ) { return 0 ; } public SimpleParentNode getParentNode ( ) { return ( SimpleParentNode ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_NODE , true ) ; } public void setParentNode ( SimpleParentNode newParentNode ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_NODE , newParentNode ) ; } public SimpleMapping getParentMapping ( ) { return ( SimpleMapping ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_MAPPING , true ) ; } public void setParentMapping ( SimpleMapping newParentMapping ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_MAPPING , newParentMapping ) ; } public SimpleNode getParent ( ) { return ( SimpleNode ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT , true ) ; } public void setParent ( SimpleNode newParent ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT , newParent ) ; } public EClass getParentMetaElement ( ) { return ( EClass ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_META_ELEMENT , true ) ; } public void setParentMetaElement ( EClass newParentMetaElement ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_META_ELEMENT , newParentMetaElement ) ; } @ SuppressWarnings ( \"unchecked\" ) public EList < SimpleChildNode > getChildren ( ) { return ( EList < SimpleChildNode > ) eGet ( SimplemappingsPackage . Literals . SIMPLE_PARENT_NODE__CHILDREN , true ) ; } public String getName ( ) { return ( String ) eGet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__NAME , true ) ; } public void setName ( String newName ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__NAME , newName ) ; } public LinkMapping getLinkMapping ( ) { return ( LinkMapping ) eGet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__LINK_MAPPING , true ) ; } public void setLinkMapping ( LinkMapping newLinkMapping ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__LINK_MAPPING , newLinkMapping ) ; } public Connection getDiagramLink ( ) { return ( Connection ) eGet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__DIAGRAM_LINK , true ) ; } public void setDiagramLink ( Connection newDiagramLink ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__DIAGRAM_LINK , newDiagramLink ) ; } public DiagramLabel getDiagramLabel ( ) { return ( DiagramLabel ) eGet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__DIAGRAM_LABEL , true ) ; } public boolean isSetDiagramLabel ( ) { return eIsSet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__DIAGRAM_LABEL ) ; } public AbstractTool getTool ( ) { return ( AbstractTool ) eGet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__TOOL , true ) ; } public boolean isSetTool ( ) { return eIsSet ( SimplemappingsPackage . Literals . SIMPLE_LINK_MAPPING__TOOL ) ; } public Figure getNodeFigure ( ) { return ( Figure ) eGet ( SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__NODE_FIGURE , true ) ; } public void setNodeFigure ( Figure newNodeFigure ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__NODE_FIGURE , newNodeFigure ) ; } public Figure getLabelFigure ( ) { return ( Figure ) eGet ( SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__LABEL_FIGURE , true ) ; } public void setLabelFigure ( Figure newLabelFigure ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__LABEL_FIGURE , newLabelFigure ) ; } @ Override public int eBaseStructuralFeatureID ( int derivedFeatureID , Class < ? > baseClass ) { if ( baseClass == SimpleParentNode . class ) { switch ( derivedFeatureID ) { case SimplemappingsPackage . SIMPLE_LINK_MAPPING__CHILDREN : return SimplemappingsPackage . SIMPLE_PARENT_NODE__CHILDREN ; default : return - 1 ; } } if ( baseClass == SimpleMappingElementWithFigure . class ) { switch ( derivedFeatureID ) { case SimplemappingsPackage . SIMPLE_LINK_MAPPING__NODE_FIGURE : return SimplemappingsPackage . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__NODE_FIGURE ; case SimplemappingsPackage . SIMPLE_LINK_MAPPING__LABEL_FIGURE", "gt": ": return SimplemappingsPackage . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__LABEL_FIGURE ;", "prediction": ": return SimplemappingsPackage . SIMPLE_LINK_MAPPING_ELEMENT_WITH_FIGURE__LABEL_FIGURE ;\n", "label": 0}
{"id": 13437, "input": "<s> package org . gatein . common . text ; @ SuppressWarnings ( \"serial\" ) public class MalformedInputException extends EncodingException { public MalformedInputException ( ) { } public MalformedInputException ( String string ) { super ( string ) ; } public MalformedInputException ( String string , Throwable throwable ) { super ( string , throwable ) ; } public MalformedInputException ( Throwable throwable ) {", "gt": "super ( throwable ) ;", "prediction": "super ( throwable ) ;\n", "label": 1}
{"id": 3749, "input": "<s> import java . io . IOException ; import java . io . Writer ; import java . util . Set ; import javax . annotation . processing . AbstractProcessor ; import javax . annotation . processing . Filer ; import javax . annotation . processing . RoundEnvironment ; import javax . annotation . processing . SupportedAnnotationTypes ; import javax . lang . model . element . Element ; import javax . lang . model . element . TypeElement ; import javax . lang . model . util . Elements ; @ SupportedAnnotationTypes ( \"TestMe\" ) public class T6413690 extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnvironment ) { TypeElement testMe = elements . getTypeElement ( TestMe . class", "gt": ". getName ( ) ) ;", "prediction": ". getName ( ) ) ;\n", "label": 0}
{"id": 13443, "input": "<s> package org . fuzzydb . server . internal . search ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . Scorer ; public class ResultsQ extends Q < NextItem > { private int resultsQAdded = 0 ; private volatile Score currentScoreThreshold ; private final int targetNumResults ; public ResultsQ ( final int maxNonMatches , final float scoreThreshold , int targetNumResults ) { this . targetNumResults = targetNumResults ; this . currentScoreThreshold = new Score ( ) { private static final long serialVersionUID = 1L ; @ Override public void add ( Scorer s , float score , Direction d ) { throw new UnsupportedOperationException ( ) ; } @ Override protected void update ( ) { this . linear = scoreThreshold ; this . nonMatches = maxNonMatches ; } } ; } @ Override final public void add ( NextItem newItem ) {", "gt": "super . add ( newItem ) ;", "prediction": "resultsQAdded ++ ;\n", "label": 1}
{"id": 2167, "input": "<s> package jns . agent ; import jns . Simulator ; import jns . element . IPHandler ; import jns . element . IPPacket ; import jns . util . IPAddr ; import jns . util . Protocols ; import jns . util . Queue ; import java . util . Enumeration ; import java . util . Hashtable ; public class SimpleGoBackN implements CL_Agent { private Hashtable m_ports ; private CL_Agent m_ip ; public SimpleGoBackN ( ) { m_ports = new Hashtable ( ) ; } public SimpleGoBackNAgent createNewAgent ( int local_port ) { SimpleGoBackNAgent newagent = new SimpleGoBackNAgent ( local_port ) ; attach ( newagent , local_port ) ; return newagent ; } public void attach ( Agent higher_level , int unique_id ) { if ( ! ( higher_level instanceof SimpleGoBackNAgent ) ) Simulator . error ( \"SimpleGoBackN can only attach SimpleGoBackNAgent\" ) ; if ( m_ports . get ( new Integer ( unique_id ) ) != null ) Simulator . error ( \"SGN can only attach one agent per port\" ) ; higher_level . attach ( this ) ; m_ports . put ( new Integer ( unique_id ) , new AgentPort ( higher_level ) ) ; } public void attach ( Agent lower_level ) { if ( ! ( lower_level instanceof IPHandler ) ) { System . out . println ( lower_level ) ; Simulator . error ( \"SGN can only run on top of IP!\" ) ; } m_ip = ( CL_Agent ) lower_level ; } public void indicate ( int status , Object indicator ) { if ( status == Agent . READY_TO_SEND ) { for ( Enumeration e = m_ports . elements ( ) ; e . hasMoreElements ( ) ; ) ( ( AgentPort ) e . nextElement ( ) ) . agent . indicate ( Agent . READY_TO_SEND , this ) ; } else if ( status == Agent . PACKET_AVAILABLE ) { IPPacket ippacket = ( IPPacket ) ( ( IPHandler ) indicator ) . read ( Protocols . SGN ) ; if ( ! ( ippacket . data instanceof SimpleGoBackNPacket ) ) Simulator . warning ( \"IP packet passed to SGN with wrong packet content\" ) ; SimpleGoBackNPacket packet = ( SimpleGoBackNPacket ) ippacket . data ; AgentPort agentport = ( AgentPort ) m_ports . get ( new Integer ( packet . destination_port ) ) ; if ( agentport == null ) { Simulator . warning ( \"SGN Packet sent to port noone's listening to\" ) ; return ; } agentport .", "gt": "packets . pushFront ( ippacket ) ;", "prediction": "sendPacket ( packet ) ;\n", "label": 0}
{"id": 13447, "input": "<s> package com . cloudera . sqoop ; import org . apache . hadoop . conf . Configuration ; public class ConnFactory extends org . apache . sqoop . ConnFactory { public static final String FACTORY_CLASS_NAMES_KEY = org . apache . sqoop . ConnFactory . FACTORY_CLASS_NAMES_KEY ; public static final String DEFAULT_FACTORY_CLASS_NAMES = org . apache . sqoop", "gt": ". ConnFactory . DEFAULT_FACTORY_CLASS_NAMES ;", "prediction": ". ConnFactory . DEFAULT_FACTORY_CLASS_NAMES ;\n", "label": 1}
{"id": 2593, "input": "<s> class X { Object m ( boolean b ) { return", "gt": "( b ? 3 : b ) ;", "prediction": "b ;\n", "label": 0}
{"id": 13449, "input": "<s> package future ; import org . lwjgl . LWJGLException ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import static org . lwjgl . opengl . GL11 . * ; public class ScissorDemo { private static final String WINDOW_TITLE = \"Scissoring!\" ; private static final int [ ] WINDOW_DIMENSIONS = { 640 , 480 } ; private static int scissorBox [ ] = { 0 , 0 , WINDOW_DIMENSIONS [ 0 ] , WINDOW_DIMENSIONS [ 1 ] } ; private static int mouseLocation [ ] = { 0 , 0 } ; private static int mouseButtonPressed = - 1 ; private static boolean scissorInverted = false ; public static void main ( String [ ] args ) { setUpDisplay ( ) ; setUpStates ( ) ; enterGameLoop ( ) ; cleanUp ( false ) ; } private static void render ( ) { glClear ( GL_COLOR_BUFFER_BIT ) ; int scissorX = scissorBox [ 0 ] ; int scissorY = scissorBox [ 1 ] ; int scissorWidth = scissorBox [ 2 ] - scissorBox [ 0 ] ; int scissorHeight = scissorBox [ 3 ] - scissorBox [ 1 ] ; if ( scissorWidth >= 0 && scissorHeight >= 0 ) { glScissor ( scissorX , scissorY , scissorWidth , scissorHeight ) ; glRectf ( - 1 , - 1 , 1 , 1 ) ; scissorInverted = false ; } else { scissorInverted = true ; } glScissor ( 0 , 0 , WINDOW_DIMENSIONS [ 0 ] , WINDOW_DIMENSIONS [ 1 ] ) ; glPushAttrib ( GL_CURRENT_BIT ) ; if ( scissorInverted ) { glColor3f ( 1 , 0 , 0 ) ; } else { glColor3f ( 0 , 1 , 0 ) ; } glBegin ( GL_POINTS ) ; glVertex2f ( scissorBox [ 0 ] / ( WINDOW_DIMENSIONS [ 0 ] / 2f ) - 1 , scissorBox [ 1 ] / ( WINDOW_DIMENSIONS [ 1 ] / 2f ) - 1 ) ; glVertex2f ( scissorBox [ 2 ] / ( WINDOW_DIMENSIONS [ 0 ] / 2f ) - 1 , scissorBox [ 3 ] / ( WINDOW_DIMENSIONS [ 1 ] / 2f ) - 1 ) ; glEnd ( ) ; glPopAttrib ( ) ; } private static void logic ( ) { if ( mouseButtonPressed == 0 ) { scissorBox [ 0 ] = mouseLocation [ 0 ] ; scissorBox [ 1 ] = mouseLocation [ 1 ] ; } else if ( mouseButtonPressed == 1 ) { scissorBox [ 2 ] = mouseLocation [ 0 ] ; scissorBox [ 3 ] = mouseLocation [ 1 ] ; } } private static void input ( ) { mouseLocation [ 0 ] = Mouse . getX ( ) ; mouseLocation [ 1 ] = Mouse . getY ( ) ; if ( Mouse . isButtonDown ( 0 ) && ! Mouse . isButtonDown ( 1 ) ) { mouseButtonPressed = 0 ; } else if ( Mouse . isButtonDown ( 1 ) && ! Mouse . isButtonDown ( 0 ) ) { mouseButtonPressed = 1 ; } else { mouseButtonPressed = - 1 ; } } private static void cleanUp ( boolean asCrash ) { Display . destroy ( ) ; System . exit ( asCrash ? 1 : 0 ) ; } private static void setUpStates ( ) { glEnable ( GL_SCISSOR_TEST ) ; glPointSize ( 25 ) ; } private static void update ( ) { Display . update ( ) ; Display . sync ( 60 ) ; } private static void enterGameLoop ( ) { while ( ! Display . isCloseRequested ( ) ) { render ( ) ; logic ( ) ; input ( ) ; update ( ) ; } } private static void setUpDisplay ( ) { try { Display . setDisplayMode ( new DisplayMode ( WINDOW_DIMENSIONS [ 0 ] , WINDOW_DIMENSIONS [ 1 ] ) ) ; Display . setVSyncEnabled ( true ) ; Display . setTitle ( WINDOW_TITLE ) ; Display", "gt": ". create ( ) ;", "prediction": ". open ( ) ;\n", "label": 1}
{"id": 4673, "input": "<s> public class T5009937 < X > { static class A { static void m ( T5009937 < String > l ) { } } static class B extends A { static void m ( T5009937", "gt": "< Integer > l )", "prediction": "< String > l )\n", "label": 0}
{"id": 13450, "input": "<s> package org . nuxeo . ecm . platform . publisher . test ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinder ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinderFactory ; public class SampleRootSectionFinderFactory implements RootSectionFinderFactory { @", "gt": "Override public RootSectionFinder getRootSectionFinder ( CoreSession session )", "prediction": "Override public void setUp ( ) throws Exception\n", "label": 1}
{"id": 9710, "input": "<s> import p1 . * ; class T6313164 { { B b = new B ( ) ; b . foo1 ( new B ( ) , new B ( ) ) ; b . foo2 ( new B ( ) , new B ( ) ) ; b .", "gt": "foo3 ( null , null ) ;", "prediction": "foo3 ( new B ( ) , new B ( ) ) ;\n", "label": 0}
{"id": 13457, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . io . Serializable ; import org . apache . lucene . index . IndexReader ; public abstract class Weight implements Serializable { public abstract Explanation explain ( IndexReader reader , int doc ) throws IOException ; public abstract Query getQuery ( ) ; public abstract float getValue ( ) ; public abstract void normalize ( float norm ) ; public abstract Scorer scorer ( IndexReader reader , boolean scoreDocsInOrder , boolean topScorer ) throws IOException ; public abstract float sumOfSquaredWeights ( ) throws IOException ;", "gt": "public boolean scoresDocsOutOfOrder ( )", "prediction": "}\n", "label": 1}
{"id": 4520, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; } public static boolean start ( RootDoc root ) { ClassDoc cd = root . classes ( ) [ 0 ] ; System . out . println ( \"*** \" + cd ) ; TypeVariable E = cd . typeParameters ( ) [ 0 ] ; System . out . println ( \"*** \" + E ) ; Type bound = E . bounds ( ) [ 0 ] ; System . out . println ( \"*** \" + bound ) ; ParameterizedType", "gt": "enumE = ( ParameterizedType ) bound ;", "prediction": "pt = ( ParameterizedType ) bound ;\n", "label": 0}
{"id": 13458, "input": "<s> package org . seage . metaheuristic . particles ; public class ParticleSwarmEvent extends java . util . EventObject { private static final long serialVersionUID = - 6183156859352794637L ;", "gt": "public ParticleSwarmEvent ( Object source )", "prediction": "public ParticleSwarmEvent ( )\n", "label": 1}
{"id": 8189, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public class AccessH1 { private static final String BUGID = \"4636667-7052425\" ; private static final String BUGNAME = \"AccessH1\" ; private static final String FS = System . getProperty ( \"file.separator\" ) ; private static final String PS = System . getProperty ( \"path.separator\" ) ; private static final String LS = System . getProperty ( \"line.separator\" ) ; private static final String TMPDEST_DIR1 = \".\" + FS + \"docs1\" + FS ; private static final String TMPDEST_DIR2 = \".\" + FS + \"docs2\" + FS ; public static int subtestNum = 0 ; public static int numSubtestsPassed = 0 ; public static void main ( String [ ] args ) { String srcdir = System . getProperty ( \"test.src\" , \".\" ) ; runJavadoc ( new String [ ] { \"-d\" , TMPDEST_DIR1 , \"-doctitle\" , \"Document Title\" , \"-sourcepath\" , srcdir , \"p1\" , \"p2\" } ) ; runTestsOnHTML ( testArray ) ; printSummary ( ) ; } public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( javadocArgs ) != 0 ) { throw new Error ( \"Javadoc failed to execute\" ) ; } } private static final String [ ] [ ] testArray = { { \"h1 {\" + LS + \"    font-size:1.8em;\" + LS + \"}\" , TMPDEST_DIR1 + \"stylesheet.css\" } , { \"<h1 class=\\\"title\\\">Document Title</h1>\" , TMPDEST_DIR1 + \"overview-summary.html\" } } ; public static void runTestsOnHTML ( String [ ] [ ] testArray ) { for ( int i = 0 ; i < testArray . length ; i ++ ) { subtestNum += 1 ; String fileString = readFileToString ( testArray [ i ] [ 1 ] ) ; String stringToFind = testArray [ i ] [ 0 ] ; if ( findString ( fileString , stringToFind ) == - 1 ) { System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" for bug \" + BUGID + \" (\" + BUGNAME + \") FAILED\\n\" + \"when searching for:\\n\" + stringToFind ) ; } else { numSubtestsPassed += 1 ; System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" passed:\\n\" + stringToFind ) ; } } } public static void printSummary ( ) { if ( numSubtestsPassed == subtestNum ) { System . out . println ( \"\\nAll \" + numSubtestsPassed + \" subtests passed\" ) ; } else { throw new Error ( \"\\n\" + ( subtestNum - numSubtestsPassed ) + \" of \" + ( subtestNum ) + \" subtests failed for bug \" + BUGID + \" (\" + BUGNAME + \")\\n\" ) ; } } public static String readFileToString ( String filename ) { try { File file = new File ( filename ) ; if ( ! file . exists ( ) ) { System . out . println ( \"\\nFILE DOES NOT EXIST: \" + filename ) ; } BufferedReader in = new BufferedReader ( new FileReader ( file ) ) ; char [ ] allChars = new char [ ( int ) file . length ( ) ] ; in . read ( allChars , 0 , ( int ) file . length ( ) ) ; in . close ( ) ; String allCharsString = new String ( allChars ) ; return allCharsString ; } catch ( FileNotFoundException e ) { System . err . println ( e ) ; return \"\" ; } catch ( IOException e ) { System .", "gt": "err . println ( e ) ;", "prediction": "err . println ( e ) ;\n", "label": 0}
{"id": 13459, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . internal . intro . IIntroConstants ; import org . eclipse . ui . views . IViewCategory ; import org . eclipse . ui . views . IViewDescriptor ; import org . eclipse . ui . views . IViewRegistry ; public class ViewContentProvider implements ITreeContentProvider { private Map childMap = new HashMap ( ) ; public ViewContentProvider ( ) { } public void dispose ( ) { childMap . clear ( ) ; } public Object [ ] getChildren ( Object element ) { Object [ ] children = ( Object [ ] ) childMap . get ( element ) ; if ( children == null ) { children = createChildren ( element ) ; childMap . put ( element , children ) ; } return children ; } private Object [ ] createChildren ( Object element ) { if ( element instanceof IViewRegistry ) { IViewRegistry reg = ( IViewRegistry ) element ; IViewCategory [ ] categories = reg . getCategories ( ) ; ArrayList filtered = new ArrayList ( ) ; for ( int i = 0 ; i < categories . length ; i ++ ) { if ( ! hasChildren ( categories [ i ] ) ) { continue ; } filtered . add ( categories [ i ] ) ; } categories = ( IViewCategory [ ] ) filtered . toArray ( new IViewCategory [ filtered . size ( ) ] ) ; if ( categories . length == 1 ) { return getChildren ( categories [ 0 ] ) ; } return categories ; } else if ( element instanceof IViewCategory ) { IViewDescriptor [ ] views = ( ( IViewCategory ) element ) . getViews ( ) ; if ( views != null ) { ArrayList filtered = new ArrayList ( ) ; for (", "gt": "int i = 0 ;", "prediction": "int i = 0 ;\n", "label": 1}
{"id": 2087, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse", "gt": ". emf . ecore . EObject ;", "prediction": ". swt . SWT ;\n", "label": 0}
{"id": 13460, "input": "<s> package org . fuzzydb . dto . attributes ; import java . io . Serializable ; public abstract class Attribute < V > implements Serializable { private static final long serialVersionUID = 1L ; private String name ; public Attribute ( String name ) { assert name != null ; this . name = name ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public", "gt": "abstract V getValueAsObject ( ) ;", "prediction": "V getValue ( )\n", "label": 1}
{"id": 7617, "input": "<s> import java . io . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class TestHtmlDocument { private static final String BUGID = \"6851834\" ; private static final String BUGNAME = \"TestHtmlDocument\" ; private static final String FS = System . getProperty ( \"file.separator\" ) ; private static final String LS = System . getProperty ( \"line.separator\" ) ; private static String srcdir = System . getProperty ( \"test.src\" , \".\" ) ; public static void main ( String [ ] args ) throws IOException { if ( generateHtmlTree ( ) . equals ( readFileToString ( srcdir + FS + \"testMarkup.html\" ) ) ) { System . out . println ( \"\\nTest passed for bug \" + BUGID + \" (\" + BUGNAME + \")\\n\" ) ; } else { throw new Error ( \"\\nTest failed for bug \" + BUGID + \" (\" + BUGNAME + \")\\n\" ) ; } } public static String generateHtmlTree ( ) { DocType htmlDocType = DocType . Transitional ( ) ; HtmlTree html = new HtmlTree ( HtmlTag . HTML ) ; HtmlTree head = new HtmlTree ( HtmlTag . HEAD ) ; HtmlTree title = new HtmlTree ( HtmlTag . TITLE ) ; StringContent titleContent = new StringContent ( \"Markup test\" ) ; title . addContent ( titleContent ) ; head . addContent ( title ) ; HtmlTree meta = new HtmlTree ( HtmlTag . META ) ; meta . addAttr ( HtmlAttr . NAME , \"keywords\" ) ; meta . addAttr ( HtmlAttr . CONTENT , \"testContent\" ) ; head . addContent ( meta ) ; HtmlTree invmeta = new HtmlTree ( HtmlTag . META ) ; head . addContent ( invmeta ) ; HtmlTree link = new HtmlTree ( HtmlTag . LINK ) ; link . addAttr ( HtmlAttr . REL , \"testRel\" ) ; link . addAttr ( HtmlAttr . HREF , \"testLink.html\" ) ; head . addContent ( link ) ; HtmlTree invlink = new HtmlTree ( HtmlTag . LINK ) ; head . addContent ( invlink ) ; html . addContent ( head ) ; Comment bodyMarker = new Comment ( \"======== START OF BODY ========\" ) ; html . addContent ( bodyMarker ) ; HtmlTree body = new HtmlTree ( HtmlTag . BODY ) ; Comment pMarker = new Comment ( \"======== START OF PARAGRAPH ========\" ) ; body . addContent ( pMarker ) ; HtmlTree p = new HtmlTree ( HtmlTag . P ) ; StringContent bodyContent = new StringContent ( \"This document is generated from sample source code and HTML \" + \"files with examples of a wide variety of Java language constructs: packages, \" + \"subclasses, subinterfaces, nested classes, nested interfaces,\" + \"inheriting from other packages, constructors, fields,\" + \"methods, and so forth. \" ) ; p . addContent ( bodyContent ) ; StringContent anchorContent = new StringContent ( \"Click Here\" ) ; p . addContent ( HtmlTree . A ( \"testLink.html\" , anchorContent ) ) ; StringContent pContent = new StringContent ( \" to <test> out a link.\" ) ; p . addContent ( pContent ) ; body . addContent ( p ) ; HtmlTree p1 = new HtmlTree ( HtmlTag . P ) ; HtmlTree anchor = new HtmlTree", "gt": "( HtmlTag . A ) ;", "prediction": "( HtmlTag . anchor ) ;\n", "label": 0}
{"id": 13462, "input": "<s> package vanilla . java . affinity . impl ; import org . junit . Assume ; import org . junit . BeforeClass ; import vanilla . java . affinity . IAffinity ; public class NativeAffinityTest extends AbstractAffinityImplTest { @ BeforeClass public static void checkJniLibraryPresent ( ) {", "gt": "Assume . assumeTrue ( NativeAffinity . LOADED ) ;", "prediction": "try\n", "label": 1}
{"id": 6029, "input": "<s> package com . gisgraphy . client . gisfeature ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import com . gisgraphy . client . commons . NameProvider ; import com . gisgraphy . client . language . Iso639Language ; import com . google . common . collect . ImmutableSet ; import com . vividsolutions . jts . geom . Point ; public interface GisFeature extends NameProvider { Long getGeonamesId ( ) ; GisFeature getGisFeature ( ) ; Long getElevation ( ) ; Long getGtopo30AverageElevation ( ) ; Point getLocation ( ) ; double getLatitude ( ) ; double getLongitude ( ) ;", "gt": "Long getPopulation ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13463, "input": "<s> package com . symbol8 . moneytracker ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import com . symbol8 . moneytracker . domain . Account ; import com . symbol8 . moneytracker . domain . Transaction ; import com . symbol8 . moneytracker . domain . Transaction . Type ; public class AccountService { private static final Account CREDIT_CARD_ACCOUNT = new Account ( \"**** **** **** 7688\" ) ; private static final Account EVERY_DAY_ACCOUNT = new Account ( \"03 0881 0047975 000\" ) ; public List < Account > getAccounts ( ) { List < Account > accounts = new ArrayList < Account > ( ) ; accounts . add ( CREDIT_CARD_ACCOUNT ) ; accounts . add ( EVERY_DAY_ACCOUNT ) ; return accounts ; } public List < Transaction > getFilteredTransactions ( Account account , Calendar filterDate ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; if ( CREDIT_CARD_ACCOUNT . equals ( account ) ) { trans . addAll ( filter ( getCreditCardSavings ( ) , filterDate ) ) ; trans . addAll ( filter ( getCreditCardAprTransactions ( ) , filterDate ) ) ; } else if ( EVERY_DAY_ACCOUNT . equals ( account ) ) { trans . addAll ( filter ( getEveryDayAprTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayMarTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayFebTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayJanTransactions ( ) , filterDate ) ) ; } return trans ; } public List < Transaction > filter ( List < Transaction > trans , Calendar filterDate ) { List < Transaction > filterTrans = new ArrayList < Transaction > ( ) ; for ( Transaction tran : trans ) { if ( isCurrent ( tran , filterDate ) ) { filterTrans . add ( tran ) ; } } return filterTrans ; } public boolean isCurrent ( Transaction tran , Calendar filterDate ) { if ( tran . getActualPaymentDate ( ) == null ) { return true ; } if ( tran . getActualPaymentDate ( ) . after ( filterDate ) ) { return true ; } return false ; } public List < Transaction > getCreditCardSavings ( ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Car Savings\" , - 102.00 , true , Type . SAVINGS ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Power Savings - March\" , - 50.00 , true , Type . SAVINGS ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Power Savings - April\" , - 20.00 , true , Type . SAVINGS ) ) ; return trans ; } public List < Transaction > getCreditCardAprTransactions ( ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; String month = \"2011/04/\" ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Car - Warrent & Wiper blades & Handbrake adjustment\" , toDate ( month , \"14\" ) , - 116.00 , true ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Car - 4 New Tyres\" , toDate ( month , \"13\" ) , - 482.00 , true ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Grocceries\" , toDate ( month , \"17\" ) , - 100.00 , false ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Vodafone Phone/Internet/Sky\" , toDate ( month , \"21\" ) , - 220.00 , true ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Genesis Power bill\" , toDate ( month , \"23\" ) , - 139.66 , true ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Groceries\" , toDate ( month , \"24\" ) , - 100.00 , false ) ) ; return trans ; } private String toDate ( String yearMonth , String day ) { return yearMonth + day ; } public List < Transaction > getEveryDayAprTransactions ( ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; String month = \"2011/04/\" ; trans . add ( new Transaction ( EVERY_DAY_ACCOUNT , \"Habit Gym Membership\" , toDate ( month , \"01\" ) , - 128.67 , true ) ) ; trans . add ( new Transaction ( EVERY_DAY_ACCOUNT , \"WCC Rates - Thurleigh Grove\" , toDate ( month , \"02\" ) , - 185.97 , true ) ) ; trans . add ( new Transaction ( EVERY_DAY_ACCOUNT , \"Clyde Maintenance\" , toDate ( month , \"02\" ) , - 50.00 , true ) ) ; trans . add ( new Transaction ( EVERY_DAY_ACCOUNT , \"Vero Insurance\" , toDate ( month", "gt": ", \"02\" ) , - 17.13 , true ) ) ;", "prediction": ", \"03\" ) , - 50.00 , true ) ) ;\n", "label": 1}
{"id": 2574, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import java . util . Collections ; import java . util . List ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . FigureListener ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . RectangleFigure ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . GraphicalEditPart ; import org . eclipse . gef . handles . MoveHandle ; import org . eclipse . gmf . runtime . diagram . ui . editpolicies . NonResizableEditPolicyEx ; import org . eclipse . gmf . runtime . diagram . ui . tools . DragEditPartsTrackerEx ; import org . eclipse . gmf . runtime . draw2d . ui . figures . WrappingLabel ; public class SimplemapTextNonResizableEditPolicy extends NonResizableEditPolicyEx { private IFigure selectionFeedbackFigure ; private IFigure focusFeedbackFigure ; private FigureListener hostPositionListener ; protected void showPrimarySelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { showSelection ( ) ; showFocus ( ) ; } } protected void showSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { hideSelection ( ) ; addFeedback ( selectionFeedbackFigure = createSelectionFeedbackFigure ( ) ) ; getHostFigure ( ) . addFigureListener ( getHostPositionListener ( ) ) ; refreshSelectionFeedback ( ) ; hideFocus ( ) ; } } protected void hideSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( false ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( selectionFeedbackFigure != null ) { removeFeedback ( selectionFeedbackFigure ) ; getHostFigure ( ) . removeFigureListener ( getHostPositionListener ( ) ) ; selectionFeedbackFigure = null ; } hideFocus ( ) ; } } protected void showFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { hideFocus ( ) ; addFeedback ( focusFeedbackFigure = createFocusFeedbackFigure ( ) ) ; refreshFocusFeedback ( ) ; } } protected void hideFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( focusFeedbackFigure != null ) { removeFeedback ( focusFeedbackFigure ) ; focusFeedbackFigure = null ; } } } protected Rectangle getFeedbackBounds ( ) { Rectangle bounds ; if ( getHostFigure ( ) instanceof Label ) { bounds = ( ( Label ) getHostFigure ( ) ) . getTextBounds ( ) ; bounds . intersect ( getHostFigure ( ) . getBounds ( ) ) ; } else { bounds = getHostFigure ( ) . getBounds ( ) . getCopy ( ) ; } getHostFigure ( ) . getParent ( ) . translateToAbsolute ( bounds ) ; getFeedbackLayer ( ) . translateToRelative ( bounds ) ; return bounds ; } protected IFigure createSelectionFeedbackFigure ( ) { if ( getHostFigure ( ) instanceof Label ) { Label feedbackFigure = new Label ( ) ; feedbackFigure . setOpaque ( true ) ; feedbackFigure . setBackgroundColor ( ColorConstants . menuBackgroundSelected ) ; feedbackFigure . setForegroundColor ( ColorConstants . menuForegroundSelected ) ; return feedbackFigure ; } else { RectangleFigure feedbackFigure = new RectangleFigure ( ) ; feedbackFigure . setFill ( false ) ; return feedbackFigure ; } } protected IFigure createFocusFeedbackFigure ( ) { return new Figure ( ) { protected void", "gt": "paintFigure ( Graphics graphics )", "prediction": "setFocus ( )\n", "label": 0}
{"id": 13466, "input": "<s> package org . eclipse . rap . demo . controls ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . IInputValidator ; import org . eclipse . jface . dialogs . InputDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . ProgressMonitorDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . window . Window ; import org . eclipse . rap . rwt . widgets . DialogCallback ; import org . eclipse . rap . rwt . widgets . DialogUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . ColorDialog ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . FontDialog ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . MessageBox ; public class DialogsTab extends ExampleTab { private Label inputDlgResLabel ; private Label loginDlgResLabel ; private Label messageDlgResLabel ; private Label errorDlgResLabel ; private Label messageBoxDlgResLabel ; private Button okButton ; private Button cancelButton ; private Button yesButton ; private Button noButton ; private Button retryButton ; private Button abortButton ; private Button ignoreButton ; private Button iconErrorButton ; private Button iconInformationButton ; private Button iconQuestionButton ; private Button iconWarningButton ; private Button iconWorkingButton ; private Button noIconButton ; private Button showMessageBoxDlgButton ; private Button showColorDialogButton ; private Button showFontDialogButton ; protected boolean useDialogCallback ; public DialogsTab ( ) { super ( \"Dialogs\" ) ; } @ Override protected void createStyleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 1 , true ) ) ; createMessageBoxStyleControls ( parent ) ; } @ Override protected void createExampleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( ) ) ; Group group1 = new Group ( parent , SWT . NONE ) ; group1 . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; group1 . setText ( \"JFace Dialogs\" ) ; group1 . setLayout ( new GridLayout ( 3 , true ) ) ; Button showInputDlgButton = new Button ( group1 , SWT . PUSH ) ; showInputDlgButton . setText ( \"Input Dialog\" ) ; showInputDlgButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { showInputDialog ( ) ; } } ) ;", "gt": "showInputDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ;", "prediction": "Button cancelButton = new Button ( group1 , SWT . PUSH ) ;\n", "label": 1}
{"id": 5439, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . materialien ; import java . util . ArrayList ; import java . util . List ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Platz ; public class Kinosaal { private String _name ; private int _anzahlReihen ; private int _anzahlSitzeProReihe ; public Kinosaal ( String name , int anzahlReihen , int anzahlSitzeProReihe ) { assert name != null : \"Vorbedingung verletzt: name != null\" ; assert anzahlReihen > 0 : \"Vorbedingung verletzt: anzahlReihen > 0\" ; assert anzahlSitzeProReihe > 0 : \"Vorbedingung verletzt: anzahlSitzeProReihe > 0\" ; _name = name ; _anzahlReihen = anzahlReihen ; _anzahlSitzeProReihe = anzahlSitzeProReihe ; } public String getName ( ) { return _name ; } public int getAnzahlReihen ( ) { return _anzahlReihen ; } public int getAnzahlSitzeProReihe ( ) { return _anzahlSitzeProReihe ; } public List < Platz > getPlaetze ( ) { List < Platz > kinoPlaetze = new ArrayList < Platz > ( ) ; int reihen = getAnzahlReihen ( ) ; int plaetze = getAnzahlSitzeProReihe ( ) ; for ( int i = 0 ; i < reihen ; i ++ ) { for ( int j = 0 ; j < plaetze ; j ++ ) { Platz platz = new Platz ( i , j ) ; kinoPlaetze . add ( platz ) ; } } return kinoPlaetze ; } public boolean hatPlatz ( Platz platz ) { assert platz != null : \"Vorbedingung verletzt: platz != null\" ; return ( ( platz . getReihe ( ) >= 0 ) && ( platz . getReihe ( ) < _anzahlReihen ) ) && ( ( platz . getSitz ( ) >= 0 ) && ( platz", "gt": ". getSitz ( ) < _anzahlSitzeProReihe ) ) ;", "prediction": ". getSitz ( ) < _anzahlReihen ) ) ;\n", "label": 0}
{"id": 13468, "input": "<s> package knowevo . myvizster . action ; import java . util . Iterator ; import prefusex . community . CommunitySet ; import edu . berkeley . guir . prefuse . EdgeItem ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . NodeItem ; import edu . berkeley . guir . prefuse . action . AbstractAction ; import edu . berkeley . guir . prefuse . graph . Node ; public class CommunityEdgeLabeler extends AbstractAction { private Object m_key ; public CommunityEdgeLabeler ( Object communityKey ) { m_key = communityKey ; } public void run ( ItemRegistry registry , double frac ) { FocusManager fman = registry . getFocusManager ( ) ; CommunitySet comm = ( CommunitySet ) fman . getFocusSet ( m_key ) ; if ( comm . getCommunityCount ( ) == 0 ) return ; Iterator iter = registry . getEdgeItems ( ) ; while ( iter . hasNext ( ) ) { EdgeItem ei = ( EdgeItem ) iter . next ( ) ; NodeItem n1 = ( NodeItem ) ei . getFirstNode ( ) ; NodeItem n2 = ( NodeItem ) ei . getSecondNode ( ) ; int c1 = comm . getCommunity ( ( Node ) n1 . getEntity ( ) ) ; int c2 = comm . getCommunity ( ( Node ) n2 . getEntity ( ) ) ; boolean b = ( c1 != c2 && c1 != - 1 && c2 != - 1 ) ; Boolean val", "gt": "= b ? Boolean . TRUE : Boolean . FALSE ;", "prediction": "= Boolean . TRUE ;\n", "label": 1}
{"id": 7502, "input": "<s> package org . apache . felix . resolver ; import java . util . List ; public interface FelixCapability { List < String", "gt": "> getUses ( ) ;", "prediction": "> getCapabilities ( ) ;\n", "label": 0}
{"id": 13469, "input": "<s> package ru . spbstu . telematics . objectCatalog ; import java . io . IOException ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class AddClassStyleServlet extends HttpServlet { ObjectCatalog catalog = new ObjectCatalog ( ) ; @ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { String styleId = req . getParameter ( \"styleId\" ) ; String classId = req . getParameter ( \"classId\" ) ; if ( styleId != null && ! styleId . equals ( \"0\" ) && classId != null ) { catalog . addClassStyle ( classId , styleId ) ; } req . setAttribute ( \"classId\" , classId ) ; req . getRequestDispatcher ( \"/class_style/add_class_style.jsp\" ) .", "gt": "forward ( req , resp ) ;", "prediction": "forward ( req , resp ) ;\n", "label": 1}
{"id": 6024, "input": "<s> import java . io . IOException ; import java . io . InputStream ; import java . util . Hashtable ; class Main { static InputStream in = System . in ; static int max = 1 ; static Hashtable ht = new Hashtable ( ) ; public static void main ( String [ ] args ) throws Exception { ht . put ( \"0\" , new BigInteger ( \"0\" ) ) ; ht . put ( \"1\" , new BigInteger ( \"1\" ) ) ; while ( true ) { String str = readLine ( ) ; if ( str == null ) return ; int n = Integer . parseInt ( str . trim ( ) ) ; if ( n > max ) { while ( max != n ) { max ++ ; BigInteger n1 = ( BigInteger ) ht . get ( \"\" + ( max - 1 ) ) ; BigInteger n3 = new BigInteger ( \"0\" ) . add ( n1 ) ; n3 = n3 . add ( ( BigInteger ) ht . get ( \"\" + ( max - 2 ) ) ) ; ht . put ( \"\" + max , n3 ) ; } } BigInteger zzz = ( BigInteger ) ht . get ( \"\" + n ) ; System . out . println ( \"The Fibonacci number for \" + n + \" is \" + zzz . toString ( 10 ) ) ; } } static String readLine ( ) throws IOException { return readLine ( 500 ) ; } static String readLine ( int max ) throws IOException { int i = 0 , character = - 1 ; byte lin [ ] = new byte [ max ] ; while ( i < max ) { character = in . read ( ) ; if ( ( character < 0 ) || ( character == '\\n' ) ) break ; lin [ i ++ ] += character ; } if ( ( character < 0 ) && ( i == 0 ) ) { return ( null ) ; } return ( new String ( lin , 0 , i ) ) ; } } class BigInteger extends Number { int signum ; int [ ] mag ; private int firstNonzeroIntNum = - 2 ; private final static long LONG_MASK = 0xffffffffL ; public BigInteger ( byte [ ] val ) { if ( val . length == 0 ) throw new NumberFormatException ( \"Zero length BigInteger\" ) ; if ( val [ 0 ] < 0 ) { mag = makePositive ( val ) ; signum = - 1 ; } else { mag = stripLeadingZeroBytes ( val ) ; signum = ( mag . length == 0 ? 0 : 1 ) ; } } public BigInteger ( int signum , byte [ ] magnitude ) { this . mag = stripLeadingZeroBytes ( magnitude ) ; if ( signum < - 1 || signum > 1 ) throw ( new NumberFormatException ( \"Invalid signum value\" ) ) ; if ( this . mag . length == 0 ) { this . signum = 0 ; } else { if ( signum == 0 ) throw ( new NumberFormatException ( \"signum-magnitude mismatch\" ) ) ; this . signum = signum ; } } public BigInteger ( String val , int radix ) { int cursor = 0 , numDigits ; int len = val . length ( ) ; if ( radix < Character . MIN_RADIX || radix > Character . MAX_RADIX ) throw new NumberFormatException ( \"Radix out of range\" ) ; if ( val . length ( ) == 0 ) throw new NumberFormatException ( \"Zero length BigInteger\" ) ; signum = 1 ; int index = val . indexOf ( '-' ) ; if ( index != - 1 ) { if ( index == 0 ) { if ( val . length ( ) == 1 ) throw new NumberFormatException ( \"Zero length BigInteger\" ) ; signum = - 1 ; cursor = 1 ; } else { throw new NumberFormatException ( \"Illegal embedded minus sign\" ) ; } } while ( cursor < len && Character . digit ( val . charAt ( cursor ) , radix ) == 0 ) cursor ++ ; if ( cursor == len ) { signum = 0 ; mag = ZERO . mag ; return ; } else { numDigits = len - cursor ; } int numBits = ( int ) ( ( ( numDigits * bitsPerDigit [ radix ] ) > > > 10 ) + 1 ) ; int numWords = ( numBits + 31 ) / 32 ; mag = new int [ numWords ] ; int firstGroupLen = numDigits % digitsPerInt [ radix ] ; if ( firstGroupLen == 0 ) firstGroupLen = digitsPerInt [ radix ] ; String group = val . substring ( cursor , cursor += firstGroupLen ) ; mag [ mag . length - 1 ] = Integer . parseInt ( group , radix ) ; if ( mag [ mag . length - 1 ] < 0 ) throw new NumberFormatException ( \"Illegal digit\" ) ; int superRadix = intRadix [ radix ] ; int groupVal = 0 ; while ( cursor < val . length ( ) ) { group = val . substring ( cursor , cursor += digitsPerInt [ radix ] ) ; groupVal = Integer . parseInt ( group , radix ) ; if ( groupVal < 0 ) throw new NumberFormatException ( \"Illegal digit\" ) ; destructiveMulAdd ( mag , superRadix , groupVal ) ; } mag = trustedStripLeadingZeroInts ( mag ) ; } BigInteger ( char [ ] val ) { int cursor = 0 , numDigits ; int len = val . length ; signum = 1 ; if ( val [ 0 ] == '-' ) { if ( len == 1 ) throw new NumberFormatException ( \"Zero length BigInteger\" ) ; signum = - 1 ; cursor = 1 ; } while ( cursor < len && Character . digit ( val [ cursor ] , 10 ) == 0 ) cursor ++ ; if ( cursor == len ) { signum = 0 ; mag = ZERO . mag ; return ; } else { numDigits = len - cursor ; } int numWords ; if ( len < 10 ) { numWords = 1 ; } else { int numBits = ( int ) ( ( ( numDigits * bitsPerDigit [ 10 ] ) > > > 10 ) + 1 ) ; numWords = ( numBits + 31 ) / 32 ; } mag = new int [ numWords ] ; int firstGroupLen = numDigits % digitsPerInt [ 10 ] ; if ( firstGroupLen == 0 ) firstGroupLen = digitsPerInt [ 10 ] ; mag [ mag . length - 1 ] = parseInt ( val , cursor", "gt": ", cursor += firstGroupLen ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13472, "input": "<s> package org . eclipse . ui . forms . events ; public interface IExpansionListener { void expansionStateChanging ( ExpansionEvent e ) ; void", "gt": "expansionStateChanged ( ExpansionEvent e ) ;", "prediction": "expansionStateChanged ( ExpansionEvent e ) ;\n", "label": 1}
{"id": 4720, "input": "<s> package net . minecraft . src ; import org . lwjgl . opengl . GL11 ; public abstract class ThxModel extends ModelBase { final float RAD_PER_DEG = 00 .01745329f ; final float PI = 03 .14159265f ; boolean visible = true ; boolean paused ; float deltaTime ; long prevTime ; long entityPrevTime ; float rotationYaw ; float rotationYawSpeed ; float rotationPitch ; float rotationPitchSpeed ; float rotationRoll ; float rotationRollSpeed ; String renderTexture ; RenderManager renderManager ; int updateCount ; public void update ( ) { updateCount ++ ; long time = System . nanoTime ( ) ; deltaTime = ( ( float ) ( time - prevTime ) ) / 1000000000f ; if ( deltaTime > .03f ) deltaTime = .03f ; if ( paused ) { } else if ( entityPrevTime > prevTime ) { float adjustedDeltaTime = ( ( float ) ( time - entityPrevTime ) ) / 1000000000f ; rotationYaw += rotationYawSpeed * adjustedDeltaTime ; rotationPitch += rotationPitchSpeed * adjustedDeltaTime ; rotationRoll += rotationRollSpeed * adjustedDeltaTime ; } else { rotationYaw += rotationYawSpeed * deltaTime ; rotationPitch", "gt": "+= rotationPitchSpeed * deltaTime ;", "prediction": "+= rotationPitchSpeed * deltaTime ;\n", "label": 0}
{"id": 13475, "input": "<s> package org . nuxeo . ecm . automation . core . collectors ; import java . util . ArrayList ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . OperationException ; import org . nuxeo . ecm . automation . OutputCollector ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; public class DocumentModelListCollector extends ArrayList < DocumentModel > implements DocumentModelList , OutputCollector < DocumentModelList , DocumentModelList > { private static final long serialVersionUID = 5732663048354570870L ; @ Override public long totalSize ( ) { return size ( ) ; } @ Override public void collect", "gt": "( OperationContext ctx , DocumentModelList obj ) throws OperationException", "prediction": "( )\n", "label": 1}
{"id": 7946, "input": "<s> package org . ofbiz . manufacturing . mrp ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . manufacturing . bom . BOMNode ; import org . ofbiz . manufacturing . bom . BOMTree ; import org . ofbiz . manufacturing . jobshopmgt . ProductionRun ; import org . ofbiz . manufacturing . techdata . TechDataServices ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; public class ProposedOrder { public static final String module = ProposedOrder . class . getName ( ) ; public static final String resource = \"ManufacturingUiLabels\" ; protected GenericValue product ; protected boolean isBuilt ; protected String productId ; protected String facilityId ; protected String manufacturingFacilityId ; protected String mrpName ; protected Timestamp requiredByDate ; protected Timestamp requirementStartDate ; protected BigDecimal quantity ; public ProposedOrder ( GenericValue product , String facilityId , String manufacturingFacilityId , boolean isBuilt , Timestamp requiredByDate , BigDecimal quantity ) { this . product = product ; this . productId = product . getString ( \"productId\" ) ; this . facilityId = facilityId ; this . manufacturingFacilityId = manufacturingFacilityId ; this . isBuilt = isBuilt ; this . requiredByDate = requiredByDate ; this . quantity = quantity ; this . requirementStartDate = null ; } public BigDecimal getQuantity ( ) { return quantity ; } public Timestamp getRequirementStartDate ( ) { return requirementStartDate ; } public Map < String , Object > calculateStartDate ( int daysToShip , GenericValue routing , Delegator delegator , LocalDispatcher dispatcher , GenericValue userLogin ) { Map < String , Object > result = null ; Timestamp endDate = ( Timestamp ) requiredByDate . clone ( ) ; Timestamp startDate = endDate ; long timeToShip = daysToShip * 8 * 60 * 60 * 1000 ; if ( isBuilt ) { List < GenericValue > listRoutingTaskAssoc = null ; if ( routing == null ) { try { Map < String , Object > routingInMap = UtilMisc . < String , Object > toMap ( \"productId\" , product . getString ( \"productId\" ) , \"ignoreDefaultRouting\" , \"Y\" , \"userLogin\" , userLogin ) ; Map < String , Object > routingOutMap = dispatcher . runSync ( \"getProductRouting\" , routingInMap ) ; routing = ( GenericValue ) routingOutMap . get ( \"routing\" ) ; listRoutingTaskAssoc = UtilGenerics . checkList ( routingOutMap . get ( \"tasks\" ) ) ; if ( routing == null ) { BOMTree tree = null ; List < BOMNode > components = FastList . newInstance ( ) ; try { tree = new BOMTree ( product . getString ( \"productId\" ) , \"MANUF_COMPONENT\" , requiredByDate , BOMTree . EXPLOSION_SINGLE_LEVEL , delegator , dispatcher , userLogin ) ; tree . setRootQuantity ( quantity ) ; tree . print ( components , true ) ; if ( components . size ( ) > 0 ) components . remove ( 0 ) ; } catch ( Exception exc ) { Debug . logWarning ( exc . getMessage ( ) , module ) ; tree = null ; } if ( tree != null && tree . getRoot ( ) != null && tree . getRoot ( ) . getProduct ( ) != null ) { routingInMap = UtilMisc . toMap ( \"productId\" , tree . getRoot ( ) . getProduct ( ) . getString ( \"productId\" ) , \"userLogin\" , userLogin ) ; routingOutMap = dispatcher . runSync", "gt": "( \"getProductRouting\" , routingInMap ) ;", "prediction": "( \"getProductRouting\" , routingInMap ) ;\n", "label": 0}
{"id": 13487, "input": "<s> package org . restlet . example . book . restlet . ch09 . common ; import org . restlet . resource . Delete ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; public interface AccountResource { @ Get", "gt": "public AccountRepresentation represent ( ) ;", "prediction": "public Account get ( ) ;\n", "label": 1}
{"id": 2058, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ViewerNotification ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleSubNodeItemProvider extends SimpleNodeItemProvider implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleSubNodeItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; } return itemPropertyDescriptors ; } @ Override public Object getImage ( Object object ) { return overlayImage ( object , getResourceLocator ( ) . getImage ( \"full/obj16/SimpleSubNode\" ) ) ; } @ Override public String getText ( Object object ) { String label = ( ( SimpleSubNode ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( \"_UI_SimpleSubNode_type\" ) : label ; }", "gt": "@ Override public void notifyChanged ( Notification notification )", "prediction": "}\n", "label": 0}
{"id": 13491, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . widgets . TreeColumn ; public class TreeColumnTooltipTextProperty extends WidgetStringValueProperty { String doGetStringValue ( Object source ) { return ( ( TreeColumn ) source ) . getToolTipText ( ) ; } void doSetStringValue ( Object source , String value ) { ( (", "gt": "TreeColumn ) source ) . setToolTipText ( value ) ;", "prediction": "TreeColumn ) source ) . setToolTipText ( value ) ;\n", "label": 1}
{"id": 9192, "input": "<s> package org . msl . simple . gmfmap . diagram . properties . figure ; import org . eclipse . gmf . gmfgraph . Figure ; public class FigurePreferedSizePropertiesSection extends ElementWithFigurePropertySection { @ Override protected Object", "gt": "transformSelection ( Object selected )", "prediction": "getAdapter ( )\n", "label": 0}
{"id": 13495, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . util . HashSet ; import java . util . Set ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; public class PhaseListenerRegistry { private final Set < PhaseListener > phaseListeners ; public PhaseListenerRegistry ( ) { phaseListeners = new HashSet < PhaseListener > ( ) ; } public void add ( PhaseListener listener ) { ParamCheck . notNull ( listener , \"listener\" ) ; phaseListeners . add ( listener ) ; } public void remove ( PhaseListener listener ) { ParamCheck . notNull ( listener , \"listener\" ) ; phaseListeners . remove ( listener ) ; } public void removeAll ( ) { phaseListeners . clear ( ) ; }", "gt": "public PhaseListener [ ] getAll ( )", "prediction": "}\n", "label": 1}
{"id": 8495, "input": "<s> package me . chester . minitruco . android . bluetooth ; import java . util . UUID ; import me . chester . minitruco . R ; import me . chester . minitruco . android . BaseActivity ; import me . chester . minitruco . android . TrucoActivity ; import android . app . AlertDialog ; import android . bluetooth . BluetoothAdapter ; import android . content . DialogInterface ; import android . content . DialogInterface . OnCancelListener ; import android . content . Intent ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . view . View ; import android . widget . Button ; import android . widget . TextView ; public abstract class BluetoothBaseActivity extends BaseActivity implements Runnable { public static final int SEPARADOR_REC = '*' ; public static final byte [ ] SEPARADOR_ENV = \"**\" . getBytes ( ) ; public static final String NOME_BT = \"miniTruco\" ; public static final UUID UUID_BT = UUID . fromString ( \"3B175368-ABB4-11DB-A508-C2B155D89593\" ) ; private static final int MSG_MOSTRA_MENSAGEM = 1 ; private static final int MSG_ERRO_FATAL = 2 ; protected BluetoothAdapter btAdapter ; protected String [ ] apelidos = new String [ 4 ] ; protected String regras ; protected Button btnIniciar ; protected View layoutIniciar ; private TextView textViewMensagem ; private TextView textViewRegras ; private TextView [ ] textViewsJogadores ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . bluetooth ) ; layoutIniciar = ( View ) findViewById ( R . id . layoutIniciar ) ; btnIniciar = ( Button ) findViewById ( R . id . btnIniciarBluetooth ) ; textViewMensagem = ( ( TextView ) findViewById ( R . id . textViewMensagem ) ) ; textViewRegras = ( TextView ) findViewById ( R . id . textViewRegras ) ; textViewsJogadores = new TextView [ 4 ] ; textViewsJogadores [ 0 ] = ( TextView ) findViewById ( R . id . textViewJogador1 ) ; textViewsJogadores [ 1 ] = ( TextView ) findViewById ( R . id . textViewJogador2 ) ; textViewsJogadores [ 2 ] = ( TextView ) findViewById ( R . id . textViewJogador3 ) ; textViewsJogadores [ 3 ] = ( TextView ) findViewById ( R . id . textViewJogador4 ) ; btAdapter = BluetoothAdapter . getDefaultAdapter ( ) ; } protected void atualizaDisplay ( ) { Message . obtain ( handlerAtualizaDisplay ) . sendToTarget ( ) ; } protected void setMensagem ( String mensagem ) { Message . obtain ( handlerAtualizaDisplay , MSG_MOSTRA_MENSAGEM , mensagem ) . sendToTarget ( ) ; } protected void msgErroFatal ( String mensagem ) { Message . obtain ( handlerAtualizaDisplay , MSG_ERRO_FATAL , mensagem ) . sendToTarget ( ) ; } protected abstract int getNumClientes ( ) ; Handler handlerAtualizaDisplay = new Handler ( ) { public void handleMessage ( Message msg ) { switch ( msg . what ) { case MSG_MOSTRA_MENSAGEM : if ( msg . obj == null ) { textViewMensagem . setVisibility ( View . GONE ) ; } else { textViewMensagem . setVisibility ( View . VISIBLE ) ; textViewMensagem . setText ( ( String ) msg . obj ) ; } break ; case MSG_ERRO_FATAL : new AlertDialog . Builder ( BluetoothBaseActivity . this ) . setTitle ( \"Erro\" ) . setMessage ( ( String ) msg . obj ) . setOnCancelListener ( new OnCancelListener ( ) { public void onCancel ( DialogInterface dialog ) { finish ( ) ; } } ) . setNeutralButton ( \"Ok\" , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { finish ( ) ; } } ) . show ( ) ; break ; }", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 0}
{"id": 13500, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; public class CComboSingleSelectionIndexProperty extends SingleSelectionIndexProperty { public CComboSingleSelectionIndexProperty ( ) { super ( new int [ ] { SWT . Selection , SWT . DefaultSelection } ) ; } int doGetIntValue ( Object source ) { return ( ( CCombo ) source ) . getSelectionIndex ( ) ; } void doSetIntValue ( Object source , int value ) { if ( value == - 1 ) ( ( CCombo ) source ) . deselectAll ( ) ; else ( ( CCombo ) source ) .", "gt": "select ( value ) ;", "prediction": "setSelection ( value ) ;\n", "label": 1}
{"id": 10132, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . DeclarationVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Symbol . MethodSymbol ; @ SuppressWarnings ( \"deprecation\" ) public class AnnotationTypeElementDeclarationImpl extends MethodDeclarationImpl implements AnnotationTypeElementDeclaration { AnnotationTypeElementDeclarationImpl ( AptEnv env , MethodSymbol sym ) { super ( env , sym ) ; } public AnnotationTypeDeclaration getDeclaringType ( ) { return", "gt": "( AnnotationTypeDeclaration ) super . getDeclaringType ( ) ;", "prediction": "null ;\n", "label": 0}
{"id": 13501, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . util . LinkedHashSet ; import java . util . Set ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . resources . IResource ; public class ResourceRegistry { private final Set < IResource > resources ; public ResourceRegistry ( ) { resources = new LinkedHashSet < IResource > ( ) ; } public void add ( IResource resource ) { ParamCheck", "gt": ". notNull ( resource , \"resource\" ) ;", "prediction": ". notNull ( resource , \"resource\" ) ;\n", "label": 1}
{"id": 665, "input": "<s> package com . redhat . ceylon . compiler . java . loader ; import java . util . Collections ; import com . redhat . ceylon . compiler . java . tools . LanguageCompiler ; import com . redhat . ceylon . compiler . typechecker . context . Context ; import com . redhat . ceylon . compiler . typechecker . model . IntersectionType ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . TypeDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . UnionType ; import com . redhat . ceylon . compiler . typechecker . model . Unit ; import com . redhat . ceylon . compiler . typechecker . model . UnknownType ; import com . redhat . ceylon . compiler . typechecker . model . Util ; public class TypeFactory extends Unit { private Context context ; public static TypeFactory instance ( com . sun . tools . javac . util . Context context ) { TypeFactory instance = context . get ( TypeFactory . class ) ; if ( instance == null ) { instance = new TypeFactory ( LanguageCompiler . getCeylonContextInstance ( context ) ) ; context . put ( TypeFactory . class , instance ) ; } return instance ; } public TypeFactory ( Context context ) { this . context = context ; } public Context getContext ( ) { return context ; } public boolean isUnion ( ProducedType pt ) { TypeDeclaration tdecl = pt . getDeclaration ( ) ; return ( tdecl instanceof UnionType && tdecl . getCaseTypes ( ) . size ( ) > 1 ) ; } public boolean isIntersection ( ProducedType pt ) { TypeDeclaration tdecl = pt . getDeclaration ( ) ; return ( tdecl instanceof IntersectionType && tdecl . getSatisfiedTypes ( )", "gt": ". size ( ) > 1 ) ;", "prediction": ". size ( ) > 1 ) ;\n", "label": 0}
{"id": 13502, "input": "<s> package knowevo . myvizster ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . graph . Entity ; public class DecoratorItem extends VisualItem { private VisualItem m_decorated ; public void init ( ItemRegistry registry , String itemClass , Entity entity ) { super . init ( registry , itemClass , entity ) ; m_decorated = registry . getItem (", "gt": "ItemRegistry . DEFAULT_NODE_CLASS , entity , false , false ) ;", "prediction": "itemClass ) ;\n", "label": 1}
{"id": 6781, "input": "<s> package model ; import static org . junit . Assert . * ; import java . util . ArrayList ; import org . junit . Test ; public class UserJUnit { @ Test public void testUserConstructor ( ) { Cart shopping = new Cart ( ) ; ArrayList < Book > rental = new ArrayList < Book > ( ) ; PaymentInfo testInfo = new PaymentInfo ( ) ; User test = new User ( \"Test\" , false , \"myemail@stupid\" , rental , testInfo , shopping ) ; assertTrue ( test . username . equals ( \"Test\" ) && test . email . equals ( \"myemail@stupid\" ) && test . isAdmin == false ) ; } @ Test public void testUserGetters ( ) { Cart shopping = new Cart ( ) ; ArrayList < Book > rental = new ArrayList < Book > ( ) ; PaymentInfo testInfo = new PaymentInfo ( ) ; User test = new User ( \"Test\" , false , \"myemail@stupid\" , rental , testInfo , shopping ) ; assertTrue ( test . getUserName ( ) . equals ( \"Test\" ) ) ; assertTrue ( test . getCart ( ) != null ) ; assertTrue ( test . getEmail ( ) . equals ( \"myemail@stupid\" ) ) ; assertTrue ( test . getPaymentInfo ( ) != null ) ; assertTrue ( test . getRentals ( ) != null ) ; } @ Test public void testUserSetters ( ) { Cart shopping = new Cart ( ) ; ArrayList < Book > rental = new ArrayList < Book > ( ) ; PaymentInfo testInfo = new PaymentInfo ( ) ; User test = new User ( \"Test\" , false ,", "gt": "\"myemail@stupid\" , rental , testInfo , shopping ) ;", "prediction": "\"myemail@stupid\" , rentals , testInfo , shopping ) ;\n", "label": 0}
{"id": 13503, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . branding . AbstractBranding ; import org . eclipse . rap . rwt . branding . Header ; import org . eclipse . rap . rwt . client . WebClient ; import org . eclipse . rap . rwt . internal . RWTMessages ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . branding . BrandingUtil ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . protocol . ProtocolMessageWriter ; import org . eclipse . rap . rwt . internal . resources . ResourceRegistry ; import org . eclipse . rap . rwt . internal . service . StartupPageTemplateHolder . Variable ; import org . eclipse . rap . rwt . internal . textsize . MeasurementUtil ; import org . eclipse . rap . rwt . internal . theme . JsonValue ; import org . eclipse . rap . rwt . internal . theme . Theme ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . internal . theme . ThemeUtil ; import org . eclipse . rap . rwt . internal . util . HTTP ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . resources . IResource ; final class StartupPageConfigurer { private static final String PACKAGE_NAME = StartupPageConfigurer . class . getPackage ( ) . getName ( ) ; private final static String FOLDER = PACKAGE_NAME . replace ( '.' , '/' ) ; private final static String INDEX_TEMPLATE = FOLDER + \"/rwt-index.html\" ; private static final String DISPLAY_TYPE = \"rwt.widgets.Display\" ; private static final String PROPERTY_URL = \"url\" ; private final ResourceRegistry resourceRegistry ; private final List < String > jsLibraries ; private final List < String > themeDefinitions ; private StartupPageTemplateHolder template ; StartupPageConfigurer ( ResourceRegistry resourceRegistry ) { this . resourceRegistry = resourceRegistry ; jsLibraries = new ArrayList < String > ( ) ; themeDefinitions = new ArrayList < String > ( ) ; } public StartupPageTemplateHolder getTemplate ( ) throws IOException { readContent ( ) ; template . reset ( ) ; applyBranding ( ) ; applyEntryPointProperties ( ) ; applyLocalizeableMessages ( ) ; addThemeDefinitions ( ) ; template . replace ( StartupPageTemplateHolder . VAR_LIBRARIES , getJsLibraries ( ) ) ; template . replace ( StartupPageTemplateHolder . VAR_APPSCRIPT , getAppScript ( ) ) ; return template ; } public void addJsLibrary ( String location ) { ParamCheck . notNull ( location , \"resource\" ) ; jsLibraries . add ( location ) ; } private void readContent ( ) throws IOException { if ( template == null ) { InputStream stream = loadTemplateFile ( ) ; InputStreamReader streamReader = new InputStreamReader ( stream , HTTP . CHARSET_UTF_8 ) ; BufferedReader reader = new BufferedReader ( streamReader ) ; try { String line = reader . readLine ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( line != null ) { buffer . append ( line ) ; buffer . append ( '\\n' ) ; line = reader . readLine ( ) ; } template = new StartupPageTemplateHolder ( buffer . toString ( ) ) ; } finally { reader . close ( ) ; } } } private static InputStream loadTemplateFile ( ) throws IOException { ClassLoader classLoader = StartupPageConfigurer . class . getClassLoader ( ) ; InputStream result = classLoader . getResourceAsStream ( INDEX_TEMPLATE ) ; if ( result == null ) { throw new IOException ( \"Failed to startup page: \" + INDEX_TEMPLATE ) ; } return result ; } private static String getAppScript ( ) { StringBuilder code = new StringBuilder ( ) ; code . append ( \"if( rwt.runtime.System.getInstance().isSupported() ) {\" ) ; code . append ( \"rwt.protocol.MessageProcessor.processMessage( \" ) ; code . append ( getStartupProtocolMessage ( \"w1\" ) ) ; code . append ( \");/*EOM*/ }\" ) ; return code . toString ( ) ; } private static String getStartupProtocolMessage ( String id ) { ProtocolMessageWriter writer = new ProtocolMessageWriter ( ) ; appendCreateDisplay ( id , writer ) ; MeasurementUtil . appendStartupTextSizeProbe ( writer ) ; return writer . createMessage ( ) ; } private static void appendCreateDisplay ( String id , ProtocolMessageWriter writer ) { writer . appendCreate ( id , DISPLAY_TYPE ) ; writer . appendHead ( PROPERTY_URL , JsonValue", "gt": ". valueOf ( getUrl ( ) ) ) ;", "prediction": ". TRUE ) ;\n", "label": 1}
{"id": 8169, "input": "<s> package org . ofbiz . product . inventory ; import java . math . BigDecimal ; import java . math . MathContext ; import java . sql . Timestamp ; import com . ibm . icu . util . Calendar ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityTypeUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class InventoryServices { public final static String module = InventoryServices . class . getName ( ) ; public static final String resource = \"ProductUiLabels\" ; public static final MathContext generalRounding = new MathContext ( 10 ) ; public static Map < String , Object > prepareInventoryTransfer ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String inventoryItemId = ( String ) context . get ( \"inventoryItemId\" ) ; BigDecimal xferQty = ( BigDecimal ) context . get ( \"xferQty\" ) ; GenericValue inventoryItem = null ; GenericValue newItem = null ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; try { inventoryItem = delegator . findOne ( \"InventoryItem\" , UtilMisc . toMap ( \"inventoryItemId\" , inventoryItemId ) , false ) ; } catch ( GenericEntityException e ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ProductNotFindInventoryItemWithId\" , locale ) + inventoryItemId ) ; } if ( inventoryItem == null ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ProductNotFindInventoryItemWithId\" , locale ) + inventoryItemId ) ; } try { Map < String , Object > results = ServiceUtil . returnSuccess ( ) ; String inventoryType = inventoryItem . getString ( \"inventoryItemTypeId\" ) ; if ( inventoryType . equals ( \"NON_SERIAL_INV_ITEM\" ) ) { BigDecimal", "gt": "atp = inventoryItem . getBigDecimal ( \"availableToPromiseTotal\" ) ;", "prediction": "quantity = ( BigDecimal ) context . get ( \"quantity\" ) ;\n", "label": 0}
{"id": 13513, "input": "<s> package org . jscsi . parser . nop ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . Constants ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . TargetMessageParser ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . utils . Utils ; public final class NOPInParser extends TargetMessageParser { private int targetTransferTag ; public NOPInParser ( final ProtocolDataUnit initProtocolDataUnit ) { super ( initProtocolDataUnit ) ; } public final int getTargetTransferTag ( ) { return targetTransferTag ; } public final void setTargetTransferTag ( final int targetTransferTag ) { this . targetTransferTag = targetTransferTag ; } @ Override public final String toString ( ) { final StringBuilder sb = new StringBuilder ( Constants . LOG_INITIAL_SIZE ) ; Utils . printField ( sb , \"LUN\" , logicalUnitNumber , 1 ) ; Utils . printField ( sb , \"Target Transfer Tag\" , targetTransferTag , 1 ) ; sb . append ( super . toString ( ) ) ; return sb . toString ( ) ; } @ Override public final DataSegmentFormat getDataSegmentFormat ( ) { return DataSegmentFormat . BINARY ; } @ Override public final void clear ( ) { super . clear ( ) ; targetTransferTag = 0x00000000 ; } @ Override protected final void deserializeBytes1to3 ( final int line ) throws InternetSCSIException { Utils . isReserved ( line & Constants . LAST_THREE_BYTES_MASK ) ; } @ Override protected final void deserializeBytes20to23 ( final int line ) throws InternetSCSIException { targetTransferTag = line ; } @ Override", "gt": "protected final void checkIntegrity ( ) throws InternetSCSIException", "prediction": "protected final void deserializeBytes40to43 ( final int line ) throws InternetSCSIException\n", "label": 1}
{"id": 4857, "input": "<s> package com . dyned . woremotesiteconfig . tasks ; import org . apache . log4j . Logger ; import com . dyned . woremotesiteconfig . javamonitor . Site ; import com . dyned . woremotesiteconfig . javamonitor . SiteApplication ; import com . dyned . woremotesiteconfig . javamonitor . SiteInstance ; import com . webobjects . foundation . NSArray ; public class SendStopInstances implements Runnable { public static final Logger log = Logger . getLogger ( SendNewInstances . class ) ; private SiteApplication _siteApplication = null ; private Site _site = null ; private String _host = null ; public SendStopInstances ( Site site , SiteApplication siteApplication , String host ) { _site = site ; _siteApplication = siteApplication ; _host = host ; } public void run ( ) { boolean noError = true ; log . info ( \"Beginning background task.\" ) ; try { NSArray < SiteInstance > siteInstances = _site . getSiteInstancesForSiteApplication ( _siteApplication ) ; for ( SiteInstance siteInstance : siteInstances ) { if ( siteInstance . host ( ) . equalsIgnoreCase ( _host ) ) { log . info ( \"Stopping instance on \" + _host ) ; noError = _site", "gt": ". sendStopInstance ( _siteApplication , siteInstance ) ;", "prediction": ". stopInstance ( siteInstance ) ;\n", "label": 0}
{"id": 13517, "input": "<s> package wiki ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Response ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . webengine . WebException ; import org . nuxeo . ecm . webengine . model . WebObject ; import org . nuxeo . ecm . webengine . model . exceptions . WebResourceNotFoundException ; import org . nuxeo . ecm . webengine . model . exceptions . WebSecurityException ; import org . nuxeo . ecm . webengine . model . impl . ModuleRoot ; @ Path ( \"/wikis\" ) @ WebObject ( type = \"wikis\" , facets = { \"mainWiki\" } ) @ Produces ( \"text/html; charset=UTF-8\" ) public class Main extends ModuleRoot { public Main ( ) { } @ GET public Object doGet ( ) throws ClientException { CoreSession session = ctx . getCoreSession ( ) ; DocumentModelList wikiSites = session . query ( \"SELECT * FROM Wiki WHERE ecm:currentLifeCycleState != 'deleted' \" ) ; return getView ( \"index\" ) . arg ( \"wikis\" , wikiSites ) ; } @ Path ( \"{segment}\" ) public Object getWiki ( @ PathParam ( \"segment\" ) String segment ) { try { CoreSession session = ctx . getCoreSession ( ) ; DocumentModel wikiSite = session . getDocument ( new IdRef ( segment ) ) ; return newObject ( \"Wiki\" , wikiSite . getId ( ) ) ; } catch ( Exception e ) { throw WebException . wrap ( e ) ; } } @ Override public Object handleError ( WebApplicationException e ) { if ( e instanceof WebSecurityException ) { return Response . status ( 401 ) . entity ( getTemplate ( \"error/error_401.ftl\" ) ) . build ( ) ; } else", "gt": "if ( e instanceof WebResourceNotFoundException )", "prediction": "\n", "label": 1}
{"id": 267, "input": "<s> import java . util . Collection ; public class T6359106 { interface Request < R extends Request < R , V > , V > { } interface DeltaRequest extends Request < DeltaRequest , T6359106 > { } interface RequestMap < V > { < R extends Request < R , W > , W extends V", "gt": "> R test ( Collection < R > c ) ;", "prediction": "> }\n", "label": 0}
{"id": 13518, "input": "<s> package org . eclipse . ui ; public interface IInPlaceEditorInput extends IPathEditorInput { public void", "gt": "setInPlaceEditor ( IInPlaceEditor editor ) ;", "prediction": "open ( ) ;\n", "label": 1}
{"id": 9359, "input": "<s> package api . torrents . artist ; public class Statistics { private Number numGroups ; private Number numLeechers ; private Number numSeeders ; private Number numSnatches ; private Number numTorrents ; public Number getNumGroups ( ) { return this . numGroups ; } public Number getNumLeechers ( ) { return this . numLeechers ; } public Number getNumSeeders ( ) { return this . numSeeders ; } public Number getNumSnatches ( ) { return this . numSnatches ; } public Number getNumTorrents ( ) { return this . numTorrents ; } @ Override public String toString ( ) { return \"Statistics [getNumGroups=\" + getNumGroups ( ) + \", getNumLeechers=\" + getNumLeechers ( ) + \", getNumSeeders=\" + getNumSeeders ( ) + \", getNumSnatches=\" + getNumSnatches ( )", "gt": "+ \", getNumTorrents=\" + getNumTorrents ( ) + \"]\" ;", "prediction": "+ \"]\" ;\n", "label": 0}
{"id": 13520, "input": "<s> import java . util . HashMap ; import junit . framework . TestCase ; import org . eclipse . cdt . core . dom . ast . ASTVisitor ; import org . eclipse . cdt . core . dom . ast . IASTArrayModifier ; import org . eclipse . cdt . core . dom . ast . IASTDeclSpecifier ; import org . eclipse . cdt . core . dom . ast . IASTDeclaration ; import org . eclipse . cdt . core . dom . ast . IASTDeclarator ; import org . eclipse . cdt . core . dom . ast . IASTEnumerationSpecifier . IASTEnumerator ; import org . eclipse . cdt . core . dom . ast . IASTExpression ; import org . eclipse . cdt . core . dom . ast . IASTInitializer ; import org . eclipse . cdt . core . dom . ast . IASTName ; import org . eclipse . cdt . core . dom . ast . IASTParameterDeclaration ; import org . eclipse . cdt . core . dom . ast . IASTPointerOperator ; import org . eclipse . cdt . core . dom . ast . IASTPreprocessorMacroDefinition ; import org . eclipse . cdt . core . dom . ast . IASTProblem ; import org . eclipse . cdt . core . dom . ast . IASTStatement ; import org . eclipse . cdt . core . dom . ast . IASTTranslationUnit ; import org . eclipse . cdt . core . dom . ast . IASTTypeId ; import org . eclipse . cdt . core . dom . ast . c . ICASTDesignator ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTCapture ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTCompositeTypeSpecifier . ICPPASTBaseSpecifier ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTNamespaceDefinition ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTTemplateParameter ; import org . eclipse . cdt . core . dom . ast . gnu . c . GCCLanguage ; import org . eclipse . cdt . core . parser . DefaultLogService ; import org . eclipse . cdt . core . parser . FileContent ; import org . eclipse . cdt . core . parser . IncludeFileContentProvider ; import org . eclipse . cdt . core . parser . ScannerInfo ; import org . eclipse . core . runtime . CoreException ; public class WhileDoForLoopTestCase extends TestCase { public void testBasicTest ( ) throws CoreException { StringBuilder content = new StringBuilder ( ) ; content . append ( \"void funWithWhileLoop(){\\n\" ) ; content . append ( \"while(){ \\n\" ) ; content . append ( \"\tint8_t localVar;\\n\" ) ; content . append ( \"}\\n\" ) ; content . append ( \"};\\n\" ) ; HashMap < String , String > options = new HashMap < String , String > ( ) ; ScannerInfo scannerInfo = new ScannerInfo ( options ) ; IASTTranslationUnit astTranslationUnit = GCCLanguage . getDefault ( ) . getASTTranslationUnit ( FileContent . create ( \"someFile.h\" , content . toString ( ) . toCharArray ( ) ) , scannerInfo , IncludeFileContentProvider . getEmptyFilesProvider ( ) , null , 0 , new DefaultLogService ( ) ) ; astTranslationUnit . accept ( new ASTVisitor ( true ) { } ) ; astTranslationUnit . accept ( new ASTVisitor ( true ) { public int visist ( IASTTranslationUnit x ) { System . out . println ( \"Visit IASTPreprocessorMacroDefinition\" ) ; for ( IASTPreprocessorMacroDefinition m : x . getMacroDefinitions ( ) ) { String name = m . getName ( ) . toString ( ) ; String valueAsString = m . getExpansion ( ) ; } return PROCESS_CONTINUE ; } public int visit ( IASTTranslationUnit x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTName x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTDeclaration x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTInitializer x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTParameterDeclaration x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTDeclarator x ) { System . err", "gt": ". println ( x . toString ( ) ) ;", "prediction": ". println ( x . toString ( ) ) ;\n", "label": 1}
{"id": 3842, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . TaskReport ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ReportTest extends XtextTest { public ReportTest ( ) { super ( \"ReportTest\" ) ; } @ Test public void testAllAttributes ( ) { String text = \"taskreport r1 \\\"Report One\\\" {\" + \"accountroot aroot \" + \"balance ac1 ac2 \" + \"caption \\\"cap string\\\" \" + \"center \\\"cent string\\\" \" + \"columns alert width 10.1  \" + \"currencyformat \\\"(\\\" \\\")\\\" \\\",\\\" \\\".\\\" 2 \" + \"end 2011-08-11 \" + \"epilog \\\"epi string\\\" \" + \"flags f1, f2 \" + \"footer \\\"foot string\\\" \" + \"formats csv, html \" + \"header \\\"head string\\\" \" + \"headline \\\"headline string\\\" \" + \"hideaccount \\\"logical expression\\\" \" + \"hidejournalentry \\\"logical expression\\\" \" + \"hideresource \\\"logical expression\\\" \" + \"hidetask \\\"logical expression\\\" \" + \"journalattributes * \" + \"journalmode journal \" + \"left \\\"left string\\\" \" + \"loadunit days \" + \"numberformat \\\"(\\\" \\\")\\\" \\\",\\\" \\\".\\\" 2 \" + \"period 2010-01-16-9:30 - 2011-01-16-20:59 \" + \"prolog \\\"prolog string\\\" \" + \"purge columns \" + \"accountreport \\\"acr\\\" \" + \"resourcereport \\\"rcr\\\" \" + \"taskreport \\\"tacr\\\" \" + \"textreport \\\"tecr\\\" \" + \"resourceroot rroot \" + \"right \\\"right string\\\" \" + \"rollupaccount \\\"logical expression\\\" \" + \"rollupresource \\\"logical expression\\\" \" + \"rolluptask \\\"logical expression\\\" \" + \"scenarios sc1,sc2,sc3 \" + \"selfcontained no \" + \"sortaccounts tree, alert.up \" + \"sortjournalentries duties.down \" + \"sortresources alert.down, duties.down \" + \"sorttasks tree \" + \"start 2010-08-09 \" + \"taskroot t1.t3 \" + \"timeformat \\\"format\\\" \" + \"timezone \\\"tz\\\" \" + \"title \\\"title string\\\" \" + \"}\" ; testParserRule ( text , TaskReport . class", "gt": ". getSimpleName ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13522, "input": "<s> package com . talis . hbase . rdf . test . junit ; import static org . openjena . atlas . lib . StrUtils . strjoinNL ; import java . util . ArrayList ; import java . util . List ; import org . openjena . atlas . iterator . Iter ; import org . openjena . atlas . iterator . Transform ; import com . hp . hpl . jena . query . Query ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . QueryFactory ; import com . hp . hpl . jena . query . QuerySolution ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . util . FileManager ; import com . talis . hbase . rdf . HBaseRdf ; import com . talis . hbase . rdf . Store ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . store . StoreFactory ; import com . talis . hbase . rdf . util . Pair ; import com . talis . hbase . rdf . util . Vocab ; public class StoreList { static Property description = Vocab . property ( HBaseRdf . namespace , \"description\" ) ; static Property list = Vocab . property ( HBaseRdf . namespace , \"list\" ) ; static Resource storeListClass = Vocab . property ( HBaseRdf . namespace , \"StoreList\" ) ; static boolean formatStores = false ; static String queryString = strjoinNL ( \"PREFIX hbaserdf: <http://rdf.hbase.talis.com/2011/hbase-rdf#>\" , \"PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\" , \"PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>\" , \"PREFIX list:     <http://jena.hpl.hp.com/ARQ/list#>\" , \"SELECT ?desc ?label\" , \"{ [] rdf:type hbaserdf:StoreList ;\" , \"     hbaserdf:list ?l .\" , \"  ?l list:member [ rdfs:label ?label ; hbaserdf:description ?desc ]\" , \"}\" ) ; static Transform < Pair < String , String > , Pair < String , StoreDesc > > t1 = new Transform < Pair < String , String > , Pair < String , StoreDesc > > ( ) { public Pair < String , StoreDesc > convert ( Pair < String , String > pair ) { return new Pair < String , StoreDesc > ( pair . car ( ) , StoreDesc . read ( pair . cdr ( ) ) ) ; } } ; static Transform < Pair < String , StoreDesc > , Pair < String , Store > > t2 = new Transform < Pair < String , StoreDesc > , Pair < String , Store > > ( ) { public Pair < String , Store > convert ( Pair < String , StoreDesc > pair ) { Store store = testStore ( pair . cdr ( ) ) ; return new Pair < String , Store > ( pair . car ( ) , store ) ; } } ; public static Store testStore ( StoreDesc desc ) { Store store = StoreFactory . create ( desc ) ; if ( formatStores || inMem ( store ) ) store . getTableFormatter ( ) . create ( ) ; return store ; } public static boolean inMem ( Store store ) { return false ; } public static List < Pair < String , StoreDesc > >", "gt": "stores ( String fn )", "prediction": "inMem ( StoreDesc desc )\n", "label": 1}
{"id": 6443, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface BookingResource extends ResourceAttribute { Task getTask ( ) ; void setTask ( Task value ) ;", "gt": "Booking getBooking ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13525, "input": "<s> package org . eclipse . xtext . xdoc . images . util ; import org . eclipse . emf . common . notify . Adapter ; import org . eclipse . emf . common . notify . Notifier ; import org . eclipse . emf . common . notify . impl . AdapterFactoryImpl ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . xtext . xdoc . images . * ; public class ImagesAdapterFactory extends AdapterFactoryImpl { protected static ImagesPackage modelPackage ; public ImagesAdapterFactory ( ) { if ( modelPackage == null ) { modelPackage = ImagesPackage . eINSTANCE ; } } @ Override public boolean isFactoryForType ( Object object ) { if ( object == modelPackage ) { return true ; }", "gt": "if ( object instanceof EObject )", "prediction": "return false ;\n", "label": 1}
{"id": 3542, "input": "<s> import java . io . * ; import com . sun . javadoc . Doclet ; import com . sun . javadoc . RootDoc ; public class Test extends Doclet { public static void main ( String ... args ) throws Exception { new Test ( ) . run ( ) ; } void run ( ) throws Exception { test ( \"<html><body>ABC      XYZ</body></html>\" ) ; test ( \"<html><body>ABC      XYZ</BODY></html>\" ) ; test ( \"<html><BODY>ABC      XYZ</body></html>\" ) ; test ( \"<html><BODY>ABC      XYZ</BODY></html>\" ) ; test ( \"<html><BoDy>ABC      XYZ</bOdY></html>\" ) ; test ( \"<html>      ABC      XYZ</bOdY></html>\" , \"Body tag missing from HTML\" ) ; test ( \"<html><body>ABC      XYZ       </html>\" , \"Close body tag missing from HTML\" ) ; test ( \"<html>      ABC      XYZ       </html>\" , \"Body tag missing from HTML\" ) ; test ( \"<html><body>ABC\" + bigText ( 8192 , 40 ) + \"XYZ</body></html>\" ) ; if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void test ( String text ) throws IOException { test ( text , null ) ; } void test ( String text , String expectError ) throws IOException { testNum ++ ; System . err . println ( \"test \" + testNum ) ; File file = writeFile ( \"overview\" + testNum + \".html\" , text ) ; String thisClassName = Test . class . getName ( ) ; File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; String [ ] args = { \"-bootclasspath\" , System . getProperty ( \"java.class.path\" ) + File . pathSeparator + System . getProperty ( \"sun.boot.class.path\" ) , \"-classpath\" , \".\" , \"-package\" , \"-overview\" , file . getPath ( ) , new File ( testSrc , thisClassName + \".java\" ) . getPath ( ) } ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javadoc . Main . execute ( \"javadoc\" , pw , pw , pw , thisClassName , args ) ; pw . close ( ) ; String out = sw . toString ( ) ; if ( ! out . isEmpty ( ) ) System . err . println ( out ) ; System . err . println", "gt": "( \"javadoc exit: rc=\" + rc ) ;", "prediction": "( \"test \" + testNum ) ;\n", "label": 0}
{"id": 13530, "input": "<s> package org . eclipse . jface . tests . viewers . interactive ; import java . util . ArrayList ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; public class Filter extends ViewerFilter { public Object [ ] filter ( Viewer viewer , Object parent , Object [ ] elements ) { ArrayList result = new ArrayList ( ) ; for ( int i = 0 ; i < elements . length ; ++ i ) { if ( i % 2 == 1 ) { result . add ( elements [ i ] ) ; } } return result", "gt": ". toArray ( ) ;", "prediction": ". toArray ( new Object [ result . size ( ) ] ) ;\n", "label": 1}
{"id": 6051, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; public final class Pagination { public static class PaginationBuilder { private Integer offset ; private PaginationBuilder ( Integer offset ) { this . offset = offset ; } public Pagination andLimit ( Integer limit ) { return new Pagination ( this . offset , limit ) ; } public Pagination andNoLimit ( ) { return new Pagination ( this . offset , null ) ; } } private Integer offset = null ; private Integer limit = null ; public static PaginationBuilder offset ( Integer offset ) { return new PaginationBuilder ( offset ) ; } public static PaginationBuilder noOffset ( ) { return new PaginationBuilder ( null ) ; } public Pagination ( Integer offset , Integer limit ) { super ( ) ; this . offset = offset ; this . limit = limit ; } public Pagination withOffset ( Integer offset ) { return new Pagination ( offset , this . limit ) ; } public Pagination withLimit ( Integer limit ) { return new Pagination ( this . offset , limit ) ; } public Integer getOffset ( ) { return offset ; } public Integer getLimit ( ) { return limit ; } public boolean isPaginationEnabled ( ) { return ( offset != null && limit != null ) ; } public Integer getEndOffset ( ) { if ( isPaginationEnabled ( ) ) {", "gt": "return offset + limit ;", "prediction": "return offset ;\n", "label": 0}
{"id": 13532, "input": "<s> package org . restlet . engine ; import org . restlet . Client ; public class ClientHelper extends ConnectorHelper < Client > { public ClientHelper ( Client client ) { super ( client ) ; } @ SuppressWarnings ( \"deprecation\" ) public int getSocketConnectTimeoutMs ( ) { int result = getHelped ( ) . getConnectTimeout ( ) ; if ( getHelpedParameters ( ) . getNames ( ) . contains ( \"socketConnectTimeoutMs\" ) ) { result = Integer . parseInt ( getHelpedParameters ( ) .", "gt": "getFirstValue ( \"socketConnectTimeoutMs\" , \"0\" ) ) ;", "prediction": "get ( \"socketConnectTimeoutMs\" ) ) ;\n", "label": 1}
{"id": 2994, "input": "<s> package org . gk . ui . client . com . form ; import org . gk . ui . client . com . utils . LayoutUtils ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . FormPanel . LabelAlign ; import com . extjs . gxt . ui . client . widget . layout . ColumnData ; import com . extjs . gxt . ui . client . widget . layout . ColumnLayout ; import com . extjs . gxt . ui . client . widget . layout . FormLayout ; import com . extjs . gxt . ui . client . widget . toolbar . ToolBar ; import com . google . gwt . user . client . ui . Widget ; public class gkFormRow extends LayoutContainer { private LabelAlign labelAlign = LabelAlign . LEFT ; public gkFormRow ( ) { setLayout ( new ColumnLayout ( ) ) ; } public gkFormRow ( String labelAlign ) { this ( ) ; setLabelAlign ( labelAlign ) ; } @ Override public boolean add ( Widget widget ) { return add ( widget , \"\" , \"\" , \"\" ) ; } public boolean add ( Widget widget , String widthRate , String width , String height ) { boolean result = true ; String [ ] rate = splitWidthRate ( widthRate ) ; FormLayout fl = new FormLayout ( ) ; fl . setLabelAlign ( labelAlign ) ; fl . setLabelWidth ( xferLabelWidth ( rate [ 0 ] ) ) ; if ( widget instanceof Field && labelAlign == LabelAlign . LEFT ) { setFieldLabelAlign ( ( Field ) widget , labelAlign . name ( ) . toLowerCase ( ) ) ; } if ( widget instanceof ToolBar ) { result &= add ( widget , new ColumnData ( xferDataWidth ( rate [ 1 ] ) ) ) ; } else { LayoutContainer lc = new LayoutContainer ( fl ) ; result &= lc . add ( widget , LayoutUtils . createFormData ( widget , width , height ) ) ; result &= add ( lc , new ColumnData ( xferDataWidth ( rate [ 1 ] ) ) ) ; } return result ; } private void setFieldLabelAlign ( Field field , String labelAlign ) { StringBuffer labelStyle = new StringBuffer ( field . getLabelStyle ( ) ) ; if ( labelStyle . indexOf ( \"text-align\" ) == - 1 ) { if ( labelStyle . length ( ) != 0 && ! ( labelStyle . charAt ( labelStyle . length ( ) - 1 ) == ';' ) ) { labelStyle . append ( \";\" ) ; } labelStyle . append ( \"text-align:\" ) . append ( labelAlign ) ; field . setLabelStyle ( labelStyle . toString ( ) ) ; } } public void setLabelAlign ( LabelAlign labelAlign ) { this . labelAlign = labelAlign ; } public void setLabelAlign ( String labelAlign ) { if ( labelAlign . matches ( \"right|left|top\" ) ) { this . labelAlign = LabelAlign . valueOf ( labelAlign . toUpperCase ( ) ) ; } } private int xferLabelWidth ( String width ) { int retWidth = 75 ; if ( width . matches ( \"^-?\\\\d+$\" ) ) { retWidth = Integer . valueOf ( width ) ; } return retWidth ; } private double xferDataWidth ( String width ) { double retWidth = 0.25 ; if ( width . endsWith ( \"%\" ) ) { width = width . replaceAll ( \"%\" , \"\" ) ; if", "gt": "( width . matches ( \"\\\\d+\" ) )", "prediction": "( width . endsWith ( \"%\" ) )\n", "label": 0}
{"id": 13538, "input": "<s> package knowevo . springbox . vizster ; import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . AffineTransform ; import knowevo . myvizster . ui . Legend ; import edu . berkeley . guir . prefuse . Display ; import edu . berkeley . guir . prefuse . util . ColorLib ; import edu . berkeley . guir . prefuse . util . FontLib ; public class MyVizsterDisplay extends Display { private VizsterApplet vizster ; private AffineTransform id = new AffineTransform ( ) ; private Legend legend = null ; public MyVizsterDisplay ( VizsterApplet vizster ) { super ( vizster . getItemRegistry ( ) ) ; this . vizster = vizster ; } public void prePaint ( Graphics2D g ) { Object o = g . getRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING ) ; g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; AffineTransform at = g . getTransform ( ) ; g . setTransform ( id ) ; Color c = ColorLib . getColor ( 200 , 200 , 200 , 255 ) ; Font f = FontLib . getFont ( \"SansSerif\" , Font . BOLD | Font . ITALIC , 48 ) ; FontMetrics fm = g . getFontMetrics ( f ) ; String s = \"vizster\" ; int x = 8 , y = fm . getAscent ( ) ; g . setColor ( c ) ; g . setFont ( f ) ; g . drawString ( s , x , y ) ; if ( vizster . isXRayMode ( ) ) { f = FontLib . getFont ( \"SansSerif\" , Font . BOLD | Font . ITALIC , 18 ) ; fm = g . getFontMetrics ( f ) ; s = \"x-ray\" ; g . setFont ( f ) ; g . drawString ( s , 140 , fm . getAscent ( ) - 2 ) ; } if ( legend != null ) { x = this . getWidth ( ) - legend . getWidth ( ) ; legend . paint ( g , this , x , 0 ) ; } g . setRenderingHint", "gt": "( RenderingHints . KEY_TEXT_ANTIALIASING , o ) ;", "prediction": "( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ;\n", "label": 1}
{"id": 3966, "input": "<s> @ ExpectedDeprecation ( false ) public class Dep1 { @ ExpectedDeprecation ( true ) public void method1 ( ) { } @ Deprecated @ ExpectedDeprecation ( true ) public void method2 ( ) { } public void method3 ( @ ExpectedDeprecation ( false ) Object method3_param0 ) { } public void method4 ( @ ExpectedDeprecation ( false ) Object method4_param0 , Object method4_param1 ) { } @ ExpectedDeprecation", "gt": "( false ) public void methodn ( )", "prediction": "( false ) public void method5 ( @ ExpectedDeprecation ( false ) Object method5_param0 )\n", "label": 0}
{"id": 13541, "input": "<s> package org . nuxeo . ecm . platform . relations . api . exceptions ; public class InvalidLiteralException extends RuntimeException { private static final long serialVersionUID = - 961763618434457797L ; public InvalidLiteralException ( ) { } public InvalidLiteralException ( String message ) { super ( message ) ; } public InvalidLiteralException ( String message , Throwable cause ) { super", "gt": "( message , cause ) ;", "prediction": "( message , cause ) ;\n", "label": 1}
{"id": 4254, "input": "<s> package org . remast . swing . util ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . GraphicsConfiguration ; import java . awt . GraphicsDevice ; import java . awt . GraphicsEnvironment ; import java . awt . Insets ; import java . awt . Point ; import java . awt . Rectangle ; import java . awt . Toolkit ; import java . awt . geom . Area ; import java . util . ArrayList ; import java . util . List ; import javax . swing . JApplet ; public class ScreenUtils { private static final Area SCREEN_AREA ; private static final Rectangle [ ] SCREENS ; private static Insets [ ] INSETS ; private static final Rectangle [ ] SCREENS_WITH_INSETS ; private static final Rectangle SCREEN_BOUNDS ; static { Area screenArea = new Area ( ) ; Rectangle screenBounds = new Rectangle ( ) ; GraphicsEnvironment environment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; List < Rectangle > screensList = new ArrayList < Rectangle > ( ) ; List < Insets > insetsList = new ArrayList < Insets > ( ) ; List < Rectangle > screensWithInsets = new ArrayList < Rectangle > ( ) ; GraphicsDevice [ ] screenDevices = environment . getScreenDevices ( ) ; for ( GraphicsDevice device : screenDevices ) { GraphicsConfiguration configuration = device . getDefaultConfiguration ( ) ; Rectangle deviceBounds = configuration . getBounds ( ) ; Insets insets = Toolkit . getDefaultToolkit ( ) . getScreenInsets ( configuration ) ; Rectangle screenBoundsWithInsets = new Rectangle ( deviceBounds . x + insets . left , deviceBounds . y + insets . top , deviceBounds . width - insets . right , deviceBounds . height - insets . bottom ) ; screensList . add ( deviceBounds ) ; insetsList . add ( insets ) ; screensWithInsets . add ( screenBoundsWithInsets ) ; screenArea . add ( new Area ( screenBoundsWithInsets ) ) ; screenBounds = screenBounds . union ( deviceBounds ) ; } SCREEN_AREA = screenArea ; SCREEN_BOUNDS = screenBounds ; SCREENS = screensList . toArray ( new Rectangle [ screensList . size ( ) ] ) ; INSETS = insetsList . toArray ( new Insets [ screensList . size ( ) ] ) ; SCREENS_WITH_INSETS = screensWithInsets . toArray ( new Rectangle [ screensWithInsets . size ( ) ] ) ; } private ScreenUtils ( ) { } public static Rectangle containsInScreenBounds ( final Component invoker , final Rectangle rect ) { Rectangle screenBounds = getScreenBounds ( invoker ) ; Point p = rect . getLocation ( ) ; if ( p . x + rect . width > screenBounds . x + screenBounds . width ) { p . x = screenBounds . x + screenBounds . width - rect . width ; } if ( p . y + rect . height > screenBounds . y + screenBounds . height ) { p . y = screenBounds . y + screenBounds", "gt": ". height - rect . height ;", "prediction": ". height - rect . height ;\n", "label": 0}
{"id": 13542, "input": "<s> package org . restlet . ext . sip ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . restlet . engine . Method ;", "gt": "import org . restlet . service . MetadataService ;", "prediction": "import org . restlet . representation . Representation ;\n", "label": 1}
{"id": 1693, "input": "<s> package org . parboiled . support ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . matchers . Matcher ; public class MatcherPath { public static class Element { public final Matcher matcher ; public final int startIndex ; public final int level ; public Element ( Matcher matcher , int startIndex , int level ) { this . matcher = matcher ; this . startIndex = startIndex ; this . level = level ; } } public final Element element ; public final MatcherPath parent ; public MatcherPath ( Element element , MatcherPath parent ) { this . element = checkArgNotNull ( element , \"element\" ) ; this . parent = parent ; } public int length ( ) { return element . level + 1 ; } public boolean isPrefixOf ( MatcherPath that ) { checkArgNotNull ( that , \"that\" ) ; return element . level <= that . element . level && ( this == that || ( that . parent != null && isPrefixOf ( that . parent ) ) ) ; } public Element getElementAtLevel ( int level ) { checkArgument ( level >= 0 ) ; if ( level > element . level ) return null ; if ( level < element . level ) return parent . getElementAtLevel ( level ) ; return element ; } public MatcherPath commonPrefix ( MatcherPath that ) { checkArgNotNull ( that , \"that\" ) ; if ( element . level > that . element . level ) return parent . commonPrefix ( that ) ; if ( element . level < that . element . level ) return commonPrefix ( that . parent ) ; if ( this == that ) return this ; return ( parent != null && that . parent != null ) ? parent . commonPrefix ( that . parent ) : null ; } public boolean contains ( Matcher matcher ) { return element . matcher == matcher || ( parent != null && parent . contains ( matcher ) ) ; } @ Override public String toString ( ) { return toString ( null ) ; } public String toString ( MatcherPath skipPrefix ) { return print ( new StringBuilder ( )", "gt": ", skipPrefix ) . toString ( ) ;", "prediction": ") . append ( skipPrefix . toString ( ) ) . toString ( ) ;\n", "label": 0}
{"id": 13543, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . client ; import java . io . IOException ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackServiceHandler ; import org . eclipse . rap . rwt . service . IServiceHandler ; import org . eclipse . swt . dnd . Transfer ; @ SuppressWarnings ( \"restriction\" ) public class RWTClient { private static final String TEXT_TRANSFER_DATA_TYPE = String . valueOf ( Transfer . registerType ( \"text\" ) ) ; private IServletEngine servletEngine ; private final IConnectionProvider connectionProvider ; private final long startTime ; private String sessionId ; private int requestCounter ; public RWTClient ( IServletEngine servletEngine ) { this ( servletEngine , new DefaultConnectionProvider ( ) ) ; } RWTClient ( IServletEngine servletEngine , IConnectionProvider connectionProvider ) { this . servletEngine = servletEngine ; this . connectionProvider = connectionProvider ; startTime = System . currentTimeMillis ( ) ; sessionId = \"\" ; requestCounter = - 2 ; } public void changeServletEngine ( IServletEngine servletEngine ) { this . servletEngine = servletEngine ; } public Object getServletEngine ( ) { return servletEngine ; } public String getSessionId ( ) { return sessionId ; } public Response sendStartupRequest ( ) throws IOException { return sendRequest ( \"GET\" , new HashMap < String , String > ( ) ) ; } public Response sendInitializationRequest ( ) throws IOException { Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( \"rwt_initialize\" , \"true\" ) ; parameters . put ( \"uiRoot\" , \"w1\" ) ; parameters . put ( \"w1.bounds.width\" , \"800\" ) ; parameters . put ( \"w1.bounds.height\" , \"600\" ) ; parameters . put ( \"w1.dpi.x\" , \"96\" ) ; parameters . put ( \"w1.dpi.y\" , \"96\" ) ; parameters . put ( \"w1.colorDepth\" , \"32\" ) ; parameters . put ( \"w1.cursorLocation.x\" , \"0\" ) ; parameters . put ( \"w1.cursorLocation.y\" , \"0\" ) ; return sendPostRequest ( parameters ) ; } public Response sendDisplayResizeRequest ( int width , int height ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"w1.bounds.width\" , String . valueOf ( width ) ) ; parameters . put ( \"w1.bounds.height\" , String . valueOf ( height ) ) ; return sendPostRequest ( parameters ) ; } public Response sendWidgetSelectedRequest ( String widgetId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.events.widgetSelected\" , widgetId ) ; return sendPostRequest ( parameters ) ; } public Response sendShellCloseRequest ( String shellId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.widgets.Shell_close\" , shellId ) ; return sendPostRequest ( parameters ) ; } public Response sendDragStartRequest ( String widgetId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.dnd.dragStart\" , widgetId ) ; parameters . put ( \"org.eclipse.swt.dnd.dragStart.x\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dragStart.y\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dragStart.time\" , createTimeParam ( ) ) ; return sendPostRequest ( parameters ) ; } public Response sendDragFinishedRequest ( String sourceWidgetId , String targetWidgetId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept\" , targetWidgetId ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.x\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.y\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.item\" , null ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.operation\" , \"move\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.feedback\" , \"0\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.dataType\" , TEXT_TRANSFER_DATA_TYPE ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.source\" , sourceWidgetId ) ; parameters . put ( \"org.eclipse.swt.dnd.dropAccept.time\" , createTimeParam ( ) ) ; parameters . put ( \"org.eclipse.swt.dnd.dragFinished\" , sourceWidgetId ) ; parameters . put ( \"org.eclipse.swt.dnd.dragFinished.x\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dragFinished.y\" , \"100\" ) ; parameters . put ( \"org.eclipse.swt.dnd.dragFinished.time\" , createTimeParam ( ) ) ; return sendPostRequest ( parameters ) ; } public Response sendResourceRequest ( String resourceLocation ) throws IOException { URL url = createUrl ( resourceLocation , new HashMap < String , String > ( ) ) ; HttpURLConnection connection = createConnection ( \"GET\" , url , 0 ) ; return new Response ( connection ) ; } public Response sendUICallBackRequest ( int timeout ) throws IOException { Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( IServiceHandler . REQUEST_PARAM , UICallBackServiceHandler . HANDLER_ID ) ; URL url = createUrl ( IServletEngine . SERVLET_NAME , parameters ) ; HttpURLConnection connection = createConnection ( \"GET\" , url , timeout ) ; return new Response ( connection ) ; } Response sendPostRequest ( ) throws IOException { return sendPostRequest ( new HashMap < String , String > ( ) ) ; } Response sendPostRequest ( Map < String , String > parameters ) throws IOException { return sendRequest ( \"POST\" , parameters ) ; } Response sendRequest ( String method , Map < String , String > parameters ) throws IOException { if ( requestCounter >= 0 ) { parameters . put ( \"requestCounter\" , String . valueOf ( requestCounter ) ) ; } URL url = createUrl ( IServletEngine . SERVLET_NAME , parameters ) ; HttpURLConnection connection = createConnection ( method , url , 0 ) ; parseSessionId ( connection ) ; requestCounter ++ ; return new Response ( connection ) ; } private URL createUrl ( String path , Map < String , String > parameters ) { int port = servletEngine . getPort ( ) ; HttpUrlBuilder urlBuilder = new HttpUrlBuilder ( \"localhost\" , port , path ) ; urlBuilder . addParameters ( parameters ) ; urlBuilder . setSessionId ( sessionId ) ; return urlBuilder . toUrl ( ) ; } private HttpURLConnection createConnection ( String method , URL url , int timeout ) throws IOException { HttpURLConnection result = ( HttpURLConnection ) connectionProvider . createConnection ( url ) ; result . setInstanceFollowRedirects ( false ) ; result . setAllowUserInteraction ( false ) ; result . setRequestMethod ( method ) ; result . setConnectTimeout ( timeout ) ; result . setReadTimeout ( timeout ) ; result . connect ( ) ; return result ; } private Map < String ,", "gt": "String > createDefaultParameters ( )", "prediction": "String > createParameters ( )\n", "label": 1}
{"id": 4806, "input": "<s> package com . sun . tools . javac . jvm ; import java . util . * ; import javax . lang . model . element . ElementKind ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . comp . * ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . jvm . Code . * ; import com . sun . tools . javac . jvm . Items . * ; import com . sun . tools . javac . tree . JCTree . * ; import static com . sun . tools . javac . code . Flags . * ; import static com . sun . tools . javac . code . Kinds . * ; import static com . sun . tools . javac . code . TypeTags . * ; import static com . sun . tools . javac . jvm . ByteCodes . * ; import static com . sun . tools . javac . jvm . CRTFlags . * ; import static com . sun . tools . javac . main . OptionName . * ; public class Gen extends JCTree . Visitor { protected static final Context . Key < Gen > genKey = new Context . Key < Gen > ( ) ; private final Log log ; private final Symtab syms ; private final Check chk ; private final Resolve rs ; private final TreeMaker make ; private final Names names ; private final Target target ; private final Type stringBufferType ; private final Map < Type , Symbol > stringBufferAppend ; private Name accessDollar ; private final Types types ; private final boolean allowGenerics ; private final boolean generateIproxies ; private final Code . StackMapFormat stackMap ; private final Type methodType ; public static Gen instance ( Context context ) { Gen instance = context . get ( genKey ) ; if ( instance == null ) instance = new Gen ( context ) ; return instance ; } protected Gen ( Context context ) { context . put ( genKey , this ) ; names = Names . instance ( context ) ; log = Log . instance ( context ) ; syms = Symtab . instance ( context ) ; chk = Check . instance ( context ) ; rs = Resolve . instance ( context ) ; make = TreeMaker . instance ( context ) ; target = Target . instance ( context ) ; types = Types . instance ( context ) ; methodType = new MethodType ( null , null , null , syms . methodClass ) ; allowGenerics = Source . instance ( context ) . allowGenerics ( ) ; stringBufferType = target . useStringBuilder ( ) ? syms . stringBuilderType : syms . stringBufferType ; stringBufferAppend = new HashMap < Type , Symbol > ( ) ; accessDollar = names . fromString ( \"access\" + target . syntheticNameChar ( ) ) ; Options options = Options . instance ( context ) ; lineDebugInfo = options . isUnset ( G_CUSTOM ) || options . isSet ( G_CUSTOM , \"lines\" ) ; varDebugInfo = options . isUnset ( G_CUSTOM ) ? options . isSet ( G ) : options . isSet ( G_CUSTOM , \"vars\" ) ; genCrt = options . isSet ( XJCOV ) ; debugCode = options . isSet ( \"debugcode\" ) ; allowInvokedynamic = target . hasInvokedynamic ( ) || options . isSet ( \"invokedynamic\" ) ; generateIproxies = target . requiresIproxy ( ) || options . isSet ( \"miranda\" ) ; if ( target . generateStackMapTable ( ) ) { this . stackMap = StackMapFormat . JSR202 ; } else { if ( target . generateCLDCStackmap ( ) ) { this . stackMap = StackMapFormat . CLDC ; } else { this . stackMap = StackMapFormat . NONE ; } } int setjsrlimit = 50 ; String jsrlimitString = options", "gt": ". get ( \"jsrlimit\" ) ;", "prediction": ". toString ( ) ;\n", "label": 0}
{"id": 13547, "input": "<s> package org . eclipse . ui ; public interface IViewSite extends IWorkbenchPartSite { public IActionBars getActionBars ( ) ;", "gt": "public String getSecondaryId ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6379, "input": "<s> import javax . tools . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import java . util . * ; import java . io . * ; public class T6406133 extends ToolTester { List < Locale > locales = Arrays . asList ( Locale . US , Locale . JAPAN , Locale . CHINA ) ; class DiagnosticTester implements DiagnosticListener < JavaFileObject > { Locale locale ; String result ; DiagnosticTester ( Locale locale ) { this . locale = locale ; } public void report ( Diagnostic < ? extends JavaFileObject > diagnostic ) { result = diagnostic . getMessage ( locale ) ; } } class ProcessorTester extends AbstractProcessor { Locale locale ; public Set < String > getSupportedAnnotationTypes ( ) { return new HashSet < String > ( Arrays . asList ( \"*\" ) ) ; } public void init ( ProcessingEnvironment env ) { locale = env . getLocale ( ) ; } public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { return true ; } } void compare ( Locale loc1 , Locale loc2 , boolean useListener ) { String res1 = exec ( useListener , loc1 ) ; String res2 = exec ( useListener , loc2 ) ; boolean success = ( loc1 . equals ( loc2 ) && res1 . equals ( res2 ) ) || ( ! loc1 . equals ( loc2 ) && ! res1 . equals ( res2 ) ) ; if ( ! success ) throw new AssertionError (", "gt": "\"Error in diagnostic localization\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13554, "input": "<s> package org . eclipse . rap . rwt . osgi . internal ; import java . util . * ; import org . osgi . framework . BundleContext ; import org . osgi . framework . ServiceReference ; class ServiceContainer < S > { private final Set < ServiceHolder < S > > services ; private final BundleContext bundleContext ; ServiceContainer ( BundleContext bundleContext ) { this . bundleContext = bundleContext ; this . services = new HashSet < ServiceHolder < S > > ( ) ; } ServiceHolder < S > add ( S service ) { return add ( service , null ) ; } ServiceHolder < S > add ( ServiceReference < S > reference ) { return add ( bundleContext . getService ( reference ) , reference ) ; } void remove ( S service ) { services . remove ( find ( service ) ) ; } @ SuppressWarnings ( \"unchecked\" ) ServiceHolder < S > [ ] getServices ( ) { Set < ServiceHolder < S > > result = new HashSet < ServiceHolder < S > > ( ) ; Iterator < ServiceHolder < S > > iterator = services . iterator ( ) ; while ( iterator . hasNext ( ) ) { result . add ( iterator . next ( ) ) ; } return result . toArray ( new ServiceHolder [ result . size ( ) ] ) ; } ServiceHolder < S > find ( S service ) { Finder < S > finder = new Finder < S > ( ) ; return finder . findServiceHolder ( service , services ) ; } void clear ( ) { services . clear ( ) ; } int size ( ) { return services . size ( ) ; } private ServiceHolder < S > add ( S service , ServiceReference < S > reference ) { ServiceHolder < S > result = find ( service ) ; if ( notFound ( result ) ) { result = new ServiceHolder < S > ( service , reference ) ; services . add ( result ) ; } else if ( referenceIsMissing ( reference , result ) ) { result . setServiceReference ( reference ) ; } return result ; } private boolean notFound ( ServiceHolder < S > result ) { return result == null ; } private boolean referenceIsMissing ( ServiceReference", "gt": "< S > reference , ServiceHolder < S > result )", "prediction": "< S > reference , ServiceHolder < S > result )\n", "label": 1}
{"id": 5974, "input": "<s> package org . ofbiz . shipment . shipment ; import java . io . IOException ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; public class ShipmentEvents { public static final String module = ShipmentEvents . class . getName ( ) ; public static String viewShipmentPackageRouteSegLabelImage ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String shipmentId = request . getParameter ( \"shipmentId\" ) ; String shipmentRouteSegmentId = request . getParameter ( \"shipmentRouteSegmentId\" ) ; String shipmentPackageSeqId = request . getParameter ( \"shipmentPackageSeqId\" ) ; GenericValue shipmentPackageRouteSeg = null ; try { shipmentPackageRouteSeg = delegator . findOne ( \"ShipmentPackageRouteSeg\" , UtilMisc . toMap ( \"shipmentId\" , shipmentId , \"shipmentRouteSegmentId\" , shipmentRouteSegmentId , \"shipmentPackageSeqId\" , shipmentPackageSeqId ) , false ) ; } catch ( GenericEntityException e ) { String errorMsg = \"Error looking up ShipmentPackageRouteSeg: \" + e . toString ( ) ; Debug . logError ( e , errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } if ( shipmentPackageRouteSeg == null ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , \"Could not find ShipmentPackageRouteSeg where shipmentId=[\" + shipmentId + \"], shipmentRouteSegmentId=[\" + shipmentRouteSegmentId + \"], shipmentPackageSeqId=[\" + shipmentPackageSeqId + \"]\" ) ; return \"error\" ; } byte [ ] bytes = shipmentPackageRouteSeg . getBytes ( \"labelImage\" ) ; if ( bytes == null || bytes . length == 0 ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , \"The ShipmentPackageRouteSeg was found where shipmentId=[\" + shipmentId + \"], shipmentRouteSegmentId=[\" + shipmentRouteSegmentId + \"], shipmentPackageSeqId=[\" + shipmentPackageSeqId + \"], but there was no labelImage on the value.\" ) ; return \"error\" ; } try { UtilHttp . streamContentToBrowser ( response , bytes , \"image/gif\" ) ; } catch ( IOException e1 ) { try { UtilHttp . streamContentToBrowser ( response , bytes , \"image/png\" ) ; }", "gt": "catch ( IOException e2 )", "prediction": "catch ( IOException e2 )\n", "label": 0}
{"id": 13557, "input": "<s> package org . eclipse . ui . internal ; public class ContainerPlaceholder extends PartPlaceholder implements ILayoutContainer { private static int nextId = 0 ; private ILayoutContainer realContainer ; public ContainerPlaceholder ( String id ) { super ( ( ( id == null ) ? \"Container Placeholder \" + nextId ++ : id ) ) ; } public void add ( LayoutPart child ) { if ( ! ( child instanceof PartPlaceholder ) ) { return ; } realContainer . add ( child ) ; } public boolean allowsBorder ( ) { return true ; } public LayoutPart [ ] getChildren ( ) { return realContainer . getChildren ( ) ; } public LayoutPart getFocus ( ) { return null ; } public LayoutPart getRealContainer ( ) { return ( LayoutPart ) realContainer ; } public boolean isChildVisible ( LayoutPart child ) { return false ; } public void remove ( LayoutPart child ) { if ( ! ( child instanceof PartPlaceholder ) ) { return ; } realContainer . remove ( child ) ; } public void replace ( LayoutPart oldChild , LayoutPart newChild ) { if ( ! ( oldChild instanceof PartPlaceholder ) && ! ( newChild instanceof PartPlaceholder ) ) { return ; } realContainer . replace ( oldChild , newChild ) ; } public void setChildVisible ( LayoutPart child , boolean visible ) { } public void setFocus ( LayoutPart child ) { } public void setRealContainer ( ILayoutContainer container ) { if ( container == null ) { if ( realContainer != null ) { LayoutPart [ ] children = realContainer . getChildren ( ) ; if ( children != null ) { for ( int i = 0 , length = children . length ; i < length ; i ++ ) { children [ i ] . setContainer ( realContainer ) ; } } } } else { LayoutPart [ ] children = container . getChildren ( ) ; if ( children != null ) { for ( int i = 0 , length = children . length ; i < length ; i ++ ) { children [ i ] . setContainer ( this ) ; } } } this . realContainer = container ; } public void findSashes (", "gt": "LayoutPart part , PartPane . Sashes sashes )", "prediction": ")\n", "label": 1}
{"id": 8628, "input": "<s> package com . asakusafw . example . jdbc . jobflow ; import com . asakusafw . example . jdbc . modelgen . dmdl . jdbc . AbstractStoreInfoJdbcImporterDescription ; public class StoreInfoFromJdbc extends AbstractStoreInfoJdbcImporterDescription { @ Override", "gt": "public String getProfileName ( )", "prediction": "public StoreInfoFromJdbc ( )\n", "label": 0}
{"id": 13558, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import org . eclipse . rap . rwt . internal . theme . QxFont ; import junit . framework . TestCase ; public class QxFont_Test extends TestCase { public void testIllegalArguments ( ) { try { QxFont . valueOf ( null ) ; fail ( \"null arguement should throw NPE\" ) ; } catch ( NullPointerException e ) { } try { QxFont . valueOf ( \"\" ) ; fail ( \"empty imput should throw IAE\" ) ; } catch ( IllegalArgumentException e ) { } } public void testParse1 ( ) { String def = \"bold 16 \\\"Bitstream Vera Sans\\\" , Helvetica,sans-serif\" ; QxFont qxFont = QxFont . valueOf ( def ) ; assertTrue ( qxFont . bold ) ; assertFalse ( qxFont . italic ) ; assertEquals ( 16 , qxFont . size ) ; assertEquals ( 3 , qxFont . family . length ) ; assertEquals ( \"Bitstream Vera Sans\" , qxFont . family [ 0 ] ) ; assertEquals ( \"Helvetica\" , qxFont . family [ 1 ] ) ; assertEquals ( \"sans-serif\" , qxFont . family [ 2 ] ) ; } public void testParse2 ( ) { String def = \"italic 11px 'Bitstream Vera Sans', Helvetica, sans-serif\" ; QxFont qxFont = QxFont . valueOf ( def ) ; assertFalse ( qxFont . bold ) ; assertTrue ( qxFont . italic ) ; assertEquals ( 11 , qxFont . size ) ; assertEquals ( 3 , qxFont . family . length ) ; assertEquals ( \"Bitstream Vera Sans\" , qxFont . family [ 0 ] ) ; assertEquals ( \"Helvetica\" , qxFont . family [ 1 ] ) ; assertEquals ( \"sans-serif\" , qxFont . family [ 2 ] ) ; } public void testDefaultString ( ) { String input = \"bold 16 \\\"Bitstream Vera Sans\\\" , 'Helvetica',sans-serif\" ; String exp = \"bold 16px \\\"Bitstream Vera Sans\\\", Helvetica, sans-serif\" ;", "gt": "QxFont qxFont = QxFont . valueOf ( input ) ;", "prediction": "QxFont qxFont = QxFont . valueOf ( input ) ;\n", "label": 1}
{"id": 1128, "input": "<s> package org . ofbiz . entity . cache ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; public class EntityCache extends AbstractCache < GenericPK , GenericValue > { public static final String module = EntityCache . class . getName ( ) ; public EntityCache ( String delegatorName ) { super ( delegatorName , \"entity\" ) ; } public GenericValue get ( GenericPK pk ) { UtilCache < GenericPK , GenericValue > entityCache = getCache ( pk . getEntityName ( ) ) ; if ( entityCache == null ) return null ; return entityCache . get ( pk ) ; } public GenericValue put ( GenericValue entity ) { if ( entity == null ) return null ; return put ( entity . getPrimaryKey ( ) , entity ) ; } public GenericValue put ( GenericPK pk , GenericValue entity ) { if ( pk . getModelEntity ( ) . getNeverCache ( ) ) { Debug . logWarning ( \"Tried to put a value of the \" + pk . getEntityName ( ) + \" entity in the BY PRIMARY KEY cache but this entity has never-cache set to true, not caching.\" , module ) ; return null ; } if ( entity == null ) { entity = GenericValue . NULL_VALUE ; } else { entity . setImmutable ( ) ; } UtilCache < GenericPK , GenericValue > entityCache = getOrCreateCache ( pk . getEntityName ( ) ) ; return entityCache . put ( pk , entity ) ; } public void remove ( String entityName , EntityCondition condition ) { UtilCache < GenericPK , GenericValue > entityCache = getCache ( entityName ) ; if ( entityCache == null ) return ; for ( GenericPK pk : entityCache . getCacheLineKeys ( ) ) { GenericValue entity = entityCache . get ( pk ) ; if ( entity == null ) continue ; if ( condition . entityMatches ( entity ) ) entityCache . remove ( pk ) ; } } public GenericValue remove ( GenericValue entity ) {", "gt": "return remove ( entity . getPrimaryKey ( ) ) ;", "prediction": "if ( entity == null ) return null ;\n", "label": 0}
{"id": 13562, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import org . restlet . Restlet ; import org . restlet . ext . wadl . WadlApplication ; import org . restlet . routing . Router ; public class MailServerApplication extends WadlApplication { public MailServerApplication ( ) { setName ( \"RESTful Mail API application\" ) ; setDescription ( \"Example API for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; } @ Override public Restlet createInboundRoot ( ) { Router router = new Router ( getContext ( ) ) ; router . attach ( \"/\" , RootServerResource . class ) ; router . attach ( \"/accounts/\" , AccountsServerResource . class ) ; router . attach ( \"/accounts/{accountId}\" , AccountServerResource . class ) ;", "gt": "router . attach ( \"/accounts/{accountId}/mails/\" , MailsServerResource . class ) ;", "prediction": "return router ;\n", "label": 1}
{"id": 8273, "input": "<s> package com . matburt . mobileorg . OrgData ; import android . app . Application ; import com . matburt . mobileorg . Services . SyncService ; public class MobileOrgApplication extends Application {", "gt": "@ Override public void onCreate ( )", "prediction": "private static final Log log = LogFactory . getLog ( MobileOrganizationApplication . class ) ;\n", "label": 0}
{"id": 13566, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage . transmogrify ; import java . util . Comparator ; public class MethodSpecificityComparator implements Comparator { public int compare ( Object o1 , Object o2 ) { int result = 0 ; IMethod method1 = ( IMethod ) o1 ; IMethod method2 = ( IMethod ) o2 ; if (", "gt": "method1 . equals ( method2 ) )", "prediction": "method1 . getName ( ) . equals ( method2 . getName ( ) ) )\n", "label": 1}
{"id": 9027, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ; public interface AccountShare extends EObject { Account getAccount ( ) ; void setAccount ( Account value ) ; float getShare ( ) ; void setShare", "gt": "( float value ) ;", "prediction": "( float value ) ;\n", "label": 0}
{"id": 13569, "input": "<s> package org . eclipse . xtext . xdoc . validation ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . xtext . validation . Check ; import org . eclipse . xtext . validation . ValidationMessageAcceptor ; import org . eclipse . xtext . xdoc . generator . util . LatexUtils ; import org . eclipse . xtext . xdoc . xdoc . AbstractSection ; import org . eclipse . xtext . xdoc . xdoc . CodeBlock ; import org . eclipse . xtext . xdoc . xdoc . CodeRef ; import org . eclipse . xtext . xdoc . xdoc . ImageRef ; import org . eclipse . xtext . xdoc . xdoc . Ref ; import org . eclipse . xtext . xdoc . xdoc . Table ; import org . eclipse . xtext . xdoc . xdoc . TableRow ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class XdocJavaValidator extends AbstractXdocJavaValidator { @ Check public void checkConsistentNumberOfColumns ( Table t ) { int columns = - 1 ; EList < TableRow > rows = t . getRows ( ) ; for ( TableRow tableRow : rows ) { if ( columns == - 1 ) columns = tableRow . getData ( ) . size ( ) ; if ( tableRow . getData ( ) . size ( ) != columns ) { error ( \"Each row must have the same number of entries (expected \" + columns + \" but was \" + tableRow . getData ( ) . size ( ) + \")\" , tableRow , XdocPackage . Literals . TABLE_ROW__DATA , ValidationMessageAcceptor . INSIGNIFICANT_INDEX ) ; } } } @ Check public void checkAbstractSectionHasTitle ( AbstractSection section ) { if ( section . getTitle ( ) == null ) warning ( \"This element should have a title.\" ,", "gt": "null , 0 ) ;", "prediction": "section ) ;\n", "label": 1}
{"id": 687, "input": "<s> package org . ofbiz . base . util ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import java . util . TreeSet ; @ SuppressWarnings ( \"serial\" ) public class MessageString implements Serializable { public static final String module = MessageString . class . getName ( ) ; protected String message ; protected String fieldName ; protected String toFieldName ; protected Throwable sourceError ; protected Locale locale ; protected String propertyResource ; protected String propertyName ; protected boolean isError = true ; public static List < Object > getMessagesForField ( String fieldName , boolean convertToStrings , List < Object > messageStringList ) { if ( fieldName == null ) { return Collections . emptyList ( ) ; } Set < String > fieldSet = new TreeSet < String > ( ) ; fieldSet . add ( fieldName ) ; return getMessagesForField ( fieldSet , convertToStrings , messageStringList ) ; } public static List < Object > getMessagesForField ( String fieldName1 , String fieldName2 , String fieldName3 , String fieldName4 , boolean convertToStrings , List < Object > messageStringList ) { Set < String > fieldSet = new TreeSet < String > ( ) ; if ( UtilValidate . isNotEmpty ( fieldName1 ) ) fieldSet . add ( fieldName1 ) ; if ( UtilValidate . isNotEmpty ( fieldName2 ) ) fieldSet . add ( fieldName2 ) ; if ( UtilValidate . isNotEmpty ( fieldName3 ) ) fieldSet . add ( fieldName3 ) ; if ( UtilValidate . isNotEmpty ( fieldName4 ) ) fieldSet . add ( fieldName4 ) ; return getMessagesForField ( fieldSet , convertToStrings , messageStringList ) ; } public static List < Object > getMessagesForField ( Set < String > fieldNameSet , boolean convertToStrings , List < Object > messageStringList ) { if ( messageStringList == null || UtilValidate . isEmpty ( fieldNameSet ) ) { return Collections . emptyList ( ) ; } List < Object > outList = new ArrayList < Object > ( messageStringList . size ( ) ) ; for ( Object messageStringCur : messageStringList ) { if ( messageStringCur instanceof MessageString ) { MessageString messageString = ( MessageString ) messageStringCur ; if ( messageString . isForField ( fieldNameSet ) ) { if ( convertToStrings ) { outList . add ( messageString . toString ( ) ) ; } else { outList . add ( messageString ) ; } } } else { continue ; } } return outList ; } public MessageString ( String message , String fieldName , String propertyResource , String propertyName , Locale locale , boolean isError ) { this . message = message ; this . fieldName = fieldName ; this . locale = locale ; this . propertyResource = propertyResource ; this . propertyName = propertyName ; this . isError = isError ; } public MessageString ( String message , String fieldName , boolean isError ) { this . message = message ; this . fieldName = fieldName ; this . isError = isError ; } public MessageString ( String message , String fieldName , String toFieldName , Throwable sourceError ) { this . message = message ; this . fieldName = fieldName ; this . toFieldName = toFieldName ; this . sourceError = sourceError ; this . isError = true ; } public MessageString ( String message , Throwable sourceError ) { this . message = message ; this . sourceError = sourceError ; this . isError = true ; } public String getFieldName ( ) { return fieldName ; } public void setFieldName ( String fieldName ) { this . fieldName = fieldName ; } public boolean isForField ( Set < String > fieldNameSet ) { if ( fieldNameSet == null ) { return true ; } return fieldNameSet . contains ( this . fieldName ) ; } public boolean isForField ( String fieldName ) { if ( this . fieldName == null ) { if ( fieldName == null ) { return true ; } else { return false ; } } else { return this . fieldName . equals ( fieldName ) ; } } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } public Throwable getSourceError ( ) { return sourceError ; } public void setSourceError ( Throwable sourceError ) { this . sourceError = sourceError ; } public String getToFieldName ( ) { return toFieldName ; } public void setToFieldName ( String toFieldName ) { this . toFieldName = toFieldName ; } public Locale getLocale ( ) { return locale ; } public void setLocale ( Locale locale ) { this . locale = locale ; } public String getPropertyName ( ) { return propertyName ; } public void setPropertyName ( String propertyName ) { this . propertyName = propertyName ; } public String getPropertyResource ( ) { return propertyResource ; } public", "gt": "void setPropertyResource ( String propertyResource )", "prediction": "void setPropertyResource ( String propertyResource )\n", "label": 0}
{"id": 13576, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . actions . PartEventAction ; import org . eclipse . ui . actions . ActionFactory . IWorkbenchAction ; public abstract class PageEventAction extends PartEventAction implements IPageListener , ActionFactory . IWorkbenchAction { private IWorkbenchPage activePage ; private IWorkbenchWindow workbenchWindow ; protected PageEventAction ( String text , IWorkbenchWindow window ) { super ( text ) ; if ( window == null ) { throw new IllegalArgumentException ( ) ; } this . workbenchWindow = window ; this . activePage = window . getActivePage ( ) ; this . workbenchWindow . addPageListener ( this ) ; this . workbenchWindow . getPartService ( ) . addPartListener ( this ) ; } public final IWorkbenchPage getActivePage ( ) { return activePage ; } public final IWorkbenchWindow getWorkbenchWindow ( ) { return workbenchWindow ; } public void pageActivated ( IWorkbenchPage page ) { this . activePage = page ; } public void", "gt": "pageClosed ( IWorkbenchPage page )", "prediction": "pageDeactivated ( IWorkbenchPage page )\n", "label": 1}
{"id": 5228, "input": "<s> package com . sun . source . tree ; public interface BinaryTree extends ExpressionTree { ExpressionTree getLeftOperand ( ) ;", "gt": "ExpressionTree getRightOperand ( ) ;", "prediction": "ExpressionTree getRightOperand ( ) ;\n", "label": 0}
{"id": 13580, "input": "<s> package org . apache . lucene . search . similar ; import org . apache . lucene . util . PriorityQueue ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermFreqVector ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . DefaultSimilarity ; import org . apache . lucene . search . Similarity ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Hits ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . document . Document ; import java . util . Set ; import java . util . HashMap ; import java . util . Map ; import java . util . Collection ; import java . util . Iterator ; import java . io . IOException ; import java . io . Reader ; import java . io . File ; import java . io . PrintStream ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . net . URL ; import java . util . ArrayList ; public final class MoreLikeThis { public static final int DEFAULT_MAX_NUM_TOKENS_PARSED = 5000 ; public static final Analyzer DEFAULT_ANALYZER = new StandardAnalyzer ( ) ; public static final int DEFAULT_MIN_TERM_FREQ = 2 ; public static final int DEFAULT_MIN_DOC_FREQ = 5 ; public static final boolean DEFAULT_BOOST = false ; public static final String [ ] DEFAULT_FIELD_NAMES = new String [ ] { \"contents\" } ; public static final int DEFAULT_MIN_WORD_LENGTH = 0 ; public static final int DEFAULT_MAX_WORD_LENGTH = 0 ; public static final Set DEFAULT_STOP_WORDS = null ; private Set stopWords = DEFAULT_STOP_WORDS ; public static final int DEFAULT_MAX_QUERY_TERMS = 25 ; private Analyzer analyzer = DEFAULT_ANALYZER ; private int minTermFreq = DEFAULT_MIN_TERM_FREQ ; private int minDocFreq = DEFAULT_MIN_DOC_FREQ ; private boolean boost = DEFAULT_BOOST ; private String [ ] fieldNames = DEFAULT_FIELD_NAMES ; private int maxNumTokensParsed = DEFAULT_MAX_NUM_TOKENS_PARSED ; private int minWordLen = DEFAULT_MIN_WORD_LENGTH ; private int maxWordLen = DEFAULT_MAX_WORD_LENGTH ; private int maxQueryTerms = DEFAULT_MAX_QUERY_TERMS ; private Similarity similarity ; private final IndexReader ir ; private float boostFactor = 1 ; public float getBoostFactor ( ) { return boostFactor ; } public void setBoostFactor ( float boostFactor ) { this . boostFactor = boostFactor ; } public MoreLikeThis ( IndexReader ir ) { this ( ir , new DefaultSimilarity ( ) ) ; } public MoreLikeThis ( IndexReader ir , Similarity sim ) { this . ir = ir ; this . similarity = sim ; } public Similarity getSimilarity ( ) { return similarity ; } public void setSimilarity ( Similarity similarity ) { this . similarity = similarity ; } public Analyzer getAnalyzer ( ) { return analyzer ; } public void setAnalyzer ( Analyzer analyzer ) { this . analyzer = analyzer ; } public int getMinTermFreq ( ) { return minTermFreq ; } public void setMinTermFreq ( int minTermFreq ) { this . minTermFreq = minTermFreq ; } public int getMinDocFreq ( ) { return minDocFreq ; } public void setMinDocFreq ( int minDocFreq ) { this . minDocFreq = minDocFreq ; } public boolean isBoost ( ) { return boost ; } public void setBoost ( boolean boost ) { this . boost = boost ; } public String [ ] getFieldNames ( ) { return fieldNames ; } public void setFieldNames ( String [ ] fieldNames ) { this . fieldNames = fieldNames ; }", "gt": "public int getMinWordLen ( )", "prediction": "public Similarity getSimilarity ( )\n", "label": 1}
{"id": 9449, "input": "<s> package ar . com . fdvs . dj . test ; import java . util . Collections ; import java . util . Date ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . data . JRBeanCollectionDataSource ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; public class WhenNoDataTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; Style noDataStyle = new StyleBuilder ( false ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . build ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addAutoText ( AutoText . AUTOTEXT_PAGE_X , AutoText . POSITION_HEADER , AutoText . ALIGNMENT_LEFT ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setWhenNoData ( \"No data for this report\" , null , false ,", "gt": "true ) . setUseFullPageWidth ( true ) ;", "prediction": "noDataStyle ) ;\n", "label": 0}
{"id": 13585, "input": "<s> package org . jscsi . scsi . tasks . buffered ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import java . nio . ByteBuffer ; import java . util . Random ; import org . apache . log4j . Logger ; import org . jscsi . scsi . protocol . cdb . CDB ; import org . jscsi . scsi . protocol . cdb . Read10 ; import org . jscsi . scsi . protocol . cdb . Read12 ; import org . jscsi . scsi . protocol . cdb . Read16 ; import org . jscsi . scsi . protocol . cdb . Read6 ; import org . jscsi . scsi . protocol . cdb . Write10 ; import org . jscsi . scsi . protocol . cdb . Write12 ; import org . jscsi . scsi . protocol . cdb . Write16 ; import org . jscsi . scsi . protocol . cdb . Write6 ; import org . junit . Test ; public class BufferedUDCTaskTest extends BufferTestTask { private static Logger _logger = Logger . getLogger ( BufferedUDCTaskTest . class ) ; private static final int MIN_BLOCKS = 5 ; private static final int MAX_BLOCKS = 15 ; private static int ITERATIONS = 10 ; private static int cmdRef = 0 ; private Random rnd = new Random ( ) ; @ Test public void testUDC ( ) { for ( int itr = 0 ; itr < ITERATIONS ; itr ++ ) { int numBlocks = Math . abs ( rnd . nextInt ( ) % ( MAX_BLOCKS - MIN_BLOCKS ) ) + MIN_BLOCKS ; ByteBuffer data = generateData ( numBlocks * STORE_BLOCK_SIZE ) ; int lba = Math . abs ( rnd . nextInt ( ) ) % ( ( STORE_CAPACITY / STORE_BLOCK_SIZE ) - numBlocks ) ; performWrite6 ( lba , numBlocks , data ) ; performRead6 ( lba , numBlocks , data ) ; performWrite10 ( lba , numBlocks , data ) ; performRead10 ( lba , numBlocks , data ) ; performWrite12 ( lba , numBlocks , data ) ; performRead12 ( lba , numBlocks , data ) ; performWrite16 ( lba , numBlocks , data ) ; performRead16 ( lba , numBlocks , data ) ; } } private void performWrite6 ( int lba , int numBlocks , ByteBuffer data ) { _logger . debug ( \"********** WRITE6 MEMORY **********\" ) ; CDB cdb = new Write6 ( false , true , lba , numBlocks ) ; this . addReadData ( numBlocks * STORE_BLOCK_SIZE , cmdRef , data ) ; this . submitMemoryTask ( cdb , cmdRef ) ; this . purgeReadData ( cmdRef ) ; cmdRef ++ ; } private void performWrite10 ( int lba , int numBlocks , ByteBuffer data ) { _logger . debug ( \"********** WRITE10 MEMORY **********\" ) ; CDB cdb = new Write10 ( 0 , false , false , false , false , false , lba , numBlocks ) ; this . addReadData ( numBlocks * STORE_BLOCK_SIZE , cmdRef , data ) ; this . submitMemoryTask ( cdb , cmdRef ) ; this . purgeReadData ( cmdRef ) ; cmdRef ++ ; } private void performWrite12 ( int lba , int numBlocks , ByteBuffer data ) { _logger . debug (", "gt": "\"********** WRITE12 MEMORY **********\" ) ;", "prediction": "\"********** WRITE12 MEMORY **********\" ) ;\n", "label": 1}
{"id": 6895, "input": "<s> package org . apache . giraph . examples ; import com . google . common . base . Preconditions ; import com . google . common . collect . Maps ; import org . apache . giraph . graph . BasicVertex ; import org . apache . giraph . graph . BspUtils ; import org . apache . giraph . graph . GiraphJob ; import org . apache . giraph . graph . EdgeListVertex ; import org . apache . giraph . graph . Edge ; import org . apache . giraph . graph . VertexReader ; import org . apache . giraph . graph . VertexWriter ; import org . apache . giraph . lib . TextVertexInputFormat ; import org . apache . giraph . lib . TextVertexInputFormat . TextVertexReader ; import org . apache . giraph . lib . TextVertexOutputFormat ; import org . apache . giraph . lib . TextVertexOutputFormat . TextVertexWriter ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . DoubleWritable ; import org . apache . hadoop . io . FloatWritable ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . ArrayWritable ; import org . apache . hadoop . io . Writable ; import org . apache . giraph . examples . LongArrayWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . InputSplit ; import org . apache . hadoop . mapreduce . RecordReader ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import org . apache . hadoop . mapreduce . lib . input . FileInputFormat ; import org . apache . hadoop . mapreduce . lib . output . FileOutputFormat ; import org . apache . hadoop . util . Tool ; import org . apache . hadoop . util . ToolRunner ; import org . apache . log4j . Logger ; import org . json . JSONArray ; import org . json . JSONException ; import java . io . IOException ; import java . util . Iterator ; import java . util . Map ; import java . util . List ; import java . util . ArrayList ; public class OutDegreeCentralityVertex extends EdgeListVertex < LongWritable , DoubleWritable , FloatWritable , LongWritable > implements Tool { private Configuration conf ; private static final Logger LOG = Logger . getLogger ( OutDegreeCentralityVertex . class ) ; public static String SOURCE_ID = \"OutDegreeCentralityVertex.sourceId\" ; public static long SOURCE_ID_DEFAULT = 1 ; private boolean isSource ( ) { return ( getVertexId ( ) . get ( ) == getContext ( ) . getConfiguration ( ) . getLong ( SOURCE_ID , SOURCE_ID_DEFAULT ) ) ; } @ Override public void compute ( Iterator < LongWritable > msgIterator ) { if", "gt": "( getSuperstep ( ) == 0 )", "prediction": "( msgIterator . hasNext ( ) )\n", "label": 0}
{"id": 13587, "input": "<s> package me . saac . i ; import java . io . IOException ; import java . util . StringTokenizer ; import java . util . ArrayList ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IntWritable ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . Reducer ; import org . apache . hadoop . mapreduce . lib . input . TextInputFormat ; import org . apache . hadoop . mapreduce . lib . output . TextOutputFormat ; import org . apache . hadoop . util . GenericOptionsParser ; import org . apache . hadoop . mapreduce . Counters ; import org . apache . hadoop . mapreduce . Counter ; public class ConComs { public static enum CHANGED_NODES_COUNTER { CHANGED_NODES } ; public static class CCMapper extends Mapper < LongWritable , Text , IntWritable , IntWritable > { private IntWritable k = new IntWritable ( ) ; private IntWritable v = new IntWritable ( ) ; public void map ( LongWritable key , Text value , Context context ) throws IOException , InterruptedException { String str = value . toString ( ) ; String [ ] data = str . split ( \"\\t\" ) ; k . set ( Integer . parseInt ( data [ 0 ] ) ) ; v . set ( Integer . parseInt ( data [ 1 ] ) ) ; context . write ( k , v ) ; } } public static class CCReducer extends Reducer < IntWritable , IntWritable , IntWritable , IntWritable > { private ArrayList < Integer > node2s = new ArrayList ( ) ; private IntWritable k = new IntWritable ( ) ; private IntWritable v = new IntWritable ( ) ; public void reduce ( IntWritable key , Iterable < IntWritable > values , Context context ) throws IOException , InterruptedException { int node1 = key . get ( ) ; int node2 ; boolean node1isOn = false ; if ( node1 == 0 ) return ; node2s . clear ( ) ; for ( IntWritable val : values ) { node2 = val . get ( ) ; if ( node2 == 0 ) { node1isOn = true ; } else { node2s . add ( node2 ) ; } } if ( node1isOn ) { v . set ( 0 ) ; context . write ( key , v ) ; for ( Integer n2 : node2s ) { k . set ( n2 ) ; context . write ( k , v ) ; context . getCounter ( CHANGED_NODES_COUNTER . CHANGED_NODES ) . increment ( 1 ) ; } } else { for ( Integer n2 : node2s ) { v . set ( n2 ) ; context . write ( key , v ) ; } } } } public static void main ( String [ ] args ) throws Exception { Configuration conf = new Configuration ( ) ; String [ ] otherArgs = new GenericOptionsParser ( conf , args ) . getRemainingArgs ( ) ; if ( otherArgs . length != 2 ) { System", "gt": ". err . println ( \"Usage: indycascade <in> <out>\" ) ;", "prediction": ". exit ( 1 ) ;\n", "label": 1}
{"id": 9099, "input": "<s> public class T6182630a { static class Foo < X > { public X x ; public void m ( X x ) { } } interface Bar { } < T extends Foo , S extends Foo & Bar > void test1 ( T t , S s ) {", "gt": "t . x = \"BAD\" ;", "prediction": "}\n", "label": 0}
{"id": 13598, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . stats . Report ; import org . apache . lucene . benchmark . byTask . stats . TaskStats ; public class RepSumByNameRoundTask extends ReportTask { public RepSumByNameRoundTask ( PerfRunData runData ) { super ( runData ) ; } public int doLogic ( ) throws Exception { Report rp = reportSumByNameRound ( getRunData ( ) . getPoints ( ) . taskStats ( ) ) ; System . out . println ( ) ; System . out . println ( \"------------> Report Sum By (any) Name and Round (\" + rp . getSize ( ) + \" about \" + rp . getReported ( ) + \" out of \" + rp . getOutOf ( ) + \")\" ) ; System . out . println ( rp . getText ( ) ) ; System . out . println ( ) ; return 0 ; } protected Report reportSumByNameRound ( List taskStats ) { LinkedHashMap p2 = new LinkedHashMap ( ) ; int reported = 0 ; for ( Iterator it = taskStats . iterator ( ) ; it . hasNext ( ) ; ) { TaskStats stat1 = ( TaskStats ) it . next ( ) ; if ( stat1 . getElapsed ( ) >= 0 ) { reported ++ ; String name = stat1 . getTask ( ) . getName ( ) ; String rname =", "gt": "stat1 . getRound ( ) + \".\" + name ;", "prediction": "stat1 . getReported ( ) ;\n", "label": 1}
{"id": 6073, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import com . sun . source . util . JavacTask ; import com . sun . tools . javac . api . JavacTool ; public class T6430241 { public static void main ( String ... args ) throws Exception { new T6430241 ( ) . run ( ) ; } void run ( ) throws Exception { setup ( ) ; testCommandLine ( ) ; testSimpleAPI ( ) ; testTaskAPI ( ) ; if ( errors > 0 ) throw new Exception ( errors + \" errors found\" ) ; } void setup ( ) throws Exception { classesDir = new File ( \"classes\" ) ; classesDir . mkdirs ( ) ; emptyDir = new File ( \"empty\" ) ; emptyDir . mkdirs ( ) ; bootClassPath = System . getProperty ( \"sun.boot.class.path\" ) ; File srcDir = new File ( \"src\" ) ; String test = \"import sun.misc.Unsafe; class Test { }\" ; testFile = writeFile ( srcDir , \"Test.java\" , test ) ; } void testCommandLine ( ) throws Exception { testCommandLine ( true ) ; testCommandLine ( true , \"-Xbootclasspath/p:\" + emptyDir ) ; testCommandLine ( false , \"-Xbootclasspath:\" + bootClassPath ) ; testCommandLine ( true , \"-Xbootclasspath/a:\" + emptyDir ) ; testCommandLine ( false , \"-XDignore.symbol.file\" ) ; System . err . println ( ) ; } void testCommandLine ( boolean expectWarnings , String ... opts ) throws Exception { System . err . println ( \"test command line: \" + Arrays . asList ( opts ) ) ; String [ ] args = initArgs ( opts ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javac . Main . compile ( args , pw ) ; String out = showOutput ( sw . toString ( ) ) ; checkCompilationOK ( rc ) ; checkOutput ( out , expectWarnings ) ; } void testSimpleAPI ( ) { testSimpleAPI ( true ) ; testSimpleAPI ( true , \"-Xbootclasspath/p:\" + emptyDir ) ; testSimpleAPI ( false , \"-Xbootclasspath:\" + bootClassPath ) ; testSimpleAPI ( true , \"-Xbootclasspath/a:\" + emptyDir ) ; testSimpleAPI ( false , \"-XDignore.symbol.file\" ) ; System . err . println ( ) ; } void testSimpleAPI ( boolean expectWarnings , String ... opts ) { System . err . println ( \"test simple API: \" + Arrays . asList ( opts ) ) ; String [ ] args = initArgs ( opts ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; JavacTool tool = JavacTool . create ( ) ; int rc = tool . run ( null , null , ps , args ) ; String out = showOutput ( baos . toString ( ) ) ; checkCompilationOK ( rc ) ; checkOutput ( out , expectWarnings ) ; } void testTaskAPI ( ) throws Exception { List < File > bcp = new ArrayList < File > ( ) ; for ( String f : bootClassPath . split ( File . pathSeparator ) ) { if ( ! f . isEmpty ( ) ) bcp . add ( new File ( f ) ) ; } testTaskAPI ( true , null ) ; testTaskAPI ( false , bcp ) ; System . err . println ( ) ; } void testTaskAPI ( boolean expectWarnings , Iterable < ? extends File > pcp ) throws Exception { System . err . println ( \"test task API: \" + pcp ) ; JavacTool tool = JavacTool . create ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( null , null , null ) ; if ( pcp != null ) fm . setLocation ( StandardLocation . PLATFORM_CLASS_PATH , pcp ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjects ( testFile ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; JavacTask task = tool . getTask ( pw , fm , null , null , null , files ) ; boolean ok = task . call ( ) ; String out = showOutput ( sw . toString ( ) ) ; checkCompilationOK ( ok ) ; checkOutput ( out , expectWarnings ) ; } File writeFile ( File dir , String path , String content ) throws IOException { File f = new File ( dir , path ) ; f . getParentFile ( ) . mkdirs ( ) ; FileWriter out = new FileWriter ( f ) ; try { out . write ( content ) ; } finally { out . close ( ) ; } return f ; } String [ ] initArgs ( String [ ] opts ) { List < String > args = new ArrayList < String > ( ) ; args . addAll ( Arrays . asList ( opts ) ) ; args . add ( \"-d\" ) ; args . add ( classesDir . getPath ( ) ) ; args . add ( testFile . getPath ( ) ) ; return args . toArray ( new String [ args . size ( ) ] ) ; } String showOutput ( String out ) { if ( ! out . isEmpty ( ) ) System . err . println ( out ) ; return out ; } void checkCompilationOK ( boolean ok ) { if ( ! ok ) error ( \"compilation failed\" ) ; } void checkCompilationOK ( int rc ) { if ( rc != 0 )", "gt": "error ( \"compilation failed, rc: \" + rc ) ;", "prediction": "\n", "label": 0}
{"id": 13599, "input": "<s> package org . restlet . ext . xdb . internal ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PushbackInputStream ; public class ChunkedInputStream extends InputEntityStream { private static final int PUSHBBACK_BUFFER_SIZE = 2 ; private volatile long chunkSize ; private volatile boolean endReached ; private volatile boolean initialized ; private volatile long position ; private final PushbackInputStream source ; public ChunkedInputStream ( Notifiable notifiable , InputStream inboundStream ) { super ( notifiable , inboundStream ) ; this . source = new PushbackInputStream ( inboundStream , PUSHBBACK_BUFFER_SIZE ) ; this . initialized = false ; this . endReached = false ; this . position = 0 ; this . chunkSize = 0 ; } private boolean canRead ( ) throws IOException { boolean result = false ; initialize ( ) ; if ( ! this . endReached ) { if ( ! chunkAvailable ( ) ) { initializeChunk ( ) ; } result = ! this . endReached ; } return result ; } private void checkCRLF ( ) throws IOException { final int cr = this . source . read ( ) ; final int lf = this . source . read ( ) ; if ( ( cr != '\\r' ) || ( lf != '\\n' ) ) { this . source . unread ( lf ) ; this . source . unread ( cr ) ; } } private boolean chunkAvailable ( ) { return this . position < this . chunkSize ; } @ Override public void close ( ) throws IOException { super . close ( ) ; this . initialized = true ; onEndReached ( ) ; } private void initialize ( ) throws IOException { if ( ! this . initialized ) { checkCRLF ( ) ; this . initialized = true ; } } private void initializeChunk ( ) throws IOException { this . chunkSize = readChunkSize ( ) ; this . position = 0 ; if ( this . chunkSize == 0 ) { onEndReached ( ) ; checkCRLF ( ) ; } } @ Override protected void onEndReached ( ) { super . onEndReached ( ) ; this . endReached = true ; } @ Override public int read ( ) throws IOException { int result = - 1 ; if ( canRead ( ) ) { result = this . source . read ( ) ; this . position ++ ; if", "gt": "( ( result == - 1 ) )", "prediction": "( result == - 1 )\n", "label": 1}
{"id": 5700, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; class MacFileUtil { final static void deleteDirectory ( final File dir ) throws Exception { if ( ! dir . exists ( ) ) return ; if ( dir . isFile ( ) ) throw new IllegalStateException ( dir + \" is not a directory.\" ) ; process ( \"rm\" , \"-rf\" , dir . getAbsolutePath ( ) ) ; if ( dir . exists ( ) ) { throw new IllegalStateException ( \"The removal of the dir \" + dir . getAbsolutePath ( ) + \" failed. The dir still exists.\" ) ; } } final static void setWritableRecursive ( final boolean writable , final File root ) throws Exception { if ( ! root . exists ( ) ) return ; if ( root . isDirectory ( ) ) { process ( \"chmod\" , \"755\" , root . getAbsolutePath ( ) ) ; for ( final File child : root . listFiles ( ) ) setWritableRecursive ( writable , child ) ; } else { if ( writable ) { process ( \"chmod\"", "gt": ", \"644\" , root . getAbsolutePath ( ) ) ;", "prediction": ", \"755\" , root . getAbsolutePath ( ) ) ;\n", "label": 0}
{"id": 13603, "input": "<s> package org . nuxeo . theme . editor . filters ; import org . nuxeo . theme . rendering . RenderingInfo ; import org . nuxeo . theme . rendering . StandaloneFilter ; public final class IdentifiableContainer extends StandaloneFilter { @ Override public RenderingInfo process ( final RenderingInfo info , final boolean cache ) { info . setMarkup ( String . format ( \"<div id=\\\"e%s\\\">%s</div>\" , info . getElement ( ) . getUid ( ) ,", "gt": "info . getMarkup ( ) ) ) ;", "prediction": "info . getMarkup ( ) ) ) ;\n", "label": 1}
{"id": 6269, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Projectile ; public interface LizaProjectile extends Projectile { List < LizaEntity > getNearbyLizaEntities (", "gt": "double x , double y , double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13605, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationDocumentation ; import org . nuxeo . ecm . automation . OperationParameters ; public class AutomationInfo { protected final List < OperationDocumentation > ops ; protected final List < OperationDocumentation > chains ; public AutomationInfo ( AutomationService service ) { ops = service . getDocumentation ( ) ; Map < String , OperationDocumentation > map = new HashMap < String , OperationDocumentation > ( ) ; for ( OperationDocumentation doc : ops ) { map . put ( doc . id , doc ) ; } chains = new ArrayList < OperationDocumentation > ( ) ; for ( OperationChain chain : service . getOperationChains ( ) ) { OperationDocumentation doc = new OperationDocumentation ( chain . getId ( ) ) ; doc . description = chain . getDescription ( ) ; doc . category = \"Chain\" ; doc . label = doc . id ; doc . params = Collections . emptyList ( ) ; List < OperationParameters > ops = chain . getOperations ( ) ; if ( ops . isEmpty ( ) ) { doc . signature = new String [ ] { \"void\" , \"void\" } ; } else if ( ops . size ( ) == 1 ) { OperationDocumentation opdoc = map . get ( ops . get ( 0 ) . id ( ) ) ; doc . signature = opdoc . signature ; } else { ArrayList < String [ ] > sigs = new ArrayList < String [ ] > ( ) ; for ( OperationParameters o : ops ) { sigs . add ( map . get ( o . id ( ) ) . signature ) ; } String [ ] head = sigs . get ( 0 ) ; ArrayList < String > rs = new ArrayList < String > ( ) ; for ( int i = 0 ; i < head . length ; i += 2 ) { String in = head [ i ] ; String out = head [ i + 1 ] ; List < String > result = new ArrayList < String > ( ) ; checkPath ( out , sigs , 1 , result ) ; for ( String r : result ) { rs . add ( in ) ; rs . add ( r ) ; } } doc . signature = rs . toArray ( new String [ rs . size ( ) ] ) ; } chains . add ( doc ) ; } } protected void checkPath ( String in , List < String [ ] > sigs , int offset , List < String > result ) { boolean last = sigs . size ( ) - 1 == offset ; String [ ] sig = sigs . get ( offset ) ; for ( int i = 0 ; i < sig . length ; i += 2 ) { if ( \"void\" . equals ( in ) || \"void\" . equals ( sig [ i ] ) || in . equals ( sig [ i ] ) ) { if ( last ) { result . add ( sig [ i + 1 ] ) ; } else { checkPath ( sig [ i + 1 ] , sigs , offset + 1 , result ) ; } } } } public List < OperationDocumentation > getOperations ( ) { return ops ; } public List <", "gt": "OperationDocumentation > getChains ( )", "prediction": "OperationDocumentation > getChains ( )\n", "label": 1}
{"id": 6324, "input": "<s> import com . sun . source . util . JavacTask ; import com . sun . tools . classfile . Instruction ; import com . sun . tools . classfile . Attribute ; import com . sun . tools . classfile . ClassFile ; import com . sun . tools . classfile . Code_attribute ; import com . sun . tools . classfile . ConstantPool . * ; import com . sun . tools . classfile . Method ; import com . sun . tools . javac . api . JavacTool ; import com . sun . tools . javac . util . List ; import java . io . File ; import java . net . URI ; import java . util . Arrays ; import java . util . Locale ; import javax . tools . Diagnostic ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . StandardJavaFileManager ; import javax . tools . ToolProvider ; public class T6199075 { int checkCount = 0 ; int bytecodeCheckCount = 0 ; enum TypeKind { BYTE ( \"byte\" , \"(byte)1\" , \"[B\" , 0 ) , CHAR ( \"char\" , \"'c'\" , \"[C\" , 1 ) , SHORT ( \"short\" , \"(short)1\" , \"[S\" , 2 ) , INT ( \"int\" , \"1\" , \"[I\" , 3 ) , LONG ( \"long\" , \"1L\" , \"[J\" , 4 ) , FLOAT ( \"float\" , \"1.0F\" , \"[F\" , 5 ) , DOUBLE ( \"double\" , \"1.0D\" , \"[D\" , 6 ) , BOOLEAN ( \"boolean\" , \"true\" , \"[Z\" , - 1 ) ; String typeString ; String valueString ; String bytecodeString ; private int subtypeTag ; TypeKind ( String typeString , String valueString , String bytecodeString , int subtypeTag ) { this . typeString = typeString ; this . valueString = valueString ; this . bytecodeString = bytecodeString ; this . subtypeTag = subtypeTag ; } boolean isSubtypeOf ( TypeKind that ) { switch ( this ) { case BOOLEAN : return that == BOOLEAN ; case BYTE : case CHAR : return this . subtypeTag == that . subtypeTag || this . subtypeTag + 2 <= that . subtypeTag ; default : return this . subtypeTag <= that . subtypeTag ; } } } enum ArgumentsArity { ZERO ( 0 ) , ONE ( 1 ) , TWO ( 2 ) , THREE ( 3 ) ; int arity ; ArgumentsArity ( int arity ) { this . arity = arity ; } String asExpressionList ( TypeKind type ) { StringBuilder buf = new StringBuilder ( ) ; String sep = \"\" ; for ( int i = 0 ; i < arity ; i ++ ) { buf . append ( sep ) ; buf . append ( type . valueString ) ; sep = \",\" ; } return buf . toString ( ) ; } } static class VarargsMethod { TypeKind varargsElement ; VarargsMethod ( TypeKind varargsElement ) { this . varargsElement = varargsElement ; } @ Override public String toString ( ) { return \"void m(\" + varargsElement . typeString + \"... args) {}\" ; } boolean isApplicable ( TypeKind actual , ArgumentsArity argsArity ) { return argsArity == ArgumentsArity . ZERO || actual . isSubtypeOf ( varargsElement ) ; } boolean isMoreSpecificThan ( VarargsMethod that ) { return varargsElement . isSubtypeOf ( that . varargsElement ) ; } } public static void main ( String ... args ) throws Exception { new T6199075 ( ) . test ( ) ; } void test ( ) throws Exception { for ( TypeKind formal1 : TypeKind . values ( ) ) { VarargsMethod m1 = new VarargsMethod ( formal1 ) ; for ( TypeKind formal2 : TypeKind . values ( ) ) { VarargsMethod m2 = new VarargsMethod ( formal2 ) ; for ( TypeKind actual : TypeKind . values ( ) ) { for ( ArgumentsArity argsArity : ArgumentsArity . values ( ) ) { compileAndCheck ( m1 , m2 , actual , argsArity ) ; } } } } System . out . println ( \"Total checks made: \" + checkCount ) ; System . out . println ( \"Bytecode checks made: \" + bytecodeCheckCount ) ; } StandardJavaFileManager fm = JavacTool . create ( ) . getStandardFileManager ( null , null , null ) ; void compileAndCheck ( VarargsMethod m1 , VarargsMethod m2 , TypeKind actual , ArgumentsArity argsArity ) throws Exception { final JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; JavaSource source = new JavaSource ( m1 , m2 , actual , argsArity ) ; ErrorChecker ec = new ErrorChecker ( ) ; JavacTask ct = ( JavacTask ) tool . getTask ( null , fm , ec , null , null , Arrays . asList ( source ) ) ; ct . generate ( ) ; check ( source , ec , m1 , m2 , actual , argsArity ) ; } void check ( JavaSource source , ErrorChecker ec , VarargsMethod m1 , VarargsMethod m2 , TypeKind actual , ArgumentsArity argsArity ) { checkCount ++ ; boolean resolutionError = false ; VarargsMethod selectedMethod = null ; boolean m1_applicable = m1 . isApplicable ( actual , argsArity ) ; boolean m2_applicable = m2 . isApplicable ( actual , argsArity ) ; if ( ! m1_applicable && ! m2_applicable ) { resolutionError = true ; } else if ( m1_applicable && m2_applicable ) { boolean", "gt": "m1_moreSpecific = m1 . isMoreSpecificThan ( m2 ) ;", "prediction": "resolutionError = true ;\n", "label": 0}
{"id": 13606, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . internal . SWTEventListener ; public interface TreeListener extends SWTEventListener { void treeCollapsed", "gt": "( TreeEvent e ) ;", "prediction": "( TreeEvent event ) ;\n", "label": 1}
{"id": 1922, "input": "<s> package org . dawb . passerelle . actors . dawn ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; import org . dawb . passerelle . common . actors . AbstractDataMessageTransformer ; import org . dawb . passerelle . common . message . DataMessageComponent ; import org . dawb . passerelle . common . message . MessageUtils ; import org . dawb . passerelle . common . parameter . roi . ROIParameter ; import com . isencia . passerelle . actor . ProcessingException ; import ptolemy . actor . Actor ; import ptolemy . actor . Director ; import ptolemy . actor . Initializable ; import ptolemy . actor . Manager ; import ptolemy . actor . Receiver ; import ptolemy . actor . util . FunctionDependency ; import ptolemy . data . expr . StringParameter ; import ptolemy . kernel . CompositeEntity ; import ptolemy . kernel . util . IllegalActionException ; import ptolemy . kernel . util . InvalidStateException ; import ptolemy . kernel . util . NameDuplicationException ; import ptolemy . kernel . util . NamedObj ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . DatasetUtils ; import uk . ac . diamond . scisoft . analysis . dataset . DoubleDataset ; import uk . ac . diamond . scisoft . analysis . dataset . Maths ; import uk . ac . diamond . scisoft . analysis . fitting . functions . AFunction ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . ROIProfile ; import uk . ac . diamond . scisoft . analysis . roi . RectangularROI ; public class RegionSelectAndScale extends AbstractDataMessageTransformer { public ROIParameter selectionROI ; public StringParameter roiName ; public StringParameter datasetName ; public StringParameter anglesAxisAdjustName ; public StringParameter energyAxisAdjustName ; public StringParameter angles ; public StringParameter energies ; public StringParameter photonEnergyNameParam ; public StringParameter workFunctionNameParam ; public StringParameter correctionFunctionNameParam ; public RegionSelectAndScale ( CompositeEntity container , String name ) throws NameDuplicationException , IllegalActionException { super ( container , name ) ; selectionROI = new ROIParameter ( this , \"selectionROI\" ) ; registerConfigurableParameter ( selectionROI ) ; roiName = new StringParameter ( this , \"roiName\" ) ; registerConfigurableParameter ( roiName ) ; datasetName = new StringParameter ( this , \"datasetName\" ) ; registerConfigurableParameter ( datasetName ) ; anglesAxisAdjustName = new StringParameter ( this , \"anglesAxisAdjustName\" ) ; registerConfigurableParameter ( anglesAxisAdjustName ) ; energyAxisAdjustName = new StringParameter ( this , \"energyAxisAdjustName\" ) ; registerConfigurableParameter ( energyAxisAdjustName ) ; angles = new StringParameter ( this , \"angles\" ) ; registerConfigurableParameter ( angles ) ; energies = new StringParameter ( this , \"energies\" ) ; registerConfigurableParameter ( energies ) ; photonEnergyNameParam = new StringParameter ( this , \"photonEnergyNameParam\" ) ; registerConfigurableParameter ( photonEnergyNameParam ) ; workFunctionNameParam = new StringParameter ( this , \"workFunctionNameParam\" ) ; registerConfigurableParameter ( workFunctionNameParam ) ; correctionFunctionNameParam = new StringParameter ( this , \"correctionFunctionNameParam\" ) ; registerConfigurableParameter ( correctionFunctionNameParam ) ; } @ Override protected DataMessageComponent getTransformedMessage ( List < DataMessageComponent > cache ) throws ProcessingException { final Map < String , Serializable > data = MessageUtils . getList ( cache ) ; final Map < String , String > scalar = MessageUtils . getScalar ( cache ) ; Map < String , AFunction > functions = null ; try { functions = MessageUtils . getFunctions ( cache ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } RectangularROI roi = ( RectangularROI ) selectionROI . getRoi ( ) ; try { Map < String , ROIBase > rois = MessageUtils . getROIs ( cache ) ; if ( rois . containsKey ( roiName . getExpression ( ) ) ) { if ( rois . get ( roiName . getExpression ( ) ) instanceof RectangularROI ) { roi = ( RectangularROI ) rois . get ( roiName . getExpression ( ) ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } DataMessageComponent result = new DataMessageComponent ( ) ; for ( String key : data . keySet ( ) ) { result . addList ( key , ( AbstractDataset ) data . get ( key ) ) ; } String", "gt": "name = datasetName . getExpression ( ) ;", "prediction": "Builder sb = new StringBuilder ( ) ;\n", "label": 0}
{"id": 13608, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . * ; import oracle . jdbc . * ; import oracle . jdbc . pool . OracleDataSource ; public class BatchUpdates { public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; PreparedStatement pstmt = null ; ResultSet rset = null ; int i = 0 ; try { String url = \"jdbc:oracle:oci8:@\" ; try { String url1 = System . getProperty ( \"JDBC_URL\" ) ; if ( url1 != null ) url = url1 ; } catch ( Exception e ) { } OracleDataSource ods = new OracleDataSource ( ) ; ods . setUser ( \"hr\" ) ; ods . setPassword ( \"hr\" ) ; ods . setURL ( url ) ; conn = ods . getConnection ( ) ; stmt = conn . createStatement ( ) ; try { stmt . execute ( \"create table mytest_table (col1 number, col2 varchar2(20))\" ) ; } catch ( Exception e1 ) { } pstmt = conn . prepareStatement ( \"insert into mytest_table values (?, ?)\" ) ; pstmt . setInt ( 1 , 1 ) ; pstmt . setString ( 2 , \"row 1\" ) ; pstmt . addBatch ( ) ; pstmt . setInt ( 1 , 2 ) ; pstmt . setString ( 2 , \"row 2\" ) ; pstmt . addBatch ( ) ; pstmt . executeBatch ( ) ; rset = stmt . executeQuery ( \"select * from mytest_table\" ) ; while ( rset . next ( ) ) { System . out . println ( rset . getInt ( 1 ) + \", \" + rset . getString ( 2 ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( stmt != null ) { try { stmt . execute ( \"drop table mytest_table\" ) ; } catch ( Exception e ) { } try { stmt . close ( ) ; } catch ( Exception e ) { } } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Exception e ) { } } if ( conn != null ) { try {", "gt": "conn . close ( ) ;", "prediction": "conn . close ( ) ;\n", "label": 1}
{"id": 7098, "input": "<s> package com . sun . mirror . declaration ; @ Deprecated @ SuppressWarnings (", "gt": "\"deprecation\" ) public interface MemberDeclaration extends Declaration", "prediction": "\n", "label": 0}
{"id": 13609, "input": "<s> package io . beancounter . applications . model ; import io . beancounter . applications . ApplicationsManager ; import java . io . Serializable ; import java . util . HashSet ; import java . util . Set ; import java . util . UUID ; public class Permissions implements Serializable { static final long serialVersionUID = 182012396185837510L ; private Set < Permission > permissions = new HashSet < Permission > ( ) ; private class Permission { private ApplicationsManager . Object object ; private ApplicationsManager . Ownership ownership ; private ApplicationsManager . Action action ; private Permission ( ApplicationsManager . Object object , ApplicationsManager . Ownership ownership , ApplicationsManager . Action action ) { this . object = object ; this . ownership = ownership ; this . action = action ; } @ Override public boolean equals ( java . lang . Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Permission that = ( Permission ) o ; if ( action != that . action ) return false ; if ( object != that . object ) return false ; if ( ownership != that . ownership ) return false ; return true ; } @ Override public int hashCode ( ) { int result = object != null ? object . hashCode ( ) : 0 ; result = 31 * result + ( ownership != null ? ownership . hashCode ( ) : 0 ) ; result = 31 * result + ( action != null ? action . hashCode ( ) : 0 ) ; return result ; } } public void addPermission ( ApplicationsManager . Action action , ApplicationsManager . Object object ) { permissions . add ( new Permission ( object , ApplicationsManager . Ownership . OWN , action ) ) ; } protected void addPermission ( ApplicationsManager . Action action , ApplicationsManager", "gt": ". Ownership ownership , ApplicationsManager . Object object )", "prediction": ". Object object , ApplicationsManager . Action action )\n", "label": 1}
{"id": 3785, "input": "<s> package Liza ; import org . bukkit . entity . LightningStrike ;", "gt": "public interface LizaLightningStrike extends LightningStrike", "prediction": "import org . bukkit . entity . Player ;\n", "label": 0}
{"id": 13617, "input": "<s> package org . restlet . ext . rdf . internal . turtle ; import java . io . IOException ; public abstract class LexicalUnit { private RdfTurtleReader contentReader ; private Context context ; private String value ; public LexicalUnit ( RdfTurtleReader contentReader , Context context ) { super ( ) ; this . contentReader = contentReader ; this . context = context ; } public LexicalUnit ( String value ) { super ( ) ; setValue ( value ) ; } public RdfTurtleReader getContentReader ( ) { return contentReader ; } public Context getContext ( ) { return context ; } public String getValue ( ) { return value ; } public abstract void parse ( ) throws IOException ; public", "gt": "abstract Object resolve ( ) ;", "prediction": "abstract String getValue ( ) ;\n", "label": 1}
{"id": 7657, "input": "<s> import java . io . * ; import java . util . * ; public class T4975569 { public static void main ( String ... args ) { new T4975569 ( ) . run ( ) ; } void run ( ) { verify ( \"T4975569$Anno\" , \"flags: ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATION\" ) ; verify ( \"T4975569$E\" , \"flags: ACC_FINAL, ACC_SUPER, ACC_ENUM\" ) ; verify ( \"T4975569$S\" , \"flags: ACC_BRIDGE, ACC_SYNTHETIC\" , \"InnerClasses:\\n       static\" ) ; verify ( \"T4975569$V\" , \"void m(java.lang.String...)\" , \"flags: ACC_VARARGS\" ) ; verify ( \"T4975569$Prot\" , \"InnerClasses:\\n       protected\" ) ; if ( errors > 0 ) throw new Error ( errors + \" found.\" ) ; } void verify ( String className , String ... expects ) { String output = javap ( className ) ; for ( String expect : expects ) { if ( output . indexOf ( expect ) < 0 ) error ( expect + \" not found\" ) ; } } void error ( String msg ) { System . err . println ( msg ) ; errors ++ ; } int errors ; String javap ( String className ) { String newline = System . getProperty ( \"line.separator\" ) ; String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; String [ ] args = { \"-v\" , \"-classpath\" , testClasses , className } ; int rc = com . sun . tools . javap . Main . run ( args , out ) ; if ( rc != 0 ) throw new Error ( \"javap failed. rc=\" + rc ) ; out . close ( ) ; String output = sw .", "gt": "toString ( ) . replaceAll ( newline , \"\\n\" ) ;", "prediction": "toString ( ) ;\n", "label": 0}
{"id": 13622, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Iterator ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . document . CompressionTools ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMOutputStream ; import org . apache . lucene . store . IndexOutput ; import org . apache . lucene . store . IndexInput ; final class FieldsWriter { static final byte FIELD_IS_TOKENIZED = 0x1 ; static final byte FIELD_IS_BINARY = 0x2 ; static final byte FIELD_IS_COMPRESSED = 0x4 ; static final int FORMAT = 0 ; static final int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES = 1 ; static final int FORMAT_CURRENT = FORMAT_VERSION_UTF8_LENGTH_IN_BYTES ; private FieldInfos fieldInfos ; private IndexOutput fieldsStream ; private IndexOutput indexStream ; private boolean doClose ; FieldsWriter ( Directory d , String segment , FieldInfos fn ) throws IOException { fieldInfos = fn ; boolean success = false ; final String fieldsName = segment + \".\" + IndexFileNames . FIELDS_EXTENSION ; try { fieldsStream = d . createOutput ( fieldsName ) ; fieldsStream . writeInt ( FORMAT_CURRENT ) ; success = true ; } finally { if ( ! success ) { try { close ( ) ; } catch ( Throwable t ) { } try { d . deleteFile ( fieldsName ) ; } catch ( Throwable t ) { } } } success = false ; final String indexName = segment + \".\" + IndexFileNames . FIELDS_INDEX_EXTENSION ; try { indexStream = d . createOutput ( indexName ) ; indexStream . writeInt ( FORMAT_CURRENT ) ; success = true ; } finally { if ( ! success ) { try { close ( ) ; } catch ( IOException ioe ) { } try { d . deleteFile ( fieldsName ) ; } catch ( Throwable t ) { } try { d . deleteFile ( indexName ) ; } catch ( Throwable t ) { } } } doClose = true ; } FieldsWriter ( IndexOutput fdx , IndexOutput fdt , FieldInfos fn ) { fieldInfos = fn ; fieldsStream = fdt ; indexStream = fdx ; doClose = false ; } void setFieldsStream ( IndexOutput stream ) { this . fieldsStream = stream ; } void flushDocument ( int numStoredFields , RAMOutputStream buffer ) throws IOException { indexStream . writeLong ( fieldsStream . getFilePointer ( ) ) ; fieldsStream . writeVInt ( numStoredFields ) ; buffer . writeTo ( fieldsStream ) ; } void skipDocument ( ) throws IOException { indexStream . writeLong ( fieldsStream . getFilePointer ( ) ) ; fieldsStream . writeVInt ( 0 ) ; } void flush ( ) throws IOException { indexStream . flush ( ) ; fieldsStream . flush ( ) ; } final void close ( ) throws IOException { if ( doClose ) { try { if ( fieldsStream != null ) { try { fieldsStream . close ( ) ; } finally { fieldsStream = null ; } } } catch ( IOException ioe ) { try { if ( indexStream != null ) { try { indexStream . close ( ) ; } finally { indexStream = null ; } } } catch ( IOException ioe2 ) { } throw ioe ; } finally { if ( indexStream != null ) { try { indexStream . close ( ) ; } finally { indexStream = null ; } } } } } final void writeField ( FieldInfo fi , Fieldable field ) throws IOException { boolean disableCompression = ( field instanceof FieldsReader . FieldForMerge ) ; fieldsStream . writeVInt ( fi . number ) ; byte bits = 0 ; if ( field . isTokenized ( ) ) bits |= FieldsWriter . FIELD_IS_TOKENIZED ; if ( field . isBinary ( ) ) bits |= FieldsWriter . FIELD_IS_BINARY ; if ( field . isCompressed ( ) ) bits |= FieldsWriter . FIELD_IS_COMPRESSED ; fieldsStream . writeByte ( bits ) ; if ( field . isCompressed ( ) ) { final byte [ ] data ; final int len ; final int offset ; if ( disableCompression ) { data = field . getBinaryValue ( ) ; assert data != null ; len = field . getBinaryLength ( ) ; offset = field . getBinaryOffset ( ) ; } else { if ( field . isBinary ( ) ) { data = CompressionTools . compress ( field . getBinaryValue ( ) , field . getBinaryOffset ( ) , field . getBinaryLength ( ) ) ; } else { byte x [ ] = field . stringValue ( ) . getBytes ( \"UTF-8\" ) ; data = CompressionTools . compress ( x , 0 , x . length ) ; } len = data . length ; offset = 0 ; } fieldsStream . writeVInt ( len ) ; fieldsStream . writeBytes ( data , offset , len ) ; } else { if ( field . isBinary ( ) ) { final byte [ ] data ; final int len ; final int offset ; data = field . getBinaryValue ( ) ; len = field . getBinaryLength ( ) ; offset = field . getBinaryOffset ( ) ; fieldsStream . writeVInt ( len ) ; fieldsStream . writeBytes ( data , offset , len ) ; } else { fieldsStream . writeString ( field . stringValue ( ) ) ; } } } final void addRawDocuments ( IndexInput stream , int [ ] lengths , int numDocs ) throws IOException { long position = fieldsStream . getFilePointer ( ) ; long start = position ; for ( int i = 0 ; i < numDocs ; i ++ ) { indexStream . writeLong ( position ) ; position += lengths [ i ] ; } fieldsStream . copyBytes ( stream , position - start ) ; assert fieldsStream . getFilePointer ( ) == position ; } final void addDocument ( Document doc ) throws IOException { indexStream . writeLong ( fieldsStream . getFilePointer ( ) ) ; int storedCount = 0 ; Iterator fieldIterator = doc . getFields ( ) . iterator ( ) ; while ( fieldIterator . hasNext ( ) ) { Fieldable field = ( Fieldable ) fieldIterator . next ( ) ; if ( field . isStored", "gt": "( ) ) storedCount ++ ;", "prediction": "( ) )\n", "label": 1}
{"id": 5951, "input": "<s> package org . parboiled . matchervisitors ; import org . parboiled . matchers . ActionMatcher ; import org . parboiled . matchers . * ; import org . parboiled . support . Checks ; public class CanMatchEmptyVisitor implements MatcherVisitor < Boolean > { public Boolean visit ( ActionMatcher matcher ) { return true ; } public Boolean visit ( AnyMatcher matcher ) { return false ; } public Boolean visit ( CharIgnoreCaseMatcher matcher ) { return false ; } public Boolean visit ( CharMatcher matcher ) { return false ; } public Boolean visit ( CharRangeMatcher matcher ) { return false ; } public Boolean visit ( AnyOfMatcher matcher ) { return false ; } public Boolean visit ( CustomMatcher matcher ) { return matcher . canMatchEmpty ( ) ; } public Boolean visit ( EmptyMatcher matcher ) { return true ; } public Boolean visit ( FirstOfMatcher matcher ) { for ( Matcher child : matcher . getChildren ( ) ) { if ( child . accept ( this ) ) return true ; } return false ; } public", "gt": "Boolean visit ( NothingMatcher matcher )", "prediction": "Boolean visit ( LastOfMatcher matcher )\n", "label": 0}
{"id": 13624, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . ArrayList ; import java . util . Iterator ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . FilteredTree ; import org . eclipse . ui . dialogs . PatternFilter ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . registry . ViewRegistry ; import org . eclipse . ui . views . IViewCategory ; import org . eclipse . ui . views . IViewDescriptor ; import org . eclipse . ui . views . IViewRegistry ; public class ShowViewDialog extends Dialog implements ISelectionChangedListener , IDoubleClickListener { private static final String DIALOG_SETTING_SECTION_NAME = \"ShowViewDialog\" ; private static final int LIST_HEIGHT = 300 ; private static final int LIST_WIDTH = 250 ; private static final String STORE_EXPANDED_CATEGORIES_ID = DIALOG_SETTING_SECTION_NAME + \".STORE_EXPANDED_CATEGORIES_ID\" ; private static final String STORE_SELECTED_VIEW_ID = DIALOG_SETTING_SECTION_NAME + \".STORE_SELECTED_VIEW_ID\" ; private FilteredTree filteredTree ; private Button okButton ; private IViewDescriptor [ ] viewDescs = new IViewDescriptor [ 0 ] ; private IViewRegistry viewReg ; private IWorkbenchWindow window ; private Color dimmedForeground ; public ShowViewDialog ( IWorkbenchWindow window , IViewRegistry viewReg ) { super ( window . getShell ( ) ) ; this . window = window ; this . viewReg = viewReg ; } protected void buttonPressed ( int buttonId ) { if ( buttonId == IDialogConstants . OK_ID ) { saveWidgetValues ( ) ; } super . buttonPressed ( buttonId ) ; } protected void cancelPressed ( ) { viewDescs = new IViewDescriptor [ 0 ] ; super . cancelPressed ( ) ; } protected void configureShell ( Shell shell ) { super . configureShell ( shell ) ; shell . setText ( WorkbenchMessages . get ( ) . ShowView_shellTitle ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( shell , IWorkbenchHelpContextIds . SHOW_VIEW_DIALOG ) ; } protected void createButtonsForButtonBar ( Composite parent ) { okButton = createButton ( parent , IDialogConstants . OK_ID , IDialogConstants . get ( ) . OK_LABEL , true ) ; createButton ( parent , IDialogConstants . CANCEL_ID , IDialogConstants . get ( ) . CANCEL_LABEL , false ) ; updateButtons ( ) ; } protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; composite . setFont ( parent . getFont ( ) ) ; createFilteredTreeViewer ( composite ) ; layoutTopControl ( filteredTree ) ; restoreWidgetValues ( ) ; applyDialogFont ( composite ) ; return composite ; } private static RGB blend ( RGB c1 , RGB c2 , int ratio ) { int r = blend ( c1 . red , c2 . red , ratio ) ; int g = blend ( c1 . green , c2 . green , ratio ) ; int b = blend ( c1 . blue , c2 . blue , ratio ) ; return new RGB ( r , g , b ) ; } private static int blend ( int v1 , int v2 , int ratio ) { int b = ( ratio * v1 + ( 100 - ratio ) * v2 ) / 100 ; return Math . min ( 255 , b ) ; } private void createFilteredTreeViewer ( Composite parent ) { PatternFilter filter = new ViewPatternFilter ( ) ; int styleBits = SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ; filteredTree = new FilteredTree ( parent , styleBits , filter , true ) ; filteredTree . setBackground ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_WIDGET_BACKGROUND ) ) ; TreeViewer treeViewer =", "gt": "filteredTree . getViewer ( ) ;", "prediction": "new TreeViewer ( filteredTree ) ;\n", "label": 1}
{"id": 2827, "input": "<s> package org . osgi . framework . resource ; import java . util . Map ; import org . osgi . framework . Constants ; public interface Requirement { String getNamespace ( ) ; Map < String , String > getDirectives ( ) ; Map < String", "gt": ", Object > getAttributes ( ) ;", "prediction": ", String > getAttributes ( ) ;\n", "label": 0}
{"id": 13629, "input": "<s> package org . apache . sqoop . tool ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . cli . ToolOptions ; public class ListTablesTool extends com . cloudera . sqoop . tool . BaseSqoopTool { public static final Log LOG = LogFactory . getLog ( ListTablesTool . class . getName ( ) ) ; public ListTablesTool ( ) { super ( \"list-tables\" ) ; } @ Override public int run ( SqoopOptions options ) { if ( ! init ( options ) ) { return 1 ; } try { String [ ] tables = manager . listTables ( ) ; if ( null == tables ) { System . err . println ( \"Could not retrieve tables list from server\" ) ; LOG . error ( \"manager.listTables() returned null\" ) ; return 1 ; } else { for ( String tbl : tables ) { System", "gt": ". out . println ( tbl ) ;", "prediction": ". out . println ( tbl ) ;\n", "label": 1}
{"id": 1427, "input": "<s> package org . dawb . workbench . plotting . printing ; import org . eclipse . swt . SWT ; import org . eclipse . swt . printing . Printer ; import org . eclipse . swt . printing . PrinterData ; public class PrintSettings { private static final String DEFAULT_UNITS_FORMAT = \"%.3f\" ; private String unitsFormat = DEFAULT_UNITS_FORMAT ; private Units units = Units . INCH ; private double left = 1 ; private double right = 1 ; private double top = 1 ; private double bottom = 1 ; private int verticalAlign = SWT . TOP ; private int horizontalAlign = SWT . CENTER ; private Orientation orientation = Orientation . PORTRAIT ; private PrinterData printerData = null ; private Scale scale = Scale . DEFAULT ; private Resolution resolution = Resolution . MEDIUM ; private boolean keepAspectRatio = true ; public static enum Orientation { PORTRAIT ( \"Portrait\" , 1 ) , LANDSCAPE ( \"Landscape\" , 2 ) ; private final String name ; private final int value ; Orientation ( String name , int value ) { this . name = name ; this . value = value ; } public String getName ( ) { return name ; } public int getValue ( ) { return value ; } } public static enum Scale { DEFAULT ( \"100%\" , 0.5 ) , PERCENT75 ( \"75%\" , 2.0 ) , PERCENT66 ( \"66%\" , 3.0 ) , PERCENT50 ( \"50%\" , 4.0 ) , PERCENT33 ( \"33%\" , 5.0 ) , PERCENT25 ( \"25%\" , 6.0 ) , PERCENT10 ( \"10%\" , 7.0 ) ; private final String name ; private final Double value ; Scale ( String name , Double value ) { this . name = name ; this . value = value ; } public String getName ( ) { return name ; } public Double getValue ( ) { return value ; } } public static enum Resolution { LOW ( \"Low\" , 1 ) , MEDIUM ( \"Medium\" , 2 ) , MEDIUMHIGH ( \"Medium High\" , 3 ) , HIGH ( \"High\" , 4 ) ; private final String name ; private final int value ; Resolution ( String name , int value ) { this . name = name ; this . value = value ; } public String getName ( ) { return name ; } public int getValue ( ) { return value ; } } public static enum Units { INCH ( \"in\" , 1 ) , CENTIMETER ( \"cm\" , 1. / 2.54 ) , MILLIMETER ( \"mm\" , 1. / 254. ) ; private final String name ; private final double scale ; Units ( String name , double scale ) { this . name = name ; this . scale = scale ; } public String getName ( ) { return name ; } public double getScale ( ) { return scale ; } public double scaleToInches ( double val ) { return val * scale ; } public double scaleFromInches ( double val ) { return val / scale ; } } public class ValueWithUnits { private double val ; private String unitsName ; ValueWithUnits ( double val , String unitsName ) { this . val = val ; this . unitsName = unitsName ; } public String getString ( ) { return String . format ( unitsFormat + \" %s\" , val , unitsName ) ; } public double getVal ( ) { return val ; } public String getUnitsName ( ) { return unitsName ; } } @ Override public PrintSettings clone ( ) { PrintSettings newSettings = new PrintSettings ( ) ; newSettings . setUnits ( units ) ; newSettings . setLeft ( left ) ; newSettings . setRight ( right ) ; newSettings . setTop ( top ) ; newSettings . setBottom ( bottom ) ; newSettings . setVerticalAlign ( verticalAlign ) ; newSettings . setHorizontalAlign ( horizontalAlign ) ; newSettings . setOrientation ( orientation ) ; newSettings . setResolution ( resolution ) ; newSettings . setKeepAspectRatio ( keepAspectRatio ) ; newSettings . setScale ( scale ) ; newSettings . setPrinterData ( getPrinterData ( ) ) ; return newSettings ; } public ValueWithUnits scaleToInches ( ValueWithUnits vwu ) { Units convertUnit = this . units ; for ( Units unit : Units . values ( ) ) { if ( unit . getName ( ) . equals ( vwu . getUnitsName ( ) ) ) { convertUnit = unit ; break ; } } return new ValueWithUnits ( convertUnit . scaleToInches ( vwu . getVal ( ) ) , convertUnit . getName ( ) ) ; } public ValueWithUnits scaleFromInches ( ValueWithUnits vwu ) { Units convertUnit = this . units ; for ( Units unit : Units . values ( ) ) { if ( unit . getName ( ) . equals (", "gt": "vwu . getUnitsName ( ) ) )", "prediction": "vwu . getUnitsName ( ) ) )\n", "label": 0}
{"id": 13640, "input": "<s> package org . spliffy . server . web ; import org . spliffy . server . web . templating . Templater ; import org . hashsplit4j . api . BlobStore ; import org . hashsplit4j . api . HashStore ; import org . spliffy . server . apps . ApplicationManager ; import org . spliffy . server . manager . CurrentDateService ; import org . spliffy . server . manager . DefaultCurrentDateService ; import org . spliffy . server . manager . ResourceManager ; import org . spliffy . server . manager . ShareManager ; import org . spliffy . server . web . templating . Formatter ; import org . spliffy . server . web . templating . HtmlTemplateParser ; import org . spliffy . server . web . templating . HtmlTemplater ; import org . spliffy . server . web . templating . TextTemplater ; public class Services { private final HashStore hashStore ; private final BlobStore blobStore ; private final Templater htmlTemplater ; private final Templater textTemplater ; private final SpliffySecurityManager securityManager ; private final ResourceManager resourceManager ; private final ShareManager shareManager ; private final ApplicationManager applicationManager ; private HtmlTemplateParser templateParser ; private final CurrentDateService currentDateService ; public Services ( HashStore hashStore , BlobStore blobStore , SpliffySecurityManager securityManager", "gt": ", ResourceManager resourceManager , ShareManager shareManager , ApplicationManager applicationManager )", "prediction": ")\n", "label": 1}
{"id": 9015, "input": "<s> import java . util . HashMap ; import java . util . Map ; class T6227617 { void m ( ) { int i1 = 2 ; int i2 = ( int ) i1 ; float f1 = 1f ; int i3 = ( int ) f1 ; String s = ( String ) \"\" ; Object o = ( Object ) \"\" ; Map < String , Integer > m = new HashMap < String , Integer > ( ) ; Integer I1 = ( Integer ) m . get ( \"\" ) ; } static", "gt": "final int i1 = Foo . i1 ;", "prediction": "class T6227617\n", "label": 0}
{"id": 13646, "input": "<s> package cs224u . ingredients ; import java . util . List ; import cs224n . util . Counter ; public class SimpleRecipeClassifier extends RecipeClassifier { @ Override public void train ( List < Recipe > recipes ) { } @ Override public double assignSimilarity ( Recipe r1 , Recipe r2 ) { List < String > is1 = r1 . getIngredients ( ) ; List < String > is2 = r2 . getIngredients ( ) ; Counter < String > c1 = new Counter < String > ( ) ; Counter < String > c2 = new Counter < String > ( ) ; for ( String line : is1 ) { for ( String ingred : line . split ( \" \" ) ) { c1 . incrementCount ( ingred , 1.0 ) ; } } for ( String line : is2 ) { for ( String ingred :", "gt": "line . split ( \" \" ) )", "prediction": "line . split ( \" \" ) )\n", "label": 1}
{"id": 9418, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; public class Utf8Validator { private static final int [ ] DFA = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 0xa , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x3 , 0x4 , 0x3 , 0x3 , 0xb , 0x6 , 0x6 , 0x6 , 0x5 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x8 , 0x0 , 0x1 , 0x2 , 0x3 , 0x5 , 0x8 , 0x7 , 0x1 , 0x1 , 0x1 , 0x4 , 0x6 , 0x1 , 0x1 , 0x1 , 0x1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; private static final int ACCEPT = 0 ; private static final int REJECT = 1 ; private int mState ; private int mPos ; public Utf8Validator ( ) { reset ( ) ; } public void reset ( ) { mState = ACCEPT ; mPos = 0 ; } public int position ( ) { return mPos ; } public boolean isValid ( ) { return mState == ACCEPT ; } public boolean validate ( byte [ ] data , int off , int len ) { for ( int i = off ; i < off + len ; ++ i ) { mState = DFA [ 256 + ( mState << 4 ) + DFA [ ( int ) ( 0xff & data [ i ] ) ] ] ; if ( mState == REJECT ) { mPos += i ; return false ; } } mPos += len ; return true ; }", "gt": "public boolean validate ( byte [ ] data )", "prediction": "}\n", "label": 0}
{"id": 13647, "input": "<s> package org . restlet . ext . sip . internal ; import java . util . Iterator ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . logging . Level ; import org . restlet . Client ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Protocol ; import org . restlet . engine . connector . ClientConnectionHelper ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . connector . InboundWay ; import org . restlet . engine . connector . OutboundWay ; import org . restlet . ext . sip . SipRequest ; import org . restlet . ext . sip . SipResponse ; import org . restlet . ext . sip . SipStatus ; public class SipClientHelper extends ClientConnectionHelper { private final Map < String , SipRequest > requests ; public SipClientHelper ( Client client ) { super ( client ) ; this . requests = new ConcurrentHashMap < String , SipRequest > ( ) ; getProtocols ( ) . add ( Protocol . SIP ) ; getProtocols ( ) . add ( Protocol . SIPS ) ; } @ Override protected boolean control ( ) { boolean result = super . control ( ) ; SipRequest request ; for ( Iterator < SipRequest > iter = getRequests ( ) . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { request = iter . next ( ) ; if ( request . hasTimedOut ( ) ) { Level level ; if ( request . isHandled ( ) || ! request . isExpectingResponse ( ) ) { level = Level . FINE ; } else { level = Level . INFO ; SipResponse response = new SipResponse ( request ) ; response . setStatus ( SipStatus . CLIENT_ERROR_REQUEST_TIMEOUT , \"The SIP client connector has timeout due to lack of activity on this transaction: \" + request . getTransaction ( ) ) ; handleInbound ( response , false ) ; } getLogger ( ) . log ( level , \"This SIP transaction has timed out: \" + request . getTransaction ( ) ) ; iter . remove ( ) ; } } return result ; } @ Override public InboundWay createInboundWay ( Connection < Client > connection , int bufferSize ) { return new SipClientInboundWay ( connection , bufferSize ) ; } @ Override public OutboundWay createOutboundWay ( Connection < Client > connection , int bufferSize ) { return new SipClientOutboundWay ( connection , bufferSize ) ; } @ Override public Request getRequest ( Response response ) { Request result = null ; if ( response != null ) { result = response . getRequest ( ) ; if ( result == null ) { SipResponse sipResponse = ( SipResponse ) response ; String tid = sipResponse . getTransactionId ( ) ; result = getRequests ( ) . get ( tid ) ; } } return result ; } public Map < String , SipRequest > getRequests ( ) { return requests ; } @ Override protected void unblock ( Response response ) { if ( response . getRequest ( ) != null ) { SipRequest request = ( SipRequest ) response . getRequest ( ) ; request .", "gt": "setHandled ( true ) ;", "prediction": "unblock ( ) ;\n", "label": 1}
{"id": 5173, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . ecore . EAttribute ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EOperation ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . impl . EPackageImpl ; import org . eclipse . gmf . gmfgraph . GMFGraphPackage ; import org . eclipse . gmf . mappings . GMFMapPackage ; import org . eclipse . gmf . tooldef . GMFToolPackage ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleChildReference ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMappingElementWithFigure ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleNodeReference ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsFactory ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimplemappingsPackageImpl extends EPackageImpl implements SimplemappingsPackage { private EClass simpleMappingEClass = null ; private EClass simpleTopNodeEClass = null ; private EClass simpleCompartmentEClass = null ; private EClass simpleLabelNodeEClass = null ; private EClass simpleLinkMappingEClass = null ; private EClass simpleNodeEClass = null ; private EClass simpleParentNodeEClass = null ; private EClass simpleChildNodeEClass = null ; private EClass simpleSubNodeEClass = null ; private EClass simpleMappingElementWithFigureEClass = null ; private EClass simpleChildReferenceEClass = null ; private EClass simpleNodeReferenceEClass = null ; private SimplemappingsPackageImpl ( ) { super ( eNS_URI , SimplemappingsFactory . eINSTANCE ) ; } private static boolean isInited = false ; public static SimplemappingsPackage init ( ) { if ( isInited ) return ( SimplemappingsPackage ) EPackage . Registry . INSTANCE . getEPackage ( SimplemappingsPackage . eNS_URI ) ; SimplemappingsPackageImpl theSimplemappingsPackage = ( SimplemappingsPackageImpl ) ( EPackage . Registry . INSTANCE . get ( eNS_URI ) instanceof SimplemappingsPackageImpl ? EPackage . Registry . INSTANCE . get ( eNS_URI ) : new SimplemappingsPackageImpl ( ) ) ; isInited = true ; GMFMapPackage . eINSTANCE . eClass ( ) ; theSimplemappingsPackage . createPackageContents ( ) ; theSimplemappingsPackage . initializePackageContents ( ) ; theSimplemappingsPackage . freeze ( ) ; EPackage . Registry . INSTANCE . put ( SimplemappingsPackage . eNS_URI , theSimplemappingsPackage ) ; return theSimplemappingsPackage ; } public EClass getSimpleMapping ( ) { return simpleMappingEClass ; } public EReference getSimpleMapping_Canvas ( ) { return ( EReference ) simpleMappingEClass . getEStructuralFeatures ( ) . get ( 0 ) ; } public EReference getSimpleMapping_Palette ( ) { return ( EReference ) simpleMappingEClass . getEStructuralFeatures ( ) . get ( 1 ) ; } public EReference getSimpleMapping_Mapping ( ) { return ( EReference ) simpleMappingEClass . getEStructuralFeatures ( ) . get ( 2 ) ; } public EReference getSimpleMapping_DomainModel ( ) { return ( EReference ) simpleMappingEClass . getEStructuralFeatures", "gt": "( ) . get ( 3 ) ;", "prediction": "( ) . get ( 3 ) ;\n", "label": 0}
{"id": 13651, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . HeaderParam ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . Request ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . SecurityContext ; import javax . ws . rs . core . UriInfo ; import org . restlet . test . ext . jaxrs . services . tests . InjectionTest ; @ Path ( \"/InjectionTestService/two/{idf}\" ) public class InjectionTestService2 { @ Context private SecurityContext securityContext ; @ Context private UriInfo uriInfo ; @ Context private Request request ; @ Context private HttpHeaders httpHeaders ; @ PathParam ( \"idf\" ) private Integer idf ; @ HeaderParam ( \"host\" ) private String hostHost ; @ GET @ Produces ( \"text/plain\" ) public Response get ( ) { String msg = \"\" ; if (", "gt": "this . securityContext == null )", "prediction": "idf != null )\n", "label": 1}
{"id": 8006, "input": "<s> package org . ofbiz . product . store ; import java . math . BigDecimal ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import javax . servlet . ServletRequest ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . common . geo . GeoWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . party . contact . ContactMechWorker ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class ProductStoreWorker { public static final String module = ProductStoreWorker . class . getName ( ) ; public static GenericValue getProductStore ( String productStoreId , Delegator delegator ) { if ( productStoreId == null || delegator == null ) { return null ; } GenericValue productStore = null ; try { productStore = delegator . findOne ( \"ProductStore\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Problem getting ProductStore entity\" , module ) ; } return productStore ; } public static GenericValue getProductStore ( ServletRequest request ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; return ProductStoreWorker . getProductStore ( productStoreId , delegator ) ; } public static String getProductStoreId ( ServletRequest request ) { HttpServletRequest httpRequest = ( HttpServletRequest ) request ; HttpSession session = httpRequest . getSession ( false ) ; if ( session != null && session .", "gt": "getAttribute ( \"productStoreId\" ) != null )", "prediction": "getAttribute ( \"id\" ) != null )\n", "label": 0}
{"id": 13659, "input": "<s> package org . restlet . example . misc ; import org . restlet . Client ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . Representation ; import org . restlet . util . Series ; public class AwsTest { public static void main ( String [ ] args ) throws Exception { Request request = new Request ( Method . GET , \"http://s3.amazonaws.com/quotes/nelson\" ) ; request . setChallengeResponse ( new ChallengeResponse ( ChallengeScheme . HTTP_AWS_S3 , \"44CF9590006BF252F707\" , \"OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV\" ) ) ; Series < Header > extraHeaders = new Series < Header > ( Header . class ) ; extraHeaders . add ( \"X-Amz-Meta-Author\" , \"foo@bar.com\" ) ; extraHeaders . add ( \"X-Amz-Magic\" , \"abracadabra\" ) ; request . getAttributes ( )", "gt": ". put ( HeaderConstants . ATTRIBUTE_HEADERS , extraHeaders ) ;", "prediction": ". add ( extraHeaders ) ;\n", "label": 1}
{"id": 2784, "input": "<s> package pkg ; import java . lang . annotation . * ; @ Documented public @ interface AnnotationType { String optional", "gt": "( ) default \"unknown\" ;", "prediction": ";\n", "label": 0}
{"id": 13660, "input": "<s> package fr . inria . zvtm . tests ; import java . awt . Color ; import junit . framework . TestCase ; import fr . inria . zvtm . engine . Utils ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . VRectangle ; public class UtilsTest extends TestCase { public UtilsTest ( String name ) { super ( name ) ; } public void setUp ( ) { vsm = VirtualSpaceManager . INSTANCE ; vs = vsm . addVirtualSpace ( \"testVS\" ) ; } public void testWidthHeight ( ) { Glyph gl = new VRectangle ( 0 , 0 , 0 , 42 , 314 , Color . GREEN ) ; double [ ] wh = Utils .", "gt": "widthHeight ( gl ) ;", "prediction": "getBounds ( gl ) ;\n", "label": 1}
{"id": 9960, "input": "<s> public class ExtendCovariant2 extends java . io . PrintStream { ExtendCovariant2 ( ) throws java . io . IOException { super ( \"\" ) ; } public java", "gt": ". io . PrintStream append ( char c )", "prediction": ". io . PrintStream getPrintStream ( )\n", "label": 0}
{"id": 13664, "input": "<s> package org . spliffy . server . apps . versions ; import com . bradmcevoy . http . CollectionResource ; import com . bradmcevoy . http . Resource ; import org . spliffy . server . web . templating . MenuItem ; import java . util . List ; import org . spliffy . server . apps . AppConfig ; import org . spliffy . server . apps . Application ; import org . spliffy . server . db . BaseEntity ; import org . spliffy . server . db . Profile ; import org . spliffy . server . web . RootFolder ; import org . spliffy . server . web . Services ; import org . spliffy . server . web . SpliffyResourceFactory ; import org . spliffy . server . web . UserResource ; public class VersionsApp implements Application { private Services services ; @ Override public String getInstanceId ( ) { return \"versions\" ; } @ Override public void init ( SpliffyResourceFactory resourceFactory , AppConfig config ) throws Exception { this . services = resourceFactory . getServices ( ) ; } @ Override public Resource getPage ( Resource parent , String requestedName ) { return null ; } @ Override public void shutDown ( ) { } @ Override public void addBrowseablePages ( CollectionResource parent , List < Resource > children ) { if ( parent instanceof UserResource ) { UserResource ur =", "gt": "( UserResource ) parent ;", "prediction": "( UserResource ) parent ;\n", "label": 1}
{"id": 4284, "input": "<s> package org . dawb . workbench . plotting . system ; import org . csstudio . swt . xygraph . figures . Annotation ; import org . csstudio . swt . xygraph . figures . Annotation . CursorLineStyle ; import org . csstudio . swt . xygraph . figures . Axis ; import org . dawb . common . ui . plot . annotation . IAnnotation ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; class AnnotationWrapper implements IAnnotation { private Annotation annotation ; AnnotationWrapper ( String name , Axis xAxis , Axis yAxis ) { this . annotation = new Annotation ( name , xAxis , yAxis ) ; } AnnotationWrapper ( Annotation annotation ) { this . annotation = annotation ; } public void setName ( String name ) { annotation . setName ( name ) ; } public void setShowName ( boolean showName ) { annotation . setShowName ( showName ) ; } public void setShowInfo ( boolean showSampleInfo ) { annotation . setShowSampleInfo ( showSampleInfo ) ; } public void setShowPosition ( boolean showPosition ) { annotation . setShowPosition ( showPosition ) ; } public void setAnnotationColor ( Color annotationColor ) { annotation . setAnnotationColor ( annotationColor ) ; } public void setAnnotationFont ( Font annotationFont ) { annotation . setAnnotationFont ( annotationFont ) ; } public String getName ( ) { return annotation . getName ( ) ; } public boolean isShowName ( ) { return annotation . isShowName ( ) ; } public boolean isShowInfo ( ) { return annotation . isShowSampleInfo ( ) ; } public boolean isShowPosition ( ) { return annotation . isShowPosition ( ) ; } public Color getAnnotationColor ( ) { return annotation . getAnnotationColor ( ) ; } public Font getAnnotationFont ( ) { return annotation . getAnnotationFont ( ) ; } public LineStyle getLineStyle ( ) { final CursorLineStyle style =", "gt": "annotation . getCursorLineStyle ( ) ;", "prediction": "annotation . getLineStyle ( ) ;\n", "label": 0}
{"id": 13666, "input": "<s> package org . eclipse . ui . dialogs ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . ui . IWorkbenchPropertyPage ; public abstract class PropertyPage extends PreferencePage implements IWorkbenchPropertyPage { private IAdaptable element ; public PropertyPage ( ) { } public IAdaptable getElement ( ) { return element ; }", "gt": "public void setElement ( IAdaptable element )", "prediction": "public void setElement ( IAdaptable element )\n", "label": 1}
{"id": 2678, "input": "<s> package com . matburt . mobileorg . test . Gui ; import android . app . Instrumentation ; import android . content . ContentResolver ; import android . content . Intent ; import android . test . ActivityInstrumentationTestCase2 ; import com . matburt . mobileorg . Gui . Capture . EditActivity ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgContract . OrgData ; import com . matburt . mobileorg . test . util . OrgTestUtils ; public class EditActivityTest extends ActivityInstrumentationTestCase2 < EditActivity > { private EditActivity activity ; private ContentResolver resolver ; private Instrumentation instrumentation ; private long nodeId ; public EditActivityTest ( ) { super ( EditActivity . class ) ; } @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; this . instrumentation = getInstrumentation ( ) ; this . resolver = instrumentation . getContext ( ) . getContentResolver ( ) ; } @ Override public void tearDown ( ) throws Exception { resolver . delete ( OrgData . buildIdUri ( nodeId ) , null , null ) ; super . tearDown ( ) ; } private void prepareActivityWithNode ( OrgNode node ) { node . write ( resolver ) ; this . nodeId = node . id ; Intent intent = new Intent ( ) ; intent . putExtra ( EditActivity . ACTIONMODE , EditActivity . ACTIONMODE_EDIT ) ; intent . putExtra ( EditActivity . NODE_ID , node . id ) ; setActivityIntent ( intent ) ; setActivityInitialTouchMode ( false ) ; this . activity = getActivity ( ) ; } public void testSimple ( ) { OrgNode node = new OrgNode ( ) ; prepareActivityWithNode ( node ) ; assertFalse ( activity . hasEdits ( ) ) ; OrgNode newNode = activity", "gt": ". getEditedNode ( ) ;", "prediction": ". getEdits ( ) ;\n", "label": 0}
{"id": 13670, "input": "<s> package com . poetry . install ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import escode . util . StreamUtils ; public class AbstractInstall { protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; protected byte [ ] load ( final String name ) throws IOException { logger . trace ( \"Trying load image :{}\" , name ) ; final Class < ? > clazz = getClass ( ) ; final Package pack = clazz . getPackage ( ) ; final String packageName = pack . getName ( ) ; final String path = \"/\" + packageName . replace ( '.' , '/' ) + \"/\" + name ; final InputStream in = getClass ( ) . getResourceAsStream ( path ) ; return StreamUtils . getBytes ( in , true ) ; } protected String read ( final String name ) throws IOException { logger . trace ( \"Trying read file :{}\" , name ) ; final Class < ? > clazz = getClass ( ) ; final Package pack = clazz . getPackage ( ) ; final String packageName = pack . getName ( ) ; final String path = \"/\" + packageName . replace ( '.' , '/' ) + \"/\" + name + \".txt\" ; final InputStream in = getClass ( ) . getResourceAsStream ( path ) ; if ( null == in ) { logger . error ( \"File path :{}\" , path ) ; } final Reader reader = new InputStreamReader ( in ) ; return StreamUtils", "gt": ". getString ( reader , true ) ;", "prediction": ". getBytes ( reader , true ) ;\n", "label": 1}
{"id": 7709, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends Runnable , S", "gt": "extends String > void disjointness ( )", "prediction": "> void run ( I runnable )\n", "label": 0}
{"id": 13674, "input": "<s> package com . cloudera . sqoop . util ; import java . io . IOException ; public final class ClassLoaderStack { private ClassLoaderStack ( ) { } public static void setCurrentClassLoader ( ClassLoader cl ) { org . apache . sqoop . util . ClassLoaderStack . setCurrentClassLoader ( cl ) ; } public static ClassLoader addJarFile ( String", "gt": "jarFile , String testClassName ) throws IOException", "prediction": "jarFileName )\n", "label": 1}
{"id": 7247, "input": "<s> class T6758789a { class Foo < T > { } < X > void m ( Foo < X > foo ) { } void test ( ) {", "gt": "m ( new Foo ( ) ) ;", "prediction": "}\n", "label": 0}
{"id": 13675, "input": "<s> package org . nuxeo . connect . client . jsf ; import java . io . Serializable ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import java . util . TimeZone ; import javax . faces . context . FacesContext ; import javax . faces . model . SelectItem ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . faces . FacesMessages ; import org . jboss . seam . international . StatusMessage ; import org . nuxeo . connect . client . ui . SharedPackageListingsSettings ; import org . nuxeo . connect . client . vindoz . InstallAfterRestart ; import org . nuxeo . connect . client . we . StudioSnapshotHelper ; import org . nuxeo . connect . data . DownloadablePackage ; import org . nuxeo . connect . data . DownloadingPackage ; import org . nuxeo . connect . packages . PackageManager ; import org . nuxeo . connect . update . LocalPackage ; import org . nuxeo . connect . update . PackageType ; import org . nuxeo . connect . update . PackageUpdateService ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . ecm . admin . AdminViewManager ; import org . nuxeo . ecm . admin . setup . SetupWizardActionBean ; import org . nuxeo . ecm . platform . ui . web . util . ComponentUtils ; import org . nuxeo . ecm . webapp . seam . NuxeoSeamHotReloadContextKeeper ; import org . nuxeo . launcher . config . ConfigurationGenerator ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"appsViews\" ) @ Scope ( ScopeType . CONVERSATION ) public class AppCenterViewsManager implements Serializable { private static final long serialVersionUID = 1L ; protected static final Log log = LogFactory . getLog ( AppCenterViewsManager . class ) ; protected enum SnapshotStatus { downloading , saving , installing , error , completed , restartNeeded ; } protected static final Map < String , String > view2PackageListName = new HashMap < String , String > ( ) { private static final long serialVersionUID = 1L ; { put ( \"ConnectAppsUpdates\" , \"updates\" ) ; put ( \"ConnectAppsStudio\" , \"studio\" ) ; put ( \"ConnectAppsRemote\" , \"remote\" ) ; put ( \"ConnectAppsLocal\" , \"local\" ) ; } } ; @ In ( create = true ) protected String currentAdminSubViewId ; @ In ( create = true ) protected NuxeoSeamHotReloadContextKeeper seamReloadContext ; @ In ( create = true ) protected SetupWizardActionBean setupWizardAction ; @ In ( create = true , required =", "gt": "false ) protected FacesMessages facesMessages ;", "prediction": "false ) protected BundleContext context ;\n", "label": 1}
{"id": 7367, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . Collection ; import java . util . Map ; import java . util . TreeMap ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . grid . gkCheckBoxSelectionModel ; import org . gk . ui . client . com . grid . gkGridIC ; import org . gk . ui . client . com . tree . dir . gkTreeDirPanelIC ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . TabPanel ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; public class SelectAttribute implements IAttribute { @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof gkGridIC ) { gkGridIC grid = ( gkGridIC ) com ; value = grid . getSelectedRowItems ( ) ; } else if ( com instanceof ComboBox ) { ComboBox combo = ( ComboBox ) com ; value = combo . getValue ( ) ; } else if ( com instanceof TabPanel ) { TabPanel tp = ( TabPanel ) com ; value = tp . getSelectedItem ( ) . getId ( ) ; } else if ( com instanceof gkXMLTreePanelIC ) { gkXMLTreePanelIC xtp = ( gkXMLTreePanelIC ) com ; value = xtp . getTree ( ) . getSelectionModel ( ) . getSelectedItem ( ) ; } else if ( com instanceof gkTreeDirPanelIC ) { gkTreeDirPanelIC xtp = ( gkTreeDirPanelIC ) com ; value = xtp . getSelectionModel ( ) . getSelectedItem ( ) ; } return value ; } @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof gkGridIC ) { gkGridIC grid = ( gkGridIC ) com ; if ( value instanceof Collection ) { grid . setSelectRowItem ( ( Collection ) value ) ; } else if ( value instanceof TreeMap ) { TreeMap tm = ( TreeMap ) value ; if ( tm . size ( ) == 1 ) { grid . setSelectRowItem ( ( Map ) tm . get ( tm . firstKey ( ) ) ) ; } } else if ( value instanceof String && grid", "gt": ". getGrid ( ) . getSelectionModel ( ) instanceof gkCheckBoxSelectionModel )", "prediction": ". getSelectRowItem ( ) == null )\n", "label": 0}
{"id": 13680, "input": "<s> package org . spliffy . server . db . store ; import java . util . UUID ; public interface ReplicationManager { void newBlob ( long", "gt": "volumeInstanceId , long hash ) ;", "prediction": "id ) ;\n", "label": 1}
{"id": 1268, "input": "<s> package com . deliciousdroid . client ; import com . deliciousdroid . util . DateParser ; public class Update { private long lastUpdate ; private int inboxNew ; public long getLastUpdate ( ) { return lastUpdate ; } public void setLastUpdate ( long lastUpdate ) { this . lastUpdate = lastUpdate ; } public int getInboxNew ( ) { return inboxNew ; } public void setInboxNew ( int inboxNew ) { this . inboxNew = inboxNew ; } public Update ( ) { } public Update ( long update , int inbox ) { lastUpdate = update ; inboxNew = inbox ; } public static Update valueOf ( String updateResponse ) { Update result = new Update ( 0 , 0 ) ; try { int start = updateResponse . indexOf ( \"<update\" ) ; int end = updateResponse . indexOf ( \"/>\" , start ) ; String updateElement = updateResponse . substring ( start , end ) ; int timestart", "gt": "= updateElement . indexOf ( \"time=\" ) ;", "prediction": "= Integer . parseInt ( updateElement ) ;\n", "label": 0}
{"id": 13685, "input": "<s> package org . nuxeo . ecm . platform . rendering ; import java . util . Collection ; public interface RenderingService { Collection < RenderingResult > process ( RenderingContext ctx ) throws RenderingException ; RenderingEngine getEngine ( String format ) ; void", "gt": "registerEngine ( RenderingEngine engine ) ;", "prediction": "process ( RenderingContext ctx ) throws RenderingException ;\n", "label": 1}
{"id": 6812, "input": "<s> package api . user ; import com . google . gson . annotations . SerializedName ; public class Personal { @ SerializedName ( \"class\" ) private String userClass ; private boolean donor ; private boolean enabled ; private Number paranoia ; private String paranoiaText ; private boolean warned ; public String getUserClass ( ) { return this . userClass ; } public boolean isDonor ( ) { return this . donor ; } public boolean isEnabled ( ) { return this . enabled ; } public Number getParanoia ( ) { return this . paranoia ; } public String getParanoiaText ( ) { return this . paranoiaText ; }", "gt": "public boolean isWarned ( )", "prediction": "public boolean isEnabled ( )\n", "label": 0}
{"id": 13686, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs . io . writers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import org . nuxeo . ecm . automation . server . jaxrs . LoginInfo ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; @ Provider @ Produces ( { \"application/json+nxentity\" , \"application/json\" } ) public class JsonLoginInfoWriter implements MessageBodyWriter < LoginInfo > { public long getSize ( LoginInfo arg0 , Class < ? > arg1 ,", "gt": "Type arg2 , Annotation [ ] arg3 , MediaType arg4 )", "prediction": "Type arg2 , Annotation [ ] arg3 , MediaType arg4 )\n", "label": 1}
{"id": 5798, "input": "<s> package com . farpost . maven . plugins ; import static java . lang . Thread . sleep ; public class Sleep { public void execute ( ) throws InterruptedException {", "gt": "sleep ( 10 ) ;", "prediction": "try\n", "label": 0}
{"id": 13689, "input": "<s> package fr . inria . zvtm . lens ; public class HWaveLens extends BLinearLens { float N = 5.0f ; public HWaveLens ( ) { super ( ) ; } public HWaveLens ( float mm , float n ) { super ( mm ) ; this . N = n ; } public HWaveLens ( float mm , float tc , float tf , int outerRadius , int innerRadius , float n ) { super ( mm , tc , tf , outerRadius , innerRadius ) ; this . N = n ; } public HWaveLens ( float mm , float tc , float tf , int outerRadius , int innerRadius , float n , int x , int y ) { super ( mm , tc , tf , outerRadius , innerRadius , x , y ) ; this . N = n ; } public void setN ( float n ) { this . N = n ; bT = LR2 / N ; } public float getN ( ) { return N ; } void computeDropoffFactors ( ) { aT = MMTf - MMTc ; bT = LR2 / N ; } public void gf ( float x , float y , float [ ] g ) { d = Math . sqrt ( Math . pow ( x - sw - lx , 2 ) + Math . pow ( y - sh - ly , 2 ) ) ; if", "gt": "( d <= LR2 )", "prediction": "( d < 0 )\n", "label": 1}
{"id": 1063, "input": "<s> package api . forum . thread ; public class Author { private boolean artist ; private Number authorId ; private String authorName ; private String permissionId ; private String avatar ; private boolean donor ; private boolean enabled ; private String userTitle ; private boolean warned ; public boolean isArtist ( ) { return artist ; } public Number getAuthorId ( ) { return authorId ; } public String getAuthorName ( ) { return authorName ; } public String getAvatar ( ) { return avatar ; } public boolean isDonor ( ) { return donor ; } public boolean isEnabled ( ) { return enabled ; } public String getUserTitle ( ) { return userTitle ; } public boolean isWarned ( ) { return warned ; } @ Override public String toString ( ) { return \"Author [isArtist=\" + isArtist ( ) + \", getAuthorId=\" + getAuthorId ( ) + \", getAuthorName=\" + getAuthorName ( ) + \", getAvatar=\" + getAvatar ( ) + \", isDonor=\" + isDonor ( ) + \", isEnabled=\" + isEnabled ( ) + \", getParanoia=\" + \", getUserTitle=\" + getUserTitle ( ) + \", isWarned=\" + isWarned ( ) + \"]\" ; } public String getPermissionId ( ) { return permissionId ; } public", "gt": "void setPermissionId ( String permissionId )", "prediction": "void setPermissionId ( String permissionId )\n", "label": 0}
{"id": 13690, "input": "<s> package io . beancounter . commons . model . activity ; import io . beancounter . commons . tests . annotations . Random ; import java . io . Serializable ; import java . util . UUID ; public class Activity implements Serializable { private static final long serialVersionUID = 68843445235L ; private UUID id ; private Verb verb ; private io . beancounter . commons . model . activity . Object object ; private Context context ; public Activity ( ) { id = UUID . randomUUID ( ) ; } public UUID getId ( ) { return id ; } public void setId ( UUID id ) { this . id = id ; } @ Random ( names = { \"v\" , \"obj\" , \"c\" } ) public Activity ( Verb v , Object obj , Context c ) { verb = v ; object = obj ; context = c ; } public Verb getVerb ( ) { return verb ; } public void setVerb ( Verb verb ) { this . verb = verb ; } public Object getObject ( ) { return object ; } public void setObject ( Object object ) { this . object = object ; } public Context getContext ( ) { return context ; } public void setContext ( Context context ) { this . context = context ; } @ Override public String toString ( ) { return \"Activity{\" + \"id=\" + id + \", verb=\" + verb + \", object=\" + object + \", context=\" + context + '}' ; } @ Override public boolean equals ( java . lang . Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Activity ) ) return false ; Activity activity = ( Activity ) o ; if ( context != null ? ! context . equals ( activity . context ) : activity . context != null ) return false ; if ( object != null ? ! object . equals ( activity . object ) : activity . object !=", "gt": "null ) return false ;", "prediction": "null ) return false ;\n", "label": 1}
{"id": 5366, "input": "<s> package dk . brics . automaton ; public class StatePair { State s ; State s1 ; State s2 ; StatePair ( State s , State s1 , State s2 ) { this . s = s ; this . s1 = s1 ; this . s2 = s2 ; } public StatePair ( State s1 , State s2 ) { this . s1 = s1 ; this . s2 = s2 ; } public State getFirstState ( ) { return s1 ; } public State getSecondState ( ) { return s2 ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof StatePair ) { StatePair p = ( StatePair ) obj ; return p . s1 == s1", "gt": "&& p . s2 == s2 ;", "prediction": "&& p . s2 == s2 ;\n", "label": 0}
{"id": 13691, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . model ; import java . util . Iterator ; import java . util . Vector ; public class Template extends AbstractTreeNode implements IBlock { private String fName ; private Vector fDirectives = new Vector ( ) ; public Template ( String aName ) { super ( null , - 1 , - 1 ) ; fName = aName ; } public void addDirective ( Directive aDirective ) { fDirectives . add ( aDirective ) ; } public String getName ( ) { return fName ; } public boolean hasChildren ( ) { return ! fDirectives . isEmpty ( ) ; } public Object [ ] getChildren ( ) { return fDirectives . toArray ( ) ; } public boolean accept ( ITreeVisitor aVisitor ) { boolean more = true ; Iterator iter = fDirectives . iterator ( ) ; while ( more && iter . hasNext ( ) ) { more = ( ( ITreeNode ) iter . next ( ) ) . accept ( aVisitor ) ; } if ( more ) { more = aVisitor . visit ( this ) ; } return more ; } public String getUniqueID ( ) { return getName ( ) ; } public String toString ( ) { return getUniqueID ( ) + \" [\" + getStartLine ( ) + \":\" +", "gt": "getEndLine ( ) + \"] with directive(s) \" + fDirectives ;", "prediction": "getStartColumn ( ) + \"]\" ;\n", "label": 1}
{"id": 3420, "input": "<s> package org . ofbiz . service . mail ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import javax . mail . Address ; import javax . mail . BodyPart ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . Part ; import javax . mail . internet . MimeMessage ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . entity . GenericValue ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class ServiceMcaCondition implements java . io . Serializable { public static final String module = ServiceMcaCondition . class . getName ( ) ; public static final int CONDITION_FIELD = 1 ; public static final int CONDITION_HEADER = 2 ; public static final int CONDITION_SERVICE = 3 ; protected String serviceName = null ; protected String headerName = null ; protected String fieldName = null ; protected String operator = null ; protected String value = null ; public ServiceMcaCondition ( Element condElement , int condType ) { switch ( condType ) { case CONDITION_FIELD : this . fieldName = condElement . getAttribute ( \"field-name\" ) ; this . operator = condElement . getAttribute ( \"operator\" ) ; this . value = condElement . getAttribute ( \"value\" ) ; break ; case CONDITION_HEADER : this . headerName = condElement . getAttribute ( \"header-name\" ) ; this . operator = condElement . getAttribute ( \"operator\" ) ; this . value = condElement . getAttribute ( \"value\" ) ; break ; case CONDITION_SERVICE : this . serviceName = condElement . getAttribute ( \"service-name\" ) ; break ; } } public boolean eval ( LocalDispatcher dispatcher , MimeMessageWrapper messageWrapper , GenericValue userLogin ) { boolean passedCondition = false ; if ( serviceName != null ) { Map < String , Object > result = null ; try { result = dispatcher . runSync ( serviceName , UtilMisc . < String , Object > toMap ( \"messageWrapper\" , messageWrapper , \"userLogin\" , userLogin ) ) ; } catch ( GenericServiceException e ) { Debug . logError ( e , module ) ; return false ; } if ( result == null ) { Debug . logError ( \"Service MCA Condition Service [\" + serviceName + \"] returned null!\" , module ) ; return false ; } else { if ( ServiceUtil . isError ( result ) ) { Debug . logError ( ServiceUtil . getErrorMessage ( result ) , module ) ; return false ; } else { Boolean reply = ( Boolean ) result . get ( \"conditionReply\" ) ; if ( reply == null ) { reply = Boolean . FALSE ; } return reply . booleanValue ( ) ; } } } else if ( headerName != null ) { MimeMessage message = messageWrapper . getMessage ( ) ;", "gt": "String [ ] headerValues = null ;", "prediction": "Map < String , Object > result = null ;\n", "label": 0}
{"id": 13701, "input": "<s> package com . cloudera . sqoop ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . sql . Connection ; import java . sql . Timestamp ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . List ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . HsqldbTestServer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileStatus ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . cloudera . sqoop . SqoopOptions . IncrementalMode ; import com . cloudera . sqoop . manager . ConnManager ; import com . cloudera . sqoop . testutil . BaseSqoopTestCase ; import com . cloudera . sqoop . tool . CodeGenTool ; import com . cloudera . sqoop . tool . ImportTool ; import com . cloudera . sqoop . tool . MergeTool ; import com . cloudera . sqoop . util . ClassLoaderStack ; public class TestMerge extends BaseSqoopTestCase { private static final Log LOG = LogFactory . getLog ( TestMerge . class . getName ( ) ) ; protected ConnManager manager ; protected Connection conn ; public static final String SOURCE_DB_URL = \"jdbc:hsqldb:mem:merge\" ; @ Override public void setUp ( ) { super . setUp ( ) ; manager = getManager ( ) ; try { conn = manager . getConnection ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } public static final String TABLE_NAME = \"MergeTable\" ; public Configuration newConf ( ) { Configuration conf = new Configuration ( ) ; if ( ! BaseSqoopTestCase . isOnPhysicalCluster ( ) ) { conf . set ( CommonArgs . FS_DEFAULT_NAME , CommonArgs . LOCAL_FS ) ; } conf . set ( \"mapred.job.tracker\" , \"local\" ) ; return conf ; } public SqoopOptions getSqoopOptions ( Configuration conf ) { SqoopOptions options = new SqoopOptions ( conf ) ; options . setConnectString ( HsqldbTestServer . getDbUrl ( ) ) ; return options ; } protected void createTable ( ) throws SQLException { PreparedStatement s = conn . prepareStatement ( \"DROP TABLE \" + TABLE_NAME + \" IF EXISTS\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } s = conn . prepareStatement ( \"CREATE TABLE \" + TABLE_NAME + \" (id INT NOT NULL PRIMARY KEY, val INT, lastmod TIMESTAMP)\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } s = conn . prepareStatement ( \"INSERT INTO \" + TABLE_NAME + \" VALUES (\" + \"0, 0, NOW())\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } s = conn . prepareStatement ( \"INSERT INTO \" + TABLE_NAME + \" VALUES (\" + \"1, 42, NOW())\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } conn . commit ( ) ; } public void testMerge ( ) throws Exception { createTable ( ) ; final String MERGE_CLASS_NAME = \"ClassForMerging\" ; SqoopOptions options = getSqoopOptions ( newConf ( ) ) ; options . setTableName ( TABLE_NAME ) ; options . setClassName ( MERGE_CLASS_NAME ) ; CodeGenTool codeGen = new CodeGenTool ( ) ; Sqoop codeGenerator = new Sqoop ( codeGen , options . getConf ( ) , options ) ; int ret = Sqoop . runSqoop ( codeGenerator , new String [ 0 ] ) ; if ( 0 != ret ) { fail ( \"Nonzero exit from codegen: \" + ret ) ; } List < String > jars = codeGen . getGeneratedJarFiles ( ) ; String jarFileName = jars . get ( 0 ) ; Path warehouse = new Path ( BaseSqoopTestCase . LOCAL_WAREHOUSE_DIR ) ; options = getSqoopOptions ( newConf ( ) ) ; options . setTableName ( TABLE_NAME ) ; options . setNumMappers ( 1 ) ; options . setTargetDir ( new Path ( warehouse , \"merge-old\" ) . toString ( ) ) ; options . setIncrementalMode ( IncrementalMode . DateLastModified ) ; options . setIncrementalTestColumn ( \"lastmod\" ) ; ImportTool importTool = new ImportTool ( ) ; Sqoop importer = new Sqoop ( importTool", "gt": ", options . getConf ( ) , options ) ;", "prediction": ", options . getConf ( ) , options ) ;\n", "label": 1}
{"id": 4904, "input": "<s> package com . redhat . ceylon . tools . test ; import org . junit . runner . RunWith ; import org . junit . runners . Suite ; import org . junit . runners . Suite . SuiteClasses ; import com . redhat . ceylon . tools . test . ImportJarToolTest ; import com . redhat . ceylon . tools . bashcompletion . BashCompletionToolTest ; import com . redhat . ceylon . tools . help . DocToolToolTest ; import com . redhat . ceylon . tools . help . HelpToolTest ; import com . redhat . ceylon . tools . help . MarkdownTest ; import com . redhat . ceylon . tools . help . PlaintextTest ; @ RunWith ( Suite . class ) @ SuiteClasses ( { BashCompletionToolTest . class , CompilerToolTest . class , DocToolTest . class , ImportJarToolTest . class , PlaintextTest . class , MarkdownTest . class , HelpToolTest", "gt": ". class , DocToolToolTest . class }", "prediction": ". class }\n", "label": 0}
{"id": 13707, "input": "<s> package org . gatein . common . util ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Map ; public class MapAdapters { private final static ArrayElementConverter < String > stringArrayElementConverter = new ArrayElementConverter < String > ( String . class ) ; private final static AbstractTypedMap . Converter < String , String > stringConverter = AbstractTypedMap . Converter . identityConverter ( ) ; public static < K , V > Map < K , V > adapt ( Map < K , V [ ] > adapted , Class < ? extends V > type ) { if ( adapted == null ) { throw new IllegalArgumentException ( \"Cannot adapt a null map\" ) ; } ArrayElementConverter < V > valueConverter = new ArrayElementConverter < V > ( type ) ; AbstractTypedMap . Converter < K , K > keyConverter = AbstractTypedMap . Converter . identityConverter ( ) ; return new TypedMap < K , V , K , V [ ] > ( adapted , keyConverter , valueConverter ) ; } public static Map < String , String > adapt ( Map < String , String [ ] > adapted ) { if ( adapted == null ) { throw new IllegalArgumentException ( \"Cannot adapt a null map\" ) ; } return new TypedMap < String , String , String , String [ ] > ( adapted , stringConverter , stringArrayElementConverter ) ; } private static class ArrayElementConverter < T > extends AbstractTypedMap . Converter < T , T [ ] > { private final Class < ? extends T > type ;", "gt": "private ArrayElementConverter ( Class < ? extends T > type )", "prediction": "public ArrayElementConverter ( Class < T > type )\n", "label": 1}
{"id": 1001, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree . JCAnnotation ; import com . sun . tools . javac . tree . JCTree . JCExpression ; import com . sun . tools . javac . tree . JCTree . JCVariableDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . Name ; public class ParameterDefinitionBuilder { private final AbstractTransformer gen ; private long modifiers ; private JCExpression type ; private List < JCAnnotation > typeAnnos ; private boolean sequenced ; private boolean defaulted ; private final String name ; private String aliasedName ; private boolean noAnnotations = false ; private boolean built = false ; private ParameterDefinitionBuilder ( AbstractTransformer gen , String name ) { this . gen = gen ; this . name = name ; } static ParameterDefinitionBuilder instance ( AbstractTransformer gen , String name ) { return new ParameterDefinitionBuilder ( gen , name ) ; } public ParameterDefinitionBuilder modifiers ( long mods ) { this . modifiers |= mods ; return this ; } public ParameterDefinitionBuilder type ( JCExpression type , List < JCAnnotation > typeAnnos ) { this . type = type ; this . typeAnnos = typeAnnos ; return this ; } public ParameterDefinitionBuilder sequenced ( boolean sequenced ) { this . sequenced = sequenced ; return this ; } public ParameterDefinitionBuilder aliasName ( String aliasedName ) { this . aliasedName = aliasedName ; return this ; } public ParameterDefinitionBuilder defaulted ( boolean defaulted ) { this . defaulted = defaulted ; return this ; } public ParameterDefinitionBuilder noAnnotations ( ) { noAnnotations = true ; return this ; } public JCVariableDecl build ( ) { if ( built ) { throw new IllegalStateException ( ) ; } built = true ; List < JCAnnotation > annots = List . nil ( ) ; if ( ! noAnnotations ) { annots = annots . appendList ( gen . makeAtName ( name ) ) ; if ( sequenced ) { annots = annots . appendList ( gen . makeAtSequenced ( ) ) ; } if ( defaulted ) { annots = annots . appendList ( gen . makeAtDefaulted ( ) ) ; } if ( typeAnnos != null ) { annots = annots . appendList ( typeAnnos ) ; } } Name name = gen . names ( ) . fromString ( aliasedName != null ? aliasedName : this . name ) ; return gen . make ( ) . VarDef ( gen . make ( ) . Modifiers ( modifiers | Flags . PARAMETER , annots ) , name , type , null ) ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( Flags . toString ( modifiers ) )", "gt": ". append ( ' ' ) ;", "prediction": ";\n", "label": 0}
{"id": 13708, "input": "<s> package monbulk . MethodBuilder . client . presenter ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map . Entry ; import com . google . gwt . core . client . GWT ; import com . google . gwt . event . shared . HandlerManager ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . HasWidgets ; import monbulk . MethodBuilder . client . PreviewWindow ; import monbulk . MethodBuilder . client . PreviewWindow . SupportedFormats ; import monbulk . MethodBuilder . client . event . ChangeWindowEvent ; import monbulk . MethodBuilder . client . event . ChangeWindowEventHandler ; import monbulk . MethodBuilder . client . model . MethodCompleteModel ; import monbulk . MethodBuilder . client . view . AppletStateNavigation ; import monbulk . MethodBuilder . client . view . MethodDetailsView ; import monbulk . MethodBuilder . client . view . MethodForm ; import monbulk . MethodBuilder . client . view . StepForm ; import monbulk . MethodBuilder . client . view . SubjectPropertiesForm ; import monbulk . client . desktop . Desktop ; import monbulk . client . event . WindowEvent ; import monbulk . shared . Architecture . IPresenter . FormPresenter ; import monbulk . shared . Architecture . IView ; import monbulk . shared . Architecture . IView . IDockView ; import monbulk . shared . Architecture . IView . IDraggable ; import monbulk . shared . Architecture . IView . IFormView ; import monbulk . shared . Events . DragEvent ; import monbulk . shared . Form . FormBuilder ; import monbulk . shared . Model . IPojo ; import monbulk . shared . Model . pojo . pojoMetaData ; import monbulk . shared . Model . pojo . pojoMethod ; import monbulk . shared . Model . pojo . pojoStepDetails ; import monbulk . shared . Model . pojo . pojoStudy ; import monbulk . shared . Model . pojo . pojoSubjectProperties ; import monbulk . shared . util . GWTLogger ; import monbulk . shared . util . HtmlFormatter ; import monbulk . shared . util . MonbulkEnums ; import monbulk . shared . util . MonbulkEnums . viewTypes ; import monbulk . shared . widgets . Window . OkCancelWindow . OkCancelHandler ; import monbulk . shared . widgets . Window . appletWindow ; import monbulk . MethodBuilder . shared . IMethodsView ; import monbulk . MethodBuilder . shared . iMBModel ; public class MethodCreatorPresenter implements FormPresenter , ChangeWindowEventHandler { private int countLoads ; private MethodCreatorStates CurrentState ; private IMethodsView ImplementedMethodView ; private IView NavigationView ; public enum MethodCreatorStates { METHOD_DETAILS , SUBJECT_PROPERTIES , STEP_DETAILS , COMPLETE , INIT } ; public enum SupportedMethodCommands { NEW , EDIT , NEXT , PREV , ADD_STEP , REMOVE_STEP , PREVIEW , SAVE , PUBLISH , DELETE_METHOD , CANCEL , EXPAND } public final HashMap < String , MethodCreatorStates > stateSelector ; public final HashMap < MethodCreatorStates , IFormView > _AllStates ; private final MethodCompleteModel mainModel ; private final HandlerManager eventBus ; private Boolean hasNewData ; public MethodCreatorPresenter ( HandlerManager evtBus ) { GWTLogger . Log ( \"MCP Construct\" , \"MCP\" , \"Construct\" , \"82\" ) ; stateSelector = new HashMap < String , MethodCreatorStates > ( ) ; _AllStates = new HashMap < MethodCreatorStates , IFormView > ( ) ; this . eventBus = evtBus ; mainModel = new MethodCompleteModel ( ) ; mainModel . setPresenter ( this ) ; Construct ( \"\" ) ; } public MethodCreatorPresenter ( HandlerManager evtBus , String ID ) { GWTLogger . Log ( \"MCP Construct with ID\" , \"MCP\" , \"Construct\" , \"117\" ) ; stateSelector = new HashMap < String , MethodCreatorStates > ( ) ; _AllStates = new HashMap < MethodCreatorStates , IFormView > ( ) ; this . eventBus = evtBus ; mainModel = new MethodCompleteModel ( ID , this ) ; mainModel . setPresenter ( this ) ; Construct ( ID ) ; } public void Construct ( String ID ) { stateSelector . put ( \"METHOD_DETAILS\" , MethodCreatorStates . METHOD_DETAILS ) ; stateSelector . put ( \"SUBJECT_PROPERTIES\" , MethodCreatorStates . SUBJECT_PROPERTIES ) ; stateSelector . put ( \"STEP_DETAILS\" , MethodCreatorStates . STEP_DETAILS ) ; stateSelector . put ( \"COMPLETE\" , MethodCreatorStates . COMPLETE ) ; stateSelector . put ( \"INIT\" , MethodCreatorStates . INIT ) ; this . ImplementedMethodView =", "gt": "new MethodDetailsView ( ) ;", "prediction": "new ImplementedMethodView ( ) ;\n", "label": 1}
{"id": 1230, "input": "<s> package org . ofbiz . entity . transaction ; import java . sql . Connection ; import java . sql . SQLException ; import java . util . Map ; import javax . naming . InitialContext ; import javax . naming . NamingException ; import javax . sql . DataSource ; import javax . sql . XAConnection ; import javax . sql . XADataSource ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import javolution . util . FastMap ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . JNDIContextFactory ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . ConnectionFactory ; import org . w3c . dom . Element ; public class JNDIFactory implements TransactionFactoryInterface { public static final String module = JNDIFactory . class . getName ( ) ; static TransactionManager transactionManager = null ; static UserTransaction userTransaction = null ; protected static Map < String , DataSource > dsCache = FastMap . newInstance ( ) ; public TransactionManager getTransactionManager ( ) { if ( transactionManager == null ) { synchronized ( JNDIFactory . class ) { if ( transactionManager == null ) { try { String jndiName = EntityConfigUtil . getTxFactoryTxMgrJndiName ( ) ; String jndiServerName = EntityConfigUtil . getTxFactoryTxMgrJndiServerName ( ) ; if ( UtilValidate . isNotEmpty ( jndiName ) ) { try { InitialContext ic = JNDIContextFactory . getInitialContext ( jndiServerName ) ; if ( ic != null ) { transactionManager = ( TransactionManager ) ic . lookup ( jndiName ) ; } } catch ( NamingException ne ) { Debug . logWarning ( ne , \"NamingException while finding TransactionManager named \" + jndiName + \" in JNDI.\" , module ) ; transactionManager = null ; } if ( transactionManager == null ) { Debug . logWarning ( \"[JNDIFactory.getTransactionManager] Failed to find TransactionManager named \" + jndiName + \" in JNDI.\" , module ) ; } } } catch ( GeneralException e ) { Debug . logError ( e , module ) ; transactionManager = null ; } } } } return transactionManager ; } public UserTransaction getUserTransaction ( ) { if ( userTransaction == null ) { synchronized ( JNDIFactory . class ) { if", "gt": "( userTransaction == null )", "prediction": "( userTransaction == null )\n", "label": 0}
{"id": 13709, "input": "<s> package org . spliffy . server . db . store ; import java . io . File ; public class FsHashUtils { public static String toHex ( long hash ) { String hex = Long . toHexString ( hash ) ; return hex ; } public static File toFile ( File root , long hash ) { File f = root ; String hex = toHex ( hash ) ; String name = hex ; while ( name . length ( ) > 3 ) { String subdir = name . substring ( 0 , 2 ) ; f = new File", "gt": "( f , subdir ) ;", "prediction": "( root , subdir ) ;\n", "label": 1}
{"id": 1130, "input": "<s> package org . ofbiz . content . webapp . ftl ; import java . io . IOException ; import java . io . Writer ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . webapp . ftl . LoopWriter ; import freemarker . core . Environment ; import freemarker . template . TemplateModelException ; import freemarker . template . TemplateTransformModel ; import freemarker . template . TransformControl ; public class InjectNodeTrailCsvTransform implements TemplateTransformModel { public static final String module = InjectNodeTrailCsvTransform . class . getName ( ) ; public static final String [ ] saveKeyNames = { \"nodeTrailCsv\" , \"globalNodeTrail\" , \"nodeTrail\" } ; public static final String [ ] removeKeyNames = { \"nodeTrailCsv\" } ; @ Deprecated public static Object getWrappedObject ( String varName , Environment env ) { return FreeMarkerWorker . getWrappedObject ( varName , env ) ; } @ Deprecated public static String getArg ( Map < String , ? extends Object > args , String key , Environment env ) { return FreeMarkerWorker . getArg ( args , key , env ) ; } @ Deprecated public static String getArg ( Map < String , ? extends Object > args , String key , Map < String , ? extends Object > ctx ) { return FreeMarkerWorker . getArg ( args , key , ctx ) ; } @ SuppressWarnings ( \"unchecked\" ) public Writer getWriter ( final Writer out , Map args ) { final StringBuilder buf = new StringBuilder ( ) ; final Environment env = Environment . getCurrentEnvironment ( ) ; final Map < String , Object > templateCtx = FreeMarkerWorker . getWrappedObject ( \"context\" , env ) ; final Delegator delegator = FreeMarkerWorker . getWrappedObject ( \"delegator\" , env ) ; final HttpServletRequest request = FreeMarkerWorker . getWrappedObject ( \"request\" , env ) ; FreeMarkerWorker . getSiteParameters ( request , templateCtx ) ; FreeMarkerWorker . overrideWithArgs ( templateCtx , args ) ; return new LoopWriter ( out ) { final String passedCsv = ( String ) templateCtx . get ( \"nodeTrailCsv\" ) ; @ Override public void write ( char cbuf [ ] , int off , int len ) { buf . append (", "gt": "cbuf , off , len ) ;", "prediction": "cbuf , off , len ) ;\n", "label": 0}
{"id": 13710, "input": "<s> package org . restlet . security ; import java . security . Principal ; import org . restlet . data . ClientInfo ; public interface Enroler { public void enrole", "gt": "( ClientInfo clientInfo ) ;", "prediction": "( ClientInfo clientInfo ) ;\n", "label": 1}
{"id": 4632, "input": "<s> package com . mobeelizer . mobile . android ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import com . mobeelizer . java . api . MobeelizerOperationError ; import com . mobeelizer . java . errors . MobeelizerOperationStatus ; interface MobeelizerConnectionManager { boolean isNetworkAvailable ( ) ; MobeelizerLoginResponse login ( ) ; MobeelizerOperationStatus < String > sendSyncAllRequest ( ) ; MobeelizerOperationStatus < String > sendSyncDiffRequest ( final File outputFile ) ; MobeelizerOperationError waitUntilSyncRequestComplete ( final String ticket ) ; File getSyncData ( final String ticket ) throws IOException ; MobeelizerOperationError confirmTask ( final String ticket ) ; MobeelizerOperationError registerForRemoteNotifications ( final String registrationId ) ; MobeelizerOperationError unregisterForRemoteNotifications ( final String remoteNotificationToken ) ; MobeelizerOperationError sendRemoteNotification ( final String device , final String group , final List < String > users ,", "gt": "final Map < String , String > notification ) ;", "prediction": "final List < String > groups ) ;\n", "label": 0}
{"id": 13714, "input": "<s> package org . eclipse . jface . databinding . viewers ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . set . IObservableSet ; import org . eclipse . core . databinding . property . set . SimpleSetProperty ; import org . eclipse . jface . databinding . swt . SWTObservables ; import org . eclipse . jface . internal . databinding . viewers . ViewerObservableSetDecorator ; import org . eclipse . jface . viewers . Viewer ; public abstract class ViewerSetProperty extends SimpleSetProperty implements IViewerSetProperty { public IObservableSet observe ( Object source ) { if ( source instanceof Viewer ) { return observe ( ( Viewer ) source ) ; } return super . observe ( source ) ; } public IObservableSet observe ( Realm realm , Object source ) { IObservableSet observable = super . observe", "gt": "( realm , source ) ;", "prediction": "( realm , source ) ;\n", "label": 1}
{"id": 9568, "input": "<s> class T7015430 { static < E extends Exception > Iterable < E > empty ( Iterable < E > arg ) throws E { return null ; } < E extends Exception > T7015430 ( Iterable < E > arg ) throws E { } static < E extends Exception > Iterable < E > empty2 ( Iterable x ) throws E { return null ; } static class Foo < X extends Exception > { Foo ( ) throws X { } } void m1 ( ) { Iterable < RuntimeException > i = java . util . Collections . emptyList ( ) ; empty ( i ) ; } void m2 ( ) { Iterable i = java . util . Collections . EMPTY_LIST ; empty ( i ) ; } void m3 ( ) { Iterable i = java . util . Collections . EMPTY_LIST ; T7015430 . < RuntimeException > empty ( i ) ; } void m4 ( ) { Iterable < RuntimeException > i = java . util . Collections . emptyList ( ) ; new T7015430 ( i ) ; } void m5 ( ) { Iterable i = java . util . Collections . EMPTY_LIST ; new T7015430 ( i ) ; } void m6 ( ) { Iterable", "gt": "i = java . util . Collections . EMPTY_LIST ;", "prediction": "< RuntimeException > i = java . util . Collections . emptyList ( ) ;\n", "label": 0}
{"id": 13718, "input": "<s> package org . eclipse . jface . resource ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . core . runtime . Assert ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . widgets . Display ; public class ImageRegistry { private Display display ; private ResourceManager manager ; private Map table ; private Runnable disposeRunnable = new Runnable ( ) { public void run ( ) { dispose ( ) ; } } ; private static class Entry { protected Image image ; protected ImageDescriptor descriptor ; } private static class OriginalImageDescriptor extends ImageDescriptor { private Image original ; private int refCount = 0 ; private Device originalDisplay ; public OriginalImageDescriptor ( Image original , Device originalDisplay ) { this . original = original ; this . originalDisplay = originalDisplay ; } public Object createResource ( Device device ) throws DeviceResourceException { if ( device == originalDisplay ) { refCount ++ ; return original ; } return super . createResource ( device ) ; } public void destroyResource ( Object toDispose ) { if ( original == toDispose ) { refCount -- ; if ( refCount == 0 ) { original . dispose ( ) ; original = null ; } } else { super . destroyResource ( toDispose ) ; } } public ImageData getImageData ( ) { return original . getImageData ( ) ; } } public ImageRegistry ( ) { this ( Display . getCurrent ( ) ) ; } public ImageRegistry ( ResourceManager manager ) { Assert . isNotNull ( manager ) ; Device dev = manager . getDevice ( ) ; if ( dev instanceof Display ) { this . display = ( Display ) dev ; } this . manager = manager ; manager . disposeExec ( disposeRunnable ) ; } public ImageRegistry ( Display display ) { this ( JFaceResources . getResources ( display ) ) ; } public Image get ( String key ) { if ( key == null ) { return null ; } if ( display != null ) { int swtKey = - 1 ; if ( key . equals ( Dialog . DLG_IMG_INFO ) ) { swtKey = SWT . ICON_INFORMATION ; } if ( key . equals ( Dialog . DLG_IMG_QUESTION ) ) { swtKey = SWT . ICON_QUESTION ; }", "gt": "if ( key . equals ( Dialog . DLG_IMG_WARNING ) )", "prediction": "if ( key . equals ( Dialog . DLG_IMG_WARNING ) )\n", "label": 1}
{"id": 9901, "input": "<s> import static com . sun . tools . javac . util . Convert . enclosingCandidates ; import com . sun . tools . javac . util . * ; import java . util . Arrays ; import java . util . Locale ; public class EnclosingCandidates { Names names = Names . instance ( new Context ( ) ) ; void test ( String name , String ... expected ) { List < Name > result = enclosingCandidates ( names . fromString ( name ) ) ; if ( ! result . isEmpty ( ) || expected . length != 0 ) { Name [ ] expectedNames = new Name [ expected . length ] ; int i = 0 ; for ( String s : expected ) expectedNames [ i ++ ] = names . fromString ( s ) ; if ( ! Arrays . equals ( result . toArray ( ) , expectedNames ) ) throw new AssertionError ( name + \" : \" + Arrays . toString ( expectedNames ) + \" != \" + result ) ; } System . out . format ( ( Locale ) null , \"OK: %s -> [%s]%n\" , name , result ) ; } public static void main ( String ... args ) { EnclosingCandidates test = new EnclosingCandidates ( ) ; test", "gt": ". test ( \"\" ) ;", "prediction": ". names = names ;\n", "label": 0}
{"id": 13724, "input": "<s> package org . restlet . ext . jaxrs . internal . util ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . ListIterator ; public class SortedOrderedBag < E > implements Collection < E > { private static final class Compar < A extends Comparable < A > > implements Comparator < A > { public Compar ( ) { } public int compare ( A o1 , A o2 ) { return o1 . compareTo ( o2 ) ; } } @ SuppressWarnings ( \"rawtypes\" ) private static final Comparator < ? > DEFAULT_COMPARATOR = new Compar ( ) ; private final Comparator < E > comp ; private final LinkedList < E > elements = new LinkedList < E > ( ) ; @ SuppressWarnings ( \"unchecked\" ) public SortedOrderedBag ( ) { this . comp = ( Comparator < E > ) DEFAULT_COMPARATOR ; } @ SuppressWarnings ( \"unchecked\" ) public SortedOrderedBag ( Collection < E > coll ) { this . comp = ( Comparator < E > ) DEFAULT_COMPARATOR ; this . addAll ( coll ) ; } public SortedOrderedBag ( Comparator < E > comp ) { this . comp = comp ; } public SortedOrderedBag ( Comparator < E > comp , Collection < E > coll ) { this . comp = comp ; this . addAll ( coll ) ; } public boolean add ( E add ) { if ( this . elements . isEmpty ( ) ) { this . elements . add ( add ) ; return true ; } final ListIterator < E > listIter ; listIter = this . elements . listIterator ( this . elements . size ( ) ) ; while ( listIter . hasPrevious ( ) ) { E current = listIter . previous ( ) ; if ( comp . compare ( add , current ) >= 0 ) { listIter . next ( ) ; listIter . add ( add ) ; return true ; } } this . elements . addFirst ( add ) ; return true ; } public boolean addAll ( Collection < ? extends E > c ) { for ( E e : c ) this . add ( e ) ; return true ; } public void clear ( ) { this . elements . clear ( ) ; } public boolean contains ( Object o ) { return this . elements . contains ( o ) ; } public boolean containsAll ( Collection < ? > c ) { return this . elements . containsAll ( c ) ; } public boolean isEmpty ( ) { return this . elements . isEmpty ( ) ; } public E get ( int index ) { return this . elements . get ( index ) ; } public Iterator < E > iterator ( ) { return this . elements . iterator ( ) ; } public boolean remove ( Object o ) { return this", "gt": ". elements . remove ( o ) ;", "prediction": ". elements . remove ( o ) ;\n", "label": 1}
{"id": 6614, "input": "<s> package ar . com . fdvs . dj . domain . constants ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignFont ; public class Font extends BaseDomainConstant implements Cloneable { private static final long serialVersionUID = 1L ; private int fontSize ; private String fontName ; private boolean bold = false ; private boolean italic = false ; private boolean underline = false ; private String pdfFontName ; private String pdfFontEncoding = null ; private boolean pdfFontEmbedded = false ; public static final String PDF_ENCODING_CP1250_Central_European = \"CP1250\" ; public static final String PDF_ENCODING_CP1251_Cyrillic = \"CP1251\" ; public static final String PDF_ENCODING_CP1252_Western_European_ANSI = \"CP1252\" ; public static final String PDF_ENCODING_CP1253_Greek = \"CP1253\" ; public static final String PDF_ENCODING_CP1254_Turkish = \"CP1254\" ; public static final String PDF_ENCODING_CP1255_Hebrew = \"CP1255\" ; public static final String PDF_ENCODING_CP1256_Arabic = \"CP1256\" ; public static final String PDF_ENCODING_CP1257_Baltic = \"CP1257\" ; public static final String PDF_ENCODING_CP1258_Vietnamese = \"CP1258\" ; public static final String PDF_ENCODING_UniGB_UCS2_H_Chinese_Simplified = \"UniGB-UCS2-H\" ; public static final String PDF_ENCODING_UniGB_UCS2_V_Chinese_Simplified = \"UniGB-UCS2-V\" ; public static final String PDF_ENCODING_UniCNS_UCS2_H_Chinese_traditional = \"UniCNS-UCS2-H\" ; public static final String PDF_ENCODING_UniCNS_UCS2_V_Chinese_traditional = \"UniCNS-UCS2-V\" ; public static final String PDF_ENCODING_UniJIS_UCS2_H_Japanese = \"UniJIS-UCS2-H\" ; public static final String PDF_ENCODING_UniJIS_UCS2_V_Japanese = \"UniJIS-UCS2-V\" ; public static final String PDF_ENCODING_UniJIS_UCS2_HW_H_Japanese = \"UniJIS-UCS2-HW-H\" ; public static final String PDF_ENCODING_UniJIS_UCS2_HW_V_Japanese = \"UniJIS-UCS2-HW-V\" ; public static final String PDF_ENCODING_UniKS_UCS2_H_Korean = \"UniKS-UCS2-H\" ; public static final String PDF_ENCODING_UniKS_UCS2_V_Korean = \"UniKS-UCS2-V\" ; public static final String PDF_ENCODING_Identity_H_Unicode_with_horizontal_writing = \"Identity-H\" ; public static final String PDF_ENCODING_Identity_V_Unicode_with_horizontal_writing = \"Identity-V\" ; public static final String _FONT_ARIAL = \"Arial\" ; public static final String _FONT_TIMES_NEW_ROMAN = \"Times New Roman\" ; public static final String _FONT_COURIER_NEW = \"Courier New\" ; public static final String _FONT_COMIC_SANS = \"Comic Sans MS\" ; public static final String _FONT_GEORGIA = \"Georgia\" ; public static final String _FONT_VERDANA = \"Verdana\" ; public static final int SMALL = 8 ; public static final int MEDIUM = 10 ; public static final int BIG = 14 ; public static Font ARIAL_SMALL = new Font ( SMALL , _FONT_ARIAL , false , false , false ) ; public static Font ARIAL_MEDIUM = new Font ( MEDIUM , _FONT_ARIAL , false , false , false ) ; public static Font ARIAL_BIG = new Font ( BIG , _FONT_ARIAL , false , false , false ) ; public static Font ARIAL_SMALL_BOLD = new Font ( SMALL , _FONT_ARIAL , true , false , false ) ; public static Font ARIAL_MEDIUM_BOLD = new Font ( MEDIUM , _FONT_ARIAL , true , false , false ) ; public static Font ARIAL_BIG_BOLD = new Font ( BIG , _FONT_ARIAL , true , false , false ) ; public static Font TIMES_NEW_ROMAN_SMALL = new Font ( SMALL , _FONT_TIMES_NEW_ROMAN , false , false , false ) ; public static Font TIMES_NEW_ROMAN_MEDIUM = new Font ( MEDIUM , _FONT_TIMES_NEW_ROMAN , false , false , false ) ; public static Font TIMES_NEW_ROMAN_BIG = new Font ( BIG , _FONT_TIMES_NEW_ROMAN , false , false , false ) ; public static Font TIMES_NEW_ROMAN_SMALL_BOLD = new Font ( SMALL , _FONT_TIMES_NEW_ROMAN , true , false , false ) ; public static Font TIMES_NEW_ROMAN_MEDIUM_BOLD = new Font ( MEDIUM , _FONT_TIMES_NEW_ROMAN , true , false , false ) ; public static Font TIMES_NEW_ROMAN_BIG_BOLD = new Font ( BIG , _FONT_TIMES_NEW_ROMAN , true , false , false ) ; public static Font COURIER_NEW_SMALL = new Font ( SMALL , _FONT_COURIER_NEW , false , false , false ) ; public static Font COURIER_NEW_MEDIUM = new Font ( MEDIUM , _FONT_COURIER_NEW , false , false , false ) ; public static Font COURIER_NEW_BIG = new Font ( BIG , _FONT_COURIER_NEW , false , false , false ) ; public static Font COURIER_NEW_SMALL_BOLD = new Font ( SMALL , _FONT_COURIER_NEW , true , false , false ) ; public static Font COURIER_NEW_MEDIUM_BOLD = new Font ( MEDIUM , _FONT_COURIER_NEW , true , false , false ) ; public static Font COURIER_NEW_BIG_BOLD = new Font ( BIG , _FONT_COURIER_NEW , true , false , false ) ; public static Font COMIC_SANS_SMALL = new Font ( SMALL , _FONT_COMIC_SANS , false", "gt": ", false , false ) ;", "prediction": ", false , false ) ;\n", "label": 0}
{"id": 13727, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . common . util . EList ; public interface ObjectProperty extends ClassProperty { Boolean getIsInverseFunctional ( ) ; void setIsInverseFunctional ( Boolean value ) ; Boolean getIsSymmetric ( ) ; void setIsSymmetric ( Boolean value ) ; Boolean getIsAsymmetric ( ) ; void setIsAsymmetric ( Boolean value ) ; Boolean getIsTransitive ( ) ; void setIsTransitive ( Boolean value ) ; Boolean getIsReflexive ( ) ; void setIsReflexive ( Boolean value ) ; Boolean getIsIrreflexive ( ) ; void setIsIrreflexive ( Boolean value ) ; EList < ObjectProperty", "gt": "> getInverseOf ( ) ;", "prediction": "> getProperties ( ) ;\n", "label": 1}
{"id": 2060, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EDataType ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . impl . EFactoryImpl ; import org . eclipse . emf . ecore . plugin . EcorePlugin ; import org . jjflyboy . tjpeditor . project . * ; public class ProjectFactoryImpl extends EFactoryImpl implements ProjectFactory { public static ProjectFactory init ( ) { try { ProjectFactory theProjectFactory = ( ProjectFactory ) EPackage . Registry . INSTANCE . getEFactory ( \"http://www.jjflyboy.org/tjpeditor/Project\" ) ; if ( theProjectFactory != null ) { return theProjectFactory ; } } catch ( Exception exception ) { EcorePlugin . INSTANCE . log ( exception ) ; } return new ProjectFactoryImpl ( ) ; } public ProjectFactoryImpl ( ) { super ( ) ; } @ Override public EObject create ( EClass eClass ) { switch ( eClass . getClassifierID ( ) ) { case ProjectPackage . GLOBAL : return createGlobal ( ) ; case ProjectPackage . PROPERTY : return createProperty ( ) ; case ProjectPackage . ACCOUNT : return createAccount ( ) ; case ProjectPackage . ACCOUNT_ATTRIBUTE : return createAccountAttribute ( ) ; case ProjectPackage . ACCOUNT_PREFIX : return createAccountPrefix ( ) ; case ProjectPackage . ACCOUNT_REPORT : return createAccountReport ( ) ; case ProjectPackage . ACCOUNT_ROOT : return createAccountRoot ( ) ; case ProjectPackage . PROJECT : return createProject ( ) ; case ProjectPackage . PROJECT_ATTRIBUTE : return createProjectAttribute ( ) ; case ProjectPackage . TASK : return createTask ( ) ; case ProjectPackage . TASK_ATTRIBUTE : return createTaskAttribute ( ) ; case ProjectPackage . REPORT : return createReport ( ) ; case ProjectPackage . REPORT_ATTRIBUTE : return createReportAttribute ( ) ; case ProjectPackage . ICAL_REPORT : return createIcalReport ( ) ; case ProjectPackage . ICAL_REPORT_ATTRIBUTE : return createIcalReportAttribute ( ) ; case ProjectPackage . EXPORT : return createExport ( ) ; case ProjectPackage . EXPORT_ATTRIBUTE : return createExportAttribute ( ) ; case ProjectPackage . RESOURCE : return createResource ( ) ; case ProjectPackage . RESOURCE_ATTRIBUTE : return createResourceAttribute ( ) ; case ProjectPackage . ALLOCATE : return createAllocate ( ) ; case ProjectPackage . ALLOCATE_RESOURCE : return createAllocateResource ( ) ; case ProjectPackage . ALLOCATE_RESOURCE_ATTRIBUTE : return createAllocateResourceAttribute ( ) ; case ProjectPackage . NAVIGATOR : return createNavigator ( ) ; case ProjectPackage . NAVIGATOR_ATTRIBUTE : return createNavigatorAttribute ( ) ; case ProjectPackage . NEW_TASK : return createNewTask ( ) ; case ProjectPackage . NEW_TASK_ATTRIBUTE : return createNewTaskAttribute ( ) ; case ProjectPackage . NIKU_REPORT : return createNikuReport ( ) ; case ProjectPackage . NIKU_REPORT_ATTRIBUTE : return createNikuReportAttribute ( ) ; case ProjectPackage . ALERT : return createAlert ( ) ; case ProjectPackage . ALTERNATIVE : return createAlternative ( ) ; case ProjectPackage . AUTHOR : return createAuthor ( ) ; case ProjectPackage . BALANCE : return createBalance ( ) ; case ProjectPackage . BOOKING : return createBooking ( ) ; case ProjectPackage . BOOKING_TASK : return createBookingTask ( ) ; case ProjectPackage . BOOKING_RESOURCE : return createBookingResource ( ) ; case ProjectPackage . CAPTION : return createCaption ( ) ; case ProjectPackage . CELL_COLOR : return createCellColor ( ) ; case ProjectPackage . CELL_TEXT : return createCellText ( ) ; case ProjectPackage . CENTER : return createCenter ( ) ; case ProjectPackage . CHARGE : return createCharge ( ) ; case ProjectPackage . CHARGE_SET : return createChargeSet ( ) ; case ProjectPackage . COLUMNS : return createColumns ( ) ; case ProjectPackage . COMPLETE : return createComplete ( ) ; case ProjectPackage . COPYRIGHT : return createCopyright ( ) ; case ProjectPackage . CREDIT : return createCredit ( ) ; case ProjectPackage . CURRENCY : return createCurrency ( ) ; case ProjectPackage . CURRENCY_FORMAT : return createCurrencyFormat ( ) ; case ProjectPackage . DAILY_MAX : return createDailyMax ( ) ; case ProjectPackage . DAILY_MIN : return createDailyMin ( ) ; case ProjectPackage . DAILY_WORKING_HOURS : return createDailyWorkingHours ( ) ; case ProjectPackage . DEFINITIONS : return createDefinitions ( ) ; case ProjectPackage . DEPENDS : return createDepends ( ) ; case ProjectPackage . DETAILS : return createDetails ( ) ; case ProjectPackage . DURATION : return createDuration ( ) ; case ProjectPackage . EFFICIENCY : return createEfficiency ( ) ; case ProjectPackage . EFFORT : return createEffort ( ) ; case ProjectPackage", "gt": ". EMAIL : return createEmail ( ) ;", "prediction": ". EVENT : return createEvent ( ) ;\n", "label": 0}
{"id": 13728, "input": "<s> package org . spliffy . sync . triplets ; import com . bradmcevoy . common . Path ; import java . util . List ; import org . spliffy . common . Triplet ; public interface TripletStore { List < Triplet >", "gt": "getTriplets ( Path path ) ;", "prediction": "triples ;\n", "label": 1}
{"id": 262, "input": "<s> package Liza ; import org . bukkit . entity . Explosive ;", "gt": "public interface LizaExplosive extends Explosive", "prediction": "import org . bukkit . entity . Entity ;\n", "label": 0}
{"id": 13732, "input": "<s> package org . nuxeo . ecm . platform . syndication . vocabularies ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; public final class HierarchicalVocabulary { public static final Comparator < HierarchicalVocabulary > ORDER_BY_ID = new Comparator < HierarchicalVocabulary > ( ) { public int compare ( HierarchicalVocabulary o1 , HierarchicalVocabulary o2 ) { return o1 . getVocabulary ( ) . getId ( ) . compareToIgnoreCase ( o2 . getVocabulary ( ) . getId ( ) ) ; } } ; private final SimpleVocabulary simpleVocabulary ; private final HierarchicalVocabulary parent ; private final List < HierarchicalVocabulary > children = new ArrayList < HierarchicalVocabulary > ( ) ; private boolean sorted = false ; public HierarchicalVocabulary ( HierarchicalVocabulary parent , SimpleVocabulary vocabulary ) { simpleVocabulary = vocabulary ; this . parent = parent ; } public void addChild ( HierarchicalVocabulary voca ) { children . add ( voca ) ; } public void addChild ( SimpleVocabulary voca ) { addChild ( new HierarchicalVocabulary", "gt": "( this , voca ) ) ;", "prediction": "( voca ) ) ;\n", "label": 1}
{"id": 4122, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . providers ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . emf . ecore . EAnnotation ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EcoreFactory ; import org . eclipse . emf . transaction . util . TransactionUtil ; import org . eclipse . gmf . runtime . common . core . service . AbstractProvider ; import org . eclipse . gmf . runtime . common . core . service . IOperation ; import org . eclipse . gmf . runtime . diagram . core . preferences . PreferencesHint ; import org . eclipse . gmf . runtime . diagram . core . providers . IViewProvider ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateDiagramViewOperation ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateEdgeViewOperation ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateNodeViewOperation ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateViewForKindOperation ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateViewOperation ; import org . eclipse . gmf . runtime . diagram . core . util . ViewUtil ; import org . eclipse . gmf . runtime . diagram . ui . preferences . IPreferenceConstants ; import org . eclipse . gmf . runtime . draw2d . ui . figures . FigureUtilities ; import org . eclipse . gmf . runtime . emf . core . util . EMFCoreUtil ; import org . eclipse . gmf . runtime . emf . type . core . IElementType ; import org . eclipse . gmf . runtime . emf . type . core . IHintedType ; import org . eclipse . gmf . runtime . notation . DecorationNode ; import org . eclipse . gmf . runtime . notation . Diagram ; import org . eclipse . gmf . runtime . notation . Edge ; import org . eclipse . gmf . runtime . notation . FontStyle ; import org . eclipse . gmf . runtime . notation . MeasurementUnit ; import org . eclipse . gmf . runtime . notation . Node ; import org . eclipse . gmf . runtime . notation . NotationFactory ; import org . eclipse . gmf . runtime . notation . NotationPackage ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleChildReferenceEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLabelNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLinkMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLinkMappingNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram .", "gt": "edit . parts . SimpleTopNodeEditPart ;", "prediction": "edit . parts . SimpleSubLabelNodeEditPart ;\n", "label": 0}
{"id": 13734, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getListAndViewResult\" } ) @ XmlRootElement ( name = \"GetListAndViewResponse\" ) public class GetListAndViewResponse { @ XmlElement ( name = \"GetListAndViewResult\" ) protected GetListAndViewResponse . GetListAndViewResult getListAndViewResult ; public GetListAndViewResponse . GetListAndViewResult getGetListAndViewResult ( ) { return getListAndViewResult ; } public void setGetListAndViewResult ( GetListAndViewResponse . GetListAndViewResult value ) { this . getListAndViewResult = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name", "gt": "= \"\" , propOrder =", "prediction": "= \"\" , propOrder =\n", "label": 1}
{"id": 4651, "input": "<s> package gui ; import javax . swing . JPanel ; import java . awt . GridLayout ; import javax . swing . JLabel ; import java . awt . Font ; import java . util . ArrayList ; import javax . swing . SwingConstants ; import model . Book ; import controllers . Controller ; public class CheckoutVerifyCartContentsPanel extends JPanel { private static final long serialVersionUID = 1995910743393899639L ; public CheckoutVerifyCartContentsPanel ( ) { setLayout ( new GridLayout ( 0 , 3 ) ) ; JLabel lblNewLabel = new JLabel ( \"Title\" ) ; lblNewLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel . setFont ( new Font ( \"Times New Roman\" , Font . BOLD , 14 ) ) ; add ( lblNewLabel ) ; JLabel lblNewLabel_1 = new JLabel ( \"Author\" ) ; lblNewLabel_1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel_1 . setFont ( new Font ( \"Times New Roman\" , Font . PLAIN , 14 ) ) ; add ( lblNewLabel_1 ) ; JLabel lblNewLabel_2 = new JLabel ( \"Price ($)\" ) ; lblNewLabel_2 . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel_2 . setFont ( new Font ( \"Times New Roman\" , Font . PLAIN , 14 ) ) ; add ( lblNewLabel_2 ) ; ArrayList <", "gt": "Book > books = null ;", "prediction": "String > list = new ArrayList < String > ( ) ;\n", "label": 0}
{"id": 13741, "input": "<s> package com . cloudera . sqoop . cli ; public class SqoopParser extends org", "gt": ". apache . sqoop . cli . SqoopParser", "prediction": ". apache . sqoop . cli . ParseException\n", "label": 1}
{"id": 5500, "input": "<s> package gui ; import java . awt . BorderLayout ; import java . awt . GridLayout ; import java . util . ArrayList ; import javax . swing . Box ; import javax . swing . BoxLayout ; import javax . swing . JLabel ; import model . Book ; public class SearchResultsPanel extends StyledPanel { private static final long serialVersionUID = - 7862774713466486186L ; public SearchResultsPanel ( ) { this . setLayout ( new GridLayout ( 0 , 1 ) ) ; } public SearchResultsPanel ( final ArrayList < Book > books ) { if ( books . size ( ) > 0 ) { this . setLayout ( new GridLayout ( 0 , 1 ) ) ; Book currentBookToAdd ; for ( int i = 0 ; i < books . size ( ) ; i ++ ) { currentBookToAdd = books . get ( i ) ; this . add ( new CatalogueBookPanel ( currentBookToAdd ) ) ; } } else { this . setLayout ( new", "gt": "BoxLayout ( this , BoxLayout . PAGE_AXIS ) ) ;", "prediction": "GridLayout ( 0 , 1 ) ) ;\n", "label": 0}
{"id": 13743, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . * ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . TermFreqVector ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . English ; import java . io . IOException ; public class TestMultiThreadTermVectors extends LuceneTestCase { private RAMDirectory directory = new RAMDirectory ( ) ; public int numDocs = 100 ; public int numThreads = 3 ; public TestMultiThreadTermVectors ( String s ) { super ( s ) ; } public void setUp ( ) throws Exception { super . setUp ( ) ; IndexWriter writer = new IndexWriter ( directory , new SimpleAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; for ( int i = 0 ; i < numDocs ; i ++ ) { Document doc = new Document ( ) ; Fieldable fld = new Field ( \"field\" , English . intToEnglish ( i ) , Field . Store . YES , Field . Index . NOT_ANALYZED , Field . TermVector . YES ) ; doc . add ( fld ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; } public void test ( ) throws Exception { IndexReader reader = null ; try { reader = IndexReader . open ( directory ) ; for ( int i = 1 ; i <= numThreads ; i ++ ) testTermPositionVectors ( reader , i ) ; } catch ( IOException ioe ) { fail ( ioe . getMessage ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } } } public void testTermPositionVectors ( final IndexReader reader , int threadCount ) throws Exception { MultiThreadTermVectorsReader [ ] mtr = new MultiThreadTermVectorsReader [ threadCount ] ; for ( int i = 0 ; i < threadCount ; i ++ ) { mtr [ i ] = new MultiThreadTermVectorsReader ( ) ; mtr [ i ] . init ( reader ) ; } int threadsAlive = mtr . length ; while ( threadsAlive > 0 ) { Thread . sleep ( 10 ) ; threadsAlive = mtr . length ; for ( int i = 0 ; i < mtr . length ; i ++ ) { if ( mtr [ i ] . isAlive ( ) == true ) { break ; } threadsAlive -- ; } } long totalTime = 0L ; for ( int i = 0 ; i < mtr . length ; i ++ ) { totalTime += mtr [ i ] . timeElapsed ; mtr [ i ] = null ; } } } class MultiThreadTermVectorsReader implements Runnable { private IndexReader reader = null ; private Thread t = null ; private final int runsToDo = 100 ; long timeElapsed = 0 ; public void init ( IndexReader reader ) { this . reader = reader ; timeElapsed = 0 ; t = new Thread ( this ) ; t . start ( ) ; } public boolean isAlive ( ) { if ( t == null ) return false ; return t . isAlive ( ) ; } public void run ( ) { try { for ( int i = 0 ; i < runsToDo ; i ++ ) testTermVectors ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return ; } private void testTermVectors ( ) throws Exception { int numDocs = reader . numDocs ( ) ; long start = 0L ; for ( int docId = 0 ; docId < numDocs ; docId ++ ) { start = System . currentTimeMillis ( ) ; TermFreqVector [ ] vectors = reader . getTermFreqVectors ( docId ) ; timeElapsed += System . currentTimeMillis ( ) - start ; verifyVectors ( vectors , docId ) ; start = System . currentTimeMillis ( ) ; TermFreqVector vector = reader . getTermFreqVector ( docId , \"field\" ) ; timeElapsed += System . currentTimeMillis ( ) - start ; vectors = new TermFreqVector [ 1 ] ; vectors [ 0 ] = vector ; verifyVectors ( vectors , docId ) ; } } private void verifyVectors ( TermFreqVector [ ] vectors , int num ) { StringBuffer temp = new StringBuffer ( ) ; String [ ] terms = null ; for ( int i = 0 ; i < vectors . length ; i ++ ) { terms = vectors [", "gt": "i ] . getTerms ( ) ;", "prediction": "i ] . terms ;\n", "label": 1}
{"id": 5766, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org .", "gt": "jjflyboy . tjpeditor . project . TaskAttribute ;", "prediction": "jjflybreak . utils . EcoreUtil ;\n", "label": 0}
{"id": 13749, "input": "<s> package org . eclipse . jface . tests . performance ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . widgets . Shell ; public abstract class TreeTest extends ViewerTest { TreeViewer viewer ; public TreeTest ( String testName , int tagging ) { super ( testName , tagging ) ; } public TreeTest ( String testName ) { super ( testName ) ; } protected StructuredViewer createViewer ( Shell shell ) { viewer = createTreeViewer ( shell ) ; viewer . setContentProvider ( getContentProvider ( ) ) ; viewer . setLabelProvider ( getLabelProvider ( ) ) ; viewer . setSorter ( new ViewerSorter ( ) ) ; viewer . setUseHashlookup ( true ) ; return viewer ; } protected TreeViewer createTreeViewer ( Shell shell ) { return new TreeViewer ( shell ) ; } protected Object getInitialInput ( ) { return new TestTreeElement ( 0 , null ) ; } private IContentProvider getContentProvider ( ) { return new ITreeContentProvider ( ) { public Object [ ] getChildren ( Object parentElement ) { TestTreeElement element = ( TestTreeElement ) parentElement ;", "gt": "return element . children ;", "prediction": "return new Object [ ]\n", "label": 1}
{"id": 693, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ; public interface Alert extends EObject { AlertLevel getLevel ( ) ; void setLevel", "gt": "( AlertLevel value ) ;", "prediction": "( AlertLevel level ) ;\n", "label": 0}
{"id": 13757, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . io . IOException ; public class SingleDocSource extends ContentSource { private int docID = 0 ; static final String DOC_TEXT = \"Well, this is just some plain text we use for creating the \" + \"test documents. It used to be a text from an online collection \" + \"devoted to first aid, but if there was there an (online) lawyers \" + \"first aid collection with legal advices, \\\"it\\\" might have quite \" + \"probably advised one not to include \\\"it\\\"'s text or the text of \" + \"any other online collection in one's code, unless one has money \" + \"that one don't need and one is happy to donate for lawyers \" + \"charity. Anyhow at some point, rechecking the usage of this text, \" + \"it became uncertain that this text is free to use, because \" + \"the web site in the disclaimer of he eBook containing that text \" + \"was not responding anymore, and at the same time, in projGut, \" + \"searching for first aid no longer found that eBook as well. \" + \"So here we are, with a perhaps much less interesting \" + \"text for the test, but oh much much safer. \" ; private synchronized int newdocid ( ) throws NoMoreDataException { if ( docID > 0 && ! forever ) { throw new NoMoreDataException ( ) ; } return docID ++ ; } public", "gt": "void close ( ) throws IOException", "prediction": "void setDocID ( int docID )\n", "label": 1}
{"id": 6387, "input": "<s> package org . gk . engine . client . event ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBusIfc ; import jfreecode . gwt . event . client . bus . JsonConvert ; import org . gk . engine . client . IEngine ; import org . gk . engine . client . build . XComponent ; import org . gk . engine . client . build . js . XJavaScript ; import org . gk . engine . client . event . attrib . IAttribute ; import org . gk . engine . client . exception . GKEngineException ; import org . gk . engine . client . exception . InvalidValueException ; import org . gk . engine . client . i18n . EngineMessages ; import org . gk . engine . client . utils . ComponentUtils ; import org . gk . ui . client . com . form . gkMap ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . Info ; import com . google . gwt . core . client . JavaScriptObject ; import com . google . gwt . json . client . JSONArray ; import com . google . gwt . json . client . JSONObject ; public abstract class EventHandler implements IHandler { private final static String JAVASCRIPT = \"_gk_js_\" ; protected EventBusIfc bus = IEngine . bus ; private static Map < String , IHandler > handlerGroup = EventFactory . createHandlerGroup ( ) ; private static Map < String , IAttribute > attributeGroup = EventFactory . createAttributeGroup ( ) ; private static Map < String , EventType > eventTypeGroup = EventFactory . createEventTypeGroup ( ) ; private static IHandler getHandler ( String cmd ) { if ( ! handlerGroup . containsKey ( cmd ) ) { throw new GKEngineException ( EngineMessages . msg . error_handlerNotFound ( cmd ) ) ; } return handlerGroup . get ( cmd ) ; } private static IAttribute getAttribute ( String cmd ) { String key = cmd . toLowerCase ( ) ; if ( ! attributeGroup . containsKey ( key ) ) { Info . display ( EngineMessages . msg . warning ( ) , EngineMessages . msg . error_attributeNotImplement ( cmd ) ) ; } return attributeGroup . get ( key ) ; } public static EventType getEventType ( String eventType ) { String key = eventType . toLowerCase ( ) ; if ( ! eventTypeGroup . containsKey ( key ) ) { Info . display ( EngineMessages . msg . warning ( ) , EngineMessages . msg . error_eventTypeNotSupport ( eventType ) ) ; } return eventTypeGroup . get ( key ) ; } public static void doProcess ( String xComId , EventData ed , XComponent xCom , BaseEvent be ) { IHandler handler = EventHandler . getHandler ( ed . getCmd ( ) ) ; handler . process ( xComId , ed . getSources ( ) , ed . getTargets ( ) , xCom , be ) ; } public static Object getAttributeValue ( String id ) { Object value = null ; String [ ] dot = id . split ( IEventConstants . SPLIT_DOT ) ; Component com = ComponentUtils . findComponent ( dot [ 0 ] ) ; if ( com != null ) { if ( dot . length == 2 ) { value = getAttributeValue (", "gt": "com , dot [ 1 ] ) ;", "prediction": "dot [ 1 ] ) ;\n", "label": 0}
{"id": 13759, "input": "<s> package org . eclipse . swt . widgets ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; public class Monitor_Test extends TestCase { private Display display ; public void testBounds ( ) { Object adapter = display . getAdapter ( IDisplayAdapter . class ) ; IDisplayAdapter displayAdapter = ( IDisplayAdapter ) adapter ; Rectangle expectedBounds = new Rectangle ( 10 , 20 , 30 , 40 ) ; displayAdapter . setBounds ( expectedBounds ) ; Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; assertNotNull ( primaryMonitor ) ; Rectangle monitorBounds = primaryMonitor . getBounds ( ) ; assertNotNull ( monitorBounds ) ; assertEquals ( new Rectangle ( 10 , 20 , 30 , 40 ) , monitorBounds ) ; displayAdapter . setBounds ( new Rectangle ( 100 , 200 , 300 , 400 ) ) ; Rectangle newMonitorBounds = primaryMonitor . getBounds ( ) ; assertEquals ( new Rectangle ( 100 , 200 , 300 , 400 ) , newMonitorBounds ) ; } public void testClientArea ( ) { Object adapter = display . getAdapter ( IDisplayAdapter . class ) ; IDisplayAdapter displayAdapter = ( IDisplayAdapter ) adapter ; Rectangle expectedBounds = new Rectangle ( 10 , 20 , 30 , 40 ) ; displayAdapter . setBounds ( expectedBounds ) ; Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; assertNotNull ( primaryMonitor ) ; Rectangle monitorClientArea = primaryMonitor . getClientArea ( ) ; assertNotNull ( monitorClientArea ) ; assertEquals ( new Rectangle ( 10 , 20 , 30 , 40 ) , monitorClientArea ) ; displayAdapter . setBounds ( new Rectangle ( 100 , 200 , 300 , 400 ) ) ; Rectangle newMonitorClientArea = primaryMonitor . getClientArea ( ) ; assertEquals ( new Rectangle ( 100 , 200 , 300 , 400 ) , newMonitorClientArea ) ; } public void testEquals ( ) { Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; Monitor [ ] monitors = display . getMonitors ( ) ; assertEquals ( primaryMonitor , monitors [ 0 ] ) ; } public void testIsSerializable ( ) throws Exception { Monitor monitor = display . getPrimaryMonitor ( ) ; Rectangle bounds = monitor . getBounds ( ) ; Monitor deserializedMonitor = Fixture . serializeAndDeserialize ( monitor ) ; getDisplayAdapter ( deserializedMonitor . display ) . attachThread ( ) ; assertEquals ( bounds , deserializedMonitor . getBounds ( ) ) ; } protected void setUp ( ) throws Exception { Fixture . setUp ( ) ;", "gt": "display = new Display ( ) ;", "prediction": "display = new Display ( ) ;\n", "label": 1}
{"id": 5054, "input": "<s> class T4718142 { static class E extends Exception { } static void thr ( ) throws E { throw new E ( ) ; } public static void main ( String [ ] args ) { int count = 0 ; final int i ; while ( true ) { try { i = count ++ ; System . out . println", "gt": "( \"assigned \" + i ) ;", "prediction": "( count ) ;\n", "label": 0}
{"id": 13760, "input": "<s> package org . restlet . test . routing ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . routing . Filter ; import org . restlet . test . AbstractFilterTestCase ; import org . restlet . test . MockFilter ; import org . restlet . test . MockRestlet ; public class FilterTestCase extends AbstractFilterTestCase { @ Override protected Filter getFilter ( ) { return new MockFilter ( null ) ; } @ Override protected Request getRequest ( ) { return new Request ( ) ; } @ Override protected Response getResponse ( Request request ) { return new Response ( request ) ; } @ Override protected Restlet getRestlet ( ) { return new MockRestlet ( null ) ; }", "gt": "@ Override protected Class < ? > getRestletClass ( )", "prediction": "}\n", "label": 1}
{"id": 8241, "input": "<s> package org . apache . felix . resolver . impl ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . SortedSet ; import java . util . StringTokenizer ; import org . apache . felix . resolver . FelixCapability ; import org . apache . felix . resolver . FelixEnvironment ; import org . apache . felix . resolver . FelixResolver ; import org . apache . felix . resolver . Logger ; import org . osgi . framework . Constants ; import org . osgi . framework . resource . Capability ; import org . osgi . framework . resource . Requirement ; import org . osgi . framework . resource . Resource ; import org . osgi . framework . resource . ResourceConstants ; import org . osgi . framework . resource . Wire ; import org . osgi . service . resolver . Environment ; import org . osgi . service . resolver . ResolutionException ; import org . osgi . framework . resource . Wiring ; public class ResolverImpl implements FelixResolver { private final Logger m_logger ; private final List < Candidates > m_usesPermutations = new ArrayList < Candidates > ( ) ; private final List < Candidates > m_importPermutations = new ArrayList < Candidates > ( ) ; public ResolverImpl ( Logger logger ) { m_logger = ( logger != null ) ? logger : new Logger ( ) { public void log ( int level , String msg ) { } public void log ( int level , String msg , Throwable throwable ) { } } ; } public Map < Resource , List < Wire > > resolve ( FelixEnvironment env , Collection < ? extends Resource > mandatoryRevisions , Collection < ? extends Resource > optionalRevisions ) { return resolve ( env , mandatoryRevisions , optionalRevisions , Collections . EMPTY_SET ) ; } public Map < Resource , List < Wire > > resolve ( FelixEnvironment env , Collection < ? extends Resource > mandatoryRevisions , Collection < ? extends Resource > optionalRevisions , Collection < ? extends Resource > ondemandFragments ) { Map < Resource , List < Wire > > wireMap = new HashMap < Resource , List < Wire > > ( ) ; Map < Resource , Packages > revisionPkgMap = new HashMap < Resource , Packages > ( ) ; boolean retry ; do { retry = false ; try { Candidates allCandidates = new Candidates ( ) ; for ( Iterator < ? extends Resource > it = mandatoryRevisions . iterator ( ) ; it . hasNext ( ) ; ) { Resource br = it . next ( ) ; if ( Util . isFragment ( br ) || ! env . getWirings ( ) . containsKey ( br ) ) { allCandidates . populate ( env , br , Candidates . MANDATORY ) ; } else { it . remove ( ) ; } } for ( Resource br : optionalRevisions ) { boolean isFragment =", "gt": "Util . isFragment ( br ) ;", "prediction": "br . isFragment ( ) ;\n", "label": 0}
{"id": 13763, "input": "<s> package org . fuzzydb . util ; public interface ScoreMapper {", "gt": "float getScore ( float scoreFactor ) ;", "prediction": "}\n", "label": 1}
{"id": 2448, "input": "<s> package org . dawnsci . rcp . functions . classes ; import org . dawnsci . rcp . functions . ITransferFunctionArrayProvider ; public abstract class AbstractTransferFunction implements ITransferFunctionArrayProvider { public abstract double getPoint ( double value ) ; @ Override public int [ ] getArray ( ) { int [ ] result = new int [ 256 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( int ) ( getPoint ( ( double ) i / 256", "gt": ") * 255 ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 13766, "input": "<s> package org . eclipse . ui . operations ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . operations . IAdvancedUndoableOperation2 ; import org . eclipse . core . commands . operations . IOperationHistory ; import org . eclipse . core . commands . operations . IOperationHistoryListener ; import org . eclipse . core . commands . operations . IUndoContext ; import org . eclipse . core . commands . operations . IUndoableOperation ; import org . eclipse . core . commands . operations . OperationHistoryEvent ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . internal . operations . TimeTriggeredProgressMonitorDialog ; import org . eclipse . ui . internal . util . Util ; import org . eclipse . ui . part . MultiPageEditorSite ; import org . eclipse . ui . statushandlers . StatusManager ; public abstract class OperationHistoryActionHandler extends Action implements ActionFactory . IWorkbenchAction , IAdaptable { private static final int MAX_LABEL_LENGTH = 32 ; private class PartListener implements IPartListener { public void partActivated ( IWorkbenchPart part ) { } public void partBroughtToTop ( IWorkbenchPart part ) { } public void partClosed ( IWorkbenchPart part ) { if ( site != null && part . equals ( site . getPart ( ) ) ) { dispose ( ) ; } else if ( ( site instanceof MultiPageEditorSite ) && ( part . equals ( ( ( MultiPageEditorSite ) site ) . getMultiPageEditor ( ) ) ) ) { dispose ( ) ; } } public void partDeactivated ( IWorkbenchPart part ) { } public void partOpened ( IWorkbenchPart part ) { } } private class HistoryListener implements IOperationHistoryListener { public void historyNotification ( final OperationHistoryEvent event ) { IWorkbenchWindow workbenchWindow = getWorkbenchWindow ( ) ; if ( workbenchWindow == null ) return ; Display display = workbenchWindow . getWorkbench ( ) . getDisplay ( ) ; if ( display == null ) return ; switch ( event . getEventType ( ) ) { case OperationHistoryEvent . OPERATION_ADDED : case OperationHistoryEvent . OPERATION_REMOVED : case OperationHistoryEvent . UNDONE : case OperationHistoryEvent . REDONE : if ( event . getOperation ( ) . hasContext ( undoContext ) ) { display . asyncExec ( new Runnable ( ) { public void run ( ) { update ( ) ; } } ) ; } break ; case OperationHistoryEvent . OPERATION_NOT_OK : if ( event . getOperation ( ) . hasContext ( undoContext ) ) { display . asyncExec ( new Runnable ( ) { public void run ( ) { if ( pruning ) { IStatus status = event . getStatus ( ) ; if ( status == null || status . getSeverity ( ) != IStatus . CANCEL ) { flush ( ) ; } update ( ) ; } else { update ( ) ; } } } ) ; } break ; case OperationHistoryEvent . OPERATION_CHANGED : if ( event . getOperation ( ) == getOperation ( ) ) { display . asyncExec ( new Runnable ( ) { public void run ( ) { update ( ) ; } } ) ; } break ; } } } private boolean pruning = false ; private IPartListener partListener = new PartListener ( ) ; private IOperationHistoryListener historyListener = new HistoryListener ( ) ; private TimeTriggeredProgressMonitorDialog progressDialog ; private IUndoContext undoContext = null ; IWorkbenchPartSite site ; OperationHistoryActionHandler ( IWorkbenchPartSite site , IUndoContext context ) { super ( \"\" ) ; this . site = site ; undoContext = context ; site . getPage ( ) . addPartListener ( partListener ) ; getHistory ( ) . addOperationHistoryListener ( historyListener ) ; update ( ) ; } public void dispose ( ) { IOperationHistory history = getHistory ( ) ; if ( history != null ) { history . removeOperationHistoryListener ( historyListener ) ; } if ( isInvalid ( ) ) { return ; } site . getPage ( ) . removePartListener ( partListener ) ; site = null ; progressDialog = null ; undoContext = null ; } abstract void flush ( ) ; abstract String getCommandString ( ) ; abstract String getTooltipString ( ) ; abstract String getSimpleCommandString ( ) ; abstract String getSimpleTooltipString ( ) ; IOperationHistory getHistory ( ) { if ( PlatformUI . getWorkbench ( ) == null ) { return null ; } return PlatformUI . getWorkbench ( ) . getOperationSupport ( ) . getOperationHistory ( ) ; } abstract IUndoableOperation getOperation ( ) ; public final void run ( ) { if ( isInvalid ( ) ) { return ; } Shell parent = getWorkbenchWindow ( ) . getShell ( ) ; progressDialog = new TimeTriggeredProgressMonitorDialog ( parent , getWorkbenchWindow ( ) . getWorkbench ( ) . getProgressService ( ) . getLongOperationTime ( ) ) ; IRunnableWithProgress runnable = new IRunnableWithProgress ( ) { public void run ( IProgressMonitor pm ) throws InvocationTargetException { try { runCommand ( pm ) ; } catch ( ExecutionException e ) { if ( pruning ) { flush ( ) ; } throw new InvocationTargetException ( e ) ; } } } ; try { boolean runInBackground = false ; if ( getOperation ( ) instanceof IAdvancedUndoableOperation2 ) { runInBackground = ( ( IAdvancedUndoableOperation2 ) getOperation ( ) ) . runInBackground ( ) ; } progressDialog . run ( runInBackground , true , runnable ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t == null ) { reportException ( e ) ; } else {", "gt": "reportException ( t ) ;", "prediction": "reportException ( t ) ;\n", "label": 1}
{"id": 3777, "input": "<s> package org . ofbiz . entity . transaction ; import java . sql . Connection ; import java . sql . SQLException ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity", "gt": ". datasource . GenericHelperInfo ;", "prediction": ". Entity ;\n", "label": 0}
{"id": 13771, "input": "<s> package org . nuxeo . ecm . platform . picture . convert ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . blobholder . BlobHolder ; import org . nuxeo . ecm . core . convert . api . ConversionException ; import org . nuxeo . ecm . core . convert . cache . SimpleCachableBlobHolder ; import org . nuxeo . ecm . core . convert . extension . Converter ; import org . nuxeo . ecm . core . convert . extension . ConverterDescriptor ; import org . nuxeo . ecm . platform . picture . api . ImagingConvertConstants ; import org . nuxeo . ecm . platform . picture . api . ImagingService ; import org . nuxeo . runtime . api . Framework ; public class RotationPictureConverter implements Converter { private static final Log log = LogFactory . getLog ( RotationPictureConverter . class ) ; @ Override public BlobHolder convert ( BlobHolder blobHolder , Map < String , Serializable > parameters ) throws ConversionException { try { ImagingService service = Framework . getService ( ImagingService . class ) ; List < Blob > results = new ArrayList < Blob > ( ) ; List < Blob > sources = blobHolder . getBlobs ( ) ; int angle = ( Integer ) parameters . get ( ImagingConvertConstants . OPTION_ROTATE_ANGLE ) ; for ( Blob source : sources ) { if ( source != null ) { Blob result = service . rotate ( source , angle ) ; if ( result != null ) { results . add ( result ) ; } } } return new SimpleCachableBlobHolder ( results ) ; } catch ( Exception e ) { throw", "gt": "new ConversionException ( \"Rotation conversion has failed\" , e ) ;", "prediction": "new ConversionException ( e ) ;\n", "label": 1}
{"id": 9857, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface PurgeReport extends ReportAttribute {", "gt": "PurgeReportAttribute getListAttribute ( ) ;", "prediction": "void purge ( ) ;\n", "label": 0}
{"id": 13775, "input": "<s> package org . fuzzydb . client ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import org . fuzzydb . core . Settings ; public class WWMDBProtocolHander extends URLStreamHandler { static private WWMDBProtocolHander instance = new WWMDBProtocolHander ( ) ; static public WWMDBProtocolHander getInstance ( ) { return instance ; } private WWMDBProtocolHander ( ) { } @ Override protected URLConnection openConnection ( URL url ) { throw new UnsupportedOperationException ( ) ; } @ Override protected int getDefaultPort ( ) { return Settings . getInstance ( ) . getPrimaryServerPort ( ) ; } static public URL getAsURL", "gt": "( String strUrl ) throws MalformedURLException", "prediction": "( )\n", "label": 1}
{"id": 3256, "input": "<s> public class TestModifier extends JavadocTester { private static final String BUG_ID = \"4210388\" ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-sourcepath\" , SRC_DIR , \"-docletpath\" , SRC_DIR , \"-doclet\" , \"ModifierAbstract\" , SRC_DIR + FS + \"Interface.java\" , SRC_DIR + FS + \"Test.java\" } ; public static void main ( String [ ] args ) { TestModifier tester = new TestModifier ( ) ; if ( run ( tester , ARGS , TEST , NEGATED_TEST ) != 0 ) { throw new Error ( \"Javadoc error occured during execution.\" ) ; } } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return", "gt": "getClass ( ) . getName ( ) ;", "prediction": "BUG_NAME ;\n", "label": 0}
{"id": 13778, "input": "<s> package editor . PassabilityEditor ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Image ; import java . awt . Rectangle ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . MouseEvent ; import java . awt . event . MouseListener ; import java . awt . event . MouseMotionListener ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; import javax . swing . JComponent ; import javax . swing . Scrollable ; import map . TileSet ; public class PassabilityGrid extends JComponent implements ActionListener , MouseListener , MouseMotionListener , Scrollable { TileSet tileSet ; Image dbImage ; int tileSelected ; PassabilityEditor parent ; int x ; int y ; private boolean updating ; char [ ] [ ] passabilitySet ; private Dimension preferredScrollableSize ; BufferedImage pTiles ; public PassabilityGrid ( PassabilityEditor p ) { parent = p ; tileSet = parent . activeTileSet ; x = 0 ; y = 0 ; passabilitySet = tileSet . getPassabilitySet ( ) ; try { pTiles = ImageIO . read ( new File ( \"data/passabilityTiles.png\" ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } dbImage = null ; setVisible ( true ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; } public int getTileSelected ( ) { return tileSelected ; } public void refreshTileSet ( ) { tileSet = parent . activeTileSet ; x = 0 ; y = 0 ; passabilitySet = tileSet . getPassabilitySet ( ) ; dbImage = null ; repaint ( ) ; } @ Override public void mouseClicked ( MouseEvent arg0 ) { if ( ! updating ) return ; if ( passabilitySet [ x ] [ y ] == TileSet . PASSABLE ) passabilitySet [ x ] [ y ] = TileSet . OVERLAY ; else if ( passabilitySet [ x ] [ y ] == TileSet . OVERLAY ) passabilitySet [ x ] [ y ] = TileSet . IMPASSABLE ; else passabilitySet [ x ] [ y ] = TileSet . PASSABLE ; paintTile ( x , y ) ; } @ Override public void mouseEntered ( MouseEvent arg0 ) { updating = true ; repaint ( ) ; } @ Override public void mouseExited ( MouseEvent arg0 ) { updating = false ; x = - 1 ; y = - 1 ; repaint ( ) ; } @ Override public void mousePressed ( MouseEvent arg0 ) { } @ Override public void mouseReleased ( MouseEvent arg0 ) { } public void paintTile ( int x , int y ) { Graphics g = dbImage . getGraphics ( ) ; tileSet . drawEditorTile ( g , x * TileSet . TILE_DIMENSION , y * TileSet . TILE_DIMENSION , x , y ) ; g . setColor ( Color . BLACK ) ; String p = \"\" + passabilitySet [ x ] [ y ] ; int xpos ; int ypos ; if ( pTiles != null ) { xpos = x * TileSet . TILE_DIMENSION ; ypos = y * TileSet . TILE_DIMENSION ; if ( passabilitySet [ x ] [ y ] == TileSet . OVERLAY ) g . drawImage ( pTiles , xpos , ypos , xpos + TileSet . TILE_DIMENSION , ypos + TileSet . TILE_DIMENSION , 0 , 0 , 32 , 32 , null ) ; else if ( passabilitySet [ x ] [ y ] == TileSet . IMPASSABLE ) g . drawImage ( pTiles , xpos , ypos , xpos + TileSet . TILE_DIMENSION , ypos + TileSet . TILE_DIMENSION , 32 , 0 , 64 , 32 , null ) ; } else { xpos = x * TileSet . TILE_DIMENSION + ( TileSet . TILE_DIMENSION / 2 ) ; ypos = y * TileSet . TILE_DIMENSION + ( TileSet . TILE_DIMENSION / 2 ) ; for ( int i = 0 ; i < 9 ; i ++ ) g . drawString ( p , xpos - 1 * ( ( i % 3 ) - 1 ) , ypos - 1 * ( ( i / 3 ) - 1 ) ) ; g . setColor ( Color . WHITE ) ; g . drawString ( p , xpos , ypos ) ; } repaint ( ) ; } @ Override public void paint ( Graphics g ) { if ( g == null ) return ; if ( dbImage == null ) { dbImage = createImage ( getWidth ( ) , getHeight ( ) ) ; Graphics g2 = dbImage . getGraphics ( ) ; g2 . setColor ( Color . GRAY ) ; g2 . fillRect ( 0 , 0 , dbImage . getWidth ( null ) , dbImage . getHeight ( null ) ) ; for ( int x = 0 ; x < tileSet . getWidth ( ) ; x ++ ) for ( int y = 0 ; y < tileSet . getHeight ( ) ; y ++ ) { paintTile ( x , y ) ; } } g . drawImage ( dbImage , 0 , 0 , null ) ; g . setColor ( Color . BLACK ) ; for ( int i = 1 ; i < tileSet . getWidth ( ) ; i ++ ) g . drawLine ( i * TileSet . TILE_DIMENSION , 0 , i * TileSet . TILE_DIMENSION , ( int ) tileSet . getHeight ( ) * TileSet . TILE_DIMENSION ) ; for ( int i = 1 ; i < tileSet . getHeight ( ) ; i ++ ) g . drawLine ( 0 , i * TileSet . TILE_DIMENSION , ( int ) tileSet . getWidth ( ) *", "gt": "TileSet . TILE_DIMENSION , i * TileSet . TILE_DIMENSION ) ;", "prediction": "TileSet . TILE_DIMENSION ) ;\n", "label": 1}
{"id": 784, "input": "<s> package com . quirijngrootbluemink . iptools ; import android . app . Activity ; import android . content . Context ; import android . net . wifi . ScanResult ; import android . net . wifi . WifiInfo ; import android . net . wifi . WifiManager ; import android . os . Bundle ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . TextView ; import android . widget . Toast ; import com . markupartist . android . widget . ActionBar ; public class WifiDetails extends Activity { WifiInfo info ; WifiManager wifi ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . wifi_details ) ; wifi = ( WifiManager ) getSystemService ( Context . WIFI_SERVICE ) ; info = wifi . getConnectionInfo ( ) ; setActionBar ( ) ; ScanResult s = ( ScanResult ) this . getIntent ( ) . getParcelableExtra ( \"Wifi\" ) ; if ( s . SSID . equals ( info . getSSID ( ) ) ) { TextView txtHiddenSSID = ( TextView ) findViewById ( R . id . txtHiddenSSID ) ; TextView txtLinkSpeed = ( TextView ) findViewById ( R . id . txtLinkSpeed ) ; TextView txtRSSI = ( TextView ) findViewById ( R . id . txtRSSI ) ; TextView txtIP = ( TextView ) findViewById ( R . id . txtIP ) ; txtHiddenSSID . setText ( ( info . getHiddenSSID ( ) ) ? getString ( R . string . yes ) : getString ( R . string . no ) ) ; txtLinkSpeed . setText ( info . getLinkSpeed ( ) + getString ( R . string . mbps ) ) ; txtRSSI . setText ( info . getRssi ( ) + getString ( R . string . dbm ) ) ; txtIP . setText ( intToIp ( info . getIpAddress ( ) ) ) ; TextView lblHiddenSSID = ( TextView ) findViewById ( R . id . lblHiddenSSID ) ; TextView lblLinkSpeed = ( TextView ) findViewById ( R . id . lblLinkSpeed ) ; TextView lblRSSI = ( TextView ) findViewById ( R . id . lblRSSI ) ; TextView lblIP = ( TextView ) findViewById ( R . id . lblIP ) ; txtHiddenSSID . setVisibility ( 0 ) ; txtLinkSpeed . setVisibility ( 0 ) ; txtRSSI . setVisibility ( 0 ) ; txtIP . setVisibility ( 0 ) ; lblHiddenSSID . setVisibility ( 0 ) ; lblLinkSpeed . setVisibility ( 0 ) ; lblRSSI . setVisibility ( 0 ) ; lblIP . setVisibility ( 0 ) ; } TextView txtSSID = ( TextView ) findViewById ( R . id . txtSSID ) ; TextView txtBSSID = ( TextView ) findViewById ( R . id . txtBSSID ) ; TextView txtFreq = ( TextView ) findViewById ( R . id . txtFreq ) ; TextView txtStrength = ( TextView ) findViewById ( R . id . txtStrength ) ; TextView txtInfo = ( TextView ) findViewById ( R . id . txtInfo ) ; TextView txtChan = ( TextView ) findViewById ( R . id . txtChan ) ; txtSSID . setText ( s . SSID + \"\" ) ; txtBSSID . setText ( s . BSSID + \"\" ) ; txtFreq . setText ( s . frequency + getString ( R . string . hz ) ) ; txtChan . setText ( calculateChannel ( s . frequency ) + \"\" ) ; txtStrength . setText ( s . level + getString ( R . string . dbm ) ) ; if ( s . capabilities . equals ( \"\" ) ) { txtInfo . setText ( \"Open network\" ) ; } else { txtInfo . setText ( s . capabilities ) ; } } public String intToIp ( int i ) { return ( ( i ) & 0xFF ) + \".\" + ( ( i > > 8 ) & 0xFF ) + \".\" + ( ( i > > 16 ) & 0xFF ) + \".\" + ( i > > 24 & 0xFF ) ; } public void showMe ( String s ) { Toast . makeText ( getApplicationContext ( ) , s , Toast . LENGTH_SHORT ) . show ( ) ; } private void setActionBar ( ) { ActionBar actionBar = ( ActionBar )", "gt": "findViewById ( R . id . actionBar ) ;", "prediction": "getSystemService ( Context . ACTION_BAR ) ;\n", "label": 0}
{"id": 13785, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . Vector ; public class TestModel { Vector fListeners = new Vector ( ) ; int fNumLevels ; int fNumChildren ; public TestModel ( int numLevels , int numChildren ) { fNumLevels = numLevels ; fNumChildren = numChildren ; } public void addListener ( ITestModelListener listener ) { fListeners . addElement ( listener ) ; } public void fireModelChanged ( TestModelChange change ) { for ( int i = 0 ; i < fListeners . size ( ) ; ++ i ) { ITestModelListener listener = (", "gt": "ITestModelListener ) fListeners . get ( i ) ;", "prediction": "ITestModelListener ) fListeners . elementAt ( i ) ;\n", "label": 1}
{"id": 3725, "input": "<s> public class SourcePath { SourcePathA a ; public static void main ( String [ ] args ) throws Throwable { Class b = Class", "gt": ". forName ( \"SourcePathB\" ) ;", "prediction": ". class ;\n", "label": 0}
{"id": 13787, "input": "<s> package org . eclipse . swt . internal . graphics ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . CRC32 ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer . IInstanceCreator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . ImageLoader ; import org . eclipse . swt . graphics . RGB ; public class InternalImageFactory { private final SharedInstanceBuffer < String , InternalImage > cache ; public InternalImageFactory ( ) { cache = new SharedInstanceBuffer < String , InternalImage > ( ) ; } public InternalImage findInternalImage ( final String fileName ) { return cache . get ( fileName , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { return createInternalImage ( fileName ) ; } } ) ; } public InternalImage findInternalImage ( InputStream stream ) { final BufferedInputStream bufferedStream = new BufferedInputStream ( stream ) ; final ImageData imageData = readImageData ( bufferedStream ) ; final String path = createGeneratedImagePath ( imageData ) ; return cache . get ( path , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { return createInternalImage ( path , bufferedStream , imageData ) ; } } ) ; } public InternalImage findInternalImage ( final ImageData imageData ) { final String path = createGeneratedImagePath ( imageData ) ; return cache . get ( path , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { InputStream stream = createInputStream ( imageData ) ; return createInternalImage ( path , stream , imageData ) ; } } ) ; } InternalImage findInternalImage ( String key , final InputStream inputStream ) { return cache . get ( key , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { BufferedInputStream bufferedStream = new BufferedInputStream ( inputStream ) ; ImageData imageData = readImageData ( bufferedStream ) ; String path = createGeneratedImagePath ( imageData ) ; return createInternalImage ( path , bufferedStream , imageData ) ; } } ) ; } static ImageData readImageData ( InputStream stream ) throws SWTException { stream . mark ( Integer . MAX_VALUE ) ; ImageData result = new ImageData ( stream ) ; try { stream . reset ( ) ; } catch ( IOException shouldNotHappen ) { String msg = \"Could not reset input stream after reading image\" ; throw new RuntimeException ( msg , shouldNotHappen ) ; } return result ; } static InputStream createInputStream ( ImageData imageData ) { ImageLoader imageLoader = new ImageLoader ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; imageLoader . data = new ImageData [ ] { imageData } ; imageLoader . save ( outputStream , getOutputFormat ( imageData ) ) ; byte [ ] bytes = outputStream . toByteArray ( ) ; return new ByteArrayInputStream ( bytes ) ; } private static InternalImage createInternalImage ( String fileName ) { InternalImage result ; try { FileInputStream stream = new FileInputStream ( fileName ) ; try { result = createInternalImage ( stream ) ; } finally { stream . close ( ) ; } } catch ( IOException ioe ) { throw new SWTException ( SWT . ERROR_IO , ioe . getMessage ( ) ) ; } return result ; } private static InternalImage createInternalImage ( InputStream stream ) { InputStream bufferedStream = new BufferedInputStream ( stream ) ; ImageData imageData = readImageData ( bufferedStream ) ; String path = createGeneratedImagePath ( imageData ) ; return createInternalImage ( path , bufferedStream , imageData ) ; } private static InternalImage createInternalImage ( String path , InputStream stream , ImageData imageData ) { RWT . getResourceManager ( ) . register ( path , stream ) ; return new InternalImage ( path , imageData . width , imageData . height ) ; } private static int getOutputFormat ( ImageData imageData ) { int result = imageData . type ; if ( imageData . type == SWT . IMAGE_UNDEFINED ) { result = SWT . IMAGE_PNG ; } return result ; } private static String createGeneratedImagePath ( ImageData data ) { String hash =", "gt": "getHash ( data ) ;", "prediction": "imageData . hash ;\n", "label": 1}
{"id": 4586, "input": "<s> package ar . com . fdvs . dj . test ; import java . sql . Connection ; import net . sf . jasperreports . engine . xml . JRXmlWriter ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . DynamicJasperHelper ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; public class QueryReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"Id\" , \"id\" , Integer . class . getName ( ) , 30 ) . addColumn ( \"First Name\" , \"firstname\" , String . class . getName ( ) , 30 ) . addColumn ( \"Last Name\" , \"lastname\" , String . class . getName ( ) , 50 ) . addColumn ( \"Street\" , \"street\" , String . class . getName ( ) , 50 ) . addColumn ( \"City\" , \"city\" , String . class . getName ( ) , 50 ) . setTitle ( \"Customers\" ) . setQuery ( \"select * from customer where firstname like $P{start}\" , DJConstants . QUERY_LANGUAGE_SQL ) . setTemplateFile ( \"templates/TemplateReportTest.jrxml\" ) . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; params . put ( \"start\" , \"A%\" ) ; return dr ; } public static void main", "gt": "( String [ ] args ) throws Exception", "prediction": "( String [ ] args ) throws Exception\n", "label": 0}
{"id": 13791, "input": "<s> package org . modelgoon . core ; import java . util . Observable ; import org . eclipse . draw2d . geometry . Point ; public class ModelElement extends Observable { Point location = new Point ( 0 , 0 ) ; public final void setLocation ( final int x , final int y ) { this . location . x = x ; this . location . y = y ; propertyChanged ( ) ; } public final void setLocation ( final Point newLocation ) { this . location . x = newLocation . x ; this . location . y = newLocation . y ; propertyChanged ( ) ; }", "gt": "public final Point getLocation ( )", "prediction": "}\n", "label": 1}
{"id": 5777, "input": "<s> package com . asakusafw . example . direct . seqfile . jobflow . format ; import java . io . IOException ; import java . util . Calendar ; import org . apache . hadoop . io . Text ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . ItemInfo ; import com . asakusafw . example . direct . seqfile . writable . ItemInfoWritable ; import com . asakusafw . runtime . directio . hadoop . SequenceFileFormat ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateOption ; import com . asakusafw . runtime . value . DateUtil ; public class ItemInfoSeqFileFormat extends SequenceFileFormat < Text , ItemInfoWritable , ItemInfo > { @ Override public Class < ItemInfo > getSupportedType ( ) { return ItemInfo . class ; } @ Override protected Text createKeyObject ( ) { return new Text ( ) ; } @ Override protected ItemInfoWritable createValueObject ( ) { return new ItemInfoWritable ( ) ; } @ Override protected void copyToModel ( Text key , ItemInfoWritable value , ItemInfo model ) throws IOException { model . setItemCode ( key ) ; model . setItemNameAsString ( value . getItemName ( ) ) ; model . setDepartmentCodeAsString ( value . getDepartmentCode ( ) ) ; model . setDepartmentNameAsString ( value . getDepartmentName ( ) ) ; model . setCategoryCodeAsString ( value . getCategoryCode ( ) ) ; model . setCategoryNameAsString ( value . getCategoryName ( ) ) ; model . setUnitSellingPrice ( value . getUnitSellingPrice ( ) ) ; model . setRegisteredDate ( toAsakusaDate ( value . getRegisteredDate ( ) ) ) ; model . setBeginDate ( toAsakusaDate ( value . getBeginDate ( ) ) ) ; model . setEndDate ( toAsakusaDate ( value . getEndDate ( ) ) ) ; } Date toAsakusaDate ( java . util . Date from ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( from ) ; return new Date ( DateUtil . getDayFromCalendar ( calendar ) ) ; } @ Override protected void copyFromModel ( ItemInfo model , Text key , ItemInfoWritable value ) throws IOException { key . set ( model . getItemCode ( ) ) ; value . setItemName ( model . getItemNameAsString ( ) ) ; value . setDepartmentCode ( model . getDepartmentCodeOption ( ) . or ( \"\" ) ) ; value . setDepartmentName ( model . getDepartmentNameOption ( ) . or ( \"\" ) ) ; value . setCategoryCode ( model . getCategoryCodeOption ( ) . or ( \"\" ) ) ; value . setCategoryName ( model . getCategoryNameOption ( ) . or ( \"\" ) ) ; value . setUnitSellingPrice ( model . getUnitSellingPriceOption ( ) . or ( 0 ) ) ; value . setRegisteredDate ( toUtilDate ( model . getRegisteredDateOption ( ) ) ) ; value . setBeginDate ( toUtilDate ( model . getBeginDateOption ( ) ) ) ; value . setEndDate ( toUtilDate ( model . getEndDateOption ( ) ) ) ; }", "gt": "java . util . Date toUtilDate ( DateOption from )", "prediction": "}\n", "label": 0}
{"id": 13792, "input": "<s> package org . apache . lucene . spatial . geometry ; public class FixedLatLng extends LatLng { public static final double SCALE_FACTOR = 1000000 ; public static final int SCALE_FACTOR_INT = 1000000 ; private int lat , lng ; private boolean normalized ; public FixedLatLng ( int lat , int lng ) { setLat ( lat ) ; setLng ( lng ) ; } public FixedLatLng ( LatLng ll ) { this . lat = ll . getFixedLat ( ) ; this . lng = ll . getFixedLng ( ) ; } protected void setLat ( int lat ) { if ( lat > 90 * SCALE_FACTOR || lat < - 90 * SCALE_FACTOR ) { throw new IllegalArgumentException ( \"Illegal lattitude\" ) ; } this . lat = lat ; } protected void setLng ( int lng ) { this . lng = lng ; } public static double fixedToDouble ( int fixed ) { return ( fixed ) / SCALE_FACTOR ; } public static int doubleToFixed ( double d ) { return ( int ) ( d * SCALE_FACTOR ) ; } @ Override public LatLng copy ( ) { return new FixedLatLng ( this ) ; } @ Override public int getFixedLat ( ) { return lat ; } @ Override public int getFixedLng ( ) { return lng ; } @ Override public double getLat ( ) { return fixedToDouble ( lat ) ; } @ Override public double getLng ( ) { return fixedToDouble ( lng ) ; } @ Override public boolean isFixedPoint ( ) { return true ; } @ Override public FixedLatLng toFixed ( ) { return this ; } @ Override public FloatLatLng toFloat ( ) { return new FloatLatLng ( this ) ; } @ Override public boolean isNormalized ( ) { return normalized || ( ( lng >= - 180 * SCALE_FACTOR_INT ) && ( lng <= 180 * SCALE_FACTOR_INT ) ) ; } @ Override public LatLng normalize ( ) { if ( isNormalized ( ) ) return this ; int delta = 0 ; if ( lng < 0 ) delta = 360 * SCALE_FACTOR_INT ; if ( lng >= 0 ) delta = - 360 * SCALE_FACTOR_INT ; int newLng = lng ; while ( newLng <= - 180 * SCALE_FACTOR_INT || newLng >= 180 * SCALE_FACTOR_INT ) { newLng += delta ; } FixedLatLng ret", "gt": "= new FixedLatLng ( lat , newLng ) ;", "prediction": "= new FixedLatLng ( newLng ) ;\n", "label": 1}
{"id": 7836, "input": "<s> package pkg1 ; public @ interface A { String value ( ) default \"sigh\" ; int i ( ) default 1 + 1 ; double d ( ) default 3.14 ; boolean b ( ) default true ; Class c ( ) default Boolean . class ; Class < ? extends Number > w ( ) default Long . class ; java . lang . annotation . ElementType e ( ) default java . lang . annotation . ElementType . TYPE ; A a ( ) default @ A (", "gt": "d = 2.718 ) ;", "prediction": "1 ) ;\n", "label": 0}
{"id": 13793, "input": "<s> package org . eclipse . ui . tests . zoom ; import org . eclipse . ui . IFolderLayout ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveFactory ; public class ZoomPerspectiveFactory implements IPerspectiveFactory { public static final String PERSP_ID = \"org.eclipse.ui.tests.zoom.ZoomPerspectiveFactory\" ; public static final String STACK1_VIEW1 = IPageLayout . ID_OUTLINE ; public static final String STACK1_VIEW2 = IPageLayout . ID_PROBLEM_VIEW ; public static final String STACK1_PLACEHOLDER1 = IPageLayout . ID_PROP_SHEET ; public static final String STACK1_VIEW3 = IPageLayout . ID_TASK_LIST ; public static final String UNSTACKED_VIEW1 = IPageLayout . ID_RES_NAV ; public static final String FASTVIEW1 = IPageLayout . ID_BOOKMARKS ; public void createInitialLayout ( IPageLayout layout ) { String folderId = \"org.eclipse.ui.test.zoom.mystack\" ; IFolderLayout folder = layout . createFolder ( folderId , IPageLayout . LEFT , 0.5f , IPageLayout . ID_EDITOR_AREA ) ; folder . addView ( STACK1_VIEW1 ) ; folder . addView ( STACK1_VIEW2 ) ; folder . addPlaceholder ( STACK1_PLACEHOLDER1 ) ; folder . addView ( STACK1_VIEW3 ) ; layout . addView ( UNSTACKED_VIEW1 , IPageLayout", "gt": ". TOP , 0.5f , IPageLayout . ID_EDITOR_AREA ) ;", "prediction": ". ID_RES_NAV ) ;\n", "label": 1}
{"id": 971, "input": "<s> package org . ofbiz . entity . jdbc ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; public abstract class AbstractCursorHandler implements InvocationHandler { protected String cursorName ; protected int fetchSize ; protected AbstractCursorHandler ( String cursorName , int fetchSize ) { this . cursorName = cursorName ; this . fetchSize = fetchSize ; } public void setCursorName ( String cursorName ) { this . cursorName = cursorName ; } public String getCursorName ( ) { return cursorName ; } public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; } public int getFetchSize ( ) { return fetchSize ; } protected Object invoke ( Object obj , Object proxy , Method method , Object ... args ) throws Throwable { if ( \"toString\" . equals ( method . getName ( ) ) ) { String str = obj", "gt": ". toString ( ) ;", "prediction": ". toString ( ) ;\n", "label": 0}
{"id": 13795, "input": "<s> package org . mitre . openid . connect . repository . impl ; import static org . mitre . util . jpa . JpaUtil . saveOrUpdate ; import static org . mitre . util . jpa . JpaUtil . getSingleResult ; import java . util . Collection ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; import javax . persistence . TypedQuery ; import org . mitre . openid . connect . model . DefaultUserInfo ; import org . mitre . openid . connect . model . UserInfo ; import org . mitre . openid . connect . repository . UserInfoRepository ; import org . springframework . stereotype . Repository ; import org . springframework . transaction . annotation . Transactional ; @ Repository public class JpaUserInfoRepository implements UserInfoRepository { @ PersistenceContext private EntityManager manager ; @ Override @ Transactional public UserInfo getByUserId ( String userId ) { return manager . find ( DefaultUserInfo . class , userId ) ; } @ Override @ Transactional public UserInfo save ( UserInfo userInfo ) { return saveOrUpdate ( userInfo . getUserId ( ) , manager , userInfo ) ; } @ Override @ Transactional public void remove ( UserInfo userInfo ) { UserInfo found = manager . find ( DefaultUserInfo . class , userInfo . getUserId ( ) ) ; if ( found != null ) { manager . remove ( userInfo ) ; } else { throw new IllegalArgumentException ( ) ; } } @ Override", "gt": "@ Transactional public void removeByUserId ( String userId )", "prediction": "@ Transactional public UserInfo update ( UserInfo userInfo )\n", "label": 1}
{"id": 2947, "input": "<s> package org . ofbiz . minilang . method . ifops ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MessageElement ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . security . Security ; import org . w3c . dom . Element ; public final class CheckPermission extends MethodOperation { private final List < PermissionInfo > altPermissionInfoList ; private final FlexibleMapAccessor < List < String > > errorListFma ; private final MessageElement messageElement ; private final PermissionInfo primaryPermissionInfo ; public CheckPermission ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"permission\" , \"action\" , \"error-list-name\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"error-list-name\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"alt-permission\" , \"fail-message\" , \"fail-property\" ) ; MiniLangValidate . requireAnyChildElement ( simpleMethod , element , \"fail-message\" , \"fail-property\" ) ; } errorListFma = FlexibleMapAccessor . getInstance ( MiniLangValidate . checkAttribute ( element . getAttribute ( \"error-list-name\" ) , \"error_list\" ) ) ; primaryPermissionInfo = new PermissionInfo ( element ) ; List < ? extends Element > altPermElements = UtilXml . childElementList ( element , \"alt-permission\" ) ; if ( ! altPermElements . isEmpty ( ) ) { List < PermissionInfo > permissionInfoList = new ArrayList < PermissionInfo > ( altPermElements . size ( ) ) ; for ( Element altPermElement : altPermElements ) { permissionInfoList . add ( new PermissionInfo ( altPermElement ) ) ; } altPermissionInfoList = Collections . unmodifiableList ( permissionInfoList ) ; } else { altPermissionInfoList = null ; } messageElement = MessageElement . fromParentElement ( element , simpleMethod ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { boolean hasPermission = false ; GenericValue userLogin = methodContext . getUserLogin ( ) ; if ( userLogin != null ) { Security security = methodContext . getSecurity ( ) ; hasPermission = this . primaryPermissionInfo . hasPermission ( methodContext , userLogin , security ) ; if ( ! hasPermission && altPermissionInfoList != null ) { for ( PermissionInfo altPermInfo : altPermissionInfoList ) { if ( altPermInfo . hasPermission ( methodContext , userLogin , security ) ) { hasPermission = true ; break ; } } } } if ( ! hasPermission && messageElement != null ) { List < String > messages = errorListFma . get ( methodContext . getEnvMap ( ) ) ; if ( messages == null ) { messages = FastList . newInstance ( ) ; errorListFma . put ( methodContext . getEnvMap ( ) , messages ) ; } messages . add ( messageElement . getMessage ( methodContext ) ) ; } return true ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<check-permission \" ) ; sb . append ( \"permission=\\\"\" ) . append ( this . primaryPermissionInfo . permissionFse ) . append ( \"\\\" \" ) ; if ( ! this . primaryPermissionInfo . actionFse . isEmpty ( ) ) { sb . append ( \"action=\\\"\" ) . append ( this . primaryPermissionInfo . actionFse ) . append ( \"\\\" \" ) ; } if ( ! \"error_list\" . equals ( this . errorListFma . getOriginalName ( ) ) ) { sb . append ( \"error-list-name=\\\"\" ) . append ( this . errorListFma ) . append ( \"\\\" \" ) ; } if ( messageElement != null ) { sb . append ( \">\" ) . append ( messageElement ) . append ( \"</check-permission>\" ) ; } else { sb . append ( \"/>\" ) ; } return sb . toString ( ) ; } public static final class CheckPermissionFactory implements Factory < CheckPermission > { @ Override public CheckPermission createMethodOperation ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { return new CheckPermission ( element , simpleMethod ) ; } @ Override public String getName ( ) { return \"check-permission\" ; } } private class PermissionInfo { private final FlexibleStringExpander actionFse ; private final FlexibleStringExpander permissionFse ; private PermissionInfo ( Element element ) throws MiniLangException { if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"permission\" , \"action\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"permission\" ) ; } this . permissionFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"permission\" ) ) ; this . actionFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"action\" ) ) ; } private boolean hasPermission ( MethodContext methodContext , GenericValue userLogin , Security security ) { String permission = permissionFse . expandString ( methodContext . getEnvMap ( ) ) ; String action = actionFse . expandString ( methodContext . getEnvMap ( ) ) ; if ( ! action . isEmpty ( ) ) { return security .", "gt": "hasEntityPermission ( permission , action , userLogin ) ;", "prediction": "hasPermission ( permission ) ;\n", "label": 0}
{"id": 13796, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . graphics . Image ; public class LabelProvider extends BaseLabelProvider implements ILabelProvider { public LabelProvider ( ) { } public", "gt": "Image getImage ( Object element )", "prediction": "Image getImage ( )\n", "label": 1}
{"id": 3288, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; public class T5070898 { public static void main ( String ... args ) throws Exception { new T5070898 ( ) . run ( ) ; } public void run ( ) throws Exception { writeFile ( ) ; compileFile ( ) ; int rc = runJavah ( ) ; System . err . println ( \"exit code: \" + rc ) ; if ( rc == 0 ) throw new Exception ( \"unexpected exit code: \" + rc ) ; } void writeFile ( ) throws Exception { String content = \"package test;\\n\" + \"public class JavahTest{\\n\" + \"    public static void main(String args){\\n\" + \"        System.out.println(\\\"Test Message\\\");\" + \"    }\\n\" + \"    private static native Object nativeTest();\\n\" + \"}\\n\" ; FileWriter out = new FileWriter ( \"JavahTest.java\" ) ; try { out . write ( content ) ; } finally { out . close ( ) ; } } void compileFile ( ) throws Exception { JavaCompiler javac = ToolProvider . getSystemJavaCompiler ( ) ; int rc = javac . run ( null , null , null , \"JavahTest.java\" ) ; if ( rc != 0 ) throw new Exception ( \"compilation failed\" ) ; } int runJavah ( ) throws Exception { List < String > cmd = new ArrayList < String > ( ) ; File java_home = new File ( System . getProperty ( \"java.home\" ) ) ; if ( java_home . getName ( ) . equals ( \"jre\" ) ) java_home = java_home . getParentFile ( ) ; cmd . add ( new File ( new File ( java_home , \"bin\" ) , \"javah\" ) . getPath ( ) ) ; cmd . add ( \"-J-Xbootclasspath:\" + System . getProperty ( \"sun.boot.class.path\" ) ) ; cmd . add ( \"JavahTest\" ) ; ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . redirectErrorStream ( true ) ; pb", "gt": ". environment ( ) . remove ( \"CLASSPATH\" ) ;", "prediction": ". exec ( ) ;\n", "label": 0}
{"id": 13797, "input": "<s> package org . jscsi . utils ; import static org . testng . AssertJUnit . assertEquals ; import static org . testng . AssertJUnit . assertTrue ; import org . testng . annotations . Test ; public final class SerialArithmeticNumberTest { @ Test public final void testInitialize ( ) { final SerialArithmeticNumber serialNumber = new SerialArithmeticNumber ( 1 ) ; assertEquals ( 1 , serialNumber . getValue ( ) ) ; } @ Test public final void testCompare1 ( ) { final SerialArithmeticNumber serialNumber = new SerialArithmeticNumber ( ) ; assertEquals ( 0 , serialNumber . getValue ( ) ) ; assertTrue ( serialNumber . compareTo ( 4 ) < 0 ) ; } @ Test public final void testCompare2 ( ) { final SerialArithmeticNumber sNumber = new SerialArithmeticNumber ( 4 ) ; assertEquals", "gt": "( 4 , sNumber . getValue ( ) ) ;", "prediction": "( 0 , sNumber . getValue ( ) ) ;\n", "label": 1}
{"id": 6825, "input": "<s> package com . sun . tools . javac . model ; import java . util . AbstractList ; import java . util . Iterator ; import java . util . NoSuchElementException ; import com . sun . tools . javac . code . Scope ; import com . sun . tools . javac . code . Symbol ; import static com . sun . tools . javac . code . Flags . * ; public class FilteredMemberList extends AbstractList < Symbol > { private final Scope scope ; public FilteredMemberList ( Scope scope ) { this . scope = scope ; } public int size ( ) { int cnt = 0 ; for ( Scope . Entry e = scope . elems ; e != null ; e = e . sibling ) { if ( ! unwanted ( e . sym ) ) cnt ++ ; } return cnt ; } public Symbol get ( int index ) { for ( Scope . Entry e = scope . elems ; e != null ; e = e . sibling ) { if ( ! unwanted ( e . sym ) && ( index -- == 0 ) ) return e . sym ; } throw new IndexOutOfBoundsException ( ) ; } public Iterator < Symbol > iterator ( ) { return new Iterator < Symbol > ( ) { private Scope . Entry nextEntry = scope . elems ; private boolean hasNextForSure = false ; public boolean hasNext ( ) { if ( hasNextForSure ) { return true ; } while ( nextEntry != null && unwanted ( nextEntry . sym ) ) { nextEntry = nextEntry . sibling ; } hasNextForSure = ( nextEntry != null ) ; return hasNextForSure ; } public Symbol next ( ) { if ( hasNext ( ) ) { Symbol result = nextEntry . sym ; nextEntry = nextEntry . sibling ; hasNextForSure = false ; return result ; } else { throw new NoSuchElementException ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } private static boolean unwanted ( Symbol s ) { return s == null || ( s", "gt": ". flags ( ) & SYNTHETIC ) != 0 ;", "prediction": "!= null && s . isVisible ( ) ) ;\n", "label": 0}
{"id": 13800, "input": "<s> package org . modelgoon . core . editparts ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . tools . CellEditorLocator ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . swt . widgets . Text ; import org . modelgoon . core . NoteFigure ; final public class LabelCellEditorLocator implements CellEditorLocator { private NoteFigure stickyNote ; public LabelCellEditorLocator ( final NoteFigure stickyNote ) { setLabel ( stickyNote ) ; } public void relocate ( final CellEditor celleditor ) { Text text = ( Text ) celleditor . getControl ( ) ; Rectangle rect = this . stickyNote . getClientArea ( ) ; this . stickyNote . translateToAbsolute ( rect ) ; org . eclipse . swt . graphics . Rectangle trim = text . computeTrim ( 0 , 0 ,", "gt": "0 , 0 ) ;", "prediction": "rect . width , rect . height ) ;\n", "label": 1}
{"id": 5380, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Arrays ; import java . util . Collections ; public class Dee implements AnnotationProcessorFactory { static class DeeProc implements AnnotationProcessor { DeeProc ( AnnotationProcessorEnvironment ape ) { } public void process ( ) { return ; } } static Collection < String > supportedTypes ; static { String types [ ] = { \"dum\" } ; supportedTypes = Collections . unmodifiableCollection ( Arrays . asList ( types ) ) ; } static Collection < String > supportedOptions ; static { String options [ ] = { \"\" } ; supportedOptions = Collections . unmodifiableCollection ( Arrays . asList ( options ) ) ; }", "gt": "public Collection < String > supportedOptions ( )", "prediction": "}\n", "label": 0}
{"id": 13801, "input": "<s> package org . eclipse . jface . internal . databinding . viewers ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . core . databinding . observable . Diffs ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . set . AbstractObservableSet ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ICheckable ; import org . eclipse . jface . viewers . IElementComparer ; public class CheckableCheckedElementsObservableSet extends AbstractObservableSet { private ICheckable checkable ; private Set wrappedSet ; private Object elementType ; private IElementComparer elementComparer ; private ICheckStateListener listener ; public CheckableCheckedElementsObservableSet ( Realm realm , final Set wrappedSet , Object elementType , IElementComparer elementComparer , ICheckable checkable ) { super ( realm ) ; Assert . isNotNull ( checkable , \"Checkable cannot be null\" ) ; Assert . isNotNull ( wrappedSet , \"Wrapped set cannot be null\" ) ; this . checkable = checkable ; this . wrappedSet = wrappedSet ; this . elementType = elementType ; this . elementComparer = elementComparer ; listener = new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { Object element = event . getElement ( ) ; if ( event . getChecked ( ) ) { if ( wrappedSet . add ( element ) ) fireSetChange ( Diffs . createSetDiff ( Collections . singleton ( element ) , Collections . EMPTY_SET ) ) ; } else { if ( wrappedSet . remove ( element ) ) fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , Collections . singleton ( element ) ) ) ; } } } ; checkable . addCheckStateListener ( listener ) ; } protected Set getWrappedSet ( ) { return wrappedSet ; } Set createDiffSet ( ) { return ViewerElementSet . withComparer ( elementComparer ) ; } public Object getElementType ( ) { return elementType ; } public boolean add ( Object o ) { getterCalled ( ) ; boolean added = wrappedSet . add ( o ) ; if ( added ) { checkable . setChecked ( o , true ) ; fireSetChange ( Diffs . createSetDiff ( Collections . singleton ( o ) , Collections . EMPTY_SET ) ) ; } return added ; } public boolean remove ( Object o ) { getterCalled ( ) ; boolean removed = wrappedSet . remove ( o ) ; if ( removed ) { checkable . setChecked ( o , false ) ; fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , Collections . singleton ( o ) ) ) ; } return removed ; } public boolean addAll ( Collection c ) { getterCalled ( ) ; Set additions = createDiffSet ( ) ; for ( Iterator iterator = c . iterator ( ) ; iterator . hasNext ( ) ; ) { Object element = iterator . next ( ) ; if ( wrappedSet . add ( element ) ) { checkable . setChecked ( element , true ) ; additions . add ( element ) ; } } boolean changed = ! additions . isEmpty ( ) ; if ( changed ) fireSetChange ( Diffs . createSetDiff ( additions , Collections . EMPTY_SET ) ) ; return changed ; } public boolean removeAll ( Collection c ) { getterCalled ( ) ; Set removals = createDiffSet ( ) ; for ( Iterator iterator = c . iterator ( ) ; iterator . hasNext ( ) ; ) { Object element = iterator . next ( ) ; if ( wrappedSet . remove ( element ) ) { checkable . setChecked ( element , false ) ; removals . add ( element ) ; } } boolean changed = ! removals . isEmpty ( ) ; if ( changed ) fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , removals ) ) ; return changed ; } public boolean retainAll ( Collection c ) { getterCalled ( ) ; Set toRetain = createDiffSet ( ) ; toRetain . addAll ( c ) ; Set removals = createDiffSet ( ) ; for ( Iterator iterator = wrappedSet . iterator ( ) ; iterator . hasNext ( ) ; ) { Object element = iterator . next ( ) ; if ( ! toRetain . contains ( element ) ) { iterator . remove ( ) ; checkable . setChecked ( element , false ) ; removals . add ( element ) ; } } boolean changed = ! removals . isEmpty ( ) ; if ( changed ) fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , removals ) ) ; return changed ; } public void clear ( ) { getterCalled ( ) ; Set", "gt": "removals = createDiffSet ( ) ;", "prediction": "removals = createDiffSet ( ) ;\n", "label": 1}
{"id": 1842, "input": "<s> import java . util . Map ; public class T6302956 { Object test ( ) { return ( Map < String ,", "gt": "String > ) System . getProperties ( ) ;", "prediction": "Object > ) test ( ) ;\n", "label": 0}
{"id": 13804, "input": "<s> package org . restlet . example . book . restlet . ch02 . sec4 . sub2 ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . MediaType ; public class Tracer extends Restlet { public Tracer ( Context context ) { super ( context ) ; } @ Override public void handle ( Request request , Response response ) { String entity = \"Method       : \" + request . getMethod ( ) + \"\\nResource URI : \" + request . getResourceRef ( ) + \"\\nIP address   : \" + request . getClientInfo ( ) . getAddress ( ) + \"\\nAgent name   : \" + request . getClientInfo ( ) . getAgentName ( ) + \"\\nAgent version: \" + request . getClientInfo (", "gt": ") . getAgentVersion ( ) ;", "prediction": ") . getAgentVersion ( ) ;\n", "label": 1}
{"id": 3269, "input": "<s> package org . ofbiz . accounting . payment ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class PaymentMethodServices { public final static String module = PaymentMethodServices . class . getName ( ) ; public final static String resource = \"AccountingUiLabels\" ; public static final String resourceError = \"AccountingUiLabels\" ; public static Map < String , Object > deletePaymentMethod ( DispatchContext ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = FastMap . newInstance ( ) ; Delegator delegator = ctx . getDelegator ( ) ; Security security = ctx . getSecurity ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; Timestamp now = UtilDateTime . nowTimestamp ( ) ; String paymentMethodId = ( String ) context . get ( \"paymentMethodId\" ) ; GenericValue paymentMethod = null ; try { paymentMethod = delegator . findOne ( \"PaymentMethod\" , UtilMisc . toMap ( \"paymentMethodId\" , paymentMethodId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e . toString ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceError , \"AccountingPaymentMethodCannotBeDeleted\" , UtilMisc . toMap ( \"errorString\" , e . getMessage ( ) ) , locale ) ) ; } if ( paymentMethod == null ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceError , \"AccountingPaymentMethodCannotBeDeleted\" , UtilMisc . toMap ( \"errorString\" , \"\" ) , locale ) ) ; } if ( paymentMethod . get ( \"partyId\" ) == null || ! paymentMethod . getString ( \"partyId\" ) . equals ( userLogin . getString ( \"partyId\" ) ) ) { if ( ! security . hasEntityPermission ( \"PAY_INFO\" , \"_DELETE\" , userLogin ) && ! security . hasEntityPermission ( \"ACCOUNTING\" , \"_DELETE\" , userLogin ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceError , \"AccountingPaymentMethodNoPermissionToDelete\" , locale ) ) ; } } paymentMethod . set ( \"thruDate\" , now ) ; try { paymentMethod . store ( ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e . toString ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceError , \"AccountingPaymentMethodCannotBeDeletedWriteFailure\" , UtilMisc . toMap ( \"errorString\" , e . getMessage ( ) ) , locale ) ) ; } result . put ( ModelService . RESPONSE_MESSAGE , ModelService . RESPOND_SUCCESS ) ; return result ; } public static Map < String , Object > makeExpireDate ( DispatchContext ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = FastMap . newInstance ( ) ; String expMonth = ( String ) context . get ( \"expMonth\" ) ; String expYear = ( String ) context . get ( \"expYear\" ) ; StringBuilder expDate = new StringBuilder ( ) ; expDate . append ( expMonth ) ; expDate . append ( \"/\" ) ; expDate . append ( expYear ) ; result . put ( \"expireDate\" , expDate . toString ( ) ) ; result . put ( ModelService . RESPONSE_MESSAGE , ModelService . RESPOND_SUCCESS ) ; return result ; } public static Map < String , Object > createCreditCard ( DispatchContext ctx , Map < String , Object > context ) { Map < String , Object > result = FastMap . newInstance ( ) ; Delegator delegator = ctx . getDelegator ( ) ; Security security = ctx . getSecurity ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale", "gt": ") context . get ( \"locale\" ) ;", "prediction": ") context . get ( \"locale\" ) ;\n", "label": 0}
{"id": 13807, "input": "<s> package org . eclipse . swt . internal . widgets . toolbarkit ; import java . io . IOException ; import java . util . Arrays ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . ToolBar ; import junit . framework . TestCase ; public class ToolBarLCA_Test extends TestCase { private Display display ; private Shell shell ; private ToolBarLCA lca ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; lca = new ToolBarLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . NONE ) ; ControlLCATestUtil . testActivateListener ( toolBar ) ; ControlLCATestUtil . testFocusListener ( toolBar ) ; ControlLCATestUtil . testMouseListener ( toolBar ) ; ControlLCATestUtil . testKeyListener ( toolBar ) ; ControlLCATestUtil . testTraverseListener ( toolBar ) ; ControlLCATestUtil . testMenuDetectListener ( toolBar ) ; ControlLCATestUtil . testHelpListener ( toolBar ) ; } public void testRenderCreate ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . NONE ) ; lca . renderInitialization ( toolBar ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( toolBar ) ; assertEquals ( \"rwt.widgets.ToolBar\" , operation . getType ( ) ) ; Object [ ] styles = operation . getStyles ( ) ; assertTrue ( Arrays . asList ( styles ) . contains ( \"HORIZONTAL\" ) ) ; assertFalse ( Arrays . asList ( styles ) . contains ( \"H_SCROLL\" ) ) ; } public void testRenderCreate_Vertical ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . VERTICAL ) ; lca . renderInitialization ( toolBar ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( toolBar ) ; Object [ ] styles = operation . getStyles ( ) ; assertTrue ( Arrays . asList ( styles ) . contains ( \"VERTICAL\" ) ) ; assertFalse ( Arrays . asList ( styles ) . contains ( \"V_SCROLL\" ) ) ; } public void testRenderCreate_Flat ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . FLAT ) ; lca . renderInitialization ( toolBar ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( toolBar ) ; Object [ ] styles = operation . getStyles ( ) ; assertTrue ( Arrays . asList ( styles ) .", "gt": "contains ( \"FLAT\" ) ) ;", "prediction": "contains ( \"FLAT\" ) ) ;\n", "label": 1}
{"id": 8702, "input": "<s> package com . deliciousdroid . client ; import java . util . Date ; import android . util . Log ; import org . json . JSONObject ; import com . deliciousdroid . util . DateParser ; public class User { private final String mUserName ; public String getUserName ( ) { return mUserName ; } public User ( String name ) { mUserName = name ; } public static User valueOf ( JSONObject user ) { try { final String userName = user . getString ( \"user\" ) ; return new User ( userName ) ; } catch ( final Exception ex ) { Log . i ( \"User\" , \"Error parsing JSON user object\" + ex . toString ( ) ) ; } return null ; } public static class Status { private final String mUserName ; private final String mStatus ; private final Date mTimestamp ; public String getUserName ( ) { return mUserName ; } public String getStatus ( ) { return mStatus ; } public Date getTimeStamp ( ) { return mTimestamp ; } public Status ( String userName , String status , Date timestamp ) { mUserName = userName ; mStatus = status ; mTimestamp = timestamp ; } public static User . Status valueOf ( JSONObject userStatus ) { try { final String userName = userStatus . getString ( \"a\" ) ; final String status = userStatus . getString ( \"d\" ) ; final String date = userStatus . getString ( \"dt\" ) ; Date timestamp = DateParser .", "gt": "parse ( date ) ;", "prediction": "parse ( date ) ;\n", "label": 0}
{"id": 13809, "input": "<s> package org . restlet . example . book . restlet . ch06 . sec2 . server ; import org . restlet . example . book . restlet . ch02 . sec5 . sub5 . common . AccountResource ; import org . restlet . ext . wadl . MethodInfo ; import org . restlet . ext . wadl . RepresentationInfo ; import org . restlet . ext . wadl . WadlServerResource ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; public class AccountServerResource extends WadlServerResource implements AccountResource { private int accountId ; @ Override protected RepresentationInfo describe ( MethodInfo methodInfo , Class < ? > representationClass , Variant variant ) { RepresentationInfo result = super . describe ( methodInfo , representationClass , variant ) ; result . setReference ( \"account\" ) ; return result ; } @ Override protected void doInit ( ) throws ResourceException { String accountIdAttribute = getAttribute ( \"accountId\" ) ; if ( accountIdAttribute != null ) { this . accountId = Integer . parseInt ( accountIdAttribute ) ; setName ( \"Resource for mail account '\" + this . accountId + \"'\" ) ; setDescription ( \"The resource describing the mail account number '\" + this . accountId + \"'\" ) ; } else { setName (", "gt": "\"Mail account resource\" ) ;", "prediction": "\"Resource for mail account '\" + this . accountId + \"'\" ) ;\n", "label": 1}
{"id": 1536, "input": "<s> package com . toedter . gwt . demo . contacts . client . activity ; public class ActivityRegistry { private static ContactDetailsActivity contactDetailsActivity ; private static ContactListActivity contactListActivity ; private static ToolBarActivity ToolbarActivity ; public static ContactDetailsActivity getContactDetailsActivity ( ) { return contactDetailsActivity ; } public static void setContactDetailsActivity ( ContactDetailsActivity contactDetailsActivity ) { ActivityRegistry . contactDetailsActivity = contactDetailsActivity ; } public static ContactListActivity getContactListActivity ( ) { return contactListActivity ; } public static void setContactListActivity ( ContactListActivity contactListActivity ) { ActivityRegistry . contactListActivity = contactListActivity ; } public static ToolBarActivity getToolbarActivity ( ) { return ToolbarActivity ; } public static", "gt": "void setToolbarActivity ( ToolBarActivity toolbarActivity )", "prediction": "ToolBarActivity getToolbarActivity ( )\n", "label": 0}
{"id": 13810, "input": "<s> package org . eclipse . rap . internal . design . example . stacks ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . swt . widgets . Control ; public class ViewToolBarRegistry { private List presentationList = new ArrayList ( ) ; private ViewToolBarRegistry ( ) { } public static ViewToolBarRegistry getInstance ( ) { return SingletonUtil . getSessionInstance ( ViewToolBarRegistry . class ) ; } public void addViewPartPresentation ( ViewStackPresentation presentation ) { presentationList . add ( presentation ) ; } public void removeViewPartPresentation ( ViewStackPresentation presentation ) { presentationList . remove ( presentation ) ; } public void fireToolBarChanged ( ) { for ( int i = 0 ; i < presentationList . size ( ) ; i ++ ) { if ( presentationList . get", "gt": "( i ) != null )", "prediction": "( i ) instanceof Control )\n", "label": 1}
{"id": 10004, "input": "<s> package org . parboiled . parserunners ; import org . parboiled . MatchHandler ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . buffers . InputBuffer ; import org . parboiled . common . Predicate ; import org . parboiled . common . StringUtils ; import org . parboiled . matchers . Matcher ; import org . parboiled . matchervisitors . DoWithMatcherVisitor ; import org . parboiled . support . ParsingResult ; import java . text . DecimalFormat ; import java . util . * ; import static org . parboiled . common . Preconditions . checkArgNotNull ; import static org . parboiled . common . Utils . humanize ; public class ProfilingParseRunner < V > extends AbstractParseRunner < V > implements MatchHandler { private final Map < Rule , RuleReport > ruleReports = new HashMap < Rule , RuleReport > ( ) ; private int runMatches ; private int totalRuns ; private int totalMatches ; private int totalMismatches ; private int totalRematches ; private int totalRemismatches ; private long totalNanoTime ; private long timeCorrection ; private final DoWithMatcherVisitor . Action updateStatsAction = new DoWithMatcherVisitor . Action ( ) { public void process ( Matcher matcher ) { RuleStats ruleStats = ( RuleStats ) matcher . getTag ( ) ; int rematches = 0 , remismatches = 0 ; for ( Integer i : ruleStats . positionMatches . values ( ) ) { if ( i > 0 ) { rematches += i - 1 ; } else if ( i < 0 ) { remismatches += - ( i + 1 ) ; } } totalMatches += ruleStats . matches ; totalMismatches += ruleStats . mismatches ; totalRematches += rematches ; totalRemismatches += remismatches ; RuleReport ruleReport = ruleReports . get ( matcher ) ; if ( ruleReport == null ) { ruleReport = new RuleReport ( matcher ) ; ruleReports . put ( matcher , ruleReport ) ; } ruleReport . update ( ruleStats . matches , ruleStats . matchSubs , ruleStats . mismatches , ruleStats . mismatchSubs , rematches , ruleStats . rematchSubs , remismatches , ruleStats . remismatchSubs , ruleStats . nanoTime ) ; } } ; public ProfilingParseRunner ( Rule rule ) { super ( rule ) ; } public ParsingResult < V > run ( InputBuffer inputBuffer ) { checkArgNotNull ( inputBuffer , \"inputBuffer\" ) ; resetValueStack ( ) ; totalRuns ++ ; MatcherContext < V > rootContext = createRootContext ( inputBuffer , this , true ) ; rootContext . getMatcher ( ) . accept ( new DoWithMatcherVisitor (", "gt": "new DoWithMatcherVisitor . Action ( )", "prediction": ")\n", "label": 0}
{"id": 13813, "input": "<s> package org . eclipse . swt . internal . browser . browserkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . eclipse . rap . rwt . testfixture . Fixture . fakeNewRequest ; import static org . eclipse . rap . rwt . testfixture . Fixture . fakeSetParameter ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . rap . rwt . widgets . BrowserCallback ; import org . eclipse . rap . rwt . widgets . BrowserUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . browser . * ; import org . eclipse . swt . internal . widgets . IBrowserAdapter ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; public class BrowserLCA_Test extends TestCase { private Display display ; private Shell shell ; private BrowserLCA lca ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display ) ; lca = new BrowserLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { Browser browser = new Browser ( shell , SWT . NONE ) ; ControlLCATestUtil . testActivateListener ( browser ) ; ControlLCATestUtil . testFocusListener ( browser ) ; ControlLCATestUtil . testMouseListener ( browser ) ; ControlLCATestUtil . testKeyListener ( browser ) ; ControlLCATestUtil . testTraverseListener ( browser ) ; ControlLCATestUtil . testMenuDetectListener ( browser ) ; ControlLCATestUtil . testHelpListener ( browser ) ; } public void testTextChanged ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; String expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; assertFalse ( BrowserLCA . hasUrlChanged ( browser ) ) ; browser = new Browser ( shell , SWT . NONE ) ; browser . setText ( \"Hello\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"Hello\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; browser . setText ( \"GoodBye\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"GoodBye\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . preserveWidgets ( ) ; browser . setText ( \"GoodBye\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"GoodBye\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; browser = new Browser ( shell , SWT . NONE ) ; browser . setText ( \"\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; } public void testUrlChanged ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; String expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; assertFalse ( BrowserLCA . hasUrlChanged ( browser ) ) ; browser = new Browser ( shell , SWT . NONE ) ; browser . setUrl ( \"http://eclipse.org/rap\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; assertEquals ( \"http://eclipse.org/rap\" , BrowserLCA . getUrl ( browser ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; browser . setUrl ( \"http://eclipse.org/rip\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; assertEquals ( \"http://eclipse.org/rip\" , BrowserLCA . getUrl ( browser ) ) ; Fixture . preserveWidgets ( ) ; browser . setUrl ( \"http://eclipse.org/rip\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; assertEquals ( \"http://eclipse.org/rip\" , BrowserLCA . getUrl ( browser ) ) ; } public void testResetUrlChanged_NotInitialized ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; browser . setUrl ( \"http://eclipse.org/rap\" ) ; Fixture . fakeResponseWriter ( ) ; BrowserLCA lca = new BrowserLCA ( ) ; lca . renderChanges ( browser ) ; assertFalse ( getAdapter ( browser ) . hasUrlChanged ( ) ) ; } public void testResetUrlChanged_Initialized ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; Fixture . markInitialized ( browser ) ; browser . setUrl ( \"http://eclipse.org/rap\" ) ; Fixture . fakeResponseWriter ( ) ; BrowserLCA lca = new BrowserLCA ( ) ; lca . renderChanges ( browser ) ; assertFalse ( getAdapter ( browser ) . hasUrlChanged ( ) ) ; }", "gt": "public void testExecuteFunction ( )", "prediction": "}\n", "label": 1}
{"id": 10130, "input": "<s> package ar . com . fdvs . dj . core . registration ; import java . util . Iterator ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignField ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . domain . ColumnProperty ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . DJGroupVariableDef ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . ExpressionColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . util . ExpressionUtils ; public class DJGroupVariableDefRegistrationManager extends AbstractEntityRegistrationManager { private static final Log log = LogFactory . getLog ( DJGroupVariableDefRegistrationManager . class ) ; JRDesignGroup group = null ; public DJGroupVariableDefRegistrationManager ( DynamicJasperDesign jd , DynamicReport dr , LayoutManager layoutManager , JRDesignGroup group ) { super ( jd , dr , layoutManager ) ; this . group = group ; } protected void registerEntity ( Entity entity ) { log . debug ( \"registering group variable...\" ) ; try { JRDesignVariable jrVariable = ( JRDesignVariable ) transformEntity ( entity ) ; getDjd ( ) . addVariable ( jrVariable ) ; } catch ( JRException e ) { throw new EntitiesRegistrationException ( e . getMessage ( ) , e ) ; } } protected Object transformEntity ( Entity entity ) { log . debug ( \"transforming group variable...\" ) ; DJGroupVariableDef columnsGroupVariable = ( DJGroupVariableDef ) entity ; DJCalculation op = columnsGroupVariable . getOperation ( ) ; JRDesignExpression expression = new JRDesignExpression ( ) ; String valueClassName = null ; String initialExpression = null ; if ( columnsGroupVariable . getColumnProperty ( ) != null ) { ColumnProperty prop = columnsGroupVariable . getColumnProperty ( ) ; expression . setText ( \"$F{\" + prop . getProperty ( ) + \"}\" ) ; expression . setValueClassName ( prop .", "gt": "getValueClassName ( ) ) ;", "prediction": "getValueClassName ( ) ) ;\n", "label": 0}
{"id": 13819, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . Term ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import java . util . ArrayList ; public class SimpleQueryMaker extends AbstractQueryMaker implements QueryMaker { protected Query [ ] prepareQueries ( ) throws Exception { Analyzer anlzr = ( Analyzer ) Class . forName ( config . get ( \"analyzer\" , \"org.apache.lucene.analysis.standard.StandardAnalyzer\" ) ) . newInstance ( ) ; QueryParser qp = new QueryParser ( DocMaker . BODY_FIELD , anlzr ) ; ArrayList qq = new ArrayList ( ) ; Query q1 = new TermQuery ( new Term ( DocMaker . ID_FIELD , \"doc2\" ) ) ; qq . add ( q1 ) ; Query q2 = new TermQuery ( new Term ( DocMaker . BODY_FIELD , \"simple\" ) ) ; qq . add ( q2 ) ; BooleanQuery bq = new BooleanQuery ( ) ; bq . add ( q1 , Occur . MUST ) ; bq . add ( q2 , Occur . MUST ) ; qq", "gt": ". add ( bq ) ;", "prediction": ". add ( bq ) ;\n", "label": 1}
{"id": 1020, "input": "<s> package gui ; import java . awt . Color ; import java . awt . Dimension ; import javax . swing . JButton ; import javax . swing . border . EmptyBorder ; public class Tab extends JButton { private static final long serialVersionUID = 6303977417629057524L ; private static final int TABBORDERWIDTH = 10 ; private static final int TABWIDTH = 120 ; private static final int TABHEIGHT = 40 ; public Tab ( final String title , final int intention ) { super ( title ) ; this . setPreferredSize ( new Dimension ( TABWIDTH , TABHEIGHT ) ) ; this . setBackground ( PanelsManager . UNSELECTEDBLUE ) ; this . setFocusPainted ( false ) ; this . setForeground ( Color . WHITE ) ; this . setBorder ( new EmptyBorder ( TABBORDERWIDTH , TABBORDERWIDTH , TABBORDERWIDTH , TABBORDERWIDTH ) ) ; this . setEnabled ( true ) ; this . addActionListener ( new TabActionListener ( intention , this ) ) ; }", "gt": "public Tab ( final String title )", "prediction": "}\n", "label": 0}
{"id": 13822, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . service ; import java . io . File ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . platform . picture . api . ImageInfo ; import org . nuxeo . ecm . platform . picture . magick . utils . ImageIdentifier ; import org . nuxeo . ecm . platform . picture . magick . utils . ImageResizer ; import org . nuxeo . ecm . platform . pictures . tiles . api . PictureTiles ; import org . nuxeo . ecm . platform . pictures . tiles . helpers . StringMaker ; public class PictureTilingCacheInfo { public static int SHRINK_DOWN_LIMIT_PX = 2000 ; private static final Log log = LogFactory . getLog ( PictureTilingCacheInfo . class ) ; protected String cacheKey ; protected String workingDir ; protected ImageInfo originalPictureInfos ; protected Map < Integer , ImageInfo > shrinkedImages ; protected List < Integer > shrinkedImagesWidths ; protected Map < String , PictureTiles > tilesSet ; protected String syncShrink = \"oneOncePerInstance\" ; protected Date lastAccessTime ; protected void updateAccessTime ( ) { lastAccessTime = new Date ( ) ; } public Date getLastAccessedTime ( ) { return lastAccessTime ; } protected long getFileSize ( String path ) { if ( path == null ) return 0 ; File file = new File ( path ) ; if ( file . exists ( ) ) { return file . length ( ) ; } else return 0 ; } public long getDiskSpaceUsageInBytes ( ) { long diskSpaceUsage = 0 ; diskSpaceUsage += getFileSize ( originalPictureInfos . getFilePath ( ) ) ; for ( Integer s : shrinkedImages . keySet ( ) ) { diskSpaceUsage += getFileSize ( shrinkedImages . get ( s ) . getFilePath ( ) ) ; } for ( String tileDef : tilesSet . keySet ( ) ) { PictureTiles tiles = tilesSet . get ( tileDef ) ; File tileDir = new File ( tiles . getTilesPath ( ) ) ; if ( tileDir . exists ( ) ) { for", "gt": "( File tileFile : tileDir . listFiles ( ) )", "prediction": "( int i = 0 ;\n", "label": 1}
{"id": 3209, "input": "<s> package org . ofbiz . workeffort . workeffort ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; public class WorkEffortPartyAssignmentServices { public static final String module = WorkEffortPartyAssignmentServices . class . getName ( ) ; public static void updateWorkflowEngine ( GenericValue wepa , GenericValue userLogin , LocalDispatcher dispatcher ) { Delegator delegator = wepa . getDelegator ( ) ; GenericValue workEffort = null ; try { workEffort = delegator . findOne ( \"WorkEffort\" , false , \"workEffortId\" , wepa . get ( \"workEffortId\" ) ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e , module ) ; } if ( workEffort != null && \"ACTIVITY\" . equals ( workEffort . getString ( \"workEffortTypeId\" ) ) ) { String statusId = ( String ) wepa . get ( \"statusId\" ) ; Map < String , Object > context = UtilMisc . toMap ( \"workEffortId\" , wepa . get ( \"workEffortId\" ) , \"partyId\" , wepa . get ( \"partyId\" ) , \"roleTypeId\" , wepa . get ( \"roleTypeId\" ) , \"fromDate\" , wepa . get ( \"fromDate\" ) , \"userLogin\" , userLogin ) ; if ( \"CAL_ACCEPTED\" . equals ( statusId ) ) { try { Map < String , Object > results = dispatcher . runSync ( \"wfAcceptAssignment\" , context ) ; if ( results != null && results . get ( ModelService . ERROR_MESSAGE ) != null ) Debug . logWarning ( ( String ) results . get ( ModelService . ERROR_MESSAGE ) , module ) ; } catch ( GenericServiceException e ) { Debug . logWarning ( e , module ) ; } } else if ( \"CAL_COMPLETED\" . equals ( statusId ) ) { try { Map < String , Object > results = dispatcher . runSync ( \"wfCompleteAssignment\" , context ) ; if ( results != null && results . get ( ModelService . ERROR_MESSAGE ) != null ) Debug . logWarning ( ( String ) results .", "gt": "get ( ModelService . ERROR_MESSAGE ) , module ) ;", "prediction": "get ( ModelService . ERROR_MESSAGE ) , module ) ;\n", "label": 0}
{"id": 13825, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public class MouseEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public int button ; public int stateMask ; public int x ; public int y ; public int count ; public MouseEvent ( Event event ) { super ( event ) ; x = event . x ; y = event . y ; button = event . button ; stateMask = event . stateMask ; count", "gt": "= event . count ;", "prediction": "= event . count ;\n", "label": 1}
{"id": 5704, "input": "<s> package org . xbill . DNS ; public class InvalidTypeException extends IllegalArgumentException { public InvalidTypeException ( int type ) { super (", "gt": "\"Invalid DNS type: \" + type ) ;", "prediction": "type ) ;\n", "label": 0}
{"id": 13827, "input": "<s> package org . spliffy . server . db . utils ; import com . bradmcevoy . http . Filter ; import com . bradmcevoy . http . FilterChain ; import com . bradmcevoy . http . Request ; import com . bradmcevoy . http . Response ; public class MiltonOpenSessionInViewFilter implements Filter { private final SessionManager sessionManager ; public MiltonOpenSessionInViewFilter ( SessionManager sessionManager ) { this . sessionManager = sessionManager ; } @ Override public void", "gt": "process ( FilterChain chain , Request request , Response response )", "prediction": "handle ( Request request , Response response )\n", "label": 1}
{"id": 5355, "input": "<s> package org . ofbiz . pos . device . impl ; import jpos . JposConst ; import jpos . JposException ; import org . ofbiz . pos . device . GenericDevice ; public class CheckScanner extends GenericDevice { public static final String module = CheckScanner . class . getName ( ) ; public CheckScanner", "gt": "( String deviceName , int timeout )", "prediction": "( )\n", "label": 0}
{"id": 13830, "input": "<s> package org . eclipse . jface . databinding . viewers ; import org . eclipse . core . databinding . property . list . IListProperty ; import", "gt": "org . eclipse . jface . viewers . Viewer ;", "prediction": "org . eclipse . jface . viewers . IStructuredSelection ;\n", "label": 1}
{"id": 5080, "input": "<s> package org . jjflyboy . tjpeditor . scoping ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . xtext . naming . QualifiedName ; public class ProjectQualifiedName extends QualifiedName { private int offset ; private boolean relative ; public static final String UPDIR = \"!\" ; public ProjectQualifiedName ( QualifiedName name , int offset ) { super ( name . getSegments ( ) . toArray ( new String [ ] { } ) ) ; setRelative ( getFirstSegment ( ) . equals ( ProjectQualifiedName . UPDIR ) ) ; this . offset = offset ; } public ProjectQualifiedName ( QualifiedName name ) { this ( name , 0 ) ; } public void advance ( ) { offset ++ ; } public boolean isRelative ( ) { return relative ; } private void setRelative ( boolean relative ) { this . relative = relative ; } public boolean isUp ( ) { return getFirstSegment ( ) . equals ( ProjectQualifiedName . UPDIR ) ; } @ Override public boolean isEmpty ( ) { return getSegmentCount ( ) == 0 ; } @ Override public List < String > getSegments ( ) { List < String > segments = super . getSegments ( ) ; return segments . subList ( offset , segments . size ( ) ) ; } @ Override public int getSegmentCount ( ) { return super . getSegmentCount ( ) - offset ; } @ Override public String getSegment ( int index ) { return super . getSegment ( offset + index ) ; } @ Override public String getFirstSegment ( ) { return super . getSegment ( offset ) ; } @ Override public QualifiedName skipFirst ( int skipCount ) { return super . skipFirst ( skipCount + offset ) ; } @ Override public QualifiedName skipLast ( int skipCount ) { return super . skipLast ( skipCount ) ; } @ Override public QualifiedName toLowerCase ( ) { List < String > newSegments = new ArrayList < String > ( ) ; for ( String segment : getSegments ( ) ) { newSegments . add ( segment . toLowerCase ( ) ) ; } QualifiedName t = QualifiedName . create ( newSegments . toArray ( new String [ ] { } ) ) ; return t ; } @ Override public QualifiedName toUpperCase ( ) { List < String > newSegments = new ArrayList < String > ( ) ; for ( String segment : super . getSegments ( ) ) { newSegments . add ( segment . toUpperCase ( ) ) ; } QualifiedName t = QualifiedName . create ( newSegments . toArray ( new String [ ] { } ) ) ; return new ProjectQualifiedName ( t , offset ) ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof QualifiedName ) { return this . getSegments ( ) . equals ( ( ( QualifiedName ) obj ) . getSegments ( ) ) ; } return false ; } @ Override public boolean equalsIgnoreCase ( Object obj ) { if ( obj instanceof QualifiedName ) { if ( ( ( ProjectQualifiedName ) obj ) . offset == offset ) { return super . equalsIgnoreCase ( obj ) ; } } else if ( offset == 0 ) { return super . equalsIgnoreCase ( obj ) ; } return false ; } protected boolean startsWith ( QualifiedName prefix , boolean ignoreCase ) { if ( prefix . getSegmentCount ( ) > getSegmentCount ( ) ) return false ; for ( int i = 0 ; i < prefix . getSegmentCount ( ) ; ++ i ) { if ( ( ignoreCase && ! this . getSegment ( i ) . equalsIgnoreCase ( prefix . getSegment ( i ) ) ) || ( ! ignoreCase && ! this . getSegment ( i ) . equals ( prefix . getSegment ( i ) ) ) ) return false ; } return true ; } public int countUpDirs ( ) { int count = 0 ; for ( String segment : getSegments ( ) ) { if ( segment . equals ( UPDIR ) ) { count ++ ; } else { break ; } } return count ; } @ Override public int hashCode ( ) { return Arrays . hashCode ( getSegments ( ) . toArray ( new String [ ] { } ) ) ; } public static void main ( String [ ] args ) { QualifiedName qnr = QualifiedName . create ( \"!\" , \"!\" , \"middle1\" , \"bottom2\" ) ; QualifiedName qn = QualifiedName . create ( \"middle1\" , \"bottom2\" ) ; ProjectQualifiedName pqn =", "gt": "new ProjectQualifiedName ( qnr , 2 ) ;", "prediction": "ProjectQualifiedName . create ( qnr ) ;\n", "label": 0}
{"id": 13831, "input": "<s> package org . seage . metaheuristic . grasp ; public class HillClimber implements IHillClimber { private int _numIter ; private Solution _currentSolution ; private IMoveManager _moveManager ; private IObjectiveFunction _objectiveFunction ; private ISolutionGenerator _solutionGenerator ; public HillClimber ( IObjectiveFunction objectiveFunction , IMoveManager moveManager , ISolutionGenerator solutionGenerator , int numIter ) { _moveManager = moveManager ; _objectiveFunction = objectiveFunction ; _solutionGenerator = solutionGenerator ; _numIter = numIter ; } public void startSearching ( Solution solution ) throws Exception { _currentSolution = solution ; int iter = 0 ; double bestVal = 0 ; while ( iter < _numIter ) { IMove [ ] moves = _moveManager . getAllMoves ( _currentSolution ) ; bestVal = solution . getObjectiveValue ( ) ; IMove best = null ; double val ; boolean noBetterMove = true ; for ( IMove m : moves ) { val = _objectiveFunction . evaluateMove ( _currentSolution , m ) ; if ( val < bestVal ) { best = m ; bestVal = val ; noBetterMove = false ; } } if ( noBetterMove ) { return ; } if ( best != null ) { _currentSolution = best . apply ( _currentSolution ) ; _currentSolution . setObjectiveValue ( bestVal ) ; } _objectiveFunction . reset ( ) ; iter ++ ; } } public void startRestartedSearching", "gt": "( int numRestarts ) throws Exception", "prediction": "( Solution solution ) throws Exception\n", "label": 1}
{"id": 9632, "input": "<s> package y ; public final class R2 { x . B .", "gt": "C a = null ;", "prediction": "B ;\n", "label": 0}
{"id": 13837, "input": "<s> package org . restlet . test . ext . oauth . app ; import org . restlet . data . MediaType ; import org . restlet . ext . oauth . OAuthUser ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . resource . ServerResource ; public class DummyResource extends ServerResource { @ Get public Representation getDummy ( ) { org . restlet . security . User u = getRequest ( ) . getClientInfo ( ) . getUser ( ) ; if ( u != null && u instanceof OAuthUser ) getContext ( ) . getAttributes ( ) . put ( \"testuser\" , u ) ; return new StringRepresentation ( \"TestSuccessful\" , MediaType . TEXT_HTML ) ; } @ Post ( \"form\" ) public Representation postDummy ( Representation input ) { org . restlet . security . User u = getRequest ( ) . getClientInfo ( ) . getUser ( ) ; if ( u", "gt": "!= null && u instanceof OAuthUser )", "prediction": "!= null && u instanceof OAuthUser )\n", "label": 1}
{"id": 8286, "input": "<s> package org . ofbiz . service . calendar ; public interface TemporalExpressionVisitor { void visit ( TemporalExpressions . DateRange expr ) ; void visit ( TemporalExpressions . DayInMonth expr ) ; void visit ( TemporalExpressions . DayOfMonthRange expr ) ; void visit ( TemporalExpressions . DayOfWeekRange expr ) ; void visit ( TemporalExpressions . Difference expr ) ; void visit ( TemporalExpressions . Frequency expr ) ; void visit ( TemporalExpressions . HourRange expr ) ; void visit ( TemporalExpressions . Intersection expr ) ; void visit ( TemporalExpressions . MinuteRange expr ) ; void visit ( TemporalExpressions", "gt": ". MonthRange expr ) ;", "prediction": ". HourRange expr ) ;\n", "label": 0}
{"id": 13838, "input": "<s> package org . restlet . test . connector ; import java . io . Serializable ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . LocalReference ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . representation . ObjectRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . ClientResource ; import org . restlet . test . RestletTestCase ; public class RiapTestCase extends RestletTestCase { private static final String DEFAULT_MSG = \"no-default\" ; private static final Serializable JUST_SOME_OBJ = new Serializable ( ) { private static final long serialVersionUID = 1L ; } ; private static final String ECHO_TEST_MSG = JUST_SOME_OBJ . toString ( ) ; private String buildAggregate ( String echoMessage , String echoCopy ) { return \"ORIGINAL: \" + echoMessage + \"\\n\" + \"ECHOCOPY: \" + echoCopy + \"\\n\" ; } public void testRiap ( ) throws Exception { final Component comp = new Component ( ) ; final Application localOnly = new Application ( ) { @ Override public Restlet createInboundRoot ( ) { return new Restlet ( getContext ( ) ) { @ Override public void handle ( Request request , Response response ) { final String selfBase = \"riap://application\" ; final Reference ref = request . getResourceRef ( ) ; final String remainder = ref . getRemainingPart ( ) ; Representation result = new StringRepresentation ( DEFAULT_MSG ) ; if ( remainder . startsWith ( \"/echo/\" ) ) { result = new StringRepresentation ( remainder . substring ( 6 ) ) ; } else if ( remainder . equals ( \"/object\" ) ) { result = new ObjectRepresentation < Serializable > ( JUST_SOME_OBJ ) ; } else if ( remainder . equals ( \"/null\" ) ) { result = new ObjectRepresentation < Serializable > ( ( Serializable ) null ) ; } else if ( remainder . equals ( \"/self-aggregated\" ) ) { final String echoMessage = ECHO_TEST_MSG ; final Reference echoRef = new LocalReference ( selfBase + \"/echo/\" + echoMessage ) ; String echoCopy = null ; try { ClientResource r = new ClientResource ( echoRef ) ; echoCopy = r . get ( ) . getText ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( \"Error getting internal reference to \" + echoRef ) ; } assertEquals ( \"expected echoMessage back\" , echoMessage , echoCopy ) ; result = new StringRepresentation ( buildAggregate ( echoMessage , echoCopy ) ) ; } response . setEntity ( result ) ; } } ; } } ; comp . getInternalRouter ( ) . attach ( \"/local\" , localOnly ) ; String localBase = \"riap://component/local\" ; Restlet dispatcher = comp . getContext ( ) . getClientDispatcher ( ) ; String msg = \"this%20message\" ; String echoURI = localBase + \"/echo/\" + msg ; Representation echoRep = dispatcher . handle ( new Request ( Method . GET , echoURI ) ) . getEntity ( ) ; assertEquals ( \"expected echo of uri-remainder\" , msg , echoRep . getText ( ) ) ; final String objURI = localBase + \"/object\" ; final Representation objRep = dispatcher . handle ( new Request ( Method . GET , objURI ) ) . getEntity ( ) ; assertSame ( \"expected specific test-object\" , JUST_SOME_OBJ , ( ( ObjectRepresentation < ? > ) objRep ) . getObject ( ) ) ; final String nullURI = localBase + \"/null\" ; final Representation nullRep = dispatcher . handle ( new Request ( Method . GET , nullURI ) ) . getEntity ( ) ; assertNull ( \"expected null\" , ( ( ObjectRepresentation < ? > ) nullRep ) . getObject ( ) ) ; final String anyURI = localBase + \"/whatever\" ; final Representation anyRep = dispatcher . handle ( new Request ( Method . GET , anyURI ) ) . getEntity ( ) ; assertEquals ( \"expected echo of uri-remainder\" , DEFAULT_MSG , anyRep . getText ( ) ) ; final String aggURI = localBase + \"/self-aggregated\" ; final Representation aggRep = dispatcher . handle ( new Request ( Method . GET , aggURI ) ) . getEntity ( ) ; final String", "gt": "expectedResult = buildAggregate ( ECHO_TEST_MSG , ECHO_TEST_MSG ) ;", "prediction": "echoURI = localBase + \"/echo/\" + msg ;\n", "label": 1}
{"id": 3737, "input": "<s> import java . lang . annotation . * ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy .", "gt": "RUNTIME ) public @ interface Ignore", "prediction": "RUNTIME ) public class Method\n", "label": 0}
{"id": 13845, "input": "<s> package org . eclipse . jface . viewers . deferred ; import org . eclipse . core . runtime . ListenerList ; public abstract class AbstractConcurrentModel implements IConcurrentModel { private ListenerList listeners = new ListenerList ( ) ; public void addListener ( IConcurrentModelListener listener ) { listeners . add ( listener ) ; } protected final void fireAdd ( Object [ ] added ) { Object [ ] listenerArray = listeners . getListeners ( ) ; for ( int i = 0 ; i < listenerArray . length ; i ++ ) { IConcurrentModelListener next = ( IConcurrentModelListener ) listenerArray [ i ] ; next . add ( added ) ; } } protected final void fireRemove ( Object [ ] removed ) { Object [ ] listenerArray = listeners . getListeners ( ) ; for ( int i = 0 ; i < listenerArray . length ; i ++ ) { IConcurrentModelListener next = ( IConcurrentModelListener ) listenerArray [ i ] ; next . remove ( removed ) ; } } protected final void fireUpdate ( Object [ ] updated ) { Object [ ] listenerArray = listeners . getListeners ( ) ; for ( int i = 0 ; i < listenerArray . length ; i ++ ) { IConcurrentModelListener next = ( IConcurrentModelListener ) listenerArray [ i ] ; next . update ( updated ) ; } } protected final IConcurrentModelListener [ ] getListeners ( ) { Object [ ] l = listeners . getListeners ( ) ; IConcurrentModelListener [ ] result = new IConcurrentModelListener [ l . length ] ; for", "gt": "( int i = 0 ;", "prediction": "( int i = 0 ;\n", "label": 1}
{"id": 1764, "input": "<s> package ar . com . fdvs . dj . test . subreport ; import java . util . Date ; import java . util . List ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class SubReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 , true ) . addGroups ( 2 ) . setMargins ( 5 , 5 , 20 , 20 ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setUseFullPageWidth ( true ) ; drb . addField ( \"statistics\" , List . class . getName ( ) ) ; drb . addField ( \"emptyStatistics\" , List . class . getName ( ) ) ; DynamicReport drHeaderSubreport = createHeaderSubreport ( ) ; drb . addSubreportInGroupHeader ( 2 , drHeaderSubreport , new ClassicLayoutManager ( ) , \"emptyStatistics\" , DJConstants . DATA_SOURCE_ORIGIN_FIELD , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) ; DynamicReport drFooterSubreport = createFooterSubreport ( ) ; drb . addSubreportInGroupHeader ( 2 , drFooterSubreport , new ClassicLayoutManager ( ) , \"statistics\" , DJConstants . DATA_SOURCE_ORIGIN_FIELD , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) ; drb . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; return dr ; } private DynamicReport createHeaderSubreport ( ) throws Exception { FastReportBuilder rb = new FastReportBuilder ( ) ; DynamicReport dr = rb . addColumn ( \"Date\" , \"date\" , Date . class . getName ( ) , 100 ) . addColumn ( \"Average\" , \"average\" , Float . class . getName ( ) , 50 ) . addColumn ( \"%\" , \"percentage\" , Float . class . getName ( ) , 50 ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 50 ) . setMargins ( 5 , 5 , 20 , 20 ) . setUseFullPageWidth ( true ) . setWhenNoDataNoPages ( ) . setTitle ( \"Header Subreport for this group\" ) . build ( ) ; return dr ; } private DynamicReport createFooterSubreport ( ) throws Exception { FastReportBuilder rb = new FastReportBuilder ( ) ; DynamicReport dr = rb . addColumn ( \"Area\" , \"name\" , String . class . getName ( ) , 100 ) . addColumn ( \"Average\" , \"average\" , Float . class . getName ( ) , 50 ) . addColumn ( \"%\" , \"percentage\" , Float . class . getName ( ) , 50 ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 50 ) . addGroups ( 1 ) . setMargins ( 5 , 5 , 20 , 20 ) . setUseFullPageWidth ( true ) . setTitle ( \"Footer Subreport for this group\" ) . build ( ) ; return dr ; } public static void main ( String [ ] args ) throws Exception { SubReportTest test = new SubReportTest ( ) ; test . testReport ( ) ; JasperViewer . viewReport", "gt": "( test . jp ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13852, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . feeds . ContentSource ; import org . apache . lucene . benchmark . byTask . feeds . DocData ; import org . apache . lucene . benchmark . byTask . utils . Config ; public class ConsumeContentSourceTask extends PerfTask { private ContentSource source ; private DocData dd = new DocData ( ) ; public ConsumeContentSourceTask ( PerfRunData runData ) { super ( runData ) ; Config config = runData . getConfig ( ) ; String sourceClass = config . get ( \"content.source\" , null ) ; if ( sourceClass == null ) { throw new IllegalArgumentException ( \"content.source must be defined\" ) ; } try { source = ( ContentSource ) Class . forName ( sourceClass ) . newInstance ( ) ; source . setConfig ( config ) ; source . resetInputs ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } protected String getLogMessage ( int recsCount ) { return \"read \" + recsCount + \" documents from the content source\" ; }", "gt": "public void close ( ) throws Exception", "prediction": "}\n", "label": 1}
{"id": 3776, "input": "<s> package org . ofbiz . base . util ; import org . apache . log4j . Level ; import org . apache . log4j . net . SyslogAppender ; @ SuppressWarnings ( \"serial\" ) public class NotifyLevel extends Level { public static final int NOTIFY_INT = FATAL_INT + 10000 ; public static final Level NOTIFY = new NotifyLevel ( NOTIFY_INT , \"NOTIFY\"", "gt": ", SyslogAppender . LOG_LOCAL0 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13861, "input": "<s> package org . gatein . common . util ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . TreeMap ; public class MapBuilder < M extends Map < K , V > , K , V > { private final M map ; private MapBuilder ( M map ) { if ( map == null ) { throw new IllegalArgumentException ( ) ; } this . map = map ; } public static < K , V > MapBuilder < HashMap < K , V > , K , V > hashMap ( ) { return new MapBuilder < HashMap < K , V > , K , V > ( new HashMap < K , V > ( ) ) ; } public static < K , V > MapBuilder < HashMap < K , V > , K , V > hashMap ( K k , V v ) { MapBuilder < HashMap < K , V > , K , V > builder = new MapBuilder < HashMap < K , V > , K , V > ( new HashMap < K , V > ( ) ) ; builder . put ( k , v ) ; return builder ; } public static < K , V > MapBuilder < TreeMap < K , V > , K , V > treeMap ( ) { return new MapBuilder < TreeMap < K , V > , K , V > ( new TreeMap < K , V > ( ) ) ; } public static < K , V > MapBuilder < TreeMap < K , V > , K , V > treeMap ( K k , V v ) { MapBuilder < TreeMap < K , V > , K , V > builder = new MapBuilder < TreeMap < K , V > , K , V > ( new TreeMap <", "gt": "K , V > ( ) ) ;", "prediction": "K , V > ( ) ) ;\n", "label": 1}
{"id": 3822, "input": "<s> package com . sun . tools . javac . code ; import java . util . * ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . jvm . Target ; import static com . sun . tools . javac . main . OptionName . * ; public enum Source { JDK1_2 ( \"1.2\" ) , JDK1_3 ( \"1.3\" ) , JDK1_4 ( \"1.4\" ) , JDK1_5 ( \"1.5\" ) , JDK1_6 ( \"1.6\" ) , JDK1_7 ( \"1.7\" ) ; private static final Context . Key < Source > sourceKey = new Context . Key < Source > ( ) ; public static Source instance ( Context context ) { Source instance = context . get ( sourceKey ) ; if ( instance == null ) { Options options = Options . instance ( context ) ; String sourceString = options . get ( SOURCE ) ; if ( sourceString != null ) instance = lookup ( sourceString ) ; if ( instance == null ) instance = DEFAULT ; context . put ( sourceKey , instance ) ; } return instance ; } public final String name ; private static Map < String , Source > tab = new HashMap < String , Source > ( ) ; static { for ( Source s : values ( ) ) { tab . put ( s . name , s ) ; } tab . put ( \"5\" , JDK1_5 ) ; tab . put ( \"6\" , JDK1_6 ) ; tab . put ( \"7\" , JDK1_7 ) ; } private Source ( String name ) { this . name = name ; } public static final Source DEFAULT = JDK1_7 ; public static Source lookup ( String name ) { return tab . get ( name ) ; } public Target requiredTarget ( ) { if ( this . compareTo ( JDK1_7 ) >= 0 ) return Target . JDK1_7 ; if ( this . compareTo ( JDK1_6 ) >= 0 ) return Target . JDK1_6 ; if ( this . compareTo ( JDK1_5 ) >= 0 ) return Target . JDK1_5 ; if ( this . compareTo ( JDK1_4 ) >= 0 ) return Target . JDK1_4 ; return Target . JDK1_1 ; } public boolean allowEncodingErrors ( ) { return compareTo ( JDK1_6 ) < 0 ; } public boolean allowAsserts ( ) { return compareTo ( JDK1_4 ) >= 0 ; } public boolean allowCovariantReturns ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowGenerics ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowDiamond ( ) { return compareTo ( JDK1_7 ) >= 0 ; } public boolean allowMulticatch ( ) { return compareTo ( JDK1_7 ) >= 0 ; } public boolean allowImprovedRethrowAnalysis ( ) { return compareTo ( JDK1_7 ) >= 0 ; } public boolean allowImprovedCatchAnalysis ( ) { return compareTo ( JDK1_7 ) >= 0 ; } public boolean allowEnums ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowForeach ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowStaticImport ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowBoxing ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowVarargs ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowAnnotations ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowHexFloats ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowAnonOuterThis ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean addBridges ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean enforceMandatoryWarnings ( ) { return compareTo ( JDK1_5 ) >= 0 ; } public boolean allowTryWithResources ( ) { return compareTo ( JDK1_7 ) >= 0 ; } public boolean allowTypeAnnotations ( ) { return compareTo (", "gt": "JDK1_7 ) >= 0 ;", "prediction": "JDK1_5 ) >= 0 ;\n", "label": 0}
{"id": 13862, "input": "<s> package org . restlet . example . ext . oauth ; import org . json . JSONObject ; public class FBUser { public String id ; public String name ; public String firstName ; public String lastName ; public String link ; public String hometown ; public String updated ; public FBUser ( JSONObject user ) { try { setUser ( user ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public String getFirstName ( ) { return firstName ; } public String getHometown ( ) { return hometown ; } public String getId ( ) { return id ; } public String getLastName ( ) { return lastName ; } public String getLink ( ) { return link ; } public String getName ( ) { return name ; } public String getUpdated ( ) { return updated ; } public void setFirstName ( String firstName ) { this . firstName = firstName ; } public void setHometown ( String hometown ) { this . hometown = hometown ; } public void setId ( String id ) { this . id = id ; } public void setLastName ( String lastName ) { this . lastName = lastName ; } public void setLink ( String link ) { this . link = link ; } public void setName ( String name ) { this . name = name ; } public void setUpdated ( String updated ) { this . updated = updated ; } public void setUser ( JSONObject user ) throws Exception { setId ( user . getString ( \"id\" ) ) ; try { setName ( user . getString ( \"name\" ) ) ; } catch ( Exception e ) { System . out . println ( \"could not set name\" ) ; } try { setFirstName ( user . getString ( \"first_name\" ) ) ; } catch ( Exception e ) { System . out . println ( \"could", "gt": "not set first name\" ) ;", "prediction": "not set first_name\" ) ;\n", "label": 1}
{"id": 7178, "input": "<s> package org . ofbiz . widget ; import org . ofbiz . base . util . Debug ; public class WidgetDataResourceWorker { public static final String module = WidgetDataResourceWorker . class . getName ( ) ; public static DataResourceWorkerInterface dataresourceWorker = null ; static { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; dataresourceWorker = ( DataResourceWorkerInterface ) loader . loadClass ( \"org.ofbiz.content.data.DataResourceWorker\" ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { Debug . logError ( e , \"Could not pre-initialize", "gt": "dynamically loaded class: \" , module ) ;", "prediction": "DataResourceWorker\" ) ;\n", "label": 0}
{"id": 13863, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . textsize . MeasurementItem ; import org . eclipse . rap . rwt . internal . textsize . MeasurementUtil ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; public class MeasurementUtil_Test extends TestCase { private static final String TEXT_TO_MEASURE = \" text \\\"to\\\" measure \" ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testCreateProbeParamObject ( ) { Probe probe = createProbe ( ) ; Object probeObject = MeasurementUtil . createProbeParamObject ( probe ) ; checkProbeObject ( probeObject , probe ) ; } public void testCreateItemParamObject ( ) { MeasurementItem item = createMeasurementItem ( ) ; Object itemObject = MeasurementUtil . createItemParamObject ( item ) ; checkItemObject ( itemObject , item ) ; } private void checkItemObject ( Object itemObject , MeasurementItem item ) { assertTrue ( itemObject instanceof Object [ ] ) ; Object [ ] itemObjectArray = ( Object [ ] ) itemObject ; assertEquals ( 8 , itemObjectArray . length ) ; assertEquals ( MeasurementUtil . getId ( item ) , itemObjectArray [ 0 ] ) ; String escaped = \" text \\\"to\\\" measure \" ; assertEquals ( escaped , itemObjectArray [ 1 ] ) ; assertTrue ( itemObjectArray [ 2 ] instanceof String [ ] ) ; String [ ] fontNameArray = ( String [ ] ) itemObjectArray [ 2 ] ; assertEquals ( 1 , fontNameArray . length ) ; assertEquals ( \"fontName\" , fontNameArray [ 0 ] ) ; assertEquals ( Integer . valueOf ( 1 ) , itemObjectArray [ 3 ] ) ; assertEquals ( Boolean . FALSE , itemObjectArray [ 4 ] ) ; assertEquals ( Boolean . FALSE , itemObjectArray [ 5 ] ) ; assertEquals ( Integer . valueOf ( 17 ) , itemObjectArray [ 6 ] ) ; assertEquals ( Boolean . FALSE , itemObjectArray [ 7 ] ) ; } private void checkProbeObject ( Object probeObject , Probe probe ) { assertTrue ( probeObject instanceof Object [ ] ) ; Object [ ] probeObjectArray = ( Object [ ] ) probeObject ; assertEquals ( 8 , probeObjectArray . length ) ; assertEquals ( MeasurementUtil . getId ( probe ) , probeObjectArray [ 0 ] ) ; assertEquals ( TEXT_TO_MEASURE , probeObjectArray [ 1 ] ) ; assertTrue ( probeObjectArray [ 2 ] instanceof String [ ] ) ; String [ ] fontNameArray = ( String [ ] ) probeObjectArray [ 2 ] ; assertEquals ( 1 , fontNameArray . length ) ; assertEquals ( \"fontName\" , fontNameArray [ 0 ] ) ; assertEquals ( Integer . valueOf ( 1 ) , probeObjectArray", "gt": "[ 3 ] ) ;", "prediction": "[ 3 ] ) ;\n", "label": 1}
{"id": 68, "input": "<s> package objects ; import java . awt . Color ; import java . awt . Component ; import java . awt . Cursor ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Image ; import java . awt . event . MouseEvent ; import java . awt . event . MouseMotionListener ; import javax . swing . BorderFactory ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JLabel ; import javax . swing . JTable ; import javax . swing . border . LineBorder ; import javax . swing . table . DefaultTableModel ; import javax . swing . table . TableCellRenderer ; import main . Application ; import main . Cache ; import objects . windows . MainWindow ; import servercontact . Server ; @ SuppressWarnings ( \"serial\" ) public class AlbumTable extends JTable { static final String [ ] columnNames = { \"\" , \"Album\" , \"albumID\" , \"coverArtID\" } ; static String ARTIST_ID = null ; static int IMAGE_SIZE = 75 ; public Object [ ] [ ] ALBUM_INFO = null ; public int albumCount = 0 ; public AlbumTable ( String incomingArtistID ) { ARTIST_ID = incomingArtistID ; Server . currentMusicDirectoryID = incomingArtistID ; initComponents ( ) ; addMouseMotionListener ( getMouseMotionListener ( ) ) ; } private MouseMotionListener getMouseMotionListener ( ) { MouseMotionListener theReturn = new MouseMotionListener ( ) { @ Override public void mouseMoved ( MouseEvent e ) { if ( columnAtPoint ( e . getPoint ( ) ) == 0 || columnAtPoint ( e . getPoint ( ) ) == 1 ) { setCursor ( new Cursor ( Cursor . HAND_CURSOR ) ) ; } else { setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; } } @ Override public void mouseDragged ( MouseEvent e ) { } } ; return theReturn ; } private void initComponents ( ) { Image [ ] albumImages ; String [ ] albumNames ; String [ ] albumCoverIDs ; String [ ] albumIDs ; if ( Cache . cacheExists ( ARTIST_ID ) ) { albumImages = Cache . getAlbumImages ( ARTIST_ID , IMAGE_SIZE ) ; albumNames = Cache . getAlbumNames ( ARTIST_ID ) ; albumCoverIDs = Cache . getAlbumCoverIDs ( ARTIST_ID ) ; albumIDs = Cache . getAlbumIDs ( ARTIST_ID ) ; } else { albumImages = Server . getAlbumImages ( ARTIST_ID , IMAGE_SIZE ) ; albumNames = Server . getAlbumNames ( ARTIST_ID ) ; albumCoverIDs = Server . getAlbumCoverIDs ( ARTIST_ID ) ; albumIDs = Server . getAlbumIDs ( ARTIST_ID ) ; } MainWindow . currentTableData = new String [ albumNames . length ] ; ALBUM_INFO = new Object [ albumNames . length ] [ columnNames . length ] ; albumCount = albumImages . length ; for ( int i = 0 ; i < albumNames . length ; i ++ ) { ALBUM_INFO [ i ] [ 0 ] = albumImages [ i ] ; ALBUM_INFO [ i ] [ 1 ] = albumNames [ i ] ; MainWindow . currentTableData [ i ] = albumIDs [ i ] ; ALBUM_INFO [ i ] [ 2 ] = albumIDs [ i ] ; ALBUM_INFO [ i ] [ 3 ] = albumCoverIDs [ i ] ; } DefaultTableModel model = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; model . setDataVector ( ALBUM_INFO , columnNames ) ; setModel ( model ) ; setFocusable ( true ) ; setBorder ( new LineBorder ( new Color ( 34 , 34 , 34 ) ) ) ; setBackground ( new Color ( 34 , 34 , 34 ) ) ; setRowHeight ( IMAGE_SIZE ) ; setShowGrid ( false ) ; setTableHeader ( null ) ; getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( new AlbumArtRenderer ( ) ) ; getColumnModel ( ) . getColumn ( 0 ) . setMinWidth ( IMAGE_SIZE ) ; getColumnModel ( ) . getColumn ( 0 ) . setMaxWidth ( IMAGE_SIZE ) ; getColumnModel ( ) . getColumn ( 0 ) . setWidth ( IMAGE_SIZE ) ; getColumnModel ( ) . getColumn ( 0 ) . setResizable ( false ) ; getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( new AlbumNameRenderer ( ) ) ; getColumnModel ( ) . getColumn ( 1 ) . setResizable ( true ) ; getColumnModel ( ) . getColumn ( 1 ) . setMinWidth ( 100 ) ; getColumnModel ( ) . getColumn ( 2 ) . setMinWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 2 ) . setMaxWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 2 ) . setWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 2 ) . setResizable ( false ) ; getColumnModel ( ) . getColumn ( 3 ) . setMinWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 3 ) . setPreferredWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 3 ) . setMaxWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 3 ) . setWidth ( 0 ) ; getColumnModel ( ) . getColumn ( 3 ) . setResizable ( false ) ; } class AlbumArtRenderer extends JLabel implements TableCellRenderer { public AlbumArtRenderer ( ) { super ( ) ; setHorizontalTextPosition ( RIGHT ) ; } @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int col ) { setIcon ( new ImageIcon ( ( Image ) value ) ) ; setText ( \"\" ) ; if ( isSelected ) { setBorder ( BorderFactory . createMatteBorder ( 0 , 0 , 1 , 0 , Application . AppColor_Border ) ) ; } setBorder ( BorderFactory . createEmptyBorder ( 0 , 0 , 2 , 0 ) ) ; return this ; } } class AlbumNameRenderer extends JLabel implements TableCellRenderer { Icon icon = new Icon ( ) { @ Override public void paintIcon ( Component c , Graphics g , int x , int y ) { } @ Override public int getIconWidth ( ) { return 10 ; } @ Override public int getIconHeight ( ) { return 1 ; } } ; public AlbumNameRenderer ( ) { } @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int col ) { setBackground ( Color . WHITE ) ; if ( hasFocus || isSelected ) { setBackground (", "gt": "Application . AppColor_SelBgndClr ) ;", "prediction": "Color . BLACK ) ;\n", "label": 0}
{"id": 13873, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . io . core . messages . Command ; import org . fuzzydb . io . core . messages . Loggable ; @ SuppressWarnings ( \"serial\" ) public class BeginAndCommitCmd extends BeginTransactionCmd implements Loggable { private BeginAndCommitCmd ( ) { super ( 0 , 0 , 0 , null ) ; } public BeginAndCommitCmd ( int storeId , int cid", "gt": ", int tid , Command payload )", "prediction": ")\n", "label": 1}
{"id": 6851, "input": "<s> import java . util . * ; class WhereCaptured { < T > void m ( List < T > l1 , List < T > l2 ) { }", "gt": "void test ( List < ? super WhereCaptured > list )", "prediction": "}\n", "label": 0}
{"id": 13874, "input": "<s> package org . nuxeo . ecm . automation . core . operations . users ; import java . util . Set ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . automation . features . PrincipalHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . security . PermissionProvider ; import org . nuxeo . ecm . platform . usermanager . UserManager ; @ Operation ( id = GetDocumentUsersAndGroups . ID , category = Constants . CAT_USERS_GROUPS , label = \"Get Users and Groups\" , description = \"\" + \"Fetch the users and groups that have a given permission \" + \"on the input document and then set them in the context under the \" + \"given key variable name. The operation returns the input \" + \"document. You can later use the list of identifiers set by this \" + \"operation on the context from another operation. The 'key' \" + \"argument represents the variable name and the 'permission' argument \" + \"the permission to check. If the 'ignore groups' argument is false \" + \"then groups will be part of the result. If the 'resolve groups' \" + \"argument is true then groups are recursively resolved, adding \" + \"user members of these groups in place of them. Be <b>warned</b> \" + \"that this may be a very consuming operation. If the 'prefix \" + \"identifiers' argument is true, then user identifiers are \" + \"prefixed by 'user:' and groups identifiers are prefixed by 'group:'.\" ) public class GetDocumentUsersAndGroups { public static final String ID = \"Document.GetUsersAndGroups\" ; @ Context protected PermissionProvider permissionProvider ; @ Context protected UserManager umgr ; @ Context protected OperationContext ctx ; @ Param ( name", "gt": "= \"permission\" ) protected String permission ;", "prediction": "= \"key\" , required = true ) protected String key ;\n", "label": 1}
{"id": 3557, "input": "<s> import java . util . List ; class T6763518 { @ SuppressWarnings ( \"rawtypes\" ) List l1 ; void m ( @ SuppressWarnings (", "gt": "\"rawtypes\" ) List l2 )", "prediction": "\"rawtypes\" ) List l2 )\n", "label": 0}
{"id": 13875, "input": "<s> package org . jscsi . target . connection . phase ; import java . io . IOException ; import java . security . DigestException ; import javax . naming . OperationNotSupportedException ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . target . connection . Connection ; import org . jscsi . target . settings . SettingsException ; public abstract class TargetPhase { protected Connection connection ; public TargetPhase ( Connection connection ) { this . connection = connection ; } public boolean execute ( ProtocolDataUnit pdu ) throws OperationNotSupportedException , IOException , InterruptedException , InternetSCSIException , DigestException , SettingsException {", "gt": "throw new OperationNotSupportedException ( ) ;", "prediction": "final BasicHeaderSegment bhs = pdu . getBasicHeaderSegment ( ) ;\n", "label": 1}
{"id": 3598, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . LimitsAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ;", "gt": "public class LimitsAttributeImpl extends MinimalEObjectImpl . Container implements LimitsAttribute", "prediction": "import org . jjflyboy . tjpeditor . project . Tests ;\n", "label": 0}
{"id": 13881, "input": "<s> package org . apache . lucene . queryParser . core . nodes ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . List ; import java . util . Map ; import java . util . ResourceBundle ; import org . apache . lucene . messages . NLS ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; public abstract class QueryNodeImpl implements QueryNode , Cloneable { private static final long serialVersionUID = 5569870883474845989L ; public static final String PLAINTEXT_FIELD_NAME = \"_plain\" ; private boolean isLeaf = true ; private Hashtable < CharSequence , Object > tags = new Hashtable < CharSequence , Object > ( ) ; private List < QueryNode > clauses = null ; protected void allocate ( ) { if ( this . clauses == null ) { this . clauses = new ArrayList < QueryNode > ( ) ; } else { this . clauses . clear ( ) ; } } public final void add ( QueryNode child ) { if ( isLeaf ( ) || this . clauses == null || child == null ) { throw new IllegalArgumentException ( NLS . getLocalizedMessage ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED ) ) ; } this . clauses . add ( child ) ; ( ( QueryNodeImpl ) child ) . setParent ( this ) ; } public final void add ( List < QueryNode > children ) { if ( isLeaf ( ) || this . clauses == null ) { throw new IllegalArgumentException ( NLS . getLocalizedMessage ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED ) ) ; } for ( QueryNode child : getChildren ( ) ) { add ( child ) ; } } public boolean isLeaf ( ) { return this . isLeaf ; } public final void set ( List < QueryNode > children ) { if ( isLeaf ( ) || this . clauses == null ) { ResourceBundle bundle = ResourceBundle . getBundle ( \"org.apache.lucene.queryParser.messages.QueryParserMessages\" ) ; String message = bundle . getObject ( \"Q0008E.NODE_ACTION_NOT_SUPPORTED\" ) . toString ( ) ; throw new IllegalArgumentException ( message ) ; } for ( QueryNode child : children ) { ( ( QueryNodeImpl ) child ) . setParent ( null ) ; } allocate ( ) ; for ( QueryNode child : children ) { add ( child ) ; } } public QueryNode cloneTree ( ) throws CloneNotSupportedException { QueryNodeImpl clone = ( QueryNodeImpl ) super . clone ( ) ; clone . isLeaf = this . isLeaf ; clone . tags = new Hashtable < CharSequence , Object > ( ) ; if ( this . clauses != null ) { List < QueryNode > localClauses = new ArrayList < QueryNode > ( ) ; for ( QueryNode clause : this . clauses ) { localClauses . add", "gt": "( clause . cloneTree ( ) ) ;", "prediction": "( clause ) ;\n", "label": 1}
{"id": 1403, "input": "<s> abstract class A implements I { @ Deprecated public void iDep_aDep_bDep ( ) { } @ Deprecated public void iDep_aDep_bUnd ( ) { } @ Deprecated public void iDep_aDep_bInh ( ) { } public void iDep_aUnd_bDep ( ) { } public void iDep_aUnd_bUnd ( ) { } public void iDep_aUnd_bInh ( ) { } @", "gt": "Deprecated public void iUnd_aDep_bDep ( )", "prediction": "Deprecated public void iDep_aUnd_bInh ( )\n", "label": 0}
{"id": 13882, "input": "<s> package com . codeslap . persistence ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; class RawQueryImpl implements RawQuery { private final SQLiteDatabase mDb ; private final DatabaseSpec mDatabaseSpec ; RawQueryImpl ( Context context , String name , String specId ) { mDatabaseSpec = PersistenceConfig . getDatabaseSpec ( specId ) ; SqliteDb helper = SqliteDb . getInstance ( context , name , mDatabaseSpec ) ; mDb = helper . getDatabase ( ) ; } @ Override public Cursor findAll ( Class < ? > theClass ) { return mDb . query ( SQLHelper . getTableName ( theClass ) , null , null , null , null , null , null , null ) ; } @ Override public Cursor findAll ( Object where ) { return findAll ( where , null ) ; } @ Override public Cursor findAll ( Object where , Constraint constraint ) { return SQLHelper . getCursorFindAllWhere ( mDb , where . getClass ( ) , where , null , constraint , mDatabaseSpec ) ; } @ Override public Cursor findAll ( Object", "gt": "where , Object attachedTo )", "prediction": "... where )\n", "label": 1}
{"id": 9375, "input": "<s> package org . ofbiz . minilang ; import java . util . Map ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; import org . ofbiz . service . engine . GenericAsyncEngine ; public final class SimpleServiceEngine extends GenericAsyncEngine { public SimpleServiceEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } @ Override public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { Map < String , Object > result = serviceInvoker ( localName , modelService , context ) ; if ( result == null ) throw new GenericServiceException ( \"Service did not return expected result\" ) ; return result ; } @ Override public void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { runSync ( localName , modelService , context ) ; } private Map < String , Object > serviceInvoker ( String localName , ModelService modelService , Map < String , ? extends Object > context ) throws GenericServiceException { DispatchContext dctx = dispatcher . getLocalContext ( localName ) ; if ( modelService . location == null || modelService . invoke == null ) throw new GenericServiceException ( \"Cannot locate service to invoke (location or invoke name missing)\" ) ; ClassLoader classLoader = null ; if ( dctx != null ) classLoader = dctx . getClassLoader ( ) ; try { return SimpleMethod . runSimpleService ( this . getLocation ( modelService ) , modelService .", "gt": "invoke , dctx , context , classLoader ) ;", "prediction": "invoke , context ) ;\n", "label": 0}
{"id": 13885, "input": "<s> package org . eclipse . rap . rwt . internal . theme . css ; import org . w3c . css . sac . * ; public class ConditionFactoryImpl implements ConditionFactory { private final CssFileReader reader ; public ConditionFactoryImpl ( CssFileReader reader ) { this . reader = reader ; } public AttributeCondition createClassCondition ( String namespaceURI , String value ) throws CSSException { return new ClassConditionImpl ( value ) ; } public AttributeCondition createPseudoClassCondition ( String namespaceURI , String value ) throws CSSException { return new PseudoClassConditionImpl ( value ) ; } public AttributeCondition createAttributeCondition ( String localName , String namespaceURI , boolean specified , String value ) throws CSSException { return new AttributeConditionImpl ( localName , value , specified ) ; } public AttributeCondition createOneOfAttributeCondition ( String localName , String namespaceURI , boolean specified , String value ) throws CSSException { return new OneOfAttributeCondition ( localName , value , specified ) ; } public CombinatorCondition createAndCondition ( Condition first , Condition second ) throws CSSException { return new AndConditionImpl ( first , second ) ; } public LangCondition createLangCondition ( String lang ) throws CSSException { String mesg = \"Lang conditions not supported by RAP - ignored\" ; reader . addProblem ( new CSSException ( mesg ) ) ; return new NullLangCondition ( ) ; } public AttributeCondition createIdCondition ( String value ) throws CSSException { String mesg = \"Id conditions not supported by RAP - ignored\" ; reader . addProblem ( new CSSException ( mesg ) ) ; return new NullAttributeCondition ( ) ; } public AttributeCondition createBeginHyphenAttributeCondition ( String localName , String namespaceURI , boolean specified , String value ) throws CSSException { String mesg = \"Begin hyphen attribute conditions not supported by RAP - ignored\" ; reader . addProblem ( new CSSException ( mesg ) ) ; return new NullAttributeCondition ( ) ; } public CombinatorCondition createOrCondition ( Condition first , Condition second ) throws CSSException { throw", "gt": "new CSSException ( \"Or conditions not supported by CSS2\" ) ;", "prediction": "new CSSException ( \"Or conditions not supported by RAP - ignored\" ) ;\n", "label": 1}
{"id": 5575, "input": "<s> package com . sun . tools . javac . util ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . AbstractCollection ; import java . util . ListIterator ; import java . util . NoSuchElementException ; public class List < A > extends AbstractCollection < A > implements java . util . List < A > { public A head ; public List < A > tail ; List ( A head , List < A > tail ) { this . tail = tail ; this . head = head ; } @ SuppressWarnings ( \"unchecked\" ) public static < A > List < A > nil ( ) { return ( List < A > ) EMPTY_LIST ; } private static List < ? > EMPTY_LIST = new List < Object > ( null , null ) { public List < Object > setTail ( List < Object > tail ) { throw new UnsupportedOperationException ( ) ; } public boolean isEmpty ( ) { return true ; } } ; public static < A > List < A > of ( A x1 ) { return new List < A > ( x1 , List . < A > nil ( ) ) ; } public static < A > List < A > of ( A x1 , A x2 ) { return new List < A > ( x1 , of ( x2 ) ) ; } public static < A > List < A > of ( A x1 , A x2 , A x3 ) { return new List < A > ( x1 , of ( x2 , x3 ) ) ; } @ SuppressWarnings ( { \"varargs\" , \"unchecked\" } ) public static < A > List < A > of ( A x1 , A x2 , A x3 , A ... rest ) { return new List < A > ( x1 , new List < A > ( x2 , new List < A > ( x3 , from ( rest ) ) ) ) ; } public static < A > List < A > from ( A [ ] array ) { List < A > xs = nil ( ) ; if ( array != null ) for ( int i = array . length - 1 ; i >= 0 ; i -- ) xs = new List < A > ( array [ i ] , xs ) ; return xs ; } @ Deprecated public static < A > List < A > fill ( int len , A init ) { List < A > l = nil ( ) ; for ( int i = 0 ; i < len ; i ++ ) l = new List < A > ( init , l ) ; return l ; } @ Override public boolean isEmpty ( ) { return tail == null ; } public boolean nonEmpty ( ) { return tail != null ; } public int length ( ) { List < A > l = this ; int len = 0 ; while ( l . tail != null ) { l = l . tail ; len ++ ; } return len ; } @ Override public int size ( ) { return length ( ) ; } public List < A > setTail ( List < A > tail ) { this . tail = tail ; return tail ; } public List < A > prepend ( A x ) { return new List < A > ( x , this ) ; } public List < A > prependList ( List < A > xs ) { if ( this . isEmpty ( ) ) return xs ; if ( xs . isEmpty ( ) ) return this ; if ( xs . tail . isEmpty ( ) ) return prepend ( xs . head ) ; List < A > result = this ; List < A > rev = xs . reverse ( ) ; Assert . check ( rev != xs ) ; while ( rev . nonEmpty ( ) ) { List < A > h = rev ; rev = rev . tail ; h . setTail ( result ) ; result = h ; } return result ; } public List < A > reverse ( ) { if ( isEmpty ( ) || tail . isEmpty ( ) ) return this ; List < A > rev = nil ( ) ; for ( List < A > l = this ; l . nonEmpty ( ) ; l = l . tail ) rev = new List < A > ( l . head , rev ) ; return rev ; } public List < A > append ( A x ) { return of ( x ) . prependList ( this ) ; } public List < A > appendList ( List < A > x ) { return x . prependList ( this ) ; } public List < A > appendList ( ListBuffer < A > x ) { return appendList ( x . toList ( ) ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public < T > T [ ] toArray ( T [ ] vec ) { int i = 0 ; List < A > l = this ; Object [ ] dest = vec ; while ( l . nonEmpty ( ) && i < vec . length ) { dest [ i ] = l . head ; l = l . tail ; i ++ ; } if ( l . isEmpty ( ) ) { if ( i < vec . length )", "gt": "vec [ i ] = null ;", "prediction": "\n", "label": 0}
{"id": 13886, "input": "<s> package org . apache . lucene . analysis . tokenattributes ; import org . apache . lucene . util . Attribute ; public interface OffsetAttribute extends Attribute { public int startOffset ( ) ; public void setOffset ( int startOffset , int endOffset ) ; public", "gt": "int endOffset ( ) ;", "prediction": "int length ( ) ;\n", "label": 1}
{"id": 2712, "input": "<s> import java . util . * ; import com . sun . source . tree . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; public class CheckClass extends Checker { public static void main ( String ... args ) throws Exception { Checker chk = new CheckClass ( ) ; chk . check ( \"TestClass.java\" ) ; } @ Override protected boolean checkLocal ( Scope s , String ref ) { TypeElement te = s", "gt": ". getEnclosingClass ( ) ;", "prediction": ". getTypeElement ( ref ) ;\n", "label": 0}
{"id": 13888, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . Vector ; public class TestElement implements Cloneable { TestModel fModel ; TestElement fContainer ; String fSomeName ; String fId ; Vector fChildren = new Vector ( ) ; boolean fIsDeleted = false ; public static final String P_SOMENAME = \"org.eclipse.jface.viewertest.name\" ; public static final String P_COLUMN_1 = \"org.eclipse.jface.viewertest.column1\" ; public TestElement ( TestModel model , TestElement container ) { fModel = model ; fContainer = container ; int p = 0 ; TestElement lastSibling = container . getLastChild ( ) ; if ( lastSibling != null ) { p = lastSibling . childId ( ) + 1 ; } fId = container . getID ( ) + \"-\" + p ; } public TestElement ( TestModel model , TestElement container , int level , int position ) { fModel = model ; fContainer = container ; if ( container != null ) fId = container . getID ( ) + \"-\" + position ; else fId = Integer . toString ( position ) ; fSomeName = \"name-\" + position ; if ( level < model . getNumLevels ( ) ) { for ( int i = 0 ; i < model . getNumChildren ( ) ; i ++ ) { fChildren . add ( new TestElement ( model , this , level + 1 , i ) ) ; } } } public TestElement addChild ( int event ) { TestElement element = new TestElement ( fModel , this ) ; element . fSomeName = \"added\" ; addChild ( element , new TestModelChange ( event , this , element ) ) ; return element ; } public TestElement addChild ( TestElement element , TestModelChange change ) { fChildren . add ( element ) ; fModel . fireModelChanged ( change ) ; return element ; } public void addChildren ( TestElement [ ] elements , TestModelChange change ) { for ( int i = 0 ; i < elements . length ; i ++ ) fChildren . add ( elements [ i ] ) ; fModel . fireModelChanged ( change ) ; } public TestElement [ ] addChildren ( int event ) { TestElement elements [ ] = new TestElement [ ] { new TestElement ( fModel , this ) , new TestElement ( fModel , this ) } ; elements [ 0 ] . fSomeName = \"added1\" ; elements [ 1 ] . fSomeName = \"added2\" ; elements [ 1 ] . fId += \"madeUnique\" ; addChildren ( elements , new TestModelChange ( event , this , elements ) ) ; return elements ; } public TestElement basicAddChild ( ) { TestElement element = new TestElement ( fModel , this ) ; element . fSomeName = \"added\" ; fChildren . add ( element ) ; return element ; } public void basicDeleteChild ( TestElement element ) { fChildren . remove ( element ) ; element . fIsDeleted = true ; } private int childId ( ) { String id = fId . substring ( fId . lastIndexOf ( \"-\" ) + 1 ) ; return Integer . parseInt ( id ) ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new Error ( ) ; } } static public TestElement createModel ( int numLevels , int numChildren ) { return new TestElement ( new TestModel ( numLevels , numChildren ) , null , 0 , 0 ) ; } public void", "gt": "deleteChild ( TestElement element )", "prediction": "addChild ( TestElement element , TestModelChange change )\n", "label": 1}
{"id": 3768, "input": "<s> class InconvertibleTypes { class Outer < S > { class Inner < T > { } } void m ( Outer < Integer > . Inner < Long > p ) { Object o = ( Outer < ? super", "gt": "Number > . Inner < Long > ) p ;", "prediction": "Integer > ) p ;\n", "label": 0}
{"id": 13889, "input": "<s> package org . eclipse . swt . dnd ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . ImageData ; public class ImageTransfer extends ByteArrayTransfer { private static final String TYPE_NAME = \"image\" ; private static final int TYPE_ID = registerType ( TYPE_NAME ) ; private ImageTransfer ( ) { } public static ImageTransfer getInstance ( ) { return SingletonUtil . getSessionInstance ( ImageTransfer . class ) ; } public void javaToNative ( Object object , TransferData transferData ) { if ( ! checkImage ( object ) || ! isSupportedType ( transferData ) ) { DND . error ( DND . ERROR_INVALID_DATA ) ; } ImageData imageData = ( ImageData ) object ; if ( imageData == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; transferData . data = imageData ; transferData . result = 1 ; } public Object nativeToJava ( TransferData transferData ) { if ( ! isSupportedType ( transferData ) || transferData . data == null ) return null ; ImageData imageData = ( ImageData ) transferData . data ; Object result = imageData . clone ( ) ; return result ; } protected int", "gt": "[ ] getTypeIds ( )", "prediction": "registerType ( TYPE_NAME )\n", "label": 1}
{"id": 2715, "input": "<s> package org . ofbiz . entity . condition ; import java . util . Iterator ; import javolution . context . ObjectFactory ; @ SuppressWarnings ( \"serial\" ) public class EntityConditionList < T extends EntityCondition > extends EntityConditionListBase < T > { public static final String module = EntityConditionList . class . getName ( ) ; protected static final ObjectFactory < EntityConditionList < EntityCondition > > entityConditionListFactory = new ObjectFactory < EntityConditionList < EntityCondition > > ( ) { @ Override protected EntityConditionList < EntityCondition > create ( ) { return new EntityConditionList", "gt": "< EntityCondition > ( ) ;", "prediction": "Impl ( ) ;\n", "label": 0}
{"id": 13898, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import java . io . Serializable ; import java . util . ArrayList ; public class ContactsRepresentation implements Serializable { private static final long serialVersionUID = 1L ; private ArrayList < ContactRepresentation > contacts ; public ContactsRepresentation ( ) { this . contacts = new ArrayList < ContactRepresentation > ( ) ; } public ArrayList < ContactRepresentation > getContacts ( ) { return contacts ; }", "gt": "public void setContacts ( ArrayList < ContactRepresentation > contacts )", "prediction": "public ContactRepresentation getContact ( )\n", "label": 1}
{"id": 5100, "input": "<s> package org . parboiled . examples . java ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . Parboiled ; import org . parboiled . parserunners . ReportingParseRunner ; import org . parboiled . Rule ; import org . parboiled . support . ParsingResult ; import java . io . * ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . List ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( args ) ; } @ SuppressWarnings ( { \"ConstantConditions\" } ) protected void run ( String [ ] args ) { System . out . println ( \"parboiled Java parser, performance test\" ) ; System . out . println ( \"---------------------------------------\" ) ; System . out . print ( \"Creating parser... :\" ) ; long start = System . currentTimeMillis ( ) ; Parboiled . createParser ( JavaParser . class ) ; time ( start ) ; System . out . print ( \"Creating 100 more parser instances... :\" ) ; JavaParser parser = null ; start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { parser = Parboiled . createParser ( JavaParser . class ) ; } time ( start ) ; System . out . print ( \"Creating 100 more parser instances using BaseParser.newInstance() ... :\" ) ; start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { parser = parser . newInstance ( ) ; } time ( start ) ; start = System . currentTimeMillis ( ) ; File baseDir = args . length == 1 ? new File ( args [ 0 ] ) : null ; if ( baseDir == null || ! baseDir . exists ( ) ) baseDir = new File ( \".\" ) ; System . out . printf ( \"Retrieving file list from '%s'\" , baseDir ) ; List < File > sources = recursiveGetAllJavaSources ( baseDir , new ArrayList < File > ( ) ) ; time ( start ) ; System . out . printf ( \"Parsing all %s given java sources\" , sources . size ( ) ) ; Rule rootRule = parser . CompilationUnit ( ) . suppressNode ( ) ; start = System . currentTimeMillis ( ) ; long lines = 0 , characters = 0 ; for ( File sourceFile : sources ) { long dontCountStart = System . currentTimeMillis ( ) ; String sourceText = readAllText ( sourceFile ) ; start += System . currentTimeMillis ( ) - dontCountStart ; ParsingResult < ? > result = null ; try { result = run ( rootRule , sourceText ) ; } catch ( Exception e ) { System . out . printf ( \"\\nException while parsing file '%s':\\n%s\" , sourceFile , e ) ; System . exit ( 1 ) ; } if ( ! result . matched ) { System . out . printf ( \"\\nParse error(s) in file '%s':\\n%s\" , sourceFile , printParseErrors ( result ) ) ; System . exit ( 1 ) ; } else { System . out . print ( '.' ) ; } lines += result . inputBuffer . getLineCount ( ) ; characters += sourceText . length ( ) ; } long time = time ( start ) ; System . out . println ( \"Parsing performance:\" ) ; System . out . printf ( \"    %6d Files -> %6.2f Files/sec\\n\" , sources . size ( ) , sources . size ( ) * 1000.0 / time ) ; System . out . printf ( \"    %6d Lines -> %6d Lines/sec\\n\" , lines , lines * 1000 / time ) ; System . out . printf ( \"    %6d Chars -> %6d Chars/sec\\n\" , characters , characters * 1000 / time ) ; } protected ParsingResult < ? > run ( Rule rootRule , String sourceText ) { return new ReportingParseRunner ( rootRule ) . run ( sourceText ) ; } private static long time ( long start ) { long end = System . currentTimeMillis ( ) ; System . out . printf ( \" %s ms\\n\" , end - start ) ; return end - start ; } private static final FileFilter fileFilter = new FileFilter ( ) { public boolean accept ( File file ) { return file . isDirectory ( ) || file . getName ( ) . endsWith ( \".java\" ) ; } } ; private static List < File > recursiveGetAllJavaSources ( File file , ArrayList < File > list ) { if ( file . isDirectory ( ) ) { for ( File f : file . listFiles ( fileFilter ) ) { recursiveGetAllJavaSources ( f , list ) ; } } else { list . add ( file ) ; } return list ; } public static String readAllText ( File file ) { checkArgNotNull ( file , \"file\" ) ; return readAllText ( file , Charset . forName ( \"UTF8\" ) ) ; } public static String readAllText ( File file , Charset charset ) { checkArgNotNull ( file , \"file\" ) ; checkArgNotNull ( charset , \"charset\" ) ; try { return readAllText", "gt": "( new FileInputStream ( file ) , charset ) ;", "prediction": "( file , charset ) ;\n", "label": 0}
{"id": 13902, "input": "<s> package org . eclipse . ui ; import java . util . Map ; import org . eclipse . core . commands . util . Tracing ; import org . eclipse . ui . internal . misc . Policy ; import org . eclipse . ui . services . IServiceLocator ; public abstract class AbstractSourceProvider implements ISourceProvider { protected static boolean DEBUG = Policy . DEBUG_SOURCES ; private ISourceProviderListener [ ] listeners = new ISourceProviderListener [ 7 ] ; private int listenerCount = 0 ; public final void addSourceProviderListener ( final ISourceProviderListener listener ) { if ( listener == null ) { throw new NullPointerException ( \"The listener cannot be null\" ) ; } if ( listenerCount == listeners . length ) { final ISourceProviderListener [ ] growArray = new ISourceProviderListener [ listeners . length + 4 ] ; System . arraycopy ( listeners , 0 , growArray , 0 , listeners . length ) ; listeners = growArray ; } listeners [ listenerCount ++ ] = listener ; } protected final void fireSourceChanged ( final int sourcePriority , final String sourceName , final Object sourceValue ) { for ( int i = 0 ; i < listenerCount ; i ++ ) { final ISourceProviderListener listener = listeners [ i ] ; listener . sourceChanged ( sourcePriority , sourceName , sourceValue ) ; } } protected final void fireSourceChanged ( final int sourcePriority , final Map sourceValuesByName ) { for ( int i = 0 ; i < listenerCount ; i ++ ) { final ISourceProviderListener listener = listeners [ i ] ; listener . sourceChanged ( sourcePriority , sourceValuesByName ) ; } } protected final void logDebuggingInfo ( final String message ) { if ( DEBUG && ( message != null ) ) { Tracing . printTrace ( \"SOURCES\" , message ) ; } } public final void removeSourceProviderListener ( final ISourceProviderListener listener ) { if ( listener == null ) { throw new NullPointerException ( \"The listener cannot be null\" ) ; } int emptyIndex = - 1 ; for ( int i = 0 ; i < listenerCount ; i ++ ) { if ( listeners [ i ] == listener ) { listeners [ i ] = null ; emptyIndex = i ; } }", "gt": "if ( emptyIndex != - 1 )", "prediction": "if ( emptyIndex == - 1 )\n", "label": 1}
{"id": 8318, "input": "<s> package com . matburt . mobileorg . OrgData ; import android . net . Uri ; public class OrgContract { interface EditsColumns { String ID = \"_id\" ; String TYPE = \"type\" ; String DATA_ID = \"data_id\" ; String TITLE = \"title\" ; String OLD_VALUE = \"old_value\" ; String NEW_VALUE = \"new_value\" ; } interface OrgDataColumns { String ID = \"_id\" ; String NAME = \"name\" ; String TODO = \"todo\" ; String PARENT_ID = \"parent_id\" ; String FILE_ID = \"file_id\" ; String LEVEL = \"level\" ; String PRIORITY = \"priority\" ; String TAGS = \"tags\" ; String PAYLOAD = \"payload\" ; } interface FilesColumns { String ID = \"_id\" ; String NAME = \"name\" ; String FILENAME = \"filename\" ; String CHECKSUM = \"checksum\" ; String NODE_ID = \"node_id\" ; } interface TodosColumns { String ID = \"_id\" ; String NAME = \"name\" ; String GROUP = \"todogroup\" ; String ISDONE = \"isdone\" ; } interface TagsColumns { String ID = \"_id\" ; String NAME = \"name\" ; String GROUP = \"taggroup\" ; } interface PrioritiesColumns { String ID = \"_id\" ; String NAME = \"name\" ; } public static final String CONTENT_AUTHORITY = \"com.matburt.mobileorg.OrgData.OrgProvider\" ; private static final Uri BASE_CONTENT_URI = Uri . parse ( \"content://\" + CONTENT_AUTHORITY ) ; private static final String PATH_ORGDATA = \"orgdata\" ; private static final String PATH_EDITS = \"edits\" ; private static final String PATH_TODOS = \"todos\" ; private static final String PATH_TAGS = \"tags\" ; private static final String PATH_PRIORITIES = \"priorities\" ; private static final String PATH_FILES = \"files\" ; private static final String PATH_SEARCH = \"search\" ; public static class OrgData implements OrgDataColumns { public static final Uri CONTENT_URI = BASE_CONTENT_URI . buildUpon ( ) . appendPath ( PATH_ORGDATA ) . build ( ) ; public static String getId ( Uri uri ) { return uri . getPathSegments ( ) . get ( 1 ) ; } public static Uri buildIdUri ( String id ) { return CONTENT_URI . buildUpon ( ) . appendPath ( id ) . build ( ) ; } public static Uri buildIdUri ( Long id ) { return buildIdUri ( id . toString ( ) ) ; } public static Uri buildChildrenUri ( String parentId ) { return CONTENT_URI . buildUpon ( ) . appendPath ( parentId ) . appendPath ( \"children\" ) . build ( ) ; } public static Uri buildChildrenUri ( long node_id ) { return buildChildrenUri ( Long . toString ( node_id ) ) ; } public static final String DEFAULT_SORT = ID + \" ASC\" ; public static final String NAME_SORT = NAME + \" ASC\" ; public static final String [ ] DEFAULT_COLUMNS = { ID , NAME , TODO , TAGS , PARENT_ID , PAYLOAD , LEVEL , PRIORITY , FILE_ID } ; } public static class Edits implements EditsColumns { public static final Uri CONTENT_URI = BASE_CONTENT_URI . buildUpon ( ) . appendPath ( PATH_EDITS ) . build ( ) ; public static final String [ ] DEFAULT_COLUMNS = { ID , DATA_ID , TITLE , TYPE , OLD_VALUE , NEW_VALUE } ; public static String getId ( Uri uri ) { return uri . getPathSegments ( ) . get ( 1 ) ; } public static Uri buildIdUri ( String id ) { return CONTENT_URI . buildUpon ( ) . appendPath ( id ) . build ( ) ; } public static Uri buildIdUri ( Long id ) { return buildIdUri ( id . toString ( ) ) ; } } public static class Files implements FilesColumns { public static final Uri CONTENT_URI = BASE_CONTENT_URI . buildUpon ( ) . appendPath ( PATH_FILES ) . build ( ) ; public static final String [ ] DEFAULT_COLUMNS = { ID , NAME , FILENAME , CHECKSUM , NODE_ID } ; public static final String DEFAULT_SORT = NAME + \" ASC\" ; public static String getId ( Uri uri ) { return uri . getLastPathSegment ( ) ; } public static String getFilename ( Uri uri ) { return uri . getPathSegments ( ) . get ( 1 ) ; } public static Uri buildFilenameUri ( String filename ) { return CONTENT_URI . buildUpon ( ) . appendPath ( filename ) .", "gt": "appendPath ( \"filename\" ) . build ( ) ;", "prediction": "build ( ) ;\n", "label": 0}
{"id": 13905, "input": "<s> package graphics . transitions ; import graphics . NES ; import java . awt . Color ; import java . awt . Graphics ; abstract public class HorizontalCurtain extends Transition { Color c = NES . BLACK ; int rHeight = 0 ; abstract public void updateHeight ( ) ; @ Override public void paint ( Graphics g ) { updateHeight ( ) ; g . drawImage ( buffer , 0 , 0 , null ) ; g . setColor ( c ) ; g . fillRect ( 0 , 0 ,", "gt": "WIDTH , rHeight ) ;", "prediction": "rHeight , rHeight ) ;\n", "label": 1}
{"id": 2542, "input": "<s> import java . awt . List ; import java", "gt": ". util . List ;", "prediction": ". awt . Color ;\n", "label": 0}
{"id": 13911, "input": "<s> package org . eclipse . ui . tests . internal ; import org . eclipse . ui . internal . util . Util ; import junit . framework . TestCase ; public class UtilTest extends TestCase { public UtilTest ( String name ) { super ( name ) ; } public void testBasicSplit ( ) { final String field = \"field1\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( field , result [ 0 ] ) ; } public void testBasic2Split ( ) { final String field = \"field1,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( \"field2\" , result [ 1 ] ) ; } public void testBasic3Split ( ) { final String field = \"field1,field3,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 3 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( \"field3\" , result [ 1 ] ) ; assertEquals ( \"field2\" , result [ 2 ] ) ; } public void testNothingSplit ( ) { final String field = \"\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( 0 , result [ 0 ] . length ( ) ) ; } public void testNothingUsefulSplit ( ) { final String field = \",\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 0 , result . length ) ; } public void testNothingUseful2Split ( ) { final String field = \",,\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 0 , result . length ) ; } public void testNothingUsefulSpaceSplit ( ) { final String field = \" ,\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( \" \" , result [ 0 ] ) ; } public void testNothingUsefulSpaceSplit2 ( ) { final String field = \", \" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( 0 , result [ 0 ] . length ( ) ) ; assertEquals ( \" \" , result [ 1 ] ) ; } public void testNothingUsefulSpaceSplit3 ( ) { final String field = \" , \" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( \" \" , result [ 0 ] ) ; assertEquals ( \" \" , result [ 1 ] ) ; } public void test2Delimiters ( ) { final String field = \"field1,,field3,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 4 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( 0 , result [ 1 ] . length ( ) ) ; assertEquals ( \"field3\" , result [ 2 ] ) ; assertEquals ( \"field2\" , result [ 3 ] ) ; } public void test3Delimiters ( ) { final String field = \"field1,,,field3,field2\" ; String [ ] result = Util", "gt": ". split ( field , ',' ) ;", "prediction": ". split ( field , ',' ) ;\n", "label": 1}
{"id": 751, "input": "<s> package org . jboss . arquillian . android . configuration ; public class AndroidExtensionConfiguration { private boolean skip ; private boolean force ; private String serialId ; private String avdName ; private String emulatorOptions ; private String sdSize = \"128M\" ; private long emulatorBootupTimeoutInSeconds = 120L ; private long emulatorShutdownTimeoutInSeconds = 60L ; private String home = System . getenv ( \"ANDROID_HOME\" ) ; private String apiLevel = \"10\" ; public String getHome ( ) { return home ; } public void setHome ( String home ) { this . home = home ; } public String getAvdName ( ) { return avdName ; } public void setAvdName ( String avdName ) { this . avdName = avdName ; } public String getSerialId ( ) { return serialId ; } public void setSerialId ( String serialId ) { this . serialId = serialId ; } public String getEmulatorOptions ( ) { return emulatorOptions ; } public void setEmulatorOptions ( String emulatorOptions ) { this", "gt": ". emulatorOptions = emulatorOptions ;", "prediction": ". emulatorOptions = emulatorOptions ;\n", "label": 0}
{"id": 13912, "input": "<s> package org . fuzzydb . util . geo ; public final class Datum { public static final Ellipsoid airy1830 = new Ellipsoid ( 6377563.396 , 6356256.910 ) ; public static final Ellipsoid airy1830Modified = new Ellipsoid ( 6377340.189 , 6356034.447 ) ; public static final TransverseMercator nationalGrid = new TransverseMercator ( 0.9996012717 , 49.0 , - 2.0 , - 100000 , 400000 , airy1830 ) ; public static final TransverseMercator irishNationalGrid = new TransverseMercator ( 1.000035 , 53.5", "gt": ", - 8.0 , 250000 , 200000 , airy1830Modified ) ;", "prediction": ", - 2.0 , - 100000 , 400000 , airy1830 ) ;\n", "label": 1}
{"id": 4374, "input": "<s> package Liza ; import org . bukkit . Server ;", "gt": "public interface LizaServer extends Server", "prediction": "import org . bukkit . Player ;\n", "label": 0}
{"id": 13921, "input": "<s> package io . beancounter . listener . facebook ; import org . apache . camel . EndpointInject ; import org . apache . camel . component . mock . MockEndpoint ; import org . apache . camel . testng . CamelTestSupport ; public class RoutingTest extends CamelTestSupport { @ EndpointInject ( uri = \"mock:getEndpoint\" ) private MockEndpoint getEndpoint ; @", "gt": "EndpointInject ( uri = \"mock:posttEndpoint\" ) private MockEndpoint postEndpoint ;", "prediction": "Test public void testGetEndpoint ( ) throws Exception\n", "label": 1}
{"id": 2165, "input": "<s> class T6680106 { class A0 { } class A1 < T extends T [ ] > { } class A2 < T extends S [ ] , S extends T [ ] > { } class A3 < T extends S [ ] , S extends U [ ] , U extends T [ ] > { } class A5 < T extends A0 & T [ ] > { } class A6 < T extends A0 & S [", "gt": "] , S extends A0 & T [ ] >", "prediction": "] >\n", "label": 0}
{"id": 13927, "input": "<s> package org . nuxeo . ecm . platform . io . test ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . io . DocumentTranslationMap ; import org . nuxeo . ecm . platform . io . api . IOResourceAdapter ; import org . nuxeo . ecm . platform . io . api . IOResources ; public class DummyIOResourceAdapter implements IOResourceAdapter { private static final long serialVersionUID = 5411716618665857482L ; private static final Log log = LogFactory . getLog ( DummyIOResourceAdapter . class ) ; public static final Map < String , String > backend = new HashMap < String , String > ( ) ; private Map < String , Serializable > properties ; public IOResources extractResources ( String repo , Collection < DocumentRef > sources ) { Map < String , String > extracted = new HashMap < String , String > ( ) ; for ( DocumentRef ref : sources ) { String key = ref . toString ( ) ; if ( backend . containsKey ( key ) ) { extracted . put ( key , backend . get ( key ) ) ; } } return new DummyIOResources ( extracted ) ; } public IOResources translateResources ( String repo , IOResources resources , DocumentTranslationMap map ) { if ( ! ( resources instanceof DummyIOResources ) ) { return null ; } Map < String , String > givenResources = ( ( DummyIOResources ) resources ) . getResources ( ) ; Map < String , String > translated = new HashMap < String , String > ( ) ; for ( Map . Entry < DocumentRef , DocumentRef > cor : map . getDocRefMap ( ) . entrySet ( ) ) { String oldKey = cor . getKey ( ) . toString ( ) ; if ( givenResources . containsKey ( oldKey ) ) { String newKey = cor . getValue ( ) . toString ( ) ; translated . put ( newKey , givenResources . get ( oldKey ) ) ; } } return new DummyIOResources ( translated ) ; } public void getResourcesAsXML (", "gt": "OutputStream out , IOResources resources )", "prediction": ")\n", "label": 1}
{"id": 8552, "input": "<s> package com . redhat . ceylon . compiler . loader ; import com . redhat . ceylon . compiler . loader . model . LazyClass ; import com . redhat . ceylon . compiler . loader . model . LazyClassAlias ; import com . redhat . ceylon . compiler . loader . model . LazyInterface ; import com . redhat . ceylon . compiler . loader . model . LazyInterfaceAlias ; import com . redhat . ceylon . compiler . loader . model . LazyMethod ; import com . redhat . ceylon . compiler . loader . model . LazyTypeAlias ; import com . redhat . ceylon . compiler . loader . model . LazyValue ; public interface ModelCompleter { void complete ( LazyClass lazyClass ) ; void completeTypeParameters ( LazyClass lazyClass ) ; void complete ( LazyInterface lazyInterface ) ; void completeTypeParameters ( LazyInterface lazyInterface ) ; void complete ( LazyValue lazyValue ) ; void complete ( LazyMethod lazyMethod ) ; void complete ( LazyClassAlias lazyClassAlias ) ; void completeTypeParameters ( LazyClassAlias lazyClassAlias ) ; void complete ( LazyInterfaceAlias lazyInterfaceAlias ) ; void", "gt": "completeTypeParameters ( LazyInterfaceAlias lazyInterfaceAlias ) ;", "prediction": "complete ( LazyMethodAlias lazyMethodAlias ) ;\n", "label": 0}
{"id": 13932, "input": "<s> package knowevo . myvizster . util ; import java . awt . event . ActionEvent ; import javax . swing . AbstractAction ; import knowevo . myvizster . Vizster ; public class ToggleAnimationAction extends AbstractAction { private Vizster vizster ; public ToggleAnimationAction ( Vizster vizster ) { this . vizster = vizster ; } public void actionPerformed ( ActionEvent arg0 ) { vizster .", "gt": "setAnimate ( ! vizster . isAnimate ( ) ) ;", "prediction": "toggle ( ) ;\n", "label": 1}
{"id": 7998, "input": "<s> package org . ofbiz . service ; import java . io . Serializable ; import java . util . List ; import java . util . Locale ; import javax . wsdl . Definition ; import javax . wsdl . Part ; import javax . wsdl . WSDLException ; import javax . xml . namespace . QName ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; @ SuppressWarnings ( \"serial\" ) public class ModelParam implements Serializable { public static final String module = ModelParam . class . getName ( ) ; public String name ; public String description ; public String type ; public String mode ; public String formLabel ; public String entityName ; public String fieldName ; public String stringMapPrefix ; public String stringListSuffix ; public List < ModelParamValidator > validators ; private String defaultValue = null ; public boolean optional = false ; public boolean overrideOptional = false ; public boolean formDisplay = true ; public boolean overrideFormDisplay = false ; public String allowHtml = null ; public boolean internal = false ; public ModelParam ( ) { } public ModelParam ( ModelParam param ) { this . name = param . name ; this . description = param . description ; this . type = param . type ; this . mode = param . mode ; this . formLabel = param . formLabel ; this . entityName = param . entityName ; this . fieldName = param . fieldName ; this . stringMapPrefix = param . stringMapPrefix ; this . stringListSuffix = param . stringListSuffix ; this . validators = param . validators ; if ( param . defaultValue != null ) this . setDefaultValue ( param . defaultValue ) ; this . optional = param . optional ; this . overrideOptional = param . overrideOptional ; this . formDisplay = param . formDisplay ; this . overrideFormDisplay = param . overrideFormDisplay ; this . allowHtml = param . allowHtml ; this . internal = param . internal ; } public void addValidator ( String className , String methodName , String failMessage ) { validators . add ( new ModelParamValidator ( className , methodName , failMessage , null , null ) ) ; } public void addValidator ( String className , String methodName , String failResource , String failProperty ) { validators . add ( new ModelParamValidator ( className , methodName , null , failResource , failProperty ) ) ; } public String getPrimaryFailMessage ( Locale locale ) { if ( UtilValidate . isNotEmpty ( validators ) ) { return validators . get ( 0 ) . getFailMessage ( locale ) ; } else { return null ; } } public String getShortDisplayDescription ( ) { return this . name + \"[\" + this . type + \"-\" + this . mode + \"]\" + ( optional ? \"\" : \"*\" ) ; } public String getName ( ) { return this . name ; } public String getType ( ) { return this . type ; } public String getMode ( ) { return this . mode ; } public String getEntityName ( ) { return this . entityName ; } public String getFieldName ( ) { return this . fieldName ; } public boolean getInternal ( ) { return this . internal ; } public boolean isIn ( ) { return \"IN\" . equals ( this . mode ) || \"INOUT\" . equals ( this . mode ) ; } public boolean isOut ( ) { return \"OUT\" . equals ( this . mode ) || \"INOUT\" . equals ( this . mode ) ; } public boolean isOptional ( ) { return this . optional ; } public Object getDefaultValue ( ) { Object defaultValueObj = null ; if ( this . type != null ) { try { defaultValueObj = ObjectType . simpleTypeConvert ( this . defaultValue , this . type , null , null , false ) ; } catch ( Exception e ) { Debug . logWarning ( e , \"Service attribute [\" + name + \"] default value could not be converted to type [\" + type + \"]: \" + e . toString ( ) , module ) ; } if ( defaultValueObj == null ) { defaultValueObj = this . defaultValue ; } } else { defaultValueObj = this . defaultValue ; } return defaultValueObj ; } public void setDefaultValue ( String defaultValue ) { this . defaultValue = defaultValue ; if ( this . defaultValue != null ) { this . optional = true ; } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Default value for attribute [\" + this . name + \"] set to [\" + this . defaultValue + \"]\" , module ) ; } public void copyDefaultValue ( ModelParam param ) { this . setDefaultValue ( param . defaultValue ) ; } public boolean equals ( ModelParam model ) { return model . name . equals ( this . name ) ; } @ Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( name ) . append ( \"::\" ) ; buf . append ( type ) . append ( \"::\" ) ; buf . append ( mode ) . append ( \"::\" ) ; buf .", "gt": "append ( formLabel ) . append ( \"::\" ) ;", "prediction": "append ( formLabel ) . append ( \"::\" ) ;\n", "label": 0}
{"id": 13940, "input": "<s> package org . apache . lucene . analysis . miscellaneous ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . Token ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import java . io . IOException ; import java . io . StringReader ; public class TestPrefixAwareTokenFilter extends BaseTokenStreamTestCase { public void test ( ) throws IOException { PrefixAwareTokenFilter ts ; ts = new PrefixAwareTokenFilter ( new SingleTokenTokenStream ( createToken ( \"a\" , 0 , 1 ) ) , new SingleTokenTokenStream ( createToken ( \"b\" , 0 , 1 ) ) ) ; assertTokenStreamContents ( ts , new String [ ] { \"a\" , \"b\" } , new int [ ] { 0 , 1 } , new int [ ] { 1 , 2 } ) ; ts = new PrefixAwareTokenFilter ( new SingleTokenTokenStream ( createToken ( \"^\" , 0 , 0 ) ) , new WhitespaceTokenizer ( new StringReader ( \"hello world\" ) ) ) ; ts = new PrefixAwareTokenFilter ( ts , new SingleTokenTokenStream ( createToken ( \"$\" , 0 , 0 ) ) ) ; assertTokenStreamContents ( ts , new String [ ] { \"^\" , \"hello\" , \"world\" , \"$\" } , new int [ ] { 0 , 0 , 6 , 11 } , new int [ ] {", "gt": "0 , 5 , 11 , 11 }", "prediction": "1 , 2 }\n", "label": 1}
{"id": 5301, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ListType ; import org . jjflyboy . tjpeditor . project . ListTypeValues ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ListTypeImpl extends ColumnAttributeImpl implements ListType { protected static final ListTypeValues TYPE_EDEFAULT = ListTypeValues . BULLETS ; protected ListTypeValues type = TYPE_EDEFAULT ; protected ListTypeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getListType ( ) ; } public ListTypeValues getType ( ) { return type ; } public void setType ( ListTypeValues newType ) { ListTypeValues oldType = type ; type = newType == null ? TYPE_EDEFAULT : newType ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . LIST_TYPE__TYPE , oldType , type ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . LIST_TYPE__TYPE : return getType ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . LIST_TYPE__TYPE : setType ( ( ListTypeValues ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . LIST_TYPE__TYPE : setType ( TYPE_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @", "gt": "Override public boolean eIsSet ( int featureID )", "prediction": "Override public void eSet ( int featureID , Object newValue )\n", "label": 0}
{"id": 13948, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import java . io . Serializable ; public class MailRepresentation implements Serializable { private static final long serialVersionUID = 1L ; private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public void setContent ( String content ) {", "gt": "this . content = content ;", "prediction": "this . content = content ;\n", "label": 1}
{"id": 7898, "input": "<s> package com . sun . tools . javac . api ; import java . util . Locale ; import java . util . MissingResourceException ; public interface Messages { void add ( String bundleName ) throws MissingResourceException ; String getLocalizedString ( Locale l", "gt": ", String key , Object ... args ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13963, "input": "<s> package org . apache . sqoop . hbase ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . hbase . client . Put ; import org . apache . hadoop . hbase . util . Bytes ; import com . cloudera . sqoop . hbase . PutTransformer ; public class ToStringPutTransformer extends PutTransformer { public static final Log LOG = LogFactory . getLog ( ToStringPutTransformer . class . getName ( ) ) ; private Map < String , byte [ ] > serializedFieldNames ; public ToStringPutTransformer ( ) { serializedFieldNames = new TreeMap < String , byte [ ] > ( ) ; } private byte [ ] getFieldNameBytes ( String fieldName ) { byte [ ] cachedName = serializedFieldNames . get ( fieldName ) ; if ( null != cachedName ) { return cachedName ; } byte [ ] nameBytes = Bytes . toBytes ( fieldName ) ; serializedFieldNames . put ( fieldName , nameBytes ) ; return nameBytes ; } @ Override public List < Put > getPutCommand ( Map < String , Object > fields ) throws IOException { String rowKeyCol = getRowKeyColumn ( ) ; String colFamily = getColumnFamily ( ) ; byte [ ] colFamilyBytes = Bytes . toBytes ( colFamily ) ; Object rowKey = fields . get ( rowKeyCol ) ; if ( null == rowKey ) { LOG . warn ( \"Could not insert row with null value for row-key column: \" + rowKeyCol ) ; return null ; } Put put = new Put ( Bytes . toBytes ( rowKey . toString ( ) ) ) ; for ( Map . Entry < String , Object > fieldEntry : fields . entrySet ( ) ) { String colName = fieldEntry . getKey ( ) ; if ( ! colName . equals ( rowKeyCol ) ) {", "gt": "Object val = fieldEntry . getValue ( ) ;", "prediction": "put . put ( colName , fieldEntry . getValue ( ) ) ;\n", "label": 1}
{"id": 8322, "input": "<s> public enum EnumSwitch4 { foo , bar , baz ; public static void main ( String [ ] args ) { EnumSwitch4 e = null ; try { switch ( e ) { default : break ; } throw new Error (", "gt": "\"failed to throw NullPointerException\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13965, "input": "<s> package br . org . archimedes . io . pdf ; import br . org . archimedes . model . Point ; import com . lowagie . text . Rectangle ; import com . lowagie . text . pdf . PdfContentByte ; public class PDFWriterHelper { private PdfContentByte cb ; private Rectangle documentArea ; private Point viewport ; private double zoom ; public PDFWriterHelper ( PdfContentByte cb , Rectangle documentArea ) { this . documentArea = documentArea ; this . cb = cb ; } public br . org . archimedes . model . Rectangle getModelArea ( ) { double x1 = - documentArea . getWidth ( ) / ( 2 * zoom ) ; double x2 = - x1 ; x1 += viewport . getX ( ) ; x2 += viewport . getX ( ) ; double y1 = documentArea . getHeight ( ) / ( 2 * zoom ) ; double y2 = - y1 ; y1 += viewport . getY ( ) ; y2 += viewport . getY ( ) ; return new br . org . archimedes . model . Rectangle ( x1 , y1 , x2 , y2 ) ; } public Point modelToDocument ( Point modelPoint ) { double x = modelPoint . getX ( )", "gt": "- viewport . getX ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5756, "input": "<s> package inheritance . conflict2 ; class A < T > { void f ( String s ) { } } class B < T > extends A < T > { void f ( T t ) { } } class C", "gt": "extends B < String >", "prediction": "< T >\n", "label": 0}
{"id": 13969, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class TestUnitReady extends AbstractCDB { public static final int OPERATION_CODE = 0x00 ; public TestUnitReady ( ) { super ( OPERATION_CODE ) ; } public TestUnitReady ( boolean linked , boolean normalACA ) { super ( OPERATION_CODE , linked , normalACA ) ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int operationCode = in . readUnsignedByte ( ) ; in . readInt ( ) ; super . setControl ( in . readUnsignedByte ( ) ) ; if ( operationCode != OPERATION_CODE ) { throw new IOException ( \"Invalid operation code: \" + Integer . toHexString ( operationCode ) ) ; } } public byte [ ] encode ( ) { ByteArrayOutputStream cdb", "gt": "= new ByteArrayOutputStream ( this . size ( ) ) ;", "prediction": "= new ByteArrayOutputStream ( ) ;\n", "label": 1}
{"id": 9696, "input": "<s> package org . ofbiz . entity . serialize ; import org . w3c . dom . Element ; public interface XmlSerializable < T > { public", "gt": "T deserialize ( Element element ) throws SerializeException ;", "prediction": "void serialize ( XmlWriter writer ) throws IOException ;\n", "label": 0}
{"id": 13980, "input": "<s> package org . nuxeo . ecm . platform . publisher . test ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . publisher . impl . finder . DefaultRootSectionsFinder ; public class SampleRootSectionFinder extends DefaultRootSectionsFinder { public SampleRootSectionFinder ( CoreSession userSession ) { super ( userSession ) ; } protected String buildQuery ( String path ) { String query = \"SELECT * FROM Document WHERE (\" ; int i = 0 ; for ( String type : getSectionTypes ( ) ) { query = query + \" ecm:primaryType = '\" + type + \"'\" ; i ++ ; if ( i < getSectionTypes ( ) . size ( ) ) { query = query + \" or \" ; } else { query = query + \" )\" ; } }", "gt": "query = query + \" order by ecm:path \" ;", "prediction": "return query ;\n", "label": 1}
{"id": 8488, "input": "<s> package com . redhat . ceylon . compiler . java . test ; import org . junit . runners . BlockJUnit4ClassRunner ; import org . junit . runners . model . InitializationError ; public class ConcurrentRunner extends BlockJUnit4ClassRunner { public", "gt": "ConcurrentRunner ( Class < ? > clase ) throws InitializationError", "prediction": "ConcurrentRunner ( )\n", "label": 0}
{"id": 13981, "input": "<s> package org . eclipse . jface . tests . viewers . interactive ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . window . ApplicationWindow ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; public class TestApplicationWindow extends ApplicationWindow { public static void main ( String [ ] args ) { new TestApplicationWindow ( ) . open ( ) ; } public TestApplicationWindow ( ) { super ( null ) ; setBlockOnOpen ( true ) ; addMenuBar ( ) ; } protected Point getInitialLocation ( Point initialSize ) { return new Point ( 30 , 30 ) ; } protected Point getInitialSize ( ) { return new Point ( 150 , 150 ) ; } protected Control createContents ( Composite parent ) { Control contents = super . createContents ( parent ) ; fillMenuBar ( ) ; return contents ; } private void fillMenuBar ( ) { MenuManager menuManager = getMenuBarManager ( ) ; MenuManager fileMenu = new MenuManager ( \"&File\" ) ; menuManager . add ( fileMenu ) ; Action loadAction = new Action ( \"&Save\" ) {", "gt": "public void run ( )", "prediction": "public void run ( )\n", "label": 1}
{"id": 8520, "input": "<s> public enum Enum3 { red , green , blue ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < 3 ; i ++ ) { Enum3 v = values ( ) [ i ] ; switch ( v ) { case red : if ( i == 0 ) continue ; break ; case", "gt": "green : if ( i == 1 ) continue ;", "prediction": "green : if ( i == 0 ) continue ;\n", "label": 0}
{"id": 13982, "input": "<s> package org . agoncal . book . javaee7 . chapter22 ; import javax . enterprise . inject . Produces ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; public class DatabaseProducer { @ Produces @ PersistenceContext ( unitName =", "gt": "\"chapter22PU\" ) private EntityManager em ;", "prediction": "\"DAO\" ) public EntityManager getPersistenceContext ( )\n", "label": 1}
{"id": 8624, "input": "<s> package org . parboiled . examples . java ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . parserunners . ReportingParseRunner ; import org . parboiled . support . ParsingResult ; import org . testng . annotations . Test ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; import static org . testng . Assert . assertEquals ; public class ReportingParseRunnerTest { @ Test public void testJavaError1 ( ) { String sourceWithErrors = \"package org.parboiled.examples;\\n\" + \"public class JavaTestSource {\\n\" + \"    @SuppressWarnings({\\\"UnnecessaryLocalVariable\\\", \\\"UnusedDeclaration\\\"})\\n\" + \"    public String method(int param) {\\n\" + \"        String name = toString(;\\n\" + \"        return name;\\n\" + \"    }\\n\" + \"}\" ; JavaParser parser = Parboiled . createParser ( JavaParser . class ) ; Rule rule = parser . CompilationUnit ( ) ; ParsingResult result = new ReportingParseRunner ( rule ) . run ( sourceWithErrors ) ; assertEquals ( result . parseErrors . size ( ) , 1 ) ; assertEquals ( printParseErrors ( result ) , \"\" + \"Invalid input ';', expected Spacing, Expression or ')' (line 5, pos 32):\\n\" + \"        String name = toString(;\\n\" + \"                        ", "gt": "      ^\\n\" ) ;", "prediction": ";\n", "label": 0}
{"id": 13985, "input": "<s> package org . eclipse . ui . internal . services ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . eclipse . ui . AbstractSourceProvider ; import org . eclipse . ui . ISourceProvider ; import org . eclipse . ui . services . IDisposable ; import org . eclipse . ui . services . IServiceLocator ; import org . eclipse . ui . services . ISourceProviderService ; public final class SourceProviderService implements ISourceProviderService , IDisposable { private final Map sourceProvidersByName = new HashMap ( ) ; private final Set sourceProviders = new HashSet ( ) ; private IServiceLocator locator ; public SourceProviderService ( final IServiceLocator locator ) { this . locator = locator ; } public final void dispose ( ) { final Iterator sourceProviderItr = sourceProviders . iterator ( ) ; while ( sourceProviderItr . hasNext ( ) ) { final ISourceProvider sourceProvider = ( ISourceProvider ) sourceProviderItr . next ( ) ; sourceProvider . dispose ( ) ; } sourceProviders . clear ( ) ; sourceProvidersByName . clear ( ) ; } public final ISourceProvider getSourceProvider ( final String sourceName ) { return ( ISourceProvider ) sourceProvidersByName . get ( sourceName ) ; } public final ISourceProvider [ ] getSourceProviders ( ) { return ( ISourceProvider [ ] ) sourceProviders . toArray ( new ISourceProvider [ sourceProviders . size ( ) ] ) ; } public final void registerProvider ( final ISourceProvider sourceProvider ) { if ( sourceProvider == null ) { throw new NullPointerException ( \"The source provider cannot be null\" ) ; } final String [ ] sourceNames = sourceProvider . getProvidedSourceNames ( ) ; for ( int i = 0 ; i < sourceNames . length ; i ++ ) { final String sourceName = sourceNames [ i ] ; sourceProvidersByName . put ( sourceName , sourceProvider ) ; } sourceProviders . add ( sourceProvider ) ; } public final void unregisterProvider ( ISourceProvider sourceProvider ) { if ( sourceProvider == null ) { throw new NullPointerException ( \"The source provider cannot be null\" ) ; } final String [ ] sourceNames = sourceProvider . getProvidedSourceNames ( ) ; for ( int i = 0 ; i < sourceNames . length ; i ++ ) { sourceProvidersByName . remove (", "gt": "sourceNames [ i ] ) ;", "prediction": "sourceNames [ i ] ) ;\n", "label": 1}
{"id": 4562, "input": "<s> import java . io . * ; import java . util . zip . * ; public class T4501660 { public static void main ( String [ ] args ) throws Exception { new T4501660 ( ) . run ( ) ; } public void run ( ) throws IOException { String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; String output = javap ( \"-classpath\" , testClasses , \"-help\" , \"T4501660\" ) ; verify ( output , \"-public\" , \"-protected\" , \"-private\" , \"class T4501660\" ) ; if ( errors > 0 ) throw new Error ( errors + \" found.\" ) ; } String javap ( String ... args ) { StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; int rc = com . sun . tools . javap . Main . run ( args , out ) ; if ( rc != 0 ) throw new Error ( \"javap failed. rc=\" + rc ) ; out . close ( ) ; System . out . println ( sw ) ; return sw . toString ( ) ; } void verify ( String output , String ... expects ) { for ( String expect : expects ) { if ( output . indexOf ( expect ) < 0 ) error ( expect + \" not found\" ) ; } } void error ( String msg ) { System", "gt": ". err . println ( msg ) ;", "prediction": ". out . println ( msg ) ;\n", "label": 0}
{"id": 13988, "input": "<s> package org . eclipse . rap . demo . databinding . nestedselection ; import java . util . * ; public class SimplePerson extends ModelObject { private String name = \"\" ; private String address = \"\" ; private String city = \"\" ; private String state = \"\" ; private final List orders = new LinkedList ( ) ; public SimplePerson ( final String name , final String address , final String city , final String state ) { this . name = name ; this . address = address ; this . city = city ; this . state = state ; int numOrders = ( int ) ( Math . random ( ) * 5 ) ; for ( int i = 0 ; i < numOrders ; ++ i ) { orders . add ( new SimpleOrder ( i , new Date ( ) ) ) ; } } public SimplePerson ( ) { } public String getAddress ( ) { return address ; } public void setAddress ( final String address ) { String old = this . address ; this . address = address ; firePropertyChange", "gt": "( \"address\" , old , address ) ;", "prediction": "( \"address\" , old , address ) ;\n", "label": 1}
{"id": 1435, "input": "<s> package api . forum . forumsections ; import java . util . List ; public class Forums { private String forumDescription ; private Number forumId ; private String forumName ; private Number lastAuthorId ; private String lastPostAuthorName ; private Number lastPostId ; private String lastTime ; private String lastTopic ; private Number lastTopicId ; private boolean locked ; private Number numPosts ; private Number numTopics ; private boolean read ; private List < String > specificRules ; private boolean sticky ; public String getForumDescription ( ) { return forumDescription ; } public Number getForumId ( ) { return forumId ; } public String getForumName ( ) { return forumName ; } public Number getLastAuthorId ( ) { return lastAuthorId ; } public String getLastPostAuthorName ( ) { return lastPostAuthorName ; } public Number getLastPostId ( ) { return lastPostId ; } public String getLastTime ( ) { return lastTime ; } public String getLastTopic ( ) { return lastTopic ; } public Number getLastTopicId ( ) { return lastTopicId ; } public boolean isLocked ( ) { return locked ; } public Number getNumPosts ( ) { return numPosts ; } public Number getNumTopics ( ) { return numTopics ; } public boolean isRead ( ) { return read ; } public List < String > getSpecificRules ( ) { return specificRules ; } public boolean isSticky ( ) { return sticky ; } @ Override public String toString ( ) { return \"Forums [getForumDescription=\" + getForumDescription ( ) + \", getForumId=\" + getForumId ( ) + \", getForumName=\" + getForumName ( ) + \", getLastAuthorId=\" + getLastAuthorId ( ) + \", getLastPostAuthorName=\" + getLastPostAuthorName ( ) + \", getLastPostId=\" + getLastPostId ( ) + \", getLastTime=\" + getLastTime ( ) + \", getLastTopic=\" + getLastTopic ( ) + \", getLastTopicId=\" + getLastTopicId ( ) + \", isLocked=\" + isLocked ( ) + \", getNumPosts=\" + getNumPosts ( ) + \", getNumTopics=\" + getNumTopics ( ) + \", isRead=\" + isRead ( ) + \", getSpecificRules=\" + getSpecificRules (", "gt": ") + \", isSticky=\" + isSticky ( ) + \"]\" ;", "prediction": ") + \"]\" ;\n", "label": 0}
{"id": 13998, "input": "<s> package org . jscsi . target . scsi . cdb ; import java . nio . ByteBuffer ; import org . jscsi . parser . scsi . SCSICommandParser ; import org . jscsi . target . scsi . sense . AdditionalSenseCodeAndQualifier ; import org . jscsi . target . scsi . sense . SenseData ; import org . jscsi . target . scsi . sense . SenseKey ; import org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific . FieldPointerSenseKeySpecificData ; import org . jscsi . target . util . BitManip ; public abstract class CommandDescriptorBlock { private FieldPointerSenseKeySpecificData [ ] illegalFieldPointers = null ; private ScsiOperationCode scsiOperationCode ; private boolean normalAutoContingentAllegiance ; public CommandDescriptorBlock ( ByteBuffer buffer ) { scsiOperationCode = ScsiOperationCode . valueOf ( buffer . get ( 0 ) ) ; if ( scsiOperationCode == null ) addIllegalFieldPointer ( 0 ) ; final CdbType cdbType = scsiOperationCode . getCdbType ( ) ; int controlByteIndex ; switch ( cdbType ) { case SIX_BYTE_COMMANDS : controlByteIndex = 5 ; break ; case TEN_BYTE_COMMANDS : controlByteIndex = 9 ; break ; case TWELVE_BYTE_COMMANDS : controlByteIndex = 11 ; break ; case SIXTEEN_BYTE_COMMANDS : controlByteIndex = 15 ; break ; default : controlByteIndex = - 1 ; } normalAutoContingentAllegiance = BitManip . getBit ( buffer . get ( controlByteIndex ) , 2 ) ; if ( normalAutoContingentAllegiance ) { addIllegalFieldPointer ( controlByteIndex , 2 ) ; } } public final ScsiOperationCode getScsiOperationCode ( ) { return scsiOperationCode ; } public final boolean isNormalACA ( ) { return normalAutoContingentAllegiance ; } protected final void addIllegalFieldPointer ( int byteNumber ) { final FieldPointerSenseKeySpecificData fp = new FieldPointerSenseKeySpecificData ( true , true , false , 0 , byteNumber ) ; addIllegalFieldPointer ( fp ) ; } protected final void addIllegalFieldPointer ( int byteNumber , int bitNumber ) { FieldPointerSenseKeySpecificData fp = new FieldPointerSenseKeySpecificData ( true , true , true , bitNumber , byteNumber ) ; addIllegalFieldPointer ( fp ) ; } private final void addIllegalFieldPointer ( final FieldPointerSenseKeySpecificData illegalFieldPointer ) { if ( illegalFieldPointers == null ) illegalFieldPointers = new FieldPointerSenseKeySpecificData [ 10 ] ; final int size = getIllegalFieldPointerSize ( ) ; if ( size >= illegalFieldPointers . length ) { FieldPointerSenseKeySpecificData [ ] temp = new FieldPointerSenseKeySpecificData [ illegalFieldPointers . length + 1 ] ; for ( int i = 0 ; i < size ; ++ i ) { temp [ i ] = illegalFieldPointers [ i ] ; } illegalFieldPointers = temp ; } illegalFieldPointers [ size ] = illegalFieldPointer ; } private final int getIllegalFieldPointerSize ( ) { if ( illegalFieldPointers == null ) return 0 ; int size = 0 ; while", "gt": "( size < illegalFieldPointers . length )", "prediction": "( size < illegalFieldPointers . length )\n", "label": 1}
{"id": 6704, "input": "<s> import java . util . logging . Logger ; import org . bukkit . command . Command ; import org . bukkit . command . CommandSender ; import org . bukkit . plugin . java . JavaPlugin ; public class BobPlugin extends JavaPlugin { private Logger log = this . getLogger ( ) ; @ Override public void onEnable ( ) { this . log . info ( \"BobPlugin has been enabled\" ) ; } @ Override public void onDisable ( ) { this . log . info (", "gt": "\"BobPlugin has been disabled\" ) ;", "prediction": "\"BobPlugin has been disabled\" ) ;\n", "label": 0}
{"id": 14000, "input": "<s> import javax . jcr . RepositoryException ; import javax . jcr . Session ; import play . exceptions . UnexpectedException ; import play . jobs . Job ; import play . jobs . OnApplicationStart ; import play . modules . cream . helpers . JcrRepositoryHelper ; import play . test . Fixtures ; @ OnApplicationStart public class Bootstrap extends Job { public void doJob ( ) { Session session = JcrRepositoryHelper . openSession ( ) ; try { if ( ! session .", "gt": "nodeExists ( \"/recipe\" ) )", "prediction": "isClosed ( ) )\n", "label": 1}
{"id": 7814, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SupportedAnnotationTypes ( \"*\" ) public class AnnoProc extends AbstractProcessor { public boolean process ( Set < ? extends TypeElement > elems , RoundEnvironment renv ) { if ( ++ round == 1 ) { Filer filer = processingEnv . getFiler ( ) ; Messager messager = processingEnv . getMessager ( ) ; try { FileObject fo1 = filer . createResource ( StandardLocation . CLASS_OUTPUT , \"p+q\" , \"Hello-World.txt\" ) ; Writer out = fo1 . openWriter ( ) ; out . write ( \"Hello World!\" ) ;", "gt": "out . close ( ) ;", "prediction": "out . close ( ) ;\n", "label": 0}
{"id": 14004, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor . actions ; public interface IVelocityActionDefinitionIds { public static final String GOTO_DEFINITION = \"com.googlecode.veloeclipse.vaulttec.ui.edit.goto.definition\" ; public static final", "gt": "String TOGGLE_COMMENT = \"com.googlecode.veloeclipse.vaulttec.ui.edit.toggle.comment\" ;", "prediction": "String GOTO_ACTION = \"com.googlecode.veloeclipse.vaulttec.ui.edit.goto.action\" ;\n", "label": 1}
{"id": 180, "input": "<s> package api . torrents . torrents ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . net . URLEncoder ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . util . ArrayList ; import java . util . List ; import api . son . MySon ; import api . soup . MySoup ; import api . util . Tuple ; public class TorrentGroup { private Response response ; private String status ; private static transient int id ; public static TorrentGroup torrentGroupFromId ( int id ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=torrentgroup&id=\" + id + \"&auth=\" + authkey ; TorrentGroup torrents = ( TorrentGroup ) MySon . toObject ( url , TorrentGroup . class ) ; TorrentGroup . id = id ; return torrents ; } public static int getId ( ) { return id ; } public boolean hasFreeLeech ( ) { for ( int i = 0 ; i < getResponse ( ) . getTorrents ( ) . size ( ) ; i ++ ) { if ( getResponse ( ) . getTorrents ( ) . get ( i ) . isFreeTorrent ( ) ) return true ; } return false ; } public Response getResponse ( ) { return this . response ; } public boolean getStatus ( ) { if ( status . equalsIgnoreCase ( \"success\" ) ) return true ; return false ; } public List < Tuple < String , String > > getDownloadLinksList ( ) { List < Tuple < String , String > > list = new ArrayList < Tuple < String , String > > ( ) ; for ( Torrents t : response . getTorrents ( ) ) { String name = t . getFilePath ( ) ; if ( t . getFilePath ( ) . equalsIgnoreCase ( \"\" ) || t . getFilePath ( ) . equals ( null ) ) { name = response . getGroup ( ) . getName ( ) + \" - \" + response . getGroup ( ) . getYear ( ) + \" (\" + t . getMediaFormatEncoding ( ) + \")\" ; } list . add ( new Tuple < String , String > ( t . getDownloadLink ( ) , name ) ) ; } return list ; } public List < Tuple < String , String > > getDownloadLinksListFor ( String [ ] formatList ) { List < Tuple < String , String > > list = new ArrayList < Tuple < String , String > > ( ) ; for ( Torrents t : response . getTorrents ( ) ) { for ( int i = 0 ; i < formatList . length ; i ++ ) { if ( formatList [ i ] . equalsIgnoreCase ( t . getFormat ( ) ) ) { String name = t . getFilePath ( ) ; if ( t . getFilePath ( ) . equalsIgnoreCase ( \"\" ) || t . getFilePath ( ) . equals ( null ) ) { name = response . getGroup ( ) . getName ( ) + \" - \" + response . getGroup ( ) . getYear ( ) + \" (\" + t . getMediaFormatEncoding ( ) + \")\" ; } list . add ( new Tuple < String , String > ( t . getDownloadLink ( ) , name ) ) ; } } } return list ; } public List < Tuple < String , String > > getDownloadLinksListExcept ( String [ ] formatList ) { List < Tuple < String , String > > list = new ArrayList < Tuple < String , String > > ( ) ; for ( Torrents t : response . getTorrents ( ) ) { for ( int i = 0 ; i < formatList . length ; i ++ ) { if ( ! formatList [ i ] . equalsIgnoreCase ( t . getFormat ( ) ) ) { String name = t . getFilePath ( ) ; if ( t . getFilePath ( ) . equalsIgnoreCase ( \"\" ) || t . getFilePath ( ) . equals ( null ) ) { name = response . getGroup ( ) . getName ( ) + \" - \" + response . getGroup ( ) . getYear ( ) + \" (\" + t . getMediaFormatEncoding ( ) + \")\" ; } list . add ( new Tuple < String , String > ( t . getDownloadLink ( ) , name ) ) ; } } } return list ; } public void downloadList ( List < Tuple < String , String > > list , String path ) { for ( Tuple < String , String > t : list ) { try { downloadTorrent ( t . getA ( ) , path , t . getB ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } private void downloadTorrent ( String url , String path , String name ) throws IOException { URL u ; u = new URL ( url ) ; ReadableByteChannel rbc = Channels . newChannel ( u . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( path + name + \".torrent\" ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , 1 << 24 ) ; System . out . println ( \"Downloaded \" + name + \" to \" + path ) ; } public String getSpotifyUrl ( ) { try { String s = \"spotify:\" + URLEncoder . encode ( getResponse ( ) . getGroup ( ) . getName ( ) , \"UTF-8\" ) ; return s ; } catch ( UnsupportedEncodingException e ) { System . err . println ( \"Could not encode url\" ) ; e . printStackTrace ( ) ; return null ; } } public String getLastFMUrl ( ) { String s ; try { s = \"http://www.last.fm/search?q=\" + URLEncoder . encode ( getResponse ( ) . getGroup ( ) . getName ( ) ,", "gt": "\"UTF-8\" ) + \"&type=album\" ;", "prediction": "\"UTF-8\" ) ;\n", "label": 0}
{"id": 14008, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . MapFieldSelector ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . vectorhighlight . FieldFragList . WeightedFragInfo ; import org . apache . lucene . search . vectorhighlight . FieldFragList . WeightedFragInfo . SubInfo ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo . Toffs ; public abstract class BaseFragmentsBuilder implements FragmentsBuilder { protected String [ ] preTags , postTags ; public static final String [ ] COLORED_PRE_TAGS = { \"<b style=\\\"background:yellow\\\">\" , \"<b style=\\\"background:lawngreen\\\">\" , \"<b style=\\\"background:aquamarine\\\">\" , \"<b style=\\\"background:magenta\\\">\" , \"<b style=\\\"background:palegreen\\\">\" , \"<b style=\\\"background:coral\\\">\" , \"<b style=\\\"background:wheat\\\">\" , \"<b style=\\\"background:khaki\\\">\" , \"<b style=\\\"background:lime\\\">\" , \"<b style=\\\"background:deepskyblue\\\">\" } ; public static final String [ ] COLORED_POST_TAGS = { \"</b>\" } ; protected BaseFragmentsBuilder ( ) { this ( new String [ ] { \"<b>\" } , new String [ ] { \"</b>\" } ) ; } protected BaseFragmentsBuilder ( String [ ] preTags , String [ ] postTags ) { this . preTags = preTags ; this . postTags = postTags ; } static Object checkTagsArgument ( Object tags ) { if ( tags instanceof String ) return tags ; else if ( tags instanceof String [ ] ) return tags ; throw new IllegalArgumentException ( \"type of preTags/postTags must be a String or String[]\" ) ; } public abstract List < WeightedFragInfo > getWeightedFragInfoList ( List < WeightedFragInfo > src ) ; public String createFragment ( IndexReader reader , int docId , String fieldName , FieldFragList fieldFragList ) throws IOException { String [ ] fragments = createFragments ( reader , docId , fieldName , fieldFragList , 1 ) ; if ( fragments == null || fragments . length == 0 ) return null ; return fragments [ 0 ] ; } public String [ ] createFragments ( IndexReader reader , int docId , String fieldName , FieldFragList fieldFragList , int maxNumFragments ) throws IOException { if ( maxNumFragments < 0 ) throw new IllegalArgumentException ( \"maxNumFragments(\" + maxNumFragments + \") must be positive number.\" ) ; List < WeightedFragInfo > fragInfos = getWeightedFragInfoList ( fieldFragList . fragInfos ) ; List < String > fragments = new ArrayList < String > ( maxNumFragments ) ; String [ ] values = getFieldValues ( reader , docId , fieldName ) ; if ( values . length == 0 ) return null ; StringBuilder buffer = new StringBuilder ( ) ; int [ ] nextValueIndex = { 0 } ; for ( int n = 0 ; n < maxNumFragments && n < fragInfos . size ( ) ; n ++ ) { WeightedFragInfo fragInfo = fragInfos . get ( n ) ; fragments . add ( makeFragment ( buffer , nextValueIndex , values , fragInfo ) ) ; } return fragments . toArray ( new String [ fragments . size ( ) ] ) ; } protected String [ ] getFieldValues ( IndexReader reader , int docId , String fieldName ) throws IOException { Document doc = reader . document ( docId , new MapFieldSelector ( new String [ ] { fieldName } ) ) ; return doc . getValues ( fieldName ) ; } protected String makeFragment ( StringBuilder buffer , int [ ] index , String [ ] values , WeightedFragInfo fragInfo ) { StringBuilder fragment = new StringBuilder ( ) ; final int s = fragInfo . startOffset ; String src = getFragmentSource ( buffer , index , values , s , fragInfo . endOffset ) ; int srcIndex = 0 ; for ( SubInfo subInfo : fragInfo . subInfos ) { for ( Toffs to : subInfo . termsOffsets ) { fragment . append ( src . substring ( srcIndex , to . startOffset - s ) ) . append ( getPreTag ( subInfo . seqnum ) ) . append ( src . substring ( to . startOffset - s , to . endOffset - s ) ) . append ( getPostTag ( subInfo . seqnum ) ) ; srcIndex = to . endOffset - s ; } } fragment . append ( src . substring ( srcIndex ) ) ; return fragment . toString ( ) ; } protected String getFragmentSource ( StringBuilder buffer , int [ ] index , String [ ] values , int startOffset , int endOffset ) { while ( buffer . length ( ) < endOffset && index [ 0 ] < values . length ) { if ( index [ 0 ] > 0 && values [ index [ 0 ] ] . length ( ) > 0 ) buffer . append ( ' ' ) ; buffer . append ( values [ index [ 0 ] ++ ] ) ; } int eo = buffer . length ( ) < endOffset ? buffer . length ( ) : endOffset ; return buffer . substring ( startOffset , eo ) ; } protected String getPreTag ( int num ) { return preTags . length > num ? preTags [ num ] : preTags [ 0 ] ; } protected String getPostTag ( int num ) { return postTags . length > num ? postTags [", "gt": "num ] : postTags [ 0 ] ;", "prediction": "num ] : postTags [ 0 ] ;\n", "label": 1}
{"id": 416, "input": "<s> package com . redhat . ceylon . compiler . java . test . languagesatisfaction ; import org . junit . runner . RunWith ; import com . redhat . ceylon . compiler . java . test . CeylonModuleRunner ; import com . redhat . ceylon . compiler . java . test . TestModule ; @ RunWith ( CeylonModuleRunner . class ) @ TestModule ( srcDirectory", "gt": "= \"test/satisfaction\" , errorIfNoTests = false ) public class LanguageSatisfactionSuite", "prediction": "= \"ceylon-compiler.xml\" , className = \"ceylon-compiler.xml\" , required = false ) public class CeylonCompilerTest\n", "label": 0}
{"id": 14010, "input": "<s> package org . apache . lucene . analysis . compound . hyphenation ; import org . xml . sax . XMLReader ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . Attributes ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . StringReader ; import java . net . MalformedURLException ; import java . util . ArrayList ; import javax . xml . parsers . SAXParserFactory ; public class PatternParser extends DefaultHandler implements PatternConsumer { XMLReader parser ; int currElement ; PatternConsumer consumer ; StringBuffer token ; ArrayList exception ; char hyphenChar ; String errMsg ; static final int ELEM_CLASSES = 1 ; static final int ELEM_EXCEPTIONS = 2 ; static final int ELEM_PATTERNS = 3 ; static final int ELEM_HYPHEN = 4 ; public PatternParser ( ) throws HyphenationException { token = new StringBuffer ( ) ; parser = createParser ( ) ; parser . setContentHandler ( this ) ; parser . setErrorHandler ( this ) ; parser . setEntityResolver ( this ) ; hyphenChar = '-' ; } public PatternParser ( PatternConsumer consumer ) throws HyphenationException { this ( ) ; this . consumer = consumer ; } public void setConsumer ( PatternConsumer consumer ) { this . consumer = consumer ; } public void parse ( String filename ) throws HyphenationException { parse ( new File ( filename ) ) ; } public void parse ( File file ) throws HyphenationException { try { InputSource src = new InputSource ( file . toURL ( ) . toExternalForm ( ) ) ; parse ( src ) ; } catch ( MalformedURLException e ) { throw new HyphenationException ( \"Error converting the File '\" + file + \"' to a URL: \" + e . getMessage ( ) ) ; } } public void parse ( InputSource source ) throws HyphenationException { try { parser . parse ( source ) ; } catch ( FileNotFoundException fnfe ) { throw new HyphenationException ( \"File not found: \" + fnfe . getMessage ( ) ) ; } catch ( IOException ioe ) { throw new HyphenationException ( ioe . getMessage ( ) ) ; } catch ( SAXException e ) { throw new HyphenationException ( errMsg ) ; } } static XMLReader createParser ( ) { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; return factory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Couldn't create XMLReader: \" + e . getMessage ( ) ) ; } } protected String readToken ( StringBuffer chars ) { String word ; boolean space = false ; int i ; for ( i = 0 ; i < chars . length ( ) ; i ++ ) { if ( Character . isWhitespace ( chars . charAt ( i ) ) ) { space = true ; } else { break ; } } if ( space ) { for ( int countr = i ; countr < chars . length ( ) ; countr ++ ) { chars . setCharAt ( countr - i , chars . charAt ( countr ) ) ; } chars . setLength ( chars . length ( ) - i ) ; if ( token . length ( ) > 0 ) { word = token . toString ( ) ; token . setLength ( 0 ) ; return word ; } } space = false ; for ( i = 0 ; i < chars . length ( ) ; i ++ ) { if ( Character . isWhitespace ( chars . charAt ( i ) ) ) { space = true ; break ; } } token . append ( chars . toString ( ) . substring ( 0 , i ) ) ; for ( int countr = i ; countr < chars . length ( ) ; countr ++ ) { chars . setCharAt ( countr - i , chars . charAt ( countr ) ) ; } chars . setLength ( chars . length ( ) - i ) ; if ( space ) { word = token . toString ( ) ; token . setLength ( 0 ) ; return word ; } token . append ( chars ) ; return null ; } protected static String getPattern ( String word ) { StringBuffer pat = new StringBuffer ( ) ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! Character . isDigit ( word . charAt ( i ) ) ) { pat . append ( word . charAt ( i ) ) ; } } return pat . toString ( ) ; } protected ArrayList normalizeException ( ArrayList ex ) { ArrayList res =", "gt": "new ArrayList ( ) ;", "prediction": "new ArrayList ( ) ;\n", "label": 1}
{"id": 6097, "input": "<s> package org . jjflyboy . tjpeditor . ui . labeling ; import org . eclipse . emf . edit . ui . provider . AdapterFactoryLabelProvider ; import org . eclipse . xtext . ui . label . DefaultEObjectLabelProvider ; import com . google . inject . Inject ; public class ProjectLabelProvider extends DefaultEObjectLabelProvider { @ Inject public", "gt": "ProjectLabelProvider ( AdapterFactoryLabelProvider delegate )", "prediction": "ProjectLabelProvider ( )\n", "label": 0}
{"id": 14011, "input": "<s> package com . digitalsanctum . idea . plugins . buildr ; import com . digitalsanctum . idea . plugins . buildr . ui . BuildrTasksPane ; import com . intellij . openapi . actionSystem . DataContext ; import com . intellij . openapi . components . ProjectComponent ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . wm . ToolWindow ; import com . intellij . openapi . wm . ToolWindowAnchor ; import com . intellij . openapi . wm . ToolWindowManager ; import com . intellij . ui . content . Content ; import com . intellij . ui . content . ContentFactory ; import org . jetbrains . annotations . NotNull ; import static com . digitalsanctum . idea . plugins . buildr . Buildr . * ; public class BuildrTasksListComponent implements ProjectComponent { private Project project ; private ToolWindow buildrToolWindow ; private BuildrTasksPane buildrTasksPane ; private ContentFactory contentFactory ; public BuildrTasksListComponent ( Project project ) { this . project = project ; } public void projectOpened ( ) { ToolWindowManager toolWindowManager = ToolWindowManager . getInstance ( this . project ) ; initBuildrToolWindow ( toolWindowManager ) ; } public void projectClosed ( ) { ToolWindowManager toolWindowManager = ToolWindowManager . getInstance ( project ) ; toolWindowManager . unregisterToolWindow ( BUILDR_TOOL_WINDOW_ID ) ; } @ NotNull public String getComponentName ( ) { return BuildrComponents . BUILDR_TASK_LIST_COMPONENT ; } public void initComponent ( ) { } public void disposeComponent ( ) { } public void refreshTaskList ( ) { this . buildrTasksPane . refreshTaskList ( ) ; } public void runSelectedTask ( ) { BuildrProjectComponent bpc = project . getComponent ( BuildrProjectComponent . class ) ; bpc . runTask ( this . buildrTasksPane . getCommand ( ) ) ; } public boolean isTaskSelected ( ) { return null != this . buildrTasksPane && this . buildrTasksPane . isTaskSelected ( ) ; } private ContentFactory getContentFactory ( ) { if ( contentFactory == null ) { contentFactory = ContentFactory . SERVICE . getInstance ( ) ; } return contentFactory ; } private void initBuildrToolWindow ( ToolWindowManager toolWindowManager ) { if ( buildrToolWindow == null ) { buildrToolWindow = toolWindowManager . registerToolWindow ( BUILDR_TOOL_WINDOW_ID , false , ToolWindowAnchor . RIGHT ) ; buildrToolWindow . setIcon ( BUILDR_16 ) ; if", "gt": "( buildrTasksPane == null )", "prediction": "( buildrTasksPane != null )\n", "label": 1}
{"id": 1399, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; public class NoStar extends Doclet { public static void main ( String [ ] args ) { if ( com . sun . tools . javadoc . Main . execute ( \"javadoc\" , \"NoStar\" , NoStar . class . getClassLoader ( ) , new String [ ] { System . getProperty ( \"test.src\" , \".\" ) + java . io . File . separatorChar + \"NoStar.java\" } ) != 0 ) throw new Error ( ) ; } public static boolean start ( com . sun . javadoc . RootDoc root ) { ClassDoc [", "gt": "] classes = root . classes ( ) ;", "prediction": "] classes = root . getClasses ( ) ;\n", "label": 0}
{"id": 14013, "input": "<s> package org . eclipse . rap . rwt . internal . util ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public final class ActiveKeysUtil { private static final Map < String , Integer > KEY_MAP = new HashMap < String , Integer > ( ) ; static { KEY_MAP . put ( \"BACKSPACE\" , new Integer ( 8 ) ) ; KEY_MAP . put ( \"BS\" , new Integer ( 8 ) ) ; KEY_MAP . put ( \"TAB\" , new Integer ( 9 ) ) ; KEY_MAP . put ( \"RETURN\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"ENTER\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"CR\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"PAUSE\" , new Integer ( 19 ) ) ; KEY_MAP . put ( \"BREAK\" , new Integer ( 19 ) ) ; KEY_MAP . put ( \"CAPS_LOCK\" , new Integer ( 20 ) ) ; KEY_MAP . put ( \"ESCAPE\" , new Integer ( 27 ) ) ; KEY_MAP . put ( \"ESC\" , new Integer ( 27 ) ) ; KEY_MAP . put ( \"SPACE\" , new Integer ( 32 ) ) ; KEY_MAP . put ( \"PAGE_UP\" , new Integer ( 33 ) ) ; KEY_MAP . put ( \"PAGE_DOWN\" , new Integer ( 34 ) ) ; KEY_MAP . put ( \"END\" , new Integer ( 35 ) ) ; KEY_MAP . put ( \"HOME\" , new Integer ( 36 ) ) ; KEY_MAP . put ( \"ARROW_LEFT\" , new Integer ( 37 ) ) ; KEY_MAP . put ( \"ARROW_UP\" , new Integer ( 38 ) ) ; KEY_MAP . put ( \"ARROW_RIGHT\" , new Integer ( 39 ) ) ; KEY_MAP . put ( \"ARROW_DOWN\" , new Integer ( 40 ) ) ; KEY_MAP . put ( \"PRINT_SCREEN\" , new Integer ( 44 ) ) ; KEY_MAP . put ( \"INSERT\" , new Integer ( 45 ) ) ; KEY_MAP . put ( \"DEL\" , new Integer ( 46 ) ) ; KEY_MAP . put ( \"DELETE\" , new Integer ( 46 ) ) ; KEY_MAP . put ( \"F1\" , new Integer ( 112 ) ) ; KEY_MAP . put ( \"F2\" , new Integer ( 113 ) ) ; KEY_MAP . put ( \"F3\" , new Integer ( 114 ) ) ; KEY_MAP . put ( \"F4\" , new Integer ( 115 ) ) ; KEY_MAP . put ( \"F5\" , new Integer ( 116 ) ) ; KEY_MAP . put ( \"F6\" , new Integer ( 117 ) ) ; KEY_MAP . put ( \"F7\" , new Integer ( 118 ) ) ; KEY_MAP . put ( \"F8\" , new Integer ( 119 ) ) ; KEY_MAP . put ( \"F9\" , new Integer ( 120 ) ) ; KEY_MAP . put ( \"F10\" , new Integer ( 121 ) ) ; KEY_MAP . put ( \"F11\" , new Integer ( 122 ) ) ; KEY_MAP . put ( \"F12\" , new Integer ( 123 ) ) ; KEY_MAP . put ( \"NUMPAD_0\" , new Integer ( 96 ) ) ; KEY_MAP . put ( \"NUMPAD_1\" , new Integer ( 97 ) ) ; KEY_MAP . put ( \"NUMPAD_2\" , new Integer ( 98 ) ) ; KEY_MAP . put ( \"NUMPAD_3\" , new Integer ( 99 ) ) ; KEY_MAP . put ( \"NUMPAD_4\" , new Integer ( 100 ) ) ; KEY_MAP . put ( \"NUMPAD_5\" , new Integer ( 101 ) ) ; KEY_MAP .", "gt": "put ( \"NUMPAD_6\" , new Integer ( 102 ) ) ;", "prediction": "put ( \"NUMPAD_6\" , new Integer ( 102 ) ) ;\n", "label": 1}
{"id": 3405, "input": "<s> package com . matburt . mobileorg . Synchronizers ; import android . app . Activity ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . content . res . Resources ; import android . os . AsyncTask ; import android . os . Bundle ; import android . preference . PreferenceManager ; import android . util . Log ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import com . dropbox . client . DropboxAPI ; import com . dropbox . client . DropboxAPI . Config ; import com . matburt . mobileorg . R ; public class DropboxAuthActivity extends Activity implements OnClickListener { private static final String LT = \"MobileOrg\" ; private DropboxAPI api = new DropboxAPI ( ) ; private TextView dbInfo ; private EditText dbLogin ; private EditText dbPassword ; private Button dbSubmit ; private Resources r ; private boolean hasToken = false ; private Config dbConfig ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . androidauth ) ; dbInfo = ( TextView ) findViewById ( R . id . dbCurrentToken ) ; dbLogin = ( EditText ) findViewById ( R . id . dbAuthLogin ) ; dbPassword = ( EditText ) findViewById ( R . id . dbAuthPassword ) ; dbSubmit = ( Button ) findViewById ( R . id . dbAuthSubmit ) ; dbSubmit . setOnClickListener ( this ) ; r = this . getResources ( ) ; this . populateInfo ( ) ; } public void onClick ( View v ) { if ( v == this . dbSubmit ) { if ( this . hasToken ) { api . deauthenticate ( ) ; clearKeys ( ) ; setLoggedIn ( false ) ; dbInfo . setText ( \"Not logged in\" ) ; } else { getAccountInfo ( ) ; } } } public void populateInfo ( ) { String [ ] keys = getKeys ( ) ; if ( keys != null ) { setLoggedIn ( true ) ; Log . i ( LT , \"Logged in to Dropbox already\" ) ; } else { setLoggedIn ( false ) ; Log . i ( LT , \"Not logged in to Dropbox\" ) ; } if ( authenticate ( ) ) { getAccountInfo ( ) ; } } public DropboxAPI getAPI ( ) { return api ; } public void setLoggedIn ( boolean loggedIn ) { this . hasToken = loggedIn ; this . dbLogin . setEnabled ( ! loggedIn ) ; this . dbPassword . setEnabled ( ! loggedIn ) ; if ( loggedIn ) { dbSubmit . setText ( \"Log Out of Dropbox\" ) ; } else { dbSubmit . setText ( \"Log In to Dropbox\" ) ; } } public void showToast ( String msg ) { Toast error = Toast . makeText ( this , msg , Toast . LENGTH_LONG ) ; error . show ( ) ; } private void getAccountInfo ( ) { if ( api . isAuthenticated ( ) ) { LoginAsyncTask login = new LoginAsyncTask ( this", "gt": ", null , null , getConfig ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14025, "input": "<s> package com . emf4sw . rdf . jena ; import com . emf4sw . rdf . BlankNode ; import com . emf4sw . rdf . Node ; import com . emf4sw . rdf . RDFFactory ; import com . emf4sw . rdf . RDFGraph ; import com . hp . hpl . jena . rdf . model . AnonId ; import com . hp . hpl . jena . rdf . model . Literal ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . RDFVisitor ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . rdf . model . Statement ; public class TripleInjector { private static final RDFFactory factory = RDFFactory . eINSTANCE ; private TripleInjector ( ) { } public static com . emf4sw . rdf . Triple inject ( Statement stmt , RDFGraph graph ) { final NodeVisitorInjector visitor = new NodeVisitorInjector ( graph ) ; final com . emf4sw . rdf . Node subject = ( Node ) stmt . getSubject ( ) . visitWith ( visitor ) ; final com . emf4sw . rdf . Property predicate = inject ( stmt . getPredicate ( ) , graph ) ; final com . emf4sw . rdf . Node object = ( com . emf4sw . rdf . Node ) stmt . getObject ( ) . visitWith ( visitor ) ; return graph . addTriple ( subject , predicate , object ) ; } protected static com . emf4sw . rdf . Property inject ( Property predicate , RDFGraph graph ) { if ( predicate . getURI ( ) == null ) { return null ; } com . emf4sw . rdf . Property ret = graph . getProperty ( predicate . getURI ( ) ) ; if ( ret == null ) { ret = factory . createProperty ( ) ; ret . setURI ( predicate . getURI ( ) ) ; graph . getProperties ( ) . add ( ret ) ; } return ret ; } public static class NodeVisitorInjector implements RDFVisitor { private final RDFGraph graph ; NodeVisitorInjector ( RDFGraph graph ) { this . graph = graph ; } @ Override public Object visitBlank ( Resource node , AnonId arg1 ) { final BlankNode ret = factory . createBlankNode ( ) ; ret . setNodeID ( arg1 . toString ( ) ) ; graph . getBlankNodes ( ) . add ( ret ) ; return ret ; } @ Override public Object visitLiteral ( Literal literal ) { final com . emf4sw . rdf . Literal ret = factory . createLiteral ( ) ; ret . setLexicalForm ( literal . getLexicalForm ( ) ) ; ret . setLang ( literal . getLanguage ( ) ) ; if ( literal . getDatatypeURI ( ) != null ) { ret . setDatatype ( graph . getDatatype ( literal . getDatatypeURI ( ) ) ) ; } graph . getLiterals ( ) . add ( ret ) ; return ret ; } @ Override public Object visitURI ( Resource resource , String arg1 ) { if ( resource . getURI ( ) == null ) { return null ; } com . emf4sw . rdf . Resource ret = graph . getResource ( resource . getURI ( ) ) ; if ( ret == null ) { ret = factory . createResource ( ) ;", "gt": "ret . setURI ( resource . getURI ( ) ) ;", "prediction": "ret . setURI ( resource . getURI ( ) ) ;\n", "label": 1}
{"id": 4050, "input": "<s> public class TestDocRootLink extends JavadocTester { private static final String BUG_ID = \"6553182\" ; private static final String [ ] [ ] TEST1 = { { BUG_ID + FS + \"pkg1\" + FS + \"C1.html\" , \"<a href=\\\"../../technotes/guides/index.html\\\">\" } , { BUG_ID + FS + \"pkg1\" + FS + \"package-summary.html\" , \"<a href=\\\"../../technotes/guides/index.html\\\">\" } } ; private static final String [ ] [ ] NEGATED_TEST1 = { { BUG_ID + FS + \"pkg1\" + FS + \"C1.html\" , \"<a href=\\\"http://download.oracle.com/javase/7/docs/technotes/guides/index.html\\\">\" } , { BUG_ID + FS + \"pkg1\" + FS + \"package-summary.html\" , \"<a href=\\\"http://download.oracle.com/javase/7/docs/technotes/guides/index.html\\\">\" } } ; private static final String [ ] [ ] TEST2 = { { BUG_ID + FS + \"pkg2\" + FS + \"C2.html\" , \"<a href=\\\"http://download.oracle.com/javase/7/docs/technotes/guides/index.html\\\">\" } , { BUG_ID + FS + \"pkg2\" + FS + \"package-summary.html\" , \"<a href=\\\"http://download.oracle.com/javase/7/docs/technotes/guides/index.html\\\">\" } } ; private static final String [ ] [ ] NEGATED_TEST2 = { { BUG_ID + FS + \"pkg2\" + FS + \"C2.html\" , \"<a href=\\\"../../technotes/guides/index.html\\\">\" } , { BUG_ID + FS + \"pkg2\" + FS + \"package-summary.html\" , \"<a href=\\\"../../technotes/guides/index.html\\\">\" } } ; private static final String [ ] ARGS1 = new String [ ] { \"-d\" , BUG_ID ,", "gt": "\"-sourcepath\" , SRC_DIR , \"pkg1\" }", "prediction": "NEGATED_TEST1 }\n", "label": 0}
{"id": 14035, "input": "<s> package org . eclipse . ui . tests . keys ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class Bug43597Test extends UITestCase { private Font textFont ; public Bug43597Test ( String name ) { super ( name ) ; } public void testFontReset ( ) { String metaCharacter = \"\u2325X\" ; Display display = Display . getCurrent ( ) ; Shell shell = new Shell ( display ) ; GridLayout gridLayout = new GridLayout ( ) ; shell . setLayout ( gridLayout ) ; Text text = new Text ( shell , SWT . LEFT ) ; text . setFont ( Graphics . getFont ( \"Lucida Grande\" , 13 , SWT . NORMAL ) ) ; text . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; shell . pack ( ) ; shell . open ( ) ; text . setText ( metaCharacter ) ; Font fontBefore = text . getFont ( ) ; text . setText ( \"\" ) ; text", "gt": ". setText ( metaCharacter ) ;", "prediction": ". setFont ( fontBefore ) ;\n", "label": 1}
{"id": 5863, "input": "<s> class T6665356b < T > { class A < S > { } class B < X > extends A < X > { } void cast ( A < ? extends Number > a ) { Object o =", "gt": "( B < ? extends Integer > ) a ;", "prediction": "a . cast ( ) ;\n", "label": 0}
{"id": 14038, "input": "<s> package org . restlet . test . gwt . client ; import com . google . gwt . core . client . EntryPoint ; import com . google . gwt . core . client . GWT ; import com . google . gwt . user . client . ui . Button ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . RootPanel ; public class TestClient implements EntryPoint { public void onModuleLoad ( ) { GWT . log ( \"Restlet module loaded.\" , null ) ; final Button button =", "gt": "new Button ( \"Restlet, Fetch!\" ) ;", "prediction": "new Button ( RootPanel . this ) ;\n", "label": 1}
{"id": 9322, "input": "<s> import java . io . BufferedWriter ; import java . io . FileWriter ; import java . util . logging . Level ; import java . util . logging . Logger ; import com . vexsoftware . votifier . model . Vote ; import com . vexsoftware . votifier . model . VoteListener ; public class FlatfileVoteListener implements VoteListener { public static final String FILE = \"./plugins/Votifier/votes.log\" ; private static final Logger log = Logger . getLogger ( \"FlatfileVoteListener\" ) ; @ Override public void voteMade ( Vote vote ) { try { BufferedWriter writer = new", "gt": "BufferedWriter ( new FileWriter ( FILE , true ) ) ;", "prediction": "BufferedWriter ( new FileWriter ( FILE ) ) ;\n", "label": 0}
{"id": 14039, "input": "<s> package org . modelgoon . core . editparts ; import org . eclipse . gef . GraphicalEditPart ; import org . eclipse . gef . editparts . ZoomListener ; import org . eclipse . gef . editparts . ZoomManager ; import org . eclipse . gef . tools . CellEditorLocator ; import org . eclipse . gef . tools . DirectEditManager ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . TextCellEditor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . part . CellEditorActionHandler ; import org . modelgoon . core . NoteFigure ; public class LogicLabelEditManager extends DirectEditManager { private IActionBars actionBars ; private CellEditorActionHandler actionHandler ; private IAction copy , cut , paste , undo , redo , find , selectAll , delete ; private double cachedZoom = - 1.0 ; private Font scaledFont ; private final ZoomListener zoomListener = new ZoomListener ( ) { public void zoomChanged ( final double newZoom ) { updateScaledFont ( newZoom ) ; } } ; public LogicLabelEditManager ( final GraphicalEditPart source , final CellEditorLocator locator ) { super ( source , null , locator ) ; } @ Override protected void bringDown ( ) { ZoomManager zoomMgr = ( ZoomManager ) getEditPart ( ) . getViewer ( ) . getProperty ( ZoomManager . class . toString ( ) ) ; if ( zoomMgr != null ) { zoomMgr . removeZoomListener ( this . zoomListener ) ; } if ( this . actionHandler != null ) { this . actionHandler . dispose ( ) ; this . actionHandler = null ; } if ( this . actionBars != null ) { restoreSavedActions ( this . actionBars ) ; this . actionBars . updateActionBars ( ) ; this . actionBars = null ; } super . bringDown ( ) ; disposeScaledFont ( ) ; } @ Override protected CellEditor createCellEditorOn ( final Composite composite ) { return new TextCellEditor ( composite , SWT . MULTI | SWT . WRAP ) ; } private void disposeScaledFont ( ) { if ( this . scaledFont != null ) { this . scaledFont . dispose ( ) ; this . scaledFont = null ; } } @ Override protected void initCellEditor ( ) { NoteFigure stickyNote = ( NoteFigure ) getEditPart ( ) . getFigure ( ) ; getCellEditor ( ) . setValue ( stickyNote . getNoteContents ( ) ) ; ZoomManager zoomMgr = ( ZoomManager ) getEditPart ( ) . getViewer ( ) . getProperty ( ZoomManager . class . toString ( ) ) ; if ( zoomMgr != null ) { this . cachedZoom = - 1.0 ; updateScaledFont ( zoomMgr . getZoom ( ) ) ; zoomMgr . addZoomListener ( this . zoomListener ) ; } else { getCellEditor ( ) . getControl ( ) . setFont ( stickyNote . getFont ( ) ) ; } this . actionBars = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getActiveEditor ( ) . getEditorSite ( ) . getActionBars ( ) ; saveCurrentActions ( this . actionBars ) ; this . actionHandler = new CellEditorActionHandler ( this . actionBars ) ; this . actionHandler . addCellEditor ( getCellEditor ( ) ) ; this . actionBars . updateActionBars ( ) ; } private void restoreSavedActions ( final IActionBars actionBars ) { actionBars . setGlobalActionHandler ( ActionFactory . COPY . getId ( ) , this . copy ) ; actionBars . setGlobalActionHandler ( ActionFactory . PASTE . getId ( ) , this . paste ) ; actionBars . setGlobalActionHandler ( ActionFactory . DELETE . getId ( ) , this . delete ) ; actionBars . setGlobalActionHandler ( ActionFactory . SELECT_ALL . getId ( ) , this . selectAll ) ; actionBars . setGlobalActionHandler ( ActionFactory . CUT . getId ( ) , this . cut ) ; actionBars . setGlobalActionHandler ( ActionFactory . FIND . getId ( ) , this . find ) ; actionBars . setGlobalActionHandler ( ActionFactory . UNDO . getId ( ) , this . undo ) ; actionBars . setGlobalActionHandler ( ActionFactory . REDO . getId ( ) , this . redo ) ; } private void saveCurrentActions ( final IActionBars actionBars ) { this . copy = actionBars . getGlobalActionHandler ( ActionFactory . COPY . getId ( ) ) ; this . paste = actionBars . getGlobalActionHandler ( ActionFactory . PASTE . getId ( ) ) ; this . delete = actionBars . getGlobalActionHandler ( ActionFactory . DELETE . getId ( ) ) ; this . selectAll = actionBars . getGlobalActionHandler ( ActionFactory . SELECT_ALL . getId ( ) ) ; this . cut = actionBars . getGlobalActionHandler ( ActionFactory . CUT . getId ( ) ) ; this . find = actionBars . getGlobalActionHandler ( ActionFactory . FIND . getId ( ) ) ; this . undo = actionBars . getGlobalActionHandler ( ActionFactory . UNDO . getId ( ) ) ; this . redo = actionBars . getGlobalActionHandler ( ActionFactory . REDO . getId ( ) ) ; } private void updateScaledFont ( final double zoom ) { if ( this", "gt": ". cachedZoom == zoom )", "prediction": ". scaledFont != null )\n", "label": 1}
{"id": 8283, "input": "<s> @ interface An { String a ( ) default", "gt": "\"foo\" . intern ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14042, "input": "<s> package litil . eval ; import litil . TypeScope ; import litil . Utils ; import litil . ast . * ; import litil . lexer . * ; import litil . parser . LitilParser ; import litil . tc . HMTypeChecker ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . * ; public class Evaluator { private int depth ; private boolean dbgAp = false ; private void dbgAp ( String msg ) { if ( dbgAp ) { System . out . println ( Utils . tab ( depth ) + msg ) ; } } public Object eval ( AstNode node , ValScope scope ) { if ( node instanceof Expr ) { if ( node instanceof Expr . EName ) { Object val = scope . get ( ( ( Expr . EName ) node ) . name ) ; if ( val == null ) { throw new EvalException ( \"Unknwon identifier \" + node ) ; } else { return val ; } } else if ( node instanceof Expr . EAccessor ) { Expr . EAccessor acc = ( Expr . EAccessor ) node ; Object obj = eval ( acc . obj , scope ) ; if ( ! ( obj instanceof Map ) ) { throw new EvalException ( \"Not a record \" + acc . obj ) ; } else { Map < String , Object > fields = ( Map < String , Object > ) obj ; if ( ! fields . containsKey ( acc . field ) ) { throw new EvalException ( \"No field \" + acc . field + \"in \" + obj ) ; } return fields . get ( acc . field ) ; } } else if ( node instanceof Expr . ENum ) { return ( ( Expr . ENum ) node ) . value ; } else if ( node instanceof Expr . EBool ) { return ( ( Expr . EBool ) node ) . value ; } else if ( node instanceof Expr . EChar ) { return ( ( Expr . EChar ) node ) . value ; } else if ( node instanceof Expr . EStr ) { String s = ( ( Expr . EStr ) node ) . value ; List < Object > chars = new ArrayList < Object > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { chars . add ( s . charAt ( i ) ) ; } return makeList ( chars ) ; } else if ( node == Expr . EUnit ) { return node ; } else if ( node instanceof Expr . ETuple ) { Expr . ETuple tuple = ( ( Expr . ETuple ) node ) ; List < Object > res = new ArrayList < Object > ( ) ; for ( Expr value : tuple . values ) { res . add ( eval", "gt": "( value , scope ) ) ;", "prediction": "( value , scope ) ) ;\n", "label": 1}
{"id": 6531, "input": "<s> package pkg2 ; import pkg1 . * ; public class SubClass extends BaseClass { public void publicMethod ( ) { } public void packagePrivateMethod ( ) { }", "gt": "public void privateMethod ( )", "prediction": "}\n", "label": 0}
{"id": 14043, "input": "<s> package com . talis . hbase . rdf . layout ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . sparql . core . Quad ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; import com . talis . hbase . rdf . Store ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . store . LayoutType ; import com . talis . hbase . rdf . store . StoreConfig ; import com . talis . hbase . rdf . store . StoreFormatter ; import com . talis . hbase . rdf . store . StoreInformationHolder ; import com . talis . hbase . rdf . store . StoreLoader ; import com . talis . hbase . rdf . store . StoreQueryRunner ; public abstract class StoreBase extends StoreInformationHolder implements Store { protected StoreDesc storeDescription ; protected StoreConfig config ; protected StoreQueryRunner querier ; protected StoreFormatter formatter ; protected StoreLoader loader ; protected TableDescLayouts tables ; protected boolean isClosed = false ; public StoreBase ( HBaseRdfConnection connection , StoreDesc desc , StoreQueryRunner querier , StoreFormatter formatter , StoreLoader loader , TableDescLayouts tables ) { super ( desc . getStoreName ( ) , connection ) ; this . storeDescription = desc ; this . querier = querier ; this . formatter = formatter ; this . loader = loader ; this . tables = tables ; this . config = new StoreConfig ( desc . getStoreName (", "gt": ") , connection ) ;", "prediction": ") , connection ) ;\n", "label": 1}
{"id": 2387, "input": "<s> package org . ofbiz . webapp . control ; import static org . ofbiz . base . util . UtilGenerics . checkMap ; import java . io . IOException ; import java . io . Serializable ; import java . io . UnsupportedEncodingException ; import java . net . URL ; import java . security . cert . X509Certificate ; import java . util . Enumeration ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . SSLUtil ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . webapp . event . EventFactory ; import org . ofbiz . webapp . event . EventHandler ; import org . ofbiz . webapp . event . EventHandlerException ; import org . ofbiz . webapp . stats . ServerHitBin ; import org . ofbiz . webapp . view . ViewFactory ; import org . ofbiz . webapp . view . ViewHandler ; import org . ofbiz . webapp . view . ViewHandlerException ; import org . ofbiz . webapp . website . WebSiteWorker ; import org . owasp . esapi . errors . EncodingException ; public class RequestHandler { public static final String module = RequestHandler . class . getName ( ) ; private static final Boolean THROW_REQUEST_HANDLER_EXCEPTION_ON_MISSING_LOCAL_REQUEST = UtilProperties . propertyValueEqualsIgnoreCase ( \"requestHandler.properties\" , \"throwRequestHandlerExceptionOnMissingLocalRequest\" , \"Y\" ) ; public static RequestHandler getRequestHandler ( ServletContext servletContext ) { RequestHandler rh = ( RequestHandler ) servletContext . getAttribute ( \"_REQUEST_HANDLER_\" ) ; if ( rh == null ) { rh = new RequestHandler ( ) ; servletContext . setAttribute ( \"_REQUEST_HANDLER_\" , rh ) ; rh . init ( servletContext ) ; } return rh ; } protected ServletContext context = null ; protected ViewFactory viewFactory = null ; protected EventFactory eventFactory = null ; protected URL controllerConfigURL = null ; public void init ( ServletContext context ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"[RequestHandler Loading...]\" , module ) ; this . context = context ; this . controllerConfigURL = ConfigXMLReader . getControllerConfigURL ( context ) ; ConfigXMLReader . getControllerConfig ( this . controllerConfigURL ) ; this . viewFactory = new ViewFactory ( this ) ; this . eventFactory = new EventFactory ( this ) ; } public ConfigXMLReader . ControllerConfig getControllerConfig ( ) { return ConfigXMLReader . getControllerConfig (", "gt": "this . controllerConfigURL ) ;", "prediction": "context ) ;\n", "label": 0}
{"id": 14048, "input": "<s> package com . northconcepts . eventbus . filter ; import com . northconcepts . eventbus . EventFilter ; import org . junit . Test ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class NotFilterTest extends LogicalFilterTest { @ Test public void testNullFilters ( ) { EventFilter filter = new NotFilter ( ( EventFilter [ ] ) null ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testZeroFilters ( ) { EventFilter filter = new NotFilter ( ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneTrueFilter ( ) { EventFilter filter = new NotFilter ( TRUE_FILTER ) ; assertFalse ( filter . allow ( event , listener ) ) ; } @ Test public void testOneFalseFilter ( ) { EventFilter filter = new NotFilter ( FALSE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testManyTrueFilters ( ) { EventFilter filter = new NotFilter ( TRUE_FILTER , TRUE_FILTER , TRUE_FILTER ) ; assertFalse ( filter . allow ( event , listener ) ) ; } @ Test", "gt": "public void testManyFalseFilters ( )", "prediction": "public void testManyFalseFilters ( )\n", "label": 1}
{"id": 5070, "input": "<s> import java . io . * ; import java . lang . reflect . Modifier ; public class T6232928 { public static void main ( String ... args ) throws Exception { Class pkginfo_cls = Class . forName ( \"T6232928.package-info\" ) ; int mod = pkginfo_cls . getModifiers ( ) ; if ( Modifier . isAbstract ( mod ) && Modifier . isInterface ( mod ) ) { if ( ( mod & 0x1000 ) == 0 ) { throw new AssertionError ( \"Test failed: interface package-info should be synthetic.\" ) ; } } else { throw new AssertionError ( \"Test failed:", "gt": "interface package-info should be abstract.\" ) ;", "prediction": "interface package-info should not be abstract.\" ) ;\n", "label": 0}
{"id": 14050, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . CookieParam ; import javax . ws . rs . core . Application ; import junit . framework . AssertionFailedError ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Cookie ; import org . restlet . data . Status ; import org . restlet . representation . Representation ; import org . restlet . test . ext . jaxrs . services . resources . CookieParamTestService ; public class CookieParamTest extends JaxRsTestCase { @ Override protected Application getApplication ( ) { return new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( CookieParamTestService . class ) ; } } ; } public void test1 ( ) throws IOException { Response response = get ( new Cookie ( \"c\" , \"value\" ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"value\" , response . getEntity ( ) . getText ( ) ) ; response = get ( new Cookie ( \"c\" , \"sdfgdfg\" ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"sdfgdfg\" , response . getEntity ( ) . getText ( ) ) ; } public void test2 ( ) throws IOException { final Response response = get ( ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_NO_CONTENT , response . getStatus ( ) ) ; final Representation entity = response . getEntity ( ) ; String text ; if ( entity != null ) { text = entity . getText ( ) ; } else { text = null ; } assertEquals ( null , text ) ; } public void testCookieArray ( ) throws Exception { final Request request = createGetRequest ( \"array\" ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c1\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c2\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"d\" , \"c3\" ) ) ; final Response response = accessServer ( request ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; final String entity = response . getEntity ( ) . getText ( ) ; final String entityWithoutBrackets = entity . substring ( 1 , entity . length ( ) - 1 ) ; assertEquals ( \"c1, c2\" , entityWithoutBrackets ) ; } public void testCookieSet ( ) throws Exception { final Request request = createGetRequest ( \"Set\" ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c1\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"c\"", "gt": ", \"c2\" ) ) ;", "prediction": ", \"c2\" ) ) ;\n", "label": 1}
{"id": 7944, "input": "<s> package org . xbill . DNS ; public class InvalidTTLException extends IllegalArgumentException { public InvalidTTLException ( long ttl ) {", "gt": "super ( \"Invalid DNS TTL: \" + ttl ) ;", "prediction": "super ( ttl ) ;\n", "label": 0}
{"id": 14055, "input": "<s> package org . jscsi . initiator . connection . state ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . initiator . connection . TargetCapacityInformations ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . data . DataInParser ; import org . jscsi . parser . scsi . SCSICommandParser . TaskAttributes ; import org . jscsi . parser . scsi . SCSIResponseParser ; import org . jscsi . parser . scsi . SCSIStatus ; public final class CapacityResponseState extends AbstractState { private final TargetCapacityInformations capacityInformation ; protected CapacityResponseState ( final Connection initConnection , final TargetCapacityInformations initCapacityInformation ) { super ( initConnection ) ; capacityInformation = initCapacityInformation ; } public final void execute ( ) throws InternetSCSIException { final ProtocolDataUnit protocolDataUnit = connection . receive ( ) ; if ( ! ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) instanceof DataInParser ) ) { if ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) instanceof SCSIResponseParser ) { connection . nextState ( new CapacityRequestState ( connection , capacityInformation , TaskAttributes . SIMPLE ) ) ; super . stateFollowing = true ; return ; } else { throw new InternetSCSIException ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) . getClass ( ) . getSimpleName ( ) + \" is not the expected type of PDU.\" ) ; } } final DataInParser parser = ( DataInParser ) protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) ; capacityInformation . deserialize ( protocolDataUnit . getDataSegment ( ) ) ; if ( ! parser . isStatusFlag ( ) || parser . getStatus ( ) != SCSIStatus . GOOD ) { final ProtocolDataUnit scsiPdu = connection . receive ( ) ; if ( scsiPdu . getBasicHeaderSegment ( ) . getOpCode ( ) == OperationCode . SCSI_RESPONSE ) { final SCSIResponseParser scsiParser = ( SCSIResponseParser ) scsiPdu . getBasicHeaderSegment ( ) . getParser ( ) ; if ( scsiParser . getStatus ( ) == SCSIStatus . GOOD ) return ; } throw", "gt": "new InternetSCSIException ( \"Error: Task did not finish successfully.\" ) ;", "prediction": "new InternetSCSIException ( scsiPdu . getStatus ( ) ) ;\n", "label": 1}
{"id": 4865, "input": "<s> package org . gk . server . utils ; import java . io . File ; import jfreecode . spring . context . WebSpringContext ; import org . apache . log4j . Logger ; public class PathUtils { private static Logger LOG = Logger . getLogger ( PathUtils . class ) ; public static String concat ( String p1 , String p2 ) { if ( p1 . endsWith ( \"/\" ) && p2 . startsWith ( \"/\" ) ) { return p1 + p2 . substring ( 1 ) ; } else if ( ! p1 . endsWith ( \"/\" ) && ! p2 . startsWith ( \"/\" ) ) { return p1 + \"/\" + p2 ; } else { return p1 + p2 ; } } public static String getUrlPath ( String filePath ) { String fp = \"filePath:\" + filePath ; int trimStringPos = WebSpringContext . webDirPath ( ) . length ( ) ; if ( WebSpringContext . isRoot ( ) ) { trimStringPos += WebSpringContext . rootPath ( ) . length ( ) ; } filePath = filePath . replace ( '\\\\' , '/' ) ; if ( filePath . startsWith ( WebSpringContext . webDirPath ( ) ) ) { filePath = filePath . substring ( trimStringPos ) ; } filePath = filePath . replaceAll ( \"/WEB-INF\" , \"/_WEB-INF\" ) ; LOG . info ( fp + \",urlPath:\" + filePath ) ; return filePath ; } public static String getFilePath ( String urlPath ) { String up = \"UrlPath:\" + urlPath ; urlPath = urlPath . replaceAll ( \"/_WEB-INF\" , \"/WEB-INF\" ) ; urlPath = WebSpringContext . isRoot ( ) ? WebSpringContext . rootPath ( ) + urlPath : urlPath ; if ( ! urlPath . startsWith ( WebSpringContext . webDirPath ( ) ) ) { urlPath = PathUtils . concat ( WebSpringContext . webDirPath ( ) , urlPath ) ; } LOG . info ( up + \",FilePath:\" + urlPath ) ; return urlPath ; } public static void main ( String [ ] args ) { String path = PathUtils . getFilePath ( PathUtils", "gt": ". getUrlPath ( \"./2.gul\" ) ) ;", "prediction": ". class ) ;\n", "label": 0}
{"id": 14058, "input": "<s> package com . ornament ; import java . util . Vector ; import processing . core . PApplet ; import com . datatype . Point ; import com . primitive2d . Ellipse ; import com . primitive2d . Line ; import com . primitive2d . Polygon ; import com . primitive2d . Drawable ; public class Fractal extends Pattern { public Point a = new Point ( 0 , 0 ) ; public Point b = new Point ( 800 , 500 ) ; private int levelLimit = 5 ; private double tri_Angle = 60 ; private String seedShape ; private double width = 500 ; private double height = 500 ; public Fractal ( Point start , Point end ) { super ( ) ; a = start . copy ( ) ; b = end . copy ( ) ; } public Fractal ( double startX , double startY , double endX , double endY ) { super ( ) ; a = new Point ( startX , startY ) ; b = new Point ( endX , endY ) ; } public void setAngle ( double angle ) { this . tri_Angle = angle ; } public void setLevelLimit ( int setLevel ) { levelLimit = setLevel ; } public void setSeedShape ( String setShape ) { seedShape = setShape ; } public void generate ( ) { Line line = new Line ( a , b ) ; this . addLine ( line ) ; for ( int i = 0 ; i < levelLimit ; i ++ ) iterate ( this . getAllLines ( ) ) ; } public void iterate ( Vector before ) { Vector now = new Vector ( ) ; for ( int i = 0 ; i < before . size ( ) ; i ++ ) { Line l = this . getLineAt ( i ) ; if ( seedShape == \"rectangle\" ) { now . addAll ( lineUp ( recPoints ( l ) ) ) ; } else { now . addAll ( lineUp ( triPoints ( l ) ) ) ; } } this . setAllLines ( now ) ; } public Vector triPoints ( Line l ) { Vector now = new Vector ( ) ; now . add ( start ( l ) ) ; now . add ( kochleft ( l ) ) ; now . add ( kochmiddle ( l ) ) ; now . add ( kochright ( l ) ) ; now . add ( end ( l ) ) ; return now ; } public Vector recPoints ( Line l ) { Vector now = new Vector ( ) ; now . add ( start ( l ) ) ; now . add ( recLeftDown ( l ) ) ; now . add ( recLeftUp ( l ) ) ; now . add ( recMidUp ( l ) ) ; now . add ( recMidMid ( l ) ) ; now . add ( recMidDown ( l ) ) ; now . add ( recRightDown ( l ) ) ; now . add ( recRightUp ( l ) ) ; now . add ( end ( l ) ) ; return now ; } Vector lineUp ( Vector dots ) { Vector orig = new Vector ( ) ; for ( int i = 0 ; i < dots . size ( ) - 1 ; i ++ ) { orig . add ( new Line ( ( Point ) dots . get ( i ) , ( Point ) dots . get ( i + 1 ) ) ) ; } return orig ; } public Point start ( Line l ) { return l . start . copy ( ) ; } public Point end ( Line l ) { return l . end . copy ( ) ; } public Point kochleft ( Line l ) { float x = ( float ) ( l . start . getX ( ) + ( l . end . getX ( ) - l . start . getX ( ) ) / 3f ) ; float y = ( float ) ( l . start . getY ( ) + ( l . end . getY ( ) - l . start . getY ( ) ) / 3f ) ; return new Point ( x , y ) ; } public Point kochmiddle ( Line l ) { float x = ( float ) ( l . start . getX ( ) + 0.5f * ( l . end . getX ( ) - l . start . getX ( ) ) + ( Math . sin ( Math . toRadians ( tri_Angle ) ) * ( l . end . getY ( ) - l . start . getY ( ) ) ) / 3f ) ; float y = ( float ) ( l . start . getY ( ) + 0.5f * ( l . end . getY ( ) - l . start . getY ( ) ) - ( Math . sin ( Math . toRadians ( tri_Angle ) ) * ( l . end . getX ( ) - l . start . getX ( ) ) ) / 3f ) ; return new Point ( x , y ) ; } public Point kochright ( Line l ) { float x = ( float ) ( l . start . getX ( ) + 2 * ( l . end . getX ( ) - l . start .", "gt": "getX ( ) ) / 3f ) ;", "prediction": "getX ( ) ) ) ;\n", "label": 1}
{"id": 7901, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class PackageIndexWriter extends AbstractPackageIndexWriter { private RootDoc root ; private Map < String , List < PackageDoc > > groupPackageMap ; private List < String > groupList ; public PackageIndexWriter ( ConfigurationImpl configuration , String filename ) throws IOException { super ( configuration , filename ) ; this . root = configuration . root ; groupPackageMap = configuration . group . groupPackages ( packages ) ; groupList = configuration . group . getGroupList ( ) ; } public static void generate ( ConfigurationImpl configuration ) { PackageIndexWriter packgen ; String filename = \"overview-summary.html\" ; try { packgen = new PackageIndexWriter ( configuration , filename ) ; packgen . buildPackageIndexFile ( \"doclet.Window_Overview_Summary\" , true ) ; packgen . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } protected void addIndex ( Content body ) { for ( int i = 0 ; i < groupList . size ( ) ; i ++ ) { String groupname = groupList . get ( i ) ; List < PackageDoc > list = groupPackageMap . get ( groupname ) ; if ( list != null && list . size ( ) > 0 ) { addIndexContents ( list . toArray ( new PackageDoc [ list . size ( ) ] ) , groupname , configuration . getText ( \"doclet.Member_Table_Summary\" , groupname , configuration . getText ( \"doclet.packages\" ) ) , body ) ; } } } protected void addPackagesList ( PackageDoc [ ] packages , String text , String tableSummary , Content body ) { Content table = HtmlTree . TABLE ( HtmlStyle . overviewSummary , 0 , 3 , 0 , tableSummary , getTableCaption ( text ) ) ; table . addContent ( getSummaryTableHeader ( packageTableHeader , \"col\" ) ) ; Content tbody = new HtmlTree ( HtmlTag . TBODY ) ; addPackagesList ( packages , tbody ) ; table . addContent ( tbody ) ; Content div = HtmlTree . DIV ( HtmlStyle . contentContainer , table ) ; body . addContent ( div ) ; } protected void addPackagesList ( PackageDoc [ ] packages , Content tbody ) { for ( int i = 0 ; i < packages . length ; i ++ ) { if ( packages [ i ] != null && packages [ i ] . name ( ) . length ( ) > 0 ) { if ( configuration . nodeprecated && Util . isDeprecated ( packages [ i ] ) ) continue ; Content packageLinkContent = getPackageLink ( packages [ i ] , getPackageName ( packages [ i ] ) ) ; Content tdPackage = HtmlTree . TD ( HtmlStyle . colFirst , packageLinkContent ) ; HtmlTree tdSummary = new HtmlTree ( HtmlTag . TD ) ; tdSummary . addStyle ( HtmlStyle . colLast ) ; addSummaryComment ( packages [ i ] , tdSummary ) ; HtmlTree tr = HtmlTree . TR ( tdPackage ) ; tr . addContent ( tdSummary ) ; if ( i % 2 == 0 ) tr . addStyle ( HtmlStyle . altColor ) ; else tr . addStyle ( HtmlStyle . rowColor ) ; tbody . addContent ( tr ) ; } } } protected void addOverviewHeader ( Content body ) { if ( root . inlineTags ( ) . length > 0 ) { HtmlTree subTitleDiv = new HtmlTree ( HtmlTag . DIV ) ; subTitleDiv . addStyle ( HtmlStyle . subTitle ) ; addSummaryComment ( root , subTitleDiv ) ; Content div = HtmlTree . DIV ( HtmlStyle . header , subTitleDiv ) ; Content see = seeLabel ; see . addContent ( \" \" ) ; Content descPara = HtmlTree . P ( see ) ; Content descLink = getHyperLink ( \"\" , \"overview_description\" , descriptionLabel , \"\" , \"\" ) ; descPara . addContent ( descLink ) ; div . addContent ( descPara ) ; body . addContent ( div ) ; } } protected", "gt": "void addOverviewComment ( Content htmltree )", "prediction": "void addSeeLabel ( Content body )\n", "label": 0}
{"id": 14065, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . connection . DataType ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . query . SortQuery ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisKeyTest extends RedisTestSupport { private RedisTemplate redisTemplate ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteDEL ( ) throws Exception { Collection < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"DEL\" , RedisConstants . KEYS , keys ) ; verify ( redisTemplate ) . delete ( keys ) ; } @ Test public void shouldExecuteEXISTS ( ) throws Exception { when ( redisTemplate . hasKey ( anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXISTS\" , RedisConstants . KEY , \"key\" ) ; verify ( redisTemplate ) . hasKey ( \"key\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIRE ( ) throws Exception { when ( redisTemplate . expire ( anyString ( ) , anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIRE\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" ) ; verify ( redisTemplate ) . expire ( \"key\" , 10L , TimeUnit . SECONDS ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIREAT ( ) throws Exception { when ( redisTemplate . expireAt ( anyString ( ) , any ( Date . class ) ) ) . thenReturn ( true ) ; long unixTime = System . currentTimeMillis ( ) / 1000L ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIREAT\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMESTAMP , unixTime ) ; verify ( redisTemplate ) . expireAt ( \"key\" , new Date ( unixTime * 1000L ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteKEYS ( ) throws Exception { Set < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; when ( redisTemplate . keys ( anyString ( ) ) ) . thenReturn ( keys ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"KEYS\" , RedisConstants . PATTERN , \"key*\" ) ; verify ( redisTemplate ) . keys ( \"key*\" ) ; assertEquals ( keys , result ) ; } @ Test public void shouldExecuteMOVE ( ) throws Exception { when ( redisTemplate . move ( anyString ( ) , anyInt ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"MOVE\" , RedisConstants . KEY , \"key\" , RedisConstants . DB , \"2\" ) ; verify ( redisTemplate ) . move ( \"key\" , 2 ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePERSIST ( ) throws Exception { when ( redisTemplate . persist ( anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PERSIST\" , RedisConstants . KEY , \"key\" ) ; verify ( redisTemplate ) . persist ( \"key\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePEXPIRE ( ) throws Exception { when ( redisTemplate . expire ( anyString ( ) , anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PEXPIRE\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" ) ; verify ( redisTemplate ) . expire ( \"key\" , 10L , TimeUnit . MILLISECONDS ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePEXPIREAT ( ) throws Exception { when ( redisTemplate . expireAt ( anyString ( ) , any ( Date . class ) ) ) . thenReturn ( true ) ; long millis = System . currentTimeMillis ( ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PEXPIREAT\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMESTAMP , millis ) ; verify ( redisTemplate ) . expireAt ( \"key\" , new Date ( millis ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteRANDOMKEY ( ) throws Exception { when ( redisTemplate . randomKey ( ) ) . thenReturn ( \"key\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"RANDOMKEY\" ) ; verify ( redisTemplate ) . randomKey ( ) ; assertEquals ( \"key\" , result ) ; } @ Test public void shouldExecuteRENAME ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"RENAME\" , RedisConstants . KEY , \"key\" ,", "gt": "RedisConstants . VALUE , \"newkey\" ) ;", "prediction": "RedisConstants . DB , \"2\" ) ;\n", "label": 1}
{"id": 2048, "input": "<s> class LocalEnum { void m ( ) { enum E { a", "gt": ", b , c }", "prediction": "}\n", "label": 0}
{"id": 14072, "input": "<s> package br . org . archimedes . io . pdf . rcp ; import br . org . archimedes . interfaces . DrawingExporter ; import br . org . archimedes . interfaces . FileModel ; import br . org . archimedes . interfaces . FileModelImpl ; import br . org . archimedes . io . pdf . PDFExporter ; import br . org . archimedes . model . Drawing ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . swt . widgets . MessageBox ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IExportWizard ; import org . eclipse . ui . IWorkbench ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PDFWizardExporter extends Wizard implements IExportWizard , DrawingExporter { private FileModel fileModel = new FileModelImpl ( ) ; private IStructuredSelection selection ; private IWorkbench workbench ; @ Override public boolean canFinish ( ) { String filePath = fileModel . getFilePath ( ) ; if ( filePath == null || selection . isEmpty ( ) || selection . getFirstElement ( ) . getClass ( ) != Drawing . class ) { return false ; } File file = new File ( filePath ) ; if ( file . isDirectory ( ) ) { return false ; } else if ( ! file . exists ( ) ) { File parent = file . getParentFile ( ) ; return parent != null && parent . isDirectory ( ) && parent . canWrite ( ) ; } else { return file . canWrite ( ) ; } } @ Override public boolean performFinish ( ) { PDFExporter exporter = new PDFExporter ( ) ; try { OutputStream output = new FileOutputStream ( fileModel . getFilePath ( ) ) ; Drawing drawing = ( Drawing ) selection . getFirstElement ( ) ; exporter . exportDrawing ( drawing , output ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; Shell shell = workbench . getActiveWorkbenchWindow ( ) . getShell ( ) ; MessageBox box = new MessageBox ( shell ) ; box . setMessage ( Messages . PDFWizardExporter_ErrorBoxTitle ) ; box . setText ( Messages . PDFWizardExporter_ErrorBoxMessage ) ; return false ; } return true ; } public void init ( IWorkbench workbench , IStructuredSelection selection ) { this . workbench = workbench ; this . selection = selection ; } public String getName ( ) { return Messages . PDFWizardExporter_ExporterName ; } @ Override public void addPages ( ) { super . addPages ( ) ; this", "gt": ". addPage ( new PDFFilePickerPage ( fileModel ) ) ;", "prediction": ". selection = selection ;\n", "label": 1}
{"id": 5564, "input": "<s> package com . asakusafw . example . direct . seqfile . jobflow ; import com . asakusafw . example . direct . seqfile . jobflow . format . StoreInfoSeqFileFormat ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . StoreInfo ; import com . asakusafw . runtime . directio . DataFormat ; import com . asakusafw . vocabulary . directio . DirectFileInputDescription ; public class StoreInfoFromSeqFile extends DirectFileInputDescription { @ Override public Class < ? > getModelType ( ) { return StoreInfo . class ; } @ Override public Class < ? extends", "gt": "DataFormat < ? > > getFormat ( )", "prediction": "StoreInfo > getStoreType ( )\n", "label": 0}
{"id": 14075, "input": "<s> package org . eclipse . ui . internal . expressions ; import org . eclipse . core . expressions . EvaluationResult ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . ExpressionInfo ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . internal . ActionExpression ; public final class LegacyActionExpressionWrapper extends WorkbenchWindowExpression { private static final int HASH_INITIAL = LegacyActionExpressionWrapper . class . getName ( ) . hashCode ( ) ; private final ActionExpression expression ; public LegacyActionExpressionWrapper ( final ActionExpression expression , final IWorkbenchWindow window ) { super ( window ) ; if ( expression == null ) { throw new NullPointerException ( \"The action expression cannot be null\" ) ; } this . expression = expression ; } public final void collectExpressionInfo ( final ExpressionInfo info ) { super . collectExpressionInfo ( info ) ; info . markDefaultVariableAccessed ( ) ; } protected final int computeHashCode ( ) { int hashCode = HASH_INITIAL * HASH_FACTOR + hashCode ( getWindow ( ) ) ; hashCode = hashCode * HASH_FACTOR + hashCode ( expression ) ; return hashCode ; } public final boolean equals ( final Object object ) { if ( object instanceof LegacyActionExpressionWrapper ) { final LegacyActionExpressionWrapper that = ( LegacyActionExpressionWrapper ) object ; return equals ( this . expression , that . expression ) && equals ( this . getWindow ( ) , that . getWindow ( ) ) ; } return false ; } public final EvaluationResult evaluate ( final IEvaluationContext context ) throws CoreException { final EvaluationResult result = super . evaluate ( context ) ; if ( result == EvaluationResult . FALSE ) { return result ; } final Object defaultVariable = context . getVariable ( ISources . ACTIVE_CURRENT_SELECTION_NAME ) ; if ( defaultVariable instanceof IStructuredSelection ) { final IStructuredSelection selection = ( IStructuredSelection ) defaultVariable ; if ( expression . isEnabledFor ( selection ) ) { return EvaluationResult . TRUE ; } } else if ( expression . isEnabledFor ( defaultVariable ) ) { return EvaluationResult . TRUE ; } return EvaluationResult . FALSE ; } public final String toString ( ) { final StringBuffer buffer", "gt": "= new StringBuffer ( ) ;", "prediction": "= new StringBuffer ( ) ;\n", "label": 1}
{"id": 1042, "input": "<s> package de . javawi . jstun . test . demo . ice ; import java . io . IOException ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; import de . javawi . jstun . attribute . MessageAttributeException ; import de . javawi . jstun . header . MessageHeaderParsingException ; import de . javawi . jstun . test . DiscoveryInfo ; import de . javawi . jstun . test . DiscoveryTest ; import de . javawi . jstun . test . demo . ice . Candidate . CandidateType ; import de . javawi . jstun . util . Address ; import de . javawi . jstun . util . UtilityException ; public class ICENegociator { private static final Logger LOGGER = LoggerFactory . getLogger ( ICENegociator . class ) ; private final static int LOCAL_PREFERENCE = 0 ; private final static int SERVER_REFLEXIVE_PREFERENCE = 42 ; private final static int PEER_REFLEXIVE_PREFERENCE = 84 ; private final static int RELAYED_PREFERENCE = 126 ; private short componentId ; private String stunServer = \"jstun.javawi.de\" ; private int stunPort = 3478 ; HashSet < Candidate > candidates ; public ICENegociator ( short componentId ) { this . componentId = componentId ; candidates = new HashSet < Candidate > ( ) ; } public ICENegociator ( String stunServer , int stunPort , short componentId ) { this . stunServer = stunServer ; this . stunPort = stunPort ; this . componentId = componentId ; candidates = new HashSet < Candidate > ( ) ; } public void gatherCandidateAddresses ( ) { try { candidates = new HashSet < Candidate > ( ) ; Enumeration < NetworkInterface > ifaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( ifaces . hasMoreElements ( ) ) { NetworkInterface iface = ifaces . nextElement ( ) ; Enumeration < InetAddress > iaddresses = iface . getInetAddresses ( ) ; while ( iaddresses . hasMoreElements ( ) ) { InetAddress iaddress = iaddresses . nextElement ( ) ; if ( ! iaddress . isLoopbackAddress ( ) && ! iaddress . isLinkLocalAddress ( ) ) { try { Candidate local = new Candidate ( new Address ( iaddress . getAddress ( ) ) , componentId ) ; candidates . add ( local ) ; DiscoveryTest test = new DiscoveryTest ( iaddress , stunServer , stunPort ) ; DiscoveryInfo di = test . test ( ) ; if ( di . getPublicIP ( ) != null ) { Candidate cand = new Candidate ( new Address ( di . getPublicIP ( ) . getAddress ( ) ) , CandidateType . ServerReflexive , componentId , local ) ; cand . setComponentId ( componentId ) ; candidates . add ( cand ) ; } } catch ( MessageHeaderParsingException mhpe ) { LOGGER . debug ( \"MessageHeaderParsingException while gathering candidate addresses.\" ) ; mhpe . printStackTrace ( ) ; } catch ( MessageAttributeException mae ) { LOGGER . debug ( \"MessageAttributeException while gathering candidate addresses.\" ) ; mae . printStackTrace ( ) ; } catch ( UtilityException ue ) { LOGGER . debug ( \"UtilityException while gathering candidate addresses.\" ) ; ue . printStackTrace ( ) ; } catch ( UnknownHostException uhe ) { LOGGER . debug ( \"MessageHeaderParsingException while gathering candidate addresses.\" ) ; uhe . printStackTrace ( ) ; } catch ( SocketException se ) { LOGGER . debug ( \"SocketException while gathering candidate addresses.\" ) ; se . printStackTrace ( ) ; } catch ( IOException ioe ) { LOGGER . debug ( \"IOException while gathering candidate addresses.\" ) ; ioe . printStackTrace ( ) ; } } } } } catch ( SocketException se ) { LOGGER . debug ( \"SocketException while enumatering over the network cards.\" ) ; se . printStackTrace ( ) ; } } public void prioritizeCandidates ( ) { int numberLocal = 0 ; int numberServerReflexive = 0 ; int numberPeerReflexive = 0 ; int numberRelayed = 0 ; Iterator < Candidate > iterCandidates = candidates . iterator ( ) ; while ( iterCandidates . hasNext ( ) ) { Candidate cand = iterCandidates . next ( ) ; CandidateType type = cand . getCandidateType ( ) ; if ( type == CandidateType . Local ) numberLocal ++ ; else if ( type == CandidateType . ServerReflexive ) numberServerReflexive ++ ; else if ( type == CandidateType . PeerReflexive ) numberPeerReflexive ++ ; else if ( type == CandidateType . Relayed ) numberRelayed ++ ; } iterCandidates = candidates . iterator ( ) ; while ( iterCandidates . hasNext ( ) ) { int typeValue = 0 ; int localValue = 0 ; int componentValue = 0 ; Candidate cand = iterCandidates . next ( ) ; CandidateType type = cand . getCandidateType ( ) ; if ( type == CandidateType . Local ) { typeValue = LOCAL_PREFERENCE ; localValue = numberLocal -- ; } else if ( type == CandidateType . ServerReflexive ) { typeValue = SERVER_REFLEXIVE_PREFERENCE ; localValue = numberServerReflexive -- ; } else if ( type == CandidateType . PeerReflexive ) { typeValue = PEER_REFLEXIVE_PREFERENCE ; localValue = numberPeerReflexive -- ; } else if ( type == CandidateType . Relayed ) { typeValue = RELAYED_PREFERENCE ; localValue = numberRelayed -- ; } componentValue = cand . getComponentId ( ) ; int priority = ( ( 2 ^ 24 ) * typeValue ) + ( ( 2 ^ 8 ) * localValue ) + componentValue ; cand . setPriority ( priority ) ; } } public List < Candidate > getSortedCandidates ( ) { Vector < Candidate > sortedCandidates =", "gt": "new Vector < Candidate > ( candidates ) ;", "prediction": "new Vector < Candidate > ( ) ;\n", "label": 0}
{"id": 14078, "input": "<s> package br . org . archimedes . model . references ; import java . util . ArrayList ; import java . util . List ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . ReferencePoint ; public class SquarePoint extends ReferencePoint { public SquarePoint ( Point point ) throws NullArgumentException { super ( point ) ; } public SquarePoint ( Point point , List < Point > pointsToMove ) throws NullArgumentException { super ( point , pointsToMove ) ; } public SquarePoint ( Point point , Point ... pointsToMove ) throws NullArgumentException { super ( point , pointsToMove ) ; } @ Override public void draw ( ) { OpenGLWrapper openGLWrapper = br . org . archimedes . Utils . getOpenGLWrapper ( ) ; double size = br . org . archimedes . Utils . getWorkspace ( ) . getGripSize ( ) / 2 ; Point point = null ; try { point = br . org . archimedes . Utils . getWorkspace ( ) . modelToScreen ( getPoint ( ) ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } List < Point > square = new ArrayList < Point > ( ) ; square . add ( new Point ( point . getX ( ) - size , point . getY ( ) - size ) ) ; square . add ( new Point ( point . getX ( ) + size , point . getY ( ) - size ) ) ; square . add ( new Point ( point . getX ( ) + size , point . getY ( ) + size ) ) ; square . add ( new Point ( point . getX ( ) - size , point . getY ( ) + size ) ) ; try { openGLWrapper .", "gt": "draw ( square ) ;", "prediction": "draw ( square ) ;\n", "label": 1}
{"id": 8697, "input": "<s> import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import java . util . * ; import com . sun . source . tree . * ; import com . sun . source . util . * ; public class TestResourceElement extends JavacTestingAbstractProcessor implements AutoCloseable { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ! roundEnv . processingOver ( ) ) { Trees trees = Trees . instance ( processingEnv ) ; for ( Element rootElement : roundEnv . getRootElements ( ) ) { TreePath treePath = trees . getPath ( rootElement ) ; VariableScanner varScanner = new VariableScanner ( trees ) ; varScanner . scan ( trees . getTree ( rootElement ) , treePath . getCompilationUnit ( ) ) ; if ( varScanner . getTrvElement ( ) == null ) { throw new AssertionError ( \"Element is null for 'trv'\" ) ; } } } return true ; } @ Override public void close ( ) { } private void test1 ( ) { try ( TestResourceElement trv = this ) { } } class VariableScanner extends TreeScanner < Void , CompilationUnitTree > { private Trees trees ; private Element trvElement ; public VariableScanner ( Trees trees ) { super ( ) ; this . trees = trees ; } @ Override public Void visitVariable", "gt": "( VariableTree node , CompilationUnitTree cu )", "prediction": "( Element e , Void aVoid )\n", "label": 0}
{"id": 14085, "input": "<s> package org . restlet . routing ; import java . util . logging . Level ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . Representation ; import org . restlet . util . Resolver ; public class Redirector extends Restlet { public static final int MODE_CLIENT_PERMANENT = 1 ; public static final int MODE_CLIENT_FOUND = 2 ; public static final int MODE_CLIENT_SEE_OTHER = 3 ; public static final int MODE_CLIENT_TEMPORARY = 4 ; public static final int MODE_SERVER_OUTBOUND = 6 ; public static final int MODE_SERVER_INBOUND = 7 ; protected volatile String targetTemplate ; protected volatile int mode ; public Redirector ( Context context , String targetTemplate ) { this ( context , targetTemplate , MODE_SERVER_OUTBOUND ) ; } public Redirector ( Context context , String targetPattern , int mode ) { super ( context ) ; this . targetTemplate = targetPattern ; this . mode = mode ; } public int getMode ( ) { return this . mode ; } protected Reference getTargetRef ( Request request , Response response ) { Template rt = new Template ( this . targetTemplate ) ; rt . setLogger ( getLogger ( ) ) ; if ( new Reference ( this . targetTemplate ) . isRelative ( ) ) { return new Reference ( request . getResourceRef ( ) , rt . format ( request , response ) ) ; } return new Reference ( rt . format ( request , response ) ) ; } public String getTargetTemplate ( ) { return this . targetTemplate ; } @ Override public void handle ( Request request , Response response ) { Reference targetRef = getTargetRef ( request , response ) ; switch ( this . mode ) { case MODE_CLIENT_PERMANENT : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Permanently redirecting client to: \" + targetRef ) ; } response . redirectPermanent ( targetRef ) ; break ; case MODE_CLIENT_FOUND : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Redirecting client to found location: \" + targetRef ) ; } response . setLocationRef ( targetRef ) ; response . setStatus ( Status . REDIRECTION_FOUND ) ; break ; case MODE_CLIENT_SEE_OTHER : if", "gt": "( request . isLoggable ( ) )", "prediction": "( request . isLoggable ( ) )\n", "label": 1}
{"id": 7855, "input": "<s> package Liza ; import org . bukkit . entity . Painting ;", "gt": "public interface LizaPainting extends Painting", "prediction": "import org . bukkit . entity . Item ;\n", "label": 0}
{"id": 14090, "input": "<s> package org . eclipse . swt . events ; import static org . mockito . Mockito . mock ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Widget ; import junit . framework . TestCase ; public class ModifyEvent_Test extends TestCase { public void testUntypedEventConstructor ( ) throws Exception { Event event = new Event ( ) ; event . display = mock ( Display . class ) ; event . widget = mock ( Widget . class ) ; event . time = 1 ; event . doit = true ; event . data = new Object ( ) ; ModifyEvent modifyEvent = new", "gt": "ModifyEvent ( event ) ;", "prediction": "ModifyEvent ( event ) ;\n", "label": 1}
{"id": 8348, "input": "<s> public interface AdditiveClosure < E extends Value", "gt": "> extends AdditionDefined < E >", "prediction": ">\n", "label": 0}
{"id": 14095, "input": "<s> package org . spliffy . server . web ; import com . bradmcevoy . http . Auth ; import com . bradmcevoy . http . GetableResource ; import com . bradmcevoy . http . Range ; import com . bradmcevoy . http . Request ; import com . bradmcevoy . http . Request . Method ; import com . bradmcevoy . http . exceptions . BadRequestException ; import com . bradmcevoy . http . exceptions . NotAuthorizedException ; import com . bradmcevoy . http . exceptions . NotFoundException ; import com . ettrema . http . acl . Principal ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Date ; import java . util . List ; import java . util . Map ; import org . spliffy . server . db . BaseEntity ; import org . spliffy . server . db . Organisation ; import org . spliffy . server . db . Profile ; public class TemplatedTextPage extends AbstractResource implements GetableResource { protected final String name ; protected final SpliffyCollectionResource parent ; protected final String contentType ; protected final String template ; public TemplatedTextPage ( String name , SpliffyCollectionResource parent , Services services , String contentType , String template ) { super ( services ) ; this . name = name ; this . parent = parent ; this . contentType = contentType ; this . template = template ; } @ Override public boolean authorise ( Request request , Method method , Auth auth ) { return true ; } @ Override public void sendContent ( OutputStream out , Range range , Map < String , String > params , String contentType ) throws IOException , NotAuthorizedException , BadRequestException , NotFoundException { System . out . println ( \"template: \" + template ) ; services . getTextTemplater ( ) . writePage ( template , this , params , out ) ; } @ Override public Long getContentLength ( ) { return null ; } @ Override public String getContentType ( String accepts ) { return contentType ; } @ Override public boolean isDir ( ) { return false ; } @ Override public SpliffyCollectionResource getParent ( ) { return parent ; } @ Override public BaseEntity getOwner ( ) { return parent . getOwner ( ) ; } @ Override", "gt": "public Organisation getOrganisation ( )", "prediction": "public String getName ( )\n", "label": 1}
{"id": 4625, "input": "<s> package domain ; import java . io . Serializable ; import javax . persistence . * ; import java . util . Set ; @ Entity public class Course implements Serializable { private static final long serialVersionUID = 1L ; @ Id @ SequenceGenerator ( name = \"COURSE_CODE_GENERATOR\" , sequenceName = \"COURSE_ID_SEQ\" ) @ GeneratedValue ( strategy = GenerationType . SEQUENCE , generator = \"COURSE_CODE_GENERATOR\" ) private String code ; private String description ; private String name ; @ OneToMany ( mappedBy = \"course\" ) private Set < CourseOccasion > courseOccasions ; public Course ( ) { } public String getCode ( ) { return this . code ; } public void setCode ( String code ) { this . code = code ; } public String getDescription ( ) { return this . description ; } public void", "gt": "setDescription ( String description )", "prediction": "setDescription ( String description )\n", "label": 0}
{"id": 14096, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . File ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IOUtils ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; public class MySQLAuthTest extends ImportJobTestCase { public static final Log LOG = LogFactory . getLog ( MySQLAuthTest . class . getName ( ) ) ; static final String HOST_URL = System . getProperty ( \"sqoop.test.mysql.connectstring.host_url\" , \"jdbc:mysql://localhost/\" ) ; static final String AUTH_TEST_DATABASE = \"sqooppasstest\" ; static final String AUTH_TEST_USER = \"sqooptest\" ; static final String AUTH_TEST_PASS = \"12345\" ; static final String AUTH_TABLE_NAME = \"authtest\" ; static final String AUTH_CONNECT_STRING = HOST_URL + AUTH_TEST_DATABASE ; private DirectMySQLManager manager ; @ Override protected boolean useHsqldbTestServer ( ) { return false ; } @ Before public void setUp ( ) { super . setUp ( ) ; SqoopOptions options = new SqoopOptions ( AUTH_CONNECT_STRING , AUTH_TABLE_NAME ) ; options . setUsername ( AUTH_TEST_USER ) ; options . setPassword ( AUTH_TEST_PASS ) ; LOG . debug ( \"Setting up another MySQLAuthTest: \" + AUTH_CONNECT_STRING ) ; manager = new DirectMySQLManager ( options ) ; Connection connection = null ; Statement st = null ; try { connection = manager . getConnection ( ) ; connection . setAutoCommit ( false ) ; st = connection . createStatement ( ) ; st . executeUpdate ( \"DROP TABLE IF EXISTS \" + AUTH_TABLE_NAME ) ; st . executeUpdate ( \"CREATE TABLE \" + AUTH_TABLE_NAME + \" (\" + \"id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, \" + \"name VARCHAR(24) NOT NULL)\" ) ; st . executeUpdate ( \"INSERT INTO \" + AUTH_TABLE_NAME + \" VALUES(\" + \"NULL,'Aaron')\" ) ; connection . commit ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Encountered SQL Exception: \" + sqlE ) ; sqlE . printStackTrace ( ) ; fail ( \"SQLException when running test setUp(): \" + sqlE ) ; } finally { try { if ( null != st ) { st . close ( ) ; } if ( null != connection ) { connection . close ( ) ; } } catch ( SQLException sqlE ) { LOG . warn ( \"Got SQLException when closing connection: \" + sqlE ) ; } } } @ After public void tearDown ( ) { super . tearDown ( ) ; try { manager . close ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Got SQLException: \" + sqlE . toString ( ) ) ; fail ( \"Got SQLException: \" + sqlE . toString ( ) ) ; } } private String [ ] getArgv ( boolean includeHadoopFlags , boolean useDirect , String connectString , String tableName ) { ArrayList < String > args = new ArrayList < String > ( ) ; if ( includeHadoopFlags ) { CommonArgs . addHadoopFlags ( args ) ; } args . add ( \"--table\" ) ; args . add ( tableName ) ; args . add ( \"--warehouse-dir\" ) ; args . add ( getWarehouseDir ( ) ) ; args . add ( \"--connect\" ) ; args . add ( connectString ) ; if ( useDirect ) { args . add ( \"--direct\" ) ; } args . add ( \"--username\" ) ; args . add ( AUTH_TEST_USER ) ; args . add ( \"--password\" ) ; args . add ( AUTH_TEST_PASS ) ; args . add ( \"--mysql-delimiters\" ) ; args . add ( \"--num-mappers\" ) ; args . add ( \"1\" ) ; return args . toArray ( new String [ 0 ] ) ; } @ Test public void testAuthAccess ( ) { String [ ] argv = getArgv ( true , true , AUTH_CONNECT_STRING , AUTH_TABLE_NAME ) ; try { runImport ( argv ) ; } catch ( IOException ioe ) { LOG . error ( \"Got IOException during import: \" + ioe . toString ( ) ) ; ioe . printStackTrace ( ) ; fail ( ioe . toString ( ) ) ; } Path warehousePath = new Path ( this . getWarehouseDir ( ) ) ; Path tablePath = new Path ( warehousePath , AUTH_TABLE_NAME ) ; Path filePath = new Path ( tablePath , \"part-m-00000\" ) ; File f = new File ( filePath . toString ( ) ) ; assertTrue ( \"Could not find imported data file\" , f . exists ( ) ) ; BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new FileInputStream ( f ) ) ) ; assertEquals ( \"1,'Aaron'\" , r . readLine ( ) ) ; } catch ( IOException ioe ) { LOG . error ( \"Got IOException verifying results:", "gt": "\" + ioe . toString ( ) ) ;", "prediction": "\" + ioe . toString ( ) ) ;\n", "label": 1}
{"id": 3748, "input": "<s> package com . extjs . gxt . ui . client . widget . form ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . util . Size ; import com . google . gwt . dom . client . Style . VerticalAlign ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; public class TwinTriggerField < D > extends TriggerField < D > { protected El twinTrigger ; private String twinTriggerStyle = \"x-form-trigger-arrow\" ; protected El span ; public String getTwinTriggerStyle ( ) { return twinTriggerStyle ; } @ Override public void onComponentEvent ( ComponentEvent ce ) { super . onComponentEvent ( ce ) ; int type = ce . getEventTypeInt ( ) ; if ( ce . getTarget ( ) == twinTrigger . dom && type == Event . ONCLICK && ! readOnly ) { onTwinTriggerClick ( ce ) ; } } public void setTwinTriggerStyle ( String twinTriggerStyle ) { this . twinTriggerStyle = twinTriggerStyle ; } @ Override protected Size adjustInputSize ( ) { return new Size ( isHideTrigger ( ) ? 0 : ( trigger . getStyleSize ( ) . width + twinTrigger . getStyleSize ( ) . width ) , 0 ) ; } @ Override protected void onRender ( Element target , int index ) { input = new El ( DOM . createInputText ( ) ) ; setElement ( DOM . createDiv ( ) , target , index ) ; addStyleName ( \"x-form-field-wrap\" ) ; trigger = new El ( DOM . createImg ( ) ) ; trigger . dom . setClassName ( \"x-form-trigger \" + triggerStyle ) ; trigger . dom . setPropertyString ( \"src\" , GXT . BLANK_IMAGE_URL ) ; twinTrigger = new El ( DOM . createImg ( ) ) ; twinTrigger . dom . setClassName ( \"x-form-trigger \" + twinTriggerStyle ) ; twinTrigger . dom . setPropertyString ( \"src\" , GXT . BLANK_IMAGE_URL ) ; span = new El ( DOM . createSpan ( ) ) ; span . dom . setClassName ( \"x-form-twin-triggers\" ) ; span . appendChild ( trigger . dom ) ; span . appendChild ( twinTrigger . dom ) ; if ( GXT . isChrome ) { input . dom . getStyle ( ) . setVerticalAlign ( VerticalAlign . TOP ) ; } el ( ) . appendChild ( input . dom ) ; el ( ) . appendChild ( span . dom ) ; if ( isHideTrigger ( ) ) { span . setVisible ( false ) ; } addStyleOnOver ( twinTrigger .", "gt": "dom , \"x-form-trigger-over\" ) ;", "prediction": "dom ) ;\n", "label": 0}
{"id": 14102, "input": "<s> package org . eclipse . rap . rwt . internal . util ; import java . util . Arrays ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . util . ActiveKeysUtil ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . SetOperation ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; public class ActiveKeysUtil_Test extends TestCase { private Display display ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testPreserveKeyBindingsEmpty ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; Fixture . preserveWidgets ( ) ; assertNull ( adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ) ; } public void testPreserveKeyBindings ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testPreserveActiveKeys ( ) { Shell shell = new Shell ( display ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( shell ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( shell ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; shell . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testKeyBindingsSafeCopy ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; keyBindings [ 0 ] = \"CTRL+B\" ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertEquals ( \"CTRL+A\" , preserved [ 0 ] ) ; } public void testPreserveCancelKeysEmpty ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; Fixture . preserveWidgets ( ) ; assertNull ( adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ) ; } public void testPreserveCancelKeys ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testPreserveCancelKeysOnWidget ( ) { Shell shell = new Shell ( display ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( shell ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( shell ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; shell . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testCancelKeySafeCopy ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; keyBindings [ 0 ] = \"CTRL+B\" ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertEquals ( \"CTRL+A\" , preserved [ 0 ] ) ; } public void testWriteKeyBindings ( ) throws JSONException { Fixture . fakeNewRequest ( ) ; String [ ] keyBindings = new String [ ] { \"x\" , \"ALT+x\" , \"E\" , \"CTRL+INSERT\" , \"CTRL+E\" , \"SHIFT+CTRL+ALT+1\" , \"CTRL+ALT+E\" , \"F1\" , \"/\" , \"SHIFT+~\" , \"CTRL+ALT+#\" , \".\" , \",\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; ActiveKeysUtil . renderActiveKeys ( display ) ; String expected = \"\\\"#88\\\",\" + \"\\\"ALT+#88\\\",\" + \"\\\"#69\\\",\" + \"\\\"CTRL+#45\\\",\" + \"\\\"CTRL+#69\\\",\" + \"\\\"ALT+CTRL+SHIFT+#49\\\",\" + \"\\\"ALT+CTRL+#69\\\",\" + \"\\\"#112\\\",\" + \"\\\"/\\\",\" + \"\\\"SHIFT+~\\\",\" + \"\\\"ALT+CTRL+#\\\",\" + \"\\\".\\\",\" + \"\\\",\\\"\" ; Message message = Fixture . getProtocolMessage ( ) ; SetOperation operation = message . findSetOperation ( \"w1\" , \"activeKeys\" ) ; JSONArray activeKeys = ( JSONArray ) operation . getProperty ( \"activeKeys\" ) ; assertEquals ( expected , activeKeys . join ( \",\" ) ) ; } public void testWriteKeyBindingsOnWidget ( ) throws JSONException { Fixture . fakeNewRequest ( ) ; Shell shell = new Shell ( display ) ; String [ ] activeKeys = new String [ ] { \"x\" , \"ALT+x\" , } ; shell . setData ( RWT . ACTIVE_KEYS , activeKeys ) ; ActiveKeysUtil . renderActiveKeys ( shell ) ; String expected = \"\\\"#88\\\",\\\"ALT+#88\\\"\" ; Message message = Fixture . getProtocolMessage ( ) ; SetOperation operation = message . findSetOperation ( shell , \"activeKeys\" ) ; JSONArray renderedKeys = ( JSONArray ) operation . getProperty ( \"activeKeys\" ) ; assertEquals ( expected ,", "gt": "renderedKeys . join ( \",\" ) ) ;", "prediction": "renderedKeys . join ( \",\" ) ) ;\n", "label": 1}
{"id": 7508, "input": "<s> import java . lang . reflect . Method ; import java . util . * ; import com . sun . mirror . apt . * ; public class TestProcessor implements AnnotationProcessor { AnnotationProcessorEnvironment env ; Tester tester = Tester . activeTester ; TestProcessor ( AnnotationProcessorEnvironment env , Tester tester ) { this . env = env ; this . tester = tester ; } public void process ( ) { System . out . printf ( \"\\n> Processing %s\\n\" , tester . getClass ( ) ) ; boolean failed = false ; for ( Method m : tester . getClass ( ) . getDeclaredMethods ( ) ) { Test anno = m . getAnnotation ( Test . class ) ; Ignore ignore = m . getAnnotation ( Ignore . class ) ; if ( anno != null ) { if ( ignore == null ) { System . out . println ( \">> Invoking test \" + m . getName ( ) ) ; Object result ; try { result = m . invoke ( tester ) ; } catch ( Exception e ) { throw new Error ( \"Test invocation failed\" , e ) ; } boolean ok = true ; if ( Collection . class . isAssignableFrom ( m . getReturnType ( ) ) ) { ok = verifyResults ( ( Collection ) result , anno . result ( ) , anno . ordered ( ) ) ; } else if ( m . getReturnType ( ) != void . class ) { ok = verifyResult ( result , anno . result ( ) ) ; } if ( ! ok ) { System . out . println ( \">>> Expected: \" + anno ) ; System . out . println ( \">>> Got: \" + result ) ; failed = true ; } } else { System . out . println ( \">> Ignoring test \" + m . getName ( ) ) ; if ( ignore . value ( ) . length ( ) > 0 ) { System . out . println ( \">>> Reason: \" + ignore . value ( ) ) ; } } } } if ( failed ) { throw new Error ( \"Test(s) returned unexpected result\" ) ; } } private boolean verifyResult ( Object result , String [ ] expected ) { assert expected . length == 1 : \"Single-valued test expecting \" + expected . length + \" results\" ; return expected [ 0 ] . equals ( String . valueOf ( result ) ) ; } private boolean verifyResults ( Collection result , String [ ] expected , boolean ordered ) { if ( result . size ( ) != expected . length ) { return false ; } String [ ] res = new String [ result . size ( ) ] ; int i = 0 ; for ( Object e : result ) { res [ i ++ ] = String . valueOf ( e ) ; } if ( ! ordered ) {", "gt": "Arrays . sort ( res ) ;", "prediction": "return false ;\n", "label": 0}
{"id": 14112, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class VerifyEvent extends KeyEvent { private static final long serialVersionUID = 1L ; public String text ; public int start , end ; public VerifyEvent ( Event event ) { super ( event ) ; this . start = event . start ; this . end = event . end ; this . text = event . text ; } @ Override public String toString ( ) { String", "gt": "string = super . toString ( ) ;", "prediction": "Buffer sb = new StringBuffer ( ) ;\n", "label": 1}
{"id": 5650, "input": "<s> package com . deliciousdroid . action ; import java . io . IOException ; import org . apache . http . auth . AuthenticationException ; import android . accounts . Account ; import android . content . Context ; import android . os . AsyncTask ; import android . widget . Toast ; import com . deliciousdroid . client . DeliciousApi ; import com . deliciousdroid . platform . BookmarkManager ; import com . deliciousdroid . platform . TagManager ; import com . deliciousdroid . providers . BookmarkContent . Bookmark ; import com . deliciousdroid . providers . TagContent . Tag ; public class DeleteBookmarkTask extends AsyncTask < BookmarkTaskArgs , Integer , Boolean > { private Context context ; private Bookmark bookmark ; private Account account ; @ Override protected Boolean doInBackground ( BookmarkTaskArgs ... args ) { context = args [ 0 ] . getContext ( ) ; bookmark = args [ 0 ] . getBookmark ( ) ; account = args [ 0 ] . getAccount ( ) ; try { Boolean success = DeliciousApi . deleteBookmark ( bookmark , account , context ) ; if ( success ) { BookmarkManager . DeleteBookmark ( args [ 0 ] . getBookmark ( ) , context ) ; return true ; } else return false ; }", "gt": "catch ( IOException e )", "prediction": "catch ( Exception e )\n", "label": 0}
{"id": 14113, "input": "<s> package utility ; import org . lwjgl . input . Keyboard ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . GLContext ; import org . lwjgl . util . glu . GLU ; import static java . lang . Math . * ; import static org . lwjgl . opengl . ARBDepthClamp . GL_DEPTH_CLAMP ; import static org . lwjgl . opengl . GL11 . * ; public final class EulerCamera implements Camera { private float x = 0 ; private float y = 0 ; private float z = 0 ; private float pitch = 0 ; private float yaw = 0 ; private float roll = 0 ; private float fov = 90 ; private float aspectRatio = 1 ; private final float zNear ; private final float zFar ; public EulerCamera ( Builder builder ) { this . x = builder . x ; this . y = builder . y ; this . z = builder . z ; this . pitch = builder . pitch ; this . yaw = builder . yaw ; this . roll = builder . roll ; this . aspectRatio = builder . aspectRatio ; this . zNear = builder . zNear ; this . zFar = builder . zFar ; this . fov = builder . fov ; } public EulerCamera ( ) { this . zNear = 0.3f ; this . zFar = 100 ; } public EulerCamera ( float aspectRatio ) { if ( aspectRatio <= 0 ) { throw new IllegalArgumentException ( \"aspectRatio \" + aspectRatio + \" was 0 or was smaller than 0\" ) ; } this . aspectRatio = aspectRatio ; this . zNear = 0.3f ; this . zFar = 100 ; } public EulerCamera ( float aspectRatio , float x , float y , float z ) { this ( aspectRatio ) ; this . x = x ; this . y = y ; this . z = z ; } public EulerCamera ( float aspectRatio , float x , float y , float z , float pitch , float yaw , float roll ) { this ( aspectRatio , x , y , z ) ; this . pitch = pitch ; this . yaw = yaw ; this . roll = roll ; } public EulerCamera ( float aspectRatio , float x , float y , float z , float pitch , float yaw , float roll , float zNear , float zFar ) { if ( aspectRatio <= 0 ) { throw new IllegalArgumentException ( \"aspectRatio \" + aspectRatio + \" was 0 or was smaller than 0\" ) ; } if ( zNear <= 0 ) { throw new IllegalArgumentException ( \"zNear \" + zNear + \" was 0 or was smaller than 0\" ) ; } if ( zFar <= zNear ) { throw new IllegalArgumentException ( \"zFar \" + zFar + \" was smaller or the same as zNear \" + zNear ) ; } this . aspectRatio = aspectRatio ; this . x = x ; this . y = y ; this . z = z ; this . pitch = pitch ; this . yaw = yaw ; this . roll = roll ; this . zNear = zNear ; this . zFar = zFar ; } public void processMouse ( ) { final float MAX_LOOK_UP = 90 ; final float MAX_LOOK_DOWN = - 90 ; float mouseDX = Mouse . getDX ( ) * 0.16f ; float mouseDY = Mouse . getDY ( ) * 0.16f ; if ( yaw + mouseDX >= 360 ) { yaw = yaw + mouseDX - 360 ; } else if ( yaw + mouseDX < 0 ) { yaw = 360 - yaw + mouseDX ; } else { yaw += mouseDX ; } if ( pitch - mouseDY >= MAX_LOOK_DOWN && pitch - mouseDY <= MAX_LOOK_UP ) { pitch += - mouseDY ; } else if ( pitch - mouseDY < MAX_LOOK_DOWN ) { pitch = MAX_LOOK_DOWN ; } else if ( pitch - mouseDY > MAX_LOOK_UP ) { pitch = MAX_LOOK_UP ; } } public void processMouse ( float mouseSpeed ) { final float MAX_LOOK_UP = 90 ; final float MAX_LOOK_DOWN = - 90 ; float mouseDX = Mouse . getDX ( ) * mouseSpeed * 0.16f ; float mouseDY = Mouse . getDY ( ) * mouseSpeed * 0.16f ; if ( yaw + mouseDX >= 360 ) { yaw = yaw + mouseDX - 360 ; } else if ( yaw + mouseDX < 0 ) { yaw = 360 - yaw + mouseDX ; } else { yaw += mouseDX ; } if ( pitch - mouseDY >= MAX_LOOK_DOWN && pitch - mouseDY <= MAX_LOOK_UP ) { pitch += - mouseDY ; } else if ( pitch - mouseDY < MAX_LOOK_DOWN ) { pitch = MAX_LOOK_DOWN ; } else if ( pitch - mouseDY > MAX_LOOK_UP ) { pitch = MAX_LOOK_UP ; } } public void processMouse ( float mouseSpeed , float maxLookUp , float maxLookDown ) { float mouseDX = Mouse . getDX ( ) * mouseSpeed * 0.16f ; float mouseDY = Mouse . getDY ( ) * mouseSpeed * 0.16f ; if ( yaw + mouseDX >= 360 ) { yaw = yaw + mouseDX - 360 ; } else if ( yaw + mouseDX < 0 ) { yaw = 360 - yaw + mouseDX ; } else { yaw += mouseDX ; } if ( pitch - mouseDY >= maxLookDown && pitch - mouseDY <= maxLookUp ) { pitch += - mouseDY ; } else if ( pitch - mouseDY < maxLookDown ) { pitch = maxLookDown ; } else if (", "gt": "pitch - mouseDY > maxLookUp )", "prediction": "pitch - mouseDY > maxLookUp )\n", "label": 1}
{"id": 5762, "input": "<s> package org . ofbiz . webapp . event ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . HttpClient ; public class TestEvent { public static final String module = TestEvent . class . getName ( ) ; public static String test ( HttpServletRequest request , HttpServletResponse response ) { request . setAttribute ( \"MESSAGE\" , \"Test Event Ran Fine.\" ) ; Debug . logInfo ( \"Test Event Ran", "gt": "Fine.\" , module ) ;", "prediction": "OK\" ) ;\n", "label": 0}
{"id": 14116, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public abstract class CmapFormat { protected int format ; protected int length ; protected int version ; protected CmapFormat ( RandomAccessFile raf ) throws IOException { length = raf . readUnsignedShort ( ) ; version = raf . readUnsignedShort ( ) ; } protected static CmapFormat create ( int format , RandomAccessFile raf ) throws IOException { switch ( format ) { case 0 : return new CmapFormat0 ( raf ) ; case 2 : return new CmapFormat2 ( raf ) ; case 4 : return new CmapFormat4 ( raf ) ; case 6 : return new CmapFormat6 ( raf ) ; } return null ; } public int getFormat ( ) { return format ; } public int getLength ( ) { return length ; } public int getVersion ( ) { return version ; } public abstract int", "gt": "mapCharCode ( int charCode ) ;", "prediction": "getFormat ( ) ;\n", "label": 1}
{"id": 7647, "input": "<s> package Liza ; import org . bukkit . entity . CaveSpider ;", "gt": "public interface LizaCaveSpider extends CaveSpider", "prediction": "import org . bukkit . entity . Player ;\n", "label": 0}
{"id": 14120, "input": "<s> package org . eclipse . jface . tests . preferences ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; public class SamplePreferencePage extends PreferencePage { private String text ; public SamplePreferencePage ( String title , String text ) { super ( title ) ; this . text = text ; } protected Control createContents ( Composite parent ) { Label label = new", "gt": "Label ( parent , SWT . LEFT ) ;", "prediction": "Label ( parent , SWT . NONE ) ;\n", "label": 1}
{"id": 8538, "input": "<s> public class Pos01 < X > { Pos01 ( X x ) { } < Z > Pos01 ( X x , Z z ) { } void test ( ) { Pos01 < Integer > p1 = new Pos01 < > ( 1 ) ; Pos01 < ? extends Integer > p2 = new Pos01 < > ( 1 ) ; Pos01 < ? > p3 = new Pos01 < > ( 1 ) ; Pos01 < ? super Integer > p4 = new Pos01 < > ( 1 ) ; Pos01 < Integer > p5 = new Pos01 < > ( 1 , \"\" ) ; Pos01 < ? extends Integer > p6 = new Pos01 < > ( 1 , \"\" ) ; Pos01 < ? > p7 = new Pos01 < > ( 1 , \"\" ) ; Pos01 < ? super Integer > p8 = new Pos01 < > ( 1 , \"\" ) ; } public static void main ( String [ ] args ) { Pos01 < String > p1 = new Pos01 < > ( \"\" ) ; p1", "gt": ". test ( ) ;", "prediction": ". add ( \"a\" ) ;\n", "label": 0}
{"id": 14123, "input": "<s> package org . eclipse . ui . tests . keys ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . jface . bindings . Binding ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . keys . IBindingService ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class Bug36537Test extends UITestCase { public Bug36537Test ( String name ) { super ( name ) ; } public void testForRedundantKeySequenceBindings ( ) { final IWorkbenchWindow window = openTestWindow ( ) ; final IWorkbench workbench = window . getWorkbench ( ) ; final IBindingService bindingService = ( IBindingService ) workbench . getAdapter ( IBindingService . class ) ; final Binding [ ] bindings = bindingService . getBindings ( ) ; final int bindingCount = bindings . length ; Map keySequenceBindingsByKeySequence = new HashMap ( ) ; for ( int i = 0 ; i < bindingCount ; i ++ ) { final Binding binding = bindings [ i ] ; TriggerSequence triggerSequence = binding . getTriggerSequence ( ) ; List matches = ( List ) keySequenceBindingsByKeySequence . get ( triggerSequence ) ; if ( matches == null ) { matches = new ArrayList ( ) ; keySequenceBindingsByKeySequence . put ( triggerSequence , matches ) ; } Iterator matchItr = matches . iterator ( ) ; while ( matchItr . hasNext ( ) ) { final Binding matchedBinding = ( Binding ) matchItr . next ( ) ; ParameterizedCommand commandA = binding . getParameterizedCommand ( ) ; ParameterizedCommand commandB = matchedBinding . getParameterizedCommand ( ) ; String contextA = binding . getContextId ( ) ; String contextB = matchedBinding . getContextId ( ) ; String keyConfA = binding . getSchemeId ( ) ; String keyConfB = matchedBinding . getSchemeId ( ) ; String localeA = binding", "gt": ". getLocale ( ) ;", "prediction": ". getLocaleId ( ) ;\n", "label": 1}
{"id": 7915, "input": "<s> class WhichImplicitThis7 { static private int i ; static class B extends WhichImplicitThis7 { private int i ; } class C extends B { C ( int j ) { } C ( ) {", "gt": "this ( i ) ;", "prediction": "}\n", "label": 0}
{"id": 14125, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import java . util . List ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . DocumentModelListImpl ; import org . nuxeo . ecm . webapp . documentsLists . DocumentsListsManager ; @ Operation ( id = GetSelectedDocuments . ID , category = Constants . CAT_FETCH , requires = Constants . SEAM_CONTEXT , label = \"UI Selected documents\" , description = \"Fetch the documents selected in the current folder listing\" ) public class GetSelectedDocuments { public static", "gt": "final String ID = \"Seam.GetSelectedDocuments\" ;", "prediction": "final String ID = \"\" ;\n", "label": 1}
{"id": 2565, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Squid ; public interface LizaSquid extends Squid { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte >", "gt": "transparent , int maxDistance ) ;", "prediction": "transparent , int maxDistance ) ;\n", "label": 0}
{"id": 14127, "input": "<s> package org . jscsi . scsi . protocol . sense ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; public enum SenseKey { NO_SENSE ( 0x00 ) , RECOVERED_ERROR ( 0x01 ) , NOT_READY ( 0x02 ) , MEDIUM_ERROR ( 0x03 ) , HARDWARE_ERROR ( 0x04 ) , ILLEGAL_REQUEST ( 0x05 ) , UNIT_ATTENTION ( 0x06 ) , DATA_PROTECT ( 0x07 ) , BLANK_CHECK ( 0x08 ) , VENDOR_SPECIFIC ( 0x09 ) , COPY_ABORTED ( 0x0A ) , ABORTED_COMMAND ( 0x0B ) , VOLUME_OVERFLOW ( 0x0D ) , MISCOMPARE ( 0x0E ) ; private final int value ; private static Map < Integer , SenseKey > mapping ; private SenseKey ( final int value ) { if ( SenseKey . mapping == null ) { SenseKey . mapping = new HashMap < Integer , SenseKey > ( ) ; } SenseKey . mapping . put ( value , this ) ; this . value = value ; } public final int value ( ) { return value ; } public static final SenseKey valueOf ( int value ) throws IOException { SenseKey v = SenseKey . mapping . get ( value ) ; if ( v == null ) { throw new IOException ( \"Invalid sense", "gt": "key value: \" + value ) ;", "prediction": "key: \" + value ) ;\n", "label": 1}
{"id": 2926, "input": "<s> package fr . telecom . scrapbook . filters ; public class OldPhotoFilter implements IImageFilter { private GaussianBlurFilter blurFx ; private NoiseFilter noiseFx ; private VignetteFilter vignetteFx ; private GradientMapFilter gradientFx ; public OldPhotoFilter ( ) { blurFx = new GaussianBlurFilter ( ) ; blurFx . Sigma = 0.3f ; noiseFx = new NoiseFilter ( ) ; noiseFx . Intensity = 0.03f ; vignetteFx = new VignetteFilter ( ) ; vignetteFx . Size = 0.6f ; gradientFx = new GradientMapFilter ( ) ; gradientFx . ContrastFactor = 0.3f ; } public Image process ( Image imageIn ) { imageIn = this . noiseFx . process ( this . blurFx . process ( imageIn ) ) ; imageIn = this .", "gt": "gradientFx . process ( imageIn ) ;", "prediction": "gradientFx . process ( this . blurFx . process ( imageIn ) ) ;\n", "label": 0}
{"id": 14133, "input": "<s> package org . apache . lucene . queryParser . standard . processors ; import java . util . List ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . core . nodes . FieldQueryNode ; import org . apache . lucene . queryParser . core . nodes . FuzzyQueryNode ; import org . apache . lucene . queryParser . core . nodes . ParametricQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . core . processors . QueryNodeProcessorImpl ; import org . apache . lucene . queryParser . core . util . UnescapedCharSequence ; import org . apache . lucene . queryParser . standard . config . LowercaseExpandedTermsAttribute ; import org . apache . lucene . queryParser . standard . nodes . WildcardQueryNode ; public class LowercaseExpandedTermsQueryNodeProcessor extends QueryNodeProcessorImpl { public LowercaseExpandedTermsQueryNodeProcessor ( ) { } public QueryNode process ( QueryNode queryTree ) throws QueryNodeException { if ( getQueryConfigHandler ( ) . hasAttribute ( LowercaseExpandedTermsAttribute . class ) ) { if ( ( ( LowercaseExpandedTermsAttribute ) getQueryConfigHandler ( ) . getAttribute ( LowercaseExpandedTermsAttribute . class ) ) . isLowercaseExpandedTerms ( ) ) { return super . process ( queryTree ) ; } } return queryTree ; } protected QueryNode postProcessNode ( QueryNode node ) throws QueryNodeException { if ( node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode || node instanceof ParametricQueryNode ) { FieldQueryNode fieldNode = ( FieldQueryNode ) node ; fieldNode . setText ( UnescapedCharSequence . toLowerCase ( fieldNode . getText", "gt": "( ) ) ) ;", "prediction": "( ) ) ) ;\n", "label": 1}
{"id": 6461, "input": "<s> package p1 ; public class C extends", "gt": "B < String , String >", "prediction": "Serializable\n", "label": 0}
{"id": 14138, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . File ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . Statement ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . ArrayList ; import java . text . ParseException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IOUtils ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; import com . cloudera . sqoop . util . FileListing ; public class OracleManagerTest extends ImportJobTestCase { public static final Log LOG = LogFactory . getLog ( OracleManagerTest . class . getName ( ) ) ; static final String TABLE_NAME = \"EMPLOYEES\" ; static final String SECONDARY_TABLE_NAME = \"CUSTOMER\" ; static final String QUALIFIED_SECONDARY_TABLE_NAME = OracleUtils . ORACLE_SECONDARY_USER_NAME + \".\" + SECONDARY_TABLE_NAME ; private static final String [ ] MAIN_TABLE_SQL_STMTS = new String [ ] { \"CREATE TABLE \" + TABLE_NAME + \" (\" + \"id INT NOT NULL, \" + \"name VARCHAR2(24) NOT NULL, \" + \"start_date DATE, \" + \"salary FLOAT, \" + \"dept VARCHAR2(32), \" + \"timestamp_tz TIMESTAMP WITH TIME ZONE, \" + \"timestamp_ltz TIMESTAMP WITH LOCAL TIME ZONE, \" + \"PRIMARY KEY (id))\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"1,'Aaron',to_date('2009-05-14','yyyy-mm-dd'),\" + \"1000000.00,'engineering','29-DEC-09 12.00.00.000000000 PM',\" + \"'29-DEC-09 12.00.00.000000000 PM')\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"2,'Bob',to_date('2009-04-20','yyyy-mm-dd'),\" + \"400.00,'sales','30-DEC-09 12.00.00.000000000 PM',\" + \"'30-DEC-09 12.00.00.000000000 PM')\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"3,'Fred',to_date('2009-01-23','yyyy-mm-dd'),15.00,\" + \"'marketing','31-DEC-09 12.00.00.000000000 PM',\" + \"'31-DEC-09 12.00.00.000000000 PM')\" , } ; private static final String [ ] SECONDARY_TABLE_SQL_STMTS = new String [ ] { \"CREATE TABLE \" + SECONDARY_TABLE_NAME + \" (\" + \"id INT NOT NULL, \" + \"name VARCHAR2(24) NOT NULL, \" + \"PRIMARY KEY (id))\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"1,'MercuryCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"2,'VenusCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"3,'EarthCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"4,'MarsCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"5,'JupiterCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"6,'SaturnCorp')\" , \"GRANT SELECT, INSERT ON \" + SECONDARY_TABLE_NAME + \" TO \" + OracleUtils . ORACLE_USER_NAME , } ; private OracleManager manager ; @ Override protected boolean useHsqldbTestServer ( ) { return false ; } private void executeUpdates ( OracleManager mgr , String [ ] sqlStmts ) { Connection connection = null ; Statement st = null ; try { connection = mgr . getConnection ( ) ; connection . setAutoCommit ( false ) ; st = connection . createStatement ( ) ; for ( String sql : sqlStmts ) { st . executeUpdate ( sql ) ; } connection . commit ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Encountered SQL Exception: \" + sqlE ) ; sqlE . printStackTrace ( ) ; fail ( \"SQLException when running test setUp(): \" + sqlE ) ; } finally { try { if ( null != st ) { st . close ( ) ; } if ( null != connection ) { connection . close ( ) ; } } catch ( SQLException sqlE ) { LOG . warn ( \"Got SQLException when closing connection: \" + sqlE ) ; } } } private void provisionSecondaryTable ( ) { SqoopOptions options = new SqoopOptions ( OracleUtils . CONNECT_STRING , SECONDARY_TABLE_NAME ) ; OracleUtils . setOracleSecondaryUserAuth ( options ) ; OracleManager mgr = new OracleManager ( options ) ; try { OracleUtils . dropTable ( SECONDARY_TABLE_NAME , mgr ) ; } catch ( SQLException sqlE ) { fail ( \"Could not drop table \" + SECONDARY_TABLE_NAME + \": \" + sqlE ) ; } executeUpdates ( mgr , SECONDARY_TABLE_SQL_STMTS ) ; try { mgr . close ( ) ; } catch ( SQLException sqlE ) { fail ( \"Failed to close secondary manager instance : \" + sqlE ) ; } } @ Before public void setUp ( ) { super . setUp ( ) ; provisionSecondaryTable ( ) ; SqoopOptions options = new SqoopOptions ( OracleUtils . CONNECT_STRING , TABLE_NAME ) ; OracleUtils . setOracleAuth ( options ) ; manager =", "gt": "new OracleManager ( options ) ;", "prediction": "new OracleManager ( options ) ;\n", "label": 1}
{"id": 9032, "input": "<s> package org . ofbiz . sql ; public abstract class UpdatePlan < P extends UpdatePlan < P , C > , C > extends SQLPlan < P > { private final ConditionPlan < C > wherePlan ; protected", "gt": "UpdatePlan ( ConditionPlan < C > wherePlan )", "prediction": "UpdatePlan < P , C > ( )\n", "label": 0}
{"id": 14142, "input": "<s> package org . apache . lucene . util ; import java . util . IdentityHashMap ; import java . util . Map ; public class AverageGuessMemoryModel extends MemoryModel { private final Map sizes = new IdentityHashMap ( ) { { put ( boolean . class , new Integer ( 1 ) ) ; put ( byte . class , new Integer ( 1 ) ) ; put ( char . class , new Integer ( 2 ) ) ; put ( short . class , new Integer ( 2 ) ) ; put ( int . class , new Integer ( 4 ) ) ; put ( float . class , new Integer ( 4 ) ) ; put ( double . class , new Integer ( 8 ) ) ; put ( long . class , new Integer ( 8 ) ) ; } } ; public int getArraySize ( ) { return 16 ; } public int getClassSize ( ) { return 8 ; } public int getPrimitiveSize ( Class clazz ) { return ( ( Integer ) sizes . get ( clazz", "gt": ") ) . intValue ( ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 752, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ; public interface Function extends EObject { int getLevel ( ) ; void setLevel ( int value ) ; String getDate ( ) ; void setDate ( String value ) ; Scenario getScenario ( ) ; void setScenario ( Scenario value ) ; String getParentId ( ) ; void setParentId ( String value ) ; Task getTask ( ) ; void setTask ( Task value ) ; int getDistance ( ) ; void setDistance ( int value ) ; Resource getResource ( ) ; void", "gt": "setResource ( Resource value ) ;", "prediction": "setResource ( Resource value ) ;\n", "label": 0}
{"id": 14143, "input": "<s> package org . eclipse . swt . internal . widgets . menuitemkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . internal . widgets . ItemLCAUtil ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; final class MenuItemLCAUtil { private static final String TYPE = \"rwt.widgets.MenuItem\" ; private static final String [ ] ALLOWED_STYLES = new String [ ] { \"CHECK\" , \"CASCADE\" , \"PUSH\" , \"RADIO\" , \"SEPARATOR\" } ; private static final String PROP_MENU = \"menu\" ; private static final String PROP_ENABLED = \"enabled\" ; private static final String PROP_SELECTION = \"selection\" ; private static final String PROP_SELECTION_LISTENER = \"selection\" ; static void preserveValues ( MenuItem item ) { WidgetLCAUtil . preserveCustomVariant ( item ) ; ItemLCAUtil . preserve ( item ) ; preserveProperty ( item , PROP_MENU , item . getMenu ( ) ) ; preserveProperty ( item , PROP_ENABLED , item . getEnabled ( ) ) ; preserveProperty ( item , PROP_SELECTION , item . getSelection ( ) ) ; preserveListener ( item , PROP_SELECTION_LISTENER , SelectionEvent . hasListener ( item ) ) ; WidgetLCAUtil . preserveHelpListener ( item ) ; } static", "gt": "void renderInitialization ( MenuItem item )", "prediction": "void preserveValues ( MenuItem item )\n", "label": 1}
{"id": 2251, "input": "<s> package api . subscriptions ; import java . util . List ; public class Response { private List < Threads > threads ; public List < Threads > getThreads ( ) { return this . threads ; }", "gt": "@ Override public String toString ( )", "prediction": "public List < Thread > getThreads ( )\n", "label": 0}
{"id": 14145, "input": "<s> package org . modelgoon . core . ui ; import org . eclipse . draw2d . IFigure ; import org . eclipse . gef . LayerConstants ; import org . eclipse . gef . commands . Command ; import org . eclipse . gef . editpolicies . GraphicalNodeEditPolicy ; import org . eclipse . gef . requests . CreateConnectionRequest ; import org . eclipse . gef . requests . ReconnectRequest ; public class ConnectionEditPolicyImpl extends GraphicalNodeEditPolicy { @ Override public void activate ( ) { super . activate ( ) ; } @ Override protected IFigure getFeedbackLayer ( ) { System . out . println ( \"ConnectionEditPolicyImpl.getFeedbackLayer()\" ) ; return getLayer ( LayerConstants . SCALED_FEEDBACK_LAYER ) ; } @ Override", "gt": "protected Command getConnectionCompleteCommand ( final CreateConnectionRequest request )", "prediction": "protected GraphicalNodeEditPolicy getLayer ( )\n", "label": 1}
{"id": 8281, "input": "<s> package org . gk . ui . client . com . grid . column ; public interface gkColumnInfo { public String getId ( ) ; public String getLabel ( ) ; public String getName ( ) ; public String getColumnWidth ( ) ; public String getValue ( ) ; public boolean isCellEditor ( ) ; public String getInit ( ) ; public Object getFieldObject ( ) ; public String getInputStyle ( ) ; public String getAlign ( ) ; public String getTitle ( ) ; public void execEventCenter ( String id , String initCmd , Object obj ) ; public void addComponentToStore ( String id , Object obj ) ; public boolean removeComponentFromStore", "gt": "( String id ) ;", "prediction": "( String id ) ;\n", "label": 0}
{"id": 14152, "input": "<s> package org . eclipse . ui . internal . testing ; import org . eclipse . swt . widgets . Display ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . Workbench ; import org . eclipse . ui . testing . TestableObject ; public class WorkbenchTestable extends TestableObject { private Display display ; private IWorkbench workbench ; private boolean oldAutomatedMode ; private boolean oldIgnoreErrors ; public WorkbenchTestable ( ) { } public void init ( Display display , IWorkbench workbench ) { Assert . isNotNull ( display ) ; Assert . isNotNull ( workbench ) ; this . display = display ; this . workbench = workbench ; if ( getTestHarness ( ) != null ) { Runnable runnable = new Runnable ( ) { public void run ( ) { if ( ! \"false\" . equalsIgnoreCase ( System . getProperty ( PlatformUI . PLUGIN_ID + \".testsWaitForEarlyStartup\" ) ) ) { waitForEarlyStartup ( ) ; } getTestHarness ( ) . runTests ( ) ; } } ; new Thread ( runnable , \"WorkbenchTestable\" ) . start ( ) ; } } private void waitForEarlyStartup ( ) { try { Job . getJobManager ( ) . join ( Workbench . EARLY_STARTUP_FAMILY , null ) ; } catch ( OperationCanceledException e ) { } catch ( InterruptedException e ) { } } public void testingStarting ( ) { Assert . isNotNull ( workbench ) ; oldAutomatedMode = ErrorDialog . AUTOMATED_MODE ; ErrorDialog . AUTOMATED_MODE = true ; oldIgnoreErrors = SafeRunnable . getIgnoreErrors ( ) ; SafeRunnable . setIgnoreErrors ( true ) ; } public void runTest ( Runnable testRunnable ) { Assert . isNotNull ( workbench ) ; display . syncExec ( testRunnable ) ; } public void testingFinished ( ) { display . syncExec ( new Runnable ( ) { public void run ( ) { Assert . isTrue ( workbench . close ( ) ) ; } } ) ;", "gt": "ErrorDialog . AUTOMATED_MODE = oldAutomatedMode ;", "prediction": "}\n", "label": 1}
{"id": 5955, "input": "<s> class WhichImplicitThis6 { private int i ; WhichImplicitThis6 ( int i ) { } class Sub extends WhichImplicitThis6 { Sub ( ) {", "gt": "super ( i ) ;", "prediction": "}\n", "label": 0}
{"id": 14154, "input": "<s> package org . jscsi", "gt": ". initiator . devices ;", "prediction": ". exception . InternetSCSIException ;\n", "label": 1}
{"id": 9936, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface RichText extends Caption , Center , Details , Epilog , Footer , Header , Headline", "gt": ", Left , ListItem , Prolog , Right , Summary", "prediction": "\n", "label": 0}
{"id": 14158, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec4 . sub1 ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; }", "gt": "public void setContent ( String content )", "prediction": "public void setContent ( String content )\n", "label": 1}
{"id": 8830, "input": "<s> class ResourceInterface { public void test1 ( ) { try ( Resource1 r1 = null ) { } } public void test2 ( ) { try ( Resource2 r2 = null ) { } } static class E1 extends Exception { } static class E2 extends Exception { } interface C1 extends AutoCloseable { void close ( ) throws E1 ; } interface C2 extends AutoCloseable { void", "gt": "close ( ) throws E2 ;", "prediction": "close ( ) throws E2 ;\n", "label": 0}
{"id": 14159, "input": "<s> package de . uos . igf . db3d . dbms . newModel4d ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; public class TriangleNet4DComp { Map < Integer , Triangle4D > elements ; Date start ; Date end ; public TriangleNet4DComp ( Date start ) { super ( ) ; elements = new HashMap < Integer , Triangle4D > ( ) ; this . start = start ; this . end = null ; }", "gt": "public void addTriangle ( Triangle4D triangle )", "prediction": "public TriangleNet4DComp ( Date start , Date end )\n", "label": 1}
{"id": 9456, "input": "<s> import java . lang . reflect . Field ; import javax . lang . model . element . Element ; import javax . lang . model . element . ExecutableElement ; import javax . lang . model . element . PackageElement ; import javax . lang . model . element . TypeElement ; import javax . lang . model . element . TypeParameterElement ; import javax . lang . model . element . UnknownElementException ; import javax . lang . model . element . VariableElement ; import javax . lang . model . type . TypeMirror ; import javax . lang . model . type . UnknownTypeException ; import javax . lang . model . util . ElementScanner7 ; import javax . lang . model . util . SimpleTypeVisitor7 ; import javax . lang . model . util . Types ; import com . sun . tools . javac . code . Symbol . ClassSymbol ; import com . sun . tools . javac . code . Symtab ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . main . JavaCompiler ; import com . sun . tools . javac . model . JavacTypes ; import com . sun . tools . javac . util . Context ; public class TestSymtabItems { public static void main ( String ... args ) throws Exception { new TestSymtabItems ( ) . run ( ) ; } void run ( ) throws Exception { Context c = new Context ( ) ; JavacFileManager . preRegister ( c ) ; Symtab syms = Symtab . instance ( c ) ; JavacTypes types = JavacTypes . instance ( c ) ; JavaCompiler . instance ( c ) ; for ( Field f : Symtab . class . getDeclaredFields ( ) ) { if ( f . getName ( ) . toLowerCase ( ) . contains ( \"methodhandle\" ) ) continue ; Class < ? > ft = f . getType ( ) ; if ( TypeMirror . class . isAssignableFrom ( ft ) ) print ( f . getName ( ) , ( TypeMirror ) f . get ( syms ) , types ) ; else if ( Element . class . isAssignableFrom ( ft ) ) print ( f . getName ( ) , ( Element ) f . get ( syms ) ) ; } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void print ( String label , Element e ) { ElemPrinter ep = new ElemPrinter ( ) ; System . err . println ( \"Test \" + label ) ; ep . visit ( e ) ; System . err . println ( ) ; } void print ( String label , TypeMirror t , Types types ) { TypePrinter tp = new TypePrinter ( ) ; System . err . println ( \"Test \" + label ) ; tp . visit ( t , types ) ; System . err . println ( ) ; } void error ( String msg ) { System . err . println ( \"Error: \" + msg ) ; errors ++ ; } int errors ; class ElemPrinter extends ElementScanner7 < Void , Void > { @ Override public Void visitPackage ( PackageElement e , Void p ) { show ( \"package\" , e ) ; indent ( + 1 ) ; super . visitPackage ( e , p ) ; indent ( - 1 ) ; return null ; } @ Override public Void visitType ( TypeElement e , Void p ) { show ( \"type\" , e ) ; indent ( + 1 ) ; super . visitType ( e , p ) ; indent ( - 1 ) ; return null ; } @ Override public Void", "gt": "visitVariable ( VariableElement e , Void p )", "prediction": "visitEnum ( EnumElement e , Void p )\n", "label": 0}
{"id": 14163, "input": "<s> package org . fuzzydb . io . packet . layer1 ; import java . io . IOException ; import java . net . Socket ; import java . nio . ByteBuffer ; import java . nio . channels . CancelledKeyException ; import java . nio . channels . SelectionKey ; import java . nio . channels . SocketChannel ; import java . util . Collection ; import java . util . LinkedList ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . io . core . PacketInterface ; import org . slf4j . Logger ; public class Connection implements PacketInterface , SocketDriver { private static final Logger log = LogFactory . getLogger ( Connection . class ) ; private boolean closing = false ; private SocketChannel sc ; private LinkedList < ByteBuffer > outgoingPackets = new LinkedList < ByteBuffer > ( ) ; private boolean writable = true ; private LinkedList < ByteBuffer > incomingPackets = new LinkedList < ByteBuffer > ( ) ; private ByteBuffer incomingLength ; private ByteBuffer incomingPacket ; private State state = State . ReadingLength ; private SelectionKey sk ; private enum State { ReadingLength , ReadingPacket } public Connection ( SocketChannel sc ) { this . sc = sc ; newIncoming ( ) ; } public synchronized Collection < ByteBuffer > read ( ) { if ( incomingPackets . size ( ) == 0 ) { return null ; } Collection < ByteBuffer > rval = incomingPackets ; incomingPackets = new LinkedList < ByteBuffer > ( ) ; return rval ; } public synchronized void eventReadable ( ) throws IOException { for ( ; ; ) { if ( state == State . ReadingLength ) { int bytesRead = sc . read ( incomingLength ) ; if ( bytesRead == - 1 ) { throw new IOException ( ) ; } if ( bytesRead == 0 ) { return ; } if ( incomingLength . position ( ) == 4 ) { int length = 0xff000000 & ( incomingLength . get ( 3 ) << 24 ) ; length |= 0x00ff0000 & ( incomingLength . get ( 2 ) << 16 ) ; length |= 0x0000ff00 & ( incomingLength . get ( 1 ) << 8 ) ; length |= 0x000000ff & incomingLength . get ( 0 ) ; incomingPacket = ByteBuffer . allocate ( length ) ; incomingLength . clear ( ) ; state = State . ReadingPacket ; } } if ( state == State . ReadingPacket ) { int bytesRead = sc . read ( incomingPacket ) ; if ( bytesRead == - 1 ) { throw new IOException ( ) ; } if ( bytesRead == 0 ) { return ; } if ( incomingPacket . position ( ) == incomingPacket . capacity ( ) ) { incomingPacket . flip ( ) ; state = State . ReadingLength ; incomingPackets . add ( incomingPacket ) ; incomingPacket = null ; } } } } private void newIncoming ( ) { incomingLength = ByteBuffer . allocate ( 4 ) ; } public synchronized void eventWritable ( ) throws IOException { writable = true ; trySend ( ) ; } private void addLengthPacket ( ByteBuffer dataPacket ) { int count = dataPacket", "gt": ". capacity ( ) ;", "prediction": ". remaining ( ) ;\n", "label": 1}
{"id": 480, "input": "<s> package com . gisgraphy . client . continent ; import static com . gisgraphy . client . continent . Continent . continent ; import com . gisgraphy . client . continent . Continent ; public class ContinentObjectMother { public static Continent europe ( ) { return continent ( \"EU\" ) . withName ( \"Europe\" ) ; } public static Continent northAmericaContinent ( ) { return continent ( \"NA\" ) . withName ( \"North America\" ) ; } public static Continent antarcticaContinent ( ) { return continent (", "gt": "\"AN\" ) . withName ( \"Antarctica\" ) ;", "prediction": "\"ANTARctica\" ) . withName ( \"Antarctica\" ) ;\n", "label": 0}
{"id": 14168, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . SQLException ; import org . apache . hadoop . conf . Configuration ; import org . apache . sqoop . mapreduce . DBWritable ; import com . cloudera . sqoop . mapreduce . db . DBInputFormat . NullDBWritable ; public class DBConfiguration { public static final String DRIVER_CLASS_PROPERTY = \"mapreduce.jdbc.driver.class\" ; public static final String URL_PROPERTY = \"mapreduce.jdbc.url\" ; public static final String USERNAME_PROPERTY = \"mapreduce.jdbc.username\" ; public static final String PASSWORD_PROPERTY = \"mapreduce.jdbc.password\" ; public static final String FETCH_SIZE = \"mapreduce.jdbc.fetchsize\" ; public static final String INPUT_TABLE_NAME_PROPERTY = \"mapreduce.jdbc.input.table.name\" ; public static final String INPUT_FIELD_NAMES_PROPERTY = \"mapreduce.jdbc.input.field.names\" ; public static final String INPUT_CONDITIONS_PROPERTY = \"mapreduce.jdbc.input.conditions\" ; public static final String INPUT_ORDER_BY_PROPERTY = \"mapreduce.jdbc.input.orderby\" ; public static final String INPUT_QUERY = \"mapreduce.jdbc.input.query\" ; public static final String INPUT_COUNT_QUERY = \"mapreduce.jdbc.input.count.query\" ; public static final String INPUT_BOUNDING_QUERY = \"mapred.jdbc.input.bounding.query\" ; public static final String INPUT_CLASS_PROPERTY = \"mapreduce.jdbc.input.class\" ; public static final String OUTPUT_TABLE_NAME_PROPERTY = \"mapreduce.jdbc.output.table.name\" ; public static final String OUTPUT_FIELD_NAMES_PROPERTY = \"mapreduce.jdbc.output.field.names\" ; public static final String OUTPUT_FIELD_COUNT_PROPERTY = \"mapreduce.jdbc.output.field.count\" ; public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd , Integer fetchSize ) { conf . set ( DRIVER_CLASS_PROPERTY , driverClass ) ; conf . set ( URL_PROPERTY , dbUrl ) ; if ( userName != null ) { conf . set ( USERNAME_PROPERTY , userName ) ; } if ( passwd != null ) { conf . set ( PASSWORD_PROPERTY , passwd ) ; } if ( fetchSize != null ) { conf . setInt ( FETCH_SIZE , fetchSize ) ; } } public static void configureDB ( Configuration job , String driverClass , String dbUrl , Integer fetchSize ) { configureDB ( job , driverClass , dbUrl , null , null , fetchSize ) ; } public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd ) { configureDB ( conf , driverClass , dbUrl , userName , passwd , null ) ; } public static void configureDB ( Configuration job , String driverClass , String dbUrl ) { configureDB ( job , driverClass , dbUrl , null ) ; } private Configuration conf ; public DBConfiguration ( Configuration job ) { this . conf = job ; } public Connection getConnection ( ) throws ClassNotFoundException , SQLException { Class . forName ( conf . get ( DBConfiguration . DRIVER_CLASS_PROPERTY ) ) ; if ( conf . get ( DBConfiguration . USERNAME_PROPERTY ) == null ) { return DriverManager . getConnection ( conf . get ( DBConfiguration . URL_PROPERTY ) ) ; } else { return DriverManager . getConnection ( conf . get ( DBConfiguration . URL_PROPERTY ) , conf . get ( DBConfiguration . USERNAME_PROPERTY ) , conf . get ( DBConfiguration . PASSWORD_PROPERTY ) ) ; } } public Configuration getConf ( ) { return conf ; } public Integer getFetchSize ( ) { if ( conf . get ( DBConfiguration . FETCH_SIZE ) == null ) { return null ; } return conf . getInt ( DBConfiguration . FETCH_SIZE , 0 ) ; } public void setFetchSize ( Integer fetchSize ) { if ( fetchSize != null ) { conf . setInt ( DBConfiguration . FETCH_SIZE , fetchSize ) ; } else { conf . set ( FETCH_SIZE , null ) ; } } public String getInputTableName ( ) { return conf . get ( DBConfiguration . INPUT_TABLE_NAME_PROPERTY ) ; } public void setInputTableName ( String tableName ) { conf . set ( DBConfiguration . INPUT_TABLE_NAME_PROPERTY , tableName ) ; } public String [ ] getInputFieldNames ( ) { return conf . getStrings ( DBConfiguration . INPUT_FIELD_NAMES_PROPERTY ) ; } public void setInputFieldNames ( String ... fieldNames ) { conf . setStrings ( DBConfiguration . INPUT_FIELD_NAMES_PROPERTY , fieldNames ) ; } public String getInputConditions ( ) { return conf . get ( DBConfiguration . INPUT_CONDITIONS_PROPERTY ) ; } public void setInputConditions ( String conditions ) { if ( conditions != null && conditions . length ( ) > 0 ) { conf . set ( DBConfiguration . INPUT_CONDITIONS_PROPERTY , conditions ) ; } } public String getInputOrderBy ( ) { return conf . get ( DBConfiguration . INPUT_ORDER_BY_PROPERTY ) ; } public void setInputOrderBy ( String orderby ) { if ( orderby != null &&", "gt": "orderby . length ( ) > 0 )", "prediction": "orderby . length ( ) > 0 )\n", "label": 1}
{"id": 4273, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Priority ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class PriorityImpl extends TaskAttributeImpl implements Priority { protected static final int PRIORITY_EDEFAULT = 0 ; protected int priority = PRIORITY_EDEFAULT ; protected PriorityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getPriority ( ) ; } public int getPriority ( ) { return priority ; } public void setPriority ( int newPriority ) { int oldPriority = priority ; priority = newPriority ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . PRIORITY__PRIORITY , oldPriority , priority ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . PRIORITY__PRIORITY : return getPriority ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . PRIORITY__PRIORITY : setPriority ( ( Integer ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . PRIORITY__PRIORITY : setPriority ( PRIORITY_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }", "gt": "@ Override public boolean eIsSet ( int featureID )", "prediction": "}\n", "label": 0}
{"id": 14169, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"contentTypeId\" } ) @ XmlRootElement ( name", "gt": "= \"GetListContentType\" ) public class GetListContentType", "prediction": "= \"UpdateContentTypeResponse\" ) public class UpdateContentTypeResponse\n", "label": 1}
{"id": 4329, "input": "<s> package com . sun . mirror . type ; import com . sun . mirror . declaration . MethodDeclaration ; @ Deprecated", "gt": "@ SuppressWarnings ( \"deprecation\" ) public interface VoidType extends TypeMirror", "prediction": "public class MethodDeclaration\n", "label": 0}
{"id": 14178, "input": "<s> package com . puppycrawl . tools . checkstyle . bcel . generic ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUTFIELD ; public class PUTFIELDReference extends FieldReference {", "gt": "public PUTFIELDReference ( PUTFIELD aInstruction , ConstantPoolGen aPoolGen )", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 2945, "input": "<s> package next . interfaces . controller . widgets ; import next . i . mobile . SelectionChangedEvent ; import next . i . mobile . SelectionChangedHandler ; import next . i . view . widgets . XCheckbox ; import next . i . view . widgets . XCheckboxGroup ; import next . i . view . widgets . XFlexTable ; import next . i . view . widgets . XLabel ; import next . i . view . widgets . XLabel . XLabelType ; import next . interfaces . controller . GitXController ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; public class CheckboxController extends GitXController { public CheckboxController ( ) { setTitle ( \"Checkbox\" ) ; } @ Override public IsWidget getViewContent ( ) { XFlexTable panel = new XFlexTable ( ) ; panel . setCellSpacing ( 20 ) ; XCheckbox check0 = new XCheckbox ( \"Red\" , \"Red\" ) ; XCheckbox check1 = new XCheckbox ( \"Green\" , \"Green\" ) ; XCheckbox check2 = new XCheckbox ( \"Blue\" , \"Blue\" ) ; final XCheckboxGroup groupVertical = new XCheckboxGroup ( true ) ; groupVertical . add ( check0 , check1 , check2 ) ; XCheckbox checkA = new XCheckbox ( \"Red\" , \"Red\" ) ; XCheckbox checkB = new XCheckbox ( \"Green\" , \"Green\" ) ; XCheckbox checkC = new XCheckbox ( \"Blue\" , \"Blue\" ) ; final XCheckboxGroup groupHorizontal = new XCheckboxGroup ( false ) ; groupHorizontal . add ( checkA , checkB , checkC ) ; final XLabel label1 = new XLabel ( \"Favorite color\" , XLabelType . Header ) ; final XLabel label2 = new XLabel ( \"Favorite color\" , XLabelType . Header ) ; panel . addWidgets ( label2 , groupHorizontal , label1 , groupVertical , new HTML ( \"&nbsp;\" ) ) ; check0 . setValue ( true ) ; check1 . setValue ( true ) ; checkA . setValue ( true ) ; checkC . setValue ( true ) ; groupVertical . addSelectionChangedHandler ( new SelectionChangedHandler ( ) { public void onSelectionChanged ( SelectionChangedEvent e ) { String s = \"Favorite color: \" ;", "gt": "for ( XCheckbox c : groupVertical . getCheckedWidgets ( ) )", "prediction": "for ( int i = 0 ;\n", "label": 0}
{"id": 14181, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class RequestSense extends AbstractParameterCDB { public static final int OPERATION_CODE = 0x03 ; private boolean DESC ; public RequestSense ( ) { super ( OPERATION_CODE ) ; } public RequestSense ( boolean useDescriptorFormat , boolean linked , boolean normalACA , long allocationLength ) { super ( OPERATION_CODE , linked , normalACA , allocationLength , 0 ) ; if ( allocationLength > 256 ) { throw new IllegalArgumentException ( \"Allocation length out of bounds for command type\" ) ; } this . DESC = useDescriptorFormat ; } public RequestSense ( boolean useDescriptorFormat , long allocationLength ) { this ( useDescriptorFormat , false , false , allocationLength ) ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int operationCode = in . readUnsignedByte ( ) ; int format = in . readUnsignedByte ( ) & 0x01 ; this . DESC = ( format == 1 ) ; in . readShort ( ) ; setAllocationLength ( in . readUnsignedByte ( ) ) ; super . setControl ( in", "gt": ". readUnsignedByte ( ) ) ;", "prediction": ". readUnsignedByte ( ) ) ;\n", "label": 1}
{"id": 142, "input": "<s> package jns . trace ; public class EventParameter { public String name ; public Object value ; public EventParameter ( ) { name = new String ( ) ; value = null ; } public EventParameter ( String name , Object value ) { this . name = name ; this . value = value ; } public boolean equals ( EventParameter other ) { return name . equals ( other . name ) && value .", "gt": "equals ( other . value ) ;", "prediction": "equals ( other . value ) ;\n", "label": 0}
{"id": 14182, "input": "<s> package org . eclipse . swt . events ; import static org . mockito . Mockito . mock ; import junit . framework . TestCase ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Widget ; public class PaintEvent_Test extends TestCase { public void testUntypedEventConstructor ( ) throws Exception { Event event = new Event ( ) ; event . display = mock ( Display . class ) ; event . widget = mock ( Widget . class ) ;", "gt": "event . time = 321 ;", "prediction": "event . event = new Event ( ) ;\n", "label": 1}
{"id": 1715, "input": "<s> package org . xbill . DNS ; import java . io . * ; import org . xbill . DNS . utils . * ; public class CERTRecord extends Record { public static class CertificateType { private CertificateType ( ) { } public static final int PKIX = 1 ; public static final int SPKI = 2 ; public static final int PGP = 3 ; public static final int IPKIX = 4 ; public static final int ISPKI = 5 ; public static final int IPGP = 6 ; public static final int ACPKIX = 7 ; public static final int IACPKIX = 8 ; public static final int URI = 253 ; public static final int OID = 254 ; private static Mnemonic types = new Mnemonic ( \"Certificate type\" , Mnemonic . CASE_UPPER ) ; static { types . setMaximum ( 0xFFFF ) ; types . setNumericAllowed ( true ) ; types . add ( PKIX , \"PKIX\" ) ; types . add ( SPKI , \"SPKI\" ) ; types . add ( PGP , \"PGP\" ) ; types . add ( PKIX , \"IPKIX\" ) ; types . add ( SPKI , \"ISPKI\" ) ; types . add ( PGP , \"IPGP\" ) ; types . add ( PGP , \"ACPKIX\" ) ; types . add ( PGP , \"IACPKIX\" ) ; types . add ( URI , \"URI\" ) ; types . add ( OID , \"OID\" ) ; } public static String string ( int type ) { return types . getText ( type ) ; } public static int value ( String s ) { return types . getValue ( s ) ; } } public static final int PKIX = CertificateType . PKIX ; public static final int SPKI = CertificateType . SPKI ; public static final int PGP = CertificateType . PGP ; public static final int URI = CertificateType . URI ; public static final int OID = CertificateType . OID ; private static final long serialVersionUID = 4763014646517016835L ; private int certType , keyTag ; private int alg ; private byte [ ] cert ; CERTRecord ( ) { } Record getObject ( ) { return new CERTRecord ( ) ; } public CERTRecord ( Name name , int dclass , long ttl , int certType , int keyTag , int alg , byte [ ] cert ) { super ( name , Type . CERT , dclass , ttl ) ; this . certType = checkU16 ( \"certType\" , certType ) ; this . keyTag = checkU16 ( \"keyTag\" , keyTag ) ; this . alg = checkU8 ( \"alg\" , alg ) ; this . cert = cert ; } void rrFromWire ( DNSInput in ) throws IOException { certType = in . readU16 ( ) ; keyTag = in . readU16 ( ) ; alg = in . readU8 ( ) ; cert = in . readByteArray ( ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { String certTypeString = st . getString ( ) ; certType = CertificateType . value ( certTypeString ) ; if ( certType < 0 ) throw st . exception ( \"Invalid certificate type: \" + certTypeString ) ; keyTag = st . getUInt16 ( ) ; String algString = st . getString ( ) ; alg = DNSSEC . Algorithm . value ( algString ) ; if ( alg < 0 ) throw st . exception ( \"Invalid algorithm: \" + algString ) ; cert = st . getBase64 ( ) ; } String rrToString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( certType ) ; sb . append ( \" \" ) ; sb . append ( keyTag ) ; sb", "gt": ". append ( \" \" ) ;", "prediction": ". append ( \" \" ) ;\n", "label": 0}
{"id": 14183, "input": "<s> package org . eclipse . ui . tests . commands ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . IParameter ; import org . eclipse . core . commands . Parameterization ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . commands . IElementReference ; import org . eclipse . ui . commands . IElementUpdater ; import org . eclipse . ui . handlers . IHandlerActivation ; import org . eclipse . ui . handlers . IHandlerService ; import org . eclipse . ui . menus . UIElement ; import org . eclipse . ui . services . IServiceLocator ; import org . eclipse . ui . services . IServiceScopes ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class CommandCallbackTest extends UITestCase { private static final String HOST_PARAM_ID = \"host\" ; private static final String PROT_PARAM_ID = \"protocol\" ; private static final String PREFIX = \"tests.commands.CCT.\" ; private static final String CMD1_ID = PREFIX + \"cmd1\" ; private static final String CMD2_ID = PREFIX + \"cmd2\" ; private ICommandService commandService ; private Command cmd1 ; private Command cmd2 ; private IHandlerService handlerService ; private IHandlerActivation cmd1Activation ; private IHandlerActivation cmd2Activation ; private CallbackHandler cmd1Handler ; private CallbackHandler cmd2Handler ; public CommandCallbackTest ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; commandService = ( ICommandService ) fWorkbench . getService ( ICommandService . class ) ; cmd1 = commandService . getCommand ( CMD1_ID ) ; cmd2 = commandService . getCommand ( CMD2_ID ) ; handlerService = ( IHandlerService ) fWorkbench . getService ( IHandlerService . class ) ; cmd1Handler = new CallbackHandler ( ) ; cmd1Activation = handlerService . activateHandler ( CMD1_ID , cmd1Handler ) ; cmd2Handler = new CallbackHandler ( ) ; cmd2Activation = handlerService . activateHandler ( CMD2_ID , cmd2Handler ) ; } protected void doTearDown ( ) throws Exception { if ( cmd1Activation != null ) { handlerService . deactivateHandler ( cmd1Activation ) ; cmd1Activation = null ; } if ( cmd2Activation != null ) { handlerService . deactivateHandler ( cmd2Activation ) ; cmd2Activation = null ; } super . doTearDown ( ) ; } private static class CallbackHandler extends AbstractHandler implements IElementUpdater { public int callbacks = 0 ; public void updateElement ( UIElement callback , Map parameters ) { callbacks ++ ; } public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } } private static class MyElement extends UIElement { public MyElement ( IServiceLocator locator ) { super ( locator ) ; } public void setChecked ( boolean checked ) { } public void setDisabledIcon ( ImageDescriptor desc ) { } public void setHoverIcon ( ImageDescriptor desc ) { } public void setIcon ( ImageDescriptor desc ) { } public void setText ( String text ) { } public void setTooltip ( String text ) { } } public void testNoParametersNoCallbacks ( ) throws Exception { ParameterizedCommand pc1 = new ParameterizedCommand ( cmd1 , null ) ; ParameterizedCommand pc2 = new ParameterizedCommand ( cmd1 , null ) ; try { commandService . registerElementForCommand ( pc1 , null ) ; fail ( \"Callback should not register\" ) ; } catch ( NotDefinedException e ) { } try { commandService . registerElementForCommand ( pc2 , null ) ; fail ( \"Callback 2 should not register\" ) ; } catch ( NotDefinedException e ) { } commandService . refreshElements ( CMD1_ID + \".1\" , null ) ; assertEquals ( 0 , cmd1Handler . callbacks ) ; commandService . refreshElements ( CMD1_ID , null ) ; assertEquals ( 0 , cmd1Handler . callbacks ) ; } public void testNoParametersWithCallbacks ( ) throws Exception { ParameterizedCommand pc1 = new ParameterizedCommand ( cmd1 , null ) ; ParameterizedCommand pc2 = new ParameterizedCommand ( cmd1 , null ) ; IElementReference cr1 = commandService . registerElementForCommand ( pc1 , new MyElement ( fWorkbench ) ) ; IElementReference cr2 = commandService . registerElementForCommand ( pc2 , new MyElement ( fWorkbench ) ) ; try { assertEquals ( 2 , cmd1Handler . callbacks ) ; cmd1Handler . callbacks = 0 ; commandService . refreshElements ( CMD1_ID , null ) ; assertEquals ( 2 , cmd1Handler . callbacks ) ; } finally { commandService . unregisterElement ( cr1 ) ; commandService . unregisterElement ( cr2 ) ; } cmd1Handler . callbacks = 0 ; commandService . refreshElements ( CMD1_ID , null ) ; assertEquals ( 0 , cmd1Handler . callbacks ) ; } public void testParametersWithCallbacks ( ) throws Exception { IParameter parmProt = cmd2 . getParameter ( PROT_PARAM_ID ) ; IParameter parmHost = cmd2 . getParameter ( HOST_PARAM_ID ) ; ParameterizedCommand pc1 = new ParameterizedCommand ( cmd2 , new Parameterization [ ] { new Parameterization ( parmProt , \"http\" ) , new Parameterization ( parmHost , \"www.eclipse.org\" ) } ) ; ParameterizedCommand pc2 = new ParameterizedCommand ( cmd2 , new Parameterization [ ] { new Parameterization ( parmProt , \"http\" ) , new Parameterization ( parmHost , \"download.eclipse.org\" ) } ) ; IElementReference cr1 = commandService . registerElementForCommand ( pc1 , new MyElement ( fWorkbench ) ) ; IElementReference cr2 = commandService . registerElementForCommand ( pc2 , new MyElement ( fWorkbench ) ) ; try { assertEquals ( 2 , cmd2Handler . callbacks ) ; cmd2Handler . callbacks = 0 ; Map filter = new HashMap ( ) ; filter . put ( PROT_PARAM_ID , \"http\" ) ; commandService . refreshElements ( CMD2_ID , filter ) ; assertEquals", "gt": "( 2 , cmd2Handler . callbacks ) ;", "prediction": "( 2 , cmd2Handler . callbacks ) ;\n", "label": 1}
{"id": 8546, "input": "<s> package javax . lang . model . element ; public enum ElementKind { PACKAGE , ENUM , CLASS , ANNOTATION_TYPE , INTERFACE , ENUM_CONSTANT , FIELD , PARAMETER , LOCAL_VARIABLE , EXCEPTION_PARAMETER , METHOD , CONSTRUCTOR , STATIC_INIT , INSTANCE_INIT , TYPE_PARAMETER , OTHER , RESOURCE_VARIABLE ; public boolean isClass ( ) { return this == CLASS || this == ENUM ; } public boolean isInterface ( ) {", "gt": "return this == INTERFACE || this == ANNOTATION_TYPE ;", "prediction": "return this == INTERFACE || this == ENUM ;\n", "label": 0}
{"id": 14184, "input": "<s> package org . fuzzydb . attrs . unused ; import org . fuzzydb . attrs . internal . BranchConstraint ; import org . fuzzydb . attrs . internal . Value ; import org . fuzzydb . attrs . util . Range ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; public abstract class GenericRangeConstraint extends BranchConstraint implements IRange { protected Comparable < Object > min ; protected Comparable < Object > max ; public final Comparable < Object > getMax ( ) { return max ; } public final Comparable < Object > getMin ( ) { return min ; } public GenericRangeConstraint ( int attrId , Comparable < Object > min , Comparable < Object > max ) { super ( attrId ) ; this . min = min ; this . max = max ; } public final boolean contains ( Comparable < Object > val ) { return Range . contains ( min ,", "gt": "val , max ) ;", "prediction": "val ) ;\n", "label": 1}
{"id": 5942, "input": "<s> package api . search . requests ; public class Results { private String bitrateList ; private Number bounty ; private String catalogueNumber ; private Number categoryId ; private String categoryName ; private String description ; private Number fillerId ; private String fillerName ; private String formatList ; private String image ; private boolean isFilled ; private String lastVote ; private String logCue ; private String mediaList ; private String releaseType ; private Number requestId ; private Number requestorId ; private String requestorName ; private String timeAdded ; private String timeFilled ; private String title ; private Number torrentId ; private Number voteCount ; private Number year ; public String getBitrateList ( ) { return this . bitrateList ; } public Number getBounty ( ) { return this . bounty ; } public String getCatalogueNumber ( ) { return this . catalogueNumber ; } public Number getCategoryId ( ) { return this . categoryId ; } public String getCategoryName ( ) { return this . categoryName ; } public String getDescription ( ) { return this . description ; } public Number getFillerId ( ) { return this . fillerId ; } public String getFillerName ( ) { return this . fillerName ; } public String getFormatList ( ) { return this . formatList ; } public String getImage ( ) { return this . image ; } public boolean getIsFilled ( ) { return this . isFilled ; } public String getLastVote ( ) { return this . lastVote ; } public String getLogCue ( ) { return this . logCue ; } public String getMediaList ( ) { return this . mediaList ; } public String getReleaseType ( ) { return this . releaseType ; } public Number getRequestId ( ) { return this . requestId ; } public Number getRequestorId ( ) { return this . requestorId ; } public String getRequestorName ( ) { return this . requestorName ; } public String getTimeAdded ( ) { return this . timeAdded ; } public String getTimeFilled ( ) { return this . timeFilled ; }", "gt": "public String getTitle ( )", "prediction": "public String getTitle ( )\n", "label": 0}
{"id": 14186, "input": "<s> package org . nuxeo . ecm . platform . publisher . task ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org", "gt": ". nuxeo . ecm . core . api . DocumentModel ;", "prediction": ". nuxeo . ecm . core . api . DocumentModel ;\n", "label": 1}
{"id": 1250, "input": "<s> package org . ofbiz . widget . tree ; import java . io . IOException ; import java . io . StringWriter ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . xml . parsers . ParserConfigurationException ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . widget . WidgetWorker ; import org . ofbiz . widget . screen . ModelScreen ; import org . ofbiz . widget . screen . ScreenFactory ; import org . ofbiz . widget . screen . ScreenStringRenderer ; import org . ofbiz . widget . screen . ScreenRenderException ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . widget . ModelWidget ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; @ SuppressWarnings ( \"serial\" ) public class ModelTree extends ModelWidget { public static final String module = ModelTree . class . getName ( ) ; protected String treeLocation ; protected String rootNodeName ; protected String defaultRenderStyle ; protected FlexibleStringExpander defaultWrapStyleExdr ; protected List < ModelNode > nodeList = FastList . newInstance ( ) ; protected Map < String , ModelNode > nodeMap = FastMap . newInstance ( ) ; protected Delegator delegator ; protected LocalDispatcher dispatcher ; protected FlexibleStringExpander expandCollapseRequestExdr ; protected FlexibleStringExpander trailNameExdr ; protected int openDepth ; protected int postTrailOpenDepth ; protected String defaultEntityName ; protected String defaultPkName ; protected boolean forceChildCheck ; public ModelTree ( ) { } public ModelTree ( Element treeElement , Delegator delegator , LocalDispatcher dispatcher ) { super ( treeElement ) ; this . rootNodeName = treeElement . getAttribute ( \"root-node-name\" ) ; this . defaultRenderStyle = UtilFormatOut . checkEmpty ( treeElement . getAttribute ( \"default-render-style\" ) , \"simple\" ) ; if ( UtilValidate . isEmpty ( this . defaultRenderStyle ) || this . defaultRenderStyle . equals ( \"simple\" ) ) { String rStyle = treeElement . getAttribute ( \"render-style\" ) ; if ( UtilValidate . isNotEmpty ( rStyle ) ) this . defaultRenderStyle = rStyle ; } this . defaultWrapStyleExdr = FlexibleStringExpander . getInstance ( treeElement . getAttribute ( \"default-wrap-style\" ) ) ; this . expandCollapseRequestExdr = FlexibleStringExpander . getInstance ( treeElement . getAttribute ( \"expand-collapse-request\" ) ) ; this . trailNameExdr = FlexibleStringExpander . getInstance ( UtilFormatOut . checkEmpty ( treeElement . getAttribute ( \"trail-name\" ) , \"trail\" ) ) ; this . delegator = delegator ; this . dispatcher = dispatcher ; this . forceChildCheck = ! \"false\" . equals ( treeElement . getAttribute ( \"force-child-check\" ) ) ; setDefaultEntityName ( treeElement . getAttribute ( \"entity-name\" ) ) ; try { openDepth = Integer . parseInt ( treeElement . getAttribute ( \"open-depth\" ) ) ; } catch ( NumberFormatException e ) { openDepth = 0 ; } try { postTrailOpenDepth = Integer . parseInt ( treeElement . getAttribute ( \"post-trail-open-depth\" ) ) ; } catch ( NumberFormatException e ) { postTrailOpenDepth = 999 ; } for ( Element nodeElementEntry : UtilXml . childElementList ( treeElement , \"node\" ) ) { ModelNode node = new ModelNode ( nodeElementEntry , this ) ; String nodeName = node . getName ( ) ; nodeList . add ( node ) ; nodeMap . put ( nodeName , node ) ; } if ( nodeList . size ( ) == 0 ) { throw new IllegalArgumentException ( \"No node elements found for the tree definition with name: \" + this . name ) ; } } public void setDefaultEntityName ( String name ) {", "gt": "String nm = name ;", "prediction": "this . defaultEntityName = name ;\n", "label": 0}
{"id": 14199, "input": "<s> package org . restlet . ext . wadl ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . w3c . dom . Node ; public abstract class DocumentedInfo { private List < DocumentationInfo > documentations ; public DocumentedInfo ( ) { super ( ) ; } public DocumentedInfo ( DocumentationInfo documentation ) { super ( ) ; getDocumentations ( ) . add ( documentation ) ; } public DocumentedInfo ( List < DocumentationInfo > documentations ) { super ( ) ; this . documentations = documentations ; } public DocumentedInfo ( String documentation ) { this ( new DocumentationInfo ( documentation ) ) ; } public List < DocumentationInfo > getDocumentations ( ) { List < DocumentationInfo > d = this . documentations ; if ( d == null ) { synchronized ( this ) { d = this . documentations ; if ( d == null ) { this . documentations = d = new ArrayList < DocumentationInfo > ( ) ; } } } return d ; } public Map < String , String > resolveNamespaces ( ) { Map < String , String > result = new HashMap < String , String > ( ) ; for ( DocumentationInfo documentationInfo : getDocumentations ( ) ) { if ( documentationInfo . getMixedContent ( ) != null ) { resolveNamespaces ( documentationInfo . getMixedContent ( ) , result ) ; } } return result ; } private void resolveNamespaces ( Node node , Map < String , String > namespaces ) { if ( node . getNamespaceURI ( ) != null ) { namespaces . put ( node . getNamespaceURI ( ) , node . getPrefix ( ) ) ; } if ( node . getChildNodes ( ) != null ) { for ( int i = 0 ; i < node . getChildNodes ( ) . getLength ( ) ; i ++ ) { resolveNamespaces ( node . getChildNodes ( ) . item ( i ) , namespaces ) ; } } } public void setDocumentation ( DocumentationInfo documentationInfo ) { getDocumentations ( ) . clear ( ) ; getDocumentations ( ) . add ( documentationInfo ) ; } public void setDocumentation ( String documentation ) { getDocumentations", "gt": "( ) . clear ( ) ;", "prediction": "( ) . clear ( ) ;\n", "label": 1}
{"id": 3158, "input": "<s> package foo ; public class T6194785a { void", "gt": "foo ( String bar )", "prediction": "foo ( )\n", "label": 0}
{"id": 14201, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import org . restlet . example . book . restlet . ch09 . common . AccountRepresentation ; import org . restlet . example . book . restlet . ch09 . common . AccountResource ; import org . restlet . ext . wadl . MethodInfo ; import org . restlet . ext . wadl . RepresentationInfo ; import org . restlet . ext . wadl . WadlServerResource ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; public class AccountServerResource extends WadlServerResource implements AccountResource { private int accountId ; @ Override protected RepresentationInfo describe ( MethodInfo methodInfo , Class < ? > representationClass , Variant variant ) { RepresentationInfo result = new RepresentationInfo ( variant ) ; result . setReference ( \"account\" ) ; return result ; } @ Override protected void doInit ( ) throws ResourceException { String accountIdAttribute =", "gt": "getAttribute ( \"accountId\" ) ;", "prediction": "\"accountId\" ;\n", "label": 1}
{"id": 7536, "input": "<s> package org . ofbiz . product . config ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Enumeration ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . config . ProductConfigWrapper . ConfigItem ; import org . ofbiz . product . config . ProductConfigWrapper . ConfigOption ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . base . util . cache . UtilCache ; public class ProductConfigWorker { public static final String module = ProductConfigWorker . class . getName ( ) ; public static final String resource = \"ProductUiLabels\" ; public static final String SEPARATOR = \"::\" ; private static final UtilCache < String , ProductConfigWrapper > productConfigCache = UtilCache . createUtilCache ( \"product.config\" , true ) ; public static ProductConfigWrapper getProductConfigWrapper ( String productId , String currencyUomId , HttpServletRequest request ) { ProductConfigWrapper configWrapper = null ; String catalogId = CatalogWorker . getCurrentCatalogId ( request ) ; String webSiteId = CatalogWorker . getWebSiteId ( request ) ; String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; GenericValue autoUserLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"autoUserLogin\" ) ; try { String cacheKey = productId + SEPARATOR + productStoreId + SEPARATOR + catalogId + SEPARATOR + webSiteId + SEPARATOR + currencyUomId ; configWrapper = productConfigCache . get ( cacheKey ) ; if ( configWrapper == null ) { configWrapper = new ProductConfigWrapper ( ( Delegator ) request . getAttribute ( \"delegator\" ) , ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) , productId , productStoreId , catalogId , webSiteId , currencyUomId , UtilHttp . getLocale ( request ) , autoUserLogin ) ; configWrapper = productConfigCache . putIfAbsentAndGet ( cacheKey , new ProductConfigWrapper ( configWrapper ) ) ; } else { configWrapper = new ProductConfigWrapper ( configWrapper ) ; } } catch ( ProductConfigWrapperException we ) { configWrapper = null ; } catch ( Exception e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; } return configWrapper ; } public static void fillProductConfigWrapper ( ProductConfigWrapper configWrapper , HttpServletRequest request ) { int numOfQuestions = configWrapper . getQuestions ( ) . size ( ) ; for ( int k = 0 ; k < numOfQuestions ; k ++ ) { String [ ] opts = request . getParameterValues ( Integer . toString ( k ) ) ; if ( opts == null ) { ProductConfigWrapper . ConfigItem question = configWrapper . getQuestions ( ) . get ( k ) ; if ( question . isStandard ( ) ) { int i = 0 ; while ( i <= ( question . getOptions ( ) . size ( ) - 1 ) ) { String comments = request . getParameter ( \"comments_\" + k + \"_\" + i ) ; if ( UtilValidate . isNotEmpty ( comments ) ) { try { configWrapper . setSelected ( k , i , comments ) ; } catch ( Exception e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; } } i ++ ; } } continue ; } for ( String opt : opts ) { int cnt = - 1 ; try { cnt = Integer . parseInt ( opt ) ; String comments = null ; ProductConfigWrapper . ConfigItem question = configWrapper . getQuestions ( ) . get ( k ) ; if ( question . isSingleChoice ( ) ) { comments = request . getParameter ( \"comments_\" + k + \"_\" + \"0\" ) ; } else { comments = request . getParameter ( \"comments_\" + k + \"_\" + cnt ) ; } configWrapper . setSelected ( k , cnt , comments ) ; ProductConfigWrapper . ConfigOption option = configWrapper . getItemOtion ( k , cnt ) ; if ( UtilValidate . isNotEmpty ( option ) && ( option . hasVirtualComponent ( ) ) ) { List < GenericValue > components = option . getComponents ( ) ; int variantIndex = 0 ; for ( int i = 0 ; i < components . size ( ) ; i ++ ) { GenericValue component = components . get ( i ) ; if ( option . isVirtualComponent ( component ) ) { String productParamName = \"add_product_id\" + k + \"_\" + cnt + \"_\" + variantIndex ; String selectedProductId = request . getParameter ( productParamName ) ; if ( UtilValidate . isEmpty ( selectedProductId ) ) { Debug . logWarning ( \"ERROR: Request param [\" + productParamName + \"] not found!\" , module ) ; } else { if ( ProductWorker . isVirtual ( ( Delegator ) request . getAttribute ( \"delegator\" ) , selectedProductId ) ) { if ( \"VV_FEATURETREE\" . equals ( ProductWorker . getProductVirtualVariantMethod ( ( Delegator ) request . getAttribute ( \"delegator\" ) , selectedProductId ) ) ) { List < String > selectedFeatures = FastList . newInstance ( ) ; Enumeration < String > paramNames = UtilGenerics . cast ( request . getParameterNames ( ) ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = paramNames . nextElement ( ) ; if ( paramName . startsWith ( \"FT\" + k + \"_\" + cnt + \"_\" + variantIndex ) ) { selectedFeatures . add ( request . getParameterValues ( paramName ) [ 0 ] ) ; } } if ( UtilValidate . isEmpty ( selectedFeatures ) ) { Debug . logWarning ( \"ERROR: No features selected for productId [\" + selectedProductId + \"]\" , module ) ; } String variantProductId = ProductWorker . getVariantFromFeatureTree ( selectedProductId , selectedFeatures , ( Delegator ) request . getAttribute ( \"delegator\" ) ) ; if ( UtilValidate . isNotEmpty ( variantProductId ) ) { selectedProductId = variantProductId ; } else { Debug . logWarning ( \"ERROR: Variant product not found!\" , module ) ; request . setAttribute ( \"_EVENT_MESSAGE_\" , UtilProperties . getMessage ( \"OrderErrorUiLabels\" , \"cart.addToCart.incompatibilityVariantFeature\" , UtilHttp . getLocale ( request ) ) ) ; } } } configWrapper . setSelected ( k , cnt , i , selectedProductId ) ; } variantIndex ++ ; } } } } catch ( Exception e ) { Debug . logWarning ( e . getMessage", "gt": "( ) , module ) ;", "prediction": "( ) , module ) ;\n", "label": 0}
{"id": 14204, "input": "<s> package org . gatein . common . text ; import org . gatein . common . io . UndeclaredIOException ; import org . gatein . common . util . ParameterValidation ; import java . io . IOException ; import java . io . Writer ; public class FastURLEncoder extends AbstractCharEncoder { private static final FastURLEncoder DEFAULT_ENCODER = new FastURLEncoder ( CharToByteEncoder . Generic . UTF8 ) ; public static FastURLEncoder getUTF8Instance ( ) { return DEFAULT_ENCODER ; } private final char [ ] [ ] table ; private static final char MAX = ( char ) 0x10FFFD ; public FastURLEncoder ( CharToByteEncoder encoder ) throws IllegalArgumentException { if ( encoder == null ) { throw new IllegalArgumentException ( \"No encoding provided\" ) ; } this . table = new char [ MAX + 1 ] [ ] ; for ( char c = 0 ; c <= MAX ; c ++ ) { char [ ] z ; if ( TextTools . isAlphaNumeric ( c ) ) { z = new char [ ] { c } ; } else { switch ( c ) { case ' ' : z = new char [ ] { '+' } ; break ; case '.' : case '-' : case '*' : case '_' : z = new char [ ] { c } ; break ; default : byte [ ] v = encoder . encode ( c ) ; if ( v . length > 0 ) { z = new char [ v . length * 3 ] ; int index = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { byte b = v [ i ] ; z [ index ++ ] = '%' ; z [ index ++ ] = TextTools . toHex ( ( b & 0xF0 ) > > 4 ) ; z [ index ++ ] = TextTools . toHex ( b & 0x0F ) ; } } else { z = null ; } break ; } } table [ c ] = z ; } } public void encode ( char c , CharWriter writer ) { ParameterValidation . throwIllegalArgExceptionIfNull ( writer , \"CharWriter\" ) ; char [ ] z = getEncoding ( c ) ; writer . append ( z ) ; } private char [ ] getEncoding ( char c ) { char [ ] z = table [ c ] ; if ( z == null ) { throw new MalformedInputException ( \"Couldn't find appropriate encoding for '\" + c + \"'\" ) ; } return z ; } protected void safeEncode ( char [ ] chars , int off , int len , CharWriter writer ) { for (", "gt": "int i = off ;", "prediction": "int i = off ;\n", "label": 1}
{"id": 8631, "input": "<s> package org . ofbiz . service . rmi ; import java . util . Map ; import java . rmi . Remote ; import java . rmi . RemoteException ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . GenericResultWaiter ; import org . ofbiz . service . GenericServiceException ; public interface RemoteDispatcher extends Remote { public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , boolean persist ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public GenericResultWaiter runAsyncWait ( String serviceName , Map < String , ? extends Object > context , boolean persist ) throws GenericServiceException , RemoteException ; public GenericResultWaiter runAsyncWait ( String serviceName , Map < String , ? extends Object > context", "gt": ") throws GenericServiceException , RemoteException ;", "prediction": ", boolean persist ) throws GenericServiceException , RemoteException ;\n", "label": 0}
{"id": 14208, "input": "<s> package org . restlet . example . ext . openid ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; import java . util . logging . Logger ; import org . openid4java . message . DirectError ; import org . openid4java . message . Message ; import org . openid4java . message . ParameterList ; import org . openid4java . server . ServerManager ; import org . restlet . data . Form ; import org . restlet . data . Method ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . resource . ServerResource ; import org . restlet . util . Series ; public class OpenIdProvider extends ServerResource { public OpenIdProvider ( ) { getLogger ( ) . info ( \"OpenID CREATED NEW PROVIDER\" ) ; } @ Post ( \"form\" ) public Representation represent ( Representation input ) { Form f = new Form ( input ) ; return handle ( new ParameterList ( f . getValuesMap ( ) ) ) ; } @ Get ( \"form\" ) public Representation represent ( ) { return handle ( new ParameterList ( getQuery ( ) . getValuesMap ( ) ) ) ; } private Representation handle ( ParameterList request ) { Logger log = getLogger ( ) ; log . info ( \"Handle on OP\" ) ; ConcurrentMap < String , Object > attribs = getContext ( ) . getAttributes ( ) ; ServerManager manager = ( ServerManager ) attribs . get ( \"openid_manager\" ) ; log . info ( \"OP endpoint = \" + manager . getOPEndpointUrl ( ) ) ; String mode = request . hasParameter ( \"openid.mode\" ) ? request . getParameterValue ( \"openid.mode\" ) : null ; Message response ; String responseText ; if ( \"associate\" . equals ( mode ) ) { response = manager . associationResponse ( request ) ; responseText = response . keyValueFormEncoding ( ) ; } else if ( \"checkid_setup\" . equals ( mode ) || \"checkid_immediate\" . equals ( mode ) ) { List < ? > userData = userInteraction ( request , manager . getOPEndpointUrl ( ) ) ; String userSelectedId = ( String ) userData . get ( 0 ) ; String userSelectedClaimedId = ( String ) userData . get ( 1 ) ; Boolean authenticatedAndApproved = ( Boolean ) userData . get ( 2 ) ; response = manager . authResponse ( request , userSelectedId , userSelectedClaimedId , authenticatedAndApproved . booleanValue ( ) ) ; if ( response instanceof DirectError ) { Form f = new Form ( ) ; @ SuppressWarnings ( \"unchecked\" ) Map < String , String > m = ( Map < String , String > ) response . getParameterMap ( ) ; for ( String key : m . keySet ( ) ) { f . add ( key , m . get ( key ) ) ; } return f . getWebRepresentation ( ) ; } else { redirectSeeOther ( response . getDestinationUrl ( true ) ) ; return new EmptyRepresentation ( ) ; } } else if ( \"check_authentication\" . equals ( mode ) ) { response = manager . verify ( request ) ; log . info ( \"OpenID : \" + response . keyValueFormEncoding ( ) ) ; responseText = response . keyValueFormEncoding ( ) ; } else if ( Method . GET . equals ( getMethod ( ) ) ) { sendXRDSLocation ( ) ; return new StringRepresentation ( \"XRDS Discovery Information\" ) ; } else { response = DirectError . createDirectError ( \"Unknown request\" ) ; responseText = response . keyValueFormEncoding ( ) ; } return new StringRepresentation ( responseText ) ; } private void sendXRDSLocation ( ) { ConcurrentMap < String , Object > attribs = getContext ( ) . getAttributes ( ) ; String id = getQuery ( ) . getFirstValue ( \"id\" ) ; String xrds = attribs . get ( \"xrds\" ) . toString ( ) ; String location = ( id != null ) ? xrds + \"?id=\" + id : xrds ; getLogger ( ) . info ( \"XRDS endpoint = \" + xrds ) ; @ SuppressWarnings ( \"unchecked\" ) Series < Header > headers = ( Series < Header > ) getResponse ( ) . getAttributes ( ) . get ( HeaderConstants . ATTRIBUTE_HEADERS ) ; if ( headers == null ) { headers = new Series < Header > ( Header . class ) ; headers . add ( \"X-XRDS-Location\" , location ) ; getResponse ( ) . getAttributes ( ) . put ( HeaderConstants . ATTRIBUTE_HEADERS , headers ) ; } else { headers . add ( \"X-XRDS-Location\" , location ) ; } getLogger ( ) . info ( \"Sending empty representation.\" ) ; } private List < Object > userInteraction ( ParameterList request , String endpoint ) { StringBuilder id = new StringBuilder ( ) ; id . append ( endpoint ) ; id . append ( \"?id=\" ) ; id . append ( \"foo\" ) ; List < Object", "gt": "> result = new ArrayList < Object > ( ) ;", "prediction": "> userData = userInteraction ( request , id . toString ( ) ) ;\n", "label": 1}
{"id": 2454, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NSECRecord extends Record { private static final long serialVersionUID = - 5165065768816265385L ; private Name next ; private TypeBitmap types ; NSECRecord ( ) { } Record getObject ( ) { return new NSECRecord ( ) ; } public NSECRecord ( Name name , int dclass , long ttl , Name next , int [ ] types ) { super ( name , Type . NSEC , dclass , ttl ) ; this . next = checkName ( \"next\" , next ) ; for ( int i = 0 ; i < types . length ; i ++ ) { Type . check ( types [ i ] ) ; } this . types = new TypeBitmap ( types ) ; } void rrFromWire ( DNSInput in ) throws IOException { next = new Name ( in ) ; types = new TypeBitmap ( in ) ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) { next . toWire ( out ,", "gt": "null , false ) ;", "prediction": "canonical ) ;\n", "label": 0}
{"id": 14209, "input": "<s> package monbulk . shared . Services ; import java . util . ArrayList ; import java . util . List ; import java . util . HashMap ; import java . util . Collection ; import monbulk . shared . util . XmlHelper ; public class Dictionary { public static class Entry { private ArrayList < String > m_definitions = new ArrayList < String > ( ) ; private String m_term ; public Entry ( String term ) { m_term = term ; } public ArrayList < String > getDefinitions ( ) { return m_definitions ; } public String getTerm ( ) { return m_term ; } } private HashMap < String , Entry > m_entries = new HashMap < String , Entry > ( ) ; private String m_name ; public Dictionary ( String name ) { m_name = name ; } public Collection < Entry > getEntries ( ) { return m_entries . values ( ) ; } public String getDefinition ( String name , String defaultValue ) { Entry e = m_entries . get ( name ) ; String value = defaultValue ; if ( e != null && e . getDefinitions ( ) . size ( ) > 0 ) { value = e . getDefinitions ( ) . get ( 0 ) ; } return value ; } public String getName ( ) { return m_name ; } public Entry addEntry ( String term ) { Entry entry = new Entry ( term ) ; m_entries . put ( term , entry ) ; return entry ; } public Entry addEntry ( String term , List < String > definitions ) { Entry entry = new Entry ( term ) ; if ( definitions != null ) { entry . getDefinitions ( ) . addAll ( definitions ) ; } m_entries . put ( term , entry ) ; return entry ; } public void addDictionary ( Dictionary dictionary ) { for ( Entry e : dictionary . getEntries ( ) ) { addEntry ( e . getTerm ( ) , e . getDefinitions ( ) ) ; } } public String getXmlForEntry ( Entry entry ) { StringBuilder sb = new StringBuilder ( ) ; XmlHelper . addTagWithValue ( sb , \"dictionary\" , m_name ) ; for ( String d : entry . getDefinitions ( ) ) { XmlHelper . addTagWithValue ( sb , \"definition\" , d ) ; } XmlHelper . addTagWithValue ( sb , \"term\" , entry . getTerm ( ) ) ; return", "gt": "sb . toString ( ) ;", "prediction": "sb . toString ( ) ;\n", "label": 1}
{"id": 8894, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . ui . client . com . grid . column . gkRadioColumnConfig ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . Radio ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class GRadioBuilder extends GridFieldBuilder { public GRadioBuilder ( String radio ) { super ( radio ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; final String boxLabel = x . getAttribute ( \"boxLabel\" , x . getLabel ( ) ) ; final String boxValue = x . getValue ( ) ; final String checked = x . getAttribute ( \"checked\" , \"false\" ) ; ColumnConfig cc = new gkRadioColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ;", "gt": "Radio radio = ( Radio ) field ;", "prediction": "}\n", "label": 0}
{"id": 14211, "input": "<s> package org . gatein . common . logging ; import junit . framework . TestCase ; import org . slf4j . impl . Log ; import org . slf4j . impl . LoggerFactoryImpl ; import org . slf4j . impl . LoggerImpl ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . locks . ReentrantLock ; public class LogTestCase extends TestCase { public void testGetLogger ( ) { Logger logger = LoggerFactory . getLogger ( LogTestCase . class ) ; assertNotNull ( logger ) ; assertEquals ( LogTestCase . class . getName ( ) , logger . getName ( ) ) ; assertSame ( logger , LoggerFactory . getLogger ( LogTestCase . class . getName ( ) ) ) ; } public void testConcurrentGetRace ( ) throws Exception { final ReentrantLock lock = LoggerFactoryImpl . getLock ( ) ; lock . lock ( ) ; final AtomicReference < Logger > loggerRef = new AtomicReference < Logger > ( ) ; final AtomicBoolean done = new AtomicBoolean ( ) ; Thread t = new Thread ( ) { public void run ( ) { Logger logger = LoggerFactory . getLogger ( \"testConcurrentGetRace\" ) ; loggerRef . set ( logger ) ; done . set ( true ) ; } } ; t . start ( ) ; while ( ! lock . hasQueuedThread ( t ) ) { Thread . sleep ( 1 ) ; } assertEquals ( null , LoggerFactoryImpl . peekLogger ( \"testConcurrentGetRace\" ) ) ; Logger logger = LoggerFactory . getLogger ( \"testConcurrentGetRace\" ) ; assertNotNull ( logger ) ; lock . unlock ( ) ; while ( ! done . get ( ) ) { Thread . sleep ( 1 ) ; } assertSame ( logger , loggerRef . get ( ) ) ; } public void testTraceEnabled ( ) { Logger logger = LoggerFactory . getLogger ( \"testTraceEnabled\" ) ; LoggerImpl loggerImpl = LoggerFactoryImpl . peekLogger ( \"testTraceEnabled\" ) ; assertTrue ( logger . isTraceEnabled ( ) ) ; loggerImpl . traceEnabled = false ; assertFalse ( logger . isTraceEnabled ( ) ) ; } public void testTrace ( ) { LoggerFactoryImpl . assertEmpty ( ) ; Logger logger = LoggerFactory . getLogger ( \"testTrace\" ) ; logger . trace ( \"testTrace1\" ) ; LoggerFactoryImpl . assertLog ( \"testTrace\" , Log . TRACE , \"testTrace1\" , null ) ; LoggerFactoryImpl . assertEmpty ( ) ; Throwable t = new Throwable ( ) ; logger . trace ( \"testTrace2\" , t ) ; LoggerFactoryImpl . assertLog ( \"testTrace\" , Log . TRACE , \"testTrace2\" , t ) ; LoggerFactoryImpl . assertEmpty ( ) ; } public void testDebugEnabled ( ) { Logger logger = LoggerFactory . getLogger ( \"testDebugEnabled\" ) ; LoggerImpl loggerImpl = LoggerFactoryImpl . peekLogger ( \"testDebugEnabled\" ) ; assertTrue ( logger . isDebugEnabled ( ) ) ; loggerImpl . debugEnabled = false ; assertFalse ( logger . isDebugEnabled ( ) ) ; } public void testDebug ( ) { LoggerFactoryImpl . assertEmpty ( ) ; Logger logger = LoggerFactory . getLogger ( \"testDebug\" ) ; logger . debug ( \"testDebug1\" ) ; LoggerFactoryImpl . assertLog ( \"testDebug\" , Log . DEBUG ,", "gt": "\"testDebug1\" , null ) ;", "prediction": "\"testDebug1\" , null ) ;\n", "label": 1}
{"id": 8832, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface DailyMin extends LimitsAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 14222, "input": "<s> package org . eclipse . swt . internal . image ; import java . io . * ; @ SuppressWarnings ( \"all\" ) public class PngInputStream extends InputStream { PngChunkReader reader ; PngChunk chunk ; int offset , length ; final static int DATA_OFFSET = 8 ; public PngInputStream ( PngIdatChunk chunk , PngChunkReader reader ) { this . chunk = chunk ; this . reader = reader ; length = chunk . getLength ( ) ; offset = 0 ; } private boolean checkChunk ( ) throws IOException { while ( offset == length ) { chunk = reader . readNextChunk ( ) ; if ( chunk == null ) throw new IOException ( ) ; if ( chunk . getChunkType ( ) == PngChunk . CHUNK_IEND ) return false ; if ( chunk . getChunkType ( ) != PngChunk . CHUNK_IDAT ) throw new IOException ( ) ; length = chunk . getLength ( ) ; offset = 0 ; } return true ; } public void close ( ) throws IOException { chunk = null ; } public int read ( ) throws IOException { if ( chunk == null ) throw new IOException ( ) ; if ( offset == length && ! checkChunk ( ) ) return - 1 ; int b = chunk . reference [ DATA_OFFSET + offset ] & 0xFF ; offset ++ ; return b ; } public int read ( byte [ ] b , int off ,", "gt": "int len ) throws IOException", "prediction": "int len ) throws IOException\n", "label": 1}
{"id": 4062, "input": "<s> package org . ofbiz . widget . screen ; import org . ofbiz . base . util . GeneralException ; @ SuppressWarnings ( \"serial\" ) public class ScreenRenderException extends GeneralException { public ScreenRenderException ( ) { super ( ) ; } public ScreenRenderException ( Throwable nested ) { super ( nested ) ; } public", "gt": "ScreenRenderException ( String str )", "prediction": "String toString ( )\n", "label": 0}
{"id": 14223, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class FocusEvent extends TypedEvent {", "gt": "private static final long serialVersionUID = 1L ;", "prediction": "public FocusEvent ( )\n", "label": 1}
{"id": 8956, "input": "<s> package org . ofbiz . minilang . method . envops ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class CheckId extends MethodOperation { public static final String module = CheckId . class . getName ( ) ; private final FlexibleMapAccessor < List < String > > errorListFma ; private final FlexibleMapAccessor < Object > fieldFma ; private final FlexibleStringExpander messageFse ; private final String propertykey ; private final String propertyResource ; public CheckId ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" , \"error-list-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"error-list-name\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"fail-message\" , \"fail-property\" ) ; } this . errorListFma = FlexibleMapAccessor . getInstance ( MiniLangValidate . checkAttribute ( element . getAttribute ( \"error-list-name\" ) , \"error_list\" ) ) ; this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; Element childElement = UtilXml . firstChildElement ( element , \"fail-message\" ) ; if ( childElement != null ) { if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , childElement , \"message\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , childElement , \"message\" ) ; MiniLangValidate . constantPlusExpressionAttributes ( simpleMethod , childElement , \"message\" ) ; } this . messageFse = FlexibleStringExpander . getInstance ( childElement . getAttribute ( \"message\" ) ) ; this . propertykey = null ; this . propertyResource = null ; } else { childElement = UtilXml . firstChildElement ( element , \"fail-property\" ) ; if ( childElement != null ) { if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , childElement , \"property\" , \"resource\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , childElement , \"property\" , \"resource\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , childElement ,", "gt": "\"property\" , \"resource\" ) ;", "prediction": "\"resource\" ) ;\n", "label": 0}
{"id": 14227, "input": "<s> package org . eclipse . ui . internal . services ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . part . IPageSite ; import org . eclipse . ui . part . MultiPageEditorSite ; import org .", "gt": "eclipse . ui . part . PageBookView ;", "prediction": "eclipse . ui . part . PartSite ;\n", "label": 1}
{"id": 8888, "input": "<s> package com . mapr . stats ; import com . google . common . collect . Lists ; import org . apache . mahout . math . stats . OnlineSummarizer ; import java . util . List ; import java . util . Random ; public class EpsilonGreedy extends BayesianBandit { private Random gen ; private double epsilon ; private final List < OnlineSummarizer > summaries ; public EpsilonGreedy ( int bandits , double epsilon , Random gen ) { this . gen = gen ; this . epsilon = epsilon ; summaries = Lists . newArrayList ( ) ; for ( int i = 0 ; i < bandits ; i ++ ) { final OnlineSummarizer s = new OnlineSummarizer ( ) ; summaries . add ( s ) ; s . add ( 1 ) ; } } @ Override public int sample ( ) { if ( gen . nextDouble ( ) < epsilon ) { return gen . nextInt ( summaries . size ( ) ) ; } else { double max = summaries . get ( 0 ) . getMean ( ) ; int i = 0 ; int maxIndex = 0 ; for ( OnlineSummarizer summary : summaries ) {", "gt": "if ( summary . getMean ( ) > max )", "prediction": "maxIndex ++ ;\n", "label": 0}
{"id": 14229, "input": "<s> package org . eclipse . ui . internal . contexts ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . contexts . ContextManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . ISources ; import org . eclipse . ui . LegacyHandlerSubmissionExpression ; import org . eclipse . ui . contexts . EnabledSubmission ; import org . eclipse . ui . contexts . IContextActivation ; import org . eclipse . ui . contexts . IContextManager ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . contexts . IWorkbenchContextSupport ; import org . eclipse . ui . internal . Workbench ; public class WorkbenchContextSupport implements IWorkbenchContextSupport { private Map activationsBySubmission = null ; private IContextService contextService ; private ContextManagerLegacyWrapper contextManagerWrapper ; private final Workbench workbench ; public WorkbenchContextSupport ( final Workbench workbenchToSupport , final ContextManager contextManager ) { workbench = workbenchToSupport ; contextService = ( IContextService ) workbench . getService ( IContextService . class ) ; contextManagerWrapper = ContextManagerFactory . getContextManagerWrapper ( contextManager ) ; } public final void addEnabledSubmission ( final EnabledSubmission enabledSubmission ) { int sourcePriorities = 0 ; if ( enabledSubmission . getActivePartId ( ) != null ) { sourcePriorities |= ISources . ACTIVE_PART_ID ; } if ( enabledSubmission . getActiveShell ( ) != null ) { sourcePriorities |= ( ISources . ACTIVE_SHELL | ISources . ACTIVE_WORKBENCH_WINDOW ) ; } if ( enabledSubmission . getActiveWorkbenchPartSite ( ) != null ) { sourcePriorities |= ISources . ACTIVE_SITE ; } final IContextActivation activation = contextService . activateContext ( enabledSubmission . getContextId ( ) , new LegacyHandlerSubmissionExpression ( enabledSubmission . getActivePartId ( ) , enabledSubmission . getActiveShell ( ) , enabledSubmission . getActiveWorkbenchPartSite ( ) ) ) ; if ( activationsBySubmission == null ) { activationsBySubmission = new HashMap ( ) ; } activationsBySubmission . put ( enabledSubmission , activation ) ; } public", "gt": "final void addEnabledSubmissions ( final Collection enabledSubmissions )", "prediction": "final void removeEnabledSubmission ( final EnabledSubmission enabledSubmission )\n", "label": 1}
{"id": 1428, "input": "<s> class CountError { void m ( ) { throw", "gt": "new Exception ( ) ;", "prediction": "new UnsupportedOperationException ( ) ;\n", "label": 0}
{"id": 14231, "input": "<s> package org . eclipse . ui . tests . session ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . themes . IThemeManager ; import junit . framework . TestCase ; public class ThemeStateTest extends TestCase { public ThemeStateTest ( final String name ) { super ( name ) ; } public void testBadPreference ( ) { String themeId = PlatformUI . getWorkbench ( ) . getThemeManager ( ) .", "gt": "getCurrentTheme ( ) . getId ( ) ;", "prediction": "getDefaultThemeId ( ) ;\n", "label": 1}
{"id": 6373, "input": "<s> package com . sap . prd . mobile . ios . mios ; import org . apache . maven . artifact . Artifact ; import org . junit . Assert ; import org . junit . Test ; import com . sap . prd . mobile . ios . mios . GAVUtil ; public class GAVUtilTest { @ Test public void testToColonNotation ( ) throws Exception { Assert . assertEquals ( \"com.sap.mytest:testArtifact:tar:classifier:1.0.0\" , GAVUtil . toColonNotation ( \"com.sap.mytest\" , \"testArtifact\" , \"1.0.0\" , \"tar\" , \"classifier\" ) ) ; } @ Test public void testToArtifact ( ) throws Exception { Artifact artifact = GAVUtil . getArtifact ( \"com.sap.mytest:testArtifact:tar:classifier:1.0.0\" ) ; Assert . assertEquals ( \"com.sap.mytest\" , artifact .", "gt": "getGroupId ( ) ) ;", "prediction": "getId ( ) ) ;\n", "label": 0}
{"id": 14234, "input": "<s> package org . eclipse . xtext . xdoc . naming ; import org . eclipse . xtext . naming . DefaultDeclarativeQualifiedNameProvider ; import org . eclipse . xtext . naming . QualifiedName ; import org . eclipse . xtext . util . Strings ; import org . eclipse . xtext . xdoc . xdoc . Identifiable ; import org . eclipse . xtext . xdoc . xdoc . LangDef ; public class XdocDocumentNameProvider extends DefaultDeclarativeQualifiedNameProvider { QualifiedName qualifiedName ( Identifiable identifiable ) { if ( ! Strings . isEmpty ( identifiable . getName ( ) ) ) return QualifiedName . create ( identifiable . getName ( ) ) ; return null ; }", "gt": "QualifiedName qualifiedName ( LangDef languageDefinition )", "prediction": "@ Override public String toString ( )\n", "label": 1}
{"id": 5529, "input": "<s> package jns . dynamic ; import java . rmi . RemoteException ; import java . rmi . Remote ; import java . net . DatagramPacket ; import java . net . InetAddress ; public interface DynamicScheduler extends Remote { public void scheduleUnicast ( InetAddress senderIPAddr , InetAddress receiverIPAddr", "gt": ", byte [ ] data ) throws RemoteException ;", "prediction": ") ;\n", "label": 0}
{"id": 14236, "input": "<s> package org . fuzzydb . server . internal . index . btree ;", "gt": "public interface NodeW extends NodeR", "prediction": "import java . io . IOException ;\n", "label": 1}
{"id": 6907, "input": "<s> package org . parboiled . support ; public class Chars { private Chars ( ) { } public static final char DEL_ERROR = '\ufdea' ; public static final char INS_ERROR = '\ufdeb' ; public static final char RESYNC = '\ufdec' ; public static final char RESYNC_START = '\ufded' ; public static final char RESYNC_END = '\ufdee' ; public static final", "gt": "char RESYNC_EOI = '\ufdef' ;", "prediction": "char RESYNC_STOP = '\u00ef\u00b7\u00af' ;\n", "label": 0}
{"id": 14238, "input": "<s> package com . inepex . classtemplater . plugin . logic ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public class AttrTypeParser { private String string ; private String separator ; private String hierarchOpen ; private String hierarchClose ; private Set < String > items = new HashSet < String > ( ) ; private List < String > firstLevelItemsInOrder = new ArrayList < String > ( ) ; public AttrTypeParser ( String string , String separator , String hierarchOpen , String hierarchClose ) { super ( ) ; if ( string . endsWith ( separator ) ) this . string = string . substring ( 0 , string . length ( ) - 1 ) ; else this . string = string ; this . separator = separator ; this . hierarchOpen = hierarchOpen ; this . hierarchClose = hierarchClose ; if ( string != null && ! string . equals ( \"\" ) ) { calcItems ( ) ; calcFirstLevelItems ( ) ; } } private void calcItems ( ) { calcItemsHelper ( string ) ; } private void calcItemsHelper ( String part ) { if ( checkCompound ( part ) ) { for ( String s : hierarchicalSplit ( part ) ) { calcItemsHelper ( s ) ; } } else { items . add ( getBase ( part ) ) ; String nextLevel = nextLevel ( part ) ; if ( nextLevel != null ) calcItemsHelper ( nextLevel ) ; } } private void calcFirstLevelItems ( ) { if ( nextLevel ( string ) != null ) for ( String s : hierarchicalSplit ( nextLevel ( string ) ) ) { firstLevelItemsInOrder . add ( s ) ; } } public String [ ] hierarchicalSplit ( String item ) { List < String > result = new ArrayList < String > ( ) ; StringBuffer part = new StringBuffer ( ) ; int hierarchy = 0 ; for ( int i = 0 ; i < item . length ( ) ; i ++ ) { String actual = item . substring ( i , i + 1 ) ; if ( actual . equals ( separator ) ) { if ( hierarchy == 0 ) { result . add ( part . toString ( ) ) ; part = new StringBuffer ( ) ; } } else if ( actual . equals ( hierarchOpen ) ) { hierarchy ++ ; } else if ( actual . equals ( hierarchClose ) ) { hierarchy -- ; } if ( hierarchy == 0 && ! actual . equals ( separator ) || hierarchy > 0 ) { part . append ( actual ) ; } } if ( part . length ( ) > 0 ) result . add ( part . toString ( ) ) ; return result . toArray ( new String [ 0 ] ) ; } public String getBase ( String item ) { if ( checkCompound ( item ) ) throw new RuntimeException ( \"invalid getBase call\" ) ; else if ( item . indexOf ( hierarchOpen ) == - 1 ) return item ; return item . substring ( 0 , item . indexOf ( hierarchOpen ) ) ; } public String nextLevel ( String item ) { if ( checkCompound ( item ) ) throw new RuntimeException ( \"invalid nextLevel call\" ) ; else if ( item . indexOf ( hierarchOpen ) == - 1 ) return null ; else return item . substring ( item . indexOf ( hierarchOpen ) + 1 , item . lastIndexOf ( hierarchClose ) ) ; } private boolean checkCompound ( String item ) { int hierarchy = 0 ; for ( int i = 0 ; i < item . length ( ) ; i ++ ) { String actual = item . substring ( i , i + 1 ) ; if ( actual . equals ( separator ) ) { if ( hierarchy == 0 ) { return true ; } } else if ( actual . equals ( hierarchOpen ) ) { hierarchy ++ ; } else if ( actual . equals ( hierarchClose ) ) { hierarchy -- ; } } return false ; } public Set < String > getItems ( ) { return items ; } public List < String > getFirstLevelItemsInOrder ( ) { return firstLevelItemsInOrder ; } public static String clean ( String s ) { return s . replace ( \"Q\" , \"\" ) . replace ( \";>\" , \">\" )", "gt": ". replace ( \";\" , \",\" ) ;", "prediction": ";\n", "label": 1}
{"id": 7133, "input": "<s> package b ; import a . * ; public class B extends A { interface Caller { void call ( ) ; } public void precall ( ) { foo ( ) ;", "gt": "Caller caller = new Caller ( )", "prediction": "}\n", "label": 0}
{"id": 14239, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . tomcat ; import org . eclipse . rap . rwt . cluster . testfixture . internal . server . ServletEngineClusterTestBase ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngineFactory ; import org . eclipse . rap . rwt . cluster . testfixture . server . TomcatFactory ; public class TomcatEngineCluster_Test extends ServletEngineClusterTestBase {", "gt": "protected IServletEngineFactory getServletEngineFactory ( )", "prediction": "public TomcatEngineCluster ( )\n", "label": 1}
{"id": 937, "input": "<s> package org . ofbiz . pos . component ; import net . xoetrope . swing . XPassword ; import org . ofbiz . pos . screen . PosScreen ; public class InputWithPassword extends Input { protected javax . swing . JTextField savedInput ; protected XPassword password = null ; public InputWithPassword ( PosScreen page ) { super ( page ) ; this . savedInput = super . input ; this . password = ( XPassword ) page . findComponent ( \"pos_inputpassword\" ) ; if ( this . password == null ) { this . password = new XPassword ( ) ; } this . password . setVisible ( false ) ; this . password . setFocusable ( false ) ; } public void setPasswordInput ( boolean isPasswordInput ) { if ( isPasswordInput ) { this . savedInput .", "gt": "setVisible ( false ) ;", "prediction": "setVisible ( true ) ;\n", "label": 0}
{"id": 14242, "input": "<s> package org . eclipse . jface . tests . dialogs ; import junit . framework . TestCase ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . jface . util . SafeRunnable ; public class SafeRunnableErrorTest extends TestCase { int count ; protected Thread runner ( ) { return new Thread ( new Runnable ( ) { public void run ( ) { ISafeRunnable runnable = new SafeRunnable ( ) { public void run ( ) throws Exception { throw new RuntimeException ( \"test exception \" + ++ count ) ; } } ; SafeRunnable . run ( runnable ) ; } } ) ; } public void testSafeRunnableHandler ( ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { throw new RuntimeException ( \"test exception\" ) ; } } ) ; } public void testSafeRunnableHandlerOtherThread ( ) throws Exception { Thread t = runner ( ) ;", "gt": "t . run ( ) ;", "prediction": "t . join ( ) ;\n", "label": 1}
{"id": 1141, "input": "<s> package org . ofbiz . order . order ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . LocalDispatcher ; public class OrderContentWrapper { public static final String module = OrderContentWrapper . class . getName ( ) ; public static final String SEPARATOR = \"::\" ; private static final UtilCache < String , String > orderContentCache = UtilCache . createUtilCache ( \"order.content\" , true ) ; public static OrderContentWrapper makeOrderContentWrapper ( GenericValue order , HttpServletRequest request ) { return new OrderContentWrapper ( order , request ) ; } protected LocalDispatcher dispatcher ; protected GenericValue order ; protected Locale locale ; protected String mimeTypeId ; public OrderContentWrapper ( LocalDispatcher dispatcher , GenericValue order , Locale locale , String mimeTypeId ) { this . dispatcher = dispatcher ; this . order = order ; this . locale = locale ; this . mimeTypeId = mimeTypeId ; } public OrderContentWrapper ( GenericValue order , HttpServletRequest request ) { this . dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; this . order = order ; this . locale = UtilHttp . getLocale ( request ) ; this . mimeTypeId = \"text/html\" ; } public String get ( String orderContentTypeId ) { return getOrderContentAsText ( order , orderContentTypeId , locale , mimeTypeId , order . getDelegator ( ) , dispatcher ) ; } public static String getOrderContentAsText ( GenericValue order , String orderContentTypeId , HttpServletRequest request ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; return getOrderContentAsText ( order , orderContentTypeId , UtilHttp . getLocale ( request ) , \"text/html\" , order . getDelegator ( ) , dispatcher ) ; } public static String getOrderContentAsText ( GenericValue order , String orderContentTypeId , Locale locale , LocalDispatcher dispatcher ) { return getOrderContentAsText ( order , orderContentTypeId , locale , null , null , dispatcher ) ; } public static String getOrderContentAsText ( GenericValue order , String orderContentTypeId , Locale locale , String mimeTypeId , Delegator delegator , LocalDispatcher dispatcher ) { String orderItemSeqId = ( order . getEntityName ( ) . equals ( \"OrderItem\" ) ? order . getString ( \"orderItemSeqId\" ) : \"_NA_\" ) ; String cacheKey = orderContentTypeId + SEPARATOR + locale + SEPARATOR + mimeTypeId + SEPARATOR + order . get ( \"orderId\" ) + SEPARATOR + orderItemSeqId ; try { String cachedValue = orderContentCache . get ( cacheKey ) ; if ( cachedValue != null ) { return cachedValue ; } Writer outWriter = new StringWriter ( ) ; getOrderContentAsText ( null , null , order , orderContentTypeId , locale , mimeTypeId , delegator , dispatcher , outWriter ) ; String outString = outWriter . toString ( ) ; if ( outString . length ( ) > 0 ) { outString = orderContentCache . putIfAbsentAndGet ( cacheKey , outString ) ; } return outString ; } catch ( GeneralException e ) { Debug . logError ( e , \"Error rendering OrderContent, inserting empty String\" , module ) ; return \"\" ; } catch ( IOException e ) { Debug . logError ( e , \"Error rendering OrderContent, inserting empty String\" , module ) ; return \"\" ; } } public static void getOrderContentAsText ( String orderId , String orderItemSeqId , GenericValue order , String orderContentTypeId , Locale locale , String mimeTypeId , Delegator delegator , LocalDispatcher dispatcher , Writer outWriter ) throws GeneralException , IOException {", "gt": "if ( orderId == null && order != null )", "prediction": "String cachedValue = orderContentCache . get ( orderId ) ;\n", "label": 0}
{"id": 14243, "input": "<s> package io . beancounter . platform . alive ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . http . HttpStatus ; import org . testng . Assert ; import org . testng . annotations . Test ; import io . beancounter . platform . APIResponse ; import io . beancounter . platform . AbstractJerseyTestCase ; import java . io . IOException ; public class AliveServiceTestCase extends AbstractJerseyTestCase { protected AliveServiceTestCase ( ) { super ( 9995 ) ; } @ Test public void testCheck ( ) throws IOException { HttpClient client = new HttpClient ( ) ; String baseQuery = \"api/check\" ; GetMethod getMethod = new GetMethod ( base_uri + baseQuery ) ; int result = client . executeMethod ( getMethod ) ; Assert . assertEquals ( result , HttpStatus . SC_OK ) ; String responseBody = new String ( getMethod . getResponseBody ( ) ) ; Assert . assertNotNull ( responseBody ) ; Assert . assertNotEquals ( responseBody , \"\" ) ; logger . info ( \"response: \" + responseBody ) ; APIResponse actual = fromJson ( responseBody , APIResponse . class ) ; APIResponse expected = new APIResponse ( actual . getObject ( ) , \"system up and running at\" , \"OK\" ) ; Assert . assertEquals ( actual , expected ) ; Assert . assertNotNull ( actual . getObject ( ) ) ; Assert . assertNotNull ( Long .", "gt": "parseLong ( actual . getObject ( ) ) ) ;", "prediction": "parseLong ( actual . getObject ( ) ) ) ;\n", "label": 1}
{"id": 5929, "input": "<s> package org . xbill . DNS . utils ; public class hexdump { private static final char [ ] hex = \"0123456789ABCDEF\" . toCharArray ( ) ; public static String dump ( String description , byte [ ] b , int offset , int length ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( length + \"b\" ) ; if ( description != null ) sb . append ( \" (\" + description + \")\" ) ; sb . append ( ':' ) ; int prefixlen = sb . toString ( ) . length ( ) ; prefixlen = ( prefixlen + 8 ) & ~ 7 ; sb . append ( '\\t' ) ; int perline = ( 80 - prefixlen ) / 3 ; for ( int i = 0 ; i < length ; i ++ ) { if ( i != 0 && i % perline == 0 ) { sb . append ( '\\n' ) ; for ( int j = 0 ; j < prefixlen / 8 ; j ++ ) sb . append ( '\\t' ) ; } int value = ( int ) ( b [ i + offset ] ) & 0xFF ; sb . append ( hex [ ( value > > 4 ) ] ) ; sb . append ( hex [ ( value & 0xF ) ] ) ; sb . append ( ' ' ) ; } sb . append ( '\\n' ) ; return sb . toString ( ) ; } public static String dump ( String s , byte [ ] b ) { return dump ( s , b , 0", "gt": ", b . length ) ;", "prediction": ", b . length ) ;\n", "label": 0}
{"id": 14245, "input": "<s> package org . eclipse . swt . widgets ; import java . io . IOException ; import java . io . InputStream ; import java . util . * ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . ITreeItemAdapter ; @ SuppressWarnings ( \"deprecation\" ) public class TreeItem_Test extends TestCase { private Display display ; private Shell shell ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConstructor ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; assertSame ( display , item . getDisplay ( ) ) ; assertEquals ( \"\" , item . getText ( ) ) ; assertSame ( item , tree . getItem ( tree . getItemCount ( ) - 1 ) ) ; try { new TreeItem ( ( TreeItem ) null , SWT . NONE ) ; fail ( \"Must not allow null-parent\" ) ; } catch ( IllegalArgumentException iae ) { } try { new TreeItem ( ( Tree ) null , SWT . NONE ) ; fail ( \"Must not allow null-parent\" ) ; } catch ( IllegalArgumentException iae ) { } try { new TreeItem ( tree , SWT . NONE , 5 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } try { new TreeItem ( item , SWT . NONE , 5 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } try { new TreeItem ( item , SWT . NONE , - 1 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } } public void testRemoveAll ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item1 = new TreeItem ( tree , SWT . NONE ) ; TreeItem item11 = new TreeItem ( item1 , SWT . NONE ) ; TreeItem item111 = new TreeItem ( item11 , SWT . NONE ) ; TreeItem item2 = new TreeItem ( tree , SWT . NONE ) ; item1 . removeAll ( ) ; assertEquals ( false , item1 . isDisposed ( ) ) ; assertEquals ( true , item11 . isDisposed ( ) ) ; assertEquals ( true , item111 . isDisposed ( ) ) ; assertEquals ( 0 , item1 . getItemCount ( ) ) ; assertEquals ( false , item2 . isDisposed ( ) ) ; } public void testVirtualRemoveAll ( ) { Tree tree = new Tree ( shell , SWT . VIRTUAL ) ; tree . setItemCount ( 1 ) ; TreeItem item = tree . getItem ( 0 ) ; item . setItemCount ( 100 ) ; TreeItem lastSubItem = item . getItem ( 99 ) ; assertFalse ( lastSubItem . isDisposed ( ) ) ; item . removeAll ( ) ; assertTrue ( lastSubItem . isDisposed ( ) ) ; } public void testFont ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; Font treeFont = Graphics . getFont ( \"BeautifullyCraftedTreeFont\" , 15 , SWT . BOLD ) ; tree . setFont ( treeFont ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; assertSame ( treeFont , item . getFont ( ) ) ; Font itemFont = Graphics . getFont ( \"ItemFont\" , 40 , SWT . NORMAL ) ; item . setFont ( itemFont ) ; assertSame ( itemFont , item . getFont ( ) ) ; item . setFont ( null ) ; assertSame ( treeFont , item . getFont ( ) ) ; } public void testChecked ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; Tree checkedTree = new Tree ( shell ,", "gt": "SWT . CHECK ) ;", "prediction": "SWT . NONE ) ;\n", "label": 1}
{"id": 2641, "input": "<s> package org . ofbiz . order . shoppinglist ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Date ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityTypeUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . shoppingcart . CartItemModifyException ; import org . ofbiz . order . shoppingcart . CheckOutHelper ; import org . ofbiz . order . shoppingcart . ItemNotFoundException ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . product . config . ProductConfigWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . calendar . RecurrenceInfo ; import org . ofbiz . service . calendar . RecurrenceInfoException ; import com . ibm . icu . util . Calendar ; public class ShoppingListServices { public static final String module = ShoppingListServices . class . getName ( ) ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static Map < String , Object > setShoppingListRecurrence ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; Timestamp startDate = ( Timestamp ) context . get ( \"startDateTime\" ) ; Timestamp endDate = ( Timestamp ) context . get ( \"endDateTime\" ) ; Integer frequency = ( Integer ) context . get ( \"frequency\" ) ; Integer interval = ( Integer ) context . get ( \"intervalNumber\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( frequency == null || interval == null ) { Debug . logWarning ( UtilProperties . getMessage ( resource_error , \"OrderFrequencyOrIntervalWasNotSpecified\" , locale ) , module ) ; return ServiceUtil . returnSuccess ( ) ; } if ( startDate == null ) { switch ( frequency . intValue ( ) ) { case 5 : startDate = UtilDateTime . getWeekStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; case 6 : startDate = UtilDateTime . getMonthStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; case 7 : startDate = UtilDateTime . getYearStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; default : return ServiceUtil . returnError ( UtilProperties . getMessage ( resource_error , \"OrderInvalidFrequencyForShoppingListRecurrence\" , locale ) ) ; } } long startTime = startDate . getTime ( ) ; long endTime = 0 ; if ( endDate != null ) { endTime = endDate . getTime ( ) ; } RecurrenceInfo recInfo = null ; try { recInfo = RecurrenceInfo . makeInfo ( delegator , startTime , frequency . intValue ( ) , interval . intValue ( ) , - 1 , endTime ) ; } catch ( RecurrenceInfoException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage", "gt": "( resource_error , \"OrderUnableToCreateShoppingListRecurrenceInformation\" , locale ) ) ;", "prediction": "( resource_error , \"OrderInvalidFrequencyForShoppingListRecurrence\" , locale ) ) ;\n", "label": 0}
{"id": 14246, "input": "<s> package org . nuxeo . ecm . automation . core . scripting ; import java . util . Calendar ; import java . util . Date ; import org . apache . commons . lang . StringEscapeUtils ; public class CoreFunctions { public DateWrapper date ( Date date ) { return new DateWrapper ( date ) ; } public DateWrapper calendar ( Calendar date ) { return new DateWrapper ( date ) ; } public String escapeHtml ( Object obj ) { return StringEscapeUtils . escapeHtml", "gt": "( obj . toString ( ) ) ;", "prediction": "( obj ) ;\n", "label": 1}
{"id": 3972, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . swing . ColorUtils ; import javax . swing . * ; import javax . swing . plaf . UIResource ; import java . awt . * ; import java . io . Serializable ; public class PgsIconFactory { private static Icon emptyIcon ; public static Icon getEmptyIcon ( ) { if ( emptyIcon == null ) { emptyIcon = new EmptyIcon ( PlafOptions . getDefaultMenuItemIconSize ( ) ) ; } return emptyIcon ; } private static class EmptyIcon implements Icon , UIResource , Serializable { private Dimension size ; public EmptyIcon ( Dimension dim ) { size = dim ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { return ; } public int getIconWidth ( ) { return size . width ; } public int getIconHeight ( ) { return size . height ; } } protected static void drawCheck ( Component c , Graphics g , int x , int y ) { g . translate ( x , y ) ; g . drawLine ( 3 , 5 , 3 , 5 ) ; g . fillRect ( 3 , 6 , 2 , 2 ) ; g . drawLine ( 4 , 8 , 9 , 3 ) ; g . drawLine ( 5 , 8 , 9 , 4 ) ; g . drawLine ( 5 , 9 , 9 , 5 ) ; g . translate ( - x , - y ) ; } private static Icon checkBoxIcon ; public static Icon getCheckBoxIcon ( ) { if ( checkBoxIcon == null ) { checkBoxIcon = new CheckBoxIcon ( ) ; } return checkBoxIcon ; } private static class CheckBoxIcon implements Icon , UIResource , Serializable { protected int getControlSize ( ) { return 13 ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { JCheckBox cb = ( JCheckBox ) c ; ButtonModel model = cb . getModel ( ) ; int controlSize = getControlSize ( ) ; boolean drawCheck = model . isSelected ( ) ; if ( model . isEnabled ( ) ) { g . setColor ( PgsLookAndFeel . getControlHighlight ( ) ) ; g . fillRect ( x , y , controlSize , controlSize ) ; PgsUtils . drawGradient ( g , x , y , controlSize , controlSize , ColorUtils . getTranslucentColor ( PgsLookAndFeel . getControlShadow ( ) , 0 ) , ColorUtils . getTranslucentColor ( PgsLookAndFeel . getControlShadow ( ) , 50 ) ) ; if ( model . isRollover ( ) ) { g . setColor ( PgsLookAndFeel . getGlow ( ) ) ; g . drawRect ( x + 1 , y + 1 , controlSize - 3 , controlSize - 3 ) ; } g . setColor ( PgsLookAndFeel . getControlDarkShadow ( ) ) ; g . drawRect ( x , y , controlSize - 1 , controlSize - 1 ) ; if ( model . isPressed ( ) && model . isArmed ( ) ) { g . setColor ( PgsLookAndFeel . getControlShadow ( ) ) ; g . fillRect ( x + 1 , y + 1 , controlSize - 2 , controlSize - 2 ) ; } g . setColor ( PgsLookAndFeel . getControlInfo ( ) ) ; } else { g . setColor ( PgsLookAndFeel . getControlShadow ( ) ) ; g . drawRect ( x , y , controlSize - 1 , controlSize - 1 ) ; } if ( drawCheck ) { g . setColor ( model . isEnabled ( ) ? PgsLookAndFeel . getPrimaryControlDarkShadow ( ) : PgsLookAndFeel . getControlShadow ( ) ) ; drawCheck ( c , g , x , y ) ; } } public int getIconWidth ( ) { return getControlSize ( ) ; } public int getIconHeight ( ) { return getControlSize ( ) ; } } private static Icon checkBoxMenuItemIcon ; public static Icon getCheckBoxMenuItemIcon ( ) { if ( checkBoxMenuItemIcon == null ) { checkBoxMenuItemIcon = new CheckBoxMenuItemIcon ( ) ; } return checkBoxMenuItemIcon ; } private static class CheckBoxMenuItemIcon implements Icon , UIResource , Serializable { protected int getControlSize ( ) { return 13 ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { JMenuItem cb = ( JMenuItem ) c ; ButtonModel model = cb . getModel ( ) ; int controlSize = getControlSize ( ) ; boolean drawCheck = model . isSelected ( ) ; if ( model . isEnabled ( ) ) { g . setColor ( PgsLookAndFeel . getControlHighlight ( ) ) ; g . fillRect ( x , y , controlSize , controlSize ) ; if ( model . isRollover ( ) ) { g . setColor ( PgsLookAndFeel . getPrimaryControl ( ) ) ; g . drawRect ( x + 1 , y + 1 , controlSize - 3 , controlSize - 3 ) ; } g . setColor ( PgsLookAndFeel . getControlDarkShadow ( ) ) ; g . drawRect ( x , y , controlSize - 1 , controlSize - 1 ) ; if ( model . isPressed ( ) && model . isArmed ( ) ) { g . setColor ( PgsLookAndFeel . getControlShadow ( ) ) ; g . fillRect ( x + 1 , y + 1 , controlSize - 2 , controlSize - 2 ) ; } g . setColor ( PgsLookAndFeel . getControlInfo ( ) ) ; } else { g . setColor ( PgsLookAndFeel . getControlShadow ( ) ) ; g . drawRect ( x , y ,", "gt": "controlSize - 1 , controlSize - 1 ) ;", "prediction": "controlSize - 1 , controlSize - 1 ) ;\n", "label": 0}
{"id": 14252, "input": "<s> package org . jscsi . target . connection . stage ; import java . io . IOException ; import java . security . DigestException ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . target . connection . Connection ; import org . jscsi . target . connection . TargetSession ; import org . jscsi . target . connection . phase . TargetPhase ; import org . jscsi . target . settings . Settings ; import org . jscsi . target . settings . SettingsException ; public abstract class TargetStage { protected final TargetPhase targetPhase ; protected final Connection connection ; protected final TargetSession session ; protected final Settings settings ; public TargetStage ( TargetPhase targetPhase ) { this . targetPhase = targetPhase ; this . connection = targetPhase . getTargetConnection ( ) ; this . session = connection . getTargetSession ( ) ; this . settings = connection . getSettings ( ) ; } public abstract void execute ( ProtocolDataUnit pdu ) throws IOException ,", "gt": "InterruptedException , InternetSCSIException , DigestException , SettingsException ;", "prediction": "InterruptedException , InternetSCSIException , DigestException , SettingsException ;\n", "label": 1}
{"id": 4825, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . Left ; import org . jjflyboy . tjpeditor . project . ProjectPackage ;", "gt": "public class LeftImpl extends ReportAttributeImpl implements Left", "prediction": "import org . jjflybreak . utils . EcoreUtil ;\n", "label": 0}
{"id": 14261, "input": "<s> package org . nuxeo . ecm . platform . publisher . api ; import java . io . Serializable ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . VersioningOption ; import org . nuxeo . ecm . core . api . event . CoreEventConstants ; import org . nuxeo . ecm . core . api . event . DocumentEventCategories ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventProducer ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; import org . nuxeo . ecm . platform . publisher . rules . PublishingValidatorException ; import org . nuxeo . ecm . platform . publisher . rules . ValidatorsRule ; import org . nuxeo . runtime . api . Framework ; public abstract class AbstractBasePublishedDocumentFactory implements PublishedDocumentFactory { public static final String ENABLE_SNAPSHOT = \"enableSnapshot\" ; public static final String TARGET_PUBLISHED_DOCUMENT_STATE = \"targetPublishedDocumentState\" ; protected CoreSession coreSession ; protected Map < String , String > parameters ; protected PublicationTree publicationTree ; protected ValidatorsRule validatorsRule ; protected EventProducer eventProducer ; public void init ( CoreSession coreSession , ValidatorsRule validatorsRule , Map < String , String > parameters ) throws ClientException { this . coreSession = coreSession ; this . parameters = parameters ; this . validatorsRule = validatorsRule ; if ( this . parameters == null ) { this . parameters = new HashMap < String , String > ( ) ; } } public void init ( CoreSession coreSession , Map < String , String > parameters ) throws ClientException { init ( coreSession , null , parameters ) ; } public String getName ( ) { return this . getClass ( ) . getSimpleName ( ) ; } protected String getParameter ( String name ) { return parameters . get ( name ) ; } protected boolean isSnapshotingEnabled ( ) { String snap = getParameter ( ENABLE_SNAPSHOT ) ; if ( snap == null ) { return false ; } else { return snap . equalsIgnoreCase ( \"true\" ) ; } } protected String getTargetPublishedDocumentState ( ) { return getParameter ( TARGET_PUBLISHED_DOCUMENT_STATE ) ; } public PublishedDocument publishDocument ( DocumentModel doc , PublicationNode targetNode ) throws ClientException { return", "gt": "publishDocument ( doc , targetNode , null ) ;", "prediction": "publishDocument ( doc , targetNode , null ) ;\n", "label": 1}
{"id": 2966, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . SmallFireball ; import Liza . LizaSmallFireball ; public class LizaCraftSmallFireball extends LizaCraftFireball implements LizaSmallFireball { public LizaCraftSmallFireball ( SmallFireball smallFireball ) { super ( smallFireball ) ; } @ Override", "gt": "public SmallFireball getBukkitHandle ( )", "prediction": "protected void setUp ( ) throws Exception\n", "label": 0}
{"id": 14276, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . core . api . DocumentModel ;", "gt": "public class DocModelToDocRef implements TypeAdapter", "prediction": "import org . nuxeo . ecm . core . api . DocumentRef ;\n", "label": 1}
{"id": 5043, "input": "<s> package org . bombusim . networking ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class NetworkDataStream { protected InputStream istream ; protected OutputStream ostream ; public InputStream getInputStream ( ) { return istream ; } public OutputStream getOutputStream ( ) { return ostream ; } public void closeConnection ( ) throws IOException { ostream . close ( ) ; istream . close ( ) ; } public int read ( byte [ ] cbuf ) throws IOException { return istream . read ( cbuf , 0 , cbuf . length ) ; } public void write ( byte [ ] bytes , int length ) throws IOException { ostream .", "gt": "write ( bytes , 0 , length ) ;", "prediction": "write ( bytes , 0 , length ) ;\n", "label": 0}
{"id": 14283, "input": "<s> package io . beancounter . commons . model . activity ; import org . joda . time . DateTime ; import io . beancounter . commons . model . activity . adapters . DateTimeAdapterJAXB ; import io . beancounter . commons . tests . annotations . Random ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . adapters . XmlJavaTypeAdapter ; import java . io . Serializable ; import java . lang . * ; import java . lang . Object ; @ XmlRootElement public class Context implements Serializable { private static final long serialVersionUID = 325277757335L ; private DateTime date ; private String service ; private String mood ; private String username ; public Context ( ) { } @ Random ( names = { \"d\" } ) public Context ( DateTime d ) { date = d ; } @ XmlJavaTypeAdapter ( DateTimeAdapterJAXB . class ) public DateTime getDate ( ) { return date ; } public void setDate ( DateTime date ) { this . date = date ; } public String getService ( ) { return service ; } public void setService ( String service ) { this . service = service ; } public String getMood ( ) { return mood ; } public void setMood ( String mood ) { this . mood = mood ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } @ Override public String toString ( ) { return \"Context{\" + \"date=\" + date + \", service=\" + service + \", mood='\" + mood + '\\'' + \", username='\" + username + '\\'' + '}' ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Context ) ) return false ; Context context = ( Context ) o ; if ( date != null ? ! date . equals ( context . date ) : context . date != null ) return false ; if ( service != null ? ! service . equals ( context . service ) : context . service != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result = date !=", "gt": "null ? date . hashCode ( ) : 0 ;", "prediction": "null ? date . hashCode ( ) : 0 ;\n", "label": 1}
{"id": 8461, "input": "<s> package org . ofbiz . pos . screen ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . swing . DefaultComboBoxModel ; import javolution . util . FastList ; import net . xoetrope . swing . XButton ; import net . xoetrope . swing . XComboBox ; import net . xoetrope . swing . XDialog ; import net . xoetrope . swing . XEdit ; import net . xoetrope . swing . XLabel ; import net . xoetrope . xui . XPage ; import net . xoetrope . xui . events . XEventHelper ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . pos . PosTransaction ; @ SuppressWarnings ( \"serial\" ) public class PaidInOut extends XPage { public static final String module = PaidInOut . class . getName ( ) ; protected static PosScreen m_pos = null ; protected XDialog m_dialog = null ; protected XLabel m_amoutLabel = null ; protected XEdit m_amountEdit = null ; protected XLabel m_reasonLabel = null ; protected XComboBox m_reasonCombo = null ; protected XLabel m_reasonCommentLabel = null ; protected XEdit m_reasonCommentEdit = null ; protected XButton m_cancel = null ; protected XButton m_ok = null ; protected DefaultComboBoxModel m_comboModel = null ; protected static PosTransaction m_trans = null ; protected String m_type = null ; protected boolean cancelled = false ; public PaidInOut ( PosTransaction trans , PosScreen page , String type ) { m_trans = trans ; m_pos = page ; m_type = type ; } public Map < String , String > openDlg ( ) { m_dialog = ( XDialog ) pageMgr . loadPage ( m_pos . getScreenLocation ( ) + \"/dialog/PaidInOut\" ) ; m_amoutLabel = ( XLabel ) m_dialog . findComponent ( \"amoutLabel\" ) ; m_amountEdit = ( XEdit ) m_dialog . findComponent ( \"amountEdit\" ) ; m_reasonLabel = ( XLabel ) m_dialog . findComponent ( \"reasonLabel\" ) ; m_reasonCombo = ( XComboBox ) m_dialog . findComponent ( \"reasonCombo\" ) ; m_reasonCommentLabel = ( XLabel ) m_dialog . findComponent ( \"reasonCommentLabel\" ) ; m_reasonCommentEdit = ( XEdit ) m_dialog . findComponent ( \"reasonCommentEdit\" ) ; m_cancel = ( XButton ) m_dialog . findComponent ( \"BtnCancel\" ) ; m_ok = ( XButton ) m_dialog . findComponent ( \"BtnOk\" ) ; Locale locale = Locale . getDefault ( ) ; XEventHelper . addMouseHandler ( this , m_cancel , \"cancel\" ) ; XEventHelper . addMouseHandler ( this , m_ok , \"verify\" ) ; XEventHelper . addMouseHandler ( this , m_amountEdit , \"editAmount\" ) ; m_comboModel = new DefaultComboBoxModel ( ) ; List < GenericValue > posPaidReasons = FastList . newInstance ( ) ; if ( m_type . equals ( \"IN\" ) ) { m_dialog . setCaption ( UtilProperties . getMessage ( PosTransaction . resource , \"PosPaidInTitle\" , locale ) ) ; try { posPaidReasons = m_trans . getSession ( ) . getDelegator ( ) . findByAnd ( \"Enumeration\" , UtilMisc . toMap ( \"enumTypeId\" , \"POS_PAID_REASON_IN\" ) , null , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; } } else { m_dialog . setCaption ( UtilProperties . getMessage ( PosTransaction . resource , \"PosPaidOutTitle\" , locale ) ) ; try { posPaidReasons = m_trans . getSession ( ) . getDelegator ( ) . findByAnd ( \"Enumeration\" , UtilMisc . toMap ( \"enumTypeId\" , \"POS_PAID_REASON_OUT\" ) , null , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; } } for ( GenericValue reason : posPaidReasons ) { m_comboModel . addElement ( reason . get ( \"description\" , locale ) ) ; } m_reasonCombo . setModel ( m_comboModel ) ; m_reasonCombo . setToolTipText ( UtilProperties . getMessage ( PosTransaction . resource , \"PosCreateOrChooseReasonInOut\" , locale ) ) ; m_dialog . pack ( ) ; m_reasonCombo . requestFocusInWindow ( ) ; m_dialog .", "gt": "showDialog ( this ) ;", "prediction": "pack ( ) ;\n", "label": 0}
{"id": 14285, "input": "<s> package org . restlet . test . bench ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . data . Protocol ; import org . restlet . engine . ConnectorHelper ; import org . restlet . engine . Engine ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; public class NioClient { public static void main ( String [ ] args ) throws Exception { ConnectorHelper < Client > helper ; helper = new org . restlet . engine . connector . HttpClientHelper ( null ) ; Engine . getInstance ( ) . getRegisteredClients ( ) . add ( 0 , helper ) ; final Client client = new Client ( new Context ( ) , Protocol . HTTP ) ; String uri = \"http://127.0.0.1:7777/\" ; int iterations = 100 ; ClientResource cr = new ClientResource ( uri ) ; cr . setRetryOnError ( false ) ; cr . setNext ( client ) ; Representation r = null ; System . out . println ( \"Calling resource: \" + uri + \" \" + iterations + \" times\" ) ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < iterations ; i ++ ) { r = cr . get ( ) ; System . out . println ( \"Copying to the local file \" + i + \"/\" + iterations ) ; ClientResource fr = new ClientResource ( \"file://C/Test/run\" + i + \".pdf\" ) ; fr . put ( r ) ; System . out . println ( \"Copy done!\" ) ; } long total = ( System . currentTimeMillis ( ) - start ) ; long avg = total / iterations ; System . out . println ( \"Bench completed in \" + total + \" ms. Average time per call: \" + avg", "gt": "+ \" ms\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9003, "input": "<s> public class AssignmentSameType7 { public static void main ( String [ ] args ) { Ref < B > exact = null ; Ref < ? extends B > ebound = null ; Ref < ? super B > sbound = null ;", "gt": "Ref < ? > unbound = null ;", "prediction": "try\n", "label": 0}
{"id": 14288, "input": "<s> package org . mitre . jwt . signer . impl ; import static org . junit . Assert . assertEquals ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . PrivateKey ; import java . security . PublicKey ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mitre . jwt . model . Jwt ; import org . mitre . jwt . model . JwtClaims ; import org . mitre . jwt . model . JwtHeader ; import org . mitre . jwt . signer . JwsAlgorithm ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import com . google . gson . JsonIOException ; import com . google . gson . JsonObject ; import com . google . gson . JsonParser ; import com . google . gson . JsonSyntaxException ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { \"classpath:test-context.xml\" } ) public class Rsa384Test { URL claimsUrl = this . getClass ( ) . getResource ( \"/jwt/claims\" ) ; URL rs384Url = this . getClass ( ) . getResource ( \"/jwt/rs384\" ) ;", "gt": "Jwt jwt = null ;", "prediction": "RSAPublicKey publicKey = null ;\n", "label": 1}
{"id": 5797, "input": "<s> package org . dawb . workbench . plotting . system . dialog ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . workbench . plotting . system . swtxy . RegionArea ; import org . dawb . workbench . plotting . system . swtxy . XYRegionGraph ; import org . dawb . workbench . plotting . system . swtxy . selection . AbstractSelectionRegion ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; public class RemoveRegionDialog extends Dialog { private XYRegionGraph xyGraph ; private Combo regionCombo ; private AbstractSelectionRegion removedRegion ; public RemoveRegionDialog ( Shell parentShell , XYRegionGraph xyGraph ) { super ( parentShell ) ; this . xyGraph = xyGraph ; setShellStyle ( getShellStyle ( ) | SWT . RESIZE ) ; } @ Override protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( \"Remove Region\" ) ; } @ Override protected Control createDialogArea ( Composite parent ) { final Composite parent_composite = ( Composite ) super . createDialogArea ( parent ) ; final Composite composite = new Composite ( parent_composite , SWT . NONE ) ; composite . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; composite . setLayout ( new GridLayout ( 1 , false ) ) ; final Label removeLabel = new Label ( composite , SWT . None ) ; removeLabel . setLayoutData ( new GridData ( ) ) ; if ( ( ( RegionArea ) xyGraph . getPlotArea ( ) ) . getRegionMap ( ) . size ( ) > 0 ) { removeLabel . setText ( \"Select the region to be removed: \" ) ; regionCombo = new Combo ( composite , SWT . DROP_DOWN ) ; regionCombo . setLayoutData ( new GridData ( SWT . FILL , 0 , true , false ) ) ; final RegionArea regArea = ( RegionArea ) xyGraph . getPlotArea ( ) ; for ( String name : regArea . getRegionMap ( ) . keySet ( ) ) { final AbstractSelectionRegion region = regArea . getRegion ( name ) ; if ( ! region . isUserRegion", "gt": "( ) ) continue ;", "prediction": "( ) )\n", "label": 0}
{"id": 14297, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . widgets . Composite ; abstract class AbstractComboBoxCellEditor extends CellEditor { public static final int DROP_DOWN_ON_MOUSE_ACTIVATION = 1 ; public static final int DROP_DOWN_ON_KEY_ACTIVATION = 1 << 1 ; public static final int DROP_DOWN_ON_PROGRAMMATIC_ACTIVATION = 1 << 2 ; public static final int DROP_DOWN_ON_TRAVERSE_ACTIVATION = 1 << 3 ; private int activationStyle = SWT . NONE ; AbstractComboBoxCellEditor ( Composite parent , int style ) { super ( parent , style ) ; } AbstractComboBoxCellEditor ( ) { } public void activate ( ColumnViewerEditorActivationEvent activationEvent ) { super . activate ( activationEvent ) ; if ( activationStyle != SWT . NONE ) { boolean dropDown = false ; if ( ( activationEvent . eventType == ColumnViewerEditorActivationEvent . MOUSE_CLICK_SELECTION || activationEvent . eventType == ColumnViewerEditorActivationEvent . MOUSE_DOUBLE_CLICK_SELECTION ) && ( activationStyle & DROP_DOWN_ON_MOUSE_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent . KEY_PRESSED && ( activationStyle & DROP_DOWN_ON_KEY_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent . PROGRAMMATIC && ( activationStyle & DROP_DOWN_ON_PROGRAMMATIC_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent", "gt": ". TRAVERSAL && ( activationStyle & DROP_DOWN_ON_TRAVERSE_ACTIVATION ) != 0 )", "prediction": ". PROGRAMMATIC && ( activationStyle & DROP_DOWN_ON_TRAVERSE_ACTIVATION ) != 0 )\n", "label": 1}
{"id": 2571, "input": "<s> package org . xbill . DNS ; public final class Credibility { private Credibility ( ) { } public static final int HINT = 0 ; public static final int ADDITIONAL = 1 ; public static final int GLUE = 2 ; public static final int NONAUTH_AUTHORITY = 3 ; public static", "gt": "final int NONAUTH_ANSWER = 3 ;", "prediction": "final int NONE = 4 ;\n", "label": 0}
{"id": 14298, "input": "<s> package fr . inria . zvtm . engine ; import java . awt . Color ; import java . awt . geom . Point2D ; import java . awt . geom . Ellipse2D ; import java . awt . AlphaComposite ; import java . util . Vector ; import java . util . HashMap ; import java . util . Set ; import java . util . Timer ; import java . util . TimerTask ; import fr . inria . zvtm . event . DynaSpotListener ; import fr . inria . zvtm . event . SelectionListener ; import fr . inria . zvtm . glyphs . Translucency ; import fr . inria . zvtm . glyphs . Glyph ; public class DynaPicker { HashMap gida = new HashMap ( 20 ) ; int DYNASPOT_MAX_RADIUS = 16 ; int LAG_TIME = 120 ; int REDUC_TIME = 180 ; Color DYNASPOT_COLOR = Color . LIGHT_GRAY ; float DYNASPOT_MAX_TRANSLUCENCY = 0.3f ; AlphaComposite dsST = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , ( float ) DYNASPOT_MAX_TRANSLUCENCY ) ; public static final short DYNASPOT_VISIBILITY_INVISIBLE = 0 ; public static final short DYNASPOT_VISIBILITY_VISIBLE = 1 ; public static final short DYNASPOT_VISIBILITY_FADEIN = 2 ; public static final short DYNASPOT_VISIBILITY_FADEOUT = 3 ; short dynaSpotVisibility = DYNASPOT_VISIBILITY_VISIBLE ; VCursor cursor ; DynaPicker ( VCursor c ) { this . cursor = c ; computeParams ( ) ; setSelectionListener ( new DefaultSelectionAction ( ) ) ; } void computeParams ( ) { ds_aa = DYNASPOT_MAX_RADIUS / ( float ) ( MAX_SPEED - MIN_SPEED ) ; ds_ab = - DYNASPOT_MAX_RADIUS * MIN_SPEED / ( float ) ( MAX_SPEED - MIN_SPEED ) ; ds_ra = - DYNASPOT_MAX_RADIUS / ( float ) REDUC_TIME ; ds_ra = - DYNASPOT_MAX_RADIUS / ( float ) Math . pow ( REDUC_TIME , 2 ) ; ds_rb = DYNASPOT_MAX_RADIUS ; } public void setDynaSpotVisibility ( short v ) { dynaSpotVisibility = v ; showDynarea = dynaSpotVisibility != DYNASPOT_VISIBILITY_INVISIBLE ; } public void setDynaSpotColor ( Color c ) { DYNASPOT_COLOR = c ; } public Color getDynaSpotColor ( ) { return DYNASPOT_COLOR ; } public void setDynaSpotTranslucence ( float a ) { DYNASPOT_MAX_TRANSLUCENCY = a ; dsST = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , ( float ) DYNASPOT_MAX_TRANSLUCENCY ) ; } public float getDynaSpotTranslucence ( ) { return DYNASPOT_MAX_TRANSLUCENCY ; } public void setDynaSpotLagTime ( int t ) { LAG_TIME = t ; } public int getDynaSpotLagTime ( ) { return LAG_TIME ; } public void setDynaSpotReducTime ( int t ) { REDUC_TIME = t ; computeParams ( ) ; } public int getDynaSpotReducTime ( ) { return REDUC_TIME ; } int MIN_SPEED = 100 ; int MAX_SPEED = 300 ; float ds_aa ; float ds_ab ; float ds_ra ; float ds_rb ; int dynaSpotRadius = 0 ; boolean dynaSpotActivated = false ; boolean showDynarea = true ; Timer dstimer ; DynaSpotTimer dynaspotTimer ; double opacity = 1.0f ; double [ ] dynawnes = new double [ 4 ] ; Ellipse2D dynaspotVSshape = new Ellipse2D . Double ( 0 , 0 , 1 , 1 ) ; void initDynaSpotTimer ( ) { dstimer = new Timer ( ) ; dynaspotTimer = new DynaSpotTimer ( this ) ; dstimer . scheduleAtFixedRate", "gt": "( dynaspotTimer , 40 , 20 ) ;", "prediction": "( new Runnable ( )\n", "label": 1}
{"id": 3004, "input": "<s> package com . matburt . mobileorg . Services ; import android . app . AlarmManager ; import android . app . Notification ; import android . app . NotificationManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . Context ; import android . content . Intent ; import android . graphics . Color ; import android . os . IBinder ; import android . support . v4 . app . NotificationCompat ; import android . support . v4 . app . NotificationCompat . Builder ; import android . text . SpannableStringBuilder ; import android . text . TextUtils ; import android . text . format . DateUtils ; import android . text . style . ForegroundColorSpan ; import android . util . Log ; import android . widget . RemoteViews ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . OrgData . MobileOrgApplication ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . util . OrgNodeNotFoundException ; public class TimeclockService extends Service { public static final String NODE_ID = \"node_id\" ; public static final String TIMECLOCK_UPDATE = \"timeclock_update\" ; public static final String TIMECLOCK_TIMEOUT = \"timeclock_timeout\" ; private final int notificationID = 1337 ; private NotificationManager mNM ; private AlarmManager alarmManager ; private Notification notification ; private long node_id ; private OrgNode node ; private int estimatedMinute = - 1 ; private int estimatedHour = - 1 ; private MobileOrgApplication appInst ; private static TimeclockService sInstance ; private long startTime ; private PendingIntent updateIntent ; private PendingIntent timeoutIntent ; private boolean hasTimedOut = false ; public static TimeclockService getInstance ( ) { return sInstance ; } @ Override public void onCreate ( ) { super . onCreate ( ) ; sInstance = this ; this . mNM = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; this . alarmManager = ( AlarmManager ) getSystemService ( Context . ALARM_SERVICE ) ; this . appInst = ( MobileOrgApplication ) getApplication ( ) ; } @ Override public void onDestroy ( ) { cancelNotification ( ) ; super . onDestroy ( ) ; } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { String action = intent . getStringExtra ( \"action\" ) ; Log . d ( \"MobileOrg\" , \"Called onStartCommand() with :\" + action ) ; if ( action == null ) { this . node_id = intent . getLongExtra ( NODE_ID , - 1 ) ; try { this . node = new OrgNode ( node_id , getContentResolver ( ) ) ; } catch ( OrgNodeNotFoundException e ) { } this . startTime = System . currentTimeMillis ( ) ; getEstimated ( ) ; showNotification ( node_id ) ; setUpdateAlarm ( ) ; setTimeoutAlarm ( this . estimatedHour , this . estimatedMinute ) ; } else if ( action . equals ( TIMECLOCK_UPDATE ) ) updateTime ( ) ; else if ( action . equals ( TIMECLOCK_TIMEOUT ) ) { doTimeout ( ) ; } return 0 ; } private void getEstimated ( ) { String estimated = node . getOrgNodePayload ( ) . getProperty ( \"Effort\" ) . trim ( ) ; if ( TextUtils . isEmpty ( estimated ) == false ) { String [ ] split = estimated . split ( \":\" ) ; try { if ( split . length == 1 ) this . estimatedMinute = Integer . parseInt ( split [ 0 ] ) ; else if ( split . length == 2 ) { this . estimatedHour = Integer . parseInt ( split [ 0 ] ) ; this . estimatedMinute = Integer . parseInt ( split [ 1 ] ) ; } } catch ( NumberFormatException e ) { } } } private void showNotification ( long node_id ) { PendingIntent contentIntent = PendingIntent . getActivity ( this , 1 , new Intent ( this , TimeclockDialog . class ) , 0 ) ; Builder builder = new NotificationCompat . Builder ( this ) ; builder . setSmallIcon ( R . drawable . icon ) ; builder . setContentTitle ( node . name ) ; builder . setContentIntent ( contentIntent ) ; builder . setOngoing ( true ) ; this . notification = builder . getNotification ( ) ; notification . contentView = new RemoteViews ( this . getPackageName ( ) , R . layout . timeclock_notification ) ; notification . contentView . setImageViewResource ( R . id . timeclock_notification_icon , R . drawable . icon ) ; notification . contentView . setTextViewText ( R . id . timeclock_notification_text , node . name ) ; updateTime ( ) ; mNM . notify ( notificationID , notification ) ; } private void setUpdateAlarm ( ) { Intent intent = new Intent ( this , TimeclockService . class ) ; intent . putExtra ( \"action\" , TIMECLOCK_UPDATE ) ; this . updateIntent = PendingIntent . getService ( appInst , 1 , intent , 0 ) ; alarmManager . setRepeating ( AlarmManager . RTC , System . currentTimeMillis ( ) + DateUtils . MINUTE_IN_MILLIS , DateUtils . MINUTE_IN_MILLIS , updateIntent ) ; } private void setTimeoutAlarm ( int hour , int minute ) { if ( hour <= 0 && minute <= 0 ) return ; long time = ( hour * DateUtils . HOUR_IN_MILLIS ) + ( minute * DateUtils . MINUTE_IN_MILLIS ) ; Intent intent = new Intent ( this , TimeclockService . class ) ; intent . putExtra ( \"action\" , TIMECLOCK_TIMEOUT ) ; this . timeoutIntent = PendingIntent . getService ( appInst , 2 , intent , 0 ) ; alarmManager . set ( AlarmManager . RTC_WAKEUP , System . currentTimeMillis ( ) + time , timeoutIntent ) ; } private void unsetAlarms ( ) { if ( this . updateIntent != null ) { alarmManager . cancel ( this . updateIntent ) ; this . updateIntent = null ; } if ( this . timeoutIntent != null ) { alarmManager . cancel ( this . timeoutIntent ) ; this . timeoutIntent = null ; } } private void doTimeout ( ) { if ( notification == null ) return ; notification . defaults = Notification . DEFAULT_ALL ; mNM . notify ( notificationID , notification ) ; notification . defaults = 0 ;", "gt": "this . hasTimedOut = true ;", "prediction": "}\n", "label": 0}
{"id": 14303, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . feeds . DocMaker ; import org . apache . lucene . document . Document ; import org . apache . lucene . index . Term ; public class UpdateDocTask extends PerfTask { public UpdateDocTask ( PerfRunData runData ) { super ( runData ) ; } private int docSize = 0 ; private Document doc = null ; public void setup ( ) throws Exception { super . setup ( ) ; DocMaker docMaker = getRunData ( ) . getDocMaker ( ) ; if ( docSize > 0 ) { doc = docMaker . makeDocument ( docSize ) ; } else { doc = docMaker . makeDocument ( ) ; } } public void tearDown ( ) throws Exception { doc = null ; super . tearDown ( ) ; } public int doLogic ( ) throws Exception { final String docID =", "gt": "doc . get ( DocMaker . ID_FIELD ) ;", "prediction": "getRunData ( ) . getDocID ( ) ;\n", "label": 1}
{"id": 626, "input": "<s> package ar . com . fdvs . dj . output ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . servlet . http . HttpServletResponse ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRExporter ; import net . sf . jasperreports . engine . JRExporterParameter ; import net . sf . jasperreports . engine . JasperPrint ; public abstract class ReportWriter { public JRExporter getExporter ( ) { return exporter ; } private static final int BUFFER_SIZE = 10 * 1024 ; protected JasperPrint jasperPrint ; protected JRExporter exporter ; protected ReportWriter ( final JasperPrint _jasperPrint , final JRExporter _exporter ) { jasperPrint = _jasperPrint ; exporter = _exporter ; exporter . setParameter ( JRExporterParameter . JASPER_PRINT , jasperPrint ) ; } public abstract void writeTo ( HttpServletResponse _response ) throws IOException , JRException ; protected void copyStreams ( final InputStream _inputStream , final OutputStream _ouputStream ) throws IOException { final byte", "gt": "[ ] buffer = new byte [ BUFFER_SIZE ] ;", "prediction": "[ ] buffer = new byte [ BUFFER_SIZE ] ;\n", "label": 0}
{"id": 14307, "input": "<s> package org . restlet . test . ext . odata . cafecustofeeds ; public class Item { private String description ; private String id ; public Item ( ) { super ( ) ; } public Item ( String id ) { this ( ) ; this . id = id ; } public String getDescription ( ) { return description ; } public String getId ( ) { return id ; } public void setDescription ( String description ) { this . description = description ; } public void", "gt": "setId ( String id )", "prediction": "setId ( String id )\n", "label": 1}
{"id": 5981, "input": "<s> class DepAnn { void m1 ( int i ) { } } @ SuppressWarnings ( \"dep-ann\" ) class DepAnn1 { void m1 ( int i ) { int x = 3 ; } } class DepAnn2 { @ SuppressWarnings ( \"dep-ann\" ) class Bar { void m1 ( int i ) { } } @ SuppressWarnings ( \"dep-ann\" )", "gt": "void m2 ( int i )", "prediction": "class Bar2\n", "label": 0}
{"id": 14313, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . IOException ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import com . cloudera . sqoop . lib . SqoopRecord ; import com . cloudera . sqoop . mapreduce . ExportOutputFormat ; public class ExportBatchOutputFormat < K extends SqoopRecord , V > extends ExportOutputFormat < K , V > { private static final Log LOG = LogFactory . getLog ( ExportBatchOutputFormat . class ) ; @ Override public RecordWriter < K , V > getRecordWriter ( TaskAttemptContext context ) throws IOException { try { return new ExportBatchRecordWriter ( context ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } public class ExportBatchRecordWriter extends ExportRecordWriter { public ExportBatchRecordWriter ( TaskAttemptContext context ) throws ClassNotFoundException , SQLException { super ( context ) ; } @ Override protected boolean isBatchExec ( ) { return true ; } @ Override protected PreparedStatement getPreparedStatement ( List < SqoopRecord > userRecords ) throws SQLException { PreparedStatement stmt = null ; Connection conn = getConnection ( ) ; synchronized ( conn ) { stmt = conn . prepareStatement ( getInsertStatement ( userRecords . size ( ) ) ) ; } for ( SqoopRecord record : userRecords ) { record . write ( stmt , 0 ) ; stmt . addBatch ( ) ; } return stmt ; } protected String getInsertStatement ( int numRows ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"INSERT INTO \" + tableName + \" \" ) ; int numSlots ; if ( this . columnNames != null ) {", "gt": "numSlots = this . columnNames . length ;", "prediction": "numSlots = this . columnNames . length ;\n", "label": 1}
{"id": 711, "input": "<s> import java . util . Set ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import static javax . tools . Diagnostic . Kind . * ; @ SupportedOptions ( \"finalError\" ) public class MessagerBasics extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( roundEnv . processingOver ( ) ) { if ( processingEnv . getOptions ( ) . containsKey ( \"finalError\" ) ) messager . printMessage ( ERROR , \"Does not compute\" ) ; else {", "gt": "messager . printMessage ( NOTE , \"Post no bills\" ) ;", "prediction": "processingEnv . getOptions ( ) . remove ( \"finalError\" ) ;\n", "label": 0}
{"id": 14318, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs ; import javax . ws . rs . GET ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; public class ChainResource extends ExecutableResource { protected final String chainId ; public ChainResource ( AutomationService service , String chainId ) { super ( service ) ; this . chainId = chainId ; } @ GET public Object doGet ( ) { return null ; } @ Override public Object execute ( ExecutionRequest xreq ) throws Exception { OperationContext ctx = xreq . createContext ( request", "gt": ", getCoreSession ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2006, "input": "<s> public class T6491592 { public static void main ( String ... args ) {", "gt": "Object o = null ;", "prediction": "try\n", "label": 0}
{"id": 14323, "input": "<s> package org . seage . problem . qap . tabusearch ; import org . seage . metaheuristic . tabusearch . * ; public class QapObjectiveFunction implements ObjectiveFunction { public double [ ] [ ] [ ] _matrix ; public QapObjectiveFunction ( Double [ ] [ ] [ ] facilityLocation ) { int numFacilities = facilityLocation [ 0 ] [ 0 ] . length ; double [ ] [ ] [ ] customers = new double [ 3 ] [ numFacilities ] [ numFacilities ] ; for ( int n = 0 ; n < 3 ; n ++ ) for ( int i = 0 ; i < numFacilities ; i ++ ) { for ( int j = 0 ; j < numFacilities ; j ++ ) { customers [ n ] [ i ] [ j ] = facilityLocation [ n ] [ i ] [ j ] ; } } _matrix = customers ; } @ Override public double [ ] evaluate ( Solution solution , Move move ) throws Exception { try { Integer [ ] assign = ( ( QapSolution ) solution ) . _assign ; int len = assign . length ; if ( move == null ) { double price = 0 ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { double a = _matrix [ 0 ] [ i ] [ j ] ; price += _matrix [ 0 ] [ i ] [ j ] * _matrix [ 1 ] [ assign [ i ] ] [ assign [ j ] ] ; } } double addition = 0 ; for ( int i = 0 ; i < _matrix [ 0 ] [ 0 ] . length ; i ++ ) { addition += _matrix [ 2 ] [ i ] [ assign [ i ] ] ; } return new double [ ] { price + addition } ; } else { QapSwapMove mv = ( QapSwapMove ) move ; int pos1 = - 1 ; int pos2 = - 1 ; for ( int i = 0 ; i < assign . length ; i ++ ) { if ( assign [ i ] == mv . customer ) { pos1 = i ; break ; } } pos2 = pos1 + mv . movement ; double price = solution . getObjectiveValue ( ) [ 0 ] ; double delta = 0 ; delta += _matrix [ 0 ] [ pos1 ] [ pos1 ] * ( _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos2 ] ] - _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos1 ] ] ) ; delta += _matrix [ 0 ] [ pos1 ] [ pos2 ] * ( _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos1 ] ] - _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos2 ] ] ) ; delta += _matrix [ 0 ] [ pos2 ] [ pos1 ] * ( _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos2 ] ] - _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos1 ] ] ) ; delta += _matrix [ 0 ] [ pos2 ] [ pos2 ] * ( _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos1 ] ] - _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos2 ] ] ) ; double temp = 0 ; for ( int i = 0 ; i <", "gt": "_matrix [ 0 ] [ 0 ] . length ;", "prediction": "assign . length ;\n", "label": 1}
{"id": 5829, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Effort extends TaskAttribute { DurationQuantity getEffort ( ) ; void setEffort", "gt": "( DurationQuantity value ) ;", "prediction": "( DurationQuantity value ) ;\n", "label": 0}
{"id": 14325, "input": "<s> package org . eclipse . ui . internal . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; public abstract", "gt": "class ExecutableExtensionHandler extends AbstractHandler implements IExecutableExtension", "prediction": "class AbstractHandler extends AbstractHandler\n", "label": 1}
{"id": 3998, "input": "<s> package net . minecraft . src ; import java . io . PrintStream ; import java . lang . reflect . Field ; import java . util . * ; import java . util . logging . Logger ; public class EntityTrackerEntry { public Entity trackedEntity ; public int trackingDistanceThreshold ; public int field_9234_e ; public int encodedPosX ; public int encodedPosY ; public int encodedPosZ ; public int encodedRotationYaw ; public int encodedRotationPitch ; public int field_48617_i ; public double lastTrackedEntityMotionX ; public double lastTrackedEntityMotionY ; public double lastTrackedEntityMotionZ ; public int updateCounter ; private double lastTrackedEntityPosX ; private double lastTrackedEntityPosY ; private double lastTrackedEntityPosZ ; private boolean firstUpdateDone ; private boolean shouldSendMotionUpdates ; private int field_28165_t ; public boolean playerEntitiesUpdated ; public Set trackedPlayers ; public EntityTrackerEntry ( Entity par1Entity , int par2 , int par3 , boolean par4 ) { updateCounter = 0 ; firstUpdateDone = false ; field_28165_t = 0 ; playerEntitiesUpdated = false ; trackedPlayers = new HashSet ( ) ; trackedEntity = par1Entity ; trackingDistanceThreshold = par2 ; field_9234_e = par3 ; shouldSendMotionUpdates = par4 ; encodedPosX = MathHelper . floor_double ( par1Entity . posX * 32D ) ; encodedPosY = MathHelper . floor_double ( par1Entity . posY * 32D ) ; encodedPosZ = MathHelper . floor_double ( par1Entity . posZ * 32D ) ; encodedRotationYaw = MathHelper . floor_float ( ( par1Entity . rotationYaw * 256F ) / 360F ) ; encodedRotationPitch = MathHelper . floor_float ( ( par1Entity . rotationPitch * 256F ) / 360F ) ; field_48617_i = MathHelper . floor_float ( ( par1Entity . func_48314_aq ( ) * 256F ) / 360F ) ; } public boolean equals ( Object par1Obj ) { if ( par1Obj instanceof EntityTrackerEntry ) { return ( ( EntityTrackerEntry ) par1Obj ) . trackedEntity . entityId == trackedEntity . entityId ; } else { return false ; } } public int hashCode ( ) { return trackedEntity . entityId ; } public void updatePlayerList ( List par1List ) { playerEntitiesUpdated = false ; if ( ! firstUpdateDone || trackedEntity . getDistanceSq ( lastTrackedEntityPosX , lastTrackedEntityPosY , lastTrackedEntityPosZ ) > 16D ) { lastTrackedEntityPosX = trackedEntity . posX ; lastTrackedEntityPosY = trackedEntity . posY ; lastTrackedEntityPosZ = trackedEntity . posZ ; firstUpdateDone = true ; playerEntitiesUpdated = true ; updatePlayerEntities ( par1List ) ; } field_28165_t ++ ; if ( updateCounter ++ % field_9234_e == 0 || trackedEntity . isAirBorne ) { if ( trackedEntity instanceof IClientDriven && ( ( ThxEntity ) trackedEntity ) . isActive ) { Packet packet = ( ( IClientDriven ) trackedEntity ) . getUpdatePacket ( ) ; for ( Object player : trackedPlayers ) { if ( player . equals ( trackedEntity . riddenByEntity ) ) continue ; ( ( EntityPlayerMP ) player ) . playerNetServerHandler . sendPacket ( packet ) ; } encodedPosX = MathHelper . floor_double ( trackedEntity . posX * 32D ) ; encodedPosY = MathHelper . floor_double ( trackedEntity . posY * 32D ) ; encodedPosZ = MathHelper . floor_double ( trackedEntity . posZ * 32D ) ; encodedRotationYaw = MathHelper . floor_float ( ( trackedEntity . rotationYaw * 256F ) / 360F ) ; encodedRotationPitch = MathHelper . floor_float ( ( trackedEntity . rotationPitch * 256F ) / 360F ) ; return ; } int i = MathHelper . floor_double ( trackedEntity . posX * 32D ) ; int j = MathHelper . floor_double ( trackedEntity . posY * 32D ) ; int k = MathHelper . floor_double ( trackedEntity . posZ * 32D ) ; int l = MathHelper . floor_float ( ( trackedEntity . rotationYaw * 256F ) / 360F ) ; int i1 = MathHelper . floor_float ( ( trackedEntity . rotationPitch * 256F ) / 360F ) ; int j1 = i - encodedPosX ; int k1 = j - encodedPosY ; int l1 = k - encodedPosZ ; Object obj = null ; boolean flag = Math . abs ( j1 ) >= 4 || Math . abs ( k1 ) >= 4 || Math . abs ( l1 ) >= 4 ; boolean flag1 = Math . abs ( l - encodedRotationYaw ) >= 4 || Math . abs ( i1 - encodedRotationPitch ) >= 4 ; if ( j1 < - 128 || j1 >= 128 || k1 < - 128 || k1 >= 128 || l1 < - 128 || l1 >= 128 || field_28165_t > 400 ) { field_28165_t = 0 ; trackedEntity . posX = ( double ) i / 32D ; trackedEntity . posY = ( double ) j / 32D ; trackedEntity . posZ = ( double ) k / 32D ; obj = new Packet34EntityTeleport ( trackedEntity . entityId , i , j , k , ( byte ) l , ( byte ) i1 ) ; } else if ( flag && flag1 ) { obj = new Packet33RelEntityMoveLook ( trackedEntity . entityId , ( byte ) j1 , ( byte ) k1 , ( byte ) l1 , ( byte ) l , ( byte ) i1 ) ; } else if ( flag ) { obj = new Packet31RelEntityMove ( trackedEntity . entityId , ( byte ) j1 , ( byte ) k1 , ( byte ) l1 ) ; } else if ( flag1 ) { obj = new Packet32EntityLook ( trackedEntity . entityId , ( byte ) l , ( byte ) i1 ) ; } if ( shouldSendMotionUpdates ) { double d = trackedEntity . motionX - lastTrackedEntityMotionX ; double d1 = trackedEntity . motionY - lastTrackedEntityMotionY ; double d2 = trackedEntity . motionZ - lastTrackedEntityMotionZ ; double d3 = 0.02D ; double d4 = d * d + d1 * d1 + d2 * d2 ; if ( d4 > d3 * d3 || d4 > 0.0D && trackedEntity . motionX == 0.0D && trackedEntity . motionY == 0.0D && trackedEntity . motionZ == 0.0D ) { lastTrackedEntityMotionX = trackedEntity . motionX ; lastTrackedEntityMotionY = trackedEntity . motionY ; lastTrackedEntityMotionZ = trackedEntity . motionZ ; sendPacketToTrackedPlayers ( new Packet28EntityVelocity ( trackedEntity . entityId , lastTrackedEntityMotionX , lastTrackedEntityMotionY , lastTrackedEntityMotionZ ) ) ; } } if ( obj != null ) { sendPacketToTrackedPlayers ( ( Packet ) obj ) ; } DataWatcher datawatcher = trackedEntity . getDataWatcher ( ) ; if ( datawatcher . hasObjectChanged ( ) ) { sendPacketToTrackedPlayersAndTrackedEntity ( new Packet40EntityMetadata ( trackedEntity . entityId , datawatcher ) ) ; } int i2 = MathHelper . floor_float ( ( trackedEntity . func_48314_aq ( ) * 256F ) / 360F ) ; if ( Math . abs ( i2 - field_48617_i ) >= 4 ) { sendPacketToTrackedPlayers ( new Packet35EntityHeadRotation ( trackedEntity . entityId , ( byte ) i2 ) ) ; field_48617_i = i2 ; } if ( flag ) { encodedPosX = i ; encodedPosY = j ; encodedPosZ = k ; } if ( flag1 ) { encodedRotationYaw = l ; encodedRotationPitch = i1 ; } } trackedEntity . isAirBorne = false ; if", "gt": "( trackedEntity . velocityChanged )", "prediction": "( ! shouldSendMotionUpdates )\n", "label": 0}
{"id": 14337, "input": "<s> package org . nuxeo . ecm . automation . core . test ; import static org . junit . Assert . assertNotNull ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . scripting . Scripting ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . event . EventService ; import org . nuxeo . ecm . core . test . CoreFeature ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import com . google . inject . Inject ; @ RunWith ( FeaturesRunner . class ) @ Features ( CoreFeature . class ) @ Deploy ( \"org.nuxeo.ecm.automation.core\" ) public class ScriptingTest { protected DocumentModel src ; @ Inject AutomationService service ; @ Inject CoreSession session ; OperationContext ctx ; @ Before public void initRepo ( ) throws Exception { src = session . createDocumentModel ( \"/\" , \"src\" , \"Folder\" ) ; src . setPropertyValue ( \"dc:title\" , \"Source\" ) ; src = session . createDocument ( src ) ; session . save ( ) ; src = session . getDocument ( src . getRef ( ) ) ; ctx =", "gt": "new OperationContext ( session ) ;", "prediction": "new OperationContext ( ) ;\n", "label": 1}
{"id": 9124, "input": "<s> package org . ofbiz . minilang . method . entityops ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . finder . ByConditionFinder ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class EntityCondition extends MethodOperation { public static final String module = EntityCondition . class . getName ( ) ; private final ByConditionFinder finder ; public EntityCondition ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"entity-name\" , \"use-cache\" , \"filter-by-date\" , \"list\" , \"distinct\" , \"delegator-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"entity-name\" , \"list\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"list\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"condition-expr\" , \"condition-list\" , \"condition-object\" , \"having-condition-list\" , \"select-field\" , \"order-by\" , \"limit-range\" , \"limit-view\" , \"use-iterator\" ) ; MiniLangValidate . requireAnyChildElement ( simpleMethod , element , \"condition-expr\" , \"condition-list\" , \"condition-object\" ) ; } this . finder = new ByConditionFinder ( element ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { try { Delegator delegator = methodContext . getDelegator ( ) ; this . finder . runFind ( methodContext . getEnvMap ( ) , delegator ) ; } catch ( GeneralException e ) { String errMsg = \"Exception thrown while performing entity find: \" + e . getMessage ( ) ; Debug . logWarning ( e , errMsg , module ) ; simpleMethod . addErrorMessage ( methodContext , errMsg ) ; return false ; } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { aic . addEntityName ( this . finder . getEntityName ( ) ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<entity-condition \" ) ; sb . append ( \"entity-name=\\\"\" ) . append ( this . finder . getEntityName ( ) )", "gt": ". append ( \"\\\" />\" ) ;", "prediction": ";\n", "label": 0}
{"id": 14338, "input": "<s> package com . xjtu . dao ; import com . xjtu . domain . User ; import org . junit . Test ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . AbstractTransactionalJUnit4SpringContextTests ; import org . springframework . test . context . transaction . TransactionConfiguration ; import static org . junit . Assert . assertEquals ; @ ContextConfiguration ( locations = { \"classpath:applicationContext.xml\" } ) @ TransactionConfiguration ( defaultRollback = false ) public class UserDaoTest extends AbstractTransactionalJUnit4SpringContextTests { @ Autowired private UserDao userDao ; @ Test public void", "gt": "should_select_all_names ( ) throws Exception", "prediction": "setUp ( ) throws Exception\n", "label": 1}
{"id": 1046, "input": "<s> package com . sun . tools . javac . util ; import java . util . Collection ; import java . util . EnumMap ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . regex . Matcher ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . util . AbstractDiagnosticFormatter . SimpleConfiguration ; import com . sun . tools . javac . util . BasicDiagnosticFormatter . BasicConfiguration ; import static com . sun . tools . javac . api . DiagnosticFormatter . PositionKind . * ; import static com . sun . tools . javac . util . BasicDiagnosticFormatter . BasicConfiguration . * ; import static com . sun . tools . javac . util . LayoutCharacters . * ; public class BasicDiagnosticFormatter extends AbstractDiagnosticFormatter { public BasicDiagnosticFormatter ( Options options , JavacMessages msgs ) { super ( msgs , new BasicConfiguration ( options ) ) ; } public BasicDiagnosticFormatter ( JavacMessages msgs ) { super ( msgs , new BasicConfiguration ( ) ) ; } public String formatDiagnostic ( JCDiagnostic d , Locale l ) { if ( l == null ) l = messages . getCurrentLocale ( ) ; String format = selectFormat ( d ) ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < format . length ( ) ; i ++ ) { char c = format . charAt ( i ) ; boolean meta = false ; if ( c == '%' && i < format . length ( ) - 1 ) { meta = true ; c = format . charAt ( ++ i ) ; } buf . append ( meta ? formatMeta ( c , d , l ) : String . valueOf ( c ) ) ; } if ( depth == 0 ) return addSourceLineIfNeeded ( d , buf . toString ( ) ) ; else return buf . toString ( ) ; } public String formatMessage ( JCDiagnostic d , Locale l ) { int currentIndentation = 0 ; StringBuilder buf = new StringBuilder ( ) ; Collection < String > args = formatArguments ( d , l ) ; String msg = localize ( l , d . getCode ( ) , args . toArray ( ) ) ; String [ ] lines = msg . split ( \"\\n\" ) ; if ( getConfiguration ( ) . getVisible ( ) . contains ( DiagnosticPart . SUMMARY ) ) { currentIndentation += getConfiguration ( ) .", "gt": "getIndentation ( DiagnosticPart . SUMMARY ) ;", "prediction": "getVisible ( ) . size ( ) ;\n", "label": 0}
{"id": 14339, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . sense . information . EightByteInformation ; import org . jscsi . target . util . BitManip ; public final class InformationSenseDataDescriptor extends SenseDataDescriptor { private static final int VALID_FLAG_BYTE_INDEX = 2 ; private static final int INFORMATION_INDEX = 4 ; private final boolean valid = true ; private final EightByteInformation information ; public InformationSenseDataDescriptor ( final EightByteInformation information ) { super ( SenseDataDescriptorType . INFORMATION , 0x0a ) ; this . information = information ; } @ Override protected final void serializeSpecificFields ( final", "gt": "ByteBuffer byteBuffer , final int index )", "prediction": "ByteBuffer byteBuffer , final int index )\n", "label": 1}
{"id": 10053, "input": "<s> import junit . framework . Assert ; import junit . framework . TestCase ; import org . junit . Test ; public class MovieTest { @ Test public void testTwoMoviesAreSame ( ) { Movie movie1 = new Movie ( \"Harry Potter\" , \"Mike Newell\" , 9 ) ; Movie movie2 = new Movie ( \"Harry Potter\" , \"Mike Newell\" , 9 ) ; Assert . assertTrue ( movie1 . equals ( movie2 ) ) ; } @ Test public void shouldReturnCorrectMovieDetails ( ) { Movie movie = new Movie ( \"Tangled\" , \"Byron Howard\" , 9 ) ; String expectedOutput = \"Tangled Byron Howard 9\" ; Assert . assertTrue ( expectedOutput . equals ( movie . toString ( ) ) ) ; } @ Test public void shouldNotEquateWithNull ( ) { Movie movie = new Movie ( \"Tangled\" , \"Byron Howard\" , 9 ) ; Assert . assertFalse ( movie . equals ( null ) ) ; } @ Test public void shouldEquateWithItSelf ( ) { Movie movie = new Movie ( \"Tangled\" , \"Byron Howard\" , 9 ) ; Assert . assertTrue ( movie . equals ( movie ) ) ; } @ Test public void shouldNotEquateTwoDifferentMovies ( ) { Movie movie1 = new", "gt": "Movie ( \"Tangled\" , \"Byron Howard\" , 9 ) ;", "prediction": "Movie ( \"Harry Potter\" , \"Mike Newell\" , 9 ) ;\n", "label": 0}
{"id": 14340, "input": "<s> package org . fuzzydb . core ; import java . net . InetSocketAddress ; public interface SettingsMBean { public boolean isWindows ( ) ; public String getPrimaryServer ( ) ; public int getPrimaryServerPort ( ) ; public String getSecondaryServer ( ) ; public int getSecondaryServerPort ( ) ; public boolean getCompressLogs ( ) ; public boolean getXmlLogs ( ) ; public String getDbRoot ( ) ; public String getPostcodeRoot ( ) ; public String getIpLookupRoot ( ) ; public int getListenPort ( ) ; public String getLogDir ( ) ; public String getReposDir ( ) ; public String getTxDir ( ) ; public int getLeafCriticalMass ( ) ; public int getDefaultTargetNumResults ( ) ; public float getDefaultScoreThreshold ( ) ; public int getQueryInactivityTimeoutSecs ( ) ; public int getQueryTimeToLiveSecs ( ) ; public int getSearchInactivityTimeoutSecs ( ) ; public int getSearchTimeToLiveSecs ( ) ; public int getTransactionInactivityTimeoutSecs ( ) ;", "gt": "public int getTransactionTimeToLiveSecs ( ) ;", "prediction": "public int getTransactionTimeToLiveSecs ( ) ;\n", "label": 1}
{"id": 2732, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import static javax . tools . JavaFileObject . Kind . CLASS ; import static javax . tools . JavaFileObject . Kind . HTML ; import static javax . tools . JavaFileObject . Kind . OTHER ; import static javax . tools . JavaFileObject . Kind . SOURCE ; import javax . lang . model . element . Modifier ; import javax . lang . model . element . NestingKind ; import javax . tools . ForwardingFileObject ; import javax . tools . JavaFileObject ; public class CeylonFileObject extends ForwardingFileObject < JavaFileObject > implements JavaFileObject { private final JavaFileObject f ; public int errors = 0 ; public CeylonFileObject ( JavaFileObject f ) { super ( f ) ; this . f = f ; } public JavaFileObject getFile ( ) { return f ; } public JavaFileObject . Kind getKind ( ) { String n = f . getName ( ) ; if ( n . endsWith ( CLASS . extension ) ) return CLASS ; else if ( n . endsWith ( SOURCE . extension ) || n . endsWith ( \".ceylon\" ) ) return SOURCE ; else if ( n", "gt": ". endsWith ( HTML . extension ) ) return HTML ;", "prediction": ". endsWith ( MODIFIER . extension ) ) return MODIFIER ;\n", "label": 0}
{"id": 14341, "input": "<s> package jssp . algorithm . tabusearch ; import ailibrary . algorithm . tabusearch . * ; public class JsspLongTermMemory implements LongTermMemory { public JsspLongTermMemory ( ) { } public void clearMemory ( ) { }", "gt": "public void memorizeSolution ( Solution soln , boolean newBestSoln )", "prediction": "}\n", "label": 1}
{"id": 7908, "input": "<s> import java . util . ArrayList ; public class T6294589 { private void testme ( boolean check ) { ArrayList < Integer > aList = new ArrayList < Integer > ( ) ; for ( @ SuppressWarnings ( \"unchecked\" ) Integer i : aList ) { System . out . println ( \"checking\" ) ; } for (", "gt": "@ SuppressWarnings ( \"unusedLocal\" ) Integer i : aList )", "prediction": "int i = 0 ;\n", "label": 0}
{"id": 14343, "input": "<s> package org . tinyradius . dictionary ; import java . io . IOException ; import java . io . InputStream ; public class DefaultDictionary extends MemoryDictionary { public static Dictionary getDefaultDictionary ( ) { return instance ; } private DefaultDictionary ( ) { } private static final String DICTIONARY_RESOURCE = \"org/tinyradius/dictionary/default_dictionary\" ; private static DefaultDictionary instance = null ; static { try { instance = new DefaultDictionary ( ) ; InputStream source = DefaultDictionary . class . getClassLoader ( ) . getResourceAsStream ( DICTIONARY_RESOURCE ) ; DictionaryParser . parseDictionary", "gt": "( source , instance ) ;", "prediction": "( source ) ;\n", "label": 1}
{"id": 6227, "input": "<s> enum E { A , B , C } @ interface Anno { E value ( ) ; } @", "gt": "Anno ( E . valueOf ( \"A\" ) ) class EnumAnnoValueMustBeEnumConstant", "prediction": "interface Annotation\n", "label": 0}
{"id": 14346, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage . transmogrify ; import java . util . Vector ; public class MethodSignature implements ISignature { private IClass [ ] _argTypes = null ; public MethodSignature ( IClass [ ] argTypes ) { _argTypes = argTypes ; } public MethodSignature ( Vector argTypes ) { _argTypes = new IClass [ argTypes . size ( ) ] ; argTypes . toArray ( _argTypes ) ; } public IClass [ ] getParameters ( ) { return _argTypes ; } public boolean isCompatibleWith ( ISignature signature ) { boolean result = true ; IClass [ ] comparedArgTypes = signature . getParameters ( ) ; if ( _argTypes . length != comparedArgTypes . length ) { result = false ; } else { for ( int i = 0 ; i < _argTypes . length ; i ++ ) { if ( ( _argTypes [ i ] != null ) && ! _argTypes [ i ] . isCompatibleWith ( comparedArgTypes [ i ] ) ) { result = false ; break ; } } } return result ; } public boolean isSame ( ISignature signature ) { return equals ( signature ) ; } public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof MethodSignature ) { MethodSignature signature = ( MethodSignature ) o ; result = java . util . Arrays . equals ( getParameters ( ) , signature . getParameters ( ) ) ; } return result ; } public String toString ( ) { StringBuffer result = new StringBuffer ( \"(\" ) ; for ( int i = 0 ; i < _argTypes . length ; i ++ ) { result . append ( _argTypes [ i ] != null ? _argTypes [ i ] . getName ( ) : \"[null]\" ) ; if ( i < ( _argTypes . length - 1 ) ) { result .", "gt": "append ( \", \" ) ;", "prediction": "append ( \", \" ) ;\n", "label": 1}
{"id": 5051, "input": "<s> import java . util . List ; public class T6456971 { static < T > T [ ] makeArray ( T ... args ) { return args ; } public static < S > void test ( ) { S [ ]", "gt": "stringLists = makeArray ( null , null ) ;", "prediction": "array = new S [ args . length ] ;\n", "label": 0}
{"id": 14349, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers ; import java . lang . reflect . InvocationTargetException ; import java . util . logging . Logger ; import javax . ws . rs . WebApplicationException ; import org . restlet . ext . jaxrs . InstantiateException ; import org . restlet . ext . jaxrs . ObjectFactory ; import org . restlet . ext . jaxrs . internal . core . ThreadLocalizedContext ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalBeanSetterTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalConstrParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalFieldTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnClassException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingConstructorException ; import org . restlet . ext . jaxrs . internal . wrappers . provider . ExtensionBackwardMapping ; import org . restlet . ext . jaxrs . internal . wrappers . provider . JaxRsProviders ; public class SingletonRootResourceClass extends RootResourceClass { private final ResourceObject rootResObject ; SingletonRootResourceClass ( Object rootResourceObject , ThreadLocalizedContext tlContext , JaxRsProviders jaxRsProviders , ExtensionBackwardMapping extensionBackwardMapping , Logger logger ) throws IllegalArgumentException , MissingAnnotationException , IllegalPathOnClassException , MissingConstructorException , IllegalConstrParamTypeException , IllegalFieldTypeException , IllegalBeanSetterTypeException , IllegalPathParamTypeException , InvocationTargetException , InjectException { super ( rootResourceObject . getClass ( ) , tlContext , jaxRsProviders , extensionBackwardMapping , logger ) ; this . injectHelper . injectInto ( rootResourceObject , true ) ; this . rootResObject = new ResourceObject (", "gt": "rootResourceObject , this ) ;", "prediction": "rootResourceObject ) ;\n", "label": 1}
{"id": 3787, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . Details ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class", "gt": "DetailsImpl extends StatusStatusSheetAttributeImpl implements Details", "prediction": "JSLibrary\n", "label": 0}
{"id": 14350, "input": "<s> package org . restlet . engine . adapter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PushbackInputStream ; import java . security . cert . Certificate ; import java . util . List ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Response ; import org . restlet . Server ; import org . restlet . data . Digest ; import org . restlet . engine . ConnectorHelper ; import org . restlet . engine . header . ContentType ; import org . restlet . engine . header . DispositionReader ; import org . restlet . engine . header . EncodingReader ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . HeaderReader ; import org . restlet . engine . header . HeaderUtils ; import org . restlet . engine . header . LanguageReader ; import org . restlet . engine . header . RangeReader ; import org . restlet . engine . io . BioUtils ; import org . restlet . engine . util . Base64 ; import org . restlet . engine . util . StringUtils ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . Representation ; import org . restlet . service . ConnectorService ; public abstract class ServerCall extends Call { private volatile boolean hostParsed ; public ServerCall ( Server server ) { this ( server . getAddress ( ) , server . getPort ( ) ) ; } public ServerCall ( String serverAddress , int serverPort ) { setServerAddress ( serverAddress ) ; setServerPort ( serverPort ) ; this . hostParsed = false ; } public abstract boolean abort ( ) ; public void complete ( ) { } public List < Certificate > getCertificates ( ) { return null ; } public String getCipherSuite ( ) { return null ; } protected long getContentLength ( ) { return HeaderUtils . getContentLength ( getRequestHeaders ( ) ) ; } @ Override public String getHostDomain ( ) { if ( ! this . hostParsed ) { parseHost ( ) ; } return super . getHostDomain ( ) ; } @ Override public int getHostPort ( ) { if ( ! this . hostParsed ) { parseHost ( ) ; } return super . getHostPort ( ) ; } public Representation getRequestEntity ( ) { Representation result = null ; long contentLength = getContentLength ( ) ; boolean chunkedEncoding = HeaderUtils . isChunkedEncoding ( getRequestHeaders ( ) ) ; boolean connectionClosed = HeaderUtils . isConnectionClose ( getRequestHeaders ( ) ) ; if ( ( ( contentLength != Representation . UNKNOWN_SIZE ) && ( contentLength != 0 ) ) || chunkedEncoding || connectionClosed ) { InputStream requestStream = getRequestEntityStream ( contentLength ) ; if ( connectionClosed ) { PushbackInputStream pbi = new PushbackInputStream ( requestStream ) ; try { int next = pbi . read ( ) ; if ( next != - 1 ) { pbi . unread ( next ) ; requestStream = pbi ; } else { requestStream = null ; } } catch ( IOException e ) { getLogger ( ) . fine ( \"Unable to read request entity\" ) ; } } if ( requestStream != null ) { result = new InputRepresentation ( requestStream , null , contentLength ) ; } else { result = new EmptyRepresentation ( ) ; } result . setSize ( contentLength ) ; } else { result = new EmptyRepresentation ( ) ; } for ( Header header : getRequestHeaders ( ) ) { if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_ENCODING ) ) { new EncodingReader ( header . getValue ( ) ) . addValues ( result . getEncodings ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_LANGUAGE ) ) { new LanguageReader ( header . getValue ( ) ) . addValues ( result . getLanguages ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_TYPE ) ) { ContentType contentType = new ContentType ( header . getValue ( ) ) ; result . setMediaType ( contentType . getMediaType ( ) ) ; result . setCharacterSet ( contentType . getCharacterSet ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_RANGE ) ) { RangeReader . update ( header . getValue ( ) , result ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_MD5 ) ) { result . setDigest ( new Digest ( Digest . ALGORITHM_MD5 , Base64 . decode", "gt": "( header . getValue ( ) ) ) ) ;", "prediction": "( header . getValue ( ) ) ) ) ;\n", "label": 1}
{"id": 8115, "input": "<s> package api . bookmarks ; import java . util . List ; public class Response { private List < Torrents > bookmarks ; private List < Artist > artists ; public List < Artist > getArtists ( ) { return this . artists ; } public", "gt": "List < Torrents > getTorrents ( )", "prediction": "void setArtists ( List < Artist > artists )\n", "label": 0}
{"id": 14363, "input": "<s> package org . eclipse . ui . dialogs ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . ui . IFileEditorMapping ; public class FileEditorMappingContentProvider implements IStructuredContentProvider { public final static FileEditorMappingContentProvider INSTANCE = new FileEditorMappingContentProvider ( ) ; private FileEditorMappingContentProvider ( ) { super ( ) ; } public void dispose ( ) { } public", "gt": "Object [ ] getElements ( Object element )", "prediction": "Viewer getViewer ( )\n", "label": 1}
{"id": 5722, "input": "<s> import p . SuperClass ; class ProtectedAccess_1 extends SuperClass { { SuperClass . i = 5 ; new SuperClass ( )", "gt": ". i = 5 ;", "prediction": ";\n", "label": 0}
{"id": 14369, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . text . MessageFormat ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . swt . widgets . Display ; public final class DisplayUtil { private DisplayUtil ( ) { } public static IDisplayLifeCycleAdapter getLCA ( Display display ) { Class < ILifeCycleAdapter > clazz = ILifeCycleAdapter . class ; IDisplayLifeCycleAdapter result = ( IDisplayLifeCycleAdapter ) display . getAdapter ( clazz ) ; if ( result == null ) { throwAdapterException ( clazz ) ; } return result ; } public static String getId ( Display display ) { return getAdapter ( display ) . getId ( ) ; } public static IWidgetAdapter getAdapter ( Display display ) { IWidgetAdapter result = display . getAdapter ( IWidgetAdapter . class ) ; if ( result == null ) { throwAdapterException ( IWidgetAdapter . class ) ; } return result ; } private static void", "gt": "throwAdapterException ( Class clazz )", "prediction": "setAdapter ( Display display )\n", "label": 1}
{"id": 359, "input": "<s> package hudson . plugins . dimensionsscm ; import hudson . plugins . dimensionsscm . DimensionsChangeSet ; import hudson . plugins . dimensionsscm . DimensionsChangeSetList ; import hudson . plugins . dimensionsscm . DateUtils ; import hudson . plugins . dimensionsscm . Logger ; import hudson . Util ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . Writer ; import java . util . List ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; import org . apache . commons . io . IOUtils ; import org . apache . commons . lang . StringEscapeUtils ; public class DimensionsChangeLogWriter { public boolean writeLog ( List < DimensionsChangeSet > changeSets , File changelogFile ) throws IOException { boolean bRet = false ; boolean appendFile = false ; FileWriter logFile = null ; if ( changelogFile . exists ( ) ) { if ( changelogFile . length ( ) > 0 ) { appendFile = true ; } } try { logFile = new FileWriter ( changelogFile , appendFile ) ; write ( changeSets , logFile , appendFile ) ; logFile . flush ( ) ; bRet = true ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new IOException ( \"Unable to write change log - \" + e . getMessage ( ) ) ; } finally { logFile . close ( ) ; } return bRet ; } private void write ( List < DimensionsChangeSet > changeSets , Writer logFile , boolean appendFile ) { Logger . Debug ( \"Writing logfile in append mode = \" + appendFile ) ; String logStr = \"\" ; PrintWriter writer = new PrintWriter ( logFile ) ; if ( ! appendFile ) { writer . println ( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" ) ; writer . println ( \"<changelog>\" ) ; } if ( changeSets != null ) { for ( DimensionsChangeSet changeSet : changeSets ) { logStr += String . format ( \"\\t<changeset version=\\\"%s\\\">\\n\" , escapeXML ( changeSet . getVersion ( ) ) ) ; logStr += String . format ( \"\\t\\t<date>%s</date>\\n\" , Util . XS_DATETIME_FORMATTER . format ( changeSet . getDate ( ) ) ) ; logStr += String . format ( \"\\t\\t<user>%s</user>\\n\" , escapeXML ( changeSet . getDeveloper ( ) ) ) ; logStr += String . format ( \"\\t\\t<comment>%s</comment>\\n\" , escapeXML ( changeSet . getSCMComment ( ) ) ) ; logStr += \"\\t\\t<items>\\n\" ; for ( DimensionsChangeSet . DmFiles item : changeSet . getFiles ( ) ) { logStr += String . format ( \"\\t\\t\\t<item operation=\\\"%s\\\" url=\\\"%s\\\">%s</item>\\n\" , item . getOperation ( ) , escapeHTML ( item . getUrl ( ) ) , escapeXML ( item . getFile ( ) ) ) ; } logStr += \"\\t\\t</items>\\n\" ; logStr += \"\\t\\t<requests>\\n\" ; for ( DimensionsChangeSet . DmRequests req : changeSet . getRequests ( ) ) { logStr += String . format ( \"\\t\\t\\t<request url=\\\"%s\\\" title=\\\"%s\\\">%s</request>\\n\" , escapeHTML ( req . getUrl ( ) ) , escapeXML ( req . getTitle ( ) ) , escapeXML ( req . getIdentifier ( ) ) ) ; } logStr += \"\\t\\t</requests>\\n\" ; logStr += \"\\t</changeset>\\n\" ; } } Logger . Debug ( \"Writing to logfile '\" + logStr + \"'\" ) ; if ( appendFile ) { writer . append ( logStr ) ; } else { writer . print ( logStr ) ; } return ; } private static String escapeXML ( String inTxt ) { if ( inTxt == null || inTxt . length ( ) == 0 ) return inTxt ; final StringBuilder outTxt = new StringBuilder ( ) ; final StringCharacterIterator iterator = new StringCharacterIterator ( inTxt ) ; char character = iterator . current ( ) ; while ( character != CharacterIterator . DONE ) { if ( character == '<' ) { outTxt . append ( \"&lt;\" ) ; } else if ( character == '>' ) { outTxt . append ( \"&gt;\" ) ; } else if ( character == '\\\"' ) { outTxt . append ( \"&quot;\" ) ; } else if ( character == '\\'' ) { outTxt . append ( \"&#039;\" ) ; } else if ( character == '&' ) { outTxt . append ( \"&amp;\" ) ; } else { outTxt . append ( character ) ; } character = iterator . next ( ) ; } return outTxt . toString ( ) ; } private static String escapeHTML ( String inTxt ) { if ( inTxt == null || inTxt . length ( ) == 0 ) return inTxt ; final", "gt": "StringBuilder outTxt = new StringBuilder ( ) ;", "prediction": "StringBuilder outTxt = new StringBuilder ( ) ;\n", "label": 0}
{"id": 14375, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . action . IAction ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PerspectiveAdapter ; public class PerspectiveTracker extends PerspectiveAdapter implements IPageListener { private IWorkbenchWindow window ; private IAction action ; protected PerspectiveTracker ( IWorkbenchWindow window ) { Assert . isNotNull ( window ) ; this . window = window ; window . addPageListener ( this ) ; window . addPerspectiveListener ( this ) ; } public PerspectiveTracker ( IWorkbenchWindow window , IAction action ) { this ( window ) ; this . action = action ; update ( ) ; } public void dispose ( ) { if ( window != null ) { window . removePageListener ( this ) ; window . removePerspectiveListener ( this ) ; } } public void pageActivated ( IWorkbenchPage page ) { update ( ) ; } public void pageClosed ( IWorkbenchPage page ) { update ( ) ; } public void pageOpened ( IWorkbenchPage page ) { } public void perspectiveActivated ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { update ( ) ; } private void update ( ) { if ( window != null ) { IPerspectiveDescriptor persp = null ; IWorkbenchPage page = window . getActivePage ( ) ; if ( page != null ) { persp = page . getPerspective ( ) ; }", "gt": "update ( persp ) ;", "prediction": "if ( persp != null )\n", "label": 1}
{"id": 7013, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . MinStart ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class MinStartImpl extends TaskAttributeImpl implements MinStart { protected static final String MIN_START_EDEFAULT = null ; protected String minStart = MIN_START_EDEFAULT ; protected MinStartImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getMinStart ( ) ; } public String getMinStart ( ) { return minStart ; } public void setMinStart ( String newMinStart ) { String oldMinStart = minStart ; minStart = newMinStart ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . MIN_START__MIN_START , oldMinStart , minStart ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . MIN_START__MIN_START : return getMinStart ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . MIN_START__MIN_START : setMinStart ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . MIN_START__MIN_START : setMinStart ( MIN_START_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public", "gt": "boolean eIsSet ( int featureID )", "prediction": "void eUnset ( int featureID )\n", "label": 0}
{"id": 14383, "input": "<s> package io . beancounter . usermanager . services . auth ; import com . google . inject . Inject ; import io . beancounter . commons . model . Service ; import io . beancounter . commons . model . auth . AuthHandler ; import io . beancounter . commons . model . auth . AuthHandlerException ; import io . beancounter . commons . model . User ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Map ; import java . util . Properties ; public final class DefaultServiceAuthorizationManager extends AbstractServiceAuthorizationManager { private static final String SERVICE = \"service\" ; @ Inject public DefaultServiceAuthorizationManager ( Map < Service , AuthHandler > authHandlers ) { for ( Map . Entry < Service , AuthHandler > authHandler : authHandlers . entrySet ( ) ) { handlers . put ( authHandler . getKey ( ) , authHandler . getValue ( ) ) ; } } public static Service buildService ( String service , Properties properties ) { Service serviceObj = new Service ( service ) ; serviceObj . setDescription ( property ( properties , service , \"description\" ) ) ; try { serviceObj . setEndpoint ( new URL ( property ( properties , service , \"endpoint\" ) ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] endpoint is not a valid URL\" , e ) ; } String sessionStr = property ( properties , true , service , \"session\" ) ; if ( sessionStr != null ) { try { serviceObj . setSessionEndpoint ( new URL ( sessionStr ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] session endpoint is not a valid URL\" , e ) ; } } serviceObj . setApikey ( property ( properties , service , \"apikey\" ) ) ; serviceObj . setSecret ( property ( properties , service , \"secret\" ) ) ; try { serviceObj . setOAuthCallback ( new URL ( property ( properties , service , \"oauthcallback\" ) ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] oauth callback endpoint is not a valid URL\" , e ) ; } try { serviceObj . setAtomicOAuthCallback ( new URL ( property ( properties , service , \"atomicoauth\" ) ) ) ; }", "gt": "catch ( MalformedURLException e )", "prediction": "catch ( MalformedURLException e )\n", "label": 1}
{"id": 7047, "input": "<s> package com . mobeelizer . mobile . android ; import java . io . File ; import java . io . IOException ; import android . content . Context ; import android . content . Intent ; import android . util . Log ; import com . mobeelizer . java . api . MobeelizerOperationError ; import com . mobeelizer . java . errors . MobeelizerOperationErrorImpl ; import com . mobeelizer . java . errors . MobeelizerOperationStatus ; import com . mobeelizer . mobile . android . api . MobeelizerSyncStatus ; class MobeelizerSyncServicePerformer { private static final String TAG = \"mobeelizer:syncserviceperformer\" ; private final MobeelizerDataFileService dataFileService ; private final boolean isAllSynchronization ; private final MobeelizerApplication application ; public MobeelizerSyncServicePerformer ( final MobeelizerApplication application , final boolean isAllSynchronization ) { this . application = application ; this . isAllSynchronization = isAllSynchronization ; this . dataFileService = new MobeelizerDataFileService ( application ) ; } public MobeelizerOperationError sync ( ) { if ( application . checkSyncStatus ( ) != MobeelizerSyncStatus . STARTED ) { Log . w ( TAG , \"Send is already running - skipping.\" ) ; return null ; } MobeelizerDatabaseImpl database = application . getDatabase ( ) ; MobeelizerConnectionManager connectionManager = application . getConnectionManager ( ) ; File outputFile = null ; File inputFile = null ; boolean success = false ; try { database . lockModifiedFlag ( ) ; String ticket = null ; if ( isAllSynchronization ) { Log . i ( TAG , \"Send sync all request.\" ) ; MobeelizerOperationStatus < String > sendSyncStatus = connectionManager . sendSyncAllRequest ( ) ; if ( sendSyncStatus . getError ( ) == null ) { ticket = sendSyncStatus . getContent ( ) ; } else { return sendSyncStatus . getError ( ) ; } } else { outputFile = File . createTempFile ( \"sync\" , \"sync\" , application . getContext ( ) . getDir ( \"sync\" , Context . MODE_PRIVATE ) ) ; if ( ! dataFileService . prepareOutputFile ( outputFile ) ) { Log . i ( TAG , \"Send file haven't been created.\" ) ; return MobeelizerOperationErrorImpl . sendFileCreationError ( ) ; } changeStatus ( MobeelizerSyncStatus . FILE_CREATED ) ; Log . i ( TAG , \"Send sync request.\" ) ; MobeelizerOperationStatus < String > sendSyncStatus = connectionManager . sendSyncDiffRequest ( outputFile ) ; if ( sendSyncStatus . getError ( ) == null ) { ticket = sendSyncStatus . getContent ( ) ; } else { return sendSyncStatus . getError ( ) ; } } Log . i ( TAG , \"Sync request completed: \" + ticket + \".\" ) ; changeStatus ( MobeelizerSyncStatus . TASK_CREATED ) ; MobeelizerOperationError waitRequestError = connectionManager . waitUntilSyncRequestComplete ( ticket ) ; if ( waitRequestError != null ) { return waitRequestError ; } Log . i", "gt": "( TAG , \"Sync process complete with success.\" ) ;", "prediction": "( TAG , \"Sync request failed: \" + ticket + \".\" ) ;\n", "label": 0}
{"id": 14389, "input": "<s> package org . fuzzydb . client . userobjects ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) public class BaseMutableString implements Serializable { public String value ; public BaseMutableString ( String s ) { value = s ; } @ Override public int hashCode ( ) { return value . hashCode ( ) ; } @ Override public boolean equals ( Object o ) { if ( o instanceof BaseMutableString ) { BaseMutableString rhs = ( BaseMutableString ) o ; return value . equals ( rhs . value ) ; } if", "gt": "( o instanceof String )", "prediction": "( o instanceof String )\n", "label": 1}
{"id": 5546, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; import com . sun . tools . doclets . internal . toolkit . Content ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class Comment extends Content { private String commentText ; public Comment ( String comment ) { commentText = nullCheck ( comment ) ; } public void addContent ( Content content ) { throw new DocletAbortException ( ) ; } public", "gt": "void addContent ( String stringContent )", "prediction": "String getCommentText ( )\n", "label": 0}
{"id": 14394, "input": "<s> package org . modelgoon . dao ; public class DAOException extends Exception { public DAOException ( final String message , final Throwable cause ) { super", "gt": "( message , cause ) ;", "prediction": "( message , cause ) ;\n", "label": 1}
{"id": 3981, "input": "<s> package de . javawi . jstun . test . demo ; import java . util . logging . FileHandler ; import java . util . logging . Handler ; import java . util . logging . Level ; import java . util . logging . SimpleFormatter ; import de . javawi . jstun . test . BindingLifetimeTest ; public class BindingLifetimeTestDemo { public static void main ( String args [ ] ) { try { Handler fh = new FileHandler ( \"logging.txt\" ) ; fh . setFormatter ( new SimpleFormatter ( ) ) ; java . util . logging . Logger . getLogger ( \"de.javawi.stun\" ) . addHandler ( fh ) ; java . util . logging . Logger . getLogger ( \"de.javawi.stun\" ) . setLevel ( Level . ALL ) ; BindingLifetimeTest test = new BindingLifetimeTest (", "gt": "\"jstun.javawi.de\" , 3478 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14396, "input": "<s> package org . eclipse . ui . internal . services ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . AbstractSourceProvider ; import org . eclipse . ui . ISources ; public final class MenuSourceProvider extends AbstractSourceProvider { private static final String [ ] PROVIDED_SOURCE_NAMES = new String [ ] { ISources . ACTIVE_MENU_NAME , ISources . ACTIVE_MENU_SELECTION_NAME , ISources . ACTIVE_MENU_EDITOR_INPUT_NAME } ; private Set menuIds = new HashSet ( ) ; public final void addShowingMenus ( final Set menuIds , final ISelection localSelection , final ISelection localEditorInput ) { this . menuIds . addAll ( menuIds ) ; if ( DEBUG ) { logDebuggingInfo ( \"Menu ids changed to \" + this . menuIds ) ; } Map m = new HashMap ( ) ; m . put ( ISources . ACTIVE_MENU_NAME , this . menuIds ) ; if ( selection != localSelection ) { selection = localSelection ; m . put ( ISources . ACTIVE_MENU_SELECTION_NAME , selection == null ? IEvaluationContext . UNDEFINED_VARIABLE : selection ) ; } if ( input != localEditorInput ) { input = localEditorInput ; m . put ( ISources . ACTIVE_MENU_EDITOR_INPUT_NAME , input == null ? IEvaluationContext . UNDEFINED_VARIABLE : input ) ; } fireSourceChanged ( ISources . ACTIVE_MENU , m ) ; } public final void dispose ( ) { menuIds . clear ( ) ; selection = null ; input = null ; } public final Map getCurrentState ( ) { final Map state = new HashMap ( ) ; state . put ( ISources . ACTIVE_MENU_NAME , menuIds ) ; state . put ( ISources . ACTIVE_MENU_SELECTION_NAME , selection == null ? IEvaluationContext", "gt": ". UNDEFINED_VARIABLE : selection ) ;", "prediction": ". UNDEFINED_VARIABLE : selection ) ;\n", "label": 1}
{"id": 9227, "input": "<s> package com . sun . tools . javac . util ; import java . lang . ref . WeakReference ; public class UnsharedNameTable extends Name . Table { static public Name . Table create ( Names names ) { return new UnsharedNameTable ( names ) ; } static class HashEntry extends WeakReference < NameImpl > { HashEntry next ; HashEntry ( NameImpl referent ) { super ( referent ) ; } } private HashEntry [ ] hashes = null ; private int hashMask ; public int index ; public UnsharedNameTable ( Names names , int hashSize ) { super ( names ) ; hashMask = hashSize - 1 ; hashes = new HashEntry [ hashSize ] ; } public UnsharedNameTable ( Names names ) { this ( names , 0x8000 ) ; } @ Override public Name fromChars ( char [ ] cs , int start , int len ) { byte [ ] name = new byte [ len * 3 ] ; int nbytes = Convert . chars2utf ( cs , start , name , 0 , len ) ; return fromUtf ( name , 0 , nbytes ) ; } @ Override public Name fromUtf ( byte [ ] cs , int start , int len ) { int h = hashValue ( cs , start , len ) & hashMask ; HashEntry element = hashes [ h ] ; NameImpl n = null ; HashEntry previousNonNullTableEntry = null ; HashEntry firstTableEntry = element ; while ( element != null ) { if ( element == null ) { break ; } n = element . get ( ) ; if ( n == null ) { if ( firstTableEntry == element ) { hashes [ h ] = firstTableEntry = element . next ; } else { Assert . checkNonNull ( previousNonNullTableEntry , \"previousNonNullTableEntry cannot be null here.\" ) ; previousNonNullTableEntry . next = element . next ; } } else { if ( n . getByteLength ( ) == len && equals ( n . bytes , 0 , cs , start , len ) ) { return n ; } previousNonNullTableEntry = element ; } element = element . next ; } byte [ ] bytes = new byte [ len ] ; System . arraycopy ( cs , start , bytes , 0 , len ) ; n = new NameImpl ( this , bytes , index ++ ) ; System . arraycopy ( cs , start , n . bytes , 0 , len ) ; HashEntry newEntry = new HashEntry ( n ) ; if ( previousNonNullTableEntry == null ) { hashes [ h ] = newEntry ; } else { Assert . checkNull ( previousNonNullTableEntry . next , \"previousNonNullTableEntry.next must be null.\" ) ; previousNonNullTableEntry . next = newEntry ; } return n ; } @ Override", "gt": "public void dispose ( )", "prediction": "public int hashCode ( )\n", "label": 0}
{"id": 14400, "input": "<s> package org . nuxeo . ecm . automation . core . operations . services ; import java . io . Serializable ; import java . util . Locale ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . nuxeo . common . utils . i18n . I18NUtils ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; import org . nuxeo . ecm . core . schema . SchemaManager ; import org . nuxeo . ecm . core . schema . types . Field ; import org . nuxeo . ecm . core . schema . types . QName ; import org . nuxeo . ecm . core . schema . types . Schema ; import org . nuxeo . ecm . directory . Directory ; import org . nuxeo . ecm . directory . Session ; import org . nuxeo . ecm . directory . api . DirectoryService ; @ Operation ( id = GetDirectoryEntries . ID , category = Constants . CAT_SERVICES , label = \"Get directory entries\" , description = \"Get the entries of a directory. This is returning a blob containing a serialized JSON array. The input document, if specified, is used as a context for a potential local configuration of the directory.\" ) public class GetDirectoryEntries { public static final String ID = \"Directory.Entries\" ; @ Context protected OperationContext ctx ; @ Context protected DirectoryService directoryService ; @ Context protected SchemaManager schemaManager ; @ Param ( name = \"directoryName\" , required = true ) protected String directoryName ; @ Param ( name = \"translateLabels\" , required = false ) protected boolean translateLabels ; @ Param ( name = \"lang\" , required = false ) protected String lang ; @ OperationMethod public Blob run ( DocumentModel doc ) throws Exception { Directory directory = directoryService . getDirectory ( directoryName , doc ) ; Session session = directory . getSession ( ) ; DocumentModelList", "gt": "entries = session . getEntries ( ) ;", "prediction": "list = session . getAll ( ) ;\n", "label": 1}
{"id": 7345, "input": "<s> package org . jboss ; import javax . ws . rs . core . Application ; import java . util . HashSet ; import java . util . Set ; public class CCLT_Application extends Application { private Set < Object > singletons = new HashSet < Object > ( ) ; private Set < Class < ? > > empty = new HashSet < Class < ? > > ( ) ; public CCLT_Application ( ) throws Exception { singletons . add ( new MessageResource ( ) ) ; } @ Override public Set < Class < ? > > getClasses ( ) { return empty ; } @ Override", "gt": "public Set < Object > getSingletons ( )", "prediction": "public Set < Class < ? > > getSingletons ( )\n", "label": 0}
{"id": 14401, "input": "<s> package org . eclipse . swt . internal . image ; import java . io . * ; public class PngHuffmanTable { CodeLengthInfo [ ] codeLengthInfo ; int [ ] codeValues ; static final int MAX_CODE_LENGTH = 15 ; static final int BAD_CODE = 0xFFFFFFF ; static final int incs [ ] = { 1391376 , 463792 , 198768 , 86961 , 33936 , 13776 , 4592 , 1968 , 861 , 336 , 112 , 48 , 21 , 7 , 3 , 1 } ; PngHuffmanTable ( int [ ] lengths ) { super ( ) ; initialize ( lengths ) ; generateTable ( lengths ) ; } private void initialize ( int [ ] lengths ) { codeValues = new int [ lengths . length ] ; for ( int i = 0 ; i < codeValues . length ; i ++ ) { codeValues [ i ] = i ; } codeLengthInfo = new CodeLengthInfo [ MAX_CODE_LENGTH ] ; for ( int i = 0 ; i < MAX_CODE_LENGTH ; i ++ ) { codeLengthInfo [ i ] = new CodeLengthInfo ( ) ; codeLengthInfo [ i ] . length = i ; codeLengthInfo [ i ] . baseIndex = 0 ; codeLengthInfo [ i ] . min = BAD_CODE ; codeLengthInfo [ i ] . max = - 1 ; } } private void generateTable ( int [ ] lengths ) { int codeValuesTemp ; for ( int k = 0 ; k < 16 ; k ++ ) { for ( int h = incs [ k ] , i = h ; i < lengths . length ; i ++ ) { int v = lengths [ i ] ; codeValuesTemp = codeValues [ i ] ; int j = i ; while ( j >= h && ( lengths [ j - h ] > v || ( lengths [ j - h ] == v && codeValues [ j - h ] > codeValuesTemp ) ) ) { lengths [ j ] = lengths [ j - h ] ; codeValues [ j ] = codeValues [ j - h ] ; j -= h ; } lengths [ j ] = v ; codeValues [ j ] = codeValuesTemp ; } } int [ ] codes = new int [ lengths . length ] ; int lastLength = 0 ; int code = 0 ; for ( int i = 0 ; i < lengths . length ; i ++ ) { while ( lastLength != lengths [ i ] ) { lastLength ++ ; code <<= 1 ; } if ( lastLength != 0 ) { codes [ i ] = code ; code ++ ; } } int last = 0 ; for ( int i = 0 ; i < lengths . length ; i ++ ) { if ( last != lengths [ i ] ) { last = lengths [ i ] ; codeLengthInfo [ last - 1 ] . baseIndex = i ; codeLengthInfo [ last - 1 ] . min = codes [ i ] ; } if ( last != 0 ) codeLengthInfo [ last - 1 ] .", "gt": "max = codes [ i ] ;", "prediction": "max = codes [ i ] ;\n", "label": 1}
{"id": 2452, "input": "<s> public class WhichImplicitThis9 { static int result ; public synchronized static void main ( String [ ] args ) { result = 0 ; new WhichImplicitThis9 ( 1 ) ; if ( result != 13658 ) throw new Error ( \"\" + result ) ; } WhichImplicitThis9 ( final int i ) { class L { L ( ) { result = result * 10 + 1 ; } L ( final int j ) { this ( new L ( ) { { result = result * 10 + 2 + i ; } } ) ; result =", "gt": "result * 10 + 4 + i ;", "prediction": "0 ;\n", "label": 0}
{"id": 14402, "input": "<s> package org . nuxeo . ecm . automation . core . impl ; import java . lang . reflect . Method ; import java . lang . reflect . Type ; import java . util . Iterator ; import java . util . Map ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . OperationType ; import org . nuxeo . ecm . automation . OutputCollector ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; public class InvokableIteratorMethod extends InvokableMethod { @ SuppressWarnings ( \"rawtypes\" ) protected Class < ? extends OutputCollector > collector ; public InvokableIteratorMethod ( OperationType op , Method method , OperationMethod anno ) { super ( op , method , anno ) ; collector = anno . collector ( ) ; if ( collector == OutputCollector . class ) { throw new IllegalArgumentException ( \"Not an iterable method\" ) ; } if ( consume == Void . TYPE ) { throw new IllegalArgumentException ( \"An iterable method must have an argument\" ) ; } Type [ ] ctypes = IterableInputHelper . findCollectorTypes ( collector ) ; if ( ! ( ( Class < ? > ) ctypes [ 0 ] ) . isAssignableFrom ( produce ) ) { throw new IllegalArgumentException ( \"The collector used on \" + method + \" doesn't match the method return type\" ) ; } try { produce = ( Class < ? > ) ctypes [ 1 ] ; } catch ( Exception e ) { throw new IllegalStateException ( \"Invalid output collector: \" + collector + \". No getOutput method found.\" ) ; } } @ Override public boolean isIterable ( ) { return true ; } @ Override public int inputMatch ( Class < ? > in ) { Class < ? > iterableIn = IterableInputHelper . getIterableType ( in ) ; if ( iterableIn != null ) { return super . inputMatch ( iterableIn ) ; } return 0 ; } @ SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) @ Override protected Object doInvoke ( OperationContext ctx , Map < String , Object > args , Object input ) throws Exception { if ( ! ( input instanceof Iterable ) ) { throw new IllegalStateException ( \"An iterable method was called in a non iterable context\" ) ; } OutputCollector list = collector . newInstance ( ) ; Iterable < ? > iterable = ( Iterable < ? > ) input ; Iterator < ? > it = iterable . iterator ( ) ; while ( it . hasNext ( ) ) { Object in = it . next ( ) ;", "gt": "ctx . setInput ( in ) ;", "prediction": "list . add ( in ) ;\n", "label": 1}
{"id": 9059, "input": "<s> package LizaCraft . Events ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Map ; import java . util . logging . Logger ; import org . bukkit . event . Event ; import org . bukkit . event . EventException ; import org . bukkit . event . EventHandler ; import org . bukkit . event . EventPriority ; import org . bukkit . event . Listener ; import org . bukkit . plugin . EventExecutor ; import org . bukkit . plugin . PluginManager ; import org . bukkit . plugin . java . JavaPlugin ; import Liza . LizaListener ; import LizaCraft . LizaCraftTestModule ; public class LizaPlugin extends JavaPlugin implements Listener { private static final Logger log = Logger . getLogger ( \"Minecraft\" ) ; public static final String PLUGIN_NAME = \"Liza Event Listener\" ; protected Map < Class < ? extends Event > , LizaCraftTestModule > waitingList = new HashMap < Class < ? extends Event > , LizaCraftTestModule > ( ) ; private Map < Class < ? extends Event > , LizaListener > listenerList = new HashMap < Class < ? extends Event > , LizaListener > ( ) ; @ Override public void onDisable ( ) { log . info ( \"LizaPlugin disabled\" ) ; } @ Override public void onEnable ( ) { log . info ( \"LizaPlugin enabled\" ) ; } public void registerEvent ( Class < ? extends Event > event ) throws IllegalArgumentException { PluginManager pm = this . getServer ( ) . getPluginManager ( ) ; EventExecutor exec = null ; Method [ ] methods = this . getClass ( ) . getDeclaredMethods ( ) ; for ( final Method method : methods ) { final EventHandler eh = method . getAnnotation ( EventHandler . class ) ; if ( eh == null ) continue ; if ( method . getParameterTypes ( ) [ 0 ] . equals ( Event . class ) ) { exec = new EventExecutor ( ) { public void execute ( Listener listener , Event event ) throws EventException { try { method . invoke ( listener , event ) ; } catch ( Throwable t ) { throw new EventException ( t ) ; } } } ; } } if ( exec == null ) { throw new IllegalArgumentException ( \"Failed to register event.\" ) ; } pm . registerEvent ( event , this , EventPriority . MONITOR , exec , this ) ; } public void registerEvent ( Class < ? extends Event > event , LizaListener listener ) { registerEvent ( event ) ; this . listenerList . put ( event , listener ) ; } @ EventHandler ( priority = EventPriority . MONITOR ) public void handleEvent ( Event e ) { releaseFromEvent ( e ) ; relayEvent ( e ) ; } public void waitForEvent ( Class < ? extends Event > event , LizaCraftTestModule testModule ) { this . waitingList . put ( event , testModule ) ; } public void releaseFromEvent ( Event event ) { LizaCraftTestModule waitee = this . waitingList", "gt": ". remove ( event . getClass ( ) ) ;", "prediction": ". get ( event ) ;\n", "label": 0}
{"id": 14407, "input": "<s> package org . powerbot . game . api . methods . widget ; import java . awt . Dimension ; import java . awt . Rectangle ; import java . util . ArrayList ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . Game ; import org . powerbot . game . api . methods . Widgets ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . util . Timer ; import org . powerbot . game . api . wrappers . widget . Widget ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; public class Lobby { public static final int STATE_LOBBY_IDLE = 7 ; public static final int STATE_LOGGING_IN = 9 ; public static final int LOGIN_DEFAULT_TIMEOUT = 30000 ; public static final int WIDGET_MAIN_LOBBY = 906 ; public static final int WIDGET_BUTTON_PLAY_GAME = 197 ; public static final int WIDGET_BUTTON_LOGOUT = 221 ; public static final int WIDGET_LABEL_CURRENT_WORLD = 11 ; public static final int WIDGET_WORLDS_TABLE = 62 ; public static final int WIDGET_WORLDS_TABLE_SCROLLBAR = 86 ; public static final int WIDGET_WORLDS_ROWS = 77 ; public static final int WIDGET_WORLDS_COLUMN_FAVOURITE = 68 ; public static final int WIDGET_WORLDS_COLUMN_WORLD_NUMBER = 69 ; public static final int WIDGET_WORLDS_COLUMN_MEMBERS = 70 ; public static final int WIDGET_WORLDS_COLUMN_PLAYERS = 71 ; public static final int WIDGET_WORLDS_COLUMN_ACTIVITY = 72 ; public static final int WIDGET_WORLDS_COLUMN_LOOT_SHARE = 75 ; public static final int WIDGET_WORLDS_COLUMN_PING = 76 ; public static enum Tab { PLAYER_INFO ( 230 , 907 ) , WORLD_SELECT ( 28 , 910 ) , FRIENDS ( 27 , 909 ) , FRIENDS_CHAT ( 280 , 589 ) , CLAN_CHAT ( 26 , 912 ) , OPTIONS ( 25 , 911 ) ; private final int widgetTabIndex ; private final int widgetPanelIndex ; private Tab ( final int widgetTabIndex , final int widgetPanelIndex ) { this . widgetTabIndex = widgetTabIndex ; this . widgetPanelIndex = widgetPanelIndex ; } public WidgetChild getWidget ( ) { if ( ! Lobby . isOpen ( ) ) { return null ; } return Widgets . get ( WIDGET_MAIN_LOBBY , widgetTabIndex ) ; } public Widget getPanelWidget ( ) { if ( ! Lobby . isOpen ( ) ) { return null ; } return Widgets . get ( widgetPanelIndex ) ; } public boolean isOpen ( ) { final WidgetChild child = getWidget ( ) ; return child != null && child . validate ( ) && child . getTextureId ( ) == 4671 ; } public boolean open ( ) { final WidgetChild child = getWidget ( ) ; if ( isOpen ( ) ) { return true ; } if ( child != null && child . validate ( ) && child . click ( true ) ) { Task . sleep ( Random . nextInt ( 1200 , 2000 ) ) ; return true ; } return false ; } } public static enum Dialog { TRANSFER_COUNTDOWN ( 255 , - 1 , 252 , \"^You have only just left another world.\" ) , ACCOUNT_IN_USE ( 260 , - 1 , 252 , \"^Your account has not logged out from its last session.\" ) , LOGIN_LIMIT_EXCEEDED ( 260 , - 1 , 252 , \"^Login limit exceeded: too many connections from your address.\" ) , MEMBERS_ONLY_WORLD ( 260 , - 1 , 252 , \"^You need a member's account to log in to this world.\" ) , INSUFFICIENT_SKILL_TOTAL ( 260 , - 1 , 252 , \"^You must have a total skill level of\" ) , WILDERNESS_WARNING ( 118 , 120 , 113 , \"^Warning: This is a High-risk Wilderness world.\" ) , VALIDATE_EMAIL ( 379 , 379 , 352 , \"^Validate your email now for increased account security\" ) ; private final int backButtonIndex ; private final int continueButtonIndex ; private final int textIndex ; private final Pattern textPattern ; private Dialog ( final int backButtonIndex , final int continueButtonIndex , final int textIndex , final String textPattern ) { this . backButtonIndex = backButtonIndex ; this . continueButtonIndex = continueButtonIndex ; this . textIndex = textIndex ; this . textPattern = Pattern . compile ( textPattern ) ; } public boolean isOpen ( ) { final WidgetChild child = Widgets . get ( WIDGET_MAIN_LOBBY , textIndex ) ; if ( child != null && child . isOnScreen ( ) ) { final String text = child . getText ( ) ; return text != null && textPattern . matcher", "gt": "( text ) . find ( ) ;", "prediction": "( text ) . matches ( ) ;\n", "label": 1}
{"id": 4006, "input": "<s> package org . ofbiz . service . eca ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public final class ServiceEcaRule implements java . io . Serializable { public static final String module = ServiceEcaRule . class . getName ( ) ; protected final String serviceName ; protected final String eventName ; protected final boolean runOnFailure ; protected final boolean runOnError ; protected final List < ServiceEcaCondition > conditions = FastList . newInstance ( ) ; protected final List < Object > actionsAndSets = FastList . newInstance ( ) ; protected boolean enabled = true ; protected final String definitionLocation ; public ServiceEcaRule ( Element eca , String definitionLocation ) { this . definitionLocation = definitionLocation ; this . serviceName = eca . getAttribute ( \"service\" ) ; this . eventName = eca . getAttribute ( \"event\" ) ; this . runOnFailure = \"true\" . equals ( eca . getAttribute ( \"run-on-failure\" ) ) ; this . runOnError = \"true\" . equals ( eca . getAttribute ( \"run-on-error\" ) ) ; for ( Element element : UtilXml . childElementList ( eca , \"condition\" ) ) { conditions . add ( new ServiceEcaCondition ( element , true , false ) ) ; } for ( Element element : UtilXml . childElementList ( eca , \"condition-field\" ) ) { conditions . add ( new ServiceEcaCondition ( element , false , false ) ) ; } for ( Element element : UtilXml . childElementList ( eca , \"condition-service\" ) ) { conditions . add ( new ServiceEcaCondition ( element , false , true ) ) ; } if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"Conditions: \" + conditions , module ) ; } Set < String > nameSet = UtilMisc . toSet ( \"set\" , \"action\" ) ; for ( Element actionOrSetElement : UtilXml . childElementList ( eca , nameSet ) ) { if ( \"action\" . equals ( actionOrSetElement . getNodeName ( ) ) ) { this . actionsAndSets . add ( new ServiceEcaAction ( actionOrSetElement , this . eventName ) ) ; } else { this . actionsAndSets . add ( new ServiceEcaSetField ( actionOrSetElement ) ) ; } } if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"actions and sets (intermixed): \" + actionsAndSets , module ) ; } } public String getShortDisplayName ( ) { return this . serviceName + \":\" + this . eventName ; } public String getServiceName ( ) { return this . serviceName ; } public String getEventName ( ) { return this . eventName ; } public String getDefinitionLocation ( ) { return this . definitionLocation ; } public List < ServiceEcaAction > getEcaActionList ( ) { List < ServiceEcaAction > actionList = FastList . newInstance ( ) ; for ( Object actionOrSet : this . actionsAndSets ) { if ( actionOrSet instanceof ServiceEcaAction ) { actionList . add ( ( ServiceEcaAction ) actionOrSet ) ; } } return actionList ; } public List < ServiceEcaCondition > getEcaConditionList ( ) { List < ServiceEcaCondition > condList = FastList . newInstance ( ) ; condList . addAll ( this . conditions ) ; return condList ; } public void eval ( String serviceName , DispatchContext dctx , Map < String , Object > context , Map < String , Object > result , boolean isError , boolean isFailure , Set < String > actionsRun ) throws GenericServiceException { if ( ! enabled ) { Debug . logInfo ( \"Service ECA [\" + this . serviceName + \"] on [\" + this . eventName + \"] is disabled; not running.\" , module ) ; return ; } if ( isFailure && ! this . runOnFailure ) { return ; } if ( isError && ! this . runOnError ) { return ; } boolean allCondTrue = true ; for ( ServiceEcaCondition ec : conditions ) { if ( ! ec . eval ( serviceName , dctx , context ) ) { if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"For Service ECA [\" + this . serviceName + \"] on [\" + this . eventName + \"] got false for condition: \" + ec , module ) ; } allCondTrue = false ; break ; } else { if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"For Service ECA [\" + this . serviceName + \"] on [\" + this . eventName + \"] got true for condition: \" + ec , module ) ; } } } if ( allCondTrue ) { for ( Object setOrAction : actionsAndSets ) { if ( setOrAction instanceof ServiceEcaAction ) { ServiceEcaAction ea = ( ServiceEcaAction ) setOrAction ; if ( ! actionsRun . contains ( ea . serviceName ) ) { if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"Running Service ECA Service: \" + ea . serviceName + \", triggered by rule on Service: \" + serviceName , module ) ; } if ( ea . runAction ( serviceName , dctx , context , result ) ) { actionsRun . add ( ea . serviceName ) ; } } } else { ServiceEcaSetField sf = ( ServiceEcaSetField ) setOrAction ; sf . eval ( context ) ; } } } } public void setEnabled ( boolean enabled ) { this . enabled = enabled ; } public boolean isEnabled ( ) { return this . enabled ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof ServiceEcaRule ) { ServiceEcaRule other = ( ServiceEcaRule ) obj ; if ( ! UtilValidate . areEqual ( this . serviceName , other . serviceName ) ) { return false ; } if ( ! UtilValidate . areEqual ( this . eventName , other . eventName ) ) { return false ; } if ( ! this . conditions . equals ( other . conditions ) ) { return false ; } if ( ! this . actionsAndSets . equals ( other . actionsAndSets ) ) { return false ; } if ( this", "gt": ". runOnFailure != other . runOnFailure )", "prediction": ". actionsRun . equals ( other . actionsRun ) )\n", "label": 0}
{"id": 14408, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; import java . awt . geom . Point2D ; import java . util . Timer ; import java . util . TimerTask ; import fr . inria . zvtm . glyphs . Translucent ; import fr . inria . zvtm . glyphs . Translucency ; import fr . inria . zvtm . engine . LowPassFilter ; public class LPDGaussianLens extends LPFSGaussianLens implements TemporalLens { double frequency = - 1 ; long mLastSampleTime = - 1 ; int xOffset = - 10 ; int yOffset = 10 ; double maxDist = 2 * Math . abs ( xOffset ) ; LowPassFilter filter = new LowPassFilter ( ) ; Point2D currentPos = new Point2D . Double ( 0 , 0 ) ; Point2D parentPos = new Point2D . Double ( 0 , 0 ) ; Point2D targetPos = new Point2D . Double ( 0 , 0 ) ; Timer timer ; LPDLTrailingTimer mouseStillUpdater ; double cutoffParamA = 0.1 ; double cutoffParamB = 0.001 ; float a = 1 ; float b = 0 ; TemporalParamListener tpl ; public LPDGaussianLens ( ) { super ( ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp ) { super ( mm , lp ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp , int outerRadius , int innerRadius ) { super ( mm , lp , outerRadius , innerRadius ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp , int outerRadius , int innerRadius , int x , int y ) { super ( mm , lp , outerRadius , innerRadius , x , y ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } void computeLPFactors ( float minLp , float maxLp ) { a = maxLp - minLp ; b = minLp ; } void initTimer ( ) { timer = new Timer ( ) ; mouseStillUpdater = new LPDLTrailingTimer ( this ) ; timer . scheduleAtFixedRate ( mouseStillUpdater , 40 , 10 ) ; } public synchronized void setAbsolutePosition ( int ax , int ay , long absTime ) { synchronized ( this ) { super . setAbsolutePosition ( ax , ay ) ; updateFrequency ( absTime ) ; updateTimeBasedParams ( ax , ay ) ; } } public void updateFrequency ( ) { updateFrequency ( System . currentTimeMillis ( ) ) ; } public void updateFrequency ( long currentTime ) { if ( frequency == - 1 ) { frequency = 1 ; } else { if ( currentTime != mLastSampleTime ) { frequency = 1000.0 / ( ( double ) ( currentTime - mLastSampleTime ) ) ; } } mLastSampleTime = currentTime ; } public void updateTimeBasedParams ( int cx , int cy ) { parentPos . setLocation ( cx , cy ) ; updateTimeBasedParams ( ) ; } public void updateTimeBasedParams ( ) { targetPos . setLocation ( parentPos . getX ( ) + xOffset , parentPos . getY ( ) + yOffset ) ; double distAway = targetPos . distance ( currentPos ) ; double opacity = 1.0 - Math . min ( 1.0 , distAway / maxDist ) ; filter . setCutOffFrequency ( ( ( 1.0 - opacity ) * cutoffParamA ) + cutoffParamB ) ; currentPos = filter . apply ( targetPos , frequency ) ; int tx = ( int ) Math . round ( currentPos . getX ( ) ) ; int ty = ( int ) Math . round ( currentPos . getY ( ) ) ; tx = Math . max ( tx , w / 2 ) ; ty = Math . min ( ty , owningView . parent . getPanelSize ( ) . height - h / 2 ) ; float nLp = ( ( float ) opacity ) * a + b ; if ( Math . abs ( nLp - this . P ) > 0.01f ) { this . setDistanceMetrics ( nLp ) ; owningView . parent . repaint ( ) ; if ( tpl != null ) { tpl . parameterUpdated ( ) ; } } } public void setCutoffFrequencyParameters ( double a , double b ) { cutoffParamA = a ; cutoffParamB = b ; } public void setNoUpdateWhenMouseStill ( boolean b ) { mouseStillUpdater . setEnabled ( ! b ) ; } public void dispose ( ) { super . dispose ( ) ; timer . cancel ( ) ; } java . awt . BasicStroke bs = new java . awt . BasicStroke ( 2.0f ) ; java . awt . Stroke os ; public void drawBoundary ( Graphics2D g2d ) { g2d . setComposite ( Translucency . acs [ Math . round ( ( 1.0f - ( P - b ) / a ) * Translucency . ACS_ACCURACY ) - 1 ] ) ; if ( r1Color != null ) { g2d . setColor ( r1Color ) ; os = g2d . getStroke ( ) ; g2d . setStroke ( bs ) ; g2d . drawLine ( lx + w / 2 - LR1 , ly + h / 2 , lx + w / 2 + LR1 , ly + h / 2 ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 - LR1 , lx + w / 2 , ly + h / 2 + LR1 ) ; g2d . setStroke ( os ) ; } g2d . setComposite ( Translucent . acO ) ; } public void setTemporalParamListener ( TemporalParamListener tpl ) { this . tpl = tpl ; } public TemporalParamListener getTemporalParamListener ( ) { return this . tpl ; } } class LPDLTrailingTimer extends TimerTask { TemporalLens lens ;", "gt": "private boolean enabled = true ;", "prediction": "public LPDLTrailingTimer ( )\n", "label": 1}
{"id": 600, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . tree . InsnNode ; import org . objectweb . asm . tree . MethodInsnNode ; import org . objectweb . asm . tree . VarInsnNode ; import static org . objectweb . asm . Opcodes . * ; import static org . parboiled . transform . AsmUtils . createArgumentLoaders ; class BodyWithSuperCallReplacer implements RuleMethodProcessor { public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( classNode , \"classNode\" ) ; checkArgNotNull ( method , \"method\" ) ; return ! method . isBodyRewritten ( ) && method . getOwnerClass ( ) == classNode . getParentClass ( ) && method . getLocalVarVariables ( ) == null ; } public void process ( ParserClassNode classNode", "gt": ", RuleMethod method ) throws Exception", "prediction": ", RuleMethod method )\n", "label": 0}
{"id": 14415, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . ui . IElementFactory ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IPersistableElement ; public class BadElementFactory implements IElementFactory { public static boolean fail = false ; public static boolean failAttempted = false ; public static class BadElementInstance implements IAdaptable , IPersistableElement { public static boolean fail = false ; public static boolean failAttempted = false ; public Object getAdapter ( Class adapter ) { if ( adapter . equals ( IPersistableElement . class ) ) return this ; return null ; } public String getFactoryId ( ) { return \"org.eclipse.ui.tests.badFactory\" ; } public void saveState ( IMemento memento ) { if ( fail ) { failAttempted = true ; throw new RuntimeException ( ) ; } } } ; public IAdaptable createElement ( IMemento memento ) { if ( fail ) { failAttempted = true ;", "gt": "throw new RuntimeException ( ) ;", "prediction": "throw new RuntimeException ( ) ;\n", "label": 1}
{"id": 1704, "input": "<s> package com . redhat . ceylon . ceylondoc ; public class CeylondException extends RuntimeException { private static final long serialVersionUID = 1L ; public CeylondException ( String msgKey , Exception cause ) { super ( CeylondMessages . msg", "gt": "( msgKey ) , cause ) ;", "prediction": "Key , msgKey , cause ) ;\n", "label": 0}
{"id": 14420, "input": "<s> package com . corundumstudio . socketio . parser ; public enum ErrorAdvice { RECONNECT ( 0 ) ; private int value ; ErrorAdvice ( int value ) { this . value = value ; } public int getValue ( ) { return value ; }", "gt": "public static ErrorAdvice valueOf ( int value )", "prediction": "}\n", "label": 1}
{"id": 1257, "input": "<s> package com . sun . tools . apt . mirror . apt ; import com . sun . mirror . apt . AnnotationProcessorEnvironment ; import com . sun . mirror . apt . RoundCompleteEvent ; import com . sun . mirror . apt . RoundState ; @ SuppressWarnings (", "gt": "\"deprecation\" ) public class RoundCompleteEventImpl extends RoundCompleteEvent", "prediction": "\n", "label": 0}
{"id": 14431, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . jface . preference . JFacePreferences ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public class JFaceColors { public static Color getBannerBackground ( Display display ) { return display . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ; } public static Color getBannerForeground ( Display display ) { return display . getSystemColor ( SWT . COLOR_LIST_FOREGROUND ) ; } public static Color getErrorBackground ( Display display ) { return display . getSystemColor ( SWT . COLOR_WIDGET_BACKGROUND ) ; } public static Color getErrorBorder ( Display display ) { return display . getSystemColor ( SWT . COLOR_WIDGET_DARK_SHADOW ) ; } public static Color getErrorText ( Display display ) { return JFaceResources . getColorRegistry ( ) . get ( JFacePreferences . ERROR_COLOR ) ; } public static Color getHyperlinkText ( Display display ) { return JFaceResources . getColorRegistry ( ) . get ( JFacePreferences . HYPERLINK_COLOR ) ; } public static Color getActiveHyperlinkText ( Display display ) { return JFaceResources . getColorRegistry ( ) . get ( JFacePreferences . ACTIVE_HYPERLINK_COLOR ) ; } public static void clearColor ( String colorName ) { } public static void disposeColors ( ) { } public static void setColors ( Control control", "gt": ", Color foreground , Color background )", "prediction": ", Color [ ] colors )\n", "label": 1}
{"id": 3073, "input": "<s> package com . redhat . nitrate ; import java . util . Hashtable ; import java . util . logging . Level ; import java . util . logging . Logger ; public abstract class TcmsCommand { public String name ( ) { String s [ ] = this . getClass ( ) . getCanonicalName ( ) . split ( \"\\\\.\" ) ; int l = s . length ; String name = s [ l - 2 ] + \".\" + s [ l - 1 ] ; return name ; } ; public Object invoke ( TcmsConnection c ) throws TcmsException { return c . invoke ( this ) ; } public String description ( ) { try { return TcmsConnection . commandToString ( this ) ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( TcmsCommand . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return ex . getMessage ( ) ; } } public Hashtable < String , String > descriptionMap ( ) { Hashtable < String , String > out = new Hashtable < String , String > ( ) ; Hashtable < String , Object > map = TcmsConnection . fieldsToHashtable ( this ) ; for ( String k : map . keySet ( ) ) { out . put ( k , map . get ( k )", "gt": ". toString ( ) ) ;", "prediction": ". toString ( ) ) ;\n", "label": 0}
{"id": 14434, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Random ; import org . apache . lucene . store . * ; import org . apache . lucene . util . * ; import org . apache . lucene . analysis . * ; import org . apache . lucene . document . * ; public class TestTransactions extends LuceneTestCase { private Random RANDOM ; private static volatile boolean doFail ; private class RandomFailure extends MockRAMDirectory . Failure { public void eval ( MockRAMDirectory dir ) throws IOException { if ( TestTransactions . doFail && RANDOM . nextInt ( ) % 10 <= 3 ) throw new IOException ( \"now failing randomly but on purpose\" ) ; } } private static abstract class TimedThread extends Thread { boolean failed ; private static int RUN_TIME_SEC = 6 ; private TimedThread [ ] allThreads ; abstract public void doWork ( ) throws Throwable ; TimedThread ( TimedThread [ ] threads ) { this . allThreads = threads ; } public void run ( ) { final long stopTime = System . currentTimeMillis ( ) + 1000 * RUN_TIME_SEC ; try { while ( System . currentTimeMillis ( ) < stopTime && ! anyErrors ( ) ) doWork ( ) ; } catch ( Throwable e ) { System . out . println ( Thread . currentThread ( ) + \": exc\" ) ; e . printStackTrace ( System . out ) ; failed = true ; } } private boolean anyErrors ( ) { for ( int i = 0 ; i < allThreads . length ; i ++ ) if ( allThreads [ i ] != null && allThreads [ i ] . failed ) return true ; return false ; } } private class IndexerThread extends TimedThread { Directory dir1 ; Directory dir2 ; Object lock ; int nextID ; public IndexerThread ( Object lock , Directory dir1 , Directory dir2 , TimedThread [ ] threads ) { super ( threads ) ; this . lock = lock ; this . dir1 = dir1 ; this . dir2 = dir2 ; } public void doWork ( ) throws Throwable { IndexWriter writer1 = new IndexWriter ( dir1 , new WhitespaceAnalyzer ( ) , IndexWriter . MaxFieldLength . LIMITED ) ; writer1 . setMaxBufferedDocs ( 3 ) ; writer1 . setMergeFactor ( 2 ) ; ( ( ConcurrentMergeScheduler ) writer1 . getMergeScheduler ( ) ) . setSuppressExceptions ( ) ; IndexWriter writer2 = new IndexWriter ( dir2 , new WhitespaceAnalyzer ( ) , IndexWriter . MaxFieldLength . LIMITED ) ; writer2 . setMaxBufferedDocs ( 2 ) ; writer2 . setMergeFactor ( 3 ) ; ( ( ConcurrentMergeScheduler ) writer2 . getMergeScheduler ( ) ) . setSuppressExceptions ( ) ; update ( writer1 ) ; update ( writer2 ) ; TestTransactions . doFail = true ; try { synchronized ( lock ) { try {", "gt": "writer1 . prepareCommit ( ) ;", "prediction": "writer1 . close ( ) ;\n", "label": 1}
{"id": 5165, "input": "<s> package org . parboiled . examples . abc ; import org . parboiled . Parboiled ; import org . parboiled . examples . TestNgParboiledTest ; import org . testng . annotations . Test ; public class AbcTest extends TestNgParboiledTest < Object > { @ Test public void test ( ) { AbcParser parser = Parboiled . createParser ( AbcParser . class ) ; test ( parser . S ( ) , \"aabbcc\" ) . hasNoErrors ( ) . hasParseTree ( \"\" + \"[S] 'aabbcc'\\n\" + \"  [OneOrMore] 'aa'\\n\" + \"    ['a'] 'a'\\n\" + \"    ['a'] 'a'\\n\" + \"  [B] 'bbcc'\\n\" + \"    ['b'] 'b'\\n\" + \"    [Optional] 'bc'\\n\" + \"      [B] 'bc'\\n\" + \"        ['b'] 'b'\\n\" + \"        [Optional]\\n\" + \"        ['c'] 'c'\\n\" + \"    ['c'] 'c'\\n\" ) ; } @ Test public void testFail1 ( ) { AbcParser parser = Parboiled . createParser ( AbcParser . class ) ; testWithRecovery ( parser . S ( ) , \"aabbbcc\" ) . hasErrors ( \"\" + \"Invalid input 'b', expected 'c' (line 1, pos 5):\\n\" + \"aabbbcc\\n\" + \"    ^\\n\" ) . hasParseTree ( \"\" + \"[S]E 'aabbcc'\\n\" + \"  [OneOrMore] 'aa'\\n\" + \"    ['a'] 'a'\\n\" + \"    ['a'] 'a'\\n\" + \"  [B]E 'bbcc'\\n\" + \"    ['b'] 'b'\\n\" + \"    [Optional]E 'bc'\\n\" + \"      [B]E 'bc'\\n\" + \"        ['b'] 'b'\\n\" + \"        [Optional]\\n\" + \"        ['c'] 'c'\\n\" + \"    ['c'] 'c'\\n\" ) ; } @ Test public void testFail2 ( ) { AbcParser parser = Parboiled", "gt": ". createParser ( AbcParser . class ) ;", "prediction": ". createParser ( AbcParser . class ) ;\n", "label": 0}
{"id": 14439, "input": "<s> package br . org . archimedes . controller . commands ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class PanCommandTest { private PanCommand pan ; private Drawing drawing ; @ Before public void setUp ( ) throws Exception { Point original = new Point ( 0 , 0 ) ; Point viewport = new Point ( 14 , 42 ) ; pan = new PanCommand ( original , viewport ) ; drawing = new Drawing ( \"Drawing\" ) ; } @ After public void tearDown ( ) throws Exception { pan = null ; drawing = null ; } @ Test ( expected = IllegalActionException . class ) public void creatingPanWithTwoEqualPointsThrowsException ( ) throws Exception { new PanCommand ( new Point ( 10 , 10 ) , new Point ( 10 , 10 ) ) ; } @ Test ( expected = NullArgumentException . class ) public void creatingPanWithNullsThrowsException ( ) throws Exception { new PanCommand ( null , null ) ; } @ Test ( expected = NullArgumentException . class ) public void executingOnANullDrawingThrowsException ( ) throws Exception { pan . doIt ( null ) ; } @ Test public void executingWorksFine ( ) throws Exception { double zoom = drawing . getZoom ( ) ; pan . doIt ( drawing ) ; Point viewport = drawing . getViewportPosition ( ) ; assertEquals ( \"The viewport position should have been updated.\" , new Point ( 14 , 42 ) , viewport ) ; assertEquals ( \"The zoom should be the same.\" , zoom , drawing .", "gt": "getZoom ( ) , Constant . EPSILON ) ;", "prediction": "getZoom ( ) ) ;\n", "label": 1}
{"id": 9248, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Face { char d [ ] [ ] = new char [ 3 ] [ 3 ] ; public void read ( String [ ] s , int c , int l ) { this . d [ l ] [ 0 ] = s [ c + 0 ] . charAt ( 0 ) ; this . d [ l ] [ 1 ] = s [ c + 1 ] . charAt ( 1 ) ; this . d [ l ] [ 2 ] = s [ c + 2 ] . charAt ( 2 ) ; } public boolean ok ( ) { for ( int i = 0 ; i != 3 ; i ++ ) for ( int j = 0 ; j != 3 ; j ++ ) if ( this . d [ i ] [ j ] != this . d [ 0 ] [ 0 ] ) return false ; return true ; } public void rotaciona ( int i ) { if ( i == 1 ) { rotDireita ( ) ; } else if ( i == - 1 ) { rotEsquerda ( ) ; } } private void rotEsquerda ( ) { } private void rotDireita ( ) { } } class Main { static int maxLg = 200 ; static int n , m , l ; static Face [ ] faces = new Face [ 7 ] ; public static void main ( String args [ ] ) throws Exception { String t [ ] ; for ( int i = 0 ; i != 7 ; i ++ ) { faces [ i ] = new Face ( ) ; } faces [ 1 ] . f ( faces [ 5 ] , faces [ 4 ] , faces [ 2 ] , faces [ 6 ] ) ; faces [ 2 ] . f ( faces [ 5 ] , faces [ 1 ] , faces [ 3 ] , faces [ 6 ] ) ; int tz = Integer . parseInt ( readLine ( ) . trim ( ) ) ; ooo : while ( tz -- != 0 ) { faces [ 5 ] . read ( split ( readLine ( ) ) , 0 , 0 ) ; faces [ 5 ] . read ( split ( readLine ( ) ) , 0 , 1 ) ; faces [ 5 ] . read ( split (", "gt": "readLine ( ) ) , 0 , 2 ) ;", "prediction": "readLine ( ) ) , 0 , 2 ) ;\n", "label": 0}
{"id": 14442, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . BitSet ; import org . apache . lucene . index . IndexReader ; public class RemoteCachingWrapperFilter extends Filter { protected Filter filter ; public RemoteCachingWrapperFilter ( Filter filter ) { this . filter = filter ; } public BitSet bits ( IndexReader reader ) throws IOException { Filter cachedFilter = FilterManager . getInstance ( ) . getFilter ( filter ) ; return cachedFilter . bits ( reader ) ; } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { Filter cachedFilter = FilterManager . getInstance ( ) . getFilter ( filter ) ; return cachedFilter .", "gt": "getDocIdSet ( reader ) ;", "prediction": "docIdSet ( reader ) ;\n", "label": 1}
{"id": 487, "input": "<s> class T7023703neg { void testForLoop ( boolean cond ) { final int bug ; final int bug2 ; for ( ; cond ; ) { final int item = 0 ; bug2 = 1 ; } bug = 0 ; } void testForEachLoop ( java . util . Collection < Integer > c ) { final int bug ; final int bug2 ; for ( Integer i : c ) { final int item = 0 ; bug2 = 1 ; } bug = 0 ; } void testWhileLoop ( boolean cond ) { final int bug ; final int bug2 ; while ( cond ) { final int item = 0 ; bug2 = 1 ; } bug = 0 ; }", "gt": "void testDoWhileLoop ( boolean cond )", "prediction": "}\n", "label": 0}
{"id": 14445, "input": "<s> package org . eclipse . ui . internal ; interface IReorderListener { public void reorder", "gt": "( Object obj , int newIndex ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6177, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . common . ImmutableList ; import org . parboiled . common . Utils ; import org . parboiled . trees . ImmutableGraphNode ; public abstract class AbstractMatcher extends ImmutableGraphNode < Matcher > implements Matcher , Cloneable { private String label ; private boolean nodeSuppressed ; private boolean subnodesSuppressed ; private boolean nodeSkipped ; private Object tag ; public AbstractMatcher ( String label ) { this ( new Rule [ 0 ] , label ) ; } public AbstractMatcher ( Rule subRule , String label ) { this ( new Rule [ ] { checkArgNotNull ( subRule , \"subRule\" ) } , label ) ; } public AbstractMatcher ( Rule [ ] subRules , String label ) { super ( ImmutableList . < Matcher > of ( toMatchers ( checkArgNotNull ( subRules , \"subRules\" ) ) ) ) ; this . label = label ; } private static Matcher [ ] toMatchers ( Rule [ ] subRules ) { Matcher [ ] matchers = new Matcher [ subRules . length ] ; for ( int i = 0 ; i < subRules . length ; i ++ ) { matchers [ i ] = ( Matcher ) subRules [ i ] ; } return matchers ; } public boolean isNodeSuppressed ( ) { return nodeSuppressed ; } public boolean areSubnodesSuppressed ( ) { return subnodesSuppressed ; } public boolean isNodeSkipped ( ) { return nodeSkipped ; } public boolean areMismatchesMemoed ( ) { return false ; } public String getLabel ( ) { return label ; } public boolean hasCustomLabel ( ) { return true ; } @ Override public String toString ( ) { return getLabel ( ) ; } public AbstractMatcher label ( String label ) { if ( Utils . equal ( label , this . label ) ) return this ; AbstractMatcher clone = createClone ( ) ; clone . label = label ; return clone ; } public Rule suppressNode ( ) { if ( nodeSuppressed ) return this ; AbstractMatcher clone = createClone ( ) ; clone . nodeSuppressed = true ; return clone ; } public Rule suppressSubnodes ( ) { if ( subnodesSuppressed ) return this ; AbstractMatcher clone = createClone ( ) ; clone . subnodesSuppressed = true ; return clone ; } public Rule skipNode ( ) { if ( nodeSkipped ) return this ;", "gt": "AbstractMatcher clone = createClone ( ) ;", "prediction": "AbstractMatcher clone = createClone ( ) ;\n", "label": 0}
{"id": 14451, "input": "<s> package com . northconcepts . eventbus . filter ; import com . northconcepts . eventbus . EventFilter ; import org . junit . Test ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class OrFilterTest extends LogicalFilterTest { @ Test public void testNullFilters ( ) { EventFilter filter = new OrFilter ( ( EventFilter [ ] ) null ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testZeroFilters ( ) { EventFilter filter = new OrFilter ( ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneTrueFilter ( ) { EventFilter filter = new OrFilter ( TRUE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneFalseFilter ( ) { EventFilter filter = new OrFilter ( FALSE_FILTER ) ; assertFalse ( filter . allow ( event , listener ) ) ; } @ Test public void testManyTrueFilters ( ) { EventFilter filter = new OrFilter ( TRUE_FILTER , TRUE_FILTER , TRUE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testManyFalseFilters ( ) { EventFilter filter = new OrFilter ( FALSE_FILTER , FALSE_FILTER , FALSE_FILTER ) ; assertFalse", "gt": "( filter . allow ( event , listener ) ) ;", "prediction": "( filter . allow ( event , listener ) ) ;\n", "label": 1}
{"id": 8258, "input": "<s> package org . ofbiz . webtools . artifactinfo ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilURL ; import org . ofbiz . webapp . control . ConfigXMLReader ; public class ControllerRequestArtifactInfo extends ArtifactInfoBase { public static final String module = ControllerRequestArtifactInfo . class . getName ( ) ; protected URL controllerXmlUrl ; protected String requestUri ; protected ConfigXMLReader . RequestMap requestInfoMap ; protected ServiceArtifactInfo serviceCalledByRequestEvent = null ; protected Set < ControllerRequestArtifactInfo > requestsThatAreResponsesToThisRequest = new TreeSet < ControllerRequestArtifactInfo > ( ) ; protected Set < ControllerViewArtifactInfo > viewsThatAreResponsesToThisRequest = new TreeSet < ControllerViewArtifactInfo > ( ) ; public ControllerRequestArtifactInfo ( URL controllerXmlUrl , String requestUri , ArtifactInfoFactory aif ) throws GeneralException { super ( aif ) ; this . controllerXmlUrl = controllerXmlUrl ; this . requestUri = requestUri ; this . requestInfoMap = aif . getControllerRequestMap ( controllerXmlUrl , requestUri ) ; if ( this . requestInfoMap == null ) { throw new GeneralException ( \"Controller request with name [\" + requestUri + \"] is not defined in controller file [\" + controllerXmlUrl + \"].\" ) ; } } public void populateAll ( ) throws GeneralException { if ( this . requestInfoMap . event != null && this . requestInfoMap . event . type != null && ( this . requestInfoMap . event . type . indexOf ( \"service\" ) >= 0 ) ) { String serviceName = this . requestInfoMap . event . invoke ; this . serviceCalledByRequestEvent = this . aif . getServiceArtifactInfo ( serviceName ) ; if ( this . serviceCalledByRequestEvent != null ) { UtilMisc . addToSortedSetInMap ( this , aif . allRequestInfosReferringToServiceName , this . serviceCalledByRequestEvent . getUniqueId ( ) ) ; } } Map < String , ConfigXMLReader . RequestResponse > requestResponseMap = UtilGenerics . checkMap ( this . requestInfoMap . requestResponseMap ) ; for ( ConfigXMLReader . RequestResponse response : requestResponseMap . values ( ) ) { if ( \"view\" . equals ( response . type ) ) { String viewUri = response . value ; if ( viewUri . startsWith ( \"/\" ) ) { viewUri = viewUri . substring ( 1 ) ; } try { ControllerViewArtifactInfo artInfo = this . aif . getControllerViewArtifactInfo ( controllerXmlUrl , viewUri ) ; this . viewsThatAreResponsesToThisRequest . add ( artInfo ) ; UtilMisc . addToSortedSetInMap ( this , this . aif . allRequestInfosReferringToView , artInfo . getUniqueId ( ) ) ; } catch ( GeneralException e ) { Debug . logWarning ( e . toString ( ) , module ) ; } } else if ( response . type . equals ( \"request\" ) ) { String otherRequestUri = response . value ; if ( otherRequestUri . startsWith ( \"/\" ) ) { otherRequestUri = otherRequestUri . substring ( 1 ) ; } try { ControllerRequestArtifactInfo artInfo = this . aif . getControllerRequestArtifactInfo ( controllerXmlUrl , otherRequestUri ) ; this . requestsThatAreResponsesToThisRequest . add ( artInfo ) ; UtilMisc . addToSortedSetInMap ( this , this . aif . allRequestInfosReferringToRequest", "gt": ", artInfo . getUniqueId ( ) ) ;", "prediction": ", artInfo . getUniqueId ( ) ) ;\n", "label": 0}
{"id": 14452, "input": "<s> package com . google . gwt . user . client . ui ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class DisclosurePanel_DefaultImages_default_StaticClientBundleGenerator implements com . google . gwt . user . client . ui . DisclosurePanel . DefaultImages { private static DisclosurePanel_DefaultImages_default_StaticClientBundleGenerator _instance0 = new DisclosurePanel_DefaultImages_default_StaticClientBundleGenerator ( ) ; private void disclosurePanelClosedInitializer ( ) { disclosurePanelClosed = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"disclosurePanelClosed\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( com . google . gwt . i18n . client . LocaleInfo . getCurrentLocale ( ) . isRTL ( ) ? bundledImage_None_rtl : bundledImage_None ) , 16 , 0 , 16 , 16 , false , false ) ; } private static class disclosurePanelClosedInitializer { static { _instance0 . disclosurePanelClosedInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return disclosurePanelClosed ; } } public com . google . gwt . resources . client . ImageResource disclosurePanelClosed ( ) { return disclosurePanelClosedInitializer . get ( ) ; } private void disclosurePanelOpenInitializer ( ) { disclosurePanelOpen = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"disclosurePanelOpen\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( com . google . gwt . i18n . client . LocaleInfo . getCurrentLocale ( ) . isRTL ( ) ? bundledImage_None_rtl : bundledImage_None ) , 0 , 0 , 16 , 16 , false , false ) ; } private static class disclosurePanelOpenInitializer { static { _instance0 . disclosurePanelOpenInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return disclosurePanelOpen ; } } public com . google . gwt . resources . client . ImageResource disclosurePanelOpen ( ) { return disclosurePanelOpenInitializer . get ( ) ; } private static java . util . HashMap < java . lang . String , com . google . gwt . resources . client . ResourcePrototype > resourceMap ; private static final java . lang . String bundledImage_None = GWT . getModuleBaseURL ( ) + \"E44767377485D18D6B6864F65BA8EF73.cache.png\" ; private static final java . lang . String bundledImage_None_rtl = GWT . getModuleBaseURL ( ) + \"0A9476898799A150D840F0B1C3672921.cache.png\" ; private static com . google . gwt . resources . client . ImageResource disclosurePanelClosed ; private static com . google . gwt . resources", "gt": ". client . ImageResource disclosurePanelOpen ;", "prediction": ". client . ImageResource disclosurePanelClosedInitializer ;\n", "label": 1}
{"id": 2644, "input": "<s> package org . parboiled . support ; import org . parboiled . errors . GrammarException ; public final class Checks { private Checks ( ) { } public static void ensure ( boolean condition , String errorMessageFormat , Object ... errorMessageArgs ) { if ( ! condition ) { throw new GrammarException ( errorMessageFormat , errorMessageArgs ) ; } } public static void ensure ( boolean condition , String errorMessage ) { if ( ! condition ) { throw", "gt": "new GrammarException ( errorMessage ) ;", "prediction": "new GrammarException ( errorMessageFormat , errorMessageArgs ) ;\n", "label": 0}
{"id": 14455, "input": "<s> package org . jscsi . scsi . protocol . mode ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . BufferUnderflowException ; public class BackgroundControl extends ModePage { public static final byte PAGE_CODE = 0x1C ; public static final int SUBPAGE_CODE = 0x01 ; public static final int PAGE_LENGTH = 0x0C ; private boolean S_L_FULL ; private boolean LOWIR ; private boolean EN_BMS ; private boolean EN_PS ; private int backgroundMediumScanIntervalTime ; private int backgroundPrescanTimeLimit ; private int minimumIdleTimeBeforeBackgroundScan ; private int maximumTimeToSuspectBackgroundScan ; public BackgroundControl ( ) { super ( PAGE_CODE , SUBPAGE_CODE , PAGE_LENGTH ) ; } @ Override protected void decodeModeParameters ( int dataLength , DataInputStream inputStream ) throws BufferUnderflowException , IllegalArgumentException { try { int b = inputStream . readUnsignedByte ( ) ; this . S_L_FULL = ( ( b > > > 2 ) & 1 ) == 1 ; this . LOWIR = ( ( b > > > 1 ) & 1 ) == 1 ; this . EN_BMS = b == 1 ; this . EN_PS = inputStream . readUnsignedByte ( ) == 1 ; this . backgroundMediumScanIntervalTime = inputStream . readUnsignedShort ( ) ; this . backgroundPrescanTimeLimit = inputStream . readUnsignedShort ( ) ; this . minimumIdleTimeBeforeBackgroundScan = inputStream . readUnsignedShort ( ) ; this . maximumTimeToSuspectBackgroundScan = inputStream . readUnsignedShort ( ) ; inputStream . readShort ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( \"Error reading input data.\" ) ; } } @ Override protected void encodeModeParameters ( DataOutputStream output ) { try { int b = 0 ; if ( this . S_L_FULL ) { b |= 4 ; } if ( this . LOWIR ) { b |= 2 ; } if ( this . EN_BMS ) { b |= 1 ; } output . writeByte ( b ) ; b = 0 ; if ( this . EN_PS ) { b = 1 ; } output . writeByte ( b ) ; output . writeShort ( this . backgroundMediumScanIntervalTime ) ; output . writeShort ( this . backgroundPrescanTimeLimit ) ; output . writeShort ( this . minimumIdleTimeBeforeBackgroundScan ) ; output . writeShort ( this . maximumTimeToSuspectBackgroundScan ) ; output . writeShort ( 0 ) ; } catch ( IOException e ) { throw new RuntimeException ( \"Unable to encode CDB.\" ) ; } } public boolean isS_L_FULL ( ) { return this . S_L_FULL ; } public void setS_L_FULL ( boolean s_l_full ) { this . S_L_FULL = s_l_full ; } public boolean isLOWIR ( ) { return this . LOWIR ; } public void setLOWIR ( boolean lowir ) { this . LOWIR = lowir ; } public boolean isEN_BMS ( ) { return this . EN_BMS ; } public void setEN_BMS ( boolean en_bms ) { this . EN_BMS = en_bms ; } public boolean isEN_PS ( ) { return this . EN_PS ; } public void setEN_PS ( boolean en_ps ) { this . EN_PS = en_ps ; } public int getBackgroundMediumScanIntervalTime ( ) { return this . backgroundMediumScanIntervalTime ; } public void setBackgroundMediumScanIntervalTime ( int backgroundMediumScanIntervalTime ) { this", "gt": ". backgroundMediumScanIntervalTime = backgroundMediumScanIntervalTime ;", "prediction": ". backgroundMediumScanIntervalTime = backgroundMediumScanIntervalTime ;\n", "label": 1}
{"id": 9106, "input": "<s> package com . caseystella . lsh . interfaces ; import org . apache . commons . math . linear . RealVector ; import com .", "gt": "caseystella . interfaces . IDistanceMetric ;", "prediction": "caseystella . lsh . interfaces . Vector ;\n", "label": 0}
{"id": 14458, "input": "<s> package org . apache . lucene . analysis . reverse ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import java . io . IOException ; public final class ReverseStringFilter extends TokenFilter { private TermAttribute termAtt ; private final char marker ; private static final char NOMARKER = '\uffff' ; public static final char START_OF_HEADING_MARKER = '\u0001' ; public static final char INFORMATION_SEPARATOR_MARKER = '\u001f' ; public static final char PUA_EC00_MARKER = '\uec00' ; public static final char RTL_DIRECTION_MARKER = '\u200f' ; public ReverseStringFilter ( TokenStream in ) { this ( in , NOMARKER ) ; } public ReverseStringFilter ( TokenStream in , char marker ) { super ( in ) ; this . marker = marker ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; } public boolean incrementToken ( ) throws IOException { if ( input . incrementToken ( ) ) { int len = termAtt . termLength ( ) ; if ( marker != NOMARKER ) { len ++ ; termAtt . resizeTermBuffer ( len ) ; termAtt . termBuffer ( ) [ len - 1 ] = marker ; } reverse ( termAtt . termBuffer ( ) , len ) ; termAtt . setTermLength ( len ) ; return true ; } else { return false ; } } public static String reverse ( final String input ) {", "gt": "char [ ] charInput = input . toCharArray ( ) ;", "prediction": "if ( input == null )\n", "label": 1}
{"id": 2845, "input": "<s> package annotation . enums ; @ interface A { } enum T { @ A a", "gt": ", @ A b ;", "prediction": ";\n", "label": 0}
{"id": 14469, "input": "<s> package org . eclipse . ui ; import java . util . Map ; public interface ISourceProviderListener { public void sourceChanged ( final int sourcePriority", "gt": ", final Map sourceValuesByName ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8985, "input": "<s> class EmptyArray { int [ ] i = { , } ; int", "gt": "[ ] j = new int [ ]", "prediction": "[ ] j =\n", "label": 0}
{"id": 14481, "input": "<s> package org . eclipse . jface . tests . wizards ; import junit . framework . TestCase ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public class ButtonAlignmentTest extends TestCase { private TheTestWizard wizard ; private TheTestWizardDialog dialog ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Display . getDefault ( ) ; } protected void tearDown ( ) throws Exception { if ( dialog != null && dialog . getShell ( ) != null && ! dialog . getShell ( ) . isDisposed ( ) ) { dialog . close ( ) ; } super . tearDown ( ) ; } public ButtonAlignmentTest ( ) { super ( \"ButtonAlignmentTest\" ) ; } public void testButtonAlignment ( ) { wizard = new TheTestWizard ( ) ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ; dialog . open ( ) ; Composite parent = dialog . getFinishedButton ( ) . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; assertEquals ( \"There should be three children, a composite for back/next buttons, the finish button, and the cancel button\" , 3 , children . length ) ; assertTrue ( children [ 0 ] instanceof Composite ) ; Composite backNextParent = ( Composite ) children [ 0 ] ; Control [ ] backNextChildren = backNextParent . getChildren ( ) ; assertEquals ( \"Back button should be the first button\" , dialog . getBackButton ( ) , backNextChildren [ 0 ] ) ; assertEquals ( \"Next button should be the second button\" , dialog . getNextButton ( ) , backNextChildren [ 1 ] ) ; int finishIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 1 : 2 ; int cancelIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 2 : 1 ; assertEquals ( \"Finish button's alignment is off\" , dialog . getFinishedButton ( ) , children [ finishIndex ] ) ; assertEquals ( \"Cancel button's alignment is off\" , dialog . getCancelButton ( ) , children [ cancelIndex ] ) ; } public void testButtonAlignmentWithoutBackNextButtons ( ) { wizard = new TheTestWizard ( ) { public void addPages ( ) { addPage ( new TheTestWizardPage ( page1Name ) ) ; } } ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ; dialog . open ( ) ; Composite parent = dialog . getFinishedButton ( ) . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; assertEquals ( \"There should be two children, the finish button, and the cancel button\" , 2 , children . length ) ; int finishIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 0 : 1 ; int cancelIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 1 : 0 ; assertEquals ( \"Finish button's alignment is off\" , dialog . getFinishedButton ( ) , children [ finishIndex ] ) ; assertEquals ( \"Cancel button's alignment is off\" , dialog . getCancelButton ( ) , children [ cancelIndex ] ) ; } public void testBug270174 ( ) { wizard = new TheTestWizard ( ) { public boolean canFinish ( ) { return false ; } } ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ; dialog . open ( ) ; Composite parent = dialog . getFinishedButton ( ) . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; assertEquals ( \"There should be three children, a composite for back/next buttons, the finish button, and the cancel button\" , 3 , children . length ) ; assertTrue ( children [ 0 ] instanceof Composite ) ; Composite backNextParent = ( Composite ) children [ 0 ] ; Control [ ] backNextChildren = backNextParent . getChildren ( ) ; assertEquals ( \"Back button should be the first button\" , dialog . getBackButton ( ) , backNextChildren [ 0 ] ) ; assertEquals ( \"Next button should be the second button\" , dialog . getNextButton ( ) , backNextChildren [ 1 ] ) ; int finishIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) ==", "gt": "SWT . LEFT ? 1 : 2 ;", "prediction": "SWT . LEFT ? 1 : 2 ;\n", "label": 1}
{"id": 5191, "input": "<s> package z1 ; public class Z1 { protected int x ; public static void main ( String [ ] args ) { new z2 .", "gt": "Z2 . T ( ) ;", "prediction": "run ( ) ;\n", "label": 0}
{"id": 14492, "input": "<s> package org . restlet . example . book . restlet . ch10 . sec3 . server ; import org . restlet . Component ; import org . restlet . Server ; import org . restlet . data . Protocol ; public class MailServerComponent extends Component { public static void main ( String [ ] args ) throws Exception { new MailServerComponent ( ) . start ( ) ; } public MailServerComponent ( ) throws Exception { setName ( \"RESTful Mail Server component\" ) ; setDescription ( \"Example for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; Server server = getServers ( ) .", "gt": "add ( Protocol . HTTP , 8111 ) ;", "prediction": "get ( 0 ) ;\n", "label": 1}
{"id": 4395, "input": "<s> public class AssignmentSameType6 { public static void main ( String [ ] args ) { Ref < B > exact = null ; Ref < ? extends B > ebound = null ; Ref < ? super B > sbound = null ; Ref < ?", "gt": "> unbound = null ;", "prediction": "extends B > tbound = null ;\n", "label": 0}
{"id": 14496, "input": "<s> package org . restlet . ext . oauth . internal ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import org . restlet . ext . oauth . AuthenticatedUser ; public abstract class TokenGenerator { private volatile SecureRandom random ; protected volatile long maxTokenTimeSec ; private static final int tokens = 1000 ; private volatile int count = 0 ; public TokenGenerator ( ) { try { random = SecureRandom . getInstance ( \"SHA1PRNG\" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } } public String generateCode ( AuthenticatedUser user ) { StringBuilder raw = new StringBuilder ( generate ( 20 ) ) ; raw . append ( '|' ) . append ( System . currentTimeMillis ( ) ) ; String code = raw . toString ( ) ; user . setCode ( code ) ; return code ; } public Token generateToken ( AuthenticatedUser user , long expire ) { long individualExp = user . getTokenExpire ( ) ; if ( individualExp > 0 ) { expire = individualExp ; } expire = ( expire <= maxTokenTimeSec ) ? expire : maxTokenTimeSec ; StringBuilder raw = new StringBuilder ( generate ( 40 ) ) ; String token = raw . toString ( ) ; Token t = null ; if ( expire != Token . UNLIMITED ) { t = new ExpireToken ( token , expire , generate ( 20 ) , user ) ; } else { t = new UnlimitedToken ( token , user ) ; } return t ; } public long expiresInSec ( Token token ) { if ( token instanceof ExpireToken ) { ExpireToken et = ( ExpireToken ) token ; ScheduledFuture < ? > sf = et . getFuture ( ) ; if ( sf != null ) return sf . getDelay ( TimeUnit . SECONDS ) ; } return Long . MAX_VALUE ; } public void setMaxTokenTime ( long maxTokenTimeSec ) { this . maxTokenTimeSec = maxTokenTimeSec ; } public void refreshToken ( ExpireToken token ) { revokeToken ( token ) ; token . expireToken ( ) ; String newToken = generate ( 20 ) ; token . setToken ( newToken ) ; } public abstract Token exchangeForToken ( String code , long expire ) throws IllegalArgumentException ; public abstract void revokeToken ( Token token ) ; public abstract void revokeExpireToken ( ExpireToken token ) ; public abstract Token findToken ( String token ) ; protected String generate ( int len ) { if ( count ++ > tokens ) { count = 0 ; random . setSeed ( random . generateSeed ( 20 ) ) ; } byte [ ] token = new byte [ len ] ; random . nextBytes ( token ) ; return toHex ( token ) ; } protected String toHex ( byte [ ] input ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < input . length ; i ++ ) { String d = Integer . toHexString ( new Byte ( input [ i ] ) . intValue ( ) & 0xFF ) ; if ( d . length ( ) == 1 )", "gt": "sb . append ( '0' ) ;", "prediction": "\n", "label": 1}
{"id": 1096, "input": "<s> package org . papaours . yama . services . impl ; import java . io . FileWriter ; import java . io . IOException ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import org . papaours . yama . model . YamaQuiz ; import org . papaours . yama . services . ExportQuizService ; public class ExportQuizServiceImpl implements ExportQuizService { public void exportQuiz ( final YamaQuiz quiz , final String xmlTargetFilePath ) throws JAXBException , IOException {", "gt": "JAXBContext context = JAXBContext . newInstance ( new Class [ ]", "prediction": "try\n", "label": 0}
{"id": 14509, "input": "<s> package org . restlet . test . resource ; import org . restlet . resource . Get ; import org . restlet . resource . ServerResource ; public class MyResource4 extends ServerResource { @ Get ( \"xml\" ) public String toXml ( ) { return \"<root/>\" ; }", "gt": "@ Get ( \"json\" ) public String toJson ( )", "prediction": "}\n", "label": 1}
{"id": 8517, "input": "<s> package gui ; import gui . PanelsManager . InitTask ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . FlowLayout ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import javax . swing . Box ; import javax . swing . BoxLayout ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JProgressBar ; public class LoadingPanel extends StyledPanel implements PropertyChangeListener { private static final long serialVersionUID = - 7661627309702862617L ; private JProgressBar progBar = null ; private JLabel status = null ; public static LoadingPanel instance ; private static boolean initialized = false ; public static boolean isInitialized ( ) { return initialized ; } public LoadingPanel ( ) { super ( \"bg.jpg\" ) ; status = new JLabel ( PanelsManager . getLoadStatus ( ) ) ; status . setForeground ( Color . WHITE ) ; if ( ! initialized ) { this . setLayout ( new BoxLayout ( this , BoxLayout . PAGE_AXIS ) ) ; instance = this ; progBar = new JProgressBar ( 0 , PanelsManager . getNumPanels ( ) ) ; JPanel progBarPanel = new JPanel ( ) ; progBarPanel . setLayout ( new FlowLayout ( ) ) ; progBarPanel . setOpaque ( false ) ; progBarPanel . add ( progBar ) ; JPanel statusPanel = new JPanel ( ) ; statusPanel . setLayout ( new FlowLayout ( ) ) ; statusPanel . setOpaque ( false ) ; statusPanel . add ( status ) ; this . add ( Box . createVerticalStrut ( 250 ) ) ; this . add ( progBarPanel ) ; this . add ( statusPanel ) ; this . add ( Box . createVerticalStrut ( 250 ) ) ; InitTask task = PanelsManager . getInitTask ( ) ; task . addPropertyChangeListener ( this ) ; task . execute ( ) ; setCursor ( Cursor . getPredefinedCursor ( Cursor . WAIT_CURSOR ) ) ; initialized = true ; } } public void finish ( ) { MainFrame mainFrame = new MainFrame ( ) ; mainFrame", "gt": ". setVisible ( true ) ;", "prediction": ". setVisible ( false ) ;\n", "label": 0}
{"id": 14510, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class LoginDialog extends Dialog { private static final int LOGIN_ID = IDialogConstants . CLIENT_ID + 1 ; private Text userText ; private Text passText ; private Label mesgLabel ; private final String title ; private final String message ; private String username ; private String password ; public LoginDialog ( final Shell parent , final String title , final String message ) { super ( parent ) ; this . title = title ; this . message = message ; } public String getPassword ( ) { return password ; } public void setUsername ( final String username ) { this . username = username ; } public String getUsername ( ) { return username ; } @ Override protected void configureShell ( final Shell shell ) { super . configureShell ( shell ) ; if ( title != null ) { shell . setText ( title ) ; } shell . addControlListener ( new ControlAdapter ( ) { @ Override public void controlResized ( ControlEvent e ) { initializeBounds ( ) ; } } ) ; } @ Override protected Control createDialogArea ( final Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; composite . setLayout ( new GridLayout ( 2 , false ) ) ; mesgLabel = new Label ( composite , SWT . NONE ) ; GridData messageData = new GridData ( SWT . FILL , SWT . CENTER , true , false ) ; messageData . horizontalSpan = 2 ; mesgLabel . setLayoutData ( messageData ) ; Label userLabel = new Label ( composite , SWT . NONE ) ; userLabel . setText ( \"Username:\" ) ; userText = new Text ( composite , SWT . BORDER ) ; userText . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false ) ) ; Label passLabel = new Label ( composite , SWT . NONE ) ; passLabel . setText ( \"Password:\" ) ; passText = new Text ( composite , SWT . BORDER |", "gt": "SWT . PASSWORD ) ;", "prediction": "SWT . CENTER ) ;\n", "label": 1}
{"id": 4679, "input": "<s> package com . sun . tools . javac . code ; import java . util . Locale ; import com . sun . tools . javac . api . Messages ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import static com . sun . tools . javac . code . TypeTags . * ; import static com . sun . tools . javac . code . BoundKind . * ; import static com . sun . tools . javac . code . Flags . * ; public abstract class Printer implements Type . Visitor < String , Locale > , Symbol . Visitor < String , Locale > { List < Type > seenCaptured = List . nil ( ) ; static final int PRIME = 997 ; protected abstract String localize ( Locale locale , String key , Object ... args ) ; protected abstract String capturedVarId ( CapturedType t , Locale locale ) ; public static Printer createStandardPrinter ( final Messages messages ) { return new Printer ( ) { @ Override protected String localize ( Locale locale , String key , Object ... args ) { return messages . getLocalizedString ( locale , key , args ) ; } @ Override protected String capturedVarId ( CapturedType t , Locale locale ) { return ( t . hashCode ( ) & 0xFFFFFFFFL ) % PRIME + \"\" ; } } ; } public String visitTypes ( List < Type > ts , Locale locale ) { ListBuffer < String > sbuf = ListBuffer . lb ( ) ; for ( Type t : ts ) { sbuf . append ( visit ( t , locale ) ) ; } return sbuf . toList ( ) . toString ( ) ; } public String visitSymbols ( List < Symbol > ts , Locale locale ) { ListBuffer < String > sbuf = ListBuffer . lb ( ) ; for ( Symbol t : ts ) { sbuf . append ( visit ( t , locale ) ) ; } return sbuf . toList ( ) . toString ( ) ; } public String visit ( Type t , Locale locale ) { return t . accept ( this , locale ) ; } public String visit ( Symbol s , Locale locale ) { return s . accept ( this , locale ) ; } @ Override public String visitCapturedType ( CapturedType t , Locale locale ) { if ( seenCaptured . contains ( t ) ) return localize ( locale , \"compiler.misc.type.captureof.1\" , capturedVarId ( t , locale ) ) ; else { try { seenCaptured =", "gt": "seenCaptured . prepend ( t ) ;", "prediction": "ListBuffer . lb ( ) ;\n", "label": 0}
{"id": 14514, "input": "<s> package io . beancounter . commons . model ; import java . net . URL ; public class OAuthToken { private URL redirectPage ;", "gt": "public OAuthToken ( URL redirectPage )", "prediction": "public OAuthToken ( URL redirectPage )\n", "label": 1}
{"id": 3240, "input": "<s> @ VisitOrder ( 1 ) public class Order { @ VisitOrder ( 2 ) static double d ; @ VisitOrder ( 3 ) private Order ( ) { } @ VisitOrder ( 4 ) int i ; @ VisitOrder ( 5 ) static class InnerOrder { @ VisitOrder ( 6 ) InnerOrder ( ) { } @ VisitOrder (", "gt": "7 ) String toString ( )", "prediction": "7 ) int j ;\n", "label": 0}
{"id": 14516, "input": "<s> package org . mitre . oauth2 . service . impl ; import java . util . Date ; import java . util . List ; import java . util . Set ; import org . mitre . oauth2 . model . AuthenticationHolderEntity ; import org . mitre . oauth2 . model . ClientDetailsEntity ; import org . mitre . oauth2 . model . OAuth2AccessTokenEntity ; import org . mitre . oauth2 . model . OAuth2RefreshTokenEntity ; import org . mitre . oauth2 . repository . AuthenticationHolderRepository ; import org . mitre . oauth2 . repository . OAuth2TokenRepository ; import org . mitre . oauth2 . service . ClientDetailsEntityService ; import org . mitre . oauth2 . service . OAuth2TokenEntityService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . scheduling . annotation . Scheduled ; import org . springframework . security . authentication . AuthenticationCredentialsNotFoundException ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . oauth2 . common . exceptions . InvalidClientException ; import org . springframework . security . oauth2 . common . exceptions . InvalidTokenException ; import org . springframework . security . oauth2 . provider . AuthorizationRequest ; import org . springframework . security . oauth2 . provider . OAuth2Authentication ; import org . springframework . security . oauth2 . provider . token . TokenEnhancer ; import org . springframework . stereotype . Service ; import com . google . common . collect . Sets ; @ Service public class DefaultOAuth2ProviderTokenService implements OAuth2TokenEntityService { private static Logger logger = LoggerFactory . getLogger ( DefaultOAuth2ProviderTokenService . class ) ; @ Autowired private OAuth2TokenRepository tokenRepository ; @ Autowired private AuthenticationHolderRepository authenticationHolderRepository ; @ Autowired private ClientDetailsEntityService clientDetailsService ; @ Autowired private TokenEnhancer tokenEnhancer ; @ Override public OAuth2AccessTokenEntity createAccessToken ( OAuth2Authentication authentication ) throws AuthenticationException , InvalidClientException { if ( authentication != null && authentication . getAuthorizationRequest ( ) != null ) { AuthorizationRequest clientAuth = authentication . getAuthorizationRequest ( ) ; ClientDetailsEntity client = clientDetailsService . loadClientByClientId ( clientAuth . getClientId ( ) ) ; if ( client == null ) { throw new InvalidClientException ( \"Client not found: \" + clientAuth . getClientId ( ) ) ; } OAuth2AccessTokenEntity token = new OAuth2AccessTokenEntity ( ) ; token . setClient ( client ) ; Set < String > scopes = Sets . newHashSet ( clientAuth . getScope ( ) ) ; token . setScope ( scopes ) ; if ( client . getAccessTokenValiditySeconds ( ) != null && client . getAccessTokenValiditySeconds ( ) > 0 ) { Date expiration = new Date ( System . currentTimeMillis ( ) + ( client . getAccessTokenValiditySeconds ( ) * 1000L ) ) ; token . setExpiration ( expiration ) ; } AuthenticationHolderEntity authHolder = new AuthenticationHolderEntity ( ) ; authHolder . setAuthentication ( authentication ) ; authHolder = authenticationHolderRepository . save ( authHolder ) ; token . setAuthenticationHolder ( authHolder ) ; if ( client . isAllowRefresh ( ) ) { OAuth2RefreshTokenEntity refreshToken = new OAuth2RefreshTokenEntity ( ) ; if ( client . getRefreshTokenValiditySeconds ( ) != null ) { Date expiration = new Date ( System . currentTimeMillis ( ) + ( client . getRefreshTokenValiditySeconds ( ) * 1000L ) ) ; refreshToken . setExpiration ( expiration ) ; } refreshToken . setAuthenticationHolder ( authHolder ) ; refreshToken . setClient ( client ) ; tokenRepository . saveRefreshToken ( refreshToken ) ; token . setRefreshToken ( refreshToken ) ; } tokenEnhancer . enhance ( token , authentication ) ; tokenRepository . saveAccessToken ( token ) ; if ( token . getRefreshToken ( ) != null ) { tokenRepository . saveRefreshToken ( token . getRefreshToken ( ) ) ; } return token ; } throw new AuthenticationCredentialsNotFoundException ( \"No authentication credentials found\" ) ; } @ Override public OAuth2AccessTokenEntity refreshAccessToken ( String refreshTokenValue , Set < String > scope ) throws AuthenticationException { OAuth2RefreshTokenEntity refreshToken = tokenRepository . getRefreshTokenByValue ( refreshTokenValue ) ; if ( refreshToken == null ) { throw new InvalidTokenException ( \"Invalid refresh token: \" + refreshTokenValue ) ; } ClientDetailsEntity client = refreshToken . getClient ( ) ; AuthenticationHolderEntity authHolder = refreshToken . getAuthenticationHolder ( ) ; if ( ! client . isAllowRefresh ( ) ) { throw new InvalidClientException ( \"Client does not allow refreshing access token!\" ) ; } tokenRepository . clearAccessTokensForRefreshToken ( refreshToken ) ; if ( refreshToken . isExpired ( ) ) { tokenRepository . removeRefreshToken ( refreshToken ) ; throw new InvalidTokenException ( \"Expired refresh token: \" + refreshTokenValue ) ; } OAuth2AccessTokenEntity token = new OAuth2AccessTokenEntity ( ) ; Set < String > refreshScopes = refreshToken . getAuthenticationHolder ( ) . getAuthentication ( ) . getAuthorizationRequest ( ) . getScope ( ) ; if ( scope != null && ! scope . isEmpty ( ) ) { if ( refreshScopes != null && refreshScopes . containsAll ( scope ) ) { token . setScope ( scope ) ; } else { token . setScope ( refreshScopes ) ; } } else { token . setScope ( refreshScopes ) ; } token . setClient ( client ) ; if ( client . getAccessTokenValiditySeconds ( ) != null ) { Date expiration = new Date ( System . currentTimeMillis ( ) + ( client . getAccessTokenValiditySeconds ( ) * 1000L ) ) ; token . setExpiration ( expiration ) ; } token . setRefreshToken ( refreshToken ) ; token . setAuthenticationHolder ( authHolder ) ; tokenEnhancer .", "gt": "enhance ( token , authHolder . getAuthentication ( ) ) ;", "prediction": "enhance ( token , authentication ) ;\n", "label": 1}
{"id": 9865, "input": "<s> package objects ; import java . awt . Color ; import javax . swing . JScrollPane ; import javax . swing . JTable ; import javax . swing . border . MatteBorder ; public class MyScrollPane extends JScrollPane { public MyScrollPane ( JTable table ) { super ( table ) ; MatteBorder border = new MatteBorder ( 0 , 0 , 0 , 1 , new Color (", "gt": "34 , 34 , 34 ) ) ;", "prediction": "0 , 0 , 0 ) ) ;\n", "label": 0}
{"id": 14517, "input": "<s> package org . powerbot . game . api . wrappers ; public class RegionOffset { protected final int x , y , plane ; public RegionOffset ( final int x , final int y , final int plane ) { this . x = x ; this . y = y ; this . plane = plane ; } public int getX ( ) { return x ; }", "gt": "public int getY ( )", "prediction": "public int getY ( )\n", "label": 1}
{"id": 9790, "input": "<s> public class MisMatch { static final int constant = 3 ; static int notConstant = 4 ; private static strictfp class NestedClass { } protected abstract class AbstractNestedClass { void myMethod ( ) throws RuntimeException , Error { } abstract void myAbstractMethod ( ) ; } void VarArgsMethod1 ( Number ... num ) { ; } void VarArgsMethod2 ( float f , double d", "gt": ", Number ... num )", "prediction": ")\n", "label": 0}
{"id": 14518, "input": "<s> package distributedServices ; import microFacebook . Validate ; public class FilePacket implements java . io . Serializable { private static final long serialVersionUID = 1L ; public enum Action { CREATE , GET , PUT , APPEND , DELETE ; } public final String fileName ; public final Action action ; public String contents ; public FilePacket ( Action action , String fileName , String contents ) { Validate .", "gt": "notNull ( fileName , \"File name cannot be null.\" ) ;", "prediction": "notNull ( action ) ;\n", "label": 1}
{"id": 3920, "input": "<s> package pkg ; import java . lang . annotation . * ; @", "gt": "Documented public @ interface AnnotationType", "prediction": "SuppressWarnings (\n", "label": 0}
{"id": 14520, "input": "<s> package org . fuzzydb . attrs . unused ; public interface IRange { public boolean contains ( Comparable < Object > val ) ;", "gt": "public Comparable < Object > getMax ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8962, "input": "<s> package main ; import java . awt . Image ; import java . awt . SystemTray ; import java . awt . Toolkit ; import java . awt . TrayIcon ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . io . File ; import javax . swing . UIManager ; import objects . TrayRightClickMenu ; import objects . windows . MainWindow ; import objects . windows . ServerInfoDialog ; import objects . windows . SplashDialog ; import servercontact . Server ; import com . jtattoo . plaf . aluminium . AluminiumLookAndFeel ; import config . AppConfig ; public class Main { public static void main ( String [ ] args ) { createAppDirectories ( ) ; loadLookAndFeel ( ) ; Application . loadUIProperties ( ) ; loadSplashScreen ( ) ; loadServerForm ( ) ; loadMainWindow ( ) ; addShutdownHook ( ) ; } private static void loadTrayIcon ( ) { String tooltip = \"SubsonicJ\" ; Image image = Toolkit . getDefaultToolkit ( ) . getImage ( Main . class . getResource ( \"/res/Tray-icon.png\" ) ) ; TrayIcon trayIcon = new TrayIcon ( image , tooltip , null ) ; final TrayRightClickMenu popupMenu = new TrayRightClickMenu ( ) ; trayIcon . addMouseListener ( new MouseAdapter ( ) { public void mouseReleased ( MouseEvent evt ) { if ( evt . isPopupTrigger ( ) ) { popupMenu . setLocation ( ( evt . getPoint ( ) . x - popupMenu . getWidth ( ) ) , ( evt . getPoint ( ) . y - popupMenu . getHeight ( ) ) ) ; popupMenu . setInvoker ( popupMenu ) ; popupMenu . setVisible ( true ) ; } } } ) ; if ( SystemTray . isSupported ( ) ) { try { SystemTray . getSystemTray ( ) . add ( trayIcon ) ; } catch ( Exception e ) { System . out . println ( \"Main: Can't add tray icon\" ) ; e . printStackTrace ( ) ; } } } private static void addShutdownHook ( ) { Thread hook = new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( \"Exiting SubsonicJ...\" ) ; } } ) ; Runtime . getRuntime ( ) . addShutdownHook ( hook ) ; } private static void loadLookAndFeel ( ) { try { UIManager . setLookAndFeel ( \"com.jtattoo.plaf.aluminium.AluminiumLookAndFeel\" ) ; System . out . println ( \"Main: Custom LookAndFeel set\" ) ; } catch ( Exception ex ) { System . out . println ( \"Main: Can't load Look and Feel...Exiting application\" ) ; System . out . println ( ex ) ; System . exit ( 0 ) ; } } public static void setWindowDecorations ( boolean on ) { if ( on ) { AluminiumLookAndFeel . setCurrentTheme ( Application . decoratedProperties ) ; } else { AluminiumLookAndFeel . setCurrentTheme ( Application . undecoratedProperties ) ; } } private static void createAppDirectories ( ) { String [ ] dirs = new String [ ] { AppConfig . appDirectory , AppConfig . serversDirectory , AppConfig . settingsDirectory , AppConfig . cacheDirectory } ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File directory = new File ( dirs [ i ] ) ; if ( ! directory . exists ( ) ) { try { directory . mkdir ( ) ; } catch ( Exception e ) { System . out . println ( \"Main: Can't create directories for application\" ) ; System . out", "gt": ". println ( e ) ;", "prediction": ". println ( e . getMessage ( ) ) ;\n", "label": 0}
{"id": 14521, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . ui . IElementFactory ; import org . eclipse . ui . IMemento ; public class WorkingSetFactory implements IElementFactory { public IAdaptable createElement ( IMemento memento ) { String workingSetName = memento . getString ( IWorkbenchConstants . TAG_NAME ) ; String label = memento . getString ( IWorkbenchConstants . TAG_LABEL ) ; if ( label == null ) { label = workingSetName ; } String workingSetEditPageId = memento . getString ( IWorkbenchConstants . TAG_EDIT_PAGE_ID ) ; String aggregateString = memento . getString (", "gt": "AbstractWorkingSet . TAG_AGGREGATE ) ;", "prediction": "IWorkbenchConstants . TAG_AGGREGATE ) ;\n", "label": 1}
{"id": 6063, "input": "<s> package writers ; import java . io . * ; import tmpimage . TmpImage ; public class PpmWriter implements ImageWriter { private TmpImage tmp ; private String output ; public PpmWriter ( TmpImage tmp , String output ) { this . tmp = tmp ; this . output = output ; this . writeToFile ( ) ; } public void writeToFile ( ) { try { FileWriter fstream = new FileWriter ( this . output ) ; BufferedWriter out = new BufferedWriter ( fstream ) ; out . write ( \"P3\\n\" ) ; out . write ( this . tmp . getWidth ( ) + \" \" + this . tmp . getHeight ( ) + \" \" ) ; out . write ( \"255\" ) ; int k = 0 ; for ( int i = 0 ; i < this . tmp . getHeight ( ) ; i ++ ) { for (", "gt": "int j = 0 ;", "prediction": "int j = 0 ;\n", "label": 0}
{"id": 14531, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . MarkupValidator ; import org . eclipse . swt . internal . widgets . labelkit . LabelThemeAdapter ; public class Label extends Control { private String text = \"\" ; private Image image ; boolean markupEnabled ; private boolean markupValidationDisabled ; public Label ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; } @ Override void initState ( ) { state |= THEME_BACKGROUND ; } public void setText ( String text ) { checkWidget ( ) ; if ( text == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( ( style & SWT . SEPARATOR ) == 0 ) { if ( markupEnabled && ! markupValidationDisabled ) { MarkupValidator . getInstance ( ) . validate ( text ) ; } this . text = text ; image = null ; } } public String getText ( ) { checkWidget ( ) ; return text ; } public void setImage ( Image image ) { checkWidget ( ) ; if ( ( style & SWT . SEPARATOR ) == 0 ) { this . image = image ; text = \"\" ; } } public Image getImage ( ) { checkWidget ( ) ; return image ; } public void setAlignment ( int alignment ) { checkWidget ( ) ; if ( ( style & SWT . SEPARATOR ) == 0 && ( alignment & ( SWT . LEFT | SWT . RIGHT | SWT . CENTER ) ) != 0 ) { style &= ~ ( SWT . LEFT | SWT . RIGHT | SWT . CENTER ) ; style |= alignment & ( SWT . LEFT | SWT . RIGHT | SWT . CENTER ) ; } } public int getAlignment ( ) { checkWidget ( ) ; int result ; if ( ( style & SWT . SEPARATOR ) != 0 ) { result = 0 ; } else if ( ( style & SWT . LEFT ) != 0 ) { result = SWT . LEFT ; } else if ( ( style & SWT . CENTER ) != 0 ) { result = SWT . CENTER ; } else if ( ( style & SWT . RIGHT ) != 0 ) { result = SWT . RIGHT ; } else { result = SWT . LEFT ; } return result ; } @ Override public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int width = 0 ; int height = 0 ; if ( ( style & SWT . SEPARATOR ) != 0 ) { int lineWidth = getSeparatorLineWidth ( ) ; if ( ( style & SWT . HORIZONTAL ) != 0 ) { width = DEFAULT_WIDTH ; height = lineWidth ; } else { width = lineWidth ; height = DEFAULT_HEIGHT ; } } else if ( image != null ) { Rectangle rect = image . getBounds ( ) ; width = rect . width ; height = rect . height ; } else if ( text . length ( ) > 0 ) { int wrapWidth = 0 ; if ( ( style & SWT . WRAP ) != 0 && wHint != SWT . DEFAULT ) { wrapWidth = wHint ; } Point extent ; if ( markupEnabled ) { extent = TextSizeUtil . markupExtent ( getFont ( ) , text , wrapWidth ) ; } else { extent = Graphics . textExtent ( getFont ( ) , text , wrapWidth ) ; } width = extent . x ; height = extent . y + 2 ; } else { height = Graphics . getCharHeight ( getFont ( ) ) ; } if ( wHint != SWT . DEFAULT ) { width = wHint ; } if ( hHint != SWT . DEFAULT ) { height = hHint ; } int", "gt": "border = getBorderWidth ( ) ;", "prediction": "textWidth = 0 ;\n", "label": 1}
{"id": 6718, "input": "<s> package next . interfaces . controller . widgets ; import next . i . view . widgets . XFlexTable ; import next . i . view . widgets . XSlider ; import next . interfaces . controller . GitXController ; import com . google . gwt . event . logical . shared . ValueChangeEvent ; import com . google . gwt . event . logical . shared . ValueChangeHandler ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . user . client . ui . Label ; public class SliderController extends GitXController { public SliderController ( ) { setTitle ( \"Slider\" ) ; } @ Override public IsWidget getViewContent ( ) { XFlexTable panel = new XFlexTable ( ) ; panel . setCellSpacing ( 40 ) ; HTML label = new HTML ( \"&nbsp;\" ) ; XSlider slider1 = new XSlider ( 75 ) ; XSlider slider2 = new XSlider ( 100 ) ; XSlider slider3 = new XSlider ( 35 ) ; addHandlers ( label , slider1 , slider2 , slider3 ) ; panel . addWidgets ( slider1 , slider2 , slider3 , label ) ; return panel ; } private void addHandlers ( final Label label , XSlider ... sliders ) { for ( final", "gt": "XSlider s : sliders )", "prediction": "XSlider sl : sliders )\n", "label": 0}
{"id": 14553, "input": "<s> package io . beancounter . commons . helper . jedis ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import com . google . inject . name . Named ; import org . apache . commons . pool . impl . GenericObjectPool ; import redis . clients . jedis . JedisPool ; import redis . clients . jedis . JedisPoolConfig ; @ Singleton public class DefaultJedisPoolFactory implements JedisPoolFactory { private static JedisPool pool ; @ Inject public DefaultJedisPoolFactory ( @ Named ( \"address\" ) String address ) { JedisPoolConfig", "gt": "config = new JedisPoolConfig ( ) ;", "prediction": "poolConfig = new JedisPoolConfig ( ) ;\n", "label": 1}
{"id": 6511, "input": "<s> package ar . com . fdvs . dj . test . groups . labels ; import java . awt . Color ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJGroupLabel ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . ImageBanner ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . LabelPosition ; import ar . com . fdvs . dj . domain . constants . Stretching ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class GroupLabelTest3 extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorderBottom ( Border . PEN_1_POINT ) ; headerStyle . setBackgroundColor ( Color . gray ) ; headerStyle . setTextColor ( Color . white ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; headerStyle . setTransparency ( Transparency . OPAQUE ) ; Style headerVariables = new Style ( ) ; headerVariables . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; headerVariables . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitleStyle ( titleStyle ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( false ) . setGrandTotalLegend ( \"Grand Total\" ) . setGrandTotalLegendStyle ( headerVariables ) . setDefaultStyles ( titleStyle , null , headerStyle , detailStyle ) . setPrintColumnNames ( false ) . addImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/logo_fdv_solutions_60.jpg\" , new Integer ( 100 ) , new Integer ( 30 ) , ImageBanner . ALIGN_RIGHT ) . setOddRowBackgroundStyle ( oddRowStyle ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaProductLine = ColumnBuilder . getNew ( ) . setColumnProperty ( \"productLine\" , String . class . getName ( ) ) . setTitle ( \"Product Line\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"Item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . setStyle ( importeStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . setStyle ( importeStyle", "gt": ") . setHeaderStyle ( headerStyle ) . build ( ) ;", "prediction": ") . setHeaderStyle ( headerStyle ) . build ( ) ;\n", "label": 0}
{"id": 14561, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . resources . client . CssResource ; public interface AboutDialog_BinderImpl_GenCss_style extends CssResource {", "gt": "String panel ( ) ;", "prediction": "public void setUp ( ) throws Exception ;\n", "label": 1}
{"id": 9355, "input": "<s> package org . dawb . workbench . plotting . preference ; import org . dawb . common . services . ImageServiceBean . HistoType ; import org . dawb . common . services . HistogramBound ; import org . dawb . common . services . ImageServiceBean . ImageOrigin ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . core . runtime . preferences . AbstractPreferenceInitializer ; import org . eclipse . jface . preference . IPreferenceStore ; public class PlottingPreferenceInitializer extends AbstractPreferenceInitializer { @ Override public void initializeDefaultPreferences ( ) { IPreferenceStore store = Activator . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PlottingConstants . PLOT_X_DATASET , true ) ; store . setDefault ( PlottingConstants . XY_SHOWLEGEND , true ) ; store . setDefault ( PlottingConstants . P_PALETTE , 1 ) ; store . setDefault ( PlottingConstants . ORIGIN_PREF , ImageOrigin . TOP_LEFT . getLabel ( ) ) ; store . setDefault ( PlottingConstants . ASPECT , true ) ; store . setDefault ( PlottingConstants . SHOW_AXES , true ) ; store . setDefault ( PlottingConstants . HISTO , false ) ; store . setDefault ( PlottingConstants . HISTO_PREF , HistoType . MEAN . getLabel ( ) ) ; store . setDefault ( PlottingConstants . MIN_CUT , HistogramBound . DEFAULT_MINIMUM . toString ( ) ) ; store . setDefault ( PlottingConstants . MAX_CUT , HistogramBound . DEFAULT_MAXIMUM . toString ( ) ) ; store . setDefault ( PlottingConstants . NAN_CUT , HistogramBound . DEFAULT_NAN . toString ( ) ) ; store . setDefault ( PlottingConstants . FREE_DRAW_WIDTH , 4 ) ; store .", "gt": "setDefault ( PlottingConstants . MASK_DRAW_MULTIPLE , false ) ;", "prediction": "setDefault ( PlottingConstants . FREE_DRAW_HEIGHT , 4 ) ;\n", "label": 0}
{"id": 14564, "input": "<s> package org . eclipse . ui . menus ; import org . eclipse . core . expressions . Expression ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IContributionManager ; public interface IContributionRoot { public void addContributionItem ( IContributionItem item , Expression visibleWhen ) ; public void registerVisibilityForChild ( IContributionItem", "gt": "item , Expression visibleWhen ) ;", "prediction": "item ) ;\n", "label": 1}
{"id": 331, "input": "<s> package com . sun . tools . javac . code ; import java . util . EnumSet ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import javax . lang . model . element . Modifier ; public class Flags { private Flags ( ) { } public static String toString ( long flags ) { StringBuilder buf = new StringBuilder ( ) ; String sep = \"\" ; for ( Flag s : asFlagSet ( flags ) ) { buf . append ( sep ) ; buf . append ( s ) ; sep = \" \" ; } return buf . toString ( ) ; } public static EnumSet < Flag > asFlagSet ( long mask ) { EnumSet < Flag > flags = EnumSet . noneOf ( Flag . class ) ; if ( ( mask & PUBLIC ) != 0 ) flags . add ( Flag . PUBLIC ) ; if ( ( mask & PRIVATE ) != 0 ) flags . add ( Flag . PRIVATE ) ; if ( ( mask & PROTECTED ) != 0 ) flags . add ( Flag . PROTECTED ) ; if ( ( mask & STATIC ) != 0 ) flags . add ( Flag . STATIC ) ; if ( ( mask & FINAL ) != 0 ) flags . add ( Flag . FINAL ) ; if ( ( mask & SYNCHRONIZED ) != 0 ) flags . add ( Flag . SYNCHRONIZED ) ; if ( ( mask & VOLATILE ) != 0 ) flags . add ( Flag . VOLATILE ) ; if ( ( mask & TRANSIENT ) != 0 ) flags . add ( Flag . TRANSIENT ) ; if ( ( mask & NATIVE ) != 0 ) flags . add ( Flag . NATIVE ) ; if ( ( mask & INTERFACE ) != 0 ) flags . add ( Flag . INTERFACE ) ; if ( ( mask & ABSTRACT ) != 0 ) flags . add ( Flag . ABSTRACT ) ; if ( ( mask & STRICTFP ) != 0 ) flags . add ( Flag . STRICTFP ) ; if ( ( mask & BRIDGE ) != 0 ) flags . add ( Flag . BRIDGE ) ; if ( ( mask & SYNTHETIC ) != 0 ) flags . add ( Flag . SYNTHETIC ) ; if ( ( mask & DEPRECATED ) != 0 ) flags . add ( Flag . DEPRECATED ) ; if ( ( mask & HASINIT ) != 0 ) flags . add ( Flag . HASINIT ) ; if ( ( mask & ENUM ) != 0 ) flags . add ( Flag . ENUM ) ; if ( ( mask & IPROXY ) != 0 ) flags . add ( Flag . IPROXY ) ; if ( ( mask & NOOUTERTHIS ) != 0 ) flags . add ( Flag . NOOUTERTHIS ) ; if ( ( mask & EXISTS ) != 0 ) flags . add ( Flag . EXISTS ) ; if ( ( mask & COMPOUND ) != 0 ) flags . add ( Flag . COMPOUND ) ; if ( ( mask & CLASS_SEEN ) != 0 ) flags . add ( Flag . CLASS_SEEN ) ; if ( ( mask & SOURCE_SEEN ) != 0 ) flags . add ( Flag . SOURCE_SEEN ) ; if ( ( mask & LOCKED ) != 0 ) flags . add ( Flag . LOCKED ) ; if ( ( mask & UNATTRIBUTED ) != 0 ) flags . add ( Flag . UNATTRIBUTED ) ; if ( ( mask & ANONCONSTR ) != 0 ) flags . add ( Flag . ANONCONSTR ) ; if ( ( mask & ACYCLIC ) != 0 ) flags . add ( Flag . ACYCLIC ) ; if ( ( mask & PARAMETER ) != 0 ) flags . add ( Flag . PARAMETER ) ; if ( ( mask & VARARGS ) != 0 ) flags . add ( Flag . VARARGS ) ; return flags ; } public static final int PUBLIC = 1 << 0 ; public static final int PRIVATE = 1 << 1 ; public static final", "gt": "int PROTECTED = 1 << 2 ;", "prediction": "int PROTECTED = 1 << 2 ;\n", "label": 0}
{"id": 14567, "input": "<s> package org . apache . lucene . search . highlight ; import java . util . List ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . search . spans . Spans ; public class SimpleSpanFragmenter implements Fragmenter { private static final int DEFAULT_FRAGMENT_SIZE = 100 ; private int fragmentSize ; private int currentNumFrags ; private int position = - 1 ; private QueryScorer queryScorer ; private int waitForPos = - 1 ; private int textSize ; private TermAttribute termAtt ; private PositionIncrementAttribute posIncAtt ; private OffsetAttribute offsetAtt ; public SimpleSpanFragmenter ( QueryScorer queryScorer ) { this ( queryScorer , DEFAULT_FRAGMENT_SIZE ) ; } public SimpleSpanFragmenter ( QueryScorer queryScorer , int fragmentSize ) { this . fragmentSize = fragmentSize ; this . queryScorer = queryScorer ; } public boolean isNewFragment ( ) { position += posIncAtt . getPositionIncrement ( ) ; if ( waitForPos == position ) { waitForPos = - 1 ; } else if ( waitForPos != - 1 ) { return false ; } WeightedSpanTerm wSpanTerm = queryScorer . getWeightedSpanTerm ( termAtt . term ( ) ) ; if ( wSpanTerm != null ) { List positionSpans = wSpanTerm . getPositionSpans ( ) ; for ( int i = 0 ; i < positionSpans . size ( ) ; i ++ ) { if ( ( ( PositionSpan ) positionSpans . get ( i ) ) . start == position ) { waitForPos = ( ( PositionSpan ) positionSpans . get ( i ) ) . end + 1 ; break ; } } } boolean isNewFrag = offsetAtt . endOffset ( ) >= ( fragmentSize * currentNumFrags ) && ( textSize - offsetAtt . endOffset ( ) ) >= ( fragmentSize", "gt": "> > > 1 ) ;", "prediction": "* currentNumFrags ) ;\n", "label": 1}
{"id": 3045, "input": "<s> class T6711619a { static class A { private void a ( ) { } private A a ; } static class B extends A { private B b ( ) { } private B b ; } static interface I { void i ( ) ; } static interface I1 { void i1 ( ) ; } static class E extends B implements I , I1 { public void i ( ) { } public void i1 ( ) { } } static class C < W extends B & I1 , T extends W > { T t ; W w ; C ( W w , T t ) { this . w = w ; this . t = t ; } } static void testMemberMethods ( C < ? extends A , ? extends I > arg ) { arg . t . a ( ) ; arg . t . b ( ) ; } static void testMemberFields ( C < ? extends A , ? extends I > arg ) { A ta ; B tb ; ta = arg", "gt": ". t . a ;", "prediction": ". t ;\n", "label": 0}
{"id": 14568, "input": "<s> package org . seage . problem . qap . sannealing ; import java . util . Random ; import org . seage . metaheuristic . sannealing . IMoveManager ; import org . seage . metaheuristic . sannealing . Solution ; public class QapMoveManager implements IMoveManager { public Solution getModifiedSolution ( Solution solution ) { QapSolution qapSolution = ( ( QapSolution ) solution ) . clone ( ) ; Random rnd = new Random ( ) ; int qapSolutionLength = qapSolution . getAssign ( ) . length ; int a = rnd . nextInt ( qapSolutionLength ) ; int b = rnd . nextInt ( qapSolutionLength ) ; if ( a != b ) { qapSolution . getAssign ( ) [ a ] = qapSolution . getAssign ( ) [ a ] + qapSolution . getAssign ( ) [ b ] ; qapSolution . getAssign ( ) [ b ] = qapSolution . getAssign ( ) [ a ] - qapSolution . getAssign ( ) [ b ] ; qapSolution . getAssign ( ) [ a ] = qapSolution . getAssign ( ) [ a ] - qapSolution", "gt": ". getAssign ( ) [ b ] ;", "prediction": ". getAssign ( ) [ b ] ;\n", "label": 1}
{"id": 461, "input": "<s> package javax . tools ; import java . util . Locale ; public interface Diagnostic < S > { enum Kind { ERROR , WARNING , MANDATORY_WARNING , NOTE , OTHER , } public final static long NOPOS = - 1 ; Kind getKind ( ) ; S getSource ( ) ; long getPosition ( ) ; long getStartPosition ( ) ; long getEndPosition ( ) ; long getLineNumber ( ) ; long getColumnNumber ( ) ;", "gt": "String getCode ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14575, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . structure . PersistentObject ; import de . uos . igf . db3d . dbms . api . SRID ; public class SpaceDefinition implements PersistentObject { private ScalarOperator sop ; private int srid ; public SpaceDefinition ( double epsilon , int srid ) { this . sop = new ScalarOperator ( epsilon ) ; this . srid = srid ; } public ScalarOperator getScalarOperator ( ) { return this . sop ; } public int getSRID ( ) { return this . srid ; } public String getSridDescription ( ) { return SRID . getSridDescription", "gt": "( this . srid ) ;", "prediction": "( srid ) ;\n", "label": 1}
{"id": 4111, "input": "<s> public class TestHiddenMembers extends JavadocTester { private static final String BUG_ID = \"4492178\" ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = { { BUG_ID + FS + \"pkg\" + FS + \"SubClass.html\" , \"inherited from class pkg.<A HREF=\\\"../pkg/BaseClass.html\\\">BaseClass</A>\" } } ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; public static void main ( String [ ] args ) { TestHiddenMembers", "gt": "tester = new TestHiddenMembers ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 14583, "input": "<s> package com . emf4sw . rdf . resource ; import static org . eclipse . emf . ecore . util . EcoreUtil . getObjectsByType ; import java . util . HashMap ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . impl . ResourceImpl ; import com . emf4sw . rdf . DocumentGraph ; import com . emf4sw . rdf . NamedGraph ; import com . emf4sw . rdf . RDFFactory ; import com . emf4sw . rdf . RDFPackage ; import com . emf4sw . rdf . Triple ; public abstract class RDFResourceImpl extends ResourceImpl implements RDFResource { protected RDFReader < ? > reader ; protected RDFWriter < ? > writer ; public RDFResourceImpl ( ) { super ( ) ; setIntrinsicIDToEObjectMap ( new HashMap < String , EObject > ( ) ) ; } public RDFResourceImpl ( URI uri ) { super ( uri ) ; setIntrinsicIDToEObjectMap ( new HashMap < String , EObject > ( ) ) ; } @ Override public NamedGraph createNamedGraph ( URI uri ) { if ( ! getContents ( ) . isEmpty ( ) ) { throw new IllegalStateException ( \"Cannot create NamedGraph, RDFResource already contains a graph\" ) ; } final NamedGraph aGraph = RDFFactory . eINSTANCE . createNamedGraph ( ) ; aGraph . setURI ( uri . toString ( ) ) ; getContents ( ) . add ( aGraph ) ; return aGraph ; } @ Override public DocumentGraph createGraph ( ) { if ( ! getContents ( ) . isEmpty ( ) ) { throw new IllegalStateException ( \"Cannot create DocumentGraph, RDFResource already contains a graph\" ) ; } final DocumentGraph aGraph = RDFFactory . eINSTANCE . createDocumentGraph ( ) ; getContents ( ) . add ( aGraph ) ; return aGraph ; } @ Override public DocumentGraph getGraph ( ) { if ( getContents ( ) . size ( ) == 0 ) { return null ; } return getContents ( ) . get ( 0 ) == null ? null : ( DocumentGraph ) getContents ( ) . get ( 0 ) ; } @ Override public NamedGraph", "gt": "getNamedGraph ( URI uri )", "prediction": "getNamedGraph ( URI uri )\n", "label": 1}
{"id": 1692, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EObject ;", "gt": "public interface Global extends EObject", "prediction": "import org . eclipse . emf . ecore . InternalEObject ;\n", "label": 0}
{"id": 14589, "input": "<s> package org . fuzzydb . server . internal . whirlwind ; import org . fuzzydb . client . Ref ; public interface RefAware < T > extends Immutable { public", "gt": "void setRef ( Ref < T > ref ) ;", "prediction": "T get ( ) ;\n", "label": 1}
{"id": 6215, "input": "<s> package com . toedter . gwt . demo . contacts . client . activity ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import java . util . ArrayList ; import java . util . List ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . Mock ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . runners . MockitoJUnitRunner ; import org . mockito . stubbing . Answer ; import com . google . gwt . event . shared . EventBus ; import com . google . gwt . place . shared . PlaceController ; import com . google . gwt . user . client . rpc . AsyncCallback ; import com . google . gwt . user . client . ui . AcceptsOneWidget ; import com . toedter . gwt . demo . contacts . client . IClientFactory ; import com . toedter . gwt . demo . contacts . client . IContactServiceAsync ; import com . toedter . gwt . demo . contacts . client . event . ContactViewEvent ; import com . toedter . gwt . demo . contacts . client . place . ContactPlace ; import com . toedter . gwt . demo . contacts . client . ui . IContactListView ; import com . toedter . gwt . demo . contacts . shared . Contact ; @ RunWith ( MockitoJUnitRunner . class ) public class ContactListActivityTest { @ Mock private IClientFactory clientFactoryMock ; @ Mock private PlaceController placeControllerMock ; @ Mock private IContactListView contactListViewMock ; @ Mock private AcceptsOneWidget acceptsOneWidgetMock ; @ Mock private IContactServiceAsync contactServiceAsyncMock ; @ Mock private EventBus eventBusMock ; private List < Contact > contacts ; private Contact contact1 ; private Contact contact2 ; @ SuppressWarnings ( \"unchecked\" ) @ Before public void setUp ( ) throws Exception { when ( clientFactoryMock . getPlaceController ( ) ) . thenReturn ( placeControllerMock ) ; when ( clientFactoryMock . getContactListView ( ) ) . thenReturn ( contactListViewMock ) ; when ( clientFactoryMock . getContactService ( ) ) . thenReturn ( contactServiceAsyncMock ) ; Answer < Void > answer = new Answer < Void > ( ) { @ Override public Void answer ( InvocationOnMock invocation ) { Object [ ] args = invocation . getArguments ( ) ; AsyncCallback < List < Contact > > asyncCallback = ( AsyncCallback < List < Contact > > ) args [ 0 ] ; contact1 = new Contact ( ) ; contact1 . setFirstName ( \"Kai\" ) ; contact1 . setLastName ( \"Toedter\" ) ; contact1 . setEmail ( \"kai@toedter.com\" ) ; contact2 = new Contact ( ) ; contact2 . setFirstName ( \"Kai2\" ) ; contact2 . setLastName ( \"Toedter2\" ) ; contact2 . setEmail ( \"kai2@toedter.com\" ) ; final List < Contact > contacts2 = new ArrayList < Contact > ( ) ; contacts2 . add ( contact1 ) ; contacts2 . add ( contact2 ) ; asyncCallback . onSuccess ( contacts2 ) ; return null ; } } ; doAnswer ( answer ) . when ( contactServiceAsyncMock ) . getAllContacts ( any ( AsyncCallback . class ) ) ; Answer < Void > setContactsAnswer = new Answer < Void > ( ) { @ Override public Void answer ( InvocationOnMock invocation ) throws Throwable { contacts = ( List < Contact > ) invocation . getArguments ( ) [ 0 ] ; return null ; } } ; doAnswer ( setContactsAnswer ) . when ( clientFactoryMock ) . setContacts ( any ( List", "gt": ". class ) ) ;", "prediction": "< Contact > ) ) ;\n", "label": 0}
{"id": 14595, "input": "<s> package org . fuzzydb . attrs . converters ; import static org . junit . Assert . * ; import org . fuzzydb . attrs . converters . StringToEcefVectorConverter ; import org . fuzzydb . attrs . location . EcefVector ; import org . fuzzydb . dto . dimensions . IPoint3D ; import org . junit . Test ; import org . springframework . core . convert . converter . Converter ; public class StringToEcefVectorConverterTest { private final Converter < String , IPoint3D > converter = new StringToEcefVectorConverter ( null ) ; @ Test public void testConvertTupleWithWhitespace ( ) { EcefVector result = ( EcefVector ) converter . convert (", "gt": "\"{ 53.02 , -0.103 }\" ) ;", "prediction": "null ) ;\n", "label": 1}
{"id": 5491, "input": "<s> package org . ofbiz . base . util ; import java . io . PrintStream ; import java . io . PrintWriter ; @ SuppressWarnings ( \"serial\" ) public class GeneralRuntimeException extends RuntimeException { Throwable nested = null ; public GeneralRuntimeException ( ) { super ( ) ; } public GeneralRuntimeException ( String msg ) { super ( msg ) ; } public GeneralRuntimeException ( Throwable nested ) { super ( ) ; this . nested = nested ; } public GeneralRuntimeException ( String msg , Throwable nested ) { super ( msg ) ; this . nested = nested ; } @ Override public String getMessage ( ) { if ( nested != null ) return super . getMessage ( ) + \" (\" + nested . getMessage ( ) + \")\" ;", "gt": "else return super . getMessage ( ) ;", "prediction": "else return super . getMessage ( ) ;\n", "label": 0}
{"id": 14599, "input": "<s> package org . eclipse . core . tests . harness ; import org . eclipse . core . runtime . IProgressMonitor ; public abstract class TestProgressMonitor implements IProgressMonitor { public void beginTask ( String name , int totalWork ) { } public void done ( ) { } public void internalWorked ( double work ) { } public boolean isCanceled ( ) { return false ; } public", "gt": "void setCanceled ( boolean b )", "prediction": "void worked ( double work )\n", "label": 1}
{"id": 3969, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface TryTree extends StatementTree { BlockTree getBlock ( ) ; List < ?", "gt": "extends CatchTree > getCatches ( ) ;", "prediction": "extends Statement > getStatements ( ) ;\n", "label": 0}
{"id": 14603, "input": "<s> package com . talis . hbase . rdf . layout . verticalpartitioning ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . LoaderTuplesNodes ; import com . talis . hbase . rdf . layout . QueryRunnerBase ; public class StoreVerticallyPartitioned extends StoreBaseVerticallyPartitioned { public StoreVerticallyPartitioned ( HBaseRdfConnection connection , StoreDesc desc ) { super ( connection , desc , new QueryRunnerBase ( desc . getStoreName ( ) , connection , QueryRunnerVerticallyPartitioned . class ) , new FmtLayoutVerticallyPartitioned ( desc . getStoreName ( ) , connection ) , new LoaderTuplesNodes ( desc . getStoreName ( ) ,", "gt": "connection , TupleLoaderVerticallyPartitioned . class ) ) ;", "prediction": "connection ) ) ;\n", "label": 1}
{"id": 3550, "input": "<s> import java . lang . annotation . * ; @ RetentionPolicy ( RetentionPolicy", "gt": ". RUNTIME ) public @ interface Recovery", "prediction": ". RUNTIME ) @ Retention ( RetentionPolicy . RUNTIME ) @ RetentionSource ( \"org.eclipse.ui.tests\" ) public class Tests\n", "label": 0}
{"id": 14606, "input": "<s> package org . eclipse . jface . databinding . viewers ; import org . eclipse . core . databinding . property . value . IValueProperty ; import org . eclipse . jface . viewers . Viewer ; public interface IViewerValueProperty extends IValueProperty { public IViewerObservableValue observe ( Viewer viewer ) ; public IViewerObservableValue", "gt": "observeDelayed ( int delay , Viewer viewer ) ;", "prediction": "observe ( Object element ) ;\n", "label": 1}
{"id": 6291, "input": "<s> package org . jjflyboy . tjpeditor ; import java . util . Properties ; import org . eclipse . xtext . Constants ; import org . eclipse . xtext . service . DefaultRuntimeModule ; import com . google . inject . Binder ; import com . google . inject . name . Names ; @ SuppressWarnings ( \"all\" ) public abstract class AbstractProjectRuntimeModule extends DefaultRuntimeModule { protected Properties properties = null ; @ Override public void configure ( Binder binder ) { properties = tryBindProperties ( binder , \"org/jjflyboy/tjpeditor/Project.properties\" ) ; super . configure ( binder ) ; } public void configureLanguageName ( Binder binder ) { binder . bind ( String . class ) . annotatedWith ( Names . named ( Constants . LANGUAGE_NAME ) ) . toInstance ( \"org.jjflyboy.tjpeditor.Project\" ) ; } public void configureFileExtensions ( Binder binder ) { if ( properties == null || properties . getProperty ( Constants . FILE_EXTENSIONS ) == null ) binder . bind ( String . class ) . annotatedWith ( Names . named ( Constants . FILE_EXTENSIONS ) ) . toInstance ( \"tjp,tji\" ) ; } public Class < ? extends org . eclipse . xtext . IGrammarAccess > bindIGrammarAccess ( ) { return org . jjflyboy . tjpeditor . services . ProjectGrammarAccess . class ; } public Class < ? extends org . eclipse . xtext . serializer . sequencer . ISemanticSequencer > bindISemanticSequencer ( ) { return org . jjflyboy . tjpeditor . serializer . ProjectSemanticSequencer . class ; } public Class < ? extends org . eclipse . xtext . serializer . sequencer . ISyntacticSequencer > bindISyntacticSequencer ( ) { return org . jjflyboy . tjpeditor . serializer . ProjectSyntacticSequencer . class ; } public Class < ? extends org . eclipse . xtext . serializer . ISerializer > bindISerializer ( ) { return org . eclipse . xtext . serializer . impl . Serializer . class ; } public Class < ? extends org . eclipse . xtext . parser . IParser > bindIParser ( ) { return org . jjflyboy . tjpeditor . parser . antlr . ProjectParser . class ; } public Class < ? extends org . eclipse . xtext . parser . ITokenToStringConverter > bindITokenToStringConverter ( ) { return org . eclipse . xtext . parser . antlr . AntlrTokenToStringConverter . class ; } public Class < ? extends org . eclipse . xtext . parser", "gt": ". antlr . IAntlrTokenFileProvider > bindIAntlrTokenFileProvider ( )", "prediction": ". ITokenStreamProvider > bindITokenStreamProvider ( )\n", "label": 0}
{"id": 14609, "input": "<s> package org . apache . lucene . benchmark . byTask . utils ; import java . io . IOException ; import java . io . Reader ; public class StringBufferReader extends Reader { private StringBuffer sb ; private int length ; private int next = 0 ; private int mark = 0 ; public StringBufferReader ( StringBuffer sb ) { set ( sb ) ; } private void ensureOpen ( ) throws IOException { if ( sb == null ) { throw new IOException ( \"Stream has already been closed\" ) ; } } public void close ( ) { synchronized ( lock ) { sb = null ; } } public void mark ( int readAheadLimit ) throws IOException { if ( readAheadLimit < 0 ) { throw new IllegalArgumentException ( \"Read-ahead limit cannpt be negative: \" + readAheadLimit ) ; } synchronized ( lock ) { ensureOpen ( ) ; mark = next ; } } public boolean markSupported ( ) { return true ; } public int read ( ) throws IOException { synchronized ( lock ) { ensureOpen ( ) ; return next >= length ? - 1 : sb . charAt ( next ++ ) ; } } public int read ( char cbuf [ ] , int off , int len ) throws IOException { synchronized ( lock ) { ensureOpen ( ) ; if ( off < 0 || off > cbuf . length || len < 0 || off + len > cbuf . length ) { throw new IndexOutOfBoundsException ( \"off=\" + off + \" len=\"", "gt": "+ len + \" cbuf.length=\" + cbuf . length ) ;", "prediction": "+ len + \" cbuf.length=\" + cbuf . length ) ;\n", "label": 1}
{"id": 906, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; public enum OutputFormat { XML , PHP , JSON ,", "gt": "PYTHON , RUBY , ATOM , GEORSS }", "prediction": "JSONObject }\n", "label": 0}
{"id": 14615, "input": "<s> package org . nuxeo . webengine . sites . listeners ; import static org . nuxeo . ecm . core . api . event . DocumentEventTypes . * ; import static org . nuxeo . webengine . sites . utils . SiteConstants . * ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . lang . ArrayUtils ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventListener ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; import org . nuxeo . webengine . sites . utils . SitesRelationsWikiHelper ; public class SitesWikiListener implements EventListener { private static final Log log = LogFactory . getLog ( SitesWikiListener . class ) ; private final String openBracket = \"[\" ; private final String closeBracket = \"]\" ; private final String imageTag = \"image:\" ; public void handleEvent ( Event event ) { String eventName = event . getName ( ) ; if ( ! ( DOCUMENT_UPDATED . equals ( eventName ) || DOCUMENT_CREATED . equals ( eventName ) || BEFORE_DOC_UPDATE . equals ( eventName ) || ABOUT_TO_CREATE . equals ( eventName ) ) ) { return ; } DocumentEventContext docCtx ; if ( event . getContext ( ) instanceof DocumentEventContext ) { docCtx = ( DocumentEventContext ) event . getContext ( ) ; } else { return ; } DocumentModel webPage = docCtx . getSourceDocument ( ) ; if ( webPage == null || ! WEBPAGE . equals ( webPage . getType ( ) ) ) { return ; } try { Boolean isRichText = ( Boolean ) webPage . getPropertyValue ( WEBPAGE_EDITOR ) ; if ( isRichText ) { return ; } WikiProcessingResult result = new WikiProcessingResult ( ) ; if ( BEFORE_DOC_UPDATE . equals ( event . getName ( ) ) || ABOUT_TO_CREATE . equals ( event . getName ( ) ) ) { String wikiContent = ( String ) webPage . getPropertyValue ( WEBPAGE_CONTENT ) ; String basePath = ( String ) webPage . getContextData ( \"basePath\" ) ; if ( basePath == null ) { basePath = \"/nuxeo/site/sites\" ; } String targetObjectPath = ( String ) webPage . getContextData ( \"targetObjectPath\" ) ; result = processWikiContent ( wikiContent , basePath , targetObjectPath ) ; webPage . setPropertyValue ( WEBPAGE_CONTENT , result . wikiContent ) ; SitesRelationsWikiHelper . updateRelations ( webPage , result . relationLinks ) ; } } catch ( ClientException e ) { log . error ( \"SitesWikiListener error...\" , e ) ; } } public class WikiProcessingResult { protected final List < String > relationLinks = new ArrayList < String > ( ) ; protected String wikiContent ; public List < String > getRelationLinks ( ) { return relationLinks ; } public String getWikiContent ( ) { return wikiContent ; } } public WikiProcessingResult processWikiContent ( String wikiContent , String basePath , String targetObjectPath ) { WikiProcessingResult result = new WikiProcessingResult ( ) ; String [ ] wikiLinks = getLinks ( wikiContent ) ; for ( int i = 0 ; i < wikiLinks . length ; i ++ ) { String [ ] splitWikiLinks = StringUtils . split ( wikiLinks [ i ] ) ; String linkString = splitWikiLinks [ 0 ] ; boolean isImageLink = false ; String orgLinkString = linkString ; if ( linkString . startsWith ( imageTag ) ) { isImageLink = true ; linkString = linkString . substring ( 6 ) ; } boolean isNamedLink = splitWikiLinks . length > 1 ; if ( ! ( linkString . startsWith ( \"http://\" ) || linkString . startsWith ( \"https://\" ) || linkString . startsWith ( basePath ) ) ) { String newLinkString ; if ( linkString . startsWith ( \".\" ) ) { newLinkString = basePath + linkString . replace ( \".\" , \"/\" ) ; } else { if ( targetObjectPath != null ) { newLinkString = linkString . replace ( \".\" , \"/\" ) ; newLinkString = targetObjectPath + \"/\" + newLinkString ; } else { newLinkString = linkString ; } } result . relationLinks . add ( newLinkString ) ; if ( ! isNamedLink ) { newLinkString = newLinkString + \" \" + linkString ; } if ( isImageLink ) { newLinkString = imageTag + newLinkString ; } wikiContent = wikiContent . replace ( orgLinkString , newLinkString ) ; } if ( linkString . startsWith ( basePath ) ) { result . relationLinks . add ( linkString ) ; } } result . wikiContent = wikiContent ; return result ; } private", "gt": "String [ ] getLinks ( String content )", "prediction": "void processWikiContent ( String wikiContent , String basePath , String targetObjectPath )\n", "label": 1}
{"id": 9964, "input": "<s> package org . ofbiz . entity . transaction ; import java . sql . Connection ; import java . sql . SQLException ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . CursorConnection ; public class TransactionFactory { public static final String module = TransactionFactory . class . getName ( ) ; public static TransactionFactoryInterface transactionFactory = null ; public static TransactionFactoryInterface getTransactionFactory ( ) { if ( transactionFactory == null ) { synchronized ( TransactionFactory . class ) { if ( transactionFactory == null ) { try { String className = EntityConfigUtil . getTxFactoryClass ( ) ; if ( className == null ) { throw new IllegalStateException ( \"Could not find transaction factory class name definition\" ) ; } Class < ? > tfClass = null ; if ( UtilValidate . isNotEmpty ( className ) ) { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; tfClass = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } } try { transactionFactory = ( TransactionFactoryInterface ) tfClass . newInstance ( ) ; } catch ( IllegalAccessException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } catch ( InstantiationException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } } catch ( SecurityException e ) { Debug . logError (", "gt": "e , module ) ;", "prediction": "e , module ) ;\n", "label": 0}
{"id": 14616, "input": "<s> package io . beancounter . dispatcher . process ; import java . util . HashSet ; import java . util . Set ; import com . google . inject . Inject ; import com . google . inject . name . Named ; import org . apache . camel . builder . RouteBuilder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class DispatcherRoute extends RouteBuilder { private static final Logger LOGGER = LoggerFactory . getLogger ( DispatcherRoute . class ) ; @ Inject @ Named ( \"kestrel.queue.dispatcher.prefix\" ) String queuePrefix ; @ Inject @ Named ( \"kestrel.queue.dispatcher.queues\" ) String queueNames ; public void configure ( ) { errorHandler ( deadLetterChannel ( errorEndpoint ( ) ) ) ; from ( fromEndpoint ( ) ) . multicast ( ) . parallelProcessing ( ) . to ( toEndpoints ( ) ) ; from ( \"jetty:http://0.0.0.0:34590/dispatcher/ping\" ) . transform ( constant ( \"PONG\\n\" ) ) ; } protected String [ ] toEndpoints ( ) { LOGGER . debug ( \"dispatching to queues: {}\" , queueNames ) ; String [ ] queues = queueNames . split ( \",\" ) ; Set < String > urls = new HashSet < String > ( ) ; for ( String queue : queues ) { urls . add ( queuePrefix + queue ) ; } return", "gt": "urls . toArray ( new String [ 0 ] ) ;", "prediction": "urls . toArray ( new String [ urls . size ( ) ] ) ;\n", "label": 1}
{"id": 1616, "input": "<s> package org . gk . ui . client . com . i18n ; import java . util . Date ; import java . util . Map ; import org . gk . ui . client . com . form . gkMap ; import com . google . gwt . i18n . client . DateTimeFormat ; public class CDateTimeFormat extends DateTimeFormat { private static final Map < String , DateTimeFormat > cache = new gkMap ( ) ; protected CDateTimeFormat ( String pattern ) { super ( pattern ) ; } public static DateTimeFormat getFormat ( String pattern ) { DateTimeFormat dtf = cache . get ( pattern ) ; if ( dtf == null ) { dtf = new CDateTimeFormat ( pattern ) ; cache . put ( pattern , dtf ) ; } return dtf ; } @ Override public String format ( Date date ) { String year = DateTimeFormat . getFormat ( PredefinedFormat . YEAR ) . format ( date ) ; String chinese = convertToCYear ( year ) ; String result = super . format ( date ) ; return result . replaceAll ( year , chinese ) ; } @ Override @ SuppressWarnings ( \"deprecation\" ) public Date parseStrict ( String text ) throws IllegalArgumentException { Date result = super . parseStrict ( text ) ; result . setYear ( result . getYear ( ) + 1911 ) ; return result ; } @ Override @ SuppressWarnings ( \"deprecation\" ) public Date parse ( String text ) throws IllegalArgumentException { Date result = super . parse ( text ) ; result . setYear ( result . getYear ( ) + 1911 ) ; return result ; } private String convertToCYear ( String year ) { int value = Integer . parseInt ( year ) - 1911 ; if ( value <= 0 ) { return \"000\" ; } StringBuffer result = new StringBuffer ( String . valueOf ( value ) ) ; if ( result . length ( ) < 3 ) { for ( int i = 3", "gt": "- result . length ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14617, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import org . restlet . example . book . restlet .", "gt": "ch09 . client . MailList . SelectionStyle ;", "prediction": "ch08 . client ;\n", "label": 1}
{"id": 5239, "input": "<s> package java . lang ; public class Byte { public static Byte valueOf ( byte v ) { return new Byte ( v ) ; } public Byte ( byte v ) { value = v ; }", "gt": "public byte byteValue ( )", "prediction": "}\n", "label": 0}
{"id": 14623, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . restHandler ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . util . List ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . Provider ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . DefaultMarshaler ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . interfaces . PublishingMarshalingException ; import org . nuxeo . ecm . webengine . WebEngine ; @ Provider public class RemotePubMessageReader implements MessageBodyReader < RemotePubParam > { public boolean isReadable ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType mt ) { return mt . equals ( RemotePubParam . mediaType ) ; } public RemotePubParam readFrom ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType arg3 , MultivaluedMap arg4 , InputStream is ) throws IOException , WebApplicationException { DefaultMarshaler marshaler = new DefaultMarshaler ( WebEngine . getActiveContext ( ) . getCoreSession ( ) ) ; InputStreamReader isr = new InputStreamReader ( is , \"UTF-8\" ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuffer sb = new StringBuffer ( ) ; int ch ; while ( ( ch = br . read ( ) ) > - 1 ) { sb . append ( ( char ) ch ) ; } br . close ( ) ; String xmlData = sb . toString ( ) ; try { List < Object > params = marshaler", "gt": ". unMarshallParameters ( xmlData ) ;", "prediction": ". marshal ( xmlData ) ;\n", "label": 1}
{"id": 5587, "input": "<s> public class Pos02 { static class A extends Exception { } static class B extends Exception { } static class C extends Exception { } static class C1 extends C { } static class C2 extends C { } enum ExceptionKind { A , B , C1 , C2 } static int caughtExceptions = 0 ; static int caughtRethrownExceptions = 0 ; static void test ( ExceptionKind ekind ) throws A , C1 { try { switch ( ekind ) { case A : throw new A ( ) ; case B : throw new B ( ) ; case C1 : throw new C1 ( ) ; case C2 : throw new C2 ( ) ; } } catch ( final C2 | B ex ) { caughtExceptions ++ ; } catch ( final C | A ex ) { caughtExceptions ++ ; throw ex ; } } public static void main ( String [ ] args ) { for ( ExceptionKind ekind : ExceptionKind . values ( ) ) { try { test ( ekind ) ; } catch ( final C1 | A ex ) { caughtRethrownExceptions ++ ; } } if ( caughtExceptions", "gt": "!= 4 && caughtRethrownExceptions == 2 )", "prediction": "!= 0 )\n", "label": 0}
{"id": 14626, "input": "<s> package org . eclipse . ui . handlers ; import java . util . Hashtable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . jface . commands . RadioState ; public final class RegistryRadioState extends RadioState implements IExecutableExtension { private final void readDefault ( final String defaultString ) { if ( \"true\" . equalsIgnoreCase ( defaultString ) ) { setValue ( Boolean . TRUE ) ; } } private final void readPersisted ( final String persistedString ) { if ( \"false\" . equalsIgnoreCase ( persistedString ) ) { setShouldPersist ( false ) ; } setShouldPersist ( true ) ; } public final void setInitializationData ( final IConfigurationElement configurationElement , final String propertyName , final Object data ) { if ( data instanceof String ) { setRadioGroupIdentifier ( ( String ) data ) ; setValue ( Boolean . FALSE ) ; setShouldPersist ( true ) ; } else if", "gt": "( data instanceof Hashtable )", "prediction": "( data instanceof String [ ] )\n", "label": 1}
{"id": 3555, "input": "<s> package domain ; import java . io . Serializable ; import java . util . Set ; import javax . persistence . * ; @ Entity @ NamedQuery ( name = \"getTeachersByName\" , query = \"SELECT teacher FROM Teacher teacher WHERE teacher.name LIKE :pattern\" ) public class Teacher implements Serializable { private static final long serialVersionUID = 1L ; @ Id @ SequenceGenerator ( name = \"TEACHER_ID_GENERATOR\" , sequenceName = \"TEACHER_ID_SEQ\" ) @ GeneratedValue ( strategy = GenerationType . SEQUENCE , generator = \"TEACHER_ID_GENERATOR\" ) private Integer id ; private String name ; @ OneToMany ( mappedBy = \"teacher\" ) private Set < CourseOccasion > courseOccasions ; public Teacher ( ) { } public Integer getId ( ) { return this . id ; } public void setId ( Integer id ) { this . id = id ; } public String getName ( ) { return this . name ; } public void setName ( String name ) { this . name = name ; } public void setCourseOccasions ( Set < CourseOccasion > courseOccasions ) { this . courseOccasions = courseOccasions ; } public Set <", "gt": "CourseOccasion > getCourseOccasions ( )", "prediction": "String > getName ( )\n", "label": 0}
{"id": 14631, "input": "<s> package org . fuzzydb . util ; import java . io . IOException ; import java . util . Map ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; public class CsvReaderBkgnd extends CsvReader implements Runnable { private Thread thread ; private BlockingQueue < Object > queue = new ArrayBlockingQueue < Object > ( 10 ) ; private Object [ ] packet ; private int next = 0 ; public CsvReaderBkgnd ( String file , boolean stripQuotes ) throws IOException { super ( file , stripQuotes , false ) ; } public CsvReaderBkgnd ( String file , boolean stripQuotes , boolean hasHeader ) throws IOException { super ( file , stripQuotes , hasHeader , false ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public Map < String , Object > readLine ( ) throws IOException , UnsupportedTypeException , GarbageLineException { start ( ) ; Object o = null ; try { if ( packet == null ) { packet = ( Object [ ] ) queue . take ( ) ; next = 0 ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } o = packet [ next ++ ] ; if ( next == packet . length ) { packet = null ; } if ( o instanceof UnsupportedTypeException ) { throw ( UnsupportedTypeException ) o ; } if ( o instanceof GarbageLineException ) { throw ( GarbageLineException ) o ; } if ( o instanceof IOException ) { throw ( IOException ) o ; } return ( Map < String , Object > ) o ; } private void start ( ) { if ( thread == null ) { thread = new Thread ( this ) ; thread . start ( ) ; } } public void run ( ) { int size = 100 ; Map < String , Object > map ; Object [ ] stuff = new Object [ size ] ; int i = 0 ; for ( ; ; ) { try { map = super . readLine ( ) ; } catch ( IOException e ) { stuff [ i ] = e ; try { queue . put ( stuff ) ; } catch ( InterruptedException e1 ) { throw", "gt": "new RuntimeException ( e1 ) ;", "prediction": "new RuntimeException ( e1 ) ;\n", "label": 1}
{"id": 4238, "input": "<s> package org . remast . baralga . gui . model ; @ SuppressWarnings ( \"serial\" ) public class ProjectActivityStateException extends Exception { public", "gt": "ProjectActivityStateException ( final String message )", "prediction": "ProjectActivityStateException ( )\n", "label": 0}
{"id": 14632, "input": "<s> package play . modules . cream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . lang . annotation . Annotation ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import javax . jcr . Repository ; import javax . jcr . Session ; import javax . jcr . SimpleCredentials ; import org . apache . commons . lang . StringUtils ; import org . apache . jackrabbit . core . TransientRepository ; import org . jcrom . Jcrom ; import org . jcrom . annotations . JcrNode ; import play . Invoker . InvocationContext ; import play . Logger ; import play . Play ; import play . PlayPlugin ; import play . classloading . ApplicationClasses . ApplicationClass ; import play . exceptions . UnexpectedException ; import play . modules . cream . annotations . JcrNoSession ; import play . modules . cream . annotations . JcrSession ; import play . modules . cream . helpers . JcrRepositoryCreationHelper ; import play . modules . cream . helpers . JcrRepositoryHelper ; import play . modules . cream . ocm . JcrMapper ; public class JcrPlugin extends PlayPlugin { @ Override public void afterInvocation ( ) { JCR . closeSession ( ) ; } @ Override public void beforeInvocation ( ) { InvocationContext current = InvocationContext . current ( ) ; if ( ! current . isAnnotationPresent ( JcrNoSession . class ) ) { Session currentSession = createCurrentSession ( current ) ; JCR . addSession ( currentSession ) ; } } @ Override @ SuppressWarnings ( \"unchecked\" ) public Object bind ( String name , Class clazz , java . lang . reflect . Type type , Annotation [ ] annotations , Map < String , String [ ] > params ) { if ( Model . class . isAssignableFrom ( clazz ) ) { String keyName = Model . Manager . factoryFor ( clazz ) . keyName ( ) ; String idKey = name + \".\" + keyName ; if ( params . containsKey ( idKey ) && params . get ( idKey ) . length > 0 && params . get ( idKey ) [ 0 ] != null && params . get ( idKey ) [ 0 ] . trim ( ) . length ( ) > 0 ) { String id = params . get ( idKey ) [ 0 ] ; try { Model o = ( Model ) JcrMapper . loadByUUID ( clazz , id ) ; if ( o != null ) { return Model . edit ( o , name , params , annotations ) ; } } catch ( Exception e ) { throw new UnexpectedException ( e ) ; } } return Model . create ( clazz , name , params , annotations ) ; } return super . bind ( name , clazz , type , annotations , params ) ; } @ Override public Object bind ( String name , Object o , Map < String , String [ ] > params ) { if ( o instanceof Model ) { return Model . edit ( o , name , params , null ) ; } return null ; } @ Override public void enhance ( ApplicationClass applicationClass ) throws Exception { new JcrEnhancer ( ) . enhanceThisClass ( applicationClass ) ; } @ Override public String getStatus ( ) { StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; out . println ( \"Jcr Repository:\" ) ; out . println ( \"~~~~~~~~~~~~~~\" ) ; if ( JcrRepositoryHelper . repository == null ) { out . println ( \"(not yet initialized)\" ) ; return sw . toString ( ) ; } out . println ( \"name: \" + JcrRepositoryHelper . repository . getDescriptor ( Repository . REP_NAME_DESC ) ) ; out . println ( \"version: \" + JcrRepositoryHelper . repository . getDescriptor ( Repository . REP_VERSION_DESC ) ) ; out . println ( \"default workspace: \" + JcrRepositoryHelper . defaultWorkspace ) ; out . println ( \"\\nJcr Mapped Classes:\" ) ; out . println ( \"~~~~~~~~~~~~~~~~~~\" ) ; for ( Class clazz : JcrMapper . jcrom . getMappedClasses ( ) ) { out . println ( clazz . getName ( ) ) ; } return sw", "gt": ". toString ( ) ;", "prediction": ". toString ( ) ;\n", "label": 1}
{"id": 9447, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Ghast ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaGhast ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftGhast implements LizaGhast { private Ghast ghast ; public LizaCraftGhast ( Ghast ghast ) { this . ghast = ghast ; } @ Override public void damage ( int amount ) { this . ghast . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . ghast . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . ghast . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . ghast . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . ghast . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . ghast . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . ghast . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . ghast . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . ghast . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this", "gt": ". ghast . getLastTwoTargetBlocks ( transparent , maxDistance ) ;", "prediction": ". ghast . getLineOfSight ( transparent , maxDistance ) ;\n", "label": 0}
{"id": 14636, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . safehtml . shared . SafeHtmlUtils ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiBinderUtil ; import com . google . gwt . user . client . ui . Widget ; public class AboutDialog_BinderImpl implements UiBinder < com . google . gwt . user . client . ui . Widget , org . restlet . example . book . restlet . ch09 . client . AboutDialog > , org . restlet . example . book . restlet . ch09 . client . AboutDialog . Binder { interface Template extends SafeHtmlTemplates { @ Template ( \"<div class='{0}'></div> <div class='{1}'> This sample application demonstrates the construction of a complex user interface using GWT's built-in widgets. Have a look at the code to see how easy it is to build your own apps! </div> <div class='{2}'> <span id='{3}'></span> </div>\" ) SafeHtml html1 ( String arg0 , String arg1 , String arg2 , String arg3 ) ; } Template template = GWT . create ( Template . class ) ; public com . google . gwt . user . client . ui . Widget createAndBindUi ( final org . restlet . example . book . restlet . ch09 . client . AboutDialog owner ) { org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay = ( org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle ) GWT . create ( org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle . class ) ; com . google . gwt . resources . client . ImageResource logo = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay . logo ( ) ; org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenCss_style style = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay . style ( ) ; java . lang . String domId0 = com . google . gwt . dom . client . Document . get ( ) . createUniqueId ( ) ; com . google . gwt . user . client . ui . Button closeButton = ( com . google . gwt . user . client . ui . Button ) GWT . create ( com . google . gwt . user . client . ui . Button . class ) ; com . google . gwt . user . client . ui . HTMLPanel f_HTMLPanel1 = new com . google . gwt . user . client . ui . HTMLPanel ( template . html1 ( \"\" + style . logo ( ) + \"\" , \"\" + style . aboutText ( ) + \"\" , \"\" + style . buttons ( ) + \"\" , domId0 ) . asString ( ) ) ; closeButton . setText ( \"Close\" ) ; f_HTMLPanel1 . setStyleName ( \"\" + style . panel ( ) + \"\" ) ; f_HTMLPanel1 . setWidth ( \"24em\" ) ; UiBinderUtil . TempAttachment attachRecord0 = UiBinderUtil . attachToDom ( f_HTMLPanel1 . getElement ( ) ) ; com . google . gwt . user . client . Element domId0Element = com . google . gwt . dom . client . Document . get ( ) . getElementById ( domId0 ) . cast ( ) ;", "gt": "attachRecord0 . detach ( ) ;", "prediction": "if ( domId0Element != null )\n", "label": 1}
{"id": 2356, "input": "<s> package models ; import java . util . List ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . Id ; import play . db . ebean . Model ; @ Entity public class Device extends Model { private static final long serialVersionUID = 1L ; @ Id public Long id ; @ Column ( columnDefinition = \"TEXT\" ) public String registrationID ; @ Column ( columnDefinition = \"TEXT\" ) public String authorizationToken ; public static Finder < Long , Device > find = new Finder < Long , Device > ( Long . class , Device . class ) ; public static List < Device > all ( ) { return find . all ( ) ; } public static Device get ( Long id ) { return find . byId ( id ) ; }", "gt": "public static Device getDeviceFromRegistrationID ( Long registrationID )", "prediction": "}\n", "label": 0}
{"id": 14637, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . * ; import oracle . jdbc . * ; import oracle . jdbc . pool . OracleDataSource ; class SendBatch { public static void main ( String args [ ] ) throws SQLException { String url = \"jdbc:oracle:oci8:@\" ; try { String url1 = System . getProperty ( \"JDBC_URL\" ) ; if ( url1 != null ) url = url1 ; } catch ( Exception e ) { } OracleDataSource ods = new OracleDataSource ( ) ; ods . setUser ( \"hr\" ) ; ods . setPassword ( \"hr\" ) ; ods . setURL ( url ) ; Connection conn = ods . getConnection ( ) ; Statement stmt = conn . createStatement ( ) ; stmt . execute ( \"delete from departments where department_id > 2000\" ) ; ( ( OracleConnection ) conn ) . setDefaultExecuteBatch ( 50 ) ; PreparedStatement ps = conn . prepareStatement ( \"insert into departments values (?, ?, ?, ?)\" ) ; ps . setInt ( 1 , 2010 ) ; ps . setString ( 2 , \"Import\" ) ; ps . setInt ( 3 , 114 ) ; ps . setInt ( 4 , 1700 ) ; System . out . println ( ps . executeUpdate ( ) ) ; ps . setInt ( 1 , 2020 ) ; ps . setString ( 2 , \"Export\" ) ; ps . setInt ( 3 , 145 ) ; ps . setInt ( 4 , 2500 ) ; int rows = ps . executeUpdate ( ) ; System . out . println ( \"Number of rows updated before calling sendBatch: \" + rows ) ; rows =", "gt": "( ( OraclePreparedStatement ) ps ) . sendBatch ( ) ;", "prediction": "ps . executeUpdate ( ) ;\n", "label": 1}
{"id": 1576, "input": "<s> package org . dawb . workbench . ui . editors . test ; import org . junit . runner . RunWith ; import org . junit . runners . Suite . SuiteClasses ; @ RunWith ( org . junit . runners . Suite . class ) @ SuiteClasses ( { EditorsTest . class , EditorStressTest . class , LargeFilesTest . class , SWTXYStressTest . class , SWTXYUpdateTest . class , SWTXYAxisTest . class , SWTXYAxisUpdateTest .", "gt": "class , SWTXYRegionsTest . class , SWTXYTraceTest . class }", "prediction": "class }\n", "label": 0}
{"id": 14640, "input": "<s> package org . seage . grammar . iif ; import org . seage . data . DataNode ; import org . seage . grammar . Symbol ; import org . seage . grammar . GrammarRule ; import org . seage . grammar . NonterminalSymbol ; import java . util . * ; public class FVariableGrammarRule extends GrammarRule { private static final long serialVersionUID = - 4347619039586359678L ; public FVariableGrammarRule ( int uniqueId ) { super ( new NonterminalSymbol ( \"F\" ) , new Vector < Symbol > ( ) , uniqueId ) ; right . add ( new NonterminalSymbol ( \"VAR\" ) ) ; } public Object eval ( DataNode symbolTable , NonterminalSymbol treePos ) throws Exception { Vector < Symbol > children = treePos . getChildren ( ) ; if ( children . size ( ) != 1 ) throw new Exception ( \"Arity error: expected 1 children, found: \" + children . size ( ) ) ; Object o = symbolTable . getValue ( children . get ( 0 ) . eval ( symbolTable ) . toString ( ) ) ; if ( o == null ) { return 0 ; } return o ; } public Symbol", "gt": "optimize ( NonterminalSymbol treePos ) throws Exception", "prediction": "getSymbol ( )\n", "label": 1}
{"id": 7659, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Arrays ; import java . io . * ; import static java . util . Collections . * ; public class ClassDeclApf implements AnnotationProcessorFactory { static int round = - 1 ; private static final Collection < String > supportedAnnotations = unmodifiableCollection ( Arrays . asList ( \"*\" ) ) ; private static final Collection < String > supportedOptions = emptySet ( ) ; public Collection < String > supportedAnnotationTypes ( ) { return supportedAnnotations ; } public Collection < String > supportedOptions ( ) { return supportedOptions ; } public AnnotationProcessor getProcessorFor ( Set < AnnotationTypeDeclaration > atds , AnnotationProcessorEnvironment env ) { return new ClassDeclAp ( env ) ; } private static class ClassDeclAp implements AnnotationProcessor { private final AnnotationProcessorEnvironment env ; ClassDeclAp ( AnnotationProcessorEnvironment env ) { this . env = env ; } void drain ( InputStream is , OutputStream os ) { try { while ( is . available ( ) > 0 ) os . write ( is . read ( ) ) ; } catch ( java . io . IOException ioe ) { throw new RuntimeException ( ioe ) ; } } public void process ( ) { int size = env . getSpecifiedTypeDeclarations ( ) . size ( ) ; try { round ++ ; switch ( size ) { case 0 : if ( round == 0 ) { drain ( new FileInputStream ( \"./tmp/classes/Round1Class.class\" ) , env . getFiler ( ) . createClassFile ( \"Round1Class\" ) ) ; } else throw new RuntimeException ( \"Got \" + size + \" decl's in round \" + round ) ; break ; case 1 : if", "gt": "( round == 1 )", "prediction": "( round == 1 )\n", "label": 0}
{"id": 14641, "input": "<s> package agents ; import sim . util . Bag ; public class BattleHistories { private boolean isAttacker = false ; private Bag battles = new Bag ( ) ; public long [ ] attacks = new long [ 43 ] ; public long [ ] lastPeriod = new long [ 43 ] ; public long [ ] wins = new long [ 43 ] ; public double [ ] avgAttackers = new double [ 43 ] ; public double [ ] minAttackers = new double [ 43 ] ; public double [ ] maxAttackers = new double [ 43 ] ; public double [ ] avgDefenders = new double [ 43 ] ; public double [ ] minDefenders = new double [ 43 ] ; public double [ ] maxDefenders = new double [ 43 ] ; public double [ ] attackRatio = new double [ 43 ] ; public BattleHistories ( boolean isAttacker ) { this . isAttacker = isAttacker ; } public void add ( BattleHistory battle ) { battles . add ( battle ) ; int territoryID ; if ( isAttacker ) { territoryID = battle . getAttackerID ( ) ; } else { territoryID = battle . getDefenderID ( ) ; } attacks [ territoryID ] ++ ; lastPeriod [ territoryID ] = battle . getPeriod ( ) ; if ( battle . isYouWon ( ) ) { wins [ territoryID ] ++ ; } if ( attacks [ territoryID ] <= 1 ) { avgAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; minAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; maxAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; avgDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; minDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; maxDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; if ( battle . getSoldiersDefending ( ) != 0 ) { attackRatio [ territoryID ] = battle . getSoldiersAttacking ( ) / battle . getSoldiersDefending ( ) ; } } else { avgAttackers [ territoryID ] = ( ( avgAttackers [ territoryID ] * ( attacks [ territoryID ] - 1 ) ) + battle . getSoldiersAttacking ( ) ) / attacks [ territoryID ] ; if ( battle . getSoldiersAttacking ( ) < minAttackers [ territoryID ] ) { minAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; } if ( battle . getSoldiersAttacking ( ) > maxAttackers [ territoryID ] ) { maxAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; } avgDefenders [ territoryID ] = ( ( avgDefenders [ territoryID ] * ( attacks [ territoryID ] - 1 ) ) + battle . getSoldiersDefending ( ) ) / attacks [ territoryID ] ; if ( battle . getSoldiersDefending ( ) < minDefenders [ territoryID ] ) { minDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; } if ( battle . getSoldiersDefending ( ) > maxDefenders [ territoryID ] ) { maxDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; } if ( battle . getSoldiersDefending ( ) != 0 ) { attackRatio [ territoryID ] = battle . getSoldiersAttacking ( ) / battle . getSoldiersDefending ( ) ; attackRatio [ territoryID ] = ( ( avgAttackers [ territoryID ] * ( attacks [ territoryID ] - 1 ) ) + battle . getSoldiersAttacking ( ) ) / attacks [ territoryID ] ; } } } public Bag getAllAttacksBy ( int territoryID ) { Bag b = new Bag ( ) ; BattleHistory tempBattle ; for ( int i = 0 ; i < battles . numObjs ; i ++ ) { tempBattle = ( ( BattleHistory ) battles . get", "gt": "( i ) ) ;", "prediction": "( i ) ) ;\n", "label": 1}
{"id": 4676, "input": "<s> package src ; import java . io . File ; import org . bukkit . event . block . BlockBreakEvent ; import org . bukkit . event . player . PlayerJoinEvent ; import org . bukkit . event . player . PlayerQuitEvent ; import LizaCraft . LizaCraftTestModule ; public class BobTest { public static void main ( String [ ] args ) { File plugin = new File ( \"bobplugin.jar\" ) ; if ( plugin . exists ( ) ) { LizaCraftTestModule testModule = new LizaCraftTestModule ( \"Bob's Test\" ) ; testModule . startModule ( ) ; testModule . getServer ( ) ; testModule . enableEvents ( ) ; testModule . getEventListener ( ) . registerEvent ( PlayerJoinEvent . class ) ; testModule . getEventListener ( ) . registerEvent ( BlockBreakEvent . class ) ; testModule . getEventListener ( ) . registerEvent ( PlayerQuitEvent . class ) ; testModule . waitForEvent ( PlayerJoinEvent . class ) ; testModule . waitForEvent ( BlockBreakEvent . class ) ; testModule .", "gt": "getServer ( ) . broadcastMessage ( \"Loading plugin now\" ) ;", "prediction": "waitForEvent ( PlayerQuitEvent . class ) ;\n", "label": 0}
{"id": 14644, "input": "<s> package br . org . archimedes . extend ; import static org . junit . Assert . assertEquals ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . dimension . Dimension ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . extend . interfaces . Extender ; import br . org . archimedes . infiniteline . InfiniteLine ; import br . org . archimedes . leader . Leader ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; import br . org . archimedes . semiline . Semiline ; import br . org . archimedes . stub . StubElement ; import br . org . archimedes . text . Text ; public class ExtendManagerTest extends Tester { private static final Map < Class < ? extends Element > , Extender > EMPTY_MAP = Collections . emptyMap ( ) ; private static final Collection < Element > EMPTY_LIST = Collections . emptyList ( ) ; private ExtendManager manager ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; manager = new ExtendManager ( ) ; } @ Test public void dontModifyElementWithNoExtender ( ) throws Exception { MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( EMPTY_MAP ) ; ExtendManager manager = new ExtendManager ( extenderEPLoader ) ; Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; manager . extend ( line , EMPTY_LIST , new Point ( 0.0 , 0.0 ) ) ; assertEquals ( line , new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ) ; } @ Test ( expected = NullArgumentException . class ) public void callMockedExtenderForExistentExtender ( ) throws Exception { final Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; final Collection < Element > reference = EMPTY_LIST ; final Point point = new Point ( 0.0 , 0.0 ) ; Extender extenderMockado = new Extender ( ) { public Element extend ( Element element , Collection < Element > references , Point click ) throws NullArgumentException { assertEquals ( line , element ) ; assertEquals ( reference , references ) ; assertEquals ( point , click ) ; throw new NullArgumentException ( ) ; } public Collection < Element > getInfiniteExtensionElements ( Element element ) throws IllegalArgumentException { return null ; } } ; HashMap < Class < ? extends Element > , Extender > extenderMap = new HashMap < Class < ? extends Element > , Extender > ( ) ; extenderMap . put ( Line . class , extenderMockado ) ; MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( extenderMap ) ; ExtendManager manager = new ExtendManager ( extenderEPLoader ) ; manager . extend ( line , reference , point ) ; } @ Test public void testExtensionElementsArc ( ) throws Exception { Arc arc = new Arc ( new Point ( - 1 , 0 ) , new Point ( 0 , 1 ) , new Point ( 1 , 0 ) ) ; Circle circle = new Circle ( new Point ( 0 , 0 ) , 1.0 ) ; Collection < Element > expected = new ArrayList < Element > ( 1 ) ; expected . add ( circle ) ; Collection < Element > extension = manager . getInfiniteExtensionElements ( arc ) ; assertCollectionTheSame ( expected , extension ) ; } @ Test public void testExtensionElementsCircle ( ) throws Exception { Circle circle = new Circle ( new Point ( 0 , 0 ) , 1.0 ) ; Collection < Element > expected = new ArrayList < Element > ( 1 ) ; expected . add ( circle ) ; Collection < Element > extension = manager . getInfiniteExtensionElements ( circle ) ; assertCollectionTheSame ( expected , extension ) ; } @ Test public void testExtensionElementsDimension ( ) throws Exception { Dimension dimension = new Dimension ( new Point ( 1 , 1 ) , new Point ( 2 , 2 ) , new Point ( 3 , 4 ) , new Double ( 10 ) ) ; Collection < Element > expected = new ArrayList < Element > ( 1 ) ; expected . add ( dimension ) ; Collection < Element > extension = manager . getInfiniteExtensionElements ( dimension ) ; assertCollectionTheSame ( expected , extension ) ; } @ Test public void testExtensionElementsInifiniteLine ( ) throws Exception { InfiniteLine infiniteLine = new InfiniteLine ( new Point ( 1 , 0 ) , new Point ( 0 , 1 ) ) ; Collection < Element > expected = new ArrayList < Element > ( 1 ) ; expected . add ( infiniteLine ) ; Collection < Element > extension = manager . getInfiniteExtensionElements ( infiniteLine ) ; assertCollectionTheSame ( expected , extension ) ; } @ Test public void testExtensionElementsLeader ( ) throws Exception { Leader leader = new Leader ( new Point ( 1 , 1 ) , new Point ( 2 , 2 )", "gt": ", new Point ( 3 , 4 ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3179, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Length extends TaskAttribute {", "gt": "DurationQuantity getLength ( ) ;", "prediction": "public String toString ( ) ;\n", "label": 0}
{"id": 14649, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . resources . QueryParamTestService ; public class QueryParamTest extends JaxRsTestCase { public void checkBothGiven ( String subPath ) throws IOException { Response response = get ( subPath + \"?firstname=Angela&lastname=Merkel\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Angela Merkel\" , response . getEntity ( ) . getText ( ) ) ; response = get ( subPath + \"?lastname=Merkel&firstname=Angela\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Angela Merkel\" , response . getEntity ( ) . getText ( ) ) ; } private void checkMult ( String relPath , String res0 , String res1 , String res2 ) throws IOException { Response response = get ( relPath ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res0 , response . getEntity ( ) . getText ( ) ) ; response = get ( relPath + \"?qp=1\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res1 , response . getEntity ( ) . getText ( ) ) ; response = get ( relPath + \"?qp=1&qp=2\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res2 , response . getEntity ( ) . getText ( ) ) ; } public void checkOneGiven ( String subPath ) throws IOException { Response response = get ( subPath + \"?firstname=Goofy\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Goofy null\" , response . getEntity ( ) . getText ( ) ) ; response = get ( subPath + \"?lastname=Goofy\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"null Goofy\" , response . getEntity ( ) . getText ( ) ) ; } @ Override protected Application getApplication ( ) { final Application appConfig = new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( QueryParamTestService . class ) ; } } ; return appConfig ; } public void testA ( ) throws IOException { checkBothGiven ( \"a\" ) ; checkOneGiven ( \"a\" ) ; } public void testCheckUnmodifiable ( ) { final Response response = get ( \"checkUnmodifiable\" ) ; assertTrue ( \"The List annotated with @QueryParam must not be modifiable\" , response . getStatus ( ) . isSuccess ( ) ) ; } public void testDecoded ( ) throws IOException { final Response response = get ( \"qpDecoded?firstname=George%20U.&lastname=Bush\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"George U. Bush\" , response . getEntity ( ) . getText ( ) ) ; } public void testEncodedA ( ) throws IOException { final Response response = get ( \"encodedA?firstname=George%20U.&lastname=Bush\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"George%20U. Bush\" , response . getEntity ( ) . getText ( ) ) ; } public void testFieldDecoded ( ) throws Exception { final Response response1 = get ( \"decoded?decoded=abc\" ) ; sysOutEntityIfError ( response1 ) ; assertEquals ( Status . SUCCESS_OK , response1 . getStatus ( ) ) ; assertEquals ( \"abc\" , response1 . getEntity ( ) . getText ( ) ) ; final Response response2 = get ( \"decoded?decoded=%20\" ) ; sysOutEntityIfError ( response2 ) ; assertEquals ( Status . SUCCESS_OK , response2 . getStatus ( ) ) ; assertEquals ( \" \" , response2 . getEntity ( ) . getText ( ) ) ; } public void", "gt": "testFieldEncoded ( ) throws Exception", "prediction": "testDecodedUnmodifiable ( ) throws Exception\n", "label": 1}
{"id": 942, "input": "<s> package com . mapr . storm ; import backtype . storm . task . OutputCollector ; import backtype . storm . task . TopologyContext ; import backtype . storm . topology . IRichBolt ; import backtype . storm . topology . OutputFieldsDeclarer ; import backtype . storm . tuple . Fields ; import backtype . storm . tuple . Tuple ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import java . util . Arrays ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Queue ; public class TimeLimitedJoin implements IRichBolt { private final long expirationTime ; private final int maxTuplesToRetain ; private final Fields joinKey ; private OutputCollector collector ; private final Queue < TimedTuple > queue = new LinkedList < TimedTuple > ( ) ; private final Map < Key , TimedTuple > pendingByKey = Maps . newHashMap ( ) ; public TimeLimitedJoin ( long expirationTime , int maxTuplesToRetain , Fields joinKey ) { this . expirationTime = expirationTime ; this . maxTuplesToRetain = maxTuplesToRetain ; this . joinKey = joinKey ; } @ Override public void prepare ( Map config , TopologyContext context , OutputCollector collector ) { this . collector = collector ; } @ Override public synchronized void execute ( Tuple input ) { long cutoff = now ( ) - expirationTime ; while ( queue . size ( ) > 0 && ( queue . size ( ) > maxTuplesToRetain || queue . peek ( ) . time < cutoff ) ) { TimedTuple expiringTuple = queue . poll ( ) ; if ( expiringTuple . tuple != null ) { collector . ack ( expiringTuple . tuple ) ; Key key = extractJoinKey ( input ) ; if ( pendingByKey . get ( key ) . time < cutoff ) { pendingByKey . remove ( key ) ; } } } final Key key = extractJoinKey ( input ) ; TimedTuple match = pendingByKey . get ( key ) ; if ( match != null ) { if ( match . tuple != null ) { pendingByKey . remove ( key ) ; collector . emit ( Arrays . asList ( input , match . tuple ) , ImmutableList . of ( Lists . newArrayList ( key ) , match . tuple , input ) ) ; collector . ack ( input ) ; collector . ack ( match . tuple ) ; match . tuple = null ; } } else { final TimedTuple t = new TimedTuple ( now ( ) , input ) ; queue . add ( t ) ; pendingByKey . put ( key , t ) ; } } private Key extractJoinKey ( Tuple input ) { List < Object >", "gt": "keys = Lists . newArrayList ( ) ;", "prediction": "args = new ArrayList < Object > ( ) ;\n", "label": 0}
{"id": 14674, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo . Toffs ; public class FieldFragList { private final int fragCharSize ; List < WeightedFragInfo > fragInfos = new ArrayList < WeightedFragInfo > ( ) ; public FieldFragList ( int fragCharSize ) { this . fragCharSize = fragCharSize ; } public void add ( int startOffset , int endOffset , List < WeightedPhraseInfo > phraseInfoList ) { fragInfos . add ( new WeightedFragInfo ( startOffset , endOffset , phraseInfoList ) ) ; } public static class WeightedFragInfo { List < SubInfo > subInfos ; float totalBoost ; int startOffset ; int endOffset ; public WeightedFragInfo ( int startOffset , int endOffset , List < WeightedPhraseInfo > phraseInfoList ) { this . startOffset = startOffset ; this . endOffset = endOffset ; subInfos = new ArrayList < SubInfo > ( ) ; for ( WeightedPhraseInfo phraseInfo : phraseInfoList ) { SubInfo subInfo = new SubInfo ( phraseInfo . text , phraseInfo . termsOffsets , phraseInfo . seqnum ) ; subInfos . add ( subInfo ) ; totalBoost += phraseInfo . boost ; } } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"subInfos=(\" ) ; for ( SubInfo si : subInfos ) sb . append ( si . toString ( ) ) ; sb . append ( \")/\" ) . append ( totalBoost ) . append ( '(' ) . append ( startOffset ) . append ( ',' ) . append ( endOffset ) . append ( ')' ) ; return sb . toString ( ) ; } static class SubInfo { final String text ; final List < Toffs > termsOffsets ; int seqnum ; SubInfo ( String text , List < Toffs", "gt": "> termsOffsets , int seqnum )", "prediction": "> termsOffsets )\n", "label": 1}
{"id": 6640, "input": "<s> package org . ofbiz . accounting . payment ; import java . math . BigDecimal ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class BillingAccountWorker { public static final String module = BillingAccountWorker . class . getName ( ) ; public static final String resourceError = \"AccountingUiLabels\" ; private static BigDecimal ZERO = BigDecimal . ZERO ; private static int decimals = - 1 ; private static int rounding = - 1 ; static { decimals = UtilNumber . getBigDecimalScale ( \"order.decimals\" ) ; rounding = UtilNumber . getBigDecimalRoundingMode ( \"order.rounding\" ) ; if ( decimals != - 1 ) ZERO = ZERO . setScale ( decimals ) ; } public static List < Map < String , Object > > makePartyBillingAccountList ( GenericValue userLogin , String currencyUomId , String partyId , Delegator delegator , LocalDispatcher dispatcher ) throws GeneralException { List < Map < String , Object > > billingAccountList = FastList . newInstance ( ) ; Map < String , Object > agentResult = dispatcher . runSync ( \"getRelatedParties\" , UtilMisc . < String , Object > toMap ( \"userLogin\" , userLogin , \"partyIdFrom\" , partyId , \"roleTypeIdFrom\" , \"AGENT\" , \"roleTypeIdTo\" , \"CUSTOMER\" , \"partyRelationshipTypeId\" , \"AGENT\" , \"includeFromToSwitched\" , \"Y\" ) ) ; if ( ServiceUtil . isError ( agentResult ) ) { throw new GeneralException ( \"Error while finding party BillingAccounts when getting Customers that this party is an agent of: \" + ServiceUtil . getErrorMessage ( agentResult ) ) ; } List < String > relatedPartyIdList = UtilGenerics . checkList ( agentResult . get ( \"relatedPartyIdList\" ) ) ; EntityCondition barFindCond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"partyId\" , EntityOperator . IN , relatedPartyIdList ) , EntityCondition . makeCondition ( \"roleTypeId\" , EntityOperator . EQUALS , \"BILL_TO_CUSTOMER\" ) ) , EntityOperator . AND ) ; List < GenericValue > billingAccountRoleList = delegator . findList ( \"BillingAccountRole\" , barFindCond , null , null , null , false ) ; billingAccountRoleList = EntityUtil . filterByDate ( billingAccountRoleList ) ; if ( billingAccountRoleList . size ( ) > 0 ) { BigDecimal totalAvailable = BigDecimal . ZERO ; for ( GenericValue billingAccountRole : billingAccountRoleList ) { GenericValue billingAccountVO = billingAccountRole . getRelatedOne ( \"BillingAccount\" , false ) ; java . sql . Timestamp thruDate = billingAccountVO . getTimestamp ( \"thruDate\" ) ; if ( ( thruDate != null ) && UtilDateTime . nowTimestamp ( ) . after ( thruDate ) ) continue ; if ( currencyUomId . equals ( billingAccountVO . getString ( \"accountCurrencyUomId\" ) ) ) { BigDecimal accountBalance = BillingAccountWorker . getBillingAccountBalance ( billingAccountVO ) ; Map < String , Object > billingAccount = new HashMap < String , Object > ( billingAccountVO ) ; BigDecimal accountLimit = getAccountLimit ( billingAccountVO ) ; billingAccount . put ( \"accountBalance\" , accountBalance ) ; BigDecimal accountAvailable = accountLimit . subtract ( accountBalance ) ; totalAvailable = totalAvailable . add ( accountAvailable ) ; billingAccountList . add ( billingAccount ) ; } } Collections . sort ( billingAccountList , new BillingAccountComparator ( ) ) ; } return billingAccountList ; } public static BigDecimal getAccountLimit ( GenericValue billingAccount ) throws GenericEntityException { if ( billingAccount . getBigDecimal ( \"accountLimit\" ) != null ) { return billingAccount . getBigDecimal ( \"accountLimit\" ) ; } else { Debug . logWarning ( \"Billing Account [\" + billingAccount . getString ( \"billingAccountId\" ) + \"] does not have an account limit defined, assuming zero.\" , module ) ; return ZERO ; } } public static BigDecimal getBillingAccountBalance ( Delegator delegator , String billingAccountId ) throws GenericEntityException { GenericValue billingAccount = delegator . findOne ( \"BillingAccount\" , UtilMisc . toMap ( \"billingAccountId\" , billingAccountId ) , false ) ; return getBillingAccountBalance ( billingAccount ) ; } public static BigDecimal getBillingAccountBalance ( GenericValue billingAccount ) throws GenericEntityException { Delegator delegator = billingAccount . getDelegator ( ) ; String billingAccountId = billingAccount . getString ( \"billingAccountId\" ) ; BigDecimal balance = ZERO ; BigDecimal accountLimit = getAccountLimit ( billingAccount ) ; balance = balance . add ( accountLimit ) ; EntityConditionList < EntityExpr > whereConditions = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"billingAccountId\" , EntityOperator . EQUALS , billingAccountId ) , EntityCondition . makeCondition ( \"paymentMethodTypeId\" , EntityOperator . EQUALS , \"EXT_BILLACT\" ) , EntityCondition . makeCondition ( \"statusId\" , EntityOperator . NOT_IN , UtilMisc . toList ( \"ORDER_CANCELLED\" , \"ORDER_REJECTED\" ) ) , EntityCondition . makeCondition ( \"preferenceStatusId\" , EntityOperator . NOT_IN , UtilMisc . toList ( \"PAYMENT_SETTLED\" , \"PAYMENT_RECEIVED\" , \"PAYMENT_DECLINED\" , \"PAYMENT_CANCELLED\" ) ) ) , EntityOperator . AND ) ; List < GenericValue > orderPaymentPreferenceSums = delegator . findList ( \"OrderPurchasePaymentSummary\" , whereConditions , UtilMisc . toSet ( \"maxAmount\" ) , null , null , false ) ; for ( Iterator < GenericValue > oppsi = orderPaymentPreferenceSums . iterator ( ) ; oppsi . hasNext ( ) ; ) { GenericValue orderPaymentPreferenceSum = oppsi . next ( ) ; BigDecimal maxAmount = orderPaymentPreferenceSum . getBigDecimal ( \"maxAmount\" ) ; balance = maxAmount != null ? balance . subtract ( maxAmount ) : balance ; } List < GenericValue > paymentAppls = delegator . findByAnd ( \"PaymentApplication\" , UtilMisc . toMap ( \"billingAccountId\" , billingAccountId ) , null , false ) ; for ( Iterator < GenericValue > pAi = paymentAppls . iterator ( ) ;", "gt": "pAi . hasNext ( ) ;", "prediction": "pAi . hasNext ( ) ;\n", "label": 0}
{"id": 14676, "input": "<s> package tk . blackwolf12333 . grieflog . utils . config ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . bukkit . configuration . InvalidConfigurationException ; import org . bukkit . configuration . file . FileConfiguration ; import org . bukkit . configuration . file . YamlConfiguration ; import org . bukkit . entity . Player ; import tk . blackwolf12333 . grieflog . GriefLog ; public class ConfigHandler { public static GriefLog plugin ; public static File configFile ; public static File friendsFile ; public static FileConfiguration config ; public static FileConfiguration friendsConfig ; public static ConfigValues values ; public ConfigHandler ( GriefLog plugin ) { ConfigHandler . plugin = plugin ; } public static void setupGriefLogConfig ( ) { configFile = new File ( plugin . getDataFolder ( ) , \"config.yml\" ) ; config = new YamlConfiguration ( ) ; if ( ! configFile . exists ( ) ) { configFile . getParentFile ( ) . mkdirs ( ) ; try { configFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } copy ( plugin . getResource ( \"config.yml\" ) , configFile ) ; loadConfig ( ) ; } else { checkForChangesAndLoad ( ) ; } } public static void setupFriendsConfig ( ) { friendsFile = new File ( plugin . getDataFolder ( ) , \"friends.yml\" ) ; friendsConfig = new YamlConfiguration ( ) ; if ( ! friendsFile . exists ( ) ) { friendsFile . getParentFile ( ) . mkdirs ( ) ; copy ( plugin . getResource ( \"friends.yml\" ) , friendsFile ) ; loadFriendsConfig ( ) ; } else { loadFriendsConfig ( ) ; } } private static void copy ( InputStream in , File file ) { try { OutputStream out = new FileOutputStream ( file ) ; byte [ ] buf = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buf ) ) > 0 ) { out . write ( buf , 0 , len ) ; } out . close ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void saveConfig ( ) { try { GriefLog . log . info ( \"Saving configuration file.\" ) ; config . save ( configFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void saveFriendsConfig ( ) { try { friendsConfig . save ( friendsFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void loadConfig ( ) { try { config . load ( configFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InvalidConfigurationException e ) { } } public static void loadFriendsConfig ( ) { try { friendsConfig . load ( friendsFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void reloadConfig ( ) { loadConfig ( ) ; } public static void reloadFriendsConfig ( ) { loadFriendsConfig ( ) ; } private static void checkForChangesAndLoad ( ) { try { loadConfig ( ) ; Map < String , Object > oldConf = config . getValues ( true ) ; FileConfiguration newconfig = new YamlConfiguration ( ) ; newconfig . load ( plugin . getResource ( \"config.yml\" ) ) ; Map < String , Object > newConf = newconfig . getValues ( true ) ; if ( newConf . size ( ) > oldConf . size ( ) ) { configFile . delete ( ) ; createNewConfigFileAndLoad ( ) ; List < String > contents = readFileAndPutContentsInList ( ) ; for ( Iterator < String > it = oldConf . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String next = it . next ( ) ; String newNode = next + \": \" + oldConf . get ( next ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { String line = contents . get ( i ) ; if ( line . contains ( next ) ) { contents . set ( i , newNode ) ; } else { continue ; } } } writeListToFileAndLoad ( contents ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InvalidConfigurationException e ) { } } private static List < String > readFileAndPutContentsInList ( ) throws IOException , FileNotFoundException { BufferedReader reader = new BufferedReader ( new FileReader ( configFile ) ) ; String line = null ; List < String > contents = new ArrayList < String > ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { contents . add ( line ) ; } reader . close ( ) ; return contents ; } private static void writeListToFileAndLoad ( List < String > list ) throws IOException , InvalidConfigurationException { BufferedWriter bw = new BufferedWriter ( new FileWriter ( configFile ) ) ;", "gt": "for ( int i = 0 ;", "prediction": "for ( String line : list )\n", "label": 1}
{"id": 6519, "input": "<s> package net . rdrei . android . absshadow . test . shadow ; import android . graphics . drawable . Drawable ; import android . view . View ; import android . widget . SpinnerAdapter ; import com . actionbarsherlock . app . ActionBar ; import com . actionbarsherlock . app . SherlockActivity ; import com . xtremelabs . robolectric . internal . Implementation ; import com . xtremelabs . robolectric . internal . Implements ; import com . xtremelabs . robolectric . shadows . ShadowActivity ; @ Implements ( SherlockActivity . class ) public class ShadowSherlockActivity extends ShadowActivity { @ Implementation public ActionBar getSupportActionBar ( ) { return new ActionBar ( ) { @ Override public void show ( ) { } @ Override public void setTitle ( int arg0 ) { } @ Override public void setTitle ( CharSequence arg0 ) { } @ Override public void setSubtitle ( int arg0 ) { } @ Override public void setSubtitle ( CharSequence arg0 ) { } @ Override public void setSelectedNavigationItem ( int arg0 ) { } @ Override public void setNavigationMode ( int arg0 ) { } @ Override public void setLogo ( Drawable arg0 ) { } @ Override public void setLogo ( int arg0 ) { } @ Override public void setListNavigationCallbacks ( SpinnerAdapter arg0 , OnNavigationListener arg1 ) { } @ Override public void setIcon ( Drawable arg0 ) { } @ Override public void setIcon ( int arg0 ) { } @ Override public void setDisplayUseLogoEnabled ( boolean arg0 ) { } @ Override public void setDisplayShowTitleEnabled ( boolean arg0 ) { } @ Override public void setDisplayShowHomeEnabled ( boolean arg0 ) { } @ Override public void setDisplayShowCustomEnabled ( boolean arg0 ) { } @ Override public void setDisplayOptions ( int arg0 , int arg1 ) { } @ Override public void setDisplayOptions ( int arg0 ) { } @ Override public void setDisplayHomeAsUpEnabled ( boolean arg0 ) { } @ Override public void setCustomView ( View arg0 , LayoutParams arg1 ) { } @ Override public void setCustomView ( int arg0 ) { } @ Override public void setCustomView ( View arg0 ) { } @ Override public void setBackgroundDrawable ( Drawable arg0 ) { } @ Override public void selectTab ( Tab arg0 ) { } @ Override public void removeTabAt ( int arg0 ) { } @ Override public void removeTab ( Tab arg0 ) { } @ Override public void removeOnMenuVisibilityListener ( OnMenuVisibilityListener arg0 ) { } @ Override public void removeAllTabs ( ) { } @ Override public Tab newTab ( ) { return null ; } @ Override public boolean isShowing ( ) { return false ; } @ Override public void hide ( ) { } @ Override public CharSequence getTitle ( ) { return null ; } @ Override public int getTabCount ( ) { return 0 ; } @ Override public Tab getTabAt ( int arg0 ) { return null ; } @ Override public CharSequence getSubtitle ( ) { return null ; } @ Override public Tab getSelectedTab ( ) { return null ; } @ Override public int getSelectedNavigationIndex ( ) { return 0 ; } @ Override public int getNavigationMode ( ) { return 0 ; } @ Override public int getNavigationItemCount ( ) { return 0 ; } @ Override public int getHeight ( ) { return 0 ; } @ Override public int getDisplayOptions ( ) { return 0 ; } @ Override public View getCustomView ( ) { return null ; } @ Override public void addTab ( Tab arg0 , int arg1 , boolean arg2 ) { } @ Override public void addTab (", "gt": "Tab arg0 , int arg1 )", "prediction": "Tab arg0 , int arg1 , boolean arg2 )\n", "label": 0}
{"id": 14677, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . jface . databinding . swt . WidgetValueProperty ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Control ; public class ControlForegroundProperty extends WidgetValueProperty { public Object getValueType ( ) { return Color . class ; } protected Object doGetValue ( Object source ) { return ( (", "gt": "Control ) source ) . getForeground ( ) ;", "prediction": "Control ) source ) . getForeground ( ) ;\n", "label": 1}
{"id": 8805, "input": "<s> package ar . com . fdvs . dj . test ; import ar . com . fdvs . dj . core . DynamicJasperHelper ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . ColumnBuilderException ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Page ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . conditionalStyle . ConditionStyleExpression ; import ar . com . fdvs . dj . domain . entities . conditionalStyle . ConditionalStyle ; import java . awt . Color ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import junit . framework . TestCase ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRExporterParameter ; import net . sf . jasperreports . engine . JasperPrint ; import net . sf . jasperreports . engine . data . JRBeanCollectionDataSource ; import net . sf . jasperreports . engine . export . JRXlsExporter ; import net . sf . jasperreports . engine . export . JRXlsExporterParameter ; public class ConditionalStyleReportTest2 extends TestCase { private DynamicReportBuilder drb ; public DynamicReport buildDynamicReport ( ) { return drb . build ( ) ; } public ConditionalStyleReportTest2 ( ) { try { drb = new DynamicReportBuilder ( ) ; drb . setGrandTotalLegend ( \"Total\" ) ; drb . setPageSizeAndOrientation ( new Page ( 585 , 842 ) ) ; drb . setUseFullPageWidth ( true ) ; drb . setAllowDetailSplit ( false ) ; drb . setWhenNoData ( \"No data\" , null , true , true ) ; drb . setReportName ( \"Test inner crosstab\" ) ; ArrayList listCondStyle = getConditonalStyles ( ) ; AbstractColumn columnState1 = ColumnBuilder . getNew ( ) . setColumnProperty ( \"1\" , Integer . class . getName ( ) ) . setTitle ( \"Sales\" ) . setHeaderStyle ( getHeaderStyle ( ) ) . setStyle ( getDataStyle ( ) ) . addConditionalStyles ( listCondStyle ) . build ( ) ; drb . addColumn ( columnState1 ) ; AbstractColumn columnState2 = ColumnBuilder . getNew ( ) . setColumnProperty ( \"2\" , String . class . getName ( ) ) . setTitle ( \"Year\" ) . setHeaderStyle ( getHeaderStyle ( ) ) . setStyle ( getDataStyle ( ) ) . addConditionalStyles ( listCondStyle ) . build ( ) ;", "gt": "drb . addColumn ( columnState2 ) ;", "prediction": "drb . addColumn ( columnState2 ) ;\n", "label": 0}
{"id": 14680, "input": "<s> package org . apache . lucene . store ; public class AlreadyClosedException extends IllegalStateException {", "gt": "public AlreadyClosedException ( String message )", "prediction": "public AlreadyClosedException ( )\n", "label": 1}
{"id": 3018, "input": "<s> public class Neg { static void m ( ) { } public static void main ( String ... args ) { Neg . < Can , I , write , a , little ,", "gt": "story , here > m ( ) ;", "prediction": "little }\n", "label": 0}
{"id": 14685, "input": "<s> package com . talis . hbase . rdf . examples . benchmarks . lubm ; import org . mindswap . pellet . jena . PelletReasonerFactory ; import com . hp . hpl . jena . ontology . OntModel ; import com . hp . hpl . jena . query . Query ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . QueryFactory ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . talis . hbase . rdf . HBaseRdfFactory ; import com . talis . hbase . rdf . Store ; public class LubmQ4 { public static void main ( String [ ] args ) { Store store = HBaseRdfFactory . connectStore ( args [ 0 ] ) ; Model schema = HBaseRdfFactory", "gt": ". connectNamedModel ( store , \"http://cs.utdallas.edu/hbase-rdf/bm#LUBM\" ) ;", "prediction": ". connectModel ( store ) ;\n", "label": 1}
{"id": 3019, "input": "<s> package org . remast . baralga . gui . panels . report ; import info . clearthought . layout . TableLayout ; import java . awt . BorderLayout ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import javax . swing . JScrollPane ; import javax . swing . JTable ; import org . jdesktop . swingx . JXPanel ; import org . jdesktop . swingx . renderer . DefaultTableRenderer ; import org . jdesktop . swingx . renderer . FormatStringValue ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . model . report . HoursByWeek ; import org . remast . baralga . gui . model . report . HoursByWeekReport ; import org . remast . baralga . gui . panels . table . HoursByWeekTableFormat ; import org . remast . baralga . gui . panels . table . HoursByWeekTextFilterator ; import org . remast . swing . JSearchField ; import org . remast . swing . table . JHighligthedTable ; import ca . odell . glazedlists . FilterList ; import ca . odell . glazedlists . matchers . MatcherEditor ; import ca . odell . glazedlists . swing . EventTableModel ; import ca . odell . glazedlists . swing . TableComparatorChooser ; import ca . odell . glazedlists . swing . TextComponentMatcherEditor ; import com . google . common . eventbus . Subscribe ; @ SuppressWarnings ( \"serial\" ) public class HoursByWeekPanel extends JXPanel { public static final DateFormat WEEK_FORMAT = new SimpleDateFormat ( \"ww\" ) ; public static final DateFormat YEAR_FORMAT = new SimpleDateFormat ( \"yyyy\" ) ; private HoursByWeekReport report ; private EventTableModel < HoursByWeek > tableModel ; public HoursByWeekPanel ( final HoursByWeekReport report ) { this . report = report ; this . setLayout ( new BorderLayout ( ) ) ; this . report . getEventBus ( )", "gt": ". register ( this ) ;", "prediction": ". addMouseListener ( new MouseAdapter ( )\n", "label": 0}
{"id": 14687, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . BranchConstraint ; import org . fuzzydb . attrs . util . Point2D ; import org . fuzzydb . attrs . util . Range2D ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; public abstract class Point2DRangeConstraint extends BranchConstraint implements IRange2D { private Range2D range2d ; public Point2D getMax ( ) { return range2d . getMax ( ) ; } public Point2D getMin ( ) { return range2d . getMin ( ) ; } public Point2DRangeConstraint ( int", "gt": "attrId , Point2D min , Point2D max )", "prediction": "index )\n", "label": 1}
{"id": 8305, "input": "<s> package p1 ; public class T4720359a { static void m ( ) { } } class T4720359c extends p2 . T4720359b {", "gt": "public static int m ( )", "prediction": "static void m ( )\n", "label": 0}
{"id": 14690, "input": "<s> package com . google . code . microlog4android . config ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Properties ; import java . util . StringTokenizer ; import android . content . Context ; import android . content . res . AssetManager ; import android . content . res . Resources ; import android . content . res . Resources . NotFoundException ; import android . util . Log ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . appender . Appender ; import com . google . code . microlog4android . format . Formatter ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; import com . google . code . microlog4android . repository . LoggerRepository ; public class PropertyConfigurator { private static final String TAG = \"Microlog.PropertyConfiguration\" ; public static String DEFAULT_PROPERTIES_FILENAME = \"microlog.properties\" ; public static final String ROOT_LOGGER_KEY = \"microlog.rootLogger\" ; public static final String MICROLOG_PREFIX = \"microlog\" ; public static final String LOGGER_PREFIX_KEY = \"microlog.logger\" ; public static final String FORMATTER_PREFIX_KEY = \"microlog.formatter\" ; public static final String PATTERN_LAYOUT_PREFIX_KEY = \"microlog.formatter.PatternFormatter.pattern\" ; public static final String APPENDER_PREFIX_KEY = \"microlog.appender\" ; public static final String FILE_APPENDER_FILE_NAME_KEY = \"microlog.appender.FileAppender.File\" ; public static final String FILE_APPENDER_APPEND_KEY = \"microlog.appender.FileAppender.Append\" ; public static final String LOG_LEVEL_PREFIX_KEY = \"microlog.level\" ; public static final String TAG_PREFIX_KEY = \"microlog.tag\" ; public static final String [ ] APPENDER_ALIASES = { \"LogCatAppender\" , \"FileAppender\" } ; public static final String [ ] APPENDER_CLASS_NAMES = { \"com.google.code.microlog4android.appender.LogCatAppender\" , \"com.google.code.microlog4android.appender.FileAppender\" } ; public static final String [ ] FORMATTER_ALIASES = { \"SimpleFormatter\" , \"PatternFormatter\" } ; public static final String [ ] FORMATTER_CLASS_NAMES = { \"com.google.code.microlog4android.format.SimpleFormatter\" , \"com.google.code.microlog4android.format.PatternFormatter\" } ; private static final HashMap < String , String > appenderAliases = new HashMap < String , String > ( 43 ) ; private static final HashMap < String , String > formatterAliases = new HashMap < String , String > ( 21 ) ; private Context context ; private LoggerRepository loggerRepository ; { for ( int index = 0 ; index < APPENDER_ALIASES . length ; index ++ ) { appenderAliases . put ( APPENDER_ALIASES [ index ] , APPENDER_CLASS_NAMES [ index ] ) ; } for ( int index = 0 ; index < FORMATTER_ALIASES . length ; index ++ ) { formatterAliases . put ( FORMATTER_ALIASES [ index ] , FORMATTER_CLASS_NAMES [ index ] ) ; } } ; private PropertyConfigurator ( Context context ) { this . context = context ; loggerRepository = DefaultLoggerRepository . INSTANCE ; } public static PropertyConfigurator getConfigurator ( Context context ) { if ( context == null ) { throw new IllegalArgumentException ( \"The context must not be null\" ) ; } return new PropertyConfigurator ( context ) ; } public void configure ( ) { configure ( DEFAULT_PROPERTIES_FILENAME ) ; } public void configure ( String filename ) { Resources resources = context . getResources ( ) ; AssetManager assetManager = resources . getAssets ( ) ; try { InputStream inputStream = assetManager . open ( filename ) ; Properties properties = loadProperties ( inputStream ) ; startConfiguration ( properties ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to open the microlog properties file. Hint: the file should be in the /assets directory \" + filename + \" \" + e ) ; } } public void configure ( int resId ) { Resources resources = context . getResources ( ) ; try { InputStream rawResource = resources . openRawResource ( resId ) ; Properties properties = loadProperties ( rawResource ) ; startConfiguration ( properties ) ; } catch ( NotFoundException e ) { Log . e ( TAG , \"Did not find the microlog properties resource. Hint: this should be in the /res/raw directory \" + e ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to read the microlog properties resource.\" + e ) ; } } private Properties loadProperties ( InputStream inputStream ) throws IOException { Properties properties", "gt": "= new Properties ( ) ;", "prediction": "= new Properties ( ) ;\n", "label": 1}
{"id": 9782, "input": "<s> package com . sun . mirror . apt ; import java . util . Collection ; import java . util . Map ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface AnnotationProcessorEnvironment { Map < String , String > getOptions ( ) ; Messager getMessager ( ) ; Filer getFiler ( ) ; Collection < TypeDeclaration > getSpecifiedTypeDeclarations ( ) ;", "gt": "PackageDeclaration getPackage ( String name ) ;", "prediction": "}\n", "label": 0}
{"id": 14693, "input": "<s> package com . hoccer . api . android ; import java . io . IOException ; import java . util . List ; import org . apache . http . client . ClientProtocolException ; import android . content . Context ; import android . location . Address ; import android . location . Geocoder ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . net . wifi . WifiManager ; import android . os . Bundle ; import android . util . Log ; import com . hoccer . api . UpdateException ; public class LinccLocationManager implements LocationListener { private static final String UNKNOWN_LOCATION_TEXT = \"You can not hoc without a location\" ; private final LocationManager mLocationManager ; private final WifiManager mWifiManager ; private final Context mContext ; private final AsyncLinccer mLinccer ; private final Updateable mUpdater ; private final boolean mNetworkProviderAvailable ; public LinccLocationManager ( Context pContext , AsyncLinccer linccer , Updateable updater ) { mContext = pContext ; mLinccer = linccer ; mUpdater = updater ; mLocationManager = ( LocationManager ) pContext . getSystemService ( Context . LOCATION_SERVICE ) ; mWifiManager = ( WifiManager ) pContext . getSystemService ( Context . WIFI_SERVICE ) ; mNetworkProviderAvailable = mLocationManager . getAllProviders ( ) . contains ( LocationManager . NETWORK_PROVIDER ) ; } public Context getContext ( ) { return mContext ; } public AsyncLinccer getLinccer ( ) { return mLinccer ; } public void refreshLocation ( ) throws UpdateException , ClientProtocolException , IOException { mLinccer . autoSubmitEnvironmentChanges ( false ) ; mLinccer . onWifiScanResults ( mWifiManager . getScanResults ( ) ) ; Location location ; if ( mNetworkProviderAvailable ) { location = mLocationManager . getLastKnownLocation ( LocationManager . NETWORK_PROVIDER ) ; if ( location != null ) mLinccer . onNetworkChanged ( location ) ; } location = mLocationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( location != null ) mLinccer . onGpsChanged ( location ) ; mLinccer . submitEnvironment ( ) ; } public void deactivate ( ) { mLocationManager . removeUpdates ( this ) ; } public void activate ( ) { mLocationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , 1000 , 1 , this ) ; if ( mNetworkProviderAvailable ) { mLocationManager . requestLocationUpdates ( LocationManager . NETWORK_PROVIDER , 1000 , 1 , this ) ; } } @ Override public void onLocationChanged ( Location location ) { Log . v ( \"LinccLocationManager\" , location . toString ( ) ) ; if ( mUpdater != null ) { mUpdater . updateNow ( ) ; } } @ Override public void onProviderDisabled ( String provider ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } public Address getAddress ( Location location ) throws IOException { if ( location == null ) { return new Address ( null ) ; } Geocoder gc = new Geocoder ( mContext ) ; Address address = null ; List < Address > addresses = gc . getFromLocation ( location . getLatitude ( ) , location . getLongitude ( ) , 1 ) ; if ( addresses . size ( ) > 0 ) { address = addresses . get ( 0 ) ; } return address ; } public String getDisplayableAddress ( Location location ) { try { Address address = getAddress ( location ) ; String addressLine = null ; String info = \" (~\" + location . getAccuracy ( ) + \"m)\" ; if ( location . getAccuracy ( ) < 500 ) { addressLine = address . getAddressLine ( 0 ) ; } else { addressLine = address . getAddressLine ( 1 ) ; } addressLine = trimAddress ( addressLine ) ; return addressLine + info ; } catch ( Exception e ) { return UNKNOWN_LOCATION_TEXT + \" ~\" + location .", "gt": "getAccuracy ( ) + \"m\" ;", "prediction": "toString ( ) ;\n", "label": 1}
{"id": 758, "input": "<s> package com . mobeelizer . mobile . android . model ; import static com . mobeelizer . java . model . MobeelizerReflectionUtil . getValue ; import static com . mobeelizer . java . model . MobeelizerReflectionUtil . setValue ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import android . util . Log ; import com . mobeelizer . java . api . MobeelizerCredential ; import com . mobeelizer . java . api . MobeelizerErrorsBuilder ; import com . mobeelizer . java . api . MobeelizerField ; import com . mobeelizer . java . api . MobeelizerModel ; import com . mobeelizer . java . api . MobeelizerModelCredentials ; import com . mobeelizer . java . model . MobeelizerFieldImpl ; import com . mobeelizer . java . model . MobeelizerModelImpl ; import com . mobeelizer . java . sync . MobeelizerJsonEntity ; import com . mobeelizer . java . sync . MobeelizerJsonEntity . ConflictState ; public class MobeelizerAndroidModel implements MobeelizerModel { private final static String TAG = \"mobeelizer:modeldefinition\" ; public static final String _GUID = \"_guid\" ; public static final String _OWNER = \"_owner\" ; public static final String _GROUP = \"_group\" ; public static final String _DELETED = \"_deleted\" ; public static final String _MODIFIED = \"_modified\" ; public static final String _CONFLICTED = \"_conflicted\" ; private final String tableName ; private final Map < String , MobeelizerAndroidField > fields = new HashMap < String , MobeelizerAndroidField > ( ) ; private final ContentValues valuesForDelete ; private final MobeelizerModelImpl model ; private final String currentUser ; private final String currentGroup ; public MobeelizerAndroidModel ( final MobeelizerModelImpl model , final String currentUser , final String currentGroup ) { this . model = model ; this . currentUser = currentUser ; this . currentGroup = currentGroup ; for ( MobeelizerField field : this . model . getFields ( ) ) { fields . put ( field . getName ( ) , new MobeelizerAndroidField ( ( MobeelizerFieldImpl ) field ) ) ; } tableName = model . getName ( ) . toLowerCase ( Locale . ENGLISH ) ; valuesForDelete = new ContentValues ( ) ; valuesForDelete . put ( _MODIFIED , 1 ) ; valuesForDelete . put ( _DELETED , 1 ) ; } @ Override public Class < ? > getMappingClass ( ) { return model . getMappingClass ( ) ; } @ Override public String getName ( ) { return model . getName ( ) ; } @ Override public MobeelizerModelCredentials getCredentials ( ) { return model . getCredentials ( ) ; } public String getTableName ( ) { return tableName ; } @ Override public Set < MobeelizerField > getFields ( ) { return model . getFields ( ) ; } public String convertToDatabaseValue ( final String field , final Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ? \"1\" : \"0\" ; } else if ( value instanceof Date ) { return ( ( Date ) value ) . getTime ( ) + \"\" ; } else { return value . toString ( ) ; } } public boolean exists ( final SQLiteDatabase database , final String guid ) { Cursor cursor = getByGuid ( database , guid ) ; boolean exists = cursor . moveToNext ( ) ; cursor . close ( ) ; return exists ; } public < T > boolean exists ( final SQLiteDatabase database , final T entity ) { String guid = ( String ) getValue ( model . getGuidField ( ) , entity ) ; return guid != null && exists ( database , guid ) ; } public < T > void create ( final SQLiteDatabase database , final T entity , final String owner , final String group , final MobeelizerErrorsBuilder builder ) { MobeelizerCredential createCredentials = model . getCredentials ( ) . getCreateAllowed ( ) ; if ( ( createCredentials == MobeelizerCredential . NONE ) ) { builder . addNoCredentialsToPerformOperationOnModel ( \"create\" ) ; } String guid = UUID . randomUUID ( ) . toString ( ) ; ContentValues values = new ContentValues ( ) ; setValue ( model . getGuidField ( ) , entity , guid ) ; if ( model . getOwnerField ( ) != null ) { setValue ( model . getOwnerField ( ) , entity , owner ) ; } if ( model . getGroupField ( ) != null ) { setValue ( model . getGroupField ( ) , entity , group ) ; } values . put ( _GUID , guid ) ; values . put ( _OWNER , owner ) ; values . put ( _GROUP , group ) ; values . put ( _CONFLICTED , Integer . valueOf ( 0 ) ) ; values . put ( _DELETED , Integer . valueOf ( 0 ) ) ; values . put ( _MODIFIED , Integer . valueOf ( 1 ) ) ; for ( MobeelizerAndroidField field : fields . values ( ) ) { if ( ! field . hasNullOrDefaultValue ( entity ) && ! checkCredential ( field . getCredentials ( ) . getCreateAllowed ( ) , owner , group ) ) { builder . addNoCredentialsToPerformOperationOnField ( field . getName ( ) , \"create\" ) ; } field . setValueFromEntityToDatabase ( values , entity , builder ) ; } if ( builder . hasNoErrors ( ) ) { if ( model . getModifiedField ( ) != null ) { setValue ( model . getModifiedField ( ) , entity , true ) ; } insertEntity ( database , values ) ; } else { setValue ( model . getGuidField ( )", "gt": ", entity , null ) ;", "prediction": ", entity , false ) ;\n", "label": 0}
{"id": 14698, "input": "<s> package org . nuxeo . ecm . automation . client ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class AdapterManager { protected Map < Class < ? > , List < AdapterFactory < ? > > > adapters ; @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Object objToAdapt , Class < T > adapterType ) { Class < ? > cls = objToAdapt . getClass ( ) ; List < AdapterFactory < ? > > factories = adapters . get ( adapterType ) ; if ( factories != null ) { for ( AdapterFactory < ? > f : factories ) { if ( f . getAcceptType ( ) . isAssignableFrom ( cls ) ) { return ( T ) f . getAdapter ( objToAdapt ) ; } } } return null ; } public void registerAdapter (", "gt": "AdapterFactory < ? > factory )", "prediction": "Class < T > adapterClass , AdapterFactory < ? > factory )\n", "label": 1}
{"id": 8120, "input": "<s> package org . parboiled . transform ; import org . objectweb . asm . tree . MethodNode ; import org . parboiled . common . Predicate ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import java . io . IOException ; import java . util . Collection ; import static org . testng . Assert . assertEquals ; public class ClassNodeInializerTest extends TransformationTest { @ BeforeClass public void setup ( ) throws IOException { setup ( TestParser . class ) ; } @ Test ( enabled = false ) public void testClassNodeSetup ( ) throws Exception { assertEquals ( classNode . name , \"org/parboiled/transform/TestParser$$parboiled\" ) ; assertEquals ( classNode . superName , \"org/parboiled/transform/TestParser\" ) ; assertEquals ( join ( classNode . getConstructors ( ) , null ) , \"<init>\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . containsExplicitActions ( ) ; } } ) , \"RuleWithDirectExplicitAction,RuleWithIndirectExplicitAction,RuleWithIndirectExplicitDownAction,\" + \"RuleWithIndirectExplicit2ParamAction,RuleWith2Returns,RuleWithCaptureInAction\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . containsImplicitActions ( ) ; } } ) , \"RuleWithDirectImplicitAction,RuleWithIndirectImplicitAction,RuleWithDirectImplicitUpAction,\" + \"RuleWithIndirectExplicitDownAction,RuleWithIndirectImplicitParamAction,\" + \"RuleWithCachedAnd2Params,RuleWithCaptureParameter,RuleWithIllegalImplicitAction,\" + \"RuleWithActionAccessingPrivateField,RuleWithActionAccessingPrivateMethod\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . hasCachedAnnotation ( ) ; } } ) , \"RuleWithoutAction,RuleWithLabel,RuleWithNamedLabel,RuleWithLeaf,RuleWithDirectImplicitAction,\" + \"RuleWithIndirectImplicitAction,RuleWithDirectExplicitAction,RuleWithIndirectExplicitAction,\" + \"RuleWithDirectImplicitUpAction,RuleWithIndirectExplicitDownAction,RuleWithCapture1,RuleWithCapture2,\" + \"RuleWithCachedAnd2Params,RuleWithCaptureInAction,RuleWithActionAccessingPrivateField,\" + \"RuleWithActionAccessingPrivateMethod,Ch,IgnoreCase,CharRange,AnyOf,String,IgnoreCase,\" + \"FirstOf,OneOrMore,Optional,Sequence,Test,TestNot,ZeroOrMore,Eoi,Any,Empty\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . hasDontLabelAnnotation ( ) ; } } ) , \"RuleWithoutAction,RuleWithLabel,RuleWithNamedLabel,RuleWithLeaf,RuleWithDirectImplicitAction,\" + \"RuleWithIndirectImplicitAction,RuleWithDirectExplicitAction,RuleWithIndirectExplicitAction,\" +", "gt": "\"RuleWithDirectImplicitUpAction,RuleWithIndirectExplicitDownAction,RuleWithCapture1,RuleWithCapture2,\" + \"RuleWithCaptureInAction,RuleWithActionAccessingPrivateField,RuleWithActionAccessingPrivateMethod,\" + \"Eoi,Any,Empty\" ) ;", "prediction": "\"RuleWithDirectImplicitUpAction,RuleWithIndirectExplicitDownAction,\" + \"RuleWithLabel,RuleWithNamedLabel,RuleWithLeaf,\" + \"FirstOf,OneOrMore,Sequence,Test\" ) ;\n", "label": 0}
{"id": 14699, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . core . runtime . Assert ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . swt . widgets . Widget ; public class TableViewer extends AbstractTableViewer { private Table table ; private TableViewerRow cachedRow ; public TableViewer ( Composite parent ) { this ( parent , SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; } public TableViewer ( Composite parent , int style ) { this ( new Table ( parent , style ) ) ; } public TableViewer ( Table table ) { this . table = table ; hookControl ( table ) ; } public Control getControl ( ) { return table ; } public Table getTable ( ) { return table ; } protected ColumnViewerEditor createViewerEditor ( ) { return new TableViewerEditor ( this , null , new ColumnViewerEditorActivationStrategy ( this ) , ColumnViewerEditor . DEFAULT ) ; } public void setSelection ( ISelection selection , boolean reveal ) { super . setSelection ( selection , reveal ) ; } protected ViewerRow getViewerRowFromItem ( Widget item ) { if ( cachedRow == null ) { cachedRow = new TableViewerRow ( ( TableItem ) item ) ; } else { cachedRow . setItem ( ( TableItem ) item ) ; } return cachedRow ; } protected ViewerRow internalCreateNewRowPart ( int style , int rowIndex ) { TableItem item ; if ( rowIndex >= 0 ) { item = new TableItem ( table , style , rowIndex ) ; } else { item = new TableItem ( table , style ) ; } return getViewerRowFromItem ( item ) ; } protected Item getItemAt ( Point p ) { TableItem [ ] selection = table . getSelection ( ) ; if ( selection . length == 1 ) { int columnCount = table . getColumnCount ( ) ; for ( int i = 0 ; i < columnCount ; i ++ ) { if ( selection [ 0 ] . getBounds ( i ) . contains ( p ) ) { return selection [ 0 ] ; } } } return table . getItem ( p ) ; } protected int doGetItemCount ( ) { return table . getItemCount ( ) ; } protected int doIndexOf ( Item item ) { return table . indexOf ( ( TableItem ) item ) ; } protected void doSetItemCount ( int count ) { table . setItemCount ( count ) ; } protected Item [ ] doGetItems ( ) { return table . getItems ( ) ; } protected int doGetColumnCount ( ) { return table . getColumnCount ( ) ; } protected Widget doGetColumn ( int index ) { return table . getColumn ( index ) ; } protected Item doGetItem ( int index ) { return table . getItem ( index ) ; } protected Item [ ] doGetSelection ( ) { return table . getSelection ( ) ; } protected int [ ] doGetSelectionIndices ( ) { return table . getSelectionIndices ( ) ; } protected void doClearAll ( ) { table . clearAll ( ) ; } protected void doResetItem ( Item item ) { TableItem tableItem = ( TableItem ) item ; int columnCount = Math . max ( 1 , table . getColumnCount ( ) ) ;", "gt": "for ( int i = 0 ;", "prediction": "for ( int i = 0 ;\n", "label": 1}
{"id": 7458, "input": "<s> import java . util . * ; public class T6332204 { void m ( int [ ] [ ] data , Comparator c ) { Arrays .", "gt": "binarySearch ( data , 1 , c ) ;", "prediction": "sort ( data , c ) ;\n", "label": 0}
{"id": 14700, "input": "<s> package org . seage . problem . qap . tabusearch ; import org . seage . metaheuristic . tabusearch . * ; public class QapSolution extends SolutionAdapter { protected Integer [ ] _assign ; public QapSolution ( ) { } public QapSolution ( Double [ ] [ ] [ ] customers ) { _assign = new Integer [ customers . length ] ; for ( int i = 0 ; i < customers . length ; i ++ ) _assign [ i ] = i ; } public QapSolution ( Integer [ ] assign ) { _assign = assign ; } public Object clone ( ) { QapSolution copy = ( QapSolution ) super . clone ( ) ; copy . _assign = ( Integer [ ] ) this . _assign . clone ( ) ; return copy ; } public Integer [ ] getAssign ( ) { return _assign ; } public void setAssign ( Integer [ ] assign ) { _assign = assign ; } public String toString ( ) { StringBuffer s = new StringBuffer ( ) ; s . append ( \"[\" ) ; for ( int i = _assign . length - 1 ; i >= 1 ; i -- ) { s . append ( ( _assign [ i ] + 1 ) ) ; s .", "gt": "append ( \",\" ) ;", "prediction": "append ( \",\" ) ;\n", "label": 1}
{"id": 1984, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Minecart ; public interface LizaMinecart extends Minecart { List < LizaEntity > getNearbyLizaEntities ( double x , double y", "gt": ", double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14704, "input": "<s> package org . nuxeo . ecm . platform . comment . api ; public final class CommentEvents { public static final String COMMENT_ADDED = \"commentAdded\" ; public static", "gt": "final String COMMENT_REMOVED = \"commentRemoved\" ;", "prediction": "final String COMMENT_REMOVED = \"commentRemoved\" ;\n", "label": 1}
{"id": 7212, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface NewTask extends TimesheetAttribute { String getId ( ) ; void setId ( String value ) ; String getText ( ) ; void setText ( String value ) ; EList <", "gt": "NewTaskAttribute > getAttributes ( ) ;", "prediction": "Task > getTasks ( ) ;\n", "label": 0}
{"id": 14714, "input": "<s> package io . beancounter . commons . tagdef ; public class TagDefException extends Exception { public TagDefException", "gt": "( String message , Exception e )", "prediction": "( String message )\n", "label": 1}
{"id": 7501, "input": "<s> package ar . com . fdvs . dj . test . database ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class HSQLTest { protected static final Log log = LogFactory . getLog ( HSQLTest . class ) ; public final String TEST_DB_PATH = \"target/test-classes/hsql/test_dj_db\" ; public static void main ( String [ ] args ) throws SQLException , ClassNotFoundException { Class . forName ( \"org.hsqldb.jdbcDriver\" ) ; Connection c = DriverManager . getConnection ( \"jdbc:hsqldb:file:target/test-classes/hsql/test_dj_db\" , \"sa\" , \"\" ) ; PreparedStatement ps = c . prepareStatement ( \"SELECT * FROM Customer\" ) ; ResultSet rs = ps . executeQuery ( ) ; while ( rs . next ( ) ) { log . info ( rs . getString ( \"firstname\" ) + \", \" +", "gt": "rs . getString ( \"lastname\" ) ) ;", "prediction": "rs . getString ( \"lastname\" ) ) ;\n", "label": 0}
{"id": 14718, "input": "<s> package org . elasticsearch . memcached . netty ; import org . elasticsearch . ElasticSearchException ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . netty . OpenChannelsHandler ; import org . elasticsearch . common . netty . bootstrap . ServerBootstrap ; import org . elasticsearch . common . netty . channel . Channel ; import org . elasticsearch . common . netty . channel . ChannelPipeline ; import org . elasticsearch . common . netty . channel . ChannelPipelineFactory ; import org . elasticsearch . common . netty . channel . Channels ; import org . elasticsearch . common . netty . channel . socket . nio . NioServerSocketChannelFactory ; import org . elasticsearch . common . netty . channel . socket . oio . OioServerSocketChannelFactory ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . PortsRange ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . http . BindHttpException ; import org . elasticsearch . memcached . MemcachedServerTransport ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . transport . BindTransportException ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . * ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; public class NettyMemcachedServerTransport extends AbstractLifecycleComponent < MemcachedServerTransport > implements MemcachedServerTransport { private final RestController restController ; private final NetworkService networkService ; private final int workerCount ; private final boolean blockingServer ; private final String port ; private final String bindHost ; private final String publishHost ; private final Boolean tcpNoDelay ; private final Boolean tcpKeepAlive ; private final Boolean reuseAddress ; private final ByteSizeValue tcpSendBufferSize ; private final ByteSizeValue tcpReceiveBufferSize ; private volatile ServerBootstrap serverBootstrap ; private volatile BoundTransportAddress boundAddress ; private volatile Channel serverChannel ; private volatile OpenChannelsHandler serverOpenChannels ; @ Inject public NettyMemcachedServerTransport ( Settings settings , RestController restController , NetworkService networkService ) { super ( settings ) ; this . restController = restController ; this . networkService = networkService ; this . workerCount = componentSettings . getAsInt ( \"worker_count\" , Runtime . getRuntime ( ) . availableProcessors ( ) * 2 ) ; this . blockingServer = componentSettings . getAsBoolean ( \"memcached.blocking_server\" , settings . getAsBoolean ( TCP_BLOCKING_SERVER , settings . getAsBoolean ( TCP_BLOCKING , false ) ) ) ; this . port = componentSettings . get ( \"port\" , settings . get ( \"memcached.port\" , \"11211-11311\" ) ) ; this . bindHost = componentSettings . get ( \"bind_host\" ) ; this . publishHost = componentSettings . get ( \"publish_host\" ) ; this . tcpNoDelay = componentSettings . getAsBoolean ( \"tcp_no_delay\" , settings . getAsBoolean ( TCP_NO_DELAY , true ) ) ; this . tcpKeepAlive = componentSettings . getAsBoolean ( \"tcp_keep_alive\" , settings . getAsBoolean ( TCP_KEEP_ALIVE , true ) ) ; this . reuseAddress = componentSettings . getAsBoolean ( \"reuse_address\" , settings . getAsBoolean ( TCP_REUSE_ADDRESS , NetworkUtils . defaultReuseAddress ( ) ) ) ; this . tcpSendBufferSize = componentSettings . getAsBytesSize ( \"tcp_send_buffer_size\" , settings . getAsBytesSize ( TCP_SEND_BUFFER_SIZE , TCP_DEFAULT_SEND_BUFFER_SIZE ) ) ; this . tcpReceiveBufferSize = componentSettings . getAsBytesSize ( \"tcp_receive_buffer_size\" , settings . getAsBytesSize ( TCP_RECEIVE_BUFFER_SIZE , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ) ; } @ Override public BoundTransportAddress boundAddress ( ) { return boundAddress ; } @ Override protected void doStart ( ) throws ElasticSearchException { this . serverOpenChannels = new OpenChannelsHandler ( logger ) ; if ( blockingServer ) { serverBootstrap = new ServerBootstrap ( new OioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_boss\" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_worker\" ) ) ) ) ; } else { serverBootstrap = new ServerBootstrap ( new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_boss\" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_worker\" ) ) , workerCount ) ) ; } ChannelPipelineFactory pipelineFactory = new ChannelPipelineFactory ( ) { @ Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline pipeline = Channels . pipeline ( ) ; pipeline . addLast ( \"openChannels\" , serverOpenChannels ) ; pipeline . addLast ( \"decoder\" , new MemcachedDecoder ( logger ) ) ; pipeline . addLast ( \"dispatcher\" , new MemcachedDispatcher ( restController ) ) ; return pipeline ; } } ; serverBootstrap . setPipelineFactory ( pipelineFactory ) ; if ( tcpNoDelay != null ) { serverBootstrap . setOption ( \"child.tcpNoDelay\" , tcpNoDelay ) ; } if ( tcpKeepAlive != null ) { serverBootstrap . setOption ( \"child.keepAlive\" , tcpKeepAlive ) ; } if ( tcpSendBufferSize != null ) { serverBootstrap . setOption ( \"child.sendBufferSize\" , tcpSendBufferSize . bytes ( ) ) ; } if ( tcpReceiveBufferSize != null ) { serverBootstrap . setOption ( \"child.receiveBufferSize\" , tcpReceiveBufferSize . bytes ( ) ) ; } if ( reuseAddress != null ) { serverBootstrap . setOption ( \"reuseAddress\" , reuseAddress ) ; serverBootstrap . setOption ( \"child.reuseAddress\" , reuseAddress ) ; } InetAddress hostAddressX ; try { hostAddressX = networkService . resolveBindHostAddress ( bindHost ) ; }", "gt": "catch ( IOException e )", "prediction": "catch ( Exception e )\n", "label": 1}
{"id": 9010, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import ar . com . fdvs . dj . domain", "gt": ". chart . DJChart ;", "prediction": ". chart . Category ;\n", "label": 0}
{"id": 14719, "input": "<s> package com . design ; import com . datastruct . DCHalfEdge ; public class Shade extends Part { public Shade ( double width , double height ) { super", "gt": "( width , height ) ;", "prediction": "( width , height ) ;\n", "label": 1}
{"id": 7200, "input": "<s> @ CompilerAnnotationTest ( @ CompilerAnnotationTest2 ( name = \"test\" , name2 = \"test2\" )", "gt": ") public @ interface CompilerAnnotationTest", "prediction": "public static String test ( )\n", "label": 0}
{"id": 14723, "input": "<s> package com . emf4sw . owl . resource ; abstract public interface OWLWriter { Object write", "gt": "( OWLResource resource , OWLFormats format ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9717, "input": "<s> package org . ofbiz . ebaystore ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Collections ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import java . util . SortedMap ; import java . util . TreeMap ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import com . ebay . sdk . ApiContext ; import com . ebay . sdk . ApiException ; import com . ebay . sdk . SdkException ; import com . ebay . sdk . SdkSoapException ; import com . ebay . sdk . call . AddDisputeCall ; import com . ebay . sdk . call . AddItemCall ; import com . ebay . sdk . call . AddOrderCall ; import com . ebay . sdk . call . DeleteSellingManagerTemplateCall ; import com . ebay . sdk . call . GetBestOffersCall ; import com . ebay . sdk . call . GetItemCall ; import com . ebay . sdk . call . GetMyeBaySellingCall ; import com . ebay . sdk . call . GetSellingManagerInventoryCall ; import com . ebay . sdk . call . GetSellingManagerSoldListingsCall ; import com . ebay . sdk . call . GetUserCall ; import com . ebay . sdk . call . LeaveFeedbackCall ; import com . ebay . sdk . call . RelistItemCall ; import com . ebay . sdk . call . RespondToBestOfferCall ; import com . ebay . sdk . call . VerifyAddSecondChanceItemCall ; import com . ebay . soap . eBLBaseComponents . AddOrderRequestType ; import com . ebay . soap . eBLBaseComponents . AddOrderResponseType ; import com . ebay . soap . eBLBaseComponents . AmountType ; import com . ebay . soap . eBLBaseComponents . AutomatedLeaveFeedbackEventCodeType ; import com . ebay . soap . eBLBaseComponents . BestOfferActionCodeType ; import com . ebay . soap . eBLBaseComponents . BestOfferDetailsType ; import com . ebay . soap . eBLBaseComponents . BestOfferStatusCodeType ; import com . ebay . soap . eBLBaseComponents . BestOfferType ; import com . ebay . soap . eBLBaseComponents . BuyerPaymentMethodCodeType ; import com . ebay . soap . eBLBaseComponents . CommentTypeCodeType ; import com . ebay . soap . eBLBaseComponents . CurrencyCodeType ; import com . ebay . soap . eBLBaseComponents . DeleteSellingManagerTemplateRequestType ; import com . ebay . soap . eBLBaseComponents . DeleteSellingManagerTemplateResponseType ; import com . ebay . soap . eBLBaseComponents . DetailLevelCodeType ; import com . ebay . soap . eBLBaseComponents . DisputeExplanationCodeType ; import com . ebay . soap . eBLBaseComponents . DisputeReasonCodeType ; import com . ebay . soap . eBLBaseComponents . FeedbackDetailType ; import com . ebay . soap . eBLBaseComponents . GetSellingManagerInventoryRequestType ; import com . ebay . soap . eBLBaseComponents . GetSellingManagerInventoryResponseType ; import com . ebay . soap . eBLBaseComponents . ItemArrayType ; import com . ebay . soap . eBLBaseComponents . ItemListCustomizationType ; import com . ebay . soap . eBLBaseComponents . ItemSortTypeCodeType ; import com . ebay . soap . eBLBaseComponents . ItemType ; import com . ebay . soap . eBLBaseComponents . ListingTypeCodeType ; import com . ebay . soap . eBLBaseComponents . OrderType ; import com . ebay . soap . eBLBaseComponents . PaginatedItemArrayType ; import com . ebay . soap . eBLBaseComponents . PaginationType ; import com . ebay . soap . eBLBaseComponents . SellingManagerOrderStatusType ; import com . ebay . soap . eBLBaseComponents . SellingManagerPaidStatusCodeType ; import com . ebay . soap . eBLBaseComponents . SellingManagerProductDetailsType ; import com . ebay . soap . eBLBaseComponents . SellingManagerProductType ; import com . ebay . soap . eBLBaseComponents . SellingManagerShippedStatusCodeType ;", "gt": "import com . ebay . soap . eBLBaseComponents . SellingManagerSoldOrderType ;", "prediction": "import com . ebay . soap . eBLBaseComponents . StoreType ;\n", "label": 0}
{"id": 14724, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . Collection ; import java . util . HashSet ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; public class PreferenceNodeFilter extends ViewerFilter { Collection ids = new HashSet ( ) ; public PreferenceNodeFilter ( String [ ] filteredIds ) { super ( ) ; for ( int i = 0 ; i < filteredIds . length ; i ++ ) { ids . add ( filteredIds [ i ] ) ; } } public boolean select ( Viewer viewer , Object parentElement , Object element ) { return checkNodeAndChildren ( ( IPreferenceNode ) element ) ; }", "gt": "private boolean checkNodeAndChildren ( IPreferenceNode node )", "prediction": "}\n", "label": 1}
{"id": 1745, "input": "<s> package p2 ; public class A2 < T >", "gt": "extends p1 . A1 < T >", "prediction": "\n", "label": 0}
{"id": 14725, "input": "<s> package org . eclipse . swt . browser ; import org . eclipse . swt . events . TypedEvent ; import org . eclipse . swt . widgets . Event ; public class ProgressEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public int current ; public int total ; ProgressEvent ( Event event ) { super ( event ) ; } @ Override public String toString ( ) { String string = super . toString ( ) ; return string . substring ( 0 , string . length ( ) - 1 ) + \" current=\" + current + \" total=\"", "gt": "+ total + \"}\" ;", "prediction": "+ total ;\n", "label": 1}
{"id": 4764, "input": "<s> package org . ofbiz . content . openoffice ; import java . io . ByteArrayOutputStream ; import com . sun . star . io . XSeekable ; import com . sun . star . io . XOutputStream ; import com . sun . star . io . BufferSizeExceededException ; import com . sun . star . io . NotConnectedException ; public class OpenOfficeByteArrayOutputStream extends ByteArrayOutputStream implements XOutputStream { public static final String module = OpenOfficeByteArrayOutputStream . class . getName ( ) ; public OpenOfficeByteArrayOutputStream ( ) { super ( ) ; } public OpenOfficeByteArrayOutputStream ( int arg0 ) { super ( arg0 ) ; } public void writeBytes ( byte [ ] buf ) throws BufferSizeExceededException , NotConnectedException , com . sun . star . io . IOException { try { write ( buf ) ; } catch ( java . io . IOException e ) { throw ( new com . sun . star . io . IOException ( e . getMessage ( ) ) ) ; } } public void closeOutput ( ) throws BufferSizeExceededException , NotConnectedException , com . sun . star . io . IOException { try { super . flush ( ) ; close ( ) ; }", "gt": "catch ( java . io . IOException e )", "prediction": "catch ( java . io . IOException e )\n", "label": 0}
{"id": 14727, "input": "<s> package org . eclipse . ui . tests . menus ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . ui . menus . ExtensionContributionFactory ; import org . eclipse . ui . menus . IContributionRoot ; import org . eclipse . ui . services . IServiceLocator ; public class DeclaredProgrammaticFactory extends ExtensionContributionFactory { public DeclaredProgrammaticFactory ( ) { super ( ) ; } static class MyItem extends ActionContributionItem { public MyItem ( ) { super ( new Action ( \"MyItem\" ) { public String getId ( ) { return \"myitem\" ; } } ) ; } } public void createContributionItems ( IServiceLocator serviceLocator , IContributionRoot additions ) { additions . addContributionItem (", "gt": "new MyItem ( ) , null ) ;", "prediction": "new MyItem ( ) ) ;\n", "label": 1}
{"id": 6467, "input": "<s> package javax . lang . model . element ; import java . util . List ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; public interface TypeElement extends Element , Parameterizable , QualifiedNameable { List < ? extends Element > getEnclosedElements ( ) ; NestingKind getNestingKind ( ) ; Name getQualifiedName ( ) ; @ Override Name getSimpleName ( ) ; TypeMirror getSuperclass ( ) ; List < ? extends TypeMirror > getInterfaces ( ) ; List <", "gt": "? extends TypeParameterElement > getTypeParameters ( ) ;", "prediction": "TypeMirror > getDeclaredTypes ( ) ;\n", "label": 0}
{"id": 14728, "input": "<s> package com . cloudera . sqoop . lib ; public interface FieldMappable extends org . apache .", "gt": "sqoop . lib . FieldMappable", "prediction": "sqoop . lib . FieldMappable\n", "label": 1}
{"id": 5231, "input": "<s> package Liza ; import org . bukkit . entity . StorageMinecart ;", "gt": "public interface LizaStorageMinecart extends StorageMinecart", "prediction": "import org . bukkit . entity . Item ;\n", "label": 0}
{"id": 14729, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . nodes . GroupQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . search . Query ; public class GroupQueryNodeBuilder implements StandardQueryBuilder { public GroupQueryNodeBuilder ( ) { } public Query build ( QueryNode queryNode ) throws QueryNodeException { GroupQueryNode groupNode = ( GroupQueryNode ) queryNode ; return ( Query ) ( groupNode ) . getChild ( )", "gt": ". getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ;", "prediction": ";\n", "label": 1}
{"id": 8376, "input": "<s> package org . ofbiz . order . shoppingcart ; import java . math . BigDecimal ; import java . math . MathContext ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . shoppingcart . product . ProductPromoWorker ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . config . ProductConfigWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreSurveyWrapper ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . security . Security ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . webapp . control . RequestHandler ; public class ShoppingCartEvents { public static String module = ShoppingCartEvents . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; private static final String NO_ERROR = \"noerror\" ; private static final String NON_CRITICAL_ERROR = \"noncritical\" ; private static final String ERROR = \"error\" ; public static final MathContext generalRounding = new MathContext ( 10 ) ; public static String addProductPromoCode ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; ShoppingCart cart = getCartObject ( request ) ; String productPromoCodeId = request . getParameter ( \"productPromoCodeId\" ) ; if ( UtilValidate . isNotEmpty ( productPromoCodeId ) ) { String checkResult = cart . addProductPromoCode ( productPromoCodeId , dispatcher ) ; if ( UtilValidate . isNotEmpty ( checkResult ) ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , checkResult ) ; return \"error\" ; } } return \"success\" ; } public static String addItemGroup ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; Map < String , Object > parameters = UtilHttp . getParameterMap ( request ) ; String groupName = ( String ) parameters . get ( \"groupName\" ) ; String parentGroupNumber = ( String ) parameters . get ( \"parentGroupNumber\" ) ; String groupNumber = cart . addItemGroup ( groupName , parentGroupNumber ) ; request . setAttribute ( \"itemGroupNumber\" , groupNumber ) ; return \"success\" ; } public static String addCartItemToGroup ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; Map < String , Object > parameters = UtilHttp . getParameterMap ( request ) ; String itemGroupNumber = ( String ) parameters . get ( \"itemGroupNumber\" ) ; String indexStr", "gt": "= ( String ) parameters . get ( \"lineIndex\" ) ;", "prediction": "= ( String ) parameters . get ( \"indexStr\" ) ;\n", "label": 0}
{"id": 14734, "input": "<s> package org . eclipse . rap . rwt . internal . client ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap .", "gt": "rwt . client . Client ;", "prediction": "rwt . lifecycle . WidgetUtil ;\n", "label": 1}
{"id": 7834, "input": "<s> import java . io . * ; import java . util . * ; import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; public abstract class Tester { ClassDeclaration thisClassDecl ; AnnotationProcessorEnvironment env ; static Tester activeTester ; private static final String [ ] DEFAULT_ARGS = { \"-nocompile\" , \"-XPrintAptRounds\" , \"-XListDeclarations\" , } ; private static final String [ ] NO_STRINGS = { } ; private static Class dummy = TestProcessorFactory . class ; private final String testSrc = System . getProperty ( \"test.src\" , \".\" ) ; private final String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; private String [ ] args ; static { ClassLoader loader = Tester . class . getClassLoader ( ) ; if ( loader != null ) { loader . setPackageAssertionStatus ( null , true ) ; } } protected Tester ( String ... additionalArgs ) { String sourceFile = testSrc + File . separator + getClass ( ) . getName ( ) + \".java\" ; ArrayList < String > as = new ArrayList < String > ( ) ; Collections . addAll ( as , DEFAULT_ARGS ) ; as . add ( \"-sourcepath\" ) ; as . add ( testSrc ) ; as . add ( \"-factory\" ) ; as . add ( TestProcessorFactory . class . getName ( ) ) ; Collections . addAll ( as , additionalArgs ) ; as . add ( sourceFile ) ; args = as . toArray ( NO_STRINGS ) ; } protected void run ( ) { activeTester = this ; if ( com . sun . tools . apt . Main . process ( args ) != 0 ) { throw new Error ( \"apt errors encountered.\" ) ; } } protected void init ( ) { } protected MethodDeclaration getMethod ( String methodName ) { for ( MethodDeclaration m : thisClassDecl . getMethods ( ) ) { if ( methodName . equals ( m . getSimpleName ( ) ) ) { return m ; } } return null ; } protected FieldDeclaration getField ( String fieldName ) { for ( FieldDeclaration f : thisClassDecl . getFields ( ) ) { if ( fieldName", "gt": ". equals ( f . getSimpleName ( ) ) )", "prediction": ". equals ( f . getSimpleName ( ) ) )\n", "label": 0}
{"id": 14736, "input": "<s> package nehsics . test ; import nehsics . world . * ; import nehsics . ui . * ; import nehsics . force . * ; import nehsics . bodies . * ; import java . awt . * ; import static nehsics . math . Util . * ; import java . util . * ; public class TestOneD extends UserControlledScene { public final static String NAME = \"Rotating Triangle\" ; private Bonder bonder ; public static void main ( String [ ] args ) { new Starter ( \"nehsics.test.TestOneD\" ) ; } public TestOneD ( Canvas c ) { super ( c ) ; } protected void setup ( ) { FieldManager f = new FieldManager ( ) ; Walls walls = new Walls ( 250 , .9 ) ; world . addListener ( walls ) ; Stats s = new Stats ( ) ; world . addListener ( s ) ; world . addListener ( f ) ; world . addListener ( new Gravitation ( f ) ) ; world . addListener ( new Collider ( s ) ) ; bonder = new Bonder ( ) ; world . addListener ( bonder ) ; Circle c1 ; Circle c2 ; Circle c3 ; world . addBody ( c1 = new Circle ( 10 , 10 ) ) ; c1 . setPosition ( v ( 20 , 00 ) ) ; world . addBody ( c2 = new Circle ( 10 , 10 ) ) ; c2 . setColor ( Color . green ) ; c2 . setPosition ( v ( 0 , - 10 ) ) ; world . addBody ( c3 = new Circle ( 10 , 10 ) ) ; c3 . setColor ( Color . red ) ; c3 . setPosition ( v ( 0 , - 30 ) ) ; BindingForce b2 = new BindingForce ( c1 , c2 ) ; BindingForce b1 = new BindingForce ( c2 , c1 ) ; BindingForce b3 = new BindingForce ( c2 , c3 ) ; BindingForce b4 = new BindingForce ( c3 , c2 ) ; BindingForce b5 = new BindingForce ( c1 , c3 ) ; BindingForce b6 = new BindingForce ( c3 , c1 ) ; c1 . addBond ( b6 , c3 ) ; c3 . addBond ( b5 , c1 ) ; bonder . addBond ( b6 ) ; bonder . addBond ( b5 ) ; c2 . addBond ( b2 , c1 ) ; c3 . addBond ( b3 , c2 ) ; bonder . addBond ( b2 ) ; bonder . addBond ( b3 ) ; bonder . addBond ( b4 ) ; c2 . addBond ( b4 , c3 ) ; c1 . addBond ( b1 , c2 ) ; bonder . addBond ( b1 ) ; double temp = 100 ; Circle c ; for ( int i = 0 ; i < 9 ; i ++ ) for ( int j = 0 ; j < 9 ; j ++ ) { world . addBody ( c = new Circle ( 5 , 5 ) ) ; c . setPosition ( v ( 50 + 15 * i - 150 ,", "gt": "50 + 15 * j - 150 ) ) ;", "prediction": "0 ) ) ;\n", "label": 1}
{"id": 312, "input": "<s> import java . io . * ; import java . util . * ; public class Main { File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; public static void main ( String [ ] args ) throws Exception { new Main ( ) . run ( ) ; } public void run ( ) throws Exception { compile ( true , \"Test.java\" ) ; List < String > base_files = Arrays . asList ( \"Boolean.java\" , \"Byte.java\" , \"Character.java\" , \"Integer.java\" , \"Long.java\" , \"Number.java\" , \"Object.java\" , \"Short.java\" , \"Void.java\" ) ; List < String > extra_files = Arrays . asList ( \"Double.java\" , \"Float.java\" , \"Cloneable.java\" , \"Serializable.java\" ) ; List < String > files = new ArrayList < String > ( ) ; files . addAll ( base_files ) ; files . add ( \"Test.java\" ) ; compile ( false , files ) ; for ( String f : extra_files ) { files = new ArrayList < String > ( ) ; files . addAll ( base_files ) ; files . addAll ( extra_files ) ; files . remove ( f ) ; files . add ( \"Test.java\" ) ; compile ( false , files ) ; } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void compile ( boolean stdBootClassPath , String ... files ) { compile ( stdBootClassPath , Arrays . asList ( files ) ) ; } void compile ( boolean stdBootClassPath , List < String > files ) { File empty = new File ( \"empty\" ) ; empty . mkdirs ( ) ; List < String > args = new ArrayList < String > ( ) ; args . add ( \"-classpath\" ) ; args . add ( \"empty\" ) ; if ( ! stdBootClassPath ) { args . add ( \"-bootclasspath\" ) ; args . add ( \"empty\" ) ; } args . add ( \"-d\" ) ; args . add ( \".\" ) ; for ( String f : files ) args . add ( new File ( testSrc , f ) . getPath ( ) ) ; System . out . println ( \"Compile: \" + args ) ; StringWriter out = new StringWriter ( ) ; int rc = com . sun . tools . javac . Main . compile ( args . toArray ( new String [ args . size ( ) ] ) , new PrintWriter ( out ) ) ; System . out . println ( out . toString ( ) ) ; System", "gt": ". out . println ( \"result: \" + rc ) ;", "prediction": ". exit ( rc ) ;\n", "label": 0}
{"id": 14737, "input": "<s> package org . powerbot . game . api . wrappers . widget ; import java . awt . Graphics ; import java . awt . Point ; import java . awt . Polygon ; import java . awt . Rectangle ; import org . powerbot . game . api . methods . Widgets ; import org . powerbot . game . api . methods . input . Mouse ; import org . powerbot . game . api . methods . node . Menu ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . util . node . HashTable ; import org . powerbot . game . api . wrappers . Entity ; import org . powerbot . game . api . wrappers . Identifiable ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSInterface ; import org . powerbot . game . client . RSInterfaceNode ; public class WidgetChild implements Entity , Identifiable { private final int index ; private final Widget parentWidget ; private final WidgetChild parent ; public WidgetChild ( final Widget parent , final int index ) { parentWidget = parent ; this . index = index ; this . parent = null ; } public WidgetChild ( final Widget parentWidget , final WidgetChild parentComponent , final int index ) { this . parentWidget = parentWidget ; this . parent = parentComponent ; this . index = index ; } public Widget getWidget ( ) { return parentWidget ; } public WidgetChild getParent ( ) { return parent ; } public int getIndex ( ) { return index ; } public int getAbsoluteX ( ) { return getAbsoluteLocation ( ) . x ; } public int getAbsoluteY ( ) { return getAbsoluteLocation ( ) . y ; } public Point getAbsoluteLocation ( ) { if ( getInternal ( ) == null ) { return new Point ( - 1 , - 1 ) ; } final Client client = Context . client ( ) ; final int parentId = getParentId ( ) ; int x = 0 , y = 0 ; if ( parentId != - 1 ) { final Point point = Widgets . get ( parentId > > 0x10 , parentId & 0xffff ) . getAbsoluteLocation ( ) ; x = point . x ; y = point . y ; } else { final Rectangle [ ] bounds = client . getRSInterfaceBoundsArray ( ) ; final int index = getBoundsArrayIndex ( ) ; if ( bounds != null && index > 0 && index < bounds . length && bounds [ index ] != null ) { return new Point ( bounds [ index ] . x , bounds [ index ] . y ) ; } } if ( parentId != - 1 ) { final WidgetChild child = Widgets . getChild ( parentId ) ; final int horizontalScrollSize = child . getScrollableContentWidth ( ) , verticalScrollSize = child . getScrollableContentHeight ( ) ; if ( horizontalScrollSize > 0 || verticalScrollSize > 0 ) { x -= child . getHorizontalScrollPosition ( ) ; y -= child . getVerticalScrollPosition ( ) ; } } x += getRelativeX ( ) ; y += getRelativeY ( ) ; return new Point ( x , y ) ; } public int getRelativeX ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getX ( ) * Context . multipliers ( ) . INTERFACE_X : - 1 ; } public int getRelativeY ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getY ( ) * Context . multipliers ( ) . INTERFACE_Y : - 1 ; } public Point getRelativeLocation ( ) { final RSInterface widget = getInternal ( ) ; if ( widget == null ) { return new Point ( - 1 , - 1 ) ; } final Multipliers multipliers = Context . multipliers ( ) ; return new Point ( widget . getX ( ) * multipliers . INTERFACE_X , widget . getY ( ) * multipliers . INTERFACE_Y ) ; } public int getWidth ( ) { if ( ! isInScrollableArea ( ) ) { return getHorizontalScrollThumbSize ( ) ; } final RSInterface widget = getInternal ( ) ; return widget != null ? ( widget . getWidth ( ) * Context . multipliers ( ) . INTERFACE_WIDTH ) - 4 : - 1 ; } public int getHeight ( ) { if ( ! isInScrollableArea ( ) ) { return getVerticalScrollThumbSize ( ) ; } final RSInterface widget = getInternal ( ) ; return widget != null ? ( widget . getHeight ( ) * Context . multipliers ( ) . INTERFACE_HEIGHT ) - 4 : - 1 ; } public int getId ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getID ( ) * Context . multipliers ( ) . INTERFACE_ID : - 1 ; } public int getType ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getType ( ) * Context . multipliers ( ) . INTERFACE_TYPE : - 1 ; } public int getSpecialType ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getSpecialType ( ) * Context . multipliers ( ) . INTERFACE_SPECIALTYPE : - 1 ; } public int getChildId ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getComponentID ( ) * Context . multipliers ( ) . INTERFACE_COMPONENTID : - 1 ; } public int getChildIndex ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getComponentIndex ( ) * Context . multipliers ( ) . INTERFACE_COMPONENTINDEX : - 1 ; } public String getChildName ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? ( String ) widget . getComponentName ( ) : null ; }", "gt": "public int getTextureId ( )", "prediction": "}\n", "label": 1}
{"id": 2292, "input": "<s> class QualifiedNewStaticClass { static class C { } QualifiedNewStaticClass x ; C c = x .", "gt": "new C ( ) ;", "prediction": "c ;\n", "label": 0}
{"id": 14739, "input": "<s> package org . seage . problem . tsp . tabusearch ; import org . seage . metaheuristic . tabusearch . * ; import org . seage . problem . tsp . City ; public class TspObjectiveFunction implements ObjectiveFunction { private static final long serialVersionUID = 3000751801782794274L ; public double [ ] [ ] _matrix ; public TspObjectiveFunction ( City [ ] cities ) { int numCities = cities . length ; double [ ] [ ] customers = new double [ numCities ] [ ] ; for ( int i = 0 ; i < numCities ; i ++ ) { customers [ i ] = new double [ 2 ] ; customers [ i ] [ 0 ] = ( Double ) cities [ i ] . X ; customers [ i ] [ 1 ] = ( Double ) cities [ i ] . Y ; } _matrix = createMatrix ( customers ) ; } @ Override public double [ ] evaluate ( Solution solution , Move move ) throws Exception { try { int [ ] tour = ( ( TspSolution ) solution ) . _tour ; int len = tour . length ; if ( move == null ) { double dist = 0 ; for ( int i = 0 ; i < len ; i ++ ) { dist += _matrix [ tour [ i ] ] [ i + 1 >= len ? tour [ 0 ] : tour [ i + 1 ] ] ; } return new double [ ] { dist } ; } else { TspSwapMove mv = ( TspSwapMove ) move ; int pos1 = - 1 ; int pos2 = - 1 ; for ( int i = 0 ; i < tour . length ; i ++ ) { if ( tour [ i ] == mv . customer ) { pos1 = i ; break ; } } pos2 = pos1 + mv . movement ; if ( pos1 > pos2 ) { int temp = pos2 ; pos2 = pos1 ; pos1 = temp ; } double dist = solution . getObjectiveValue ( ) [ 0 ] ; if ( pos1 + 1 == pos2 ) { dist -= _matrix [ tour [ pos1 - 1 ] ] [ tour [ pos1 ] ] ; dist -= _matrix [ tour [ pos2 ] ] [ tour [ ( pos2 + 1 ) % len ] ] ; dist += _matrix [ tour [ pos1 -", "gt": "1 ] ] [ tour [ pos2 ] ] ;", "prediction": "1 ] ] [ tour [ pos2 ] ] ;\n", "label": 1}
{"id": 1744, "input": "<s> abstract enum ExplicitlyAbstractEnum2 { FE { void foo ( ) { return ; } } ; abstract", "gt": "void foo ( ) ;", "prediction": "enum Enum\n", "label": 0}
{"id": 14749, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import org . eclipse . rap . rwt . internal . theme . QxDimension ; import junit . framework . TestCase ; public class QxDimension_Test extends TestCase { public void testIllegalArguments ( ) { try { QxDimension . valueOf ( null ) ; fail ( \"NPE expected\" ) ; } catch ( NullPointerException e ) { } try { QxDimension . valueOf ( \"\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } try { QxDimension . valueOf ( \" 23px\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } try { QxDimension . valueOf ( \"23em\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } } public void testZero ( ) { assertSame ( QxDimension . ZERO , QxDimension . valueOf ( \"0\" ) ) ; assertSame ( QxDimension . ZERO , QxDimension . valueOf ( \"0px\" ) ) ; assertEquals ( 0 , QxDimension . ZERO . value ) ; } public void testValid ( ) { QxDimension dim23 = QxDimension . valueOf ( \"23\" ) ; assertEquals ( 23 , dim23 . value ) ; QxDimension dim23px = QxDimension . valueOf ( \"23px\" ) ; assertEquals ( 23 , dim23px . value ) ; QxDimension negative = QxDimension . valueOf ( \"-1\" ) ; assertEquals ( - 1", "gt": ", negative . value ) ;", "prediction": ", negative . value ) ;\n", "label": 1}
{"id": 7430, "input": "<s> package Liza ; import org . bukkit . Server ; public interface LizaServer extends Server { LizaWorld", "gt": "getWorld ( String name ) ;", "prediction": "world ;\n", "label": 0}
{"id": 14750, "input": "<s> package com . yahoo . ycsb . measurements ; import java . io . IOException ; import java . io . Serializable ; import java . util . HashMap ; import com . yahoo . ycsb . measurements . exporter . MeasurementsExporter ; public abstract class OneMeasurement implements Serializable { private static final long serialVersionUID = 7807865821392650553L ; String _name ; public String getName ( ) { return _name ; } public OneMeasurement ( String _name ) { this . _name = _name ; } public abstract void reportReturnCode ( int code ) ; public abstract void measure ( int latency ) ; public abstract void add ( OneMeasurement m ) ; public abstract long getOperations ( ) ; public abstract HashMap < Integer , int [ ] > getReturnCodes ( ) ; public abstract String getSummary ( ) ; public abstract void exportMeasurements ( MeasurementsExporter exporter ) throws IOException ; public String computeTime ( double time ) { int i ; for ( i = 0 ; time > 1024 && i < 2 ; i ++ ) time = time / 1024 ; time = Math . round ( time * 100 ) / 100.0 ; if ( i == 0 ) return String . format ( \"%-6s\" , ( Double . toString ( time ) + \"us\" ) ) ; else if ( i == 1 ) return String . format ( \"%-6s\" , ( Double . toString ( time ) + \"ms\" ) ) ; else return String . format ( \"%-6s\" , ( Double . toString ( time ) + \"s\" ) ) ; } public String computeTime ( int time ) { int i ; for ( i = 0 ; time > 1024 && i < 2 ;", "gt": "i ++ ) time = time / 1024 ;", "prediction": "i ++ ) time = time / 1024 ;\n", "label": 1}
{"id": 10058, "input": "<s> import java . io . * ; public class Test { public static void main ( String ... args ) throws Exception { new Test ( ) . run ( ) ; } public void run ( ) throws Exception { javadoc ( \"Error.java\" , \"1 error\" ) ; javadoc ( \"JavacWarning.java\" , \"1 warning\" ) ; javadoc ( \"JavadocWarning.java\" , \"1 warning\" ) ; if ( errors > 0 ) throw new Exception ( errors + \" errors found\" ) ; } void javadoc ( String path , String expect ) { File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; String [ ] args = { \"-source\" , \"1.4\" , \"-bootclasspath\" , System . getProperty ( \"sun.boot.class.path\" ) , \"-classpath\" , \".\" , \"-package\" , new File ( testSrc , path ) . getPath ( ) } ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javadoc . Main . execute ( \"javadoc\" , pw , pw , pw , com . sun . tools . doclets . standard . Standard . class . getName (", "gt": ") , args ) ;", "prediction": ") , args ) ;\n", "label": 0}
{"id": 14756, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . expressions . EvaluationResult ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . ExpressionInfo ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . handlers . HandlerUtil ; public class CloseOthersHandler extends AbstractEvaluationHandler { private Expression enabledWhen ; public CloseOthersHandler ( ) { registerEnablement ( ) ; } public Object execute ( ExecutionEvent event ) throws ExecutionException { IWorkbenchWindow window = HandlerUtil . getActiveWorkbenchWindowChecked ( event ) ; IWorkbenchPage page = window . getActivePage ( ) ; if ( page != null ) { IEditorReference [ ] refArray = page . getEditorReferences ( ) ; if ( refArray != null && refArray . length > 1 ) { IEditorReference [ ] otherEditors = new IEditorReference [ refArray . length - 1 ] ; IEditorReference activeEditor = ( IEditorReference ) page . getReference ( page . getActiveEditor ( ) ) ; for ( int i = 0 ; i < refArray . length ; i ++ ) { if ( refArray [ i ] != activeEditor ) continue ; System . arraycopy ( refArray , 0 , otherEditors , 0 , i ) ; System . arraycopy ( refArray , i + 1 , otherEditors , i , refArray . length - 1 - i ) ; break ; } page .", "gt": "closeEditors ( otherEditors , true ) ;", "prediction": "setActiveEditor ( activeEditor ) ;\n", "label": 1}
{"id": 7103, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface MethodInvocationTree extends ExpressionTree { List < ? extends Tree > getTypeArguments ( ) ; ExpressionTree getMethodSelect ( ) ; List", "gt": "< ? extends ExpressionTree > getArguments ( ) ;", "prediction": "< ExpressionTree > getArguments ( ) ;\n", "label": 0}
{"id": 14757, "input": "<s> package com . emf4sw . rdf ; import org . eclipse . emf . ecore . EObject ; public interface URIElement extends EObject { String getURI ( ) ; void setURI", "gt": "( String value ) ;", "prediction": "( String value ) ;\n", "label": 1}
{"id": 114, "input": "<s> package org . parboiled . transform ; import org . parboiled . common . ImmutableList ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import java . io . IOException ; import java . util . List ; import static org . parboiled . transform . AsmTestUtils . assertTraceDumpEquality ; public class ImplicitActionsConverterTest extends TransformationTest { private final List < RuleMethodProcessor > processors = ImmutableList . of ( new UnusedLabelsRemover ( ) , new ReturnInstructionUnifier ( ) , new InstructionGraphCreator ( ) , new ImplicitActionsConverter ( ) ) ; @ BeforeClass public void setup ( ) throws IOException { setup ( TestParser . class ) ; } @ SuppressWarnings ( { \"unchecked\" } ) @ Test public void testReturnInstructionUnification ( ) throws Exception { assertTraceDumpEquality ( processMethod ( \"RuleWithIndirectImplicitAction\" , processors ) , \"\" + \"    ALOAD 0\\n\" + \"    BIPUSH 97\\n\" + \"    INVOKESTATIC java/lang/Character.valueOf (C)Ljava/lang/Character;\\n\" + \"    BIPUSH 98\\n\" + \"    INVOKESTATIC java/lang/Character.valueOf (C)Ljava/lang/Character;\\n\" + \"    ICONST_1\\n\" + \"    ANEWARRAY java/lang/Object\\n\" + \"    DUP\\n\" + \"    ICONST_0\\n\" + \"    ALOAD 0\\n\" + \"    INVOKEVIRTUAL org/parboiled/transform/TestParser.action ()Z\\n\" + \"    IFNE L0\\n\" + \"    ALOAD 0\\n\" + \"    GETFIELD org/parboiled/transform/TestParser.integer : I\\n\" + \"    ICONST_5\\n\" + \"    IF_ICMPNE L1\\n\" + \"   L0\\n\" + \"    ICONST_1\\n\" + \"    GOTO L2\\n\" + \"   L1\\n\" + \"    ICONST_0\\n\" + \"   L2\\n\" + \"    INVOKESTATIC org/parboiled/BaseParser.ACTION (Z)Lorg/parboiled/Action;\\n\" + \"    AASTORE\\n\" + \"    INVOKEVIRTUAL org/parboiled/transform/TestParser.Sequence (Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/parboiled/Rule;\\n\" + \"    ARETURN\\n\" ) ; assertTraceDumpEquality ( processMethod ( \"RuleWithDirectImplicitAction\" , processors ) , \"\" + \"    ALOAD 0\\n\" + \"    BIPUSH 97\\n\" + \"    INVOKESTATIC java/lang/Character.valueOf (C)Ljava/lang/Character;\\n\" + \"    ALOAD 0\\n\" + \"    GETFIELD org/parboiled/transform/TestParser.integer : I\\n\" + \"    IFNE L0\\n\" + \"    ICONST_1\\n\" + \"    GOTO L1\\n\" + \"   L0\\n\" + \"    ICONST_0\\n\" + \"   L1\\n\" + \"    INVOKESTATIC org/parboiled/BaseParser.ACTION (Z)Lorg/parboiled/Action;\\n\" + \"    ICONST_2\\n\" + \"    ANEWARRAY java/lang/Object\\n\" + \"    DUP\\n\" + \"    ICONST_0\\n\" + \"    BIPUSH 98\\n\" + \"    INVOKESTATIC java/lang/Character.valueOf (C)Ljava/lang/Character;\\n\" + \"    AASTORE\\n\" + \"    DUP\\n\" + \"    ICONST_1\\n\" + \"    BIPUSH 99\\n\" + \"    INVOKESTATIC java/lang/Character.valueOf (C)Ljava/lang/Character;\\n\" + \"    AASTORE\\n\" + \"   ", "gt": "INVOKEVIRTUAL org/parboiled/transform/TestParser.Sequence (Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/parboiled/Rule;\\n\" + \"    ARETURN\\n\" ) ;", "prediction": "INVOKEVIRTUAL org/parboiled/BaseParser.ACTION (Z)Lorg/parboiled/Action ;\n", "label": 0}
{"id": 14758, "input": "<s> package org . eclipse . xtext . xdoc . parser . antlr . internal ; import org . eclipse . xtext . parser . antlr . Lexer ; import org . antlr . runtime . * ; import java . util . Stack ; import java . util . List ; import java . util . ArrayList ; @ SuppressWarnings ( \"all\" ) public class InternalXdocLexer extends Lexer { public static final int T__42 = 42 ; public static final int T__12 = 12 ; public static final int T__28 = 28 ; public static final int T__23 = 23 ; public static final int T__51 = 51 ; public static final int T__13 = 13 ; public static final int T__47 = 47 ; public static final int T__50 = 50 ; public static final int T__21 = 21 ; public static final int T__19 = 19 ; public static final int T__39 = 39 ; public static final int T__30 = 30 ; public static final int T__46 = 46 ; public static final int T__52 = 52 ; public static final int T__17 = 17 ; public static final int RULE_MULTI_NL = 5 ; public static final int T__27 = 27 ; public static final int T__24 = 24 ; public static final int T__49 = 49 ; public static final int T__10 = 10 ; public static final int T__48 = 48 ; public static final int T__34 = 34 ; public static final int T__15 = 15 ; public static final int T__35 = 35 ; public static final int RULE_ID = 6 ; public static final int T__36 = 36 ; public static final int T__20 = 20 ; public static final int T__44 = 44 ; public static final int T__14 = 14 ; public static final int T__33 = 33 ; public static final int T__22 = 22 ; public static final int T__11 = 11 ; public static final int T__29 = 29 ; public static final int T__45 = 45 ; public static final int RULE_WS = 4 ; public static final int T__43 = 43 ; public static final int T__31 = 31 ; public static final int T__40 = 40 ; public static final int EOF = - 1 ; public static final int T__53 = 53 ; public static final int T__32 = 32 ; public static final int T__16 = 16 ; public static final int RULE_SINGLE_NL = 7 ; public static final int T__38 = 38 ; public static final int T__37 = 37 ; public static final int T__26 = 26 ; public static final int RULE_ANY_OTHER = 8 ; public static final int T__25 = 25 ; public static final int RULE_SL_COMMENT = 9 ; public static final int T__41 = 41 ; public static final int T__18 = 18 ; public InternalXdocLexer ( ) { ; } public InternalXdocLexer ( CharStream input ) { this ( input , new RecognizerSharedState ( ) ) ; } public InternalXdocLexer ( CharStream input , RecognizerSharedState state ) { super ( input , state ) ; } public String getGrammarFileName ( ) { return \"../org.eclipse.xtext.xdoc/src-gen/org/eclipse/xtext/xdoc/parser/antlr/internal/InternalXdoc.g\" ; } public final void mT__10 ( ) throws RecognitionException { try { int _type = T__10 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"document[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__11 ( ) throws RecognitionException { try { int _type = T__11 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( ']' ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__12 ( ) throws RecognitionException { try { int _type = T__12 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"subtitle[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__13 ( ) throws RecognitionException { try { int _type = T__13 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"authors[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public", "gt": "final void mT__14 ( ) throws RecognitionException", "prediction": "final void mT__14 ( ) throws RecognitionException\n", "label": 1}
{"id": 3500, "input": "<s> import java . util . Collection ; public final class Misc < T > implements Marker2 , Marker3 { private static final long longConstant = Long . MAX_VALUE ; private static final String asciispecials = \"\\t\\n\u0007\" ; public void covar ( Collection < ? extends T > s ) { return ; } public void contravar ( Collection < ? super T > s ) { return ; } public < S >", "gt": "S varUse ( int i )", "prediction": "void add ( S s )\n", "label": 0}
{"id": 14760, "input": "<s> package org . eclipse . swt . custom ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . * ; public class SashForm_Test extends TestCase { private Display display ; private Shell shell ; public void testIsSerializable ( ) throws Exception { SashForm sashForm = new SashForm ( shell , SWT . HORIZONTAL ) ; new Label ( sashForm , SWT . NONE ) ; new Label ( sashForm , SWT . NONE ) ; sashForm . setWeights ( new int [ ] { 30 , 70 } ) ; SashForm deserializedSashForm = Fixture . serializeAndDeserialize ( sashForm ) ; assertEquals ( sashForm . getWeights ( ) [ 0 ] , deserializedSashForm . getWeights ( ) [ 0 ] ) ; assertEquals ( sashForm . getWeights ( ) [ 1 ]", "gt": ", deserializedSashForm . getWeights ( ) [ 1 ] ) ;", "prediction": ", deserializedSashForm . getWeights ( ) [ 1 ] ) ;\n", "label": 1}
{"id": 7829, "input": "<s> package org . gk . engine . client . build . menu ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class MenuItemBuilder extends Builder { public MenuItemBuilder ( String processNodeName ) { super ( processNodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List subNodes =", "gt": "new gkList ( ) ;", "prediction": "new ArrayList ( nodeList . size ( ) ) ;\n", "label": 0}
{"id": 14764, "input": "<s> package org . jscsi . parser . datasegment ; import java . nio . ByteBuffer ; import org . jscsi . exception . InternetSCSIException ; public interface IDataSegment { @ Deprecated public int deserialize ( final ByteBuffer src , final int len ) ; public int append ( final ByteBuffer src , final int len ) ; @ Deprecated public int serialize ( final ByteBuffer dst , final int off ) ; public", "gt": "IDataSegmentIterator iterator ( ) ;", "prediction": "int size ( ) ;\n", "label": 1}
{"id": 5802, "input": "<s> package org . remast . baralga . gui . actions ; import java . awt . Frame ; import javax . swing . ImageIcon ; import javax . swing . filechooser . FileFilter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . gui . settings . UserSettings ; import org . remast . baralga . model . export . ExcelExporter ; import org . remast . baralga . model . export . Exporter ; import org . remast . swing . util . FileFilters ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public final class ExportExcelAction extends AbstractExportAction { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( ExportExcelAction . class ) ; @ SuppressWarnings ( \"unused\" ) private static final Logger log = LoggerFactory . getLogger ( ExportExcelAction . class ) ; private static final String EXCEL_FILE_EXTENSION = \".xlsx\" ; private static final FileFilter EXCEL_FILE_FILTER = new FileFilters . ExcelFileFilter ( ) ; public ExportExcelAction ( final Frame owner , final PresentationModel model ) { super ( owner , model ) ; putValue ( NAME , textBundle . textFor ( \"ExcelExportAction.Name\" ) ) ; putValue ( SHORT_DESCRIPTION , textBundle . textFor ( \"ExcelExportAction.ShortDescription\" ) ) ; putValue ( SMALL_ICON , new ImageIcon ( getClass ( ) .", "gt": "getResource ( \"/icons/gnome-mime-application-vnd.ms-excel.png\" ) ) ) ;", "prediction": "getResource ( EXCEL_FILE_EXTENSION ) ) ) ;\n", "label": 0}
{"id": 14771, "input": "<s> package org . fuzzydb . io . packet ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . channels . SocketChannel ; import java . util . Collection ; import java . util . Iterator ; import junit . framework . Assert ; import org . fuzzydb . io . core . ClassLoaderInterface ; import org . fuzzydb . io . core . Message ; import org . fuzzydb . io . core . SourcedMessage ; import org . fuzzydb . io . core . exceptions . NotListeningException ; import org . fuzzydb . io . core . impl . DummyCli ; import org . fuzzydb . io . packet . CommsStack ; import org . fuzzydb . io . packet . TCPStack ; import org . fuzzydb . io . packet . layer1 . Server ; import org . fuzzydb . io . packet . layer1 . ServerImpl ; import org . fuzzydb . io . packet . layer1 . SocketListeningServer ; import org . junit . Before ; import org . junit . Test ; public class CommsStressTest { protected static final String defaultAddress = \"127.0.0.1\" ; protected static int serverPort = 5001 ; private ClassLoaderInterface cli = new DummyCli ( ) ; @ SuppressWarnings ( \"serial\" ) private static class TestMessage extends Message { int value ; @ SuppressWarnings ( \"unused\" ) byte [ ] bytes = new byte [ 10 ] ; public TestMessage ( int value ) { super ( 0 , 0 ) ; this . value = value ; } } @ Before public void setUp ( ) { serverPort ++ ; } private void doConnectLoops ( Server server , int loops ) throws IOException , NotListeningException { for ( int loop = 0 ; loop < loops ; loop ++ ) { InetSocketAddress isa = new InetSocketAddress ( defaultAddress , serverPort ) ; CommsStack client = new TCPStack ( SocketChannel . open ( isa ) , cli ) ; TestMessage tm = new TestMessage ( 42 ) ; client . getMessageInterface ( ) . send ( tm ) ; Collection < SourcedMessage > messages = server . waitForMessage ( 1000 ) ; Iterator < SourcedMessage > i = messages . iterator ( ) ; TestMessage rx = ( TestMessage ) i . next ( ) . getMessage ( ) ; Assert . assertEquals ( tm . value , rx . value ) ; client . getMessageInterface ( ) . close ( ) ; } } private void doMessageLoops ( Server server , int loops ) throws IOException , NotListeningException { InetSocketAddress isa = new InetSocketAddress ( defaultAddress , serverPort ) ; CommsStack client = new TCPStack ( SocketChannel . open ( isa ) , cli ) ; for ( int loop = 0 ; loop < loops ; loop ++ ) { TestMessage tm = new TestMessage ( 42 ) ; client . getMessageInterface ( ) . send ( tm ) ; Collection < SourcedMessage > messages = server . waitForMessage ( 1000 ) ; Iterator < SourcedMessage > i = messages . iterator ( ) ; TestMessage rx = ( TestMessage ) i . next ( ) . getMessage ( ) ; Assert . assertEquals ( tm . value , rx . value ) ; } client . getMessageInterface ( ) . close ( ) ; } @ Test public void testManyMessages ( ) throws IOException , NotListeningException { final int loops = 10000 ; ServerImpl server = new SocketListeningServer ( new InetSocketAddress", "gt": "( serverPort ) ) ;", "prediction": "( defaultAddress , serverPort ) ) ;\n", "label": 1}
{"id": 9781, "input": "<s> import java . util . * ; class CastTest { private class AA < T > { } private class AB < T > extends AA < T > { } private class AC < T > extends AA < Vector < T > > { } private class AD < T > extends AA < Vector < ? extends T > > { } private class AE < T", "gt": "> extends AA < Vector < ? super T > >", "prediction": ">\n", "label": 0}
{"id": 14774, "input": "<s> package org . eclipse . ui . forms ; import org . eclipse . jface . viewers . ISelection ; public interface IPartSelectionListener { public", "gt": "void selectionChanged ( IFormPart part , ISelection selection ) ;", "prediction": "void selectionChanged ( ISelection selection ) ;\n", "label": 1}
{"id": 5119, "input": "<s> enum NoFinal2 { A , B , C ; protected void finalize ( ) { System . err", "gt": ". println ( \"FISK\" ) ;", "prediction": ". println ( \"\" ) ;\n", "label": 0}
{"id": 14779, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . server ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocument ; import org . nuxeo . ecm . platform . publisher . helper . VersioningHelper ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . ExtendedDocumentLocation ; public class ExternalCorePublishedDocument implements PublishedDocument { private static final long serialVersionUID = 1L ; protected String sourceServer ; protected String repositoryName ; protected DocumentRef ref ; protected String versionLabel ; protected String path ; protected String parentPath ; protected boolean isPending ; public ExternalCorePublishedDocument ( DocumentModel doc ) throws ClientException { ExtendedDocumentLocation xLoc = ExtendedDocumentLocation . extractFromDoc ( doc ) ; this . sourceServer = xLoc . getOriginalServer ( ) ; this .", "gt": "repositoryName = xLoc . getServerName ( ) ;", "prediction": "repositoryName = xLoc . getRepositoryName ( ) ;\n", "label": 1}
{"id": 6646, "input": "<s> package com . sun . tools . javac . api ; import java . io . File ; import java . io . IOException ; import java . nio . CharBuffer ; import java . util . * ; import java . util . concurrent . atomic . AtomicBoolean ; import javax . annotation . processing . Processor ; import javax . lang . model . element . Element ; import javax . lang . model . element . TypeElement ; import javax . lang . model . type . TypeMirror ; import javax . tools . * ; import com . sun . source . tree . * ; import com . sun . source . util . * ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . comp . * ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . main . * ; import com . sun . tools . javac . model . * ; import com . sun . tools . javac . parser . Parser ; import com . sun . tools . javac . parser . ParserFactory ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . tree . JCTree . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . main . JavaCompiler ; public class JavacTaskImpl extends JavacTask { private ClientCodeWrapper ccw ; private Main compilerMain ; private JavaCompiler compiler ; private Locale locale ; private String [ ] args ; protected Context context ; private List < JavaFileObject > fileObjects ; private Map < JavaFileObject , JCCompilationUnit > notYetEntered ; private ListBuffer < Env < AttrContext > > genList ; protected TaskListener taskListener ; protected AtomicBoolean used = new AtomicBoolean ( ) ; private Iterable < ? extends Processor > processors ; private Integer result = null ; JavacTaskImpl ( Main compilerMain , String [ ] args , Context context , List < JavaFileObject > fileObjects ) { this . ccw = ClientCodeWrapper . instance ( context ) ; this . compilerMain = compilerMain ; this . args = args ; this . context = context ; this . fileObjects = fileObjects ; setLocale ( Locale . getDefault ( ) ) ; compilerMain . getClass ( ) ; args . getClass ( ) ; fileObjects . getClass ( ) ; } protected JavacTaskImpl ( Main compilerMain , Iterable < String > flags , Context context , Iterable < String > classes , Iterable < ? extends JavaFileObject > fileObjects ) { this ( compilerMain , toArray ( flags , classes ) , context , toList ( fileObjects ) ) ; } static private String [ ] toArray ( Iterable < String > flags , Iterable < String > classes ) { ListBuffer < String > result = new ListBuffer < String > ( ) ; if ( flags != null ) for ( String flag : flags ) result . append ( flag ) ; if ( classes != null ) for ( String cls : classes ) result . append ( cls ) ; return result . toArray ( new String [ result . length ( ) ] ) ; } static private List < JavaFileObject > toList ( Iterable < ? extends JavaFileObject > fileObjects ) { if ( fileObjects == null ) return List . nil ( ) ; ListBuffer < JavaFileObject > result = new ListBuffer < JavaFileObject > ( ) ; for ( JavaFileObject fo : fileObjects ) result . append ( fo ) ; return result . toList ( ) ; } public Boolean call ( ) { if ( ! used", "gt": ". getAndSet ( true ) )", "prediction": ". get ( ) )\n", "label": 0}
{"id": 14787, "input": "<s> package litil . lexer ; public class LexingException extends RuntimeException { public final String line ; public final int row ; public final int col ; public LexingException ( String error , String line , int row , int col ) { super ( error + \" @ \" + row + \":\" + col + \"\\n\" + line + \"\\n\" + nspaces ( col ) + \"^\" ) ; this . line = line ; this . row = row ; this . col = col ; } private static String nspaces ( int n ) { StringBuilder res = new StringBuilder ( \"\" ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res . append ( \" \" ) ; } return", "gt": "res . toString ( ) ;", "prediction": "res . toString ( ) ;\n", "label": 1}
{"id": 4981, "input": "<s> package com . sun . tools . classfile ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Iterator ; public class ConstantPool { public static class InvalidIndex extends ConstantPoolException { private static final long serialVersionUID = - 4350294289300939730L ; InvalidIndex ( int index ) { super ( index ) ; } @ Override public String getMessage ( ) { return \"invalid index #\" + index ; } } public static class UnexpectedEntry extends ConstantPoolException { private static final long serialVersionUID = 6986335935377933211L ; UnexpectedEntry ( int index , int expected_tag , int found_tag ) { super ( index ) ; this . expected_tag = expected_tag ; this . found_tag = found_tag ; } @ Override public String getMessage ( ) { return \"unexpected entry at #\" + index + \" -- expected tag \" + expected_tag + \", found \" + found_tag ; } public final int expected_tag ; public final int found_tag ; } public static class InvalidEntry extends ConstantPoolException { private static final long serialVersionUID = 1000087545585204447L ; InvalidEntry ( int index , int tag ) { super ( index ) ; this . tag = tag ; } @ Override public String getMessage ( ) { return \"unexpected tag at #\" + index + \": \" + tag ; } public final int tag ; } public static class EntryNotFound extends ConstantPoolException { private static final long serialVersionUID = 2885537606468581850L ; EntryNotFound ( Object value ) { super ( - 1 ) ; this . value = value ; } @ Override public String getMessage ( ) { return \"value not found: \" + value ; } public final Object value ; } public static final int CONSTANT_Utf8 = 1 ; public static final int CONSTANT_Integer = 3 ; public static final int CONSTANT_Float = 4 ; public static final int CONSTANT_Long = 5 ; public static final int CONSTANT_Double = 6 ; public static final int CONSTANT_Class = 7 ; public static final int CONSTANT_String = 8 ; public static final int CONSTANT_Fieldref = 9 ; public static final int CONSTANT_Methodref = 10 ; public static final int CONSTANT_InterfaceMethodref = 11 ; public static final int CONSTANT_NameAndType = 12 ; public static final int CONSTANT_MethodHandle = 15 ; public static final int CONSTANT_MethodType = 16 ; public static final int CONSTANT_InvokeDynamic = 18 ; public static enum RefKind { REF_getField ( 1 , \"getfield\" ) , REF_getStatic ( 2 , \"getstatic\" ) , REF_putField ( 3 , \"putfield\" ) , REF_putStatic ( 4 , \"putstatic\" ) , REF_invokeVirtual ( 5 , \"invokevirtual\" ) , REF_invokeStatic ( 6 , \"invokestatic\" ) , REF_invokeSpecial ( 7 , \"invokespecial\" ) , REF_newInvokeSpecial ( 8 , \"newinvokespecial\" ) , REF_invokeInterface ( 9 , \"invokeinterface\" ) ; public final int tag ; public final String name ; RefKind ( int tag , String name ) { this . tag = tag ; this . name = name ; } static RefKind getRefkind ( int tag ) { switch ( tag ) { case 1 : return REF_getField ; case 2 : return REF_getStatic ; case 3 : return REF_putField ; case 4 : return REF_putStatic ; case 5 : return REF_invokeVirtual ; case 6 : return REF_invokeStatic ; case 7 : return REF_invokeSpecial ; case 8 : return REF_newInvokeSpecial ; case 9 : return REF_invokeInterface ; default : return null ; } } } ConstantPool ( ClassReader cr ) throws IOException , InvalidEntry { int count = cr . readUnsignedShort ( ) ; pool = new CPInfo [ count ] ; for ( int i = 1 ; i < count ; i ++ ) { int tag = cr . readUnsignedByte ( ) ; switch ( tag ) { case CONSTANT_Class : pool [ i ] = new CONSTANT_Class_info ( this , cr ) ; break ; case CONSTANT_Double : pool [ i ] = new CONSTANT_Double_info ( cr ) ; i ++ ; break ; case CONSTANT_Fieldref : pool [ i ] = new CONSTANT_Fieldref_info ( this , cr ) ; break ; case CONSTANT_Float : pool [ i ] = new CONSTANT_Float_info ( cr ) ; break ; case CONSTANT_Integer : pool [ i ] = new CONSTANT_Integer_info ( cr ) ; break ; case CONSTANT_InterfaceMethodref : pool [ i ] = new CONSTANT_InterfaceMethodref_info ( this , cr ) ; break ; case CONSTANT_InvokeDynamic : pool [ i ] = new CONSTANT_InvokeDynamic_info ( this , cr ) ; break ; case CONSTANT_Long : pool [ i ] = new CONSTANT_Long_info ( cr ) ; i ++ ; break ; case CONSTANT_MethodHandle : pool [ i ] = new CONSTANT_MethodHandle_info ( this , cr ) ; break ; case CONSTANT_MethodType : pool [ i ] = new CONSTANT_MethodType_info ( this , cr ) ; break ; case CONSTANT_Methodref : pool [ i ] = new CONSTANT_Methodref_info ( this , cr ) ; break ; case CONSTANT_NameAndType : pool [ i ] = new CONSTANT_NameAndType_info ( this , cr ) ; break ; case CONSTANT_String : pool [ i ] = new CONSTANT_String_info ( this , cr ) ; break ; case CONSTANT_Utf8 : pool [ i ] = new CONSTANT_Utf8_info ( cr ) ; break ; default : throw new InvalidEntry ( i , tag ) ; } } } public ConstantPool ( CPInfo [ ] pool ) { this . pool = pool ; } public int size ( ) { return pool . length ; } public int byteLength ( ) { int length = 2 ; for ( int i = 1 ; i < size ( ) ; ) { CPInfo cpInfo = pool [ i ] ; length += cpInfo . byteLength ( ) ; i += cpInfo . size ( ) ; } return length ; } public CPInfo get ( int index ) throws InvalidIndex { if ( index <= 0 || index >= pool . length ) throw new InvalidIndex ( index ) ; CPInfo info = pool [ index ] ; if ( info == null ) { throw new InvalidIndex ( index ) ; } return pool [ index ] ; } private CPInfo get ( int index , int expected_type ) throws InvalidIndex , UnexpectedEntry { CPInfo info = get ( index ) ; if ( info . getTag ( ) != expected_type ) throw new UnexpectedEntry ( index , expected_type , info . getTag ( ) ) ; return info ; } public CONSTANT_Utf8_info getUTF8Info (", "gt": "int index ) throws InvalidIndex , UnexpectedEntry", "prediction": ")\n", "label": 0}
{"id": 14793, "input": "<s> package org . apache . sqoop . util ; import java . sql . SQLException ; import org . apache . commons . logging . Log ; import org . apache . log4j . Level ; import org . apache . log4j . Logger ; public final class LoggingUtils { private LoggingUtils ( ) { } public static void logAll ( Log log , SQLException e ) { log . error ( \"Top level exception: \" , e ) ; e = e . getNextException ( ) ; int indx = 1 ; while ( e != null ) { log . error ( \"Chained", "gt": "exception \" + indx + \": \" , e ) ;", "prediction": "exception: \" , e ) ;\n", "label": 1}
{"id": 5379, "input": "<s> package javax . lang . model . element ; import java . util . List ; import javax . lang . model . util . Types ; import javax . lang . model . type . * ; public interface ExecutableElement extends Element , Parameterizable { List < ? extends TypeParameterElement > getTypeParameters ( ) ; TypeMirror getReturnType ( ) ; List < ? extends VariableElement > getParameters ( ) ;", "gt": "boolean isVarArgs ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14796, "input": "<s> package org . eclipse . ui ; public interface IPageService { public void addPageListener ( IPageListener listener ) ; public void addPerspectiveListener ( IPerspectiveListener listener ) ; public IWorkbenchPage getActivePage ( ) ; public void removePageListener ( IPageListener listener ) ; public", "gt": "void removePerspectiveListener ( IPerspectiveListener listener ) ;", "prediction": "IWorkbenchPage getActivePage ( ) ;\n", "label": 1}
{"id": 5195, "input": "<s> public class T5082929 { void test ( Float f , Integer i ) {", "gt": "boolean b = f == i ;", "prediction": "}\n", "label": 0}
{"id": 14797, "input": "<s> package org . spliffy . server . apps . admin . users ; import com . bradmcevoy . http . CollectionResource ; import com . bradmcevoy . http . Resource ; import org . spliffy . server . web . templating . MenuItem ; import java . util . List ; import org . spliffy . server . apps . AppConfig ; import org . spliffy . server . apps . Application ; import org . spliffy . server . db . Profile ; import org . spliffy . server . apps . orgs . OrganisationFolder ; import org . spliffy . server . web . RootFolder ; import org . spliffy . server . web . SpliffyCollectionResource ; import org . spliffy . server . web . SpliffyResourceFactory ; public class UserAdminApp implements Application { private SpliffyResourceFactory resourceFactory ; @ Override public String getInstanceId ( ) { return \"manageUsers\" ; } @ Override public void init ( SpliffyResourceFactory resourceFactory , AppConfig config ) throws Exception { this . resourceFactory = resourceFactory ; } @ Override public Resource getPage ( Resource parent , String requestedName ) { if ( parent instanceof OrganisationFolder ) { if ( requestedName . equals ( \"manageUsers\" ) ) { OrganisationFolder orgFolder = ( OrganisationFolder ) parent ; return new UserAdminPage ( requestedName , orgFolder . getOrganisation ( ) , ( SpliffyCollectionResource ) parent , resourceFactory . getServices ( ) ) ; } } return null ; } @ Override public void addBrowseablePages (", "gt": "CollectionResource parent , List < Resource > children )", "prediction": "List < Page > browseablePages )\n", "label": 1}
{"id": 9653, "input": "<s> package org . msl . simple . gmf . bridge . transform ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . HashMap ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . preferences . AbstractPreferenceInitializer ; import org . eclipse . core . runtime . preferences . DefaultScope ; import org . eclipse . core . runtime . preferences . InstanceScope ; import org . eclipse . gmf . internal . bridge . ui . Plugin ; import org . osgi . service . prefs . BackingStoreException ; import org . osgi . service . prefs . Preferences ; public class TransformOptions extends AbstractPreferenceInitializer { private static final String PREF_GENERATE_RCP = \"generate_rcp\" ; private static final String PREF_USE_MAP_MODE = \"use_map_mode\" ; private static final String PREF_USE_RUNTIME_FIGURES = \"use_runtime_figures\" ; private static final String PREF_IGNORE_MAPMODEL_VALIDATION = \"ignore_mapmodel_validation\" ; private static final String PREF_IGNORE_GMFGEN_VALIDATION = \"ignore_gmfgen_validation\" ; private static final String PREF_FIGURE_TEMPLATES = \"dynamic_figure_templates\" ; private static final String PREF_MAIN_TRANSFORM = \"main-qvto\" ; private static final String PREF_PRE_RECONCILE_TRANSFORM = \"pre-reconcile-qvto\" ; private static final String PREF_POST_RECONCILE_TRANSFORM = \"post-reconcile-qvto\" ; private static String [ ] PROP_NAMES = new String [ ] { PREF_GENERATE_RCP , PREF_USE_MAP_MODE , PREF_USE_RUNTIME_FIGURES , PREF_IGNORE_MAPMODEL_VALIDATION , PREF_IGNORE_GMFGEN_VALIDATION , PREF_FIGURE_TEMPLATES , PREF_MAIN_TRANSFORM , PREF_PRE_RECONCILE_TRANSFORM , PREF_POST_RECONCILE_TRANSFORM , } ; private Preferences myContextPrefs ; private Preferences myGlobalPrefs ; private final HashMap < String , String > myInMemPrefs = new HashMap < String , String > ( ) ; private final String myNoValueToken = new String ( \"no value\" ) ; public TransformOptions ( ) { } public void setContext ( Preferences contextPrefs ) { if ( myContextPrefs != contextPrefs ) { myContextPrefs = contextPrefs ; reset ( ) ; } } public void reset ( ) { myInMemPrefs . clear ( ) ; } public void flush ( ) { try { for ( String k : myInMemPrefs . keySet ( ) ) { String v = myInMemPrefs . get ( k ) ; if ( v != myNoValueToken ) { getGlobalPrefs ( ) . put ( k , v ) ; } } getGlobalPrefs ( ) . flush ( ) ; if ( myContextPrefs != null ) { for ( String k : PROP_NAMES ) { String v = getWithContexts ( k ) ; if ( v != null && v != myNoValueToken ) { myContextPrefs . put ( k , v ) ; } } myContextPrefs . flush ( ) ; } } catch ( BackingStoreException ex ) { Plugin . log ( ex ) ; } } public boolean getGenerateRCP ( ) { return getBoolean ( PREF_GENERATE_RCP ) ; } public boolean getUseMapMode ( ) { return getBoolean ( PREF_USE_MAP_MODE ) ; } public boolean getUseRuntimeFigures ( ) { return getBoolean ( PREF_USE_RUNTIME_FIGURES ) ; } public boolean getIgnoreMapModelValidation ( ) { return getBoolean ( PREF_IGNORE_MAPMODEL_VALIDATION ) ; } public boolean getIgnoreGMFGenValidation ( ) { return getBoolean ( PREF_IGNORE_GMFGEN_VALIDATION ) ; } public URL getFigureTemplatesPath ( ) { return getURL ( PREF_FIGURE_TEMPLATES ) ; } public URL getMainTransformation ( ) { return getURL ( PREF_MAIN_TRANSFORM ) ; } public URL getPreReconcileTransform ( ) { return getURL ( PREF_PRE_RECONCILE_TRANSFORM ) ; } public URL getPostReconcileTransform ( ) { return getURL ( PREF_POST_RECONCILE_TRANSFORM ) ; } public void setGenerateRCP ( boolean value ) { myInMemPrefs . put ( PREF_GENERATE_RCP , Boolean . toString ( value ) ) ; } public void setUseMapMode ( boolean value ) { myInMemPrefs . put", "gt": "( PREF_USE_MAP_MODE , Boolean . toString ( value ) ) ;", "prediction": "( PREF_USE_MAP_MODE , Boolean . toString ( value ) ) ;\n", "label": 0}
{"id": 14799, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . Version ; public class TestMatchAllDocsQuery extends LuceneTestCase { private Analyzer analyzer = new StandardAnalyzer ( Version . LUCENE_CURRENT ) ; public void testQuery ( ) throws Exception { RAMDirectory dir = new RAMDirectory ( ) ; IndexWriter iw = new IndexWriter ( dir , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; iw . setMaxBufferedDocs ( 2 ) ; addDoc ( \"one\" , iw , 1f ) ; addDoc ( \"two\" , iw , 20f ) ; addDoc ( \"three four\" , iw , 300f ) ; iw . close ( ) ; IndexReader ir = IndexReader . open ( dir ) ; IndexSearcher is = new IndexSearcher ( ir ) ; ScoreDoc [ ] hits ; hits = is . search ( new MatchAllDocsQuery ( ) , null , 1000 ) . scoreDocs ; assertEquals ( 3 , hits . length ) ; assertEquals ( \"one\" , ir . document ( hits [ 0 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"two\" , ir . document ( hits [ 1 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"three four\" , ir . document ( hits [ 2 ] . doc ) . get ( \"key\" ) ) ; MatchAllDocsQuery normsQuery = new MatchAllDocsQuery ( \"key\" ) ; hits = is . search ( normsQuery , null , 1000 ) . scoreDocs ; assertEquals ( 3 , hits . length ) ; assertEquals ( \"three four\" , ir . document ( hits [ 0 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"two\" , ir . document ( hits [ 1 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"one\" , ir . document ( hits [ 2 ] . doc ) . get ( \"key\" ) ) ; ir . setNorm ( 0 , \"key\" , 400f ) ; normsQuery = new MatchAllDocsQuery ( \"key\" ) ; hits = is . search ( normsQuery , null , 1000 ) . scoreDocs ; assertEquals ( 3 , hits . length ) ; assertEquals ( \"one\" , ir . document ( hits [ 0 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"three four\" , ir . document ( hits [ 1 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"two\" , ir . document ( hits [ 2 ] . doc ) . get ( \"key\" ) ) ; BooleanQuery bq = new BooleanQuery ( ) ; bq . add ( new MatchAllDocsQuery ( ) , BooleanClause . Occur . MUST ) ; bq . add ( new MatchAllDocsQuery ( ) , BooleanClause . Occur . MUST ) ; hits = is . search ( bq , null , 1000 ) . scoreDocs ; assertEquals (", "gt": "3 , hits . length ) ;", "prediction": "3 , hits . length ) ;\n", "label": 1}
{"id": 530, "input": "<s> public abstract class ArrayDims5 { abstract int [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] f ( ) [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]", "gt": "[ ] [ ] [ ] ;", "prediction": "}\n", "label": 0}
{"id": 14800, "input": "<s> package org . restlet . test . service ; import junit . framework . Test ; import junit . framework . TestSuite ; public class ServiceTestSuite { public static Test suite ( ) { TestSuite suite =", "gt": "new TestSuite ( \"Service package\" ) ;", "prediction": "new TestSuite ( ) ;\n", "label": 1}
{"id": 9349, "input": "<s> @ java . lang . annotation . Target ( { FIELD } ) @ interface foo { }", "gt": "@ foo public class WrongTarget", "prediction": ";\n", "label": 0}
{"id": 14803, "input": "<s> package org . nuxeo . ecm . automation ; import org . nuxeo . ecm . core . api . DocumentModel ; public class ConflictOperationException extends OperationException { private static final long serialVersionUID = 1L ; public ConflictOperationException ( DocumentModel doc ) { super ( \"Conflict detected while trying to update document \" + doc .", "gt": "getId ( ) ) ;", "prediction": "getId ( ) ) ;\n", "label": 1}
{"id": 8112, "input": "<s> package com . midtro . platform . math ; public class Vector2 { public int x ; public int y ; public Vector2 ( ) { } public Vector2 ( final int [ ] coords ) { x = coords [ 0 ] ; y = coords [ 1 ] ; } public Vector2 ( final Vector2 other ) { this ( other . x , other . y ) ; } public Vector2 ( final int x , final int y ) { this . x = x ; this . y = y ; } public void set ( final Vector2 other ) { set ( other . x , other . y ) ; } public void set ( final int x , final int y ) { this . x = x ; this . y = y ; } public Vector2 copy ( ) { return new Vector2 ( x , y ) ; } @ Override public String toString ( ) { return \"<\" + x + \", \" + y + \">\" ; } public float distance ( final Vector2 other ) { final int dx = other . x - x ; final int dy = other . y - y ; return ( int ) Math . sqrt ( ( dx * dx ) + ( dy * dy ) ) ; } @ Override public int hashCode ( ) { return 997 * ( x ) ^ 991 * ( y ) ; }", "gt": "@ Override public boolean equals ( final Object other )", "prediction": "}\n", "label": 0}
{"id": 14804, "input": "<s> package org . eclipse . swt . internal . widgets . listkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . util . Arrays ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . * ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . IListAdapter ; import org . eclipse . swt . internal . widgets . Props ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . * ; import org . json . JSONArray ; import org . json . JSONException ; import org . mockito . ArgumentCaptor ; public class ListLCA_Test extends TestCase { private Display display ; private Shell shell ; private ListLCA lca ; private List list ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; list = new List ( shell , SWT . NONE ) ; lca = new ListLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { ControlLCATestUtil . testActivateListener ( list ) ; ControlLCATestUtil . testFocusListener ( list ) ; ControlLCATestUtil . testMouseListener ( list ) ; ControlLCATestUtil . testKeyListener ( list ) ; ControlLCATestUtil . testTraverseListener ( list ) ; ControlLCATestUtil . testMenuDetectListener ( list ) ; ControlLCATestUtil . testHelpListener ( list ) ; } public void testPreserveValues ( ) { Fixture . markInitialized ( display ) ; Fixture . preserveWidgets ( ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . TRUE , adapter . getPreserved ( Props . ENABLED ) ) ; Fixture . clearPreserved ( ) ; list . setEnabled ( false ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . FALSE , adapter . getPreserved ( Props . ENABLED ) ) ; Fixture . clearPreserved ( ) ; list . setEnabled ( true ) ; list . setSize ( 10 , 10 ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . TRUE , adapter . getPreserved ( Props . VISIBLE ) ) ; Fixture . clearPreserved ( ) ; list . setVisible ( false ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . FALSE , adapter . getPreserved ( Props . VISIBLE ) ) ; Fixture . clearPreserved ( ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( null , adapter . getPreserved ( Props . MENU ) ) ; Fixture . clearPreserved ( ) ; Menu menu = new Menu ( list ) ; MenuItem item = new MenuItem ( menu , SWT . NONE ) ; item . setText ( \"1 Item\" ) ; list . setMenu ( menu ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( menu , adapter . getPreserved ( Props . MENU ) ) ; Fixture . clearPreserved ( ) ; list . getFocusIndex ( ) ; Rectangle rectangle = new Rectangle ( 10 , 10 , 30 , 50 ) ; list . setBounds ( rectangle ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( rectangle , adapter . getPreserved ( Props . BOUNDS ) ) ; Fixture . clearPreserved ( ) ; Color background = Graphics . getColor ( 122 , 33 , 203 ) ; list . setBackground ( background ) ; Color foreground = Graphics . getColor ( 211 , 178 , 211 ) ; list . setForeground ( foreground ) ; Font font = Graphics . getFont ( \"font\" , 12 , SWT . BOLD ) ; list . setFont ( font ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( background , adapter . getPreserved ( Props . BACKGROUND ) ) ; assertEquals ( foreground , adapter . getPreserved ( Props . FOREGROUND ) ) ; assertEquals ( font , adapter . getPreserved ( Props . FONT ) ) ; Fixture . clearPreserved ( ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( null , list . getToolTipText ( ) ) ; Fixture . clearPreserved ( ) ; list . setToolTipText ( \"some text\" ) ; Fixture . preserveWidgets ( ) ;", "gt": "adapter = WidgetUtil . getAdapter ( list ) ;", "prediction": "adapter = WidgetUtil . getAdapter ( list ) ;\n", "label": 1}
{"id": 8752, "input": "<s> public class Test < T > { < T extends Test < ? super Number > > T m1 ( T t ) { return m2 ( t ) ; } < T extends Test < ? super", "gt": "Number > > T m2 ( T t )", "prediction": "Number > > T m3 ( T t )\n", "label": 0}
{"id": 14820, "input": "<s> package br . org . archimedes . trimmers ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . trimmers . LineTrimmer ; import br . org . archimedes . trims . interfaces . Trimmer ; import org . junit . Assert ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; public class LineTrimTest extends Tester { Trimmer trimmer = new LineTrimmer ( ) ; Collection < Point > cutPoints = new ArrayList < Point > ( ) ; public void setUp ( ) throws NullArgumentException , InvalidArgumentException { } @ Test public void testNullLineArgument ( ) { try { trimmer . trim ( null , cutPoints , new Point ( 0.0 , 0.0 ) ) ; } catch ( NullArgumentException e ) { Assert . assertTrue ( \"Should throw null argument exception\" , true ) ; return ; } Assert . assertFalse ( \"Should throw null argument exception\" , true ) ; } @ Test public void testNullcutPointsArgument ( ) throws InvalidArgumentException , NullArgumentException { Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ; try { trimmer . trim ( line , null , new Point ( 0.0 , 0.0 ) ) ; } catch ( NullArgumentException e ) { Assert . assertTrue ( \"Should throw null argument exception\" , true ) ; return ; } Assert . assertFalse ( \"Should throw null argument exception\" , true ) ; } @ Test public void lineTrimsCenter ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( 0.0 , 2.0 ) ) ; cutPoints . add ( new Point ( 2.0 , 2.0 ) ) ; Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ; Collection < Element > collection = trimmer . trim ( line , cutPoints , new Point ( 1.0 , 2.0 ) ) ; assertCollectionContains ( collection , new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 0.0 , 2.0 ) ) ) ; assertCollectionContains ( collection , new Line ( new Point ( 2.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ) ; Assert . assertEquals ( \"A trim at the middle of cutPoints should produce 2 lines.\" , 2 , collection . size ( ) ) ; } @ Test public void lineTrimsEndingPortionOfLine ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( 0.0 , 2.0 ) ) ; cutPoints . add ( new Point ( 2.0 , 2.0 ) ) ; Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ; Collection < Element > collection = trimmer . trim ( line , cutPoints , new Point ( - 0.5 , 2.0 ) ) ; assertCollectionContains ( collection , new Line ( new Point ( 0.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ) ; Assert . assertEquals ( \"A trim at the end of line should produce 1 lines\" , 1 , collection . size ( ) ) ; } @ Test public void lineTrimsExtremePoint ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( 0.0 , 2.0 ) ) ; cutPoints . add ( new Point ( 2.0 , 2.0 ) ) ; Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 2.0 , 2.0 ) ) ; Collection < Element > collection = trimmer . trim ( line , cutPoints , new Point (", "gt": "1.0 , 2.0 ) ) ;", "prediction": "- 1.0 , 2.0 ) ) ;\n", "label": 1}
{"id": 380, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface LogicalAbsoluteIdExression extends LogicalExpression { String getValue ( ) ; void", "gt": "setValue ( String value ) ;", "prediction": "setValue ( String value ) ;\n", "label": 0}
{"id": 14824, "input": "<s> package org . eclipse . ui . internal . forms . widgets ; import java . util . Hashtable ; import java . util . Vector ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . ui . forms . internal . widgets . IAggregateHyperlinkSegmentAdapter ; public class AggregateHyperlinkSegment extends ParagraphSegment implements IHyperlinkSegment , Adaptable { private String href ; private Vector segments = new Vector ( ) ; private IAggregateHyperlinkSegmentAdapter aggregateHyperlinkSegmentAdapter ; public AggregateHyperlinkSegment ( ) { } public Object getAdapter ( Class adapter ) { Object result = null ; if ( adapter == IAggregateHyperlinkSegmentAdapter . class ) { if ( aggregateHyperlinkSegmentAdapter == null ) { aggregateHyperlinkSegmentAdapter = new IAggregateHyperlinkSegmentAdapter ( ) { public Object [ ] getHyperlinkSegments ( ) { return segments . toArray ( ) ; } } ; } result = aggregateHyperlinkSegmentAdapter ; } return result ; } public void add ( TextHyperlinkSegment segment ) { segments . add ( segment ) ; } public void add ( ImageHyperlinkSegment segment ) { segments . add ( segment ) ; } public boolean advanceLocator ( GC gc , int wHint , Locator loc , Hashtable objectTable , boolean computeHeightOnly ) { boolean newLine = false ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { ParagraphSegment segment = ( ParagraphSegment ) segments . get ( i ) ; if ( segment . advanceLocator ( gc , wHint , loc , objectTable , computeHeightOnly ) ) newLine = true ; } return newLine ; } public String getHref ( ) { return href ; } public void setHref ( String href ) { this . href = href ; } public String getText ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; buf . append ( segment . getText ( ) ) ; } return buf . toString ( ) ; } public Rectangle getBounds ( ) { Rectangle bounds = new Rectangle ( Integer . MAX_VALUE , Integer . MAX_VALUE , 0 , 0 ) ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; Rectangle sbounds = segment . getBounds ( ) ; bounds . x = Math . min ( bounds . x , sbounds . x ) ; bounds . y = Math . min ( bounds . y , sbounds . y ) ; bounds . width = Math . max ( bounds . width , sbounds . width ) ; bounds . height = Math . max ( bounds . height , sbounds . height ) ; } return bounds ; } public boolean contains ( int x , int y ) { for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; if ( segment . contains ( x , y ) ) return true ; } return false ; } public boolean intersects ( Rectangle rect ) { for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; if ( segment . intersects ( rect ) ) return true ; } return false ; } public void layout ( GC gc , int", "gt": "width , Locator locator , Hashtable resourceTable , boolean selected )", "prediction": "wHint )\n", "label": 1}
{"id": 5899, "input": "<s> package org . ofbiz . datafile ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) public class ModelField implements Serializable { public String name = \"\" ; public int position = - 1 ; public int length = - 1 ; public String type = \"\" ; public String format = \"\" ; public String validExp = \"\" ; public String description = \"\" ; public Object defaultValue = null ; public boolean isPk = false ; public boolean ignored = false ; public boolean expression = false ; public String refField = null ; public String getName ( ) { return name ; } public void setName ( String name ) { this", "gt": ". name = name ;", "prediction": ". name = name ;\n", "label": 0}
{"id": 14825, "input": "<s> package org . apache . lucene . search . payloads ; import java . io . Serializable ; public abstract class PayloadFunction implements Serializable { public abstract float currentScore ( int docId , String field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) ; public abstract float docScore ( int docId , String field , int numPayloadsSeen", "gt": ", float payloadScore ) ;", "prediction": ", float currentScore , float currentPayloadScore ) ;\n", "label": 1}
{"id": 4154, "input": "<s> package com . sun . mirror . type ; @ Deprecated @ SuppressWarnings ( \"deprecation\" )", "gt": "public interface ReferenceType extends TypeMirror", "prediction": "public class Type\n", "label": 0}
{"id": 14826, "input": "<s> package org . restlet . ext . xml ; import java . io . IOException ; import java . util . List ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . converter . ConverterHelper ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; import org . w3c . dom . Document ; public class XmlConverter extends ConverterHelper { private static final VariantInfo VARIANT_APPLICATION_ALL_XML = new VariantInfo ( MediaType . APPLICATION_ALL_XML ) ; private static final VariantInfo VARIANT_APPLICATION_XML = new VariantInfo ( MediaType . APPLICATION_XML ) ; private static final VariantInfo VARIANT_TEXT_XML = new VariantInfo ( MediaType . TEXT_XML ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; if ( VARIANT_APPLICATION_ALL_XML . isCompatible ( source ) || VARIANT_APPLICATION_XML . isCompatible ( source ) || VARIANT_TEXT_XML . isCompatible ( source ) ) { result = addObjectClass ( result , Document . class ) ; result = addObjectClass ( result , DomRepresentation . class ) ; result = addObjectClass ( result , SaxRepresentation . class ) ; } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( Document . class . isAssignableFrom ( source ) || DomRepresentation . class . isAssignableFrom ( source ) || SaxRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_APPLICATION_ALL_XML ) ; result = addVariant ( result , VARIANT_APPLICATION_XML ) ; result = addVariant ( result , VARIANT_TEXT_XML ) ; } return result ; } @ Override public float score ( Object source , Variant target , Resource resource ) { float result = - 1.0F ; if ( source instanceof Document ) { if ( target == null ) { result = 0.5F ; } else if ( MediaType . APPLICATION_ALL_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.8F ; } else if ( MediaType . APPLICATION_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.9F ; } else if ( MediaType . TEXT_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.9F ; } else { result = 0.5F ; } } return result ; } @ Override public < T > float score ( Representation source , Class < T > target , Resource resource ) { float result = - 1.0F ; if ( ( target != null ) && ( Document . class . isAssignableFrom ( target ) || DomRepresentation . class . isAssignableFrom ( target ) || SaxRepresentation . class . isAssignableFrom ( target ) ) ) { if ( MediaType . APPLICATION_ALL_XML . isCompatible ( source . getMediaType ( ) ) ) { result = 0.8F ; } else if ( MediaType . APPLICATION_XML . isCompatible ( source . getMediaType ( ) ) ) { result = 0.9F ; } else if ( MediaType . TEXT_XML . isCompatible ( source . getMediaType ( ) ) ) { result = 0.9F ; } else { result = 0.5F ; } } return result ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public < T > T toObject ( Representation source , Class < T > target , Resource resource ) throws IOException { Object result = null ; if ( Document . class . isAssignableFrom ( target ) ) { result = new DomRepresentation ( source ) . getDocument ( ) ; } else if ( DomRepresentation . class . isAssignableFrom ( target ) ) { result = new DomRepresentation ( source ) ; } else if ( SaxRepresentation . class . isAssignableFrom ( target ) ) { result = new SaxRepresentation ( source ) ; } return ( T ) result ; } @ Override public Representation toRepresentation ( Object source , Variant target , Resource resource ) throws IOException { Representation result = null ; if ( source instanceof Document ) { result = new DomRepresentation ( target . getMediaType ( ) , ( Document ) source ) ; } else", "gt": "if ( source instanceof Representation )", "prediction": "if ( source instanceof DomRepresentation )\n", "label": 1}
{"id": 1052, "input": "<s> package com . shopzilla . api . client . model ; import com . shopzilla . api . client . model . response . MerchantResponse ; import com . shopzilla . services . catalog . MerchInfoType ; import com . shopzilla . services . catalog . MerchantsResponse ; import org . apache . commons . lang . StringUtils ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import static org . junit . Assert . assertTrue ; public class MerchantModelAdapterTest { @ Test public void testFromCatalogAPI ( ) throws Exception { MerchantsResponse input = generateInput ( ) ; MerchantResponse expectedOutput = generateExpectedOutput ( ) ; assertTrue ( areEquals ( expectedOutput , MerchantModelAdapter . fromCatalogAPI ( input ) ) ) ; } private MerchantsResponse generateInput ( ) { MerchantsResponse response = new MerchantsResponse ( ) ; MerchantsResponse . Merchant merchant = new MerchantsResponse . Merchant ( ) ; merchant . setMid ( 123L ) ; MerchInfoType merchantInfo = new MerchInfoType ( ) ; merchant . setMerchantInfo ( merchantInfo ) ; merchantInfo . setCountryCode ( \"US\" ) ; merchantInfo . setLogoUrl ( \"logoUrl\" ) ; merchantInfo . setName ( \"name\" ) ; merchantInfo . setUrl ( \"url\" ) ; response . getMerchant ( ) . add ( merchant ) ; return response ; } private MerchantResponse generateExpectedOutput ( ) { MerchantResponse response = new MerchantResponse ( ) ; List < MerchantInfo > merchantInfos = new ArrayList < MerchantInfo > ( ) ; MerchantInfo merchantInfo = new MerchantInfo ( ) ; merchantInfo . setCountryCode ( \"US\" ) ; merchantInfo . setId ( 123L ) ; merchantInfo . setLogoUrl ( \"logoUrl\" ) ; merchantInfo . setName ( \"name\" ) ; merchantInfo . setUrl ( \"url\" ) ; merchantInfos . add ( merchantInfo ) ; response . setMerchants ( merchantInfos ) ; return response ; } private boolean areEquals ( MerchantResponse first , MerchantResponse second ) { if ( first == null && second == null ) { return true ; } if ( first == null || second == null ) { return false ; } if ( first == second ) { return true ; } if ( ! StringUtils . equals ( first . getServiceUrl ( ) , second . getServiceUrl ( ) ) ) { return false ; } if ( first . getMerchants ( ) == null && second . getMerchants ( ) == null ) { return true ; } if ( first . getMerchants ( ) == null || second . getMerchants ( ) == null ) { return false ; } if ( first . getMerchants ( ) == second . getMerchants ( ) ) { return true ; } if ( first . getMerchants ( ) . size ( ) != second . getMerchants ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < first . getMerchants ( ) . size ( ) ; i ++ ) { if ( ! areMerchantEquals ( first . getMerchants ( ) . get ( i ) , second . getMerchants ( ) . get ( i ) ) ) { return false ; } } return true ; } private boolean areMerchantEquals ( MerchantInfo first , MerchantInfo second ) { if ( first == second ) { return true ; } if ( first == null || second == null ) { return false ; } if ( ! StringUtils . equals ( first . getCountryCode ( ) , second . getCountryCode ( ) ) ) { return false ; } if ( ! StringUtils . equals ( first . getLogoUrl ( ) , second . getLogoUrl ( ) ) ) { return false ; } if ( ! StringUtils . equals ( first . getName ( ) , second . getName ( ) ) ) { return false ; } if ( ! StringUtils . equals ( first . getUrl", "gt": "( ) , second . getUrl ( ) ) )", "prediction": "( ) , second . getUrl ( ) ) )\n", "label": 0}
{"id": 14827, "input": "<s> package com . cloudera . sqoop . mapreduce ; import org . apache . avro . Schema ; import org . apache . hadoop . conf . Configuration ; public final class AvroJob { public static final String MAP_OUTPUT_SCHEMA = org . apache . sqoop . mapreduce . AvroJob . MAP_OUTPUT_SCHEMA ; private AvroJob ( ) { } public static void setMapOutputSchema ( Configuration job , Schema s ) { org . apache . sqoop . mapreduce . AvroJob . setMapOutputSchema ( job , s ) ; } public static Schema getMapOutputSchema ( Configuration job ) { return org . apache .", "gt": "sqoop . mapreduce . AvroJob . getMapOutputSchema ( job ) ;", "prediction": "sqoop . mapreduce . AvroJob . getMapOutputSchema ( job ) ;\n", "label": 1}
{"id": 5554, "input": "<s> class Base { Base ( int i ) { } } class CantRefBeforeConstr extends Base { int i ; CantRefBeforeConstr ( ) {", "gt": "super ( i ) ;", "prediction": "}\n", "label": 0}
{"id": 14836, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; public class SetPropTask extends PerfTask { public SetPropTask ( PerfRunData runData ) { super ( runData ) ; } private String name ; private String value ; public int doLogic ( ) throws Exception { if ( name == null || value == null ) { throw new Exception ( getName ( ) + \" - undefined name or value: name=\" + name + \" value=\" + value ) ; } getRunData ( ) . getConfig ( ) . set ( name , value ) ; return 0 ; } public void setParams ( String params ) { super . setParams ( params ) ; int k = params . indexOf ( \",\" ) ; name = params . substring ( 0 , k ) . trim ( ) ; value = params .", "gt": "substring ( k + 1 ) . trim ( ) ;", "prediction": "substring ( k + 1 ) . trim ( ) ;\n", "label": 1}
{"id": 963, "input": "<s> package org . parboiled . annotations ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java .", "gt": "lang . annotation . Target ;", "prediction": "lang . reflect . Field ;\n", "label": 0}
{"id": 14837, "input": "<s> package com . emf4sw . rdf . sesame ; import java . util . Iterator ; import org . openrdf . model . BNode ; import org . openrdf . model . Graph ; import org . openrdf . model . Literal ; import org . openrdf . model . Resource ; import org . openrdf . model . Statement ; import org . openrdf . model . URI ; import org . openrdf . model . Value ; import org . openrdf . rio . helpers . StatementCollector ; import com . emf4sw . rdf . Node ; import com . emf4sw . rdf . Property ; import com . emf4sw . rdf . RDFFactory ; import com . emf4sw . rdf . RDFGraph ; public class SesameGraph2RDFGraph { public SesameGraph2RDFGraph ( ) { } public void to ( final Graph graph , final RDFGraph aGraph ) { for ( Iterator < Statement > stmtIt = graph . iterator ( ) ; stmtIt . hasNext ( ) ; ) { Statement stmt = stmtIt . next ( ) ; aGraph . addTriple ( asResource ( stmt . getSubject ( ) , aGraph ) , asProperty ( stmt . getPredicate ( ) , aGraph ) , asNode ( stmt . getObject ( ) , aGraph ) ) ; } } public void to ( final StatementCollector source , final RDFGraph aGraph ) { for ( Statement stmt : source . getStatements ( ) ) { aGraph . addTriple ( asResource ( stmt . getSubject ( ) , aGraph ) , asProperty ( stmt . getPredicate ( ) , aGraph ) , asNode ( stmt . getObject ( ) , aGraph ) ) ; } } private Property asProperty ( URI aURI , RDFGraph aGraph ) { return aGraph . getProperty ( aURI . toString ( ) ) ; } private Node asNode ( Value object , RDFGraph aGraph ) { Node aNode = null ; if ( object instanceof Literal ) { aNode = RDFFactory . eINSTANCE . createLiteral ( ) ; ( ( com . emf4sw . rdf . Literal ) aNode ) . setLexicalForm ( ( ( Literal ) object ) . getLabel ( ) ) ; if ( ( ( Literal ) object ) . getLanguage ( ) != null ) { ( ( com . emf4sw . rdf . Literal ) aNode ) . setLang ( ( ( Literal ) object ) . getLanguage ( ) ) ; } if ( ( ( Literal ) object ) .", "gt": "getDatatype ( ) != null )", "prediction": "getDatatype ( ) != null )\n", "label": 1}
{"id": 2788, "input": "<s> package com . redhat . ceylon . compiler . java . test ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import org . junit . runners . model . RunnerScheduler ; public class ConcurrentScheduler implements RunnerScheduler { ThreadPoolExecutor tpool = ( ThreadPoolExecutor ) Executors . newFixedThreadPool ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; @ Override public void schedule ( Runnable r ) { System . out . printf ( \"Submitting task into pool: %s%n\" , r ) ; tpool . execute ( r ) ; } @ Override public void finished ( ) { System . out . printf ( \"Waiting for pool to finish with %d active threads and %d tasks%n\" , tpool .", "gt": "getActiveCount ( ) , tpool . getTaskCount ( ) ) ;", "prediction": "getActiveCount ( ) , tpool . getTaskCount ( ) ) ;\n", "label": 0}
{"id": 14839, "input": "<s> package org . jscsi", "gt": ". parser . tmf ;", "prediction": ". exception . InternetSCSIException ;\n", "label": 1}
{"id": 1533, "input": "<s> package com . matburt . mobileorg . util ; public class OrgFileNotFoundException extends Exception { private static final long serialVersionUID = - 4140326020786885688L ; public OrgFileNotFoundException ( ) { super ( ) ; }", "gt": "public OrgFileNotFoundException ( String message )", "prediction": "public OrgFileNotFoundException ( String message )\n", "label": 0}
{"id": 14842, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . Parameter ; public class BooleanClause implements java . io . Serializable { public static final class Occur extends Parameter implements java . io . Serializable { private Occur ( String name ) { super ( name ) ; } public String toString ( ) { if ( this == MUST ) return \"+\" ; if ( this == MUST_NOT ) return \"-\" ; return \"\" ; } public static final Occur MUST = new Occur ( \"MUST\" ) ; public static final Occur SHOULD = new Occur ( \"SHOULD\" ) ; public static final Occur MUST_NOT = new Occur ( \"MUST_NOT\" ) ; } private Query query ; private Occur occur ; public BooleanClause ( Query query , Occur occur ) { this . query = query ; this . occur = occur ; } public Occur getOccur ( ) { return occur ; } public void setOccur ( Occur occur ) { this . occur = occur ; } public Query getQuery ( ) { return query ; } public void setQuery ( Query query ) { this . query = query ; } public boolean isProhibited ( ) { return Occur . MUST_NOT . equals ( occur ) ; } public boolean isRequired ( ) { return Occur . MUST . equals ( occur ) ; } public boolean equals ( Object o ) { if ( o == null || ! ( o", "gt": "instanceof BooleanClause ) ) return false ;", "prediction": "instanceof BooleanClause ) ) return false ;\n", "label": 1}
{"id": 232, "input": "<s> package com . redhat . ceylon . compiler . java . test ; import javax . tools . Diagnostic ; public class CompilerError implements Comparable < CompilerError > { public final long lineNumber ; public final String message ; public final Diagnostic . Kind kind ; public final String filename ; public CompilerError ( long lineNumber , String message ) { this ( Diagnostic . Kind . ERROR , null , lineNumber , message ) ; } public CompilerError ( Diagnostic . Kind kind , String filename , long lineNumber , String message ) { this . kind = kind ; this . filename = filename ; this . lineNumber = lineNumber ; this . message = message ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( kind == null ) ? 0 : kind . hashCode ( ) ) ; result = prime * result + ( int ) ( lineNumber ^ ( lineNumber > > > 32 ) ) ; result = prime * result + ( ( message == null ) ? 0 : message . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; CompilerError other = ( CompilerError ) obj ; if ( kind != other . kind ) return false ; if ( lineNumber != other . lineNumber ) return false ; if ( message == null ) { if ( other . message != null ) return false ; } else if ( ! message . equals ( other . message ) ) return false ; return true ; } public String toString ( ) { return lineNumber + \": \" + message ; } @ Override public int compareTo ( CompilerError o ) { long cmp = this . kind . compareTo ( o . kind ) ; if ( cmp == 0 ) { cmp = this", "gt": ". lineNumber - o . lineNumber ;", "prediction": ". filename . compareTo ( o . filename ) ;\n", "label": 0}
{"id": 14854, "input": "<s> package org . restlet . engine . io ; import java . io . IOException ; import java . nio . channels . Channel ; public class WrapperChannel < T extends Channel > implements Channel { private T wrappedChannel ; public WrapperChannel ( T wrappedChannel ) { this . wrappedChannel = wrappedChannel ; }", "gt": "public void close ( ) throws IOException", "prediction": "}\n", "label": 1}
{"id": 5509, "input": "<s> public class Increment { int i = 0 ; int j = ( i ) ++ ; int k = ( j ) -- ; int l = ++ ( k ) ; int m =", "gt": "-- ( l ) ;", "prediction": "++ ( m ) ;\n", "label": 0}
{"id": 14857, "input": "<s> package org . apache . lucene . search . similar ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . similar . MoreLikeThis ; public class MoreLikeThisQuery extends Query { private String likeText ; private String [ ] moreLikeFields ; private Analyzer analyzer ; float percentTermsToMatch = 0.3f ; int minTermFrequency = 1 ; int maxQueryTerms = 5 ; Set stopWords = null ; int minDocFreq = - 1 ; public MoreLikeThisQuery ( String likeText , String [ ] moreLikeFields , Analyzer analyzer ) { this . likeText = likeText ; this . moreLikeFields = moreLikeFields ; this . analyzer = analyzer ; } public Query rewrite ( IndexReader reader ) throws IOException { MoreLikeThis mlt = new MoreLikeThis ( reader ) ; mlt . setFieldNames ( moreLikeFields ) ; mlt . setAnalyzer ( analyzer ) ; mlt . setMinTermFreq ( minTermFrequency ) ; if ( minDocFreq >= 0 ) { mlt . setMinDocFreq ( minDocFreq ) ; } mlt . setMaxQueryTerms ( maxQueryTerms ) ; mlt . setStopWords ( stopWords ) ; BooleanQuery bq = ( BooleanQuery ) mlt . like ( new ByteArrayInputStream ( likeText . getBytes ( ) ) ) ; BooleanClause [ ] clauses = bq . getClauses ( ) ; bq . setMinimumNumberShouldMatch ( ( int ) ( clauses . length * percentTermsToMatch ) ) ; return bq ; } public String toString ( String field ) { return \"like:\" + likeText ; } public float getPercentTermsToMatch ( ) { return percentTermsToMatch ; } public void setPercentTermsToMatch ( float percentTermsToMatch ) { this . percentTermsToMatch = percentTermsToMatch ; } public Analyzer getAnalyzer ( ) { return analyzer ; } public void setAnalyzer ( Analyzer analyzer ) { this . analyzer = analyzer ; } public String getLikeText ( ) { return likeText ; } public void setLikeText ( String likeText ) { this . likeText = likeText ; } public int getMaxQueryTerms ( ) { return maxQueryTerms ; } public void setMaxQueryTerms ( int maxQueryTerms ) { this . maxQueryTerms = maxQueryTerms ; } public int getMinTermFrequency ( ) { return minTermFrequency ; } public void setMinTermFrequency ( int minTermFrequency ) { this . minTermFrequency = minTermFrequency ; } public String [ ] getMoreLikeFields ( ) { return moreLikeFields ; } public void setMoreLikeFields ( String [ ] moreLikeFields ) { this . moreLikeFields = moreLikeFields ; } public Set getStopWords ( ) { return stopWords ; } public void setStopWords ( Set stopWords ) { this . stopWords = stopWords ; }", "gt": "public int getMinDocFreq ( )", "prediction": "public Query rewrite ( IndexReader reader ) throws IOException\n", "label": 1}
{"id": 627, "input": "<s> import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; class Main { static int maxLg = 200 ; static Hashtable connections = new Hashtable ( ) ; static Vector v ; static Hashtable parents = new Hashtable ( ) ; static String l [ ] ; static Vector queue = new Vector ( ) ; Main ( ) throws NumberFormatException , IOException { connections . clear ( ) ; int cs = Integer . parseInt ( readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i != cs ; i ++ ) { String l [ ] = split ( readLine ( ) . trim ( ) ) ; if ( ! connections . containsKey ( l [ 0 ] ) ) { connections . put ( l [ 0 ] , new Vector ( ) ) ; } if ( ! connections . containsKey ( l [ 1 ] ) ) { connections . put ( l [ 1 ] , new Vector ( ) ) ; } ( ( Vector ) connections . get ( l [ 0 ] ) ) . addElement ( l [ 1 ] ) ; ( ( Vector ) connections . get ( l [ 1 ] ) ) . addElement ( l [ 0 ] ) ; } l = split ( readLine ( ) . trim ( ) ) ; parents . clear ( ) ; String from = l [ 0 ] , to = l [ 1 ] ; parents . put ( from , from ) ; if ( ! connections . containsKey ( from ) || ! connections . containsKey ( to ) ) { System . out . println ( \"No route\" ) ; return ; } queue . removeAllElements ( ) ; queue . addElement ( from ) ; while ( queue . size ( ) != 0 ) { String next = ( String ) queue . elementAt ( 0 ) ; queue . removeElementAt ( 0 ) ; v = ( ( Vector ) connections . get ( next ) ) ; for ( int i = 0 ; i != v . size ( ) ; i ++ ) { String overNext = ( String ) v . elementAt ( i ) ; if ( overNext .", "gt": "equals ( to ) )", "prediction": "equals ( from ) )\n", "label": 0}
{"id": 14862, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . image . DataBuffer ; import java . awt . image . SinglePixelPackedSampleModel ; import java . awt . image . WritableRaster ; public class XLinearLens extends BLinearLens { int [ ] tmPixelsI , toPixelsI ; short [ ] tmPixelsS , toPixelsS ; byte [ ] tmPixelsB , toPixelsB ; protected double a = 0 ; protected double b = 0 ; double dd = 0 ; public XLinearLens ( ) { this ( 2.0f , 0 , 1 , 100 , 50 , 0 , 0 ) ; } public XLinearLens ( float mm ) { this ( mm , 0 , 1 , 100 , 50 , 0 , 0 ) ; } public XLinearLens ( float mm , float tc , float tf , int outerRadius , int innerRadius ) { this ( mm , tc , tf , outerRadius , innerRadius , 0 , 0 ) ; } public XLinearLens ( float mm , float tc , float tf , int outerRadius , int innerRadius , int x , int y ) { super ( mm , tc , tf , outerRadius , innerRadius , x , y ) ; a = ( 1 - MM ) / ( float ) ( LR1 - LR2 ) ; b = ( MM * LR1 - LR2 ) / ( float ) ( LR1 - LR2 ) ; } void initBuffers ( int mainBufferSize , int magBufferSize ) { switch ( transferType ) { case DataBuffer . TYPE_INT : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; tmPixelsI = new int [ mainBufferSize ] ; toPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_USHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; tmPixelsS = new short [ mainBufferSize ] ; toPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_BYTE : { oPixelsB = new byte [ mainBufferSize ] ; mPixelsB = new byte [ magBufferSize ] ; tPixelsB = new byte [ mainBufferSize ] ; tmPixelsB = new byte [ mainBufferSize ] ; toPixelsB = new byte [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_SHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; tmPixelsS = new short [ mainBufferSize ] ; toPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } default : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; tmPixelsI = new int [ mainBufferSize ] ; toPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } } } public void gf ( float x , float y , float [ ] g ) { dd = Math . sqrt ( Math . pow ( x - sw - lx , 2 ) + Math . pow ( y - sh - ly , 2 ) ) ; if ( dd <= LR2 ) g [ 0 ] = g [ 1 ] = MM ; else if ( dd <= LR1 ) g [ 0 ] = g [ 1 ] = ( float ) ( a * (", "gt": "float ) dd + b ) ;", "prediction": "LR1 - LR2 ) ) ;\n", "label": 1}
{"id": 1376, "input": "<s> package org . gk . ui . client . com . utils ; import java . util . Date ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBus ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import org . gk . ui . client . com . CoreIC ; import org . gk . ui . client . com . form . gkComboBox ; import org . gk . ui . client . com . form . gkDateField ; import org . gk . ui . client . com . form . gkLabelField ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . form . gkRadio ; import org . gk . ui . client . com . form . gkTimeField ; import org . gk . ui . client . com . form . gkYMField ; import org . gk . ui . client . com . panel . gkFieldAccessIfc ; import org . gk . ui . client . com . panel . gkFormPanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . KeyListener ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . SelectionChangedEvent ; import com . extjs . gxt . ui . client . event . SelectionChangedListener ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . form . AdapterField ; import com . extjs . gxt . ui . client . widget . form . CheckBox ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . LabelField ; import com . extjs . gxt . ui . client . widget . form . NumberField ; import com . extjs . gxt . ui . client . widget . form . Radio ; import com . extjs . gxt . ui . client . widget . form . SliderField ; import com . extjs . gxt . ui . client . widget . form . TextField ; public class BindingUtils { public static void update ( LayoutContainer lc , Map info ) { update ( lc . getId ( ) , info ) ; } public static void update ( String eventId , Map info ) { EventBus . get ( ) . publish ( new EventObject ( eventId , info ) ) ; } public static Radio createRadio ( String eventId , final Map info , final String infoKey , final String infoValue , CoreIC core ) { final Radio radio = new gkRadio ( ) { @ Override protected void onFocus ( ComponentEvent ce ) { if ( ! hasFocus ) { if ( ! readOnly ) { info . put ( infoKey , infoValue ) ; } super . onFocus ( ce ) ; } } } ; core . subscribe ( eventId , new EventProcess ( ) { @ Override public void execute ( String eventId , EventObject eo ) { Map infoMap = eo . getInfoMap ( ) ; if ( infoMap . containsKey ( infoKey ) ) { Object value = infoMap . get ( infoKey ) ; radio . setValue ( infoValue . equals ( value ) ) ; info . put ( infoKey , value ) ; } } } ) ; radio . addListener ( Events . Change , new Listener < FieldEvent > ( ) { @ Override public void handleEvent ( FieldEvent fe ) { updateDirtyField ( infoKey , info ) ; Boolean value = ( Boolean ) fe . getField ( ) . getValue ( ) ; Object currentValue = info . get ( infoKey ) ; if ( value != null && value ) { if ( ! infoValue . equals ( currentValue ) ) { info . put ( infoKey , infoValue ) ; } } else { if ( infoValue . equals ( currentValue ) ) { info . put ( infoKey , \"\" ) ; } } } } ) ; if ( info . get ( infoKey ) == null ) { initialInfoValue ( radio , infoKey ,", "gt": "info , \"\" ) ;", "prediction": "infoValue ) ;\n", "label": 0}
{"id": 14869, "input": "<s> package com . cloudera . sqoop . mapreduce ; import java . io . IOException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . mapreduce . InputFormat ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . OutputFormat ; import com . cloudera . sqoop . manager . ExportJobContext ; public class ExportJobBase extends org . apache . sqoop . mapreduce . ExportJobBase { public static final String SQOOP_EXPORT_TABLE_CLASS_KEY = org . apache . sqoop . mapreduce . ExportJobBase . SQOOP_EXPORT_TABLE_CLASS_KEY ; public static final String SQOOP_EXPORT_UPDATE_COL_KEY = org . apache . sqoop . mapreduce . ExportJobBase . SQOOP_EXPORT_UPDATE_COL_KEY ; public static final String EXPORT_MAP_TASKS_KEY = org . apache . sqoop . mapreduce . ExportJobBase . EXPORT_MAP_TASKS_KEY ; public ExportJobBase ( final ExportJobContext ctxt ) { super ( ctxt ) ; } public ExportJobBase ( final ExportJobContext ctxt , final Class < ? extends Mapper > mapperClass , final Class < ? extends InputFormat > inputFormatClass ,", "gt": "final Class < ? extends OutputFormat > outputFormatClass )", "prediction": "final Class < ? extends OutputFormat > outputFormatClass )\n", "label": 1}
{"id": 4170, "input": "<s> package com . example . tutorial . flowpart ; import org . junit . Test ; import com . asakusafw . testdriver . FlowPartTestDriver ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; import com . example . tutorial . modelgen . table . model . ItemInfo ; import com . example . tutorial . modelgen . table . model . OrderAmount ; import com . example . tutorial . modelgen . table . model . OrderDetail ; public class TutorialFlowTest { @ Test public void testExample ( ) throws Throwable { FlowPartTestDriver driver = new FlowPartTestDriver ( ) ; In < OrderDetail > orderIn = driver . createIn ( OrderDetail . class ) ; In < ItemInfo > itemIn = driver . createIn ( ItemInfo . class ) ; Out < OrderDetail > orderOut = driver . createOut ( OrderDetail . class ) ; Out < OrderAmount > resultOut = driver . createOut", "gt": "( OrderAmount . class ) ;", "prediction": "( OrderAmount . class ) ;\n", "label": 0}
{"id": 14870, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers . provider ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Type ; import java . util . Collections ; import java . util . List ; import javax . ws . rs . Consumes ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . ext . ExceptionMapper ; import javax . ws . rs . ext . Providers ; import org . restlet . data . MediaType ; import org . restlet . ext . jaxrs . internal . core . ThreadLocalizedContext ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalBeanSetterTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalFieldTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . ext . jaxrs . internal . wrappers . WrapperUtil ; import org . restlet . ext . jaxrs . internal . wrappers . params . ContextInjector ; abstract class AbstractProviderWrapper implements ProviderWrapper { private final List < org . restlet . data . MediaType > consumedMimes ; private final List < org . restlet . data . MediaType > producedMimes ; private final Class < ? > genericMbrType ; private final Class < ? > genericMbwType ; AbstractProviderWrapper ( Class < ? > jaxRsProviderClass ) throws IllegalArgumentException , WebApplicationException { final Consumes pm = jaxRsProviderClass . getAnnotation ( Consumes . class ) ; if ( pm != null ) { this . consumedMimes = WrapperUtil . convertToMediaTypes ( pm . value ( ) ) ; } else { this . consumedMimes = Collections . singletonList ( MediaType . ALL ) ; } final Produces cm = jaxRsProviderClass . getAnnotation ( Produces . class ) ; if ( cm != null ) { this . producedMimes = WrapperUtil . convertToMediaTypes ( cm . value ( ) ) ; } else { this . producedMimes = Collections . singletonList ( MediaType . ALL ) ; } this . genericMbrType = Util . getGenericClass ( jaxRsProviderClass , javax . ws . rs . ext . MessageBodyReader . class ) ; this . genericMbwType = Util . getGenericClass ( jaxRsProviderClass , javax . ws . rs . ext . MessageBodyWriter . class ) ; } @ Override public abstract boolean equals ( Object otherProvider ) ; public abstract String getClassName ( ) ; public List < MediaType > getConsumedMimes ( ) { return this . consumedMimes ; } public List < MediaType > getProducedMimes ( ) { return this . producedMimes ; } @ Override public abstract int hashCode ( ) ; void initProvider ( Object jaxRsProvider , ThreadLocalizedContext tlContext , Providers allProviders , ExtensionBackwardMapping extensionBackwardMapping ) throws IllegalFieldTypeException , IllegalBeanSetterTypeException , InjectException , InvocationTargetException { final ContextInjector iph = new ContextInjector ( jaxRsProvider . getClass ( ) , tlContext , allProviders , extensionBackwardMapping ) ; iph . injectInto ( jaxRsProvider , false ) ; } public abstract boolean isContextResolver ( ) ; public abstract boolean isExceptionMapper ( ) ; public abstract boolean isReader ( ) ; public abstract boolean isWriter ( ) ; public boolean supportsWrite ( Class < ? > entityClass , Type genericType ) { if ( entityClass == null ) { return false ; } if ( genericType == null ) { } if ( this . genericMbwType == null ) { return false ; } final boolean supportsWrite = this . genericMbwType . isAssignableFrom ( entityClass ) ; return supportsWrite ; } public boolean supportsRead ( Class < ? > entityClass , Type genericType ) { if ( entityClass == null ) { return false ; } if ( genericType == null ) { } if ( this . genericMbrType == null ) { return false ; } return this . genericMbrType . isAssignableFrom ( entityClass ) ; } public boolean supportsRead ( MediaType mediaType ) { boolean result = false ; for ( int i = 0 ; ! result && i < getConsumedMimes", "gt": "( ) . size ( ) ;", "prediction": "( ) . size ( ) ;\n", "label": 1}
{"id": 1494, "input": "<s> public class TestCast6979683_GOOD { public static void main ( String ... av ) { bugReportExample ( ) ; for ( int x = - 1 ; x <= 2 ; x ++ ) { zconvTests ( x != 0 ) ; iconvTests ( x ) ; bconvTests ( ( byte ) x ) ; cconvTests ( ( char ) x ) ; } System . out . println ( \"Successfully ran \" + tests + \" tests.\" ) ; } static int tests ; static void assertEquals ( Object x , Object y ) { if ( ! x . equals ( y ) ) { throw new RuntimeException ( \"assertEquals: \" + x + \" != \" + y ) ; } ++ tests ; } static void bugReportExample ( ) { { } Object x = ( Object ) 1 ; int y = ( int ) x ; { } } static boolean zconv1 ( Boolean o ) { return o ; } static boolean zconv2 ( Object o ) { return ( boolean ) o ; } static boolean zconv3 ( Comparable < Boolean > o ) { return ( boolean ) o ; } static void zconvTests ( boolean x ) { assertEquals ( x , zconv1 ( x ) ) ; assertEquals ( x , zconv2 ( x ) ) ; assertEquals ( x , zconv3 ( x ) ) ; } static int iconv1 ( Integer o ) { return o ; } static int iconv2 ( Object o ) { return ( int ) o ; } static int iconv3 ( java . io . Serializable o ) { return ( int ) o ; } static int iconv4 ( Number o ) { return ( int ) o ; } static int iconv5 ( Comparable < Integer > o ) { return ( int ) o ; } static void iconvTests ( int x ) { assertEquals ( x , iconv1 ( x ) ) ; assertEquals ( x , iconv2 ( x ) ) ; assertEquals ( x , iconv3", "gt": "( x ) ) ;", "prediction": "( x ) ) ;\n", "label": 0}
{"id": 14875, "input": "<s> package org . apache . lucene . demo . html ; public class ParseException extends Exception { public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( \"\" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } StringBuffer expected = new StringBuffer ( ) ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( \" \" ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( \"...\" ) ; } expected . append ( eol ) . append ( \"    \" ) ; } String retval = \"Encountered \\\"\" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += \" \" ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += \"\\\" at line \" + currentToken . next . beginLine + \", column \" + currentToken . next . beginColumn ; retval += \".\" + eol ; if ( expectedTokenSequences . length == 1 ) { retval += \"Was expecting:\" + eol + \"    \" ; } else { retval += \"Was expecting one of:\" + eol + \"    \" ; } retval += expected . toString ( ) ; return retval ; } protected String eol = System . getProperty ( \"line.separator\" , \"\\n\" ) ; protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\\b' : retval . append ( \"\\\\b\" ) ; continue ; case '\\t' : retval . append ( \"\\\\t\" ) ; continue ;", "gt": "case '\\n' : retval . append ( \"\\\\n\" ) ;", "prediction": "case '\\n' : retval . append ( \"\\\\n\" ) ;\n", "label": 1}
{"id": 7865, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . IOException ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; import org . apache . maven . project . MavenProject ; import org . apache . maven . project . MavenProjectHelper ; import org . codehaus . plexus . archiver . Archiver ; import org . codehaus . plexus . archiver . ArchiverException ; import org . codehaus . plexus . archiver . manager . ArchiverManager ; import org . codehaus . plexus . archiver . manager . NoSuchArchiverException ; public class XCodePackageAppStoreMetaDataMojo extends AbstractXCodeMojo { private ArchiverManager archiverManager ; private MavenProjectHelper projectHelper ; private File appStoreMetadata ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { try { packageAndAttachAppStoreMetaData ( ) ; } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( NoSuchArchiverException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } } private void packageAndAttachAppStoreMetaData ( ) throws IOException , NoSuchArchiverException , ArchiverException , MojoExecutionException { final String bundleIdentifier = getBundleIdentifier ( ) ; final File appStoreMetaDataFolder = new File ( appStoreMetadata , bundleIdentifier ) ; if ( appStoreMetaDataFolder . exists ( ) && appStoreMetaDataFolder . list ( ) . length != 0 ) { Archiver archiver = archiverManager . getArchiver ( \"zip\" ) ; File destination = new File ( new File ( project . getBuild ( ) . getDirectory ( ) ) , \"AppStoreMetadata.zip\" ) ; archiver . addDirectory ( appStoreMetaDataFolder , new String [ ] { \"**/*\" } , null ) ; archiver . setDestFile ( destination ) ; archiver . createArchive ( ) ; getLog ( ) . info ( \"AppStore MetaData", "gt": "packaged in (\" + destination + \")\" ) ;", "prediction": ": \" + appStoreMetaDataFolder . getAbsolutePath ( ) ) ;\n", "label": 0}
{"id": 14876, "input": "<s> package org . restlet . ext . sip . internal ; public final class SipConstants { public static final String HEADER_ALERT_INFO = \"Alert-Info\" ; public static final String HEADER_ALLOW_EVENTS = \"Allow-Events\" ; public static final String HEADER_CALL_ID = \"Call-ID\" ; public static final String HEADER_CALL_INFO = \"Call-Info\" ; public static final String HEADER_CALL_SEQ = \"CSeq\" ; public static final String HEADER_CONTACT = \"Contact\" ; public static final String HEADER_ENCRYPTION = \"Encryption\" ; public static final String HEADER_ERROR_INFO = \"Error-Info\" ; public static final String HEADER_EVENT = \"Event\" ; public static final String HEADER_IN_REPLY_TO = \"In-Reply-To\" ; public static final String HEADER_MIME_VERSION = \"MIME-Version\" ; public static final String HEADER_MIN_EXPIRES = \"Min-Expires\" ; public static final String HEADER_ORGANIZATION = \"Organization\" ; public static final String HEADER_PRIORITY = \"Priority\" ; public static final String HEADER_PROXY_REQUIRE = \"Proxy-Require\" ; public static final String HEADER_RECORD_ROUTE = \"Record-Route\" ; public static final String HEADER_REFER_TO = \"Refer-To\" ; public static final String HEADER_REPLY_TO = \"Reply-To\" ; public static final String HEADER_REQUIRE = \"Require\" ; public static final String HEADER_RETRY_AFTER = \"Retry-After\" ; public static final String HEADER_ROUTE = \"Route\" ; public static final String HEADER_RSEQ = \"RSeq\" ; public static final String HEADER_SERVER = \"Server\" ; public static final String HEADER_SIP_ETAG = \"SIP-ETag\" ; public static final String HEADER_SIP_IF_MATCH = \"SIP-If-Match\" ; public static", "gt": "final String HEADER_SUBJECT = \"Subject\" ;", "prediction": "final String HEADER_SIP_HEADER = \"SIP-Header\" ;\n", "label": 1}
{"id": 8250, "input": "<s> package org . ofbiz . product . promo ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . StringReader ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . apache . commons . lang . RandomStringUtils ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class PromoServices { public final static String module = PromoServices . class . getName ( ) ; public static final String resource = \"ProductUiLabels\" ; protected final static char [ ] smartChars = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'K' , 'L' , 'M' , 'N' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' } ; public static Map < String , Object > createProductPromoCodeSet ( DispatchContext dctx , Map < String , ? extends Object > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; Delegator delegator = dctx . getDelegator ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Long quantity = ( Long ) context . get ( \"quantity\" ) ; int codeLength = ( Integer ) context . get ( \"codeLength\" ) ; String promoCodeLayout = ( String ) context . get ( \"promoCodeLayout\" ) ; boolean useSmartLayout = false ; boolean useNormalLayout = false ; if ( \"smart\" . equals ( promoCodeLayout ) ) { useSmartLayout = true ; } else if ( \"normal\" . equals ( promoCodeLayout ) ) { useNormalLayout = true ; } String newPromoCodeId = \"\" ; StringBuilder bankOfNumbers = new StringBuilder ( ) ; bankOfNumbers . append ( UtilProperties . getMessage ( resource , \"ProductPromoCodesCreated\" , locale ) ) ; for ( long i = 0 ; i < quantity ; i ++ ) { Map < String , Object > createProductPromoCodeMap = null ; boolean foundUniqueNewCode = false ; long count = 0 ; while ( ! foundUniqueNewCode ) { if ( useSmartLayout ) { newPromoCodeId = RandomStringUtils . random ( codeLength , smartChars ) ; } else if ( useNormalLayout ) { newPromoCodeId = RandomStringUtils . randomAlphanumeric ( codeLength ) ; } GenericValue existingPromoCode = null ; try { existingPromoCode = delegator . findOne ( \"ProductPromoCode\" , UtilMisc . toMap ( \"productPromoCodeId\" , newPromoCodeId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( \"Could not find ProductPromoCode for just generated ID: \" + newPromoCodeId , module ) ; } if ( existingPromoCode == null ) { foundUniqueNewCode = true ; } count ++ ; if ( count > 999999 ) { return ServiceUtil . returnError ( \"Unable to locate unique PromoCode! Length [\" + codeLength + \"]\" ) ; } } try { Map < String , Object > newContext = dctx . makeValidContext ( \"createProductPromoCode\" , \"IN\" , context ) ; newContext . put ( \"productPromoCodeId\" , newPromoCodeId ) ; createProductPromoCodeMap = dispatcher . runSync ( \"createProductPromoCode\" , newContext ) ; } catch ( GenericServiceException err ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ProductPromoCodeCannotBeCreated\" , locale ) , null , null , createProductPromoCodeMap ) ; }", "gt": "if ( ServiceUtil . isError ( createProductPromoCodeMap ) )", "prediction": "}\n", "label": 0}
{"id": 14878, "input": "<s> package org . apache . batik . svggen . font . table ; public interface Table { public static final int BASE = 0x42415345 ; public static final int CFF = 0x43464620 ; public static final int DSIG = 0x44534947 ; public static final int EBDT = 0x45424454 ; public static final int EBLC = 0x45424c43 ; public static final int EBSC = 0x45425343 ; public static final int GDEF = 0x47444546 ; public static final int GPOS = 0x47504f53 ; public static final int GSUB = 0x47535542 ; public static final int JSTF = 0x4a535446 ; public static final int LTSH = 0x4c545348 ; public static final int MMFX = 0x4d4d4658 ; public static final int MMSD = 0x4d4d5344 ; public static final int OS_2 = 0x4f532f32 ; public static final int PCLT = 0x50434c54 ; public static final int VDMX = 0x56444d58 ; public static final int cmap = 0x636d6170 ; public static final int cvt = 0x63767420 ; public static final int fpgm = 0x6670676d ; public static final int fvar = 0x66766172 ; public static final int gasp = 0x67617370 ; public static final int glyf = 0x676c7966 ; public static final int hdmx = 0x68646d78 ; public static final int head = 0x68656164 ; public static final int hhea = 0x68686561 ; public static final int hmtx = 0x686d7478 ; public static final int kern = 0x6b65726e ; public static final int loca = 0x6c6f6361 ; public static final int maxp = 0x6d617870 ; public static final int name = 0x6e616d65 ; public static final int prep = 0x70726570 ; public static final int post = 0x706f7374 ; public static final int vhea = 0x76686561 ; public static final int vmtx = 0x766d7478 ; public static final short platformAppleUnicode = 0 ; public static final short platformMacintosh = 1 ; public static final short platformISO = 2 ; public static final short platformMicrosoft = 3 ; public static final short encodingUndefined = 0 ; public static final short encodingUGL = 1 ; public static final short encodingRoman = 0 ; public static final short encodingJapanese = 1 ; public static final short encodingChinese = 2 ; public static final short encodingKorean = 3 ; public static final short encodingArabic = 4 ; public static final short encodingHebrew = 5 ; public static final short encodingGreek = 6 ; public static final short encodingRussian = 7 ; public static final short encodingRSymbol = 8 ; public static final short encodingDevanagari = 9 ; public static final short encodingGurmukhi = 10 ; public static final short encodingGujarati = 11 ; public static final short encodingOriya = 12 ; public static final short encodingBengali = 13 ; public static final short encodingTamil = 14 ; public static final short encodingTelugu = 15 ; public static final short encodingKannada = 16 ; public static final short encodingMalayalam = 17 ; public static final short encodingSinhalese = 18 ; public static final short encodingBurmese = 19 ; public static final short encodingKhmer = 20 ; public static final short encodingThai = 21 ; public static final short encodingLaotian = 22 ; public static final short encodingGeorgian = 23 ; public static final short encodingArmenian = 24 ; public static final short encodingMaldivian = 25 ; public static final short encodingTibetan = 26 ; public static final short encodingMongolian = 27 ; public static final short encodingGeez = 28 ; public static final short encodingSlavic = 29 ; public static final short encodingVietnamese = 30 ; public static final short encodingSindhi = 31 ; public static final short encodingUninterp = 32 ; public static final", "gt": "short encodingASCII = 0 ;", "prediction": "short encodingArabic = 33 ;\n", "label": 1}
{"id": 2983, "input": "<s> package com . matburt . mobileorg . Gui . Outline ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Gui . Theme . DefaultTheme ; import com . matburt . mobileorg . OrgData . OrgFileParser ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import android . content . ContentResolver ; import android . content . Context ; import android . graphics . Typeface ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . SpannableStringBuilder ; import android . text . TextUtils ; import android . text . style . ForegroundColorSpan ; import android . text . style . StyleSpan ; import android . util . TypedValue ; import android . view . Gravity ; import android . view . View ; import android . widget . Checkable ; import android . widget . RelativeLayout ; import android . widget . TextView ; public class OutlineItem extends RelativeLayout implements Checkable { private TextView titleView ; private TextView tagsView ; public OutlineItem ( Context context ) { super ( context ) ; View . inflate ( getContext ( ) , R . layout . outline_item , this ) ; titleView = ( TextView ) findViewById ( R . id . outline_item_title ) ; tagsView = ( TextView ) findViewById ( R . id . outline_item_tags ) ; titleView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , 14 ) ; tagsView . setTextSize ( TypedValue . COMPLEX_UNIT_DIP , 14 ) ; } public void setup ( OrgNode node , boolean expanded , DefaultTheme theme , ContentResolver resolver ) { setupTags ( node . tags , theme ) ; SpannableStringBuilder titleSpan = new SpannableStringBuilder ( node . name ) ; if ( node . name . startsWith ( OrgFileParser . BLOCK_SEPARATOR_PREFIX ) ) { setupAgendaBlock ( titleSpan , theme ) ; return ; } applyLevelFormating ( theme , node . level , titleSpan ) ; setupTitle ( node . name , theme , titleSpan ) ; setupPriority ( node . priority , theme , titleSpan ) ; setupTodo ( node . todo , titleSpan , theme , resolver ) ; applyLevelIndentation ( node . level , titleSpan ) ; if ( expanded == false ) setupChildrenIndicator ( node , resolver , theme , titleSpan ) ; titleSpan . setSpan ( new StyleSpan ( Typeface . NORMAL ) , 0 , titleSpan . length ( ) , 0 ) ; titleView .", "gt": "setText ( titleSpan ) ;", "prediction": "setTextSize ( TypedValue . COMPLEX_UNIT_DIP , 14 ) ;\n", "label": 0}
{"id": 14880, "input": "<s> package org . apache . lucene . spatial . tier ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . lucene . search . Filter ; import org . apache . lucene . spatial . geometry . shape . Rectangle ; import org . apache . lucene . spatial . tier . projections . CartesianTierPlotter ; import org . apache . lucene . spatial . tier . projections . IProjector ; import org . apache . lucene . spatial . tier . projections . SinusoidalProjector ; public class CartesianPolyFilterBuilder { public static final double MILES_FLOOR = 1.0 ; private IProjector projector = new SinusoidalProjector ( ) ; private Logger log = Logger . getLogger ( getClass ( ) . getName ( ) ) ; private final String tierPrefix ; public CartesianPolyFilterBuilder ( String tierPrefix ) { this . tierPrefix = tierPrefix ; } public Shape getBoxShape ( double latitude , double longitude , double miles ) { if ( miles < MILES_FLOOR ) { miles = MILES_FLOOR ; } Rectangle box = DistanceUtils . getInstance ( ) . getBoundary ( latitude , longitude , miles ) ; double latY = box . getMaxPoint ( ) . getY ( ) ; double latX = box . getMinPoint ( ) . getY ( ) ; double longY = box . getMaxPoint ( ) . getX ( ) ; double longX = box . getMinPoint ( ) . getX ( ) ; CartesianTierPlotter ctp = new CartesianTierPlotter ( 2 , projector , tierPrefix ) ; int bestFit = ctp . bestFit ( miles ) ; log . info ( \"Best Fit is : \" + bestFit ) ; ctp = new CartesianTierPlotter ( bestFit , projector , tierPrefix ) ; Shape shape = new Shape ( ctp . getTierFieldName ( ) ) ; double beginAt = ctp . getTierBoxId ( latX , longX ) ; double endAt = ctp . getTierBoxId ( latY , longY ) ; double tierVert = ctp . getTierVerticalPosDivider ( ) ; log . fine ( \" | \" + beginAt + \" | \" + endAt ) ; double startX = beginAt - ( beginAt % 1 ) ; double startY = beginAt - startX ; double endX =", "gt": "endAt - ( endAt % 1 ) ;", "prediction": "endAt - ( endAt % 1 ) ;\n", "label": 1}
{"id": 8858, "input": "<s> package com . mapr . stats ; import java . util . Random ; abstract class BanditFactory { public abstract BayesianBandit createBandit ( int bandits", "gt": ", Random gen ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14883, "input": "<s> package org . restlet . ext . sip . internal ; import java . util . logging . Level ; import org . restlet . Response ; import org . restlet . engine . connector . ClientOutboundWay ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . TagWriter ; import org . restlet . engine . io . IoState ; import org . restlet . ext . sip . SipRecipientInfo ; import org . restlet . ext . sip . SipRequest ; import org . restlet . ext . sip . SipResponse ; import org . restlet . util . Series ; public class SipClientOutboundWay extends ClientOutboundWay { public SipClientOutboundWay ( Connection < ? > connection , int bufferSize ) { super ( connection , bufferSize ) ; } @ Override protected void addGeneralHeaders ( Series < Header > headers ) { if ( getMessage ( ) . getRequest ( ) instanceof SipRequest ) { SipRequest sipRequest = ( SipRequest ) getMessage ( ) . getRequest ( ) ; if ( ! sipRequest . getSipRecipientsInfo ( ) . isEmpty ( ) ) { for ( SipRecipientInfo recipient : sipRequest . getSipRecipientsInfo ( ) ) { headers . add ( HeaderConstants . HEADER_VIA , SipRecipientInfoWriter . write ( recipient ) ) ; } } } super . addGeneralHeaders ( headers ) ; } @ Override protected void addRequestHeaders ( Series < Header > headers ) { SipRequest sipRequest = null ; if ( getMessage ( ) . getRequest ( ) instanceof SipRequest ) { sipRequest = ( SipRequest ) getMessage ( ) . getRequest ( ) ; if ( sipRequest . getCallId ( ) != null ) { headers . add ( SipConstants . HEADER_CALL_ID , sipRequest . getCallId ( ) ) ; } if ( sipRequest . getCommandSequence ( ) != null ) { headers . add ( SipConstants . HEADER_CALL_SEQ , sipRequest . getCommandSequence ( ) ) ; } if ( sipRequest . getFrom ( ) != null ) { headers . add ( HeaderConstants . HEADER_FROM , AddressWriter . write ( sipRequest . getFrom ( ) ) ) ; } if ( sipRequest . getTo ( ) != null ) { headers . add ( SipConstants . HEADER_TO , AddressWriter . write ( sipRequest . getTo ( ) ) ) ; } if ( sipRequest . getAlertInfo ( ) != null ) { headers . add ( SipConstants . HEADER_ALERT_INFO , AddressWriter . write ( sipRequest . getAlertInfo ( ) ) ) ; } if ( ! sipRequest . getAllowedEventTypes ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_ALLOW_EVENTS , EventTypeWriter . write ( sipRequest . getAllowedEventTypes ( ) ) ) ; } if ( ! sipRequest . getCallerInfo ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_CALL_INFO , AddressWriter . write ( sipRequest . getCallerInfo ( ) ) ) ; } if ( ! sipRequest . getContacts ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_CONTACT , ContactInfoWriter . write ( sipRequest . getContacts ( ) ) ) ; } if ( sipRequest . getEvent ( ) != null ) { headers . add ( SipConstants . HEADER_EVENT , EventWriter . write ( sipRequest . getEvent ( ) ) ) ; } if ( sipRequest . getMimeVersion ( ) != null ) { headers . add ( SipConstants . HEADER_MIME_VERSION , sipRequest . getMimeVersion ( ) ) ; } if ( sipRequest . getOrganization ( ) != null ) { headers . add ( SipConstants . HEADER_ORGANIZATION , sipRequest . getOrganization ( ) ) ; } if ( ! sipRequest . getRecordedRoutes ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_RECORD_ROUTE , AddressWriter . write ( sipRequest . getRecordedRoutes ( ) ) ) ; } if ( sipRequest . getReplyTo ( ) != null ) { headers . add ( SipConstants . HEADER_REPLY_TO , AddressWriter . write ( sipRequest . getReplyTo ( ) ) ) ; } if ( ! sipRequest . getSupported ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_SUPPORTED , OptionTagWriter . write ( sipRequest . getSupported ( ) ) ) ; } if ( ! sipRequest . getInReplyTo ( ) . isEmpty ( ) ) { StringBuilder sb = new StringBuilder ( sipRequest . getInReplyTo ( ) . get ( 0 ) ) ; for ( int i = 1 ; i < sipRequest . getInReplyTo ( ) . size ( ) ; i ++ ) { sb . append ( \",\" ) . append ( sipRequest . getInReplyTo ( ) . get ( i ) ) ; } headers . add ( SipConstants . HEADER_IN_REPLY_TO , sb . toString ( ) ) ; } if ( sipRequest . getPriority ( ) != null ) { headers . add ( SipConstants . HEADER_PRIORITY , sipRequest . getPriority ( ) . getValue ( ) ) ; } if ( ! sipRequest . getProxyRequires ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_PROXY_REQUIRE , OptionTagWriter . write ( sipRequest . getProxyRequires ( ) ) ) ; } if ( sipRequest . getReferTo ( ) != null ) { headers . add ( SipConstants . HEADER_REFER_TO , AddressWriter", "gt": ". write ( sipRequest . getReferTo ( ) ) ) ;", "prediction": ". write ( sipRequest . getReferTo ( ) ) ) ;\n", "label": 1}
{"id": 8737, "input": "<s> package org . kares . jruby ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ThreadFactory ; public class MemoThreadFactory implements ThreadFactory { private final ThreadFactory delegate ; private final List < Thread > createdThreads ; public MemoThreadFactory ( ThreadFactory delegate ) { this . delegate = delegate ; this . createdThreads = new ArrayList < Thread > ( ) ; } public MemoThreadFactory ( ThreadFactory delegate , List < Thread > returnedThreads ) { this . delegate = delegate ; this . createdThreads = returnedThreads ; } public Thread newThread ( Runnable runnable ) { Thread thread", "gt": "= delegate . newThread ( runnable ) ;", "prediction": "= new Thread ( runnable ) ;\n", "label": 0}
{"id": 14886, "input": "<s> package org . seage . problem . jssp ; import java . util . * ; public class Schedule { private ScheduleCell [ ] _lastCellInJob ; private ScheduleCell [ ] _lastCellOnMachine ; private ScheduleCell _furthestCell ; public Schedule ( int numJobs , int numMachines ) { _lastCellInJob = new ScheduleCell [ numJobs ] ; _lastCellOnMachine = new ScheduleCell [ numMachines ] ; } public void addCell ( int jobIndex , int machineIndex , ScheduleCell newCell ) { if ( _lastCellOnMachine [ machineIndex ] != null ) _lastCellOnMachine [ machineIndex ] . setNextCellOnMachine ( newCell ) ; newCell . setPreviousCellOnMachine ( _lastCellOnMachine [ machineIndex ] ) ; newCell . setPreviousCellInJob ( _lastCellInJob [ jobIndex ] ) ; _lastCellOnMachine [ machineIndex ] = newCell ; _lastCellInJob [ jobIndex ] = newCell ; if ( _furthestCell == null ) _furthestCell = newCell ; else if ( newCell . getEndTime ( ) > _furthestCell . getEndTime ( ) ) _furthestCell = newCell ; } public ScheduleCell [ ] findCriticalPath ( ) throws Exception { ArrayList results = new ArrayList ( ) ; ScheduleCell sc = _furthestCell ; findBreak ( sc , results ) ; ScheduleCell [ ] scArray = new ScheduleCell [ results . size ( ) ] ; for ( int i = 0 ; i < results . size ( ) ; i ++ ) { scArray [ i ] = ( ScheduleCell ) results . get ( i ) ; } return scArray ; } private void findBreak ( ScheduleCell cell , ArrayList array ) throws Exception { if ( cell == null ) throw new Exception ( \"Critical path: Null pointer\" ) ; boolean breakFound = false ; ScheduleCell currCell = cell ; ScheduleCell prevCellOnMachine = null ; ScheduleCell prevCellInJob = null ; while ( ! breakFound ) { if ( currCell == null ) { if ( prevCellOnMachine == null && prevCellInJob == null ) throw new Exception ( \"ALL Null pointer\" ) ; ; throw new Exception ( \"While: Null pointer\" ) ; } prevCellOnMachine = currCell . getPreviousCellOnMachine ( ) ; prevCellInJob = currCell . getPreviousCellInJob ( ) ; if ( prevCellOnMachine == null && prevCellInJob == null ) return ; if ( prevCellInJob == null ) { currCell = prevCellOnMachine ; } else { if ( currCell . getStartTime ( ) == prevCellInJob . getEndTime ( ) ) { breakFound = true ; } else currCell = prevCellOnMachine ; } } if ( prevCellInJob . getPreviousCellOnMachine ( ) != null ) { if ( prevCellInJob . getStartTime ( ) == prevCellInJob . getPreviousCellOnMachine ( ) . getEndTime ( ) ) { if ( prevCellInJob . getPreviousCellOnMachine ( ) . getPreviousCellInJob ( ) == null ) { array . add ( prevCellInJob . getPreviousCellOnMachine ( ) ) ; array . add ( prevCellInJob ) ; } else { if ( ! prevCellInJob . getPreviousCellOnMachine ( ) . compareStart2EndTo ( prevCellInJob . getPreviousCellOnMachine ( )", "gt": ". getPreviousCellInJob ( ) ) )", "prediction": ". getEndTime ( ) ) )\n", "label": 1}
{"id": 4995, "input": "<s> package ar . com . fdvs . dj . test . domain ; import java . util . Collection ; public class DummyObject { Collection data1 ; Collection data2 ; public Collection getData1 ( ) { return data1 ; } public void setData1 ( Collection data1 ) { this . data1 = data1 ; } public Collection getData2 ( ) { return data2 ; } public void setData2 ( Collection data2 ) { this", "gt": ". data2 = data2 ;", "prediction": ". data2 = data2 ;\n", "label": 0}
{"id": 14888, "input": "<s> package net . claribole . zgrviewer ; import java . io . IOException ; class WebBrowser { WebBrowser ( ) { } public void show ( String url , GraphicsManager gm ) { if ( url != null && url . length ( ) > 0 ) { String command = null ; if ( ConfigManager . autoDetectBrowser ) { try { if ( Utils . osIsWindows ( ) ) { command = \"rundll32 url.dll,FileProtocolHandler \" + url ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; } else if ( Utils . osIsMacOS ( ) ) { command = \"open \" + url ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; } else { command = \"mozilla-firefox -remote openURL(\" + url + \")\" ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; int exitCode ; try { if ( ( exitCode = proc . waitFor ( ) ) != 0 ) { command = \"mozilla-firefox \" + url ; proc = Runtime . getRuntime ( ) . exec ( command ) ; } } catch ( InterruptedException ex1 ) { javax . swing . JOptionPane . showMessageDialog ( gm . vsm . getActiveView ( ) . getFrame ( ) , \"Browser invocation failed \" +", "gt": "command + \"\\n\" + ex1 ) ;", "prediction": "ex1 . getMessage ( ) ) ;\n", "label": 1}
{"id": 5771, "input": "<s> package jns . util ; public class Preferences { public static String VERSION = \"1.7\" ; public static int default_maxqueuelength = 1000000 ; public static double delay_ip_to_ifacequeue = 0.000001 ; public static double delay_ifacequeue_to_ip = 0.000001 ; public static double delay_iface_send_update = 0.001 ; public static boolean first_iface_is_default_route = false ; public static final int default_iface_MTU = 1500 ; public", "gt": "static final double ip_fragmentation_timeout = 1.0 ;", "prediction": "static final int default_maxqueuelength = 1000000 ;\n", "label": 0}
{"id": 14891, "input": "<s> package br . org . archimedes ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.i18n.messages\" ; public static String Constant_defaultFontFileName ; public static String NeverSaved ; public static String NewDrawingName ; public static String LayerComboContributionItem_LayerLocked ; public static String LayerComboContributionItem_NoDrawing ; static { NLS . initializeMessages ( BUNDLE_NAME ,", "gt": "Messages . class ) ;", "prediction": "Messages . class ) ;\n", "label": 1}
{"id": 2470, "input": "<s> package org . hackreduce . models ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . hadoop . io . Text ; public class StockExchangeRecord { SimpleDateFormat sdf = new SimpleDateFormat ( \"yyyy-MM-dd\" ) ; String exchange ; String stockSymbol ; Date date ; double stockPriceOpen ; double stockPriceHigh ; double stockPriceLow ; double stockPriceClose ; int stockVolume ; double stockPriceAdjClose ; public StockExchangeRecord ( String inputString ) throws IllegalArgumentException { String [ ] attributes = inputString . split ( \",\" ) ; if ( attributes . length != 9 ) throw new IllegalArgumentException ( \"Input string given did not have 9 values in CSV format\" ) ; try { setExchange ( attributes [ 0 ] ) ; setStockSymbol ( attributes [ 1 ] ) ; setDate ( sdf . parse ( attributes [ 2 ] ) ) ; setStockPriceOpen ( Double . parseDouble ( attributes [ 3 ] ) ) ; setStockPriceHigh ( Double . parseDouble ( attributes [ 4 ] ) ) ; setStockPriceLow ( Double . parseDouble ( attributes [ 5 ] ) ) ; setStockPriceClose ( Double . parseDouble ( attributes [ 6 ] ) ) ; setStockVolume ( Integer . parseInt ( attributes [ 7 ] ) ) ; setStockPriceAdjClose ( Double . parseDouble ( attributes [ 8 ] ) ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( \"Input string contained an unknown value that couldn't be parsed\" , e ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( \"Input string contained an unknown number value that couldn't be parsed\" , e ) ; } } public StockExchangeRecord ( Text inputText ) throws IllegalArgumentException { this ( inputText . toString ( ) ) ; } public String getExchange ( ) { return exchange ; } public void setExchange ( String exchange ) { this", "gt": ". exchange = exchange ;", "prediction": ". exchange = exchange ;\n", "label": 0}
{"id": 14894, "input": "<s> package org . nuxeo . ecm . webengine . management ; import org . nuxeo . ecm . webengine . model", "gt": ". impl . DefaultObject ;", "prediction": ". Element ;\n", "label": 1}
{"id": 7696, "input": "<s> import java . util . Iterator ; class Test { < T > void test ( ) { new Iterable < T > ( ) { public Iterator <", "gt": "T > iterator ( )", "prediction": "T > iterator ( )\n", "label": 0}
{"id": 14898, "input": "<s> package org . eclipse . ui . tests . commands ; import org . eclipse . core . commands . Category ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . CommandManager ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . IExecutionListener ; import org . eclipse . core . commands . NotHandledException ; import org . eclipse . ui . tests . harness . util . UITestCase ; public final class CommandManagerTest extends UITestCase { private final class ExecutionListener implements IExecutionListener { private String notHandledId = null ; private String preExecuteId = null ; private NotHandledException notHandledException = null ; private ExecutionEvent preExecuteEvent = null ; public final void notHandled ( final String commandId , final NotHandledException exception ) { notHandledId = commandId ; notHandledException = exception ; } public final void postExecuteFailure ( final String commandId , final ExecutionException exception ) { } public final void postExecuteSuccess ( final String commandId , final Object returnValue ) { } public final void preExecute ( final String commandId , final ExecutionEvent event ) { preExecuteId = commandId ; preExecuteEvent = event ; } } public CommandManagerTest ( String testName ) { super ( testName ) ; } public final void testExecutionListener ( ) { final String commandId = \"myCommand\" ; final CommandManager commandManager = new CommandManager ( ) ; final Category category = commandManager . getCategory ( commandId ) ; category . define ( \"name\" , null ) ; final Command command = commandManager . getCommand ( commandId ) ; command . define ( \"name\" , null , category , null ) ; final ExecutionListener listener = new ExecutionListener ( ) ; commandManager . addExecutionListener ( listener ) ; Exception exception = null ; final ExecutionEvent event = new ExecutionEvent ( ) ; try { command . execute ( event ) ; } catch ( final ExecutionException e ) { exception = e ; } catch ( final NotHandledException e ) { exception = e ; } assertSame ( \"Should have received a pre-execute event for the correct command\" , commandId , listener . preExecuteId ) ; assertSame ( \"Should have received a pre-execute event with", "gt": "the correct event\" , event , listener . preExecuteEvent ) ;", "prediction": "the correct command\" , commandId , listener . preExecuteEvent ) ;\n", "label": 1}
{"id": 8270, "input": "<s> package com . dyned . woremotesiteconfig . eom . migrations ; import com . webobjects . eocontrol . EOEditingContext ; import com . webobjects . foundation . NSArray ; import er . extensions . migration . ERXMigrationDatabase ; import er . extensions . migration . ERXMigrationTable ; import er . extensions . migration . ERXModelVersion ; public class WOSiteConfigStore0 extends ERXMigrationDatabase . Migration { @ Override public NSArray < ERXModelVersion > modelDependencies ( ) { return null ; } @ Override public void downgrade ( EOEditingContext editingContext , ERXMigrationDatabase database ) throws Throwable { } @ Override public void upgrade ( EOEditingContext editingContext , ERXMigrationDatabase database ) throws Throwable { ERXMigrationTable storedSiteTable = database . newTableNamed ( \"StoredSite\" ) ; storedSiteTable . newIntegerColumn ( \"id\" , false ) ; storedSiteTable . newStringColumn ( \"jmHost\" , 50 , false ) ; storedSiteTable . newStringColumn ( \"jmPassword\" , 50 , true ) ; storedSiteTable . newStringColumn ( \"jmPort\" , 50 , true ) ; storedSiteTable . newLargeStringColumn ( \"name\" , true ) ; storedSiteTable . newLargeStringColumn ( \"notes\" , true ) ; storedSiteTable . create ( ) ; storedSiteTable . setPrimaryKey ( \"id\" ) ; ERXMigrationTable storedInstanceHostTable = database . newTableNamed ( \"StoredInstanceHost\" ) ; storedInstanceHostTable . newStringColumn ( \"hostName\" , 50 , false ) ; storedInstanceHostTable . newIntegerColumn ( \"id\" , false ) ; storedInstanceHostTable . newIntegerColumn ( \"idStoredApp\" , false ) ; storedInstanceHostTable . newIntegerColumn ( \"instances\" , false ) ; storedInstanceHostTable . create ( ) ; storedInstanceHostTable . setPrimaryKey ( \"id\" ) ; ERXMigrationTable timePointApplicationTable = database . newTableNamed ( \"TimePointApplication\" ) ; timePointApplicationTable . newIntegerColumn ( \"id\" , false ) ;", "gt": "timePointApplicationTable . newIntegerColumn ( \"idStoredApp\" , false ) ;", "prediction": "timePointApplicationTable . newIntegerColumn ( \"idStoredApp\" , false ) ;\n", "label": 0}
{"id": 14899, "input": "<s> package org . fuzzydb . server . internal . server ; import org . fuzzydb . io . core . MessageSource ; import org . fuzzydb . server . internal . common . ServiceRegistry ; import com . google . inject . Module ; public class DatabaseFactory { public static Database createDatabase ( MessageSource messageSource , boolean isPersistent ) { Module modules = new DatabaseModule ( messageSource , isPersistent ) ; ServiceRegistry .", "gt": "initialise ( modules ) ;", "prediction": "register ( modules ) ;\n", "label": 1}
{"id": 7523, "input": "<s> package org . ofbiz . service ; public class ExecutionServiceException extends org . ofbiz . base . util . GeneralException { public ExecutionServiceException ( ) { super ( ) ; } public ExecutionServiceException ( String str ) {", "gt": "super ( str ) ;", "prediction": "super ( str ) ;\n", "label": 0}
{"id": 14903, "input": "<s> package org . vaadin . addon . vodatime . demoandtestapp ; import org . joda . time . DateTime ; import org . joda . time . LocalDate ; public class SampleBean { private DateTime dateTime ; private LocalDate localDate ; private String text ; public DateTime getDateTime ( ) { return dateTime ; } public void setDateTime ( DateTime dateTime ) { this . dateTime = dateTime ; } public LocalDate getLocalDate ( ) { return localDate ; } public void setLocalDate ( LocalDate localDate ) { this . localDate = localDate ; } public String getText ( ) { return text ; } public void setText ( String text ) {", "gt": "this . text = text ;", "prediction": "this . text = text ;\n", "label": 1}
{"id": 2223, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . Column ; import org . jjflyboy . tjpeditor . project . ColumnAttribute ; import org . jjflyboy . tjpeditor . project . ColumnId ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ColumnImpl extends MinimalEObjectImpl . Container implements Column { protected static final ColumnId ID_EDEFAULT = ColumnId . ALERT ; protected ColumnId id = ID_EDEFAULT ; protected ColumnAttribute attribute ; protected ColumnImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getColumn ( ) ; } public ColumnId getId ( ) { return id ; } public void setId ( ColumnId newId ) { ColumnId oldId = id ; id = newId == null ? ID_EDEFAULT : newId ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . COLUMN__ID , oldId , id ) ) ; } public ColumnAttribute getAttribute ( ) { return attribute ; } public NotificationChain basicSetAttribute ( ColumnAttribute newAttribute , NotificationChain msgs ) { ColumnAttribute oldAttribute = attribute ; attribute = newAttribute ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . COLUMN__ATTRIBUTE , oldAttribute , newAttribute ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setAttribute ( ColumnAttribute newAttribute ) { if ( newAttribute != attribute ) { NotificationChain msgs = null ; if ( attribute != null ) msgs = ( ( InternalEObject ) attribute ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . COLUMN__ATTRIBUTE , null , msgs ) ; if ( newAttribute != null ) msgs = ( ( InternalEObject ) newAttribute ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . COLUMN__ATTRIBUTE , null , msgs ) ; msgs = basicSetAttribute ( newAttribute , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . COLUMN__ATTRIBUTE , newAttribute , newAttribute ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . COLUMN__ATTRIBUTE : return basicSetAttribute ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . COLUMN__ID : return getId ( ) ; case ProjectPackage . COLUMN__ATTRIBUTE : return getAttribute ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage", "gt": ". COLUMN__ID : setId ( ( ColumnId ) newValue ) ;", "prediction": ". COLUMN__ID : setId ( ( String ) newValue ) ;\n", "label": 0}
{"id": 14912, "input": "<s> package com . orange . place . helper ; import org . json . JSONObject ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . util . Log ; import com . orange . place . constant . DBConstants ; import com . orange . place . constant . ServiceConstant ; import com . orange . place . constants . Constants ; import com . orange . utils . JsonUtil ; public class PrefHelper { public static String getUserLoginId ( Context context ) { return getPreference ( context ) . getString ( DBConstants . F_LOGINID , null ) ; } public static String getUserId ( Context context ) { return getPreference ( context ) . getString ( DBConstants . F_USERID , null ) ; } public static SharedPreferences getPreference ( Context context ) { return context . getSharedPreferences ( Constants . PREF_NAME , Context . MODE_PRIVATE ) ; } public static void storeUserInfo ( Context context , JSONObject data ) { Log . d ( Constants . LOG_TAG , \"Set user info in JSON into preference.\" ) ; if ( data == null ) { Log . e ( Constants . LOG_TAG , \"Data is null, nothing stored!\" ) ; return ; } Editor editor = getPreference ( context ) . edit ( ) ; editor . putString ( DBConstants . F_USERID , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_USERID ) ) ; editor . putString ( DBConstants . F_NICKNAME , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_NICKNAME ) ) ; editor . putString ( DBConstants . F_LOGINID , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_LOGINID ) ) ; editor . putString ( DBConstants . F_SINA_ACCESS_TOKEN , JsonUtil . getStringOrNull ( data , ServiceConstant", "gt": ". PARA_SINA_ACCESS_TOKEN ) ) ;", "prediction": ". PARA_SINAACCESS_TOKEN ) ) ;\n", "label": 1}
{"id": 5142, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class BooleanCondition extends Condition { private final Value left ; private final String op ; private final Value right ; public BooleanCondition ( Value left , String op , Value right ) { this . left = left ; this . op = op . toLowerCase ( ) ; this . right = right ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public Value getLeft ( ) { return left ; } public String getOp ( ) { return op ; } public Value getRight ( ) { return right ; } @ Override public boolean equals ( Object o ) { if ( o instanceof BooleanCondition ) { BooleanCondition other = ( BooleanCondition ) o ; return left . equals ( other . left ) & op . equals ( other . op ) && right . equals", "gt": "( other . right ) ;", "prediction": "( other . right ) ;\n", "label": 0}
{"id": 14916, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . api . DB3DException ; import de . uos . igf . db3d . dbms . geom . Line3D ; import de . uos . igf . db3d . dbms . geom . MBB3D ; import de . uos . igf . db3d . dbms . geom . Plane3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; public interface Spatial3D { public static final byte SAMPLE_3D = 1 ; public static final byte CURVE_3D = 2 ; public static final byte SURFACE_3D = 3 ; public static", "gt": "final byte HULL_3D = 4 ;", "prediction": "final byte TRIANGLE3D = 4 ;\n", "label": 1}
{"id": 9021, "input": "<s> package com . sun . tools . javap ; import java . io . PrintWriter ; public class Main { public static void main ( String [ ] args ) { JavapTask t = new JavapTask ( ) ; int rc = t . run ( args ) ; System . exit ( rc ) ; } public static int", "gt": "run ( String [ ] args , PrintWriter out )", "prediction": "main ( String [ ] args )\n", "label": 0}
{"id": 14918, "input": "<s> package org . apache . lucene . search . similar ; import java . io . IOException ; import java . io . StringReader ; import java . util . HashSet ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; public final class SimilarityQueries { private SimilarityQueries ( ) { } public static Query formSimilarQuery ( String body , Analyzer a , String field , Set stop ) throws IOException { TokenStream ts = a . tokenStream ( field , new StringReader ( body ) ) ; TermAttribute termAtt = ( TermAttribute ) ts . addAttribute ( TermAttribute . class ) ; BooleanQuery tmp = new BooleanQuery ( ) ; Set already = new HashSet ( ) ; while (", "gt": "ts . incrementToken ( ) )", "prediction": "ts . hasNext ( ) )\n", "label": 1}
{"id": 7847, "input": "<s> package org . jjflyboy . tjpeditor . project ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . Enumerator ; public enum Weekday implements Enumerator { MON ( 0 , \"MON\" , \"mon\" ) , TUE ( 1 , \"TUE\" , \"tue\" ) , WED ( 2 , \"WED\" , \"wed\" ) , THR ( 3 , \"THR\" , \"thu\" ) , FRI ( 4 , \"FRI\" , \"fri\" ) , SAT ( 5 , \"SAT\" , \"sat\" ) , SUN ( 6 , \"SUN\" , \"sun\" ) ; public static final int MON_VALUE = 0 ; public static final int TUE_VALUE = 1 ; public static final int WED_VALUE = 2 ; public static final int THR_VALUE = 3 ; public static final int FRI_VALUE = 4 ; public static final int SAT_VALUE = 5 ; public static final int SUN_VALUE = 6 ; private static final Weekday [ ] VALUES_ARRAY = new Weekday [ ] { MON , TUE , WED , THR , FRI , SAT , SUN , } ; public static final List < Weekday > VALUES = Collections . unmodifiableList ( Arrays . asList ( VALUES_ARRAY ) ) ; public static Weekday get ( String literal ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { Weekday result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( literal ) ) { return result ; } } return null ; } public static Weekday getByName ( String name ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { Weekday result = VALUES_ARRAY [ i ] ; if ( result . getName ( ) . equals ( name ) ) { return result ; } } return null ; } public static Weekday get ( int value ) { switch ( value ) { case MON_VALUE : return MON ; case TUE_VALUE : return TUE ; case WED_VALUE : return WED ;", "gt": "case THR_VALUE : return THR ;", "prediction": "case THR_VALUE : return THR ;\n", "label": 0}
{"id": 14919, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . restlet . test . ext . jaxrs . services . tests . ThrowWebAppExcProviderTest ; @ Path (", "gt": "\"simple\" ) public class SimpleResource", "prediction": "\"test\" ) @ Produces (\n", "label": 1}
{"id": 10087, "input": "<s> package com . toedter . gwt . demo . contacts . client . ui ; import com . google . gwt . resources . client . ClientBundle ; import com . google . gwt . resources . client . ImageResource ; public interface Resources extends ClientBundle { @ Source ( \"images/document-save-3.png\" ) ImageResource save ( ) ; @ Source ( \"images/user-new-3.png\" ) ImageResource addContact ( ) ; @ Source ( \"images/user-delete-2.png\" )", "gt": "ImageResource deleteContact ( ) ;", "prediction": "ImageResource removeContact ( ) ;\n", "label": 0}
{"id": 14923, "input": "<s> package com . onarandombox . MultiversePortals . utils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . command . CommandSender ; import org . bukkit . configuration . file . FileConfiguration ; import org . bukkit . entity . Player ; import org . bukkit . permissions . Permission ; import org . bukkit . util . Vector ; import com . onarandombox . MultiverseCore . api . MultiverseWorld ; import com . onarandombox . MultiversePortals . MVPortal ; import com . onarandombox . MultiversePortals . MultiversePortals ; import com . onarandombox . MultiversePortals . PortalLocation ; public class PortalManager { private MultiversePortals plugin ; private Map < String , MVPortal > portals ; private Map < MultiverseWorld , Map < Integer , Collection < MVPortal > > > worldChunkPortals ; private static final Collection < MVPortal > emptyPortalSet = new ArrayList < MVPortal > ( ) ; public PortalManager ( MultiversePortals plugin ) { this . plugin = plugin ; this . portals = new HashMap < String , MVPortal > ( ) ; this . worldChunkPortals = new HashMap < MultiverseWorld , Map < Integer , Collection < MVPortal > > > ( ) ; } public MVPortal getPortal ( Player sender , Location l ) { if ( ! this . plugin . getCore ( ) . getMVWorldManager ( ) . isMVWorld ( l . getWorld ( ) . getName ( ) ) ) { return null ; } MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( l . getWorld ( ) . getName ( ) ) ; for ( MVPortal portal : getNearbyPortals ( world , l ) ) { if ( ! MultiversePortals . EnforcePortalAccess || portal . playerCanEnterPortal ( ( Player ) sender ) ) { PortalLocation portalLoc = portal . getLocation ( ) ; if ( portalLoc . isValidLocation ( ) && portalLoc . getRegion ( ) . containsVector ( l ) ) { return portal ; } } } return null ; } @ Deprecated public MVPortal isPortal ( Player sender , Location l ) { return this . getPortal ( sender , l ) ; } public boolean isPortal ( Location l ) { return this . getPortal ( l ) != null ; } public MVPortal getPortal ( Location l ) { MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( l . getWorld ( ) . getName ( ) ) ; for ( MVPortal portal : getNearbyPortals ( world , l ) ) { MultiverseRegion r = portal . getLocation ( ) . getRegion ( ) ; if ( r != null && r . containsVector ( l ) ) { return portal ; } } return null ; } public boolean addPortal ( MVPortal portal ) { if ( ! this . portals . containsKey ( portal . getName ( ) ) ) { MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( portal . getWorld ( ) ) ; addUniquePortal ( world , portal . getName ( ) , portal ) ; return true ; } return false ; } public boolean addPortal ( MultiverseWorld world , String name , String owner , PortalLocation location ) { if ( ! this . portals . containsKey ( name ) ) { addUniquePortal ( world , name , new MVPortal ( this . plugin , name , owner , location ) ) ; return true ; } return false ; } private void addUniquePortal ( MultiverseWorld world , String name , MVPortal portal ) { this . portals . put ( name , portal ) ; addToWorldChunkPortals ( world , portal ) ; } public MVPortal removePortal ( String portalName , boolean removeFromConfigs ) { if ( ! isPortal ( portalName ) ) { return null ; } if ( removeFromConfigs ) { FileConfiguration config = this . plugin . getPortalsConfig ( ) ; config . set ( \"portals.\" + portalName , null ) ; this . plugin . savePortalsConfig ( ) ; } MVPortal removed = this . portals . remove ( portalName ) ; MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( removed . getWorld ( ) ) ; removeFromWorldChunkPortals ( world , removed ) ; removed . removePermission ( ) ; Permission portalAccess = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.access.*\" ) ; Permission exemptAccess = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.exempt.*\" ) ; Permission portalFill = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.fill.*\" ) ; if ( exemptAccess != null ) { exemptAccess . getChildren ( ) . remove ( removed . getExempt ( ) . getName ( ) ) ; this . plugin . getServer ( ) . getPluginManager ( ) . recalculatePermissionDefaults ( exemptAccess ) ; } if ( portalAccess != null ) { portalAccess . getChildren ( ) . remove ( removed . getPermission ( ) . getName ( ) ) ; this . plugin . getServer ( ) . getPluginManager ( ) . recalculatePermissionDefaults ( portalAccess ) ; } if ( portalFill != null ) { portalFill . getChildren ( ) . remove ( removed . getFillPermission ( ) . getName ( ) ) ; this . plugin . getServer ( ) . getPluginManager ( ) . recalculatePermissionDefaults ( portalFill ) ; } if ( MultiversePortals . ClearOnRemove ) { MultiverseRegion region = removed . getLocation ( ) . getRegion ( ) ; replaceInRegion ( removed . getWorld ( ) , region , Material . PORTAL , Material . AIR ) ; } this . plugin . getServer ( ) . getPluginManager ( ) . removePermission ( removed . getPermission ( ) ) ; this . plugin . getServer ( ) . getPluginManager ( ) . removePermission ( removed .", "gt": "getExempt ( ) ) ;", "prediction": "getFillPermission ( ) ) ;\n", "label": 1}
{"id": 3722, "input": "<s> package org . msl . simple . gmfmap . simplemapping . setting ; import org . eclipse . emf . common . util . BasicEList ; import org . eclipse . emf . ecore . EAttribute ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . BasicSettingDelegate . Stateless ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse . gmf . mappings . FeatureLabelMapping ; import org . eclipse . gmf . mappings . NodeMapping ; import org . eclipse . gmf . mappings . NodeReference ; import org . eclipse . gmf . tooldef . AbstractTool ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleNodeSettingDelegate extends Stateless { public SimpleNodeSettingDelegate ( EStructuralFeature arg0 ) { super ( arg0 ) ; } @ Override protected Object get ( InternalEObject owner , boolean resolve , boolean coreType ) { if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals . SIMPLE_NODE ) { switch ( eStructuralFeature . getEContainingClass ( ) . getEAllStructuralFeatures ( ) . indexOf ( eStructuralFeature ) ) { case SimplemappingsPackage . SIMPLE_NODE__DOMAIN_META_ELEMENT : return getDomainMetaElement ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__TOOL : return getTool ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__LABEL_ATTRIBUTES : return getLabelAttributes ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__DIAGRAM_NODE : return getDiagramNode ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__DIAGRAM_LABEL : return getDiagramLabel ( ( SimpleNode ) owner ) ; } } return null ; } private DiagramLabel getDiagramLabel ( SimpleNode owner ) { NodeReference nodeRef = owner . getNodeReference ( ) ; if ( nodeRef != null && nodeRef . getChild ( ) != null ) { NodeMapping nodeMapping = nodeRef . getChild ( ) ; if ( ! nodeMapping . getLabelMappings ( ) . isEmpty ( ) ) return nodeMapping . getLabelMappings ( ) . get ( 0 ) . getDiagramLabel ( ) ; } return null ; } private Node getDiagramNode ( SimpleNode owner ) { NodeReference nodeRef = owner . getNodeReference ( ) ; if ( nodeRef != null && nodeRef . getChild ( ) != null ) { NodeMapping nodeMapping = nodeRef . getChild ( ) ; return nodeMapping . getDiagramNode ( ) ; } return null ; } private Object getLabelAttributes ( SimpleNode owner ) { FeatureLabelMapping featureLabelMapping = ! owner . getNodeReference ( ) . getChild ( ) . getLabelMappings ( ) . isEmpty ( ) ? ( FeatureLabelMapping ) owner . getNodeReference ( ) . getChild ( ) . getLabelMappings ( ) . get ( 0 ) : null ; return featureLabelMapping != null ? featureLabelMapping . getFeatures ( ) : new BasicEList < EAttribute > ( ) ; } private AbstractTool getTool ( SimpleNode owner ) { NodeReference nodeRef = owner . getNodeReference ( ) ; if ( nodeRef != null && nodeRef .", "gt": "getChild ( ) != null )", "prediction": "getChild ( ) != null )\n", "label": 0}
{"id": 14925, "input": "<s> package com . codeslap . test . persistence ; import android . app . Activity ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . SQLException ; import android . net . Uri ; import com . codeslap . persistence . BaseContentProvider ; import com . codeslap . persistence . PersistenceConfig ; import org . junit . Test ; import static org . easymock . EasyMock . createMockBuilder ; import static org . easymock . EasyMock . expect ; import static org . easymock . EasyMock . replay ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class ContentProviderTest extends SqliteTest { private TestProvider mProvider ; @ Override public void configure ( ) { super . configure ( ) ; mProvider = createMockBuilder ( TestProvider . class ) . addMockedMethod ( \"getContext\" ) . createMock ( ) ; expect ( mProvider . getContext ( ) ) . andReturn ( new Activity ( ) ) . anyTimes ( ) ; replay ( mProvider ) ; mProvider . onCreate ( ) ; } @ Test public void contentProviderTest ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ExampleAutoincrement . class ) ; ContentValues values = new ContentValues ( ) ; values . put ( \"name\" , \"Foo Bar\" ) ; values . put ( \"number\" , 111 ) ; values . put ( \"decimal\" , 222f ) ; values . put ( \"bool\" , true ) ; values . put ( \"blob\" , \"Foo bar baz\" . getBytes ( ) ) ; Uri insert = mProvider . insert ( uri , values ) ; assertNotNull ( insert ) ; values . put ( \"number\" , 333 ) ; int update = mProvider . update ( uri , values , \"name LIKE ?\" , new String [ ] { \"Foo Bar\" } ) ; assertEquals ( 1 , update ) ; Cursor query = mProvider . query ( uri , new String [ ] { \"name\" } , \"name LIKE ?\" , new String [ ] { \"Foo Bar\" } , null ) ; assertNotNull ( query ) ; assertEquals ( 1 , query . getCount ( ) ) ; assertEquals ( 1 , query . getColumnCount ( ) ) ; assertTrue ( query . moveToNext ( ) ) ; assertEquals ( \"Foo Bar\" , query . getString ( 0 ) ) ; int deleted = mProvider . delete ( uri , \"number = ?\" , new String [ ] { \"333\" } ) ; assertEquals ( 1 , deleted ) ; } @ Test ( expected = SQLException . class ) public void shouldFailWithEmptyValuesTest ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ExampleAutoincrement . class ) ; ContentValues values = new ContentValues ( ) ; mProvider . insert ( uri , values ) ; } @ Test ( expected = SQLException . class ) public void shouldFailWithNullValuesTest ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ExampleAutoincrement . class ) ; mProvider . insert ( uri , null ) ; } @ Test ( expected = IllegalArgumentException . class ) public void queryShouldFailWithNotRegisteredClass ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ContentProviderTest . class ) ; mProvider . query ( uri , null , null , null , null ) ; } @ Test ( expected = IllegalArgumentException . class ) public void updateShouldFailWithNotRegisteredClass ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ContentProviderTest . class ) ; mProvider . update ( uri , null , null , null ) ; } @ Test ( expected = IllegalArgumentException . class ) public void insertShouldFailWithNonRegisteredClass ( ) { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ContentProviderTest . class ) ; ContentValues values = new ContentValues ( ) ; mProvider .", "gt": "insert ( uri , values ) ;", "prediction": "insert ( uri , values ) ;\n", "label": 1}
{"id": 365, "input": "<s> package org . parboiled ; import org . parboiled . annotations . MemoMismatches ; import org . parboiled . parserunners . ProfilingParseRunner ; import org . testng . annotations . Test ; import static org . testng . Assert . assertEquals ; import static org . testng . Assert . assertFalse ; public class MemoMismatchesTest { static class Parser extends BaseParser < Integer > { Rule Clause ( ) { return Sequence ( FirstOf ( Zero ( ) , One ( ) , Two ( ) ) , EOI ) ; } Rule Zero ( ) { return Sequence ( TestNot ( SevenOrNine ( ) ) , Ch ( '0' ) ) ; } Rule One ( ) { return Sequence ( TestNot ( SevenOrNine ( ) ) , Ch ( '1' ) ) ; } Rule Two ( ) { return Sequence ( TestNot ( SevenOrNine ( ) ) , Ch ( '2' ) ) ; } Rule SevenOrNine ( ) { return FirstOf ( '7' , '9' ) ; } } static class MemoParser extends Parser { @ Override @ MemoMismatches Rule SevenOrNine ( ) { return super . SevenOrNine ( ) ; } } @ Test public void test1 ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; ParserStatistics stats = ParserStatistics . generateFor ( parser . Clause ( ) ) ; assertEquals ( stats . toString ( ) , \"\" + \"Parser statistics for rule 'Clause':\\n\" + \"    Total rules       : 13\\n\" + \"        Actions       : 0\\n\" + \"        Any           : 0\\n\" + \"        CharIgnoreCase: 0\\n\" + \"        Char          : 6\\n\" + \"        Custom        : 0\\n\" + \"        CharRange     : 0\\n\" + \"        AnyOf         : 0\\n\" + \"        Empty         : 0\\n\" + \"        FirstOf       : 2\\n\" + \"        FirstOfStrings: 0\\n\" + \"        Nothing       : 0\\n\" + \"        OneOrMore     : 0\\n\" + \"        Optional      : 0\\n\" + \"        Sequence      : 4\\n\" + \"        String        : 0\\n\" + \"        Test          : 0\\n\" + \"        TestNot       : 1\\n\" + \"        ZeroOrMore    : 0\\n\" + \"\\n\" + \"    Action Classes    : 0\\n\" + \"    ProxyMatchers     : 0\\n\" + \"    VarFramingMatchers: 0\\n\" + \"MemoMismatchesMatchers: 0\\n\" ) ; ProfilingParseRunner runner = new ProfilingParseRunner ( parser . Clause ( ) ) ; assertFalse ( runner . run ( \"2\" ) . hasErrors ( ) ) ; assertEquals ( runner . getReport ( ) . printBasics ( ) . replaceFirst ( \"\\\\d\\\\.\\\\d\\\\d\\\\d s\" , \"X.XXX s\" ) , \"\" + \"Runs                     :               1\\n\" + \"Active rules             :              13\\n\" + \"Total net rule time      :           X.XXX s\\n\" + \"Total rule invocations   :              21\\n\" + \"Total rule matches       :               8\\n\" + \"Total rule mismatches    :              13\\n\" + \"Total match share        :           38.10 %\\n\" + \"Rule re-invocations      :               8\\n\" + \"Rule re-matches          :               2\\n\" + \"Rule re-mismatches       :               6\\n\" + \"Rule re-invocation share :           38.10 %\\n\" ) ; } @ Test public void test2 ( ) { MemoParser parser =", "gt": "Parboiled . createParser ( MemoParser . class ) ;", "prediction": "new MemoParser ( ) ;\n", "label": 0}
{"id": 14926, "input": "<s> package org . nuxeo . ecm . webapp . notification ; import static org . jboss . seam . ScopeType . SESSION ; import java . io . Serializable ; import javax . annotation . security . PermitAll ; import org . jboss . seam . annotations . Destroy ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . annotations . Unwrap ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . platform . notification . api . NotificationManager ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"notificationManager\" ) @ Scope ( SESSION ) public class NotificationServiceBusinessDelegate implements Serializable { private static final long serialVersionUID = 1L ; private NotificationManager notificationManager ; public void initialize ( ) { } @ Unwrap public NotificationManager getNotificationManager ( ) throws ClientException { if ( null == notificationManager ) { try { notificationManager = Framework . getService ( NotificationManager . class ) ; }", "gt": "catch ( Exception e )", "prediction": "catch ( Exception e )\n", "label": 1}
{"id": 6819, "input": "<s> package com . sun . tools . javap ; import com . sun . tools . classfile . Attribute ; import com . sun . tools . classfile . Code_attribute ; import com . sun . tools . classfile . ConstantPool ; import com . sun . tools . classfile . ConstantPoolException ; import com . sun . tools . classfile . Descriptor ; import com . sun . tools . classfile . Descriptor . InvalidDescriptor ; import com . sun . tools . classfile . Instruction ; import com . sun . tools . classfile . LocalVariableTypeTable_attribute ; import com . sun . tools . classfile . Signature ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; public class LocalVariableTypeTableWriter extends InstructionDetailWriter { public enum NoteKind { START ( \"start\" ) { public boolean match ( LocalVariableTypeTable_attribute . Entry entry , int pc ) { return ( pc == entry . start_pc ) ; } } , END ( \"end\" ) { public boolean match ( LocalVariableTypeTable_attribute . Entry entry , int pc ) { return ( pc == entry . start_pc + entry . length ) ; } } ; NoteKind ( String text ) { this . text = text ; } public abstract boolean match ( LocalVariableTypeTable_attribute . Entry entry , int pc ) ; public final String text ; } ; static LocalVariableTypeTableWriter instance ( Context context ) { LocalVariableTypeTableWriter instance = context . get ( LocalVariableTypeTableWriter . class ) ; if ( instance == null ) instance = new LocalVariableTypeTableWriter ( context ) ; return instance ; } protected LocalVariableTypeTableWriter ( Context context ) { super ( context ) ; context . put ( LocalVariableTypeTableWriter . class , this ) ; classWriter = ClassWriter . instance ( context ) ; } public void reset ( Code_attribute attr ) { codeAttr = attr ; pcMap = new HashMap < Integer , List < LocalVariableTypeTable_attribute . Entry > > ( ) ; LocalVariableTypeTable_attribute lvt = ( LocalVariableTypeTable_attribute ) ( attr . attributes . get ( Attribute . LocalVariableTypeTable ) ) ; if ( lvt == null ) return ; for ( int i = 0 ; i < lvt . local_variable_table . length ; i ++ ) { LocalVariableTypeTable_attribute . Entry entry = lvt . local_variable_table [ i ] ; put ( entry . start_pc , entry ) ; put ( entry . start_pc + entry . length , entry ) ; } } public void writeDetails ( Instruction instr ) { int pc = instr . getPC ( ) ; writeLocalVariables ( pc , NoteKind . END ) ; writeLocalVariables ( pc , NoteKind . START ) ; } @ Override public void flush ( ) { int pc = codeAttr . code_length ; writeLocalVariables ( pc , NoteKind . END ) ; } public void writeLocalVariables ( int pc , NoteKind kind ) { ConstantPool constant_pool = classWriter . getClassFile ( ) . constant_pool ; String indent = space ( 2 ) ; List < LocalVariableTypeTable_attribute . Entry > entries = pcMap . get ( pc ) ; if ( entries != null ) { for ( ListIterator < LocalVariableTypeTable_attribute . Entry > iter = entries . listIterator ( kind == NoteKind . END ? entries . size ( ) : 0 ) ; kind == NoteKind . END ? iter . hasPrevious ( ) : iter . hasNext ( ) ; ) { LocalVariableTypeTable_attribute . Entry entry = kind == NoteKind . END ? iter . previous ( ) : iter . next ( ) ; if ( kind . match ( entry , pc ) ) { print ( indent ) ; print ( kind . text ) ; print ( \" generic local \" ) ; print ( entry . index ) ; print ( \" // \" ) ; Descriptor d = new Signature ( entry . signature_index ) ; try { print ( d . getFieldType ( constant_pool ) . toString ( ) . replace ( \"/\" , \".\" ) ) ; } catch ( InvalidDescriptor e ) { print ( report ( e ) ) ; } catch ( ConstantPoolException e ) { print ( report ( e ) ) ; } print ( \" \" ) ; try { print ( constant_pool . getUTF8Value ( entry . name_index ) ) ; } catch ( ConstantPoolException e ) { print ( report ( e ) ) ; } println ( ) ; } } } } private void put ( int pc , LocalVariableTypeTable_attribute . Entry entry ) { List < LocalVariableTypeTable_attribute . Entry > list = pcMap . get ( pc ) ;", "gt": "if ( list == null )", "prediction": "if ( list == null )\n", "label": 0}
{"id": 14927, "input": "<s> package org . apache . sqoop . manager ; import java . io . IOException ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . manager . ExportJobContext ; import com . cloudera . sqoop . util . ExportException ; import org . apache . hadoop . mapreduce . lib . output . NullOutputFormat ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . sqoop . mapreduce . ExportInputFormat ; import org . apache . sqoop . mapreduce . PGBulkloadExportJob ; public class PGBulkloadManager extends PostgresqlManager { public static final Log LOG = LogFactory . getLog ( PGBulkloadManager . class . getName ( ) ) ; public PGBulkloadManager ( final SqoopOptions opts ) { super ( opts ) ; } @ Override public void exportTable", "gt": "( ExportJobContext context ) throws IOException , ExportException", "prediction": "( ExportJobContext context ) throws ExportException\n", "label": 1}
{"id": 8855, "input": "<s> package api . user ; import api . inbox . PrivateMessage ; import api . search . user . UserSearch ; import api . son . MySon ; import api . soup . MySoup ; import api . util . CouldNotLoadException ; public class User { private Profile response ; private String status ; private static transient int id ; public static User userFromId ( int id ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=user&id=\" + id + \"&auth=\" + authkey ; User user = ( User ) MySon . toObject ( url , User . class ) ; User . id = id ; return user ; } public static User userFromName ( String username ) throws CouldNotLoadException { UserSearch us = UserSearch . userSearchFromSearchTerm ( username . toLowerCase ( ) ) ; if ( us . getResponse ( ) . getResults ( ) != null && ! us . getResponse ( ) . getResults ( ) . isEmpty ( ) ) { return userFromId ( us . getResponse ( ) . getResults ( ) . get ( 0 ) . getUserId ( ) . intValue ( ) ) ; } else { throw new CouldNotLoadException ( \"User not found\" ) ; } } public void addToFriends ( ) { if ( ! getProfile ( ) . IsFriend ( ) ) { MySoup . pressLink ( \"friends.php?action=add&friendid=\" + id + \"&auth=\" + MySoup . getAuthKey ( ) ) ; System . out . println ( \"Added to friends\" ) ; } else { System . out . println ( \"Already added as friend\" ) ; } } public void sendMessage ( String subject , String body ) throws CouldNotLoadException { PrivateMessage pm = new PrivateMessage (", "gt": "id , subject , body ) ;", "prediction": "subject , body ) ;\n", "label": 0}
{"id": 14932, "input": "<s> package org . eclipse . core . tests . harness ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import junit . framework . Assert ; import org . eclipse . core . runtime . Platform ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . osgi . framework . BundleException ; import org . osgi . framework . FrameworkEvent ; import org . osgi . framework . FrameworkListener ; import org . osgi . framework . ServiceReference ; import org . osgi . service . packageadmin . PackageAdmin ; public class BundleTestingHelper { public static Bundle [ ] getBundles ( BundleContext context , String symbolicName , String version ) { ServiceReference packageAdminReference = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; if ( packageAdminReference == null ) throw new IllegalStateException ( \"No package admin service found\" ) ; PackageAdmin packageAdmin = ( PackageAdmin ) context . getService ( packageAdminReference ) ; Bundle [ ] result = packageAdmin . getBundles ( symbolicName , version ) ; context . ungetService ( packageAdminReference ) ; return result ; } public static Bundle installBundle ( BundleContext context , String location ) throws BundleException , MalformedURLException , IOException { return installBundle ( \"\" , context , location ) ; } public static Bundle installBundle ( String tag , BundleContext context , String location ) throws BundleException , MalformedURLException , IOException { URL entry = context . getBundle ( ) . getEntry ( location ) ; if ( entry == null ) Assert . fail ( tag + \" entry \" + location + \" could not be found in \" + context . getBundle ( ) . getSymbolicName ( ) ) ; Bundle installed = context . installBundle ( Platform . asLocalURL ( entry ) . toExternalForm ( ) ) ; return installed ; } public static void refreshPackages ( BundleContext context , Bundle [ ] bundles ) { if ( bundles . length == 0 ) return ; ServiceReference packageAdminRef = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; PackageAdmin packageAdmin = null ; if ( packageAdminRef != null ) { packageAdmin = ( PackageAdmin ) context . getService ( packageAdminRef ) ; if ( packageAdmin == null ) return ; } final boolean [ ] flag = new boolean [ ] { false } ; FrameworkListener listener = new FrameworkListener ( ) { public void frameworkEvent ( FrameworkEvent event ) { if ( event . getType ( ) == FrameworkEvent . PACKAGES_REFRESHED ) synchronized ( flag ) { flag [ 0 ] = true ; flag . notifyAll ( ) ; } } } ; context . addFrameworkListener ( listener ) ; packageAdmin . refreshPackages ( bundles ) ; synchronized ( flag ) { while ( ! flag [ 0 ] ) { try { flag . wait ( ) ; } catch ( InterruptedException e ) { } } } context . removeFrameworkListener ( listener ) ; context . ungetService ( packageAdminRef ) ; } public static void resolveBundles ( BundleContext context , Bundle [ ] bundles ) { ServiceReference packageAdminRef = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; PackageAdmin packageAdmin = null ; if ( packageAdminRef != null ) { packageAdmin = ( PackageAdmin ) context . getService ( packageAdminRef ) ; if ( packageAdmin == null ) return ; } packageAdmin . resolveBundles ( bundles ) ; context . ungetService ( packageAdminRef ) ; } public static void runWithBundles ( String tag , Runnable runnable , BundleContext context , String [ ] locations , TestRegistryChangeListener listener ) { if ( listener != null ) listener . register ( ) ; try { Bundle [ ] installed = new Bundle [ locations . length ] ; for ( int i = 0 ; i < locations . length ; i ++ ) try { installed [ i ] = installBundle ( tag + \".setup.0\" , context , locations [ i ] ) ; Assert . assertEquals ( tag + \".setup.1.\" + locations [ i ] , Bundle . INSTALLED , installed [ i ] . getState ( ) ) ; } catch ( BundleException e ) { CoreTest . fail ( tag + \".setup.2\" + locations [ i ] , e ) ; } catch ( IOException e ) { CoreTest . fail ( tag + \".setup.3\" + locations [ i ] , e ) ; } if ( listener != null ) listener . reset ( ) ; BundleTestingHelper . resolveBundles ( context , installed ) ; if ( listener != null ) { Assert . assertTrue ( tag + \".setup.4\" , listener . eventReceived ( installed . length * 10000 ) ) ; } try { runnable . run ( ) ; } finally { if ( listener != null ) listener . reset ( ) ; for ( int i = 0 ; i < installed . length ; i ++ ) try { installed [ i ] . uninstall ( ) ; } catch ( BundleException e ) { CoreTest . fail ( tag + \".tearDown.1.\" + locations [ i ] , e ) ; } BundleTestingHelper . resolveBundles ( context , installed ) ; if ( listener != null ) { Assert . assertTrue ( tag + \".tearDown.2\" , listener . eventReceived ( installed . length * 10000 ) ) ; } } } finally { if ( listener != null )", "gt": "listener . unregister ( ) ;", "prediction": "listener . shutdown ( ) ;\n", "label": 1}
{"id": 6263, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ArithmeticAssignmentOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ArithmeticOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AssignOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . BaseMemberExpression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . CharLiteral ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ComparisonOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . EqualityOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Exists ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ExistsOrNonemptyCondition ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Expression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ExpressionComprehensionClause ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . FloatLiteral ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ForComprehensionClause ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ForIterator ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . IdenticalOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . IfComprehensionClause ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . InOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . InvocationExpression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . IsCondition ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . IsOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . KeyValueIterator ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . LogicalAssignmentOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . LogicalOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . NaturalLiteral ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . NegativeOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Nonempty ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . NotOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . PositiveOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . PostfixOperatorExpression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . PowerOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . PrefixOperatorExpression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . QualifiedMemberExpression ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . SpecifierStatement ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . StringLiteral ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . StringTemplate ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Term ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . ValueIterator ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Variable ; import com . redhat . ceylon . compiler . typechecker . tree . Visitor ; public abstract class BoxingVisitor extends Visitor { protected abstract boolean isBooleanTrue ( Declaration decl ) ; protected abstract boolean isBooleanFalse ( Declaration decl ) ; @ Override public void visit ( BaseMemberExpression that ) { super . visit ( that ) ; if ( that . getDeclaration ( ) == null ) return ; Declaration decl = that . getDeclaration ( ) ; if ( CodegenUtil . isUnBoxed ( ( TypedDeclaration ) decl ) || isBooleanTrue ( decl ) || isBooleanFalse ( decl ) ) CodegenUtil . markUnBoxed ( that ) ; if ( CodegenUtil . isRaw ( ( TypedDeclaration ) decl ) ) CodegenUtil . markRaw ( that ) ; if ( CodegenUtil . hasTypeErased ( ( TypedDeclaration ) decl ) ) CodegenUtil . markTypeErased ( that ) ; } @ Override public void visit ( QualifiedMemberExpression that ) { super . visit ( that ) ; if ( that . getDeclaration ( ) == null ) return ; if ( that . getMemberOperator ( ) instanceof Tree . SafeMemberOp ) { if ( CodegenUtil . hasTypeErased ( ( TypedDeclaration ) that . getDeclaration ( ) ) ) CodegenUtil . markTypeErased ( that ) ; return ; } if ( Decl . isValueTypeDecl ( that . getPrimary ( ) ) ) { CodegenUtil . markUnBoxed ( that ) ; if ( CodegenUtil . isRaw ( ( TypedDeclaration ) that . getDeclaration ( ) ) ) CodegenUtil . markRaw ( that ) ; if ( CodegenUtil . hasTypeErased ( ( TypedDeclaration ) that . getDeclaration ( ) ) ) CodegenUtil . markTypeErased ( that ) ; } else { propagateFromDeclaration ( that , ( TypedDeclaration ) that . getDeclaration ( ) ) ; } } @ Override public void visit ( Expression that ) { super . visit ( that ) ; propagateFromTerm ( that , that . getTerm ( ) ) ; } @ Override public void visit ( InvocationExpression that ) { super . visit ( that ) ; propagateFromTerm ( that , that . getPrimary ( ) ) ; } @ Override public void visit ( NaturalLiteral that ) { super . visit ( that ) ; CodegenUtil . markUnBoxed ( that ) ; } @ Override public void visit ( FloatLiteral that ) { super . visit ( that ) ; CodegenUtil . markUnBoxed ( that ) ; } @ Override public void visit ( StringLiteral that ) { super . visit ( that ) ; CodegenUtil . markUnBoxed ( that ) ; } @ Override public void visit ( CharLiteral that ) { super . visit ( that ) ; CodegenUtil . markUnBoxed ( that ) ; } @ Override public", "gt": "void visit ( StringTemplate that )", "prediction": "void visit ( PostfixOperatorExpression that )\n", "label": 0}
{"id": 14933, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . ArrayList ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . NullWritable ; import org . apache . sqoop . util . AsyncSink ; import org . apache . sqoop . util . JdbcUrl ; import org . apache . sqoop . util . LoggingAsyncSink ; import org . apache . sqoop . util . NullAsyncSink ; import org . apache . sqoop . util . TaskId ; import com . cloudera . sqoop . io . NamedFifo ; import com . cloudera . sqoop . mapreduce . db . DBConfiguration ; import com . cloudera . sqoop . manager . MySQLUtils ; public class MySQLExportMapper < KEYIN , VALIN > extends SqoopMapper < KEYIN , VALIN , NullWritable , NullWritable > { public static final Log LOG = LogFactory . getLog ( MySQLExportMapper . class . getName ( ) ) ; public static final String MYSQL_CHECKPOINT_BYTES_KEY = \"sqoop.mysql.export.checkpoint.bytes\" ; public static final long DEFAULT_CHECKPOINT_BYTES = 32 * 1024 * 1024 ; protected long checkpointDistInBytes ; protected Configuration conf ; protected File fifoFile ; protected Process mysqlImportProcess ; protected OutputStream importStream ; protected AsyncSink outSink ; protected AsyncSink errSink ; protected File passwordFile ; protected String mysqlCharSet ; private long bytesWritten ; private void initMySQLImportProcess ( ) throws IOException { File taskAttemptDir = TaskId . getLocalWorkPath ( conf ) ; this . fifoFile = new File ( taskAttemptDir , conf . get ( MySQLUtils . TABLE_NAME_KEY , \"UNKNOWN_TABLE\" ) + \".txt\" ) ; String filename = fifoFile . toString ( ) ; try { new NamedFifo ( this . fifoFile ) . create ( ) ; } catch ( IOException ioe ) { LOG . error ( \"Could not mknod \" + filename ) ; this . fifoFile = null ; throw new IOException ( \"Could not create FIFO to interface with mysqlimport\" , ioe ) ; } ArrayList < String > args = new ArrayList < String > ( ) ; String connectString = conf . get ( MySQLUtils . CONNECT_STRING_KEY ) ; String databaseName = JdbcUrl . getDatabaseName ( connectString ) ; String hostname = JdbcUrl . getHostName ( connectString ) ; int port = JdbcUrl . getPort ( connectString ) ; if ( null == databaseName ) { throw new IOException ( \"Could not determine database name\" ) ; } args . add ( MySQLUtils . MYSQL_IMPORT_CMD ) ; String password = conf . get ( MySQLUtils . PASSWORD_KEY ) ; if ( null != password && password . length ( ) > 0 ) { passwordFile = new File ( MySQLUtils . writePasswordFile ( conf ) ) ; args . add ( \"--defaults-file=\" + passwordFile ) ; } String username = conf . get ( MySQLUtils . USERNAME_KEY ) ; if ( null != username ) { args . add ( \"--user=\" + username ) ; } args . add ( \"--host=\" + hostname ) ; if ( - 1 != port ) { args . add ( \"--port=\" + Integer . toString ( port ) ) ; } args . add ( \"--compress\" ) ; args . add ( \"--local\" ) ; args . add ( \"--silent\" ) ; DBConfiguration dbConf = new DBConfiguration ( conf ) ; String [ ] cols = dbConf . getInputFieldNames ( ) ; if ( null != cols ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; for ( String col : cols ) { if ( ! first ) { sb . append ( \",\" ) ; } sb . append ( col ) ; first = false ; } args . add ( \"--columns=\" + sb . toString ( ) ) ; } int outputFieldDelim = conf . getInt ( MySQLUtils . OUTPUT_FIELD_DELIM_KEY , ( int ) ',' ) ; int outputRecordDelim = conf . getInt ( MySQLUtils . OUTPUT_RECORD_DELIM_KEY , ( int ) '\\n' ) ; int enclosedBy = conf . getInt ( MySQLUtils . OUTPUT_ENCLOSED_BY_KEY , 0 ) ; int escapedBy = conf . getInt ( MySQLUtils . OUTPUT_ESCAPED_BY_KEY , 0 ) ; boolean encloseRequired = conf . getBoolean ( MySQLUtils . OUTPUT_ENCLOSE_REQUIRED_KEY , false ) ; args . add ( \"--fields-terminated-by=0x\" + Integer . toString ( outputFieldDelim , 16 ) ) ; args . add ( \"--lines-terminated-by=0x\" + Integer . toString ( outputRecordDelim , 16 ) ) ; if ( 0 != enclosedBy ) { if ( encloseRequired ) { args . add ( \"--fields-enclosed-by=0x\" + Integer . toString ( enclosedBy , 16 ) ) ; } else { args . add ( \"--fields-optionally-enclosed-by=0x\" + Integer . toString ( enclosedBy , 16 ) ) ; } } if ( 0 != escapedBy ) { args . add ( \"--escaped-by=0x\" + Integer . toString ( escapedBy , 16 ) ) ; } args . add ( databaseName ) ; args . add ( filename ) ; LOG . debug ( \"Starting mysqlimport with arguments:\" ) ; for ( String arg : args ) { LOG . debug ( \"  \" + arg ) ; } mysqlImportProcess = Runtime . getRuntime ( ) . exec ( args . toArray ( new String [ 0 ] ) ) ; this . outSink = new NullAsyncSink ( ) ; this . outSink . processStream ( mysqlImportProcess . getInputStream ( ) ) ; this . errSink = new LoggingAsyncSink ( LOG ) ; this . errSink . processStream ( mysqlImportProcess . getErrorStream ( ) ) ; this . importStream = new BufferedOutputStream ( new FileOutputStream ( fifoFile ) ) ; this . bytesWritten = 0 ; } @ Override public void run ( Context context ) throws IOException , InterruptedException { this . conf = context . getConfiguration ( ) ; setup ( context ) ; initMySQLImportProcess ( ) ; try { while ( context . nextKeyValue ( ) ) { map ( context . getCurrentKey ( ) , context . getCurrentValue ( ) , context ) ; } cleanup ( context ) ; } finally { closeExportHandles ( ) ; } }", "gt": "private void closeExportHandles ( ) throws IOException , InterruptedException", "prediction": "}\n", "label": 1}
{"id": 7258, "input": "<s> package com . sun . tools . javac . util ; import java . util . EnumSet ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javax . tools . Diagnostic ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . api . DiagnosticFormatter ; import com . sun . tools . javac . code . Lint . LintCategory ; import com . sun . tools . javac . tree . JCTree ; import static com . sun . tools . javac . util . JCDiagnostic . DiagnosticType . * ; public class JCDiagnostic implements Diagnostic < JavaFileObject > { public static class Factory { protected static final Context . Key < JCDiagnostic . Factory > diagnosticFactoryKey = new Context . Key < JCDiagnostic . Factory > ( ) ; public static Factory instance ( Context context ) { Factory instance = context . get ( diagnosticFactoryKey ) ; if ( instance == null ) instance = new Factory ( context ) ; return instance ; } DiagnosticFormatter < JCDiagnostic > formatter ; final String prefix ; final Set < DiagnosticFlag > defaultErrorFlags ; protected Factory ( Context context ) { this ( JavacMessages . instance ( context ) , \"compiler\" ) ; context . put ( diagnosticFactoryKey , this ) ; Options options = Options . instance ( context ) ; if ( options . isSet ( \"onlySyntaxErrorsUnrecoverable\" ) ) defaultErrorFlags . add ( DiagnosticFlag . RECOVERABLE ) ; } public Factory ( JavacMessages messages , String prefix ) { this . prefix = prefix ; this . formatter = new BasicDiagnosticFormatter ( messages ) ; defaultErrorFlags = EnumSet . of ( DiagnosticFlag . MANDATORY ) ; } public JCDiagnostic error ( DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( ERROR , null , defaultErrorFlags , source , pos , key , args ) ; } public JCDiagnostic mandatoryWarning ( DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( WARNING , null , EnumSet . of ( DiagnosticFlag . MANDATORY ) , source , pos , key , args ) ; } public JCDiagnostic mandatoryWarning ( LintCategory lc , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( WARNING , lc , EnumSet . of ( DiagnosticFlag . MANDATORY ) , source , pos , key , args ) ; } public JCDiagnostic warning ( LintCategory lc , String key , Object ... args ) { return create ( WARNING , lc , EnumSet . noneOf ( DiagnosticFlag . class ) , null , null , key , args ) ; } public JCDiagnostic warning ( DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( WARNING , null , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; } public JCDiagnostic warning ( LintCategory lc , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( WARNING , lc , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; } public JCDiagnostic mandatoryNote ( DiagnosticSource source , String key , Object ... args ) { return create ( NOTE , null , EnumSet . of ( DiagnosticFlag . MANDATORY ) , source , null , key , args ) ; } public JCDiagnostic note ( String key , Object ... args ) { return create ( NOTE , null , EnumSet . noneOf ( DiagnosticFlag . class ) , null , null , key , args ) ; } public JCDiagnostic note ( DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( NOTE , null , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; } public JCDiagnostic fragment ( String key", "gt": ", Object ... args )", "prediction": ", Object ... args )\n", "label": 0}
{"id": 14934, "input": "<s> package org . eclipse . rap . internal . design . example . fancy . layoutsets ; import org . eclipse . rap . internal . design . example . ILayoutSetConstants ; import org . eclipse . rap . ui . interactiondesign . layout . model . ILayoutSetInitializer ; import org . eclipse . rap . ui . interactiondesign . layout . model . LayoutSet ; import org . eclipse . swt . layout . FormAttachment ; import org . eclipse . swt . layout . FormData ; public class PerspectiveSwitcherInitializer implements ILayoutSetInitializer { public void initializeLayoutSet ( final LayoutSet layoutSet ) { layoutSet . addImagePath ( ILayoutSetConstants . PERSP_CLOSE , ILayoutSetConstants . IMAGE_PATH_FANCY + \"close.png\" ) ; layoutSet . addImagePath ( ILayoutSetConstants . PERSP_LEFT_ACTIVE , ILayoutSetConstants . IMAGE_PATH_FANCY + \"perspective_left_active.png\" ) ; layoutSet . addImagePath ( ILayoutSetConstants . PERSP_RIGHT_ACTIVE , ILayoutSetConstants . IMAGE_PATH_FANCY + \"perspective_right_active.png\" ) ; layoutSet . addImagePath ( ILayoutSetConstants . PERSP_BG , ILayoutSetConstants . IMAGE_PATH_FANCY + \"perspective_bg.png\" ) ; layoutSet . addImagePath ( ILayoutSetConstants . PERSP_BG_ACTIVE , ILayoutSetConstants . IMAGE_PATH_FANCY + \"perspective_bg_active.png\" ) ; FormData fdButton = new FormData ( ) ; fdButton . top = new FormAttachment", "gt": "( 0 , 4 ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3305, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . EnderDragon ; import Liza . LizaEnderDragon ; public class LizaCraftEnderDragon extends LizaCraftComplexLivingEntity implements LizaEnderDragon { public LizaCraftEnderDragon ( EnderDragon enderDragon ) { super ( enderDragon ) ; } @ Override public EnderDragon getBukkitHandle ( ) {", "gt": "return ( EnderDragon ) this . entity ;", "prediction": "return this . Ender ;\n", "label": 0}
{"id": 14936, "input": "<s> package org . nuxeo . ecm . platform . syndication . vocabularies ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . dom4j . dom . DOMDocument ; import org . dom4j . dom . DOMDocumentFactory ; import org . w3c . dom . Element ; public final class Tree { public static final class Builder { private final Map < String , List < SimpleVocabulary > > pendingVocabularies = new HashMap < String , List < SimpleVocabulary > > ( ) ; private final Map < String , HierarchicalVocabulary > mapVocabularies = new HashMap < String , HierarchicalVocabulary > ( ) ; public void addElement ( String parent , HierarchicalVocabulary parentVoca1 , SimpleVocabulary voca ) { if ( null == parent ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( null , voca ) ; addNewVocabulary ( newVoca ) ; } else { HierarchicalVocabulary parentVoca = mapVocabularies . get ( parent . toLowerCase ( ) ) ; if ( null != parentVoca ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( parentVoca , voca ) ; parentVoca . addChild ( newVoca ) ; addNewVocabulary ( newVoca ) ; } else { mapVocabularies . put ( parent , parentVoca1 ) ; addPendingVocabulary ( parent , voca ) ; } } } private void addNewVocabulary ( HierarchicalVocabulary voca ) { String id = voca . getVocabulary ( ) . getId ( ) . toLowerCase ( ) ; mapVocabularies . put ( id , voca ) ; addWaitingChildren ( voca ) ; } private void addWaitingChildren ( HierarchicalVocabulary voca ) { String id = voca . getVocabulary ( ) . getId ( ) . toLowerCase ( ) ; List < SimpleVocabulary > children = pendingVocabularies . remove ( id ) ; if ( null != children ) { for ( SimpleVocabulary child : children ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( voca , child ) ; voca . addChild ( newVoca ) ; } } } private void addPendingVocabulary ( String parent , SimpleVocabulary dir ) { List < SimpleVocabulary > dirs = pendingVocabularies . get ( parent . toLowerCase ( ) ) ; if ( null == dirs ) { dirs = new ArrayList < SimpleVocabulary > ( ) ; } dirs . add ( dir ) ; pendingVocabularies . put ( parent . toLowerCase ( ) , dirs ) ; } public Tree build ( ) { List < HierarchicalVocabulary > rootNodes = new ArrayList < HierarchicalVocabulary > ( ) ; Map < String , HierarchicalVocabulary > mV = new HashMap < String , HierarchicalVocabulary > ( ) ; mV . putAll ( mapVocabularies ) ; for ( String key : mV . keySet ( ) ) { addWaitingChildren ( mapVocabularies . get ( key ) ) ; } for ( HierarchicalVocabulary voca : mapVocabularies . values ( ) ) { HierarchicalVocabulary vp = getNode ( voca ) ; if ( ! rootNodes . contains ( vp ) ) { rootNodes . add ( vp ) ; } } Collections . sort ( rootNodes , HierarchicalVocabulary . ORDER_BY_ID ) ; return new Tree ( rootNodes ) ; } public HierarchicalVocabulary getNode ( HierarchicalVocabulary hv ) { if ( hv . getParent ( ) == null ) { return hv ; } else { return getNode ( hv . getParent ( ) ) ; } } } private final List < HierarchicalVocabulary > rootNodes = new ArrayList < HierarchicalVocabulary > ( ) ; private Tree (", "gt": "List < HierarchicalVocabulary > rootNodes )", "prediction": ")\n", "label": 1}
{"id": 5034, "input": "<s> package org . xbill . DNS ; public class MGRecord extends SingleNameBase { private static final long serialVersionUID = - 3980055550863644582L ; MGRecord ( ) { } Record getObject ( ) { return new MGRecord ( ) ; } public MGRecord ( Name name , int dclass , long ttl , Name mailbox ) { super ( name , Type . MG , dclass , ttl ,", "gt": "mailbox , \"mailbox\" ) ;", "prediction": "mailbox ) ;\n", "label": 0}
{"id": 14937, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . Directory ; import java . io . IOException ; import java . util . List ; import java . util . ArrayList ; import java . util . Set ; public abstract class MergePolicy { public static class OneMerge { SegmentInfo info ; boolean mergeDocStores ; boolean optimize ; boolean increfDone ; boolean registerDone ; long mergeGen ; boolean isExternal ; int maxNumSegmentsOptimize ; SegmentReader [ ] readers ; SegmentReader [ ] readersClone ; List mergeFiles ; final SegmentInfos segments ; final boolean useCompoundFile ; boolean aborted ; Throwable error ; public OneMerge ( SegmentInfos segments , boolean useCompoundFile ) { if ( 0 == segments . size ( ) ) throw new RuntimeException ( \"segments must include at least one segment\" ) ; this . segments = segments ; this . useCompoundFile = useCompoundFile ; } synchronized void setException ( Throwable error ) { this . error = error ; } synchronized Throwable getException ( ) { return error ; } synchronized void abort ( ) { aborted = true ; } synchronized boolean isAborted ( ) { return aborted ; } synchronized void checkAborted ( Directory dir ) throws MergeAbortedException { if ( aborted ) throw new MergeAbortedException ( \"merge is aborted: \" + segString ( dir ) ) ; } String segString ( Directory dir ) { StringBuffer b = new StringBuffer ( ) ; final int numSegments = segments . size ( ) ; for ( int i = 0 ; i < numSegments ; i ++ ) { if ( i > 0 ) b . append ( ' ' ) ; b . append ( segments . info ( i ) . segString ( dir ) ) ; } if ( info != null ) b . append ( \" into \" ) . append ( info . name ) ; if ( optimize ) b . append ( \" [optimize]\" ) ; if ( mergeDocStores ) { b . append ( \" [mergeDocStores]\" ) ; } return b . toString ( ) ; } } public static class MergeSpecification { public List merges = new ArrayList ( ) ; public void add ( OneMerge merge ) { merges . add ( merge ) ; } public String segString ( Directory dir ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \"MergeSpec:\\n\" ) ; final int count = merges . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) b . append ( \"  \" ) . append ( 1 + i ) . append ( \": \" ) . append ( ( ( OneMerge ) merges . get ( i ) ) . segString ( dir ) ) ; return b . toString ( ) ; } } public static class MergeException extends RuntimeException { private Directory dir ; public MergeException ( String message ) { super ( message ) ; } public MergeException ( String message , Directory dir ) { super ( message ) ; this . dir = dir ; } public MergeException ( Throwable exc ) { super ( exc ) ; } public MergeException ( Throwable exc , Directory dir ) { super ( exc ) ; this . dir = dir ; } public Directory getDirectory ( ) { return dir ; } } public static class MergeAbortedException extends IOException { public MergeAbortedException ( ) { super ( \"merge is aborted\" ) ; } public MergeAbortedException ( String message ) { super ( message ) ; } }", "gt": "final protected IndexWriter writer ;", "prediction": "}\n", "label": 1}
{"id": 2787, "input": "<s> package org . dawb . workbench . plotting . system . dialog ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . workbench . plotting . system . swtxy . XYRegionGraph ; import org . dawb . workbench . plotting . system . swtxy . selection . AbstractSelectionRegion ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; public class AddRegionDialog extends Dialog { private XYRegionGraph xyGraph ; private RegionComposite regionComposite ; private RegionType type ; public AddRegionDialog ( final Shell parentShell , final XYRegionGraph xyGraph , RegionType type ) { super ( parentShell ) ; setShellStyle ( getShellStyle ( ) | SWT . RESIZE ) ; this . xyGraph = xyGraph ; this . type = type ; } @ Override protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( \"Add Region\" ) ; } @ Override protected Control createDialogArea ( Composite parent ) { final Composite parent_composite = (", "gt": "Composite ) super . createDialogArea ( parent ) ;", "prediction": "Composite ) parent ;\n", "label": 0}
{"id": 14946, "input": "<s> package org . eclipse . ui ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . viewers . ISelectionProvider ; public interface IWorkbenchPartSite extends IWorkbenchSite { public String getId ( ) ; public String getPluginId ( ) ; public String getRegisteredName ( ) ; public void registerContextMenu ( String menuId , MenuManager", "gt": "menuManager , ISelectionProvider selectionProvider ) ;", "prediction": "menuManager ) ;\n", "label": 1}
{"id": 9446, "input": "<s> package org . ofbiz . sql . test ; import java . util . Collections ; import java . util . List ; import org . ofbiz . sql . BetweenCondition ; import org . ofbiz . sql . BooleanCondition ; import org . ofbiz . sql . Condition ; import org . ofbiz . sql . ConditionList ; import org . ofbiz . sql . Joiner ; import org . ofbiz . sql . ListCondition ; import org . ofbiz . sql . NumberValue ; import org . ofbiz . sql . Value ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; @ SourceMonitored public class ConditionsTest extends GenericTestCaseBase { private static final NumberValue < Long > l1 = NumberValue . valueOf ( 1 ) ; private static final NumberValue < Long > l2 = NumberValue . valueOf ( 5 ) ; private static final NumberValue < Long > l3 = NumberValue . valueOf ( 10 ) ; public ConditionsTest ( String name ) { super ( name ) ; } private static < C extends Condition > void basicTest ( String label , Class < C > clz , C c , String s , C o , boolean matches ) { assertEquals ( label + \":toString\" , s , c . toString ( ) ) ; assertNotEquals ( label + \":not-equals-this\" , c , ConditionsTest . class ) ; if ( o != null ) { if ( matches ) { assertEquals ( label + \":equals\" , o , c ) ; } else { assertNotEquals ( label + \":not-equals\" , o , c ) ; } } ConditionVisitorRecorder visitor = new ConditionVisitorRecorder ( ) ; c . accept ( visitor ) ; c . accept ( visitor ) ; assertEquals ( label + \":visited\" , 2 , visitor . counts . remove ( clz ) . intValue ( ) ) ; assertTrue ( label + \":nothing-else-visited\" , visitor . counts . isEmpty ( ) ) ; } private static void betweenConditionTest ( String label , BetweenCondition c , Value left , Value r1 , Value r2 , String s , BetweenCondition o , boolean matches ) { assertEquals ( label + \":left\" , left , c . getLeft ( ) ) ; assertEquals ( label + \":r1\" , r1 , c . getR1 ( ) ) ; assertEquals ( label + \":r2\" , r2 , c . getR2 ( ) ) ; basicTest ( label , BetweenCondition . class , c , s , o , matches ) ; } public void testBetweenCondition ( ) { BetweenCondition c1 = new BetweenCondition ( l1 , l2 , l3 ) ; betweenConditionTest ( \"c1\" , c1 , l1 , l2 , l3 , \"1 BETWEEN 5 AND 10\" , null , false ) ; BetweenCondition c2 = new BetweenCondition ( l3 , l1 , l2 ) ; betweenConditionTest ( \"c2\" , c2 , l3 , l1 , l2 , \"10 BETWEEN 1 AND 5\" , c1 , false ) ; BetweenCondition c3 = new BetweenCondition ( l1 , l2 , l3 ) ; betweenConditionTest ( \"c3\" , c3 , l1 , l2 , l3 , \"1 BETWEEN 5 AND 10\" , c1 , true ) ; BetweenCondition c4 = new BetweenCondition ( l1 , l3 , l2 ) ; betweenConditionTest ( \"c4\" , c4 , l1 , l3 , l2 , \"1 BETWEEN 10 AND 5\" , c1 , false ) ; BetweenCondition c5 = new BetweenCondition ( l1 , l2 , l1 ) ; betweenConditionTest ( \"c5\" , c5 , l1 , l2 , l1 , \"1 BETWEEN 5 AND 1\" , c1 , false ) ; } private static void booleanConditionTest ( String label , BooleanCondition c , Value left , String op , Value right , String s , BooleanCondition o , boolean matches ) { assertEquals ( label + \":left\" , left , c . getLeft ( ) ) ; assertEquals ( label + \":op\" , op , c . getOp ( ) ) ; assertEquals ( label + \":right\" , right , c . getRight ( ) ) ; basicTest ( label , BooleanCondition . class , c , s , o , matches ) ; } public void testBooleanCondition ( ) { BooleanCondition c1 = new BooleanCondition ( l1 , \"=\" , l2 ) ; booleanConditionTest ( \"c1\" , c1 , l1 , \"=\" , l2 , \"1 = 5\" , null , false ) ; BooleanCondition c2 = new BooleanCondition ( l1 , \"=\" , l3 ) ; booleanConditionTest ( \"c2\" , c2 , l1 , \"=\" , l3 , \"1 = 10\" , c1 , false ) ; BooleanCondition c3 = new BooleanCondition ( l1 , \"<\" , l2 ) ; booleanConditionTest ( \"c3\" , c3 , l1 , \"<\" , l2 , \"1 < 5\" , c1 , false ) ; BooleanCondition c4 = new BooleanCondition ( l2 , \">\" , l3 ) ; booleanConditionTest ( \"c4\" , c4 , l2 , \">\" , l3 , \"5 > 10\" , c1 , false ) ; BooleanCondition c5 = new BooleanCondition ( l1 , \"=\" , l2 ) ; booleanConditionTest ( \"c5\" , c5 , l1 , \"=\" , l2 , \"1 = 5\" , c1 , true ) ; } private static void conditionListTest ( String label , ConditionList c , Joiner joiner , List < ? extends Condition > conditions , String s , ConditionList o , boolean matches ) { assertEquals ( label + \":joiner\" , joiner , c . getJoiner ( ) ) ; basicTest ( label , ConditionList . class , c , s , o , matches ) ; BooleanCondition b = new BooleanCondition ( l1 , \"=\" , l3 ) ; c . add ( b ) ; assertEqualsIterable ( label + \":iterable\" , conditions , Collections . < Condition > emptyList ( ) , false , c , list ( b ) , true ) ; } public void testConditionList ( ) { BooleanCondition b1 = new BooleanCondition ( l1 , \"=\" , l2 ) ; BooleanCondition b2 = new BooleanCondition ( l2 , \"=\" , l3 ) ; ConditionList c1 = new ConditionList ( Joiner . AND , GenericTestCaseBase . < Condition > list", "gt": "( b1 ) ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 14951, "input": "<s> package org . restlet . test . resource ; public class LightContact { private String email1 ; private String firstName ; private String lastName ; public LightContact ( String email , String firstName , String lastName ) { super ( ) ; this . email1 = email ; this . firstName = firstName ; this . lastName = lastName ; } public String getEmail1 ( ) { return email1 ; } public String getFirstName ( ) { return firstName ; } public String getLastName ( ) { return lastName ; } public void setEmail1 ( String email ) { this . email1 = email ; } public void setFirstName ( String firstName ) { this . firstName = firstName ; }", "gt": "public void setLastName ( String lastName )", "prediction": "public void setLastName ( String lastName )\n", "label": 1}
{"id": 1213, "input": "<s> package org . gk . engine . client . build . portal ; import java . util . List ; import org . gk . engine . client . build . panel . XContentPanel ; import org . gk . engine . client . gen . UIGen ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . custom . Portlet ; import com . google . gwt . xml . client . Node ; public class XPortlet extends XContentPanel { protected String column ; public XPortlet ( Node node , List < UIGen > widgets ) { super ( node , widgets ) ; height", "gt": "= super . getAttribute ( \"height\" , \"150\" ) ;", "prediction": "= 0 ;\n", "label": 0}
{"id": 14954, "input": "<s> package org . jscsi . initiator . connection . phase ; import java . nio . ByteBuffer ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . initiator . connection . ITask ; import org . jscsi . initiator . connection . Session ; import org . jscsi . initiator . connection . TargetCapacityInformations ; import org . jscsi . initiator . connection . state . CapacityRequestState ; import org . jscsi . initiator . connection . state . GetConnectionsRequestState ; import org . jscsi . initiator . connection . state . LogoutRequestState ; import org . jscsi . initiator . connection . state . ReadRequestState ; import org . jscsi . initiator . connection . state . WriteRequestState ; import org . jscsi . parser . login . LoginStage ; import org . jscsi . parser . logout . LogoutRequestParser . LogoutReasonCode ; import org . jscsi . parser . scsi . SCSICommandParser . TaskAttributes ; public final class FullFeaturePhase extends AbstractPhase { private static final int READ_FIRST_STAGE_BLOCKS = 64 ; private static final int READ_SECOND_STAGE_BLOCKS = 128 ; private static final int READ_THIRD_STAGE_BLOCKS = 256 ; private static final int WRITE_FIRST_STAGE_BLOCKS = 1024 ; private static final int WRITE_SECOND_STAGE_BLOCKS = 2048 ; private static final int WRITE_THIRD_STAGE_BLOCKS = 4096 ; @ Override public final boolean login ( final Session session ) throws Exception { final Connection connection = session . getNextFreeConnection ( ) ; connection . nextState ( new GetConnectionsRequestState ( connection ) ) ; session . releaseUsedConnection ( connection ) ; return true ; } @ Override public final boolean logoutSession ( final ITask task , final Session session ) throws Exception { final Connection connection = session . getNextFreeConnection ( ) ; connection . getSession ( ) . addOutstandingTask ( connection , task ) ; connection . nextState ( new LogoutRequestState ( connection , LogoutReasonCode . CLOSE_SESSION ) ) ; return true ; } @ Override public final boolean read ( final ITask task , final Session session , final ByteBuffer dst , final int logicalBlockAddress , final long length ) throws Exception { if ( dst . remaining ( ) < length ) { throw new IllegalArgumentException ( \"Destination buffer is too small.\" ) ; } int startAddress = logicalBlockAddress ; final long blockSize = session . getBlockSize ( ) ; long totalBlocks = ( long ) Math . ceil ( length / ( double ) blockSize ) ; long bytes2Process = length ; final Connection connection = session . getNextFreeConnection ( ) ; connection . getSession ( ) . addOutstandingTask ( connection , task ) ; short blocks = ( short ) Math . min ( READ_FIRST_STAGE_BLOCKS , totalBlocks ) ; if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; bytes2Process -= blocks * blockSize ; blocks = ( short ) Math . min ( READ_SECOND_STAGE_BLOCKS , totalBlocks ) ; if ( blocks > 0 ) { if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; bytes2Process -= blocks * blockSize ; } blocks = ( short ) Math . min ( READ_THIRD_STAGE_BLOCKS , totalBlocks ) ; while ( blocks > 0 ) { if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; blocks = ( short ) Math . min ( READ_THIRD_STAGE_BLOCKS , totalBlocks ) ; } return true ; } @ Override public final boolean write ( final ITask task , final Session session , final ByteBuffer src , final int logicalBlockAddress , final long length ) throws Exception { if ( src . remaining ( ) < length ) { throw new IllegalArgumentException ( \"Source buffer is too small. Buffer size: \" + src . remaining ( ) + \" Expected: \" + length ) ; } int startAddress = logicalBlockAddress ; final long blockSize = session . getBlockSize ( ) ; int totalBlocks = ( int ) Math . ceil ( length / (", "gt": "double ) blockSize ) ;", "prediction": "double ) blockSize ) ;\n", "label": 1}
{"id": 7887, "input": "<s> package api . util ; public class Sextuple < A , B , C , D , E , F > { private A a ; private B b ; private C c ; private D d ; private E e ; private F f ; public Sextuple ( A a , B b , C c , D d , E e , F f ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; this . e = e ; this . f = f ; } public A getA ( ) { return a ; } public B getB ( ) { return b ; } public C getC ( ) { return c ; } public D getD ( ) { return d ; } public void setA ( A a ) { this . a = a ; } public void setB ( B b ) { this . b = b ; } public void setC ( C c ) { this . c = c ; } public void setD ( D d ) { this . d = d ; } public E getE ( ) { return e ; } public void setE ( E e ) { this . e = e ; } public F getF ( ) { return f ; } public void setF ( F f ) { this . f = f ; } @ Override public String toString ( ) { return a + \",\" + b + \",\" + c + \",\" + d", "gt": "+ \",\" + e + \",\" + f ;", "prediction": ";\n", "label": 0}
{"id": 14958, "input": "<s> package org . eclipse . swt . graphics ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; public class FontMetrics_Test extends TestCase { public void testGetHeight ( ) { Display display = new Display ( ) ; GC gc = new GC ( display ) ; gc . setFont ( new Font ( display , \"Arial\" , 10 , SWT . NORMAL ) ) ; FontMetrics fontMetrics10 = gc . getFontMetrics ( ) ; int height10 = fontMetrics10 . getHeight ( ) ; gc . setFont ( new Font ( display , \"Arial\" , 30 , SWT . NORMAL ) ) ; FontMetrics fontMetrics30 = gc . getFontMetrics ( ) ; int height30 = fontMetrics30 . getHeight ( ) ; assertTrue ( height30 > height10 ) ; } public void testEquals ( ) { Display display = new Display ( ) ; GC gc = new GC ( display ) ; gc . setFont ( new Font ( display , \"Arial\" , 10 , SWT . NORMAL ) ) ; FontMetrics fontMetrics = gc . getFontMetrics ( ) ; FontMetrics equalFontMetrics = gc . getFontMetrics ( ) ; assertTrue ( equalFontMetrics . equals ( fontMetrics ) ) ; gc . setFont ( new Font ( display , \"Arial\" , 12 , SWT . NORMAL ) ) ; FontMetrics differentFontMetrics = gc . getFontMetrics ( ) ; assertFalse ( differentFontMetrics . equals ( fontMetrics ) ) ; } protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; } protected", "gt": "void tearDown ( ) throws Exception", "prediction": "void tearDown ( ) throws Exception\n", "label": 1}
{"id": 793, "input": "<s> package org . ofbiz . entity . util ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; public interface DistributedCacheClear { public void setDelegator", "gt": "( Delegator delegator , String userLoginId ) ;", "prediction": "( Delegator delegate ) ;\n", "label": 0}
{"id": 14959, "input": "<s> package org . modelgoon . packages . figures ; import org . eclipse . draw2d . AbstractBorder ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . geometry . Insets ; public class RoundedBorder extends AbstractBorder { public Insets getInsets ( final IFigure figure ) { return new Insets ( 3 , 5 ,", "gt": "3 , 10 ) ;", "prediction": "5 ) ;\n", "label": 1}
{"id": 307, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Main { static int maxW , maxH ; static Linha l [ ] ; static int lines ; static int maxP ; public static boolean verifica ( int points ) { if ( points == 8 ) { return false ; } else { return tenta ( points - 1 ) ; } } public static boolean tenta ( int points ) { int curH = lines * points ; if ( curH > maxH ) { return verifica ( points ) ; } int mh = maxH / points , mmw = maxW / points ; mh -= lines ; for ( int i = 0 ; i != lines ; i ++ ) { int mw = mmw ; for ( int k = 0 ; k < l [ i ] . n ; k ++ ) { if ( l [ i ] . len [ k ] > mmw ) { return verifica ( points ) ; } else if ( mw == mmw ) { mw -= l [ i ] . len [ k ] ; } else if ( mw < ( l [ i ] . len [ k ] + 1 ) ) { mw = ( mmw ) - ( l [ i ] . len [ k ] ) ; mh -- ; if ( mh < 0 ) { return verifica ( points ) ; } } else { mw -= ( l [ i ] . len [ k ] + 1 ) ; } } if ( mh < 0 ) return verifica ( points ) ; } if ( maxP < points ) { maxP = points ; } return true ; } public static void novo ( ) { lines = Integer . parseInt ( readLine ( 100 ) . trim ( ) ) ; l = new Linha [ lines ] ; for ( int i = 0 ; i != lines ; i ++ ) { l [ i ] = new Linha ( readLine ( 10000 ) . trim ( ) ) ; } int z [ ] = parseIntLine ( ) ; maxW = z [ 0 ] ; maxH = z [ 1 ] ; if ( lines * 8 > maxH || ! tenta ( 8 ) ) { System . out . println ( \"No solution\" ) ; } else { maxP = 8 ; if ( ! tenta ( 28 ) ) { System . out . println ( \"No solution\" ) ; } else { System . out . println ( maxP ) ; } } } public static void main ( String args [ ] ) { try { int c = Integer . parseInt ( readLine ( 10 ) . trim ( ) ) ; while ( c -- != 0 ) { novo ( ) ; } } catch ( Exception e ) { while ( true ) ; } } public static String [ ] parseNewLine ( ) { String l = readLine ( 10000 ) . trim ( ) ; StringTokenizer st = new StringTokenizer ( l ) ; String [ ] s = new String [ st . countTokens ( ) ] ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { s [ i ++ ] = st . nextToken ( ) ; } return s ; } public static String [ ] parseLine ( String l ) { StringTokenizer st = new StringTokenizer ( l ) ; String [ ] s = new String [ st . countTokens ( ) ] ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { s [ i ++ ] = st . nextToken ( ) ; } return s ; } public static int [ ] parseIntLine ( ) { String l = readLine ( 10000 ) . trim ( ) ; StringTokenizer st = new StringTokenizer ( l ) ; int [ ] s = new int [ st . countTokens ( ) ] ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { s [ i ++ ] = Integer . parseInt ( st .", "gt": "nextToken ( ) . trim ( ) ) ;", "prediction": "nextToken ( ) ) ;\n", "label": 0}
{"id": 14961, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . * ; public class TableItem extends Item { private class TableItemAdapter implements ITableItemAdapter , IWidgetFontAdapter , IWidgetColorAdapter { public Color getUserBackground ( ) { return background ; } public Color getUserForeground ( ) { return foreground ; } public Font getUserFont ( ) { return font ; } public Color [ ] getCellBackgrounds ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Color [ ] result = new Color [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . background ; } } } return result ; } public Color [ ] getCellForegrounds ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Color [ ] result = new Color [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . foreground ; } } } return result ; } public Font [ ] getCellFonts ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Font [ ] result = new Font [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . font ; } } } return result ; } public boolean isParentDisposed ( ) { return TableItem . this . parent . isDisposed ( ) ; } } private static final class Data implements SerializableCompatibility { static final int UNKNOWN_WIDTH = - 1 ; String text = \"\" ; int textWidth = UNKNOWN_WIDTH ; Image image ; Font font ; Color background ; Color foreground ; } private transient TableItemAdapter tableItemAdapter ; final Table parent ; boolean cached ; int index ; private Data [ ] data ; private boolean checked ; private boolean grayed ; private Color background ; private Color foreground ; private Font font ; public TableItem ( Table parent , int style ) { this ( parent , style , checkNull ( parent ) . getItemCount ( ) ) ; } public TableItem ( Table parent , int style , int index ) { this ( parent , style , index , true ) ; } TableItem ( Table parent , int style , int index , boolean create ) { super ( parent , style ) ; this . parent = parent ; this . index = index ; if ( create ) { this . parent . createItem ( this , index ) ; } } @ Override @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Class < T > adapter ) { T result ; if ( adapter == IWidgetFontAdapter . class || adapter == IWidgetColorAdapter . class || adapter == ITableItemAdapter . class ) { if ( tableItemAdapter == null ) { tableItemAdapter = new TableItemAdapter ( ) ; } result = ( T ) tableItemAdapter ; } else { result = super . getAdapter ( adapter ) ; } return result ; } public Table getParent ( ) { checkWidget ( ) ; return parent ; } @ Override public void setText ( String text ) { checkWidget ( ) ; setText ( 0 , text ) ; } public void setText ( int index , String text ) { checkWidget ( ) ; if ( text == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( parent . markupEnabled && ! parent . markupValidationDisabled ) { MarkupValidator . getInstance ( ) . validate ( text ) ; } int count = Math . max ( 1 , parent . getColumnCount ( ) ) ; if ( index >= 0 && index < count ) { ensureData ( index , count ) ; if ( ! text . equals ( data [ index ] . text ) ) { data [ index ] . text = text ; data [ index ] . textWidth = Data . UNKNOWN_WIDTH ; markCached ( ) ; if ( parent . getColumnCount ( ) == 0 ) { parent . updateScrollBars ( ) ; } parent . redraw ( ) ; } } } public void setText ( String [ ] strings ) { checkWidget ( ) ; if ( strings == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } for ( int i = 0 ; i < strings . length ; i ++ ) { String string = strings [ i ] ; if ( string != null ) { setText ( i , string ) ; } } } @ Override public String getText ( ) { checkWidget ( ) ; return getText ( 0 ) ; } public String getText ( int index ) { checkWidget ( ) ; if ( ! parent . checkData ( this , parent . indexOf ( this ) ) ) { error ( SWT . ERROR_WIDGET_DISPOSED ) ; } String result = \"\" ; if ( hasData ( index ) ) { result = data [ index ] . text ; } return result ; } @ Override public void setImage ( Image image ) { checkWidget ( ) ; setImage ( 0 , image ) ; } public void setImage ( int", "gt": "index , Image image )", "prediction": "index , Image image )\n", "label": 1}
{"id": 5398, "input": "<s> package advws . net . nagios . jmeoldy . util ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; public class SimpleCommandLineParser { private Map < String , String > argMap ; public SimpleCommandLineParser ( String [ ] arg ) { argMap = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < arg . length ; i ++ ) { String key ; if ( arg [ i ] . startsWith ( \"--\" ) ) { key = arg [ i ] . substring ( 2 ) ; } else if ( arg [ i ] . startsWith ( \"-\" ) ) { key = arg [ i ] . substring ( 1 ) ; } else { argMap . put ( arg [ i ] , null ) ; continue ; } String value ; int index = key . indexOf ( '=' ) ; if ( index == - 1 ) { if ( ( ( i + 1 ) < arg . length ) && ( arg [ i + 1 ] . charAt ( 0 ) != '-' ) ) { argMap . put ( key , arg [ i + 1 ] ) ; i ++ ; } else { argMap . put ( key , null ) ; } } else { value = key . substring", "gt": "( index + 1 ) ;", "prediction": "( 0 , index ) ;\n", "label": 0}
{"id": 14962, "input": "<s> package knowevo . myvizster . render ; import java . awt . BasicStroke ; import java . awt . Image ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Entity ; import edu . berkeley . guir . prefuse . render . ImageFactory ; import edu . berkeley . guir . prefuse . render . TextImageItemRenderer ; public class VizsterImageRenderer extends TextImageItemRenderer { private static final String PHOTO_FIELD = \"photo\" ; private static final String NAME_FIELD = \"name\" ; private BasicStroke stroke1 = new BasicStroke ( 1 ) ; private BasicStroke stroke2 = new BasicStroke ( 2 ) ; private ImageFactory m_bwimages ; public VizsterImageRenderer ( ) { this . setImageAttributeName ( PHOTO_FIELD ) ; this . setTextAttributeName ( NAME_FIELD ) ; m_bwimages = new ImageFactory ( ) ; this . setRoundedCorner ( 8 , 8 ) ; this . setHorizontalPadding ( 4 ) ; this . setVerticalPadding ( 1 ) ; } public ImageFactory getBlackAndWhiteImageFactory ( ) { return m_bwimages ; } public int getRenderType ( VisualItem item ) { ItemRegistry registry = item . getItemRegistry ( ) ; FocusManager fm = registry . getFocusManager ( ) ; FocusSet focusSet = fm . getDefaultFocusSet ( ) ; FocusSet clickSet = fm . getFocusSet ( Vizster . CLICK_KEY ) ; FocusSet mouseSet = fm . getFocusSet ( Vizster . MOUSE_KEY ) ; FocusSet searchSet = fm . getFocusSet ( Vizster . SEARCH_KEY ) ; Entity entity = item . getEntity ( ) ; boolean fs = focusSet . contains ( entity ) ; boolean cs = clickSet . contains ( entity ) ; boolean ms = mouseSet . contains ( entity ) ; if ( ms || item . isHighlighted ( ) ) { return RENDER_TYPE_DRAW_AND_FILL ; } else if ( ( fs || cs ) && searchSet != null && searchSet . size ( ) > 0 ) { return RENDER_TYPE_DRAW ; } else if ( fs || cs ) { return RENDER_TYPE_DRAW_AND_FILL ; } else if ( item . isHighlighted ( ) ) return RENDER_TYPE_FILL ; else return RENDER_TYPE_NONE ; } protected Image getImage ( VisualItem item ) { if ( ! m_showImages ) return null ; String imageLoc = getImageLocation ( item ) ; int [ ] hvalue = ( int [ ] ) item . getVizAttribute ( \"highlightValue\" ) ; int val = ( hvalue", "gt": "== null ? 0 : hvalue [ 0 ] ) ;", "prediction": "== null ) ? 0 : hvalue [ 0 ] ;\n", "label": 1}
{"id": 3120, "input": "<s> import java . io . File ; import java . io . IOException ; import java . net . URI ; import javax . tools . JavaFileObject ; public class T6440333 extends ToolTester { void test ( String ... args ) throws IOException { File path = test_src . getCanonicalFile ( ) ; File src = new File ( new File ( path , \".\" ) , \"T6440333.java\" ) ; JavaFileObject fo = fm . getJavaFileObjects ( src ) . iterator ( ) . next ( ) ; URI expect = src . getCanonicalFile ( ) . toURI ( ) ; System . err . println ( \"Expect \" + expect ) ; System . err . println ( \"Found  \" + fo . toUri ( ) ) ; if ( ! expect . equals ( fo . toUri ( ) ) ) { throw new AssertionError ( ) ; } } public static void main ( String ... args ) throws IOException { new", "gt": "T6440333 ( ) . test ( args ) ;", "prediction": "T6440333 ( ) ;\n", "label": 0}
{"id": 14963, "input": "<s> package org . fuzzydb . attrs . layout ; import org . fuzzydb . attrs . bool . BooleanConstraint ; import org . fuzzydb . attrs . bool . BooleanValue ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; public class BooleanCodec extends LayoutAttrCodec < IAttribute > { private static final int ENCODED_LENGTH = 1 ; private static BooleanCodec instance = null ; public static synchronized BooleanCodec getInstance ( ) { if ( instance == null ) { instance = new BooleanCodec ( ) ; } return instance ; } @ Override public void encode ( LayoutAttrMap < IAttribute > map , int attrId , Object value ) { int index = map . getIndexForIntsWrite ( attrId , ENCODED_LENGTH ) ; Boolean bv = ( Boolean ) value ; map . getInts ( ) [ index ] = bv . booleanValue ( ) ? 1 : 0 ; } @ Override public IAttribute getDecoded ( LayoutAttrMap < IAttribute > map , int attrId ) { int index = map . getIndexQuick ( attrId ) ; boolean isTrue = map . getInts ( ) [ index ] == 1 ; return BooleanValue . valueOf ( attrId , isTrue ) ; } @ Override protected boolean consistentForInternal ( LayoutAttrMap <", "gt": "IAttribute > map , int attrId , IAttributeConstraint constraint )", "prediction": "IAttribute > map )\n", "label": 1}
{"id": 165, "input": "<s> package a ; public abstract class CrossPackageImplA { public static void main ( String [ ] args ) { CrossPackageImplA a = new CrossPackageImplC ( ) ; System . out . println ( a . message ( ) ) ; } abstract", "gt": "String message ( ) ;", "prediction": "public abstract class PackageA\n", "label": 0}
{"id": 14971, "input": "<s> package br . org . archimedes . text . edittext ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . SelectorFactory ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . model . Element ; import br . org . archimedes . text . Text ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; public class EditTextFactory extends SelectorFactory { private UndoableCommand command ; public EditTextFactory ( ) { super ( ) ; } protected String getCancelMessage ( ) { return Messages . Factory_Cancel ; } public String getName ( ) { return \"edittext\" ; } public List < Command > getCommands ( ) { List < Command > cmds = null ; if ( command != null ) { cmds = new ArrayList < Command > ( ) ; cmds . add ( command ) ; command = null ; } return cmds ; } @ Override protected String finishFactory ( Set < Element > selection ) throws InvalidParameterException { String message = null ; try { Text text = tryGetText ( selection ) ; command = new EditTextCommand ( text ) ; message = Messages . Factory_Edited ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } return message ; } private Text tryGetText ( Set < Element > selection ) throws InvalidParameterException { if ( selection == null || selection . isEmpty ( ) ) { throw new InvalidParameterException ( Messages . Factory_InvalidSelection ) ; } Text text = null ; for ( Element element : selection ) { if ( element . getClass ( ) == Text . class ) {", "gt": "text = ( Text ) element ;", "prediction": "text = ( Text ) element ;\n", "label": 1}
{"id": 4893, "input": "<s> class ExtendsAccess { class defaultClass { } public class publicClass { } private class privateClass { } protected class protectedClass { } static class defaultStaticClass { } public static class publicStaticClass { } private static class privateStaticClass { } protected static class protectedStaticClass { } interface defaultInterface { } public interface publicInterface { } private interface privateInterface { } protected interface protectedInterface { } } class ExtendsAccess111 extends publicClass { } class ExtendsAccess112 extends defaultClass { } class ExtendsAccess113 extends protectedClass { } class ExtendsAccess114 extends privateClass { } class ExtendsAccess1211 extends ExtendsAccess . publicClass { } class ExtendsAccess1221 extends ExtendsAccess . defaultClass { } class ExtendsAccess1231 extends ExtendsAccess . protectedClass { } class ExtendsAccess1241 extends ExtendsAccess . privateClass { } class ExtendsAccess1212 extends p . ExtendsAccess . publicClass { } class ExtendsAccess1222 extends p . ExtendsAccess . defaultClass { } class ExtendsAccess1232 extends p . ExtendsAccess . protectedClass { } class ExtendsAccess1242 extends p . ExtendsAccess . privateClass { } class ExtendsAccess1311 extends ExtendsAccess { class N extends publicClass { } } class ExtendsAccess1321 extends ExtendsAccess { class N extends defaultClass { } } class ExtendsAccess1331 extends ExtendsAccess { class N extends protectedClass { } } class ExtendsAccess1341 extends ExtendsAccess { class N extends privateClass { } } class ExtendsAccess1312 extends p . ExtendsAccess { class N extends publicClass { } } class ExtendsAccess1322 extends p . ExtendsAccess { class N extends defaultClass { } } class ExtendsAccess1332 extends p . ExtendsAccess { class N extends protectedClass { } } class ExtendsAccess1342 extends p . ExtendsAccess { class N extends privateClass { } } class ExtendsAccess1411 extends ExtendsAccess { class N extends ExtendsAccess . publicClass { } } class ExtendsAccess1421 extends ExtendsAccess { class N extends ExtendsAccess . defaultClass { } } class ExtendsAccess1431 extends ExtendsAccess { class N extends ExtendsAccess . protectedClass { } } class ExtendsAccess1441 extends ExtendsAccess { class N extends ExtendsAccess1441 . protectedClass { } } class ExtendsAccess1451 extends ExtendsAccess { class N extends ExtendsAccess . privateClass { } } class ExtendsAccess1412 extends p . ExtendsAccess { class N extends p . ExtendsAccess . publicClass { } } class ExtendsAccess1422 extends p . ExtendsAccess { class N extends p . ExtendsAccess . defaultClass { } } class ExtendsAccess1432 extends p . ExtendsAccess { class N extends p . ExtendsAccess . protectedClass { } } class ExtendsAccess1442 extends p . ExtendsAccess { class N extends ExtendsAccess1442 . protectedClass { } } class ExtendsAccess1452 extends p . ExtendsAccess { class N extends p . ExtendsAccess . privateClass { } } class ExtendsAccess211 extends publicStaticClass { } class ExtendsAccess212 extends defaultStaticClass { } class ExtendsAccess213 extends protectedStaticClass { } class ExtendsAccess214 extends privateStaticClass { } class ExtendsAccess2211 extends ExtendsAccess . publicStaticClass { } class ExtendsAccess2221 extends ExtendsAccess . defaultStaticClass { } class ExtendsAccess2231 extends ExtendsAccess . protectedStaticClass { } class ExtendsAccess2241 extends ExtendsAccess . privateStaticClass { } class ExtendsAccess2212 extends p . ExtendsAccess . publicStaticClass { } class ExtendsAccess2222 extends p . ExtendsAccess . defaultStaticClass { } class ExtendsAccess2232 extends p . ExtendsAccess . protectedStaticClass { } class ExtendsAccess2242 extends p . ExtendsAccess . privateStaticClass { } class ExtendsAccess2311 extends ExtendsAccess { class N extends publicStaticClass { } } class ExtendsAccess2321 extends ExtendsAccess { class N extends defaultStaticClass { } } class ExtendsAccess2331 extends ExtendsAccess { class N extends protectedStaticClass { } } class ExtendsAccess2341 extends ExtendsAccess { class N extends privateStaticClass { } } class ExtendsAccess2312 extends p . ExtendsAccess { class N extends publicStaticClass { } } class ExtendsAccess2322 extends p . ExtendsAccess { class N extends defaultStaticClass { } } class ExtendsAccess2332 extends p . ExtendsAccess { class N extends protectedStaticClass { } } class ExtendsAccess2342 extends p . ExtendsAccess { class N extends privateStaticClass { } } class ExtendsAccess2411 extends ExtendsAccess { class N extends ExtendsAccess . publicStaticClass { } } class ExtendsAccess2421 extends ExtendsAccess { class N extends ExtendsAccess . defaultStaticClass { } } class ExtendsAccess2431 extends ExtendsAccess { class N extends ExtendsAccess . protectedStaticClass { } } class ExtendsAccess2441 extends ExtendsAccess { class N extends ExtendsAccess2431 . protectedStaticClass { } } class ExtendsAccess2451 extends ExtendsAccess { class N extends ExtendsAccess . privateStaticClass { } } class ExtendsAccess2412 extends p . ExtendsAccess { class N extends p . ExtendsAccess . publicStaticClass { } } class ExtendsAccess2422 extends p . ExtendsAccess { class N extends p . ExtendsAccess . defaultStaticClass { } } class ExtendsAccess2432 extends p . ExtendsAccess { class N extends p . ExtendsAccess . protectedStaticClass { } } class ExtendsAccess2442 extends p . ExtendsAccess { class N extends ExtendsAccess2442 . protectedStaticClass { } } class ExtendsAccess2452 extends p . ExtendsAccess { class N extends p . ExtendsAccess . privateStaticClass { } } class ExtendsAccess311 extends ExtendsAccess implements publicInterface { } class ExtendsAccess312 extends ExtendsAccess implements defaultInterface { } class ExtendsAccess313 extends ExtendsAccess implements protectedInterface { } class ExtendsAccess314 extends ExtendsAccess implements privateInterface { } class ExtendsAccess3211 extends ExtendsAccess implements ExtendsAccess . publicInterface { } class ExtendsAccess3221 extends ExtendsAccess implements ExtendsAccess . defaultInterface { } class ExtendsAccess3231 extends ExtendsAccess implements ExtendsAccess . protectedInterface { } class ExtendsAccess3241 extends ExtendsAccess implements ExtendsAccess . privateInterface { } class ExtendsAccess3212 extends ExtendsAccess implements p . ExtendsAccess . publicInterface { } class ExtendsAccess3222 extends ExtendsAccess implements p . ExtendsAccess . defaultInterface { } class ExtendsAccess3232 extends ExtendsAccess implements p . ExtendsAccess . protectedInterface { } class ExtendsAccess3242 extends ExtendsAccess implements p . ExtendsAccess . privateInterface { } class ExtendsAccess331 extends ExtendsAccess { class N implements publicInterface { } } class ExtendsAccess3321 extends ExtendsAccess { class N implements defaultInterface { } } class ExtendsAccess3331 extends ExtendsAccess { class N implements protectedInterface { } } class ExtendsAccess3341 extends ExtendsAccess { class N implements privateInterface { } } class ExtendsAccess3312 extends p . ExtendsAccess { class N implements publicInterface { } } class ExtendsAccess3322 extends p . ExtendsAccess { class N implements defaultInterface { } } class ExtendsAccess3332 extends p . ExtendsAccess { class N implements protectedInterface { } } class ExtendsAccess3342 extends p . ExtendsAccess { class N implements privateInterface { } } class ExtendsAccess341 extends ExtendsAccess { class N implements ExtendsAccess . publicInterface { } } class ExtendsAccess3421 extends ExtendsAccess { class N implements ExtendsAccess . defaultInterface { } } class ExtendsAccess3431 extends ExtendsAccess { class N implements ExtendsAccess . protectedInterface { } } class ExtendsAccess3441 extends ExtendsAccess { class N implements ExtendsAccess3441 . protectedInterface { } } class ExtendsAccess3451 extends ExtendsAccess { class N implements ExtendsAccess . privateInterface { } } class ExtendsAccess342 extends p . ExtendsAccess { class N implements p . ExtendsAccess . publicInterface { } } class ExtendsAccess3422 extends p . ExtendsAccess { class N implements", "gt": "p . ExtendsAccess . defaultInterface", "prediction": "protectedInterface\n", "label": 0}
{"id": 14972, "input": "<s> package com . corundumstudio . socketio . transport ; import java . io . IOException ; import java . util . Collection ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . TimeUnit ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelFuture ; import org . jboss . netty . channel . ChannelFutureListener ; import org . jboss . netty . channel . ChannelHandler . Sharable ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . Channels ; import org . jboss . netty . channel . MessageEvent ; import org . jboss . netty . handler . codec . http . HttpHeaders ; import org . jboss . netty . handler . codec . http . HttpMethod ; import org . jboss . netty . handler . codec . http . HttpRequest ; import org . jboss . netty . handler . codec . http . QueryStringDecoder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . corundumstudio . socketio . Configuration ; import com . corundumstudio . socketio . DisconnectableHub ; import com . corundumstudio . socketio . SocketIOClient ; import com . corundumstudio . socketio . ack . AckManager ; import com . corundumstudio . socketio . handler . AuthorizeHandler ; import com . corundumstudio . socketio . messages . PacketsMessage ; import com . corundumstudio . socketio . messages . XHRErrorMessage ; import com . corundumstudio . socketio . messages . XHRPostMessage ; import com . corundumstudio . socketio . parser . ErrorAdvice ; import com . corundumstudio . socketio . parser . ErrorReason ; import com . corundumstudio . socketio . parser . Packet ; import com . corundumstudio . socketio . parser . PacketType ; import com . corundumstudio . socketio . scheduler . CancelableScheduler ; import com . corundumstudio . socketio . scheduler . SchedulerKey ; import com . corundumstudio . socketio . scheduler . SchedulerKey . Type ; @ Sharable public class XHRPollingTransport extends BaseTransport { public static final String NAME = \"xhr-polling\" ; private final Logger log = LoggerFactory . getLogger ( getClass ( ) ) ; private final Map < UUID , XHRPollingClient > sessionId2Client = new ConcurrentHashMap < UUID , XHRPollingClient > ( ) ; private final CancelableScheduler scheduler ; private final AckManager ackManager ; private final AuthorizeHandler authorizeHandler ; private final DisconnectableHub disconnectable ; private final Configuration configuration ; private final String path ; public XHRPollingTransport ( String connectPath , AckManager ackManager , DisconnectableHub disconnectable , CancelableScheduler scheduler , AuthorizeHandler authorizeHandler , Configuration configuration ) { this . path = connectPath + NAME + \"/\" ; this . ackManager = ackManager ; this . authorizeHandler = authorizeHandler ; this . configuration = configuration ; this . disconnectable = disconnectable ; this . scheduler = scheduler ; } public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { Object msg = e . getMessage ( ) ; if ( msg instanceof HttpRequest ) { HttpRequest req = ( HttpRequest ) msg ; QueryStringDecoder queryDecoder = new QueryStringDecoder ( req . getUri ( ) ) ; Channel channel = ctx . getChannel ( ) ; if ( queryDecoder . getPath ( ) . startsWith ( path ) ) { handleMessage ( req , queryDecoder , channel ) ; return ; } } ctx . sendUpstream ( e ) ; } private void handleMessage ( HttpRequest req , QueryStringDecoder queryDecoder , Channel channel ) throws IOException { String [ ] parts = queryDecoder . getPath ( ) . split ( \"/\" ) ; if ( parts . length > 3 ) { UUID sessionId = UUID . fromString ( parts [ 4 ] ) ; String origin = req . getHeader ( HttpHeaders . Names . ORIGIN ) ; if ( HttpMethod . POST . equals ( req . getMethod ( ) ) ) { onPost ( sessionId , channel , origin , req . getContent ( ) ) ; } else if ( HttpMethod . GET . equals ( req . getMethod ( ) ) ) { onGet ( sessionId , channel , origin ) ; } if ( queryDecoder . getParameters ( ) . containsKey ( \"disconnect\" ) ) { BaseClient client = sessionId2Client . get ( sessionId ) ; disconnectable . onDisconnect ( client ) ; } } else { log . warn ( \"Wrong {} method request path: {}, from ip: {}. Channel closed!\" , new Object [ ] { req . getMethod ( ) , path , channel . getRemoteAddress ( ) } ) ; channel . close ( ) ; } } private void scheduleNoop ( Channel channel , final UUID sessionId ) { SchedulerKey key = new SchedulerKey ( Type . POLLING , sessionId ) ; scheduler . cancel ( key ) ; scheduler . schedule ( key , new Runnable ( ) { @ Override public void run ( ) { XHRPollingClient client = sessionId2Client . get ( sessionId ) ; if ( client != null ) { client . send ( new Packet ( PacketType . NOOP ) ) ; } } } , configuration . getPollingDuration ( ) , TimeUnit . SECONDS ) ; } private void scheduleDisconnect ( Channel channel , final UUID sessionId ) { final SchedulerKey key = new SchedulerKey ( Type . CLOSE_TIMEOUT , sessionId ) ; scheduler . cancel ( key ) ; ChannelFuture future = channel . getCloseFuture ( ) ; future . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { scheduler . schedule ( key , new Runnable ( ) { @ Override public void run ( ) { XHRPollingClient client = sessionId2Client . get ( sessionId ) ; if ( client != null ) { disconnectable . onDisconnect ( client ) ; log . debug ( \"Client: {} disconnected due to connection timeout\" , sessionId ) ; } } } , configuration . getCloseTimeout ( ) , TimeUnit . SECONDS ) ; } } ) ; } private void onPost ( UUID sessionId , Channel channel , String origin , ChannelBuffer content ) throws IOException { XHRPollingClient client", "gt": "= sessionId2Client . get ( sessionId ) ;", "prediction": "= sessionId2Client . get ( sessionId ) ;\n", "label": 1}
{"id": 5172, "input": "<s> package fr . telecom . scrapbook . filters ; public class SaturationModifyFilter implements IImageFilter { public float SaturationFactor = 0.5f ; public Image process ( Image imageIn ) { float saturation = this . SaturationFactor + 1f ; float negosaturation = 1f - saturation ; int r , g , b ; for ( int x = 0 ; x < imageIn . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < imageIn . getHeight ( ) ; y ++ ) { r = imageIn . getRComponent ( x , y ) ; g = imageIn . getGComponent ( x , y ) ; b = imageIn . getBComponent ( x , y ) ; float nego1 = negosaturation * 0.2126f ; float ngeo2 = nego1 + saturation ; float ngeo3 = negosaturation * 0.7152f ; float nego4 = ngeo3 + saturation ; float nego5 = negosaturation * 0.0722f ; float nego6 = nego5 + saturation ; float nego7 = ( ( r * ngeo2 ) + ( g * ngeo3 ) ) + ( b * nego5 ) ; float nego8 = ( ( r * nego1 ) + ( g * nego4 ) ) + ( b * nego5 ) ; float nego9 = ( ( r * nego1 ) + ( g * ngeo3 ) ) +", "gt": "( b * nego6 ) ;", "prediction": "( b * nego5 ) ;\n", "label": 0}
{"id": 14973, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"updateContentTypeResult\" } ) @ XmlRootElement ( name = \"UpdateContentTypeResponse\" ) public class UpdateContentTypeResponse { @ XmlElement ( name = \"UpdateContentTypeResult\" ) protected UpdateContentTypeResponse . UpdateContentTypeResult updateContentTypeResult ; public UpdateContentTypeResponse . UpdateContentTypeResult getUpdateContentTypeResult ( ) { return updateContentTypeResult ; } public void setUpdateContentTypeResult ( UpdateContentTypeResponse . UpdateContentTypeResult value ) { this . updateContentTypeResult = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class UpdateContentTypeResult { @ XmlMixed @ XmlAnyElement ( lax = true", "gt": ") protected List < Object > content ;", "prediction": ") protected List < String > content ;\n", "label": 1}
{"id": 8513, "input": "<s> package firstSentence2 ; public class C extends B {", "gt": "public void m ( )", "prediction": "public C ( )\n", "label": 0}
{"id": 14975, "input": "<s> package org . restlet . test . resource ; import java . io . IOException ; import org . restlet . Application ; import org . restlet . Client ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . data . Status ; import org . restlet . engine . Engine ; import org . restlet . resource . ResourceException ; import org . restlet . routing . Router ; import org . restlet . test . RestletTestCase ; public class AnnotatedResource10TestCase extends RestletTestCase { private static class TestApplication extends Application { @ Override public Restlet createInboundRoot ( ) { Router router = new Router ( getContext ( ) ) ; router . attach ( \"/test\" , MyResource10 . class ) ; return router ; } } private Component c ; private Client client ; private String uri ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Engine . getInstance ( ) . getRegisteredConverters ( ) . clear ( ) ; Engine . getInstance ( ) . registerDefaultConverters ( ) ; c = new Component ( ) ; final Server server = c . getServers ( ) . add ( Protocol . HTTP , 0 ) ; c . getDefaultHost ( ) . attach ( new TestApplication ( ) ) ; c . start ( ) ; client = new Client ( Protocol . HTTP ) ; uri = \"http://localhost:\" + server . getEphemeralPort ( ) + \"/test\" ; } @ Override protected void tearDown ( ) throws Exception { c . stop ( ) ; c = null ; client . stop ( ) ; client = null ; super . tearDown ( ) ; } public void test ( ) throws IOException , ResourceException { client = new Client ( Protocol . HTTP ) ; Request request = new Request ( Method . GET , uri ) ; Response response = client . handle ( request ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"asText\" , response . getEntity ( ) . getText ( ) ) ; response . getEntity ( ) . release ( ) ; request = new Request", "gt": "( Method . POST , uri ) ;", "prediction": "( Method . POST , uri ) ;\n", "label": 1}
{"id": 4278, "input": "<s> import java . util . * ; import java . io . * ; import java . text . * ; class Main { void start ( ) throws Exception { System . out . println ( readLine ( 110 ) ) ; int teamsCount = Integer . parseInt ( readLine ( 5 ) ) ; ArrayList teams = new ArrayList ( teamsCount + 1 ) ; Hashtable teamsTable = new Hashtable ( ) ; while ( teamsCount -- != 0 ) { Team t = new Team ( ) ; t . name = readLine ( 100 ) ; teams . add ( t ) ; teamsTable . put ( t . name , t ) ; } int gamesCount = Integer . parseInt ( readLine ( 5 ) ) ; while ( gamesCount -- != 0 ) { String line = readLine ( 100 ) ; int arroba = line . indexOf ( '@' ) ; Team t1 = ( Team ) teamsTable . get ( line . substring ( 0 , line . indexOf ( '#' ) ) ) ; int goals1 = Integer . parseInt ( line . substring ( line . indexOf ( '#' ) + 1 , arroba ) ) ; t1 . goals += goals1 ; line = line . substring ( arroba ) ; Team t2 = ( Team ) teamsTable . get ( line . substring ( line . indexOf ( '#' ) + 1 ) ) ; int goals2 = Integer . parseInt ( line . substring ( 1 , line . indexOf ( '#' ) ) ) ; t2 . goals += goals2 ; t1 . against += goals2 ; t2 . against += goals1 ; t1 . games ++ ; t2 . games ++ ; if ( goals1 > goals2 ) { t1 . won ++ ; t2 . lost ++ ; t1 . points += 3 ; } else if ( goals1 < goals2 ) { t2 . won ++ ; t1 . lost ++ ; t2 . points += 3 ; } else { t1 . draw ++ ; t2 . draw ++ ; t1 . points += 1 ; t2 . points += 1 ; } } TreeSet h = new TreeSet ( new CompareTeams ( ) ) ; h . addAll ( teams ) ; int i = 1 ; for ( Iterator it = h . iterator ( ) ; it . hasNext ( ) ; i ++ ) { Team t = ( Team ) it . next ( ) ; System . out . println ( i + \") \" + t . name + \" \" + t . points + \"p, \" + t . games + \"g (\" + t . won + \"-\" + t . draw + \"-\" + t . lost + \"), \" + ( t . goals - t . against ) + \"gd (\" + t . goals + \"-\" + t . against + \")\" ) ; } } public static void main ( String args [ ] ) throws Exception { try { int caseCount = Integer . parseInt ( readLine ( 5 ) ) ; int i = 0 ; while ( caseCount -- != 0 ) { if ( i ++ != 0", "gt": ") System . out . println ( ) ;", "prediction": ")\n", "label": 0}
{"id": 14976, "input": "<s> package org . nuxeo . ecm . platform . comment . web ; import java . util . List ; import javax . faces . event . ActionEvent ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . actions . Action ; public interface CommentManagerActions { String CHILDREN_COMMENT_LIST = \"CHILDREN_COMMENT_LIST\" ; List < Action > getActionsForComment ( ) ; List < Action > getActionsForComment ( String category ) ; void initialize ( ) throws Exception ; void documentChanged ( ) ; void initComments ( ) throws ClientException ; void initComments ( DocumentModel commentedDoc ) throws ClientException ; List < ThreadEntry > getCommentsAsThread ( ) throws ClientException ; List < ThreadEntry > getCommentsAsThread ( DocumentModel commentedDoc ) throws ClientException ; List < ThreadEntry > getCommentsAsThreadOnDoc ( DocumentModel doc ) throws ClientException ; String beginComment ( ) ; String cancelComment ( ) ; String addComment ( ) throws ClientException ; String createComment ( DocumentModel docToComment ) throws ClientException ; DocumentModel addComment ( DocumentModel comment ) throws ClientException ; String deleteComment ( ) throws ClientException ; String deleteComment ( String commentId ) throws ClientException ; void destroy ( ) ; String getNewContent ( ) ; void setNewContent ( String newContent ) ; String getPrincipalName ( ) ; boolean getPrincipalIsAdmin ( ) ; boolean getCommentStarted ( ) ; String getSavedReplyCommentId ( ) ; void setSavedReplyCommentId ( String savedReplyCommentId ) ; boolean getShowCreateForm ( ) ; void setShowCreateForm", "gt": "( boolean flag ) ;", "prediction": "( boolean showCreateForm ) ;\n", "label": 1}
{"id": 1727, "input": "<s> package org . ofbiz . webapp . view ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . OutputStream ; import java . io . StringWriter ; import java . io . Writer ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . Iterator ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . jpublish . JPublishContext ; import org . jpublish . Page ; import org . jpublish . Repository ; import org . jpublish . RepositoryWrapper ; import org . jpublish . SiteContext ; import org . jpublish . StaticResourceManager ; import org . jpublish . Template ; import org . jpublish . action . ActionManager ; import org . jpublish . component . ComponentMap ; import org . jpublish . page . PageInstance ; import org . jpublish . util . CharacterEncodingMap ; import org . jpublish . util . DateUtilities ; import org . jpublish . util . NumberUtilities ; import org . jpublish . util . URLUtilities ; public class JPublishWrapper { public static final String module = JPublishWrapper . class . getName ( ) ; protected ServletContext servletContext = null ; protected SiteContext siteContext = null ; public JPublishWrapper ( ServletContext context ) { this . servletContext = context ; String rootDir = servletContext . getRealPath ( \"/\" ) ; File contextRoot = new File ( rootDir ) ; File webInfPath = new File ( contextRoot , \"WEB-INF\" ) ; configureClasspath ( webInfPath ) ; try { siteContext = new SiteContext ( contextRoot , \"WEB-INF/jpublish.xml\" ) ; siteContext . setWebInfPath ( webInfPath ) ; } catch ( Exception e ) { Debug . logError ( e , \"Cannot load SiteContext\" , module ) ; } try { ActionManager actionManager = siteContext . getActionManager ( ) ; actionManager . executeStartupActions ( ) ; } catch ( Exception e ) { Debug . logError ( e , \"Problems executing JPublish startup actions\" , module ) ; } servletContext . setAttribute ( \"jpublishWrapper\" , this ) ; } protected void configureClasspath ( File webInfPath ) { File webLibPath = new File ( webInfPath , \"lib\" ) ; File webClassPath = new File ( webInfPath , \"classes\" ) ; StringBuilder classPath = new StringBuilder ( ) ; classPath . append ( System . getProperty ( \"java.class.path\" ) ) ; if ( webClassPath . exists ( ) ) { classPath . append ( System . getProperty ( \"path.separator\" ) ) ; classPath . append ( webClassPath ) ; } if ( webLibPath . exists ( ) ) { File [ ] files = webLibPath . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( files [ i ] . getName ( ) . toLowerCase ( ) . endsWith ( \".jar\" ) || files [ i ] . getName ( ) . toLowerCase ( ) . endsWith ( \".zip\" ) ) { classPath . append ( System . getProperty ( \"path.separator\" ) ) ; classPath . append ( files [ i ] ) ; } } } AccessController . doPrivileged ( new SetClassPathAction ( classPath . toString ( ) ) ) ; } protected boolean executeGlobalActions ( HttpServletRequest request , HttpServletResponse response , JPublishContext context , String path , boolean allowRedirect ) throws Exception { ActionManager actionManager = siteContext . getActionManager ( ) ; return optionalRedirect ( actionManager . executeGlobalActions ( context ) , path , response , allowRedirect ) ; } protected boolean executePathActions ( HttpServletRequest request , HttpServletResponse response , JPublishContext context , String path , boolean allowRedirect ) throws Exception { ActionManager actionManager = siteContext . getActionManager ( ) ; return optionalRedirect ( actionManager . executePathActions ( path , context ) , path , response , allowRedirect ) ; } protected boolean executeParameterActions ( HttpServletRequest request , HttpServletResponse response , JPublishContext context , String path , boolean allowRedirect ) throws Exception { if ( ! siteContext . isParameterActionsEnabled ( ) ) { return false ; } ActionManager actionManager = siteContext . getActionManager ( ) ; String [ ] actionNames = request . getParameterValues ( siteContext . getActionIdentifier ( ) ) ; if ( actionNames != null ) { for ( int i = 0 ;", "gt": "i < actionNames . length ;", "prediction": "i < actionNames . length ;\n", "label": 0}
{"id": 14978, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . textsize . MeasurementItem ; import org . eclipse . rap . rwt . internal . textsize . MeasurementOperator ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeResultStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeEstimation ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorageUtil ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . widgets . Display ; public class TextSizeUtil_Test extends TestCase { private static final String TEST_STRING = \"test\" ; private static final FontData FONT_DATA = new FontData ( \"arial\" , 10 , SWT . NORMAL ) ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; new Display ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testStringExtentAssignsUnknownStringsToTextSizeMeasuring ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getMeasurementItems ( ) . length ) ; assertEquals ( TEST_STRING , getMeasurementItems ( ) [ 0 ] . getTextToMeasure ( ) ) ; assertEquals ( FONT_DATA , getMeasurementItems ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentUsesEstimationForUnknownStrings ( ) { Point determined = TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; Point estimated = TextSizeEstimation . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( estimated , determined ) ; } public void testStringExtentUsesStoreageForKnowStrings ( ) { Point storedSize = new Point ( 100 , 10 ) ; fakeMeasurement ( TEST_STRING , SWT . DEFAULT , TextSizeUtil . STRING_EXTENT , storedSize ) ; Point determinedSize = TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( storedSize , determinedSize ) ; } public void testStringExtentForEmptyString ( ) { Point emptyStringSize = TextSizeUtil . stringExtent ( getFont ( ) , \"\" ) ; assertEquals ( new Point ( 0 , 10 ) , emptyStringSize ) ; } public void testStringExtentMustNotExpandLineBreaks ( ) { Point singleLine = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\" ) ; Point multiLine = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\\nSecond Line\" ) ; assertEquals ( singleLine . y , multiLine . y ) ; } public void testStringExtentConsideresLeadingAndTrailingSpaces ( ) { Point str = TextSizeUtil . stringExtent ( getFont ( ) , \"  First Line    \" ) ; Point trimStr = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\" ) ; assertTrue ( str . x > trimStr . x ) ; } public void testTextExtentExpandLineBreaks ( ) { Point singleLine = TextSizeUtil . textExtent ( getFont ( ) , \"First Line\" , 0 ) ; Point multiLine = TextSizeUtil . textExtent ( getFont ( ) , \"First Line\\nSecond Line\" , 0 ) ; assertTrue ( singleLine . y < multiLine . y ) ; } public void testGetCharHeightAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . getCharHeight ( getFont ( ) ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testGetCharHeightUsesEstimationForUnknownStrings ( ) { int determined = TextSizeUtil . getCharHeight ( getFont ( ) ) ; int estimated = TextSizeEstimation . getCharHeight ( getFont ( ) ) ; assertEquals ( estimated , determined , 0 ) ; } public void testGetCharHeightUsesStorageForUnknownStrings ( ) { int charHeight = 13 ; ProbeResultStore probeResultStore = ProbeResultStore . getInstance ( ) ; probeResultStore . createProbeResult ( new Probe ( FONT_DATA ) , new Point ( 10 , charHeight ) ) ; int determined = TextSizeUtil . getCharHeight ( getFont ( ) ) ; assertEquals ( charHeight , determined ) ; } public void testGetAvgCharWidthAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testGetAvgCharWidthUsesEstimationForUnknownStrings ( ) { float determined = TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; float estimated = TextSizeEstimation . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( estimated , determined , 0 ) ; } public void testGetAvgCharWidthUsesStorageForKnownStrings ( ) { ProbeResultStore probeStore = ProbeResultStore . getInstance ( ) ; Point probeSize = new Point ( Probe . DEFAULT_PROBE_STRING . length ( ) * 4 , 10 ) ; probeStore . createProbeResult ( new Probe ( FONT_DATA ) , probeSize ) ; float determined = TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( 4 , determined , 0 ) ; } public void testHeightAdjustmentInCaseOfWhitespaceText ( ) { fakeMeasurement ( \" \" , SWT . DEFAULT , TextSizeUtil . TEXT_EXTENT , new Point ( 2 , 0 ) ) ; Point size = TextSizeUtil . textExtent ( getFont ( ) , \" \" , 0 ) ; assertEquals ( 10 , size . y ) ; } public void testHeightAdjustmentInCaseOfMultiLineLengthGreaterThanWrapWidth ( ) { String textToMeasure = \"multi\\nline\\ntext\" ; fakeMeasurement ( textToMeasure , 2 , TextSizeUtil . TEXT_EXTENT , new Point ( 6 , 10 ) ) ; Point size = TextSizeUtil . textExtent ( Graphics . getFont ( FONT_DATA ) , textToMeasure , 2 ) ; assertEquals ( 40 , size . y ) ; } private void fakeMeasurement ( String text , int wrapWidth , int mode , Point size ) { ProbeResultStore . getInstance ( ) . createProbeResult ( new Probe ( FONT_DATA ) , new Point ( 10 , 10 ) ) ; RWTFactory . getTextSizeStorage ( ) . storeFont ( FONT_DATA ) ; TextSizeStorageUtil . store ( FONT_DATA ,", "gt": "text , wrapWidth , mode , size ) ;", "prediction": "size ) ;\n", "label": 1}
{"id": 8214, "input": "<s> package domain ; import java . io . Serializable ; import javax . persistence . * ; @ Embeddable public class RegisteredOnPK implements Serializable { private static final long serialVersionUID = 1L ; @ Column ( name = \"student_id\" ) private Integer studentId ; @ Column ( name = \"course_occasion_id\" ) private Integer courseOccasionId ; public RegisteredOnPK ( ) { } public Integer getStudentId ( ) { return this . studentId ; } public void setStudentId ( Integer studentId ) { this . studentId = studentId ; } public Integer getCourseOccasionId ( ) { return this . courseOccasionId ; } public void setCourseOccasionId ( Integer courseOccasionId ) { this . courseOccasionId = courseOccasionId ; } public boolean equals ( Object other ) { if ( this == other ) { return true ; } if ( ! ( other instanceof RegisteredOnPK ) ) { return false ; } RegisteredOnPK castOther = ( RegisteredOnPK ) other ; return this . studentId . equals ( castOther . studentId ) && this . courseOccasionId . equals ( castOther . courseOccasionId ) ; } public int hashCode ( ) { final int prime = 31 ; int hash = 17 ; hash = hash * prime + this . studentId . hashCode ( ) ; hash = hash * prime", "gt": "+ this . courseOccasionId . hashCode ( ) ;", "prediction": "+ courseOccasionId . hashCode ( ) ;\n", "label": 0}
{"id": 14981, "input": "<s> package org . eclipse . ui . internal ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . misc . Policy ; import org . eclipse . ui . internal . util . BundleUtility ; public class WorkbenchImages { private static final String DESCRIPTORS = WorkbenchImages . class . getName ( ) + \"#descriptors\" ; private static final String IMAGE_REGISTRY = WorkbenchImages . class . getName ( ) + \"#imageRegistry\" ; public final static String ICONS_PATH = \"$nl$/icons/full/\" ; private final static String PATH_ETOOL = ICONS_PATH + \"etool16/\" ; private final static String PATH_DTOOL = ICONS_PATH + \"dtool16/\" ; private final static String PATH_ELOCALTOOL = ICONS_PATH + \"elcl16/\" ; private final static String PATH_DLOCALTOOL = ICONS_PATH + \"dlcl16/\" ; private final static String PATH_EVIEW = ICONS_PATH + \"eview16/\" ; private final static String PATH_OVERLAY = ICONS_PATH + \"ovr16/\" ; private final static String PATH_OBJECT = ICONS_PATH + \"obj16/\" ; private final static String PATH_POINTER = ICONS_PATH + \"pointer/\" ; private final static String PATH_WIZBAN = ICONS_PATH + \"wizban/\" ; private final static void declareImage ( String key , String path , boolean shared ) { URL url = BundleUtility . find ( PlatformUI . PLUGIN_ID , path ) ; ImageDescriptor desc = ImageDescriptor . createFromURL ( url ) ; declareImage ( key , desc , shared ) ; } private final static void declareImages ( ) { declareImage ( ISharedImages . IMG_DEC_FIELD_ERROR , PATH_OVERLAY + \"error_ovr.gif\" , true ) ; declareImage ( ISharedImages . IMG_DEC_FIELD_WARNING , PATH_OVERLAY + \"warning_ovr.gif\" , true ) ; declareImage ( IWorkbenchGraphicConstants . IMG_ETOOL_PIN_EDITOR , PATH_ETOOL + \"pin_editor.gif\" , false ) ; declareImage ( IWorkbenchGraphicConstants . IMG_ETOOL_PIN_EDITOR_DISABLED , PATH_DTOOL + \"pin_editor.gif\" , false ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVE_EDIT , PATH_ETOOL + \"save_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVE_EDIT_DISABLED , PATH_DTOOL + \"save_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVEAS_EDIT , PATH_ETOOL + \"saveas_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVEAS_EDIT_DISABLED , PATH_DTOOL + \"saveas_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVEALL_EDIT , PATH_ETOOL + \"saveall_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_SAVEALL_EDIT_DISABLED , PATH_DTOOL + \"saveall_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_UNDO , PATH_ETOOL + \"undo_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_UNDO_DISABLED , PATH_DTOOL + \"undo_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_REDO , PATH_ETOOL + \"redo_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_REDO_DISABLED , PATH_DTOOL + \"redo_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_CUT , PATH_ETOOL + \"cut_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_CUT_DISABLED , PATH_DTOOL + \"cut_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_COPY , PATH_ETOOL + \"copy_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_COPY_DISABLED , PATH_DTOOL + \"copy_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_PASTE , PATH_ETOOL + \"paste_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_PASTE_DISABLED , PATH_DTOOL + \"paste_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_DELETE , PATH_ETOOL + \"delete_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_DELETE_DISABLED , PATH_DTOOL + \"delete_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_DELETE , PATH_ETOOL + \"delete.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_DELETE_DISABLED , PATH_DTOOL + \"delete.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_CLEAR , PATH_ETOOL + \"clear.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_CLEAR_DISABLED , PATH_DTOOL + \"clear.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_NEW_WIZARD , PATH_ETOOL + \"new_wiz.gif\" , true ) ; declareImage ( ISharedImages . IMG_TOOL_NEW_WIZARD_DISABLED , PATH_DTOOL + \"new_wiz.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_PRINT_EDIT , PATH_ETOOL + \"print_edit.gif\" , true ) ; declareImage ( ISharedImages . IMG_ETOOL_PRINT_EDIT_DISABLED , PATH_DTOOL + \"print_edit.gif\" , true ) ; declareImage ( IWorkbenchGraphicConstants . IMG_ETOOL_HELP_CONTENTS , PATH_ETOOL + \"help_contents.gif\" , true ) ; declareImage ( IWorkbenchGraphicConstants . IMG_ETOOL_HELP_SEARCH , PATH_ETOOL + \"help_search.gif\" , true ) ; declareImage ( IWorkbenchGraphicConstants . IMG_ETOOL_NEW_FASTVIEW , PATH_ETOOL + \"new_fastview.gif\" , true ) ; declareImage ( IWorkbenchGraphicConstants .", "gt": "IMG_DTOOL_NEW_FASTVIEW , PATH_DTOOL + \"new_fastview.gif\" , true ) ;", "prediction": "IMG_ETOOL_NEW_FASTVIEW_DISABLED , PATH_DTOOL + \"new_fastview.gif\" , true ) ;\n", "label": 1}
{"id": 2205, "input": "<s> package org . ofbiz . entity . jdbc ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . Reader ; import java . math . BigDecimal ; import java . nio . ByteBuffer ; import java . sql . Blob ; import java . sql . Clob ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import javax . sql . rowset . serial . SerialBlob ; import javax . sql . rowset . serial . SerialClob ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericDataSourceException ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericModelException ; import org . ofbiz . entity . GenericNotImplementedException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionParam ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . condition . OrderByList ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . jdbc . JdbcValueHandler ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . model . ModelFieldType ; import org . ofbiz . entity . model . ModelFieldTypeReader ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . model . ModelViewEntity ; public class SqlJdbcUtil { public static final String module = SqlJdbcUtil . class . getName ( ) ; public static final int CHAR_BUFFER_SIZE = 4096 ; public static String makeFromClause ( ModelEntity modelEntity , ModelFieldTypeReader modelFieldTypeReader , DatasourceInfo datasourceInfo ) throws GenericEntityException { StringBuilder sql = new StringBuilder ( \" FROM \" ) ; if ( modelEntity instanceof ModelViewEntity ) { ModelViewEntity modelViewEntity = ( ModelViewEntity ) modelEntity ; if ( \"ansi\" . equals ( datasourceInfo . joinStyle ) || \"ansi-no-parenthesis\" . equals ( datasourceInfo . joinStyle ) ) { boolean useParenthesis = true ; if ( \"ansi-no-parenthesis\" . equals ( datasourceInfo . joinStyle ) ) { useParenthesis = false ; } Set < String > joinedAliasSet = new TreeSet < String > ( ) ; StringBuilder openParens = null ; if ( useParenthesis ) openParens = new StringBuilder ( ) ; StringBuilder restOfStatement = new StringBuilder ( ) ; for ( int i = 0 ; i < modelViewEntity . getViewLinksSize ( ) ; i ++ ) { if ( i > 0 && useParenthesis ) openParens . append ( '(' ) ; ModelViewEntity . ModelViewLink viewLink = modelViewEntity . getViewLink ( i ) ; ModelEntity linkEntity = modelViewEntity . getMemberModelEntity ( viewLink . getEntityAlias ( ) ) ; ModelEntity relLinkEntity = modelViewEntity . getMemberModelEntity ( viewLink . getRelEntityAlias ( ) ) ; if ( i == 0 ) { restOfStatement . append ( makeViewTable ( linkEntity , modelFieldTypeReader , datasourceInfo ) ) ; restOfStatement . append ( \" \" ) ; restOfStatement . append ( viewLink . getEntityAlias ( ) ) ; joinedAliasSet . add ( viewLink . getEntityAlias ( ) ) ; } else { if ( ! joinedAliasSet . contains ( viewLink . getEntityAlias ( ) ) ) { throw new GenericModelException ( \"Tried to link the \" + viewLink . getEntityAlias ( ) + \" alias to the \" + viewLink . getRelEntityAlias ( ) + \" alias of the \" + modelViewEntity . getEntityName ( ) + \" view-entity, but it is not the first view-link and has not been included in a previous view-link. In other words, the left/main alias isn't connected to the rest of the member-entities yet.\" ) ; } } joinedAliasSet . add ( viewLink . getRelEntityAlias ( ) ) ; if ( viewLink . isRelOptional ( ) ) { restOfStatement . append ( \" LEFT OUTER JOIN \" ) ; } else { restOfStatement . append ( \" INNER JOIN \" ) ; } restOfStatement . append ( makeViewTable ( relLinkEntity , modelFieldTypeReader , datasourceInfo ) ) ; restOfStatement . append ( \" \" ) ; restOfStatement . append ( viewLink . getRelEntityAlias ( ) ) ; restOfStatement . append ( \" ON \" ) ; StringBuilder condBuffer = new StringBuilder ( ) ; for ( int j = 0 ; j < viewLink . getKeyMapsSize ( ) ; j ++ ) { ModelKeyMap keyMap = viewLink . getKeyMap ( j ) ; ModelField linkField = linkEntity . getField ( keyMap . getFieldName ( ) ) ; if ( linkField == null ) { throw new GenericModelException ( \"Invalid field name in view-link key-map for the \" + viewLink . getEntityAlias ( ) + \" and the \" + viewLink . getRelEntityAlias ( ) + \" member-entities of the \" + modelViewEntity . getEntityName ( ) + \" view-entity; the field [\" + keyMap . getFieldName ( ) + \"] does not exist on the [\" + linkEntity . getEntityName ( ) + \"] entity.\" ) ; } ModelField relLinkField = relLinkEntity . getField (", "gt": "keyMap . getRelFieldName ( ) ) ;", "prediction": "keyMap . getFieldName ( ) ) ;\n", "label": 0}
{"id": 14982, "input": "<s> package br . org . archimedes . text . edittext ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.text.edittext.messages\" ; public static String Factory_Cancel ; public static String Factory_Edited ; public static String Factory_InvalidSelection ; public static String TextEditor_CancelButton ; public static String TextEditor_OkButton ;", "gt": "public static String TextEditor_WindowName ;", "prediction": "public static String TextEditor_ConfirmButton ;\n", "label": 1}
{"id": 3298, "input": "<s> package org . remast . baralga . gui . panels . table ; import java . beans . PropertyChangeEvent ; import java . text . ParseException ; import java . util . Date ; import org . joda . time . DateTime ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . BaralgaMain ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . model . Project ; import org . remast . baralga . model . ProjectActivity ; import org . remast . text . SmartTimeFormat ; import org . remast . util . TextResourceBundle ; import ca . odell . glazedlists . gui . WritableTableFormat ; public class AllActivitiesTableFormat implements WritableTableFormat < ProjectActivity > { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaMain . class ) ; private PresentationModel model ; public AllActivitiesTableFormat ( final PresentationModel model ) { this . model = model ; } public int getColumnCount ( ) { return 5 ; } public String getColumnName ( final int column ) { switch ( column ) { case 0 : return textBundle . textFor ( \"AllActivitiesTableFormat.ProjectHeading\" ) ; case 1 : return textBundle . textFor ( \"AllActivitiesTableFormat.DateHeading\" ) ; case 2 : return textBundle . textFor ( \"AllActivitiesTableFormat.StartHeading\" ) ; case 3 : return textBundle . textFor ( \"AllActivitiesTableFormat.EndHeading\" ) ; case 4 : return textBundle . textFor ( \"AllActivitiesTableFormat.DurationHeading\" ) ; default : return \"\" ; } } public Object getColumnValue ( final ProjectActivity activity , final int column ) { switch ( column ) { case 0 : return activity . getProject ( ) ; case 1 : return activity . getStart ( ) . toDate ( ) ; case 2 : return FormatUtils . formatTime ( activity . getStart ( ) ) ; case 3 : return FormatUtils . formatTime ( activity . getEnd ( ) ) ; case 4 : return ( Double ) activity . getDuration ( ) ; default : return \"\" ; } } public boolean isEditable ( final ProjectActivity baseObject , final int column ) { return column != 4 ; } public ProjectActivity setColumnValue ( final ProjectActivity activity , final Object editedValue , final int column ) { if ( column == 0 ) { if ( editedValue == null ) { return activity ; } final Project oldProject = activity . getProject ( ) ; activity . setProject ( ( Project ) editedValue ) ; final PropertyChangeEvent propertyChangeEvent = new PropertyChangeEvent ( activity , ProjectActivity . PROPERTY_PROJECT , oldProject , editedValue ) ; model . fireProjectActivityChangedEvent ( activity , propertyChangeEvent ) ; } else if ( column == 1 ) { final Date oldDate = activity . getEnd ( ) . toDate ( ) ; Date newDate = ( Date ) editedValue ; activity . setDay ( new DateTime ( newDate ) ) ; final PropertyChangeEvent propertyChangeEvent = new PropertyChangeEvent ( activity , ProjectActivity . PROPERTY_DATE , oldDate , newDate ) ; model . fireProjectActivityChangedEvent ( activity , propertyChangeEvent ) ; } else if ( column == 2 ) { try { final Date oldStart = activity . getStart ( ) . toDate ( ) ; int [ ] hoursMinutes = SmartTimeFormat . parseToHourAndMinutes ( ( String ) editedValue ) ; activity . setStartTime ( hoursMinutes [ 0 ] , hoursMinutes [ 1 ] ) ; final PropertyChangeEvent propertyChangeEvent = new PropertyChangeEvent ( activity , ProjectActivity . PROPERTY_START , oldStart , activity . getStart ( ) . toDate ( ) ) ; model . fireProjectActivityChangedEvent ( activity , propertyChangeEvent ) ; } catch ( IllegalArgumentException e ) { } catch ( ParseException e ) { } } else if ( column == 3 ) { try { final Date oldEnd = activity . getEnd", "gt": "( ) . toDate ( ) ;", "prediction": "( ) . toDate ( ) ;\n", "label": 0}
{"id": 14984, "input": "<s> package org . apache . lucene . queryParser . standard . config ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . standard . processors . ParametricRangeQueryNodeProcessor ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . MultiTermQuery . RewriteMethod ; import org . apache . lucene . util . AttributeImpl ; public class MultiTermRewriteMethodAttributeImpl extends AttributeImpl implements MultiTermRewriteMethodAttribute { private static final long serialVersionUID = - 2104763012723049527L ; private MultiTermQuery . RewriteMethod multiTermRewriteMethod = MultiTermQuery . CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ; public MultiTermRewriteMethodAttributeImpl ( ) { } public void setMultiTermRewriteMethod ( MultiTermQuery . RewriteMethod method ) { multiTermRewriteMethod = method ; } public MultiTermQuery . RewriteMethod getMultiTermRewriteMethod ( ) { return multiTermRewriteMethod ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; }", "gt": "public void copyTo ( AttributeImpl target )", "prediction": "}\n", "label": 1}
{"id": 8312, "input": "<s> package org . dawb . workbench . plotting . system . swtxy ; import java . util . ArrayList ; import java . util . List ; import org . csstudio . swt . xygraph . undo . XYGraphMemento ; public class XYRegionMemento extends XYGraphMemento { private List < RegionBean > regionBeanList ; public XYRegionMemento ( ) { super ( ) ; this . regionBeanList =", "gt": "new ArrayList < RegionBean > ( ) ;", "prediction": "new ArrayList < RegionBean > ( ) ;\n", "label": 0}
{"id": 14985, "input": "<s> package org . nuxeo . ecm . automation . core . operations . document ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . collectors . DocumentModelCollector ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; @ Operation ( id = DeleteDocument . ID , category = Constants . CAT_DOCUMENT , label = \"Delete\" , description = \"Delete the input document. The previous context input will be restored for the next operation.\" ) public class DeleteDocument { public static final String ID = \"Document.Delete\" ; @ Context protected CoreSession session ; @ OperationMethod ( collector = DocumentModelCollector . class ) public DocumentModel run ( DocumentRef doc ) throws Exception { session", "gt": ". removeDocument ( doc ) ;", "prediction": ". save ( doc ) ;\n", "label": 1}
{"id": 5289, "input": "<s> package org . ofbiz . datafile ; import java . util . ArrayList ; import java . util . List ; public class ModelRecord { public static final String LIMIT_ONE = \"one\" ; public static final String LIMIT_MANY = \"many\" ; public String name = \"\" ; public String typeCode = \"\" ; public String tcMin = \"\" ; public long tcMinNum = - 1 ; public String tcMax = \"\" ; public long tcMaxNum = - 1 ; public boolean tcIsNum = true ; public int tcPosition = - 1 ; public int tcLength = - 1 ; public String description = \"\" ; public String parentName = \"\" ; public String limit = \"\" ; public ModelRecord parentRecord = null ; public List < ModelRecord > childRecords = new ArrayList < ModelRecord > ( ) ; public List < ModelField > fields = new ArrayList < ModelField > ( ) ; ModelField getModelField ( String fieldName ) { for ( ModelField curField : fields ) { if ( curField . name . equals ( fieldName ) ) { return curField ; } } return null ; }", "gt": "public String getName ( )", "prediction": "public ModelField getModelField ( String fieldName )\n", "label": 0}
{"id": 14988, "input": "<s> package org . fuzzydb . postcode ; import org . fuzzydb . core . Settings ; import org . fuzzydb . postcode . PostcodeConvertor ; import org . fuzzydb . util . geo . GeoInformation ; import org . junit . Before ; import org . junit . Test ; import junit . framework . Assert ; public class PostcodeConverterTest { private PostcodeConvertor convertor ; @ Before public void setUp ( ) throws Exception { Settings . getInstance ( ) . setPostcodeRoot ( \"data\" ) ; convertor = new PostcodeConvertor ( ) ; } @ Test public void testJibbleSimple ( ) { GeoInformation r = convertor . lookupShort ( \"CB23\" ) ; assertCB23 ( r ) ; } @ Test public void testJibbleSimpleSpaced ( ) { GeoInformation r = convertor . lookupShort ( \"CB 23\" ) ; assertCB23 ( r ) ; } private void assertCB23 ( GeoInformation r ) { Assert . assertNotNull ( r ) ; Assert . assertTrue ( r . getLatitude ( ) < 52.35 ) ; Assert . assertTrue ( r . getLatitude ( ) > 52.2 ) ; Assert . assertTrue ( r . getLongitude ( ) < 0.2 ) ; Assert . assertTrue ( r . getLatitude ( ) > - 0.2 ) ; } @ Test public void testJibbleSimpleCased ( ) { GeoInformation r = convertor . lookupShort ( \"cb23\" ) ; assertCB23 ( r ) ; } @ Test public void testJibbleSimpleCasedSpaced ( ) { GeoInformation r = convertor . lookupShort ( \" c B 23 \" ) ; assertCB23 ( r ) ; } @ Test public void testJibbleInvalid ( ) { GeoInformation r = convertor . lookupShort ( \"FOOBAR\" ) ; Assert . assertNull ( r ) ; } @ Test", "gt": "public void testJibbleEmpty ( )", "prediction": "public void testJibbleInvalid ( )\n", "label": 1}
{"id": 56, "input": "<s> import java . util . Set ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; public class TypesBadArg extends JavacTestingAbstractProcessor { boolean success = true ; public boolean process ( Set < ? extends TypeElement > tes , RoundEnvironment round ) { if ( round . processingOver ( ) ) return true ; final Elements elements = processingEnv . getElementUtils ( ) ; final Types types = processingEnv . getTypeUtils ( ) ; final TypeMirror javaLang = elements . getPackageElement ( \"java.lang\" ) . asType ( ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . isSubtype ( javaLang , javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . isAssignable ( javaLang , javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . contains ( javaLang , javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . directSupertypes ( javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . erasure ( javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . capture ( javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . unboxedType ( javaLang ) ; } } ) ; makeBadCall ( new Runnable ( ) { public void run ( ) { types . unboxedType ( types . getNoType ( TypeKind . VOID ) ) ; } } ) ; if ( ! success ) throw new AssertionError ( \"Some test(s) failed.\" ) ; return true ; }", "gt": "private void makeBadCall ( Runnable runnable )", "prediction": "}\n", "label": 0}
{"id": 14990, "input": "<s> package org . nuxeo . ecm . platform . audit . ws ; import java . io . Serializable ; public class EventDescriptorPage implements Serializable { private static final long serialVersionUID = 876567561L ; private int pageIndex ; private boolean bHasMorePage ; private EventDescriptor [ ] events ; public EventDescriptorPage ( ) { this ( null , 0 , false ) ; } public EventDescriptorPage ( EventDescriptor [ ] events , int pageIndex , boolean bHasMorePage ) { this . pageIndex = pageIndex ; this . bHasMorePage = bHasMorePage ; this . events = events ; } public int getPageIndex ( ) { return pageIndex ; } public boolean hasModePage ( ) { return bHasMorePage ; } public EventDescriptor [ ] getEvents ( ) { return events ; } public boolean getHasMorePage ( ) { return bHasMorePage ; } public void", "gt": "setPageIndex ( int pageIndex )", "prediction": "setPageIndex ( int pageIndex )\n", "label": 1}
{"id": 485, "input": "<s> class StringConstRequired { String s = \"three\" ; int m ( String arg ) { switch ( arg ) { case", "gt": "\"one\" : return 1 ;", "prediction": "\"a\" : s = \"a\" ;\n", "label": 0}
{"id": 14995, "input": "<s> package org . nuxeo . ecm . platform . annotations ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . annotations . api . Annotation ; import org . nuxeo . ecm . platform . annotations . api . AnnotationException ; import org . nuxeo . ecm . platform . annotations . api . AnnotationManager ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; import org . nuxeo . ecm . platform . annotations . service . DefaultUriResolver ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . runtime . test . NXRuntimeTestCase ; public class AnnotationManagerTest extends NXRuntimeTestCase { private final AnnotationManager manager = new AnnotationManager ( ) ; @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.relations\" ) ; deployBundle ( \"org.nuxeo.ecm.relations.jena\" ) ; } @ Test public void testGetPostNewAnnotation ( ) throws AnnotationException { assertNotNull ( manager ) ; InputStream is = getClass ( ) . getResourceAsStream ( \"/post-rdf.xml\" ) ; assertNotNull ( is ) ; Annotation annotation = manager . getAnnotation ( is ) ; assertNotNull ( annotation ) ; assertEquals ( \"http://www.w3.org/2005/Incubator/\" , annotation . getAnnotates ( ) . toString ( ) ) ; annotation . setSubject ( new ResourceImpl ( \"http://foo/1\" ) ) ; assertEquals ( \"http://www.w3.org/2005/Incubator/\" , annotation . getAnnotates ( ) . toString ( ) ) ; } @ Test public void testReadAnnoteaSpecPost ( ) throws AnnotationException { assertNotNull ( manager ) ; InputStream is = getClass ( ) . getResourceAsStream ( \"/annotea-spec-post.xml\" ) ; assertNotNull ( is ) ; Annotation annotation = manager . getAnnotation ( is ) ; assertNotNull ( annotation ) ; } @ Test public void testGetCreatedAnnotation ( ) throws AnnotationException { InputStream is", "gt": "= getClass ( ) . getResourceAsStream ( \"/repo-rdf.xml\" ) ;", "prediction": "= getClass ( ) . getResourceAsStream ( \"/created-rdf.xml\" ) ;\n", "label": 1}
{"id": 3515, "input": "<s> package ar . com . fdvs . dj . core . layout ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . engine . design . JRDesignBand ; import net . sf . jasperreports . engine . design . JRDesignTextField ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; public class ListLayoutManager extends AbstractLayoutManager { private static final Log log = LogFactory . getLog ( ListLayoutManager . class ) ; protected Map referencesMap = new HashMap ( ) ; public Map getReferencesMap ( ) { return referencesMap ; } protected void startLayout ( ) { getReport ( ) . getOptions ( ) . setColumnsPerPage ( new Integer ( 1 ) ) ; getReport ( ) . getOptions ( ) . setColumnSpace ( new Integer ( 0 ) ) ; getDesign ( ) . setColumnCount ( 1 ) ; getDesign ( ) . setColumnWidth ( getReport ( ) . getOptions ( ) . getColumnWidth ( ) ) ; super . startLayout ( ) ; if ( getReport ( ) . getOptions ( ) . isPrintColumnNames ( ) ) { generateHeaderBand ( ) ; } getDesign ( ) . setIgnorePagination ( getReport ( ) . getOptions ( ) . isIgnorePagination ( ) ) ; } protected void transformDetailBandTextField ( AbstractColumn column , JRDesignTextField textField ) { log . debug (", "gt": "\"transforming detail band text field...\" ) ;", "prediction": "\"Transforming detail band text field\" ) ;\n", "label": 0}
{"id": 14998, "input": "<s> package org . restlet . representation ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . util . Date ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Disposition ; import org . restlet . data . MediaType ; import org . restlet . data . Range ; import org . restlet . data . Tag ; import org . restlet . engine . io . BioUtils ; import org . restlet . engine . util . DateUtils ; public abstract class Representation extends RepresentationInfo { public static final long UNKNOWN_SIZE = - 1L ; private volatile boolean available ; private volatile org . restlet . data . Digest digest ; private volatile Disposition disposition ; private volatile Date expirationDate ; private volatile boolean isTransient ; private volatile Range range ; private volatile long size ; public Representation ( ) { this ( null ) ; } public Representation ( MediaType mediaType ) { super ( mediaType ) ; this . available = true ; this . disposition = null ; this . isTransient = false ; this . size = UNKNOWN_SIZE ; this . expirationDate = null ; this . digest = null ; this . range = null ; } public Representation ( MediaType mediaType , Date modificationDate ) { this ( mediaType , modificationDate , null ) ; } public Representation ( MediaType mediaType , Date modificationDate , Tag tag ) { super ( mediaType , modificationDate , tag ) ; } public Representation ( MediaType mediaType , Tag tag ) { this ( mediaType , null , tag ) ; } public Representation ( Variant variant , Date modificationDate ) { this ( variant , modificationDate , null ) ; } public Representation ( Variant variant , Date modificationDate , Tag tag ) { setCharacterSet ( variant . getCharacterSet ( ) ) ; setEncodings ( variant . getEncodings ( ) ) ; setLocationRef ( variant . getLocationRef ( ) ) ; setLanguages ( variant . getLanguages ( ) ) ; setMediaType ( variant . getMediaType ( ) ) ; setModificationDate ( modificationDate ) ; setTag ( tag ) ; } public Representation ( Variant variant , Tag tag ) { this ( variant , null , tag ) ; } public void append ( Appendable appendable ) throws IOException { appendable . append ( getText ( ) ) ; } public long exhaust ( ) throws IOException { long result = - 1L ; if ( isAvailable ( ) ) { InputStream is = getStream ( ) ; result = BioUtils . exhaust ( is ) ; is . close ( ) ; } return result ; } public long getAvailableSize ( ) { return BioUtils . getAvailableSize ( this ) ; } public abstract java . nio . channels . ReadableByteChannel getChannel ( ) throws IOException ; public org . restlet . data . Digest getDigest ( ) { return this . digest ; } public Disposition getDisposition ( ) { return disposition ; } public Date getExpirationDate ( ) { return this . expirationDate ; } public Range getRange ( ) { return this . range ; } public abstract Reader getReader ( ) throws IOException ; public org . restlet . util . SelectionRegistration getRegistration ( ) throws IOException { if", "gt": "( isSelectable ( ) )", "prediction": "( disposition == null )\n", "label": 1}
{"id": 7929, "input": "<s> import java . io . * ; import java . nio . * ; import java . util . * ; import java . util . jar . * ; import javax . tools . * ; import javax . tools . StandardJavaFileManager . * ; public class T6400872 { static File testSrc = new File ( System . getProperty ( \"test.src\" , \".\" ) ) ; static File testClasses = new File ( System . getProperty ( \"test.classes\" , \".\" ) ) ; public static void main ( String ... args ) throws Exception { compile ( testClasses , null , new File ( testSrc , \"A.java\" ) , new File ( testSrc , \"B.java\" ) ) ; jar ( new File ( \"A.jar\" ) , iterable ( new File ( \".\" , \"B.jar\" ) ) , testClasses , new File ( \"A.class\" ) ) ; jar ( new File ( \"B.jar\" ) , iterable ( new File ( \".\" , \"A.jar\" ) ) , testClasses , new File ( \"B.class\" ) ) ; compile ( new File ( \".\" ) , iterable ( new File ( \"A.jar\" ) ) , new File ( testSrc , \"C.java\" ) ) ; } static void compile ( File classOutDir , Iterable < File > classPath , File ... files ) throws IOException { System . err . println ( \"compile...\" ) ; JavaCompiler compiler = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = compiler . getStandardFileManager ( null , null , null ) ; try { Iterable < ? extends JavaFileObject > fileObjects = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( files ) ) ; List < String > options = new ArrayList < String > ( ) ; if ( classOutDir != null ) { options . add ( \"-d\" ) ; options . add ( classOutDir . getPath ( ) ) ; } if ( classPath != null ) { options . add ( \"-classpath\" ) ; options . add ( join ( classPath , File . pathSeparator ) ) ; } options . add ( \"-verbose\" ) ; JavaCompiler . CompilationTask task = compiler . getTask ( null , fm , null , options , null , fileObjects ) ; if ( ! task . call ( ) ) throw new AssertionError ( \"compilation failed\" ) ; } finally { fm . close ( ) ; } } static void jar ( File jar , Iterable < File > classPath , File base , File ... files ) throws IOException { System . err . println ( \"jar...\" ) ; Manifest m = new Manifest ( ) ; if ( classPath != null ) { Attributes mainAttrs = m . getMainAttributes ( ) ; mainAttrs . put ( Attributes . Name . MANIFEST_VERSION , \"1.0\" ) ; mainAttrs . put ( Attributes . Name . CLASS_PATH , join ( classPath , \" \" ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( jar ) ) ; JarOutputStream j = new JarOutputStream ( out , m ) ; add ( j , base , files ) ; j . close ( ) ; } static void add ( JarOutputStream j , File base , File ... files ) throws IOException { if ( files == null ) return ; for ( File f : files ) add ( j , base , f ) ; } static void add ( JarOutputStream j , File base , File file ) throws IOException { File f = new File ( base , file . getPath ( ) ) ; if ( f . isDirectory ( ) ) { String [ ] children = f . list ( ) ; if ( children != null ) for ( String c : children ) add ( j , base , new File ( file , c ) ) ; } else { JarEntry e = new JarEntry ( file . getPath ( ) ) ; e . setSize ( f . length ( ) ) ; j . putNextEntry ( e ) ; j . write ( read ( f ) ) ; j . closeEntry ( ) ; } } static byte [ ] read ( File f ) throws IOException { byte [ ] buf = new byte [ ( int ) f . length ( ) ] ; BufferedInputStream in = new BufferedInputStream ( new FileInputStream ( f ) ) ; int offset = 0 ; while ( offset < buf . length ) { int n = in . read ( buf , offset , buf . length - offset ) ; if ( n < 0 ) throw new EOFException ( ) ; offset += n ; } return buf ; } static < T > Iterable < T > iterable ( T single ) { return Collections . singleton ( single ) ; } static < T > String join ( Iterable < T > iter , String sep ) { StringBuilder p = new StringBuilder ( ) ; for ( T t : iter ) { if ( p . length ( ) > 0 ) p . append ( ' ' ) ;", "gt": "p . append ( t ) ;", "prediction": "p . append ( t . toString ( ) ) ;\n", "label": 0}
{"id": 14999, "input": "<s> package org . gatein . common . http ; import java . io . Serializable ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; @ SuppressWarnings ( \"serial\" ) public class HttpRequest implements Serializable { public abstract static class Body implements Serializable { } public static class Raw extends Body { private byte [ ] bytes ; public byte [ ] getBytes ( ) { return bytes ; } public void setBytes ( byte [ ] bytes ) { this . bytes = bytes ; } } public static class Form extends Body { private Map < String , String [ ] > parameters = new HashMap < String , String [ ] > ( ) ; public void addParameter ( String name , String [ ] values ) { if ( name == null ) { throw new IllegalStateException ( ) ; } if ( values == null ) { throw new IllegalStateException ( ) ; } for ( int i = 0 ; i < values . length ; i ++ ) { String value = values [ i ] ; if ( value == null ) { throw new IllegalStateException ( ) ; } } parameters . put ( name , values . clone ( ) ) ; } public void removeParameter ( String name ) { if ( name == null ) { throw new IllegalStateException ( ) ; } parameters . remove ( name ) ; }", "gt": "public Set < String > getParameterNames ( )", "prediction": "}\n", "label": 1}
{"id": 9780, "input": "<s> class Box < T > { } interface N1 { < T > Box < T > box ( T t ) ; } interface N2 { < T > Box < T > box ( T t ) ; } abstract class", "gt": "GenericMerge implements N1 , N2", "prediction": "Box < T >\n", "label": 0}
{"id": 15004, "input": "<s> package com . talis . hbase . rdf . test ; import junit . framework . TestSuite ; import org . junit . runners . AllTests ; import org . junit . runner . RunWith ; import com . talis . hbase . rdf . test . graph . TestHBaseRdfGraph ; import com . talis . hbase . rdf . test . graph . TestHBaseRdfReifier ; import com . talis . hbase . rdf . test . model . TestHBaseRdfModel ; @ RunWith ( AllTests . class ) public class HBaseRdfModelGraphTestSuite extends TestSuite { static boolean includeSimple = true ; static boolean includeVertPart = true ; static boolean includeIndexed = true ; static boolean includeVPIndexed = true ; static boolean includeHybrid = true ; static boolean includeHash = true ; public static junit . framework . Test suite ( ) { TestSuite ts = new TestSuite ( ) ; if ( includeSimple ) { ts . addTestSuite ( TestHBaseRdfModel . TestHBaseRdfSimpleModel . class ) ; ts . addTestSuite ( TestHBaseRdfGraph . TestHBaseRdfSimpleGraph . class ) ; ts . addTestSuite ( TestHBaseRdfReifier . TestHBaseRdfSimpleReifier . class ) ; } if ( includeVertPart ) { ts . addTestSuite ( TestHBaseRdfModel . TestHBaseRdfVertPartModel . class ) ; ts .", "gt": "addTestSuite ( TestHBaseRdfGraph . TestHBaseRdfVertPartGraph . class ) ;", "prediction": "addTestSuite ( TestHBaseRdfGraph . TestHBaseRdfVertPartGraph . class ) ;\n", "label": 1}
{"id": 2702, "input": "<s> interface Base { void m ( Object ... x ) ; } interface VarargsClash extends Base { void m ( Object", "gt": "[ ] x ) ;", "prediction": "... x ) ;\n", "label": 0}
{"id": 15006, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import javax . servlet . http . HttpSession ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . ServiceContext ; import org . eclipse . rap . rwt . internal . service . SessionStoreImpl ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . rap . rwt . testfixture . * ; public class ContextProvider_Test extends TestCase { public void testThreadLocalFunctionalityWithCurrentThread ( ) { assertFalse ( ContextProvider . hasContext ( ) ) ; TestResponse response = new TestResponse ( ) ; TestRequest request = new TestRequest ( ) ; ServiceContext serviceContext = new ServiceContext ( request , response ) ; ContextProvider . setContext ( serviceContext ) ; assertTrue ( ContextProvider . hasContext ( ) ) ; ContextProvider . disposeContext ( ) ; assertFalse ( ContextProvider . hasContext ( ) ) ; } public void testThreadLocalFunctionalityWithAnyThread ( ) throws Exception { TestResponse response = new TestResponse ( ) ; TestRequest request = new TestRequest ( ) ; ServiceContext serviceContext = new ServiceContext ( request , response ) ; final boolean [ ] hasContext = new boolean [ 1 ] ; Thread thread1 = new Thread ( ) { public void run ( ) { hasContext [ 0 ] = ContextProvider . hasContext ( ) ; } } ; ContextProvider . setContext ( serviceContext , thread1 ) ; thread1 . start ( ) ; thread1 . join ( ) ; assertTrue ( hasContext [ 0 ] ) ; assertFalse ( ContextProvider . hasContext ( ) ) ; hasContext [ 0 ] = false ; Thread thread2 = new Thread ( ) { public void run ( ) { hasContext [ 0 ] = ContextProvider . hasContext ( ) ; } } ; ContextProvider . setContext ( serviceContext , thread2 ) ; ContextProvider . disposeContext ( thread2 ) ; thread2 . start ( ) ; thread2 . join ( ) ; assertFalse ( hasContext [ 0 ] ) ; assertFalse ( ContextProvider . hasContext ( ) ) ; hasContext [ 0 ] = true ; final boolean [ ] useMapped = { false } ; Thread thread3 = new Thread ( ) { public void run ( ) { useMapped [ 0 ] = ContextProvider . releaseContextHolder ( ) ; hasContext [ 0 ] = ContextProvider . hasContext ( ) ; } } ; ContextProvider", "gt": ". setContext ( serviceContext , thread3 ) ;", "prediction": ". setContext ( serviceContext , thread3 ) ;\n", "label": 1}
{"id": 3175, "input": "<s> package org . msl . simple . gmfmap . model . delegates ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { public static final String PLUGIN_ID = \"org.msl.simple.gmfmap.model.delegates\" ; private static Activator plugin ; public Activator ( ) { } public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; } public void stop ( BundleContext context ) throws Exception { plugin = null ; super . stop ( context ) ; }", "gt": "public static Activator getDefault ( )", "prediction": "}\n", "label": 0}
{"id": 15012, "input": "<s> package org . fuzzydb . server . internal . index ; import org . fuzzydb . client . exceptions . KeyCollisionException ; import org . fuzzydb . client . internal . RefImpl ; public interface Index < T > { void initialise ( ) ; public void testInsert ( RefImpl < T > ref , T o ) throws KeyCollisionException ; void insert ( RefImpl < T > ref , T o ) ; void remove (", "gt": "RefImpl < T > ref , T obj ) ;", "prediction": "RefImpl < T > ref , T o ) ;\n", "label": 1}
{"id": 10, "input": "<s> package com . sun . source . tree ; public interface Tree { public enum Kind { ANNOTATION ( AnnotationTree . class ) , ARRAY_ACCESS ( ArrayAccessTree . class ) , ARRAY_TYPE ( ArrayTypeTree . class ) , ASSERT ( AssertTree . class ) , ASSIGNMENT ( AssignmentTree . class ) , BLOCK ( BlockTree . class ) , BREAK ( BreakTree . class ) , CASE ( CaseTree . class ) , CATCH ( CatchTree . class ) , CLASS ( ClassTree . class ) , COMPILATION_UNIT ( CompilationUnitTree . class ) , CONDITIONAL_EXPRESSION ( ConditionalExpressionTree . class ) , CONTINUE ( ContinueTree . class ) , DO_WHILE_LOOP ( DoWhileLoopTree . class ) , ENHANCED_FOR_LOOP ( EnhancedForLoopTree . class ) , EXPRESSION_STATEMENT ( ExpressionStatementTree . class ) , MEMBER_SELECT ( MemberSelectTree . class ) , FOR_LOOP ( ForLoopTree . class ) , IDENTIFIER ( IdentifierTree . class ) , IF ( IfTree . class ) , IMPORT ( ImportTree . class ) , INSTANCE_OF ( InstanceOfTree . class ) , LABELED_STATEMENT ( LabeledStatementTree . class ) , METHOD ( MethodTree . class ) , METHOD_INVOCATION ( MethodInvocationTree . class ) , MODIFIERS ( ModifiersTree . class ) , NEW_ARRAY ( NewArrayTree . class ) , NEW_CLASS ( NewClassTree . class ) , PARENTHESIZED ( ParenthesizedTree . class ) , PRIMITIVE_TYPE ( PrimitiveTypeTree . class ) , RETURN ( ReturnTree . class ) , EMPTY_STATEMENT ( EmptyStatementTree . class ) , SWITCH ( SwitchTree . class ) , SYNCHRONIZED ( SynchronizedTree . class ) , THROW ( ThrowTree . class ) , TRY ( TryTree . class ) , PARAMETERIZED_TYPE ( ParameterizedTypeTree . class ) , UNION_TYPE ( UnionTypeTree . class ) , TYPE_CAST ( TypeCastTree . class ) , TYPE_PARAMETER ( TypeParameterTree . class ) , VARIABLE ( VariableTree . class ) , WHILE_LOOP ( WhileLoopTree . class ) , POSTFIX_INCREMENT ( UnaryTree . class ) , POSTFIX_DECREMENT ( UnaryTree . class ) , PREFIX_INCREMENT ( UnaryTree . class ) , PREFIX_DECREMENT ( UnaryTree . class ) , UNARY_PLUS ( UnaryTree . class ) , UNARY_MINUS ( UnaryTree . class ) , BITWISE_COMPLEMENT ( UnaryTree . class ) , LOGICAL_COMPLEMENT ( UnaryTree . class ) , MULTIPLY ( BinaryTree . class ) , DIVIDE ( BinaryTree . class ) , REMAINDER ( BinaryTree . class ) , PLUS ( BinaryTree . class ) , MINUS ( BinaryTree . class ) , LEFT_SHIFT ( BinaryTree . class ) , RIGHT_SHIFT ( BinaryTree . class ) , UNSIGNED_RIGHT_SHIFT ( BinaryTree . class ) , LESS_THAN ( BinaryTree . class ) , GREATER_THAN ( BinaryTree . class ) , LESS_THAN_EQUAL ( BinaryTree . class ) , GREATER_THAN_EQUAL ( BinaryTree . class ) , EQUAL_TO ( BinaryTree . class ) , NOT_EQUAL_TO ( BinaryTree . class ) , AND ( BinaryTree . class ) , XOR ( BinaryTree . class ) , OR ( BinaryTree . class ) , CONDITIONAL_AND ( BinaryTree . class ) , CONDITIONAL_OR ( BinaryTree . class ) , MULTIPLY_ASSIGNMENT ( CompoundAssignmentTree . class ) , DIVIDE_ASSIGNMENT ( CompoundAssignmentTree . class ) , REMAINDER_ASSIGNMENT ( CompoundAssignmentTree . class ) , PLUS_ASSIGNMENT ( CompoundAssignmentTree . class ) , MINUS_ASSIGNMENT ( CompoundAssignmentTree . class ) , LEFT_SHIFT_ASSIGNMENT ( CompoundAssignmentTree . class ) , RIGHT_SHIFT_ASSIGNMENT ( CompoundAssignmentTree . class ) , UNSIGNED_RIGHT_SHIFT_ASSIGNMENT ( CompoundAssignmentTree . class ) , AND_ASSIGNMENT ( CompoundAssignmentTree . class ) , XOR_ASSIGNMENT ( CompoundAssignmentTree . class ) , OR_ASSIGNMENT ( CompoundAssignmentTree . class ) , INT_LITERAL ( LiteralTree . class ) , LONG_LITERAL ( LiteralTree . class ) , FLOAT_LITERAL ( LiteralTree . class ) , DOUBLE_LITERAL ( LiteralTree . class ) , BOOLEAN_LITERAL ( LiteralTree . class ) , CHAR_LITERAL ( LiteralTree . class ) , STRING_LITERAL ( LiteralTree . class ) , NULL_LITERAL ( LiteralTree . class ) , UNBOUNDED_WILDCARD ( WildcardTree . class ) , EXTENDS_WILDCARD ( WildcardTree . class ) , SUPER_WILDCARD ( WildcardTree . class ) , ERRONEOUS ( ErroneousTree . class ) , INTERFACE ( ClassTree . class ) , ENUM ( ClassTree . class ) , ANNOTATION_TYPE ( ClassTree . class ) , OTHER ( null ) ; Kind ( Class < ? extends Tree > intf ) { associatedInterface = intf ; } public Class < ? extends Tree > asInterface ( ) { return associatedInterface ; } private final Class < ? extends Tree > associatedInterface ; } Kind getKind ( ) ; < R , D > R accept ( TreeVisitor < R , D >", "gt": "visitor , D data ) ;", "prediction": "visitor )\n", "label": 0}
{"id": 15016, "input": "<s> package org . eclipse . core . tests . session . samples ; import junit . framework . Test ; import junit . framework . TestCase ; import org . eclipse . core . tests . harness . CoreTest ; import org . eclipse . core . tests . session . SessionTestSuite ; public class SampleCrashTest extends TestCase { public SampleCrashTest ( String methodName ) { super ( methodName ) ; } public void test1 ( ) { System . out . println ( getName ( ) ) ; } public void test2 ( ) { System . out", "gt": ". println ( getName ( ) ) ;", "prediction": ". println ( getName ( ) ) ;\n", "label": 1}
{"id": 4337, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . PoweredMinecart ; public interface LizaPoweredMinecart extends PoweredMinecart { List < LizaEntity > getNearbyLizaEntities ( double x ,", "gt": "double y , double z ) ;", "prediction": "double y ) ;\n", "label": 0}
{"id": 15018, "input": "<s> package com . xtremelabs . androidtohackui . draggables . ui ; import android . content . Context ; import android . util . AttributeSet ; import android . util . Log ; import android . view . GestureDetector ; import android . view . GestureDetector . SimpleOnGestureListener ; import android . view . MotionEvent ; import android . widget . FrameLayout ; public class DraggableView extends FrameLayout { private boolean mIsTouchable = true ; private float mXOffset ; private float mAnchorX ; private GestureDetector mGestureDetector ; private boolean mIsScrolling ; public DraggableView ( Context context ) { super ( context ) ; init ( context ) ; } public DraggableView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; init ( context ) ; } public DraggableView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; init ( context ) ; } private void init ( Context context ) { mGestureDetector = new GestureDetector ( context , new DraggableViewGestureListener ( ) ) ; } public void setXOffset ( float offset ) { mXOffset = offset ; setLeft ( ( mXOffset > 0 ) ? ( int ) mXOffset : 0 ) ; setRight ( getLeft ( ) + getMeasuredWidth ( ) ) ; } public float getXOffset ( ) { return mXOffset ; } public void setAnchorX ( float anchorX ) { mAnchorX = anchorX ; } public float getAnchorX ( ) { return mAnchorX ; } public void setIsTouchable ( boolean touchable ) { mIsTouchable = touchable ; } public void startTouchSample ( MotionEvent event ) { if ( ! mIsTouchable ) return ; Log . i ( \"AndroidHack\" , \"Starting sampling for view\" ) ; mGestureDetector . onTouchEvent ( event ) ; mIsScrolling = false ; } public boolean move ( MotionEvent event ) { Log . i ( \"AndroidHack\"", "gt": ", \"moving view\" ) ;", "prediction": ", \"Moving view\" ) ;\n", "label": 1}
{"id": 4447, "input": "<s> public class NewGeneric { private static class Type < T > { Type ( ) { T t", "gt": "= new T ( ) ;", "prediction": ";\n", "label": 0}
{"id": 15019, "input": "<s> package org . restlet . ext . oauth ; import java . util . List ; import org . restlet . ext . oauth . internal . Token ; import org . restlet . security . Role ; public abstract class AuthenticatedUser { public abstract void addRole ( Role r , String owner ) ; public abstract void clearCode ( ) ; public abstract Client getClient ( ) ; public abstract String getCode ( ) ; public abstract List < Role > getGrantedRoles ( ) ; public abstract String getId ( ) ; public abstract String getPassword ( ) ; public abstract Token getToken ( ) ; public abstract long getTokenExpire ( ) ; public abstract boolean isGrantedRole ( Role", "gt": "role , String owner ) ;", "prediction": "r ) ;\n", "label": 1}
{"id": 1756, "input": "<s> package ar . com . fdvs . dj . domain . chart . dataset ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignXyDataset ; import net . sf . jasperreports . charts . design . JRDesignXySeries ; import net . sf . jasperreports . engine . JRExpression ; import net . sf . jasperreports . engine . design . JRDesignChartDataset ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . util . ExpressionUtils ; public class XYDataset extends AbstractDataset { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private PropertyColumn xValue = null ; private List series = new ArrayList ( ) ; private Map seriesLabels = new HashMap ( ) ; public void setXValue ( PropertyColumn xValue ) { this . xValue = xValue ; } public PropertyColumn getXValue ( ) { return xValue ; } public void addSerie ( AbstractColumn column ) { series . add ( column ) ; } public void addSerie ( AbstractColumn column , String label ) { addSerie ( column , new LiteralExpression ( label ) ) ; } public", "gt": "void addSerie ( AbstractColumn column , StringExpression labelExpression )", "prediction": "void addSeries ( List series )\n", "label": 0}
{"id": 15020, "input": "<s> package fr . inria . zvtm . lens ; public class FSWaveLens extends FixedSizeLens { double d = 0 ; float N = 5.0f ; public FSWaveLens ( ) { this ( 2.0f , DEFAULT_LR1 , DEFAULT_LR2 , 3 , 0 , 0 ) ; } public FSWaveLens ( float mm , int outerRadius , int innerRadius , float n , int x , int y ) { this . MM = mm ; this . LR1 = outerRadius ; this . LR2 = innerRadius ; this . N = n ; updateMagBufferWorkingDimensions ( ) ; lx = x ; ly = y ; } public void setMMandRadii ( float mm , int outerRadius , int innerRadius ) { this . setMMandRadii ( mm , outerRadius , innerRadius , true ) ; } public void setMaximumMagnification ( float mm ) { this . setMaximumMagnification ( mm , true ) ; } public void setN ( float n ) { this . N = n ; } public float getN ( ) { return N ; } public void gf ( float x , float y , float [ ] g ) { d = Math . sqrt ( Math . pow ( x - sw - lx , 2 ) + Math . pow ( y - sh - ly , 2 ) ) ; if ( d <= LR2 ) { g [ 0 ] = g [ 1 ] = MM ; } else if ( d <= LR1 ) { g [ 0 ] = g [ 1 ] = ( float ) ( ( MM - 1 ) * Math . sin ( d / N - LR2 / N ) / ( d / N", "gt": "- LR2 / N ) + 1 ) ;", "prediction": "- LR1 / N ) ) ;\n", "label": 1}
{"id": 988, "input": "<s> import java . awt . * ; import JobAttributes . * ; public class ImportIsFullyQualified {", "gt": "JobAttributes . DefaultSelectionType x ;", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 15027, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . service . IServiceHandler ; class ServiceHandlerRegistry { private final Map < String , IServiceHandler > handlers ; ServiceHandlerRegistry ( ) { handlers = new HashMap < String , IServiceHandler > ( ) ; } IServiceHandler get ( String serviceHandlerId ) { synchronized ( handlers ) { return handlers . get ( serviceHandlerId ) ; } } void put ( String serviceHandlerId , IServiceHandler serviceHandler ) { synchronized ( handlers ) { handlers .", "gt": "put ( serviceHandlerId , serviceHandler ) ;", "prediction": "put ( serviceHandlerId , serviceHandler ) ;\n", "label": 1}
{"id": 39, "input": "<s> package org . papaours . yama . model . dataset ; import javax . xml . bind . annotation . XmlElement ; public class YamaDatasetItem { private int number ; private double value ; public YamaDatasetItem ( ) { super ( ) ; } public YamaDatasetItem ( final int theNumber , final double theValue ) { super ( ) ; this . number = theNumber ; this . value = theValue ; } @ XmlElement public int getNumber ( ) { return number ; } public void setNumber ( final int theNumber ) { this . number = theNumber ; } @ XmlElement public double getValue ( ) { return value ; } public void setValue", "gt": "( final double theValue )", "prediction": "( final double theValue )\n", "label": 0}
{"id": 15028, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . server ; import org . restlet . data . Reference ; import org . restlet . example . book . restlet . ch08 . gae . common . MailRepresentation ; import org . restlet . example . book . restlet . ch08 . gae . common . MailResource ; import org . restlet . ext . wadl . WadlServerResource ; public class MailServerResource extends WadlServerResource implements MailResource { public MailRepresentation retrieve ( ) { MailRepresentation mail = new MailRepresentation ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef (", "gt": ") . toString ( ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 7975, "input": "<s> package org . bombusim . lime . activity ; import java . io . InputStream ; import java . io . InputStreamReader ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . text . Html ; import android . text . method . LinkMovementMethod ; import android . widget . TextView ; public class About { private About ( ) { } ; public static void showAboutDialog ( Activity hostActivity ) { Context context = hostActivity . getBaseContext ( ) ; StringBuilder sb = new StringBuilder ( ) ; try { InputStreamReader isr = new InputStreamReader ( context . getResources ( ) . openRawResource ( R . raw . about ) ) ; while ( true ) { int c = isr . read ( ) ; if ( c == - 1 ) break ; sb . append ( ( char ) c ) ; } isr . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } String about = String . format ( sb . toString ( ) , context . getText ( R . string . app_name ) , Lime . getInstance ( ) . getVersion ( ) ) ; CharSequence aboutDecorated = Html . fromHtml ( about ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( hostActivity ) ; builder . setTitle ( context . getText ( R . string . aboutBombusLime ) ) . setIcon ( R . drawable . ic_launcher ) . setMessage ( aboutDecorated ) . setPositiveButton ( R . string", "gt": ". close , new DialogInterface . OnClickListener ( )", "prediction": ". about , null ) ;\n", "label": 0}
{"id": 15037, "input": "<s> package org . jscsi . target . scsi . modeSense ; import org . jscsi . target . scsi . cdb . ModeSense6Cdb ; public enum PageControl { CURRENT_VALUES ( 0x00 ) , CHANGEABLE_VALUES ( 0x01 ) , DEFAULT_VALUES ( 0x02 ) , SAVED_VALUES ( 0x03 ) ; private final int value ; private PageControl ( final int value ) { this . value = value ; } public static PageControl getPageControl ( final int value ) { final PageControl", "gt": "[ ] vals = values ( ) ;", "prediction": "pageControl = new PageControl ( value ) ;\n", "label": 1}
{"id": 6982, "input": "<s> public class DUBeforeDefined2 { int i = j = 1 ; final int j ; void f ( ) { if ( i != j ) throw new Error ( ) ; } public static void", "gt": "main ( String [ ] args )", "prediction": "main ( String [ ] args )\n", "label": 0}
{"id": 15039, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor . outline ; import org . eclipse . jface . text . BadPositionCategoryException ; import org . eclipse . jface . text . DefaultPositionUpdater ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IPositionUpdater ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import com . googlecode . veloeclipse . editor . VelocityEditor ; import com . googlecode . veloeclipse . vaulttec . ui . model . ITreeNode ; public class VelocityOutlineContentProvider implements ITreeContentProvider { public static final String VELOCITY_TEMPLATE = \"__velocity_template\" ; private VelocityEditor fEditor ; private IPositionUpdater fPositionUpdater ; public VelocityOutlineContentProvider ( VelocityEditor anEditor ) { fEditor = anEditor ; fPositionUpdater = new DefaultPositionUpdater ( VELOCITY_TEMPLATE ) ; } public void inputChanged ( Viewer aViewer , Object anOldInput , Object aNewInput ) { if ( anOldInput != aNewInput ) { if ( anOldInput != null ) { IDocument document = fEditor . getDocumentProvider ( ) . getDocument ( anOldInput ) ; if ( document != null ) { try { document . removePositionCategory ( VELOCITY_TEMPLATE ) ; } catch ( BadPositionCategoryException e ) { } document . removePositionUpdater ( fPositionUpdater ) ; } } if ( aNewInput != null ) { IDocument document = fEditor . getDocumentProvider ( ) . getDocument ( aNewInput ) ; if ( document != null ) { document . addPositionCategory ( VELOCITY_TEMPLATE ) ; document . addPositionUpdater ( fPositionUpdater ) ; } } } } public void dispose ( ) { } public Object [ ] getElements ( Object inputElement ) { return fEditor . getRootElements ( ) ; } public Object [ ] getChildren ( Object anElement ) { return ( anElement instanceof ITreeNode ) ? ( ( ITreeNode ) anElement ) . getChildren", "gt": "( ) : ITreeNode . NO_CHILDREN ;", "prediction": "( ) : null ;\n", "label": 1}
{"id": 4024, "input": "<s> package org . hackreduce . examples . stockexchange ; import java . io . IOException ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . conf . Configured ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . Reducer ; import org . apache . hadoop . mapreduce . lib . input . FileInputFormat ; import org . apache . hadoop . mapreduce . lib . input . TextInputFormat ; import org . apache . hadoop . mapreduce . lib . output . FileOutputFormat ; import org . apache . hadoop . util . Tool ; import org . apache . hadoop . util . ToolRunner ; public class RecordCounter extends Configured implements Tool { public enum Count { RECORDS_SKIPPED , TOTAL_KEYS , UNIQUE_KEYS } public static class RecordCounterMapper extends Mapper < LongWritable , Text , Text , LongWritable > { public static final Text TOTAL_COUNT = new Text ( \"total\" ) ; public static final LongWritable ONE_COUNT = new LongWritable ( 1 ) ; SimpleDateFormat sdf = new SimpleDateFormat ( \"yyyy-MM-dd\" ) ; @ Override @ SuppressWarnings ( \"unused\" ) protected void map ( LongWritable key , Text value , Context context ) throws IOException , InterruptedException { String inputString = value . toString ( ) ; try { String [ ] attributes = inputString . split ( \",\" ) ; if ( attributes . length != 9 ) throw new IllegalArgumentException ( \"Input string given did not have 9 values in CSV format\" ) ; try { String exchange = attributes [ 0 ] ; String stockSymbol = attributes [ 1 ] ; Date date = sdf . parse ( attributes [ 2 ] ) ; double stockPriceOpen = Double . parseDouble ( attributes [ 3 ] ) ; double stockPriceHigh = Double . parseDouble ( attributes [ 4 ] ) ; double stockPriceLow = Double . parseDouble ( attributes [ 5 ] ) ; double stockPriceClose = Double . parseDouble ( attributes [ 6 ] ) ; int stockVolume = Integer . parseInt ( attributes [ 7 ] ) ; double stockPriceAdjClose = Double .", "gt": "parseDouble ( attributes [ 8 ] ) ;", "prediction": "parseDouble ( attributes [ 8 ] ) ;\n", "label": 0}
{"id": 15045, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; public class PictureTemplate { protected final String title ; protected final String description ; protected final String tag ; protected final int maxSize ; public PictureTemplate ( String title , String description , String tag , int maxSize ) { this . title = title ; this . description = description ; this . tag = tag ; this . maxSize = maxSize ; } public String getTitle ( ) { return title ; } public String getDescription ( ) { return description ; } public String getTag ( ) { return tag ; } public int getMaxSize ( ) { return maxSize ; } @ Override", "gt": "public int hashCode ( )", "prediction": "public String toString ( )\n", "label": 1}
{"id": 3071, "input": "<s> package org . ofbiz . widget . screen ; import java . io . IOException ; import java . util . Map ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . base . util . GeneralException ; public interface ScreenStringRenderer { public String getRendererName ( ) ; public void renderScreenBegin ( Appendable writer , Map < String , Object > context ) throws IOException ; public void renderScreenEnd ( Appendable writer , Map < String , Object > context ) throws IOException ; public void renderSectionBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Section section ) throws IOException ; public void renderSectionEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Section section ) throws IOException ; public void renderContainerBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Container container ) throws IOException ; public void renderContainerEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Container container ) throws IOException ; public void renderContentBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderContentBody ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderContentEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderSubContentBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderSubContentBody ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderSubContentEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderHorizontalSeparator ( Appendable writer , Map < String , Object > context , ModelScreenWidget . HorizontalSeparator separator ) throws IOException ; public void renderLabel ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Label label ) throws IOException ; public void renderLink ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Link link ) throws IOException ; public void renderImage ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Image image ) throws IOException ; public void renderContentFrame ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderScreenletBegin ( Appendable writer , Map < String , Object > context , boolean collapsed , ModelScreenWidget . Screenlet screenlet ) throws IOException ; public void renderScreenletSubWidget ( Appendable writer , Map < String , Object > context , ModelScreenWidget subWidget , ModelScreenWidget . Screenlet screenlet ) throws GeneralException , IOException ; public void renderScreenletEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Screenlet screenlet ) throws IOException ; public void renderPortalPageBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . PortalPage portalPage ) throws GeneralException , IOException ; public void renderPortalPageEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . PortalPage portalPage ) throws GeneralException , IOException ; public void renderPortalPageColumnBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . PortalPage portalPage , GenericValue portalPageColumn ) throws GeneralException , IOException ; public void renderPortalPageColumnEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . PortalPage portalPage , GenericValue portalPageColumn ) throws GeneralException , IOException ; public void renderPortalPagePortletBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . PortalPage portalPage", "gt": ", GenericValue portalPortlet ) throws GeneralException , IOException ;", "prediction": ", GenericValue portalPagePortlet ) throws IOException ;\n", "label": 0}
{"id": 15047, "input": "<s> package org . restlet . representation ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Writer ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; import org . restlet . engine . io . BioUtils ; public abstract class CharacterRepresentation extends Representation { public CharacterRepresentation ( MediaType mediaType ) { super ( mediaType ) ; setCharacterSet ( CharacterSet . UTF_8 ) ; } @ Override public java . nio . channels . ReadableByteChannel getChannel ( ) throws IOException { return org . restlet . engine . io . NioUtils . getChannel ( getStream ( ) ) ; } @ Override public InputStream getStream ( ) throws IOException { return BioUtils . getInputStream ( getReader ( ) , getCharacterSet ( ) ) ; } @ Override public void write ( OutputStream outputStream ) throws IOException { Writer writer = BioUtils . getWriter ( outputStream , getCharacterSet ( ) ) ; write ( writer ) ; writer . flush ( ) ; } @ Override public void write ( java . nio . channels . WritableByteChannel writableChannel ) throws IOException { OutputStream os = org . restlet . engine . io . NioUtils . getStream ( writableChannel ) ; write ( os ) ; os", "gt": ". flush ( ) ;", "prediction": ". flush ( ) ;\n", "label": 1}
{"id": 6725, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . Server ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . entity . Arrow ; import org . bukkit . entity . CaveSpider ; import org . bukkit . entity . Egg ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . entity . Player ; import org . bukkit . entity . Snowball ; import org . bukkit . entity . Vehicle ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaCaveSpider ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftCaveSpider implements LizaCaveSpider { private CaveSpider caveSpider ; public LizaCraftCaveSpider ( CaveSpider caveSpider ) { this . caveSpider = caveSpider ; } @ Override public LivingEntity getTarget ( ) { return new LizaCraftLivingEntity ( this . caveSpider . getTarget ( ) ) ; } @ Override public void setTarget ( LivingEntity target ) { this . caveSpider . setTarget ( target ) ; } @ Override public void damage ( int amount ) { this . caveSpider . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . caveSpider . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . caveSpider . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . caveSpider . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . caveSpider . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . caveSpider . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . caveSpider . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . caveSpider . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks (", "gt": "HashSet < Byte > transparent , int maxDistance )", "prediction": ")\n", "label": 0}
{"id": 15048, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . rap . rwt . internal . protocol . ProtocolMessageWriter ; import org . eclipse . rap . rwt . internal . protocol . ProtocolUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . internal . graphics . FontUtil ; public class MeasurementUtil { public static void appendStartupTextSizeProbe ( ProtocolMessageWriter writer ) { MeasurementOperator . getInstance ( ) . appendStartupTextSizeProbe ( writer ) ; } static Object createItemParamObject ( MeasurementItem item ) { Object [ ] result = new Object [ 8 ] ; FontData fontData = item . getFontData ( ) ; result [ 0 ] = getId ( item ) ; result [ 1 ] = item . getTextToMeasure ( ) ; result [ 2 ] = ProtocolUtil . parseFontName ( fontData . getName ( ) ) ; result [ 3 ] = Integer . valueOf ( fontData . getHeight ( ) ) ; result [ 4 ] = Boolean . valueOf ( ( fontData . getStyle ( ) & SWT . BOLD ) != 0 ) ; result [ 5 ] = Boolean . valueOf ( ( fontData . getStyle ( ) & SWT . ITALIC ) != 0 ) ; result [ 6 ] = Integer . valueOf ( item . getWrapWidth ( ) ) ; result [ 7 ] = Boolean . valueOf ( isMarkup ( item . getMode ( ) ) ) ; return result ; } static Object createProbeParamObject ( Probe probe ) { Object [ ] result = new Object [ 8 ] ; FontData fontData = probe . getFontData ( ) ; result [ 0 ] = getId ( probe ) ; result [ 1 ] = probe . getText ( ) ; result [ 2 ] = ProtocolUtil . parseFontName ( fontData . getName ( ) ) ; result [ 3 ] = Integer . valueOf ( fontData . getHeight ( ) ) ; result [ 4 ] = Boolean . valueOf ( ( fontData . getStyle ( ) & SWT . BOLD ) != 0 ) ; result [ 5 ] = Boolean . valueOf ( ( fontData . getStyle ( ) &", "gt": "SWT . ITALIC ) != 0 ) ;", "prediction": "SWT . ITALIC ) != 0 ) ;\n", "label": 1}
{"id": 1514, "input": "<s> package com . matburt . mobileorg . test . OrgData ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgNodePayload ; import com . matburt . mobileorg . OrgData . OrgNodeTimeDate ; import com . matburt . mobileorg . test . util . OrgTestUtils ; import com . matburt . mobileorg . test . util . OrgTestUtils . TestTimestampPayload ; import android . test . AndroidTestCase ; public class OrgNodePayloadTest extends AndroidTestCase { public void testGetIdFromId ( ) { OrgNodePayload payload = new OrgNodePayload ( OrgTestUtils . testIdPayload ) ; assertEquals ( OrgTestUtils . testId , payload . getId ( ) ) ; } public void testGetIdFromOrigId ( ) { OrgNodePayload payload = new OrgNodePayload ( OrgTestUtils . testIdAgendasPayload ) ; assertEquals ( OrgTestUtils . testId , payload . getId ( ) ) ; } public void testOrgNodeGetId ( ) { OrgNode node = new OrgNode ( ) ; node . setPayload ( OrgTestUtils . testIdAgendasPayload ) ; assertEquals ( OrgTestUtils . testId , node . getNodeId ( getContext ( ) . getContentResolver ( ) ) ) ; } public void testScheduledGet ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; assertEquals ( TestTimestampPayload . scheduled , payload . getScheduled ( ) ) ; } public void testDeadlineGet ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; assertEquals ( TestTimestampPayload . deadline , payload . getDeadline ( ) ) ; } public void testTimestampGetSimple ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payloadSimple ) ; assertEquals ( TestTimestampPayload . timestamp , payload . getTimestamp ( ) ) ; } public void testTimestampGet ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; assertEquals ( TestTimestampPayload . timestamp , payload . getTimestamp ( ) ) ; } public void testScheduledModify ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Scheduled , newTimestamp ) ; assertEquals ( newTimestamp , payload . getScheduled ( ) ) ; } public void testDeadlineModify ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Deadline , newTimestamp ) ; assertEquals ( newTimestamp , payload . getDeadline ( ) ) ; } public void testTimestampModify ( ) { OrgNodePayload payload = new OrgNodePayload ( TestTimestampPayload . payload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Timestamp , newTimestamp ) ; assertEquals ( newTimestamp , payload . getTimestamp ( ) ) ; } public void testScheduledInsertNew ( ) { OrgNodePayload payload = new OrgNodePayload ( OrgTestUtils . testIdAgendasPayload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Scheduled , newTimestamp ) ; assertEquals ( newTimestamp , payload . getScheduled ( ) ) ; } public void testDeadlineInsertNew ( ) { OrgNodePayload payload = new OrgNodePayload ( OrgTestUtils . testIdAgendasPayload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Deadline , newTimestamp ) ; assertEquals ( newTimestamp , payload . getDeadline ( ) ) ; } public void testTimestampInsertNew ( ) { OrgNodePayload payload = new OrgNodePayload ( OrgTestUtils . testIdAgendasPayload ) ; final String newTimestamp = TestTimestampPayload . timestampNotInPayload ; payload . insertOrReplaceDate ( OrgNodeTimeDate . TYPE . Timestamp , newTimestamp ) ; assertEquals (", "gt": "newTimestamp , payload . getTimestamp ( ) ) ;", "prediction": "newTimestamp , payload . getScheduled ( ) ) ;\n", "label": 0}
{"id": 15049, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class NewAnalyzerTask extends PerfTask { private List analyzerClassNames ; private int current ; public NewAnalyzerTask ( PerfRunData runData ) { super ( runData ) ; analyzerClassNames = new ArrayList ( ) ; } public int doLogic ( ) throws IOException { String className = null ; try { if ( current >= analyzerClassNames . size ( ) ) { current = 0 ; } className = ( String ) analyzerClassNames . get ( current ++ ) ; if ( className == null || className . equals ( \"\" ) ) { className = \"org.apache.lucene.analysis.standard.StandardAnalyzer\" ; } if ( className . indexOf ( \".\" ) == - 1 || className . startsWith ( \"standard.\" ) ) { className = \"org.apache.lucene.analysis.\" + className ; } getRunData ( ) . setAnalyzer ( ( Analyzer ) Class . forName ( className ) . newInstance ( ) ) ; System . out . println ( \"Changed", "gt": "Analyzer to: \" + className ) ;", "prediction": "analyzer class: \" + className ) ;\n", "label": 1}
{"id": 4991, "input": "<s> package org . dawb . workbench . plotting . tools ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import org . dawb . common . ui . plot . IPlottingSystem ; import org . dawb . common . ui . plot . PlottingFactory ; import org . dawb . common . ui . plot . region . IROIListener ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . tool . AbstractToolPage ; import org . dawb . common . ui . plot . trace . ITraceListener ; import org . dawb . common . ui . plot . trace . TraceEvent ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . viewers . ColumnLabelProvider ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . window . ToolTip ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac .", "gt": "diamond . scisoft . analysis . roi . EllipticalFitROI ;", "prediction": "SWT ;\n", "label": 0}
{"id": 15052, "input": "<s> package org . nuxeo . ecm . platform . io . api . util ; import java . util . Collection ; import java . util . Map ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . platform . io . api . IOManager ; public interface IOConfiguration { String DOC_READER_FACTORY = \"org.nuxeo.ecm.core.io.doc_reader_factory\" ; String DOC_WRITER_FACTORY = \"org.nuxeo.ecm.core.io.doc_writer_factory\" ; IOManager getManager ( ) ; String getRepositoryName ( ) ; void setRepositoryName ( String repositoryName ) ; Collection < DocumentRef > getDocuments ( ) ; DocumentRef getFirstDocument ( ) ; void addDocument ( DocumentRef docRef ) ; void setProperty ( String name", "gt": ", Object serializable ) ;", "prediction": ", String value ) ;\n", "label": 1}
{"id": 2268, "input": "<s> package com . mapr . stats ; import java . util . Random ; class GammaNormalBayesFactory extends BanditFactory { @ Override public BayesianBandit createBandit ( int bandits , Random gen ) { return new GammaNormalBayesModel (", "gt": "bandits , gen ) ;", "prediction": "bandits , gen ) ;\n", "label": 0}
{"id": 15055, "input": "<s> package io . beancounter . commons . nlp ; import java . net . URI ; import java . net . URISyntaxException ; public class Category extends Feature { public static Category build ( URI baseuri , String id , String label ) { try { return new Category ( new URI ( baseuri + \"/\" + id ) , label ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( \"[\" + baseuri + \"/\" + id + \"] is not a well formed URI\" , e ) ; } } public static Category build ( String uri , String label ) { try { return new Category ( new URI", "gt": "( uri ) , label ) ;", "prediction": "( uri ) , label ) ;\n", "label": 1}
{"id": 863, "input": "<s> package play . modules . linkedin ; import java . io . Serializable ; public class LinkedInProfile implements Serializable { private String id ; private String firstName ; private String lastName ; private String industry ; private String pictureUrl ; private String headline ; private String accessToken ; public LinkedInProfile ( String id , String firstName , String lastName , String industry , String pictureUrl , String headline , String accessToken ) { super ( ) ; this . id = id ; this . firstName = firstName ; this . lastName = lastName ; this . industry = industry ; this . pictureUrl = pictureUrl ; this . headline = headline ; this . accessToken = accessToken ; } public String getId ( ) { return id ; } public void setId ( String id ) { this . id = id ; } public String getFirstName ( ) { return firstName ; } public void setFirstName ( String firstName ) { this . firstName = firstName ; } public String getLastName ( ) { return lastName ; } public void setLastName ( String lastName ) { this . lastName = lastName ; } public String getIndustry ( ) { return industry ; } public void setIndustry ( String industry ) {", "gt": "this . industry = industry ;", "prediction": "this . industry = industry ;\n", "label": 0}
{"id": 15064, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import java . io . IOException ; import java . io . InputStream ; import java . text . MessageFormat ; import java . util . Map ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . rap . rwt . application . Application ; import org . eclipse . rap . rwt . application . ApplicationConfiguration ; import org . eclipse . rap . rwt . internal . client . ClientProvider ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . theme . Theme ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . internal . theme . css . CssFileReader ; import org . eclipse . rap . rwt . internal . theme . css . StyleSheet ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . IEntryPointFactory ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . ResourceLoader ; import org . eclipse . rap . rwt . service . IServiceHandler ; import org . eclipse . rap . rwt . service . ISettingStoreFactory ; import org . eclipse . swt . widgets . Widget ; public class ApplicationImpl implements Application , Adaptable { private final ApplicationContext applicationContext ; private final ApplicationConfiguration configuration ; static class ResourceLoaderImpl implements ResourceLoader { private final ClassLoader loader ; private ResourceLoaderImpl ( ClassLoader loader ) { this . loader = loader ; } public InputStream getResourceAsStream ( String resourceName ) throws IOException { return loader . getResourceAsStream ( resourceName ) ; } } public ApplicationImpl ( ApplicationContext applicationContext , ApplicationConfiguration configuration ) { this . applicationContext = applicationContext ; this . configuration = configuration ; } public void setOperationMode ( OperationMode operationMode ) { ParamCheck . notNull ( operationMode , \"operationMode\" ) ; switch ( operationMode ) { case JEE_COMPATIBILITY : break ; case SWT_COMPATIBILITY : applicationContext . getLifeCycleFactory ( ) . configure ( RWTLifeCycle . class ) ; break ; case SESSION_FAILOVER : new SessionFailoverConfigurator ( applicationContext ) . configure ( ) ; break ; default : throw new IllegalArgumentException ( \"Unsupported operation mode: \" + operationMode ) ; } } public void addPhaseListener ( PhaseListener phaseListener ) { ParamCheck . notNull ( phaseListener , \"phaseListener\" ) ; applicationContext . getPhaseListenerRegistry ( ) . add ( phaseListener ) ; } public void setSettingStoreFactory ( ISettingStoreFactory settingStoreFactory ) { ParamCheck . notNull ( settingStoreFactory , \"settingStoreFactory\" ) ; applicationContext . getSettingStoreManager ( ) . register ( settingStoreFactory ) ; } public void addEntryPoint ( String path , Class < ? extends IEntryPoint > entryPointType , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointType , \"entryPointType\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointType , properties ) ; } public void addEntryPoint ( String path , IEntryPointFactory entryPointFactory , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointFactory , properties ) ; } public void addEntryPointByParameter ( String parameter , Class < ? extends IEntryPoint > type ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( type , \"type\" ) ; applicationContext . getEntryPointManager ( ) . registerByName ( parameter , type ) ; } public void addEntryPointByParameter ( String parameter , IEntryPointFactory entryPointFactory ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByName ( parameter , entryPointFactory ) ; } public void addResource ( IResource resource ) { ParamCheck . notNull ( resource , \"resource\" ) ; applicationContext . getResourceRegistry ( ) . add ( resource ) ; } public void addServiceHandler ( String serviceHandlerId , IServiceHandler serviceHandler ) { ParamCheck . notNull ( serviceHandlerId , \"serviceHandlerId\" ) ; ParamCheck . notNull ( serviceHandler , \"serviceHandler\" ) ; ServiceManager serviceManager = applicationContext . getServiceManager ( ) ; serviceManager . registerServiceHandler ( serviceHandlerId , serviceHandler ) ; } public void addStyleSheet ( String themeId , String styleSheetLocation ) { addStyleSheet ( themeId , styleSheetLocation , new ResourceLoaderImpl ( getClassLoader ( ) ) ) ; } public void addStyleSheet ( String themeId , String styleSheetLocation , ResourceLoader resourceLoader ) { ParamCheck . notNull ( themeId , \"themeId\" ) ; ParamCheck . notNull ( styleSheetLocation , \"styleSheetLocation\" ) ; ParamCheck . notNull ( resourceLoader , \"resourceLoader\" ) ; StyleSheet styleSheet = readStyleSheet ( styleSheetLocation , resourceLoader ) ; ThemeManager themeManager = applicationContext . getThemeManager ( ) ; Theme theme = themeManager . getTheme ( themeId ) ; if ( theme != null ) { theme . addStyleSheet ( styleSheet ) ; } else { themeManager . registerTheme ( new Theme ( themeId , \"unknown\" , styleSheet ) ) ; } } public void addThemableWidget ( Class < ? extends Widget > widget ) { addThemableWidget ( widget , new ResourceLoaderImpl ( widget . getClassLoader ( ) ) ) ; } public void addThemableWidget ( Class < ? extends Widget > widget , ResourceLoader resourceLoader ) { ParamCheck . notNull ( widget , \"widget\" ) ; ParamCheck . notNull ( resourceLoader , \"resourceLoader\" ) ; applicationContext . getThemeManager ( ) . addThemeableWidget ( widget , resourceLoader ) ; } public void addClientProvider ( ClientProvider clientProvider ) { applicationContext . getClientSelector ( ) . addClientProvider ( clientProvider ) ; } public void setAttribute ( String name , Object value ) { applicationContext . getApplicationStore ( ) . setAttribute ( name , value ) ; }", "gt": "private ClassLoader getClassLoader ( )", "prediction": "}\n", "label": 1}
{"id": 1106, "input": "<s> package com . sun . source . tree ; public interface EnhancedForLoopTree extends StatementTree { VariableTree getVariable ( ) ; ExpressionTree getExpression ( ) ;", "gt": "StatementTree getStatement ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15066, "input": "<s> package com . poetry . dao ; import java . util . List ; import org . springframework . stereotype . Repository ; import com . poetry . model . Bookmark ; import com . poetry . model . Poetry ; @ Repository public class BookmarkDao extends AbstractDao { public boolean exists ( final String poetryId , final String poetId ) { return exists ( new Bookmark ( poetryId , poetId ) ) ; } public boolean exists ( final Bookmark bookmark ) { getSession ( ) . flush ( ) ; return exists ( Bookmark . class , bookmark ) ; } public void addBookmark ( final Bookmark bookmark ) { insert ( bookmark ) ; } public void removeBookmark ( final Bookmark bookmark ) { delete ( bookmark ) ; } public int getTheNumberOfBookmarks ( final String username ) { logger . trace ( \"trying the number of {}'s bookmark\" , username ) ; return ( ( Long ) findOne ( \"select count( bookmark.poetId ) \" + \"from Bookmark bookmark \" + \"where bookmark.poetId = ?\" , username ) ) . intValue ( ) ; } @ SuppressWarnings ( \"unchecked\" ) public List < Poetry > getBookmarksOf ( String poetId ) { return extract ( ( List < Object [ ] > ) find ( \"from Poetry poetry, Bookmark bookmark \" + \"where poetry.id = bookmark.poetryId and bookmark.poetId = ? \" + \"order by poetry.id desc\" , poetId ) , 0 ) ; } @ SuppressWarnings ( \"unchecked\" ) public List < Poetry > getBookmarksOf ( final String poetId , final String start ) { return extract ( ( List < Object [ ] > ) find ( \"from Poetry poetry, Bookmark bookmark \" + \"where poetry.id = bookmark.poetryId and bookmark.poetId = ? and poetry.id < ?\" + \"order by poetry.id desc\" , poetId , start", "gt": ") , 0 ) ;", "prediction": ") , 0 ) ;\n", "label": 1}
{"id": 630, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . PurgeReport ; import org . jjflyboy . tjpeditor . project . PurgeReportAttribute ; public class PurgeReportImpl extends ReportAttributeImpl implements PurgeReport { protected static final PurgeReportAttribute LIST_ATTRIBUTE_EDEFAULT = PurgeReportAttribute . COLUMNS ; protected PurgeReportAttribute listAttribute = LIST_ATTRIBUTE_EDEFAULT ; protected PurgeReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getPurgeReport ( ) ; } public PurgeReportAttribute getListAttribute ( ) { return listAttribute ; } public void setListAttribute ( PurgeReportAttribute newListAttribute ) { PurgeReportAttribute oldListAttribute = listAttribute ; listAttribute = newListAttribute == null ? LIST_ATTRIBUTE_EDEFAULT : newListAttribute ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE , oldListAttribute , listAttribute ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE : return getListAttribute ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE : setListAttribute ( ( PurgeReportAttribute ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage", "gt": ". PURGE_REPORT__LIST_ATTRIBUTE : setListAttribute ( LIST_ATTRIBUTE_EDEFAULT ) ;", "prediction": ". PURGE_REPORT__LIST_ATTRIBUTE : getListAttribute ( ) . clear ( ) ;\n", "label": 0}
{"id": 15074, "input": "<s> package org . w3c . css . sac ; public interface DocumentHandler { public void startDocument ( InputSource source ) throws CSSException ; public void endDocument ( InputSource source ) throws CSSException ; public void comment ( String text ) throws CSSException ; public void ignorableAtRule ( String atRule ) throws CSSException ; public void namespaceDeclaration ( String prefix , String uri ) throws CSSException ; public void importStyle ( String uri , SACMediaList media , String defaultNamespaceURI ) throws CSSException ; public void startMedia ( SACMediaList media ) throws CSSException ; public void endMedia ( SACMediaList media ) throws CSSException ; public void startPage ( String name , String pseudo_page ) throws CSSException ; public void endPage ( String name , String pseudo_page ) throws CSSException ; public void startFontFace ( ) throws CSSException ; public void endFontFace ( ) throws CSSException ; public", "gt": "void startSelector ( SelectorList selectors ) throws CSSException ;", "prediction": "void startFontFace ( ) throws CSSException ;\n", "label": 1}
{"id": 2941, "input": "<s> package LizaCraft . Entity ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . Server ; import org . bukkit . World ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Item ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . inventory . ItemStack ; import org . bukkit . util . Vector ; import Liza . LizaItem ; public class LizaCraftItem implements LizaItem { private Item item ; public LizaCraftItem ( Item item ) { this . item = item ; } @ Override public ItemStack getItemStack ( ) { return this . item . getItemStack ( ) ; } @ Override public int getPickupDelay ( ) { return this . item . getPickupDelay ( ) ; } @ Override public void setItemStack ( ItemStack arg0 ) { this . item . setItemStack ( arg0 ) ; } @ Override public void setPickupDelay ( int arg0 ) { this . item . setPickupDelay ( arg0 ) ; } @ Override public boolean eject ( ) { return this . item . eject ( ) ; } @ Override public int getEntityId ( ) { return this . item . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . item . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . item . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . item . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . item . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . item . getMaxFireTicks ( ) ; } @ Override public List < Entity > getNearbyEntities ( double arg0 , double arg1 , double arg2 ) { return this . item . getNearbyEntities ( arg0 , arg1 , arg2 ) ; } @ Override public Entity getPassenger ( ) { return this . item . getPassenger ( ) ; } @ Override public Server getServer ( ) { return this . item . getServer ( ) ; } @ Override public int getTicksLived ( ) { return this .", "gt": "item . getTicksLived ( ) ;", "prediction": "item . getTicksLived ( ) ;\n", "label": 0}
{"id": 15075, "input": "<s> package com . emf4sw . rdf . examples ; import java . io . IOException ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . xmi . impl . XMIResourceFactoryImpl ; import com . atl . common . models . Models ; import com . emf4sw . rdf . resource . impl . TTLResourceFactory ; import com . emf4sw . rdf . transform . RDF2Model ; public class Rdf2EcoreModel { public static void main ( String [ ] args ) { Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"xmi\" , new XMIResourceFactoryImpl ( ) ) ; Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"ecore\" , new XMIResourceFactoryImpl ( ) ) ; Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"ttl\" , new TTLResourceFactory ( ) ) ; Models . register ( Models . resource ( \"src/person.ecore\" , true ) ) ; RDF2Model r2m = new RDF2Model (", "gt": "Models . resource ( \"src/person.ecore\" , true ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3856, "input": "<s> package com . sun . tools . apt . mirror . type ; import com . sun . mirror . type . PrimitiveType ; import com . sun . mirror . util . TypeVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Type ; import static com . sun . mirror . type . PrimitiveType . Kind . * ; @ SuppressWarnings ( \"deprecation\" ) class PrimitiveTypeImpl extends TypeMirrorImpl implements PrimitiveType { private final Kind kind ; PrimitiveTypeImpl ( AptEnv env , Kind kind ) { super ( env , getType ( env , kind ) ) ; this . kind = kind ; } public Kind getKind ( ) { return kind ; } public void accept ( TypeVisitor v ) { v . visitPrimitiveType ( this ) ; } private static Type getType ( AptEnv env , Kind kind ) { switch ( kind ) { case BOOLEAN : return env . symtab . booleanType ; case BYTE : return env . symtab . byteType ; case SHORT : return env . symtab . shortType ; case INT : return env . symtab . intType ; case LONG", "gt": ": return env . symtab . longType ;", "prediction": ": return env . symtab . longType ;\n", "label": 0}
{"id": 15078, "input": "<s> package org . eclipse . jface . window ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; public class SameShellProvider implements IShellProvider { private Control targetControl ; public SameShellProvider ( Control targetControl ) { this . targetControl = targetControl ; } public Shell getShell ( ) { if ( targetControl instanceof Shell ) { return ( Shell ) targetControl ; } return targetControl == null", "gt": "? null : targetControl . getShell ( ) ;", "prediction": "? null : targetControl . getShell ( ) ;\n", "label": 1}
{"id": 7292, "input": "<s> package org . dawb . workbench . ui . editors . preference ; import org . dawb . workbench . ui . Activator ; import org . eclipse . core . runtime . preferences . AbstractPreferenceInitializer ; import org . eclipse . jface . preference . IPreferenceStore ; public class EditorPreferenceInitializer extends AbstractPreferenceInitializer { @ Override public void initializeDefaultPreferences ( ) { IPreferenceStore store = Activator . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( EditorConstants . IGNORE_DATASET_FILTERS , false ) ; store . setDefault ( EditorConstants . SHOW_XY_COLUMN , false ) ; store . setDefault ( EditorConstants . SHOW_DATA_SIZE , false ) ; store . setDefault ( EditorConstants . SHOW_DIMS , false ) ; store . setDefault ( EditorConstants . SHOW_VARNAME , false ) ; store . setDefault ( EditorConstants . SHOW_SHAPE , true ) ; store . setDefault ( EditorConstants . DATA_FORMAT , \"#0.00\" ) ; store . setDefault ( EditorConstants . PLAY_SPEED , 1500 ) ; store . setDefault ( EditorConstants . PLOTTING_SYSTEM_CHOICE , \"org.dawb.workbench.editors.plotting.lightWeightPlottingSystem\" ) ; store . setDefault", "gt": "( EditorConstants . HIGHLIGHT_ACTORS_CHOICE , true ) ;", "prediction": "( EditorConstants . PLOTTING_WIDTH , 1500 ) ;\n", "label": 0}
{"id": 15084, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . jboss . seam . core . Events ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . webapp . helpers . EventNames ; @ Operation ( id = RefreshUI . ID , category = Constants . CAT_UI , requires = Constants . SEAM_CONTEXT , label = \"Refresh\" , description = \"Refresh the UI cache. This is a void operation - the input object is returned back as the oputput\" ) public class RefreshUI { public static final String ID = \"Seam.Refresh\" ; @ Param ( name = \"additional list of seam events to raise\" , required = false ) protected StringList additionalSeamEvents ; @ OperationMethod public void run ( ) { OperationHelper . getContentViewActions ( ) . resetAllContent ( ) ; NavigationContext context", "gt": "= OperationHelper . getNavigationContext ( ) ;", "prediction": "= new NavigationContext ( ) ;\n", "label": 1}
{"id": 940, "input": "<s> class Dummy { } class AnonymousType { void method ( ) { new Dummy ( ) { void foo ( ) { } }", "gt": ". foo ( ) ;", "prediction": ";\n", "label": 0}
{"id": 15085, "input": "<s> package org . eclipse . ui . internal . progress ; interface IJobProgressManagerListener { void addJob ( final JobInfo info ) ; void addGroup ( final GroupInfo info ) ; public void refreshJobInfo ( JobInfo info ) ; public", "gt": "void refreshGroup ( GroupInfo info ) ;", "prediction": "void refreshGroupInfo ( GroupInfo info ) ;\n", "label": 1}
{"id": 435, "input": "<s> package com . sun . tools . apt . mirror . type ; import java . util . Collection ; import java . util . ArrayList ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . TypeVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Symbol . TypeSymbol ; import com . sun . tools . javac . code . Type ; @ SuppressWarnings ( \"deprecation\" )", "gt": "public class TypeVariableImpl extends TypeMirrorImpl implements TypeVariable", "prediction": "public class TypeVisitor extends TypeVisitor\n", "label": 0}
{"id": 15086, "input": "<s> package org . nuxeo . ecm . platform . forms . layout . export ; import java . util . ArrayList ; import org . nuxeo . ecm . platform . forms . layout . api . WidgetTypeDefinition ; public class WidgetTypeDefinitions extends ArrayList < WidgetTypeDefinition > { private static", "gt": "final long serialVersionUID = 1L ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 6596, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Select ; import org . jjflyboy . tjpeditor . project . SelectArgument ; public class SelectImpl extends AllocateResourceAttributeImpl implements Select { protected static final SelectArgument ARGUMENT_EDEFAULT = SelectArgument . MAXLOADED ; protected SelectArgument argument = ARGUMENT_EDEFAULT ; protected SelectImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getSelect ( ) ; } public SelectArgument getArgument ( ) { return argument ; } public void setArgument ( SelectArgument newArgument ) { SelectArgument oldArgument = argument ; argument = newArgument == null ? ARGUMENT_EDEFAULT : newArgument ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SELECT__ARGUMENT , oldArgument , argument ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SELECT__ARGUMENT : return getArgument ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . SELECT__ARGUMENT : setArgument ( ( SelectArgument ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage .", "gt": "SELECT__ARGUMENT : setArgument ( ARGUMENT_EDEFAULT ) ;", "prediction": "SELECT__ARGUMENT : setArgument ( ( SelectArgument ) null ) ;\n", "label": 0}
{"id": 15087, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeResult ; import org . eclipse . rap . rwt . internal . textsize . ProbeResultStore ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Point ; public class ProbeResultStore_Test extends TestCase { private static final FontData FONT_DATA_2 = new FontData ( \"helvetia\" , 22 , SWT . BOLD ) ; private static final FontData FONT_DATA_1 = new FontData ( \"arial\" , 23 , SWT . ITALIC ) ; private static final Probe PROBE_OF_FONT_DATA_1 = new Probe ( FONT_DATA_1 ) ; private static final Point SIZE = new Point ( 23 , 45 ) ; private ProbeResultStore probeResultStore ; public void testCreateAndGetProbeResult ( ) { ProbeResult created = probeResultStore . createProbeResult ( PROBE_OF_FONT_DATA_1 , SIZE ) ; ProbeResult found = probeResultStore . getProbeResult ( FONT_DATA_1 ) ; assertNotNull ( created ) ; assertSame ( created , found ) ; assertNull ( probeResultStore . getProbeResult ( FONT_DATA_2 ) ) ; } public void testContains ( ) { probeResultStore . createProbeResult ( PROBE_OF_FONT_DATA_1 , SIZE ) ; assertTrue ( probeResultStore", "gt": ". containsProbeResult ( FONT_DATA_1 ) ) ;", "prediction": ". containsProbeResult ( FONT_DATA_1 ) ) ;\n", "label": 1}
{"id": 1884, "input": "<s> public interface Interface { public", "gt": "void method ( ) ;", "prediction": "String getName ( ) ;\n", "label": 0}
{"id": 15088, "input": "<s> package org . nuxeo . ecm . platform . publisher . api ; import org . nuxeo . ecm . core . api . ClientException ; public class PublisherException extends ClientException { private static final long serialVersionUID = 1L ; public PublisherException ( ) { } public PublisherException ( String message , Throwable cause ) { super ( message , cause ) ; } public PublisherException ( String message ) { super ( message ) ; } public", "gt": "PublisherException ( Throwable cause )", "prediction": "PublisherException ( Throwable cause )\n", "label": 1}
{"id": 5082, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . MushroomCow ; import Liza . LizaMushroomCow ; public class LizaCraftMushroomCow extends LizaCraftCow implements LizaMushroomCow { public LizaCraftMushroomCow ( MushroomCow mooshroom ) { super ( mooshroom ) ; } @ Override public MushroomCow getBukkitHandle ( ) { return", "gt": "( MushroomCow ) this . entity ;", "prediction": "null ;\n", "label": 0}
{"id": 15096, "input": "<s> package org . apache . lucene . collation ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . KeywordTokenizer ; import java . text . Collator ; import java . util . Locale ; import java . io . Reader ; public class TestCollationKeyFilter extends CollationTestBase { private Collator collator = Collator . getInstance ( new Locale ( \"ar\" ) ) ; private Analyzer analyzer = new TestAnalyzer ( collator ) ; private String firstRangeBeginning = encodeCollationKey ( collator . getCollationKey ( firstRangeBeginningOriginal ) . toByteArray ( ) ) ; private String firstRangeEnd = encodeCollationKey ( collator . getCollationKey ( firstRangeEndOriginal ) . toByteArray ( ) ) ; private String secondRangeBeginning = encodeCollationKey ( collator . getCollationKey ( secondRangeBeginningOriginal ) . toByteArray ( ) ) ; private String secondRangeEnd = encodeCollationKey ( collator . getCollationKey ( secondRangeEndOriginal ) . toByteArray ( ) ) ; public class TestAnalyzer extends Analyzer { private Collator collator ; TestAnalyzer ( Collator collator ) { this . collator = collator ; } public TokenStream tokenStream ( String fieldName , Reader reader ) { TokenStream result = new KeywordTokenizer ( reader ) ; result = new CollationKeyFilter ( result , collator ) ; return result ; } } public void testFarsiQueryParserCollating ( ) throws Exception { testFarsiQueryParserCollating ( analyzer ) ; } public void testFarsiRangeFilterCollating ( ) throws Exception { testFarsiRangeFilterCollating ( analyzer , firstRangeBeginning , firstRangeEnd , secondRangeBeginning , secondRangeEnd ) ; } public void testFarsiRangeQueryCollating ( ) throws Exception { testFarsiRangeQueryCollating ( analyzer , firstRangeBeginning , firstRangeEnd , secondRangeBeginning , secondRangeEnd ) ; } public void testFarsiConstantScoreRangeQuery ( ) throws Exception { testFarsiConstantScoreRangeQuery ( analyzer , firstRangeBeginning , firstRangeEnd , secondRangeBeginning , secondRangeEnd ) ; } public void testCollationKeySort ( ) throws Exception { Analyzer usAnalyzer = new TestAnalyzer ( Collator . getInstance ( Locale . US ) ) ; Analyzer franceAnalyzer = new TestAnalyzer ( Collator . getInstance ( Locale . FRANCE ) ) ; Analyzer swedenAnalyzer = new TestAnalyzer ( Collator . getInstance ( new Locale ( \"sv\" , \"se\" ) ) ) ; Analyzer denmarkAnalyzer = new TestAnalyzer ( Collator . getInstance ( new Locale ( \"da\" ,", "gt": "\"dk\" ) ) ) ;", "prediction": "\"fr\" ) ) ) ;\n", "label": 1}
{"id": 9894, "input": "<s> public class T6299211 { void m ( ) { java . util . Collections .", "gt": "max ( null ) ;", "prediction": "emptyList ( ) ;\n", "label": 0}
{"id": 15097, "input": "<s> package org . eclipse . ui ; public interface IContainmentAdapter { public static final int CHECK_CONTEXT = 1 ; public static final int CHECK_IF_CHILD = 2 ; public static", "gt": "final int CHECK_IF_ANCESTOR = 4 ;", "prediction": "final int CHECK_NONE = 3 ;\n", "label": 1}
{"id": 9424, "input": "<s> public class T6723444 { static class Foo < X extends Throwable > { Foo ( ) throws X { } } < X extends Throwable > T6723444 ( ) throws X { } < X extends Throwable > T6723444 ( Foo < X > foo ) throws X { } < X1 extends Throwable , X2 extends Throwable > T6723444 ( Foo < X1 > foo , int i ) throws X1 , X2 { } public static void main ( String [ ] args ) throws Exception { Foo < Exception > exFoo = new Foo < Exception > ( ) ; exFoo = new Foo < Exception > ( ) { } ; new < Exception > T6723444 ( ) ; new < Exception > T6723444 ( ) { } ; new T6723444 ( exFoo ) ; new T6723444 ( exFoo ) { } ; new < Exception , Exception", "gt": "> T6723444 ( exFoo , 1 ) ;", "prediction": "> T6723444 ( )\n", "label": 0}
{"id": 15098, "input": "<s> package org . eclipse . ui . preferences ; import org . eclipse . core . runtime . jobs . Job ; public interface IWorkbenchPreferenceContainer { public boolean openPage ( String preferencePageId , Object data ) ;", "gt": "public IWorkingCopyManager getWorkingCopyManager ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8526, "input": "<s> package cycle2 ; @ interface Bar { Baz baz ( ) ; } @ interface Baz {", "gt": "Bar bar ( ) ;", "prediction": "Ellipse ellipse ( ) ;\n", "label": 0}
{"id": 15099, "input": "<s> package com . corundumstudio . socketio . parser ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public interface JsonSupport { AckArgs readAckArgs ( InputStream src , Class < ? > argType ) throws IOException ; < T > T readValue ( InputStream src , Class < T > valueType ) throws IOException ; void writeValue ( OutputStream out , Object value ) throws IOException ; String writeValueAsString ( Object value ) throws IOException ; void addEventMapping ( String eventName , Class < ? > eventClass ) ; void addJsonClass ( Class < ? > clazz ) ; void removeEventMapping", "gt": "( String eventName ) ;", "prediction": "( String eventName ) ;\n", "label": 1}
{"id": 3090, "input": "<s> package org . bombusim . lime . service ; import java . io . IOException ; import java . net . UnknownHostException ; import javax . net . ssl . SSLException ; import org . bombusim . lime . Lime ; import org . bombusim . lime . activity . preferences . LimePrefs ; import org . bombusim . lime . data . PresenceStorage ; import org . bombusim . lime . data . Roster ; import org . bombusim . lime . logger . LimeLog ; import org . bombusim . xml . XMLException ; import org . bombusim . xmpp . XmppAccount ; import org . bombusim . xmpp . XmppObject ; import org . bombusim . xmpp . XmppStream ; import org . bombusim . xmpp . exception . XmppAuthException ; import org . bombusim . xmpp . exception . XmppException ; import org . bombusim . xmpp . exception . XmppTerminatedException ; import org . bombusim . xmpp . stanza . XmppPresence ; import org . xbill . DNS . Lookup ; import org . xbill . DNS . ResolverConfig ; import android . app . AlarmManager ; import android . app . PendingIntent ; import android . app . Service ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . net . ConnectivityManager ; import android . net . wifi . WifiManager ; import android . net . wifi . WifiManager . WifiLock ; import android . os . Binder ; import android . os . IBinder ; import android . os . PowerManager ; import android . util . Log ; public class XmppService extends Service { public static final String ON_KEEP_ALIVE = \"onKeepAlive\" ; public static final String ON_BOOT = \"onBoot\" ; public static final String ON_STATUS = \"onStatusChange\" ; private BroadcastReceiver mRosterBr ; private BroadcastReceiver mPrefsBr ; private XmppStream mStream ; public class LocalBinder extends Binder { public XmppService getService ( ) { return XmppService . this ; } } private final IBinder binder = new LocalBinder ( ) ; @ Override public IBinder onBind ( Intent intent ) { return binder ; } public void postStanza ( XmppObject stanza , String fromJid ) { XmppStream s = getXmppStream ( fromJid ) ; if ( s != null ) s . postStanza ( stanza ) ; } public XmppStream getXmppStream ( String rosterJid ) { if ( ! mStream . jid . equals ( rosterJid ) ) return null ; return mStream ; } @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { if ( intent != null ) { if ( ON_KEEP_ALIVE . equals ( intent . getAction ( ) ) ) { keepAlive ( ) ; mKeepAliveAlarm . releaseWakeLock ( ) ; return START_STICKY ; } } XmppAccount activeAccount = Lime . getInstance ( ) . getActiveAccount ( ) ; if ( mStream == null ) { mStream = new XmppStream ( activeAccount ) ; mStream . setContext ( this ) ; } else { mStream . bindAccount ( activeAccount ) ; } String lang = getResources ( ) . getConfiguration ( ) . locale . getLanguage ( ) ; mStream . setLocaleLang ( lang ) ; if ( mRosterBr == null ) { mRosterBr = new ConnBroadcastReceiver ( ) ; registerReceiver ( mRosterBr , new IntentFilter ( ConnectivityManager . CONNECTIVITY_ACTION ) ) ; } if ( mPrefsBr == null ) { mPrefsBr = new PrefsUpdateReceiver ( ) ; registerReceiver ( mPrefsBr , new IntentFilter ( LimePrefs . PREFS_CHANGED ) ) ; } checkNetworkState ( ) ; setWiFiLock ( ( networkType == ConnectivityManager . TYPE_WIFI ) ) ; PresenceStorage ps = new PresenceStorage ( this ) ; mStream . setPresence ( ps . getStatus ( ) , ps . getMessage ( ) , ps . getPriority ( ) ) ; if ( mStream . resourceAvailable ) { mStream . sendPresence ( ) ; } else { doConnect ( ) ; } return START_STICKY ; } public void doConnect ( ) { if ( mStream . getStatus ( ) == XmppPresence . PRESENCE_OFFLINE ) return ; if ( networkAvailable ) { ResolverConfig . refresh ( ) ; Lookup . refreshDefault ( ) ; mKeepAliveAlarm . setAlarm ( this ) ; showNotification ( true ) ; mStream . doConnect ( ) ; } else { mStream . doForcedDisconnect ( ) ; mKeepAliveAlarm . cancelAlarm ( this ) ; cancelNotification ( ) ; } } @ Override public void onDestroy ( ) { cancelNotification ( ) ; setWiFiLock ( false ) ; } private void showNotification ( boolean online ) { Lime . getInstance ( ) . notificationMgr ( ) . showOnlineNotification ( online ) ; } private void cancelNotification ( ) { Lime . getInstance ( ) . notificationMgr ( ) . cancelOnlineNotification ( ) ; } private boolean networkAvailable ; private int networkType ; public void checkNetworkState ( ) { try { ConnectivityManager cm = ( ConnectivityManager ) getSystemService ( Context . CONNECTIVITY_SERVICE ) ; networkAvailable = cm . getActiveNetworkInfo ( ) . isAvailable ( ) ; int networkType = cm . getActiveNetworkInfo ( ) . getType ( ) ; this . networkType = networkType ; Lime . getInstance ( ) . vcardResolver . setOnMobile ( networkType == ConnectivityManager . TYPE_MOBILE ) ; } catch ( Exception e ) { networkAvailable = false ; } } private WifiLock mWiFiLock ; private void setWiFiLock ( boolean locked ) { if ( ! Lime . getInstance ( ) . prefs . wifiLock ) return ; if ( ! locked ) { if ( mWiFiLock == null ) return ; mWiFiLock . release ( ) ; return ; } WifiManager wm = ( WifiManager ) getSystemService ( Context . WIFI_SERVICE ) ; if ( mWiFiLock == null ) mWiFiLock = wm . createWifiLock ( WifiManager . WIFI_MODE_FULL , \"org.bombusim.lime\" ) ; mWiFiLock . setReferenceCounted ( false ) ; mWiFiLock . acquire ( ) ; } private class ConnBroadcastReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { checkNetworkState ( ) ; setWiFiLock ( ( networkType == ConnectivityManager . TYPE_WIFI ) ) ; LimeLog . i ( \"XmppService\" , \"Network state: \" + ( ( networkType == ConnectivityManager . TYPE_WIFI ) ? \"WiFi\" : \"GPRS\" ) + ( ( networkAvailable ) ? \" Up\" : \" Down\" ) , null ) ; doConnect ( ) ; } } private class PrefsUpdateReceiver extends BroadcastReceiver { @ Override public void onReceive ( Context context , Intent intent ) { setWiFiLock ( true ) ; } } public void disconnectAll ( ) { try { unregisterReceiver ( mRosterBr ) ; unregisterReceiver ( mPrefsBr ) ; mRosterBr = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } mKeepAliveAlarm", "gt": ". cancelAlarm ( this ) ;", "prediction": ". cancel ( ) ;\n", "label": 0}
{"id": 15101, "input": "<s> package org . apache . lucene . xmlparser ; import java . io . IOException ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import junit . framework . TestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . search . Hits ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . store . RAMDirectory ; import org . w3c . dom . Document ; import org . xml . sax . SAXException ; public class TestQueryTemplateManager extends TestCase { CoreParser builder ; Analyzer analyzer = new StandardAnalyzer ( ) ; private IndexSearcher searcher ; String docFieldValues [ ] = { \"artist=Jeff Buckley \\talbum=Grace \\treleaseDate=1999 \\tgenre=rock\" , \"artist=Fugazi \\talbum=Repeater \\treleaseDate=1990 \\tgenre=alternative\" , \"artist=Fugazi \\talbum=Red Medicine \\treleaseDate=1995 \\tgenre=alternative\" , \"artist=Peeping Tom \\talbum=Peeping Tom \\treleaseDate=2006 \\tgenre=rock\" , \"artist=Red Snapper \\talbum=Prince Blimey \\treleaseDate=1996 \\tgenre=electronic\" } ; String queryForms [ ] = { \"artist=Fugazi \\texpectedMatches=2 \\ttemplate=albumBooleanQuery\" , \"artist=Fugazi \\treleaseDate=1990 \\texpectedMatches=1 \\ttemplate=albumBooleanQuery\" , \"artist=Buckley \\tgenre=rock \\texpectedMatches=1 \\ttemplate=albumFilteredQuery\" , \"artist=Buckley \\tgenre=electronic \\texpectedMatches=0 \\ttemplate=albumFilteredQuery\" , \"queryString=artist:buckly~ NOT genre:electronic \\texpectedMatches=1 \\ttemplate=albumLuceneClassicQuery\" } ; public void testFormTransforms ( ) throws SAXException , IOException , ParserConfigurationException , TransformerException , ParserException { QueryTemplateManager qtm = new QueryTemplateManager ( ) ; qtm . addQueryTemplate ( \"albumBooleanQuery\" , getClass ( ) . getResourceAsStream ( \"albumBooleanQuery.xsl\" ) ) ; qtm . addQueryTemplate ( \"albumFilteredQuery\" , getClass ( ) . getResourceAsStream ( \"albumFilteredQuery.xsl\" ) ) ; qtm . addQueryTemplate ( \"albumLuceneClassicQuery\" , getClass ( ) . getResourceAsStream ( \"albumLuceneClassicQuery.xsl\" ) ) ; for ( int i = 0 ; i < queryForms . length ; i ++ ) { Properties queryFormProperties = getPropsFromString ( queryForms [ i ] ) ; Document doc = qtm . getQueryAsDOM ( queryFormProperties , queryFormProperties . getProperty ( \"template\" ) ) ; Query q = builder . getQuery ( doc . getDocumentElement ( ) ) ; Hits h = searcher . search ( q ) ; int expectedHits = Integer . parseInt ( queryFormProperties . getProperty ( \"expectedMatches\" ) ) ; assertEquals ( \"Number of results should match for query \" + queryForms [ i ] , expectedHits , h . length ( ) ) ; } } Properties getPropsFromString ( String nameValuePairs ) { Properties result = new Properties ( ) ; StringTokenizer st = new StringTokenizer ( nameValuePairs , \"\\t=\" ) ; while", "gt": "( st . hasMoreTokens ( ) )", "prediction": "( st . hasMoreTokens ( ) )\n", "label": 1}
{"id": 7725, "input": "<s> package api . torrents . torrents ; import java . util . List ; public class Producer { private Number id ; private String name ; public Number getId ( ) { return this . id ; } public void setId ( Number id ) { this . id = id ; } public String getName ( ) { return this . name ; }", "gt": "public void setName ( String name )", "prediction": "public void setName ( String name )\n", "label": 0}
{"id": 15104, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . swt . graphics . Rectangle ; public abstract class AbstractTabItem { public abstract Rectangle getBounds ( ) ; public abstract void setInfo ( PartInfo info ) ; public abstract void dispose ( ) ;", "gt": "public void setBusy ( boolean busy )", "prediction": "}\n", "label": 1}
{"id": 741, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; }", "gt": "public static boolean start ( RootDoc root )", "prediction": "}\n", "label": 0}
{"id": 15108, "input": "<s> package org . seage . metaheuristic . tabusearch ; public class BestEverAspirationCriteria implements AspirationCriteria { private static final long serialVersionUID = 8050033847751573251L ; public boolean overrideTabu ( final Solution solution , final Move proposedMove , final double [ ] proposedValue , final ITabuSearch tabuSearch ) { return TabuSearch . isFirstBetterThanSecond ( proposedValue , tabuSearch . getBestSolution ( ) . getObjectiveValue ( ) , tabuSearch . isMaximizing", "gt": "( ) ) ? true : false ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 1555, "input": "<s> package org . ofbiz . accounting . finaccount ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . finaccount . FinAccountHelper ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class FinAccountServices { public static final String module = FinAccountServices . class . getName ( ) ; public static final String resourceError = \"AccountingErrorUiLabels\" ; public static Map < String , Object > createAccountAndCredit ( DispatchContext dctx , Map < String , Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; String finAccountTypeId = ( String ) context . get ( \"finAccountTypeId\" ) ; String accountName = ( String ) context . get ( \"accountName\" ) ; String finAccountId = ( String ) context . get ( \"finAccountId\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( finAccountTypeId == null ) { finAccountTypeId = \"SVCCRED_ACCOUNT\" ; } if ( accountName == null ) { if ( \"SVCCRED_ACCOUNT\" . equals ( finAccountTypeId ) ) { accountName = \"Customer Service Credit Account\" ; } else { accountName = \"Financial Account\" ; } } GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; try { String partyId = ( String ) context . get ( \"partyId\" ) ; Map < String , String > lookupMap = UtilMisc . toMap ( \"finAccountTypeId\" , finAccountTypeId , \"ownerPartyId\" , partyId ) ; String productStoreId = ( String ) context . get ( \"productStoreId\" ) ; if ( UtilValidate . isNotEmpty ( productStoreId ) ) { String payToPartyId = ProductStoreWorker . getProductStorePayToPartyId ( productStoreId , delegator ) ; if ( UtilValidate . isNotEmpty ( payToPartyId ) ) { lookupMap . put ( \"organizationPartyId\" , payToPartyId ) ; } } String currencyUomId = ( String ) context . get ( \"currencyUomId\" ) ; if ( UtilValidate . isNotEmpty ( currencyUomId ) ) { lookupMap . put ( \"currencyUomId\" , currencyUomId ) ; } GenericValue creditAccount ; if ( finAccountId != null ) { creditAccount = delegator . findOne ( \"FinAccount\" , UtilMisc . toMap ( \"finAccountId\" , finAccountId ) , false ) ; } else { List < GenericValue > creditAccounts = delegator . findByAnd ( \"FinAccount\" , lookupMap , UtilMisc . toList ( \"-fromDate\" ) , false ) ; creditAccount = EntityUtil . getFirst ( EntityUtil . filterByDate ( creditAccounts ) ) ; } if ( creditAccount == null ) { String createAccountServiceName = \"createFinAccount\" ; if ( UtilValidate . isNotEmpty ( productStoreId ) ) { createAccountServiceName = \"createFinAccountForStore\" ; } ModelService createAccountService = dctx . getModelService ( createAccountServiceName ) ; Map < String , Object > createAccountContext = createAccountService . makeValid ( context , ModelService . IN_PARAM ) ; createAccountContext . put ( \"finAccountTypeId\" , finAccountTypeId ) ; createAccountContext . put ( \"finAccountName\" , accountName ) ; createAccountContext . put ( \"ownerPartyId\" , partyId ) ; createAccountContext . put ( \"userLogin\" , userLogin ) ; Map < String , Object > createAccountResult = dispatcher . runSync ( createAccountServiceName , createAccountContext ) ; if ( ServiceUtil . isError ( createAccountResult ) || ServiceUtil . isFailure ( createAccountResult ) ) { return createAccountResult ; } if ( createAccountResult != null ) { String creditAccountId = ( String ) createAccountResult . get ( \"finAccountId\" ) ; if ( UtilValidate . isNotEmpty ( creditAccountId ) ) { creditAccount = delegator . findOne ( \"FinAccount\" , UtilMisc . toMap ( \"finAccountId\" , creditAccountId ) , false ) ; Map < String , Object > roleCtx = FastMap . newInstance ( ) ; roleCtx . put ( \"partyId\" , partyId ) ; roleCtx . put ( \"roleTypeId\" , \"OWNER\" ) ; roleCtx . put ( \"finAccountId\" , creditAccountId ) ; roleCtx . put ( \"userLogin\" , userLogin ) ; roleCtx . put ( \"fromDate\" , UtilDateTime", "gt": ". nowTimestamp ( ) ) ;", "prediction": ". parse ( createAccountResult . get ( \"fromDate\" ) ) ) ;\n", "label": 0}
{"id": 15109, "input": "<s> package org . nuxeo . ecm . automation . core . operations . execution ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . DocumentModelListImpl ; @ Operation ( id = RunDocumentChain . ID , category = Constants . CAT_SUBCHAIN_EXECUTION , label = \"Run Document Chain\" , description = \"Run an operation chain which is returning a document in the current context. The input for the chain ro run is the current input of the operation. Return the output of the chain as a document.\" ) public class RunDocumentChain { public static final String ID = \"Context.RunDocumentOperation\" ; @ Context protected OperationContext ctx ; @ Context protected AutomationService service ; @ Param ( name = \"id\" ) protected String chainId ; @ Param ( name = \"isolate\" , required = false , values = \"false\" ) protected boolean isolate = false ; @ OperationMethod", "gt": "public DocumentModel run ( DocumentModel doc ) throws Exception", "prediction": "public DocumentModel run ( DocumentModelList list ) throws Exception\n", "label": 1}
{"id": 1812, "input": "<s> public class DefAssignBoolean_10 { public static void main ( String [ ] args ) { int i , j ; boolean [ ] a = new boolean [ 10 ] ; if ( a [ 1 ] |= a [ 0 ] || ( j = - 1 ) > 0 ) ; else if ( j", "gt": "!= - 1 ) ;", "prediction": "== 0 )\n", "label": 0}
{"id": 15121, "input": "<s> package com . emf4sw . owl . resource ; import java . io . InputStream ; abstract public interface OWLReader { void read ( InputStream", "gt": "inStream , OWLResource resource , OWLFormats format ) ;", "prediction": "is ) ;\n", "label": 1}
{"id": 8661, "input": "<s> package exceptions ; public class ImageLoadFailedException extends Exception { private static final long serialVersionUID = 673774854766029951L ; public ImageLoadFailedException ( ) { super (", "gt": "\"Failed to load image.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15122, "input": "<s> package org . apache . lucene . analysis . fr ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import java . io . IOException ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public final class FrenchStemFilter extends TokenFilter { private FrenchStemmer stemmer = null ; private Set exclusions = null ; private TermAttribute termAtt ; public FrenchStemFilter ( TokenStream in ) { super ( in ) ; stemmer = new FrenchStemmer ( ) ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; } public FrenchStemFilter ( TokenStream in , Set exclusiontable ) { this ( in ) ; exclusions = exclusiontable ; } public boolean incrementToken ( ) throws IOException { if ( input . incrementToken ( ) ) { String term = termAtt . term ( ) ; if ( exclusions == null", "gt": "|| ! exclusions . contains ( term ) )", "prediction": ")\n", "label": 1}
{"id": 3412, "input": "<s> package org . remast . baralga . gui . actions ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import javax . swing . ImageIcon ; import org . remast . baralga . gui . dialogs . ManageProjectsDialog ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public class ManageProjectsAction extends AbstractBaralgaAction { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( ManageProjectsAction . class ) ; public ManageProjectsAction ( final Frame owner , final PresentationModel model ) { super ( owner , model ) ; putValue", "gt": "( NAME , textBundle . textFor ( \"ManageProjectsAction.Name\" ) ) ;", "prediction": "( \"title\" , model . getTitle ( ) ) ;\n", "label": 0}
{"id": 15124, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import java . util . Set ; import java . util . SortedSet ; import javax . ws . rs . CookieParam ; import javax . ws . rs . DefaultValue ; import javax . ws . rs . Encoded ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Cookie ; import javax . ws . rs . core . MediaType ; import org . restlet . test . ext . jaxrs . services . tests . CookieParamTest ; @ Path ( \"cookieParamTest\" ) public class CookieParamTestService { @ GET @ Produces ( MediaType . TEXT_PLAIN ) @ Path ( \"array\" ) public String array ( @ CookieParam ( \"c\" ) Cookie [ ] cc ) { String result = \"[\" ; for ( final Cookie c : cc ) { result += c . getValue ( ) + \", \" ; } return result . substring ( 0 , result . length ( ) - 2 ) + \"]\" ; } @ GET @ Produces ( \"text/plain\" ) public String get ( @ CookieParam ( \"c\" ) String cookieValue ) { return cookieValue ; } @ GET @ Produces ( MediaType . TEXT_PLAIN ) @ Path ( \"Set\" ) public String set ( @ CookieParam ( \"c\" ) Set < Cookie > cc ) { String result = \"{\" ; for ( final Cookie c : cc ) { result += c . getValue ( ) + \", \" ; } return result . substring ( 0 , result . length ( ) - 2 ) + \"}\" ; } @ GET @ Produces ( MediaType . TEXT_PLAIN ) @ Path ( \"SortedSet\" ) public String sortedSet ( @ CookieParam ( \"c\" ) SortedSet < String > cc ) { return cc . toString ( ) ; } @ GET @ Produces ( \"text/plain\" ) @ Path ( \"withDefault\" ) @ Encoded public String withDefault ( @ CookieParam ( \"c\" ) @ DefaultValue (", "gt": "\"default\" ) String cookieValue )", "prediction": "\"null\" ) )\n", "label": 1}
{"id": 2689, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . util . * ; public class Cache { private interface Element { public boolean expired ( ) ; public int compareCredibility ( int cred ) ; public int getType ( ) ; } private static int limitExpire ( long ttl , long maxttl ) { if ( maxttl >= 0 && maxttl < ttl ) ttl = maxttl ; long expire = ( System . currentTimeMillis ( ) / 1000 ) + ttl ; if ( expire < 0 || expire > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) expire ; } private static class CacheRRset extends RRset implements Element { private static final long serialVersionUID = 5971755205903597024L ; int credibility ; int expire ; public CacheRRset ( Record rec , int cred , long maxttl ) { super ( ) ; this . credibility = cred ; this . expire = limitExpire ( rec . getTTL ( ) , maxttl ) ; addRR ( rec ) ; } public CacheRRset ( RRset rrset , int cred , long maxttl ) { super ( rrset ) ; this . credibility = cred ; this . expire = limitExpire ( rrset . getTTL ( ) , maxttl ) ; } public final boolean expired ( ) { int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; return ( now >= expire ) ; } public final int compareCredibility ( int cred ) { return credibility - cred ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( super . toString ( ) ) ; sb . append ( \" cl = \" ) ; sb . append ( credibility ) ; return sb . toString ( ) ; } } private static class NegativeElement implements Element { int type ; Name name ; int credibility ; int expire ; public NegativeElement ( Name name , int type , SOARecord soa , int cred , long maxttl ) { this . name = name ; this . type = type ; long cttl = 0 ; if ( soa != null ) cttl = soa . getMinimum ( ) ; this . credibility = cred ; this . expire = limitExpire ( cttl , maxttl ) ; } public int getType ( ) { return type ; } public final boolean expired ( ) { int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; return ( now >= expire ) ; } public final int compareCredibility ( int cred ) { return credibility - cred ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( type == 0 ) sb . append ( \"NXDOMAIN \" + name ) ; else sb . append ( \"NXRRSET \" + name + \" \" + Type . string ( type ) ) ; sb . append ( \" cl = \" ) ; sb . append ( credibility ) ; return sb . toString ( ) ; } } private static class CacheMap extends LinkedHashMap { private int maxsize = - 1 ; CacheMap ( int maxsize ) { super ( 16 , ( float ) 0.75 , true ) ; this . maxsize = maxsize ; } int getMaxSize ( ) { return maxsize ; } void setMaxSize ( int maxsize ) { this . maxsize = maxsize ; } protected boolean removeEldestEntry ( Map . Entry eldest ) {", "gt": "return maxsize >= 0 && size ( ) > maxsize ;", "prediction": "boolean result = false ;\n", "label": 0}
{"id": 15125, "input": "<s> package org . eclipse . ui . dynamic . markerSupport ; import org . eclipse . core . resources . IMarker ; import org . eclipse . ui", "gt": ". views . markers . ISubCategoryProvider ;", "prediction": ". IWorkbenchPart ;\n", "label": 1}
{"id": 8742, "input": "<s> package ar . com . fdvs . dj . domain ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . util . PropertiesMap ; public class ColumnProperty extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private String property ; private String valueClassName ; private PropertiesMap fieldProperties = new PropertiesMap ( ) ; public ColumnProperty ( String property , String valueClass ) { this . setProperty ( property ) ; this . setValueClassName ( valueClass ) ; } public ColumnProperty ( String property , Class clazz ) { this . setProperty ( property ) ; this . setValueClassName ( clazz . getName ( ) ) ; } public ColumnProperty ( ) { super ( ) ; } public String getProperty ( ) { return property ; } public void setProperty ( String property ) { this . property = property ; } public String getValueClassName ( ) { return valueClassName ; } public void setValueClassName ( String valueClass ) { this . valueClassName = valueClass ; } public PropertiesMap getFieldProperties ( ) { return fieldProperties ; } public void setFieldProperties ( PropertiesMap fieldProperties ) { this . fieldProperties = fieldProperties ; } public Object addFieldProperty", "gt": "( String key , String value )", "prediction": "( String property )\n", "label": 0}
{"id": 15128, "input": "<s> package org . eclipse . ui . internal . part ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IPersistableElement ; import org . eclipse . ui . internal . EditorReference ; public class NullEditorInput implements IEditorInput { private EditorReference editorReference ; public NullEditorInput ( ) { } public NullEditorInput ( EditorReference editorReference ) { Assert . isLegal ( editorReference != null ) ; this . editorReference = editorReference ; } public boolean exists ( ) { return false ; } public ImageDescriptor getImageDescriptor ( ) { return ImageDescriptor . getMissingImageDescriptor ( ) ; } public String getName ( ) { String result = null ; if ( editorReference != null ) { result = editorReference . internalGetName ( ) ; } if ( result != null ) { return result ; } return \"\" ; } public IPersistableElement getPersistable ( ) { return null ; }", "gt": "public String getToolTipText ( )", "prediction": "public void dispose ( )\n", "label": 1}
{"id": 9292, "input": "<s> package pkg2 ; import java . util . * ; public class Foo { public void method (", "gt": "Vector < Object > o )", "prediction": "Method method )\n", "label": 0}
{"id": 15135, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec4 . server ; import org . restlet . example . book . restlet . ch02 . sec5 . sub5 . common . RootResource ; import org . restlet . resource . ServerResource ; public class RootServerResource extends ServerResource implements RootResource { public String represent ( ) { return \"Welcome to the \" + getApplication ( ) . getName", "gt": "( ) + \" !\" ;", "prediction": "( ) + \"!\" ;\n", "label": 1}
{"id": 1903, "input": "<s> package org . parboiled . matchers ; import org . parboiled . MatcherContext ; import org . parboiled . matchervisitors . MatcherVisitor ; import org . parboiled . support . Chars ; import static org . parboiled . common . Preconditions . checkArgNotNull ; import static org . parboiled . common . StringUtils . escape ; public class CharMatcher extends AbstractMatcher { public final char character ; public CharMatcher ( char character ) { super ( getLabel ( character ) ) ; this . character = character ; } private static String getLabel ( char c ) { switch ( c ) { case Chars . DEL_ERROR : case Chars . INS_ERROR : case Chars . RESYNC : case Chars . RESYNC_START : case Chars . RESYNC_END : case Chars . RESYNC_EOI : case Chars . INDENT : case Chars . DEDENT : case Chars", "gt": ". EOI : return escape ( c ) ;", "prediction": ". EOF : case Chars . EOF_START : case Chars . EOF_END : return null ;\n", "label": 0}
{"id": 15137, "input": "<s> package org . eclipse . ui . internal . registry ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . dynamichelpers . ExtensionTracker ; import org . eclipse . core . runtime . dynamichelpers . IExtensionChangeHandler ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . IWorkingSetPage ; public class WorkingSetRegistry implements IExtensionChangeHandler { private static final String DEFAULT_PAGE_ID = \"org.eclipse.ui.resourceWorkingSetPage\" ; private HashMap workingSetDescriptors = new HashMap ( ) ; public WorkingSetRegistry ( ) { IExtensionTracker tracker = PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) ; tracker . registerHandler ( this , ExtensionTracker . createExtensionPointFilter ( getExtensionPointFilter ( ) ) ) ; } private IExtensionPoint getExtensionPointFilter ( ) { return Platform . getExtensionRegistry ( ) . getExtensionPoint ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_WORKINGSETS ) ; } public void addWorkingSetDescriptor ( WorkingSetDescriptor descriptor ) { Assert . isTrue ( ! workingSetDescriptors . containsValue ( descriptor ) , \"working set descriptor already registered\" ) ; IExtensionTracker tracker = PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) ; tracker . registerObject ( descriptor . getConfigurationElement ( ) . getDeclaringExtension ( ) , descriptor , IExtensionTracker . REF_WEAK ) ; workingSetDescriptors . put ( descriptor . getId ( ) , descriptor ) ; } public IWorkingSetPage getDefaultWorkingSetPage ( ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) workingSetDescriptors . get ( DEFAULT_PAGE_ID ) ; if ( descriptor != null ) { return descriptor . createWorkingSetPage ( ) ; } return null ; } public WorkingSetDescriptor getWorkingSetDescriptor ( String pageId ) { return ( WorkingSetDescriptor ) workingSetDescriptors . get ( pageId ) ; } public WorkingSetDescriptor [ ] getWorkingSetDescriptors ( ) { return ( WorkingSetDescriptor [ ] ) workingSetDescriptors . values ( ) . toArray ( new WorkingSetDescriptor [ workingSetDescriptors . size ( ) ] ) ; } public WorkingSetDescriptor [ ] getNewPageWorkingSetDescriptors ( ) { Collection descriptors = workingSetDescriptors . values ( ) ; List result = new ArrayList ( descriptors . size ( ) ) ; for ( Iterator iter = descriptors . iterator ( ) ; iter . hasNext ( ) ; ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) iter . next ( ) ; if ( descriptor . getPageClassName ( ) != null ) { result . add ( descriptor ) ; } } return ( WorkingSetDescriptor [ ] ) result . toArray ( new WorkingSetDescriptor [ result . size ( ) ] ) ; } public boolean hasNewPageWorkingSetDescriptor ( ) { Collection descriptors = workingSetDescriptors . values ( ) ; for ( Iterator iter = descriptors . iterator ( ) ; iter . hasNext ( ) ; ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) iter . next ( ) ; if ( descriptor . getPageClassName ( ) != null ) { return true ; } } return false ; } public WorkingSetDescriptor [ ] getUpdaterDescriptorsForNamespace ( String namespace ) { if ( namespace == null ) return new WorkingSetDescriptor [ 0 ] ; Collection descriptors = workingSetDescriptors . values ( ) ; List result = new ArrayList ( ) ; for ( Iterator iter = descriptors . iterator ( ) ; iter . hasNext ( ) ; ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) iter . next ( ) ; if ( namespace .", "gt": "equals ( descriptor . getUpdaterNamespace ( ) ) )", "prediction": "equals ( descriptor . getNamespace ( ) ) )\n", "label": 1}
{"id": 2694, "input": "<s> import java . util . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; @ AT1 @ AT2 public class InterfaceDecl extends Tester { public static void main ( String [ ] args ) { ( new InterfaceDecl ( ) ) . run ( ) ; } private InterfaceDeclaration iDecl = null ; private InterfaceDeclaration nested = null ; protected void init ( ) { iDecl = ( InterfaceDeclaration ) env . getTypeDeclaration ( \"I\" ) ; nested = ( InterfaceDeclaration ) iDecl . getNestedTypes ( ) . iterator ( ) . next ( ) ; } @ Test ( result = \"interface\" ) Collection < String > accept ( ) { final Collection < String > res = new ArrayList < String > ( ) ; iDecl . accept ( new SimpleDeclarationVisitor ( ) { public void visitTypeDeclaration ( TypeDeclaration t ) { res . add ( \"type\" ) ; } public void visitClassDeclaration ( ClassDeclaration c ) { res . add ( \"class\" ) ; } public void visitInterfaceDeclaration ( InterfaceDeclaration e ) { res . add ( \"interface\" ) ; } public void visitAnnotationTypeDeclaration ( AnnotationTypeDeclaration e ) { res . add ( \"annotation type\" ) ; } } ) ; return res ; } @ Test ( result = \"true\" ) boolean equals1 ( ) { return iDecl . equals ( iDecl ) ; } @ Test ( result = \"false\" ) boolean equals2 ( ) { return iDecl . equals ( nested ) ; } @ Test ( result = \"true\" ) boolean equals3 ( ) { return iDecl . equals ( env . getTypeDeclaration ( \"I\" ) ) ; } @ Test ( result = { \"@AT1\" , \"@AT2\" } ) Collection < AnnotationMirror > getAnnotationMirrors ( ) { return iDecl . getAnnotationMirrors ( ) ; } @ Test ( result = \" Sed Quis custodiet ipsos custodes?\\n\" ) String getDocComment ( ) { return iDecl . getDocComment ( ) ; } @ Test ( result = { \"abstract\" } ) Collection < Modifier > getModifiers1 ( ) { return iDecl . getModifiers ( ) ; } @ Test ( result = { \"public\" , \"abstract\" , \"static\" } ) Collection < Modifier > getModifiers2 ( ) { return nested . getModifiers ( ) ; } @ Test ( result = \"InterfaceDecl.java\" ) String getPosition ( ) { return iDecl . getPosition ( ) . file ( ) . getName ( ) ; } @ Test ( result = \"I\" ) String getSimpleName1 ( ) { return iDecl . getSimpleName ( ) ; } @ Test ( result = \"Nested\" ) String getSimpleName2 ( ) { return nested . getSimpleName ( ) ; } @ Test ( result = \"null\" ) TypeDeclaration getDeclaringType1 ( ) { return iDecl . getDeclaringType ( ) ; } @ Test ( result = \"I<T extends java.lang.Number>\" ) TypeDeclaration getDeclaringType2 ( ) { return nested . getDeclaringType ( ) ; } @ Test ( result = { \"i\" } ) Collection < FieldDeclaration > getFields ( ) { return iDecl . getFields ( ) ; } @ Test ( result = { \"T extends java.lang.Number\" } ) Collection < TypeParameterDeclaration > getFormalTypeParameters1 ( ) { return iDecl . getFormalTypeParameters ( ) ; } @ Test ( result = { } ) Collection < TypeParameterDeclaration > getFormalTypeParameters2 ( ) { return nested . getFormalTypeParameters ( ) ; } @ Test ( result = { \"m()\" , \"toString()\" } ) Collection < ? extends MethodDeclaration > getMethods ( ) { return nested . getMethods ( ) ; } @ Test ( result = \"I.Nested\" ) Collection < TypeDeclaration > getNestedTypes ( ) { return iDecl . getNestedTypes ( ) ; } @ Test ( result = \"\" ) PackageDeclaration getPackage1 ( ) { return iDecl", "gt": ". getPackage ( ) ;", "prediction": ". getPackage ( ) ;\n", "label": 0}
{"id": 15143, "input": "<s> package net . claribole . zgrviewer ; import java . util . Vector ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . DPath ; import fr . inria . zvtm . glyphs . VPolygon ; import fr . inria . zvtm . glyphs . VShape ; import fr . inria . zvtm . glyphs . ClosedShape ; import fr . inria . zvtm . svg . Metadata ; public class LEdge extends LElem { static final short UNDIRECTED = 0 ; static final short INCOMING = 1 ; static final short OUTGOING = 2 ; static final String UNDIRECTED_STR = \"--\" ; static final String DIRECTED_STR = \"->\" ; boolean directed = false ; LNode tail ; LNode head ; LEdge ( String title , Vector < Glyph > glyphs ) { this . title = title ; this . glyphs = new Glyph [ glyphs . size ( ) ] ; this . URLs = new String [ glyphs . size ( ) ] ; this . tooltips = new String [ glyphs . size ( ) ] ; for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] = glyphs . elementAt ( i ) ; if ( this . glyphs [ i ] . getOwner ( ) != null ) { URLs [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURL ( ) ; tooltips [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURLTitle ( ) ; } } if ( this . glyphs . length > 0 ) { this . groupID = ( ( Metadata ) this . glyphs [ 0 ] . getOwner ( ) ) . getClosestAncestorGroupID ( ) ; } else { this . groupID = Messages . EMPTY_STRING ; } for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] . setOwner ( this ) ; } } LEdge ( Vector < Glyph > glyphs ) { this . title = \"\" ; this . glyphs = new Glyph [ glyphs . size ( ) ] ; this . URLs = new String [ glyphs . size ( ) ] ; this . tooltips = new String [ glyphs . size ( ) ] ; for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] = glyphs . elementAt ( i ) ; this . glyphs [ i ] . setOwner ( this ) ; this . URLs [ i ] = \"\" ; this . tooltips [ i ] = \"\" ; } this . groupID = Messages . EMPTY_STRING ; } public String getURL ( Glyph g ) { for ( int i = 0 ; i < glyphs . length ; i ++ ) { if ( g ==", "gt": "glyphs [ i ] )", "prediction": "this . glyphs [ i ] )\n", "label": 1}
{"id": 8902, "input": "<s> package org . ofbiz . accounting . thirdparty . ideal ; import java . io . IOException ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import java . util . Set ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . order . order . OrderChangeHelper ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import com . ing . ideal . connector . IdealConnector ; import com . ing . ideal . connector . IdealException ; import com . ing . ideal . connector . Issuer ; import com . ing . ideal . connector . Issuers ; import com . ing . ideal . connector . Transaction ; public class IdealEvents { public static final String resource = \"AccountingUiLabels\" ; public static final String resourceErr = \"AccountingErrorUiLabels\" ; public static final String commonResource = \"CommonUiLabels\" ; public static final String module = IdealEvents . class . getName ( ) ; private static int decimals = UtilNumber . getBigDecimalScale ( \"invoice.decimals\" ) ; private static int rounding = UtilNumber . getBigDecimalRoundingMode ( \"invoice.rounding\" ) ; public static String callIdeal ( HttpServletRequest request , HttpServletResponse response ) { Locale locale = UtilHttp . getLocale ( request ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String orderId = ( String ) request . getAttribute ( \"orderId\" ) ; String issuerId = ( String ) request . getAttribute ( \"issuerId\" ) ; GenericValue orderHeader = null ; List < GenericValue > orderItemList = null ; try { orderHeader = delegator . findOne ( \"OrderHeader\" , UtilMisc . toMap ( \"orderId\" , orderId ) , false ) ; orderItemList = delegator . findByAnd ( \"OrderItem\" , UtilMisc . toMap ( \"orderId\" , orderId ) ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Cannot get the order header for order: \" + orderId , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , UtilProperties . getMessage ( resourceErr , \"idealEvents.problemsGettingOrderHeader\" , locale ) ) ; return \"error\" ; } BigDecimal orderTotal =", "gt": "orderHeader . getBigDecimal ( \"grandTotal\" ) ;", "prediction": "null ;\n", "label": 0}
{"id": 15146, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . nodes . MatchAllDocsQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . standard . parser . EscapeQuerySyntaxImpl ; import org . apache . lucene . search . MatchAllDocsQuery ; public class MatchAllDocsQueryNodeBuilder implements StandardQueryBuilder { public MatchAllDocsQueryNodeBuilder ( ) { } public MatchAllDocsQuery build ( QueryNode queryNode ) throws QueryNodeException { if ( ! ( queryNode instanceof MatchAllDocsQueryNode ) ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . LUCENE_QUERY_CONVERSION_ERROR , new Object [ ] { queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) , queryNode . getClass", "gt": "( ) . getName ( ) }", "prediction": "( ) }\n", "label": 1}
{"id": 1862, "input": "<s> package com . gisgraphy . client . administrativedivision ; import javax . measure . quantity . Length ; import javax . measure . unit . Unit ; import org . apache . commons . lang . Validate ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import com . gisgraphy . client . commons . DistanceCalculator ; import com . gisgraphy . client . commons . NameFormatter ; import com . gisgraphy . client . commons . NamePart ; import com . gisgraphy . client . gisfeature . AdministrativeEntity ; import com . gisgraphy . client . gisfeature . AlternateGisFeatureName ; import com . gisgraphy . client . gisfeature . GeonamesGisFeature ; import com . gisgraphy . client . gisfeature . GisFeature ; import com . gisgraphy . client . gisfeature . GisFeatureProvider ; import com . gisgraphy . client . gisfeature . GisFeatureType ; import com . gisgraphy . client . gisfeature . InMemoryGeonamesGisFeatureProvider ; import com . gisgraphy . client . language . Iso639Language ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . ibm . icu . util . Currency ; import com . vividsolutions . jts . geom . Point ; public final class City implements Comparable < City > , GisFeature , DistanceCalculator < City > , AdministrativeEntity , CurrencyProvider { public static City forFeature ( GeonamesGisFeature gisFeature ) { return new City ( new InMemoryGeonamesGisFeatureProvider ( gisFeature ) ) ; } public static City forGisFeatureProvider ( GisFeatureProvider gisFeatureProvider ) { return new City ( gisFeatureProvider ) ; } private GisFeatureProvider gisFeatureProvider ; private City ( GisFeatureProvider gisFeatureProvider ) { super ( ) ; Validate . notNull ( gisFeatureProvider . getGisFeature ( ) ) ; Validate . notNull ( gisFeatureProvider . getGisFeatureDistanceCalculator ( ) ) ; shouldHaveParentAdministrativeEntity ( gisFeatureProvider . getGisFeature ( ) ) ; this . gisFeatureProvider = gisFeatureProvider ; } private void shouldHaveParentAdministrativeEntity ( GisFeature gisFeature ) { Validate . notNull ( gisFeature . getParentAdministrativeEntity ( ) ) ; } public int compareTo ( City o ) { if ( o == null ) { return 1 ; } else { return this . getName ( ) . compareTo ( o . getName ( ) ) ; } } public String getName ( ) { return getGisFeatureDefaultName ( ) ; } @ Override public int hashCode ( ) { return gisFeatureProvider . gisFeatureHashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; City other = ( City ) obj ; return gisFeatureProvider . gisFeatureEquals ( other . gisFeatureProvider ) ; } public ImmutableSet < AlternateGisFeatureName > getGisFeatureAlternateNames ( ) { return gisFeature ( ) . getGisFeatureAlternateNames ( ) ; } public GisFeature getGisFeature ( ) { return gisFeature ( ) ; } public Long getGeonamesId ( ) { return gisFeature ( ) . getGeonamesId ( ) ; } public String getGisFeatureDefaultName ( ) { return gisFeature ( ) . getGisFeatureDefaultName ( ) ; } public String getGisFeaturePreferredName ( Iso639Language language ) { return gisFeature ( ) . getGisFeaturePreferredName ( language ) ; } public String getGisFeatureShortName ( Iso639Language language ) { return gisFeature ( ) . getGisFeatureShortName ( language ) ; } public AdministrativeEntity getParentAdministrativeEntity ( ) { return gisFeature ( ) . getParentAdministrativeEntity ( ) ; } public Long getElevation ( ) { return gisFeature ( ) . getElevation ( ) ; } public GisFeatureType getGisFeatureType ( ) { return gisFeature ( ) . getGisFeatureType ( ) ; } public Long getGtopo30AverageElevation ( ) { return gisFeature ( ) . getGtopo30AverageElevation ( ) ; } public DateTime getLastModificationDate ( ) { return gisFeature ( ) . getLastModificationDate ( ) ; } public double getLatitude ( ) { return gisFeature ( ) . getLatitude ( ) ; } public Point getLocation ( ) {", "gt": "return gisFeature ( ) . getLocation ( ) ;", "prediction": "return gisFeature ( ) . getLocation ( ) ;\n", "label": 0}
{"id": 15153, "input": "<s> package br . org . archimedes . io . svg . elements ; import static org . junit . Assert . assertEquals ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; public class PolylineExporterTest extends Tester { private Polyline polyline ; private PolylineExporter exporter ; private ByteArrayOutputStream stream ; @ Before public void setUp ( ) throws Exception { List < Point > list = new ArrayList < Point > ( ) ; list . add ( new Point ( 0 , 0 ) ) ; list . add (", "gt": "new Point ( 0 , 100 ) ) ;", "prediction": "new Point ( 1 , 1 ) ) ;\n", "label": 1}
{"id": 6753, "input": "<s> package org . ofbiz . base . start ; import java . io . File ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class Classpath { private List < File > _elements = new ArrayList < File > ( ) ; public Classpath ( ) { } public Classpath ( String initial ) { addClasspath ( initial ) ; } public boolean addComponent ( String component ) { if ( ( component != null ) && ( component . length ( ) > 0 ) ) { return addComponent ( new File ( component ) ) ; } return false ; } public boolean addComponent ( File component ) { if ( component != null ) { try { if ( component . exists ( ) ) { File key = component . getCanonicalFile ( ) ; if ( ! _elements . contains ( key ) ) { _elements . add ( key ) ; return true ; } } else { System . out . println ( \"Warning : Module classpath component '\" + component + \"' is not valid and will be ignored...\" ) ; } } catch ( IOException e ) { } } return false ; } public boolean addClasspath ( String s ) { boolean added = false ; if ( s != null ) { StringTokenizer t = new StringTokenizer ( s , File . pathSeparator ) ; while ( t . hasMoreTokens ( ) ) { added |= addComponent ( t . nextToken ( ) ) ; } } return added ; } private void appendPath ( StringBuilder cp , String path ) { if ( path . indexOf ( ' ' ) >= 0 ) { cp . append ( '\\\"' ) ; cp . append ( path ) ; cp . append ( '\"' ) ; } else { cp . append ( path ) ; } } public void instrument ( String instrumenterFile , String instrumenterClassName ) { _elements = InstrumenterWorker . instrument ( _elements , instrumenterFile , instrumenterClassName ) ; } @ Override public String toString ( ) { StringBuilder cp = new StringBuilder ( 1024 ) ; int cnt = _elements . size ( ) ; if ( cnt >= 1 ) { cp . append ( _elements . get ( 0 ) . getPath ( ) ) ; } for ( int i = 1 ; i < cnt ; i ++ ) { cp . append ( File . pathSeparatorChar ) ; appendPath ( cp , _elements . get ( i ) . getPath ( ) ) ; } return cp . toString ( ) ; } public URL [ ] getUrls ( ) { int cnt = _elements . size ( ) ; URL [ ] urls = new URL [ cnt ] ; for ( int i = 0 ; i < cnt ; i ++ ) { try { urls [ i ] = _elements . get ( i ) . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { System . out . println ( \"Error adding classpath entry: \" + e . toString ( ) ) ; e . printStackTrace ( ) ; } } return urls ; } public ClassLoader getClassLoader ( ) { ClassLoader parent = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( parent == null ) { parent", "gt": "= Classpath . class . getClassLoader ( ) ;", "prediction": "= ClassLoader . getSystemClassLoader ( ) ;\n", "label": 0}
{"id": 15161, "input": "<s> package org . restlet . test . ext . jaxrs . services . path ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import", "gt": "javax . ws . rs . Produces ;", "prediction": "javax . ws . rs . Produces ;\n", "label": 1}
{"id": 6782, "input": "<s> package org . remast . baralga . gui . model . report ; import java . util . Date ; import org . apache . commons . lang . builder . CompareToBuilder ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . joda . time . DateTime ; public class HoursByDay implements Comparable < HoursByDay > { private DateTime day ; private double hours ; public HoursByDay ( final DateTime day , final double hours ) { this . day = day ; this . hours = hours ; } public Date getDay ( ) { return day . toDate ( ) ; } public double getHours ( ) { return hours ; } @ Override public boolean equals ( final Object that ) { if ( this == that ) { return true ; } if ( ! ( that instanceof HoursByDay ) ) { return false ; } final HoursByDay accAct = ( HoursByDay ) that ; final EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; equalsBuilder . append ( day . getYear ( ) , accAct . day . getYear ( ) ) ; equalsBuilder . append ( day . getDayOfYear ( ) , accAct . day . getDayOfYear ( ) ) ; return equalsBuilder . isEquals ( ) ; } public void addHours ( final double additionalHours ) { this . hours += additionalHours ; } @ Override public int compareTo ( final HoursByDay that ) { if ( that == null ) { return 0 ; } if ( this . equals ( that ) ) { return 0 ; } final CompareToBuilder compareBuilder = new CompareToBuilder ( ) ; compareBuilder . append ( day . getYear ( ) , that . day . getYear ( ) ) ; compareBuilder . append ( day . getDayOfYear ( ) , that . day . getDayOfYear ( ) ) ; return compareBuilder . toComparison ( ) ; } @ Override public int hashCode ( ) { final HashCodeBuilder hashCodeBuilder = new HashCodeBuilder ( ) ; hashCodeBuilder . append", "gt": "( day . getYear ( ) ) ;", "prediction": "( day . getYear ( ) , day . getYear ( ) ) ;\n", "label": 0}
{"id": 15165, "input": "<s> package org . json ; public class XMLTokener extends JSONTokener { public static final java . util . HashMap entity ; static { entity = new java . util . HashMap ( 8 ) ; entity . put ( \"amp\" , XML . AMP ) ; entity . put ( \"apos\" , XML . APOS ) ; entity . put ( \"gt\" , XML . GT ) ; entity . put ( \"lt\" , XML . LT ) ; entity . put ( \"quot\" , XML . QUOT ) ; } public XMLTokener ( String s ) { super ( s ) ; } public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( \"Unclosed CDATA\" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ']' && sb . charAt ( i + 1 ) == ']' && sb . charAt ( i + 2 ) == '>' ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } } public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == '<' ) { return XML . LT ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == '<' || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == '&' ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } } public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == '#' ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ';' ) { break ; } else { throw syntaxError ( \"Missing ';' in XML entity: &\" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + \";\" ; } public Object nextMeta ( ) throws JSONException { char c ; char q ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case 0 : throw syntaxError ( \"Misshaped meta tag\" ) ; case '<' : return XML . LT ; case '>' : return XML . GT ; case '/' : return XML . SLASH ; case '=' : return XML . EQ ; case '!'", "gt": ": return XML . BANG ;", "prediction": ": return XML . SHEQ ;\n", "label": 1}
{"id": 7937, "input": "<s> package objects ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . util . Timer ; import java . util . TimerTask ; import java . util . concurrent . Callable ; import javax . swing . JLabel ; import main . Application ; import mp3player . CurrentPlaylist ; import objects . windows . FloatingMessage ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import servercontact . Server ; public class AddAllButton extends JLabel implements Runnable { static Thread t ; String musicDirID ; Object sync = new Object ( ) ; static boolean stop = false ; public AddAllButton ( ) { setForeground ( new Color ( 204 , 204 , 204 ) ) ; setText ( \"Add All\" ) ; setCursor ( new Cursor ( Cursor . HAND_CURSOR ) ) ; setToolTipText ( \"Add all songs below to current playlist\" ) ; addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { if ( Server . currentMusicDirectoryID != null ) { musicDirID = Server . currentMusicDirectoryID ; init ( ) ; } else { System . out . println ( \"AddAll: Server.currentMusicDirectoryID is null\" ) ; Application . setStatus ( \"Adding songs failed. Reload the artist/album and try again\" ) ; } } } ) ; } private void stop ( ) { stop = true ; } public boolean isAlive ( ) { return t == null ; } private void done ( ) { stop = false ; t = null ; System . out . println ( \"Finished with AddAll action\" ) ; } private void addSongsToPlaylist ( NodeList songNodes , boolean play , boolean shuffle ) { for ( int i = 0 ; i < songNodes . getLength ( ) ; i ++ ) { if ( stop ) { System . out . println ( \"Stopping at addSongsToPlaylist\" ) ; break ; } Element songNode = ( Element ) songNodes . item ( i ) ; String songid = songNode . getAttribute ( \"id\" ) ; String parentid = songNode . getAttribute ( \"parent\" ) ; CurrentPlaylist . addSongToPlaylist ( songid , parentid , play ) ; } if ( ! stop ) { System . out . println ( songNodes . getLength ( ) + \" songs added successfully\" ) ; Application . setStatus ( songNodes . getLength ( ) + \" songs added successfully\" ) ; } } protected void init ( ) { if ( t != null ) { System . out .", "gt": "println ( \"AddAll: Stopping current AddAll process\" ) ;", "prediction": "println ( t . toString ( ) ) ;\n", "label": 0}
{"id": 15166, "input": "<s> package org . restlet . engine . util ; import org . restlet . Request ; import org . restlet . data . Reference ; import org . restlet . engine . security . AuthenticatorUtils ; public class ReferenceUtils { public static Reference update ( Reference resourceRef , Request request ) { Reference result = resourceRef . isAbsolute ( ) ? resourceRef : resourceRef . getTargetRef ( ) ; result = AuthenticatorUtils . updateReference ( result , request . getChallengeResponse ( ) , request ) ; return result ; } public static String format ( Reference resourceRef , boolean isProxied , Request request ) { String result = null ;", "gt": "Reference requestRef = update ( resourceRef , request ) ;", "prediction": "if ( isProxied )\n", "label": 1}
{"id": 9722, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface WeeklyMax extends LimitsAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 15167, "input": "<s> package io . beancounter . commons . tests . model ; import io . beancounter . commons . tests . annotations . Random ; import java . util . UUID ; public class FakePoint { private UUID id ; private double x ; private double y ; @ Random ( names = { \"id\" , \"x\" , \"y\" } ) public FakePoint ( UUID id , Double x , Double y ) { this . id = id ; this . x = x ; this . y = y ; } public UUID getId ( ) { return id ; } public double getX ( ) { return x ; } public double getY ( ) { return y ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; FakePoint fakePoint = ( FakePoint ) o ; if ( Double . compare ( fakePoint . x , x ) != 0 ) return false ; if ( Double . compare ( fakePoint . y , y ) != 0 ) return false ; if ( id != null ? ! id . equals ( fakePoint . id ) : fakePoint . id != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result ; long temp ; result = id != null ? id . hashCode ( ) : 0 ; temp = x != + 0.0d ? Double . doubleToLongBits ( x ) : 0L ; result = 31 * result + ( int ) ( temp ^ ( temp >", "gt": "> > 32 ) ) ;", "prediction": "> > 32 ) ) ;\n", "label": 1}
{"id": 6990, "input": "<s> package com . farpost . ldt . formatter ; import java . io . PrintStream ; public class PlainResultFormatter extends AbstractPlainResultFormatter { private final PrintStream out ; public PlainResultFormatter ( PrintStream out ) {", "gt": "this . out = out ;", "prediction": "super ( out ) ;\n", "label": 0}
{"id": 15171, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import java . util . Iterator ; import de . uos . igf . db3d . dbms . geom . Line3D ; import de . uos . igf . db3d . dbms . geom . MBB3D ; import de . uos . igf . db3d . dbms . geom . Plane3D ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . geom . Segment3D ; import de . uos . igf . db3d . dbms . geom . SimpleGeoObj ; import de . uos . igf . db3d . dbms . geom . Tetrahedron3D ; import de . uos . igf . db3d . dbms . geom . Triangle3D ; import de . uos . igf . db3d . dbms . util . SAM ; public class TetrahedronNet3D extends SpatialObject3D implements Solid3D , ComplexGeoObj { protected TetrahedronNet3DComp [ ] components ; public TetrahedronNet3D ( ScalarOperator sop ) { super ( ) ; this . components = null ; this . setScalarOperator ( sop ) ; this . setMBB ( null ) ; } protected TetrahedronNet3D ( TetrahedronNet3DComp [ ] components , ScalarOperator sop ) { super ( ) ; this . components = components ; this . setScalarOperator ( sop ) ; updateMBB ( ) ; } public TetrahedronNet3D ( TetrahedronNet3D net ) { super ( ) ; TetrahedronNet3DComp [ ] comps = net . getComponents ( ) ; this . components = new TetrahedronNet3DComp [ comps . length ] ; for ( int i = 0 ; i < comps . length ; i ++ ) { this . components [ i ] = comps [ i ] . serializationCopy ( ) ; this . components [ i ] . setNet ( this ) ; } this . setScalarOperator ( net . getScalarOperator ( ) . copy ( ) ) ; updateMBB ( ) ; } public int countComponents ( ) { return getComponents ( ) . length ; } public int countElements ( ) { int sum = 0 ; for ( int i = 0 ; i < countComponents ( ) ; i ++ ) sum = sum + getComponent ( i ) . countElements ( ) ; return sum ; } public TetrahedronNet3DComp [ ] getComponents ( ) { if ( components != null ) return components ; else return new TetrahedronNet3DComp [ 0 ] ; } public TetrahedronNet3DComp getComponent ( int index ) { return this . components [ index ] ; } public void addComponent ( TetrahedronNet3DComp comp ) { Iterator it = comp . getElementsViaRecursion ( ) . iterator ( ) ; while ( it . hasNext ( ) ) ( ( TetrahedronElt3D ) it . next ( ) ) . setID ( this . nextElementID ( ) ) ; comp . setComponentID ( this . nextComponentID ( ) ) ; TetrahedronNet3DComp [ ] comps = getComponents ( ) ; TetrahedronNet3DComp [ ] temp = new TetrahedronNet3DComp [ comps . length + 1 ] ; for ( int i = 0 ; i < comps . length ; i ++ ) temp [ i ] = comps [ i ] ; temp [ comps . length ] = comp ; comp . setNet ( this ) ; setComponents ( temp ) ; } public void removeComponent ( TetrahedronNet3DComp comp ) { TetrahedronNet3DComp [ ] comps = getComponents ( ) ; TetrahedronNet3DComp [ ] temp = new TetrahedronNet3DComp [ comps . length - 1 ] ; int x = 0 ; for ( int i = 0 ; i < comps . length ; i ++ ) { if ( comps [ i ] != comp ) { temp [ x ] = comps [ i ] ; x ++ ; } } setComponents ( temp ) ; } public TetrahedronNet3DComp createComponent ( ) { TetrahedronNet3DComp comp = new TetrahedronNet3DComp ( getScalarOperator ( ) . copy ( ) ) ; addComponent ( comp ) ; return comp ; } public TetrahedronNet3D splitTetrahedronNet ( int [ ] indexes , ScalarOperator sop ) { TetrahedronNet3DComp [ ] newTetrahedronNetComps = new TetrahedronNet3DComp [ indexes . length ] ; for ( int i = 0 ; i < indexes . length ; i ++ ) { newTetrahedronNetComps [ i ] = this . getComponent ( i ) ; this . removeComponent ( getComponent ( i ) ) ; } return new TetrahedronNet3D ( newTetrahedronNetComps , sop ) ; } public double getArea ( ) { double temp = 0 ; TetrahedronNet3DComp [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) temp = temp + comps [ i ] . getArea ( ) ; return temp ; } public double getVolume ( ) { double temp = 0 ; TetrahedronNet3DComp [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) temp = temp + comps [ i ] . getVolume ( ) ; return temp ; } public int getEuler ( ) { TetrahedronNet3DComp [ ] comps = this . getComponents ( ) ; int euler = 0 ; for ( int i = 0 ; i < comps . length ; i ++ ) euler += comps [ i ] . getEuler ( ) ; return euler ; } public int countVertices ( ) { int temp = 0 ; TetrahedronNet3DComp [ ] comps = getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) temp += comps [ i ] . countVertices ( ) ; return temp ; } public int countEdges ( ) { int temp = 0 ; TetrahedronNet3DComp [ ] comps = getComponents ( ) ;", "gt": "for ( int i = 0 ;", "prediction": "for ( int i = 0 ;\n", "label": 1}
{"id": 8589, "input": "<s> package com . psrivastava . stopwatch ; import java . util . ArrayList ; import android . app . Activity ; import android . app . ListFragment ; import android . os . Bundle ; import android . os . SystemClock ; import android . util . Log ; import android . view . View ; import android . view . View . OnClickListener ; import android . view . WindowManager ; import android . widget . FrameLayout ; import android . widget . ImageButton ; import android . widget . ListView ; public class StopwatchActivity extends Activity { private static final String TAG = \"StopwatchActivity\" ; Chronometer mChronometer ; Boolean mChronoPaused = false ; long mElapsedTime = 0 ; ImageButton mStartButton , mPauseButton , mStopButton ; ArrayList < String > mSplitTimes = new ArrayList < String > ( ) ; LapViewFragment splitTimesFragment ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; mChronometer = ( Chronometer ) findViewById ( R . id . chronometer ) ; mStartButton = ( ImageButton ) findViewById ( R . id . bStart ) ; mStartButton . setOnClickListener ( startListener ) ; mPauseButton = ( ImageButton ) findViewById ( R . id . bPause ) ; mPauseButton . setOnClickListener ( pauseListener ) ; mStopButton = ( ImageButton ) findViewById ( R . id . bStop ) ; mStopButton . setOnClickListener ( stopListener ) ; if ( getFragmentManager ( ) . findFragmentById ( R . id . flLapView ) == null ) { splitTimesFragment = new LapViewFragment ( ) ; getFragmentManager ( ) . beginTransaction ( ) . add ( R . id . flLapView , splitTimesFragment ) . commit ( ) ; } } @ Override protected void onRestoreInstanceState ( Bundle savedInstanceState ) { super . onRestoreInstanceState ( savedInstanceState ) ; if ( savedInstanceState . getBoolean ( \"running\" ) ) { Log . i ( \"StopwatchActivity\" , \"base changed\" ) ; mChronometer . setBase ( savedInstanceState . getLong ( \"base\" ) ) ; mChronometer . start ( ) ; } } @ Override protected void onSaveInstanceState ( Bundle outState ) { outState . putBoolean ( \"running\" , mChronometer . isRunning ( ) ) ; outState . putLong ( \"base\" , mChronometer . getBase ( ) ) ; super . onSaveInstanceState ( outState ) ; } View . OnClickListener startListener = new OnClickListener ( ) { public void onClick ( View v ) { if ( mChronoPaused ) { mPauseButton . setVisibility ( View . VISIBLE ) ; mStopButton . setVisibility ( View . VISIBLE ) ; Log . v ( TAG , \"start-chrono was paused\" ) ; mChronometer . setBase ( SystemClock . elapsedRealtime ( ) - mElapsedTime ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_KEEP_SCREEN_ON ) ; } else if ( ! mChronometer . isStarted ( ) ) { mPauseButton . setVisibility ( View . VISIBLE ) ; mStopButton . setVisibility ( View . VISIBLE ) ; ( ( FrameLayout ) findViewById ( R . id . flLapView ) ) . removeAllViews ( ) ; splitTimesFragment = new LapViewFragment ( ) ; getFragmentManager ( ) . beginTransaction ( ) . add ( R . id . flLapView , splitTimesFragment ) . commit ( ) ; Log . v ( TAG , \"start-chrono was stopped\" ) ; mChronometer . setBase ( SystemClock . elapsedRealtime ( ) ) ; getWindow ( ) . addFlags ( WindowManager . LayoutParams . FLAG_KEEP_SCREEN_ON ) ; } else if ( ! mChronoPaused ) { Log . v ( TAG , \"split button pressed\" ) ; mSplitTimes . add ( 0 , timeFormat ( ( SystemClock . elapsedRealtime ( )", "gt": "- mChronometer . getBase ( ) ) ) ) ;", "prediction": "- mElapsedTime ) ) ) ;\n", "label": 0}
{"id": 15173, "input": "<s> package controllers ; import play . * ; import play . mvc . * ; import views . html . * ; public class Application extends Controller { public static Result index ( ) { return ok ( index . render ( \"Your new application", "gt": "is ready.\" ) ) ;", "prediction": "\" ) ) ;\n", "label": 1}
{"id": 260, "input": "<s> package net . minecraft . src ; import net . minecraft . client . Minecraft ; public class mod_Thx extends BaseModMp { static ThxConfig config ; public static mod_Thx instance ; public mod_Thx ( ) { System . out . println ( \"mod_Thx() called\" ) ; config = new ThxConfig ( ) ; instance = this ; } @ Override public void load ( ) { log ( \"load() called\" ) ; ModLoader . setInGameHook ( this , true , true ) ; helicopter : { ModLoaderMp . registerNetClientHandlerEntity ( ThxEntityHelicopter . class , 75 ) ; int entityId = ModLoader . getUniqueEntityId ( ) ; log ( \"Registering entity class for Helicopter with entity id \" + entityId ) ; ModLoader . registerEntityID ( ThxEntityHelicopter . class , \"thxHelicopter\" , entityId ) ; } rocket : { ModLoaderMp . registerNetClientHandlerEntity ( ThxEntityRocket . class , 76 ) ; int entityId = ModLoader . getUniqueEntityId ( ) ; log ( \"Registering entity class for Rocket with entity id \" + entityId ) ; ModLoader . registerEntityID ( ThxEntityRocket . class , \"thxRocket\" , entityId ) ; } missile : { ModLoaderMp . registerNetClientHandlerEntity ( ThxEntityMissile . class , 77 ) ; int entityId = ModLoader . getUniqueEntityId ( ) ; log ( \"Registering entity class for Missile with entity id \" + entityId ) ; ModLoader . registerEntityID ( ThxEntityMissile . class , \"thxMissile\" , entityId ) ; } helicopterItem : { int itemId = getNextItemId ( ) ; log ( \"Setting up inventory item for helicopter with item id \" + itemId ) ; Item item = new ThxItemHelicopter ( itemId ) ; if ( config . getBoolProperty ( \"disable_helicopter_item_image\" ) ) { item . setIconIndex ( 92 ) ; } else { item . setIconIndex ( ModLoader . addOverride ( \"/gui/items.png\" , \"/thx/helicopter_icon.png\" ) ) ; } item . setItemName ( \"thxHelicopter\" ) ; ModLoader . addName ( item , \"THX Helicopter Prototype\" ) ; log ( \"Adding recipe for helicopter\" ) ; ItemStack itemStack = new ItemStack ( item , 1 , 1 ) ; Object [ ] recipe = new Object [ ] { \" X \" , \"X X\" , \"XXX\" , Character . valueOf ( 'X' ) , Block . planks } ; ModLoader . addRecipe ( itemStack , recipe ) ; } log ( \"Done loading \" + getVersion ( ) ) ; } @ Override public void addRenderer ( java . util . Map map ) { map . put ( ThxEntityHelicopter . class , new ThxRender ( ) ) ; map . put ( ThxEntityRocket . class , new ThxRender ( ) ) ; map . put ( ThxEntityMissile . class , new ThxRender ( ) ) ; } @ Override public String getVersion ( ) { return \"Minecraft THX Helicopter Mod - mod_thx-mc125_v018\" ; } @ Override public void handlePacket ( Packet230ModLoader packet ) { int entityId = packet . dataInt [ 0 ] ; if ( entityId < 1 ) log ( \"Received non-entity packet type \" + packet . packetType + \": \" + packet ) ; else { Entity entity = ( ( WorldClient ) ModLoader . getMinecraftInstance ( ) . theWorld ) . getEntityByID ( entityId ) ; if ( entity instanceof ThxEntity ) ( ( ThxEntity ) entity ) . lastUpdatePacket = packet ; } } int getNextItemId ( ) { for ( int idx = 24000 ; idx + 256 < Item . itemsList . length ; idx ++ ) { if ( Item . itemsList [ idx + 256 ] == null ) return idx ; } throw new RuntimeException ( \"Could not find next available Item ID -- can't continue!\" ) ; } public static void log ( String s ) { if ( ThxConfig . ENABLE_LOGGING ) System . out . println ( \"mod_thx: \" + s ) ; } static String getProperty ( String name ) { return config . getProperty ( name ) ; } static int getIntProperty ( String name ) { return config . getIntProperty ( name ) ; } static boolean getBoolProperty ( String name ) { return config . getBoolProperty ( name ) ; } static EntityPlayer getEntityPlayerById ( int id ) { Object [ ] players = ModLoader . getMinecraftInstance ( ) . theWorld . playerEntities . toArray ( ) ; for ( int i = 0 ; i < players . length ; i ++ ) { EntityPlayer ep =", "gt": "( EntityPlayer ) players [ i ] ;", "prediction": "( EntityPlayer ) players [ i ] ;\n", "label": 0}
{"id": 15184, "input": "<s> package io . beancounter . commons . helper ; import org . testng . annotations . Test ; import static org . testng . Assert . assertEquals ; public class UriUtilsTest { @ Test public void shouldCorrectlyEncodeUriWithForwardSlashes ( ) throws Exception { String rawUri = \"http://api.beancounter.io/oauth/callback/username\" ; String expected = \"aHR0cDovL2FwaS5iZWFuY291bnRlci5pby9vYXV0aC9jYWxsYmFjay91c2VybmFtZQ\" ; assertEquals ( UriUtils . encodeBase64 ( rawUri ) , expected ) ; } @ Test public void longEncodedUrisShouldNotBeChunked ( ) throws Exception { String longInput = \"Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.\" ; String expected = \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\" + \"IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg\" + \"dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu\" + \"dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo\" + \"ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4\" ; assertEquals ( UriUtils . encodeBase64 ( longInput", "gt": ") , expected ) ;", "prediction": ") , expected ) ;\n", "label": 1}
{"id": 3081, "input": "<s> package p1 ; public abstract class A { abstract", "gt": "void f ( ) ;", "prediction": "class B\n", "label": 0}
{"id": 15185, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . FieldSelector ; import org . apache . lucene . document . FieldSelectorResult ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . search . FieldCache ; import java . io . IOException ; import java . util . * ; public class ParallelReader extends IndexReader { private List readers = new ArrayList ( ) ; private List decrefOnClose = new ArrayList ( ) ; boolean incRefReaders = false ; private SortedMap fieldToReader = new TreeMap ( ) ; private Map readerToFields = new HashMap ( ) ; private List storedFieldReaders = new ArrayList ( ) ; private int maxDoc ; private int numDocs ; private boolean hasDeletions ; public ParallelReader ( ) throws IOException { this ( true ) ; } public ParallelReader ( boolean closeSubReaders ) throws IOException { super ( ) ; this . incRefReaders = ! closeSubReaders ; } public void add ( IndexReader reader ) throws IOException { ensureOpen ( ) ; add ( reader , false ) ; } public void add ( IndexReader reader , boolean ignoreStoredFields ) throws IOException { ensureOpen ( ) ; if ( readers . size ( ) == 0 ) { this . maxDoc = reader . maxDoc ( ) ; this . numDocs = reader . numDocs ( ) ; this . hasDeletions = reader . hasDeletions ( ) ; } if ( reader . maxDoc ( ) != maxDoc ) throw new IllegalArgumentException ( \"All readers must have same maxDoc: \" + maxDoc + \"!=\" + reader . maxDoc ( ) ) ; if ( reader . numDocs ( ) != numDocs ) throw new IllegalArgumentException ( \"All readers must have same numDocs: \" + numDocs + \"!=\" + reader . numDocs ( ) ) ; Collection fields = reader . getFieldNames ( IndexReader . FieldOption . ALL ) ; readerToFields . put ( reader , fields ) ; Iterator i = fields . iterator ( ) ; while ( i . hasNext ( ) ) { String field = ( String ) i . next ( ) ; if ( fieldToReader . get ( field ) == null ) fieldToReader . put ( field , reader ) ; } if ( ! ignoreStoredFields ) storedFieldReaders . add ( reader ) ; readers . add ( reader ) ; if ( incRefReaders ) { reader . incRef ( ) ; } decrefOnClose . add ( Boolean .", "gt": "valueOf ( incRefReaders ) ) ;", "prediction": "TRUE ) ;\n", "label": 1}
{"id": 5035, "input": "<s> package org . gk . engine . client . build . tree ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . gk . engine . client . build . panel . XContentPanel ; import org . gk . engine . client . event . EventCenter ; import org . gk . engine . client . gen . UIGen ; import org . gk . engine . client . res . UIRes ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . tree . xml . gkTreeHandler ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . dnd . DND . Operation ; import com . extjs . gxt . ui . client . event . DNDEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . TreePanelEvent ; import com . extjs . gxt . ui . client . util . IconHelper ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . menu . Menu ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanelSelectionModel ; import com . google . gwt . resources . client . ImageResource ; import com . google . gwt . user . client . ui . AbstractImagePrototype ; import com . google . gwt . xml . client . Node ; public class XTree extends XContentPanel { protected String name , value , operation , hasChildren ; protected String dragSource , dropTarget ; protected String onClick , onExpand , onCollapse , onMouseOver ; public XTree ( Node node , List < UIGen > widgets ) { super ( node , widgets ) ; name = super . getAttribute ( \"name\" , \"ROOT\" ) ; value = super . getAttribute ( \"value\" , \"ROOT\" ) ; operation = super . getAttribute ( \"operation\" , \"move\" ) ; hasChildren = super . getAttribute ( \"hasChildren\" , \"false\" ) ; dragSource = super . getAttribute ( \"drag\" , \"false\" ) ; dropTarget = super . getAttribute ( \"drop\" , \"false\" ) ; onClick = super . getAttribute ( \"onClick\" , \"\" ) ; onExpand = super . getAttribute ( \"onExpand\" , \"\" ) ; onCollapse = super . getAttribute ( \"onCollapse\" , \"\" ) ; onMouseOver = super . getAttribute ( \"onMouseOver\" , \"\" ) ; } @ Override public Component build ( ) { gkXMLTreePanelIC tree = new gkXMLTreePanelIC ( id , \"name\" , \"\" , dragSource ) { @ Override protected gkMap getRootNodeInfo ( ) { return new gkMap ( gkXMLTreePanelIC . NAME , name ) . fill ( \"text\" , value ) ; } @ Override protected void createTreeHandler ( ) { Operation op = operation . toLowerCase ( ) . equals ( \"copy\" ) ? Operation . COPY : Operation . MOVE ; new gkTreeHandler ( tree , op ) { @ Override public void update ( Map info ) { DNDEvent dnd = new DNDEvent ( null ) ; dnd . setData ( info ) ; EventCenter . exec ( id , onDrop , XTree . this , dnd ) ; } } ; } @ Override protected AbstractImagePrototype iconProvider ( String name ) { AbstractImagePrototype img = IconHelper . create ( name ) ; if ( img == null ) { ImageResource imgRes = UIRes . icon . get ( name ) ; img = imgRes ==", "gt": "null ? null : AbstractImagePrototype . create ( imgRes ) ;", "prediction": "null ? null : imgRes ;\n", "label": 0}
{"id": 15189, "input": "<s> package org . apache . lucene . ant ; import org . apache . lucene . document . Document ; import java . io . File ; public class FileExtensionDocumentHandler implements DocumentHandler { public Document getDocument ( File file ) throws DocumentHandlerException { Document doc = null ; String name = file . getName ( ) ; try { if ( name . endsWith ( \".txt\" ) ) { doc = TextDocument . Document ( file ) ; } if ( name . endsWith ( \".html\" ) ) { doc =", "gt": "HtmlDocument . Document ( file ) ;", "prediction": "TextDocument . Document ( file ) ;\n", "label": 1}
{"id": 9082, "input": "<s> package com . redhat . ceylon . compiler . loader . mirror ; import java . util . List ; public interface MethodMirror extends AnnotatedMirror { boolean isStatic ( ) ; boolean isPublic ( ) ; boolean isProtected ( ) ; boolean isDefaultAccess ( ) ; boolean isConstructor ( ) ; boolean isAbstract ( ) ; boolean isFinal ( ) ; boolean isStaticInit ( ) ; boolean isVariadic ( ) ; List < VariableMirror > getParameters ( ) ; TypeMirror getReturnType ( ) ; boolean isDeclaredVoid ( ) ; List < TypeParameterMirror", "gt": "> getTypeParameters ( ) ;", "prediction": "> getTypeParameters ( ) ;\n", "label": 0}
{"id": 15203, "input": "<s> package org . eclipse . ui . activities ; import java . util . Set ; import org . eclipse . jface . resource . ImageDescriptor ; public interface IWorkbenchActivitySupport { IActivityManager getActivityManager ( ) ; void setEnabledActivityIds ( Set enabledActivityIds ) ; ImageDescriptor getImageDescriptor ( IActivity activity ) ; ImageDescriptor getImageDescriptor ( ICategory category ) ;", "gt": "ITriggerPointManager getTriggerPointManager ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8978, "input": "<s> package com . nesscomputing . hbase . spill ; import java . io . File ; import java . util . List ; import org . apache . hadoop . hbase . client . Put ; import org . junit . Assert ; import org . junit . Ignore ; public class SpilledFileTester { @ Ignore public void testSimple ( ) throws Exception { final File file = new File ( \"/tmp/log-c37ec4b4-a495-4256-b3b1-f2b25f83821e-00797.spilled\" ) ; final SpilledFile spilledFile = new SpilledFile ( file ) ; Assert . assertEquals ( 1 , spilledFile . getVersion ( ) ) ; int count = spilledFile . getElements ( ) ; final List < Put >", "gt": "data = spilledFile . load ( ) ;", "prediction": "puts = new ArrayList < Put > ( count ) ;\n", "label": 0}
{"id": 15213, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . ISerializable ; public abstract class SenseDataDescriptor implements ISerializable { private static final int COMMON_FIELDS_LENGTH = 2 ; private final SenseDataDescriptorType descriptorType ; private final int additionalLength ; public SenseDataDescriptor ( final SenseDataDescriptorType descriptorType , final int additionalLength ) { this . descriptorType = descriptorType ; this . additionalLength = additionalLength ; } private final void serializeCommonFields ( final ByteBuffer byteBuffer , final int index ) { byteBuffer . position ( index ) ; byteBuffer . put ( descriptorType . getValue ( ) ) ; byteBuffer . put ( ( byte ) additionalLength ) ; } protected abstract void serializeSpecificFields ( ByteBuffer byteBuffer , final int index ) ; private final int getAdditionalLength ( ) { return additionalLength ; } public void serialize (", "gt": "ByteBuffer byteBuffer , int index )", "prediction": "final ByteBuffer byteBuffer , final int index )\n", "label": 1}
{"id": 499, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Shift ; import org . jjflyboy . tjpeditor . project . ShiftTimesheet ; public class ShiftTimesheetImpl extends TimesheetAttributeImpl implements ShiftTimesheet { protected Shift shift ; protected ShiftTimesheetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getShiftTimesheet ( ) ; } public Shift getShift ( ) { if ( shift != null && shift . eIsProxy ( ) ) { InternalEObject oldShift = ( InternalEObject ) shift ; shift = ( Shift ) eResolveProxy ( oldShift ) ; if ( shift != oldShift ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . SHIFT_TIMESHEET__SHIFT , oldShift , shift ) ) ; } } return shift ; } public Shift basicGetShift ( ) { return shift ; } public void setShift ( Shift newShift ) { Shift oldShift = shift ; shift = newShift ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SHIFT_TIMESHEET__SHIFT , oldShift , shift ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SHIFT_TIMESHEET__SHIFT : if ( resolve ) return getShift ( ) ; return basicGetShift ( ) ; } return super . eGet (", "gt": "featureID , resolve , coreType ) ;", "prediction": "featureID , resolve , coreType ) ;\n", "label": 0}
{"id": 15224, "input": "<s> package org . apache . lucene . queryParser . surround . query ; import java . util . List ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . BooleanClause ; public class AndQuery extends ComposedQuery { public AndQuery ( List queries , boolean inf , String opName ) { super ( queries , inf , opName ) ; } public Query makeLuceneQueryFieldNoBoost ( String fieldName , BasicQueryFactory qf ) { return SrndBooleanQuery . makeBooleanQuery ( makeLuceneSubQueriesField ( fieldName , qf ) , BooleanClause .", "gt": "Occur . MUST ) ;", "prediction": "Occur . SHOULD ) ;\n", "label": 1}
{"id": 673, "input": "<s> class TestConstructor < T , K > { T t ; K k ; public TestConstructor ( T t , K k ) { this . t = t ; } public TestConstructor ( K k ) { this . k = k ; this . t = null ; } public TestConstructor ( T t ) { this . t = t ; this . k = null ; } public void setT ( T t ) { this . t = t ; this . k = null ; } public void setT ( K k ) { this . k = k ; this . t = null ; } public void setT ( T t , K k ) { this . t = t ; this . k = k ; } } class TestC < T > { T t ; public < T > void setT ( T t ) { this . t = t ; } } public class T6326754 { public static void", "gt": "main ( String ... arg )", "prediction": "main ( String [ ] args )\n", "label": 0}
{"id": 15225, "input": "<s> package org . nuxeo . ecm . platform . annotations . service ; import java . net . URI ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; public class DefaultUriResolverTest { private static final String baseUrl = \"http://myexemple.com/nuxeo/Annotations/\" ; private static final String annId = \"3ACF6D754\" ; private static final String annotationUrl = baseUrl + annId ; private static final String annotationUrn = \"urn:annotation:\" + annId ; private final UriResolver resolver = new DefaultUriResolver ( ) ;", "gt": "@ Test public void testTranslateToGraphUri ( ) throws Exception", "prediction": "public DefaultUriResolverTest ( )\n", "label": 1}
{"id": 2623, "input": "<s> import java . util . * ; class X { void m ( ) { Object o = List . < String", "gt": "> unknown ( ) ;", "prediction": "> get ( ) ;\n", "label": 0}
{"id": 15228, "input": "<s> package org . seage . metaheuristic . tabusearch ; public class ComplexTabuList implements TabuList { private static final long serialVersionUID = - 1144625207822991616L ; public final static int DEFAULT_TENURE = 10 ; public final static int DEFAULT_NUM_ATTR = 2 ; private int tenure ; private int [ ] [ ] tabuList ; private int currentPos ; private int listLength ; private int numAttr ; private final static double LIST_GROW_FACTOR = 2.0 ; public ComplexTabuList ( ) { this ( DEFAULT_TENURE , DEFAULT_NUM_ATTR ) ; } public ComplexTabuList ( int tenure , int numAttr ) { super ( ) ; this . tenure = tenure ; this . numAttr = numAttr ; this . listLength = ( int ) ( tenure * LIST_GROW_FACTOR ) ; this . tabuList = new int [ listLength ] [ numAttr ] ; this . currentPos = 0 ; for ( int i = 0 ; i < listLength ; i ++ ) for ( int j = 0 ; j < numAttr ; j ++ ) this . tabuList [ i ] [ j ] = Integer . MIN_VALUE ; } public boolean isTabu ( Solution fromSolution , Move move ) { if ( ! ( move instanceof ComplexMove ) ) throw new IllegalArgumentException ( \"Move is not of type ComplexMove\" ) ; ComplexMove cMove = ( ComplexMove ) move ; int [ ] attrs = cMove . attributes ( ) ; if ( attrs . length != this . numAttr ) throw new IllegalArgumentException ( \"Wrong number of attributes (\" + attrs . length + \"). Should be \" + this . numAttr + \".\" ) ; for ( int i = 1 ; i <= tenure ; i ++ ) if ( currentPos - i < 0 ) return false ; else for ( int j = 0 ; j < this . numAttr ; j ++ ) if ( attrs [ j ] == tabuList [ ( currentPos - i ) % listLength ] [ j ] ) return true ; return false ; } public void setTabu ( Solution fromSolution , Move move ) { if ( ! ( move instanceof ComplexMove ) ) throw new IllegalArgumentException ( \"Move is not of type ComplexMove\" ) ; ComplexMove cMove = ( ComplexMove ) move ; int [ ] attrs = cMove . attributes ( ) ; if ( attrs . length != this . numAttr ) throw new IllegalArgumentException ( \"Wrong number of attributes (\" + attrs . length + \"). Should be \" + this . numAttr + \".\" ) ; for ( int j = 0 ; j < this . numAttr ; j ++ ) tabuList [ ( currentPos ) % listLength ] [ j ] = attrs [ j ] ; currentPos ++ ; } public int getNumberOfAttributes ( ) { return numAttr ; } public int getTenure ( ) { return tenure ; } public void setTenure ( int tenure ) { if ( tenure < 0 ) return ; if ( tenure > this .", "gt": "tenure && tenure > tabuList . length )", "prediction": "tenure ) tenure = this . tenure ;\n", "label": 1}
{"id": 4921, "input": "<s> package javax . lang . model . type ; import java . util . List ; public interface UnionType extends TypeMirror { List < ?", "gt": "extends TypeMirror > getAlternatives ( ) ;", "prediction": "extends TypeMirror > types ;\n", "label": 0}
{"id": 15235, "input": "<s> package org . nuxeo . ecm . platform . annotations . service ; import java . util . List ; import org . nuxeo . ecm . platform . annotations . api . AnnotationException ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; import org . nuxeo . ecm . platform . annotations . descriptors . PermissionMapperDescriptor ; public interface AnnotationConfigurationService { void setUriResolver ( UriResolver resolver ) ; UriResolver getUriResolver ( ) ; void setFilter ( URLPatternFilter filter ) ; URLPatternFilter getUrlPatternFilter ( ) ; void setMetadataMapper ( MetadataMapper mapper ) ; MetadataMapper getMetadataMapper ( ) ; void setPermissionManager ( PermissionManager manager ) ; PermissionManager getPermissionManager ( ) ; void setAnnotabilityManager ( AnnotabilityManager annotabilityManager ) ; AnnotabilityManager getAnnotabilityManager ( ) ; void addListener ( EventListener listener ) ; List < EventListener > getListeners ( ) ; void setIDGenerator ( AnnotationIDGenerator generator ) ; AnnotationIDGenerator getIDGenerator ( ) ; void setPermissionMapper ( PermissionMapperDescriptor contribution ) ; String getCreateAnnotationPermission ( ) throws AnnotationException ;", "gt": "String getDeleteAnnotationPermission ( ) throws AnnotationException ;", "prediction": "String getDeleteAnnotationPermission ( ) throws AnnotationException ;\n", "label": 1}
{"id": 5712, "input": "<s> import java . io . * ; import java . util . * ; public class Main { public static void main ( String args [ ] ) throws Exception { Scanner sc = new Scanner ( System . in ) ; sc . useDelimiter ( \"\\\\n\" ) ; Set < String > ig = new HashSet < String > ( ) ; while ( true ) { String l = sc . read ( ) ; if ( \"::\" . equals ( l ) ) break ; ig . add ( l . toLowerCase ( ) ) ; } List < V > lista = new ArrayList < V > ( ) ; while ( true ) { String l = sc . read ( ) ; if ( l == null ) break ; pal = l . split ( \"\\\\s+\" ) ; } } } class V { V ( String a , int b , int c ) { s = a ; p1 = b ; p2 = c ; } String s ;", "gt": "int p1 , p2 ;", "prediction": "V ( String a , int b , int c )\n", "label": 0}
{"id": 15241, "input": "<s> package org . eclipse . ui . internal ; interface IBackgroundSaveListener { public", "gt": "void handleBackgroundSaveStarted ( ) ;", "prediction": "void backgroundSave ( IBackgroundSaveEvent event ) ;\n", "label": 1}
{"id": 3164, "input": "<s> package org . ofbiz . base . conversion ; import java . io . IOException ; import java . io . Reader ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . sql . Blob ; import java . sql . Clob ; import java . text . DecimalFormat ; import java . text . SimpleDateFormat ; import java . util . Locale ; import java . util . UUID ; import java . util . regex . Pattern ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; public class MiscConverters implements ConverterLoader { public static final int CHAR_BUFFER_SIZE = 4096 ; public static class BlobToBlob extends AbstractConverter < Blob , Blob > { public BlobToBlob ( ) { super ( Blob . class , Blob . class ) ; } public Blob convert ( Blob obj ) throws ConversionException { try { return new javax . sql . rowset . serial . SerialBlob ( obj . getBytes ( 1 , ( int ) obj . length ( ) ) ) ; } catch ( Exception e ) { throw new ConversionException ( e ) ; } } } public static class BlobToByteArray extends AbstractConverter < Blob , byte [ ] > { public BlobToByteArray ( ) { super ( Blob . class , byte [ ] . class ) ; } public byte [ ] convert ( Blob obj ) throws ConversionException { try { return obj . getBytes ( 1 , ( int ) obj . length ( ) ) ; } catch ( Exception e ) { throw new ConversionException ( e ) ; } } } public static class ByteArrayToBlob extends AbstractConverter < byte [ ] , Blob > { public ByteArrayToBlob ( ) { super ( byte [ ] . class , Blob . class ) ; } public Blob convert ( byte [ ] obj ) throws ConversionException { try { return new javax . sql . rowset . serial . SerialBlob ( obj ) ; } catch ( Exception e ) { throw new ConversionException ( e ) ; } } } public static class ByteBufferToByteArray extends AbstractConverter < ByteBuffer , byte [ ] > { public ByteBufferToByteArray ( ) { super ( ByteBuffer . class , byte [ ] . class ) ; } public byte [ ] convert ( ByteBuffer obj ) throws ConversionException { try { return obj . hasArray ( ) ? obj . array ( ) : null ; } catch ( Exception e ) { throw new ConversionException ( e ) ; } } } public static class ByteArrayToByteBuffer extends AbstractConverter < byte [ ] , ByteBuffer > { public ByteArrayToByteBuffer ( ) { super ( byte [ ]", "gt": ". class , ByteBuffer . class ) ;", "prediction": ". class , ByteBuffer . class ) ;\n", "label": 0}
{"id": 15243, "input": "<s> package br . org . archimedes . ellipse . tests ; import static org . junit . Assert . * ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Constant ; import br . org . archimedes . ellipse . Ellipse ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . ReferencePoint ; import br . org . archimedes . model . Vector ; public class EllipseTest { private Point widthPoint1 ; private Point heightPoint1 ; private Point center1 ; private Ellipse ellipse1 ; private Point widthPoint2 ; private Point heightPoint2 ; private Point center2 ; private Ellipse ellipse2 ; @ Before public void setUp ( ) throws Exception { this . center1 = new Point ( 0 , 0 ) ; this . widthPoint1 = new Point ( 0 , 10 ) ; this . heightPoint1 = new Point ( 5 , 0 ) ; this . ellipse1 = new Ellipse ( center1 , widthPoint1 , heightPoint1 ) ; this . center2 = new Point ( 1 , 1 ) ; this . widthPoint2 = new Point ( 6 , 1 ) ; this . heightPoint2 = new Point ( 1 , 11 ) ; this . ellipse2 = new Ellipse ( center2 , widthPoint2 , heightPoint2 ) ; } @ Test ( expected = NullArgumentException . class ) public void shouldNotCreateEllipseIfCenterIsNotPassed ( ) throws Exception { new Ellipse ( null , widthPoint1 , heightPoint1 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void shouldNotCreateEllipseIfPointsAreTooCloseOfCenter ( ) throws Exception { new Ellipse ( center1 , center1 , heightPoint1 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void shouldNotCreateEllipseIfColinearPointsArePassed ( ) throws Exception { new Ellipse ( center1 , new Point ( - 5 , 0 ) , new Point ( 5 , 0 ) ) ; } @ Test public void shouldEqualsToAnotherEllipseIfAllPointsAreEquals ( ) throws Exception { Ellipse ellipse = new Ellipse ( center1 , widthPoint1 , heightPoint1 ) ; assertTrue ( ellipse1 . equals ( ellipse ) ) ; } @ Test public void shouldGetEqualSemiMajorAxis ( ) { assertEquals ( ellipse1 . getSemiMajorAxis ( ) , new Vector ( center1 , widthPoint1 ) ) ; Vector expected = new Vector ( new Point ( 1 , 1 ) , new Point ( 1 , 11 ) ) ; assertEquals ( expected , ellipse2 . getSemiMajorAxis ( ) ) ; } @ Test public void getFiTest ( ) { assertEquals ( Math . PI / 2 , ellipse1 . getFi ( ) , Constant . EPSILON ) ; assertEquals ( 0 , ellipse2 . getFi ( ) , Constant . EPSILON ) ; } @ Test public void getSemiMinorAxisTest ( ) { Vector expected = new Vector ( new Point ( 0 , 0 ) , new Point ( - 5 , 0 ) ) ; assertEquals ( expected , ellipse1 . getSemiMinorAxis ( ) ) ; expected = new Vector ( new Point ( 1 , 1 ) , new", "gt": "Point ( 6 , 1 ) ) ;", "prediction": "Point ( 1 , 11 ) ) ;\n", "label": 1}
{"id": 4816, "input": "<s> package org . parboiled . trees ; import java . util . List ; public class ImmutableTreeNode < T extends TreeNode < T > > extends ImmutableGraphNode < T > implements TreeNode < T > { private T parent ; public ImmutableTreeNode ( ) { } public ImmutableTreeNode ( List < T > children ) { super ( children ) ; acquireChildren ( ) ; } public T getParent ( ) { return parent ; } @ SuppressWarnings ( { \"unchecked\" } )", "gt": "protected void acquireChildren ( )", "prediction": "public List < T > getChildren ( )\n", "label": 0}
{"id": 15255, "input": "<s> package org . modelgoon . core . ui ; import java . util . List ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . EditPart ; import org . eclipse . gef . Request ; import org . eclipse . gef . commands . Command ; import org . eclipse . gef . commands . CompoundCommand ; import org . eclipse . gef . editpolicies . XYLayoutEditPolicy ; import org . eclipse . gef . requests . CreateRequest ; import org . eclipse . gef . requests . GroupRequest ; import org . modelgoon . core . ModelElement ; public class RootElementEditPolicy extends XYLayoutEditPolicy { RootElementEditPart < ? > editPart ; public RootElementEditPolicy ( final RootElementEditPart < ? > editPart ) { super ( ) ; this . editPart = editPart ; } @ Override protected Command createChangeConstraintCommand ( final EditPart child , final Object constraint ) { Rectangle rect = ( Rectangle ) constraint ; return new ChangeElementConstraintsCommand ( ( AbstractComponentEditPart < ? > ) child , rect ) ; } @ Override protected Command getCreateCommand", "gt": "( final CreateRequest request )", "prediction": "( )\n", "label": 1}
{"id": 4818, "input": "<s> package org . parboiled . errors ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . buffers . InputBuffer ; import org . parboiled . support . MatcherPath ; import java . util . List ; public class InvalidInputError extends BasicParseError { private final List < MatcherPath > failedMatchers ; public InvalidInputError ( InputBuffer inputBuffer , int startIndex , List < MatcherPath > failedMatchers , String errorMessage ) { super ( checkArgNotNull ( inputBuffer , \"inputBuffer\" ) , startIndex , errorMessage ) ; this . failedMatchers = checkArgNotNull ( failedMatchers , \"failedMatchers\" ) ; } public List", "gt": "< MatcherPath > getFailedMatchers ( )", "prediction": "< MatcherPath > getFailedMatchers ( )\n", "label": 0}
{"id": 15258, "input": "<s> package org . eclipse . jface . viewers ; import java . util . Arrays ; import java . util . Comparator ; public class TreePathViewerSorter extends ViewerSorter { public int category ( TreePath parentPath , Object element ) { return category ( element ) ; } public int compare ( Viewer viewer , TreePath parentPath , Object e1 , Object e2 ) { return compare ( viewer , e1 , e2 ) ; } public boolean isSorterProperty ( TreePath parentPath", "gt": ", Object element , String property )", "prediction": ")\n", "label": 1}
{"id": 9942, "input": "<s> package api . search . user ; import com . google . gson . annotations . SerializedName ; public class Results { @ SerializedName ( \"class\" ) private String userClass ; private boolean donor ; private boolean enabled ; private Number userId ; private String username ; private boolean warned ; public String getUserClass ( ) { return userClass ; } public boolean isDonor ( ) { return donor ; } public boolean isEnabled ( ) { return enabled ; } public Number getUserId ( ) { return userId ; } public String getUsername ( ) { return username ; } public Boolean getWarned ( ) { return warned ; } @ Override public String toString ( ) { return \"Results [getUserClass=\" + getUserClass ( ) + \", isDonor=\" + isDonor ( ) + \", isEnabled=\" + isEnabled ( ) + \", getUserId=\" + getUserId ( ) + \", getUsername=\" + getUsername ( ) + \", getWarned=\" +", "gt": "getWarned ( ) + \"]\" ;", "prediction": "getWarned ( ) + \"]\" ;\n", "label": 0}
{"id": 15260, "input": "<s> package org . restlet . ext . jaxrs . internal . exceptions ; import java . util . Collection ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Variant ; import javax . ws . rs . core . Response . Status ; public class NotAcceptableWebAppException extends WebApplicationException { private static final long serialVersionUID = 6895779829973209211L ; private final Collection < Variant > supported ; public NotAcceptableWebAppException ( Collection < Variant > supported ) { super ( Status . NOT_ACCEPTABLE ) ; if ( supported == null ) { throw new IllegalArgumentException (", "gt": "\"The allowed variants must not be null\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8108, "input": "<s> package org . remast . baralga . model . filter ; import com . google . common . base . Predicate ; import org . apache . commons . lang . ObjectUtils ; import org . remast . baralga . model . Project ; import org . remast . baralga . model . ProjectActivity ; public class ProjectPredicate implements Predicate < ProjectActivity > { private final Project project ; public ProjectPredicate ( final Project project ) { this . project = project ; } public boolean apply ( final ProjectActivity activity ) { if ( activity == null ) { return false ; } return ObjectUtils . equals ( this .", "gt": "project , activity . getProject ( ) ) ;", "prediction": "project , activity . getProject ( ) ) ;\n", "label": 0}
{"id": 15261, "input": "<s> package org . modelgoon . jdt . wizards ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . ui . internal . IWorkbenchGraphicConstants ; import org . eclipse . ui . internal . WorkbenchImages ; public class CreateSimpleAssociationWizard extends Wizard { SimpleAssociationWizardModel simpleAssociationWizardModel ; public CreateSimpleAssociationWizard ( final SimpleAssociationWizardModel simpleAssociationWizardModel ) { super ( ) ; this . simpleAssociationWizardModel = simpleAssociationWizardModel ; } @ Override public void addPages ( ) { super . addPages ( ) ; addPage ( new SimpleAssociationWizardPage ( this . simpleAssociationWizardModel ) ) ; setWindowTitle ( \"Create Unique Association\" ) ; setDefaultPageImageDescriptor ( WorkbenchImages . getImageDescriptor ( IWorkbenchGraphicConstants . IMG_WIZBAN_NEW_WIZ ) ) ; } public SimpleAssociationWizardModel getModel ( ) { return this . simpleAssociationWizardModel ; } @ Override", "gt": "public boolean performFinish ( )", "prediction": "public String getTitle ( )\n", "label": 1}
{"id": 8562, "input": "<s> interface Attribute < T > { } interface AttributeSet2 { < T > Attribute < ? > get ( Class < T > category ) ; } class AttributeSet2Impl implements AttributeSet2 { public Attribute get ( Class category ) { return null ; } } interface AttributeSet3 { Attribute < ? > get ( Class < ? > category ) ; } class AttributeSet3Impl implements AttributeSet3 { public Attribute get ( Class category ) { return null ; } } interface AttributeSet4 { Attribute < ? > get ( Number category ) ; } class AttributeSet4Impl implements AttributeSet4 { public Attribute get ( Number category ) { return null ; } } interface AttributeSet5 { Attribute < ? > get ( Attribute < Number > category ) ; } class AttributeSet5Impl implements AttributeSet5 { public Attribute get ( Attribute category ) { return null ; } } interface I1 < T > { void f ( Attribute < T > l ) ; } class C1 implements I1 < String > { public void f ( Attribute l ) { } void test ( ) { Attribute < Number > n = null ;", "gt": "f ( n ) ;", "prediction": "try\n", "label": 0}
{"id": 15267, "input": "<s> package episode_11_12_13 ; public enum State { INTRO", "gt": ", MAIN_MENU , GAME ;", "prediction": "}\n", "label": 1}
{"id": 2606, "input": "<s> public class T6231246 { public static void main ( String [ ] args ) { System .", "gt": "out . println ( \"Hello world\" ) ;", "prediction": "exit ( 0 ) ;\n", "label": 0}
{"id": 15273, "input": "<s> package org . fuzzydb . client . userobjects ; import java . io . Serializable ; import org . fuzzydb . core . annotations . Key ; public class SampleUniqueKeyedObject implements Serializable { private static final long serialVersionUID = 1L ; @ Key ( unique = true ) private Integer key ; private int id ; public SampleUniqueKeyedObject ( int key , int id ) { this . key = new Integer ( key ) ; this . id = id ; } public int getKey ( ) { return key . intValue ( ) ; }", "gt": "public void setKey ( int key )", "prediction": "public int getId ( )\n", "label": 1}
{"id": 3454, "input": "<s> package mage . tracker . repository ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; import javax . persistence . TypedQuery ; import mage . tracker . domain . Card ; import org . springframework . stereotype . Repository ; @ Repository public class CardRepository extends GenericRepository < Card > { @ PersistenceContext private EntityManager em ; public Card findByName ( String name ) { TypedQuery query = em . createNamedQuery ( Card .", "gt": "FIND_BY_NAME , Card . class ) ;", "prediction": "QUERY ) ;\n", "label": 0}
{"id": 15274, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public class CmapFormat2 extends CmapFormat { protected CmapFormat2 ( RandomAccessFile raf ) throws IOException { super ( raf ) ; format = 2 ; } public int getFirst ( ) { return 0 ; } public int getLast ( ) { return 0 ; } public int", "gt": "mapCharCode ( int charCode )", "prediction": "getWidth ( )\n", "label": 1}
{"id": 69, "input": "<s> package org . dawb . workbench . ui . editors ; import java . util . Arrays ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import uk . ac . diamond . scisoft . analysis . io . IMetaData ; class DataFilter extends ViewerFilter { private String searchString ; private IMetaData meta ; public void setSearchText ( String s ) { if ( s == null ) s = \"\" ; this . searchString = \".*\" + s . toLowerCase ( ) + \".*\" ; } @ Override public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( searchString == null || searchString . length ( ) == 0 ) { return true ; } final String dsName = ( ( CheckableObject ) element ) . getName ( ) ; final String name = dsName . toLowerCase ( ) ; if ( name == null || \"\" . equals ( name ) ) return true ; if ( name . matches ( searchString ) ) { return true ; } if ( name . matches ( searchString ) ) { return true ; } if ( meta != null ) { final int [ ] shape = meta . getDataShapes ( ) . get ( dsName ) ; if ( shape != null ) { final String dStr = Arrays . toString ( shape ) ; if ( dStr . matches ( searchString ) ) { return true ; } } } return false ; } public void", "gt": "setMetaData ( IMetaData metaData )", "prediction": "dispose ( )\n", "label": 0}
{"id": 15275, "input": "<s> package org . apache . lucene . queryParser . standard . config ; import java . util . HashMap ; import java . util . Map ; import org . apache . lucene . document . DateTools ; import org . apache . lucene . document . DateTools . Resolution ; import org . apache . lucene . util . AttributeImpl ; public class FieldDateResolutionMapAttributeImpl extends AttributeImpl implements FieldDateResolutionMapAttribute { private static final long serialVersionUID = - 2104763012523049527L ; private Map < CharSequence , DateTools . Resolution > dateRes = new HashMap < CharSequence , DateTools . Resolution > ( ) ; public FieldDateResolutionMapAttributeImpl ( ) { } public void setFieldDateResolutionMap ( Map < CharSequence , DateTools . Resolution > dateRes ) { this . dateRes = dateRes ; } public Map < CharSequence , Resolution > getFieldDateResolutionMap ( ) { return this . dateRes ; } public void clear ( ) { throw", "gt": "new UnsupportedOperationException ( ) ;", "prediction": "new UnsupportedOperationException ( ) ;\n", "label": 1}
{"id": 1243, "input": "<s> package org . ofbiz . workeffort . workeffort ; import java . util . List ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; public class WorkEffortWorker { public static final String module = WorkEffortWorker . class . getName ( ) ; public static List < GenericValue > getLowestLevelWorkEfforts ( Delegator delegator , String workEffortId , String workEffortAssocTypeId ) { return getLowestLevelWorkEfforts ( delegator , workEffortId , workEffortAssocTypeId , \"workEffortIdFrom\" , \"workEffortIdTo\" ) ; } public static List < GenericValue > getLowestLevelWorkEfforts ( Delegator delegator , String workEffortId , String workEffortAssocTypeId , String left , String right ) { if ( left == null ) { left = \"workEffortIdFrom\" ; } if ( right == null ) { right = \"workEffortIdTo\" ; } List < GenericValue > workEfforts = FastList . newInstance ( ) ; try { EntityConditionList < EntityExpr > exprsLevelFirst = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( left , workEffortId ) , EntityCondition . makeCondition ( \"workEffortAssocTypeId\" , workEffortAssocTypeId ) ) , EntityOperator . AND ) ; List < GenericValue > childWEAssocsLevelFirst = delegator . findList ( \"WorkEffortAssoc\" , exprsLevelFirst , null , null , null , true ) ; for ( GenericValue childWEAssocLevelFirst : childWEAssocsLevelFirst ) { EntityConditionList < EntityExpr > exprsLevelNext = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( left , childWEAssocLevelFirst . get ( right ) ) , EntityCondition . makeCondition ( \"workEffortAssocTypeId\" , workEffortAssocTypeId ) ) , EntityOperator . AND ) ; List < GenericValue > childWEAssocsLevelNext = delegator . findList ( \"WorkEffortAssoc\" , exprsLevelNext , null , null , null , true ) ; while ( UtilValidate . isNotEmpty ( childWEAssocsLevelNext ) ) { List < GenericValue > tempWorkEffortList = FastList . newInstance ( ) ; for ( GenericValue childWEAssocLevelNext : childWEAssocsLevelNext ) { EntityConditionList < EntityExpr > exprsLevelNth = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( left , childWEAssocLevelNext . get ( right ) ) , EntityCondition . makeCondition ( \"workEffortAssocTypeId\" , workEffortAssocTypeId ) ) , EntityOperator . AND ) ; List < GenericValue > childWEAssocsLevelNth = delegator . findList ( \"WorkEffortAssoc\" , exprsLevelNth", "gt": ", null , null , null , true ) ;", "prediction": ", null , null , null , true ) ;\n", "label": 0}
{"id": 15283, "input": "<s> package org . restlet . ext . wadl ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . data . Language ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . Engine ; import org . restlet . ext . xml . DomRepresentation ; import org . restlet . ext . xml . SaxRepresentation ; import org . restlet . ext . xml . TransformRepresentation ; import org . restlet . ext . xml . XmlWriter ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . Representation ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . DefaultHandler ; public class WadlRepresentation extends SaxRepresentation { private static class ContentReader extends DefaultHandler implements LexicalHandler { public enum MixedContentState { CDATA , COMMENT , ELEMENT , ENTITY , NONE , TEXT } public enum State { APPLICATION , DOCUMENTATION , FAULT , GRAMMARS , INCLUDE , LINK , METHOD , NONE , OPTION , PARAMETER , REPRESENTATION , REQUEST , RESOURCE , RESOURCES , RESOURCETYPE , RESPONSE } private ApplicationInfo currentApplication ; private DocumentationInfo currentDocumentation ; private GrammarsInfo currentGrammars ; private IncludeInfo currentInclude ; private LinkInfo currentLink ; private MethodInfo currentMethod ; private CDATASection currentMixedContentCDataSection ; private Node currentMixedContentNode ; private OptionInfo currentOption ; private ParameterInfo currentParameter ; private RepresentationInfo currentRepresentation ; private RequestInfo currentRequest ; private ResourcesInfo currentResources ; private final List < ResourceInfo > currentResourcesList ; private ResourceTypeInfo currentResourceType ; private ResponseInfo currentResponse ; private Document mixedContentDocument ; private final List < MixedContentState > mixedContentStates ; private Node mixedContentTopNode ; private Map < String , String > namespaces ; private final List < State > states ; private final WadlRepresentation wadlRepresentation ; public ContentReader ( WadlRepresentation wadlRepresentation ) { this . states = new ArrayList < State > ( ) ; this . states . add ( State . NONE ) ; this . mixedContentStates = new ArrayList < MixedContentState > ( ) ; this . mixedContentStates . add ( MixedContentState . NONE ) ; this . currentApplication = null ; this . currentDocumentation = null ; this . currentGrammars = null ; this . currentInclude = null ; this . currentLink = null ; this . currentMethod = null ; this . currentOption = null ; this . currentParameter = null ; this . currentRepresentation = null ; this . currentRequest = null ; this . currentResourcesList = new ArrayList < ResourceInfo > ( ) ; this . currentResources = null ; this . currentResourceType = null ; this . currentResponse = null ; try { this . mixedContentDocument = new DomRepresentation ( MediaType . TEXT_XML ) . getDocument ( ) ; } catch ( IOException e ) { } this . currentMixedContentCDataSection = null ; this . namespaces = new HashMap < String , String > ( ) ; this . wadlRepresentation = wadlRepresentation ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( getState ( ) == State . DOCUMENTATION ) { if ( getMixedContentState ( ) == MixedContentState . CDATA ) { this . currentMixedContentCDataSection . appendData ( new String ( ch , start , length ) ) ; } else if ( getMixedContentState ( ) != MixedContentState . ENTITY ) { this . currentMixedContentNode . appendChild ( this . mixedContentDocument . createTextNode ( new String ( ch , start , length ) ) ) ; } } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( getState ( ) == State . DOCUMENTATION ) { this . currentMixedContentNode . appendChild ( this . mixedContentDocument . createComment ( new String ( ch , start , length ) ) ) ; } } public void endCDATA ( ) throws SAXException { if ( getState ( ) == State . DOCUMENTATION ) { popMixedContentState ( ) ; } } @ Override public void endDocument ( ) throws SAXException { popState ( ) ; if ( this . namespaces != null && ! this . namespaces . isEmpty ( ) && this . currentApplication != null ) { this . currentApplication . setNamespaces ( namespaces ) ; } this . wadlRepresentation . setApplication ( this . currentApplication ) ; } public void endDTD ( ) throws SAXException { } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( uri . equalsIgnoreCase ( APP_NAMESPACE ) ) { if ( localName . equals ( \"application\" ) ) { popState ( ) ; } else if ( localName . equals ( \"doc\" ) ) { this . currentDocumentation . setMixedContent ( mixedContentTopNode ) ; popState ( ) ; } else if ( localName . equals ( \"fault\" ) ) { popState ( ) ; } else if ( localName . equals ( \"grammars\" ) ) { popState ( ) ; } else if ( localName . equals ( \"include\" ) ) { popState ( ) ; } else if ( localName . equals ( \"link\" ) ) { popState ( ) ; } else if ( localName . equals ( \"method\" ) ) { popState ( ) ; } else if ( localName . equals ( \"option\" ) ) { popState ( ) ; } else if ( localName . equals ( \"param\" ) ) { popState ( ) ; } else if ( localName . equals ( \"representation\" ) ) { popState ( ) ; } else if ( localName . equals ( \"request\" ) ) { popState ( ) ; } else if ( localName . equals ( \"resource\" ) ) { this . currentResourcesList . remove ( 0 ) ; popState ( ) ; } else if ( localName .", "gt": "equals ( \"resources\" ) )", "prediction": "equals ( \"resourceType\" ) )\n", "label": 1}
{"id": 9730, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . Precedes ; import org . jjflyboy . tjpeditor . project . ProjectPackage ;", "gt": "public class PrecedesImpl extends TaskAttributeImpl implements Precedes", "prediction": "import org . jjflybreak . antlr . util . AntlrUtil ;\n", "label": 0}
{"id": 15294, "input": "<s> package org . eclipse . ui ; public interface IWorkbenchPart2 extends IWorkbenchPart { public String getPartName ( ) ; public", "gt": "String getContentDescription ( ) ;", "prediction": "void setPartName ( String partName ) ;\n", "label": 1}
{"id": 4107, "input": "<s> package org . ofbiz . base . container ; import org . ofbiz . base . util . CachedClassLoader ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . start . Classpath ; import java . net . URL ; public class ClassLoaderContainer implements Container { public static final String module = ClassLoaderContainer . class . getName ( ) ; protected static CachedClassLoader cl = null ; private String name ; @ Override public void init ( String [ ] args , String name , String configFile ) throws ContainerException { this . name = name ; ClassLoader parent = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( parent == null ) { parent = Classpath . class . getClassLoader ( ) ; } if ( parent == null ) { parent = ClassLoader . getSystemClassLoader ( ) ; } cl = new CachedClassLoader ( new URL [ 0 ] , parent ) ; Thread . currentThread ( ) . setContextClassLoader ( cl ) ; Debug . logInfo ( \"CachedClassLoader created\" , module ) ; } public boolean start ( ) throws ContainerException { return true ; } public void stop ( ) throws ContainerException { }", "gt": "public String getName ( )", "prediction": "}\n", "label": 0}
{"id": 15300, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import org . apache . lucene . store . IndexInput ; abstract class FormatPostingsPositionsConsumer { abstract void addPosition ( int position , byte [ ] payload , int payloadOffset ,", "gt": "int payloadLength ) throws IOException ;", "prediction": "int payloadLength ) ;\n", "label": 1}
{"id": 529, "input": "<s> package org . ofbiz . sql . test ; import java . util . HashMap ; import java . util . Map ; public abstract class Recorder < I > { public Map < I , Integer > counts = new HashMap < I , Integer > ( ) ; protected void record ( I key ) { Integer count = counts . get ( key ) ; if ( count == null ) { counts . put ( key , Integer . valueOf", "gt": "( 1 ) ) ;", "prediction": "( 1 ) ) ;\n", "label": 0}
{"id": 15301, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . core . api . Blob ; public class PictureViewImpl implements PictureView { int width ; int height ; String title ; String description ; String tag ; String filename ; Object content ; Blob blob ; public PictureViewImpl ( ) { } public PictureViewImpl ( Map < String , Serializable > m ) { title = ( String ) m . get ( PictureView . FIELD_TITLE ) ; description = ( String ) m . get ( PictureView . FIELD_DESCRIPTION ) ; tag = ( String ) m . get ( PictureView . FIELD_TAG ) ; filename = ( String ) m . get ( PictureView . FIELD_FILENAME ) ; blob = ( Blob ) m . get ( PictureView . FIELD_CONTENT ) ; Integer w = ( Integer ) m . get ( PictureView . FIELD_WIDTH ) ; if ( w != null ) { width = w ; } Integer h = ( Integer ) m . get ( PictureView . FIELD_HEIGHT ) ; if ( h != null ) { height = h ; } } @ Override public int getWidth ( ) { return width ; } @ Override public void setWidth ( int width ) { this . width = width ; } @ Override public String getTitle ( ) { return title ; } @ Override public void setTitle ( String title ) { this . title = title ; } @ Override public String getDescription ( ) { return description ; } @ Override public void setDescription ( String description ) { this . description = description ; } @ Override public String getTag ( ) { return tag ; } @ Override public void setTag ( String tag ) { this . tag = tag ; } @ Override public String getFilename ( ) { return filename ; } @ Override public void setFilename ( String filename ) { this . filename = filename ; } @ Override public Object getContent ( ) { return content ; } @ Override public void setContent ( Object content ) { this . content = content ; } @ Override public int getHeight ( ) { return height ; } @ Override public void setHeight ( int height ) { this . height = height ; } @ Override public Blob getBlob ( ) { return blob ; } @ Override public void setBlob ( Blob blob ) { this . blob = blob ; } @ Override public Map < String , Serializable > asMap ( ) { Map < String , Serializable > m = new HashMap < String , Serializable > ( ) ; m . put ( PictureView . FIELD_TITLE , getTitle ( ) ) ; m . put ( PictureView . FIELD_DESCRIPTION , getDescription ( ) ) ; m . put ( PictureView . FIELD_TAG , getTag ( ) ) ; m . put ( PictureView . FIELD_HEIGHT , getHeight ( ) ) ; m . put ( PictureView .", "gt": "FIELD_WIDTH , getWidth ( ) ) ;", "prediction": "FIELD_WIDTH , getWidth ( ) ) ;\n", "label": 1}
{"id": 5153, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public abstract class JavadocTester { protected static final String FS = System . getProperty ( \"file.separator\" ) ; protected static final String PS = System . getProperty ( \"path.separator\" ) ; protected static final String NL = System . getProperty ( \"line.separator\" ) ; protected static final String SRC_DIR = System . getProperty ( \"test.src\" , \".\" ) ; protected static final String JAVA_VERSION = System . getProperty ( \"java.version\" ) ; protected static final String [ ] [ ] NO_TEST = new String [ ] [ ] { } ; public static final String ERROR_OUTPUT = \"ERROR_OUTPUT\" ; public static final String NOTICE_OUTPUT = \"NOTICE_OUTPUT\" ; public static final String WARNING_OUTPUT = \"WARNING_OUTPUT\" ; public static final String STANDARD_OUTPUT = \"STANDARD_OUTPUT\" ; public static final String DEFAULT_DOCLET_CLASS = \"com.sun.tools.doclets.formats.html.HtmlDoclet\" ; public static final String DEFAULT_DOCLET_CLASS_OLD = \"com.sun.tools.doclets.standard.Standard\" ; public StringWriter errors ; public StringWriter notices ; public StringWriter warnings ; public StringBuffer standardOut ; private static int numTestsRun = 0 ; private static int numTestsPassed = 0 ; private static int javadocRunNum = 0 ; protected boolean exactNewlineMatch = true ; public JavadocTester ( ) { } public abstract String getBugId ( ) ; public abstract String getBugName ( ) ; public static int run ( JavadocTester tester , String [ ] args , String [ ] [ ] testArray , String [ ] [ ] negatedTestArray ) { int returnCode = tester . runJavadoc ( args ) ; tester . runTestsOnHTML ( testArray , negatedTestArray ) ; return returnCode ; } public int runJavadoc ( String [ ] args ) { float javaVersion = Float . parseFloat ( JAVA_VERSION . substring ( 0 , 3 ) ) ; String docletClass = javaVersion < 1.5 ? DEFAULT_DOCLET_CLASS_OLD : DEFAULT_DOCLET_CLASS ; return runJavadoc ( docletClass , args ) ; } public int runJavadoc ( String docletClass , String [ ] args ) { javadocRunNum ++ ; if ( javadocRunNum == 1 ) { System . out . println ( \"\\n\" + \"Running javadoc...\" ) ; } else { System . out . println ( \"\\n\" + \"Running javadoc (run \" + javadocRunNum + \")...\" ) ; } initOutputBuffers ( ) ; ByteArrayOutputStream stdout = new ByteArrayOutputStream ( ) ; PrintStream prev = System . out ; System . setOut ( new PrintStream ( stdout ) ) ; int returnCode = com . sun . tools . javadoc . Main . execute ( getBugName ( ) , new PrintWriter ( errors , true ) , new PrintWriter ( warnings , true ) , new PrintWriter ( notices , true ) , docletClass , getClass ( ) . getClassLoader ( ) , args ) ; System . setOut ( prev ) ; standardOut = new StringBuffer ( stdout . toString ( ) ) ; printJavadocOutput ( ) ; return returnCode ; } private void initOutputBuffers ( ) { errors = new StringWriter ( ) ; notices = new StringWriter ( ) ; warnings = new StringWriter ( ) ; } public void runTestsOnHTML ( String [ ] [ ] testArray , String [ ] [ ] negatedTestArray ) { runTestsOnHTML ( testArray , false ) ; runTestsOnHTML ( negatedTestArray , true ) ; } private void runTestsOnHTML ( String [ ] [ ]", "gt": "testArray , boolean isNegated )", "prediction": "testArray , String [ ] [ ] negatedTestArray )\n", "label": 0}
{"id": 15304, "input": "<s> package com . corundumstudio . socketio . parser ; import java . io . IOException ; import org . junit . Assert ; import org . junit . Test ; public class DecoderConnectionPacketTest extends DecoderBaseTest { @ Test public void testDecodeHeartbeat ( ) throws IOException { Packet packet = decoder . decodePacket ( \"2:::\" , null ) ; Assert . assertEquals ( PacketType . HEARTBEAT , packet . getType ( ) ) ; } @ Test public void testDecode ( ) throws IOException { Packet packet = decoder . decodePacket ( \"1::/tobi\" , null ) ; Assert . assertEquals ( PacketType . CONNECT , packet . getType ( ) ) ; Assert . assertEquals ( \"/tobi\" , packet . getEndpoint ( ) ) ; } @ Test public void testDecodeWithQueryString ( ) throws IOException { Packet packet = decoder . decodePacket ( \"1::/test:?test=1\" , null ) ; Assert . assertEquals ( PacketType . CONNECT , packet . getType ( ) ) ; Assert . assertEquals ( \"/test\" , packet . getEndpoint ( ) ) ; Assert . assertEquals ( \"?test=1\" , packet . getQs ( ) ) ; } @ Test public void testDecodeDisconnection ( ) throws IOException { Packet packet = decoder . decodePacket ( \"0::/woot\" , null ) ; Assert . assertEquals ( PacketType . DISCONNECT , packet .", "gt": "getType ( ) ) ;", "prediction": "getType ( ) ) ;\n", "label": 1}
{"id": 3349, "input": "<s> package jns . element ; import jns . trace . Traceable ; public abstract class Element extends Traceable { public", "gt": "abstract void update ( ) ;", "prediction": "Element ( )\n", "label": 0}
{"id": 15307, "input": "<s> import java . util . * ; public class C { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numPlayers = in . nextInt ( ) ; in . skip ( \" \" ) ; while ( numPlayers != 0 ) { String rolls = in . nextLine ( ) ; ArrayList < Integer > players = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < numPlayers ; i ++ ) { players . add ( 3 ) ; } int currPlayer = 1 ; int middle = 0 ; int i = 0 ; while ( i < rolls . length ) { char roll1 = rolls . charAt ( i ) ; i ++ ; char roll2 = rolls . charAt ( i ) ; i ++ ; char roll3 = rolls . charAt ( i ) ; i ++ ; } numPlayers = in . nextInt ( ) ; in . skip ( \" \" ) ; } } public static action ( ArrayList < Integer > players , char roll ) { if ( roll == \"L\" ) { giveLeft ( players , currPlayer ) ; } else if ( roll == \"R\" ) { giveRight ( players , currPlayer ) ; } else { players . set ( currPlayer - 1 , players . get ( currPlayer - 1 ) - 1 ) ; } } public static class Game { public ArrayList < Integer > players ; public int middle ; public int currPlayer ; public Game ( int numPlayers ) { this . players = new ArrayList < Integer > ( numPlayers ) ; for ( int i = 0 ; i < numPlayers ; i ++ ) { this . players . add ( 3 ) ; } this . middle = 0 ; this . currPlayer = 0 ; } public void simulate ( String rolls , int gameNumber ) { int i = 0 ; System . out . printf ( \"Game %d:\\n\" , gameNumber ) ; while ( i < rolls . length ) { ArrayList < Character > playerRolls = new ArrayList < Character > ( 3 ) ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; this . processRolls ( playerRolls ) ; this . nextPlayer ( ) ; if ( this . winCondition ( ) ) this . displayWin ( ) ; break ; } this . displayEnd ( ) ; } private void displayWin ( ) { for", "gt": "( int i = 0 ;", "prediction": "( int i = 0 ;\n", "label": 1}
{"id": 7202, "input": "<s> package org . gk . engine . client . utils ; import org . gk . engine . client . event . IEventConstants ; import org . gk . engine . client . exception . GKEngineException ; import org . gk . engine . client . i18n . EngineMessages ; import org . gk . ui . client . com . panel . gkAccordionLayout ; import com . extjs . gxt . ui . client . Style . Orientation ; import com . extjs . gxt . ui . client . widget . Layout ; import com . extjs . gxt . ui . client . widget . layout . BorderLayout ; import com . extjs . gxt . ui . client . widget . layout . BoxLayout ; import com . extjs . gxt . ui . client . widget . layout . BoxLayout . BoxLayoutPack ; import com . extjs . gxt . ui . client . widget . layout . CenterLayout ; import com . extjs . gxt . ui . client . widget . layout . FitLayout ; import com . extjs . gxt . ui . client . widget . layout . FlowLayout ; import com . extjs . gxt . ui . client . widget . layout . FormLayout ; import com . extjs . gxt . ui . client . widget . layout . HBoxLayout ; import com . extjs . gxt . ui . client . widget . layout . HBoxLayout . HBoxLayoutAlign ; import com . extjs . gxt . ui . client . widget . layout . RowLayout ; import com . extjs . gxt . ui . client . widget . layout . TableLayout ; import com . extjs . gxt . ui . client . widget . layout . VBoxLayout ; import com . extjs . gxt . ui . client . widget . layout . VBoxLayout . VBoxLayoutAlign ; public class LayoutUtils { private final static String FLOWLAYOUT = \"flowlayout|flow\" ; private final static String FITLAYOUT = \"fitlayout|fit\" ; private final static String HROWLAYOUT = \"hrow\" ; private final static String VROWLAYOUT = \"vrow\" ; private final static String BORDERLAYOUT = \"border\" ; private final static String FORMLAYOUT = \"formlayout|form\" ; private final static String ACCORDIONLAYOUT = \"accordionlayout|accordion|acc\" ; private final static String CENTERLAYOUT = \"center\" ; private final static String TABLELAYOUT = \"table(,\\\\d+)?\" ; public final static String VBOXLAYOUT = \"vbox(:\\\\w+(,\\\\w+)?)?\" ; public final static String HBOXLAYOUT = \"hbox(:\\\\w+(,\\\\w+)?)?\" ; private final static String HBOXLAYOUTALIGN = \"TOP|MIDDLE|BOTTOM|STRETCH|STRETCHMAX\" ; private final static String VBOXLAYOUTALIGN = \"LEFT|MIDDLE|RIGHT|STRETCH|STRETCHMAX\" ; private final static String BOXLAYOUTPACK = \"START|CENTER|END\" ; public static Layout getPageLayout ( String layoutName ) { Layout layout = createCommonLayout ( layoutName ) ; if ( layout == null ) { if ( layoutName . matches ( TABLELAYOUT ) ) { layout = createTableLayout ( layoutName ) ; } else if ( layoutName . matches ( HBOXLAYOUT ) ) { layout = createHBoxLayout ( layoutName ) ; } else if ( layoutName . matches ( VBOXLAYOUT ) ) { layout = createVBoxLayout ( layoutName ) ; } } if ( layout == null ) { throw new GKEngineException ( EngineMessages . msg . error_layoutNotCreate ( layoutName ) ) ; } return layout ; } private static Layout createCommonLayout ( String layoutName ) {", "gt": "Layout layout = null ;", "prediction": "Layout layout = createCommonLayout ( layoutName ) ;\n", "label": 0}
{"id": 15308, "input": "<s> package org . eclipse . ui . tests . commands ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . ui . handlers . HandlerUtil ; import org . eclipse . ui . handlers . RadioState ; public class RadioStateHandler extends AbstractHandler { public Object execute ( ExecutionEvent event ) throws ExecutionException { if ( HandlerUtil . matchesRadioState ( event ) ) return null ; String currentState = event . getParameter ( RadioState . PARAMETER_ID ) ; HandlerUtil . updateRadioState (", "gt": "event . getCommand ( ) , currentState ) ;", "prediction": "event ) ;\n", "label": 1}
{"id": 3504, "input": "<s> package com . sgrif . poker ; import java . util . Locale ; import static com . sgrif . poker . Game . * ; public class Main { private static int [ ] deck = Deck . getDeck ( ) ; public static void main ( String [ ] args ) { bench ( false , 1 ) ; } private static void test1 ( ) { new Game ( 0 , 8 , 0 ) ; } private static void test2 ( ) { g . getRanking5 ( deck [ 0 ] , deck [ 1 ] , deck [ 2 ] , deck [ 3 ] , deck [ 13 ] ) ; } private static void bench ( boolean comp , int times ) { long best1 = 0 ; long best2 = 0 ; for ( int x = 0 ; x < 100 ; x ++ ) { long time_before = System . nanoTime ( ) ; for ( int y = 0 ; y < times ; y ++ ) { test1 ( ) ; } long time_after = System . nanoTime ( ) ; long t = time_after - time_before ; if ( t < best1 || best1 == 0 ) { best1 = t ; } } best1 /= times ; int c1 = 0 ; String [ ] s = { \"nanoseconds\" , \"microseconds\" , \"milliseconds\" , \"seconds\" } ; while ( best1 >= 1000 ) { best1 /= 1000 ; c1 += 1 ; } System . out . printf ( Locale . US , \"Case 1 took %1$,d %2$s %n\" , best1 , s [ c1 ] ) ; if ( comp ) { for ( int x = 0 ; x < 100 ; x ++ ) { long time_before = System . nanoTime ( ) ; for ( int y = 0 ; y < times ; y ++ ) { test2 ( ) ; } long time_after = System . nanoTime ( ) ; long t = time_after - time_before ; if ( t < best2 || best2 == 0 ) { best2 = t ; } } best2 /= times ; int c2 = 0 ; while ( best2 >= 1000 ) { best2 /= 1000 ; c2 += 1 ; } System . out . printf ( Locale . US , \"Case 2 took %1$,d %2$s %n\" , best2 , s [ c2 ] ) ; } } private static void memBench ( ) { Object o = new Game (", "gt": "2 , 2 , 5 ) ;", "prediction": "0 , 8 , 0 ) ;\n", "label": 0}
{"id": 15310, "input": "<s> package org . eclipse . jface . bindings . keys . formatting ; import java . util . HashMap ; import java . util . ResourceBundle ; import org . eclipse . jface . bindings . keys . IKeyLookup ; import org . eclipse . jface . bindings . keys . KeyLookupFactory ; import org . eclipse . jface . bindings . keys . KeySequence ; import org . eclipse . jface . bindings . keys . KeyStroke ; import org . eclipse . jface . util . Util ; public final class NativeKeyFormatter extends AbstractKeyFormatter { private final static String CARBON_KEY_DELIMITER_KEY = \"CARBON_KEY_DELIMITER\" ; private final static HashMap CARBON_KEY_LOOK_UP = new HashMap ( ) ; private final static ResourceBundle RESOURCE_BUNDLE ; private final static String WIN32_KEY_STROKE_DELIMITER_KEY = \"WIN32_KEY_STROKE_DELIMITER\" ; static { RESOURCE_BUNDLE = ResourceBundle . getBundle ( NativeKeyFormatter . class . getName ( ) ) ; final String carbonBackspace = \"\u232b\" ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . BS_NAME , carbonBackspace ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . BACKSPACE_NAME , carbonBackspace ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . CR_NAME , \"\u21a9\" ) ; final String carbonDelete = \"\u2326\" ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . DEL_NAME , carbonDelete ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . DELETE_NAME , carbonDelete ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ALT_NAME , \"\u2325\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . COMMAND_NAME , \"\u2318\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . CTRL_NAME , \"\u2303\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . SHIFT_NAME , \"\u21e7\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_DOWN_NAME , \"\u2193\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_LEFT_NAME , \"\u2190\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_RIGHT_NAME , \"\u2192\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_UP_NAME , \"\u2191\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . END_NAME , \"\u2198\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . NUMPAD_ENTER_NAME , \"\u2324\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . HOME_NAME , \"\u2196\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . PAGE_DOWN_NAME , \"\u21df\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . PAGE_UP_NAME , \"\u21de\" ) ; } public final String format ( final int key ) { final IKeyLookup lookup = KeyLookupFactory . getDefault ( ) ; final String name = lookup . formalNameLookup ( key ) ; if ( Util . isMac ( ) ) { String formattedName = ( String ) CARBON_KEY_LOOK_UP . get ( name ) ; if ( formattedName != null ) { return formattedName ; } } return super . format ( key ) ; } protected String getKeyDelimiter ( ) { if ( Util . isMac ( ) ) { return Util . translateString ( RESOURCE_BUNDLE , CARBON_KEY_DELIMITER_KEY , Util . ZERO_LENGTH_STRING ) ; } return Util . translateString ( RESOURCE_BUNDLE , KEY_DELIMITER_KEY , KeyStroke . KEY_DELIMITER ) ; } protected String getKeyStrokeDelimiter ( ) { if ( Util . isWindows ( ) ) { return Util . translateString ( RESOURCE_BUNDLE , WIN32_KEY_STROKE_DELIMITER_KEY , KeySequence . KEY_STROKE_DELIMITER ) ; } return Util . translateString ( RESOURCE_BUNDLE , KEY_STROKE_DELIMITER_KEY , KeySequence . KEY_STROKE_DELIMITER ) ; } protected int [ ] sortModifierKeys ( final int modifierKeys ) { final IKeyLookup lookup = KeyLookupFactory . getDefault ( ) ; final int [ ] sortedKeys = new int [ 4 ] ; int index = 0 ; if ( Util . isWindows ( ) ) { if ( ( modifierKeys & lookup . getCtrl ( ) ) != 0 ) { sortedKeys [ index ++ ] = lookup . getCtrl ( ) ; } if ( ( modifierKeys & lookup . getAlt (", "gt": ") ) != 0 )", "prediction": ") ) != 0 )\n", "label": 1}
{"id": 7889, "input": "<s> public enum TestEnum6 { AAA ( TestEnum6 . AAA ) ;", "gt": "TestEnum6 ( TestEnum6 e )", "prediction": "}\n", "label": 0}
{"id": 15319, "input": "<s> package org . fuzzydb . attrs ; import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; import org . fuzzydb . attrs . bool . BooleanPriority ; import org . fuzzydb . attrs . bool . BooleanScorer ; import org . fuzzydb . attrs . dimensions . DimensionPriority ; import org . fuzzydb . attrs . dimensions . Dimensions ; import org . fuzzydb . attrs . enums . EnumDefinition ; import org . fuzzydb . attrs . enums . EnumExclusiveScorerExclusive ; import org . fuzzydb . attrs . enums . EnumExclusiveScorerPreference ; import org . fuzzydb . attrs . enums . EnumSingleValueScorer ; import org . fuzzydb . attrs . enums . MultiEnumScorer ; import org . fuzzydb . attrs . enums . OptionsScorer ; import org . fuzzydb . attrs . enums . SeatsScorer ; import org . fuzzydb . attrs . enums . SingleEnumPriority ; import org . fuzzydb . attrs . internal . ScoreConfiguration ; import org . fuzzydb . attrs . location . LocationAndRangeScorer ; import org . fuzzydb . attrs . location . PathDeviationScorer ; import org . fuzzydb . attrs . location . VectorDistanceScorer ; import org . fuzzydb . attrs . simple . FloatPriority ; import org . fuzzydb . attrs . simple . FloatRangePreferenceScorer ; import org . fuzzydb . attrs . simple . SimilarFloatValueScorer ; import org . fuzzydb . attrs . simple . WeightedSumScorer ; import org . fuzzydb . dto . dimensions . IDimensions ; import org . fuzzydb . util . AsymptoticScoreMapper ; import org . fuzzydb . util . LinearScoreMapper ; import com . thoughtworks . xstream . XStream ; public class XMLAliases { static private Map < String , Class < ? > > scorerAliases = new HashMap < String , Class < ? > > ( ) ; static { initScorerAliases ( ) ; } private static void initScorerAliases ( ) { scorerAliases . put ( \"BooleanScorer\" , BooleanScorer . class ) ; scorerAliases . put ( \"EnumExclusiveScorerExclusive\" , EnumExclusiveScorerExclusive . class ) ; scorerAliases . put ( \"EnumMatchScorer\" , EnumExclusiveScorerExclusive . class ) ; scorerAliases . put ( \"EnumScoresMapScorer\" , EnumExclusiveScorerPreference . class ) ; scorerAliases . put ( \"EnumSingleValueScorer\" , EnumSingleValueScorer . class ) ; scorerAliases . put ( \"MultiEnumScorer\" , MultiEnumScorer . class ) ; scorerAliases . put ( \"OptionsScorer\" , OptionsScorer . class ) ; scorerAliases . put ( \"SimilarFloatValueScorer\" , SimilarFloatValueScorer . class ) ; scorerAliases . put ( \"FloatRangePreferenceScorer\" , FloatRangePreferenceScorer . class ) ; scorerAliases . put ( \"WeightedSumScorer\" , WeightedSumScorer . class ) ; scorerAliases . put ( \"LocationAndRangeScorer\" , LocationAndRangeScorer . class ) ; scorerAliases . put ( \"PathDeviationScorer\" , PathDeviationScorer . class ) ; scorerAliases . put ( \"VectorDistanceScorer\" , VectorDistanceScorer . class ) ; scorerAliases . put ( \"SeatsScorer\" , SeatsScorer . class ) ; scorerAliases . put ( \"PathDeviationScorer\" , PathDeviationScorer . class ) ; scorerAliases . put ( \"LinearScoreMapper\" , LinearScoreMapper . class ) ; scorerAliases . put ( \"AsymptoticScoreMapper\" , AsymptoticScoreMapper . class ) ; } public static Map < String , Class < ? > > getScorerAliases ( ) { return scorerAliases ; } public static void applyScorerAliases ( XStream xStream ) { xStream . alias ( \"ScoreConfiguration\" , ScoreConfiguration . class ) ; xStream . useAttributeFor ( ScoreConfiguration . class , \"name\" ) ; xStream . addImplicitCollection ( ScoreConfiguration . class , \"scorersList\" ) ; xStream . alias ( \"Scorer\" , Scorer . class ) ; xStream . useAttributeFor ( Scorer . class , \"name\" ) ; for ( Entry < String , Class < ? > > entry : getScorerAliases ( ) . entrySet ( ) ) { xStream . alias ( entry . getKey ( ) , entry . getValue ( ) ) ; } } static public void applyEnumAliases ( XStream xStream ) { xStream . alias ( \"EnumDefinition\" , EnumDefinition . class ) ; xStream . useAttributeFor ( EnumDefinition . class , \"name\" ) ; xStream . addImplicitCollection ( EnumDefinition . class , \"strValues\" ) ; } static public void applyIndexConfigAliases ( XStream xStream ) { xStream . alias ( \"ManualPriorities\" , ManualIndexStrategy . class ) ; xStream . useAttributeFor ( ManualIndexStrategy . class , \"name\" ) ; xStream . addImplicitCollection ( ManualIndexStrategy . class , \"priorities\" ) ; xStream . alias ( \"Priority\" , AttributePriority . class ) ; xStream . alias ( \"BooleanPriority\" , BooleanPriority . class ) ; xStream . alias ( \"SingleEnumPriority\" , SingleEnumPriority . class ) ; xStream . alias", "gt": "( \"FloatPriority\" , FloatPriority . class ) ;", "prediction": "( \"MultiEnumPriority\" , MultiEnumPriority . class ) ;\n", "label": 1}
{"id": 10129, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Enderman ; public interface LizaEnderman extends Enderman { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte", "gt": "> transparent , int maxDistance ) ;", "prediction": "> transparent , int maxDistance ) ;\n", "label": 0}
{"id": 15323, "input": "<s> package org . nlogo . extensions . sound ; public class Dump implements org . nlogo . api . Reporter { public String getAgentClassString ( ) { return \"OTP\" ; } public org . nlogo . api . Syntax getSyntax ( ) { return org . nlogo . api . Syntax . reporterSyntax ( org . nlogo . api . Syntax . StringType ( ) ) ; } public boolean getSwitchesBoolean ( ) { return false ; } public org . nlogo . api . Reporter newInstance ( String name ) { return new Dump ( ) ; } public Object report ( org . nlogo . api . Argument args [ ] , org . nlogo . api . Context context ) { return SoundExtension", "gt": ". dump ( ) ;", "prediction": ". report ( args , context ) ;\n", "label": 1}
{"id": 3144, "input": "<s> class Base { void m ( ) { } } class OverrideStatic extends Base {", "gt": "static void m ( )", "prediction": "}\n", "label": 0}
{"id": 15324, "input": "<s> package org . eclipse . ui . internal . activities . ws ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . ui . activities . ITriggerPointAdvisor ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . internal . registry . RegistryReader ; public final class TriggerPointAdvisorDescriptor { private String id ; private IConfigurationElement element ; public TriggerPointAdvisorDescriptor ( IConfigurationElement element ) throws IllegalArgumentException { id = element . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ; if ( id == null || RegistryReader . getClassValue ( element , IWorkbenchRegistryConstants . ATT_CLASS ) == null ) { throw new IllegalArgumentException ( ) ; } this", "gt": ". element = element ;", "prediction": ". element = element ;\n", "label": 1}
{"id": 6756, "input": "<s> interface Base { int m ( ) ; } interface ClashesWith extends Base {", "gt": "String m ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15325, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . Segment3D ; import de . uos . igf . db3d . dbms . geom . Tetrahedron3D ; import de . uos . igf . db3d . dbms . geom . Triangle3D ; public interface Volume3D extends Spatial3D { public double getVolume ( ) ; public double getArea ( ) ; public int countVertices ( ) ; public int countEdges ( ) ; public int countFaces ( ) ; public int countBorderVertices ( ) ;", "gt": "public int countBorderEdges ( ) ;", "prediction": "public int countBorderEdges ( ) ;\n", "label": 1}
{"id": 3173, "input": "<s> package com . farpost . ldt . formatter ; import com . farpost . ldt . TestResult ; public interface ResultFormatter { void format", "gt": "( TestResult result ) ;", "prediction": "( TestResult result ) ;\n", "label": 0}
{"id": 15332, "input": "<s> package org . fuzzydb . server ; import static org . junit . Assert . assertNotNull ; import java . io . IOException ; import java . net . MalformedURLException ; import org . fuzzydb . client . Client ; import org . fuzzydb . client . Store ; import org . fuzzydb . client . WWMDBProtocolHander ; import org . fuzzydb . server . EmbeddedClientFactory ; import org . junit . Test ; public class EmbeddedClientFactoryTest { @ Test public void createStoreAgainstEmbeddedDatabaseShouldReturnNonNullStore ( ) throws IOException { Client client = EmbeddedClientFactory . getInstance ( ) . createClient ( ) ; Store store = client . createStore ( \"store@\" + System . currentTimeMillis ( ) ) ; assertNotNull ( store ) ; client . deleteStore ( store . getStoreName ( ) ) ; EmbeddedClientFactory . getInstance ( ) . shutdownDatabase ( ) ; } @ Test public void openUrlForEmbeddedStore ( ) throws MalformedURLException { final String storeName = \"store@\" +", "gt": "System . currentTimeMillis ( ) ;", "prediction": "System . currentTimeMillis ( ) ;\n", "label": 1}
{"id": 9094, "input": "<s> @ SuppressWarnings ( \"\" ) public class Part2 { class Nested { @ SuppressWarnings ( \"\"", "gt": ") void bar ( )", "prediction": ") public String getName ( )\n", "label": 0}
{"id": 15337, "input": "<s> package com . symbol8 . moneytracker . domain ; import java . text . SimpleDateFormat ; public class Account { public static final SimpleDateFormat PRINTABLE_DATE_FORMAT = new SimpleDateFormat ( \"yyyy/MM/dd hh:mm:ss\" ) ; private String id ; public Account ( ) { } public Account ( String id ) { this ( ) ; this . id = id ; } public String getId ( ) { return id ; } public void setId ( String id ) { this . id = id ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Account other = ( Account ) obj ; if", "gt": "( id == null )", "prediction": "( getId ( ) != other . getId ( ) ) return false ;\n", "label": 1}
{"id": 5984, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . parts ; import org . eclipse . draw2d . FigureUtilities ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . geometry . Dimension ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . EditPart ; import org . eclipse . gef . EditPartFactory ; import org . eclipse . gef . tools . CellEditorLocator ; import org . eclipse . gmf . runtime . diagram . ui . editparts . ITextAwareEditPart ; import org . eclipse . gmf . runtime . draw2d . ui . figures . WrappingLabel ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Text ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry ; public class SimplemapEditPartFactory implements EditPartFactory { public EditPart createEditPart ( EditPart context , Object model ) { if ( model instanceof View ) { View view = ( View ) model ; switch ( SimplemapVisualIDRegistry . getVisualID ( view ) ) { case SimpleMappingEditPart . VISUAL_ID : return new SimpleMappingEditPart ( view ) ; case SimpleTopNodeEditPart . VISUAL_ID : return new SimpleTopNodeEditPart ( view ) ; case SimpleTopNodeNameEditPart . VISUAL_ID : return new SimpleTopNodeNameEditPart ( view ) ; case SimpleLinkMappingEditPart . VISUAL_ID : return new SimpleLinkMappingEditPart ( view ) ; case SimpleLinkMappingNameEditPart . VISUAL_ID : return new SimpleLinkMappingNameEditPart ( view ) ; case SimpleLabelNodeEditPart . VISUAL_ID : return new SimpleLabelNodeEditPart ( view ) ; case SimpleCompartmentEditPart . VISUAL_ID : return new SimpleCompartmentEditPart ( view ) ; case SimpleCompartmentNameEditPart . VISUAL_ID : return new SimpleCompartmentNameEditPart ( view ) ; case SimpleSubNodeEditPart . VISUAL_ID : return new SimpleSubNodeEditPart ( view ) ; case SimpleSubNodeNameEditPart . VISUAL_ID : return new SimpleSubNodeNameEditPart ( view ) ; case SimpleChildReferenceEditPart . VISUAL_ID : return new SimpleChildReferenceEditPart ( view ) ; } } return createUnrecognizedEditPart ( context , model ) ; } private EditPart createUnrecognizedEditPart ( EditPart context , Object model ) { return null ; } public static CellEditorLocator getTextCellEditorLocator ( ITextAwareEditPart source ) { if ( source . getFigure ( ) instanceof WrappingLabel ) return new TextCellEditorLocator ( ( WrappingLabel ) source .", "gt": "getFigure ( ) ) ;", "prediction": "getFigure ( ) ) ;\n", "label": 0}
{"id": 15338, "input": "<s> package org . fuzzydb . server . internal . pager ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . Semaphore ; import org . fuzzydb . server . internal . server . WorkerThread ; public class ExclusiveWrite { private static final int MAX_PERMITS = Integer . MAX_VALUE ; private final Semaphore lock = new Semaphore ( MAX_PERMITS ) ; private final Set < Thread > readLocks = Collections . synchronizedSet ( new HashSet < Thread > ( ) ) ; private volatile Thread writeLock = null ; public ExclusiveWrite ( ) { } public void acquireRead ( ) { assert ( ! readLocks . contains ( Thread . currentThread ( ) ) ) ; if ( ! lock . tryAcquire ( ) ) { WorkerThread . beginIO ( ) ; lock . acquireUninterruptibly ( ) ; WorkerThread . endIO ( ) ; } readLocks . add ( Thread . currentThread ( ) ) ; } public synchronized void releaseRead ( ) { assert ( readLocks . contains ( Thread . currentThread ( ) ) ) ; lock . release ( ) ; readLocks . remove ( Thread . currentThread ( ) ) ; } public void acquireWrite ( ) { assert ( ! readLocks . contains ( Thread . currentThread ( ) ) ) ; if ( ! lock . tryAcquire ( MAX_PERMITS ) ) { WorkerThread . beginIO ( ) ; lock . acquireUninterruptibly ( MAX_PERMITS ) ; WorkerThread . endIO ( ) ; } synchronized ( this ) { assert ( writeLock == null ) ; writeLock = Thread . currentThread ( ) ; } } public boolean tryAcquireWrite ( ) { if ( ! readLocks . isEmpty ( ) ) { return false ; } if ( writeLock != null ) { return false ; } if ( ! lock . tryAcquire ( MAX_PERMITS ) ) { return false ; } synchronized ( this ) { assert ( writeLock == null ) ; writeLock = Thread . currentThread ( ) ; } return true ; } public synchronized void releaseWrite ( ) { assert ( writeLock == Thread . currentThread ( ) ) ; writeLock = null ; lock . release ( MAX_PERMITS ) ; } public synchronized void releaseWriteAcquireRead ( ) {", "gt": "assert ( writeLock == Thread . currentThread ( ) ) ;", "prediction": "assert ( readLocks . contains ( Thread . currentThread ( ) ) ) ;\n", "label": 1}
{"id": 9334, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . navigator ; import org . eclipse . core . resources . IFile ; import org . eclipse . emf . common . ui . URIEditorInput ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . workspace . util . WorkspaceSynchronizer ; import org . eclipse . gef . EditPart ; import org . eclipse . gef . GraphicalViewer ; import org . eclipse . gmf . runtime . diagram . ui . parts . DiagramEditor ; import org . eclipse . gmf . runtime . diagram . ui . resources . editor . document . IDiagramDocument ; import org . eclipse . gmf . runtime . notation . Diagram ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . navigator . ILinkHelper ; import org . eclipse . ui . part . FileEditorInput ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapDiagramEditorPlugin ; public class SimplemapNavigatorLinkHelper implements ILinkHelper { private static IEditorInput getEditorInput ( Diagram diagram ) { Resource diagramResource = diagram . eResource ( ) ; for ( EObject nextEObject : diagramResource . getContents ( ) ) { if ( nextEObject == diagram ) { return new FileEditorInput ( WorkspaceSynchronizer . getFile ( diagramResource ) ) ; } if ( nextEObject instanceof Diagram ) { break ; } } URI uri = EcoreUtil . getURI ( diagram ) ; String editorName = uri . lastSegment ( ) + '#' + diagram . eResource ( ) . getContents ( ) . indexOf ( diagram ) ; IEditorInput editorInput = new URIEditorInput ( uri , editorName ) ; return editorInput ; } public IStructuredSelection findSelection ( IEditorInput anInput ) { IDiagramDocument document = SimplemapDiagramEditorPlugin . getInstance ( ) . getDocumentProvider ( ) . getDiagramDocument ( anInput ) ; if ( document == null ) { return StructuredSelection . EMPTY ; } Diagram diagram = document . getDiagram ( ) ; if ( diagram == null || diagram . eResource ( ) == null ) { return StructuredSelection . EMPTY ; } IFile file = WorkspaceSynchronizer . getFile ( diagram . eResource ( ) ) ; if ( file != null ) { SimplemapNavigatorItem item = new SimplemapNavigatorItem ( diagram , file , false ) ; return new StructuredSelection ( item ) ; }", "gt": "return StructuredSelection . EMPTY ;", "prediction": "return StructuredSelection . EMPTY ;\n", "label": 0}
{"id": 15345, "input": "<s> package com . emf4sw . rdf . impl ; import java . util . Collection ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . util . EObjectResolvingEList ; import com . emf4sw . rdf . Node ; import com . emf4sw . rdf . RDFList ; import com . emf4sw . rdf . RDFPackage ; public class RDFListImpl extends BlankNodeImpl implements RDFList { protected EList < Node > elements ; protected RDFListImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return RDFPackage . Literals . RDF_LIST ; } public EList < Node > getElements ( ) { if ( elements == null ) { elements = new EObjectResolvingEList < Node > ( Node . class , this , RDFPackage . RDF_LIST__ELEMENTS ) ; } return elements ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case RDFPackage . RDF_LIST__ELEMENTS : return getElements ( ) ; } return super .", "gt": "eGet ( featureID , resolve , coreType ) ;", "prediction": "eGet ( featureID , resolve , coreType ) ;\n", "label": 1}
{"id": 7224, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface Footer extends ReportAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 15361, "input": "<s> package org . spliffy . server . web . calc ; import java . math . BigDecimal ; import org . spliffy . server . web . SpliffyResource ; import org . spliffy . server . web . templating . Formatter ; class Sumor implements Accumulator { private final int decimals ; private final Formatter formatter ; public Sumor ( int decimals , Formatter formatter ) { super ( ) ; this . decimals = decimals ; this . formatter = formatter ; } BigDecimal value = new BigDecimal ( 0 ) ; @", "gt": "Override public void accumulate ( SpliffyResource r , Object o )", "prediction": "Override public void accumulate ( )\n", "label": 1}
{"id": 4020, "input": "<s> package org . bombusim . lime . activity ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import org . bombusim . lime . data . AccountsFactory ; import org . bombusim . lime . service . XmppService ; import org . bombusim . lime . service . XmppServiceBinding ; import org . bombusim . lime . widgets . OkCancelBar ; import org . bombusim . xmpp . XmppAccount ; import org . bombusim . xmpp . XmppJid ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . DialogInterface ; import android . content . Intent ; import android . graphics . drawable . BitmapDrawable ; import android . os . Bundle ; import android . text . InputType ; import android . view . MenuItem ; import android . view . View ; import android . widget . CheckBox ; import android . widget . EditText ; import android . widget . Spinner ; public class AccountSettingsActivity extends Activity { EditText editJid ; EditText editPass ; EditText editResource ; EditText editPriority ; EditText editXmppHost ; EditText editXmppPort ; CheckBox checkSpecificHostPort ; CheckBox checkZlib ; CheckBox checkAutologin ; Spinner spinSecurity ; Spinner spinPlainPassword ; OkCancelBar mOkCancel ; boolean mAdvancedSettings = false ; private XmppServiceBinding sb ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . account_settings ) ; editJid = ( ( EditText ) findViewById ( R . id . jid ) ) ; editPass = ( ( EditText ) findViewById ( R . id . password ) ) ; editResource = ( ( EditText ) findViewById ( R . id . resource ) ) ; editPriority = ( ( EditText ) findViewById ( R . id . priority ) ) ; checkAutologin = ( ( CheckBox ) findViewById ( R . id . autoLogin ) ) ; editXmppHost = ( ( EditText ) findViewById ( R . id . xmpphost ) ) ; editXmppPort = ( ( EditText ) findViewById ( R . id . xmppport ) ) ; checkSpecificHostPort = ( ( CheckBox ) findViewById ( R . id . specificHostPort ) ) ; spinSecurity = ( ( Spinner ) findViewById ( R . id . ssl ) ) ; spinPlainPassword = ( ( Spinner ) findViewById ( R . id . plainpassword ) ) ; checkZlib = ( ( CheckBox ) findViewById ( R . id . zlib ) ) ; mOkCancel = ( OkCancelBar ) findViewById ( R . id . okCancel ) ; showAdvancedSettings ( false ) ; if ( savedInstanceState != null ) { loadInstanceState ( savedInstanceState ) ; } else { loadActiveAccount ( ) ; } findViewById ( R . id . advancedSettings ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { showAdvancedSettings ( true ) ; } } ) ; findViewById ( R . id . showPassword ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { int inputtype = InputType . TYPE_CLASS_TEXT | InputType . TYPE_TEXT_FLAG_NO_SUGGESTIONS ; if ( ( ( CheckBox ) v ) . isChecked ( ) ) inputtype |= InputType . TYPE_TEXT_VARIATION_VISIBLE_PASSWORD ; else inputtype |= InputType . TYPE_TEXT_VARIATION_PASSWORD ; editPass . setInputType ( inputtype ) ; } } ) ; findViewById ( R . id . specificHostPort ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { updateHostState ( ) ; } } ) ; mOkCancel . setOnButtonActionListener ( new OkCancelBar . OnButtonActionListener ( ) { @ Override public void onPositive ( ) { sb . doDisconnect ( ) ; if ( ! saveAccount ( ) ) return ; Lime . getInstance ( ) . loadAccounts ( ) ; finish ( ) ; } @ Override public void onNegative ( ) { onBackPressed ( ) ; } } ) ; updateHostState ( ) ; sb = new XmppServiceBinding ( this ) ; } private void showAdvancedSettings ( boolean show ) { mAdvancedSettings = show ; findViewById ( R . id . advancedSettings ) . setVisibility ( ( show ) ? View . GONE : View . VISIBLE ) ; findViewById ( R . id . layoutAdvancedSettings ) . setVisibility ( ( show ) ? View . VISIBLE : View . GONE ) ; } private void loadActiveAccount ( ) { XmppAccount account = Lime . getInstance ( ) . getActiveAccount ( ) ; editJid . setText ( account . userJid ) ; editPass . setText ( account . password ) ; editResource . setText ( account . resource ) ; editPriority . setText ( String . valueOf ( account . priority ) ) ; checkAutologin . setChecked ( account . autoLogin ) ; editXmppHost . setText ( account . xmppHost ) ; editXmppPort . setText ( String . valueOf ( account . xmppPort ) ) ; checkSpecificHostPort . setChecked ( account . specificHostPort ) ; checkZlib . setChecked ( account . trafficCompression ) ; spinSecurity . setSelection ( account . secureConnection ) ; spinPlainPassword . setSelection ( account . enablePlainAuth ) ; } void updateHostState ( ) { int visibility = ( ( CheckBox ) findViewById ( R . id . specificHostPort ) ) . isChecked ( ) ? View . VISIBLE : View . GONE ; findViewById ( R . id . linearLayotHost ) . setVisibility ( visibility ) ; } @ Override protected void onResume ( ) { sb . doBindService ( ) ; super . onResume ( ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; sb . doUnbindService ( ) ; } @ Override public void onBackPressed ( ) { if ( Lime . getInstance ( ) . getActiveAccount ( ) . _id == - 1 ) Lime . getInstance ( ) . deleteActiveAccount ( ) ; finish ( ) ; } @ Override protected void onSaveInstanceState ( Bundle outState ) { super . onSaveInstanceState ( outState ) ; outState . putString ( \"jid\" , editJid . getText ( ) . toString ( ) ) ; outState . putString ( \"password\" , editPass . getText ( ) . toString ( ) ) ; outState . putString ( \"resource\" , editResource . getText ( ) . toString ( ) ) ; outState . putString ( \"priority\" , editPriority . getText ( ) . toString ( ) ) ; outState . putString ( \"host\" , editXmppHost . getText ( ) . toString ( ) ) ; outState . putString ( \"port\" , editXmppPort . getText ( ) . toString ( ) ) ; outState . putBoolean ( \"autologin\" , checkAutologin . isChecked ( ) ) ; outState . putBoolean ( \"hostport\" , checkSpecificHostPort . isChecked ( ) ) ; outState . putBoolean ( \"zlib\" , checkZlib . isChecked ( ) ) ; outState . putInt ( \"ssl\" ,", "gt": "spinSecurity . getSelectedItemPosition ( ) ) ;", "prediction": "editZlib . isChecked ( ) ) ;\n", "label": 0}
{"id": 15364, "input": "<s> package com . datastruct ; import com . math . CompPoint ; import java . util . Random ; import java . util . Vector ; import processing . core . PApplet ; import com . math . Geom ; public class DoublyConnectedEdgeList { public Vector < DCFace > faces = new Vector < DCFace > ( ) ; public Vector < DCHalfEdge > edges = new Vector < DCHalfEdge > ( ) ; public Vector < CompPoint > verticies = new Vector < CompPoint > ( ) ; public CompPoint centroid ; public DoublyConnectedEdgeList ( ) { } public void addVertex ( CompPoint p ) { verticies . addElement ( p ) ; } public DCHalfEdge addHalfEdge ( DCHalfEdge newEdge ) { edges . addElement ( newEdge ) ; return newEdge ; } public DCHalfEdge addEdgeWithPartner ( DCHalfEdge newEdge ) { if ( edges . size ( ) > 0 ) { setPartners ( newEdge , edges . get ( edges . size ( ) - 1 ) ) ; } edges . addElement ( newEdge ) ; return newEdge ; } public void addEdgeAt ( DCHalfEdge newEdge , int addPosition ) { edges . add ( addPosition , newEdge ) ; } public void addFace ( DCFace face ) { faces . add ( face ) ; } public DCFace getFaceByFocus ( CompPoint focus ) { for ( int i = 0 ; i < faces . size ( ) ; i ++ ) { DCFace checkFace = faces . get ( i ) ; if ( checkFace . getFocus ( ) . compareTo ( focus ) == 0 ) { return checkFace ; } } return null ; } public void drawFaces ( PApplet parent ) { for ( int i = 0 ; i < faces . size ( ) ; i ++ ) { DCFace checkFace = faces . get ( i ) ; checkFace . draw ( parent ) ; } } public boolean deleteEdge ( DCHalfEdge edge ) { return edges . removeElement ( edge ) ; } public double [ ] getBorderPoints ( CompPoint start ) { double [ ] thetas = new double [ edges . size ( ) ] ; for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { CompPoint point = edges . get ( i ) . start ; double theta = start . angle ( point ) ; thetas [ i ] = theta ; } return thetas ; } public void translate ( double x , double y , CompPoint focus ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { DCHalfEdge currentEdge = edges . get ( i ) ; currentEdge . translate ( x , y , focus ) ; } } public void rotate ( double theta , CompPoint _focus ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { DCHalfEdge currentEdge = edges . get ( i ) ; currentEdge . rotate ( theta , _focus ) ; } } private void setPartners ( DCHalfEdge currentEdge , DCHalfEdge prevEdge ) { int color = new Random ( ) . nextInt ( ) * 0xFFFFFF ; currentEdge . setPartnerEdge ( \"start\" , prevEdge , prevEdge . end , color ) ; prevEdge . setPartnerEdge ( \"end\" , currentEdge , currentEdge", "gt": ". start , color ) ;", "prediction": ". end , color ) ;\n", "label": 1}
{"id": 2584, "input": "<s> public class JCrypt { private JCrypt ( ) { } private static final int ITERATIONS = 16 ; private static final int con_salt [ ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x3E , 0x3F , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , } ; private static final boolean shifts2 [ ] = { false , false , true , true , true , true , true , true , false , true , true , true , true , true , true , false } ; private static final int skb [ ] [ ] = { { 0x00000000 , 0x00000010 , 0x20000000 , 0x20000010 , 0x00010000 , 0x00010010 , 0x20010000 , 0x20010010 , 0x00000800 , 0x00000810 , 0x20000800 , 0x20000810 , 0x00010800 , 0x00010810 , 0x20010800 , 0x20010810 , 0x00000020 , 0x00000030 , 0x20000020 , 0x20000030 , 0x00010020 , 0x00010030 , 0x20010020 , 0x20010030 , 0x00000820 , 0x00000830 , 0x20000820 , 0x20000830 , 0x00010820 , 0x00010830 , 0x20010820 , 0x20010830 , 0x00080000 , 0x00080010 , 0x20080000 , 0x20080010 , 0x00090000 , 0x00090010 , 0x20090000 , 0x20090010 , 0x00080800 , 0x00080810 , 0x20080800 , 0x20080810 , 0x00090800 , 0x00090810 , 0x20090800 , 0x20090810 , 0x00080020 , 0x00080030 , 0x20080020 , 0x20080030 , 0x00090020 , 0x00090030 , 0x20090020 , 0x20090030 , 0x00080820 , 0x00080830 , 0x20080820 , 0x20080830 , 0x00090820 , 0x00090830 , 0x20090820 , 0x20090830 , } , { 0x00000000 , 0x02000000 , 0x00002000 , 0x02002000 , 0x00200000 , 0x02200000 , 0x00202000 , 0x02202000 , 0x00000004 , 0x02000004 , 0x00002004 , 0x02002004 , 0x00200004 , 0x02200004 , 0x00202004 , 0x02202004 , 0x00000400 , 0x02000400 , 0x00002400 , 0x02002400 , 0x00200400 , 0x02200400 , 0x00202400 , 0x02202400 , 0x00000404 , 0x02000404 , 0x00002404 , 0x02002404 , 0x00200404 , 0x02200404 , 0x00202404 , 0x02202404 , 0x10000000 , 0x12000000 , 0x10002000 , 0x12002000 , 0x10200000 , 0x12200000 , 0x10202000 , 0x12202000 , 0x10000004 , 0x12000004 , 0x10002004 , 0x12002004 , 0x10200004 , 0x12200004 , 0x10202004 , 0x12202004 , 0x10000400 , 0x12000400 , 0x10002400 , 0x12002400 , 0x10200400 , 0x12200400 , 0x10202400 , 0x12202400 , 0x10000404 , 0x12000404 , 0x10002404 , 0x12002404 , 0x10200404 ,", "gt": "0x12200404 , 0x10202404 , 0x12202404 , }", "prediction": "}\n", "label": 0}
{"id": 15365, "input": "<s> package org . restlet . test . engine ; import java . io . IOException ; import java . util . List ; import org . restlet . Request ; import org . restlet . data . ChallengeRequest ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Digest ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . engine . header . ChallengeWriter ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . security . AuthenticatorUtils ; import org . restlet . ext . crypto . internal . HttpAwsS3Helper ; import org . restlet . test . RestletTestCase ; import org . restlet . util . Series ; public class AuthenticationTestCase extends RestletTestCase { @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; org . restlet . engine . Engine . clear ( ) ; } public void testAwsS3 ( ) { HttpAwsS3Helper helper = new HttpAwsS3Helper ( ) ; ChallengeWriter cw = new ChallengeWriter ( ) ; ChallengeResponse challenge = new ChallengeResponse ( ChallengeScheme . HTTP_AWS_S3 , \"0PN5J17HBGZHT7JJ3X82\" , \"uV3F3YluFJax1cknvbcGwgjvx4QpvB+leU8dUj2o\" ) ; Request request = new Request ( Method . GET , \"http://johnsmith.s3.amazonaws.com/photos/puppy.jpg\" ) ; Series < Header > httpHeaders = new Series < Header > ( Header . class ) ; httpHeaders . add ( HeaderConstants . HEADER_DATE , \"Tue, 27 Mar 2007 19:36:42 +0000\" ) ; helper . formatResponse ( cw , challenge , request , httpHeaders ) ; assertEquals ( \"0PN5J17HBGZHT7JJ3X82:xXjDGYUmKxnwqr5KXNPGldn5LbA=\" , cw . toString ( ) ) ; cw = new ChallengeWriter ( ) ; request . setMethod ( Method . PUT ) ; httpHeaders . set ( HeaderConstants . HEADER_DATE , \"Tue, 27 Mar 2007 21:15:45 +0000\" , true ) ; httpHeaders . add ( HeaderConstants . HEADER_CONTENT_LENGTH , \"94328\" ) ; httpHeaders . add ( HeaderConstants . HEADER_CONTENT_TYPE , \"image/jpeg\" ) ; helper . formatResponse ( cw , challenge , request , httpHeaders ) ; assertEquals ( \"0PN5J17HBGZHT7JJ3X82:hcicpDDvL9SsO6AkvxqmIWkmOuQ=\" , cw . toString ( ) ) ; } public void testParsingBasic ( ) throws IOException { String authenticate1 = \"Basic realm=\\\"Restlet tutorial\\\"\" ; String authorization1 = \"Basic c2NvdHQ6dGlnZXI=\" ; assertEquals ( authorization1 , AuthenticatorUtils . formatResponse ( AuthenticatorUtils . parseResponse ( null , authorization1 , null ) , null , null ) ) ; List < ChallengeRequest > creq = AuthenticatorUtils . parseRequest ( null , authenticate1 , null ) ; assertEquals ( creq . size ( ) , 1 ) ; assertEquals ( authenticate1 , AuthenticatorUtils . formatRequest ( creq . get ( 0 ) , null , null ) ) ; } public void testParsingDigest ( ) throws IOException { ChallengeResponse cres1 = new ChallengeResponse ( ChallengeScheme . HTTP_DIGEST , null , \"admin\" , \"12345\" . toCharArray ( ) , Digest . ALGORITHM_NONE , null , \"qop\" , new Reference ( \"/protected/asdass\" ) , null , null , \"MTE3NzEwMzIwMjkwMDoxNmMzODFiYzRjNWRjMmMyOTVkMWFhNDdkMTQ4OGFlMw==\" , \"MTE3NzEwMzIwMjkwMDoxNmMzODFiYzRjNWRjMmMyOTVkMWFhNDdkMTQ4OGFlMw==\" , 1 , 0L ) ; Request request = new Request ( Method . GET , \"http://remote.com/protected/asdass\" ) ; String authorization1 = AuthenticatorUtils . formatResponse ( cres1 , request , null ) ; String authenticate1 = \"Digest realm=realm, domain=\\\"/protected/ /alsoProtected/\\\", qop=auth, algorithm=MD5, nonce=\\\"MTE3NzEwMzIwMjg0Mjo2NzFjODQyMjAyOWRlNWQ1YjFjNmEzYzJmOWRlZmE2Mw==\\\"\" ; ChallengeResponse cres = AuthenticatorUtils . parseResponse ( null , authorization1 , null ) ; cres . setRawValue ( null ) ; assertEquals ( authorization1 , AuthenticatorUtils . formatResponse ( cres , request , null ) ) ; List < ChallengeRequest > creq = AuthenticatorUtils . parseRequest ( null , authenticate1 , null ) ; assertEquals ( creq . size ( ) , 1 ) ; assertEquals ( authenticate1 , AuthenticatorUtils . formatRequest ( creq . get ( 0 ) , null , null ) ) ; } public void testParsingMultiValuedAuthenticate ( ) throws IOException {", "gt": "String authenticate0 = \"Basic realm=\\\"Restlet tutorial\\\"\" ;", "prediction": "String authenticate1 = \"Basic realm=\\\"Restlet tutorial\\\"\" ;\n", "label": 1}
{"id": 1144, "input": "<s> package com . redhat . ceylon . compiler . java . test . interop ; interface JavaNestingInterface < C > { public static class InnerStatic < I > { public class Inner2 < I2 > { public class Inner3 < I3 > { } } public static class InnerStatic2 < I2 > { public class Inner3 < I3 > { } } } public interface InnerInterface < I > { public static class Inner2 < I2 > { public class Inner3 < I3 > { } public static class InnerStatic3 < I3 > { } } } } public class JavaNesting < C > { public class Inner < I > { public class Inner2 < I2 > { } } public static class InnerStatic < I > { public class Inner2 < I2 > { public class Inner3 < I3 > { } } public static class InnerStatic2 < I2 > { public class Inner3 < I3 > { } }", "gt": "public interface InnerInterface < I2 >", "prediction": "}\n", "label": 0}
{"id": 15369, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . apache . commons . lang . StringUtils ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo", "gt": ". ecm . core . schema . utils . DateParser ;", "prediction": ". ecm . core . api . Blob ;\n", "label": 1}
{"id": 6311, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . Export ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ExportTest extends XtextTest { @ Test public void testAllExports ( ) { String text = \"export \\\"test export\\\" \" + \"{ \" + \"definitions * \" + \"end 2011-07-07 \" + \"hideresource \\\"logical expression\\\" \" + \"hidetask \\\"logical expression\\\" \" + \"period 2010-01-16 + 4 m \" + \"resourceattributes * \" + \"rollupresource \\\"logical expression\\\" \" + \"rolluptask \\\"logical expression\\\" \" + \"scenarios sc1, sc2 \" + \"start 2011-07-07 \" + \"taskattributes - \"", "gt": "+ \"timezone \\\"EST\\\" \" + \"}\" ;", "prediction": ";\n", "label": 0}
{"id": 15376, "input": "<s> package org . restlet . engine ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . Connector ; import org . restlet . Context ; import org . restlet . data . Protocol ; public abstract class ConnectorHelper < T extends Connector > extends RestletHelper < T > { public static org . restlet . service . ConnectorService getConnectorService ( ) { org . restlet . service . ConnectorService result = null ; org . restlet . Application application = org . restlet . Application . getCurrent ( ) ; if ( application != null ) { result = application . getConnectorService ( ) ; } else { result = new org . restlet . service . ConnectorService ( ) ; } return result ; } private final List < Protocol > protocols ; public", "gt": "ConnectorHelper ( T connector )", "prediction": "ConnectorHelper ( )\n", "label": 1}
{"id": 9613, "input": "<s> package org . ofbiz . webapp . event ; import java . util . * ; import javax . script . ScriptContext ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import groovy . lang . GroovyClassLoader ; import groovy . lang . Script ; import org . codehaus . groovy . control . CompilerConfiguration ; import org . codehaus . groovy . runtime . InvokerHelper ; import javolution . util . FastMap ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . util . * ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . service . ExecutionServiceException ; import org . ofbiz . service . config . ServiceConfigUtil ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public class GroovyEventHandler implements EventHandler { public static final String module = GroovyEventHandler . class . getName ( ) ; protected static final Object [ ] EMPTY_ARGS = { } ; private static final Set < String > protectedKeys = createProtectedKeys ( ) ; private static Set < String > createProtectedKeys ( ) { Set < String > newSet = new HashSet < String > ( ) ; newSet . add ( \"request\" ) ; newSet . add ( \"response\" ) ; newSet . add ( \"session\" ) ; newSet . add ( \"dispatcher\" ) ; newSet . add ( \"delegator\" ) ; newSet . add ( \"security\" ) ; newSet . add ( \"locale\" ) ; newSet . add ( \"timeZone\" ) ; newSet . add ( \"userLogin\" ) ; return Collections . unmodifiableSet ( newSet ) ; } private GroovyClassLoader groovyClassLoader ; public void init ( ServletContext context ) throws EventHandlerException { try { String scriptBaseClass = ServiceConfigUtil . getEngineParameter ( \"groovy\" , \"scriptBaseClass\" ) ; if ( scriptBaseClass != null ) { CompilerConfiguration conf = new CompilerConfiguration ( ) ; conf . setScriptBaseClass ( scriptBaseClass ) ; groovyClassLoader = new GroovyClassLoader ( getClass ( ) . getClassLoader ( ) , conf ) ; } } catch ( GenericConfigException gce ) { Debug . logWarning ( gce , \"Error retrieving the configuration for the groovy service engine: \" , module ) ; } } public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse response ) throws EventHandlerException { try { Map < String , Object > context = new HashMap < String , Object > ( ) ; context . put ( \"request\" , request ) ; context . put ( \"response\" , response ) ; HttpSession session = request . getSession ( ) ; context . put ( \"session\" , session ) ; context . put ( \"dispatcher\" , request . getAttribute ( \"dispatcher\" ) ) ; context . put ( \"delegator\" , request . getAttribute ( \"delegator\" ) ) ; context . put ( \"security\" ,", "gt": "request . getAttribute ( \"security\" ) ) ;", "prediction": "request . getAttribute ( \"security\" ) ) ;\n", "label": 0}
{"id": 15377, "input": "<s> package knowevo . myvizster . controls ; import java . awt . event . MouseEvent ; import java . util . TimerTask ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . activity . Activity ; import edu . berkeley . guir . prefuse . event . ControlAdapter ; import edu . berkeley . guir . prefuse . focus . FocusSet ; public class HighlightControl extends ControlAdapter { private Object focusKey ; private Activity activity ; private TimerTask task ; private long delay = 500 ; public HighlightControl ( Activity act , Object key ) { this . activity = act ; this . focusKey = key ; } public void itemEntered ( VisualItem vi , MouseEvent e ) { if ( ! shouldProcess ( vi ) ) return ; if ( task != null ) task . cancel ( ) ; ItemRegistry registry = vi . getItemRegistry ( ) ; synchronized ( registry ) { FocusManager fman = registry . getFocusManager ( ) ; FocusSet fset", "gt": "= fman . getFocusSet ( focusKey ) ;", "prediction": "= fman . getFocusSet ( vi ) ;\n", "label": 1}
{"id": 5799, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import junit . framework . Assert ; import org . apache . commons . io . output . ByteArrayOutputStream ; import org . junit . Test ; import com . sap . prd . mobile . ios . mios . Forker ; public class ForkerTest { @ Test public void testStraightForward ( ) throws Exception { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; final PrintStream log = new PrintStream ( out , true ) ; try { Forker . forkProcess ( log , new File ( \".\" ) . getAbsoluteFile ( ) , \"echo\" , \"Hello World\" ) ; } finally { log . close ( ) ; } Assert . assertEquals ( \"Hello World\\n\" , new String ( out . toByteArray ( ) ) ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testMissingPrintStreamForLogging ( ) throws Exception { Forker . forkProcess ( null , new File ( \".\" ) . getAbsoluteFile ( ) , \"echo\" , \"Hello World\" ) ; } @ Test ( expected = IllegalArgumentException . class ) public void testMissingArguments_1 ( ) throws Exception { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; final PrintStream log = new PrintStream ( out , true ) ; try { Forker . forkProcess ( log , new File ( \".\" ) . getAbsoluteFile ( ) , (", "gt": "String [ ] ) null ) ;", "prediction": "String ) null ) ;\n", "label": 0}
{"id": 15379, "input": "<s> package com . inepex . classtemplater . plugin . logic ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . jdt . core . ICompilationUnit ; import org . eclipse . jdt . core . IField ; import org . eclipse . jdt . core . IMethod ; import org . eclipse . jdt . core . IType ; public class Class { static final Pattern getterPattern = Pattern . compile ( \"(get|is)([A-Z])(.*)\" ) ; static final Pattern setterSetter = Pattern . compile ( \"(set)([A-Z])(.*)\" ) ; String name ; String packageName ; List < Attribute > attributes = new ArrayList < Attribute > ( ) ; List < Method > methods = new ArrayList < Method > ( ) ; List < Property > properthies ; Map < String , Annotation > annotations = new HashMap < String , Annotation > ( ) ; String workspaceRelativePath ; public Class ( String name , String packageName ) { super ( ) ; this . name = name ; this . packageName = packageName ; } public Class ( List < IField > jdtFields ) throws Exception { this . name = jdtFields . get ( 0 ) . getDeclaringType ( ) . getTypeQualifiedName ( ) ; this . packageName = ( ( ICompilationUnit ) jdtFields . get ( 0 ) . getParent ( ) . getParent ( ) ) . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; for ( IField field : jdtFields ) { this . attributes . add ( new Attribute ( field ) ) ; } this . annotations = Annotation . getAnnotationsOf ( jdtFields . get ( 0 ) . getDeclaringType ( ) , jdtFields . get ( 0 ) . getCompilationUnit ( ) ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( ( ICompilationUnit ) jdtFields . get ( 0 ) . getParent ( ) . getParent ( ) ) ; } public Class ( List < IMethod > jdtMethods , boolean isMethods ) throws Exception { this . name = jdtMethods . get ( 0 ) . getDeclaringType ( ) . getTypeQualifiedName ( ) ; this . packageName = ( ( ICompilationUnit ) jdtMethods . get ( 0 ) . getParent ( ) . getParent ( ) ) . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; for ( IMethod method : jdtMethods ) { this . methods . add ( new Method ( method ) ) ; } this . annotations = Annotation . getAnnotationsOf ( jdtMethods . get ( 0 ) . getDeclaringType ( ) , jdtMethods . get ( 0 ) . getCompilationUnit ( ) ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( ( ICompilationUnit ) jdtMethods . get ( 0 ) . getParent ( ) . getParent ( ) ) ; } public Class ( ICompilationUnit compunit ) throws Exception { this . name = compunit . findPrimaryType ( ) . getTypeQualifiedName ( ) ; this . packageName = compunit . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; this . attributes = getAttrs ( compunit ) ; this . methods = getMethods ( compunit ) ; this . annotations = Annotation . getAnnotationsOf ( compunit . getAllTypes ( ) [ 0 ] , compunit ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( compunit ) ; } private void buildProperthies ( ) { Map < String , Property > props = new HashMap < String , Property > ( ) ; for ( Method method : this . methods ) { Matcher matcher = getterPattern . matcher ( method . name ) ; if ( matcher . matches ( ) ) { if ( ! method . getReturnType ( ) . equals ( \"void\" ) ) { Property prop = getOrCreateProperty ( matcher , props ) ; prop . setGetter ( method ) ; } } else { matcher = setterSetter . matcher ( method . name ) ; if ( matcher . matches ( ) && method . getParameters ( ) . size ( ) == 1 ) { Property prop = getOrCreateProperty ( matcher , props ) ; prop . setSetter ( method ) ; } } } this . properthies = new ArrayList < Property > ( props . values ( ) ) ; } private Property getOrCreateProperty ( Matcher matcher , Map < String , Property > props ) { String propertyName = matcher . group ( 2 ) . toLowerCase ( ) . concat ( matcher . group ( 3 ) ) ; Property prop = props . get ( propertyName ) ; if ( prop == null ) { props . put ( propertyName , prop = new Property ( propertyName ) ) ; } return prop ; } private ArrayList < Attribute > getAttrs ( ICompilationUnit unit ) throws Exception { ArrayList < Attribute > attrs = new ArrayList < Attribute > ( ) ; IType [ ] allTypes = unit . getAllTypes ( ) ; for ( IType type : allTypes ) { for ( IField", "gt": "field : type . getFields ( ) )", "prediction": "field : type . getFields ( ) )\n", "label": 1}
{"id": 6472, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Report ; import org . jjflyboy . tjpeditor . project . ReportPrefix ; public class ReportPrefixImpl extends IncludePropertiesAttributeImpl implements ReportPrefix { protected Report report ; protected ReportPrefixImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getReportPrefix ( ) ; } public Report getReport ( ) { if ( report != null && report . eIsProxy ( ) ) { InternalEObject oldReport = ( InternalEObject ) report ; report = ( Report ) eResolveProxy ( oldReport ) ; if ( report != oldReport ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . REPORT_PREFIX__REPORT , oldReport , report ) ) ; } } return report ; } public Report basicGetReport ( ) { return report ; } public void setReport ( Report newReport ) { Report oldReport = report ; report = newReport ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . REPORT_PREFIX__REPORT , oldReport , report ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . REPORT_PREFIX__REPORT : if ( resolve ) return getReport ( ) ; return basicGetReport ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . REPORT_PREFIX__REPORT : setReport ( ( Report ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . REPORT_PREFIX__REPORT : setReport ( ( Report ) null ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case", "gt": "ProjectPackage . REPORT_PREFIX__REPORT : return report != null ;", "prediction": "ProjectPackage . REPORT_PREFIX__REPORT : return report != null ;\n", "label": 0}
{"id": 15380, "input": "<s> package org . apache . lucene . queryParser . core ; import org . apache . lucene . messages . Message ; import org . apache . lucene . messages . NLSException ; public class QueryNodeError extends Error implements NLSException { private static final long serialVersionUID = 1804855832182710327L ; private Message message ; public QueryNodeError ( Message message ) { super ( message . getKey ( ) ) ; this . message = message ; }", "gt": "public QueryNodeError ( Throwable throwable )", "prediction": "public QueryNodeError ( String message )\n", "label": 1}
{"id": 4646, "input": "<s> import java . util . Random ; import java . util . Map ; import java . util . HashMap ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Scope . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . file . JavacFileManager ; public class CompoundScopeTest { public static void main ( String ... args ) throws Exception { new CompoundScopeTest ( ) . run ( args ) ; } static final int MAX_SYMBOLS_COUNT = 20 ; static final int PASSES = 10 ; void run ( String ... args ) throws Exception { int count = PASSES ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( \"-seed\" ) && ( i + 1 < args . length ) ) seed = Long . parseLong ( args [ ++ i ] ) ; else if ( arg . equals ( \"-tests\" ) && ( i + 1 < args . length ) ) count = Integer . parseInt ( args [ ++ i ] ) ; else throw new Exception ( \"unknown arg: \" + arg ) ; } rgen = new Random ( seed ) ; for ( int i = 0 ; i < count ; i ++ ) { Test t = new Test ( ) ; t . run ( ) ; } if ( errors > 0 ) throw new Exception ( errors + \" errors found\" ) ; } void log ( String msg ) { System . err . println ( msg ) ; } void error ( String msg ) { System . err . println ( \"Error: \" + msg ) ; errors ++ ; } Random rgen ; long seed = 0 ; int errors ; class Test { List < Symbol > elems = List . nil ( ) ; Map < Name , List < Symbol > > shadowedMap = new HashMap < Name , List < Symbol > > ( ) ; void run ( ) throws Exception { log ( \"starting test\" ) ; setup ( ) ; Scope [ ] scopes = { createScope ( rgen . nextInt ( MAX_SYMBOLS_COUNT ) ) , createScope ( rgen . nextInt ( MAX_SYMBOLS_COUNT ) ) , createScope ( rgen . nextInt ( MAX_SYMBOLS_COUNT ) ) } ; boolean [ ] [ ] scopeNesting = { { false , true , false , true } , { false , true , true , true } , { false , false , true , true } } ; for ( int i = 0 ; i < 4 ; i ++ ) { CompoundScope root = new CompoundScope ( symtab . noSymbol ) ; CompoundScope sub = new CompoundScope ( symtab . noSymbol ) ; boolean subAdded = false ; for (", "gt": "int sc = 0 ;", "prediction": "int j = 0 ;\n", "label": 0}
{"id": 15382, "input": "<s> package org . eclipse . ui . internal . part ; import org . eclipse . ui . part . MultiPageEditorSite ; public interface IMultiPageEditorSiteHolder { public", "gt": "MultiPageEditorSite getSite ( ) ;", "prediction": "MultiPageEditorSite getSite ( ) ;\n", "label": 1}
{"id": 9535, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . IncludePropertiesAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ;", "gt": "public class IncludePropertiesAttributeImpl extends MinimalEObjectImpl . Container implements IncludePropertiesAttribute", "prediction": "import org . jjflybreak . utils . EcoreUtil ;\n", "label": 0}
{"id": 15383, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . settings ; import com . digitalsanctum . idea . plugins . buildr . Buildr ; import com . digitalsanctum . idea . plugins . buildr . BuildrBundle ; import com . digitalsanctum . idea . plugins . buildr . BuildrComponents ; import com . intellij . openapi . components . ApplicationComponent ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . options . ConfigurationException ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; import javax . swing . * ; public class BuildrSettings implements ApplicationComponent , Configurable { private BuildrSettingsPane form ; @ NotNull public String getComponentName ( ) { return BuildrComponents . BUILDR_SETTINGS ; } public void initComponent ( ) { loadRegisteredData ( ) ; } public void disposeComponent ( ) { } @ Nls public String getDisplayName ( ) { return BuildrBundle . message ( \"settings.title\" ) ; } public Icon getIcon ( ) { return Buildr . BUILDR_32 ; } public String getHelpTopic ( ) { return null ; } public JComponent createComponent ( ) { if ( form == null ) { form = new BuildrSettingsPane ( ) ; } return form . getPanel ( ) ; } public boolean isModified ( ) { return form == null || form . isModified ( ) ; } public void apply ( ) throws ConfigurationException { if ( form != null ) { form", "gt": ". validate ( ) ;", "prediction": ". apply ( ) ;\n", "label": 1}
{"id": 3228, "input": "<s> package org . gk . engine . client . build . tree ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class TreeDirBuilder extends Builder { public TreeDirBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List subNodes = new gkList ( ) ; super . parserNode ( subNodes , node . getChildNodes ( ) ) ; XTreeDir tree", "gt": "= new XTreeDir ( node , subNodes ) ;", "prediction": "Dir = new XTreeDir ( ) ;\n", "label": 0}
{"id": 15389, "input": "<s> package org . apache . lucene . index ; import java . util . List ; import java . io . IOException ; public interface IndexDeletionPolicy {", "gt": "public void onInit ( List commits ) throws IOException ;", "prediction": "public List getDeletions ( ) ;\n", "label": 1}
{"id": 2286, "input": "<s> package me . chester . test ; import me . chester . minitruco . core . Carta ; import me . chester . minitruco . core . Jogador ; public class JogadorMock extends Jogador { private boolean aceitaMao11 = true ; private boolean aceitaAumento = true ; int cartaAtual ; @ Override public void inicioMao ( ) { System . out . println ( \"iniciomao\" + this ) ; cartaAtual = 0 ; } @ Override public void vez ( Jogador j , boolean podeFechada ) { final Jogador jogador = this ; System . out . println ( \"vez \" + j + \",\" + jogador ) ; if ( j . equals ( this ) ) { new Thread ( ) { @ Override public void run ( ) { jogo . jogaCarta ( jogador , jogador . getCartas ( ) [ cartaAtual ++ ] ) ; } } . start ( ) ; } } @ Override public void pediuAumentoAposta ( Jogador j , int valor ) { final Jogador jogador = this ; if ( j . getEquipe ( ) != this . getEquipe ( ) ) { new Thread ( ) { @ Override public void run ( ) { jogo . respondeAumento ( jogador , aceitaAumento ) ; } } . start ( ) ; } } @", "gt": "Override public void informaMao11 ( Carta [ ] cartasParceiro )", "prediction": "Override public void vezAmentoAposta ( Jogador j , int valor )\n", "label": 0}
{"id": 15391, "input": "<s> package org . eclipse . rap . rwt . lifecycle ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; public class WidgetUtil_Test extends TestCase { public void testFind ( ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; Composite composite = new Composite ( shell , SWT . NONE ) ; Button button = new Button ( composite , SWT . PUSH ) ; String shellId = WidgetUtil . getId ( shell ) ; String compositeId = WidgetUtil . getId ( composite ) ; String buttonId = WidgetUtil . getId ( button ) ; assertSame ( composite , WidgetUtil . find ( composite , compositeId ) ) ; assertSame ( button , WidgetUtil . find ( composite , buttonId ) ) ; assertSame ( composite , WidgetUtil . find ( composite , compositeId ) ) ; assertNull ( WidgetUtil . find ( composite , shellId ) ) ; } public void testGetVariant ( ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; String valid = \"Foo_Bar_23_42\" ; shell . setData ( RWT . CUSTOM_VARIANT , valid ) ; assertEquals ( valid , WidgetUtil . getVariant ( shell ) ) ; String withDash = \"Foo-Bar-23-42\" ; shell . setData ( RWT . CUSTOM_VARIANT , withDash ) ; assertEquals ( withDash , WidgetUtil . getVariant ( shell ) ) ; String withLeadingDash = \"-Foo-Bar-23-42\" ;", "gt": "shell . setData ( RWT . CUSTOM_VARIANT , withLeadingDash ) ;", "prediction": "shell . setData ( RWT . CUSTOM_VARIANT , withLeadingDash ) ;\n", "label": 1}
{"id": 9381, "input": "<s> package org . gk . ui . client . com . grid ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . toolbar . gkPageSizePlugin ; import com . extjs . gxt . ui . client . data . BasePagingLoadConfig ; import com . extjs . gxt . ui . client . data . BasePagingLoadResult ; import com . extjs . gxt . ui . client . data . BasePagingLoader ; import com . extjs . gxt . ui . client . data . RpcProxy ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . layout . FitLayout ; import com . extjs . gxt . ui . client . widget . toolbar . PagingToolBar ; import com . google . gwt . user . client . rpc . AsyncCallback ; public abstract class gkPageGridIC extends gkGridIC { protected final static String DATA = \"data\" ; protected final static String TOTALSIZE = \"totalSize\" ; protected final static String OFFSET = \"offset\" ; protected final static String LIMIT = \"pageSize\" ; private final static int PAGESIZE = 10 ; protected PagingToolBar toolbar ; protected BasePagingLoader pageLoader ; protected int totalSize ; protected boolean serverPaging ; protected boolean loadingPage ; private BarPosition barPosition ; public enum BarPosition { TOP , BOTTOM , TRUE } public gkPageGridIC ( BarPosition barPosition ) { this . barPosition = barPosition ; init ( ) ; } protected void init ( ) { setLayout ( new FitLayout ( ) ) ; pageLoader = createDataLoader ( ) ; store = new ListStore ( pageLoader ) ; grid = createGrid ( store , createColumnModel ( ) ) ; toolbar = new PagingToolBar ( PAGESIZE ) ; toolbar . addPlugin ( new gkPageSizePlugin ( ) ) ; toolbar . bind ( pageLoader ) ; add ( grid ) ; if ( barPosition == BarPosition . TOP ) { setTopComponent ( toolbar ) ; } else { setBottomComponent ( toolbar ) ; } addListener ( ) ; } @ Override public void bindEvent ( ) { } @ Override public void createNewRow ( String row ) { boolean noLimit = getLimit ( ) == 0 ? true : getTotalSize ( ) < getLimit ( ) ; int rowIndex = Integer . parseInt ( row ) ; if ( grid . getStore ( ) . getCount ( ) - 1 == rowIndex && noLimit ) { if ( getLimit ( ) != 0 ) { setTotalSize ( getTotalSize ( ) + 1 ) ; } if ( isAutoNewRow ( ) ) { addRow ( ) ; } } } @ Override protected void onResize ( int width , int height ) { String hideMode", "gt": "= getHideMode ( ) . value ( ) ;", "prediction": "= getHideMode ( ) ;\n", "label": 0}
{"id": 15394, "input": "<s> package org . eclipse . ui . forms . widgets ; import org . eclipse . swt . widgets . Composite ; public interface ILayoutExtension { public int computeMinimumWidth ( Composite parent , boolean changed ) ; public int computeMaximumWidth ( Composite parent", "gt": ", boolean changed ) ;", "prediction": ", boolean changed ) ;\n", "label": 1}
{"id": 7703, "input": "<s> package org . dawb . workbench . plotting . tools ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . dawb . common . ui . plot . IPlottingSystem ; import org . dawb . common . ui . plot . PlottingFactory ; import org . dawb . common . ui . plot . region . IROIListener ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . tool . AbstractToolPage ; import org . dawb . common . ui . plot . tool . IToolPageSystem ; import org . dawb . common . ui . plot . trace . ITraceListener ; import org . dawb . common . ui . plot . trace . TraceEvent ; import org . dawb . workbench . plotting . Activator ; import org . dawb . workbench . plotting . tools . MeasurementTool . RegionColorListener ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . MouseEvent ; import org . eclipse . draw2d . MouseListener ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . window . ToolTip ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . Clipboard ; import org . eclipse . swt . dnd . TextTransfer ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IActionBars ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . roi . PointROI ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; public class InfoPixelTool extends AbstractToolPage implements IROIListener , IRegionListener , MouseListener { private final static Logger logger = LoggerFactory . getLogger ( InfoPixelTool . class ) ; protected IPlottingSystem plotter ; private ITraceListener traceListener ; private IRegion xHair , yHair ; private Composite composite ; private TableViewer viewer ; private RegionColorListener viewUpdateListener ; private Map < String , ROIBase > dragBounds ; public double xValues [ ] = new double [ 1 ] ; public double yValues [ ] = new double [ 1 ] ; public InfoPixelTool ( ) { dragBounds = new HashMap < String , ROIBase > ( 7 ) ; try { plotter = PlottingFactory . createPlottingSystem ( ) ; this . traceListener = new ITraceListener . Stub ( ) { @ Override public void tracesPlotted ( TraceEvent evt ) { if ( ! ( evt . getSource ( ) instanceof List < ? > ) ) { return ; } } } ; } catch ( Exception e ) { logger . error ( \"Cannot get plotting system!\" , e ) ; } } @ Override public void createControl ( Composite parent ) { this . composite = new Composite ( parent , SWT . NONE ) ; composite . setLayout ( new FillLayout ( ) ) ; viewer = new TableViewer ( composite , SWT . FULL_SELECTION | SWT . SINGLE | SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; createColumns ( viewer ) ; viewer . getTable ( ) . setLinesVisible ( true ) ; viewer . getTable ( ) . setHeaderVisible ( true ) ; createActions ( ) ; getSite ( ) . setSelectionProvider ( viewer ) ; viewer . setContentProvider ( new IStructuredContentProvider ( ) { @ Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } @ Override public void dispose ( ) { } @ Override public Object [ ] getElements ( Object inputElement ) { final Collection < IRegion > regions = getPlottingSystem ( ) . getRegions ( ) ; if ( regions == null || regions . isEmpty ( ) ) return new Object [ ] { \"-\" } ; final List < IRegion > visible = new ArrayList < IRegion > ( ) ; for ( int i = 0 ; i < regions . size ( ) ; i ++ ) { IRegion pointRegion = ( IRegion ) ( regions . toArray ( ) ) [ i ] ; if ( pointRegion . getRegionType ( ) == RegionType . XAXIS_LINE || pointRegion . getRegionType ( ) == RegionType . POINT ) { visible . add ( pointRegion ) ; } } return visible . toArray ( new IRegion [ visible . size ( ) ] ) ; } } ) ; viewer . setInput ( new Object ( ) ) ; activate ( ) ; } @ Override public Object getAdapter ( @ SuppressWarnings ( \"rawtypes\" ) Class clazz ) { if", "gt": "( clazz == IToolPageSystem . class )", "prediction": "( clazz . isArray ( ) )\n", "label": 0}
{"id": 15400, "input": "<s> package org . eclipse . ui . statushandlers ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . application . WorkbenchAdvisor ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . statushandlers . IStatusDialogConstants ; import org . eclipse . ui . statushandlers . StatusManager . INotificationTypes ; public class WorkbenchErrorHandler extends AbstractStatusHandler { public boolean supportsNotification ( int type ) { if ( type == INotificationTypes . HANDLED ) { return true ; } return super . supportsNotification ( type ) ; } private WorkbenchStatusDialogManager statusDialogManager ; public void handle ( final StatusAdapter statusAdapter , int style ) { statusAdapter . setProperty ( WorkbenchStatusDialogManager . HINT , new Integer ( style ) ) ; if ( ( ( style & StatusManager . SHOW ) == StatusManager . SHOW ) || ( ( style & StatusManager . BLOCK ) == StatusManager . BLOCK ) ) { final boolean block = ( ( style & StatusManager . BLOCK ) == StatusManager . BLOCK ) ; if ( Display . getCurrent ( ) != null ) { showStatusAdapter ( statusAdapter , block ) ; } else { if ( block ) { Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { showStatusAdapter ( statusAdapter , true ) ; } } ) ; } else { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { showStatusAdapter ( statusAdapter , false ) ; } } ) ; } } } if ( ( style & StatusManager . LOG ) == StatusManager . LOG ) { StatusManager . getManager ( ) . addLoggedStatus ( statusAdapter . getStatus ( ) ) ; WorkbenchPlugin . getDefault ( ) . getLog ( ) . log ( statusAdapter . getStatus ( ) ) ; } } private void showStatusAdapter ( StatusAdapter statusAdapter , boolean block ) { if ( ! PlatformUI . isWorkbenchRunning ( ) ) { WorkbenchPlugin . log ( statusAdapter . getStatus ( ) ) ; return ; } getStatusDialogManager ( ) . addStatusAdapter ( statusAdapter , block ) ; if ( block ) { Shell shell ; while ( ( shell = getStatusDialogShell ( ) ) != null && ! shell . isDisposed ( ) ) { if ( ! shell . getDisplay (", "gt": ") . readAndDispatch ( ) )", "prediction": ") . isDisposed ( ) )\n", "label": 1}
{"id": 2928, "input": "<s> package org . remast . baralga . gui . model ; import java . beans . PropertyChangeEvent ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import javax . swing . JDialog ; import javax . swing . JOptionPane ; import org . apache . commons . lang . ObjectUtils ; import org . joda . time . DateTime ; import org . remast . baralga . gui . BaralgaMain ; import org . remast . baralga . gui . events . BaralgaEvent ; import org . remast . baralga . gui . lists . ProjectFilterList ; import org . remast . baralga . gui . model . edit . EditStack ; import org . remast . baralga . gui . model . report . HoursByDayReport ; import org . remast . baralga . gui . model . report . HoursByMonthReport ; import org . remast . baralga . gui . model . report . HoursByProjectReport ; import org . remast . baralga . gui . model . report . HoursByWeekReport ; import org . remast . baralga . gui . model . report . ObservingAccumulatedActivitiesReport ; import org . remast . baralga . gui . settings . UserSettings ; import org . remast . baralga . model . BaralgaDAO ; import org . remast . baralga . model . Project ; import org . remast . baralga . model . ProjectActivity ; import org . remast . baralga . model . filter . Filter ; import org . remast . baralga . model . io . DataBackup ; import org . remast . util . DateUtils ; import org . remast . util . TextResourceBundle ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import ca . odell . glazedlists . BasicEventList ; import ca . odell . glazedlists . SortedList ; import com . google . common . eventbus . EventBus ; public class PresentationModel { private EventBus eventBus = new EventBus ( ) ; public final EventBus getEventBus ( ) { return eventBus ; } @ SuppressWarnings ( \"unused\" ) private static final Logger log = LoggerFactory . getLogger ( PresentationModel . class ) ; private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaMain . class ) ; private final SortedList < Project > projectList ; private final SortedList < Project > allProjectsList ; private final", "gt": "SortedList < ProjectActivity > activitiesList ;", "prediction": "SortedList < Project > activitiesList ;\n", "label": 0}
{"id": 15402, "input": "<s> package org . eclipse . ui . dynamic . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; public final class DynamicHandler extends AbstractHandler { public", "gt": "final Object execute ( final ExecutionEvent event )", "prediction": "static final String ID = \"org.eclipse.ui.dynamic.handler\" ;\n", "label": 1}
{"id": 9354, "input": "<s> package com . asakusafw . example . summarization . gateway ; import com . asakusafw . example . summarization . modelgen . dmdl . csv . AbstractReceiptCsvInputDescription ; public class ReceiptFromCSV extends AbstractReceiptCsvInputDescription { @ Override public String getBasePath ( ) { return \"input\" ; } @ Override", "gt": "public String getResourcePattern ( )", "prediction": "public void setBasePath ( String basePath )\n", "label": 0}
{"id": 15404, "input": "<s> package org . eclipse . ui . tests . harness . tests ; import java . lang . reflect . UndeclaredThrowableException ; import junit . framework . TestCase ; import org . eclipse . ui . tests . harness . util . Mocks ; public class MocksTest extends TestCase { private IPrimitive primitiveMock ; private static boolean uninitializedBoolean ; private static byte unitializedByte ; private static char unitializedChar ; private static short unitializedShort ; private static int unitializedInt ; private static long unitializedLong ; private static float unitializedFloat ; private static double unitializedDouble ; protected void setUp ( ) throws Exception { primitiveMock = ( IPrimitive ) Mocks . createRelaxedMock ( IPrimitive . class ) ; } public void testPrimitiveBooleanReturnType ( ) throws Exception { try { boolean value = primitiveMock . getBoolean ( ) ; assertEquals ( uninitializedBoolean , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveBooleanSetLastReturnValue ( ) throws Exception { Boolean value = Boolean . TRUE ; primitiveMock . getBoolean ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . booleanValue ( ) , primitiveMock . getBoolean ( ) ) ; } public void testPrimitiveByteReturnType ( ) throws Exception { try { byte value = primitiveMock . getByte ( ) ; assertEquals ( unitializedByte , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveByteSetLastReturnValue ( ) throws Exception { Byte value = new Byte ( ( byte ) 1 ) ; primitiveMock . getByte ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . byteValue ( ) , primitiveMock . getByte ( ) ) ; } public void testPrimitiveCharReturnType ( ) throws Exception { try { char value = primitiveMock . getChar ( ) ; assertEquals ( unitializedChar , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveCharSetLastReturnValue ( ) throws Exception { Character value = new Character ( 'a' ) ; primitiveMock . getChar ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . charValue ( ) , primitiveMock . getChar ( ) ) ; } public void testPrimitiveShortReturnType ( ) throws Exception { try { short value = primitiveMock . getShort ( ) ; assertEquals ( unitializedShort , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveShortSetLastReturnValue ( ) throws Exception { Short value = new Short ( ( short ) 1 ) ; primitiveMock . getShort ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . shortValue ( ) , primitiveMock . getShort ( ) ) ; } public void testPrimitiveIntReturnType ( ) throws Exception { try { int value = primitiveMock . getInt ( ) ; assertEquals ( unitializedInt , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveIntSetLastReturnValue ( ) throws Exception { Integer value = new Integer ( 1 ) ; primitiveMock . getInt ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . intValue ( ) , primitiveMock . getInt ( ) ) ; } public void testPrimitiveLongReturnType ( ) throws Exception { try { long value = primitiveMock . getLong ( ) ; assertEquals ( unitializedLong , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveLongSetLastReturnValue ( ) throws Exception { Long value = new Long ( 1 ) ; primitiveMock . getLong ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . longValue ( ) , primitiveMock . getLong ( ) ) ; } public void testPrimitiveFloatReturnType ( ) throws Exception { try { float value = primitiveMock . getFloat ( ) ; assertEquals ( unitializedFloat , value , 0 ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveFloatSetLastReturnValue ( ) throws Exception { Float value = new Float ( 1 ) ; primitiveMock . getFloat ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . floatValue ( ) , primitiveMock . getFloat ( ) , 0 ) ; } public void testPrimitiveDoubleReturnType ( ) throws Exception { try { double value = primitiveMock . getDouble ( ) ; assertEquals ( unitializedDouble , value , 0 ) ; } catch ( UndeclaredThrowableException e ) { fail", "gt": "( \"exception should not have been thrown\" ) ;", "prediction": "( \"exception should not have been thrown\" ) ;\n", "label": 1}
{"id": 7587, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class ParameterValue extends Value { private final String name ; public ParameterValue ( String name ) { this . name = name ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public String getName ( ) { return name ; } @ Override public boolean equals ( Object o ) {", "gt": "if ( o instanceof ParameterValue )", "prediction": "if ( this == o ) return true ;\n", "label": 0}
{"id": 15417, "input": "<s> package org . nuxeo . webengine . sites . models ; import org . nuxeo", "gt": ". theme . models . AbstractModel ;", "prediction": ". ecm . core . api . ClientException ;\n", "label": 1}
{"id": 880, "input": "<s> package org . remast . baralga . gui . panels . report ; import info . clearthought . layout . TableLayout ; import java . awt . BorderLayout ; import java . util . Observable ; import java . util . Observer ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JTable ; import org . jdesktop . swingx . renderer . DefaultTableRenderer ; import org . jdesktop . swingx . renderer . FormatStringValue ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . model . report . ObservingAccumulatedActivitiesReport ; import org . remast . baralga . gui . panels . table . AccumulatedActivitiesTableFormat ; import org . remast . baralga . gui . panels . table . AccumulatedProjectActivityTextFilterator ; import org . remast . baralga . model . report . AccumulatedActivitiesReport ; import org . remast . baralga . model . report . AccumulatedProjectActivity ; import org . remast . swing . JSearchField ; import org . remast . swing . table . JHighligthedTable ; import ca . odell . glazedlists . FilterList ; import ca . odell . glazedlists . matchers . MatcherEditor ; import ca . odell . glazedlists . swing . EventTableModel ; import ca . odell . glazedlists . swing . TableComparatorChooser ; import ca . odell . glazedlists . swing . TextComponentMatcherEditor ; @ SuppressWarnings ( \"serial\" ) public class AccummulatedActitvitiesPanel extends JPanel implements Observer { private AccumulatedActivitiesReport report ; private EventTableModel < AccumulatedProjectActivity > tableModel ; public AccummulatedActitvitiesPanel ( final AccumulatedActivitiesReport report ) { this . report = report ; this . setLayout ( new BorderLayout ( ) ) ; this . report . addObserver ( this ) ; initialize ( ) ; } private void initialize ( ) { final JSearchField searchField = new JSearchField ( ) ; final MatcherEditor < AccumulatedProjectActivity > textMatcherEditor = new TextComponentMatcherEditor < AccumulatedProjectActivity > ( searchField , new AccumulatedProjectActivityTextFilterator ( ) ) ; final FilterList < AccumulatedProjectActivity > textFilteredIssues = new FilterList < AccumulatedProjectActivity > ( this . report . getAccumulatedActivitiesByDay ( ) , textMatcherEditor ) ; tableModel = new EventTableModel < AccumulatedProjectActivity > ( textFilteredIssues , new AccumulatedActivitiesTableFormat ( ) ) ; final JTable table = new JHighligthedTable ( tableModel ) ; TableComparatorChooser . install ( table , this . report . getAccumulatedActivitiesByDay ( ) , TableComparatorChooser . MULTIPLE_COLUMN_MOUSE ) ; table . getColumn ( table . getColumnName ( 0 ) ) . setCellRenderer ( new DefaultTableRenderer ( new", "gt": "FormatStringValue ( FormatUtils . DAY_FORMAT ) ) ) ;", "prediction": "JScrollPane ( table ) ) ) ;\n", "label": 0}
{"id": 15422, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import java . io . File ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; import org . nuxeo . ecm . core . storage . sql . coremodel . SQLBlob ; import org . nuxeo . runtime . services . streaming . FileSource ; import org . nuxeo . runtime . services", "gt": ". streaming . StreamSource ;", "prediction": ". streaming . BlobSource ;\n", "label": 1}
{"id": 3419, "input": "<s> class OverrideBridge1 { static class A < T > { public void foo ( T t ) { } } static", "gt": "class B extends A < String >", "prediction": "class A < T >\n", "label": 0}
{"id": 15425, "input": "<s> package fr . inria . zvtm . text ; public class PostfixTextShortener implements TextShortener { public static final PostfixTextShortener INSTANCE = new PostfixTextShortener ( ) ; private PostfixTextShortener ( ) { } public String shorten ( String source , int len ) { if ( len < 0 ) { throw new IllegalArgumentException ( \"len should be positive\" ) ; } int slen", "gt": "= source . length ( ) ;", "prediction": "= len ;\n", "label": 1}
{"id": 2026, "input": "<s> package org . ofbiz . minilang . method . callops ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . service . GenericServiceException ; import org . w3c . dom . Element ; public final class CallServiceAsynch extends MethodOperation { public static final String module = CallServiceAsynch . class . getName ( ) ; private final boolean includeUserLogin ; private final FlexibleMapAccessor < Map < String , Object > > inMapFma ; private final FlexibleStringExpander serviceNameFse ; public CallServiceAsynch ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"serviceName\" , \"in-map-name\" , \"include-user-login\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"include-user-login\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"service-name\" , \"in-map-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"service-name\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } serviceNameFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"service-name\" ) ) ; inMapFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"in-map-name\" ) ) ; includeUserLogin = ! \"false\" . equals ( element . getAttribute ( \"include-user-login\" ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { if ( methodContext . isTraceOn ( ) ) { outputTraceMessage ( methodContext , \"Begin call-service-asynch.\" ) ; } String serviceName = serviceNameFse . expandString ( methodContext . getEnvMap ( ) ) ; Map < String , Object > inMap = inMapFma . get ( methodContext . getEnvMap ( ) ) ; if ( inMap == null ) { inMap = FastMap . newInstance ( ) ; } if ( includeUserLogin ) { GenericValue userLogin = methodContext . getUserLogin ( ) ; if ( userLogin != null && inMap . get ( \"userLogin\" ) == null ) { inMap . put ( \"userLogin\" , userLogin ) ; } } Locale locale = methodContext . getLocale ( ) ; if ( locale != null ) { inMap . put ( \"locale\" , locale ) ; } try { if ( methodContext . isTraceOn ( ) ) { outputTraceMessage ( methodContext , \"Invoking service \\\"\" + serviceName + \"\\\", IN attributes:\" , inMap . toString ( ) ) ; } methodContext . getDispatcher ( ) . runAsync ( serviceName , inMap ) ; } catch ( GenericServiceException e ) { if ( methodContext . isTraceOn ( ) ) { outputTraceMessage ( methodContext , \"Service engine threw an exception: \" + e . getMessage ( ) + \", halting script execution. End call-service-asynch.\" ) ; } Debug . logError ( e , module ) ; String errMsg = \"ERROR: Could not complete the \" + simpleMethod . getShortDescription ( ) + \" process [problem invoking the \" + serviceName + \" service: \" + e . getMessage ( ) + \"]\" ; if ( methodContext . getMethodType ( ) == MethodContext . EVENT ) { methodContext . putEnv ( simpleMethod . getEventErrorMessageName ( ) , errMsg ) ; methodContext . putEnv ( simpleMethod . getEventResponseCodeName ( ) , simpleMethod . getDefaultErrorCode ( ) ) ; } else { methodContext . putEnv ( simpleMethod . getServiceErrorMessageName ( ) , errMsg ) ; methodContext . putEnv ( simpleMethod . getServiceResponseMessageName ( ) , simpleMethod . getDefaultErrorCode ( ) ) ; } return false ; } if ( methodContext . isTraceOn ( ) ) { outputTraceMessage ( methodContext , \"End call-service-asynch.\" ) ; } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { aic . addServiceName ( this . serviceNameFse . toString ( ) ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<call-service-asynch \" ) ; sb . append ( \"service-name=\\\"\" ) . append ( this . serviceNameFse ) . append ( \"\\\" \" ) ; if ( ! this . inMapFma . isEmpty ( ) ) { sb . append ( \"in-map-name=\\\"\" ) . append (", "gt": "this . inMapFma ) . append ( \"\\\" \" ) ;", "prediction": "this . inMapFse ) . append ( \"\\\" \" ) ;\n", "label": 0}
{"id": 15433, "input": "<s> package com . codeslap . persistence ; import java . util . ArrayList ; import java . util . List ; class Node { private final Class < ? > mContent ; private List < Node > children ; private Node mParent ; Node ( Class < ? > content ) { mContent = content ; } boolean addChild ( final Node child ) { if ( child . mContent == mContent ) { return false ; } List < Node > allButMe = allButMe ( ) ; if ( allButMe . contains ( child ) ) { return false ; } if ( children == null ) { children = new ArrayList < Node > ( ) ; } children . add ( child ) ; child . setParent ( this ) ; return true ; } List < Node > allButMe ( ) { Node root = this ; do { Node parent = root . getParent ( ) ; if ( parent == null ) { break ; } root = parent ; } while ( true ) ; List < Node > allButMe = new ArrayList < Node > ( ) { @ Override public boolean add ( Node node ) { if ( contains ( node ) ) { return false ; } return super . add ( node ) ; } } ; if ( root . mContent != mContent ) { allButMe . add ( root ) ; } allButMe ( root , allButMe , this ) ; return allButMe ; } private void allButMe ( Node node , List < Node > list , Node me ) { if ( node . children == null || node .", "gt": "children . size ( ) == 0 )", "prediction": "children . isEmpty ( ) )\n", "label": 1}
{"id": 8641, "input": "<s> class T6795580 { class Outer < S > { class Inner < T > { } } void cast1 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < Integer > . Inner < Long > [ ] ) p ; } void cast2 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < ? extends Number > . Inner < Long > [ ] ) p ; } void cast3 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < Integer > . Inner < ? extends Number > [ ] ) p ; } void cast4 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < ? extends Number > . Inner < ? extends Number > [ ] ) p ; } void cast5 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < ? super Number > . Inner < Long > [ ] ) p ; } void cast6 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < Integer > . Inner < ? super Number > [ ] ) p ; } void cast7 ( Outer < Integer > . Inner < Long > [ ] p ) { Object o = ( Outer < ? super Number > . Inner < ?", "gt": "super Number > [ ] ) p ;", "prediction": "super Number > [ ] ) p ;\n", "label": 0}
{"id": 15434, "input": "<s> package org . jscsi . target . scsi . inquiry ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . IResponseData ; import org . jscsi . target . scsi . cdb . ScsiOperationCode ; public final class StandardInquiryData implements IResponseData { private static final int SIZE = 36 ; private static final String VENDOR_ID = \"disyUKon\" ; private static final int VENDOR_ID_FIELD_POSITION = 8 ; private static final int VENDOR_ID_FIELD_LENGTH = 8 ; private static final String PRODUCT_ID = \"jSCSI Target\" ; private static final int PRODUCT_ID_FIELD_POSITION = 16 ; private static final int PRODUCT_ID_FIELD_LENGTH = 16 ; private static final String PRODUCT_REVISION_LEVEL = \"1.00\" ; private static final int PRODUCT_REVISION_LEVEL_FIELD_POSITION = 32 ; private static final int PRODUCT_REVISION_LEVEL_FIELD_LENGTH = 4 ; private static StandardInquiryData instance ; private StandardInquiryData ( ) { } public static StandardInquiryData getInstance ( ) { if ( instance == null ) instance = new StandardInquiryData ( ) ; return instance ; } public void serialize ( ByteBuffer byteBuffer , int index ) { byteBuffer . position ( index ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 0x05 ) ; byteBuffer . put ( ( byte ) 2 ) ; byteBuffer . put ( ( byte ) 31 ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 128 ) ; byteBuffer . put ( ( byte ) 0 ) ; putString ( byteBuffer , VENDOR_ID , index + VENDOR_ID_FIELD_POSITION , VENDOR_ID_FIELD_LENGTH ) ; putString ( byteBuffer , PRODUCT_ID , index + PRODUCT_ID_FIELD_POSITION , PRODUCT_ID_FIELD_LENGTH ) ; putString ( byteBuffer , PRODUCT_REVISION_LEVEL , index + PRODUCT_REVISION_LEVEL_FIELD_POSITION , PRODUCT_REVISION_LEVEL_FIELD_LENGTH ) ; } private void putString ( final ByteBuffer byteBuffer , final String string , final int position , final int fieldLength ) { byteBuffer . position ( position ) ; final int stringLength = Math . min ( string . length ( ) , fieldLength ) ; for ( int i = 0 ; i < stringLength ; ++ i ) byteBuffer . put ( ( byte ) string . charAt ( i ) ) ; for ( int i = stringLength ; i < fieldLength ; ++ i ) byteBuffer . put ( (", "gt": "byte ) 0 ) ;", "prediction": "byte ) 0 ) ;\n", "label": 1}
{"id": 447, "input": "<s> package org . ofbiz . base . container ; import java . net . UnknownHostException ; import java . rmi . registry . Registry ; import java . rmi . registry . LocateRegistry ; import java . rmi . RemoteException ; import java . rmi . NoSuchObjectException ; import java . rmi . server . UnicastRemoteObject ; import org . ofbiz . base . util . RMIExtendedSocketFactory ; public class NamingServiceContainer implements Container { public static final String module = NamingServiceContainer . class . getName ( ) ; protected String configFileLocation = null ; protected boolean isRunning = false ; protected Registry registry = null ; protected int namingPort = 1099 ; protected String namingHost = null ; protected RMIExtendedSocketFactory rmiSocketFactory ; private String name ; public void init ( String [ ] args , String name , String configFile ) throws ContainerException { this . name = name ; this . configFileLocation = configFile ; ContainerConfig . Container cfg = ContainerConfig . getContainer ( name , configFileLocation ) ; ContainerConfig . Container . Property port = cfg . getProperty ( \"port\" ) ; if ( port . value != null ) { try { this . namingPort = Integer . parseInt ( port . value ) ; } catch ( Exception e ) { throw new ContainerException ( \"Invalid port defined in container [naming-container] configuration; not a valid int\" ) ; } } ContainerConfig . Container . Property host = cfg . getProperty ( \"host\" ) ; if ( host != null && host . value != null ) { this .", "gt": "namingHost = host . value ;", "prediction": "namingHost = host . value ;\n", "label": 0}
{"id": 15435, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . util . Arrays ; public class QxAnimation implements QxType { public Animation [ ] animations ; public QxAnimation ( ) { animations = new Animation [ 0 ] ; } public void addAnimation ( String name , int duration , String timingFunction ) { Animation animation = new Animation ( name , duration , timingFunction ) ; Animation [ ] newAnimations = new Animation [ animations . length + 1 ] ; System . arraycopy ( animations , 0 , newAnimations , 0 , animations . length ) ; newAnimations [ animations . length ] = animation ; animations = newAnimations ; } public String toDefaultString ( ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < animations . length ; i ++ ) { if ( result . length ( ) != 0 ) { result . append ( \", \" ) ; } result . append ( animations [ i ] . name ) ; result . append ( \" \" ) ; result . append ( animations [ i ] . duration ) ; result . append ( \"ms \" ) ; result . append ( animations [ i ] . timingFunction ) ; } return result . toString ( ) ; } @ Override public String toString ( ) { return \"QxAnimation{ \" + toDefaultString ( ) + \" }\" ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( animations ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } QxAnimation other = ( QxAnimation ) obj ; if ( ! Arrays . equals ( animations , other . animations ) ) { return false ; } return true ; } public static String toCamelCaseString ( String string ) { StringBuilder result = new StringBuilder ( ) ; boolean toUpperCase = false ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { char ch = string . charAt ( i ) ; if ( ch == '-' ) { toUpperCase = true ; } else if ( toUpperCase ) { result . append ( Character . toUpperCase ( ch ) ) ; toUpperCase = false ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static final class Animation { private static final String [ ] PREDEFINED_NAMES = new String [ ] { \"hoverIn\" , \"hoverOut\" , \"fadeIn\" , \"fadeOut\" , \"slideIn\" , \"slideOut\" , \"flyInLeft\" , \"flyInTop\" , \"flyInRight\" , \"flyInBottom\" , \"flyOutLeft\" , \"flyOutTop\" , \"flyOutRight\" , \"flyOutBottom\" } ; private static final String [ ] PREDEFINED_TIMING_FUNCTIONS = new String [ ] { \"ease\" , \"linear\" , \"ease-in\" , \"ease-out\" , \"ease-in-out\" } ; public final String name ; public final int duration ; public final String timingFunction ; private Animation ( String name , int duration , String timingFunction ) { checkName ( name ) ; checkTimingFunction ( timingFunction ) ; this . name = name ; this . duration = duration ; this . timingFunction = timingFunction ; } private void checkName ( String name ) { boolean result = false ; if ( name == null ) { throw new NullPointerException ( \"null argument\" ) ; } for ( int i = 0 ; i < PREDEFINED_NAMES . length && ! result ; i ++ ) { if ( name . equals ( PREDEFINED_NAMES [ i ] ) ) { result = true ; } } if ( ! result ) { String msg = \"Invalid value for animation name: \" + name ; throw new IllegalArgumentException ( msg ) ; } } private void checkTimingFunction ( String timingFunction ) { boolean result = false ; if ( timingFunction == null ) { throw new NullPointerException ( \"null argument\" ) ; } for ( int i = 0 ; i < PREDEFINED_TIMING_FUNCTIONS . length && ! result ; i ++ ) { if ( timingFunction . equals ( PREDEFINED_TIMING_FUNCTIONS [ i ] ) ) { result = true ; } } if ( ! result ) { String msg = \"Invalid value for animation timing function: \" + timingFunction ; throw new IllegalArgumentException ( msg ) ; } } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + duration ; result = prime * result + ( ( name == null ) ? 0 : name", "gt": ". hashCode ( ) ) ;", "prediction": ". hashCode ( ) ) ;\n", "label": 1}
{"id": 4365, "input": "<s> package org . ofbiz . entity . config ; import java . util . List ; import org . w3c . dom . Element ; import org . ofbiz . base . util . UtilXml ; import javolution . util . FastList ; public abstract class ResourceInfo extends NamedInfo { public List < Element > resourceElements = FastList . newInstance ( ) ; public ResourceInfo ( Element element ) { super ( element ) ; resourceElements . addAll ( UtilXml . childElementList", "gt": "( element , \"resource\" ) ) ;", "prediction": "( element ) ) ;\n", "label": 0}
{"id": 15436, "input": "<s> package br . org . archimedes . interfaces ; import java . util . Collection ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes", "gt": ". model . Rectangle ;", "prediction": ". model . Vector ;\n", "label": 1}
{"id": 5294, "input": "<s> package ar . com . fdvs . dj . domain . constants ; import net . sf . jasperreports . engine . JRGraphicElement ; public class Border extends BaseDomainConstant { private static final long serialVersionUID = 1L ; public static Border NO_BORDER = new Border ( JRGraphicElement . PEN_NONE ) ; public static Border THIN = new Border ( JRGraphicElement . PEN_THIN ) ; public static Border PEN_1_POINT = new Border ( JRGraphicElement . PEN_1_POINT ) ; public static Border PEN_2_POINT = new Border ( JRGraphicElement . PEN_2_POINT ) ; public static Border PEN_4_POINT = new Border ( JRGraphicElement . PEN_4_POINT ) ; public static Border DOTTED = new Border (", "gt": "JRGraphicElement . PEN_DOTTED ) ;", "prediction": "JRGraphicElement . DOTTED ) ;\n", "label": 0}
{"id": 15437, "input": "<s> package org . nuxeo . ecm . webengine . test ; import org . nuxeo . runtime . test . runner . web . WebPage ; import com . google . inject . Inject ; public class ModulePage extends WebPage { @ Inject protected WebEngineHomePage home ;", "gt": "public WebEngineHomePage getHome ( )", "prediction": "public ModulePage ( )\n", "label": 1}
{"id": 3867, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import java . util . HashMap ; import java . util . Map ; import com . redhat . ceylon . compiler . java . codegen . AbstractTransformer . BoxingStrategy ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AssignmentOp ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . BinaryOperatorExpression ; import com . sun . tools . javac . tree . JCTree ; public class Operators { private enum PrimitiveType { BOOLEAN , CHARACTER , INTEGER , FLOAT , STRING ; } private static final PrimitiveType [ ] IntegerFloat = new PrimitiveType [ ] { PrimitiveType . INTEGER , PrimitiveType . FLOAT } ; private static final PrimitiveType [ ] IntegerCharacter = new PrimitiveType [ ] { PrimitiveType . INTEGER , PrimitiveType . CHARACTER } ; private static final PrimitiveType [ ] IntegerFloatCharacter = new PrimitiveType [ ] { PrimitiveType . INTEGER , PrimitiveType . FLOAT , PrimitiveType . CHARACTER } ; private static final PrimitiveType [ ] IntegerFloatString = new PrimitiveType [ ] { PrimitiveType . INTEGER , PrimitiveType . FLOAT , PrimitiveType . STRING } ; private static final PrimitiveType [ ] All = PrimitiveType . values ( ) ; public enum OptimisationStrategy { OPTIMISE ( true , BoxingStrategy . UNBOXED ) , OPTIMISE_BOXING ( false , BoxingStrategy . INDIFFERENT ) , NONE ( false , BoxingStrategy . BOXED ) ; private BoxingStrategy boxingStrategy ; private boolean useJavaOperator ; OptimisationStrategy ( boolean useJavaOperator , BoxingStrategy boxingStrategy ) { this . useJavaOperator = useJavaOperator ; this . boxingStrategy = boxingStrategy ; } public BoxingStrategy getBoxingStrategy ( ) { return boxingStrategy ; } public boolean useJavaOperator ( ) { return useJavaOperator ; } } public enum OperatorTranslation { UNARY_POSITIVE ( Tree . PositiveOp . class , 1 , \"positiveValue\" , JCTree . POS , IntegerFloat ) , UNARY_NEGATIVE ( Tree . NegativeOp . class , 1 , \"negativeValue\" , JCTree . NEG , IntegerFloat ) , UNARY_BITWISE_NOT ( \"ceylon.language.Integer\" , 1 , \"not\" , JCTree . COMPL , PrimitiveType . INTEGER ) , UNARY_POSTFIX_INCREMENT ( Tree . PostfixIncrementOp . class , 1 , \"getSuccessor\" , JCTree . POSTINC , IntegerCharacter ) , UNARY_POSTFIX_DECREMENT ( Tree . PostfixDecrementOp . class , 1 , \"getPredecessor\" , JCTree . POSTDEC , IntegerCharacter ) , UNARY_PREFIX_INCREMENT ( Tree . IncrementOp . class , 1 , \"getSuccessor\" , JCTree . PREINC , IntegerCharacter ) , UNARY_PREFIX_DECREMENT ( Tree . DecrementOp . class , 1 , \"getPredecessor\" , JCTree . PREDEC , IntegerCharacter ) , BINARY_SUM ( Tree . SumOp . class , 2 , \"plus\" , JCTree . PLUS , IntegerFloatString ) , BINARY_DIFFERENCE ( Tree . DifferenceOp . class , 2 , \"minus\" , JCTree . MINUS , IntegerFloat ) , BINARY_PRODUCT ( Tree . ProductOp . class , 2 , \"times\" , JCTree . MUL , IntegerFloat ) , BINARY_QUOTIENT ( Tree . QuotientOp . class , 2 , \"divided\" , JCTree . DIV , IntegerFloat ) , BINARY_POWER ( Tree . PowerOp . class , 2 , \"power\" ) , BINARY_REMAINDER ( Tree . RemainderOp . class , 2 , \"remainder\" , JCTree . MOD , PrimitiveType . INTEGER ) , BINARY_BITWISE_AND ( \"ceylon.language.Integer\" , 2 , \"and\" , JCTree . BITAND , PrimitiveType . INTEGER ) , BINARY_BITWISE_OR ( \"ceylon.language.Integer\" , 2 , \"or\" , JCTree . BITOR , PrimitiveType . INTEGER ) , BINARY_BITWISE_XOR ( \"ceylon.language.Integer\" , 2 , \"xor\" , JCTree . BITXOR , PrimitiveType . INTEGER ) , BINARY_BITWISE_LOG_LEFT_SHIFT ( \"ceylon.language.Integer\" , 2 , \"leftLogicalShift\" , JCTree . SL , PrimitiveType . INTEGER ) , BINARY_BITWISE_LOG_RIGHT_SHIFT ( \"ceylon.language.Integer\" , 2 , \"rightLogicalShift\" , JCTree . USR , PrimitiveType . INTEGER ) , BINARY_BITWISE_ARI_RIGHT_SHIFT ( \"ceylon.language.Integer\" , 2 , \"rightArithmeticShift\" , JCTree . SR , PrimitiveType . INTEGER ) , BINARY_AND ( Tree . AndOp . class , 2 , \"<not-used>\" , JCTree . AND , PrimitiveType . BOOLEAN ) , BINARY_OR ( Tree . OrOp . class , 2 , \"<not-used>\" , JCTree . OR , PrimitiveType . BOOLEAN ) , BINARY_UNION ( Tree . UnionOp . class , 2 , \"union\" ) , BINARY_INTERSECTION ( Tree . IntersectionOp . class , 2 , \"intersection\" ) , BINARY_XOR ( Tree . XorOp . class , 2 , \"exclusiveUnion\" ) , BINARY_COMPLEMENT ( Tree . ComplementOp . class , 2 , \"complement\" ) , BINARY_EQUAL ( Tree . EqualOp . class , 2 , \"equals\" , JCTree . EQ , All ) { @ Override public OptimisationStrategy getOptimisationStrategy ( BinaryOperatorExpression t , AbstractTransformer gen ) { if ( ! t . getUnboxed ( ) ) return OptimisationStrategy . NONE ; OptimisationStrategy left = isTermOptimisable ( t . getLeftTerm ( ) , gen ) ; OptimisationStrategy right = isTermOptimisable ( t . getRightTerm ( ) , gen ) ; if ( left == OptimisationStrategy . OPTIMISE && right == OptimisationStrategy . OPTIMISE ) { ProducedType leftType = t . getLeftTerm ( ) . getTypeModel ( ) ; ProducedType rightType =", "gt": "t . getRightTerm ( ) . getTypeModel ( ) ;", "prediction": "t . getRightTerm ( ) . getTypeModel ( ) ;\n", "label": 0}
{"id": 15438, "input": "<s> package org . apache . lucene . analysis . sinks ; import org . apache . lucene . analysis . SinkTokenizer ; import org . apache . lucene . analysis . TeeSinkTokenFilter ; import org . apache . lucene . analysis . Token ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . List ; import java . util . Date ; public class DateRecognizerSinkTokenizer extends SinkTokenizer { public static final String DATE_TYPE = \"date\" ; protected DateFormat dateFormat ; public DateRecognizerSinkTokenizer ( ) { this ( null , SimpleDateFormat . getDateInstance ( ) ) ; } public DateRecognizerSinkTokenizer ( DateFormat dateFormat ) { this ( null , dateFormat ) ; } public DateRecognizerSinkTokenizer ( List input ) { this ( input , SimpleDateFormat . getDateInstance ( ) ) ; } public DateRecognizerSinkTokenizer ( List input , DateFormat dateFormat ) { super ( input ) ; this . dateFormat = dateFormat ; } public void add ( Token t ) { if ( t != null ) { try { Date date = dateFormat . parse ( t", "gt": ". term ( ) ) ;", "prediction": ". getValue ( ) ) ;\n", "label": 1}
{"id": 9631, "input": "<s> package me . moocar . logbackgelf ; import java . util . Arrays ; public class ChunkFactory { private final byte [ ] chunkedGelfId ; private final boolean padSeq ; public ChunkFactory ( byte [ ] chunked_gelf_id , boolean padSeq ) { chunkedGelfId = chunked_gelf_id ; this . padSeq = padSeq ; } public byte [ ] create ( byte [ ] messageId , byte seqNum , byte numChunks , byte [ ] subPayload ) { return concatArrays ( concatArrays ( concatArrays ( chunkedGelfId , messageId ) , getSeqNumbers ( seqNum , numChunks ) ) , subPayload ) ; } private byte [ ] concatArrays ( byte [ ] array1 , byte [ ] array2 ) { byte [ ] finalArray = Arrays . copyOf ( array1 , array2 . length + array1 . length ) ; System . arraycopy ( array2 , 0 , finalArray , array1 . length , array2 . length ) ; return finalArray ; } private byte [ ] getSeqNumbers (", "gt": "byte seqNum , byte numChunks )", "prediction": ")\n", "label": 0}
{"id": 15440, "input": "<s> package com . puppycrawl . tools . checkstyle . bcel . classfile ; import java . util . Set ; import org . apache . bcel . classfile . FieldOrMethod ; import com . puppycrawl . tools . checkstyle . api . Scope ; public class Utils { public static boolean inScope ( FieldOrMethod aFieldOrMethod , Set aScopes ) { if ( aFieldOrMethod . isPrivate ( ) ) { return ( aScopes . contains ( Scope . PRIVATE ) ) ; } else if ( aFieldOrMethod . isProtected ( ) ) { return ( aScopes . contains (", "gt": "Scope . PROTECTED ) ) ;", "prediction": "Scope . PROTECTED ) ) ;\n", "label": 1}
{"id": 4902, "input": "<s> package com . sun . tools . javac . code ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . Map ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . Options ; import com . sun . tools . javac . util . Pair ; import static com . sun . tools . javac . code . Flags . * ; public class Lint { protected static final Context . Key < Lint > lintKey = new Context . Key < Lint > ( ) ; public static Lint instance ( Context context ) { Lint instance = context . get ( lintKey ) ; if ( instance == null ) instance = new Lint ( context ) ; return instance ; } public Lint augment ( Attribute . Compound attr ) { return augmentor . augment ( this , attr ) ; } public Lint augment ( List < Attribute . Compound > attrs ) { return augmentor . augment ( this , attrs ) ; } public Lint augment ( List < Attribute . Compound > attrs , long flags ) { Lint l = augmentor . augment ( this , attrs ) ; if ( ( flags & DEPRECATED ) != 0 ) { if ( l == this ) l = new Lint ( this ) ; l . values . remove ( LintCategory . DEPRECATION ) ; l . suppressedValues . add ( LintCategory . DEPRECATION ) ; } return l ; } private final AugmentVisitor augmentor ; private final EnumSet < LintCategory > values ; private final EnumSet < LintCategory > suppressedValues ; private static Map < String , LintCategory > map = new HashMap < String , LintCategory > ( ) ; protected Lint ( Context context ) { Options options = Options . instance ( context ) ; values = EnumSet . noneOf ( LintCategory . class ) ; for ( Map . Entry < String , LintCategory > e : map . entrySet ( ) ) { if ( options . lint ( e . getKey ( ) ) ) values . add ( e . getValue ( ) ) ; } suppressedValues = EnumSet . noneOf ( LintCategory . class ) ; context . put ( lintKey , this ) ; augmentor = new AugmentVisitor ( context ) ; } protected Lint ( Lint other ) { this . augmentor = other . augmentor ; this . values = other . values . clone ( ) ; this . suppressedValues = other . suppressedValues . clone ( ) ; } @ Override public String toString ( ) { return \"Lint:[values\" + values + \" suppressedValues\" + suppressedValues + \"]\" ; } public enum LintCategory { CAST ( \"cast\" ) , CLASSFILE ( \"classfile\" ) , DEPRECATION ( \"deprecation\" ) , DEP_ANN ( \"dep-ann\" ) , DIVZERO ( \"divzero\" ) , EMPTY ( \"empty\" ) , FALLTHROUGH ( \"fallthrough\" ) , FINALLY ( \"finally\" ) , OPTIONS ( \"options\" ) , OVERRIDES ( \"overrides\" ) , PATH ( \"path\" ) , PROCESSING ( \"processing\" ) , RAW ( \"rawtypes\" ) , SERIAL ( \"serial\" ) , STATIC ( \"static\" ) , SUNAPI ( \"sunapi\" , true ) , TRY ( \"try\" ) , UNCHECKED ( \"unchecked\" ) , VARARGS ( \"varargs\" ) ; LintCategory ( String option ) { this ( option , false ) ; } LintCategory ( String option , boolean hidden ) { this . option = option ; this . hidden = hidden ; map . put ( option , this ) ; } static LintCategory get ( String option ) { return map . get ( option ) ; } public final String option ; public final boolean hidden ; } ; public boolean isEnabled ( LintCategory lc ) { return values . contains ( lc ) ; } public boolean isSuppressed ( LintCategory lc ) { return suppressedValues . contains ( lc ) ; } protected static class AugmentVisitor implements Attribute . Visitor { private final Context context ; private Symtab syms ; private Lint parent ; private Lint lint ; AugmentVisitor ( Context context ) { this . context = context ; } Lint augment ( Lint parent , Attribute . Compound attr ) { initSyms ( ) ; this . parent = parent ; lint = null ; attr . accept ( this ) ; return ( lint == null ? parent : lint ) ; } Lint augment ( Lint parent , List < Attribute . Compound > attrs ) { initSyms ( ) ; this . parent = parent ; lint = null ; for ( Attribute . Compound a : attrs ) { a . accept ( this ) ; } return ( lint == null ? parent : lint ) ; } private void initSyms ( ) { if ( syms == null ) syms = Symtab . instance ( context ) ; } private void suppress ( LintCategory lc ) { if ( lint == null ) lint = new Lint ( parent ) ; lint . suppressedValues . add ( lc ) ; lint . values . remove ( lc ) ; } public void visitConstant ( Attribute . Constant value ) { if ( value . type . tsym == syms . stringType . tsym ) { LintCategory lc = LintCategory . get ( ( String )", "gt": "( value . value ) ) ;", "prediction": "value . value ) ;\n", "label": 0}
{"id": 15441, "input": "<s> package org . mitre . jwt . signer . impl ; import java . io . UnsupportedEncodingException ; import java . nio . charset . Charset ; import java . security . GeneralSecurityException ; import java . security . NoSuchAlgorithmException ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import org . apache . commons . codec . binary . Base64 ; import org . mitre . jwt . signer . AbstractJwtSigner ; import org . mitre . jwt . signer . JwsAlgorithm ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . util . Assert ; public class HmacSigner extends AbstractJwtSigner implements InitializingBean { public static final String DEFAULT_PASSPHRASE = \"changeit\" ; public static final JwsAlgorithm DEFAULT_ALGORITHM = JwsAlgorithm . HS256 ; private static Logger logger = LoggerFactory . getLogger ( HmacSigner . class ) ; private Mac mac ; private String passphrase = DEFAULT_PASSPHRASE ; public HmacSigner ( ) { super ( DEFAULT_ALGORITHM ) ; } public HmacSigner ( byte [ ] passphraseAsRawBytes ) throws NoSuchAlgorithmException { this ( DEFAULT_ALGORITHM . getJwaName ( ) , new String ( passphraseAsRawBytes , Charset . forName ( \"UTF-8\" ) ) ) ; } public HmacSigner ( String passphrase ) throws NoSuchAlgorithmException { this ( DEFAULT_ALGORITHM . getJwaName ( ) , passphrase ) ; } public HmacSigner ( String algorithmName , byte [ ] passphraseAsRawBytes ) throws NoSuchAlgorithmException { this ( algorithmName , new String ( passphraseAsRawBytes , Charset . forName ( \"UTF-8\" ) ) ) ; } public HmacSigner ( String algorithmName , String passphrase ) { super ( JwsAlgorithm . getByJwaName ( algorithmName ) ) ; Assert . notNull ( passphrase , \"A passphrase must be supplied\" ) ; setPassphrase ( passphrase ) ; } @ Override public void afterPropertiesSet ( ) { initializeMac ( ) ; } @ Override public String generateSignature ( String signatureBase ) throws NoSuchAlgorithmException { initializeMac ( ) ; if ( passphrase == null ) { throw new IllegalArgumentException ( \"Passphrase cannot be null\" ) ; } try { mac . init ( new SecretKeySpec ( getPassphrase ( ) . getBytes ( ) , mac . getAlgorithm ( ) ) ) ; mac . update ( signatureBase . getBytes ( \"UTF-8\" ) ) ; } catch ( GeneralSecurityException e ) { logger . error ( \"GeneralSecurityException in HmacSigner.java: \" , e ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( \"UnsupportedEncodingException in HmacSigner.java: \" , e ) ; } byte [ ] sigBytes = mac . doFinal ( ) ; String sig = new String ( Base64 . encodeBase64URLSafe ( sigBytes ) ) ; sig = sig . replace ( \"=\" , \"\" ) ; return sig ; } public String getPassphrase ( ) { return passphrase ; } public void setPassphrase ( byte [ ] rawbytes ) { this . setPassphrase ( new String ( rawbytes , Charset . forName ( \"UTF-8\" ) ) ) ; } public void setPassphrase ( String passphrase ) { this", "gt": ". passphrase = passphrase ;", "prediction": ". setPassphrase ( passphrase ) ;\n", "label": 1}
{"id": 4296, "input": "<s> package qualifiedNewScope ; class A { class B { } public static void main ( String [ ] args ) { new A ( ) { }", "gt": ". new B ( )", "prediction": ";\n", "label": 0}
{"id": 15442, "input": "<s> package org . seage . grammar ; import org . seage . data . DataNode ; import java . util . * ; public class NonterminalSymbol implements Symbol { private static final long serialVersionUID = - 1930442234125327450L ; public NonterminalSymbol ( String name ) { this . name = name ; children = new Vector < Symbol > ( ) ; rule = null ; } public NonterminalSymbol ( NonterminalSymbol other ) { this ( other . name ) ; } public Object eval ( DataNode symbolTable ) { try { return rule . eval ( symbolTable , this ) ; } catch ( Exception e ) { System . err . println ( \"GOT ERROR: \" + e ) ; e . printStackTrace ( ) ; return null ; } } public Symbol optimize ( ) { try { return rule . optimize ( this ) ; } catch ( Exception e ) { System . err . println ( \"GOT ERROR: \" + e ) ; return null ; } } public void expand ( Stack < NonterminalSymbol > stack , GrammarRule rule ) { this . rule = rule ; Vector < Symbol > right = rule . getRight ( ) ; Iterator < Symbol > it = right . iterator ( ) ; int i = stack . size ( ) ; while ( it . hasNext ( ) ) { Symbol s = ( Symbol ) it . next ( ) ; if ( s . getType ( ) == Symbol . Type . NONTERMINAL ) { NonterminalSymbol sn = new NonterminalSymbol ( ( NonterminalSymbol ) s ) ; children . add ( sn ) ; stack . add ( i , sn ) ; } else { TerminalSymbol ts = ( TerminalSymbol ) s . copy ( ) ; ts . pick ( ) ; children . add ( ts ) ; } } } public Vector < Symbol > getChildren ( ) { return children ; } public String toString ( ) { return name ; } public String getStringTree ( ) { String ret = new String ( ) ; for ( Symbol s : children ) { if ( s . getType ( ) == Symbol . Type . TERMINAL ) ret += s . toString ( ) ; else { ret += ( ( NonterminalSymbol ) ( s ) ) . getStringTree ( ) ; } } return ret ; } public String getSymbolTree ( ) { Iterator < Symbol > it = children . iterator ( ) ; Iterator < ? > rit = rule . getRight ( ) . iterator ( ) ; String ret = new String ( ) ; while ( rit . hasNext ( ) ) { Symbol s = ( Symbol ) rit . next ( ) ; if ( s . getType ( ) == Symbol . Type . TERMINAL ) ret += s . toString ( ) ; else { ret += ( ( NonterminalSymbol ) ( it . next ( ) ) ) . getStringTree ( ) ; } } return ret ; } public Symbol copy ( ) { return ( Symbol ) new NonterminalSymbol ( this ) ; } protected Vector < Symbol > children ; protected GrammarRule rule ; protected String name ; public boolean equals ( Object b ) { return ( b instanceof NonterminalSymbol ) && ( ( NonterminalSymbol ) b ) . name . equals ( this . name ) ; } public int hashCode ( ) { return name . hashCode ( ) ; }", "gt": "public Type getType ( )", "prediction": "public String toString ( )\n", "label": 1}
{"id": 4083, "input": "<s> import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . StringTokenizer ; class aMain { static int pecaCount ; static ArrayList set = new ArrayList ( ) ; static Peca ignoravel ; static int maiorSoma ; static boolean encontrado ; static int somaAbsoluta ; static int somaAbsolutaCorrente ; static Peca menorPecaIgnoravel ; static int maximos [ ] = new int [ 1001 ] ; static HashSet mapas [ ] = new HashSet [ 1000 ] ; public static void main ( String args [ ] ) throws NumberFormatException , IOException { int temp ; while ( true ) { pecaCount = Integer . parseInt ( readLine ( 10 ) . trim ( ) ) ; if ( pecaCount == 0 ) { break ; } set . clear ( ) ; menorPecaIgnoravel = null ; maiorSoma = - 1 ; ignoravel = null ; for ( int i = 0 ; i != pecaCount ; i ++ ) { String [ ] linha = split ( readLine ( 30 ) ) ; Peca p = new Peca ( ) ; p . cima = Integer . parseInt ( linha [ 0 ] ) ; p . baixo = Integer . parseInt ( linha [ 1 ] ) ; if ( p . cima < p . baixo ) { temp = p . cima ; p . cima = p . baixo ; p . baixo = temp ; } p . abs = Math . abs ( p . cima - p . baixo ) ; set . add ( p ) ; } Collections . sort ( set , new CompareThem ( ) ) ; int somaMaxima = 0 ; somaAbsoluta = 0 ; for ( int i = pecaCount - 1 ; i != - 1 ; i -- ) { somaAbsoluta += getPeca ( i ) . cima + getPeca ( i ) . baixo ; somaMaxima += getPeca ( i ) . abs ; maximos [ i ] = somaMaxima ; getPeca ( i ) . level = i ; if ( mapas [ i ] == null ) { mapas [ i ] = new HashSet ( ) ; } else { mapas [ i ] . clear ( ) ; } } encontrado = false ; if ( pecaCount == 1 ) { if ( getPeca ( 0 ) . abs != 0 ) { System . out . println ( \"impossible\" ) ; continue ; } else { System . out . println ( getPeca ( 0 ) . cima + \" discard none\" ) ; continue ; } } if ( pecaCount == 2 ) { if ( getPeca ( 0 ) . abs == 0 ) { printDiscard ( getPeca ( 0 ) . cima , getPeca ( 1 ) ) ; continue ; } if ( getPeca ( 1 ) . abs == 0 ) { printDiscard ( getPeca ( 1 ) . cima , getPeca ( 0 ) ) ; continue ; } System . out . println ( \"impossible\" ) ; continue ; } if ( somaAbsoluta % 2 == 0 ) { somaAbsolutaCorrente = somaAbsoluta / 2 ; tenta ( 0 , 0 , 0 ) ; if ( encontrado ) { continue ; } } menorPecaIgnoravel = null ; maiorSoma = - 1 ; for ( int i = 0 ; i != pecaCount ; i ++ ) { if ( getPeca ( i ) . abs == 0 ) { continue ; } for ( int i2 = 0 ; i2 != pecaCount ; i2 ++ ) { mapas [ i2 ] . clear ( ) ; } ignoravel = getPeca ( i ) ; if ( ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) % 2 == 0 ) { if ( encontrado ) { if ( menorPecaIgnoravel . cima + menorPecaIgnoravel . baixo < ignoravel . cima + ignoravel . baixo ) { continue ; } } somaAbsolutaCorrente = ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) / 2 ; tenta ( 0 , 0 , 0 ) ; } } if ( ! encontrado ) { System . out . println ( \"impossible\" ) ; } else { printDiscard ( maiorSoma , menorPecaIgnoravel ) ; } } } private static void printDiscard ( int i , Peca peca ) { System . out . println ( i + \" discard \" + peca . baixo + \" \" + peca . cima ) ; } private static void imprime ( ) { for ( int i = 0 ; i != pecaCount ; i ++ ) { if ( ignoravel != null && getPeca ( i ) == ignoravel ) continue ; Peca temp = getPeca ( i ) ; System . out . print ( \"[\" + temp . cima + \"/\" + temp . baixo + \"/\" + temp . abs + \"],\" ) ; } System . out . println ( ) ; } private static Peca getPeca ( int i ) { return ( Peca ) set . get ( i ) ; } static boolean tenta ( int p , int diferenca , int somaDeUmLado ) { if ( somaDeUmLado > somaAbsolutaCorrente ) { return false ; } if ( p == pecaCount ) { if ( diferenca == 0 ) { if ( ignoravel != null ) { if ( ! encontrado || somaDeUmLado > maiorSoma ) { maiorSoma = somaDeUmLado ; menorPecaIgnoravel = ignoravel ; } else if ( somaDeUmLado == maiorSoma ) { if ( ignoravel . baixo < menorPecaIgnoravel . baixo ) { maiorSoma = somaDeUmLado ; menorPecaIgnoravel = ignoravel ; } } } else { System . out . println ( somaDeUmLado + \" discard none\" ) ; } encontrado = true ; return true ; } return false ; } if ( Math . abs ( diferenca ) > maximos [ p ] ) { return false ; } Peca posicaoAtual = getPeca ( p ) ; if ( mapas [ p ] . contains ( new Integer ( diferenca ) ) ) { return false ; } mapas [ p ] . add ( new Integer ( diferenca ) ) ; if ( posicaoAtual == ignoravel ) { return tenta ( p + 1 , diferenca , somaDeUmLado ) ; } if ( posicaoAtual . abs == 0 ) { return tenta ( p + 1 , diferenca , somaDeUmLado + posicaoAtual . baixo ) ; } if ( tenta ( p + 1 , diferenca + posicaoAtual . abs , somaDeUmLado + posicaoAtual . cima ) ) { return true ; } if ( tenta ( p + 1 , diferenca - posicaoAtual . abs , somaDeUmLado + posicaoAtual . baixo ) ) { return true ; } return false ; } static String [", "gt": "] split ( String s )", "prediction": "] getPeca ( int i )\n", "label": 0}
{"id": 15443, "input": "<s> package org . fuzzydb . server . internal . index . btree . node ; import java . io . Serializable ; import org . fuzzydb . client . Ref ; import org . fuzzydb . server . internal . index . btree . NodeW ; public class RootSentinel extends Node implements Serializable , Cloneable { private static final long serialVersionUID = 1L ; final Ref < NodeW > root ; public RootSentinel ( Ref < NodeW > root ) { this . root = root ; } @ Override public Node clone ( ) { throw new UnsupportedOperationException ( ) ; } public", "gt": "Ref < NodeW > getRoot ( )", "prediction": "NodeW clone ( )\n", "label": 1}
{"id": 6936, "input": "<s> package com . mapr . stats ; import org . apache . mahout . math . jet . random . Normal ; import java . util . Random ; public class NormalDistributionSampler extends DistributionGenerator { private double sd ; private Random gen ; public NormalDistributionSampler ( double sd , Random gen ) { this", "gt": ". sd = sd ;", "prediction": ". sd = sd ;\n", "label": 0}
{"id": 15444, "input": "<s> package org . restlet . example . misc ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . MediaType ; import org . restlet . data . Protocol ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . util . Series ; public class HeadersTest { public static void main ( String [ ] args ) throws Exception { final Restlet restlet = new Restlet ( ) { @ SuppressWarnings ( \"unchecked\" ) @ Override public void handle ( Request request , Response response ) { Series < Header > headers = ( Series < Header > ) request . getAttributes ( ) . get ( HeaderConstants . ATTRIBUTE_HEADERS ) ; response . setEntity ( \"Accept header: \" + headers . getFirstValue ( \"accept\" , true ) , MediaType . TEXT_PLAIN ) ; headers = new Series < Header > ( Header . class ) ; headers . add ( \"X-Test\" , \"Test value\" ) ; headers . add ( \"Location\" , \"http://www.restlet.org\" ) ; response . getAttributes ( ) .", "gt": "put ( HeaderConstants . ATTRIBUTE_HEADERS , headers ) ;", "prediction": "put ( HeaderConstants . ATTRIBUTE_HEADERS , headers ) ;\n", "label": 1}
{"id": 5637, "input": "<s> package org . ofbiz . security ; import org . ofbiz . base . util . GeneralException ; @ SuppressWarnings ( \"serial\" ) public class SecurityConfigurationException extends GeneralException { public SecurityConfigurationException ( String str , Throwable t ) { super", "gt": "( str , t ) ;", "prediction": "( str , t ) ;\n", "label": 0}
{"id": 15449, "input": "<s> package com . abhyrama . smushit ; import org . apache . http . client . HttpClient ; import org . apache . http . client . ResponseHandler ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . impl . client . DefaultHttpClient ; import org . apache . http . impl . client . BasicResponseHandler ; import org . apache . http . entity . mime . MultipartEntity ; import org . apache . http . entity . mime . HttpMultipartMode ; import org . apache . http . entity . mime . content . FileBody ; import java . io . IOException ; import java . io . File ; import java . util . * ; import flexjson . JSONDeserializer ; public class SmushIt { public static final String FILE_PARAM_NAME = \"files[]\" ; public static final String SMUSHIT_URL = \"http://www.smushit.com/ysmush.it/ws.php\" ; public static final int MAX_FILE_SIZE = 1024 * 1024 ; public static final String SMUSHIT_RESPONSE_ARRAY_START = \"[\" ; public static final String SMUSHIT_RESPONSE_ARRAY_END = \"]\" ; public static int SMUSH_BATCH_SIZE = 10 ; protected List < String > files = new LinkedList < String > ( ) ; protected boolean verbose ; public boolean isVerbose ( ) { return verbose ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public void addFile ( String file ) { this . files . add ( file ) ; } public void addFiles ( List < String > files ) { this . files . addAll ( files ) ; } public List < SmushItResultVo > smush ( ) throws IOException { List < SmushItResultVo > smushItResultVos = new LinkedList < SmushItResultVo > ( ) ; int count = this . files . size ( ) ; int startIndex = 0 ; int endIndex = SMUSH_BATCH_SIZE ; List < String > subList = null ; if ( this . files . size ( ) <= SMUSH_BATCH_SIZE ) { subList = this . files ; smushItResultVos . addAll ( this . smushHelper ( subList ) ) ; } else { subList = this . files . subList ( startIndex , endIndex ) ; while ( subList . size ( ) != 0 ) { smushItResultVos . addAll ( this . smushHelper ( subList ) ) ; startIndex = endIndex ; endIndex = endIndex + SMUSH_BATCH_SIZE ; if ( endIndex > count ) { endIndex = count ; } subList = this . files . subList ( startIndex , endIndex ) ; } } return smushItResultVos ; } protected void printFileNames ( List < String > files ) { for ( String file : files ) { System . out . println ( file ) ; } } protected List < SmushItResultVo > smushHelper ( List < String > files ) throws IOException { if ( this . verbose ) { System . out . println ( \"Smushing files:\" ) ; this . printFileNames ( files ) ; } HttpClient httpClient = new DefaultHttpClient ( ) ; HttpPost httpPost = new HttpPost ( SMUSHIT_URL ) ; MultipartEntity multipartEntity = new MultipartEntity ( HttpMultipartMode . BROWSER_COMPATIBLE ) ; this . addFilesToRequest ( multipartEntity , files ) ; httpPost . setEntity ( multipartEntity ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; String responseBody = httpClient . execute ( httpPost , responseHandler ) ; List < SmushItResultVo > smushItResultVos = this . transformToResultVo ( responseBody ) ; if ( this . verbose ) { for ( SmushItResultVo smushItResultVo : smushItResultVos ) { System . out . println ( \"Source Image:\" + smushItResultVo . getSourceImage ( ) + \", Source image size:\" + smushItResultVo . getSourceImageSize ( ) + \", Smushed image size:\" + smushItResultVo . getSmushedImageSize ( ) + \", Percentage saving:\" + smushItResultVo . getSavingPercentage ( ) ) ; } } httpClient . getConnectionManager ( ) . shutdown ( ) ; return smushItResultVos ; } protected List < SmushItResultVo > transformToResultVo ( String jsonResponse ) { System . out . println ( jsonResponse ) ; List < SmushItResultVo > smushItResultVos = new LinkedList < SmushItResultVo > ( ) ; if ( this . isResponseArray ( jsonResponse ) ) { List < Map > result = new JSONDeserializer < List < Map > > ( ) . deserialize ( jsonResponse ) ; for ( Map map : result ) { smushItResultVos . add ( SmushItResultVo . create ( map ) ) ; } } else { Map result = new JSONDeserializer < Map > ( ) . deserialize ( jsonResponse ) ; smushItResultVos . add ( SmushItResultVo . create ( result ) ) ; } return smushItResultVos ; } protected boolean isResponseArray ( String jsonResponse ) { return jsonResponse . startsWith ( SMUSHIT_RESPONSE_ARRAY_START ) && jsonResponse . endsWith ( SMUSHIT_RESPONSE_ARRAY_END ) ; } protected void addFilesToRequest ( MultipartEntity multipartEntity , List < String > files ) {", "gt": "for ( String file : files )", "prediction": "for ( String file : files )\n", "label": 1}
{"id": 6803, "input": "<s> package pkg ; import static pkg . B . b ; class A { public static", "gt": "void main ( String [ ] args )", "prediction": "void main ( String [ ] args )\n", "label": 0}
{"id": 15458, "input": "<s> package tk . blackwolf12333 . grieflog . data . player ; import org . bukkit . Bukkit ; import org . bukkit . ChatColor ; import org . bukkit . Location ; import org . bukkit . World ; import tk . blackwolf12333 . grieflog . PlayerSession ; import tk . blackwolf12333 . grieflog . utils . Events ; public class PlayerJoinData extends BasePlayerData { String ipaddress ; Integer x ; Integer y ; Integer z ; public PlayerJoinData ( String playerName , Integer gamemode , String world , String ipaddress , Integer x , Integer y , Integer z ) { this . playerName = playerName ; this . gamemode = gamemode ; this . worldName = world ; this . ipaddress = ipaddress ; this . x = x ; this . y = y ; this . z = z ; this . event = Events . JOIN ; } public PlayerJoinData ( String time , String playerName , Integer gamemode , String world , String ipaddress , Integer x , Integer y , Integer z ) { this . time = time ; this . playerName = playerName ; this . gamemode = gamemode ; this . worldName = world ; this . ipaddress = ipaddress ; this . x = x ; this . y = y ; this . z = z ; this . event = Events . JOIN ; } public String getIpaddress ( ) { return ipaddress ; } public void setIpaddress ( String ipaddress ) { this . ipaddress = ipaddress ; } public Integer getX ( ) { return x ; } public void setX ( Integer x ) { this . x = x ; } public Integer getY ( ) { return y ; } public void setY ( Integer y ) { this . y = y ; } public Integer getZ ( ) { return z ; } public void setZ ( Integer z ) { this . z = z ; } @ Override public void rollback ( ) { } @ Override public void tpto ( PlayerSession who ) { String playername = playerName ; World world = Bukkit . getServer ( ) . getWorld ( worldName ) ; Location loc = new Location ( world , x , y , z ) ; PlayerSession player = who ; player . print ( ChatColor . YELLOW + \"[GriefLog] Teleporting you to \" + playername + \".\" ) ; player", "gt": ". teleport ( loc ) ;", "prediction": ". tpto ( player ) ;\n", "label": 1}
{"id": 6627, "input": "<s> package org . ofbiz . entity . config ; import java . util . HashMap ; import java . util . Map ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Element ; public class DelegatorInfo extends NamedInfo { public String entityModelReader ; public String entityGroupReader ; public String entityEcaReader ; public boolean useEntityEca ; public String entityEcaHandlerClassName ; public boolean useDistributedCacheClear ; public String distributedCacheClearClassName ; public String distributedCacheClearUserLoginId ; public String sequencedIdPrefix ; public String defaultGroupName ; public Map < String , String > groupMap = new HashMap < String , String > ( ) ; public String kekText ; public DelegatorInfo ( Element element ) { super ( element ) ; this . entityModelReader = element . getAttribute ( \"entity-model-reader\" ) ; this . entityGroupReader = element . getAttribute ( \"entity-group-reader\" ) ; this . entityEcaReader = element . getAttribute ( \"entity-eca-reader\" ) ; this . useEntityEca = ! \"false\" . equalsIgnoreCase ( element . getAttribute ( \"entity-eca-enabled\" ) ) ; this . entityEcaHandlerClassName = element . getAttribute ( \"entity-eca-handler-class-name\" ) ; this . useDistributedCacheClear = \"true\" . equalsIgnoreCase ( element . getAttribute ( \"distributed-cache-clear-enabled\" ) ) ; this . distributedCacheClearClassName = element . getAttribute ( \"distributed-cache-clear-class-name\" ) ; if ( this . distributedCacheClearClassName . isEmpty ( ) ) this . distributedCacheClearClassName = \"org.ofbiz.entityext.cache.EntityCacheServices\" ; this . distributedCacheClearUserLoginId = element . getAttribute ( \"distributed-cache-clear-user-login-id\" ) ; if ( this . distributedCacheClearUserLoginId . isEmpty ( ) ) this . distributedCacheClearUserLoginId = \"system\" ; this . sequencedIdPrefix = element . getAttribute ( \"sequenced-id-prefix\" ) ; this . defaultGroupName = element . getAttribute ( \"default-group-name\" ) ; if ( this . defaultGroupName . isEmpty", "gt": "( ) ) this . defaultGroupName = \"org.ofbiz\" ;", "prediction": "( ) ) this . defaultGroupName = \"system\" ;\n", "label": 0}
{"id": 15460, "input": "<s> package org . eclipse . ui . tests . autotests ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . ui . IMemento ; public class TestResults { private Map results = new HashMap ( ) ; private final static String ATT_NAME = \"name\" ; private final static String ATT_TEST = \"test\" ; public TestResults ( ) { } public TestResults ( IMemento toLoad ) { IMemento [ ] tests = toLoad . getChildren ( ATT_TEST ) ; for ( int i = 0 ; i < tests . length ; i ++ ) { IMemento memento = tests [ i ] ; String name = memento . getString ( ATT_NAME ) ; if ( name == null ) { continue ; } results . put ( name , new TestResultFilter ( memento ) ) ; } } public String [ ] getTestNames ( ) { Collection ids = results . keySet ( ) ; return ( String [ ] ) ids . toArray (", "gt": "new String [ ids . size ( ) ] ) ;", "prediction": "new String [ ids . size ( ) ] ) ;\n", "label": 1}
{"id": 2368, "input": "<s> package com . matburt . mobileorg . Gui . Capture ; import java . util . ArrayList ; import android . content . Context ; import android . util . AttributeSet ; import android . view . View ; import android . widget . Button ; import android . widget . Spinner ; import android . widget . TableLayout ; import android . widget . TableRow ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . util . OrgUtils ; class TagTableRow extends TableRow { private static int spinnerId = 0 ; private Spinner spinner ; private Button button ; private String selectionExtra = \"\" ; private TableLayout parentView ; private TagsFragment tagsFragment ; public TagTableRow ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public void setTags ( String selectedTag , ArrayList < String > tags ) { if ( selectedTag . endsWith ( \":\" ) ) { selectionExtra = \":\" ; selectedTag = selectedTag . replace ( \":\" , \"\" ) ; } spinner = ( Spinner ) findViewById ( R . id . edit_tag_list ) ; spinner . setId ( spinnerId ++ ) ; OrgUtils . setupSpinnerWithEmpty ( spinner , tags , selectedTag ) ; button = ( Button ) findViewById ( R . id . edit_tag_remove ) ; button . setOnClickListener ( removeListener ) ; } public void setParents ( TableLayout parentView , TagsFragment tagsFragment ) { this . parentView = parentView ; this . tagsFragment = tagsFragment ; } public void setModifiable ( boolean enabled ) { if ( enabled ) button . setVisibility ( VISIBLE ) ; else button . setVisibility ( INVISIBLE ) ; spinner . setEnabled ( enabled ) ; } public void setLast ( ) { selectionExtra = \":\" ; } public String getSelection ( ) { return spinner . getSelectedItem ( ) . toString ( ) + selectionExtra ; } private void remove ( ) { if ( parentView != null ) parentView . removeView ( this ) ; if ( tagsFragment != null ) tagsFragment . tagEntries . remove ( this ) ; } private View", "gt": ". OnClickListener removeListener = new View . OnClickListener ( )", "prediction": "getViewById ( int id )\n", "label": 0}
{"id": 15461, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . jaas ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; public interface MailResource { @ Get public Mail retrieve ( ) ; @ Put public void store", "gt": "( Mail mail ) ;", "prediction": "( Mail mail ) ;\n", "label": 1}
{"id": 7553, "input": "<s> package org . ofbiz . pos . device . impl ; import jpos . JposConst ; import jpos . JposException ; import org . ofbiz . pos . device . GenericDevice ; public class LineDisplay extends GenericDevice { public static final String module = LineDisplay . class . getName ( ) ; public LineDisplay ( String deviceName , int timeout ) { super ( deviceName , timeout ) ; this . control = new jpos . LineDisplay ( ) ; }", "gt": "@ Override protected void initialize ( ) throws JposException", "prediction": "}\n", "label": 0}
{"id": 15466, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . Index ; import org . apache . lucene . document . Field . Store ; import org . apache . lucene . store . RAMDirectory ; public class TestParallelTermEnum extends LuceneTestCase { private IndexReader ir1 ; private IndexReader ir2 ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Document doc ; RAMDirectory rd1 = new RAMDirectory ( ) ; IndexWriter iw1 = new IndexWriter ( rd1 , new SimpleAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; doc = new Document ( ) ; doc . add ( new Field ( \"field1\" , \"the quick brown fox jumps\" , Store . YES , Index . ANALYZED ) ) ; doc . add ( new Field ( \"field2\" , \"the quick brown fox jumps\" , Store . YES , Index . ANALYZED ) ) ; doc . add ( new Field ( \"field4\" , \"\" , Store . NO , Index . ANALYZED ) ) ; iw1 . addDocument ( doc ) ; iw1 . close ( ) ; RAMDirectory rd2 = new RAMDirectory ( ) ; IndexWriter iw2 = new IndexWriter ( rd2 , new SimpleAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; doc = new Document ( ) ; doc . add ( new Field ( \"field0\" , \"\" , Store . NO , Index . ANALYZED ) ) ; doc . add ( new Field ( \"field1\" , \"the fox jumps over the lazy dog\" , Store . YES , Index . ANALYZED ) ) ; doc . add ( new Field ( \"field3\" , \"the fox jumps over the lazy dog\" , Store . YES , Index . ANALYZED ) ) ; iw2 . addDocument ( doc ) ; iw2 . close ( ) ; this . ir1 = IndexReader . open ( rd1 ) ; this . ir2 = IndexReader . open ( rd2 ) ; } protected void tearDown ( ) throws Exception { super . tearDown ( ) ; ir1 . close ( ) ; ir2 . close ( ) ; } public void test1 ( ) throws IOException { ParallelReader pr = new ParallelReader ( ) ; pr . add ( ir1 ) ; pr . add ( ir2 ) ; TermDocs td = pr . termDocs ( ) ; TermEnum te = pr . terms ( ) ; assertTrue ( te . next ( ) ) ; assertEquals ( \"field1:brown\" , te . term ( ) . toString ( ) ) ; td . seek ( te . term ( ) ) ; assertTrue ( td . next ( ) ) ; assertEquals ( 0 , td . doc ( ) ) ; assertFalse ( td .", "gt": "next ( ) ) ;", "prediction": "next ( ) ) ;\n", "label": 1}
{"id": 3941, "input": "<s> package a ; import a . Foo . InnerInterface ; public", "gt": "interface FooInterface extends Foo . InnerInterface", "prediction": "interface Foo\n", "label": 0}
{"id": 15474, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import java . util . Collection ; import java . util . Set ; import java . util . ArrayList ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . ToStringUtils ; public class SpanFirstQuery extends SpanQuery implements Cloneable { private SpanQuery match ; private int end ; public SpanFirstQuery ( SpanQuery match , int end ) { this . match = match ; this . end = end ; } public SpanQuery getMatch ( ) { return match ; } public int getEnd ( ) { return end ; } public String getField ( ) { return match . getField ( ) ; } public Collection getTerms ( ) { return match . getTerms ( ) ; } public String toString ( String field ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( \"spanFirst(\" ) ; buffer . append ( match . toString ( field ) ) ; buffer . append ( \", \" ) ; buffer . append ( end ) ; buffer . append ( \")\" ) ; buffer . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return buffer . toString ( ) ; } public Object clone ( ) { SpanFirstQuery spanFirstQuery = new SpanFirstQuery ( ( SpanQuery ) match . clone ( ) , end ) ; spanFirstQuery . setBoost ( getBoost ( ) ) ; return spanFirstQuery ; } public void extractTerms ( Set terms ) { match . extractTerms ( terms ) ; } public Spans getSpans ( final IndexReader reader ) throws IOException { return new Spans ( ) { private Spans spans = match . getSpans ( reader ) ; public boolean next ( ) throws IOException { while ( spans . next ( ) ) { if ( end ( ) <= end ) return true ; } return false ; } public boolean skipTo ( int target ) throws IOException { if ( ! spans . skipTo ( target ) ) return false ; return spans", "gt": ". end ( ) <= end || next ( ) ;", "prediction": ". skipTo ( target ) ;\n", "label": 1}
{"id": 31, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect . mirror ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . GenericDeclaration ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . util . ArrayList ; import java . util . List ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeParameterMirror ; public class ReflectionUtils { public static AnnotationMirror getAnnotation ( AnnotatedElement annotated , String type ) { return getAnnotation ( annotated . getDeclaredAnnotations ( ) , type ) ; } public static AnnotationMirror getAnnotation ( Annotation [ ] annotations , String type ) { for ( Annotation annotation : annotations ) { if ( annotation . annotationType ( ) . getName ( ) . equals ( type ) ) return new ReflectionAnnotation ( annotation ) ; } return null ; } public static List < TypeParameterMirror > getTypeParameters ( GenericDeclaration decl ) { TypeVariable < ? > [ ] javaTypeParameters = decl", "gt": ". getTypeParameters ( ) ;", "prediction": ". getTypeParameters ( ) ;\n", "label": 0}
{"id": 15477, "input": "<s> package org . nuxeo . ecm . platform . io . api . util ; import java . io . IOException ; import java . util . Collection ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentLocation ; import org . nuxeo . ecm . core . api . impl . DocumentLocationImpl ; public class IOHelper { private IOHelper ( ) { } public static void copy ( IOConfiguration src , IOConfiguration dest , Collection < String > ioAdapters ) throws IOException , ClientException { String uri = exportAsStream ( src , ioAdapters ) ; try { importFromStream ( dest , uri ) ; } finally { if ( uri != null ) { } } } public static String exportAsStream ( IOConfiguration location , Collection < String > ioAdapters ) throws ClientException { return location . getManager ( ) . externalizeExport ( location . getRepositoryName ( ) , location . getDocuments ( ) , ( String ) location . getProperty ( IOConfiguration . DOC_READER_FACTORY ) , location . getProperties ( ) , ioAdapters ) ; } public static void importFromStream ( IOConfiguration location , String streamUri ) throws ClientException { String docWriterFactoryName = ( String ) location . getProperty ( IOConfiguration . DOC_WRITER_FACTORY ) ; DocumentLocation targetLocation = new DocumentLocationImpl ( location . getRepositoryName ( ) , location . getFirstDocument ( ) ) ; if ( docWriterFactoryName == null ) { location . getManager ( ) . importExportedFile ( streamUri , targetLocation ) ; } else { location . getManager ( ) . importExportedFile ( streamUri ,", "gt": "targetLocation , docWriterFactoryName , location . getProperties ( ) ) ;", "prediction": "targetLocation , docWriterFactoryName ) ;\n", "label": 1}
{"id": 6809, "input": "<s> package org . parboiled . trees ; public interface MutableTreeNode < T extends MutableTreeNode < T > > extends TreeNode < T > { void addChild ( int index , T child ) ; void setChild", "gt": "( int index , T child ) ;", "prediction": "( int index , T child ) ;\n", "label": 0}
{"id": 15479, "input": "<s> package sk . m217 . actionbarcompat ; import android . app . Activity ; import android . graphics . drawable . Drawable ; public class ActionBarCompatICS { public static void setIcon ( Activity activity , int resId ) { activity . getActionBar ( ) . setIcon ( resId ) ; } public static void setIcon ( Activity activity , Drawable icon ) { activity . getActionBar ( ) . setIcon ( icon ) ; } public static void setTitle ( Activity activity , CharSequence title ) { activity . getActionBar ( ) . setTitle ( title ) ; } public static void setTitle ( Activity activity , int resId ) { activity . getActionBar ( ) . setTitle ( resId ) ; } public static void setDisplayShowHomeEnabled ( Activity activity , boolean showHome ) { activity . getActionBar ( ) . setDisplayShowHomeEnabled ( showHome ) ; } public static void setDisplayHomeAsUpEnabled ( Activity activity , boolean showHomeAsUp ) { activity . getActionBar ( ) . setDisplayHomeAsUpEnabled ( showHomeAsUp ) ; } public static void setDisplayShowTitleEnabled ( Activity activity , boolean showTitle ) {", "gt": "activity . getActionBar ( ) . setDisplayShowTitleEnabled ( showTitle ) ;", "prediction": "activity . getActionBar ( ) . setDisplayShowTitleEnabled ( showTitle ) ;\n", "label": 1}
{"id": 5880, "input": "<s> package org . ofbiz . base . util . cache ; import java . io . IOException ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArraySet ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import javolution . util . FastList ; import javolution . util . FastMap ; import jdbm . helper . FastIterator ; import jdbm . htree . HTree ; import org . ofbiz . base . concurrent . ExecutionPool ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilValidate ; import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap ; import com . googlecode . concurrentlinkedhashmap . EvictionListener ; import com . googlecode . concurrentlinkedhashmap . ConcurrentLinkedHashMap . Builder ; @ SuppressWarnings ( \"serial\" ) public class UtilCache < K , V > implements Serializable , EvictionListener < Object , CacheLine < V > > { public static final String module = UtilCache . class . getName ( ) ; private static final ConcurrentHashMap < String , UtilCache < ? , ? > > utilCacheTable = new ConcurrentHashMap < String , UtilCache < ? , ? > > ( ) ; private final static ConcurrentHashMap < String , AtomicInteger > defaultIndices = new ConcurrentHashMap < String , AtomicInteger > ( ) ; private final String name ; protected AtomicLong hitCount = new AtomicLong ( 0 ) ; protected AtomicLong missCountNotFound = new AtomicLong ( 0 ) ; protected AtomicLong missCountExpired = new AtomicLong ( 0 ) ; protected AtomicLong missCountSoftRef = new AtomicLong ( 0 ) ; protected AtomicLong removeHitCount = new AtomicLong ( 0 ) ; protected AtomicLong removeMissCount = new AtomicLong ( 0 ) ; protected int sizeLimit = 0 ; protected int maxInMemory = 0 ; protected long expireTimeNanos = 0 ; protected boolean useSoftReference = false ; protected boolean useFileSystemStore = false ; private String fileStore = \"runtime/data/utilcache\" ; protected Set < CacheListener < K , V > > listeners = new CopyOnWriteArraySet < CacheListener < K , V > > ( ) ; protected transient HTree < Object , V > fileTable = null ; protected ConcurrentMap < Object , CacheLine < V > > memoryTable = null ; protected JdbmRecordManager jdbmMgr ; private static final ConcurrentMap < String , JdbmRecordManager > fileManagers = new ConcurrentHashMap < String , JdbmRecordManager > ( ) ; private UtilCache ( String cacheName , int sizeLimit , int maxInMemory , long expireTimeMillis , boolean useSoftReference , boolean useFileSystemStore , String propName , String ... propNames ) { this . name = cacheName ; this . sizeLimit = sizeLimit ; this . maxInMemory = maxInMemory ; this . expireTimeNanos = TimeUnit . NANOSECONDS . convert ( expireTimeMillis , TimeUnit . MILLISECONDS ) ; this . useSoftReference = useSoftReference ; this . useFileSystemStore = useFileSystemStore ; setPropertiesParams ( propName ) ; setPropertiesParams ( propNames ) ; int maxMemSize = this . maxInMemory ; if ( maxMemSize == 0 ) maxMemSize = sizeLimit ; if ( maxMemSize == 0 ) { memoryTable = new ConcurrentHashMap < Object , CacheLine < V > > ( ) ; } else { memoryTable = new Builder < Object , CacheLine < V > > ( ) . maximumWeightedCapacity ( maxMemSize ) . listener ( this ) . build ( ) ; } if ( this . useFileSystemStore ) { jdbmMgr = fileManagers . get ( fileStore ) ; if ( jdbmMgr == null ) { Debug . logImportant ( \"Creating file system cache store for cache with name: \" + cacheName , module ) ; try { String ofbizHome = System . getProperty ( \"ofbiz.home\" ) ; if ( ofbizHome == null ) { Debug . logError ( \"No ofbiz.home property set in environment\" , module ) ; } else { jdbmMgr = new JdbmRecordManager ( ofbizHome + \"/\" + fileStore ) ; } } catch ( IOException e ) { Debug . logError ( e , \"Error creating file system cache store for cache with name: \" + cacheName , module ) ; } fileManagers . putIfAbsent ( fileStore , jdbmMgr ) ; } jdbmMgr = fileManagers . get ( fileStore ) ; if ( jdbmMgr != null ) { try { this . fileTable = HTree . createInstance ( jdbmMgr ) ; jdbmMgr . setNamedObject ( cacheName , this . fileTable . getRecid ( ) ) ; jdbmMgr . commit ( ) ; } catch ( IOException e ) { Debug . logError ( e , module ) ; } } } } private static String getNextDefaultIndex ( String cacheName ) { AtomicInteger curInd = defaultIndices . get ( cacheName ) ; if ( curInd == null ) { defaultIndices . putIfAbsent ( cacheName , new AtomicInteger ( 0 ) ) ; curInd = defaultIndices . get ( cacheName ) ; } int i = curInd . getAndIncrement ( ) ; return i == 0 ? \"\" : Integer . toString ( i ) ; } public static String getPropertyParam ( ResourceBundle res , String [ ] propNames , String parameter ) { try {", "gt": "for ( String propName : propNames )", "prediction": "return res . getString ( propNames [ 0 ] ) ;\n", "label": 0}
{"id": 15482, "input": "<s> package org . restlet . ext . javamail ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . ext . xml . DomRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . Post ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; import org . restlet . routing . Template ; import org . restlet . util . Resolver ; import org . w3c . dom . Node ; public class TriggerResource extends ServerResource { public static final String ATTRIBUTE_MAILBOX_CHALLENGE_SCHEME = \"org.restlet.ext.javamail.mailbox.authentication.scheme\" ; public static final String ATTRIBUTE_MAILBOX_LOGIN = \"org.restlet.ext.javamail.mailbox.login\" ; public static final String ATTRIBUTE_MAILBOX_PASSWORD = \"org.restlet.ext.javamail.mailbox.password\" ; public static final String ATTRIBUTE_MAILBOX_URI = \"org.restlet.ext.javamail.mailbox.uri\" ; private ChallengeScheme mailboxChallengeScheme ; private String mailboxLogin ; private String mailboxPassword ; private String mailboxUri ; private String mailUriTemplate ; private MailResolver resolver ; private boolean targetEntityEnabled ; private Method targetMethod ; private String targetUri ; @ Post public void acceptMails ( Representation entity ) throws ResourceException { final List < String > mailIdentifiers = getMailIdentifiers ( ) ; final List < String > mailsSuccessful = new ArrayList < String > ( ) ; final Map < String , String > mailsUnsuccessful = new HashMap < String , String > ( ) ; Representation mail ; for ( final String mailIdentifier : mailIdentifiers ) { try { mail = getMail ( mailIdentifier ) ; if ( mail != null ) { this . resolver = getResolver ( mailIdentifier , mail ) ; callTarget ( this . resolver ) ; deleteMail ( mailIdentifier ) ; mailsSuccessful . add ( mailIdentifier ) ; } } catch ( ResourceException e ) { mailsUnsuccessful . put ( mailIdentifier , e . getMessage ( ) ) ; } } getResponse ( ) . setEntity ( getResponseRepresentation ( mailsSuccessful , mailsUnsuccessful ) ) ; getResponse ( ) . setStatus ( getResponseStatus ( mailsSuccessful , mailsUnsuccessful ) ) ; } protected void callTarget ( Resolver < String > resolver ) throws ResourceException { final Method method = getTargetMethod ( resolver ) ; final Reference targetRef = getTargetRef ( resolver ) ; final Request request = new Request ( method , targetRef ) ; final ChallengeResponse challengeResponse = getTargetChallengeResponse ( resolver ) ; if ( challengeResponse != null ) { request . setChallengeResponse ( challengeResponse ) ; } if ( isTargetEntityEnabled ( ) ) { request . setEntity ( getTargetEntity ( resolver ) ) ; } final Response response = getContext ( ) . getClientDispatcher ( ) . handle ( request ) ; if ( ! response . getStatus ( ) . isSuccess ( ) ) { throw new ResourceException ( Status . SERVER_ERROR_INTERNAL , \"Call to the target resource didn't succeed\" ) ; } } protected void deleteMail ( String mailIdentifier ) throws ResourceException { Reference mailRef = getMailRef ( mailIdentifier ) ; if ( mailRef . isRelative ( ) ) { mailRef . setBaseRef ( getMailboxUri ( ) ) ; mailRef = mailRef . getTargetRef ( ) ; } final Request request = new Request ( Method . DELETE , mailRef ) ; if ( getMailboxChallengeScheme ( ) != null ) { final ChallengeResponse challengeResponse = new ChallengeResponse ( getMailboxChallengeScheme ( ) , getMailboxLogin ( ) , getMailboxPassword ( ) ) ; request . setChallengeResponse ( challengeResponse ) ; } final Response response = getContext ( ) . getClientDispatcher ( ) . handle ( request ) ; if ( response . getStatus ( ) . isError ( ) ) { throw new ResourceException ( Status . SERVER_ERROR_INTERNAL , \"Unable to delete the mail from the mailbox\" ) ; } } @ Override protected void doInit ( ) throws ResourceException { this . mailboxChallengeScheme = null ; this . mailboxLogin = null ; this . mailboxPassword = null ; this . mailboxUri = null ; this . mailUriTemplate = \"/{mailId}\" ; this . resolver = null ; } protected Representation getMail ( String identifier ) throws ResourceException { final Reference mailRef = getMailRef ( identifier ) ; final Request request = new Request ( Method . GET , mailRef ) ; if ( getMailboxChallengeScheme ( ) != null ) { final ChallengeResponse challengeResponse = new ChallengeResponse ( getMailboxChallengeScheme ( ) , getMailboxLogin ( ) , getMailboxPassword ( ) ) ; request . setChallengeResponse ( challengeResponse ) ; } final Response response = getContext ( ) . getClientDispatcher ( ) . handle ( request ) ; if ( ! response . getStatus ( ) . isSuccess ( ) ) { throw new ResourceException ( Status . SERVER_ERROR_INTERNAL , \"Unable to get the mail from the mailbox\" ) ; } return new DomRepresentation ( response . getEntity ( ) ) ; } public ChallengeScheme getMailboxChallengeScheme ( ) { if ( this . mailboxChallengeScheme == null ) { this . mailboxChallengeScheme = ( ChallengeScheme ) getContext ( ) . getAttributes ( ) . get ( ATTRIBUTE_MAILBOX_CHALLENGE_SCHEME ) ; } return this . mailboxChallengeScheme ; } public String getMailboxLogin ( ) { if ( this . mailboxLogin == null ) { this . mailboxLogin = ( String ) getContext ( ) . getAttributes ( ) . get ( ATTRIBUTE_MAILBOX_LOGIN ) ; } return this . mailboxLogin ; } public String getMailboxPassword ( ) { if ( this . mailboxPassword == null ) { this . mailboxPassword = ( String ) getContext ( ) . getAttributes ( ) . get ( ATTRIBUTE_MAILBOX_PASSWORD ) ; } return this . mailboxPassword ; } public String getMailboxUri ( ) { if ( this . mailboxUri == null ) { this . mailboxUri = ( String ) getContext ( ) . getAttributes ( ) . get ( ATTRIBUTE_MAILBOX_URI ) ; } return this . mailboxUri ; }", "gt": "protected List < String > getMailIdentifiers ( ) throws ResourceException", "prediction": "}\n", "label": 1}
{"id": 2082, "input": "<s> package org . gk . engine . client . build . portal ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class PortalBuilder extends Builder { public PortalBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List", "gt": "subNodes = new gkList ( ) ;", "prediction": "< Node > nodes = new ArrayList < Node > ( ) ;\n", "label": 0}
{"id": 15490, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . core . databinding . property . value . IValueProperty ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . List ; import org . eclipse . swt . widgets . Table ; public final class WidgetSingleSelectionIndexProperty extends WidgetDelegatingValueProperty { private IValueProperty cCombo ; private IValueProperty combo ; private IValueProperty list ; private IValueProperty table ; public WidgetSingleSelectionIndexProperty ( ) { super ( Integer . TYPE ) ; } protected IValueProperty doGetDelegate ( Object source ) { if ( source instanceof CCombo ) { if ( cCombo == null ) cCombo = new CComboSingleSelectionIndexProperty ( ) ; return cCombo ; } if ( source instanceof Combo ) { if ( combo == null ) combo = new ComboSingleSelectionIndexProperty ( ) ; return combo ; } if ( source instanceof List ) { if ( list == null ) list = new ListSingleSelectionIndexProperty ( ) ; return list ; } if ( source instanceof Table ) { if ( table == null ) table = new TableSingleSelectionIndexProperty ( ) ; return table ; }", "gt": "throw notSupported ( source ) ;", "prediction": "return null ;\n", "label": 1}
{"id": 118, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . ExtendTask ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ExtendTest extends XtextTest { public ExtendTest ( ) { super ( \"ExtendTest\" ) ; } @ Test public void testExtendTaskText ( ) { String text = \"extend task { text T20 \\\"T20 Extend\\\" {inherit scenariospecific}}\" ; testParserRule ( text , ExtendTask . class . getSimpleName ( ) ) ; } @ Test public void testExtendTaskText2 ( ) { String text = \"extend task {text T20 \\\"T20 Extend\\\" {scenariospecific inherit}}\" ; testParserRule ( text , ExtendTask . class . getSimpleName ( ) ) ; } @ Test public void testExtendTaskTextInheritOnly ( ) { String text = \"extend task {text T20 \\\"T20 Extend\\\" {inherit}}\" ; testParserRule ( text , ExtendTask . class .", "gt": "getSimpleName ( ) ) ;", "prediction": "getSimpleName ( ) ) ;\n", "label": 0}
{"id": 15491, "input": "<s> package org . apache . lucene . store . db ; import java . io . IOException ; import com . sleepycat . db . DatabaseEntry ; import com . sleepycat . db . internal . Db ; import com . sleepycat . db . internal . DbTxn ; import com . sleepycat . db . DatabaseException ; public class Block extends Object { protected DatabaseEntry key , data ; protected Block ( File file ) throws IOException { byte [ ] fileKey = file . getKey ( ) ; key = new DatabaseEntry ( new byte [ fileKey . length + 8 ] ) ; key . setUserBuffer ( fileKey . length + 8 , true ) ; data = new DatabaseEntry ( new byte [ DbIndexOutput . BLOCK_LEN ] ) ; data . setUserBuffer ( data . getSize ( ) , true ) ; System . arraycopy ( fileKey , 0 , key . getData ( ) , 0 , fileKey . length ) ; seek ( 0L ) ; } protected byte [ ] getKey ( ) { return key . getData ( ) ; } protected byte [ ] getData ( ) { return data . getData ( ) ; } protected void seek ( long position ) throws IOException { byte [ ] data = key . getData ( ) ; int index = data . length - 8 ; position >>>= DbIndexOutput . BLOCK_SHIFT ; data [ index + 0 ] = ( byte ) ( 0xff & ( position > > > 56 ) ) ; data [ index + 1 ] = ( byte ) ( 0xff & ( position > > > 48 ) ) ; data [ index + 2 ] = ( byte ) ( 0xff & ( position > > > 40 ) ) ; data [ index + 3 ] = ( byte ) ( 0xff & ( position > > > 32 ) ) ; data [ index + 4 ] = ( byte ) ( 0xff & ( position > > > 24 ) ) ; data [ index + 5 ] = ( byte ) ( 0xff & ( position > > > 16 ) ) ; data [ index + 6 ] = ( byte ) ( 0xff & ( position > > > 8 ) ) ; data [ index + 7 ] = ( byte ) ( 0xff & ( position > >", "gt": "> 0 ) ) ;", "prediction": "> 0 ) ) ;\n", "label": 1}
{"id": 8944, "input": "<s> package com . example . tutorial . flowpart ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . FlowPart ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory . Extend ; import com . example . tutorial . modelgen . table . model . ItemInfo ; import com . example . tutorial . modelgen . table . model . OrderAmount ; import com . example . tutorial . modelgen . table . model . OrderDetail ; import com . example . tutorial . operator . TutorialOpFactory ; import com . example . tutorial . operator . TutorialOpFactory . Join ; import com . example . tutorial . operator . TutorialOpFactory . SetStatus ; import com . example . tutorial . operator . TutorialOpFactory . Sum ; @ FlowPart public class TutorialFlow extends FlowDescription { private In < OrderDetail > orderIn ; private In < ItemInfo > itemIn ; private Out < OrderDetail > orderOut ; private Out < OrderAmount > resultOut ; private TutorialOpFactory op = new TutorialOpFactory ( ) ; private CoreOperatorFactory core = new CoreOperatorFactory ( ) ; public TutorialFlow ( In < OrderDetail > orderIn , In < ItemInfo > itemIn , Out < OrderDetail > orderOut , Out < OrderAmount > resultOut ) { this . orderIn = orderIn ;", "gt": "this . itemIn = itemIn ;", "prediction": "this . itemIn = itemIn ;\n", "label": 0}
{"id": 15501, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import org . eclipse . rap . rwt . service . FileSettingStore_Test ; import org . eclipse . rap . rwt . service . ISettingStoreFactory ; import org . eclipse . rap . rwt . testfixture . internal . service . MemorySettingStore ; import org . eclipse . rap . rwt . testfixture . internal . service . MemorySettingStoreFactory ; public class MemorySettingStore_Test extends FileSettingStore_Test { private ISettingStoreFactory factory = new MemorySettingStoreFactory ( ) ; protected ISettingStoreFactory getFactory ( ) { return factory ; }", "gt": "public void testFactoryCreatesRightInstance ( )", "prediction": "protected void setUp ( ) throws Exception\n", "label": 1}
{"id": 9497, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; public class NoCopyByteArrayOutputStream extends ByteArrayOutputStream { public NoCopyByteArrayOutputStream ( ) { super ( ) ; }", "gt": "public NoCopyByteArrayOutputStream ( int size )", "prediction": "@ Override public void close ( ) throws IOException\n", "label": 0}
{"id": 15503, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; import org . eclipse . swt . graphics . * ; class PngPlteChunk extends PngChunk { int paletteSize ; PngPlteChunk ( PaletteData palette ) { super ( palette . getRGBs ( ) . length * 3 ) ; paletteSize = length / 3 ; setType ( TYPE_PLTE ) ; setPaletteData ( palette ) ; setCRC ( computeCRC ( ) ) ; } PngPlteChunk ( byte [ ] reference ) { super ( reference ) ; paletteSize = length / 3 ; } int getChunkType ( ) { return CHUNK_PLTE ; } int getPaletteSize ( ) { return paletteSize ; } PaletteData getPaletteData ( ) { RGB [ ] rgbs = new RGB [ paletteSize ] ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { int offset = DATA_OFFSET + ( i * 3 ) ; int red = reference [ offset ] & 0xFF ; int green = reference [ offset + 1 ] & 0xFF ; int blue = reference [ offset + 2 ] & 0xFF ; rgbs [ i ] = new RGB ( red , green , blue ) ; } return new PaletteData ( rgbs ) ; } void setPaletteData ( PaletteData palette ) { RGB [ ] rgbs = palette . getRGBs ( ) ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { int offset = DATA_OFFSET + ( i * 3 ) ; reference [ offset ] = ( byte ) rgbs [ i ] . red ; reference [ offset + 1 ] = ( byte )", "gt": "rgbs [ i ] . green ;", "prediction": "rgbs [ i + 1 ] . green ;\n", "label": 1}
{"id": 6057, "input": "<s> package com . sun . tools . classfile ; public interface Dependency { public interface Filter { boolean accepts ( Dependency dependency ) ; } public interface Finder { public Iterable < ? extends", "gt": "Dependency > findDependencies ( ClassFile classfile ) ;", "prediction": "Dependency > getDependencies ( ) ;\n", "label": 0}
{"id": 15505, "input": "<s> package org . agoncal . book . javaee7 . chapter19 . ex02 ; import org . agoncal . book . javaee7 . chapter19 . OrderLine ; import org . junit . Test ; import org . xml . sax . SAXParseException ; import java . util . List ; import static org . junit . Assert . assertEquals ; public class DomParsingWithValidationTest { @ Test ( expected = SAXParseException . class ) public void shouldParseOrderLines ( ) throws Exception { List < OrderLine > parseOrderLines = new DomParsingWithValidation ( ) . parseOrderLines ( ) ; assertEquals ( 2 , parseOrderLines .", "gt": "size ( ) ) ;", "prediction": "size ( ) ) ;\n", "label": 1}
{"id": 6628, "input": "<s> package com . vexsoftware . votifier . net ; import java . io . BufferedWriter ; import java . io . InputStream ; import java . io . OutputStreamWriter ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketException ; import java . util . logging . * ; import javax . crypto . BadPaddingException ; import org . bukkit . Bukkit ; import com . vexsoftware . votifier . Votifier ; import com . vexsoftware . votifier . crypto . RSA ; import com . vexsoftware . votifier . model . * ; public class VoteReceiver extends Thread { private static final Logger LOG = Logger . getLogger ( \"Votifier\" ) ; private final Votifier plugin ; private final String host ; private final int port ; private ServerSocket server ; private boolean running = true ; public VoteReceiver ( final Votifier plugin , String host , int port ) throws Exception { this . plugin = plugin ; this . host = host ; this . port = port ; initialize ( ) ; } private void initialize ( ) throws Exception { try { server = new ServerSocket ( ) ; server . bind ( new InetSocketAddress ( host , port ) ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"Error initializing vote receiver. Please verify that the configured\" ) ; LOG . log ( Level . SEVERE , \"IP address and port are not already in use. This is a common problem\" ) ; LOG . log ( Level . SEVERE , \"with hosting services and, if so, you should check with your hosting provider.\" , ex ) ; throw new Exception ( ex ) ; } } public void shutdown ( ) { running = false ; if ( server == null ) return ; try { server . close ( ) ; } catch ( Exception ex ) { LOG . log ( Level . WARNING , \"Unable to shut down vote receiver cleanly.\" ) ; } } @ Override public void run ( ) { while ( running ) { try { Socket socket = server . accept ( ) ; socket . setSoTimeout ( 5000 ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) ) ) ; InputStream in = socket . getInputStream ( ) ; writer . write ( \"VOTIFIER \" + Votifier . getInstance ( ) .", "gt": "getVersion ( ) ) ;", "prediction": "getName ( ) ) ;\n", "label": 0}
{"id": 15514, "input": "<s> package io . beancounter . activities ; public class ActivityStoreException extends Exception { public ActivityStoreException ( String message ) { super ( message ) ; } public ActivityStoreException ( String message , Exception e ) { super", "gt": "( message , e ) ;", "prediction": "( message , e ) ;\n", "label": 1}
{"id": 4609, "input": "<s> class ConditionalArgTypes_2 { public static void main ( String [ ] args ) { boolean b = true ; System . out . println ( b", "gt": "? 0 : false ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15517, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"updateContentTypeXmlDocumentResult\" } ) @ XmlRootElement ( name = \"UpdateContentTypeXmlDocumentResponse\" ) public class UpdateContentTypeXmlDocumentResponse { @ XmlElement ( name = \"UpdateContentTypeXmlDocumentResult\" ) protected UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult updateContentTypeXmlDocumentResult ; public UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult getUpdateContentTypeXmlDocumentResult ( ) { return updateContentTypeXmlDocumentResult ; } public void setUpdateContentTypeXmlDocumentResult ( UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult value ) { this . updateContentTypeXmlDocumentResult = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" }", "gt": ") public static class UpdateContentTypeXmlDocumentResult", "prediction": ") @ XmlType ( name = \"\" , propOrder =\n", "label": 1}
{"id": 6793, "input": "<s> package org . remast . baralga . gui . model . report ; import org . joda . time . DateTime ; import org . remast . baralga . gui . events . BaralgaEvent ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . model . ProjectActivity ; import ca . odell . glazedlists . BasicEventList ; import ca . odell . glazedlists . SortedList ; import com . google . common . eventbus . EventBus ; import com . google . common . eventbus . Subscribe ; public class HoursByWeekReport { private final PresentationModel model ; private EventBus eventBus = new EventBus ( ) ; private final SortedList < HoursByWeek > hoursByWeekList ; public HoursByWeekReport ( final PresentationModel model ) { this . model = model ; this . model . getEventBus ( ) . register ( this ) ; this . hoursByWeekList = new SortedList < HoursByWeek > ( new BasicEventList < HoursByWeek > ( ) ) ; calculateHours ( ) ; } public EventBus getEventBus ( ) { return eventBus ; } public void calculateHours ( ) { this . hoursByWeekList . clear ( ) ; for ( ProjectActivity activity : this . model . getActivitiesList ( ) ) { this . addHours ( activity ) ; } } public void addHours ( final ProjectActivity activity ) { final DateTime dateTime = activity . getStart ( ) ; final HoursByWeek newHoursByWeek = new HoursByWeek ( dateTime , activity . getDuration ( ) ) ; if ( this . hoursByWeekList . contains ( newHoursByWeek ) ) { HoursByWeek hoursByWeek = this . hoursByWeekList . get ( hoursByWeekList . indexOf ( newHoursByWeek ) ) ; hoursByWeek . addHours ( newHoursByWeek . getHours ( ) ) ; } else { this . hoursByWeekList . add ( newHoursByWeek ) ; } } public", "gt": "SortedList < HoursByWeek > getHoursByWeek ( )", "prediction": "void removeHours ( final ProjectActivity activity )\n", "label": 0}
{"id": 15530, "input": "<s> package org . nuxeo . ecm . platform . picture . core ; import java . io . File ; import java . io . InputStream ; @ Deprecated public interface MimeUtils { String getImageMimeType ( File file ) ; String getImageMimeType", "gt": "( InputStream in ) ;", "prediction": "( InputStream stream ) ;\n", "label": 1}
{"id": 6366, "input": "<s> package com . sun . mirror . declaration ; import com . sun . mirror . type . TypeMirror ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface ParameterDeclaration extends Declaration {", "gt": "TypeMirror getType ( ) ;", "prediction": "public ParameterDeclaration ( )\n", "label": 0}
{"id": 15536, "input": "<s> package org . eclipse . rap . rwt . widgets ; import javax . servlet . http . Cookie ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . TestRequest ; import org . eclipse . rap . rwt . widgets . ClusteredSynchronizer ; public class ClusteredSynchronizer_Test extends TestCase { public void testExtractRequestCookiesWithSingleCookie ( ) { TestRequest request = new TestRequest ( ) ; request . addCookie ( new Cookie ( \"name\" , \"value\" ) ) ; String cookies = ClusteredSynchronizer . extractRequestCookies ( request ) ; assertEquals ( \"name=value\" , cookies ) ; } public void testExtractRequestCookiesWithMultipleCookies ( ) { TestRequest request = new TestRequest ( ) ; request . addCookie ( new Cookie ( \"name1\" , \"value1\" ) ) ; request . addCookie ( new Cookie", "gt": "( \"name2\" , \"value2\" ) ) ;", "prediction": "( \"name2\" , \"value2\" ) ) ;\n", "label": 1}
{"id": 5709, "input": "<s> package firstSentence ; public class B extends A {", "gt": "public void m ( )", "prediction": "}\n", "label": 0}
{"id": 15542, "input": "<s> package io . beancounter . platform ; public class ServiceException extends Exception { public ServiceException ( Exception e ) { super ( e ) ; } public ServiceException ( String message ) { super ( message ) ; } public ServiceException (", "gt": "String message , Exception e )", "prediction": "Throwable cause )\n", "label": 1}
{"id": 6440, "input": "<s> package com . redhat . ceylon . compiler . java . tools ; import java . io . File ; import java . io . IOException ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import javax . tools . FileObject ; import javax . tools . JavaFileManager ; import javax . tools . JavaFileObject ; import javax . tools . JavaFileObject . Kind ; import javax . tools . StandardJavaFileManager ; import javax . tools . StandardLocation ; import com . redhat . ceylon . cmr . api . Logger ; import com . redhat . ceylon . cmr . api . RepositoryManager ; import com . redhat . ceylon . cmr . ceylon . CeylonUtils ; import com . redhat . ceylon . cmr . impl . CachingRepositoryManager ; import com . redhat . ceylon . common . FileUtil ; import com . redhat . ceylon . common . config . Repositories ; import com . redhat . ceylon . compiler . java . codegen . CeylonFileObject ; import com . redhat . ceylon . compiler . java . util . Util ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . sun . tools . javac . main . OptionName ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . file . RegularFileObject ; import com . sun . tools . javac . file . RelativePath . RelativeFile ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Options ; public class CeyloncFileManager extends JavacFileManager implements StandardJavaFileManager { private Module currentModule ; private JarOutputRepositoryManager jarRepository ; private Context context ; private Options options ; private RepositoryManager repoManager ; private RepositoryManager outputRepoManager ; private Logger cmrLogger ; public CeyloncFileManager ( Context context , boolean register , Charset charset ) { super ( context , register , charset ) ; options = Options . instance ( context ) ; } private Logger getLogger ( ) { if ( cmrLogger == null ) cmrLogger = new JavacLogger ( options , Log . instance ( context ) ) ; return cmrLogger ; } private JarOutputRepositoryManager getJarRepository ( ) { if ( jarRepository == null ) jarRepository = new JarOutputRepositoryManager ( CeylonLog . instance ( context ) , options , this ) ; return jarRepository ; } public Context getContext ( ) { return context ; } @ Override public void setContext ( Context context ) { this . context = context ; super . setContext ( context ) ; } public JavaFileObject . Kind getKind ( String name ) { if ( name . endsWith ( JavaFileObject . Kind . CLASS . extension ) ) return JavaFileObject . Kind . CLASS ; else if ( name . endsWith ( JavaFileObject . Kind . SOURCE . extension ) || name . endsWith ( \".ceylon\" ) ) return JavaFileObject . Kind . SOURCE ; else if ( name . endsWith ( JavaFileObject . Kind . HTML . extension ) ) return JavaFileObject . Kind . HTML ; else return JavaFileObject . Kind . OTHER ; } public static void preRegister ( final Context context ) { context . put ( JavaFileManager . class , new Context . Factory < JavaFileManager > ( ) { public JavaFileManager make ( Context context ) { return new CeyloncFileManager", "gt": "( context , true , null ) ;", "prediction": "( context ) ;\n", "label": 0}
{"id": 15543, "input": "<s> package org . restlet . ext . jaxrs . internal . spi ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . ext . RuntimeDelegate ; import javax . ws . rs . ext . RuntimeDelegate . HeaderDelegate ; import org . restlet . engine . header . ContentType ; import org . restlet . ext . jaxrs . internal . util . Converter ; public class MediaTypeHeaderDelegate implements HeaderDelegate < MediaType > { public MediaTypeHeaderDelegate ( ) { } public MediaType fromString ( String contentType ) throws IllegalArgumentException { final org . restlet . data .", "gt": "MediaType restletMediaType = ContentType . readMediaType ( contentType ) ;", "prediction": "MediaType result ;\n", "label": 1}
{"id": 2519, "input": "<s> import java . io . * ; abstract class AChurchBoolean { public abstract < Return , Parameter , Throws extends Throwable > Return accept ( IVisitor < Return , Parameter , Throws > visitor , Parameter parameter ) throws Throws ; public interface IVisitor < Return , Parameter , Throws extends Throwable > { public Return caseTrue ( Parameter parameter ) throws Throws ; public Return caseFalse ( Parameter parameter ) throws Throws ; } } class TrueChurchBoolean extends AChurchBoolean { private static TrueChurchBoolean instance = new TrueChurchBoolean ( ) ; private TrueChurchBoolean ( ) { } public static TrueChurchBoolean singleton ( ) { return instance ; } public < Return , Parameter , Throws extends Throwable > Return accept ( IVisitor < Return , Parameter , Throws > visitor , Parameter parameter ) throws Throws { return visitor . caseTrue ( parameter ) ; } } class FalseChurchBoolean extends AChurchBoolean { private static FalseChurchBoolean instance = new FalseChurchBoolean ( ) ; private FalseChurchBoolean ( ) { } public static FalseChurchBoolean singleton ( ) { return instance ; } public < Return , Parameter , Throws extends Throwable > Return accept ( IVisitor < Return , Parameter , Throws > visitor , Parameter parameter ) throws Throws { return visitor . caseFalse ( parameter ) ; } } class Pair < T , U > { private T first ; private U second ; Pair ( T first , U second ) { this . first = first ; this . second = second ; } T getFirst ( ) { return first ; } U getSecond ( ) { return second ; } } class ChurchBooleanTest { private AChurchBoolean bool ; public ChurchBooleanTest ( AChurchBoolean bool ) { this . bool = bool ; } public AChurchBoolean readIf (", "gt": "File file , byte [ ] output ) throws IOException", "prediction": ")\n", "label": 0}
{"id": 15544, "input": "<s> package org . restlet . data ; import java . io . File ; public final class LocalReference extends Reference { public static final int CLAP_DEFAULT = 0 ; public static final int CLAP_CLASS = 1 ; public static final int CLAP_SYSTEM = 2 ; public static final int CLAP_THREAD = 3 ; public static final int RIAP_APPLICATION = 4 ; public static final int RIAP_COMPONENT = 5 ; public static final int RIAP_HOST = 6 ; public static LocalReference createClapReference ( Package pkg ) { return createClapReference ( CLAP_DEFAULT , pkg ) ; } public static LocalReference createClapReference ( int authorityType , Package pkg ) { String pkgPath = pkg . getName ( ) . replaceAll ( \"\\\\.\" , \"/\" ) ; return new LocalReference ( \"clap://\" + getAuthorityName ( authorityType ) + \"/\" + pkgPath ) ; } public static LocalReference createClapReference ( String path ) { return createClapReference ( CLAP_DEFAULT , path ) ; } public static LocalReference createClapReference ( int authorityType , String path ) { return new LocalReference ( \"clap://\" + getAuthorityName ( authorityType ) + path ) ; } public static LocalReference createFileReference ( File file ) { return createFileReference ( file . getAbsolutePath ( ) ) ; } public static LocalReference createFileReference ( String filePath ) { return createFileReference ( \"\" , filePath ) ; } public static LocalReference createFileReference ( String hostName , String filePath ) { return new LocalReference ( \"file://\" + hostName + \"/\" + normalizePath ( filePath ) ) ; } public static LocalReference createJarReference ( Reference jarFile , String entryPath ) { return new LocalReference ( \"jar:\" + jarFile . getTargetRef ( ) . toString ( ) + \"!/\" + entryPath ) ; } public static LocalReference createRiapReference ( int authorityType , String path ) { return new LocalReference ( \"riap://\" + getAuthorityName ( authorityType ) + path ) ; } public static LocalReference createZipReference ( Reference zipFile , String entryPath ) { return new LocalReference ( \"zip:\" + zipFile . getTargetRef ( ) . toString ( ) + \"!/\" + entryPath ) ; } public static String getAuthorityName ( int authority ) { String result = null ; switch ( authority ) { case CLAP_DEFAULT : result = \"\" ; break ; case CLAP_CLASS : result = \"class\" ; break ; case CLAP_SYSTEM : result = \"system\" ; break ; case CLAP_THREAD : result = \"thread\" ; break ; case RIAP_APPLICATION : result = \"application\" ; break ; case RIAP_COMPONENT : result = \"component\" ; break ; case RIAP_HOST : result = \"host\" ; break ; } return result ; } public static String localizePath ( String path ) { final StringBuilder result = new StringBuilder ( ) ; char nextChar ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { nextChar = path . charAt ( i ) ; if ( nextChar == '/' ) { result . append ( File . separatorChar ) ; } else { result . append ( nextChar ) ; } } return result . toString ( ) ; } public static String normalizePath ( String path ) { final StringBuilder result = new StringBuilder ( ) ; char nextChar ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { nextChar = path . charAt ( i ) ; if ( ( nextChar == File . separatorChar ) ) { result . append ( '/' ) ; } else if ( ! isUnreserved ( nextChar ) ) { result . append ( Reference . encode ( \"\" + nextChar ) ) ; } else { result . append ( nextChar ) ; } } return result . toString ( ) ; } public LocalReference ( Reference localRef ) { super ( localRef . getTargetRef ( )", "gt": ". toString ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8933, "input": "<s> package org . ofbiz . shipment . thirdparty . dhl ; import java . io . IOException ; import java . io . StringWriter ; import java . math . BigDecimal ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . xml . parsers . ParserConfigurationException ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Base64 ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . HttpClient ; import org . ofbiz . base . util . HttpClientException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . shipment . shipment . ShipmentServices ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class DhlServices { public final static String module = DhlServices . class . getName ( ) ; public final static String shipmentPropertiesFile = \"shipment.properties\" ; public final static String DHL_WEIGHT_UOM_ID = \"WT_lb\" ; public static final String resourceError = \"ProductUiLabels\" ; public static String sendDhlRequest ( String xmlString , Delegator delegator , String shipmentGatewayConfigId , String resource , Locale locale ) throws DhlConnectException { String conStr = getShipmentGatewayConfigValue ( delegator , shipmentGatewayConfigId , \"connectUrl\" , resource , \"shipment.dhl.connect.url\" ) ; if ( conStr == null ) { throw new DhlConnectException ( UtilProperties . getMessage ( resourceError , \"FacilityShipmentDhlConnectUrlIncomplete\" , locale ) ) ; } if ( xmlString == null ) { throw new DhlConnectException ( UtilProperties . getMessage", "gt": "( resourceError , \"FacilityShipmentDhlXmlCannotBeNull\" , locale ) ) ;", "prediction": "( resourceError , \"FacilityShipmentDhlConnectUrlIncomplete\" , locale ) ) ;\n", "label": 0}
{"id": 15546, "input": "<s> package org . fuzzydb . io . core ; import java . nio . ByteBuffer ; public interface SourcedMessage {", "gt": "MessageSink getSource ( ) ;", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 4325, "input": "<s> class A { void m1 ( ) { System . err . println ( \"hello\" ) ;", "gt": "0 System . err . println ( \"world\" ) ;", "prediction": "}\n", "label": 0}
{"id": 15549, "input": "<s> package episode_31 ; import org . jbox2d . collision . shapes . PolygonShape ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . * ; import org . lwjgl . LWJGLException ; import org . lwjgl . input . Keyboard ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import java . util . HashSet ; import java . util . Set ; import static org . lwjgl . opengl . GL11 . * ; public class PhysicsDemo { private static final String WINDOW_TITLE = \"Physics in 2D!\" ; private static final int [ ] WINDOW_DIMENSIONS = { 640 , 480 } ; private static World world = new World ( new Vec2 ( 0 , - 9.8f ) , false ) ; private static Set < Body > bodies = new HashSet < Body > ( ) ; private static void render ( ) { glClear ( GL_COLOR_BUFFER_BIT ) ; for ( Body body : bodies ) { if ( body . getType ( ) == BodyType . DYNAMIC ) { glPushMatrix ( ) ; Vec2 bodyPosition = body . getPosition ( ) . mul ( 30 ) ; glTranslatef ( bodyPosition . x , bodyPosition . y , 0 ) ; glRotated ( Math . toDegrees ( body . getAngle ( ) ) , 0 , 0 , 1 ) ; glRectf ( - 0.75f * 30 , - 0.75f * 30 , 0.75f * 30 , 0.75f * 30 ) ; glPopMatrix ( ) ; } } } private static void logic ( ) { world . step ( 1 / 60f , 8 , 3 ) ; } private static void input ( ) { for ( Body body : bodies ) { if ( body . getType ( ) == BodyType . DYNAMIC ) { if ( Keyboard . isKeyDown ( Keyboard . KEY_A ) && ! Keyboard . isKeyDown ( Keyboard . KEY_D ) ) { body . applyAngularImpulse ( + 0.01f ) ; } else if ( Keyboard . isKeyDown ( Keyboard . KEY_D ) && ! Keyboard . isKeyDown ( Keyboard . KEY_A ) ) { body . applyAngularImpulse ( - 0.01f ) ; } if ( Mouse . isButtonDown ( 0 ) ) { Vec2 mousePosition = new Vec2 ( Mouse . getX ( ) , Mouse . getY ( ) ) . mul ( 0.5f ) . mul ( 1 / 30f ) ; Vec2 bodyPosition = body . getPosition ( ) ; Vec2 force = mousePosition . sub ( bodyPosition ) ; body . applyForce ( force , body . getPosition ( ) ) ; } } } } private static void cleanUp ( boolean asCrash ) { Display . destroy ( ) ; System . exit ( asCrash ? 1 : 0 ) ; } private static void setUpMatrices ( ) { glMatrixMode ( GL_PROJECTION ) ; glOrtho ( 0 , 320 , 0 , 240 , 1 , - 1 ) ; glMatrixMode ( GL_MODELVIEW ) ; } private static void setUpObjects ( ) { BodyDef boxDef = new BodyDef ( ) ; boxDef . position . set ( 320 / 30 / 2 , 240 / 30 / 2 ) ; boxDef . type = BodyType . DYNAMIC ; PolygonShape boxShape = new PolygonShape ( ) ; boxShape . setAsBox ( 0.75f , 0.75f ) ; Body box = world . createBody ( boxDef ) ; FixtureDef boxFixture = new FixtureDef ( ) ; boxFixture . density = 0.1f ; boxFixture . shape = boxShape ; box . createFixture ( boxFixture ) ; bodies . add ( box ) ; BodyDef groundDef = new BodyDef ( ) ; groundDef . position . set ( 0 , 0 ) ; groundDef . type = BodyType . STATIC ; PolygonShape groundShape = new PolygonShape ( ) ; groundShape . setAsBox ( 1000 , 0 ) ; Body ground = world . createBody ( groundDef ) ; FixtureDef groundFixture = new FixtureDef ( ) ; groundFixture . density = 1 ; groundFixture . restitution = 0.3f ; groundFixture . shape = groundShape ; ground . createFixture ( groundFixture ) ; bodies . add ( ground ) ; } private", "gt": "static void update ( )", "prediction": "static void render ( )\n", "label": 1}
{"id": 3989, "input": "<s> package mage . tracker . dto ; import java . util . Date ; import mage . tracker . domain . Account ; import mage . tracker . domain . Comment ; public class CommentData { private String text ; private Date postTime ; private String accountName ; private Long accountId ; public CommentData ( Comment comment ) { this . text = comment . getText ( ) ; this . postTime = comment . getPostTime ( ) ; Account account", "gt": "= comment . getAccount ( ) ;", "prediction": "= comment . getAccount ( ) ;\n", "label": 0}
{"id": 15553, "input": "<s> package pdgame ; public class T4TPlayer extends BasicPlayer { int oppLastMove = GameMove . COOPERATE ; public T4TPlayer ( ) { myID = \"T4T Player\" ; } public int makeMove ( ) { if ( oppLastMove == GameMove . COOPERATE ) return GameMove . COOPERATE ; else return GameMove . DEFECT ; } @ Override public void setScore ( int myMove , int oppMove , int myScore , int", "gt": "oppScore , String oppID )", "prediction": "oppLastMove )\n", "label": 1}
{"id": 2108, "input": "<s> package api . son ; import java . lang . reflect . Type ; import api . util . StringUtils ; import com . google . gson . JsonDeserializationContext ; import com . google . gson . JsonDeserializer ; import com . google . gson . JsonElement ; import com . google . gson . JsonParseException ; public class MyStringDeserializer implements JsonDeserializer < Object > { @ Override public Object deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { String s = StringUtils . unescapeHTML ( json . getAsJsonPrimitive ( ) .", "gt": "getAsString ( ) ) ;", "prediction": "getAsString ( ) ) ;\n", "label": 0}
{"id": 15566, "input": "<s> package org . restlet . test . resource ; import java . util . Date ; public class FullContact extends Contact { private String address1 ; private String address2 ; private String address3 ; public FullContact ( String email , String firstName , String lastName , Date birthDate , String email2 , String address1 , String address2 , String address3 , String fax , String phone ) { super ( email , firstName , lastName , birthDate , email2 ) ; this . address1 = address1 ; this . address2 = address2 ; this . address3 = address3 ; this . fax = fax ; this . phone = phone ; } private String fax ; private String phone ; public String getAddress1 ( ) { return address1 ; } public String getAddress2 ( ) { return address2 ; } public String getAddress3 ( ) { return address3 ; } public String getFax ( ) { return fax ; } public String getPhone ( ) { return phone ; } public void setAddress1 ( String address1 ) { this . address1 = address1 ; } public void setAddress2 ( String address2 ) { this . address2 = address2 ; } public void setAddress3 ( String address3 ) { this . address3 = address3 ; } public void", "gt": "setFax ( String fax )", "prediction": "setAddress4 ( String address4 )\n", "label": 1}
{"id": 5768, "input": "<s> package com . midtro . platform . modules ; import com . midtro . platform . Application ; public interface MessageHandler { void handle ( Application app ,", "gt": "Object ... parameters ) ;", "prediction": "Message message ) ;\n", "label": 0}
{"id": 15569, "input": "<s> package org . restlet . ext . odata ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . restlet . Context ; import org . restlet . data . MediaType ; import org . restlet . data . Parameter ; import org . restlet . data . Reference ; import org . restlet . ext . atom . Entry ; import org . restlet . ext . atom . Feed ; import org . restlet . ext . atom . Link ; import org . restlet . ext . atom . Relation ; import org . restlet . ext . odata . internal . EntryContentHandler ; import org . restlet . ext . odata . internal . EntryIterator ; import org . restlet . ext . odata . internal . FeedContentHandler ; import org . restlet . ext . odata . internal . edm . EntityType ; import org . restlet . ext . odata . internal . edm . Metadata ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . ClientResource ; import org . restlet . resource . ResourceException ; import org . restlet . routing . Template ; import org . restlet . routing . Variable ; import org . restlet . util . Series ; public class Query < T > implements Iterable < T > { public static final int TYPE_COMPLEX_TYPE_OR_PROPERTY = 3 ; public static final int TYPE_COMPLEX_TYPE_PROPERTY = 4 ; public static final int TYPE_COMPLEX_TYPE_PROPERTY5 = 5 ; public static final int TYPE_ENTITY = 2 ; public static final int TYPE_ENTITY_SET = 1 ; public static final int TYPE_LINKS = 7 ; public static final int TYPE_PROPERTY_VALUE = 6 ; public static final int TYPE_UNKNOWN = 0 ; private int count ; private List < T > entities ; private Class < ? > entityClass ; private EntityType entityType ; private boolean executed ; private Feed feed ; private boolean inlineCount ; private Logger logger ; private Reference nextPage ; private String query ; private Service service ; private String subpath ; public Query ( Service service , String subpath , Class < T > entityClass ) { this . count = - 1 ; this . executed = false ; this . entityClass = entityClass ; if ( service . getMetadata ( ) != null ) { this . entityType = ( ( Metadata ) service . getMetadata ( ) ) . getEntityType ( entityClass ) ; } else { this . entityType = null ; } this . service = service ; Reference ref = new Reference ( subpath ) ; if ( ref . isAbsolute ( ) ) { this . subpath = ref . getRelativeRef ( service . getServiceRef ( ) ) . toString ( true , true ) ; } else { this . subpath = subpath ; } } @ SuppressWarnings ( \"unchecked\" ) public Query < T > addParameter ( String name , String value ) { Query < T > result = new Query < T > ( this . getService ( ) , this . getSubpath ( ) , ( Class < T > ) this . entityClass ) ; if ( getQuery ( ) == null || \"\" . equals ( getQuery ( ) ) ) { result . setQuery ( name + \"=\" + value ) ; } else { result . setQuery ( getQuery ( ) + \"&\" + name + \"=\" + value ) ; } return result ; } @ SuppressWarnings ( \"unchecked\" ) public Query < T > addParameters ( Series < Parameter > params ) { Query < T > result = new Query < T > ( this . getService ( ) , this . getSubpath ( ) , ( Class < T > ) this . entityClass ) ; StringBuilder builder = new StringBuilder ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . size ( ) ; i ++ ) { Parameter param = params . get ( i ) ; if ( i == 0 ) { builder . append ( param . getName ( ) ) ; builder . append ( \"=\" ) ; builder . append ( param . getValue ( ) ) ; } } } if ( getQuery ( ) == null || \"\" . equals ( getQuery ( ) ) ) { result . setQuery ( builder . toString ( ) ) ; } else { result . setQuery ( getQuery ( ) + \"&\" + builder . toString ( ) ) ; } return result ; } protected String createTargetUri ( ) { String service = getService ( ) . getServiceRef ( ) . toString ( ) ; StringBuilder result = new StringBuilder ( service ) ; String subpath = ( getSubpath ( ) == null ) ? \"\" : getSubpath ( ) ; if ( service . endsWith ( \"/\" ) ) { if ( subpath . startsWith ( \"/\" ) ) { result . append ( subpath . substring ( 1 ) ) ; } else { result . append ( subpath ) ; } } else { if ( subpath . startsWith ( \"/\" ) ) { result . append ( subpath ) ; } else { result . append ( \"/\" ) . append ( subpath ) ; } } if ( getQuery ( ) != null ) { result . append ( \"?\" ) . append ( getQuery ( ) ) ; } return result . toString ( ) ; } public void execute ( ) throws Exception { if ( ! isExecuted ( ) ) { String targetUri = createTargetUri ( ) ; ClientResource resource = service . createResource ( new Reference ( targetUri ) ) ; Metadata metadata = ( Metadata ) service . getMetadata ( ) ; if ( metadata == null ) { throw new Exception ( \"Can't execute the query without the service's metadata.\" ) ; } Representation result = null ; try { result = resource . get ( MediaType . APPLICATION_ATOM ) ; } catch ( ResourceException e ) { getLogger ( ) . warning ( \"Can't execute the query for the following reference: \" + targetUri + \" due to \" + e . getMessage ( ) ) ; throw e ; } if ( resource . getStatus", "gt": "( ) . isSuccess ( ) )", "prediction": "( ) . isSuccess ( ) )\n", "label": 1}
{"id": 9553, "input": "<s> package au . net . fremnet . bukkit . Bedrock ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . event . EventHandler ; import org . bukkit . event . Listener ; import org . bukkit . event . player . PlayerMoveEvent ; public class BedrockPlayerListener implements Listener { @ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { World world = event . getTo ( ) . getWorld ( ) ; if ( Bedrock . Blacklist . contains ( world ) ) return ; Location from = event . getFrom ( ) ; Location to = event . getTo ( ) ; int toY = ( int ) Math . floor ( to . getY ( ) ) , toX = ( int ) Math . floor ( to . getX ( ) ) , toZ = ( int ) Math . floor ( to . getZ ( ) ) , fromY = ( int ) Math . ceil ( from . getY ( ) ) ; if ( toY > Bedrock . CheckBelow ) return ; if ( fromY > Bedrock . CheckBelow ) { int startX = toX - Bedrock . FlattenSquare ; int endX = toX + Bedrock . FlattenSquare ; int startZ = toZ - Bedrock . FlattenSquare ; int endZ = toZ + Bedrock . FlattenSquare ; replace ( world , startX , startZ , endX , endZ ) ; } else { if ( Math . abs ( to . getX ( ) - from . getX ( ) ) > 0.1 ) { int startX = source ( from . getX ( ) , to . getX ( ) , true ) - 1 ; int endX = source ( from . getX ( ) , to . getX ( ) , false ) + 1 ; int startZ = toZ - Bedrock . FlattenSquare ; int endZ = toZ + Bedrock . FlattenSquare ; replace ( world , startX , startZ , endX , endZ ) ; } if ( Math . abs ( to . getZ ( ) - from . getZ ( ) ) > 0.01 ) { int startX", "gt": "= toX - Bedrock . FlattenSquare ;", "prediction": "= source ( from . getZ ( ) , to . getZ ( ) , true ) - 1 ;\n", "label": 0}
{"id": 15571, "input": "<s> package org . nuxeo . ecm . automation . core . util ; import java . io . InputStream ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . common . utils . StringUtils ; import org . nuxeo . ecm . automation . OperationException ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . model . Property ; import org . nuxeo . ecm . core . api . model . PropertyException ; import org . nuxeo . ecm . core . api . model . impl . ListProperty ; import org . nuxeo . ecm . core . api . security . ACE ; import org . nuxeo . ecm . core . api . security . ACL ; import org . nuxeo . ecm . core . api . security . impl . ACLImpl ; import org . nuxeo . ecm . core . api . security . impl . ACPImpl ; import org . nuxeo . ecm . core . schema . types . ComplexType ; import org . nuxeo . ecm . core . schema . types . ListType ; import org . nuxeo . ecm . core . schema . types . SimpleType ; import org . nuxeo . ecm . core . schema . types . Type ; import org . nuxeo . ecm . core . schema . types . primitives . BinaryType ; import org . nuxeo . ecm . core . schema . types . primitives . BooleanType ; import org . nuxeo . ecm . core . schema . types . primitives . DateType ; import org . nuxeo . ecm . core . schema . types . primitives . DoubleType ; import org . nuxeo . ecm . core . schema . types . primitives . IntegerType ; import org . nuxeo . ecm . core . schema . types . primitives . LongType ; import org . nuxeo . ecm . core . schema . types . primitives . StringType ; public class DocumentHelper { private DocumentHelper ( ) { } public static DocumentModel saveDocument ( CoreSession session , DocumentModel doc ) throws ClientException { doc = session . saveDocument ( doc ) ; return session . getDocument ( doc . getRef ( ) ) ; } public static void removeProperty ( DocumentModel doc , String xpath ) throws ClientException { Property p = doc . getProperty ( xpath ) ; if ( p . isList ( ) ) { ( ( ListProperty ) p ) . clear ( ) ; } else { Property pp = p . getParent ( ) ; if ( pp != null && pp . isList ( ) ) { ( ( ListProperty ) pp ) . remove ( p ) ; } else { p . remove ( ) ; } } } public static void addBlob ( Property p , Blob blob ) throws PropertyException { if ( p . isList ( ) ) { Type ft = ( ( ListProperty ) p ) . getType ( ) . getFieldType ( ) ; if ( ft . isComplexType ( ) && ( ( ComplexType ) ft ) . getFieldsCount ( ) == 2 ) { p . addValue ( createBlobHolderMap ( blob ) ) ; } else { p . addValue ( blob ) ; } } else { p . setValue ( blob ) ; } } public static HashMap < String , Serializable > createBlobHolderMap ( Blob blob ) { HashMap < String , Serializable > map = new HashMap < String , Serializable > ( ) ; map . put ( \"file\" , ( Serializable ) blob ) ; map . put ( \"filename\" , blob . getFilename ( ) ) ; return map ; } public static void setProperties ( CoreSession session , DocumentModel doc , Map < String , String > values ) throws Exception { for ( Map . Entry < String , String > entry : values . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; setProperty ( session , doc , key , value ) ; } } public static void setProperty ( CoreSession session , DocumentModel doc , String key , String value ) throws Exception { if ( \"ecm:acl\" . equals ( key ) ) { setLocalAcl ( session , doc , value ) ; } Property p = doc . getProperty ( key ) ; if ( value == null", "gt": "|| value . length ( ) == 0 )", "prediction": ")\n", "label": 1}
{"id": 7801, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignBar3DPlot ; import net . sf . jasperreports . charts . design . JRDesignCategoryDataset ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJBar3DChartBuilder ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class Bar3DChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnState ) ; drb . addColumn ( columnBranch ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; GroupBuilder gb1 = new GroupBuilder ( ) ; DJGroup g1 = gb1 . setCriteriaColumn ( ( PropertyColumn ) columnState ) . addFooterVariable ( columnAmount , DJCalculation . SUM ) . addFooterVariable ( columnaQuantity , DJCalculation . SUM ) . addVariable ( \"group_state_name\" , columnState , DJCalculation . FIRST ) . setGroupLayout ( GroupLayout . VALUE_IN_HEADER_WITH_HEADERS ) . build ( ) ; drb . addGroup ( g1 ) ; drb . setUseFullPageWidth ( true ) ; DJAxisFormat categoryAxisFormat = new DJAxisFormat ( \"category\" ) ; categoryAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelMask ( \"\" ) ; categoryAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJAxisFormat valueAxisFormat = new DJAxisFormat ( \"value\" ) ; valueAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat .", "gt": "setTickLabelMask ( \"#,##0.0\" ) ;", "prediction": "setTickLabelMask ( \"\" ) ;\n", "label": 0}
{"id": 15577, "input": "<s> package br . org . archimedes . ellipse ; import java . util . ArrayList ; import java . util . List ; import br . org . archimedes . controller . commands . PutOrRemoveElementCommand ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . gui . model . Workspace ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . Parser ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Point ; import br . org . archimedes . parser . DistanceParser ; import br . org . archimedes . parser . PointParser ; import br . org . archimedes . parser . StringDecoratorParser ; public class EllipseFactory implements CommandFactory { private Point center ; private Point widthPoint ; private Point heightPoint ; private Point focus1 ; private Point focus2 ; private double radius ; private Workspace workspace ; private boolean active ; private PutOrRemoveElementCommand command ; private boolean isCenterProtocol ; public EllipseFactory ( ) { workspace = br . org . archimedes . Utils . getWorkspace ( ) ; deactivate ( ) ; this . isCenterProtocol = false ; } public String begin ( ) { active = true ; br . org . archimedes . Utils . getController ( ) . deselectAll ( ) ; return Messages . EllipseFactory_SelectInitialPoint ; } public String cancel ( ) { deactivate ( ) ; return Messages . Canceled ; } public void drawVisualHelper ( ) { OpenGLWrapper opengl = br . org . archimedes . Utils . getOpenGLWrapper ( ) ; if ( isCenterProtocol ) { if ( center != null && widthPoint == null && ! isDone ( ) ) { Point start = center ; Point end = workspace . getMousePosition ( ) ; opengl . setLineStyle ( OpenGLWrapper . STIPPLED_LINE ) ; Line line ; try { line = new Line ( start , end ) ; line . draw ( opengl ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvalidArgumentException e ) { e . printStackTrace ( ) ; } } else if ( center != null && widthPoint != null && ! isDone ( ) ) { Point start = center ; Point middle = widthPoint ; Point end = workspace . getMousePosition ( ) ; opengl . setLineStyle ( OpenGLWrapper . STIPPLED_LINE ) ; try { Ellipse ellipse = new Ellipse ( start , middle , end ) ; ellipse . draw ( opengl ) ; Line line = new Line ( start , middle ) ; line . draw ( opengl ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvalidArgumentException e ) { } } } else { if ( focus1 != null && focus2 == null && ! isDone ( ) ) { Point f1 = focus1 ; Point f2 = workspace . getMousePosition ( ) ; opengl . setLineStyle ( OpenGLWrapper . STIPPLED_LINE ) ; Line line ; try { line = new Line ( f1 , f2 ) ; line . draw ( opengl ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvalidArgumentException e ) { e . printStackTrace ( ) ; } } else if ( focus1 != null &&", "gt": "focus2 != null && ! isDone ( ) )", "prediction": "focus2 != null && ! isDone ( ) )\n", "label": 1}
{"id": 2220, "input": "<s> public class StringConversion2 { public static void main ( String [ ] args ) { Object o = \"Hello \" ; String s = \"World!\" ; o += s ; if ( ! o . equals ( \"Hello World!\" ) ) throw new", "gt": "Error ( \"test failed\" ) ;", "prediction": "IllegalArgumentException ( ) ;\n", "label": 0}
{"id": 15581, "input": "<s> package org . restlet . test . ext . jaxrs . util ; import junit . framework . TestCase ; import org . restlet . ext . jaxrs . internal . util . OrderedMap ; @ SuppressWarnings ( \"all\" ) public class OrderedMapTest extends TestCase { public void test2 ( ) { OrderedMap < String , Integer > sob = new OrderedMap < String , Integer > ( ) ; sob . add ( \"a\" , 1 ) ; assertEquals ( \"[a -> 1]\" , sob . toString ( ) ) ; sob . add ( \"b\" , 2 ) ; assertEquals ( \"[a -> 1, b -> 2]\" , sob . toString ( ) ) ; sob . add ( \"d\" , 1 ) ; assertEquals ( \"[a -> 1, b -> 2, d", "gt": "-> 1]\" , sob . toString ( ) ) ;", "prediction": "-> 2]\" , sob . toString ( ) ) ;\n", "label": 1}
{"id": 4500, "input": "<s> import java . util . List ; class T6369605a { static < T extends List < T > > T m1 ( ) { return null ; } static < T extends List < U > , U extends List < T > > T m2 ( ) { return null ; } static < T extends List < U > , U extends List < V > , V extends List < T > > T m3 ( ) { return null ; } List < ? > l1 = m1 ( ) ; List < ? > l2 = m2 ( ) ; List", "gt": "< ? > l3 = m3 ( ) ;", "prediction": "< ? > l3 = m3 ( ) ;\n", "label": 0}
{"id": 15583, "input": "<s> package org . eclipse . ui . commands ; public final class NotDefinedException extends CommandException { private static final long serialVersionUID = 3257572788998124596L ; public NotDefinedException ( String s ) { super ( s ) ; } public NotDefinedException ( final org . eclipse . core . commands .", "gt": "common . NotDefinedException e )", "prediction": "Command command )\n", "label": 1}
{"id": 8828, "input": "<s> package com . mobeelizer . mobile . android ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; import java . util . UUID ; import android . os . Environment ; import android . util . Log ; import com . mobeelizer . java . sync . MobeelizerInputData ; class MobeelizerFileService { private static final String TAG = \"mobeelizer:fileservice\" ; private final MobeelizerApplication application ; MobeelizerFileService ( final MobeelizerApplication application ) { this . application = application ; } String addFile ( final InputStream stream ) { String guid = UUID . randomUUID ( ) . toString ( ) ; String path = savaFile ( guid , stream ) ; application . getDatabase ( ) . addFile ( guid , path ) ; return guid ; } void deleteFilesFromSync ( final List < String > files ) { for ( String guid : files ) { Log . i ( TAG , \"Delete file from sync: \" + guid ) ; String path = application . getDatabase ( ) . getFilePath ( guid ) ; if ( path == null ) { continue ; } File file = new File ( path ) ; if ( ! file . delete ( ) ) { Log . w ( TAG , \"Cannot remove file \" + file . getAbsolutePath ( ) ) ; } application . getDatabase ( ) . deleteFileFromSync ( guid ) ; } } void addFilesFromSync ( final List < String > files , final MobeelizerInputData inputData ) { for ( String guid : files ) { if ( application . getDatabase ( ) . isFileExists ( guid ) ) { Log . i ( TAG , \"Skip existing file from sync: \" + guid ) ; continue ; } Log . i ( TAG , \"Add file from sync: \" + guid ) ; String path = null ; try { path = savaFile ( guid , inputData . getFile ( guid ) ) ; } catch ( IOException e ) { Log . w ( TAG , e . getMessage ( ) , e ) ; path = \"/unknown\" ; } application . getDatabase ( ) . addFileFromSync (", "gt": "guid , path ) ;", "prediction": "guid , path ) ;\n", "label": 0}
{"id": 15594, "input": "<s> package org . eclipse . swt . internal . widgets . displaykit ; import static org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil . getId ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . IDisplayLifeCycleAdapter ; import org . eclipse . rap . rwt . internal . lifecycle . IRenderRunnable ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . lifecycle . UITestUtil ; import org . eclipse . rap . rwt . internal . theme . ThemeUtil ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackManager ; import org . eclipse . rap . rwt . lifecycle . AbstractWidgetLCA ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseEvent ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . DestroyOperation ; import org . eclipse . rap . rwt . testfixture . Message . SetOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; import org . eclipse . swt . internal . widgets . WidgetAdapter ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Widget ; public class DisplayLCA_Test extends TestCase { private static final List < Widget > log = new ArrayList < Widget > ( ) ; private static final List < Widget > renderInitLog = new ArrayList < Widget > ( ) ; private static final List < Widget > renderChangesLog = new ArrayList < Widget > ( ) ; private static final List < Widget > renderDisposeLog = new ArrayList < Widget > ( ) ; private Display display ; private String displayId ; private DisplayLCA displayLCA ; @ Override protected void setUp ( ) throws Exception { clearLogs ( ) ; Fixture . setUp ( ) ; display = new Display ( ) ; displayId = DisplayUtil . getId ( display ) ; displayLCA = new DisplayLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; clearLogs ( ) ; setEnableUiTests ( false ) ; }", "gt": "public void testPreserveValues ( )", "prediction": "@ Override protected void tearDown ( ) throws Exception\n", "label": 1}
{"id": 4536, "input": "<s> package gui ; import javax . swing . ImageIcon ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . SpringLayout ; import javax . swing . SwingConstants ; public class CheckoutThankyouPanel extends JPanel { private static final long serialVersionUID = 997202355725952480L ; public CheckoutThankyouPanel ( ) { SpringLayout springLayout = new SpringLayout ( ) ; setLayout ( springLayout ) ; JLabel tigerImage = new JLabel ( \"\" ) ; springLayout . putConstraint ( SpringLayout . NORTH , tigerImage , 0 , SpringLayout . NORTH , this ) ; springLayout . putConstraint ( SpringLayout . WEST , tigerImage , 0 , SpringLayout . WEST , this ) ; springLayout . putConstraint ( SpringLayout . EAST , tigerImage , 821 , SpringLayout . WEST , this ) ; tigerImage . setHorizontalAlignment ( SwingConstants . CENTER ) ; tigerImage . setIcon ( new ImageIcon ( CheckoutThankyouPanel . class . getResource ( \"/gui/thankyou.png\" ) ) ) ; add ( tigerImage ) ; JLabel thankyouMessage = new JLabel ( \"Your purchase has been processed, you will recive an email with your receipt shortly, all rented books will now be available.\" ) ; springLayout . putConstraint ( SpringLayout . SOUTH , tigerImage , - 25 , SpringLayout . NORTH , thankyouMessage ) ; springLayout . putConstraint ( SpringLayout . NORTH , thankyouMessage , 459 , SpringLayout . NORTH , this ) ; springLayout . putConstraint ( SpringLayout . WEST , thankyouMessage , 0 , SpringLayout . WEST , this ) ; springLayout . putConstraint ( SpringLayout . SOUTH , thankyouMessage , - 10 , SpringLayout . SOUTH , this ) ; springLayout . putConstraint ( SpringLayout . EAST , thankyouMessage , 0", "gt": ", SpringLayout . EAST , tigerImage ) ;", "prediction": ", SpringLayout . EAST , this ) ;\n", "label": 0}
{"id": 15595, "input": "<s> package de . uos . igf . db3d . dbms . util ; import java . util . Collection ; public final class IdentityHashSet extends AbstractHashSet { public IdentityHashSet ( ) { super ( ) ; } public IdentityHashSet ( Collection c ) { super ( c ) ; } public IdentityHashSet ( int initialCapacity , float loadFactor ) { super ( initialCapacity , loadFactor ) ; } public IdentityHashSet ( int initialCapacity ) { super ( initialCapacity ) ; } protected int hashOfObject ( Object key ) { return System . identityHashCode ( key ) ; } protected boolean equalityTest ( Object key , Object key2 ) {", "gt": "return key == key2 ;", "prediction": "return equals ( key , key2 ) ;\n", "label": 1}
{"id": 9018, "input": "<s> package syntax1 ; import java . lang . annotation . * ; import java . util . * ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD , ElementType . TYPE", "gt": ") public @ interface Syntax1", "prediction": ") public class Method\n", "label": 0}
{"id": 15601, "input": "<s> package org . apache . lucene . util ; import java . lang . reflect . * ; import java . text . DecimalFormat ; import java . util . * ; public final class RamUsageEstimator { private MemoryModel memoryModel ; private final Map seen ; private int refSize ; private int arraySize ; private int classSize ; private boolean checkInterned ; public RamUsageEstimator ( ) { this ( new AverageGuessMemoryModel ( ) ) ; } public RamUsageEstimator ( boolean checkInterned ) { this ( new AverageGuessMemoryModel ( ) , checkInterned ) ; } public RamUsageEstimator ( MemoryModel memoryModel ) { this ( memoryModel , true ) ; } public RamUsageEstimator ( MemoryModel memoryModel , boolean checkInterned ) { this . memoryModel = memoryModel ; this . checkInterned = checkInterned ; seen = new IdentityHashMap ( 64 ) ; this . refSize = memoryModel . getReferenceSize ( ) ; this . arraySize = memoryModel . getArraySize ( ) ; this . classSize = memoryModel . getClassSize ( ) ; } public long estimateRamUsage ( Object obj ) { long size = size ( obj ) ; seen . clear ( ) ; return size ; } private long size ( Object obj ) { if ( obj == null ) { return 0 ; } if ( checkInterned && obj instanceof String && obj == ( ( String ) obj ) . intern ( ) ) { return 0 ; } if ( seen . containsKey ( obj ) ) { return 0 ; } seen . put ( obj , null ) ; Class clazz = obj . getClass ( ) ; if ( clazz . isArray ( ) ) { return sizeOfArray ( obj ) ; } long size = 0 ; while ( clazz != null ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { if ( Modifier . isStatic ( fields [ i ] . getModifiers ( ) ) ) { continue ; } if ( fields [ i ] . getType ( ) . isPrimitive ( ) ) { size += memoryModel . getPrimitiveSize ( fields [ i ] . getType ( ) ) ; } else { size += refSize ; fields [ i ] . setAccessible ( true ) ; try { Object value = fields [ i ] . get ( obj ) ; if ( value != null ) { size += size ( value ) ; } } catch ( IllegalAccessException ex ) { } } } clazz = clazz . getSuperclass ( ) ; } size += classSize ; return size ; } private long sizeOfArray ( Object obj ) { int len = Array . getLength ( obj ) ; if ( len == 0 ) { return 0 ; } long size = arraySize ; Class arrayElementClazz = obj .", "gt": "getClass ( ) . getComponentType ( ) ;", "prediction": "getClass ( ) ;\n", "label": 1}
{"id": 2952, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . LivingEntity ; public interface LizaLivingEntity extends LivingEntity { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza (", "gt": "HashSet < Byte > transparent , int maxDistance ) ;", "prediction": "HashSet < Byte > transparent , int maxDistance ) ;\n", "label": 0}
{"id": 15603, "input": "<s> package br . org . archimedes . rotate ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.rotate.messages\" ; public static String CancelRotate ; public static String CommandFinished ; public static String ExpectedPoint ; public static String ExpectedVector ; public static String Iteration1 ; public static String Iteration2 ; public static String Iteration3 ; public static String NewAxisIteration1 ; public static String NewAxisIteration2 ; public static String RedefineInitial ; public static String SelectionExpected ; public static String TargetExpected ; static { NLS . initializeMessages (", "gt": "BUNDLE_NAME , Messages . class ) ;", "prediction": "BUNDLE_NAME , Messages . class . getName ( ) ) ;\n", "label": 1}
{"id": 9471, "input": "<s> import java . util . Set ; import java . util . Collections ; import javax . lang . model . element . TypeElement ; import javax . annotation . processing . * ; import com . sun . tools . javac . processing . AnnotationProcessingError ; public class T6412656 extends ToolTester { int count = 0 ; void test ( String ... args ) { task = tool . getTask ( null , fm , null , null , Collections . singleton ( T6412656 . class . getName ( ) ) , null ) ; task . setProcessors ( Collections . singleton ( new MyProc ( this ) ) ) ; task . call ( ) ; if ( count == 0 ) throw new AssertionError ( \"Annotation processor not run\" ) ; System . out . println ( \"OK\" ) ; } public static void main ( String ... args ) { new T6412656 ( ) . test ( args ) ; } @ SupportedAnnotationTypes ( \"*\" ) static class MyProc extends AbstractProcessor { T6412656 test ; MyProc ( T6412656 test ) { this", "gt": ". test = test ;", "prediction": ". test = test ;\n", "label": 0}
{"id": 15605, "input": "<s> package org . nuxeo . connect . download . tests ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class SlowDownloaderServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @ Override public void init ( ) throws ServletException { System . out . println ( \"Init slow downloader\" ) ; } @ Override protected void doGet ( HttpServletRequest req , HttpServletResponse", "gt": "resp ) throws ServletException , IOException", "prediction": "resp ) throws ServletException , IOException\n", "label": 1}
{"id": 4778, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; public enum HtmlTag { A ( BlockType . INLINE , EndTag . END ) , BLOCKQUOTE , BODY ( BlockType . OTHER , EndTag . END ) , BR ( BlockType . INLINE , EndTag . NOEND ) , CAPTION , CENTER , CODE ( BlockType . INLINE , EndTag . END ) , DD , DIV , DL , DT , EM ( BlockType . INLINE , EndTag . END ) , FONT ( BlockType . INLINE , EndTag . END ) , FRAME ( BlockType . OTHER , EndTag . NOEND ) , FRAMESET ( BlockType . OTHER , EndTag . END ) , H1 , H2 , H3 , H4 , H5 , H6 , HEAD ( BlockType . OTHER , EndTag . END ) , HR ( BlockType . BLOCK , EndTag . NOEND ) , HTML ( BlockType . OTHER , EndTag . END ) , I ( BlockType . INLINE , EndTag . END ) , IMG ( BlockType . INLINE , EndTag . NOEND ) , LI , LINK ( BlockType . OTHER , EndTag . NOEND ) , MENU , META ( BlockType . OTHER , EndTag . NOEND ) , NOFRAMES ( BlockType . OTHER , EndTag . END ) , NOSCRIPT ( BlockType . OTHER , EndTag . END ) , OL , P , PRE , SCRIPT ( BlockType . OTHER , EndTag . END ) , SMALL ( BlockType . INLINE , EndTag . END ) , SPAN ( BlockType . INLINE , EndTag . END ) , STRONG ( BlockType . INLINE , EndTag . END ) , TABLE , TBODY , TD , TH , TITLE ( BlockType . OTHER , EndTag . END ) , TR , TT (", "gt": "BlockType . INLINE , EndTag . END ) , UL ;", "prediction": "BlockType . INLINE , EndTag . END ) }\n", "label": 0}
{"id": 15610, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . ISaveablePart ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . IWorkbenchWindow ; public class SaveAsAction extends BaseSaveAction { public SaveAsAction ( IWorkbenchWindow window ) { super ( WorkbenchMessages . get ( ) . SaveAs_text , window ) ; setActionDefinitionId ( IWorkbenchCommandConstants . FILE_SAVE_AS ) ; setText ( WorkbenchMessages . get ( ) . SaveAs_text ) ; setToolTipText ( WorkbenchMessages . get ( ) . SaveAs_toolTip ) ; setId ( \"saveAs\" ) ; window . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IWorkbenchHelpContextIds . SAVE_AS_ACTION ) ; setImageDescriptor ( WorkbenchImages . getImageDescriptor ( ISharedImages", "gt": ". IMG_ETOOL_SAVEAS_EDIT ) ) ;", "prediction": ". IMG_SAVE_AS ) ) ;\n", "label": 1}
{"id": 5479, "input": "<s> package com . gisgraphy . client . gisfeature ; import org . joda . time . DateTime ; import org . junit . Assert ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . franceGisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . rambouilletAdm4GisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureType . geonamesFeatureClass ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import org . junit . Test ; import com . gisgraphy . client . gisfeature . GeonamesGisFeature ; import com . gisgraphy . client . gisfeature . GisFeatureGeography ; import com . gisgraphy . client . gisfeature . GisFeatureNames ; public class GeonamesGisFeatureTest { @ Test public void shouldCreateFranceGisFeature ( ) { GeonamesGisFeature france = GisFeatureObjectMother . franceGisFeature ( ) ; assertEquals ( france . getGeonamesFeatureClass ( ) , \"A\" ) ; assertEquals ( france . getGeonamesFeatureCode ( ) , \"PCLI\" ) ; assertEquals ( france . getGeonamesId ( ) . longValue ( ) , 3017382L ) ; assertEquals ( france . getNames ( ) . getName ( ) , \"France\" ) ; assertNotNull ( france . getGeography ( ) ) ; assertEquals ( france . getGeography ( ) . getLocation ( ) . getCoordinate ( ) . x , 2.0 , 0.0001 ) ; assertEquals ( france . getGeography ( ) . getLocation ( ) . getCoordinate ( ) . y , 46.0 , 0.0001 ) ; assertNotNull ( france . getLastModificationDate ( ) ) ; } @ Test public void shouldCreateGisFeature ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithModificationDate ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . lastModificationDate ( new DateTime ( ) ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithNullParentEntity ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . lastModificationDate ( new DateTime ( ) ) . parentAdministrativeEntity ( null ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithNullModificationDate ( ) { final GeonamesGisFeature gisFeature = GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . lastModificationDate", "gt": "( null ) . build ( ) ;", "prediction": "( new DateTime ( ) ) . build ( ) ;\n", "label": 0}
{"id": 15611, "input": "<s> package com . codeslap . persistence . pref ; import android . content . SharedPreferences ; import android . preference . * ; import android . text . InputType ; import android . widget . TextView ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class PersistencePreferenceActivity extends PreferenceActivity { private final Map < android . preference . Preference , String > mDependencies = new HashMap < android . preference . Preference , String > ( ) ; @ Override protected void onPostResume ( ) { super . onPostResume ( ) ; for ( android . preference . Preference preference : mDependencies . keySet ( ) ) { if ( preference . getDependency ( ) == null ) { preference . setDependency ( mDependencies . get ( preference ) ) ; } } } public void addPreferencesFrom ( Class < ? > ... classes ) { addPreferencesFrom ( null , classes ) ; } public void addPreferencesFrom ( PrefsFactory prefsFactory , Class < ? > ... classes ) { if ( getPreferenceScreen ( ) == null ) { PreferenceScreen preferenceScreen = getPreferenceManager ( ) . createPreferenceScreen ( this ) ; setPreferenceScreen ( preferenceScreen ) ; } Map < Integer , List < PrefMetadata > > fieldMap = new HashMap < Integer , List < PrefMetadata > > ( ) ; List < CategoryMetadata > categories = new ArrayList < CategoryMetadata > ( ) ; for ( Class < ? > theClass : classes ) { for ( Field field : theClass . getDeclaredFields ( ) ) { Preference annotation = field . getAnnotation ( Preference . class ) ; if ( annotation == null || annotation . ignore ( ) ) { continue ; } int title = annotation . title ( ) ; int summary = annotation . summary ( ) ; if ( title == 0 && summary == 0 ) { continue ; } Class < ? > type = field . getType ( ) ; if ( type != String . class && type != int . class && type != Integer . class && type != float . class && type != Float . class && type != double . class && type != Double . class && type != boolean . class && type != Boolean . class ) { continue ; } PrefMetadata prefMetaData = new PrefMetadata ( ) . setTitle ( title ) . setSummary ( summary ) . setOrder ( annotation . order ( ) ) . setType ( type ) . setDefaultValue ( annotation . defaultValue ( ) ) . setKey ( annotation . value ( ) ) . setDependency ( annotation . dependency ( ) ) . setEntries ( annotation . entries ( ) ) . setEntryValues ( annotation . entryValues ( ) ) . setDialogIcon ( annotation . dialogIcon ( ) ) . setDialogMessage ( annotation . dialogMessage ( ) ) . setDialogTitle ( annotation . dialogTitle ( ) ) ; if ( fieldMap . containsKey ( annotation . category ( ) ) ) { fieldMap . get ( annotation . category ( ) ) . add ( prefMetaData ) ; } else { ArrayList < PrefMetadata > list = new ArrayList < PrefMetadata > ( ) ; list . add ( prefMetaData ) ; fieldMap . put ( annotation . category ( ) , list ) ; categories . add ( new CategoryMetadata ( annotation . category ( ) , annotation . categoryOrder ( ) ) ) ; } } } Collections . sort ( categories , new Comparator < CategoryMetadata > ( ) { @ Override public int compare ( CategoryMetadata foo , CategoryMetadata bar ) { return foo . categoryOrder - bar . categoryOrder ; } } ) ; for ( CategoryMetadata category : categories ) { List < PrefMetadata > fields = fieldMap . get ( category . categoryTitle ) ; Collections . sort ( fields , new Comparator < PrefMetadata > ( ) { @ Override public int compare ( PrefMetadata foo , PrefMetadata bar ) { return foo . getOrder ( ) - bar . getOrder ( ) ; } } ) ; if ( category . categoryTitle != - 1 ) { PreferenceCategory preferenceCategory = new PreferenceCategory ( this ) ; preferenceCategory . setTitle ( category . categoryTitle ) ; getPreferenceScreen ( ) . addPreference ( preferenceCategory ) ; } addFieldsToHierarchy ( prefsFactory , fields ) ; } } private void addFieldsToHierarchy ( PrefsFactory prefsFactory , List < PrefMetadata > fields ) { for ( PrefMetadata metadata : fields ) { boolean hasDefault = ! \"\" . equals ( metadata . getDefaultValue ( ) ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; Class < ? > type = metadata . getType ( ) ; String key = metadata . getKey ( ) ; String defaultValue = metadata . getDefaultValue ( ) ; android . preference . Preference preference = null ; if ( prefsFactory != null ) { preference = prefsFactory . getPreference ( key ) ; } if ( preference == null ) { if ( type == boolean . class || type == Boolean . class ) { preference = new SmartCheckBoxPreference ( this ) ; boolean checked = prefs . getBoolean ( key , hasDefault ? Boolean . parseBoolean ( defaultValue ) : false ) ; ( ( CheckBoxPreference ) preference ) . setChecked ( checked ) ; } else if ( type == int . class || type == Integer . class || type == long . class || type == Long . class ) { if ( type == long . class || type == Long . class ) { long value = prefs . getLong ( key , hasDefault ? Long . parseLong ( defaultValue ) : 0L ) ; preference = new SmartEditTextPreference ( this , long . class , String . valueOf ( value ) ) ; ( ( EditTextPreference ) preference ) . setText ( String . valueOf ( value ) ) ; } else { int value = prefs . getInt ( key , hasDefault ? Integer . parseInt ( defaultValue ) : 0 ) ; preference = new SmartEditTextPreference ( this , int . class , String . valueOf ( value ) ) ; ( ( EditTextPreference ) preference ) . setText ( String . valueOf ( value ) ) ; } setEditTextType", "gt": "( preference , InputType . TYPE_CLASS_NUMBER ) ;", "prediction": "( preference ) ;\n", "label": 1}
{"id": 1530, "input": "<s> package fr . telecom . scrapbook . filters ; import java . util . List ; import fr . telecom . scrapbook . filters . ImageBlender . BlendMode ; public class RainBowFilter implements IImageFilter { public ImageBlender blender = new ImageBlender ( ) ; public boolean IsDoubleRainbow = false ; private GradientFilter gradientFx ; public float gradAngleDegree = 40f ; public RainBowFilter ( ) { blender . Mixture = 0.25f ; blender . Mode = BlendMode . Additive ; IsDoubleRainbow = true ; List < Integer > rainbowColors = Gradient . RainBow ( ) . MapColors ; if ( this . IsDoubleRainbow ) { rainbowColors . remove ( rainbowColors . size", "gt": "( ) - 1 ) ;", "prediction": "( ) - 1 ) ;\n", "label": 0}
{"id": 15612, "input": "<s> package org . restlet . test . ext . oauth ; import java . util . HashSet ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import org . restlet . ext . oauth . AuthenticatedUser ; import org . restlet . ext . oauth . internal . AuthenticatedUserImpl ; import org . restlet . ext . oauth . internal . ExpireToken ; import org . restlet . ext . oauth . internal . MemTokenGenerator ; import org . restlet . ext . oauth . internal . Token ; import org . restlet . ext . oauth . internal . TokenGenerator ; import org . restlet . ext . oauth . internal . UnlimitedToken ; import org . restlet . test . RestletTestCase ; public class TokenGeneratorTestCase extends RestletTestCase { public void testCodeGeneratorSequence ( ) throws Exception { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor ( 5 ) ; TokenGenerator generator = new MemTokenGenerator ( pool ) ; AuthenticatedUser user = new AuthenticatedUserImpl ( \"1234567890\" , null ) ; Set < String > codes = new HashSet < String > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { codes . add ( generator . generateCode ( user ) ) ; } assertEquals ( 100 , codes . size ( ) ) ; } public void testTokenGenerator ( ) throws Exception { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor ( 5 ) ; TokenGenerator generator = new MemTokenGenerator ( pool ) ; AuthenticatedUser user = new AuthenticatedUserImpl ( \"1234567890\" , null ) ; Token token = generator . generateToken ( user , Token . UNLIMITED ) ; assertEquals ( \"1234567890\" , token . getUser ( ) . getId ( ) ) ; assertTrue ( token instanceof UnlimitedToken ) ; } public void testTimeTokenGeneratorSequence ( ) throws Exception { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor ( 5 ) ; TokenGenerator generator = new MemTokenGenerator ( pool ) ;", "gt": "generator . setMaxTokenTime ( 10 ) ;", "prediction": "AuthenticatedUser user = new AuthenticatedUserImpl ( \"1234567890\" , null ) ;\n", "label": 1}
{"id": 6884, "input": "<s> package net . sourceforge . users . shafiul ; import android . app . Activity ; import android . content . Intent ; import android . os . Bundle ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . Button ; import android . widget . RadioGroup ; import android . widget . RadioGroup . OnCheckedChangeListener ; import android . widget . TextView ; public class OpenedClass extends Activity implements OnClickListener , OnCheckedChangeListener { TextView question , test ; Button returnData ; RadioGroup selectionList ; String gotBread , setData ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . send ) ; initialize ( ) ; } private void initialize ( ) { question = ( TextView ) findViewById ( R . id . tvQuestion ) ; test = ( TextView ) findViewById ( R . id . tvText ) ; returnData = ( Button", "gt": ") findViewById ( R . id . bReturn ) ;", "prediction": ") findViewById ( R . id . tvReturnData ) ;\n", "label": 0}
{"id": 15621, "input": "<s> package br . org . archimedes . gui . rca . editor ; import java . util . ArrayList ; import java . util . Collection ; import java . util . LinkedList ; import java . util . List ; import java . util . Observable ; import java . util . Observer ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseListener ; import org . eclipse . swt . events . MouseMoveListener ; import org . eclipse . swt . events . PaintEvent ; import org . eclipse . swt . events . PaintListener ; import org . eclipse . swt . graphics . Cursor ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . PaletteData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . opengl . GLCanvas ; import org . eclipse . swt . opengl . GLData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . part . EditorPart ; import org . lwjgl . LWJGLException ; import org . lwjgl . opengl . GLContext ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . NoActiveDrawingException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . model . MouseClickHandler ; import br . org . archimedes . gui . model . MouseMoveHandler ; import br . org . archimedes . gui . model . VisualHelper ; import br . org . archimedes . gui . model . Workspace ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . gui . rca . Activator ; import br . org . archimedes . gui . rca . InterpreterView ; import br . org . archimedes . model . Drawing ; public class DrawingEditor extends EditorPart implements Observer , ISelectionProvider { public static final String EDITOR_ID = \"br.org.archimedes.gui.rca.editor.DrawingEditor\" ;", "gt": "private static List < Cursor > cursors ;", "prediction": "public DrawingEditor ( )\n", "label": 1}
{"id": 7745, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . providers ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapDiagramEditorPlugin ; public class ElementInitializers { protected ElementInitializers ( ) { } public static ElementInitializers getInstance ( ) { ElementInitializers cached = SimplemapDiagramEditorPlugin . getInstance ( ) . getElementInitializers ( ) ; if ( cached == null ) { SimplemapDiagramEditorPlugin . getInstance ( )", "gt": ". setElementInitializers ( cached = new ElementInitializers ( ) ) ;", "prediction": ". setElementInitializers ( new SimplemapDiagramEditorPlugin ( ) ) ;\n", "label": 0}
{"id": 15624, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import org . eclipse . rap . rwt . internal . branding . BrandingManager ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointManager ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleAdapterFactory ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleFactory ; import org . eclipse . rap . rwt . internal . lifecycle . PhaseListenerRegistry ; import org . eclipse . rap . rwt . internal . resources . JSLibraryConcatenator ; import org . eclipse . rap . rwt . internal . resources . ResourceDirectory ; import org . eclipse . rap . rwt . internal . resources . ResourceRegistry ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . service . SettingStoreManager ; import org . eclipse . rap . rwt . internal . service . StartupPage ; import org . eclipse . rap . rwt . internal . textsize . ProbeStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorage ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . resources . IResourceManager ; import org . eclipse . rap . rwt . service . IApplicationStore ; import org . eclipse . swt . internal . graphics . FontDataFactory ; import org . eclipse . swt . internal . graphics . ImageDataFactory ; import org . eclipse . swt . internal . graphics . ImageFactory ; import org . eclipse . swt . internal . graphics . InternalImageFactory ; import org . eclipse . swt . internal . graphics . ResourceFactory ; import org . eclipse . swt . internal . widgets . DisplaysHolder ; public class RWTFactory { public static IApplicationStore getApplicationStore ( ) { return ApplicationContextUtil . getInstance ( ) . getApplicationStore ( ) ; } public static LifeCycleFactory getLifeCycleFactory ( ) { return ApplicationContextUtil . getInstance ( ) . getLifeCycleFactory ( ) ; } public static BrandingManager getBrandingManager ( ) { return ApplicationContextUtil . getInstance ( ) . getBrandingManager ( ) ; }", "gt": "public static EntryPointManager getEntryPointManager ( )", "prediction": "}\n", "label": 1}
{"id": 7157, "input": "<s> class Orphaned { void m ( ) { case 3 : System", "gt": ". out . println ( \"3\" ) ;", "prediction": ". out . println ( \"m\" ) ;\n", "label": 0}
{"id": 15628, "input": "<s> package org . fuzzydb . core . marker ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core .", "gt": "whirlwind . internal . IAttributeMap ;", "prediction": "whirlwind . internal . IAttributeConstraint ;\n", "label": 1}
{"id": 850, "input": "<s> package org . ofbiz . entity ; import java . util . concurrent . ConcurrentHashMap ; import org . ofbiz . base . lang . Factory ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilObject ; public abstract class DelegatorFactory implements Factory < Delegator , String > { public static final String module = DelegatorFactoryImpl . class . getName ( ) ; private static final ConcurrentHashMap < String , Delegator > delegatorCache = new ConcurrentHashMap < String , Delegator > ( ) ; public static Delegator getDelegator ( String delegatorName ) { if ( delegatorName == null ) { delegatorName = \"default\" ; } do { Delegator delegator = delegatorCache . get ( delegatorName ) ; if ( delegator != null ) { delegator . initEntityEcaHandler ( ) ; delegator . initDistributedCacheClear ( ) ; return delegator ; } try { delegator = UtilObject . getObjectFromFactory ( DelegatorFactory . class , delegatorName ) ; } catch ( ClassNotFoundException e ) { Debug . logError ( e , module ) ; } delegatorCache . putIfAbsent (", "gt": "delegatorName , delegator ) ;", "prediction": "delegatorName , delegator ) ;\n", "label": 0}
{"id": 15634, "input": "<s> package org . nuxeo . ecm . platform . mail . action ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . mail . Address ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Part ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeUtility ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; public class TransformMessageAction implements MessageAction { private static final Log log = LogFactory . getLog ( TransformMessageAction . class ) ; protected final Map < String , Map < String , Object > > schemas = new HashMap < String , Map < String , Object > > ( ) ; protected final Map < String , Object > mailSchema = new HashMap < String , Object > ( ) ; protected final Map < String , Object > dcSchema = new HashMap < String , Object > ( ) ; protected final Map < String , Object > filesSchema = new HashMap < String , Object > ( ) ; protected final List < Map < String , Object > > files = new ArrayList < Map < String , Object > > ( ) ; protected StringBuilder text = new StringBuilder ( ) ; private final HashMap < String , List < Part > > messageBodyParts = new HashMap < String , List < Part > > ( ) ; public TransformMessageAction ( ) { messageBodyParts . put ( \"text\" , new ArrayList < Part > ( ) ) ; messageBodyParts . put ( \"html\" , new ArrayList < Part > ( ) ) ; schemas . put ( \"mail\" , mailSchema ) ; schemas . put ( \"dublincore\" , dcSchema ) ; filesSchema . put ( \"files\" , files ) ; schemas . put ( \"files\" , filesSchema ) ; } public boolean execute ( ExecutionContext context ) throws Exception { Message message = context . getMessage ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Transforming message\" + message . getSubject ( ) ) ; } if ( message . getFrom ( ) != null && message . getFrom ( ) . length != 0 ) { List < String > contributors = new ArrayList < String > ( ) ; for ( Address ad : message . getFrom ( ) ) { contributors . add ( safelyDecodeText ( ad . toString ( ) ) ) ; } dcSchema . put ( \"contributors\" , contributors ) ; dcSchema . put ( \"creator\" , contributors . get ( 0 ) ) ; dcSchema . put ( \"created\" , message . getReceivedDate ( ) ) ; } if ( message . getAllRecipients ( ) != null && message . getAllRecipients ( ) . length != 0 ) { List < String > recipients = new ArrayList < String > ( ) ; for ( Address address : message . getAllRecipients ( ) ) { recipients . add ( safelyDecodeText ( address . toString ( ) ) ) ; } mailSchema . put ( \"recipients\" , recipients ) ; } if ( message instanceof MimeMessage ) { processMimeMessage ( ( MimeMessage ) message ) ; } mailSchema . put ( \"text\" , text . toString ( ) ) ; dcSchema . put ( \"title\" , message . getSubject ( ) ) ; context . put ( \"transformed\" , schemas ) ; return true ; } private void processMimeMessage ( MimeMessage message ) throws MessagingException , IOException { Object object = message . getContent ( ) ; if ( object instanceof String ) { addToTextMessage ( message . getContent ( ) . toString ( ) , true ) ; } else if ( object instanceof MimeMultipart ) { processMultipartMessage ( ( MimeMultipart ) object ) ; processSavedTextMessageBody ( ) ; } } private void processMultipartMessage ( MimeMultipart parts ) throws MessagingException , IOException { log . debug ( \"processing multipart message.\" ) ; for ( int i = 0 ; i < parts . getCount ( ) ; i ++ ) { Part part = parts . getBodyPart ( i ) ; if ( part . getDataHandler ( ) . getContent ( ) instanceof MimeMultipart ) { log . debug ( \"** found embedded multipart message\" ) ; processMultipartMessage ( ( MimeMultipart ) part . getDataHandler ( ) . getContent ( ) ) ; continue ; } log . debug ( \"processing single part message: \" + part . getClass ( ) ) ; processSingleMessagePart ( part ) ; } } private void processSingleMessagePart ( Part part ) throws MessagingException , IOException { String partContentType =", "gt": "part . getContentType ( ) ;", "prediction": "part . getContentType ( ) ;\n", "label": 1}
{"id": 9203, "input": "<s> class EASuper { static { EarlyAssert . foo ( ) ; } } public class EarlyAssert extends EASuper { static public void foo ( ) { boolean assertionStatus = false ; assert assertionStatus = true ; if ( ! assertionStatus ) { throw new Error ( \"Assertions are not enabled before initialization as they should be.\" ) ; } } public static void main ( String [ ] args ) { boolean assertionStatus = false ; assert assertionStatus = true ; if ( assertionStatus ) { throw new Error ( \"Assertions are", "gt": "not disabled after initialization as they should be.\" ) ;", "prediction": "not enabled before initialization as they should be.\" ) ;\n", "label": 0}
{"id": 15635, "input": "<s> package org . fuzzydb . postcode ; import java . io . UnsupportedEncodingException ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . dto . attributes . NonIndexStringAttribute ; import org . fuzzydb . dto . attributes . RandomGenerator ; import org . fuzzydb . util . MTRandom ; import org . slf4j . Logger ; public class RandomUKShortPostcode implements RandomGenerator < NonIndexStringAttribute > { private static Logger log = LogFactory . getLogger ( RandomUKShortPostcode . class ) ; public RandomUKShortPostcode ( ) { } @ Override public NonIndexStringAttribute next ( String attrName ) { return new NonIndexStringAttribute ( attrName , nextShortPostcode ( ) ) ; } public String nextShortPostcode ( ) { byte [ ] shortData = JibbleConvertor . getInstance ( ) . getPrefixData ( ) ; if ( shortData == null || shortData . length < 4 ) { throw new RuntimeException ( \"Random Postcodes short data did not load\" ) ; } int numCodes = shortData . length / 4 ; int index = 4 * MTRandom . getInstance ( ) . nextInt ( numCodes ) ; String result ; try { result = new String ( shortData , index , 4 , \"UTF8\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( \"Internal", "gt": "error: \" , e ) ;", "prediction": "error\" , e ) ;\n", "label": 1}
{"id": 3133, "input": "<s> package api . util ; public class Septuple < A , B , C , D , E , F , G > { private A a ; private B b ; private C c ; private D d ; private E e ; private F f ; private G g ; public Septuple ( A a , B b , C c , D d , E e , F f , G g ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; this . e = e ; this . f = f ; this . g = g ; } public A getA ( ) { return a ; } public B getB ( ) { return b ; } public C getC ( ) { return c ; } public D getD ( ) { return d ; } public void setA ( A a ) { this . a = a ; } public void setB ( B b ) { this . b = b ; } public void setC ( C c ) { this . c = c ; } public void setD ( D d ) { this . d = d ; } public E getE ( ) { return e ; } public void setE ( E e ) { this . e = e ; } public F getF ( ) { return f ; }", "gt": "public void setF ( F f )", "prediction": "public void setF ( F f )\n", "label": 0}
{"id": 15637, "input": "<s> package org . eclipse . ui . internal . commands ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . jface . bindings . BindingManager ; import org . eclipse . ui . commands . ExecutionException ; import org . eclipse . ui . commands . ICommand ; import org . eclipse . ui . commands . ICommandListener ; import org . eclipse . ui . commands . NotDefinedException ; import org . eclipse . ui . commands . NotHandledException ; final class CommandLegacyWrapper implements ICommand { private final BindingManager bindingManager ; private final Command command ; CommandLegacyWrapper ( final Command command , final BindingManager bindingManager ) { if ( command == null ) { throw new NullPointerException ( \"The wrapped command cannot be <code>null</code>.\" ) ; } if ( bindingManager == null ) { throw new NullPointerException ( \"A binding manager is required to wrap a command\" ) ; } this . command = command ; this . bindingManager = bindingManager ; } public final void addCommandListener ( final ICommandListener commandListener ) { command . addCommandListener ( new LegacyCommandListenerWrapper ( commandListener , bindingManager ) ) ; } public final Object execute ( Map parameterValuesByName ) throws ExecutionException , NotHandledException { try { return command . execute ( new ExecutionEvent ( command , ( parameterValuesByName == null ) ? Collections . EMPTY_MAP : parameterValuesByName , null , null ) ) ; } catch ( final org . eclipse . core . commands . ExecutionException e ) { throw new ExecutionException ( e ) ; } catch ( final org . eclipse . core . commands . NotHandledException e ) { throw new NotHandledException ( e ) ; } } public final Map getAttributeValuesByName ( ) { final Map attributeValues = new HashMap ( ) ; attributeValues . put ( ILegacyAttributeNames . ENABLED , command . isEnabled ( ) ? Boolean . TRUE : Boolean . FALSE ) ; attributeValues . put ( ILegacyAttributeNames . HANDLED , command . isHandled ( ) ? Boolean . TRUE : Boolean . FALSE ) ; return attributeValues ; } public final String getCategoryId ( ) throws NotDefinedException { try { return command . getCategory ( ) . getId ( ) ; } catch ( final org . eclipse . core .", "gt": "commands . common . NotDefinedException e )", "prediction": "commands . NotHandledException e )\n", "label": 1}
{"id": 2214, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import java . awt . * ; public class PgsCheckBoxMenuItemUI extends BasicCheckBoxMenuItemUI { public static ComponentUI createUI ( JComponent c ) { return new PgsCheckBoxMenuItemUI ( ) ; } protected void installDefaults ( ) { super . installDefaults ( ) ; } protected void paintBackground ( Graphics g , JMenuItem menuItem , Color bgColor ) { PgsUtils . paintMenuItemBackground ( g , menuItem , bgColor , getPropertyPrefix ( ) ) ; } protected void paintText ( Graphics g , JMenuItem c , Rectangle textRect , String text ) { PgsUtils . installAntialiasing ( g ) ; super .", "gt": "paintText ( g , c , textRect , text ) ;", "prediction": "paintBackground ( g , c , textRect , text ) ;\n", "label": 0}
{"id": 15638, "input": "<s> package org . eclipse . swt . graphics ; import org . eclipse . swt . * ; import org . eclipse . swt . internal . SerializableCompatibility ; @ SuppressWarnings ( \"all\" ) public final class PaletteData implements SerializableCompatibility { public boolean isDirect ; public RGB [ ] colors ; public int redMask ; public int greenMask ; public int blueMask ; public int redShift ; public int greenShift ; public int blueShift ; public PaletteData ( RGB [ ] colors ) { if ( colors == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; this . colors = colors ; this . isDirect = false ; } public PaletteData ( int redMask , int greenMask , int blueMask ) { this . redMask = redMask ; this . greenMask = greenMask ; this . blueMask = blueMask ; this . isDirect = true ; this . redShift = shiftForMask ( redMask ) ; this . greenShift = shiftForMask ( greenMask ) ; this . blueShift = shiftForMask ( blueMask ) ; } public int getPixel ( RGB rgb ) { if ( rgb == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( isDirect ) { int pixel = 0 ; pixel |= ( redShift < 0 ? rgb . red << - redShift : rgb . red > > > redShift ) & redMask ; pixel |= ( greenShift < 0 ? rgb . green << - greenShift : rgb . green > > > greenShift ) & greenMask ; pixel |= ( blueShift < 0 ? rgb . blue << - blueShift : rgb . blue > > > blueShift ) & blueMask ; return pixel ; } else { for ( int i = 0 ; i < colors . length ; i ++ ) { if ( colors [ i ] . equals ( rgb ) ) return i ; } SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; return 0 ; } } public RGB getRGB ( int pixel ) { if ( isDirect ) { int r = pixel & redMask ; r = ( redShift < 0 ) ? r > > > - redShift : r << redShift ; int g = pixel & greenMask ; g = ( greenShift < 0 ) ? g > > > - greenShift : g << greenShift ; int b = pixel & blueMask ; b = ( blueShift < 0 ) ? b > > > - blueShift : b << blueShift ; return new RGB ( r , g , b ) ; } else { if ( pixel < 0 || pixel >= colors . length ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } return colors [ pixel ] ; } }", "gt": "public RGB [ ] getRGBs ( )", "prediction": "}\n", "label": 1}
{"id": 9489, "input": "<s> package org . ofbiz . shipment . thirdparty . usps ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import javax . servlet . ServletConfig ; import javax . servlet . ServletException ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . xml . transform . TransformerException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class UspsMockApiServlet extends HttpServlet { public static final String module = UspsMockApiServlet . class . getName ( ) ; public UspsMockApiServlet ( ) { super ( ) ; } @ Override public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; } @ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doGet ( request , response ) ; } @ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { if ( ! \"Rate\" . equals ( request . getParameter ( \"API\" ) ) ) { Debug . logError ( \"Unsupported API [\" + request . getParameter ( \"API\" ) + \"]\" , module ) ; return ; } String xmlValue = request . getParameter ( \"XML\" ) ; Document requestDocument = null ; try { requestDocument = UtilXml . readXmlDocument ( xmlValue , false ) ; } catch ( Exception e ) { Debug . logError ( e , module ) ; return ; } if ( requestDocument == null ) { Debug . logError ( \"In UspsMockApiSerlvet No XML document found in request, quiting now; XML parameter is: \" + xmlValue , module ) ; return ; } List < ? extends Element > packageElementList = UtilXml . childElementList ( requestDocument . getDocumentElement ( ) , \"Package\" ) ; if ( UtilValidate . isNotEmpty ( packageElementList ) ) { Document responseDocument = UtilXml . makeEmptyXmlDocument ( \"RateResponse\" ) ; for ( Element packageElement : packageElementList ) { Element responsePackageElement = UtilXml . addChildElement ( responseDocument . getDocumentElement ( ) , \"Package\" , responseDocument ) ; responsePackageElement . setAttribute ( \"ID\" , packageElement . getAttribute ( \"ID\" ) ) ; UtilXml . addChildElementValue ( responsePackageElement , \"ZipOrigination\" , UtilXml . childElementValue ( packageElement , \"ZipOrigination\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"ZipDestination\" , UtilXml . childElementValue ( packageElement , \"ZipDestination\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Pounds\" , UtilXml . childElementValue ( packageElement , \"Pounds\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Ounces\" , UtilXml . childElementValue ( packageElement , \"Ounces\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Container\" , UtilXml . childElementValue ( packageElement , \"Container\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Size\" , UtilXml . childElementValue ( packageElement , \"Size\" ) , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Zone\" , \"1\" , responseDocument ) ; UtilXml . addChildElementValue ( responsePackageElement , \"Postage\" , \"3.00\" , responseDocument ) ; } OutputStream os = new ByteArrayOutputStream ( ) ; try { UtilXml . writeXmlDocument ( responseDocument , os , \"UTF-8\" , true , false , 0 ) ; } catch ( TransformerException e ) { Debug . logInfo (", "gt": "e , module ) ;", "prediction": "e , module ) ;\n", "label": 0}
{"id": 15639, "input": "<s> package org . eclipse . jface . dialogs ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; public class MessageDialogWithToggle extends MessageDialog { public static final String ALWAYS = \"always\" ; public static final String NEVER = \"never\" ; public static final String PROMPT = \"prompt\" ; public static MessageDialogWithToggle open ( int kind , Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key , int style ) { MessageDialogWithToggle dialog = new MessageDialogWithToggle ( parent , title , null , message , kind , getButtonLabels ( kind ) , 0 , toggleMessage , toggleState ) ; style &= SWT . SHEET ; dialog . setShellStyle ( dialog . getShellStyle ( ) | style ) ; dialog . prefStore = store ; dialog . prefKey = key ; dialog . open ( ) ; return dialog ; } public static MessageDialogWithToggle openError ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( ERROR , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openInformation ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( INFORMATION , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openOkCancelConfirm ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( CONFIRM , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openWarning ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( WARNING , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openYesNoCancelQuestion ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( QUESTION_WITH_CANCEL , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openYesNoQuestion ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( QUESTION , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } private String prefKey = null ; private IPreferenceStore prefStore = null ; private Button toggleButton = null ; private String toggleMessage ; private boolean toggleState ; public MessageDialogWithToggle ( Shell parentShell , String dialogTitle , Image image , String message , int dialogImageType , String [ ] dialogButtonLabels , int defaultIndex , String toggleMessage , boolean toggleState ) { super ( parentShell , dialogTitle , image , message , dialogImageType , dialogButtonLabels , defaultIndex ) ; this . toggleMessage = toggleMessage ; this . toggleState = toggleState ; setButtonLabels ( dialogButtonLabels ) ; } protected void buttonPressed ( int buttonId ) { super . buttonPressed ( buttonId ) ; if ( buttonId != IDialogConstants . CANCEL_ID && toggleState && prefStore != null && prefKey != null ) { switch ( buttonId ) { case IDialogConstants . YES_ID : case IDialogConstants . YES_TO_ALL_ID : case IDialogConstants . PROCEED_ID : case IDialogConstants . OK_ID : prefStore . setValue ( prefKey , ALWAYS ) ; break ; case IDialogConstants . NO_ID : case IDialogConstants . NO_TO_ALL_ID : prefStore . setValue ( prefKey , NEVER ) ; break ; } } } protected void createButtonsForButtonBar ( Composite parent ) { final String [ ] buttonLabels = getButtonLabels ( ) ; final Button [ ] buttons = new Button [ buttonLabels . length ] ; final int defaultButtonIndex = getDefaultButtonIndex ( ) ; int suggestedId = IDialogConstants . INTERNAL_ID ; for ( int i = 0 ; i < buttonLabels . length ; i ++ ) { String label = buttonLabels [ i ] ; int id = mapButtonLabelToButtonID ( label , suggestedId ) ; if ( id == suggestedId ) { suggestedId ++ ; } Button button = createButton ( parent , id , label , defaultButtonIndex == i ) ; buttons [", "gt": "i ] = button ;", "prediction": "i ] = button ;\n", "label": 1}
{"id": 6518, "input": "<s> package org . ofbiz . service . engine ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . List ; import java . util . Map ; import javolution . util . FastMap ; import org . apache . xmlrpc . XmlRpcException ; import org . apache . xmlrpc . client . XmlRpcClientConfigImpl ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelParam ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . config . ServiceConfigUtil ; import org . ofbiz . service . xmlrpc . XmlRpcClient ; public class XMLRPCClientEngine extends GenericAsyncEngine { public static final String module = XMLRPCClientEngine . class . getName ( ) ; public XMLRPCClientEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } @ Override public void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { runSync ( localName , modelService , context ) ; } @ Override public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { Map < String , Object > result = serviceInvoker ( modelService , context ) ; if ( result == null ) throw new GenericServiceException ( \"Service did not return expected result\" ) ; return result ; } private Map < String , Object > serviceInvoker ( ModelService modelService , Map < String , Object > context ) throws GenericServiceException { if ( modelService . location == null || modelService . invoke == null ) throw new GenericServiceException ( \"Cannot locate service to invoke\" ) ; XmlRpcClientConfigImpl config = null ; XmlRpcClient client = null ; String serviceName = modelService . invoke ; String engine = modelService . engineName ; String url = null ; String login = null ; String password = null ; String keyStoreComponent = null ; String keyStoreName = null ; String keyAlias = null ; try { url = ServiceConfigUtil . getEngineParameter ( engine , \"url\" ) ; login = ServiceConfigUtil . getEngineParameter ( engine , \"login\" ) ; password = ServiceConfigUtil . getEngineParameter ( engine , \"password\" ) ; keyStoreComponent = ServiceConfigUtil . getEngineParameter ( engine , \"keyStoreComponent\" ) ; keyStoreName = ServiceConfigUtil . getEngineParameter ( engine , \"keyStoreName\" ) ; keyAlias = ServiceConfigUtil . getEngineParameter ( engine , \"keyAlias\" ) ; config = new XmlRpcClientConfigImpl ( ) ; config . setBasicUserName ( login ) ; config . setBasicPassword ( password ) ; config . setServerURL ( new URL ( url ) ) ; } catch ( MalformedURLException e ) { throw new GenericServiceException ( \"Cannot invoke service : engine parameters are not correct\" ) ; } catch ( GenericConfigException e ) { throw new GenericServiceException ( \"Cannot invoke service : engine parameters are not correct\" ) ; } if ( UtilValidate . isNotEmpty ( keyStoreComponent ) && UtilValidate . isNotEmpty ( keyStoreName ) && UtilValidate . isNotEmpty ( keyAlias ) ) { client = new XmlRpcClient ( config , keyStoreComponent , keyStoreName , keyAlias ) ; } else { client = new XmlRpcClient ( config ) ; } List < ModelParam > inModelParamList = modelService . getInModelParamList ( ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"[XMLRPCClientEngine.invoke] : Parameter length - \" + inModelParamList . size ( ) , module ) ; for ( ModelParam p : inModelParamList ) { Debug . logVerbose ( \"[XMLRPCClientEngine.invoke} : Parameter: \" + p . name + \" (\" + p . mode + \")\" , module ) ; } } Map < String , Object > result = null ; Map < String , Object > params = FastMap . newInstance ( ) ; for ( ModelParam modelParam : modelService . getModelParamList ( ) ) { if ( \"OUT\" . equals ( modelParam . mode ) || modelParam . internal ) continue ; Object paramValue = context . get ( modelParam . name ) ; if ( paramValue != null ) { params . put ( modelParam . name , paramValue ) ; } } List < Map < String , Object > > listParams = UtilMisc . toList ( params ) ; try { result = UtilGenerics . cast ( client . execute ( serviceName , listParams . toArray ( ) ) ) ; } catch ( XmlRpcException e ) { result = ServiceUtil .", "gt": "returnError ( e . getLocalizedMessage ( ) ) ;", "prediction": "getErrorResult ( e ) ;\n", "label": 0}
{"id": 15643, "input": "<s> package org . nuxeo . webengine . sites . models ; import org . nuxeo . theme . models . AbstractModel ; public class SearchModel extends AbstractModel { private String name ; private String description ; private String path ; private String author ; private String created ; private String modified ; public SearchModel ( String name , String description , String path , String author , String created , String modified ) { this . name = name ; this . description = description ; this . path = path ; this . author = author ; this . created = created ; this . modified = modified ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public void", "gt": "setDescription ( String description )", "prediction": "setDescription ( String description )\n", "label": 1}
{"id": 677, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . Location ; import org . bukkit . World ; public interface LizaWorld extends World { List < LizaEntity > getLizaEntities ( ) ; List < LizaEntity > getLizaEntitiesWithinRadius ( Location center , double radius ) ; List < LizaEntity >", "gt": "getLizaEntitiesWithinBox ( Location corner1 , Location corner2 ) ;", "prediction": "getLizaEntitiesWithinCenter ( Location center , double radius ) ;\n", "label": 0}
{"id": 15648, "input": "<s> package org . nuxeo . ecm . automation . core . operations ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; @ Operation ( id = LogOperation . ID , category = Constants . CAT_NOTIFICATION , label = \"Log\" , description = \"Logging with log4j\" ) public class LogOperation { public static final String ID = \"LogOperation\" ; @ Param ( name = \"category\" , required = false ) protected String category ; @ Param ( name = \"message\" , required = true ) protected String message ; @ Param ( name = \"level\" , required = true , widget = Constants . W_OPTION , values = { \"info\" , \"debug\" , \"warn\" , \"error\" } ) protected String level = \"info\" ; @ OperationMethod public void run ( ) { if ( category == null ) { category = \"org.nuxeo.ecm.automation.logger\" ; }", "gt": "Log log = LogFactory . getLog ( category ) ;", "prediction": "if ( message == null )\n", "label": 1}
{"id": 5998, "input": "<s> public class TestLinkToSerialForm extends JavadocTester { private static final String BUG_ID = \"4521661\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"serialized-form.html\" , \"<a name=\\\"pkg.C\\\">\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<a href=\\\"../serialized-form.html#pkg.C\\\">\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; public static void main ( String [ ] args ) { TestLinkToSerialForm tester = new TestLinkToSerialForm ( ) ; run", "gt": "( tester , ARGS , TEST , NEGATED_TEST ) ;", "prediction": "Tests ( tester , args ) ;\n", "label": 0}
{"id": 15651, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec4 . sub3 ; import org . restlet . Application ; import org . restlet . Server ; import org . restlet . data . Protocol ; import org . restlet . example . book . restlet . ch01 . HelloServerResource ; public class RangeServer { public static void main ( String [ ] args ) throws Exception { Application app = new Application ( ) ; app . setInboundRoot ( HelloServerResource . class ) ; new Server ( Protocol . HTTP , 8111 , app", "gt": ") . start ( ) ;", "prediction": ") . start ( ) ;\n", "label": 1}
{"id": 1215, "input": "<s> package com . sun . javadoc ; public interface WildcardType extends Type { Type [ ] extendsBounds ( ) ; Type", "gt": "[ ] superBounds ( ) ;", "prediction": "[ ] superBounds ;\n", "label": 0}
{"id": 15652, "input": "<s> package org . nuxeo . ecm . platform . localconfiguration . simple . operations ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . operations . document . FetchDocument ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . test . CoreFeature ; import org . nuxeo . ecm . core . test . annotations . BackendType ; import org . nuxeo . ecm . core . test . annotations . Granularity ; import org . nuxeo . ecm . core . test . annotations . RepositoryConfig ; import org . nuxeo . ecm . platform . localconfiguration . simple . AbstractSimpleConfigurationTest ; import org . nuxeo . ecm . platform . localconfiguration . simple . LocalConfigurationRepositoryInit ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import com . google . inject . Inject ; @ RunWith ( FeaturesRunner . class ) @ Features ( CoreFeature . class ) @ RepositoryConfig ( type = BackendType . H2 , init = LocalConfigurationRepositoryInit . class , user = \"Administrator\" , cleanup = Granularity . METHOD ) @ Deploy ( { \"org.nuxeo.ecm.automation.core\" , \"org.nuxeo.ecm.platform.localconfiguration.simple\" } ) public class TestSimpleConfigurationSetOperations extends AbstractSimpleConfigurationTest { @ Inject AutomationService service ; @ Test public void shouldSetContextVariableFromSimpleConfiguration ( ) throws Exception { DocumentModel workspace = session . getDocument ( PARENT_WORKSPACE_REF ) ; Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( \"key1\" , \"value1\" ) ; parameters . put ( \"key2\" , \"value2\" ) ; initializeSimpleConfiguration ( workspace , parameters ) ; OperationContext ctx = new OperationContext ( session ) ; assertNotNull ( ctx ) ; OperationChain chain = new OperationChain ( \"testSimpleConfigurationChain\" ) ; chain . add ( FetchDocument . ID ) . set ( \"value\" , PARENT_WORKSPACE_REF ) ; chain . add ( SetSimpleConfigurationParameterAsVar . ID ) . set ( \"name\" , \"simpleConfigurationParameter\" ) . set", "gt": "( \"parameterName\" , \"key2\" ) ;", "prediction": "( \"parameters\" , parameters ) ;\n", "label": 1}
{"id": 6852, "input": "<s> package LizaCraft ; import java . lang . reflect . Field ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import net . minecraft . server . MinecraftServer ; import net . minecraft . server . ThreadServerApplication ; import org . bukkit . craftbukkit . CraftServer ; import org . bukkit . event . Event ; import org . bukkit . plugin . Plugin ; import org . bukkit . plugin . PluginDescriptionFile ; import org . bukkit . plugin . PluginLoader ; import org . bukkit . plugin . PluginManager ; import org . bukkit . plugin . SimplePluginManager ; import org . bukkit . plugin . java . JavaPlugin ; import Liza . LizaServer ; import LizaCraft . Events . LizaPlugin ; public class LizaCraftTestModule { private static final String MINECRAFT_SERVER_THREAD_NAME = \"Server thread\" ; private static final String MINECRAFT_SERVER_FIELD_NAME = \"a\" ; private static final String PLUGIN_MANAGER_LIST_NAME = \"plugins\" ; private static final String PLUGIN_MANAGER_FILE_ASSOCIATION_MAP = \"fileAssociations\" ; private static final String PLUGIN_ENABLED_FIELD_NAME = \"isEnabled\" ; private static final String PLUGIN_SERVER_FIELD_NAME = \"server\" ; private static final String PLUGIN_LOADER_FIELD_NAME = \"loader\" ; private static final String PLUGIN_DESCRIPTION_FIELD_NAME = \"description\" ; private static final String PLUGIN_LOOKUP_FIELD_NAME = \"lookupNames\" ; private static final String PLUGIN_EXTENSION = \".jar\" ; private LizaServerThread serverThread ; private LizaServer server ; private LizaPlugin eventListener ; private String name ; private boolean waiting = false ; private Event waitingOn ; public LizaCraftTestModule ( String name ) { this . name = name ; this . eventListener = new LizaPlugin ( ) ; } public String getName ( ) { return this . name ; } public void disableEvents ( ) { } @ SuppressWarnings ( \"unchecked\" ) public void enableEvents ( ) { Class < ? extends PluginManager > pluginManager = ( ( SimplePluginManager ) this . server . getPluginManager ( ) ) . getClass ( ) ; Field f ; PluginLoader pluginLoader = null ; try { f = pluginManager . getDeclaredField ( PLUGIN_MANAGER_FILE_ASSOCIATION_MAP ) ; f . setAccessible ( true ) ; Map < Pattern , PluginLoader > fileAssociations = ( ( HashMap ) f . get ( this . server . getPluginManager ( ) ) ) ; for ( Pattern p : fileAssociations . keySet ( ) ) { Matcher match = p . matcher ( PLUGIN_EXTENSION ) ; if ( match . find ( ) ) { pluginLoader = fileAssociations . get ( p ) ; } } f . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } PluginDescriptionFile desc = new PluginDescriptionFile ( LizaPlugin . PLUGIN_NAME , null , null ) ; Class < ? extends JavaPlugin > plugin = this . eventListener . getClass ( ) ; try { f = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_ENABLED_FIELD_NAME ) ; f . setAccessible ( true ) ; f . set ( this . eventListener , true ) ; f . setAccessible ( false ) ; f = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_LOADER_FIELD_NAME ) ; f . setAccessible ( true ) ; f . set ( this . eventListener , pluginLoader ) ; f . setAccessible ( false ) ; f = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_SERVER_FIELD_NAME ) ; f . setAccessible ( true ) ; f . set ( this . eventListener , this . server ) ; f . setAccessible ( false ) ; f = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_DESCRIPTION_FIELD_NAME ) ; f . setAccessible ( true ) ; f . set ( this . eventListener , desc ) ; f . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } List < Plugin > plugins ; try { f = pluginManager . getDeclaredField ( PLUGIN_MANAGER_LIST_NAME ) ; f . setAccessible ( true ) ; plugins = ( List < Plugin > ) f . get ( this . server . getPluginManager ( ) ) ; plugins . add ( this . eventListener ) ; f . set ( this . server . getPluginManager ( ) , plugins ) ; f . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Map < String , Plugin > lookupNames ; try { f = pluginManager . getDeclaredField ( PLUGIN_LOOKUP_FIELD_NAME ) ; f . setAccessible ( true ) ; lookupNames = ( HashMap < String , Plugin > ) f . get ( this . server . getPluginManager ( ) ) ; lookupNames . put ( LizaPlugin . PLUGIN_NAME , this . eventListener ) ; f . set ( this . server . getPluginManager ( ) , lookupNames ) ; f . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } this . eventListener . onEnable ( ) ; } public LizaServer getServer ( ) { CraftServer cs = null ; try { while ( cs == null ) { cs = searchThreads ( ) ; } } catch ( Exception e ) { return getServer ( ) ; } this . server = new LizaCraftServer ( cs ) ; return ( LizaServer ) this . server ; } private CraftServer searchThreads ( ) { ThreadGroup rootGroup = Thread . currentThread ( ) . getThreadGroup ( ) ; while ( rootGroup . getParent ( ) != null ) { rootGroup = rootGroup . getParent ( ) ; } Thread threads [ ] = new Thread [ rootGroup . activeCount ( ) ] ; while ( rootGroup . enumerate ( threads , true ) >= threads . length ) { threads = new Thread [ threads . length * 2 ] ; } ThreadServerApplication tsa = null ; for ( Thread t : threads ) { if ( t != null && t . getName ( ) != null && t . getName ( ) . equals ( MINECRAFT_SERVER_THREAD_NAME ) ) { tsa = ( ThreadServerApplication ) t ; break ; } } Class < ? extends ThreadServerApplication > c = tsa . getClass ( ) ; Field f ; MinecraftServer ms = null ; try { f = c .", "gt": "getDeclaredField ( MINECRAFT_SERVER_FIELD_NAME ) ;", "prediction": "getDeclaredField ( MINECRAFT_SERVER_THREAD_NAME ) ;\n", "label": 0}
{"id": 15654, "input": "<s> package nehsics . math ; public class Average { private double a ; private int n ; public void add ( double x ) { n ++ ; a -= a / n - x / n ; }", "gt": "public double getAvg ( )", "prediction": "public double get ( double x )\n", "label": 1}
{"id": 8875, "input": "<s> import java . util . * ; class T6294779b { interface I1 < E > { List < E > m ( ) ; } interface I2 < E > { Queue < E > m ( ) ; } interface I3 < E > { LinkedList < E > m ( ) ; } interface I4 < E > extends I1 < E", "gt": "> , I2 < E > , I3 < E >", "prediction": ">\n", "label": 0}
{"id": 15661, "input": "<s> package org . restlet . ext . oauth . internal ; import java . util . List ; import java . util . concurrent . ConcurrentMap ; import java . util . logging . Level ; import org . restlet . data . Form ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . ext . oauth . AuthenticatedUser ; import org . restlet . ext . oauth . Client ; import org . restlet . ext . oauth . OAuthError ; import org . restlet . ext . oauth . HttpOAuthHelper ; import org . restlet . ext . oauth . OAuthServerResource ; import org . restlet . ext . oauth . ResponseType ; import org . restlet . representation . Representation ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . routing . Redirector ; import org . restlet . security . Role ; @ Deprecated public class AuthorizationServerResourceOld extends OAuthServerResource { public static final String ID = \"id\" ; public static final String OPENID = \"openid\" ; @ Get ( \"html\" ) @ Post ( \"html\" ) public Representation represent ( ) { Form params = getQuery ( ) ; String sessionId = getCookies ( ) . getFirstValue ( ClientCookieID ) ; getLogger ( ) . fine ( \"sessionId = \" + sessionId ) ; ConcurrentMap < String , Object > attribs = getContext ( ) . getAttributes ( ) ; AuthSession session = ( sessionId == null ) ? null : ( AuthSession ) attribs . get ( sessionId ) ; String id = ( String ) getContext ( ) . getAttributes ( ) . get ( ID ) ; getLogger ( ) . fine ( \"id = \" + id ) ; getLogger ( ) . fine ( \"session = \" + session ) ; if ( session != null ) getLogger ( ) . fine ( \"client = \" + session . getClient ( ) ) ; else { getCookieSettings ( ) . removeAll ( ClientCookieID ) ; } if ( id != null && session != null && session . getClient ( ) != null ) { getLogger ( ) . fine ( \"After Authentication - cleanup\" ) ; params . removeFirst ( OPENID ) ; Client client = ( Client ) session . getClient ( ) ; getLogger ( ) . fine", "gt": "( \"Found client = \" + client ) ;", "prediction": "( \"Client = \" + client ) ;\n", "label": 1}
{"id": 1021, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . ClassWriter ; import org . objectweb . asm . MethodVisitor ; import org . objectweb . asm . Type ; import static org . objectweb . asm . Opcodes . * ; class ActionClassGenerator extends GroupClassGenerator { public ActionClassGenerator ( boolean forceCodeBuilding ) { super ( forceCodeBuilding ) ; } public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( method , \"method\" ) ; return method . containsExplicitActions ( ) ; } @ Override protected boolean appliesTo ( InstructionGraphNode node ) { return node . isActionRoot ( ) ; } @", "gt": "Override protected Type getBaseType ( )", "prediction": "SuppressWarnings ( \"unchecked\" ) @ Override public < T > T getAdapter ( Class < T > adapter )\n", "label": 0}
{"id": 15662, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . Attribute ; import org . fuzzydb . attrs . util . Point2D ; import org . fuzzydb . attrs . util . Range2D ; public abstract class RangePreference2D extends Attribute implements IRange2D { public Point2D getMax ( ) { return range2d . getMax ( ) ; } public Point2D getMin ( ) { return range2d . getMin ( ) ; } public RangePreference2D ( int attrId", "gt": ", Point2D min , Point2D max )", "prediction": ")\n", "label": 1}
{"id": 5940, "input": "<s> package com . sun . tools . javah ; import java . io . PrintWriter ; public class Main { public static void main ( String [ ] args ) { JavahTask t = new JavahTask ( ) ; int rc = t . run ( args ) ; System", "gt": ". exit ( rc ) ;", "prediction": ". out . println ( rc ) ;\n", "label": 0}
{"id": 15663, "input": "<s> package org . nuxeo . ecm . core . rest ; import java . util . List ; import javax . ws . rs . GET ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . audit . api . LogEntry ; import org . nuxeo . ecm . platform . audit . api . Logs ; import org . nuxeo . ecm . platform . audit . api . NXAuditEvents ; import org . nuxeo . ecm . webengine . WebException ; import org . nuxeo . ecm . webengine . model . View ; import org . nuxeo . ecm . webengine . model . WebAdapter ; import org . nuxeo . ecm . webengine . model . impl . DefaultAdapter ; import org . nuxeo . runtime . api . Framework ; @ WebAdapter ( name = \"audits\" , type = \"AuditService\" , targetType = \"Document\" ) public class AuditService extends DefaultAdapter { protected NXAuditEvents guardedService ( ) { NXAuditEvents service ; try { service = Framework . getService ( NXAuditEvents . class ) ; } catch ( Exception e ) { throw WebException . wrap ( \"Failed to get audit service\" , e ) ; } if ( service == null ) { throw new WebException ( \"Failed to get audit service\" ) ; } return service ; } @ GET public Object doGet ( ) { return new View ( getTarget ( ) , \"audits\" ) . resolve ( ) ; } public List < LogEntry > getAudits ( ) { Logs logs = guardedService ( ) ; DocumentObject document = ( DocumentObject", "gt": ") getTarget ( ) ;", "prediction": ") logs . getAdapter ( DocumentObject . class ) ;\n", "label": 1}
{"id": 7085, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . ToolTip ; public class ToolTipImpl extends ColumnAttributeImpl implements ToolTip { protected LogicalExpression expression ; protected static final String TIP_EDEFAULT = null ; protected String tip = TIP_EDEFAULT ; protected ToolTipImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getToolTip ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . TOOL_TIP__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . TOOL_TIP__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . TOOL_TIP__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TOOL_TIP__EXPRESSION , newExpression , newExpression ) ) ; } public String getTip ( ) { return tip ; } public void setTip ( String newTip ) { String oldTip = tip ; tip = newTip ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TOOL_TIP__TIP , oldTip , tip ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . TOOL_TIP__EXPRESSION : return basicSetExpression ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . TOOL_TIP__EXPRESSION : return getExpression ( ) ; case ProjectPackage . TOOL_TIP__TIP : return getTip ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . TOOL_TIP__EXPRESSION : setExpression ( ( LogicalExpression ) newValue ) ; return ; case ProjectPackage . TOOL_TIP__TIP : setTip ( ( String ) newValue ) ; return ; } super . eSet (", "gt": "featureID , newValue ) ;", "prediction": "featureID , newValue ) ;\n", "label": 0}
{"id": 15667, "input": "<s> package org . nuxeo . ecm . platform . publisher . task ; import org . nuxeo . ecm . core . api . * ; import org . nuxeo . ecm . core . api . security . ACL ; import org . nuxeo . ecm . core . api . security . ACP ; import org . nuxeo . ecm . core . api . security . SecurityConstants ; import org . nuxeo . ecm . core . api . security . UserEntry ; import org . nuxeo . ecm . core . api . security . impl . UserEntryImpl ; import java . util . ArrayList ; import java . util . List ; public class ChangePermissionUnrestricted extends UnrestrictedSessionRunner { private final DocumentModel document ; private final NuxeoPrincipal principal ; private final String aclName ; private final String [ ] validators ; private final ACL existingACL ; public ChangePermissionUnrestricted ( CoreSession session , DocumentModel document , String [ ] validators , NuxeoPrincipal principal , String aclName , ACL acl ) { super ( session ) ; this . document = document ; this . validators = validators ; this . principal = principal ; this . aclName = aclName ; this . existingACL = acl ; } @ Override public void run ( ) throws ClientException { List < UserEntry >", "gt": "userEntries = new ArrayList < UserEntry > ( ) ;", "prediction": "userEntries = new ArrayList < UserEntry > ( ) ;\n", "label": 1}
{"id": 5717, "input": "<s> package org . openengsb . connector . github . internal ; public class Object extends APIAbstract { public Object ( GitHubAPI a ) { super ( a ) ; } public Response tree ( String owner , String repositoryName , String sha ) { return httpGet ( \"https://github.com/api/v2/json/tree/show/\" + encode ( owner ) + \"/\" + encode ( repositoryName ) + \"/\" + encode ( sha ) ) ; } public Response blob ( String owner , String repositoryName , String treeSha , String path ) { return httpGet ( \"https://github.com/api/v2/json/blob/show/\" + encode ( owner ) + \"/\" + encode ( repositoryName ) + \"/\" + encode ( treeSha ) + \"/\" +", "gt": "encode ( path ) ) ;", "prediction": "encode ( path ) ) ;\n", "label": 0}
{"id": 15669, "input": "<s> package org . restlet . ext . webdav ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . restlet . engine . Method ; import org . restlet . service . MetadataService ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD )", "gt": "@ Method ( \"LOCK\" ) public @ interface Lock", "prediction": "@ Produces (\n", "label": 1}
{"id": 9377, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . util . * ; import org . xbill . DNS . utils . * ; public class TSIGRecord extends Record { private static final long serialVersionUID = - 88820909016649306L ; private Name alg ; private Date timeSigned ; private int fudge ; private byte [ ] signature ; private int originalID ; private int error ; private byte [ ] other ; TSIGRecord ( ) { } Record getObject ( ) { return new TSIGRecord ( ) ; } public TSIGRecord ( Name name , int dclass , long ttl , Name alg , Date timeSigned , int fudge , byte [ ] signature , int originalID , int error , byte other [ ] ) { super ( name , Type . TSIG , dclass , ttl ) ; this . alg = checkName ( \"alg\" , alg ) ; this . timeSigned = timeSigned ; this . fudge = checkU16 ( \"fudge\" , fudge ) ; this . signature = signature ; this . originalID = checkU16 ( \"originalID\" , originalID ) ; this . error = checkU16 ( \"error\" , error ) ; this . other = other ; } void rrFromWire ( DNSInput in ) throws IOException { alg = new Name ( in ) ; long timeHigh = in . readU16 ( ) ; long timeLow = in . readU32 ( ) ; long time = ( timeHigh << 32 ) + timeLow ; timeSigned = new Date ( time * 1000 ) ; fudge = in . readU16 ( ) ; int sigLen = in . readU16 ( ) ; signature = in . readByteArray ( sigLen ) ; originalID = in . readU16 ( ) ; error = in . readU16 ( ) ; int otherLen = in . readU16 ( ) ; if ( otherLen > 0 ) other = in . readByteArray ( otherLen ) ; else other = null ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { throw st . exception ( \"no text format defined for TSIG\" ) ; } String rrToString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( alg ) ; sb . append ( \" \" ) ; if ( Options . check ( \"multiline\" ) ) sb . append ( \"(\\n\\t\" ) ; sb . append ( timeSigned . getTime ( ) / 1000 ) ; sb . append ( \" \" ) ; sb . append ( fudge ) ; sb . append ( \" \" ) ; sb . append ( signature . length ) ; if ( Options . check ( \"multiline\" ) ) { sb . append ( \"\\n\" ) ; sb . append ( base64 . formatString ( signature , 64 , \"\\t\" , false ) ) ; } else { sb . append ( \" \" ) ; sb . append ( base64 . toString ( signature ) ) ; } sb . append ( \" \" ) ; sb . append ( Rcode . TSIGstring ( error ) ) ; sb . append ( \" \" ) ; if ( other == null ) sb . append ( 0 ) ; else { sb . append ( other . length ) ; if ( Options . check ( \"multiline\" ) ) sb . append ( \"\\n\\n\\n\\t\" ) ; else sb . append ( \" \" ) ; if ( error == Rcode . BADTIME ) { if ( other", "gt": ". length != 6 )", "prediction": "Len > 0 )\n", "label": 0}
{"id": 15671, "input": "<s> package org . eclipse . rap . demo . controls ; import java . util . Iterator ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Spinner ; import org . eclipse . swt . widgets . Text ; public class CTabFolderTab extends ExampleTab { protected static final int MAX_ITEMS = 3 ; private static final String PROP_CONTEXT_MENU = \"contextMenu\" ; private static final String CTAB_IMAGE_PATH = \"resources/newfolder_wiz.gif\" ; private Image ctabImage ; private CTabFolder folder ; private boolean showClose ; private boolean unselectedCloseVisible ; private boolean setImage ; private boolean unselectedImageVisible ; private boolean showTopRightControl ; private boolean minVisible ; private boolean maxVisible ; private int selFgIndex ; private int selBgIndex ; private int tabHeight = - 1 ; private boolean showSelectionBgGradient = false ; private boolean showSelectionBgImage = false ; private boolean customFontOnItem ; private static Font customFont = Graphics . getFont ( \"Courier\" , 12 , SWT . ITALIC ) ; private Button [ ] tabRadios ; public CTabFolderTab ( ) { super ( \"CTabFolder\" ) ; } @ Override protected void createStyleControls ( Composite parent ) { createStyleButton ( \"FLAT\" , SWT . FLAT ) ; createStyleButton ( \"BORDER\" , SWT . BORDER ) ; createStyleButton ( \"TOP\" , SWT . TOP ) ; createStyleButton ( \"BOTTOM\" , SWT . BOTTOM ) ; createStyleButton ( \"CLOSE\" , SWT . CLOSE ) ; createStyleButton ( \"SINGLE\" , SWT . SINGLE ) ; createStyleButton ( \"MULTI\" , SWT . MULTI ) ; createVisibilityButton ( ) ; createEnablementButton ( ) ; createFontChooser ( ) ; createFgColorButton ( ) ; createBgColorButton ( ) ; createSelectionFgColorButton ( ) ; createSelectionBgColorButton ( ) ; createSelectionBgGradientButton ( ) ; createSelectionBgImageButton ( ) ; createBgImageButton ( ) ; createTabHeightControl ( styleComp ) ; createTopRightControl ( styleComp ) ; final Button cbMin = createPropertyButton ( \"Minimize visible\" , SWT . CHECK ) ; cbMin . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { minVisible = cbMin . getSelection ( ) ; updateProperties ( ) ; } } ) ; final Button cbMax = createPropertyButton ( \"Maximize visible\" , SWT . CHECK ) ; cbMax . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { maxVisible = cbMax . getSelection ( ) ; updateProperties ( ) ; } } ) ; tabRadios = new Button [ MAX_ITEMS ] ; for ( int i = 0 ; i < MAX_ITEMS ; i ++ ) { final int index = i ; String rbText = \"Select \" + folder . getItem ( index ) . getText ( ) ; tabRadios [ i ] = createPropertyButton ( rbText , SWT . RADIO ) ; tabRadios [ i ] . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Button radio = ( Button ) event . getSource ( ) ; if ( radio . getSelection ( ) ) { folder . setSelection ( index ) ; } } } ) ; } tabRadios [ 0 ] . setSelection ( true ) ; String text = \"Set Image\" ; Button cbSetImage = createPropertyButton ( text , SWT . CHECK ) ; cbSetImage . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Button button = ( Button ) event . widget ; setImage = button . getSelection ( ) ; updateProperties ( ) ; } } ) ; text = \"UnselectedImageVisible\" ; Button cbUnselectedImageVisible = createPropertyButton ( text , SWT . CHECK ) ; cbUnselectedImageVisible . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Button button = ( Button ) event . widget ; unselectedImageVisible = button . getSelection ( ) ; updateProperties ( ) ; } } ) ; text = \"UnselectedCloseVisible\" ; Button cbUnselectedCloseVisible = createPropertyButton ( text , SWT . CHECK ) ; cbUnselectedCloseVisible . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Button button = ( Button ) event . widget ; unselectedCloseVisible = button . getSelection ( ) ; updateProperties ( ) ; } } ) ; text = \"showClose on Tab 2\" ; Button cbShowClose = createPropertyButton ( text , SWT . CHECK ) ; cbShowClose . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Button button = ( Button ) event . widget ; showClose = button . getSelection ( ) ; updateProperties ( ) ; } } ) ; text = \"Custom font on Tab 2\" ; Button cbCustomFont = createPropertyButton ( text , SWT . CHECK ) ; cbCustomFont", "gt": ". addSelectionListener ( new SelectionAdapter ( )", "prediction": ". addSelectionListener ( new SelectionAdapter ( )\n", "label": 1}
{"id": 6736, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . entities . Entity ; public class AbstractPiePlot extends AbstractPlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private Boolean circular = null ; private String labelFormat = null ; private String legendLabelFormat = null ; public Boolean getCircular ( ) { return circular ; } public void setCircular ( Boolean circular ) {", "gt": "this . circular = circular ;", "prediction": "this . circular = circular ;\n", "label": 0}
{"id": 15674, "input": "<s> package org . eclipse . ui . forms ; import java . util . Vector ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . forms . widgets . FormToolkit ; import org . eclipse . ui . forms . widgets . ScrolledForm ; public class ManagedForm implements IManagedForm { private Object input ; private ScrolledForm form ; private FormToolkit toolkit ; private Object container ; private boolean ownsToolkit ; private boolean initialized ; private Vector parts = new Vector ( ) ; public ManagedForm ( Composite parent ) { toolkit = new FormToolkit ( parent . getDisplay ( ) ) ; ownsToolkit = true ; form = toolkit . createScrolledForm ( parent ) ; } public ManagedForm ( FormToolkit toolkit , ScrolledForm form ) { this . form = form ; this . toolkit = toolkit ; } public void addPart ( IFormPart part ) { parts . add ( part ) ; part . initialize ( this ) ; } public void removePart ( IFormPart part ) { parts . remove ( part ) ; } public IFormPart [ ] getParts ( ) { return ( IFormPart [ ] ) parts . toArray ( new IFormPart [ parts . size ( ) ] ) ; } public FormToolkit getToolkit ( ) { return toolkit ; } public ScrolledForm getForm ( ) { return form ; } public void reflow ( boolean changed ) { form . reflow ( changed ) ; } public void fireSelectionChanged ( IFormPart part , ISelection selection ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart cpart = ( IFormPart ) parts . get ( i ) ; if ( part . equals ( cpart ) ) continue ; if ( cpart instanceof IPartSelectionListener ) { ( ( IPartSelectionListener ) cpart ) . selectionChanged ( part , selection ) ; } } } public void initialize ( ) { if ( initialized ) return ; for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; part . initialize ( this ) ; } initialized = true ; } public void dispose ( ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; part . dispose ( ) ; } if ( ownsToolkit ) { toolkit . dispose ( ) ; } } public void refresh ( ) { Thread t = Thread . currentThread ( ) ; Thread dt = toolkit . getColors ( ) . getDisplay ( ) . getThread ( ) ; if ( t . equals ( dt ) ) doRefresh ( ) ; else { toolkit . getColors ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { doRefresh ( ) ; } } ) ; } } private void doRefresh ( ) { int nrefreshed = 0 ; for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isStale ( ) ) { part . refresh ( ) ; nrefreshed ++ ; } } if ( nrefreshed > 0 ) form . reflow ( true ) ; } public void commit ( boolean onSave ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isDirty ( ) ) part . commit ( onSave ) ; } } public boolean setInput ( Object input ) { boolean pageResult = false ; this . input = input ; for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; boolean result = part . setFormInput ( input ) ; if ( result ) pageResult = true ; } return pageResult ; } public Object getInput ( ) { return input ; } public void setFocus ( ) { if ( parts . size ( ) > 0 ) { IFormPart part = ( IFormPart ) parts . get ( 0 ) ; part . setFocus ( ) ; } } public boolean isDirty ( ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isDirty ( ) ) return true ; } return false ; } public boolean isStale ( ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isStale ( ) ) return true ; } return false ; } public void dirtyStateChanged ( ) { } public void staleStateChanged ( ) { } public Object getContainer ( ) { return container ; } public", "gt": "void setContainer ( Object container )", "prediction": "void dispose ( )\n", "label": 1}
{"id": 936, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; import java . util . * ; public class ClassTree { private List < ClassDoc > baseclasses = new ArrayList < ClassDoc > ( ) ; private Map < ClassDoc , List < ClassDoc > > subclasses = new HashMap < ClassDoc , List < ClassDoc > > ( ) ; private List < ClassDoc > baseinterfaces = new ArrayList < ClassDoc > ( ) ; private Map < ClassDoc , List < ClassDoc > > subinterfaces = new HashMap < ClassDoc , List < ClassDoc > > ( ) ; private List < ClassDoc > baseEnums = new ArrayList < ClassDoc > ( ) ; private Map < ClassDoc , List < ClassDoc > > subEnums = new HashMap < ClassDoc , List < ClassDoc > > ( ) ; private List < ClassDoc > baseAnnotationTypes = new ArrayList < ClassDoc > ( ) ; private Map < ClassDoc , List < ClassDoc > > subAnnotationTypes = new HashMap < ClassDoc , List < ClassDoc > > ( ) ; private Map < ClassDoc , List < ClassDoc > > implementingclasses = new HashMap < ClassDoc , List < ClassDoc > > ( ) ; public ClassTree ( Configuration configuration , boolean noDeprecated ) { configuration . message . notice ( \"doclet.Building_Tree\" ) ; buildTree ( configuration . root . classes ( ) , configuration ) ; } public ClassTree ( RootDoc root , Configuration configuration ) { buildTree ( root . classes ( ) , configuration ) ; } public ClassTree ( ClassDoc [ ] classes , Configuration configuration ) { buildTree ( classes , configuration ) ; } private void buildTree ( ClassDoc [ ] classes , Configuration configuration ) { for ( int i = 0 ; i < classes . length ; i ++ ) { if ( configuration . nodeprecated && ( Util . isDeprecated ( classes [ i ] ) || Util . isDeprecated ( classes [ i ] . containingPackage ( ) ) ) ) { continue ; } if ( classes [ i ] . isEnum ( ) ) { processType ( classes [ i ] , configuration , baseEnums , subEnums ) ; } else if ( classes [ i ] . isClass ( ) ) { processType ( classes [ i ] , configuration , baseclasses , subclasses ) ; } else if ( classes [ i ] . isInterface ( ) ) { processInterface ( classes [ i ] ) ; List < ClassDoc > list = implementingclasses . get ( classes [ i ] ) ; if ( list != null ) { Collections . sort ( list ) ; } } else if ( classes [ i ] . isAnnotationType ( ) ) { processType ( classes [ i ] , configuration , baseAnnotationTypes , subAnnotationTypes ) ; } } Collections . sort ( baseinterfaces ) ; for ( Iterator < List < ClassDoc > > it = subinterfaces . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Collections . sort ( it . next ( ) ) ; } for ( Iterator < List < ClassDoc > > it = subclasses . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Collections . sort ( it . next ( ) ) ; } } private void processType ( ClassDoc cd , Configuration configuration , List < ClassDoc > bases , Map < ClassDoc , List < ClassDoc > > subs ) { ClassDoc superclass = Util . getFirstVisibleSuperClassCD ( cd , configuration ) ; if ( superclass != null ) { if ( ! add ( subs , superclass , cd ) ) { return ; } else { processType ( superclass , configuration , bases , subs ) ; } } else { if ( ! bases . contains ( cd ) ) { bases . add ( cd ) ; } } List < Type > intfacs = Util . getAllInterfaces ( cd , configuration ) ; for ( Iterator < Type > iter = intfacs . iterator ( ) ; iter . hasNext ( ) ; ) { add ( implementingclasses , iter . next ( ) . asClassDoc ( ) , cd ) ; } } private void processInterface ( ClassDoc cd ) { ClassDoc [ ] intfacs = cd . interfaces ( ) ; if ( intfacs . length > 0 ) { for ( int i = 0 ; i < intfacs . length ; i ++ ) { if ( ! add ( subinterfaces , intfacs [ i ] , cd ) ) { return ; } else { processInterface ( intfacs", "gt": "[ i ] ) ;", "prediction": "[ i ] , subinterfaces , cd ) ;\n", "label": 0}
{"id": 15678, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . sense . SenseData ; import org . jscsi . target . scsi . sense . SenseKey ; import org . jscsi . target . scsi . sense . senseDataDescriptor . CommandSpecificSenseDataDescriptor ; import org . jscsi . target . util . BitManip ; import org . jscsi . target . util . ReadWrite ; public class SegmentPointerSenseKeySpecificData extends SenseKeySpecificData { private final boolean segmentDescriptor ; private final boolean bitPointerValid ; private final short fieldPointer ; private final int bitPointer ; public SegmentPointerSenseKeySpecificData ( final boolean senseKeySpecificDataValid , final boolean segmentDescriptor , final boolean bitPointerValid , final int bitPointer , final int fieldPointer ) { super ( senseKeySpecificDataValid ) ; this . segmentDescriptor = segmentDescriptor ; this . bitPointerValid = bitPointerValid ; this . bitPointer = bitPointer ; this", "gt": ". fieldPointer = ( short ) fieldPointer ;", "prediction": ". fieldPointer = fieldPointer ;\n", "label": 1}
{"id": 4136, "input": "<s> package org . ofbiz . sql ; public final class KeyMap { private final String leftFieldName ; private final String rightFieldName ; public KeyMap ( String leftFieldName , String rightFieldName ) { this . leftFieldName = leftFieldName ; this . rightFieldName = rightFieldName ; } public String getLeftFieldName ( ) { return leftFieldName ; } public String getRightFieldName ( ) { return rightFieldName ; } @ Override public boolean equals ( Object o ) { if ( o instanceof KeyMap ) { KeyMap other = ( KeyMap ) o ; return leftFieldName . equals ( other . leftFieldName ) && rightFieldName .", "gt": "equals ( other . rightFieldName ) ;", "prediction": "equals ( other . rightFieldName ) ;\n", "label": 0}
{"id": 15679, "input": "<s> package org . eclipse . jface . viewers ; public interface IBasicPropertyConstants { public static final String P_TEXT = \"org.eclipse.jface.text\" ; public static final", "gt": "String P_IMAGE = \"org.eclipse.jface.image\" ;", "prediction": "String P_PROPERTIES = \"org.eclipse.jface.properties\" ;\n", "label": 1}
{"id": 7954, "input": "<s> package javax . tools ; import java . io . * ; import java . net . URI ; import java . nio . CharBuffer ; import javax . lang . model . element . Modifier ; import javax . lang . model . element . NestingKind ; import javax . tools . JavaFileObject . Kind ; public class SimpleJavaFileObject implements JavaFileObject { protected final URI uri ; protected final Kind kind ; protected SimpleJavaFileObject ( URI uri , Kind kind ) { uri . getClass ( ) ; kind . getClass ( ) ; if ( uri . getPath ( ) == null ) throw new IllegalArgumentException ( \"URI must have a path: \" + uri ) ; this . uri = uri ; this . kind = kind ; } public URI toUri ( ) { return uri ; } public String getName ( ) { return toUri ( ) . getPath ( ) ; } public InputStream openInputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public OutputStream openOutputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Reader openReader ( boolean ignoreEncodingErrors ) throws IOException { CharSequence charContent = getCharContent ( ignoreEncodingErrors ) ; if ( charContent == null ) throw new UnsupportedOperationException ( ) ; if ( charContent instanceof CharBuffer ) { CharBuffer buffer = ( CharBuffer ) charContent ; if ( buffer . hasArray ( ) ) return new CharArrayReader ( buffer . array ( ) ) ; } return new StringReader ( charContent . toString ( ) ) ; } public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Writer openWriter ( ) throws IOException { return new OutputStreamWriter ( openOutputStream ( ) ) ; } public long getLastModified ( ) { return 0L ; } public boolean delete ( ) { return false ; } public Kind getKind ( ) { return kind ; } public boolean isNameCompatible ( String simpleName , Kind kind ) { String baseName = simpleName + kind . extension ; return kind . equals ( getKind ( ) ) && ( baseName . equals ( toUri ( ) . getPath ( ) ) || toUri ( ) . getPath ( ) . endsWith ( \"/\" + baseName ) ) ; } public NestingKind getNestingKind ( ) { return null ; } public Modifier getAccessLevel ( ) { return null ; }", "gt": "@ Override public String toString ( )", "prediction": "public Modifier getModifier ( )\n", "label": 0}
{"id": 15686, "input": "<s> package org . eclipse . jface . tests . fieldassist ; import org . eclipse . jface . fieldassist . ControlDecoration ; import org . eclipse . jface . fieldassist . FieldDecorationRegistry ; import org . eclipse . swt . SWT ; public abstract class FieldAssistTestCase extends AbstractFieldAssistTestCase { static final String SAMPLE_CONTENT = \"s\" ; static final char ACTIVATE_CHAR = 'i' ; static final char EXTRA_CHAR = 'b' ; public void testDecorationIsVisible ( ) { AbstractFieldAssistWindow window = getFieldAssistWindow ( ) ; window . setPropagateKeys ( false ) ; window . setAutoActivationCharacters ( new char [ ] { ACTIVATE_CHAR } ) ; window . open ( ) ; assertOneShellUp ( ) ; ControlDecoration decoration = new ControlDecoration ( getFieldAssistWindow ( ) . getFieldAssistControl ( ) , SWT . RIGHT ) ; decoration . setImage ( FieldDecorationRegistry . getDefault ( ) . getFieldDecoration ( FieldDecorationRegistry . DEC_INFORMATION ) . getImage ( ) ) ; decoration . setDescriptionText ( \"foo\" ) ; spinEventLoop ( ) ; assertTrue ( \"1.0\" , decoration . isVisible ( ) ) ; decoration . hide ( ) ; assertFalse ( \"1.1\" , decoration . isVisible ( ) ) ; decoration . setShowOnlyOnFocus ( true ) ; sendFocusElsewhere ( ) ; sendFocusInToControl ( ) ; spinEventLoop ( ) ; assertFalse ( \"1.2\" , decoration . isVisible ( ) ) ; decoration . show ( ) ; assertTrue ( \"1.3\" , decoration", "gt": ". isVisible ( ) ) ;", "prediction": ". isVisible ( ) ) ;\n", "label": 1}
{"id": 6275, "input": "<s> package com . sun . tools . doclets . internal . toolkit . taglets ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . javadoc . * ; public abstract class TagletWriter { protected boolean isFirstSentence = false ; public abstract TagletOutput getOutputInstance ( ) ; protected abstract TagletOutput getDocRootOutput ( ) ; protected abstract TagletOutput deprecatedTagOutput ( Doc doc ) ; protected abstract MessageRetriever getMsgRetriever ( ) ; protected abstract TagletOutput getParamHeader ( String header ) ; protected abstract TagletOutput paramTagOutput ( ParamTag paramTag , String paramName ) ; protected abstract TagletOutput returnTagOutput ( Tag returnTag ) ; protected abstract TagletOutput seeTagOutput ( Doc holder , SeeTag [ ] seeTags ) ; protected abstract TagletOutput simpleTagOutput ( Tag [ ] simpleTags , String header ) ; protected abstract TagletOutput simpleTagOutput ( Tag simpleTag , String header ) ; protected abstract TagletOutput getThrowsHeader ( ) ; protected abstract TagletOutput throwsTagOutput ( ThrowsTag throwsTag ) ; protected abstract TagletOutput throwsTagOutput ( Type throwsType ) ; protected abstract TagletOutput valueTagOutput ( FieldDoc field , String constantVal , boolean includeLink ) ; public static void genTagOuput ( TagletManager tagletManager , Doc doc , Taglet [ ] taglets , TagletWriter writer , TagletOutput output ) { tagletManager . checkTags ( doc , doc . tags ( ) , false ) ; tagletManager . checkTags ( doc , doc . inlineTags ( ) , true ) ; TagletOutput currentOutput = null ; for ( int i = 0 ; i < taglets . length ; i ++ ) { if ( doc instanceof ClassDoc && taglets [ i ] instanceof ParamTaglet ) { continue ; } if ( taglets [ i ] instanceof DeprecatedTaglet ) { continue ; } try { currentOutput = taglets [ i ] .", "gt": "getTagletOutput ( doc , writer ) ;", "prediction": "getOutput ( ) ;\n", "label": 0}
{"id": 15692, "input": "<s> package br . org . archimedes . intersectors ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . util . Collection ; import java . util . Collections ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Point ; public class LineLineIntersectorTest extends Tester { @ Test public void simpleLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( - 1 , 3 , 10 , 3 ) ; Point p0 = new Point ( 3 , 3 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertCollectionTheSame ( Collections . singleton ( p0 ) , intersections ) ; } @ Test public void paralelsLinesIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void sameLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void subLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 3 , 3 , 10 , 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void interLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 10 , 10 , 15 , 15 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void noLineIntersectionWouldIfOneExtended ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 4 , 3 , 3 , - 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void noLineIntersectionWouldIfTwoExtended ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 0 , 0 , 3 , - 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue (", "gt": "intersections . isEmpty ( ) ) ;", "prediction": "intersections . isEmpty ( ) ) ;\n", "label": 1}
{"id": 8050, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . ArrayList ; import java . util . List ; import com . mobeelizer . mobile . android . api . MobeelizerCriterion ; import com . mobeelizer . mobile . android . api . MobeelizerDisjunction ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerDisjunctionRestritionImpl implements MobeelizerInternalCriterion , MobeelizerDisjunction { private final List < MobeelizerCriterion > criterions = new ArrayList < MobeelizerCriterion > ( ) ; @ Override public MobeelizerDisjunction add ( final MobeelizerCriterion criterion ) { criterions . add ( criterion ) ; return this ; } @ Override public String addToQuery ( final List < String >", "gt": "selectionArgs , final MobeelizerAndroidModel model )", "prediction": "query )\n", "label": 0}
{"id": 15694, "input": "<s> package org . eclipse . ui . tests . dialogs ; import java . util . Iterator ; import junit . framework . TestCase ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . help . WorkbenchHelp ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . tests . harness . util . DialogCheck ; public class UIPreferencesAuto extends TestCase { public UIPreferencesAuto ( String name ) { super ( name ) ; } protected Shell getShell ( ) { return DialogCheck . getShell ( ) ; } private PreferenceDialog getPreferenceDialog ( String id ) { PreferenceDialogWrapper dialog = null ; PreferenceManager manager = WorkbenchPlugin . getDefault ( ) . getPreferenceManager ( ) ; if ( manager != null ) { dialog = new PreferenceDialogWrapper ( getShell ( ) , manager ) ; dialog . create ( ) ; WorkbenchHelp . setHelp ( dialog . getShell ( ) , IWorkbenchHelpContextIds . PREFERENCE_DIALOG ) ; for ( Iterator iterator = manager . getElements ( PreferenceManager . PRE_ORDER ) . iterator ( ) ; iterator . hasNext ( ) ; ) { IPreferenceNode node = ( IPreferenceNode ) iterator . next ( ) ; if ( node . getId ( ) . equals ( id ) ) { dialog . showPage ( node ) ; break ; } } } return dialog ; } public void testWorkbenchPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.Workbench\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testAppearancePref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.Views\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testDefaultTextEditorPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.TextEditor\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testFileEditorsPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.FileEditors\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testLocalHistoryPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.FileStates\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testPerspectivesPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.Perspectives\" ) ; DialogCheck . assertDialogTexts", "gt": "( dialog , this ) ;", "prediction": "( dialog , this ) ;\n", "label": 1}
{"id": 5949, "input": "<s> public class SwitchScope { public static void main ( String [ ] args ) { switch ( args . length ) { case 0 : final int k ; k = 12 ; class Local {", "gt": "int j = k ;", "prediction": "}\n", "label": 0}
{"id": 15705, "input": "<s> package org . eclipse . ui . part ; import java . util . Arrays ; import java . util . List ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . WorkbenchImages ; import org . eclipse . ui . internal . WorkbenchMessages ; public class DrillDownAdapter implements ISelectionChangedListener { private TreeViewer fChildTree ; private DrillStack fDrillStack ; private Action homeAction ; private Action backAction ; private Action forwardAction ; public DrillDownAdapter ( TreeViewer tree ) { fDrillStack = new DrillStack ( ) ; fChildTree = tree ; } public void addNavigationActions ( IMenuManager manager ) { createActions ( ) ; manager . add ( homeAction ) ; manager . add ( backAction ) ; manager . add ( forwardAction ) ; updateNavigationButtons ( ) ; } public void addNavigationActions ( IToolBarManager toolBar ) { createActions ( ) ; toolBar . add ( homeAction ) ; toolBar . add ( backAction ) ; toolBar . add ( forwardAction ) ; updateNavigationButtons ( ) ; } public boolean canExpand ( Object element ) { return fChildTree . isExpandable ( element ) ; } public boolean canGoBack ( ) { return fDrillStack . canGoBack ( ) ; } public boolean canGoHome ( ) { return fDrillStack . canGoHome ( ) ; } public boolean canGoInto ( ) { IStructuredSelection oSelection = ( IStructuredSelection ) fChildTree . getSelection ( ) ; if ( oSelection == null || oSelection . size ( ) != 1 ) { return false ; } Object anElement = oSelection . getFirstElement ( ) ; return canExpand ( anElement ) ; } private void createActions ( ) { if ( homeAction != null ) { return ; } homeAction = new Action ( WorkbenchMessages . get ( ) . GoHome_text ) { public void run ( ) { goHome ( ) ; } } ; homeAction . setToolTipText ( WorkbenchMessages . get ( ) . GoHome_toolTip ) ; homeAction . setImageDescriptor ( WorkbenchImages . getImageDescriptor ( ISharedImages . IMG_ETOOL_HOME_NAV ) ) ; ISharedImages images = PlatformUI . getWorkbench ( ) . getSharedImages ( ) ; backAction = new Action ( WorkbenchMessages . get ( ) . GoBack_text ) { public void run ( ) { goBack ( ) ; } } ; backAction . setToolTipText ( WorkbenchMessages . get ( ) . GoBack_toolTip ) ; backAction . setImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_BACK ) ) ; backAction . setDisabledImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_BACK_DISABLED ) ) ; forwardAction = new Action ( WorkbenchMessages . get ( ) . GoInto_text ) { public void run ( ) { goInto ( ) ; } } ; forwardAction . setToolTipText ( WorkbenchMessages . get ( ) . GoInto_toolTip ) ; forwardAction . setImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_FORWARD ) ) ; forwardAction . setDisabledImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_FORWARD_DISABLED ) ) ; fChildTree . addSelectionChangedListener ( this ) ; updateNavigationButtons ( ) ; } private void expand ( List items ) { fChildTree . setExpandedElements ( items . toArray ( ) ) ; } private List getExpanded ( ) { return Arrays . asList ( fChildTree . getExpandedElements ( ) ) ; } public void goBack ( ) { Object currentInput = fChildTree . getInput ( ) ; DrillFrame oFrame = fDrillStack . goBack ( ) ; Object input = oFrame . getElement ( ) ; fChildTree . setInput ( input ) ; expand ( oFrame . getExpansion ( ) ) ; if ( fChildTree . getSelection ( ) . isEmpty ( ) ) { fChildTree . setSelection ( new StructuredSelection ( currentInput ) , true ) ; } updateNavigationButtons ( ) ; } public void goHome ( ) { Object currentInput = fChildTree . getInput ( ) ; DrillFrame oFrame = fDrillStack . goHome ( ) ; Object input = oFrame . getElement ( ) ; fChildTree . setInput ( input ) ; expand ( oFrame . getExpansion ( ) ) ; if ( fChildTree . getSelection ( ) . isEmpty ( ) ) { fChildTree . setSelection ( new StructuredSelection ( currentInput ) , true ) ; } updateNavigationButtons ( ) ; } public void goInto ( ) { IStructuredSelection sel = ( IStructuredSelection ) fChildTree . getSelection ( ) ; Object element = sel . getFirstElement ( ) ; goInto ( element ) ; } public void goInto ( Object newInput ) { if ( canExpand ( newInput ) ) { Object oldInput = fChildTree . getInput ( ) ; List expandedList = getExpanded ( ) ; fDrillStack . add ( new DrillFrame ( oldInput , \"null\"", "gt": ", expandedList ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 4233, "input": "<s> package org . gk . engine . client . build . portal ; import java . util . Iterator ; import java . util . List ; import org . gk . engine . client . build . XComponent ; import org . gk . engine . client . gen . UIGen ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . custom . Portal ; import com . extjs . gxt . ui . client . widget . custom . Portlet ; import com . google . gwt . xml . client . Node ; public class XPortal extends XComponent { protected String columnWidth ; public XPortal ( Node node , List < XPortlet > widgets ) { super ( node , widgets ) ; columnWidth = super . getAttribute ( \"columnWidth\" , \".33,.33,.33\" ) ; } public String getColumnWidth ( ) { return columnWidth ; } @ Override public Component build ( ) { String [ ] colWidth = columnWidth . split ( \",\" ) ; Portal portal = new Portal ( colWidth . length ) ; super . initComponent ( portal ) ; for ( int i = 0 ; i < colWidth . length ; i ++ ) { portal . setColumnWidth ( i , Double . parseDouble ( colWidth", "gt": "[ i ] ) ) ;", "prediction": "[ i ] ) ) ;\n", "label": 0}
{"id": 15706, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . widgets . Item ; public class ItemTextProperty extends WidgetStringValueProperty { String doGetStringValue ( Object source ) { return ( ( Item ) source ) . getText ( ) ; } void doSetStringValue ( Object", "gt": "source , String value )", "prediction": "source , String value )\n", "label": 1}
{"id": 8654, "input": "<s> package rare10 ; class A { class B { Object t ; } static class C { { B b = null ;", "gt": "b . t = \"foo\" ;", "prediction": "}\n", "label": 0}
{"id": 15708, "input": "<s> package org . apache . lucene . store . db ; import com . sleepycat . db . EnvironmentConfig ; import com . sleepycat . db . Environment ; public class SanityLoadLibrary { public static void main ( String [ ] ignored ) throws Exception { EnvironmentConfig envConfig = EnvironmentConfig . DEFAULT ; envConfig . setAllowCreate ( false ) ; Environment env =", "gt": "new Environment ( null , envConfig ) ;", "prediction": "new Environment ( envConfig ) ;\n", "label": 1}
{"id": 8994, "input": "<s> package org . bombusim . xmpp . handlers ; import java . io . IOException ; import org . bombusim . xmpp . XmppError ; import org . bombusim . xmpp . XmppObject ; import org . bombusim . xmpp . XmppObjectListener ; import org . bombusim . xmpp . XmppStream ; import org . bombusim . xmpp . exception . XmppException ; import org . bombusim . xmpp . stanza . Iq ; public class IqFallback extends XmppObjectListener { @ Override public int blockArrived ( XmppObject data , XmppStream stream ) throws IOException , XmppException { try { Iq f = ( Iq ) data ; String from = f . getAttribute ( \"from\" ) ; String type = f . getTypeAttribute ( ) ; if ( type . equals ( \"result\" ) ) { return BLOCK_REJECTED ; } if ( type . equals ( \"error\" ) ) { return BLOCK_REJECTED ; } XmppError err = new XmppError ( XmppError .", "gt": "FEATURE_NOT_IMPLEMENTED , null ) ;", "prediction": "ERROR_INVALID_ARGUMENT ) ;\n", "label": 0}
{"id": 15709, "input": "<s> package org . jscsi . target . settings . entry ; import org . jscsi . target . TargetServer ; import org . jscsi . target . settings . BooleanResultFunction ; import org . jscsi . target . settings . KeySet ; import org . jscsi . target . settings . NegotiationStatus ; import org . jscsi . target . settings . NegotiationType ; import org . jscsi . target . settings . TextParameter ; public final class BooleanEntry extends Entry { private final boolean negotiationValue ; private final BooleanResultFunction resultFunction ; public BooleanEntry ( final KeySet keySet , final Use use , final NegotiationStatus negotiationStatus , final boolean negotiationValue , final BooleanResultFunction resultFunction , final Boolean defaultValue ) { super ( keySet , NegotiationType . NEGOTIATED , use , negotiationStatus , defaultValue ) ; this . negotiationValue = negotiationValue ; this . resultFunction = resultFunction ; } @ Override protected Object parseOffer ( TargetServer target , final String values ) { return TextParameter . parseBooleanValue ( values ) ; } @ Override protected boolean inProtocolValueRange ( final Object values ) { if ( values instanceof Boolean ) return true ; return false ; } @ Override protected void processDeclaration ( final Object values ) { } @ Override protected String processNegotiation ( final Object values ) { final boolean request = ( Boolean ) values ; final boolean result = resultFunction . getResult ( request , negotiationValue ) ; value = result ; return TextParameter . booleanToTextValue ( result ) ; } @ Override public Boolean getBooleanValue ( ) { return ( Boolean ) value ; } @ Override public Entry copy ( ) { final BooleanEntry e = new BooleanEntry ( keySet , use , negotiationStatus , negotiationValue , resultFunction , ( Boolean ) value ) ; e . alreadyNegotiated", "gt": "= this . alreadyNegotiated ;", "prediction": "= alreadyNegotiated ;\n", "label": 1}
{"id": 4980, "input": "<s> package Liza ; import org . bukkit . entity . Weather ;", "gt": "public interface LizaWeather extends Weather", "prediction": "import org . bukkit . entity . City ;\n", "label": 0}
{"id": 15714, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; class BufferScrolledCompositeOriginsVisitor extends AllWidgetTreeVisitor { public boolean doVisit ( Widget widget ) { if ( widget instanceof ScrolledComposite ) { bufferOrigin ( ( ScrolledComposite ) widget ) ; bufferContentSize ( ( ScrolledComposite ) widget ) ; } return true ; } private void bufferOrigin ( ScrolledComposite composite ) { Point origin", "gt": "= composite . getOrigin ( ) ;", "prediction": "= composite . getOrigin ( ) ;\n", "label": 1}
{"id": 9404, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleSubNodeImpl extends SimpleNodeImpl implements SimpleSubNode { protected SimpleSubNodeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_SUB_NODE ; } @ SuppressWarnings ( \"unchecked\" ) public EList < SimpleChildNode > getChildren ( ) { return ( EList < SimpleChildNode > ) eGet ( SimplemappingsPackage . Literals . SIMPLE_PARENT_NODE__CHILDREN , true ) ; } @ Override public int eBaseStructuralFeatureID ( int derivedFeatureID", "gt": ", Class < ? > baseClass )", "prediction": ")\n", "label": 0}
{"id": 15717, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . rap . rwt . internal . theme . ThemeAdapterManager ; import org . eclipse . rap . rwt . internal . theme . ThemeManagerException ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . * ; public class ThemeAdapterManager_Test extends TestCase { private static class TestWidget extends Widget { private static final long serialVersionUID = 1L ; public TestWidget ( Widget parent ) { super ( parent , SWT . NONE ) ; } } private Display display ; private Shell shell ; public void testGetThemeAdapterForWidgetWithoutThemeAdapter ( ) { Widget widget = new TestWidget ( shell ) ; ThemeAdapterManager themeAdapterManager = new ThemeAdapterManager ( ) ; try { themeAdapterManager .", "gt": "getThemeAdapter ( widget ) ;", "prediction": "getThemeAdapter ( widget ) ;\n", "label": 1}
{"id": 978, "input": "<s> class DuplicateCaseLabel { String m ( int arg ) { switch ( arg ) { case 0 : return \"zero\" ; case", "gt": "1 : return \"one\" ;", "prediction": "1 : return \"one\" ;\n", "label": 0}
{"id": 15722, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . internal . dnd . SwtUtil ; public abstract class PartSashContainer extends LayoutPart implements ILayoutContainer { protected Composite parent ; protected ControlListener resizeListener ; protected LayoutTree root ; private Composite parentWidget ; private LayoutPart zoomedPart ; protected WorkbenchPage page ; boolean active = false ; boolean layoutDirty = false ; protected ArrayList children = new ArrayList ( ) ; protected static class RelationshipInfo { protected LayoutPart part ; protected LayoutPart relative ; protected int relationship ; protected int left ; protected int right ; public float getRatio ( ) { int total = left + right ; if ( total > 0 ) { return ( float ) left / ( float ) total ; } return 0.5f ; } } public PartSashContainer ( String id , final WorkbenchPage page , Composite parentWidget ) { super ( id ) ; this . page = page ; this . parentWidget = parentWidget ; resizeListener = new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { resizeSashes ( ) ; } } ; } public boolean childObscuredByZoom ( LayoutPart toTest ) { LayoutPart zoomPart = getZoomedPart ( ) ; if ( zoomPart != null && toTest != zoomPart ) { return true ; } return isObscuredByZoom ( ) ; } public void findSashes ( LayoutPart pane , PartPane . Sashes sashes ) { if ( root == null ) { return ; } LayoutTree part = root . find ( pane ) ; if ( part == null ) { return ; } part . findSashes ( sashes ) ; } public void add ( LayoutPart child ) { if ( child == null ) { return ; } addEnhanced ( child , SWT . RIGHT , 0.5f , findBottomRight ( ) ) ; } void addEnhanced ( LayoutPart child , int swtDirectionConstant , float ratioForNewPart , LayoutPart relative ) { int relativePosition = PageLayout . swtConstantToLayoutPosition ( swtDirectionConstant ) ; float ratioForUpperLeftPart ; if ( relativePosition == IPageLayout . RIGHT || relativePosition == IPageLayout . BOTTOM ) { ratioForUpperLeftPart = 1.0f - ratioForNewPart ; } else { ratioForUpperLeftPart = ratioForNewPart ; } add ( child , relativePosition , ratioForUpperLeftPart , relative ) ; } public void add ( LayoutPart child , int relationship , float ratio , LayoutPart relative ) { boolean isHorizontal = ( relationship == IPageLayout . LEFT || relationship == IPageLayout . RIGHT ) ; LayoutTree node = null ; if ( root != null && relative != null ) { node = root . find ( relative ) ; } Rectangle bounds ; if ( getParent ( ) == null ) { Control control = getPage ( ) . getClientComposite ( ) ; if ( control != null && ! control . isDisposed ( ) ) { bounds = control . getBounds ( ) ; } else { bounds = new Rectangle ( 0 , 0 , 800 , 600 ) ; } bounds . x = 0 ; bounds . y = 0 ; } else { bounds = getBounds ( ) ; } int totalSize = measureTree ( bounds , node , isHorizontal ) ; int left = ( int ) ( totalSize * ratio ) ; int right = totalSize - left ; add ( child , relationship , left , right , relative ) ; } static int measureTree ( Rectangle outerBounds , LayoutTree toMeasure , boolean horizontal ) { if ( toMeasure == null ) { return Geometry . getDimension ( outerBounds , horizontal ) ; } LayoutTreeNode parent = toMeasure . getParent ( ) ; if ( parent == null ) { return Geometry . getDimension ( outerBounds , horizontal ) ; } if ( parent . getSash ( ) . isHorizontal ( ) == horizontal ) { return measureTree ( outerBounds , parent , horizontal ) ; } boolean isLeft = parent . isLeftChild ( toMeasure ) ; LayoutTree otherChild = parent . getChild ( ! isLeft ) ; if ( otherChild . isVisible ( ) ) { int left = parent . getSash ( ) . getLeft ( ) ; int right = parent . getSash ( ) . getRight ( ) ; int childSize = isLeft ? left : right ; int bias = parent . getCompressionBias ( ) ; if ( isLeft ) { bias = - bias ; } if ( bias == 1 ) { return childSize ; } else if ( bias == - 1 ) { return measureTree ( outerBounds , parent , horizontal ) - ( left + right - childSize ) ; } if ( ( left + right ) == 0 ) return 0 ; return measureTree ( outerBounds , parent , horizontal ) * childSize / ( left + right ) ; } return measureTree ( outerBounds , parent , horizontal ) ; } protected void addChild ( RelationshipInfo info ) { LayoutPart child = info . part ; children . add ( child ) ; if ( root == null ) { root = new LayoutTree ( child ) ; } else { int vertical = ( info . relationship == IPageLayout . LEFT || info . relationship == IPageLayout . RIGHT ) ? SWT . VERTICAL : SWT . HORIZONTAL ; boolean left = info . relationship == IPageLayout . LEFT || info . relationship == IPageLayout . TOP ; LayoutPartSash sash = new LayoutPartSash ( this , vertical ) ; sash . setSizes ( info . left , info . right ) ; if ( ( parent != null ) && ! ( child instanceof PartPlaceholder ) ) { sash .", "gt": "createControl ( parent ) ;", "prediction": "setPlaceholder ( ( PartPlaceholder ) child ) ;\n", "label": 1}
{"id": 9654, "input": "<s> package com . mobeelizer . mobile . android ; import java . io . File ; import java . util . List ; import java . util . Map ; import com . mobeelizer . java . api . MobeelizerOperationError ; import com . mobeelizer . java . errors . MobeelizerOperationStatus ; class MobeelizerDevelopmentConnectionManager implements MobeelizerConnectionManager { private static final String SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE = \"Sync is not supported in development mode.\" ; private static final String PUSH_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE = \"Push is not supported in development mode.\" ; private final String developmentRole ; public MobeelizerDevelopmentConnectionManager ( final String developmentRole ) { this . developmentRole = developmentRole ; } @ Override public boolean isNetworkAvailable ( ) { return false ; } @ Override public MobeelizerLoginResponse login ( ) { return new MobeelizerLoginResponse ( null , \"00000000-0000-0000-0000-000000000000\" , developmentRole , false ) ; } @ Override public MobeelizerOperationStatus < String > sendSyncAllRequest ( ) { throw new UnsupportedOperationException ( SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; } @ Override public MobeelizerOperationStatus < String > sendSyncDiffRequest ( final File outputFile ) { throw new UnsupportedOperationException ( SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; } @ Override public MobeelizerOperationError waitUntilSyncRequestComplete ( final String ticket ) { throw new UnsupportedOperationException ( SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; } @ Override public File getSyncData ( final String ticket ) { throw new UnsupportedOperationException ( SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; } @ Override public MobeelizerOperationError confirmTask ( final String ticket ) { throw new UnsupportedOperationException ( SYNC_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; } @ Override public MobeelizerOperationError registerForRemoteNotifications ( final String registrationId ) { throw new UnsupportedOperationException ( PUSH_IS_NOT_SUPPORTED_IN_DEVELOPMENT_MODE ) ; }", "gt": "@ Override public MobeelizerOperationError unregisterForRemoteNotifications ( final String registrationId )", "prediction": "}\n", "label": 0}
{"id": 15723, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . model ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ITaskGroup ; public class SuccesorTaskFinder { private AbstractTask currentTask ; ICompositeCheatSheetTask bestLaterTask ; ICompositeCheatSheetTask bestEarlierTask ; private boolean seenThisTask ; public SuccesorTaskFinder ( ICompositeCheatSheetTask task ) { currentTask = ( AbstractTask ) task ; } public ICompositeCheatSheetTask [ ] getRecommendedSuccessors ( ) { if ( ITaskGroup . CHOICE . equals ( currentTask . getKind ( ) ) ) { List runnableChoices = findRunnableChoices ( ) ; if ( runnableChoices . size ( ) != 0 ) { return ( ICompositeCheatSheetTask [ ] ) runnableChoices . toArray ( new ICompositeCheatSheetTask [ runnableChoices . size ( ) ] ) ; } } return getBestSuccessor ( ) ; } private List findRunnableChoices ( ) { List result ; result = new ArrayList ( ) ; if ( isStartable ( currentTask ) ) { ICompositeCheatSheetTask [ ] subtasks = currentTask . getSubtasks ( ) ; for ( int i = 0 ; i < subtasks . length ; i ++ ) { if ( isStartable ( subtasks [ i ] ) ) { result . add ( subtasks [ i ] ) ; } } } return result ; } private boolean isStartable ( ICompositeCheatSheetTask task ) { int state = task . getState ( ) ; return ( state != ICompositeCheatSheetTask . COMPLETED && state != ICompositeCheatSheetTask . SKIPPED && task . requiredTasksCompleted ( ) ) ; } private ICompositeCheatSheetTask [ ] getBestSuccessor ( ) { bestLaterTask = null ; bestEarlierTask = null ; seenThisTask = false ; searchRunnableChildren ( currentTask . getCompositeCheatSheet ( ) . getRootTask ( ) ) ; if ( bestLaterTask != null ) { return new ICompositeCheatSheetTask [ ] { bestLaterTask } ; } if ( bestEarlierTask != null ) { return new ICompositeCheatSheetTask [ ] { bestEarlierTask } ; } return new ICompositeCheatSheetTask [ 0 ] ; } private void searchRunnableChildren ( ICompositeCheatSheetTask task ) { if ( bestLaterTask != null ) { return ; } if ( task == currentTask ) { seenThisTask = true ; } if ( task . getState ( ) == ICompositeCheatSheetTask . COMPLETED || task . getState ( ) == ICompositeCheatSheetTask . SKIPPED ) { if ( isTaskAncestor ( task , currentTask ) ) { seenThisTask = true ; } return ; } if ( isStartable ( task ) && task != currentTask ) { if ( seenThisTask ) { if ( bestLaterTask == null ) { bestLaterTask = task ; } } else { if ( bestEarlierTask == null ) { bestEarlierTask = task ; } } } ICompositeCheatSheetTask [ ] subtasks = task . getSubtasks ( ) ; for ( int i = 0 ; i < subtasks . length ; i ++ ) {", "gt": "searchRunnableChildren ( subtasks [ i ] ) ;", "prediction": "if ( isStartable ( subtasks [ i ] ) )\n", "label": 1}
{"id": 8096, "input": "<s> package org . parboiled . common ; import org . testng . annotations . Test ; import static org . parboiled . common . ImmutableLinkedList . nil ; import static org . testng . Assert . assertEquals ; public class ImmutableLinkedListTest { @ Test public void testImmutableLinkedList ( ) { assertEquals ( nil ( ) . size ( ) , 0 ) ; assertEquals ( nil ( ) . prepend ( 5 ) . size ( ) , 1 ) ; assertEquals ( nil ( ) . prepend ( 5 ) . prepend ( 7 ) . size ( ) , 2 ) ; ImmutableLinkedList < Object > abc = nil ( ) . prepend ( \"c\" ) . prepend ( \"b\" ) . prepend ( \"a\" ) ; assertEquals ( StringUtils . join ( abc , \",\"", "gt": ") , \"a,b,c\" ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 15729, "input": "<s> package org . eclipse . ui . tests . dynamicplugins ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . wizards . IWizardRegistry ; import org . eclipse . ui . wizards . IWizardDescriptor ; public class NewWizardTests extends DynamicTestCase { private static final String WIZARD_ID = \"org.eclipse.newNewWizard1.newNewWizard1\" ; public NewWizardTests ( String testName ) { super ( testName ) ; } public void testNewWizardProperties ( ) { IWizardRegistry registry = WorkbenchPlugin . getDefault ( ) . getNewWizardRegistry ( ) ; assertNull ( registry . findWizard ( WIZARD_ID ) ) ; getBundle ( ) ; IWizardDescriptor wizard = registry . findWizard ( WIZARD_ID ) ; assertNotNull ( wizard ) ; testNewWizardProperties ( wizard ) ; removeBundle ( ) ;", "gt": "assertNull ( registry . findWizard ( WIZARD_ID ) ) ;", "prediction": "}\n", "label": 1}
{"id": 3955, "input": "<s> class G < N extends G . Node < N > > { static class Node < N extends Node < N > > { } } class F extends G < F . MyNode > { static class", "gt": "MyNode extends G . Node < MyNode >", "prediction": "MyNode < N >\n", "label": 0}
{"id": 15735, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import java . io . IOException ; public final class FuzzyTermEnum extends FilteredTermEnum { private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19 ; private int [ ] [ ] d ; private float similarity ; private boolean endEnum = false ; private Term searchTerm = null ; private final String field ; private final String text ; private final String prefix ; private final float minimumSimilarity ; private final float scale_factor ; private final int [ ] maxDistances = new int [ TYPICAL_LONGEST_WORD_IN_INDEX ] ; public FuzzyTermEnum ( IndexReader reader , Term term ) throws IOException { this ( reader , term , FuzzyQuery . defaultMinSimilarity , FuzzyQuery . defaultPrefixLength ) ; } public FuzzyTermEnum ( IndexReader reader , Term term , float minSimilarity ) throws IOException { this ( reader , term , minSimilarity , FuzzyQuery . defaultPrefixLength ) ; } public FuzzyTermEnum ( IndexReader reader , Term term , final float minSimilarity , final int prefixLength ) throws IOException { super ( ) ; if ( minSimilarity >= 1.0f ) throw new IllegalArgumentException ( \"minimumSimilarity cannot be greater than or equal to 1\" ) ; else if ( minSimilarity < 0.0f ) throw new IllegalArgumentException ( \"minimumSimilarity cannot be less than 0\" ) ; if ( prefixLength < 0 ) throw new IllegalArgumentException ( \"prefixLength cannot be less than 0\" ) ; this . minimumSimilarity = minSimilarity ; this . scale_factor = 1.0f / ( 1.0f - minimumSimilarity ) ; this . searchTerm = term ; this . field = searchTerm . field ( ) ; final int fullSearchTermLength = searchTerm . text ( ) . length ( ) ; final int realPrefixLength = prefixLength > fullSearchTermLength ? fullSearchTermLength : prefixLength ; this . text = searchTerm . text ( ) . substring ( realPrefixLength ) ; this . prefix = searchTerm . text ( ) . substring ( 0 , realPrefixLength ) ; initializeMaxDistances ( ) ; this . d = initDistanceArray ( ) ; setEnum ( reader . terms ( new Term ( searchTerm . field ( ) , prefix ) ) ) ; } protected final boolean termCompare ( Term term ) { if ( field == term . field ( ) && term . text ( ) . startsWith ( prefix ) ) { final String target = term . text ( ) . substring ( prefix . length ( ) ) ; this . similarity = similarity ( target ) ; return ( similarity > minimumSimilarity ) ; } endEnum = true ; return false ; } public final float difference ( ) { return ( float ) ( ( similarity - minimumSimilarity ) * scale_factor ) ; } public final boolean endEnum ( ) { return endEnum ; } private static final int min ( int a , int b , int c ) { final int t = ( a < b ) ? a : b ; return ( t < c ) ? t : c ; } private final int [ ] [ ] initDistanceArray ( ) { return new int [ this . text . length ( ) + 1 ] [ TYPICAL_LONGEST_WORD_IN_INDEX ] ; } private float similarity ( final String target ) { final int m = target . length ( ) ; final int n = text . length ( ) ; if ( n == 0 ) { return prefix . length ( ) == 0 ? 0.0f : 1.0f - ( ( float ) m / prefix . length ( ) ) ; } if ( m == 0 ) { return prefix . length ( ) == 0 ? 0.0f : 1.0f - ( ( float ) n / prefix . length ( ) ) ; } final int maxDistance = getMaxDistance ( m ) ; if ( maxDistance < Math . abs ( m - n ) ) { return 0.0f ; } if ( d [ 0 ] . length <= m ) { growDistanceArray ( m ) ; } for ( int i = 0 ; i <= n ; i ++ ) d [ i ] [ 0 ] = i ; for ( int j = 0 ; j <= m ; j ++ ) d [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= n ; i ++ ) { int bestPossibleEditDistance = m ; final char s_i = text . charAt ( i - 1 ) ; for ( int j = 1 ; j <= m ; j ++ ) { if ( s_i != target . charAt ( j - 1 ) ) { d [ i ] [ j ] = min ( d [ i - 1 ] [ j ] , d [ i ] [ j - 1 ] , d [ i - 1 ] [ j - 1 ] ) + 1 ; } else { d [ i ] [ j ] = min ( d [ i - 1 ] [ j ] + 1 , d [ i ] [ j - 1 ] + 1 , d [ i - 1 ] [ j - 1 ] ) ; } bestPossibleEditDistance = Math . min ( bestPossibleEditDistance , d [ i ] [ j ] ) ; } if ( i > maxDistance && bestPossibleEditDistance > maxDistance ) { return 0.0f ; } } return 1.0f - ( ( float ) d [ n ] [ m ] / ( float ) ( prefix . length ( ) + Math . min ( n , m ) ) ) ; } private void growDistanceArray ( int m ) { for ( int i = 0 ; i < d . length ; i ++ ) { d [ i ] = new int [ m + 1 ] ; } } private final int getMaxDistance ( int m ) { return ( m < maxDistances . length ) ? maxDistances [ m ] : calculateMaxDistance ( m ) ; } private void initializeMaxDistances ( ) { for ( int i = 0 ;", "gt": "i < maxDistances . length ;", "prediction": "i < d . length ;\n", "label": 1}
{"id": 6415, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import java . util . Map ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . BooleanExpression ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . ExpressionHelper ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . DJGroupVariable ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class CustomExpressionReportTest3 extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorder ( Border . PEN_2_POINT ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style amountStyle = new Style ( ) ; amountStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; Color veryLightGrey = new Color ( 230 , 230 , 230 ) ; oddRowStyle . setBackgroundColor ( veryLightGrey ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setTitleStyle ( titleStyle ) . setTitleHeight ( new Integer ( 30 ) ) . setSubtitleHeight ( new Integer ( 20 ) ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( true ) . setOddRowBackgroundStyle ( oddRowStyle ) . setColumnsPerPage ( new Integer ( 1 ) ) . setColumnSpace ( new Integer ( 5 ) ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaCantidad = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . setPattern ( \"$ 0.00\" ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaCustomExpression = ColumnBuilder . getNew ( ) . setCustomExpression ( getRatioExpression ( ) ) . setTitle ( \"CustomExp\" ) . setWidth ( new Integer ( 90 ) ) . setPattern ( \"#,##0.0\" ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle )", "gt": ". build ( ) ;", "prediction": ". build ( ) ;\n", "label": 0}
{"id": 15738, "input": "<s> package org . restlet . test . ext . jaxrs . server ; public interface ServerWrapperFactory {", "gt": "public ServerWrapper createServerWrapper ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7672, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . entities . Entity ; import net . sf . jasperreports . charts . design . JRDesignPie3DPlot ; import net . sf . jasperreports . engine . JRChartPlot ; public class Pie3DPlot extends AbstractPiePlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private Double depthFactor = null ; public void setDepthFactor ( Double depthFactor ) { this . depthFactor = depthFactor ; } public Double getDepthFactor ( ) { return depthFactor ; } public void transform ( DynamicJasperDesign design , JRChartPlot plot , String name ) { super . transform ( design , plot , name ) ; JRDesignPie3DPlot piePlot = ( JRDesignPie3DPlot ) plot ; if ( getCircular ( ) != null ) piePlot . setCircular ( getCircular ( ) ) ; if ( getLabelFormat ( ) != null ) piePlot . setLabelFormat ( getLabelFormat ( ) ) ; if ( getLegendLabelFormat ( ) != null ) piePlot", "gt": ". setLegendLabelFormat ( getLegendLabelFormat ( ) ) ;", "prediction": ". setLegendLabelFormat ( getLegendLabelFormat ( ) ) ;\n", "label": 0}
{"id": 15744, "input": "<s> package org . eclipse . ui . statushandlers ; import org . eclipse . core . runtime . QualifiedName ; import org . eclipse . ui . PlatformUI ; public interface IStatusAdapterConstants { static final String PROPERTY_PREFIX = PlatformUI . PLUGIN_ID + \".workbench.statusHandlers.adapters\" ; public static final QualifiedName TITLE_PROPERTY = new QualifiedName (", "gt": "PROPERTY_PREFIX , \"title\" ) ;", "prediction": "PROPERTY_PREFIX ) ;\n", "label": 1}
{"id": 4543, "input": "<s> package org . gk . ui . client . com . grid . column ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . NumberField ; import com . extjs . gxt . ui . client . widget . grid . Grid ; public abstract class gkNumberColumnConfig extends gkCellColumnConfig { public gkNumberColumnConfig ( gkColumnInfo field ) { super ( field ) ; } @ Override protected Field createField ( ) { Field field = new NumberField ( ) { @ Override public void focus ( ) { if ( rendered ) { getFocusEl ( ) . focus ( ) ; onFocus ( new FieldEvent ( this ) ) ; } if ( ! hasFocus ) { fireEvent ( Events . Focus ) ; } } @ Override public void setFieldLabel ( String fieldLabel ) { super . setFieldLabel ( fieldLabel ) ; setHeader ( fieldLabel ) ; } @ Override protected void blur ( ) { if ( rendered ) { getFocusEl ( ) . blur ( ) ; } if ( hasFocus ) { fireEvent ( Events . Blur ) ; hasFocus = false ; } } } ; field . setInputStyleAttribute ( \"text-align\" , \"right\" ) ; return field ; } @ Override protected Field createColumnCell ( final ModelData model , final String property , ListStore < ModelData > store , int rowIndex , int", "gt": "colIndex , Grid < ModelData > grid )", "prediction": "columnIndex )\n", "label": 0}
{"id": 15745, "input": "<s> package de . uos . igf . db3d . dbms . structure ; import de . uos . igf . db3d . dbms", "gt": ". geom . MBB3D ;", "prediction": ". geometry . Point ;\n", "label": 1}
{"id": 4460, "input": "<s> package FRC2115 . commands ; public class DeployPlunger extends CommandBase { private double m_timeout ; public DeployPlunger ( double timeout ) { m_timeout = timeout ; requires ( plunger ) ; } protected void initialize ( ) { setTimeout ( m_timeout ) ; } protected void execute ( ) { plunger . shoot ( ) ; } protected boolean isFinished ( ) {", "gt": "return isTimedOut ( ) ;", "prediction": "return true ;\n", "label": 0}
{"id": 15747, "input": "<s> package monbulk . client . event ; import com . google . gwt . event . shared . GwtEvent ; public class WindowEvent extends GwtEvent < WindowEventHandler > { public enum EventType { ActivateWindow , CloseWindow , MaximiseWindow , Ok , Cancel , } public static Type < WindowEventHandler > TYPE = new Type < WindowEventHandler > ( ) ; private String m_windowId ; private EventType m_eventType ; public WindowEvent ( String windowId , EventType eventType ) { m_windowId = windowId ; m_eventType = eventType ; } public String getWindowId ( ) { return m_windowId ; } public EventType getEventType ( ) { return m_eventType ; } @ Override public Type < WindowEventHandler > getAssociatedType ( ) { return TYPE ; } @", "gt": "Override protected void dispatch ( WindowEventHandler handler )", "prediction": "Override public void handleEvent ( WindowEvent event )\n", "label": 1}
{"id": 38, "input": "<s> class NonStaticFieldExpr1 { public int x ;", "gt": "int y = NonStaticFieldExpr1 . x ;", "prediction": "public int y ;\n", "label": 0}
{"id": 15749, "input": "<s> package org . apache . lucene . xmlparser . builders ; import java . io . IOException ; import java . io . StringReader ; import java . util . ArrayList ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . spans . SpanOrQuery ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . search . spans . SpanTermQuery ; import org . apache . lucene . xmlparser . DOMUtils ; import org . apache . lucene . xmlparser . ParserException ; import org . w3c . dom . Element ; public class SpanOrTermsBuilder extends SpanBuilderBase { Analyzer analyzer ; public SpanOrTermsBuilder ( Analyzer analyzer ) { super ( ) ; this . analyzer = analyzer ; } public SpanQuery getSpanQuery ( Element e ) throws ParserException { String fieldName = DOMUtils . getAttributeWithInheritanceOrFail ( e , \"fieldName\" ) ;", "gt": "String value = DOMUtils . getNonBlankTextOrFail ( e ) ;", "prediction": "if ( fieldName == null )\n", "label": 1}
{"id": 1055, "input": "<s> package com . caseystella ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . apache . commons . math . MathException ; import org . apache . commons . math . linear . RealVector ; import com . caseystella . interfaces . IBackingStore ; import com . caseystella . interfaces . IDistanceMetric ; import com . caseystella . interfaces . IHashCreator ; import com . caseystella . lsh . interfaces . ILSH ; public class KNN { public static class Payload { private RealVector vector ; private byte [ ] payload ; public Payload ( RealVector vector , byte [ ] payload ) { this . vector = vector ; this . payload = payload ; } public RealVector getVector ( ) { return vector ; } public byte [ ] getPayload ( ) { return payload ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( payload ) ; result = prime * result + ( ( vector == null ) ? 0 : vector . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Payload other = ( Payload ) obj ; if ( ! Arrays . equals ( payload , other . payload ) ) return false ; if ( vector == null ) { if ( other . vector != null ) return false ; } else if ( ! vector . equals ( other . vector ) ) return false ; return true ; } } public static class Result { private Iterable < Payload > payloads ; private int totalItemsReturned ; Result ( Iterable < Payload > payloads , int totalItemsReturned ) { this . payloads = payloads ; this . totalItemsReturned = totalItemsReturned ; } public Iterable < Payload > getPayloads ( ) { return payloads ; } public int getTotalItemsReturned ( ) { return totalItemsReturned ; } } private Iterable < ILSH > hashes ; private IBackingStore backingStore ; private IDistanceMetric underlyingMetric ; public KNN ( int numHashes , int hashDimension , long seed , IHashCreator creator , IBackingStore backingStore ) throws MathException {", "gt": "this . backingStore = backingStore ;", "prediction": "this . numHashes = numHashes ;\n", "label": 0}
{"id": 15757, "input": "<s> package org . eclipse . jface . viewers ; import java . io . Serializable ; import org . eclipse . jface . util . Policy ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; public abstract class ViewerRow implements Cloneable , Serializable { public static final int ABOVE = 1 ; public static final int BELOW = 2 ; private static final String KEY_TEXT_LAYOUT = Policy . JFACE + \"styled_label_key_\" ; private static final String KEY_TEXT_LAYOUT_0 = Policy . JFACE + \"styled_label_key_0\" ; private static String [ ] cachedDataKeys ; public abstract Rectangle getBounds ( int columnIndex ) ; public abstract Rectangle getBounds ( ) ; public abstract Widget getItem ( ) ; public abstract int getColumnCount ( ) ; public abstract Image getImage ( int columnIndex ) ; public abstract void setImage ( int columnIndex , Image image ) ; public abstract String getText ( int columnIndex ) ; public abstract void setText ( int columnIndex , String text ) ; public abstract Color getBackground ( int columnIndex ) ; public abstract void setBackground ( int columnIndex , Color color ) ; public abstract Color getForeground ( int columnIndex ) ; public abstract void setForeground ( int columnIndex , Color color ) ; public abstract Font getFont ( int columnIndex ) ; public abstract void setFont ( int columnIndex , Font font ) ; public ViewerCell getCell ( Point point ) { int index = getColumnIndex ( point ) ; return getCell ( index ) ; } public int getColumnIndex ( Point point ) { int count = getColumnCount ( ) ; if ( count == 0 ) { return 0 ; } for ( int i = 0 ; i < count ; i ++ ) { if ( getBounds ( i ) . contains ( point ) ) { return i ; } } return - 1 ; } public ViewerCell getCell ( int column ) { if ( column >= 0 ) return new ViewerCell ( ( ViewerRow ) clone ( ) , column , getElement ( ) ) ; return null ; } public abstract Control getControl ( ) ; public abstract ViewerRow getNeighbor ( int direction , boolean sameLevel ) ; public abstract TreePath getTreePath ( ) ; public abstract Object clone ( ) ; public abstract Object getElement ( ) ; public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( getItem ( ) == null ) ? 0 : getItem ( ) . hashCode ( ) ) ; return result ; } public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final ViewerRow other = ( ViewerRow ) obj ; if ( getItem ( ) == null ) { if ( other . getItem ( ) != null ) return false ; } else if ( ! getItem ( ) . equals ( other . getItem ( ) ) ) return false ; return true ; } ViewerCell getCellAtVisualIndex ( int visualIndex ) { return getCell ( getCreationIndex ( visualIndex ) ) ; } protected int getVisualIndex ( int creationIndex ) { return creationIndex ; } protected int getCreationIndex ( int visualIndex ) { return visualIndex ; } public Rectangle getTextBounds ( int index ) { return null ; } public Rectangle getImageBounds ( int index ) { return null ; } int getWidth ( int columnIndex ) {", "gt": "return getBounds ( columnIndex ) . width ;", "prediction": "return getWidth ( columnIndex ) ;\n", "label": 1}
{"id": 4496, "input": "<s> package org . remast . baralga . gui . model ; import org . junit . Test ; public class PresentationModelTest { @", "gt": "Test public void testAcitivityOverMidnight ( ) throws ProjectActivityStateException", "prediction": "Test public void testGetPresentation ( )\n", "label": 0}
{"id": 15758, "input": "<s> package br . org . archimedes ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Platform ; import org . osgi . framework . Bundle ; public class FileLoader { private static final String TESTS_PLUGIN_ID = \"br.org.archimedes.tests\" ; public static InputStream getReaderForFile ( String filePath ) throws FileNotFoundException { InputStream fileInput ; try { Bundle bundle = Platform . getBundle ( TESTS_PLUGIN_ID ) ; IPath file = new Path ( filePath ) ; fileInput = FileLocator . openStream ( bundle , file , false ) ; }", "gt": "catch ( Throwable t )", "prediction": "catch ( IOException e )\n", "label": 1}
{"id": 2409, "input": "<s> package org . msl . simple . gmfmap . diagram . properties . figure ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Figure ; import org . eclipse . gmf . gmfgraph . FigureDescriptor ; import org . msl . simple . gmfmap . diagram . properties . AbstractSimplemapPropertySection ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; public abstract class ElementWithFigurePropertySection extends AbstractSimplemapPropertySection { protected Figure getFigure ( Object selected ) { Object transformSelection = super . transformSelection ( selected ) ; Figure figure = null ; if ( transformSelection instanceof SimpleNode ) { figure = ( ( SimpleNode ) transformSelection ) . getDiagramNode ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleCompartment ) { figure = ( ( SimpleCompartment ) transformSelection ) . getCompartment ( ) . getAccessor ( ) . getFigure ( ) ; } if ( transformSelection instanceof SimpleLinkMapping ) { FigureDescriptor figDesc = ( ( SimpleLinkMapping ) transformSelection ) . getDiagramLink ( ) . getFigure ( ) ; figure = figDesc != null ? figDesc . getActualFigure ( ) : null ; } return figure ; } protected Figure getLabelFigure ( Object selected ) { Object transformSelection = super . transformSelection ( selected ) ; Figure figure = null ; if ( transformSelection instanceof SimpleNode ) { DiagramLabel diagramLabel = ( ( SimpleNode ) transformSelection ) . getDiagramLabel ( ) ; if ( diagramLabel != null && diagramLabel . getAccessor ( ) != null ) figure = diagramLabel . getAccessor ( ) . getFigure ( ) ; } if ( transformSelection instanceof SimpleLabelNode ) { figure = ( ( SimpleNode ) transformSelection ) . getDiagramLabel ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleCompartment ) { figure = ( ( SimpleCompartment ) transformSelection ) . getCompartment ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleLinkMapping ) { figure = ( ( SimpleLinkMapping ) transformSelection ) . getDiagramLabel", "gt": "( ) . getFigure ( ) . getActualFigure ( ) ;", "prediction": "( ) . getFigure ( ) ;\n", "label": 0}
{"id": 15759, "input": "<s> package spell ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . prefs . Preferences ; import org . ini4j . Ini ; import org . ini4j . IniPreferences ; import org . ini4j . InvalidFileFormatException ; import actors . Actor ; public class Spell { private static HashMap < String , Spell > spellCache = new HashMap < String , Spell > ( ) ; public static Spell getSpell ( String name , boolean forceLoad ) { Spell s = null ; try { if ( spellCache . containsKey ( name ) && ! forceLoad ) s = spellCache . get ( name ) ; else { s = new Spell ( name ) ; spellCache . put ( name , s ) ; } } catch ( Exception e ) { System . err . println ( \"can not read or find file: \" + \"data/spells/\" + name + \"/spell.ini\" ) ; } return s ; } public static Spell getSpell ( String name ) { return getSpell ( name , false ) ; } private boolean fire = false ; private boolean frez = false ; private boolean elec = false ; private boolean lght = false ; private boolean dark = false ; private int lvl = 1 ; private String value = \"0\" ; private boolean valueType = false ; private boolean targetAlly = false ; private int targetRange = 0 ; private String name ; private Spell ( String name ) throws Exception { this . name = name ; Preferences p = null ; p = new IniPreferences ( new Ini ( new File ( \"data/spells/\" + name + \".ini\" ) ) ) . node ( \"spell\" ) ; lvl = p . getInt ( \"level\" , 1 ) ; fire = p . getBoolean ( \"fire\" , false ) ; frez = p . getBoolean ( \"frez\" , false ) ; elec = p . getBoolean ( \"elec\" , false ) ; lght = p . getBoolean ( \"lght\" , false ) ; dark = p . getBoolean ( \"dark\" , false ) ; targetAlly = p . getBoolean ( \"targetAlly\" , false ) ; targetRange = p . getInt ( \"targetRange\" , 0 ) ; value = p . get ( \"value\" , \"0\" ) ; valueType = p . get ( \"type\" , \"constant\" ) . equals ( \"variable\" ) ? true : false ; } public String getValue ( ) { return value ; } public boolean getValueType ( ) { return valueType ; } public int getLevel ( ) { return lvl ; } public int getElementalEffectiveness ( Actor a ) { int sum = 0 ; int elem = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) if ( getElementalAlignment ( i ) ) { elem ++ ; sum += a . getElementalResistance ( i ) ; } if ( sum <= elem - 1 ) return 0 ; else if ( sum >= elem + 1 ) return 2 ; else return 1 ; } public boolean getElementalAlignment ( int i ) { if ( i == 0 ) return fire ; else if ( i == 1 ) return frez ; else if (", "gt": "i == 2 ) return elec ;", "prediction": "i == 2 ) return dark ;\n", "label": 1}
{"id": 7059, "input": "<s> package org . ofbiz . webtools . artifactinfo ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import javolution . util . FastSet ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelRelation ; import org . ofbiz . entityext . eca . EntityEcaRule ; public class EntityArtifactInfo extends ArtifactInfoBase { protected ModelEntity modelEntity ; protected Set < EntityArtifactInfo > entitiesRelatedOne = new TreeSet < EntityArtifactInfo > ( ) ; protected Set < EntityArtifactInfo > entitiesRelatedMany = new TreeSet < EntityArtifactInfo > ( ) ; public EntityArtifactInfo ( String entityName , ArtifactInfoFactory aif ) throws GenericEntityException { super ( aif ) ; this . modelEntity = this . aif . getModelEntity ( entityName ) ; } public void populateAll ( ) throws GeneralException { List < ModelRelation > relationOneList = modelEntity . getRelationsOneList ( ) ; for ( ModelRelation relationOne : relationOneList ) { this . entitiesRelatedOne . add ( this . aif . getEntityArtifactInfo ( relationOne . getRelEntityName ( ) ) ) ; } List < ModelRelation > relationManyList = modelEntity . getRelationsManyList ( ) ; for ( ModelRelation relationMany : relationManyList ) { this . entitiesRelatedMany . add ( this . aif . getEntityArtifactInfo ( relationMany . getRelEntityName ( ) ) ) ; } } public ModelEntity getModelEntity ( ) { return this . modelEntity ; } @ Override public String getDisplayName ( ) {", "gt": "return this . getUniqueId ( ) ;", "prediction": "return this . modelEntity . getName ( ) ;\n", "label": 0}
{"id": 15763, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import java . util . List ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . nodes . FieldQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . core . nodes . TokenizedPhraseQueryNode ; import org . apache . lucene . search . PhraseQuery ; import org . apache . lucene . search . TermQuery ; public class PhraseQueryNodeBuilder implements StandardQueryBuilder { public PhraseQueryNodeBuilder ( ) { } public PhraseQuery build ( QueryNode queryNode ) throws QueryNodeException { TokenizedPhraseQueryNode phraseNode = ( TokenizedPhraseQueryNode ) queryNode ; PhraseQuery phraseQuery = new PhraseQuery ( ) ; List < QueryNode > children = phraseNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { TermQuery termQuery = ( TermQuery ) child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; FieldQueryNode termNode = ( FieldQueryNode ) child ; phraseQuery . add ( termQuery .", "gt": "getTerm ( ) , termNode . getPositionIncrement ( ) ) ;", "prediction": "build ( queryNode ) ) ;\n", "label": 1}
{"id": 1696, "input": "<s> class T6586091 { static class A < T extends A < ? > > { } static class B extends A < A < ? > > { } A < A < ? > > t = null ; B", "gt": "c = ( B ) t ;", "prediction": "( T )\n", "label": 0}
{"id": 15764, "input": "<s> package org . eclipse . jface . tests . layout ; import junit . framework . Test ; import junit . framework . TestSuite ; public class AllTests extends TestSuite { public static void main ( String [ ] args ) { junit . textui . TestRunner", "gt": ". run ( suite ( ) ) ;", "prediction": ". run ( new AllTests ( ) ) ;\n", "label": 1}
{"id": 4134, "input": "<s> package com . redhat . ceylon . compiler . java . test . structure ; import java . util . LinkedList ; import java . util . List ; import org . junit . Assert ; import org . junit . Test ; import com . redhat . ceylon . compiler . java . test . CompilerTest ; import com . redhat . ceylon . compiler . java . tools . CeyloncTaskImpl ; public class StructureTest2 extends CompilerTest { @ Override protected String transformDestDir ( String name ) { return name + \"-2\" ; } @ Test public void testTopToplevelAttribute ( ) { compareWithJavaSource ( \"toplevel/ToplevelAttribute\" ) ; } @ Test public void testTopToplevelAttributeGenerics ( ) { compareWithJavaSource ( \"toplevel/ToplevelAttributeGenerics\" ) ; } @ Test public void testTopToplevelAttributeShared ( ) { compareWithJavaSource ( \"toplevel/ToplevelAttributeShared\" ) ; } @ Test public void testTopToplevelGetter ( ) { compareWithJavaSource ( \"toplevel/ToplevelGetter\" ) ; } @ Test public void testTopToplevelGetterSetter ( ) { compareWithJavaSource ( \"toplevel/ToplevelGetterSetter\" ) ; } @ Test public void testTopToplevelMethods ( ) { compareWithJavaSource ( \"toplevel/ToplevelMethods\" ) ; } @ Test public void testTopToplevelMethodWithDefaultedParams ( ) { compareWithJavaSource ( \"toplevel/ToplevelMethodWithDefaultedParams\" ) ; } @ Test public void testTopToplevelObject ( ) { compareWithJavaSource ( \"toplevel/ToplevelObject\" ) ; } @ Test public void testTopToplevelObjectWithMembers ( ) { compareWithJavaSource ( \"toplevel/ToplevelObjectWithMembers\" ) ; } @ Test public void testTopToplevelObjectShared ( ) { compareWithJavaSource ( \"toplevel/ToplevelObjectShared\" ) ; } @ Test public void testTopToplevelObjectWithSupertypes ( ) { compareWithJavaSource ( \"toplevel/ToplevelObjectWithSupertypes\" ) ; } @ Test public void testTopToplevelVariable ( ) { compareWithJavaSource ( \"toplevel/ToplevelVariable\" ) ; } @ Test public void testTopToplevelVariableShared ( ) { compareWithJavaSource ( \"toplevel/ToplevelVariableShared\" ) ; } @ Test public void testMthTopLevelSpecifyingTopLevel ( ) { compareWithJavaSource ( \"toplevel/TopLevelSpecifyingTopLevel\" ) ; } @ Test public void testTypBasicTypes ( ) { compareWithJavaSource ( \"type/BasicTypes\" ) ; } @ Test public void testTypBottom ( ) { compareWithJavaSource ( \"type/Bottom\" ) ; } @ Test public void testTypGenericBottom ( ) { compareWithJavaSource ( \"type/GenericBottom\" ) ; } @ Test public void testTypConversions ( ) { compareWithJavaSource ( \"type/Conversions\" ) ; } @ Test public void testTypOptionalType ( ) { compareWithJavaSource ( \"type/OptionalType\" ) ; } @ Test public void testTypSequenceType ( ) { compareWithJavaSource ( \"type/SequenceType\" ) ; } @ Test public void testImpImportAliasAndWildcard ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportAliasAndWildcard\" ) ; } private void compileImportedPackage ( ) { compile ( \"import_/pkg/C1.ceylon\" , \"import_/pkg/C2.ceylon\" ) ; } @ Test public void testImpImportAttrSingle ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportAttrSingle\" ) ; } @ Test public void testImpImportMethodSingle ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportMethodSingle\" ) ; } @ Test public void testImpImportTypeSingle ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportTypeSingle\" ) ; } @ Test public void testImpImportTypeMultiple ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportTypeMultiple\" ) ; } @ Test public void testImpImportTypeAlias ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportTypeAlias\" ) ; } @ Test public void testImpImportWildcard ( ) { compileImportedPackage ( ) ; compareWithJavaSource ( \"import_/ImportWildcard\" ) ; } @ Test public void testImpImportWildcardSinglePass ( ) { List < String > options = new LinkedList < String > ( ) ; options . add ( \"-src\" ) ; options . add ( getPackagePath ( ) + \"/import_/src\" ) ; CeyloncTaskImpl task = getCompilerTask ( options , \"import_/src/pkg/File.ceylon\" , \"import_/src/pkg/sub/ConcreteDirectory.ceylon\" ) ; Assert . assertTrue ( task . call ( ) ) ; task = getCompilerTask ( options , \"import_/src/pkg/File.ceylon\" , \"import_/src/pkg/sub/ConcreteDirectory.ceylon\" ) ; Assert . assertTrue ( task . call ( ) ) ; } @ Test public void testImpImportJavaRuntimeTypeSingle ( ) { compareWithJavaSource ( \"import_/ImportJavaRuntimeTypeSingle\" ) ; } @ Test public void testImpImportJavaRuntimeTypeWildcard ( ) { compareWithJavaSource ( \"import_/ImportJavaRuntimeTypeWildcard\" ) ; } @ Test public void testImpImportCeylonLanguageType ( ) { compareWithJavaSource ( \"import_/ImportCeylonLanguageType\" ) ; } @ Test public void testNstCcc ( ) { compareWithJavaSource ( \"nesting/ccc/CCC\" ) ; } @ Test public void testNstCci ( ) { compareWithJavaSource ( \"nesting/cci/CCI\" ) ; } @ Test public void testNstCic ( ) { compareWithJavaSource ( \"nesting/cic/CIC\" ) ; } @ Test public void testNstCii ( ) { compareWithJavaSource ( \"nesting/cii/CII\" ) ; } @ Test public void testNstIcc ( ) { compareWithJavaSource ( \"nesting/icc/ICC\" ) ; } @ Test public void testNstIci ( ) { compareWithJavaSource ( \"nesting/ici/ICI\" ) ; } @ Test public void testNstIic ( ) { compareWithJavaSource ( \"nesting/iic/IIC\" ) ; } @ Test public void testNstIii ( ) { compareWithJavaSource ( \"nesting/iii/III\" ) ; } @ Test public void testNstLocals ( ) { compareWithJavaSource ( \"nesting/Locals\" ) ; } @ Test public void testNstClassMethodDefaultedParameter ( ) { compareWithJavaSource ( \"nesting/ClassMethodDefaultedParameter\" ) ; } @ Test public void testNstFunctionDefaultedParameter ( ) { compareWithJavaSource ( \"nesting/FunctionDefaultedParameter\" ) ; } @ Test", "gt": "public void testNstClassInitDefaultedParameter ( )", "prediction": "public void testNstMethodDefaultedParameter ( )\n", "label": 0}
{"id": 15765, "input": "<s> package com . emf4sw . rdf . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EcoreUtil ; import com . emf4sw . rdf . Datatype ; import com . emf4sw . rdf . Literal ; import com . emf4sw . rdf . RDFGraph ; import com . emf4sw . rdf . RDFPackage ; public class LiteralImpl extends NodeImpl implements Literal { protected static final String LEXICAL_FORM_EDEFAULT = null ; protected String lexicalForm = LEXICAL_FORM_EDEFAULT ; protected static final String LANG_EDEFAULT = null ; protected String lang = LANG_EDEFAULT ; protected Datatype datatype ; protected LiteralImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return RDFPackage . Literals . LITERAL ; } public String getLexicalForm ( ) { return lexicalForm ; } public void setLexicalForm ( String newLexicalForm ) { String oldLexicalForm = lexicalForm ; lexicalForm = newLexicalForm ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LEXICAL_FORM , oldLexicalForm , lexicalForm ) ) ; } public String getLang ( ) { return lang ; } public void setLang ( String newLang ) { String oldLang = lang ; lang = newLang ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LANG , oldLang , lang ) ) ; } public Datatype getDatatype ( ) { if ( datatype != null && datatype . eIsProxy ( ) ) { InternalEObject oldDatatype = ( InternalEObject ) datatype ; datatype = ( Datatype ) eResolveProxy ( oldDatatype ) ; if ( datatype != oldDatatype ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ; } } return datatype ; } public Datatype basicGetDatatype ( ) { return datatype ; } public void setDatatype ( Datatype newDatatype ) { Datatype oldDatatype = datatype ; datatype = newDatatype ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ; } public RDFGraph getGraph ( ) { if ( eContainerFeatureID ( ) != RDFPackage . LITERAL__GRAPH ) return null ; return ( RDFGraph ) eContainer ( ) ; } public NotificationChain basicSetGraph ( RDFGraph newGraph , NotificationChain msgs ) { msgs = eBasicSetContainer ( ( InternalEObject ) newGraph , RDFPackage . LITERAL__GRAPH , msgs ) ; return msgs ; } public void setGraph ( RDFGraph newGraph ) { if ( newGraph != eInternalContainer ( ) || ( eContainerFeatureID ( ) != RDFPackage . LITERAL__GRAPH && newGraph != null ) ) { if ( EcoreUtil . isAncestor ( this , newGraph ) ) throw new IllegalArgumentException ( \"Recursive containment not allowed for \" + toString ( ) ) ; NotificationChain msgs = null ; if ( eInternalContainer ( ) != null ) msgs = eBasicRemoveFromContainer ( msgs ) ; if ( newGraph != null ) msgs = ( ( InternalEObject ) newGraph ) . eInverseAdd ( this , RDFPackage . RDF_GRAPH__LITERALS , RDFGraph . class , msgs ) ; msgs = basicSetGraph ( newGraph , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__GRAPH , newGraph , newGraph ) ) ; } @ Override public NotificationChain eInverseAdd ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case RDFPackage . LITERAL__GRAPH : if ( eInternalContainer ( ) != null ) msgs = eBasicRemoveFromContainer ( msgs ) ; return basicSetGraph ( ( RDFGraph", "gt": ") otherEnd , msgs ) ;", "prediction": ") otherEnd , msgs ) ;\n", "label": 1}
{"id": 5096, "input": "<s> package org . ofbiz . order . shoppingcart . product ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . order . shoppingcart . ShoppingCartEvents ; import org . ofbiz . order . shoppingcart . WebShoppingCart ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . webapp . website . WebSiteWorker ; public class ProductStoreCartAwareEvents { public static final String module = ProductStoreCartAwareEvents . class . getName ( ) ; public static String setSessionProductStore ( HttpServletRequest request , HttpServletResponse response ) { Map < String , Object > parameters = UtilHttp . getParameterMap ( request ) ; String productStoreId = ( String ) parameters . get ( \"productStoreId\" ) ; try { ProductStoreCartAwareEvents . setSessionProductStore ( productStoreId , request ) ; } catch ( Exception e ) { String errMsg = \"Problem setting new store: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } return \"success\" ; } public static void setSessionProductStore ( String productStoreId , HttpServletRequest request ) { if ( productStoreId == null ) { return ; } HttpSession session = request . getSession ( ) ; String oldProductStoreId = ( String ) session . getAttribute ( \"productStoreId\" ) ; if ( productStoreId . equals ( oldProductStoreId ) ) { return ; } Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; GenericValue productStore = ProductStoreWorker . getProductStore ( productStoreId , delegator ) ; if ( productStore == null ) { throw new IllegalArgumentException ( \"Cannot set session ProductStore, passed productStoreId [\" + productStoreId + \"] is not valid/not found.\" ) ; } GenericValue webSite = WebSiteWorker .", "gt": "getWebSite ( request ) ;", "prediction": "getWebSite ( ) ;\n", "label": 0}
{"id": 15766, "input": "<s> package org . apache . lucene . ant ; import java . io . IOException ; import org . apache . lucene . ant . DocumentTestCase ; import org . apache . lucene . ant . TextDocument ; public class TextDocumentTest extends DocumentTestCase { public TextDocumentTest ( String name ) { super ( name ) ; } TextDocument doc ; public void setUp ( ) throws IOException { doc = new TextDocument ( getFile ( \"test.txt\" ) ) ; } public void testDoc ( ) { assertEquals ( \"Contents\" , \"Test Contents\" , doc . getContents ( ) ) ; }", "gt": "public void tearDown ( )", "prediction": "}\n", "label": 1}
{"id": 1947, "input": "<s> package inheritDist ; public interface A {", "gt": "void m1 ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15768, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . ControlHolder ; import org . eclipse . swt . internal . widgets . ICompositeAdapter ; import org . eclipse . swt . internal . widgets . IControlHolderAdapter ; public class Composite extends Scrollable { private final ICompositeAdapter compositeAdapter ; private Layout layout ; int layoutCount ; private final ControlHolder controlHolder ; private Control [ ] tabList ; int backgroundMode ; Composite ( Composite parent ) { super ( parent ) ; controlHolder = new ControlHolder ( ) ; compositeAdapter = new CompositeAdapter ( ) ; } public Composite ( Composite parent , int style ) { super ( parent , style ) ; controlHolder = new ControlHolder ( ) ; compositeAdapter = new CompositeAdapter ( ) ; } @ Override void initState ( ) { if ( ( style & ( SWT . H_SCROLL | SWT . V_SCROLL ) ) == 0 ) { state |= THEME_BACKGROUND ; } } public Control [ ] getChildren ( ) { checkWidget ( ) ; return controlHolder . getControls ( ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Class < T > adapter ) { T result ; if ( adapter == IControlHolderAdapter . class ) { result = ( T ) controlHolder ; } else if ( adapter == ICompositeAdapter . class ) { result = ( T ) compositeAdapter ; } else { result = super . getAdapter ( adapter ) ; } return result ; } public void setLayout ( Layout layout ) { checkWidget ( ) ; this . layout = layout ; } public Layout getLayout ( ) { checkWidget ( ) ; return layout ; } public void setLayoutDeferred ( boolean defer ) { checkWidget ( ) ; if ( ! defer ) { if ( -- layoutCount == 0 ) { if ( ( state & LAYOUT_CHILD ) != 0 || ( state & LAYOUT_NEEDED ) != 0 ) { updateLayout ( true , true ) ; } } } else { layoutCount ++ ; } } public boolean getLayoutDeferred ( ) { checkWidget ( ) ; return layoutCount > 0 ; } public boolean isLayoutDeferred ( ) { checkWidget ( ) ; return findDeferredControl ( ) != null ; } public void layout ( ) { checkWidget ( ) ; layout ( true ) ; } public void layout ( boolean changed ) { checkWidget ( ) ; if ( layout != null ) { layout ( changed , false ) ; } } public void layout ( boolean changed , boolean all ) { checkWidget ( ) ; if ( layout != null || all ) { markLayout ( changed , all ) ; updateLayout ( true , all ) ; } } public void layout ( Control [ ] changed ) { checkWidget ( ) ; if ( changed == null ) { error ( SWT . ERROR_INVALID_ARGUMENT ) ; } layout ( changed , SWT . NONE ) ; } public void layout ( Control [ ] changed , int flags ) { checkWidget ( ) ; if ( changed != null ) { for", "gt": "( int i = 0 ;", "prediction": "( int i = 0 ;\n", "label": 1}
{"id": 9249, "input": "<s> package com . matburt . mobileorg . OrgData ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import android . text . format . DateUtils ; import android . util . Log ; public class OrgNodeDate { public long beginTime = 0 ; public long endTime = 0 ; public int allDay = 0 ; public String type = \"\" ; private static final SimpleDateFormat dateTimeformatter = new SimpleDateFormat ( \"yyyy-MM-dd HH:mm\" ) ; private static final SimpleDateFormat dateformatter = new SimpleDateFormat ( \"yyyy-MM-dd\" ) ; private static final int DATE = 1 ; private static final int BEGIN_TIME = 2 ; private static final int END_TIME = 3 ; private static final String datePattern = \"(\\\\d{1,2}\\\\:\\\\d{2})\" ; private static final Pattern schedulePattern = Pattern . compile ( \"(\\\\d{4}-\\\\d{2}-\\\\d{2})\" + \"(?:[^\\\\d]*)\" + datePattern + \"?\" + \"(?:\\\\-\" + datePattern + \")?\" ) ; public OrgNodeDate ( String date ) throws IllegalArgumentException { Matcher schedule = schedulePattern . matcher ( date ) ; if ( schedule . find ( ) ) { try { if ( schedule . group ( BEGIN_TIME ) == null ) { this . beginTime = dateformatter . parse ( schedule . group ( DATE ) ) . getTime ( ) ; this . beginTime = getDayInUTC ( beginTime ) ; this . endTime = this . beginTime + DateUtils . DAY_IN_MILLIS ; this . allDay = 1 ; } else if ( schedule . group ( BEGIN_TIME ) != null && schedule . group ( END_TIME ) != null ) { this . beginTime = dateTimeformatter . parse ( schedule . group ( DATE ) + \" \" + schedule . group ( BEGIN_TIME ) ) . getTime ( ) ; this . endTime = dateTimeformatter . parse ( schedule . group ( DATE ) + \" \" + schedule . group ( END_TIME ) ) . getTime ( ) ; this . allDay = 0 ; } else if ( schedule . group ( BEGIN_TIME ) != null ) { this . beginTime = dateTimeformatter . parse ( schedule . group ( DATE ) + \" \" + schedule . group ( BEGIN_TIME ) ) . getTime ( ) ; this . endTime = beginTime + DateUtils . HOUR_IN_MILLIS ; this . allDay = 0 ; } return ; } catch ( ParseException e ) { Log . w ( \"MobileOrg\" , \"Unable to parse schedule: \" + date ) ; } } else throw new IllegalArgumentException ( \"Could not create date out of entry\" ) ; } private static long getDayInUTC ( long time ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTimeInMillis ( time ) ; cal . set ( Calendar . HOUR , 0 ) ; cal", "gt": ". set ( Calendar . MINUTE , 0 ) ;", "prediction": ". set ( Calendar . MINUTE , 0 ) ;\n", "label": 0}
{"id": 15771, "input": "<s> package org . spliffy . server . web ; import com . bradmcevoy . http . Resource ; import com . bradmcevoy . http . exceptions . BadRequestException ; import com . bradmcevoy . http . exceptions . NotAuthorizedException ; import java . util . Date ; import org . spliffy . server . db . Organisation ; public abstract class AbstractCollectionResource extends AbstractResource implements SpliffyCollectionResource { private Date modDate ; private Date createdDate ; public AbstractCollectionResource ( Services services ) { super ( services ) ; } public AbstractCollectionResource ( Services services , Date createDate , Date modDate ) { super ( services ) ; this . createdDate = createDate ; this . modDate = modDate ; } @ Override public boolean isDir ( ) { return true ; } @ Override public Date getModifiedDate ( ) { return modDate ; } @", "gt": "Override public Date getCreateDate ( )", "prediction": "Override public Date getCreatedDate ( )\n", "label": 1}
{"id": 3101, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface PurgeResource extends ResourceAttribute { PurgeResourceAttribute getListAttribute ( ) ; void", "gt": "setListAttribute ( PurgeResourceAttribute value ) ;", "prediction": "setListAttribute ( PurgeResourceAttribute attribute ) ;\n", "label": 0}
{"id": 15773, "input": "<s> package monbulk . client ; import arc . mf . client . RemoteServer ; import arc . mf . session . DefaultLoginDialog ; import arc . mf . session . ErrorDialog ; import arc . mf . session . LoginDialog ; import arc . mf . session . Session ; import arc . mf . session . SessionHandler ; import arc . gui . gwt . widget . ContainerWidget ; import com . google . gwt . core . client . EntryPoint ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . RootPanel ; import monbulk . MediaFlux . Services . MediaFluxServices ; import monbulk . client . desktop . * ; import monbulk . client . desktop . Apps . DarisInterface ; import monbulk . shared . util . GWTLogger ; import monbulk . MetadataEditor . MetadataEditor ; import monbulk . MetadataEditor . MetadataSelectWindow ; import monbulk . MethodBuilder . client . MethodBuilder ; import monbulk . MethodBuilder . client . PreviewWindow ; import monbulk . shared . Services . User ; import monbulk . shared . Services . UserService ; public class Monbulk implements EntryPoint { private static User s_user = null ; private static Settings s_settings = null ; public static Settings getSettings ( ) { return s_settings ; } public static User getUser ( ) { return s_user ; } public void onModuleLoad ( ) { String hostName = Window . Location . getHostName ( ) ; if ( hostName . equals ( \"127.0.0.1\" ) || hostName . equals ( \"localhost\" ) ) { debugLogon ( ) ; String user = Window . Location . getParameter ( \"user\" ) ; GWTLogger . isDebug = user == null || ! user . equals ( \"izzo\" ) ; } else { showLogin ( ) ; GWTLogger . isDebug = false ; } } private void showLogin ( ) { Session . setLoginTitle ( \"Monbulk Logon\" ) ; LoginDialog dlg = new DefaultLoginDialog ( ) ; dlg . setVersion ( Version . VERSION ) ; dlg . setTitle ( \"Monbulk\" ) ; Session . setLoginDialog ( dlg ) ; initialise ( ) ; } private void debugLogon ( ) { String user = Window . Location . getParameter ( \"user\" ) ; if ( user != null && user . equals ( \"izzo\" ) ) { RemoteServer . SVC_URL = \"http://medimage.versi.edu.au:443\" + RemoteServer . SVC_URL ; } else { RemoteServer . SVC_URL", "gt": "= \"http://localhost:81\" + RemoteServer . SVC_URL ;", "prediction": "= \"http://medimage.versi.edu.au:443\" ;\n", "label": 1}
{"id": 5610, "input": "<s> package org . gk . engine . client . build . page ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class PageBuilder extends Builder { public PageBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List subNodes = new gkList ( ) ; XPage page = new", "gt": "XPage ( node , subNodes ) ;", "prediction": "XPage ( ) ;\n", "label": 0}
{"id": 15775, "input": "<s> package org . modelgoon . jdt . editparts ; import java . util . ArrayList ; import java . util . List ; import org . modelgoon . core . ModelElement ; import org . modelgoon . core . ui . RootElementEditPart ; import org . modelgoon . jdt . model . UMLClass ; import org . modelgoon . jdt . model . UMLModel ; public class JDTClassDiagramEditPart extends RootElementEditPart < UMLModel > { List < ModelElement > children = new ArrayList < ModelElement > ( ) ; public JDTClassDiagramEditPart ( ) { super ( ) ; addCreationCommand ( UMLClass . class , new CreateClassCommand ( this ) ) ; } @ Override protected List < ? > getModelChildren ( ) { this . children . clear ( ) ; UMLModel model = getModelElement ( ) ; this . children . addAll ( model . getClasses ( ) ) ; this . children .", "gt": "addAll ( model . getNotes ( ) ) ;", "prediction": "addAll ( model . getChildren ( ) ) ;\n", "label": 1}
{"id": 1559, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . tools . doclets . internal . toolkit . builders . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public abstract class AbstractDoclet { public Configuration configuration ; private static final String TOOLKIT_DOCLET_NAME = new com . sun . tools . doclets . formats . html . HtmlDoclet ( ) . getClass ( ) . getName ( ) ; private boolean isValidDoclet ( AbstractDoclet doclet ) { if ( ! doclet . getClass ( ) . getName ( ) . equals ( TOOLKIT_DOCLET_NAME ) ) { configuration . message . error ( \"doclet.Toolkit_Usage_Violation\" , TOOLKIT_DOCLET_NAME ) ; return false ; } return true ; } public boolean start ( AbstractDoclet doclet , RootDoc root ) { configuration = configuration ( ) ; configuration . root = root ; if ( ! isValidDoclet ( doclet ) ) { return false ; } try { doclet . startGeneration ( root ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; return false ; } return true ; } public static LanguageVersion languageVersion ( ) { return LanguageVersion . JAVA_1_5 ; } public abstract Configuration configuration ( ) ; private void startGeneration ( RootDoc root ) throws Exception { if ( root . classes ( ) . length == 0 ) { configuration . message . error ( \"doclet.No_Public_Classes_To_Document\" ) ; return ; } configuration . setOptions ( ) ; configuration . getDocletSpecificMsg ( ) . notice ( \"doclet.build_version\" , configuration . getDocletSpecificBuildDate ( ) ) ; ClassTree classtree = new ClassTree ( configuration , configuration . nodeprecated ) ; generateClassFiles ( root , classtree ) ; if ( configuration . sourcepath != null && configuration . sourcepath . length ( ) > 0 ) { StringTokenizer pathTokens = new StringTokenizer ( configuration . sourcepath , String . valueOf ( File . pathSeparatorChar ) ) ; boolean first = true ; while ( pathTokens . hasMoreTokens ( ) ) { Util . copyDocFiles ( configuration , pathTokens . nextToken ( ) + File . separator , DocletConstants . DOC_FILES_DIR_NAME , first ) ; first = false ; } } PackageListWriter . generate ( configuration ) ; generatePackageFiles ( classtree ) ; generateOtherFiles ( root , classtree ) ; configuration . tagletManager . printReport ( ) ; } protected void generateOtherFiles ( RootDoc", "gt": "root , ClassTree classtree ) throws Exception", "prediction": "root ) throws Exception\n", "label": 0}
{"id": 15781, "input": "<s> package tk . blackwolf12333 . grieflog . data . block ; import org . bukkit . Bukkit ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . block . BlockFace ; import tk . blackwolf12333 . grieflog . PlayerSession ; import tk . blackwolf12333 . grieflog . utils . Events ; public class BlockBreakData extends BaseBlockData { public BlockBreakData ( Block block , String playerName , Integer gamemode ) { putBlock ( block ) ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; } public BlockBreakData ( Integer x , Integer y , Integer z , String world , String blockType , byte blockData , String playerName , Integer gamemode ) { this . blockX = x ; this . blockY = y ; this . blockZ = z ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; } public BlockBreakData ( String time , Integer x , Integer y , Integer z , String world , String blockType , byte blockData , String playerName , Integer gamemode ) { this . time = time ; this . blockX = x ; this . blockY = y ; this . blockZ = z ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; } @ Override public void rollback ( ) { try { World w = Bukkit . getWorld ( worldName ) ; Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; w . getBlockAt ( loc ) . setTypeIdAndData ( Material . getMaterial ( blockType ) . getId ( ) , blockData , true ) ; if ( blockType . contains ( \"DOOR\" ) ) { w . getBlockAt ( getOtherDoorBlock ( w . getBlockAt ( loc ) ) ) . setTypeIdAndData ( Material . getMaterial ( blockType ) . getId ( ) , blockData , true ) ; } } catch ( Exception e ) { } } @ Override public String getMinimal ( ) { return time + \" \" + playerName + \" broke \" + blockType . toLowerCase ( ) + \".\" ; } @ Override public boolean isInWorldEditSelectionOf ( PlayerSession player ) { Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; return player . getWorldEditSelection ( )", "gt": ". contains ( loc ) ;", "prediction": ". contains ( loc ) ;\n", "label": 1}
{"id": 7260, "input": "<s> package org . dawb . workbench . plotting . tools . fitting ; import uk . ac . diamond . scisoft . analysis . dataset . DoubleDataset ; import uk . ac . diamond . scisoft . analysis . dataset . IDataset ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IFunction ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IParameter ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IPeak ; public class NullPeak implements IPeak { @ Override public String getName ( ) { return null ; } @ Override public void setName ( String newName ) { } @ Override public double val ( double ... values ) { return 0 ; } @ Override public IParameter getParameter ( int index ) { return null ; } @ Override public IParameter [ ] getParameters ( ) { return null ; } @ Override public int getNoOfParameters ( ) { return 0 ; } @ Override public int getNoOfFunctions ( ) { return 0 ; } @ Override public IFunction getFunction ( int index ) { return null ; } @ Override public double getParameterValue ( int index ) { return 0 ; } @ Override public double [ ] getParameterValues ( ) { return null ; } @ Override public void setParameterValues ( double ... params ) { } @ Override public double partialDeriv ( int Parameter , double ... position ) { return 0 ; } @ Override public DoubleDataset makeDataset ( IDataset ... values ) { return null ; } @ Override public double residual ( boolean allValues , IDataset data , IDataset ... values ) { return 0 ; } @ Override public double getPosition ( ) { return 0 ; } @ Override public double getFWHM ( ) { return 0 ; } @ Override public double getArea ( ) { return 0 ; } @ Override public double getHeight ( ) { return 0 ; } @ Override public String getDescription ( ) { return null ; } @ Override", "gt": "public void setDescription ( String newDescription )", "prediction": "public void setDescription ( String description )\n", "label": 0}
{"id": 15783, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . constants ; public final class UserWorkspaceConstants { public static final String USERS_PERSONAL_WORKSPACES_ROOT = \"UserWorkspaces\" ; public static final String PERSONAL_WORKSPACE_LABEL = \"command.user.personal.workspace\" ;", "gt": "public static final String REPOSITORY_WORKSPACE_LABEL = \"command.user.return.to.repository\" ;", "prediction": "}\n", "label": 1}
{"id": 7001, "input": "<s> package com . example . business . jobflow ; import com . example . business . modelgen . table . model . Shipment ;", "gt": "public class ShipmentToDb extends DefaultDbExporterDescription", "prediction": "import com . example . business . modelgen . table . model . Customer ;\n", "label": 0}
{"id": 15788, "input": "<s> package org . eclipse . ui . internal ; public class DirtyPerspectiveMarker { public DirtyPerspectiveMarker ( String id ) { perspectiveId = id ; } public String perspectiveId ; public int hashCode ( ) { return perspectiveId . hashCode ( ) ; } public boolean equals ( Object o ) { if", "gt": "( o instanceof DirtyPerspectiveMarker )", "prediction": "( this == o ) return true ;\n", "label": 1}
{"id": 9487, "input": "<s> class MulticatchTypesMustBeDisjoint { class E1 extends Exception { } class E2 extends E1 { } void e1 ( ) throws E1 { } void e2 ( ) throws E2 { } void m ( ) { try { e1 ( ) ; e2 ( ) ; } catch (", "gt": "E1 | E2 e )", "prediction": "E1 e )\n", "label": 0}
{"id": 15790, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; public interface ChapterRef extends Chapter {", "gt": "Chapter getChapter ( ) ;", "prediction": "public String getTitle ( ) ;\n", "label": 1}
{"id": 6707, "input": "<s> package org . jboss . arquillian . android . enricher ; import java . lang . annotation . Annotation ; import java . util . logging . Logger ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . core . api . Instance ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . test . api . ArquillianResource ; import org . jboss . arquillian . test . spi . enricher . resource . ResourceProvider ; public class AndroidDeviceResourceProvider implements ResourceProvider { private static final Logger log = Logger .", "gt": "getLogger ( AndroidDeviceResourceProvider . class . getName ( ) ) ;", "prediction": "getLogger ( AndroidDeviceResourceProvider . class . getName ( ) ) ;\n", "label": 0}
{"id": 15796, "input": "<s> package org . gatein . common . util ; public class ConversionException extends Exception { private static final long serialVersionUID = 4647584036804084315L ; public ConversionException ( ) { } public ConversionException ( String message ) { super ( message ) ; } public ConversionException ( String message , Throwable cause ) { super ( message , cause ) ; }", "gt": "public ConversionException ( Throwable cause )", "prediction": "public ConversionException ( Throwable cause )\n", "label": 1}
{"id": 10120, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . List ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerNullRestritionImpl implements MobeelizerInternalCriterion { private final String field ; private final boolean isNull ; public MobeelizerNullRestritionImpl ( final String field , final boolean isNull ) { this . field = field ; this . isNull = isNull ; } @ Override public String addToQuery ( final List < String > selectionArgs , final MobeelizerAndroidModel model ) { return field + ( isNull ? \" is", "gt": "null\" : \" is not null\" ) ;", "prediction": "null\" : \" is not null\" ) ;\n", "label": 0}
{"id": 15797, "input": "<s> package localServices ; public class StatusException extends Exception { private static final long serialVersionUID = 1L ; private Status status ; public StatusException ( Status status ) { this . status = status ; } public StatusException ( Status status , String message ) { super ( message ) ; this", "gt": ". status = status ;", "prediction": ". status = status ;\n", "label": 1}
{"id": 9478, "input": "<s> import java . io . * ; public class TestSourceTab extends JavadocTester { private static final String BUG_ID = \"4510979\" ; private static final String TMP_SRC_DIR = \"tmpSrc\" ; private static final String OUTPUT_DIR1 = BUG_ID + \"-tabLengthEight\" ; private static final String OUTPUT_DIR2 = BUG_ID + \"-tabLengthFour\" ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS1 = new String [ ] { \"-d\" , OUTPUT_DIR1 , \"-sourcepath\" , TMP_SRC_DIR , \"-notimestamp\" , \"-linksource\" , TMP_SRC_DIR + FS + \"SingleTab\" + FS + \"C.java\" } ; private static final String [ ] ARGS2 = new String [ ] { \"-d\" , OUTPUT_DIR2 , \"-sourcepath\" , TMP_SRC_DIR , \"-notimestamp\" , \"-sourcetab\" , \"4\" , TMP_SRC_DIR + FS + \"DoubleTab\" + FS + \"C.java\" } ; private static final String [ ] [ ] FILES_TO_DIFF = { { OUTPUT_DIR1 + FS + \"src-html\" + FS + \"C.html\" , OUTPUT_DIR2 + FS + \"src-html\" + FS + \"C.html\" } , { OUTPUT_DIR1 + FS + \"C.html\" , OUTPUT_DIR2 + FS + \"C.html\" } } ; public static void main ( String [ ] args ) throws IOException { TestSourceTab tester = new TestSourceTab ( ) ; run ( tester , ARGS1 , TEST , NEGATED_TEST ) ; run ( tester , ARGS2 , TEST , NEGATED_TEST ) ; tester . runDiffs ( FILES_TO_DIFF ) ; } TestSourceTab ( ) throws IOException { initTabs ( new File ( SRC_DIR ) , new File ( TMP_SRC_DIR ) ) ; } void initTabs ( File from , File to ) throws IOException { for ( File f : from . listFiles ( ) ) { File t = new File ( to , f . getName ( ) ) ; if ( f . isDirectory ( ) ) { initTabs ( f , t ) ; } else if ( f . getName ( ) . endsWith ( \".java\" ) ) { write ( t , read ( f ) . replace ( \"\\\\t\" , \"\\t\" ) ) ; } } } String read ( File f ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; try { String line ; while ( ( line = in . readLine ( ) ) != null ) { sb . append ( line ) ; sb . append ( \"\\n\" ) ; } } finally { in . close ( ) ; } return sb . toString ( ) ; } void write ( File f , String s ) throws IOException { f . getParentFile ( ) . mkdirs ( ) ; Writer out = new FileWriter ( f ) ; try { out . write ( s ) ; } finally { out . close ( ) ; } } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return getClass (", "gt": ") . getName ( ) ;", "prediction": ") . getName ( ) ;\n", "label": 0}
{"id": 15803, "input": "<s> package com . poetry . controller ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . http . Cookie ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . beans . factory . annotation . Qualifier ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . ResponseBody ; import com . poetry . model . Poet ; import com . poetry . model . SignStatus ; import com . poetry . service . PoetService ; import com . poetry . util . SignUtils ; @ Controller public class SignController extends AbstractController { @ Autowired @ Qualifier ( \"authenticationManager\" ) protected AuthenticationManager authenticationManager ; @ Autowired protected PoetService poetService ; @ RequestMapping ( value = \"/service/signstatus\" , method = RequestMethod . GET ) @ ResponseBody public SignStatus getStatus ( ) { if ( SignUtils . isSignIn ( ) ) { return new SignStatus ( SignUtils . getSignedInUsername ( ) , \"success\" ) ; } else { return new SignStatus ( null , \"fail\" ) ; } } @ RequestMapping ( value = \"/service/signin\" , method = RequestMethod . POST ) @ ResponseBody public SignStatus login ( @ RequestParam ( \"j_username\" ) String username , @ RequestParam ( \"j_password\" ) String password , HttpServletResponse response ) { final UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; final Poet details = new Poet ( ) ; details . setUsername ( username ) ; token . setDetails ( details ) ; try { final Authentication auth = authenticationManager . authenticate ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; final Cookie cookie = new Cookie ( \"username\" , username ) ; cookie . setMaxAge ( 0 ) ; response . addCookie ( cookie ) ; return new SignStatus ( auth . getName ( ) , \"success\" ) ; } catch ( BadCredentialsException e ) { return new SignStatus ( null , \"fail\" ) ; } } @ RequestMapping ( value = \"/service/signout\" ) public void logout ( final HttpServletResponse response ) { final Cookie cookie = new Cookie ( \"username\" , null ) ; cookie . setMaxAge ( 0 ) ; response . addCookie ( cookie ) ; } @ RequestMapping ( value = \"/service/signup\" ) @ ResponseBody public SignStatus", "gt": "signup ( final Poet poet , final HttpServletResponse response )", "prediction": "logout ( final HttpServletResponse response )\n", "label": 1}
{"id": 7064, "input": "<s> package org . parboiled . support ; import static org . parboiled . common . Preconditions . * ; import java . util . Iterator ; @ SuppressWarnings ( { \"ConstantConditions\" } ) public class DefaultValueStack < V > implements ValueStack < V > { protected static class Element { protected final Object value ; protected final Element tail ; protected Element ( Object value , Element tail ) { this . value = value ; this . tail = tail ; } } protected Element head ; protected V tempValue ; public DefaultValueStack ( ) { } public DefaultValueStack ( Iterable < V > values ) { pushAll ( values ) ; } public boolean isEmpty ( ) { return head == null ; } public int size ( ) { Element cursor = head ; int size = 0 ; while ( cursor != null ) { size ++ ; cursor = cursor . tail ; } return size ; } public void clear ( ) { head = null ; } public Object takeSnapshot ( ) { return head ; } public void restoreSnapshot ( Object snapshot ) { try { head = ( Element ) snapshot ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( \"Given argument '\" + snapshot + \"' is not a valid snapshot element\" ) ; } } public void push ( V value ) { head = new Element ( value , head ) ; } public void push ( int down , V value ) { head = push ( down , value , head ) ; } private static Element push ( int down , Object value , Element head ) { if ( down == 0 ) return new Element ( value , head ) ; checkArgument ( head != null , \"Cannot push beyond the bottom of the stack\" ) ; if ( down > 0 ) return new Element ( head . value , push ( down - 1 , value , head . tail ) ) ; throw new IllegalArgumentException ( \"Argument 'down' must not be negative\" ) ; } public void pushAll ( V firstValue , V ... moreValues ) { push ( firstValue ) ; for ( V value : moreValues ) push ( value ) ; } public void pushAll ( Iterable < V > values ) { head = null ; for ( V value : values ) push ( value ) ; } public V pop ( ) { return pop ( 0 ) ; } public V pop ( int down ) { head = pop ( down , head ) ; V result = tempValue ; tempValue = null ; return result ; } @ SuppressWarnings ( \"unchecked\" ) private Element pop ( int down , Element head ) { checkArgument ( head != null , \"Cannot pop from beyond the bottom of the stack\" ) ; if ( down == 0 ) { tempValue = ( V ) head . value ; return head . tail ; } if ( down > 0 ) return new Element ( head . value , pop ( down - 1 , head . tail ) ) ; throw new IllegalArgumentException ( \"Argument 'down' must not be negative\" ) ; } public V peek ( ) { return peek ( 0 ) ; } @ SuppressWarnings ( { \"unchecked\" } ) public V peek ( int down ) { return ( V ) peek ( down , head ) ; } @ SuppressWarnings ( { \"ConstantConditions\" } ) private static Object peek ( int down , Element head ) { checkArgument ( head != null , \"Cannot peek beyond the bottom of the stack\" ) ; if ( down == 0 ) return head . value ; if ( down > 0 ) return peek ( down - 1 , head . tail ) ; throw new IllegalArgumentException ( \"Argument 'down' must not be negative\" ) ; } public void poke ( V value ) { poke ( 0 , value ) ; } public void poke ( int down , V value ) { head = poke ( down", "gt": ", value , head ) ;", "prediction": ", value , head ) ;\n", "label": 0}
{"id": 15806, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . * ; import org . apache . lucene . document . * ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import java . io . IOException ; import java . io . Reader ; public class TestPhraseQuery extends LuceneTestCase { public static final float SCORE_COMP_THRESH = 1e-6f ; private IndexSearcher searcher ; private PhraseQuery query ; private RAMDirectory directory ; public void setUp ( ) throws Exception { super . setUp ( ) ; directory = new RAMDirectory ( ) ; Analyzer analyzer = new Analyzer ( ) { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new WhitespaceTokenizer ( reader ) ; } public int getPositionIncrementGap ( String fieldName ) { return 100 ; } } ; IndexWriter writer = new IndexWriter ( directory , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"field\" , \"one two three four five\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; doc . add ( new Field ( \"repeated\" , \"this is a repeated field - first part\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; Fieldable repeatedField = new Field ( \"repeated\" , \"second part of a repeated field\" , Field . Store . YES , Field . Index . ANALYZED ) ; doc . add ( repeatedField ) ; doc . add ( new Field ( \"palindrome\" , \"one two three two one\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new Field ( \"nonexist\" , \"phrase exist notexist exist found\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new Field ( \"nonexist\" , \"phrase exist notexist exist found\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; writer . optimize ( ) ; writer . close ( ) ; searcher = new IndexSearcher ( directory ) ; query = new PhraseQuery ( ) ; } public void tearDown ( ) throws Exception { super . tearDown ( ) ; searcher . close ( ) ; directory . close ( ) ; } public void testNotCloseEnough ( ) throws Exception { query . setSlop ( 2 ) ; query . add ( new Term ( \"field\" , \"one\" ) ) ; query . add ( new Term ( \"field\" , \"five\" ) ) ; ScoreDoc [ ] hits = searcher . search ( query , null , 1000 ) . scoreDocs ; assertEquals ( 0 , hits . length ) ; QueryUtils . check ( query , searcher ) ; } public void testBarelyCloseEnough ( ) throws Exception { query . setSlop ( 3 ) ; query . add ( new Term ( \"field\" , \"one\" ) ) ; query . add ( new Term ( \"field\" , \"five\" ) ) ; ScoreDoc [ ] hits = searcher . search ( query , null , 1000 ) . scoreDocs ; assertEquals ( 1 , hits . length ) ; QueryUtils . check ( query , searcher ) ; } public void testExact ( ) throws Exception { query . add ( new Term (", "gt": "\"field\" , \"four\" ) ) ;", "prediction": "\"field\" , \"one\" ) ) ;\n", "label": 1}
{"id": 6287, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . AccountReport ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class AccountReportImpl extends PropertyImpl implements AccountReport { protected AccountReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage", "gt": ". eINSTANCE . getAccountReport ( ) ;", "prediction": ". Literals . ACCOUNT_REPORT ;\n", "label": 0}
{"id": 15812, "input": "<s> package monbulk . shared . Services ; import com . google . gwt . core . client . GWT ; import monbulk . shared . util . MonbulkEnums . * ; public abstract class UserService implements iService { public static UserService get ( ) { try { UserService service = ( UserService ) ServiceRegistry . getService ( ServiceNames . User ) ; return service ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( e . toString ( ) ) ; } return null ; } public interface GetUserHandler { public void onGetUser ( User user ) ; } public abstract void getUser ( String name , String domain , GetUserHandler handler ) ; public", "gt": "final ServiceNames getServiceType ( )", "prediction": "static UserService get ( )\n", "label": 1}
{"id": 5710, "input": "<s> package com . gisgraphy . client . language ; public interface LanguageRepository { Iso639Language findByAlpha2Code ( String code ) ;", "gt": "Iso639Language findByAlpha3Code ( String code ) ;", "prediction": "}\n", "label": 0}
{"id": 15815, "input": "<s> package org . eclipse . ui . tests . propertysheet ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IFolderLayout ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IPerspectiveFactory ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . tests . SelectionProviderView ; import org . eclipse . ui . tests . api . SaveableMockViewPart ; import org . eclipse . ui . tests . session . NonRestorableView ; public class PropertySheetPerspectiveFactory2 implements IPerspectiveFactory { public void createInitialLayout ( IPageLayout layout ) { String editorArea = layout . getEditorArea ( ) ; IFolderLayout bottomRight = layout . createFolder ( \"bottomRight\" , IPageLayout . BOTTOM , ( float ) 0.55 , editorArea ) ; bottomRight . addPlaceholder ( IPageLayout . ID_PROP_SHEET ) ; bottomRight . addPlaceholder ( SelectionProviderView . ID ) ; bottomRight . addPlaceholder", "gt": "( NonRestorableView . ID ) ;", "prediction": "( SaveableMockViewPart . ID ) ;\n", "label": 1}
{"id": 1639, "input": "<s> package me . tomjw64 . MaxHealth ; import java . util . HashMap ; import java . util . Map ; import org . bukkit . Bukkit ; import org . bukkit . entity . Player ; public class PlayerManager { private static Map < String , PlayerHook > hookList = new HashMap < String , PlayerHook > ( ) ; public static void register ( Player p , MaxHealth plugin ) { PlayerHook hook = new PlayerHook ( p , plugin ) ; hookList . put ( p . getName ( ) , hook ) ; } public static void unRegister ( Player p , MaxHealth plugin ) { String name = p . getName ( ) ; PlayerHook pHook = hookList . get ( name ) ; pHook . loadToDB ( ) ; pHook = null ; hookList . remove ( name ) ; } public static PlayerHook getHook ( Player p ) { return hookList", "gt": ". get ( p . getName ( ) ) ;", "prediction": ". get ( p . getName ( ) ) ;\n", "label": 0}
{"id": 15832, "input": "<s> package com . yahoo . ycsb ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import com . yahoo . ycsb . client . MasterClient ; public class LoadGenerator { @ SuppressWarnings ( \"rawtypes\" ) public static void main ( String [ ] args ) { Config config = Config . getConfig ( ) ; Properties props = new Properties ( ) ; Properties fileprops = new Properties ( ) ; boolean dotransactions = true ; int threadcount = 1 ; int target = 0 ; String label = \"\" ; int argindex = 0 ; if ( args . length == 0 ) { usageMessage ( ) ; System . exit ( 0 ) ; } while ( args [ argindex ] . startsWith ( \"-\" ) ) { if ( args [ argindex ] . compareTo ( \"-threads\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; int tcount = Integer . parseInt ( args [ argindex ] ) ; config . thread_count = tcount ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-target\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; int ttarget = Integer . parseInt ( args [ argindex ] ) ; config . target = ttarget ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-load\" ) == 0 ) { config . do_transactions = false ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-t\" ) == 0 ) { config . do_transactions = true ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-db\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; config . db = args [ argindex ] ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-l\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; label = args [ argindex ] ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-P\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; String propfile = args [ argindex ] ; argindex ++ ; Properties myfileprops = new Properties ( ) ; try { myfileprops . load ( new FileInputStream ( propfile ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; System . exit ( 0 ) ; } for ( Enumeration e = myfileprops . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String prop = ( String ) e . nextElement ( ) ; fileprops . setProperty ( prop , myfileprops . getProperty ( prop ) ) ; config . setProperty ( prop , myfileprops . getProperty ( prop ) ) ; } } else if ( args [ argindex ] . compareTo ( \"-p\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; int eq = args [ argindex ] . indexOf ( '=' ) ; if ( eq < 0 ) { usageMessage ( ) ; System . exit ( 0 ) ; } String name = args [ argindex ] . substring ( 0 , eq ) ; String value = args [ argindex ] . substring (", "gt": "eq + 1 ) ;", "prediction": "eq + 1 ) ;\n", "label": 1}
{"id": 759, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . vorstellungswaehler ; import java . awt . BorderLayout ; import javax . swing . BorderFactory ; import javax . swing . JLabel ; import javax . swing . JList ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . ListSelectionModel ; class VorstellungAuswaehlWerkzeugUI { private JPanel _hauptPanel ; private JList _vorstellungAuswahlList ; public VorstellungAuswaehlWerkzeugUI ( ) { _hauptPanel = erstellePanel ( ) ; } private JPanel erstellePanel ( ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BorderLayout ( 0 , 4 ) ) ; panel . add ( new JLabel ( \"Vorstellung:\" ) , BorderLayout . NORTH ) ; _vorstellungAuswahlList =", "gt": "new JList ( ) ;", "prediction": "new JList ( ) ;\n", "label": 0}
{"id": 15834, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . compatible . controllers ; import android . support . v4 . app . FragmentActivity ; public class BlandBubbleController extends AbstractBubbleController { public BlandBubbleController ( FragmentActivity activity ) { super ( activity ) ; } @", "gt": "Override public void onBubbleAttachedToWindow ( )", "prediction": "Override public void onCreate ( Bundle savedInstanceState )\n", "label": 1}
{"id": 5620, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . errors . GrammarException ; import org . parboiled . matchervisitors . MatcherVisitor ; public class ZeroOrMoreMatcher extends CustomDefaultLabelMatcher < ZeroOrMoreMatcher > { public final Matcher subMatcher ; public ZeroOrMoreMatcher ( Rule subRule ) { super ( checkArgNotNull ( subRule , \"subRule\" ) , \"ZeroOrMore\" ) ; this . subMatcher = getChildren ( ) . get ( 0 ) ; } public boolean match ( MatcherContext context ) { checkArgNotNull ( context , \"context\" ) ; int lastIndex = context", "gt": ". getCurrentIndex ( ) ;", "prediction": ". getLastIndexOf ( subRule ) ;\n", "label": 0}
{"id": 15835, "input": "<s> package org . gatein . common . i18n ; import junit . framework . TestCase ; import org . gatein . common . i18n . BundleName ; public class BundleNameParserTestCase extends TestCase { private final BundleName . Parser parser = new BundleName . Parser ( ) ; private static final Test [ ] tests = { new Test ( \"_\" , null ) , new Test ( \"__\" , null ) , new Test ( \"___\" , null ) , new Test ( \"a\" , new BundleName ( \"a\" ) ) , new Test ( \"a_b\" , new BundleName ( \"a\" , \"b\" ) ) , new Test ( \"a_b_c\" , new BundleName ( \"a\" , \"b\" , \"c\" ) ) , new Test ( \"a__b\" , new BundleName ( \"a\" , \"\" , \"b\" ) ) , new Test ( \"a___b\" , new BundleName ( \"a\" , \"\" , \"\" , \"b\" ) ) , new Test ( \"a__b_c\" , new BundleName ( \"a\" , \"\" , \"b\" , \"c\" ) ) , new Test ( \"a_b__c\" , new BundleName ( \"a\" , \"b\" , \"\" , \"c\" ) ) , new Test ( \"a_b_c_d\" , new BundleName ( \"a\" , \"b\" , \"c\" , \"d\" ) ) , new Test ( \"\" , new BundleName ( \"\" ) ) , new Test ( \"_b\" , new BundleName ( \"\" , \"b\" ) ) , new Test ( \"_b_c\" , new BundleName ( \"\" , \"b\" , \"c\" ) ) , new Test ( \"__b\" , new BundleName ( \"\" , \"\" , \"b\" ) ) , new Test ( \"___b\" , new BundleName ( \"\" , \"\" , \"\" , \"b\" ) ) , new Test ( \"__b_c\" , new BundleName ( \"\" , \"\" , \"b\" , \"c\" ) ) , new Test ( \"_b__c\" , new BundleName ( \"\" , \"b\" , \"\" , \"c\" ) ) , new Test ( \"_b_c_d\" , new BundleName ( \"\" , \"b\" , \"c\" , \"d\" ) ) , } ; public void testA ( ) { for ( int i = 0 ; i < tests . length ; i ++ ) { Test test = tests [ i ] ; BundleName name = parser . parse ( test . input , 0 , test . input . length ( ) ) ; if ( name == null ) { assertNull ( test . input , test . expectedName ) ; } else { assertNotNull ( test . input , test . expectedName ) ; assertEquals ( test . input , test . expectedName .", "gt": "getBaseName ( ) , name . getBaseName ( ) ) ;", "prediction": "toLowerCase ( ) ) ;\n", "label": 1}
{"id": 3080, "input": "<s> package me . chester . test ; import static org . mockito . Mockito . mock ; import junit . framework . TestCase ; import me . chester . minitruco . android . CartaVisual ; import me . chester . minitruco . android . MesaView ; import me . chester . minitruco . core . Carta ; import me . chester . minitruco . core . JogadorCPU ; import me . chester . minitruco . core . Jogo ; import me . chester . minitruco . core . JogoLocal ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import android . graphics . Canvas ; import android . util . Log ; import com . xtremelabs . robolectric . Robolectric ; import com . xtremelabs . robolectric . RobolectricTestRunner ; import com . xtremelabs . robolectric . util . Implements ; @ RunWith ( RobolectricTestRunner . class ) public class JogoTest extends TestCase { @ Implements ( Log . class ) public static class ShadowLog { public static int i ( java . lang . String tag , java . lang . String msg ) { System . out . println ( \"[\" + tag + \"] \" + msg ) ; return 0 ; } } @ Before public void setUp ( ) throws Exception { Robolectric . bindShadowClass ( ShadowLog . class ) ; } @ Test public void testAnimacaoCartaNoTempo ( ) throws InterruptedException { MesaView mesa = mock ( MesaView . class ) ; CartaVisual cv = new CartaVisual ( mesa , 33 , 66 , null ) ; assertEquals ( 33 , cv . left ) ; assertEquals ( 66 , cv . top ) ; Canvas canvas = new Canvas ( ) ; cv . movePara ( 10 , 20 ) ; assertEquals ( 10 , cv . left ) ; assertEquals ( 20 , cv . top ) ; cv . movePara ( 0 , 0 ) ; cv . movePara ( 300 , 100 , 3000 ) ; Thread . sleep ( 1000 ) ; cv . draw ( canvas ) ; assertTrue ( \"Carta devia andar 100 no x, andou \" + cv . left , cv . left >= 100 ) ; assertTrue ( \"Carta n\u00e3o pode andar al\u00e9m de 200 no X, andou \" + cv . left , cv . left <= 200 ) ; assertTrue ( \"Carta tem que andar 33 no Y. andou \" + cv . top , cv . top >= 33 ) ; assertTrue ( \"Carta n\u00e3o pode andar al\u00e9m de 66 no Y, andou \" + cv . top , cv . top <= 66 ) ; Thread . sleep ( 2100 ) ; cv . draw ( canvas ) ; assertEquals ( \"Carta tem que chegar ao 300 no X, chegou em \" + cv . left , cv . left , 300 ) ; assertEquals ( \"Carta tem que chegar aos 100 no Y, chegou em \" + cv . top , cv . top , 100 ) ; cv . movePara ( 0 , 0 , 3000 ) ; Thread . sleep ( 1000 ) ; cv . draw ( canvas ) ; assertTrue ( \"Carta devia andar -100 no x, esta em \" + cv . left , cv . left <= 200 ) ; assertTrue ( \"Carta n\u00e3o pode andar al\u00e9m de -200 no X, esta em \" + cv . left , cv . left >= 100 ) ; assertTrue ( \"Carta tem que andar -33 no Y. esta em \" + cv . top , cv . top <= 67 ) ; assertTrue ( \"Carta n\u00e3o pode andar al\u00e9m de -66 no Y, esta em \" + cv . top , cv . top >= 32 ) ; Thread . sleep ( 2100 ) ; cv . draw ( canvas ) ; assertEquals ( \"Carta tem que chegar ao 0 no X, chegou em \" + cv . left , cv . left , 0 ) ; assertEquals ( \"Carta tem que chegar ao 0 no Y, chegou em \" + cv . top , cv . top , 0 ) ; } @ Test public void testTamanhoDaCartaAutoAjustadoAoDoCanvas ( ) { int [ ] [ ] telas = { { 320 , 200 } , { 200 , 320 } , { 640 , 480 } , { 120 , 240 } , { 240 , 120 } } ; for ( int [ ] tela : telas ) { int width = tela [ 0 ] ; int height = tela [ 1 ] ; CartaVisual . ajustaTamanho ( width , height ) ; String result = \"Tela \" + width + \",\" + height + \" =>  carta \" + CartaVisual . largura + \",\" + CartaVisual . altura ; assertTrue ( CartaVisual . largura > 0 ) ; assertTrue ( CartaVisual . altura > 0 ) ; assertTrue ( \"Tem que caber 6 cartas na largura. \" + result , CartaVisual . largura * 6 <= width ) ; assertTrue ( \"Tem que caber 5 cartas na altura. \" + result , CartaVisual . altura * 5 <= height ) ; } } @ Test public void testEqualsEntreCartaECartaVisual ( ) { Carta [ ] cartas = { new Carta ( \"Ap\" ) , new Carta ( \"5o\" ) , new Carta ( \"3p\" ) } ; CartaVisual [ ] cartasvisuais = { new CartaVisual ( null , 0 , 0 , \"Ap\" ) , new CartaVisual ( null , 0 , 0 , \"5o\" ) , new CartaVisual ( null , 0 , 0 , \"3p\" ) } ; for ( int i = 0 ; i < cartas . length ; i ++ ) { for ( int j = 0 ; j < cartasvisuais . length ; j ++ ) { if ( i == j ) { assertTrue ( \"Carta \" + cartas [ i ] + \" devia ser equals a CartaVisual \" + cartasvisuais [ j ] , cartas [ i ] . equals ( cartasvisuais [ j ] ) ) ; assertTrue ( \"CartaVisual \" + cartasvisuais [ j ] + \" devia ser equals a Carta \" + cartasvisuais [ j ] , cartasvisuais [ j ] . equals ( cartas [ i ] ) ) ; } else { assertFalse ( \"Carta \" + cartas [ i ] + \" n\u00e3o devia ser equals a CartaVisual \" + cartasvisuais [ j ] , cartas [ i ] . equals ( cartasvisuais [ j ] ) ) ; assertFalse ( \"CartaVisual \" + cartasvisuais [ j ] + \" n\u00e3o devia ser equals a Carta \" + cartasvisuais [ j ] , cartasvisuais [ j ] . equals ( cartas [ i ] ) ) ; } } } } @ Test public void testJogoSemNenhumAumento ( ) { Jogo jogo = new JogoLocal ( false , false , false ) ; assertTrue ( jogo . adiciona (", "gt": "new JogadorMock ( ) ) ) ;", "prediction": "0 ) ) ;\n", "label": 0}
{"id": 15851, "input": "<s> package org . eclipse . rap . demo ; import java . net . URL ; import java . util . Dictionary ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . * ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . wizard . WizardDialog ; import org . eclipse . rap . demo . editor . FooEditorInput ; import org . eclipse . rap . demo . wizard . SurveyWizard ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . * ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . actions . ContributionItemFactory ; import org . eclipse . ui . actions . ActionFactory . IWorkbenchAction ; import org . eclipse . ui . application . ActionBarAdvisor ; import org . eclipse . ui . application . IActionBarConfigurer ; import org . eclipse . ui . browser . IWebBrowser ; import org . eclipse . ui . browser . IWorkbenchBrowserSupport ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . * ; public class DemoActionBarAdvisor extends ActionBarAdvisor { private IWebBrowser browser ; private IWorkbenchAction exitAction ; private IWorkbenchAction importAction ; private IWorkbenchAction exportAction ; private Action aboutAction ; private Action rapWebSiteAction ; private MenuManager showViewMenuMgr ; private IWorkbenchAction preferencesAction ; private Action wizardAction ; private Action browserAction ; public IWorkbenchAction saveAction ; private IWorkbenchAction saveAllAction ; private Action newEditorAction ; private static int browserIndex ; public DemoActionBarAdvisor ( final IActionBarConfigurer configurer ) { super ( configurer ) ; } protected void makeActions ( final IWorkbenchWindow window ) { ImageDescriptor quitActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/ttt.gif\" ) ; ImageDescriptor helpActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/help.gif\" ) ; ImageDescriptor wizardActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/login.gif\" ) ; ImageDescriptor browserActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/internal_browser.gif\" ) ; ImageDescriptor rapWebSiteActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/browser.gif\" ) ; exitAction = ActionFactory . QUIT . create ( window ) ; exitAction . setImageDescriptor ( quitActionImage ) ; register ( exitAction ) ; importAction = ActionFactory . IMPORT . create ( window ) ; register ( importAction ) ; exportAction = ActionFactory . EXPORT . create ( window ) ; register ( exportAction ) ; saveAction = ActionFactory . SAVE . create ( window ) ; register ( saveAction ) ; saveAllAction = ActionFactory . SAVE_ALL . create ( window ) ; register ( saveAllAction ) ; preferencesAction = ActionFactory . PREFERENCES . create ( window ) ; register ( preferencesAction ) ; newEditorAction = new Action ( ) { public void run ( ) { try { window . getActivePage ( ) . openEditor ( new FooEditorInput ( DemoActionBarAdvisor . this ) , \"org.eclipse.rap.demo.editor\" , true ) ; } catch ( PartInitException e ) { e . printStackTrace ( ) ; } } } ; newEditorAction . setText ( \"Open new editor\" ) ; newEditorAction . setId ( \"org.eclipse.rap.demo.neweditor\" ) ; newEditorAction . setImageDescriptor ( window . getWorkbench ( ) . getSharedImages ( ) . getImageDescriptor ( ISharedImages . IMG_TOOL_NEW_WIZARD ) ) ; register ( newEditorAction ) ; aboutAction = new Action ( ) { public void run ( ) { Shell shell = window . getShell ( ) ; Bundle bundle = Platform . getBundle ( PlatformUI . PLUGIN_ID ) ; Dictionary headers = bundle . getHeaders ( ) ; Object version = headers . get ( Constants . BUNDLE_VERSION ) ; MessageDialog . openInformation ( shell , \"RAP Workbench Demo\" , \"Running on RAP version \" + version ) ; } } ; aboutAction . setText ( \"About\" ) ; aboutAction . setId ( \"org.eclipse.rap.demo.about\" ) ; aboutAction . setImageDescriptor ( helpActionImage ) ; register ( aboutAction ) ; rapWebSiteAction = new Action ( ) { public void run ( ) { IWorkbenchBrowserSupport browserSupport ; browserSupport = PlatformUI . getWorkbench ( ) . getBrowserSupport ( ) ; try { int style = IWorkbenchBrowserSupport . AS_EXTERNAL ; browser = browserSupport . createBrowser ( style , rapWebSiteAction . getId ( ) , \"\" , \"\" ) ; browser . openURL ( new URL ( \"http://eclipse.org/rap\" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; rapWebSiteAction . setText ( \"RAP Home Page\" ) ; rapWebSiteAction . setId ( \"org.eclipse.rap.demo.rapWebSite\" ) ; rapWebSiteAction . setImageDescriptor ( rapWebSiteActionImage ) ; register ( rapWebSiteAction ) ; showViewMenuMgr = new MenuManager ( \"Show View\" , \"showView\" ) ; IContributionItem showViewMenu = ContributionItemFactory . VIEWS_SHORTLIST . create ( window ) ; showViewMenuMgr . add ( showViewMenu ) ; wizardAction = new Action ( ) { public void run ( ) { SurveyWizard wizard = new SurveyWizard ( ) ; WizardDialog dlg = new WizardDialog ( window . getShell ( ) , wizard ) ; dlg . open ( ) ; } } ; wizardAction . setText ( \"Open wizard\" ) ; wizardAction . setId ( \"org.eclipse.rap.demo.wizard\" ) ; wizardAction . setImageDescriptor ( wizardActionImage ) ; register ( wizardAction ) ; browserAction = new Action ( ) { public void run ( ) { browserIndex ++ ; try { window . getActivePage ( ) . showView ( \"org.eclipse.rap.demo.DemoBrowserViewPart\" , String . valueOf ( browserIndex ) , IWorkbenchPage . VIEW_ACTIVATE ) ; } catch ( PartInitException e ) { e . printStackTrace ( ) ; } } } ; browserAction . setText ( \"Open new Browser View\" ) ;", "gt": "browserAction . setId ( \"org.eclipse.rap.demo.browser\" ) ;", "prediction": "browserAction . setId ( \"org.eclipse.rap.demo.wizard\" ) ;\n", "label": 1}
{"id": 1468, "input": "<s> import com . sun . source . util . JavacTask ; import java . io . IOException ; import java . net . URI ; import java . util . Arrays ; import java . util . List ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . ToolProvider ; import static javax . tools . JavaFileObject . Kind ; public class T6608214 { public static void main ( String [ ] args ) throws IOException { JavaFileObject sfo = new SimpleJavaFileObject ( URI . create ( \"\" ) , Kind . SOURCE ) { public CharSequence getCharContent ( boolean ignoreEncodingErrors ) { return \"class Test<S> { <T extends S & Runnable> void test(){}}\" ; } } ; List < ? extends JavaFileObject > files = Arrays", "gt": ". asList ( sfo ) ;", "prediction": ". asList ( sfo ) ;\n", "label": 0}
{"id": 15856, "input": "<s> package org . restlet . ext . jdbc ; import java . io . Serializable ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; public class JdbcResult implements Serializable { private static final long serialVersionUID = 1L ; private volatile transient Statement statement ; public JdbcResult ( Statement statement ) { this . statement = statement ; } public ResultSet getGeneratedKeys ( ) throws SQLException { return this . statement . getGeneratedKeys ( ) ; } public ResultSet", "gt": "getResultSet ( ) throws SQLException", "prediction": "execute ( ) throws SQLException\n", "label": 1}
{"id": 1266, "input": "<s> enum EnumPublicConstructor { RED ( 255 , 0 , 0 ) , GREEN ( 0 , 255 , 0 ) , BLUE ( 0 , 0 , 255 ) ; private int r , g , b ; public EnumPublicConstructor ( int r , int g , int b ) { this . r = r ;", "gt": "this . g = g ;", "prediction": "this . g = g ;\n", "label": 0}
{"id": 15860, "input": "<s> package br . org . archimedes . controller . commands ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; public abstract class ZoomCommand implements UndoableCommand { private double previousZoom ; private Point previousViewport ; private double newZoom ; private Point newViewport ; public ZoomCommand ( ) { previousZoom = - 1 ; previousViewport = null ; } public void doIt ( Drawing drawing ) throws IllegalActionException , NullArgumentException { if ( drawing == null ) { throw new NullArgumentException ( ) ; } if ( previousZoom < 0 ) { previousZoom = drawing . getZoom ( ) ; previousViewport = drawing . getViewportPosition ( ) ; newZoom = calculateZoom ( drawing ) ; newViewport = getNewViewport ( drawing ) ; } if ( newZoom > Constant . ZOOM_SUPERIOR_LIMIT ) { newZoom = previousZoom ; newViewport = previousViewport ; throw new IllegalActionException", "gt": "( Messages . Zoom_reachedMax ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8736, "input": "<s> package org . msl . simple . gmf . bridge . transform ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . gmf . internal . bridge . ui . Plugin ; import org . eclipse . gmf . internal . common . ui . ModelSelectionPage ; import org . eclipse . gmf . internal . common . ui . ResourceLocationProvider ; import org . eclipse . jface . dialogs . IMessageProvider ; import org . eclipse . ui . actions . WorkspaceModifyOperation ; public class ModelConfigurationPage extends ModelSelectionPage { public ModelConfigurationPage ( String pageId , ResourceLocationProvider rlp , ResourceSet resourceSet ) { super ( pageId , rlp , resourceSet ) ; } @ Override protected Resource loadResource ( ) { Resource current = getResource ( ) ; if ( current != null ) { current . getResourceSet ( ) . getResources ( ) . remove ( current ) ; } final Resource [ ] result = new Resource [ 1 ] ; WorkspaceModifyOperation initializeOperation = new WorkspaceModifyOperation ( ) { protected void execute ( IProgressMonitor progressMonitor ) throws CoreException { IProgressMonitor monitor = null ; try { monitor = ( progressMonitor != null ) ? new SubProgressMonitor ( progressMonitor , 1 , SubProgressMonitor . PREPEND_MAIN_LABEL_TO_SUBTASK ) : new NullProgressMonitor ( ) ; setStatusMessage ( Status . OK_STATUS ) ; result [ 0 ] = doLoadResource ( monitor ) ; } catch ( CoreException exception ) { throw exception ; } catch ( Exception exception ) { throw new CoreException ( Plugin . createError ( exception . getMessage ( ) , exception ) ) ; } finally { if ( monitor != null ) { monitor . done ( ) ; } } } } ; try { getContainer ( ) . run ( false , false , initializeOperation ) ; setStatusMessage ( Status . OK_STATUS ) ; } catch ( InvocationTargetException e ) { Throwable target = e . getTargetException ( ) ; if ( target instanceof CoreException ) { CoreException ce = ( CoreException ) target ; setStatusMessage ( ce .", "gt": "getStatus ( ) ) ;", "prediction": "getStatus ( ) ) ;\n", "label": 0}
{"id": 15865, "input": "<s> package com . emf4sw . rdf . resource ;", "gt": "public interface N3Resource extends RDFResource", "prediction": "import org . eclipse . emf . common . util . EList ;\n", "label": 1}
{"id": 3701, "input": "<s> package com . example . wordcount . jobflow . gateway ; import org . apache . hadoop . mapreduce . lib . output . FileOutputFormat ; import org . apache . hadoop . mapreduce . lib . output . TextOutputFormat ; import com . asakusafw . vocabulary . external . FileExporterDescription ; import com . example . wordcount . modelgen . dmdl . model . WordCount ; public class WordCountToHdfs extends FileExporterDescription { @ SuppressWarnings ( \"rawtypes\" ) @ Override public", "gt": "Class < ? extends FileOutputFormat > getOutputFormat ( )", "prediction": "void exportDocument ( DocumentModel doc , OutputStream out ) throws IOException\n", "label": 0}
{"id": 15868, "input": "<s> package com . corundumstudio . socketio . parser ; import java . util . Collections ; import java . util . List ; import org . jboss . netty . util . CharsetUtil ; public class Packet { public static final char DELIMITER = '\ufffd' ; public static final byte [ ] DELIMITER_BYTES = new String ( new char [ ] { DELIMITER } ) . getBytes ( CharsetUtil . UTF_8 ) ; public static final byte SEPARATOR = ':' ; public static final String ACK_DATA = \"data\" ; public static final Packet NULL_INSTANCE = new Packet ( null ) ; private final PacketType type ; private List < ? > args = Collections . emptyList ( ) ; private String qs ; private Object ack ; private Long ackId ; private String name ; private Long id ; private String endpoint ; private Object data ; private ErrorReason reason ; private ErrorAdvice advice ; public Packet ( PacketType type ) { super ( ) ; this . type = type ; } public PacketType getType ( ) { return type ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getEndpoint ( ) { return endpoint ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public void setAck ( Object ack ) { this . ack = ack ; } public Object getAck ( ) { return ack ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public List < ? > getArgs ( ) { return args ; } public void setArgs ( List < ? > args ) { this . args = args ; } public String getQs ( ) { return qs ; } public void setQs ( String qs ) { this . qs = qs ; } public Long getAckId ( ) { return ackId ; } public void setAckId ( Long ackId ) { this . ackId = ackId ; } public ErrorReason getReason ( ) { return reason ; } public void setReason ( ErrorReason reason ) { this . reason = reason ; } public ErrorAdvice getAdvice ( ) { return advice ; } public", "gt": "void setAdvice ( ErrorAdvice advice )", "prediction": "void setAdvice ( ErrorAdvice advice )\n", "label": 1}
{"id": 3552, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; import redstone . xmlrpc . XmlRpcArray ; public class TestPlan { public Integer product_id ; public Boolean is_active ; public XmlRpcArray tag ; public String parent ; public XmlRpcArray attachment ; public String type ; public String default_product_version ; public Integer type_id ; public Integer plan_id ; public String product ; public XmlRpcArray env_group ; public String author ; public String create_date ; public XmlRpcArray component ; public String name ; public Integer owner_id ; public String owner ; public Integer author_id ; public String extra_link ; public XmlRpcArray caseVar ; public String parent_id ; public static class add_tag extends TcmsArrayCommand { @ RequiredField public Integer [ ] plan_ids ; @ RequiredField public String [ ] tags ; } public static class check_plan_type extends TcmsArrayCommand { @ RequiredField public String name ; } public static class create extends TcmsHashCommand { @ RequiredField public Integer product ; @ RequiredField public String name ; @ RequiredField public Integer type ; @ RequiredField public Integer default_product_version ; @ RequiredField public String text ; public Integer parent ; public Boolean is_active ; } public static class get extends TcmsArrayCommand { @ RequiredField public Integer id ; } ; public static class get_change_history extends TestPlan . get { } public static class get_env_groups extends TestPlan . get { } public static class get_plan_type extends TestPlan . get { } public static class get_product extends TestPlan . get { } public static class get_tags extends TestPlan . get { } public static class get_test_cases extends TestPlan . get { } public static class get_test_runs extends TestPlan . get { } public static class get_text extends TestPlan . get { } public static class remove_tag extends TcmsArrayCommand { @ RequiredField public Integer plan_id ; @ RequiredField public String tag ; }", "gt": "public static class store_text extends TcmsArrayCommand", "prediction": "}\n", "label": 0}
{"id": 15871, "input": "<s> package org . eclipse . ui . internal . wizards ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class ImportWizardRegistry extends AbstractExtensionWizardRegistry { public static synchronized ImportWizardRegistry getInstance ( ) { return SingletonUtil", "gt": ". getSessionInstance ( ImportWizardRegistry . class ) ;", "prediction": ". getInstance ( ImportWizardRegistry . class ) ;\n", "label": 1}
{"id": 3620, "input": "<s> package com . mcbans . mcbans . calls ; import com . mcbans . mcbans . MCBansPlugin ; import com . mcbans . mcbans . utils . JSONHandler ; import com . mcbans . mcbans . utils . PlayerMethods ; import java . util . ArrayList ; import java . util . HashMap ; import org . bukkit . command . CommandSender ; import org . bukkit . entity . Player ; import org . json . JSONException ; import org . json . JSONObject ; public class Lookup implements Runnable { private final MCBansPlugin plugin ; private final String playerName ; private final CommandSender sender ; private final String senderName ; public Lookup ( MCBansPlugin plugin , String playerName , CommandSender sender , String senderName ) { this . plugin = plugin ; this . playerName = playerName ; this . sender = sender ; this . senderName = senderName ; } public void run ( ) { HashMap < String , String > urlItems = new HashMap < String , String > ( ) ; JSONHandler webHandler = new JSONHandler ( plugin ) ; urlItems . put ( \"player\" , playerName ) ; urlItems . put ( \"admin\" , senderName ) ; urlItems . put ( \"exec\" , \"playerLookup\" ) ; JSONObject result = webHandler . handleJob ( urlItems ) ; try { ArrayList < String > lines = new ArrayList ( ) ; lines . add ( plugin . lang . getFormat ( \"lookupSummary\" , playerName , result . getString ( \"total\" ) , result . getString ( \"reputation\" ) ) ) ; if ( result . getJSONArray ( \"global\" ) . length ( ) > 0 ) { lines . add ( plugin . lang . getFormat ( \"lookupGlobalBansHeader\" ) ) ; for ( int i = 0 ; i < result . getJSONArray ( \"global\" ) . length ( ) ; i ++ ) { lines . add ( result . getJSONArray ( \"global\" ) . getString ( i ) ) ; } } if ( result . getJSONArray ( \"local\" ) . length ( ) > 0 ) { lines . add ( plugin . lang . getFormat ( \"lookupLocalBansHeader\" ) ) ; for ( int i = 0 ; i < result . getJSONArray ( \"local\" ) . length ( ) ; i ++ ) { lines . add ( result . getJSONArray", "gt": "( \"local\" ) . getString ( i ) ) ;", "prediction": "( \"local\" ) . getString ( i ) ) ;\n", "label": 0}
{"id": 15872, "input": "<s> package org . eclipse . ui . model ; import org . eclipse . jface . resource . ColorDescriptor ; import org . eclipse . jface . resource . FontDescriptor ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . resource . LocalResourceManager ; import org . eclipse . jface . resource . ResourceManager ; import org . eclipse . jface . viewers . DecoratingLabelProvider ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . ui . IEditorRegistry ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . util . Util ; public class WorkbenchLabelProvider extends LabelProvider implements IColorProvider , IFontProvider { public static ILabelProvider getDecoratingWorkbenchLabelProvider ( ) { return new DecoratingLabelProvider ( new WorkbenchLabelProvider ( ) , PlatformUI . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ; } private IPropertyListener editorRegistryListener = new IPropertyListener ( ) { public void propertyChanged ( Object source , int propId ) { if ( propId == IEditorRegistry . PROP_CONTENTS ) { fireLabelProviderChanged ( new LabelProviderChangedEvent ( WorkbenchLabelProvider . this ) ) ; } } } ; private ResourceManager resourceManager ; public WorkbenchLabelProvider ( ) { PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . addPropertyListener ( editorRegistryListener ) ; } protected ImageDescriptor decorateImage ( ImageDescriptor input , Object element ) { return input ; } protected String decorateText ( String input , Object element ) { return input ; } public void dispose ( ) { PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . removePropertyListener ( editorRegistryListener ) ; if ( resourceManager != null ) resourceManager . dispose ( ) ; resourceManager = null ; super . dispose ( ) ; } protected final IWorkbenchAdapter getAdapter ( Object o ) { return ( IWorkbenchAdapter ) Util . getAdapter ( o , IWorkbenchAdapter . class ) ; } protected final IWorkbenchAdapter2 getAdapter2 ( Object o ) { return ( IWorkbenchAdapter2 ) Util . getAdapter ( o , IWorkbenchAdapter2 . class ) ; } private ResourceManager getResourceManager ( ) { if ( resourceManager == null ) { resourceManager = new LocalResourceManager ( JFaceResources . getResources ( ) ) ; } return resourceManager ; } public final Image getImage ( Object element ) { IWorkbenchAdapter adapter = getAdapter ( element ) ; if ( adapter == null ) { return null ; }", "gt": "ImageDescriptor descriptor = adapter . getImageDescriptor ( element ) ;", "prediction": "return adapter . getImage ( ) ;\n", "label": 1}
{"id": 2493, "input": "<s> package ar . com . fdvs . dj . core ; import java . util . Map ; import net . sf . jasperreports . engine . JRDefaultScriptlet ; import net . sf . jasperreports . engine . fill . JRFillGroup ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class DJDefaultScriptlet extends JRDefaultScriptlet { int veces = 0 ; public DJDefaultScriptlet ( ) { super ( ) ; } private static final Log logger = LogFactory . getLog ( DJDefaultScriptlet . class ) ; protected static final String VARS_KEY = \"vars\" ; protected static final String PARAMS_KEY = \"params\" ; protected static final String FIELDS_KEY = \"fields\" ; protected FieldMapWrapper fieldMapWrapper = new FieldMapWrapper ( ) ; protected ParameterMapWrapper parameterMapWrapper = new ParameterMapWrapper ( ) ; protected VariableMapWrapper variableMapWrapper = new VariableMapWrapper ( ) ; public void setData ( Map parsm , Map fldsm , Map varsm , JRFillGroup [ ] grps ) { super . setData (", "gt": "parsm , fldsm , varsm , grps ) ;", "prediction": "parsm , fldsm , varsm , grps ) ;\n", "label": 0}
{"id": 15874, "input": "<s> package org . gatein . common . io ; import org . gatein . common . logging . Logger ; import org . gatein . common . logging . LoggerFactory ; import org . gatein . common . util . Tools ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . ObjectStreamClass ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . Writer ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class IOTools { public static final Logger log = LoggerFactory . getLogger ( IOTools . class ) ; private static final Object [ ] EMPTY_ARGS = new Object [ 0 ] ; private static final Class < ? > [ ] EMPTY_PARAMETER_TYPES = new Class [ 0 ] ; public static void safeClose ( Object closable ) { if ( closable != null ) { try { Method m = closable . getClass ( ) . getMethod ( \"close\" , EMPTY_PARAMETER_TYPES ) ; if ( Modifier . isStatic ( m . getModifiers ( ) ) ) { log . warn ( \"close() method on closable object is static\" ) ; return ; } m . invoke ( closable , EMPTY_ARGS ) ; } catch ( NoSuchMethodException e ) { log . warn ( \"The closable object does not have a close() method\" , e ) ; } catch ( IllegalAccessException e ) { log . warn ( \"Cannot access close() method on closable object\" , e ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getCause ( ) ; if ( t instanceof RuntimeException ) { log . error ( \"The close() method threw a runtime exception\" , t ) ; throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { log . error ( \"The close() method threw an error\" , t ) ; throw ( Error ) t ; } else if ( t instanceof Exception ) { log . error ( \"The close() method threw an exception\" , t ) ; } else { log . error ( \"The close() method threw an unexpected throwable\" , t ) ; } } } } public static void safeClose ( Closeable out ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( \"Error while closing closeable \" + out , e ) ; } } } public static byte [ ] getBytes ( InputStream in ) throws IOException , IllegalArgumentException { return getBytes ( in , Tools . DEFAULT_BUFFER_SIZE ) ; } public static byte [ ] getBytes ( InputStream in , int bufferSize ) throws IOException , IllegalArgumentException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; copy ( in , out , bufferSize ) ; return out . toByteArray ( ) ; } public static byte [ ] safeGetBytes ( InputStream is ) { byte [ ] bytes ; if ( is == null ) { return null ; } try { bytes = getBytes ( is ) ; return bytes ; } catch ( IOException ignore ) { return null ; } finally { IOTools . safeClose ( is ) ; } } public static void copy ( InputStream in , OutputStream out ) throws IOException { copy ( in , out , Tools . DEFAULT_BUFFER_SIZE ) ; } public static void copy ( InputStream in , OutputStream out , int bufferSize ) throws IOException { if ( in == null ) { throw new IllegalArgumentException ( \"null in\" ) ; } if ( out == null ) { throw new IllegalArgumentException ( \"null out\" ) ; } if ( bufferSize < 1 ) { throw new IllegalArgumentException ( \"Buffer size is too small\" ) ; } byte [ ] buffer = new byte [ bufferSize ] ; while ( true ) { int i = in . read ( buffer ) ; if ( i == 0 ) { continue ; } if ( i == - 1 ) { break ; } out . write ( buffer , 0 , i ) ; } } public static void copy ( Reader reader , Writer writer ) throws IOException { copy ( reader , writer , Tools . DEFAULT_BUFFER_SIZE ) ; } public static void copy ( Reader reader , Writer writer , int bufferSize ) throws IOException { if ( reader == null ) { throw new IllegalArgumentException ( \"null in\" ) ; } if ( writer == null ) { throw new IllegalArgumentException ( \"null out\" ) ; } if ( bufferSize < 1 ) { throw new IllegalArgumentException ( \"Buffer size is too small\" ) ; } char [ ] buffer = new char [ bufferSize ] ; while ( true ) { int i = reader . read ( buffer ) ; if ( i == 0 ) { continue ; } if ( i == - 1 ) { break ; } writer . write ( buffer , 0 , i ) ; } } public static < S extends Serializable > S clone ( S serializable ) throws IllegalArgumentException , IOException { try { return clone ( serializable , null ) ; } catch ( ClassNotFoundException e ) { throw new Error ( \"Got a class not found exception for a class that was used\" , e ) ; } } @ SuppressWarnings ( \"unchecked\" ) public static < S extends Serializable > S clone ( S serializable , ClassLoader classLoader ) throws IllegalArgumentException , IOException , ClassNotFoundException { if ( serializable == null ) { throw new IllegalArgumentException ( \"Cannot clone null\" ) ; } if ( classLoader ==", "gt": "null && serializable != null )", "prediction": "null )\n", "label": 1}
{"id": 9503, "input": "<s> class T4756416 { static class C < A > { A id ( A x ) { return x ; } } interface I < A > { A id ( A x ) ; } static class D", "gt": "extends C < String > implements I < Integer >", "prediction": "< A >\n", "label": 0}
{"id": 15875, "input": "<s> package org . eclipse . swt . dnd ; import java . io . UnsupportedEncodingException ; import org . eclipse . rap . rwt . SingletonUtil ; public class TextTransfer extends ByteArrayTransfer { private static final String TYPE_NAME = \"text\" ; private static final int TYPE_ID = registerType ( TYPE_NAME ) ; private TextTransfer ( ) { } public static TextTransfer getInstance ( ) { return SingletonUtil . getSessionInstance ( TextTransfer . class ) ; } public void javaToNative ( Object object , TransferData transferData ) { if ( ! checkText ( object ) || ! isSupportedType ( transferData ) ) { DND . error ( DND . ERROR_INVALID_DATA ) ; } transferData . data = object ; transferData . result = 1 ; } public Object nativeToJava ( TransferData transferData ) { if ( ! isSupportedType ( transferData ) || transferData . data == null ) { return null ; } if ( transferData . result != 1 ) return null ; return transferData . data ; } protected int [ ] getTypeIds ( ) { return new int [ ] { TYPE_ID } ; } protected String [ ] getTypeNames ( ) { return new String [ ] { TYPE_NAME } ; } boolean checkText ( Object object ) { return ( object != null && object instanceof String && ( ( String ) object ) . length ( ) > 0 ) ; } protected boolean validate ( Object object ) { return checkText ( object ) ; } static byte [ ] stringToBytes ( String string ) { byte", "gt": "[ ] bytes = null ;", "prediction": "[ ] result = null ;\n", "label": 1}
{"id": 5287, "input": "<s> package com . matburt . mobileorg . test . util ; public class OrgTestFiles { public static class SimpleOrgFiles { public static final String [ ] tags = { \"Home\" , \"Computer\" , \"Errands\" } ; public static final String [ ] todos = { \"TODO\" , \"DONE\" } ; public static final String [ ] files = { \"GTD.org\" } ; public static final String [ ] priorities = { \"A\" , \"B\" , \"C\" } ; public static final String indexFile = \"#+READONLY\\n\" + \"#+TODO: TODO | DONE\\n\" + \"#+TAGS: { Home Computer Errands } \\n\" + \"#+ALLPRIORITIES: A B C\\n\" + \"* [[file:GTD.org][GTD.org]]\\n\" ; public static final String checksumsFile = \"25aade750f6b60aa1df155fcbb357191  index.org\\n\" + \"42055316a0808ad634d7981653cf4400faddb91f  GTD.org\" ; public static final String orgFileTopHeading = \"top heading\" ; public static final String orgFileChildHeading = \"child heading\" ; public static final String orgFile = \"* \" + orgFileTopHeading + \"\\n** \" + orgFileChildHeading ; } public static final String indexFileWithEmptyDrawers = \"#+READONLY\\n\" + \"#+TODO:\\n\" + \"#+TAGS:\\n\" + \"#+ALLPRIORITIES:\\n\" + \"* [[file:GTD.org][GTD.org]]\\n\" ; public static class ComplexOrgFiles { public static final String indexFile = \"#+READONLY\\n\" + \"#+TODO: TODO NEXT PLAN RSCH GOAL DEFERRED WAIT | SOMEDAY CANC DONE\\n\" + \"#+TAGS: { Home Computer Online Phone Errands } { Agenda Read Listen Watch Code }\\n\" + \"#+ALLPRIORITIES: A B C\\n\"", "gt": "+ \"* [[file:agendas.org][Agenda Views]]\\n\" ;", "prediction": ";\n", "label": 0}
{"id": 15881, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . queryParser . ParseException ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . search . Query ; import org . apache . lucene . xmlparser . DOMUtils ; import org . apache . lucene . xmlparser . ParserException ; import org . apache . lucene . xmlparser . QueryBuilder ; import org . w3c . dom . Element ; public class UserInputQueryBuilder implements QueryBuilder { QueryParser unSafeParser ; private Analyzer analyzer ; private String defaultField ; public UserInputQueryBuilder ( QueryParser parser ) { this . unSafeParser = parser ; } public UserInputQueryBuilder ( String defaultField , Analyzer analyzer ) { this . analyzer = analyzer ; this . defaultField = defaultField ; } public Query getQuery ( Element e ) throws ParserException { String text = DOMUtils . getText ( e ) ; try { Query q = null ; if ( unSafeParser != null ) { synchronized ( unSafeParser ) { q = unSafeParser . parse ( text ) ; } } else { String fieldName = DOMUtils . getAttribute ( e , \"fieldName\" , defaultField ) ; QueryParser parser = createQueryParser ( fieldName , analyzer ) ; q = parser . parse ( text ) ; } q . setBoost ( DOMUtils . getAttribute ( e , \"boost\" , 1.0f ) ) ; return q ; } catch ( ParseException e1 ) { throw new ParserException ( e1 . getMessage ( ) ) ; } } protected QueryParser createQueryParser ( String fieldName , Analyzer analyzer ) { return new QueryParser", "gt": "( fieldName , analyzer ) ;", "prediction": "( fieldName , analyzer ) ;\n", "label": 1}
{"id": 4582, "input": "<s> package net . rdrei . android . absshadow . test ; import net . rdrei . android . absshadow . MainActivity ; import org . junit . runner . RunWith ; import org . junit . Test ; @ RunWith ( CustomTestRunner . class ) public class MainActivityTest { @ Test", "gt": "public void initialize ( )", "prediction": "public void testGetMainActivity ( )\n", "label": 0}
{"id": 15883, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . server ; import javax . servlet . http . HttpSession ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class DelegatingServletEngine implements IServletEngine { private final IServletEngine delegate ; private boolean running ; public DelegatingServletEngine ( IServletEngine delegate ) { this . delegate = delegate ; } public IServletEngine getDelegate ( ) { return delegate ; } public void start ( Class < ? extends IEntryPoint > entryPointClass ) throws Exception { checkNotNull ( entryPointClass ) ; checkNotRunning ( ) ; delegate . start ( entryPointClass ) ; running = true ; } public void stop ( ) throws Exception { stop ( 0 ) ; } public void stop ( int timeout ) throws Exception { if ( running ) { delegate . stop ( timeout ) ; running = false ; } } public int getPort ( ) { return delegate . getPort ( ) ; } public HttpSession [ ] getSessions ( ) { if ( ! running ) { String msg = \"Sessions can only be accessed while the servlet engine is running.\" ; throw new IllegalStateException ( msg ) ; } return delegate . getSessions ( ) ; } private void checkNotNull ( Class < ?", "gt": "extends IEntryPoint > entryPointClass )", "prediction": "extends IEntryPoint > entryPointClass )\n", "label": 1}
{"id": 3884, "input": "<s> package com . mobeelizer . mobile . android . search ; public class MobeelizerOrderImpl implements MobeelizerInternalOrder { private final String field ; private final boolean asc ; public MobeelizerOrderImpl ( final String field , final boolean asc ) { this . field = field ; this . asc = asc ; } @ Override public String addToQuery ( ) { return field +", "gt": "( asc ? \" asc\" : \" desc\" ) ;", "prediction": "\",\" + asc ;\n", "label": 0}
{"id": 15884, "input": "<s> package org . restlet . example . ext . jaxrs . employees ; import java . net . URI ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlRootElement public class Employee extends AbstractEmployee { private String sex ; private String department ; private URI departmentUri ; public String getDepartment ( ) { return this . department ; } public URI getDepartmentUri ( ) { return this . departmentUri ; } public String getSex ( ) { return this . sex ; }", "gt": "public void setDepartment ( String department )", "prediction": "public String getDepartmentUri ( )\n", "label": 1}
{"id": 998, "input": "<s> package org . bombusim . xmpp . stanza ; import org . bombusim . xml . Attributes ; import org . bombusim . xmpp . XmppObject ; public final class Iq extends XmppObject { public final static int TYPE_SET = 0 ; public final static int TYPE_GET = 1 ; public final static int TYPE_RESULT = 2 ; public final static int TYPE_ERROR = 3 ; public Iq ( XmppObject parent , Attributes attributes ) { super ( parent , attributes ) ; } public Iq ( String to , int typeSet , String id ) { super ( ) ; setAttribute ( \"to\" , to ) ; String type ; switch ( typeSet ) { case TYPE_SET : type = \"set\" ; break ; case TYPE_GET : type = \"get\" ; break ; case TYPE_ERROR : type = \"error\" ;", "gt": "default : type = \"result\" ;", "prediction": "break ;\n", "label": 0}
{"id": 15885, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec1 . sub1 ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; }", "gt": "public void setAccountRef ( String accountRef )", "prediction": "public String getContent ( )\n", "label": 1}
{"id": 5053, "input": "<s> class Test extends Test { { for (", "gt": "Integer x : null )", "prediction": "int i = 0 ;\n", "label": 0}
{"id": 15888, "input": "<s> package vanilla . java . affinity ; public interface AffinityStrategy {", "gt": "public boolean matches ( int cpuId , int cpuId2 ) ;", "prediction": "}\n", "label": 1}
{"id": 5230, "input": "<s> class Q extends P { public void pDep_qDep_rDep ( ) { } public void pDep_qDep_rUnd ( ) { } public void pDep_qDep_rInh ( ) { } public void pDep_qUnd_rDep ( ) { } public void pDep_qUnd_rUnd ( ) { } public void pDep_qUnd_rInh ( ) { } public void pUnd_qDep_rDep ( ) { } public void pUnd_qDep_rUnd ( ) { } public void pUnd_qDep_rInh ( ) { }", "gt": "public void pUnd_qUnd_rDep ( )", "prediction": "}\n", "label": 0}
{"id": 15891, "input": "<s> package org . nuxeo . ecm . platform . relations . api ;", "gt": "public interface Subject extends Node", "prediction": "import java . util . ArrayList ;\n", "label": 1}
{"id": 780, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . annotations . SuppressNode ; import org . parboiled . support . Var ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class VarFramingTest extends TestNgParboiledTest < Integer > { @ BuildParseTree static class Parser extends BaseParser < Integer > { int count = 1 ; @ SuppressWarnings ( { \"InfiniteRecursion\" } ) public Rule Clause ( ) { Var < Integer > a = new Var < Integer > ( - 1 ) ; return Sequence ( Digits ( ) , a . set ( peek ( ) ) , SomeRule ( a ) , Optional ( '+' , Clause ( ) , push ( a . get ( ) ) ) ) ; } @ SuppressNode public Rule Digits ( ) { return Sequence ( OneOrMore ( CharRange ( '0' , '9' ) ) , push ( Integer . parseInt ( match ( ) ) ) ) ; } public Rule SomeRule ( Var < Integer > var ) { return toRule ( var . get ( ) == count ++ ) ; } } @ Test public void test ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; Rule rule = parser . Clause ( ) ; ParserStatistics stats = ParserStatistics . generateFor ( rule ) ; assertEquals ( stats . toString ( ) , \"\" + \"Parser statistics for rule 'Clause':\\n\" + \"    Total rules       : 11\\n\" + \"        Actions       : 4\\n\" + \"        Any           : 0\\n\" + \"        CharIgnoreCase: 0\\n\" + \"        Char          : 1\\n\" + \"        Custom        : 0\\n\" + \"        CharRange     : 1\\n\" + \"        AnyOf         : 0\\n\" + \"        Empty         : 0\\n\" + \"        FirstOf       : 0\\n\" + \"        FirstOfStrings: 0\\n\" + \"        Nothing       : 0\\n\" + \"        OneOrMore     : 1\\n\" + \"        Optional      : 1\\n\" + \"        Sequence      : 3\\n\" + \"        String        : 0\\n\" + \"        Test          : 0\\n\" + \"        TestNot       : 0\\n\" + \"        ZeroOrMore    : 0\\n\" + \"\\n\" + \"    Action Classes    : 4\\n\" + \"    ProxyMatchers     : 1\\n\" + \"    VarFramingMatchers: 1\\n\" + \"MemoMismatchesMatchers: 0\\n\" ) ; test ( rule , \"1+2+3\" ) . hasNoErrors ( ) . hasParseTree ( \"\" + \"[Clause, {1}] '1+2+3'\\n\" + \"  [Optional, {1}] '+2+3'\\n\" + \"    [Sequence, {1}] '+2+3'\\n\" + \"      ['+', {1}] '+'\\n\" + \"      [Clause, {2}] '2+3'\\n\" + \"        [Optional, {2}] '+3'\\n\" + \"          [Sequence, {2}] '+3'\\n\" + \"            ['+', {2}] '+'\\n\" + \"            [Clause, {3}] '3'\\n\" + \"      ", "gt": "       [Optional, {3}]\\n\" ) ;", "prediction": "[Sequence,\n", "label": 0}
{"id": 15893, "input": "<s> package org . restlet . util ; import org . restlet . engine . util . SystemUtils ; @ Deprecated public class Couple < T , U > { private volatile T first ; private volatile U second ; public Couple ( T first , U second ) { this . first = first ; this . second = second ; } @ Override public boolean equals ( Object other ) { boolean result = ( this == other ) ; if ( ! result && ( other instanceof Couple ) ) { Couple < ? , ? > couple = ( Couple < ? , ? > ) other ; if ( ( ( couple . getFirst ( ) == null ) && ( getFirst ( ) == null ) ) || ( ( getFirst ( ) != null ) && getFirst ( ) . equals ( couple . getFirst ( ) ) ) ) { result = ( ( ( couple . getSecond ( ) == null ) && ( getSecond ( ) == null ) ) || ( ( getSecond ( ) != null ) && getSecond ( ) . equals ( couple . getSecond ( ) ) ) ) ; } } return result ; } public T getFirst ( ) { return first ; }", "gt": "public U getSecond ( )", "prediction": "public U getSecond ( )\n", "label": 1}
{"id": 8599, "input": "<s> class CatchWithoutTry { void m ( ) {", "gt": "catch ( Exception e )", "prediction": "}\n", "label": 0}
{"id": 15894, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import java . util . List ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . nodes . BooleanQueryNode ; import org . apache . lucene . queryParser . core . nodes . ModifierQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . standard . parser . EscapeQuerySyntaxImpl ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . BooleanQuery . TooManyClauses ; public class BooleanQueryNodeBuilder implements StandardQueryBuilder { public BooleanQueryNodeBuilder ( ) { } public BooleanQuery build ( QueryNode queryNode ) throws QueryNodeException { BooleanQueryNode booleanNode = ( BooleanQueryNode ) queryNode ; BooleanQuery bQuery = new BooleanQuery ( ) ; List < QueryNode > children = booleanNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { Object obj = child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . add ( query , getModifierValue ( child ) ) ; } catch ( TooManyClauses ex ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . TOO_MANY_BOOLEAN_CLAUSES , new Object [ ] { BooleanQuery . getMaxClauseCount ( ) , queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) } ) , ex ) ; } } } } return bQuery ; } private static BooleanClause . Occur getModifierValue ( QueryNode node ) throws QueryNodeException { if ( node instanceof ModifierQueryNode ) { ModifierQueryNode mNode = ( ( ModifierQueryNode ) node ) ; switch ( mNode . getModifier ( ) ) { case MOD_REQ : return BooleanClause . Occur . MUST ; case MOD_NOT : return BooleanClause", "gt": ". Occur . MUST_NOT ;", "prediction": ". Occur . SHOULD ;\n", "label": 1}
{"id": 5465, "input": "<s> class BarNeg2 < T > { BarNeg2 < ? > . Inner < ? > . InnerMost [ ] array = new BarNeg2 < Object > . Inner < ? > .", "gt": "InnerMost [ 10 ] ;", "prediction": "InnerMost [ ]\n", "label": 0}
{"id": 15896, "input": "<s> package org . spliffy . server . web . calc ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . HashMap ; import java . util . List ; import org . spliffy . server . web . ResourceList ; import org . spliffy . server . web . SpliffyResource ; import org . spliffy . server . web . templating . Formatter ; public class Calc { private static org . apache . log4j . Logger log = org . apache . log4j . Logger . getLogger ( Calc . class ) ; private final List < SpliffyResource > list ; private final Formatter formatter ; public Calc ( List < SpliffyResource > list , Formatter formatter ) { this . list = list ; this . formatter = formatter ; } public Object eval ( String mvelExpr , Object r ) { HashMap map = new HashMap ( ) ; Object o = org . mvel . MVEL . eval ( mvelExpr , r , map ) ; return o ; } public BigDecimal sum ( String mvelExpr ) { return sum ( mvelExpr , 0 ) ; } public ResourceList filter ( String mvelExpr ) { ListFilter filter = new ListFilter ( ) ; accumulate ( filter , mvelExpr ) ; return filter . dest ; } public BigDecimal sum ( String mvelExpr , int decimals ) { Sumor summer = new Sumor ( decimals , formatter ) ; accumulate ( summer , mvelExpr ) ; return summer . value ; } void accumulate (", "gt": "Accumulator a , String mvelExpr )", "prediction": "ListFilter filter , String mvelExpr )\n", "label": 1}
{"id": 8109, "input": "<s> import java . util . Set ; import javax . annotation . processing . * ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; public class T6512707 extends JavacTestingAbstractProcessor { public boolean process (", "gt": "Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv )", "prediction": "Element element )\n", "label": 0}
{"id": 15897, "input": "<s> package io . beancounter . resolver ; public class ResolverMappingNotFoundException extends ResolverException { public ResolverMappingNotFoundException ( String message , Exception e ) { super ( message , e ) ; }", "gt": "public ResolverMappingNotFoundException ( String message )", "prediction": "public ResolverMappingNotFoundException ( String message , Exception e )\n", "label": 1}
{"id": 1516, "input": "<s> package pkg3 ; public interface I0 extends", "gt": "I2 , I3 , I4", "prediction": "I0\n", "label": 0}
{"id": 15910, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . document . AbstractField ; import org . apache . lucene . document . Document ; import java . text . NumberFormat ; import java . io . PrintStream ; import java . io . IOException ; import java . io . File ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; import java . util . Map ; public class CheckIndex { public static PrintStream out = null ; private PrintStream infoStream ; private Directory dir ; public static class Status { public boolean clean ; public boolean missingSegments ; public boolean cantOpenSegments ; public boolean missingSegmentVersion ; public String segmentsFileName ; public int numSegments ; public String segmentFormat ; public List segmentsChecked = new ArrayList ( ) ; public boolean toolOutOfDate ; public List segmentInfos = new ArrayList ( ) ; public Directory dir ; SegmentInfos newSegments ; public int totLoseDocCount ; public int numBadSegments ; public boolean partial ; public Map userData ; public static class SegmentInfoStatus { public String name ; public int docCount ; public boolean compound ; public int numFiles ; public double sizeMB ; public int docStoreOffset = - 1 ; public String docStoreSegment ; public boolean docStoreCompoundFile ; public boolean hasDeletions ; public String deletionsFileName ; public int numDeleted ; public boolean openReaderPassed ; int numFields ; public boolean hasProx ; public Map diagnostics ; public FieldNormStatus fieldNormStatus ; public TermIndexStatus termIndexStatus ; public StoredFieldStatus storedFieldStatus ; public TermVectorStatus termVectorStatus ; } public static final class FieldNormStatus { public long totFields = 0L ; public Throwable error = null ; } public static final class TermIndexStatus { public long termCount = 0L ; public long totFreq = 0L ; public long totPos = 0L ; public Throwable error = null ; } public static final class StoredFieldStatus { public int docCount = 0 ; public long totFields = 0 ; public Throwable error = null ; } public static final class TermVectorStatus { public int docCount = 0 ; public long totVectors = 0 ; public Throwable error = null ; } } public CheckIndex ( Directory dir ) { this . dir = dir ; infoStream = out ; } public void setInfoStream ( PrintStream out ) { infoStream = out ; } private void msg ( String msg ) { if ( infoStream != null ) infoStream . println ( msg ) ; } private static class MySegmentTermDocs extends SegmentTermDocs { int delCount ; MySegmentTermDocs ( SegmentReader p ) { super ( p ) ; } public void seek ( Term term ) throws IOException { super . seek ( term ) ; delCount = 0 ; } protected void skippingDoc ( ) throws IOException { delCount ++ ; } } public static boolean check ( Directory dir , boolean doFix ) throws IOException { return check ( dir , doFix , null ) ; } public static boolean check ( Directory dir , boolean doFix , List onlySegments ) throws IOException { CheckIndex checker = new CheckIndex ( dir ) ; Status status = checker . checkIndex ( onlySegments ) ; if ( doFix && ! status . clean ) checker . fixIndex ( status ) ; return status . clean ; } public Status checkIndex ( ) throws IOException { return checkIndex ( null ) ; } public Status checkIndex ( List onlySegments ) throws IOException { NumberFormat nf = NumberFormat . getInstance ( ) ; SegmentInfos sis = new SegmentInfos ( ) ; Status result = new Status ( ) ; result . dir = dir ; try { sis . read ( dir ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not read any segments file in directory\" ) ; result . missingSegments = true ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; return result ; } final int numSegments = sis . size ( ) ; final String segmentsFileName = sis . getCurrentSegmentFileName ( ) ; IndexInput input = null ; try { input = dir . openInput ( segmentsFileName ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not open segments file in directory\" ) ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; result . cantOpenSegments = true ; return result ; } int format = 0 ; try { format = input . readInt ( ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not read segment file version in directory\" ) ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; result . missingSegmentVersion = true ; return result ; } finally { if ( input != null ) input . close ( ) ; } String sFormat = \"\" ; boolean skip = false ; if ( format == SegmentInfos . FORMAT ) sFormat = \"FORMAT [Lucene Pre-2.1]\" ; if ( format == SegmentInfos . FORMAT_LOCKLESS ) sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\" ; else if ( format == SegmentInfos . FORMAT_SINGLE_NORM_FILE ) sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\" ; else if ( format == SegmentInfos . FORMAT_SHARED_DOC_STORE ) sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\" ; else { if ( format == SegmentInfos . FORMAT_CHECKSUM ) sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\" ; else if ( format == SegmentInfos . FORMAT_DEL_COUNT ) sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\" ; else if ( format == SegmentInfos . FORMAT_HAS_PROX ) sFormat = \"FORMAT_HAS_PROX [Lucene 2.4]\" ; else if ( format", "gt": "== SegmentInfos . FORMAT_USER_DATA ) sFormat = \"FORMAT_USER_DATA [Lucene 2.9]\" ;", "prediction": "== SegmentInfos . FORMAT_NONE ) sFormat = \"FORMAT_NONE [Lucene 2.4]\" ;\n", "label": 1}
{"id": 4440, "input": "<s> package rare5 ; class A < T > { class B < U > { } static class C < V > { } } class Main { A", "gt": "< String > . C ac2 ;", "prediction": "a ;\n", "label": 0}
{"id": 15916, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs . io . writers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . net . URLEncoder ; import java . util . Calendar ; import java . util . List ; import java . util . Map ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . codehaus . jackson . JsonGenerator ; import org . joda . time . DateTime ; import org . joda . time . format . ISODateTimeFormat ; import org . nuxeo . common . utils . StringUtils ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . Lock ; import org . nuxeo . ecm . core . api . model . DocumentPart ; import org . nuxeo . ecm . core . api . model . Property ; import org . nuxeo . ecm . core . api . model . PropertyNotFoundException ; import org . nuxeo . ecm . core . api . model . impl . ArrayProperty ; import org . nuxeo . ecm . core . api . model . impl . ComplexProperty ; import org . nuxeo . ecm . core . api . model . impl . ListProperty ; import org . nuxeo . ecm . core . api . model . impl . primitives . BlobProperty ; import org . nuxeo . ecm . core . schema . types . ListType ; import org . nuxeo . ecm . core . schema . utils . DateParser ; @ Provider @ Produces ( { \"application/json+nxentity\" , \"application/json\" } ) public class JsonDocumentWriter implements MessageBodyWriter < DocumentModel > { public static final String DOCUMENT_PROPERTIES_HEADER = \"X-NXDocumentProperties\" ; private static final Log log = LogFactory . getLog ( JsonDocumentWriter . class ) ; @ Context protected HttpHeaders headers ; public long getSize ( DocumentModel arg0 , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 ) { return - 1L ; } public boolean isWriteable ( Class < ? > arg0 , Type arg1 , Annotation [ ] arg2 , MediaType arg3 ) { return DocumentModel . class . isAssignableFrom ( arg0 ) ; } public void writeTo ( DocumentModel doc , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 , MultivaluedMap < String , Object > arg5 , OutputStream out ) throws IOException , WebApplicationException { try { List < String > props = headers . getRequestHeader ( DOCUMENT_PROPERTIES_HEADER ) ; String [ ] schemas = null ; if ( props != null && ! props . isEmpty ( ) ) { schemas = StringUtils . split ( props . get ( 0 ) , ',' , true ) ; } writeDocument ( out , doc , schemas ) ; } catch ( IOException e ) { log . error ( \"Failed to serialize document\" , e ) ; throw e ; } catch ( Exception e ) { log . error ( \"Failed to serialize document\" , e ) ; throw new WebApplicationException ( e , 500 ) ; } } public static void writeDocument ( OutputStream out , DocumentModel doc , String [ ] schemas ) throws Exception { writeDocument ( out , doc , schemas , null ) ; } public static void writeDocument ( OutputStream out , DocumentModel doc , String [ ] schemas , Map < String , String > contextParameters ) throws Exception { writeDocument ( JsonWriter . createGenerator ( out ) ,", "gt": "doc , schemas , contextParameters ) ;", "prediction": "doc , schemas , contextParameters ) ;\n", "label": 1}
{"id": 1617, "input": "<s> package pkg ; public class C extends Parent { public void regularParams ( int param1 , int param2 ) { } public void nonMatchingParams ( int", "gt": "param1 , int param2 )", "prediction": "param1 , int param2 )\n", "label": 0}
{"id": 15919, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . ColumnLayoutData ; import org . eclipse . jface . viewers . ColumnWeightData ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TableLayout ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; public class TableViewerComparatorTest extends ViewerComparatorTest { public TableViewerComparatorTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { TableViewer viewer = new TableViewer ( parent ) ; viewer . setContentProvider ( new TeamModelContentProvider ( ) ) ; viewer . setLabelProvider ( new TeamModelLabelProvider ( ) ) ; viewer . getTable ( ) . setLinesVisible ( true ) ; TableLayout layout = new TableLayout ( ) ; viewer . getTable ( ) . setLayout ( layout ) ; viewer . getTable ( ) . setHeaderVisible ( true ) ; String headers [ ] = { \"column 1 header\" , \"column 2 header\" } ; ColumnLayoutData layouts [ ] = { new ColumnWeightData ( 100 ) , new ColumnWeightData ( 100 ) } ; final TableColumn columns [ ] = new TableColumn [ headers . length ] ; for ( int i = 0 ; i < headers . length ; i ++ ) { layout . addColumnData ( layouts [ i ] ) ; TableColumn tc = new TableColumn ( viewer . getTable ( ) , SWT . NONE , i ) ; tc . setResizable ( layouts [ i ] . resizable ) ; tc . setText ( headers [ i ] ) ; columns [ i ] = tc ; } return viewer ; } public void testViewerSorter ( ) { fViewer . setSorter ( new ViewerSorter ( ) ) ; assertSortedResult ( TEAM1_SORTED ) ; } public void testViewerSorterInsertElement ( ) { fViewer . setSorter ( new ViewerSorter ( ) ) ; team1 . addMember ( \"Duong\" ) ; assertSortedResult ( TEAM1_SORTED_WITH_INSERT ) ; } public void testViewerComparator ( ) { fViewer . setComparator ( new ViewerComparator ( ) ) ; assertSortedResult ( TEAM1_SORTED ) ; } public void testViewerComparatorInsertElement ( ) { fViewer . setComparator ( new ViewerComparator ( ) ) ; team1 . addMember ( \"Duong\" ) ; assertSortedResult ( TEAM1_SORTED_WITH_INSERT ) ; } private void assertSortedResult ( String [ ] expected ) { TableItem [ ] items = getTableViewer ( ) . getTable ( ) . getItems ( ) ; for ( int i = 0 ; i < items . length ; i ++ ) { TableItem item = items [ i ] ; assertEquals ( \"Item not expected.  actual=\" + item . getText ( ) + \" expected=\" , expected [ i ] , item . getText ( ) ) ; } } protected void setInput ( ) { fViewer . setInput ( team1 ) ; } protected TableViewer getTableViewer ( ) { return ( TableViewer ) fViewer ; } public static void main ( String [ ] args ) { junit . textui .", "gt": "TestRunner . run ( TableViewerComparatorTest . class ) ;", "prediction": "TestUtil . setUp ( ) ;\n", "label": 1}
{"id": 7334, "input": "<s> public class T6207386 { static class F < T > { } static class C < X extends F < F < ? super X > > > { C ( X x ) { F < ?", "gt": "super X > f = x ;", "prediction": "super X > x ;\n", "label": 0}
{"id": 15920, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . search . spans . * ; public class TestComplexExplanations extends TestExplanations { public void setUp ( ) throws Exception { super . setUp ( ) ; searcher . setSimilarity ( createQnorm1Similarity ( ) ) ; } private static DefaultSimilarity createQnorm1Similarity ( ) { return new DefaultSimilarity ( ) { public float queryNorm ( float sumOfSquaredWeights ) { return 1.0f ; } } ; } public void test1 ( ) throws Exception { BooleanQuery q = new BooleanQuery ( ) ; q . add ( qp . parse ( \"\\\"w1 w2\\\"~1\" ) , Occur . MUST ) ; q . add ( snear ( st ( \"w2\" ) , sor ( \"w5\" , \"zz\" ) , 4 , true ) , Occur . SHOULD ) ; q . add ( snear ( sf ( \"w3\" , 2 ) , st ( \"w2\" ) , st ( \"w3\" ) , 5 , true ) , Occur . SHOULD ) ; Query t = new FilteredQuery ( qp . parse ( \"xx\" ) , new ItemizedFilter ( new int [ ] { 1 , 3 } ) ) ; t . setBoost ( 1000 ) ; q . add ( t , Occur . SHOULD ) ; t = new ConstantScoreQuery ( new ItemizedFilter ( new int [ ] { 0 , 2 } ) ) ; t . setBoost ( 30 ) ; q . add ( t , Occur . SHOULD ) ; DisjunctionMaxQuery dm = new DisjunctionMaxQuery ( 0.2f ) ; dm . add ( snear ( st ( \"w2\" ) , sor ( \"w5\" , \"zz\" ) , 4 , true ) ) ; dm . add ( qp . parse ( \"QQ\" ) ) ; dm . add ( qp . parse ( \"xx yy -zz\" ) ) ; dm . add ( qp . parse ( \"-xx -w1\" ) ) ; DisjunctionMaxQuery dm2 = new DisjunctionMaxQuery ( 0.5f ) ; dm2 . add ( qp . parse ( \"w1\" ) ) ; dm2 . add ( qp . parse ( \"w2\" ) ) ; dm2 . add ( qp . parse ( \"w3\" ) ) ; dm . add ( dm2 ) ; q . add ( dm , Occur . SHOULD ) ; BooleanQuery b = new BooleanQuery ( ) ; b . setMinimumNumberShouldMatch ( 2 ) ; b . add ( snear ( \"w1\" , \"w2\" , 1 , true ) , Occur . SHOULD ) ; b . add ( snear ( \"w2\" , \"w3\" , 1 , true ) , Occur . SHOULD ) ; b . add ( snear ( \"w1\" , \"w3\" , 3 , true ) , Occur . SHOULD ) ; q . add ( b , Occur . SHOULD ) ; qtest ( q , new int [ ] { 0 , 1 , 2 } ) ; } public void test2 ( ) throws Exception { BooleanQuery q = new BooleanQuery ( ) ; q . add ( qp . parse ( \"\\\"w1 w2\\\"~1\" ) , Occur . MUST ) ; q . add ( snear ( st ( \"w2\" ) , sor ( \"w5\" , \"zz\" ) , 4 , true ) , Occur . SHOULD ) ; q . add ( snear ( sf ( \"w3\" , 2 ) , st ( \"w2\" ) , st ( \"w3\" ) , 5 , true ) , Occur . SHOULD ) ; Query t = new FilteredQuery ( qp . parse ( \"xx\" ) , new ItemizedFilter ( new int [ ] { 1 , 3 } ) ) ; t . setBoost ( 1000 ) ; q . add ( t , Occur . SHOULD ) ; t = new ConstantScoreQuery ( new ItemizedFilter ( new int [ ] { 0 , 2 } ) ) ; t . setBoost ( - 20.0f ) ; q . add ( t , Occur . SHOULD ) ; DisjunctionMaxQuery dm = new DisjunctionMaxQuery ( 0.2f ) ; dm . add ( snear ( st ( \"w2\" ) , sor ( \"w5\" , \"zz\" ) , 4 , true ) ) ; dm . add ( qp . parse ( \"QQ\" ) ) ; dm . add ( qp . parse (", "gt": "\"xx yy -zz\" ) ) ;", "prediction": "\"xx yy -zz\" ) ) ;\n", "label": 1}
{"id": 6654, "input": "<s> package LizaCraft ; import java . lang . reflect . Field ; import net . minecraft . server . MinecraftServer ; import net . minecraft . server . ThreadServerApplication ; import org . bukkit . craftbukkit . CraftServer ; public class ServerGrabber { private static final String MINECRAFT_SERVER_THREAD_NAME = \"Server thread\" ; private static final String MINECRAFT_SERVER_FIELD_NAME = \"a\" ; protected CraftServer searchThreads ( LizaCraftTestModule lizaCraftTestModule ) { Thread threads [ ] = this . getThreads ( ) ; ThreadServerApplication tsa = getThreadServerApplication ( threads ) ; MinecraftServer minecraftServer = getMinecraftServer ( tsa ) ; return minecraftServer . server ; } private MinecraftServer getMinecraftServer ( ThreadServerApplication serverThread ) { Class < ? extends ThreadServerApplication > serverThreadClass = serverThread . getClass ( ) ; Field minecraftServerField ; MinecraftServer minecraftServer = null ; try { minecraftServerField = serverThreadClass . getDeclaredField ( MINECRAFT_SERVER_FIELD_NAME ) ; minecraftServerField . setAccessible ( true ) ; minecraftServer = ( MinecraftServer ) minecraftServerField . get ( serverThread ) ; minecraftServerField . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return minecraftServer ; } private ThreadServerApplication getThreadServerApplication ( Thread [ ] threads ) { ThreadServerApplication serverThread = null ; for ( Thread t : threads ) { if ( t != null && t . getName ( ) != null && t . getName ( ) . equals ( MINECRAFT_SERVER_THREAD_NAME ) ) { serverThread = ( ThreadServerApplication ) t ; break ; } } return serverThread ; } private Thread [ ] getThreads ( ) { ThreadGroup rootGroup = Thread . currentThread", "gt": "( ) . getThreadGroup ( ) ;", "prediction": "( ) . getThreadGroup ( ) ;\n", "label": 0}
{"id": 15923, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . client . util ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; public class AnnotationUtils { private AnnotationUtils ( ) { } public static String escapeHtml ( String maybeHtml ) { final Element div = DOM . createDiv ( ) ; DOM . setInnerText ( div , maybeHtml ) ; String escapedHtml = DOM . getInnerHTML ( div ) . replaceAll ( \"<BR>\" , \"\\n\" ) . replaceAll ( \"&nbsp;\" , \" \" ) ; return escapedHtml ; } public static String replaceCarriageReturns ( String text ) { return text . replaceAll (", "gt": "\"\\n\" , \"<br/>\" ) ;", "prediction": "\"<BR>\" , \" \" ) ;\n", "label": 1}
{"id": 1927, "input": "<s> package de . javawi . jstun . attribute ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; public class ResponseAddress extends MappedResponseChangedSourceAddressReflectedFrom { private static final Logger LOGGER = LoggerFactory . getLogger ( ResponseAddress . class ) ; public ResponseAddress ( ) { super ( MessageAttribute . MessageAttributeType . ResponseAddress ) ; } public static MessageAttribute parse ( byte [ ] data ) throws MessageAttributeParsingException { ResponseAddress ra = new ResponseAddress ( ) ; MappedResponseChangedSourceAddressReflectedFrom .", "gt": "parse ( ra , data ) ;", "prediction": "parse ( data , ra ) ;\n", "label": 0}
{"id": 15925, "input": "<s> package org . eclipse . rap . rwt . internal . widgets . fileuploadkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . internal . widgets . IFileUploadAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . rap . rwt . testfixture . Message . DestroyOperation ; import org . eclipse . rap . rwt . testfixture . Message . Operation ; import org . eclipse . rap . rwt . widgets . FileUpload ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . graphics . ImageFactory ; import org . eclipse . swt . internal . widgets . Props ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; @ SuppressWarnings ( \"deprecation\" ) public class FileUploadLCA_Test extends TestCase { private Display display ; private Shell shell ; private FileUpload fileUpload ; private FileUploadLCA lca ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display ) ; fileUpload = new FileUpload ( shell , SWT . NONE ) ; lca = new FileUploadLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { ControlLCATestUtil . testActivateListener ( fileUpload ) ; ControlLCATestUtil . testFocusListener ( fileUpload ) ; ControlLCATestUtil", "gt": ". testMouseListener ( fileUpload ) ;", "prediction": ". testCloseListener ( fileUpload ) ;\n", "label": 1}
{"id": 1851, "input": "<s> class MulticatchNotSupported { class E1 extends Exception { } class E2 extends Exception { } void e1 ( ) throws E1 { } void e2 ( ) throws E2 { } void m ( ) { try { e1 ( ) ; e2 ( ) ; } catch ( final E1 | E2 e ) { e", "gt": ". printStackTrace ( ) ;", "prediction": "1 ( e ) ;\n", "label": 0}
{"id": 15928, "input": "<s> package org . eclipse . xtext . xdoc . ui . autoedit ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DocumentCommand ; import org . eclipse . jface . text . IAutoEditStrategy ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentExtension4 ; import org . eclipse . jface . text . IRegion ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . events . VerifyEvent ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . xtext . ui . editor . autoedit . AbstractEditStrategy ; import org . eclipse . xtext . ui . editor . autoedit . DefaultAutoEditStrategyProvider ; public class AutoEditProvider extends DefaultAutoEditStrategyProvider { protected static class LineBreakInserter extends AbstractEditStrategy { private Widget widget ; private final IAutoEditStrategy defaultStrategy ; protected LineBreakInserter ( IAutoEditStrategy defaultStrategy ) { this . defaultStrategy = defaultStrategy ; } @ Override public void verifyKey ( VerifyEvent event ) { super . verifyKey ( event ) ; widget = event . widget ; } @ Override protected void internalCustomizeDocumentCommand ( IDocument document , DocumentCommand command ) throws BadLocationException { if ( command . text . equals ( \" \" ) && command . length == 0 ) { if ( widget instanceof StyledText ) { StyledText text = ( StyledText ) widget ; IRegion region = document . getLineInformationOfOffset ( command . offset ) ; String line = document . get ( region . getOffset ( ) , region . getLength ( ) ) ; String subLine = line . substring ( 0 , command . offset - region . getOffset ( ) ) ; int tabCount = count ( \"\\t\" , subLine ) ; int spacesForTabs = text . getTabs ( ) * tabCount ; int visibleOffset = subLine . length ( ) - tabCount + spacesForTabs ;", "gt": "if ( visibleOffset >= 100 )", "prediction": "if ( visibleOffset > 0 )\n", "label": 1}
{"id": 97, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; public class Build { public String milestone ; public String product ; public Integer product_id ; public Boolean is_active ; public String description ; public String name ; public Integer build_id ; public static class check_build extends TcmsArrayCommand { @ RequiredField public String name ; @ RequiredField public Integer productid ; } public static class create extends TcmsHashCommand { @ RequiredField public Integer product ; @", "gt": "RequiredField public String name ;", "prediction": "RequiredField public Integer product_id ;\n", "label": 0}
{"id": 15931, "input": "<s> package org . seage . metaheuristic . antcolony ; import java . util . * ; public class Ant { protected Graph _graph ; protected Node _startPosition ; protected Node _currentPosition ; protected double _distanceTravelled ; protected Vector < Node > _visited ; protected Vector < Edge > _path ; protected AntBrain _brain ; private double _qantumPheromone ; public Ant ( AntBrain brain , Graph graph , double qantumPheromone ) { _brain = brain ; _graph = graph ; _qantumPheromone = qantumPheromone ; } protected Vector < Edge > explore ( Node startingNode ) { _visited = new Vector < Node > ( ) ; _path = new Vector < Edge > ( ) ; _brain . _startingNode = startingNode ; _currentPosition = startingNode ; _visited . add ( startingNode ) ; List < Edge > edges = _brain . getAvailableEdges ( _currentPosition , _visited ) ; while ( edges != null && edges . size ( ) > 0 ) { Edge nextEdge = _brain . selectNextEdge ( edges , _visited ) ; updatePosition ( nextEdge ) ; edges = _brain . getAvailableEdges ( _currentPosition , _visited ) ; } leavePheromone ( ) ; return _path ; } protected", "gt": "void updatePosition ( Edge arcChoice )", "prediction": "Vector < Edge > explore ( Node startingNode )\n", "label": 1}
{"id": 9281, "input": "<s> package org . ofbiz . accounting . payment ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . Collection ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . accounting . invoice . InvoiceWorker ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityJoinOperator ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . entity . util . EntityUtilProperties ; import org . ofbiz . order . order . OrderChangeHelper ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . party . contact . ContactHelper ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import com . ibm . icu . util . Calendar ; public class PaymentGatewayServices { public static final String module =", "gt": "PaymentGatewayServices . class . getName ( ) ;", "prediction": "\"org.ofbiz.accounts\" ;\n", "label": 0}
{"id": 15936, "input": "<s> package org . eclipse . ui . contexts ; public abstract class ContextException extends Exception { private static final long serialVersionUID = - 5143404124388080211L ; private Throwable cause ; public ContextException ( String message ) { super ( message ) ; } public ContextException ( String message , Throwable cause ) {", "gt": "super ( message ) ;", "prediction": "super ( message , cause ) ;\n", "label": 1}
{"id": 5304, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public abstract class AbstractXCodeBuildMojo extends AbstractXCodeMojo { protected final static List < String > DEFAULT_BUILD_ACTIONS = Collections . unmodifiableList ( Arrays . asList ( \"clean\" , \"build\" ) ) ; protected List < String > buildActions ; protected String codeSignIdentity ; protected String provisioningProfile ; protected String target ; protected XCodeContext getXCodeContext ( ) { final String projectName = project . getArtifactId ( ) ; final File projectDirectory = getXCodeCompileDirectory ( ) ; final XCodeContext context = new XCodeContext ( ) ; context . setProjectName ( projectName ) ;", "gt": "context . setBuildActions ( getBuildActions ( ) ) ;", "prediction": "context . setProjectDirectory ( projectDirectory ) ;\n", "label": 0}
{"id": 15940, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec4 . sub4 ; import org . restlet . Component ; import org . restlet . data . Protocol ; public class CachingServer { public static void main ( String [ ] args ) throws Exception { Component", "gt": "component = new Component ( ) ;", "prediction": "component = new Component ( ) ;\n", "label": 1}
{"id": 6228, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class SRVRecord extends Record { private static final long serialVersionUID = - 3886460132387522052L ; private int priority , weight , port ; private Name target ; SRVRecord ( ) { } Record getObject ( ) { return new SRVRecord ( ) ; } public SRVRecord ( Name name , int dclass , long ttl , int priority , int weight , int port , Name target ) { super ( name , Type . SRV , dclass , ttl ) ; this . priority = checkU16 ( \"priority\" , priority ) ; this . weight = checkU16 ( \"weight\" , weight ) ; this . port = checkU16 ( \"port\" , port ) ; this . target = checkName ( \"target\" , target ) ; } void rrFromWire ( DNSInput in ) throws IOException { priority = in . readU16 ( ) ; weight = in . readU16 ( ) ; port = in . readU16 ( ) ; target = new Name ( in ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { priority = st . getUInt16 ( ) ; weight = st . getUInt16 ( ) ; port = st . getUInt16 ( ) ; target", "gt": "= st . getName ( origin ) ;", "prediction": "= new Name ( st ) ;\n", "label": 0}
{"id": 15945, "input": "<s> package org . eclipse . rap . internal . design . example . managers ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IContributionManagerOverrides ; import org . eclipse . jface . internal . provisional . action . ToolBarManager2 ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . ToolBar ; public class ToolBarManager extends ToolBarManager2 { public ToolBarManager ( ) { super ( ) ; } public void addPropertyChangeListener ( IPropertyChangeListener listener ) { } public ToolBar createControl ( Composite parent ) { return super . createControl ( parent ) ; } public Control createControl2 ( Composite parent ) { return createControl ( parent ) ; } public void dispose ( ) { super . dispose ( ) ; } public ToolBar getControl ( ) { return super . getControl ( ) ; } public Control getControl2 ( ) { return super . getControl2 ( ) ; } public int getItemCount ( ) { return super . getItems ( ) . length ; } public void removePropertyChangeListener ( IPropertyChangeListener listener ) { } public void setOverrides ( IContributionManagerOverrides newOverrides ) { super . setOverrides ( newOverrides ) ; } public void add ( IAction action ) { super . add ( action ) ; } public void add ( IContributionItem item ) { super . add ( item ) ; } public void appendToGroup ( String groupName , IAction action ) { super . appendToGroup ( groupName , action ) ; } public void appendToGroup ( String groupName , IContributionItem item ) { super . appendToGroup ( groupName , item ) ; } public IContributionItem find ( String id ) { return super . find ( id ) ; } public IContributionItem [ ] getItems ( ) { return super . getItems ( ) ; } public IContributionManagerOverrides getOverrides ( ) { return super . getOverrides ( ) ; } public void insertAfter ( String id , IAction action ) { super . insertAfter ( id , action ) ; } public void insertAfter ( String id , IContributionItem item ) { super . insertAfter ( id , item ) ; } public void insertBefore ( String id , IAction action ) { super . insertBefore ( id , action ) ; } public void", "gt": "insertBefore ( String id , IContributionItem item )", "prediction": "insertBefore ( String id , IContributionItem item )\n", "label": 1}
{"id": 6020, "input": "<s> import java . security . * ; public class T6379327 { public static void main ( String [ ] args ) { final String name = args [ 0 ] ; try { new PrivilegedExceptionAction ( ) {", "gt": "public Object run ( ) throws ClassNotFoundException", "prediction": "public void run ( ) throws Exception\n", "label": 0}
{"id": 15959, "input": "<s> package actors ; import graphics . Sprite ; import java . io . File ; import java . util . ArrayList ; import java . util . prefs . Preferences ; import org . ini4j . Ini ; import org . ini4j . IniPreferences ; public class Enemy extends Actor { public static final String [ ] AVAILABLEENEMIES = new ArrayList < String > ( ) { { for ( String s : new File ( \"data/actors/enemies/info\" ) . list ( ) ) if ( s . endsWith ( \".ini\" ) ) this . add ( s . substring ( 0 , s . length ( ) - 4 ) ) ; } } . toArray ( new String [ ] { } ) ; public static final int SMALL = 33 ; public static final int MEDIUM = 49 ; public static final int LARGE = 64 ; public static final int FULL = 106 ; int goldReward = 0 ; int size = MEDIUM ; String displayName ; String spriteName ; public Enemy ( String n ) { try { name = n ; Preferences p = new IniPreferences ( new Ini ( new File ( \"data/actors/enemies/info/\" + name + \".ini\" ) ) ) ; Preferences dist = p . node ( \"distribution\" ) ; Preferences elem = p . node ( \"elemental\" ) ; Preferences main = p . node ( \"enemy\" ) ; maxhp = dist . getInt ( \"hp\" , 1 ) ; hp = maxhp ; String [ ] m = dist . get ( \"mp\" , \"0/0/0/0/0/0/0/0\" ) . split ( \"/\" ) ; for ( int i = 0 ; i < m . length && i < mp . length ; i ++ ) { mp [ i ] [ 0 ] = Integer . parseInt ( m [ i ] ) ; mp [ i ] [ 1 ] = Integer . parseInt ( m [ i ] ) ; } str = dist . getInt ( \"str\" , 1 ) ; def = dist . getInt ( \"def\" , 1 ) ; itl = dist . getInt ( \"int\" , 1 ) ; spd = dist . getInt ( \"spd\" , 1 ) ; evd = dist . getInt ( \"evd\" , 1 ) ; acc = dist . getInt ( \"acc\" , 1 ) ; vit = dist . getInt ( \"vit\" , 1 ) ; fire = elem . getInt ( \"fire\" , 1 ) ; frez = elem . getInt (", "gt": "\"frez\" , 1 ) ;", "prediction": "\"frez\" , 1 ) ;\n", "label": 1}
{"id": 8125, "input": "<s> public class ClassLit { public static void main ( String [ ] args ) { ClassLit t = new ClassLit ( ) ; if ( t . getClass ( ) != ClassLit . class ) throw new Error ( ) ; int [ ] a = new int [ 2 ] ; if ( a . getClass ( ) != int [ ] . class ) throw new Error ( ) ; if ( int . class != Integer . TYPE", "gt": ") throw new Error ( ) ;", "prediction": ") throw new Error ( ) ;\n", "label": 0}
{"id": 15962, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . internal . intro . IntroDescriptor ; import org . eclipse . ui . intro . IIntroSite ; final class ViewIntroAdapterSite implements IIntroSite { private IntroDescriptor descriptor ; private IViewSite viewSite ; public ViewIntroAdapterSite ( IViewSite viewSite , IntroDescriptor descriptor ) { this . viewSite = viewSite ; this . descriptor = descriptor ; } public IActionBars getActionBars ( ) { return viewSite . getActionBars ( ) ; } public Object getAdapter ( Class adapter ) { return viewSite . getAdapter ( adapter ) ; } public String getId ( ) { return descriptor . getId ( ) ; } public IWorkbenchPage getPage ( ) { return viewSite", "gt": ". getPage ( ) ;", "prediction": ". getPage ( ) ;\n", "label": 1}
{"id": 9889, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . RollupResource ; public class RollupResourceImpl extends ReportAttributeImpl implements RollupResource { protected LogicalExpression expression ; protected RollupResourceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getRollupResource ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . ROLLUP_RESOURCE__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . ROLLUP_RESOURCE__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . ROLLUP_RESOURCE__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . ROLLUP_RESOURCE__EXPRESSION , newExpression , newExpression ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . ROLLUP_RESOURCE__EXPRESSION : return basicSetExpression ( null , msgs ) ; } return", "gt": "super . eInverseRemove ( otherEnd , featureID , msgs ) ;", "prediction": "super . eInverseRemove ( otherEnd , featureID , msgs ) ;\n", "label": 0}
{"id": 15965, "input": "<s> package org . restlet . test . data ; import java . io . File ; import org . restlet . data . LocalReference ; import org . restlet . test . RestletTestCase ; public class FileReferenceTestCase extends RestletTestCase { public void testCreation ( ) { String path = \"D:\\\\Restlet\\\\build.xml\" ; LocalReference fr = LocalReference . createFileReference ( path ) ; fr . getFile ( ) ; assertEquals ( \"file\"", "gt": ", fr . getScheme ( ) ) ;", "prediction": ", fr . getType ( ) ) ;\n", "label": 1}
{"id": 6075, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposeableAdapterFactory ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ItemProviderAdapter ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleChildReference ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleChildReferenceItemProvider extends SimpleNodeReferenceItemProvider implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleChildReferenceItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; addReferencedSimpleNodePropertyDescriptor ( object ) ; } return itemPropertyDescriptors ; } protected void addReferencedSimpleNodePropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleChildReference_referencedSimpleNode_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleChildReference_referencedSimpleNode_feature\" , \"_UI_SimpleChildReference_type\" ) , SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE__REFERENCED_SIMPLE_NODE , true , false , true , null , null , null ) ) ; } @ Override public Object getImage ( Object object ) { return overlayImage ( object , getResourceLocator ( ) . getImage ( \"full/obj16/SimpleChildReference\" ) ) ; } @ Override public", "gt": "String getText ( Object object )", "prediction": "void dispose ( )\n", "label": 0}
{"id": 15966, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; public class ReadDispose_Test extends TestCase { @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakeResponseWriter ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testWidgetDisposal ( ) throws Exception { Fixture . fakeNewRequest ( ) ; RWTFactory . getEntryPointManager ( ) . registerByName ( EntryPointUtil . DEFAULT , WidgetDisposalEntryPoint . class ) ; RWTLifeCycle lifeCycle = ( RWTLifeCycle ) RWTFactory . getLifeCycleFactory ( ) . getLifeCycle ( ) ; lifeCycle . execute ( ) ; Fixture . fakeNewRequest ( ) ; lifeCycle . execute ( ) ; Fixture . fakeNewRequest ( ) ; String buttonId = WidgetDisposalEntryPoint . buttonId ; Fixture . fakeNotifyOperation ( buttonId , ClientMessageConst . EVENT_WIDGET_SELECTED , null ) ; lifeCycle . execute ( ) ; } private static class WidgetDisposalEntryPoint implements IEntryPoint { private static String buttonId ; public int createUI ( ) { Display display = new Display ( ) ; Shell shell = new Shell ( display , SWT . NONE ) ; final Text text = new Text ( shell , SWT . MULTI ) ; final Tree tree = new Tree ( shell , SWT . SINGLE ) ; for ( int i = 0 ; i < 5 ; i ++ ) { TreeItem item = new TreeItem", "gt": "( tree , SWT . NONE ) ;", "prediction": "( tree , SWT . NONE ) ;\n", "label": 1}
{"id": 7276, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface LoadUnit extends ReportAttribute { LoadDisplayUnit getUnit ( ) ; void", "gt": "setUnit ( LoadDisplayUnit value ) ;", "prediction": "setUnit ( LoadDisplayUnit unit ) ;\n", "label": 0}
{"id": 15977, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . resources . JSLibraryConcatenator ; import org . eclipse . rap . rwt . resources . IResourceManager ; import org . eclipse . rap . rwt . testfixture . Fixture ; import junit . framework . TestCase ; public class JSLibraryConcatenator_Test extends TestCase { private static final byte [ ] CONTENT = new byte [ ] { ( byte ) 'a' } ; private JSLibraryConcatenator jsConcatenator ; private IResourceManager resourceManager ; protected void setUp ( ) { Fixture . setUp ( ) ; Fixture . useDefaultResourceManager ( ) ; resourceManager = RWTFactory . getResourceManager ( ) ; jsConcatenator = new JSLibraryConcatenator ( resourceManager ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConcatenation ( ) throws IOException { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; String location = jsConcatenator . getLocation ( ) ; assertEquals ( \"rwt-resources/resources.js\" , location ) ; assertTrue ( resourceManager . isRegistered ( \"resources.js\" ) ) ; assertEquals ( \"a\\n\" , getRegisteredContent ( \"resources.js\" ) ) ; } public void testActivate ( ) { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; jsConcatenator . deactivate ( ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } public void testIgnoreConcatenation ( ) { jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } public void testEmptyFileContent ( ) { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . appendJSLibrary ( new byte [ 0 ] ) ; jsConcatenator . activate ( ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } public void testIgnoreAppendJSLibraryAfterFinishJSConcatenation ( ) { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . activate ( ) ; jsConcatenator . appendJSLibrary ( CONTENT ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } String getRegisteredContent ( String location ) throws IOException { String result = null ; InputStream inputStream = resourceManager . getRegisteredContent ( location ) ; if ( inputStream != null ) { try { result = TestUtil . readContent (", "gt": "inputStream , \"UTF-8\" ) ;", "prediction": "inputStream ) ;\n", "label": 1}
{"id": 2296, "input": "<s> package org . osgi . framework . resource ; public interface Wire { Capability getCapability ( ) ;", "gt": "Requirement getRequirement ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15984, "input": "<s> package org . apache . lucene . search . spell ; import junit . framework . TestCase ; public class TestNGramDistance extends TestCase { public void testGetDistance1 ( ) { StringDistance nsd = new NGramDistance ( 1 ) ; float d = nsd . getDistance ( \"al\" , \"al\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = nsd . getDistance ( \"a\" , \"a\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = nsd . getDistance ( \"b\" , \"a\" ) ; assertEquals ( d , 0.0f , 0.001 ) ; d = nsd . getDistance ( \"martha\" , \"marhta\" ) ; assertEquals ( d , 0.6666 , 0.001 ) ; d = nsd . getDistance ( \"jones\" , \"johnson\" ) ; assertEquals ( d , 0.4285 , 0.001 ) ; d = nsd . getDistance ( \"natural\" , \"contrary\" ) ; assertEquals ( d , 0.25 , 0.001 ) ; d = nsd . getDistance ( \"abcvwxyz\" , \"cabvwxyz\" ) ; assertEquals ( d , 0.75 , 0.001 ) ; d = nsd . getDistance ( \"dwayne\" , \"duane\" ) ; assertEquals ( d , 0.666 , 0.001 ) ; d = nsd . getDistance ( \"dixon\" , \"dicksonx\" ) ; assertEquals ( d , 0.5 , 0.001 ) ; d = nsd . getDistance ( \"six\" , \"ten\" ) ; assertEquals ( d , 0 , 0.001 ) ; float d1 = nsd . getDistance ( \"zac ephron\" , \"zac efron\" ) ; float d2 = nsd . getDistance ( \"zac ephron\" , \"kai ephron\" ) ; assertEquals ( d1 , d2 , 0.001 ) ; d1 = nsd . getDistance ( \"brittney spears\" , \"britney spears\" ) ; d2 = nsd . getDistance ( \"brittney spears\" , \"brittney startzman\" ) ; assertTrue ( d1 > d2 ) ; d1 = nsd . getDistance ( \"12345678\" , \"12890678\" ) ; d2 = nsd . getDistance ( \"12345678\" , \"72385698\" ) ; assertEquals ( d1 , d2 , 001 ) ; } public void testGetDistance2 ( ) { StringDistance sd = new NGramDistance ( 2 ) ; float d = sd . getDistance ( \"al\" , \"al\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"a\" , \"a\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"b\" , \"a\" ) ; assertEquals ( d , 0.0f , 0.001 ) ; d = sd . getDistance ( \"a\" , \"aa\" ) ; assertEquals ( d , 0.5f , 0.001 ) ; d = sd . getDistance ( \"martha\" , \"marhta\" ) ; assertEquals ( d , 0.6666 , 0.001 ) ; d = sd . getDistance ( \"jones\" , \"johnson\" ) ; assertEquals ( d , 0.4285 , 0.001 ) ; d = sd . getDistance ( \"natural\" , \"contrary\" ) ; assertEquals ( d , 0.25 , 0.001 ) ; d = sd . getDistance ( \"abcvwxyz\" , \"cabvwxyz\" ) ; assertEquals ( d , 0.625 , 0.001 ) ; d = sd . getDistance ( \"dwayne\" , \"duane\" ) ; assertEquals ( d , 0.5833 , 0.001 ) ; d = sd . getDistance ( \"dixon\" , \"dicksonx\" ) ; assertEquals ( d , 0.5 , 0.001 ) ; d = sd . getDistance ( \"six\" , \"ten\" ) ; assertEquals ( d , 0 , 0.001 ) ; float d1 = sd . getDistance ( \"zac ephron\" , \"zac efron\" ) ; float d2 = sd . getDistance ( \"zac ephron\" , \"kai ephron\" ) ; assertTrue ( d1 > d2 ) ; d1 = sd . getDistance ( \"brittney spears\" , \"britney spears\" ) ; d2 = sd . getDistance ( \"brittney spears\" , \"brittney startzman\" ) ; assertTrue ( d1 > d2 ) ; d1 = sd . getDistance ( \"0012345678\" , \"0012890678\" ) ; d2 = sd . getDistance ( \"0012345678\" , \"0072385698\" ) ; assertEquals ( d1 , d2 , 0.001 ) ; } public void testGetDistance3 ( ) { StringDistance sd = new NGramDistance ( 3 ) ; float d = sd . getDistance ( \"al\" , \"al\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"a\" , \"a\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"b\" , \"a\" ) ; assertEquals ( d , 0.0f , 0.001 ) ; d = sd . getDistance ( \"martha\" , \"marhta\" ) ;", "gt": "assertEquals ( d , 0.7222 , 0.001 ) ;", "prediction": "assertEquals ( d , 0.6666 , 0.001 ) ;\n", "label": 1}
{"id": 6170, "input": "<s> public class ExprQualifiedType { static class Nested { static int i ; static void m ( ) { i = 1 ; } } static void test ( ) { new ExprQualifiedType ( ) . Nested . i = 1 ; new ExprQualifiedType ( ) . Nested", "gt": ". m ( ) ;", "prediction": ". m = 1 ;\n", "label": 0}
{"id": 15993, "input": "<s> package org . gatein . common . text ; import org . gatein . common . util . ParameterValidation ; public class TextTools { public static boolean isAlphaNumeric ( char c ) { return ( c >= '0' && c <= '9' ) || ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) ; } public static char toHex ( int z ) throws IllegalArgumentException { if ( z >= 0 && z < 10 ) { return ( char ) ( '0' + z ) ; } else if ( z >= 10 && z < 16 ) { return ( char ) ( 'A' - 10 + z ) ; } else { throw new IllegalArgumentException ( \"Wrong character\" ) ; } } public static String replace ( String string , String pattern , String replacement ) { StringBuffer buffer = new StringBuffer ( string . length ( ) ) ; int previous = 0 ; int current = string . indexOf ( pattern ) ; while ( current != - 1 ) { buffer . append ( string . substring ( previous , current ) ) ; buffer . append ( replacement ) ; previous = current + pattern . length ( ) ; current = string . indexOf ( pattern , previous ) ; } buffer . append ( string . substring ( previous ) ) ; return buffer . toString ( ) ; } public static String replaceAllInstancesOfBoundedString ( String initial , String prefix , String suffix , String replacement ) { return replaceBoundedString ( initial , prefix , suffix , replacement , true , false , false ) ; } public static String replaceAllInstancesOfBoundedString ( String initial , String prefix , String suffix , StringReplacementGenerator generator ) { return replaceBoundedString ( initial , prefix , suffix , generator , true , false , false ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , String replacement , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries ) { ParameterValidation . throwIllegalArgExceptionIfNull ( replacement , \"replacement\" ) ; return replaceBoundedString ( initial , prefix , suffix , new ConstantStringReplacementGenerator ( replacement ) , replaceIfBoundedStringEmpty , keepBoundaries , false ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , String replacement , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries , boolean suffixIsOptional ) { ParameterValidation . throwIllegalArgExceptionIfNull ( replacement , \"replacement\" ) ; return replaceBoundedString ( initial , prefix , suffix , new ConstantStringReplacementGenerator ( replacement ) , replaceIfBoundedStringEmpty , keepBoundaries , suffixIsOptional ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , StringReplacementGenerator generator , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries ) { return replaceBoundedString ( initial , prefix , suffix , generator , replaceIfBoundedStringEmpty , keepBoundaries , false ) ; } public static String replaceBoundedString ( final String initial , final String prefix , final String suffix , final StringReplacementGenerator generator , final boolean replaceIfBoundedStringEmpty , final boolean keepBoundaries , final boolean suffixIsOptional ) { if ( ParameterValidation . isNullOrEmpty ( initial ) ) { return initial ; } ParameterValidation . throwIllegalArgExceptionIfNull ( generator , \"StringReplacementGenerator\" ) ; ParameterValidation . throwIllegalArgExceptionIfNullOrEmpty ( prefix , \"prefix\" , \"TextTools.replaceBoundedString\" ) ; StringBuilder tmp = new StringBuilder ( initial ) ; int prefixIndex = tmp . indexOf ( prefix ) ; final int prefixLength = prefix . length ( ) ; boolean suffixAbsent = suffix == null ; int suffixLength = suffixAbsent ? 0 : suffix . length ( ) ; if ( ! suffixIsOptional && suffix != null && tmp . indexOf ( suffix ) == - 1 ) { return initial ; } while ( prefixIndex != - 1 ) { int suffixIndex ; if ( suffixAbsent ) { String match = tmp . substring ( prefixIndex + prefixLength ) ; if ( keepBoundaries ) { tmp . insert ( prefixIndex + prefixLength , generator . getReplacementFor ( match ,", "gt": "prefix , suffix , true ) ) ;", "prediction": "prefix ) ) ;\n", "label": 1}
{"id": 3848, "input": "<s> package api . better ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URL ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . util . List ; import api . son . MySon ; import api . soup . MySoup ; public class Better { private List < Response > response ; private String status ; public static Better init ( final BetterTypes types ) { String authkey = MySoup . getAuthKey ( ) ; String type = null ; switch ( types ) { case SINGLE : type = \"single\" ; } String url = \"ajax.php?action=better&method=\" + type + \"&auth=\" + authkey ; Better better = ( Better ) MySon . toObject ( url , Better . class ) ; return better ; } public void downloadAll ( String downloadLocation ) { for ( final Response r : response ) { String url = MySoup . getSite ( ) + r . getDownloadUrl ( ) ; String name = r . getGroupName ( ) + \" [\" + r . getGroupYear ( ) . toString ( ) + \"]\" ; try { downloadTorrent", "gt": "( url , downloadLocation , name ) ;", "prediction": "( url , name ) ;\n", "label": 0}
{"id": 15995, "input": "<s> package io . beancounter . profiles ; public class ProfilesException extends Exception { public ProfilesException ( String message , Exception e ) { super (", "gt": "message , e ) ;", "prediction": "message , e ) ;\n", "label": 1}
{"id": 804, "input": "<s> package com . sun . tools . javac . util ; public class FatalError extends Error { private static final long serialVersionUID = 0 ; public FatalError ( JCDiagnostic d ) { super ( d . toString ( ) ) ; } public FatalError ( JCDiagnostic", "gt": "d , Throwable t )", "prediction": "d )\n", "label": 0}
{"id": 15996, "input": "<s> package org . nuxeo . webengine . sites . fragments ; import java . text . SimpleDateFormat ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . webengine . WebEngine ; import org . nuxeo . ecm . webengine . model . WebContext ; import org . nuxeo . theme . fragments . AbstractFragment ; import org . nuxeo . theme . models . Model ; import org . nuxeo . theme . models . ModelException ; import org . nuxeo . webengine . sites . JsonAdapter ; import org . nuxeo . webengine . sites . models . WebpageCommentListModel ; import org . nuxeo . webengine . sites . models . WebpageCommentModel ; import org . nuxeo . webengine . sites . utils . SiteQueriesCollection ; import org . nuxeo . webengine . sites . utils . SiteUtils ; public class MinisiteLastCommentsFragment extends AbstractFragment { private int noComments = 5 ; private int noWordsFromContent = 50 ; @ Override public Model getModel ( ) throws ModelException { WebpageCommentListModel model = new WebpageCommentListModel ( ) ; if ( WebEngine . getActiveContext ( ) != null ) { WebContext ctx = WebEngine . getActiveContext ( ) ; CoreSession session = ctx . getCoreSession ( ) ; DocumentModel documentModel = ctx . getTargetObject ( ) . getAdapter ( DocumentModel . class ) ; try { DocumentModel ws = SiteUtils . getFirstWebSiteParent ( session , documentModel ) ; DocumentModelList comments = SiteQueriesCollection . queryLastComments ( session , ws . getPathAsString ( ) , noComments , SiteUtils . isCurrentModerated ( session , ws ) ) ; String pageTitle = null ; String pagePath = null ; for ( DocumentModel comment : comments ) { DocumentModel parentPage = SiteUtils . getPageForComment ( comment ) ; String author = SiteUtils . getUserDetails ( SiteUtils . getString ( comment , \"comment:author\" ) ) ; if ( parentPage != null ) { pageTitle = parentPage . getTitle ( ) ; pagePath = JsonAdapter . getRelativePath ( ws , parentPage ) . toString ( ) ; } String content = SiteUtils . getFistNWordsFromString ( SiteUtils . getString ( comment , \"comment:text\" ) , noWordsFromContent ) ; SimpleDateFormat simpleDateFormat = new SimpleDateFormat ( \"dd MMMM\" , WebEngine . getActiveContext ( ) . getLocale ( ) ) ; String formattedString = simpleDateFormat . format ( SiteUtils . getGregorianCalendar ( comment , \"comment:creationDate\" ) . getTime ( ) ) ; String [ ] splitFormattedString = formattedString . split ( \" \" ) ; WebpageCommentModel webpageCommentModel = new WebpageCommentModel ( pageTitle , pagePath , content , author , splitFormattedString [ 0 ] ,", "gt": "splitFormattedString [ 1 ] ) ;", "prediction": "splitFormattedString [ 1 ] ) ;\n", "label": 1}
{"id": 8401, "input": "<s> package org . dawb . workbench . plotting . printing ; import org . csstudio . swt . xygraph . figures . XYGraph ; import org . dawb . workbench . plotting . printing . PrintSettings . Orientation ; import org . dawb . workbench . plotting . printing . PrintSettings . Scale ; import org . eclipse . core . runtime . preferences . InstanceScope ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . printing . Printer ; import org . eclipse . swt . printing . PrinterData ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Canvas ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Dialog ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . preferences . ScopedPreferenceStore ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class PlotPrintPreviewDialog extends Dialog { private Shell shell ; private Display display ; private Canvas canvas ; private Printer printer ; private PrintMargin margin ; private Combo comboPrinterName ; private Combo comboScale ; private Button buttonAspectRatio ; protected String printScaleText = \"Scale\" ; protected String printButtonText = \"Print\" ; protected String printToolTipText = \"Print the plotting\" ; protected String printerSelectText = \"Select a printer\" ; protected String printPreviewText = \"Print preview\" ; protected String orientationText = \"Orientation\" ; protected String resolutionText = \"Resolution\" ; protected String portraitText = \"Portrait\" ; protected String landscapeText = \"Landscape\" ; protected String defaultPrinterText = \"Printer\" ; private PrintSettings settings ; private PrinterData [ ] printerNames ; private Image image ; private XYGraph xyGraph ; private String fileName = \"SDA plot\" ; private static final Logger logger = LoggerFactory . getLogger ( PlotPrintPreviewDialog . class ) ; public PlotPrintPreviewDialog ( XYGraph xyGraph , Display device , PrintSettings settings ) { super ( device . getActiveShell ( ) ) ; this . display = device ; if ( settings != null ) { this . settings = settings . clone ( ) ; } else { this . settings = new PrintSettings ( ) ; } this . printer = new Printer ( this . settings . getPrinterData ( ) ) ; this . xyGraph = xyGraph ; if ( getPreferenceAspectRatio ( ) ) image = xyGraph . getImage ( getImageSizeRect ( xyGraph ) ) ; else image = xyGraph . getImage ( getPrinterSizeRect ( printer ) ) ; } private Rectangle getImageSizeRect ( XYGraph xyGraph ) { int imageWidth = xyGraph . getBounds ( ) . width ; int imageHeight = xyGraph . getBounds ( ) . height ; int printWidth = printer . getBounds ( ) . width ; Point screenDPI = Display . getCurrent ( ) . getDPI ( ) ; Point printerDPI = printer . getDPI ( ) ; float scaleFactorX = printerDPI . x / screenDPI . x ; imageHeight = Math . round ( ( printWidth * imageHeight ) / imageWidth ) ; imageWidth = printWidth ; if ( scaleFactorX == 0 ) { scaleFactorX = screenDPI . x / printerDPI . x ; imageWidth = Math . round ( imageWidth * scaleFactorX ) ; imageHeight = Math . round ( imageHeight * scaleFactorX ) ; } else { imageWidth = Math . round ( imageWidth / scaleFactorX ) ; imageHeight = Math . round ( imageHeight / scaleFactorX ) ; } Rectangle rect = new Rectangle ( 0 , 0 ,", "gt": "imageWidth , imageHeight ) ;", "prediction": "imageWidth , imageHeight ) ;\n", "label": 0}
{"id": 15997, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . core . service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . platform . userworkspace . api . UserWorkspaceService ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . model . ComponentContext ; import org . nuxeo . runtime . model . ComponentInstance ; import org . nuxeo . runtime . model . DefaultComponent ; public class UserWorkspaceServiceImplComponent extends DefaultComponent { public static final String NAME = \"org.nuxeo.ecm.platform.userworkspace.UserWorkspaceService\" ; private static final Log log = LogFactory . getLog ( UserWorkspaceService . class ) ; protected UserWorkspaceDescriptor descriptor ; protected UserWorkspaceService userWorkspaceService ; @ Override public void activate ( ComponentContext context ) { log . info ( \"UserWorkspaceService activated\" ) ; } @ Override public void deactivate ( ComponentContext context ) { log . info ( \"UserWorkspaceService deactivated\" ) ; } @ Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter == UserWorkspaceService . class ) { try { return adapter . cast ( getUserWorkspaceService ( ) ) ; } catch ( Exception e ) { log . error ( \"error fetching UserWorkspaceManager: \" , e ) ; } } return null ; } private UserWorkspaceService getUserWorkspaceService ( ) throws ClientException { if ( userWorkspaceService == null ) { Class < ? > klass = descriptor . getUserWorkspaceClass ( ) ; if ( klass == null ) { throw new ClientException ( \"No class specified for the userWorkspace\" ) ; } try { userWorkspaceService = ( UserWorkspaceService ) klass . newInstance ( ) ; } catch ( InstantiationException e ) { throw new ClientException ( \"Failed to instantiate class \" +", "gt": "klass , e ) ;", "prediction": "klass , e ) ;\n", "label": 1}
{"id": 8667, "input": "<s> package javax . lang . model . util ; import javax . lang . model . type . * ; import javax . annotation . processing . SupportedSourceVersion ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; @ SupportedSourceVersion ( RELEASE_7 ) public class SimpleTypeVisitor7 < R , P", "gt": "> extends SimpleTypeVisitor6 < R , P >", "prediction": ">\n", "label": 0}
{"id": 16000, "input": "<s> package org . eclipse . ui . tests . session ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . part . ViewPart ; public class ViewWithState extends ViewPart { private static final String STATE = \"state\" ; public int fState = 0 ; public void createPartControl ( Composite parent ) { Label l = new Label ( parent , SWT . NONE ) ; l . setText ( \"This view should", "gt": "have some saved state: \" + fState ) ;", "prediction": "be disposed\" ) ;\n", "label": 1}
{"id": 2375, "input": "<s> package org . ofbiz . minilang . method . conditional ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . TimeZone ; import org . ofbiz . base . util . Assert ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . minilang . MiniLangUtil ; public abstract class Compare { private static final Map < String , Compare > INSTANCE_MAP = createInstanceMap ( ) ; private static void assertValuesNotNull ( Object lValue , Object rValue ) { if ( lValue == null ) { throw new IllegalArgumentException ( \"Cannot compare: l-value is null\" ) ; } if ( rValue == null ) { throw new IllegalArgumentException ( \"Cannot compare: r-value is null\" ) ; } } private static int compareBigDecimals ( BigDecimal lBigDecimal , BigDecimal rBigDecimal ) { int decimals = lBigDecimal . scale ( ) ; if ( rBigDecimal . scale ( ) < decimals ) { lBigDecimal = lBigDecimal . setScale ( rBigDecimal . scale ( ) , RoundingMode . UP ) ; } else if ( decimals < rBigDecimal . scale ( ) ) { rBigDecimal = rBigDecimal . setScale ( decimals , RoundingMode . UP ) ; } return lBigDecimal . compareTo ( rBigDecimal ) ; } private static Map < String , Compare > createInstanceMap ( ) { Map < String , Compare > writableMap = new HashMap < String , Compare > ( 10 ) ; writableMap . put ( \"contains\" , new CompareContains ( ) ) ; writableMap . put ( \"equals\" , new CompareEquals ( ) ) ; writableMap . put ( \"greater\" , new CompareGreater ( ) ) ; writableMap . put ( \"greater-equals\" , new CompareGreaterEquals ( ) ) ; writableMap . put ( \"is-empty\" , new CompareIsEmpty ( ) ) ; writableMap . put ( \"is-not-null\" , new CompareIsNotNull ( ) ) ; writableMap . put ( \"is-null\" , new CompareIsNull ( ) ) ; writableMap . put ( \"less\" , new CompareLess ( ) ) ; writableMap . put ( \"less-equals\" , new CompareLessEquals ( ) ) ; writableMap . put ( \"not-equals\" , new CompareNotEquals ( ) ) ; return Collections . unmodifiableMap ( writableMap ) ; } public static Compare getInstance ( String operator ) { Assert . notNull ( \"operator\" , operator ) ; return INSTANCE_MAP . get ( operator ) ; } public abstract boolean doCompare ( Object lValue , Object rValue , Class < ? > type , Locale locale , TimeZone timeZone , String format ) throws Exception ; private static final class CompareContains extends Compare { @ SuppressWarnings ( \"unchecked\" ) @ Override public boolean doCompare ( Object lValue , Object rValue , Class < ? > type , Locale locale , TimeZone timeZone , String format ) throws Exception { if ( lValue == null || lValue == GenericEntity . NULL_FIELD ) { return false ; } try { Collection collection = ( Collection ) lValue ; return collection . contains ( rValue ) ; } catch ( ClassCastException e ) { } if ( lValue instanceof String && rValue instanceof String ) { return ( ( String ) lValue ) . contains ( ( String ) rValue ) ; } throw new IllegalArgumentException ( \"Cannot compare: l-value is not a collection\" ) ; } } private", "gt": "static final class CompareEquals extends Compare", "prediction": "static int compareBigDecimals ( BigDecimal lBigDecimal , BigDecimal rBigDecimal )\n", "label": 0}
{"id": 16005, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; final class ArrayFontDescriptor extends FontDescriptor { private FontData [ ] data ; private Font originalFont = null ; public ArrayFontDescriptor ( FontData [ ] data ) { this . data = data ; } public ArrayFontDescriptor ( Font originalFont ) { this ( originalFont . getFontData ( ) ) ; this . originalFont = originalFont ; } public FontData [ ] getFontData ( ) { return copy ( data ) ; } public Font createFont ( Device device ) { if ( originalFont != null ) { if ( originalFont . getDevice ( ) == device ) { return originalFont ; } } return new Font ( device , data ) ; } public boolean equals ( Object obj ) { if ( ( obj . getClass ( ) == ArrayFontDescriptor . class ) ) { ArrayFontDescriptor descr = ( ArrayFontDescriptor ) obj ; if ( descr . originalFont != originalFont ) { return false ; } if ( originalFont != null ) { return true ; } if ( data . length != descr . data . length ) { return false ; } for ( int i = 0 ; i < data . length ; i ++ ) { FontData fd = data [ i ] ; FontData fd2 = descr . data [ i ] ; if ( ! fd . equals ( fd2 ) ) { return false ; } } return true ; } return false ; } public int hashCode ( ) { if ( originalFont != null ) { return originalFont . hashCode ( ) ; } int code = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { FontData fd = data [ i ] ; code += fd . hashCode ( ) ; } return code ; } public void destroyFont ( Font previouslyCreatedFont ) { if", "gt": "( previouslyCreatedFont == originalFont )", "prediction": "( originalFont != null )\n", "label": 1}
{"id": 10051, "input": "<s> package org . bombusim . xmpp ; import java . util . ArrayList ; import org . bombusim . xml . Attributes ; import org . bombusim . xml . XMLUtils ; public class XmppObject { private final static int MAX_CHILDS = 400 ; private String tagName ; protected ArrayList < XmppObject > childBlocks ; protected String textData = null ; protected XmppObject parent ; protected Attributes attributes ; public XmppObject ( ) { this ( \"\" , null , null ) ; } public XmppObject ( XmppObject parent , Attributes attr ) { this ( \"\" , parent , attr ) ; } public XmppObject ( String tagName , XmppObject parent , Attributes attr ) { this . parent = parent ; this . attributes = attr ; this . tagName = tagName ; } public XmppObject ( XmppObject parent , String tagName , String body ) { this ( tagName , parent , null ) ; setText ( body ) ; } public void addChild ( XmppObject newData ) { if ( childBlocks == null ) childBlocks = new ArrayList < XmppObject > ( ) ; if ( childBlocks . size ( ) < MAX_CHILDS ) childBlocks . add ( newData ) ; } public XmppObject addChild ( String name , String text ) { XmppObject child = new XmppObject ( name , this , null ) ; if ( text != null ) child . setText ( text ) ; addChild ( child ) ; return child ; } public XmppObject addChildNs ( String name , String xmlns ) { XmppObject child = addChild ( name , null ) ; child . setNameSpace ( xmlns ) ; return child ; } public void setText ( String text ) { textData = text ; } public XmppObject getParent ( ) { return parent ; } public byte [ ] getBytes ( ) { return toString ( ) . getBytes ( ) ; } public String getText ( ) { return ( textData == null ) ? \"\" : textData . toString ( ) ; } public String getAttribute ( String name ) { return attributes . getValue ( name ) ; } public String getTypeAttribute ( ) { return getAttribute ( \"type\" ) ; } public boolean compareNameSpace ( String xmlns ) { String xmlnsatr = getAttribute ( \"xmlns\" ) ; if ( xmlnsatr == null ) return false ; return xmlnsatr . equals ( xmlns ) ; } public String getNamespace ( ) { return getAttribute ( \"xmlns\" ) ; } public XmppObject setNameSpace ( String xmlns ) { return setAttribute ( \"xmlns\" , xmlns ) ; } public XmppObject setAttribute ( String attributeName , String value ) { if ( attributeName", "gt": "== null ) return this ;", "prediction": "== null )\n", "label": 0}
{"id": 16010, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . io . File ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task . standalone . commands . LoadJarPlaceholder ; @ Deprecated public class LoadJar extends LoadJarPlaceholder { private static final Log log = LogFactory . getLog (", "gt": "LoadJar . class ) ;", "prediction": "LoadJar . class ) ;\n", "label": 1}
{"id": 4555, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Resource extends Property , ResourceAttribute { String getId ( ) ; void setId ( String value ) ; String getName ( ) ; void setName ( String value ) ;", "gt": "EList < ResourceAttribute > getAttributes ( ) ;", "prediction": "}\n", "label": 0}
{"id": 16011, "input": "<s> package org . modelgoon . classes . model ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . modelgoon . core . AbstractConnection ; import org . modelgoon . core . ModelElement ; public class ClassElement extends ModelElement { String qualifiedName ; boolean isAbstract ; boolean internal ; boolean isInterface ; Map < String , Attribute > attributes = new HashMap < String , Attribute > ( ) ; Map < String , Method > methods = new HashMap < String , Method > ( ) ; List < AbstractConnection > incomingConnections = new ArrayList < AbstractConnection > ( ) ; List < AbstractConnection > outgoingConnections = new ArrayList < AbstractConnection > ( ) ; public final void setQualifiedName ( final String qualifiedName ) { this . qualifiedName = qualifiedName ; propertyChanged ( ) ; } public final String getQualifiedName ( ) { return this . qualifiedName ; } public void addAttribute ( final Attribute attribute ) { this . attributes . put ( attribute . getName ( ) , attribute ) ; propertyChanged ( ) ; } public Collection < Attribute > getAttributes ( ) { return this . attributes . values ( ) ; } public void setAbstract ( final boolean isAbstract ) { this . isAbstract = isAbstract ; propertyChanged ( ) ; } public boolean isAbstract ( ) { return this . isAbstract ; } public void setInterface ( final boolean isInterface ) { this . isInterface = isInterface ; propertyChanged ( ) ; } public boolean isInterface ( ) { return this . isInterface ; } public void setInternal ( final boolean internal ) { this . internal = internal ; propertyChanged ( ) ; } public boolean isInternal ( ) { return this . internal ; } public void addIncomingConnection ( final AbstractConnection connection ) { this .", "gt": "incomingConnections . add ( connection ) ;", "prediction": "incomingConnections . add ( connection ) ;\n", "label": 1}
{"id": 2932, "input": "<s> public class AssignmentSameType3 { public static void main ( String [ ] args ) { Ref < B > exact = null ; Ref < ? extends B > ebound = null ; Ref", "gt": "< ? super B > sbound = null ;", "prediction": "< ? extends B > especial = null ;\n", "label": 0}
{"id": 16018, "input": "<s> package org . nlogo . extensions . sound ; import java . net . URL ; public class PlaySoundAndWait implements org . nlogo . api . Command { public String getAgentClassString ( ) { return \"OTP\" ; } public org . nlogo . api . Syntax getSyntax ( ) { int [ ] right = { org . nlogo . api . Syntax . StringType ( ) , } ; return org . nlogo . api . Syntax . commandSyntax ( right ) ; } public boolean getSwitchesBoolean ( ) { return false ; } public org . nlogo . api . Command newInstance ( String name ) { return new PlaySoundAndWait ( ) ; } public void perform ( org . nlogo . api . Argument args [ ] , org . nlogo . api . Context context ) throws org . nlogo . api . ExtensionException , org . nlogo . api . LogoException { try { String soundpath = args [ 0 ] . getString ( ) ; URL soundurl ; soundpath = context", "gt": ". attachCurrentDirectory ( soundpath ) ;", "prediction": ". getResource ( soundpath ) ;\n", "label": 1}
{"id": 7927, "input": "<s> package com . matburt . mobileorg . Settings ; import java . util . ArrayList ; import android . app . Activity ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . content . res . Resources ; import android . os . Bundle ; import android . os . Handler ; import android . os . HandlerThread ; import android . os . Looper ; import android . os . Message ; import android . preference . PreferenceManager ; import android . view . LayoutInflater ; import android . view . View ; import android . view . View . OnClickListener ; import android . view . ViewGroup ; import android . view . animation . Animation ; import android . view . animation . AnimationUtils ; import android . widget . AdapterView ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . CheckBox ; import android . widget . CompoundButton ; import android . widget . EditText ; import android . widget . ListView ; import android . widget . RadioButton ; import android . widget . RadioGroup ; import android . widget . TextView ; import android . widget . Toast ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Dropbox . Dropbox ; import com . matburt . mobileorg . Dropbox . DropboxLoginListener ; import com . matburt . mobileorg . Synchronizers . SSHSynchronizer ; import com . matburt . mobileorg . Synchronizers . UbuntuOneSynchronizer ; import com . matburt . mobileorg . Synchronizers . WebDAVSynchronizer ; import com . matburt . mobileorg . Views . PageFlipView ; import com . matburt . mobileorg . util . OrgUtils ; public class WizardActivity extends Activity { private final class UIHandler extends Handler { public static final int DISPLAY_UI_TOAST = 0 ; public UIHandler ( Looper looper ) { super ( looper ) ; } @ Override public void handleMessage ( Message msg ) { switch ( msg . what ) { case UIHandler . DISPLAY_UI_TOAST : { Context context = getApplicationContext ( ) ; Toast t = Toast . makeText ( context , ( String ) msg . obj , Toast . LENGTH_LONG ) ; progress . dismiss ( ) ; t", "gt": ". show ( ) ;", "prediction": ". show ( ) ;\n", "label": 0}
{"id": 16019, "input": "<s> package org . restlet ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . Protocol ; public abstract class Connector extends Restlet { private final List < Protocol > protocols ; public Connector ( Context context ) { this ( context , null ) ; } public Connector ( Context context , List < Protocol > protocols ) { super ( context ) ; if ( protocols == null ) { this . protocols = new CopyOnWriteArrayList < Protocol > ( ) ; } else { this .", "gt": "protocols = new CopyOnWriteArrayList < Protocol > ( protocols ) ;", "prediction": "protocols = protocols ;\n", "label": 1}
{"id": 4146, "input": "<s> package org . gk . ui . client . com . grid ; import java . util . Arrays ; import com . extjs . gxt . ui . client . Style . SelectionMode ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . GridEvent ; import com . extjs . gxt . ui . client . widget . grid . CheckBoxSelectionModel ; public class gkCheckBoxSelectionModel extends CheckBoxSelectionModel { private boolean autoSelect = true ; public boolean isAutoSelect ( ) { return autoSelect ; } public void setAutoSelect ( boolean autoSelect ) { this . autoSelect = autoSelect ; } public gkCheckBoxSelectionModel ( ) { selectionMode = SelectionMode . SIMPLE ; } @ Override protected void handleMouseDown ( GridEvent e ) { ModelData md = listStore . getAt ( e . getRowIndex ( ) ) ; int checkBoxColumnIdx = 0 ; if ( md != null ) { if ( isSelected ( md ) ) { if ( e . getColIndex ( ) == checkBoxColumnIdx ) { doDeselect ( Arrays . asList ( md ) , false ) ; } } else if ( e . isShiftKey ( ) && lastSelected != null ) { if ( autoSelect ) { select ( listStore . indexOf ( lastSelected ) , e . getRowIndex ( ) , e . isControlKey ( ) ) ; } } else { if ( autoSelect || e . getColIndex ( ) == checkBoxColumnIdx ) { doSelect ( Arrays . asList ( md ) , true , false ) ; } } } e . cancelBubble ( ) ; } @ Override protected", "gt": "void onKeyPress ( GridEvent e )", "prediction": "void handleKeyDown ( KeyEvent e )\n", "label": 0}
{"id": 16023, "input": "<s> package org . eclipse . ui . commands ; import java . util . Collection ; import java . util . Map ; import org . eclipse . core . commands . Category ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . CommandManager ; import org . eclipse . core . commands . IExecutionListener ; import org . eclipse . core . commands . ParameterType ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . SerializationException ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . commands . IHandler ; import org . eclipse . ui . menus . UIElement ; import org . eclipse . ui . services . IDisposable ; public interface ICommandService extends IDisposable { public static final String AUTOGENERATED_CATEGORY_ID = CommandManager . AUTOGENERATED_CATEGORY_ID ; public void addExecutionListener ( IExecutionListener listener ) ; public void defineUncategorizedCategory ( String name , String description ) ; public ParameterizedCommand deserialize ( String serializedParameterizedCommand ) throws NotDefinedException , SerializationException ; public Category getCategory ( String categoryId ) ; public Command getCommand ( String commandId ) ; public Category [ ] getDefinedCategories ( ) ; public Collection getDefinedCategoryIds ( ) ; public Collection getDefinedCommandIds ( ) ; public Command [ ] getDefinedCommands ( ) ; public Collection getDefinedParameterTypeIds ( ) ; public", "gt": "ParameterType [ ] getDefinedParameterTypes ( ) ;", "prediction": "CommandManager getCommandManager ( ) ;\n", "label": 1}
{"id": 5747, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gef . commands . Command ; import org . eclipse . gmf . runtime . diagram . ui . editparts . IGraphicalEditPart ; import org . eclipse . gmf . runtime . emf . commands . core . commands . DuplicateEObjectsCommand ; import org . eclipse . gmf . runtime . emf . type . core . requests . CreateElementRequest ; import org . eclipse . gmf . runtime . emf . type . core . requests . DuplicateElementsRequest ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleLinkMappingCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleTopNodeCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . providers . SimplemapElementTypes ; public class SimpleMappingItemSemanticEditPolicy extends SimplemapBaseItemSemanticEditPolicy { public SimpleMappingItemSemanticEditPolicy ( ) { super ( SimplemapElementTypes . SimpleMapping_79 ) ; } protected Command getCreateCommand ( CreateElementRequest req ) { if ( SimplemapElementTypes . SimpleTopNode_1001 == req . getElementType ( ) ) { return getGEFWrapper ( new SimpleTopNodeCreateCommand ( req ) ) ; } if ( SimplemapElementTypes . SimpleLinkMapping_1002 == req . getElementType ( ) ) { return getGEFWrapper ( new SimpleLinkMappingCreateCommand ( req ) ) ; } return super . getCreateCommand ( req ) ; } protected Command getDuplicateCommand ( DuplicateElementsRequest req ) { TransactionalEditingDomain editingDomain = ( ( IGraphicalEditPart ) getHost ( ) ) . getEditingDomain ( ) ; return getGEFWrapper ( new DuplicateAnythingCommand ( editingDomain , req ) ) ; } private static class DuplicateAnythingCommand extends DuplicateEObjectsCommand {", "gt": "public DuplicateAnythingCommand ( TransactionalEditingDomain editingDomain , DuplicateElementsRequest req )", "prediction": "public DuplicateAnythingCommand ( DuplicateElementsRequest req )\n", "label": 0}
{"id": 16024, "input": "<s> package org . apache . lucene . queryParser . standard . nodes ; import org . apache . lucene . queryParser . core . nodes . FieldQueryNode ; public class PrefixWildcardQueryNode extends WildcardQueryNode { private static final long serialVersionUID = 6851557641826407515L ; public PrefixWildcardQueryNode ( CharSequence field , CharSequence text , int begin , int end ) { super ( field , text , begin , end ) ; } public PrefixWildcardQueryNode ( FieldQueryNode fqn ) { this ( fqn . getField ( ) , fqn . getText ( ) , fqn .", "gt": "getBegin ( ) , fqn . getEnd ( ) ) ;", "prediction": "getBegin ( ) , fqn . getEnd ( ) ) ;\n", "label": 1}
{"id": 2206, "input": "<s> package org . ofbiz . ebaystore ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; import com . ebay . sdk . ApiContext ; import com . ebay . sdk . call . GetUserCall ; import com . ebay . soap . eBLBaseComponents . AddressType ; import com . ebay . soap . eBLBaseComponents . DetailLevelCodeType ; import com . ebay . soap . eBLBaseComponents . UserType ; public class EbayAccount { public static Map < String , Object > getEbayUser ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = FastMap . newInstance ( ) ; Delegator delegator = dctx . getDelegator ( ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; String productStoreId = ( String ) context . get ( \"productStoreId\" ) ; String email = null , cityName = null , companyName = null , country = null , firstName = null , lastName = null , name = null , phone = null , postalCode = null , stateOrProvince = null , street = null , street1 = null , street2 = null , status = null ; Map < String , Object > registrationAddress = FastMap . newInstance ( ) ; try { ApiContext apiContext = EbayStoreHelper . getApiContext ( productStoreId , locale , delegator ) ; GetUserCall getUserCall = new GetUserCall ( apiContext ) ; DetailLevelCodeType [ ] detailLevel = { DetailLevelCodeType . RETURN_ALL } ; getUserCall . setDetailLevel ( detailLevel ) ; UserType user = getUserCall . getUser ( ) ; if ( user != null ) { email = user . getEmail ( ) ; AddressType regAddress = user . getRegistrationAddress ( ) ; if ( regAddress != null ) { cityName = regAddress . getCityName ( ) ; companyName = regAddress . getCompanyName ( ) ; country = regAddress . getCountryName ( ) ; firstName = regAddress . getFirstName ( ) ; lastName = regAddress . getLastName ( ) ; name = regAddress . getName ( ) ; phone = regAddress . getPhone ( ) ; postalCode = regAddress . getPostalCode ( ) ; stateOrProvince = regAddress . getStateOrProvince ( ) ; street = regAddress . getStreet ( ) ; street1 = regAddress . getStreet1 ( ) ; street2 = regAddress . getStreet2 ( ) ; } if ( firstName == null && lastName == null && name != null ) { String nameArray [ ] = name . split ( \" \" ) ; firstName = nameArray [ 0 ] ; lastName = nameArray [ 1 ] ; } registrationAddress . put ( \"cityName\" , cityName ) ; registrationAddress . put ( \"companyName\" , companyName ) ; registrationAddress . put ( \"country\" , country ) ; registrationAddress . put ( \"firstName\" , firstName ) ; registrationAddress . put ( \"lastName\" , lastName ) ; registrationAddress . put ( \"phone\" , phone ) ; registrationAddress . put ( \"postalCode\" , postalCode ) ; registrationAddress . put ( \"stateOrProvince\" , stateOrProvince ) ; registrationAddress . put ( \"street\" , street ) ; registrationAddress . put (", "gt": "\"street1\" , street1 ) ;", "prediction": "\"street1\" , street1 ) ;\n", "label": 0}
{"id": 16026, "input": "<s> package org . restlet . ext . jaxrs . internal . core ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . Variant ; import javax . ws . rs . core . Variant . VariantListBuilder ; import org . restlet . ext . jaxrs . internal . util . OneElementIterator ; import org . restlet . ext . jaxrs . internal . util . Util ; public class VariantListBuilderImpl extends VariantListBuilder { private static < T > Iterator < T > createIterator ( List < T > list ) { if ( ( list == null ) || list . isEmpty ( ) ) { return new OneElementIterator < T > ( null ) ; } return list . iterator ( ) ; } private List < MediaType > mediaTypes ; private List < Locale > languages ; private List < String > encodings ; private List < Variant > variants ; public VariantListBuilderImpl ( ) { } @ Override public VariantListBuilder add ( ) { buildVariants ( ) ; return this ; } @ Override public List < Variant > build ( ) { if ( Util . isNotEmpty ( this . encodings ) || Util . isNotEmpty ( this . languages ) || Util . isNotEmpty ( this . mediaTypes ) ) { buildVariants ( ) ; } List < Variant > variants = this . variants ; this . variants = null ; return variants ; } private void buildVariants ( ) { Iterator < MediaType > mediaTypeIter = createIterator ( this . mediaTypes ) ; if ( this . variants == null ) { this . variants = new ArrayList < Variant > ( ) ; } while ( mediaTypeIter . hasNext ( ) ) { MediaType mediaType = mediaTypeIter . next ( ) ; Iterator < Locale > languageIter = createIterator ( this . languages ) ; while ( languageIter . hasNext ( ) ) { Locale language = languageIter . next ( ) ; Iterator < String > encodingIter = createIterator ( this . encodings ) ; while ( encodingIter . hasNext ( ) ) { String encoding = encodingIter . next ( ) ; Variant variant = new Variant ( mediaType , language , encoding ) ; this . variants . add ( variant ) ; } } } this . encodings . clear ( ) ; this . languages . clear ( ) ; this . mediaTypes . clear ( ) ; } @ Override public VariantListBuilder encodings ( String ... encodings ) { if ( this . encodings == null ) { this . encodings = new ArrayList < String > ( ) ; } for ( String encoding : encodings ) { this . encodings . add ( encoding ) ; } return this ; } @ Override public VariantListBuilder", "gt": "languages ( Locale ... languages )", "prediction": "variants ( String ... variants )\n", "label": 1}
{"id": 5343, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . AnimalTamer ; import org . bukkit . entity . Tameable ; import Liza . LizaTameable ; public class LizaCraftTameable implements LizaTameable { private Tameable tameable ; public LizaCraftTameable ( Tameable tameable ) { this . tameable = tameable ; } @ Override public AnimalTamer getOwner ( ) { return this . tameable . getOwner ( ) ; } @ Override", "gt": "public boolean isTamed ( )", "prediction": "public String getName ( )\n", "label": 0}
{"id": 16032, "input": "<s> package org . eclipse . swt . widgets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . * ; public class TreeItem extends Item { private final TreeItem parentItem ; final Tree parent ; TreeItem [ ] items ; int itemCount ; private transient ITreeItemAdapter treeItemAdapter ; int index ; private Data [ ] data ; private Font font ; private boolean expanded ; private boolean checked ; private Color background ; private Color foreground ; private boolean grayed ; int depth ; private boolean cached ; private int flatIndex ; public TreeItem ( Tree parent , int style ) { this ( parent , null , style , parent == null ? 0 : parent . getItemCount ( ) , true ) ; } public TreeItem ( Tree parent , int style , int index ) { this ( parent , null , style , index , true ) ; } public TreeItem ( TreeItem parentItem , int style ) { this ( parentItem == null ? null : parentItem . parent , parentItem , style , parentItem == null ? 0 : parentItem . itemCount , true ) ; } public TreeItem ( TreeItem parentItem , int style , int index ) { this ( parentItem == null ? null : parentItem . parent , parentItem , style , index , true ) ; } TreeItem ( Tree parent , TreeItem parentItem , int style , int index , boolean create ) { super ( parent , style ) ; this . parent = parent ; this . parentItem = parentItem ; this . index = index ; if ( parentItem != null ) { depth = parentItem . depth + 1 ; } parent . isFlatIndexValid = false ; setEmpty ( ) ; if ( create ) { int numberOfItems ; if ( parentItem != null ) { numberOfItems = parentItem . itemCount ; } else { numberOfItems = parent . getItemCount ( ) ; } if ( index < 0 || index > numberOfItems ) { error ( SWT . ERROR_INVALID_RANGE ) ; } if ( parentItem != null ) { parentItem . createItem ( this , index ) ; } else { parent . createItem ( this , index ) ; } parent . updateScrollBars ( ) ; } } private void setEmpty ( ) { items = new TreeItem [ 4 ] ; } private void createItem ( TreeItem item , int index ) { if ( itemCount == items . length ) { boolean small = isVisible ( ) ; int length = small ? items . length + 4 : Math . max ( 4 , items . length * 3 / 2 ) ; TreeItem [ ] newItems = new TreeItem [ length ] ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; items = newItems ; } System . arraycopy ( items , index , items , index + 1 , itemCount - index ) ; items", "gt": "[ index ] = item ;", "prediction": "[ index ] = item ;\n", "label": 1}
{"id": 8492, "input": "<s> class BadlyTypedLabel1 { String m ( String s ) { switch ( s ) { case \"Hello World\" : return ( s ) ;", "gt": "case 42 : return ( \"Don't forget your towel!\" ) ;", "prediction": "}\n", "label": 0}
{"id": 16038, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . cdb . CommandDescriptorBlock ; import org . jscsi . target . util . BitManip ; import org . jscsi . target . util . ReadWrite ; public final class FieldPointerSenseKeySpecificData extends SenseKeySpecificData { private final boolean commandData ; private final boolean bitPointerValid ; private final int bitPointer ; private final short fieldPointer ; public FieldPointerSenseKeySpecificData ( final boolean senseKeySpecificDataValid , final boolean commandData , final boolean bitPointerValid , final int bitPointer , final int fieldPointer ) { super ( senseKeySpecificDataValid ) ; this . commandData = commandData ; this . bitPointerValid = bitPointerValid ; this . bitPointer = bitPointer ; this . fieldPointer = ( short ) fieldPointer ; } @ Override protected void serializeSpecificFields ( final ByteBuffer byteBuffer , final int index ) { byte b = byteBuffer . get ( index ) ; b = BitManip . getByteWithBitSet ( b , 6 , commandData ) ; b = BitManip . getByteWithBitSet ( b , 3 , bitPointerValid ) ; b &= ( bitPointer & 7 ) ; byteBuffer . put ( index , b ) ; ReadWrite . writeTwoByteInt ( byteBuffer , fieldPointer , byteBuffer .", "gt": "position ( ) ) ;", "prediction": "position ( ) ) ;\n", "label": 1}
{"id": 4708, "input": "<s> package org . ofbiz . pos . component ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import javax . swing . border . Border ; import net . xoetrope . swing . XButton ; import net . xoetrope . xui . XProjectManager ; import net . xoetrope . xui . style . XStyle ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; public class PosButtonWrapper { public static final String module = PosButtonWrapper . class . getName ( ) ; private static final String prefix = \"<html><center><font color=\\\"${FCOLOR}\\\">\" ; private static final String suffix = \"</font></center></html>\" ; private static final String disabledAll = \"buttonDisabled\" ; private static final String enabledMenu = \"posButton\" ; protected XStyle disabledStyle = null ; protected XStyle enabledStyle = null ; protected XButton xbutton = null ; protected boolean isEnabled = true ; protected String origText = null ; protected String name = null ; public PosButtonWrapper ( XButton button , String styleName ) { this . xbutton = button ; this . name = xbutton . getName ( ) ; this . origText = xbutton . getText ( ) ; this . disabledStyle = XProjectManager . getCurrentProject ( ) . getStyleManager ( ) . getStyle ( disabledAll ) ; if ( this . disabledStyle == null ) { Debug . logError ( \"ERROR: The disabled button style \\\"buttonDisabled\\\" was not found!\" , module ) ; } if ( styleName != null ) { this . enabledStyle = XProjectManager . getCurrentProject ( ) . getStyleManager ( ) . getStyle ( styleName ) ; if ( this . enabledStyle == null ) { Debug . logError ( \"ERROR: The enabled button style \\\"\" + styleName + \"\\\" was not found!\" , module ) ; } } else { this . enabledStyle = XProjectManager . getCurrentProject ( ) . getStyleManager ( ) . getStyle ( enabledMenu ) ; if ( this . enabledStyle == null ) { Debug . logError ( \"ERROR: The enabled button style \\\"\" + enabledMenu + \"\\\" was not found!\" , module ) ; } } try { this . updateText ( ) ; } catch ( Throwable t ) { Debug . logError ( t , module ) ; } } public void setEnabled ( boolean enable ) { this . isEnabled = enable ; this . updateText ( ) ; xbutton . setEnabled ( enable ) ; } public void updateText ( ) { if ( UtilValidate . isEmpty ( this . origText ) ) { return ; } StringBuffer newContent = new StringBuffer ( ) ; XStyle style = null ; if ( this . isEnabled ) { style = enabledStyle ; } else { style = disabledStyle ; } String fcolor = Integer . toHexString ( style . getStyleAsColor ( XStyle . COLOR_FORE )", "gt": ". getRGB ( ) & 0x00ffffff ) ;", "prediction": ") ;\n", "label": 0}
{"id": 16040, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . server . configuration ; import java . util . Map ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; public interface UserInfoMapper { Map < String , String", "gt": "> getUserInfo ( NuxeoPrincipal principal ) ;", "prediction": "> userInfo ;\n", "label": 1}
{"id": 8922, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; import com . sun . tools . doclets . internal . toolkit . Content ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class DocType extends Content { private String docType ; private static DocType transitional ; private static DocType frameset ; private DocType ( String type , String dtd ) { docType = \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 \" + type + \"//EN\\\" \\\"\" + dtd + \"\\\">\" + DocletConstants . NL ; } public static DocType Transitional ( ) { if ( transitional == null ) transitional = new DocType ( \"Transitional\" , \"http://www.w3.org/TR/html4/loose.dtd\" ) ; return transitional ; } public static DocType Frameset ( ) { if ( frameset == null ) frameset = new DocType ( \"Frameset\" , \"http://www.w3.org/TR/html4/frameset.dtd\" ) ; return frameset ; } public void addContent ( Content content ) { throw new DocletAbortException ( ) ; } public void addContent ( String stringContent ) { throw new DocletAbortException ( ) ; } public boolean isEmpty ( ) { return ( docType .", "gt": "length ( ) == 0 ) ;", "prediction": "length ( ) == 0 ) ;\n", "label": 0}
{"id": 16043, "input": "<s> package org . eclipse . swt . custom ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; import org . eclipse . swt . widgets . * ; public class TreeEditor_Test extends TestCase { private Display display ; private Shell shell ; public void testIsSerializable ( ) throws Exception { String itemText = \"item0\" ; Tree tree = new Tree ( shell , SWT . NONE ) ; new TreeColumn ( tree , SWT . NONE ) ; new TreeColumn ( tree , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; item . setText ( itemText ) ; TreeEditor treeEditor = new TreeEditor ( tree ) ; treeEditor . setColumn ( 1 ) ; treeEditor . setItem ( item ) ; TreeEditor deserializedTreeEditor = Fixture . serializeAndDeserialize ( treeEditor ) ; attachThread ( deserializedTreeEditor . getItem ( ) . getDisplay ( ) ) ; assertEquals ( 1 , deserializedTreeEditor . getColumn ( ) ) ; assertEquals ( itemText , deserializedTreeEditor . getItem ( ) . getText ( ) ) ; } protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } private static void", "gt": "attachThread ( Display display )", "prediction": "attachThread ( TreeItem item )\n", "label": 1}
{"id": 6498, "input": "<s> package pkg1 ; public class ClassUseTest1 < T extends Foo & Foo2 > { public < T extends Foo", "gt": "& Foo2 > T method ( T t )", "prediction": "2 > void testClassUse ( )\n", "label": 0}
{"id": 16050, "input": "<s> package org . restlet . test . ext . jaxrs . services . car ; import javax . ws . rs . GET ; import javax . ws . rs . Produces ; public class EngineResource { public static String getPlainRepr ( int carId ) { return \"This is the engine of car with id \" + carId + \".\" ; } private final CarResource car ; public EngineResource ( CarResource car ) { this . car = car ; } @ GET @ Produces ( \"text/plain\" ) public String getText ( ) { final", "gt": "int carId = this . car . getId ( ) ;", "prediction": "Car car = new Car ( ) ;\n", "label": 1}
{"id": 5787, "input": "<s> package org . ofbiz . entity . model ; import java . io . File ; import org . ofbiz . base . util . StringUtil ; public class ModelUtil { public static final String module = ModelUtil . class . getName ( ) ; public static String upperFirstChar ( String string ) { if ( string == null ) return null ; if ( string . length ( ) <= 1 ) return string . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( string ) ; sb . setCharAt ( 0 , Character . toUpperCase ( sb . charAt ( 0 ) ) ) ; return sb . toString ( ) ; } public static String lowerFirstChar ( String string ) { if ( string == null ) return null ; if ( string . length ( ) <= 1 ) return string . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( string ) ; sb . setCharAt ( 0 , Character . toLowerCase ( sb . charAt ( 0 ) ) ) ; return sb . toString ( ) ; } public static String dbNameToClassName ( String columnName ) { return upperFirstChar ( dbNameToVarName ( columnName ) ) ; } public static String dbNameToVarName ( String columnName ) { if ( columnName == null ) return null ; StringBuilder fieldName = new StringBuilder ( columnName . length ( ) ) ; boolean toUpper = false ; for ( int i = 0 ; i < columnName . length ( ) ; i ++ ) { char ch = columnName . charAt ( i ) ; if ( ch == '_' ) { toUpper = true ; } else if ( toUpper ) { fieldName . append ( Character . toUpperCase ( ch ) ) ; toUpper = false ; } else { fieldName . append ( Character . toLowerCase ( ch ) ) ; } } return fieldName . toString ( ) ; } public static String javaNameToDbName ( String javaName ) { if ( javaName == null ) return null ; if ( javaName . length ( ) <= 0 ) return \"\" ; StringBuilder dbName = new StringBuilder ( ) ; dbName . append ( Character . toUpperCase ( javaName . charAt ( 0 ) ) ) ; int namePos = 1 ; while ( namePos < javaName . length ( ) ) { char curChar = javaName . charAt ( namePos ) ; if ( Character . isUpperCase ( curChar ) ) dbName . append ( '_' ) ; dbName . append ( Character . toUpperCase ( curChar ) ) ; namePos ++ ; } return dbName . toString ( ) ; } public static String vowelBag = \"aeiouyAEIOUY\" ; public static String shortenDbName ( String dbName , int desiredLength ) { StringBuilder dbBuf = new StringBuilder ( dbName ) ; if ( dbBuf . length ( ) > desiredLength ) { for ( int i = dbBuf . length ( ) - 1 ; i > 0 ; i -- ) { if ( dbBuf . charAt ( i - 1 ) == '_' ) { continue ; } char curChar = dbBuf . charAt ( i ) ; if ( vowelBag . indexOf ( curChar ) > 0 ) { dbBuf . deleteCharAt ( i ) ; } } } while ( dbBuf . indexOf ( \"__\" ) > 0 ) { dbBuf . deleteCharAt ( dbBuf . indexOf ( \"__\" ) ) ; } while ( dbBuf . length ( ) > desiredLength ) { boolean removedChars = false ; int usIndex = dbBuf . lastIndexOf ( \"_\" ) ; while ( usIndex > 0 && dbBuf . length ( ) > desiredLength ) { int prevUsIndex = dbBuf . lastIndexOf ( \"_\" , usIndex - 1 ) ; if ( prevUsIndex < 0 && usIndex < 4 ) { break ; } if ( prevUsIndex >= 0 && ( usIndex - prevUsIndex ) <= 4 ) { usIndex = prevUsIndex ; continue ; } dbBuf . deleteCharAt ( usIndex - 2 ) ; removedChars = true ; if ( usIndex > 2 ) { usIndex = dbBuf . lastIndexOf ( \"_\" , usIndex - 2 ) ; } else { break ; } } if ( dbBuf . length ( ) > desiredLength ) { int removeIndex = dbBuf . length ( ) - 1 ; int prevRemoveIndex = dbBuf . lastIndexOf ( \"_\" , removeIndex - 1 ) ; if ( prevRemoveIndex < 0 || ( removeIndex - prevRemoveIndex ) >= 3 ) { dbBuf . deleteCharAt ( removeIndex - 1 ) ; removedChars = true ; } } while ( dbBuf . indexOf ( \"__\" ) > 0 ) { dbBuf . deleteCharAt ( dbBuf . indexOf ( \"__\" ) ) ; removedChars = true ; } if ( ! removedChars ) { break ; } } while ( dbBuf . indexOf ( \"__\" ) > 0 ) { dbBuf . deleteCharAt ( dbBuf . indexOf ( \"__\" ) ) ; } while ( dbBuf . length ( ) > desiredLength ) { int firstUs = dbBuf . indexOf ( \"_\" ) ; if ( firstUs > 0 ) { int nextUs = dbBuf . indexOf ( \"_\" , firstUs + 1 ) ; if ( nextUs > 0 ) { dbBuf . delete ( firstUs , nextUs ) ; } } } return dbBuf . toString ( ) ; } public static String packageToPath ( String packageName ) { return packageName . replace ( '.' , File . separatorChar ) ; } public static String replaceString ( String mainString , String oldString , String newString ) { return StringUtil . replaceString ( mainString , oldString , newString ) ; } public static String induceFieldType ( String sqlTypeName , int length , int precision , ModelFieldTypeReader fieldTypeReader ) { if ( sqlTypeName == null ) return \"invalid\" ; if ( sqlTypeName . equalsIgnoreCase ( \"VARCHAR\" ) || sqlTypeName . equalsIgnoreCase ( \"VARCHAR2\" ) || ( sqlTypeName . equalsIgnoreCase ( \"CHAR\" ) && length > 1 ) ) { if ( length <= 10 ) return \"very-short\" ; if ( length <= 60 ) return \"short-varchar\" ; if ( length <= 255 ) return \"long-varchar\" ; return \"very-long\" ; } else if ( sqlTypeName . equalsIgnoreCase ( \"TEXT\" ) ) { return \"very-long\" ; } else if ( sqlTypeName . equalsIgnoreCase ( \"INT\" ) || sqlTypeName . equalsIgnoreCase ( \"SMALLINT\" ) || sqlTypeName . equalsIgnoreCase ( \"DECIMAL\" ) || sqlTypeName . equalsIgnoreCase ( \"NUMERIC\" ) ) { if ( length > 18 || precision > 6 ) return \"invalid-\" + sqlTypeName + \":\" + length + \":\" + precision ; if ( precision == 0 ) return \"numeric\" ; if ( precision == 2 ) return \"currency-amount\" ; if ( precision <= 6 ) return \"floating-point\" ; return \"invalid-\" + sqlTypeName + \":\" + length + \":\" + precision ; } else if ( sqlTypeName . equalsIgnoreCase ( \"BLOB\" ) || sqlTypeName .", "gt": "equalsIgnoreCase ( \"OID\" ) )", "prediction": "equalsIgnoreCase ( \"VARBINARY\" ) )\n", "label": 0}
{"id": 16052, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getAttachmentCollectionResult\" } ) @ XmlRootElement (", "gt": "name = \"GetAttachmentCollectionResponse\" ) public class GetAttachmentCollectionResponse", "prediction": "name = \"GetAttachmentCollectionResponse\" ) public class GetAttachmentCollectionResponse\n", "label": 1}
{"id": 6468, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Map ; import java . util . Arrays ; import java . util . Collections ; public class OptionChecker implements AnnotationProcessorFactory { static class OptionCheck implements AnnotationProcessor { AnnotationProcessorEnvironment ape ; OptionCheck ( AnnotationProcessorEnvironment ape ) { this . ape = ape ; } public void process ( ) { Map < String , String > options = ape . getOptions ( ) ; if ( options . containsKey ( \"-Afoo\" ) && options . containsKey ( \"-Abar\" ) && options . containsKey ( \"-classpath\" ) ) { System . out . println ( \"Expected options found.\" ) ; return ; } else { System . err . println ( \"Unexpected options values: \" + options ) ; throw new RuntimeException ( ) ; } } } static class HelloWorld implements AnnotationProcessor { AnnotationProcessorEnvironment ape ; HelloWorld ( AnnotationProcessorEnvironment ape ) { this . ape = ape ; } public void process ( ) { java . io . PrintWriter pw ; try { pw = ape . getFiler ( ) . createSourceFile ( \"HelloWorld\" ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } pw . println ( \"public class HelloWorld {\" ) ; pw . println ( \"  public static void main (String argv[]) {\" ) ; pw . println ( \"   ", "gt": "System.out.println(\\\"Hello apt world.\\\");\" ) ;", "prediction": "\" ) ;\n", "label": 0}
{"id": 16055, "input": "<s> package org . eclipse . ui . internal . cheatsheets . data ; import java . util . ArrayList ; import java . util . Collection ; public class CheatSheet implements ICheatSheet { protected String title ; private Item introItem ; private ArrayList items ; private boolean containsCommandOrAction ; public CheatSheet ( ) { } public void setTitle ( String title ) { this . title = title ; } public String getTitle ( ) { return title ; } public Item getIntroItem ( ) { return introItem ; } public ArrayList getItems ( ) { return items ; } public void setIntroItem ( Item intro ) { introItem = intro ; } public void addItem ( Item item ) { if ( items == null ) { items = new ArrayList ( ) ; } items . add ( item ) ; } public void addItems ( Collection c ) { if", "gt": "( items == null )", "prediction": "( items == null )\n", "label": 1}
{"id": 3539, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . gmf . mappings . NodeReference ; public interface SimpleNodeReference extends EObject { NodeReference getNodeReference ( ) ;", "gt": "void setNodeReference ( NodeReference value ) ;", "prediction": "}\n", "label": 0}
{"id": 16059, "input": "<s> package org . gatein . common . text ; import junit . framework . TestCase ; import org . gatein . common . text . CharToByteEncoder ; public class CharToByteEncoderTestCase extends TestCase { public void testCorrectness ( ) { CharToByteEncoder encoder = new CharToByteEncoder . Generic ( \"UTF8\" ) ; for ( int i = 0 ; i <= 0x10FFFD ; i ++ ) { char c = ( char ) i ; int type = Character . getType ( c ) ; byte [ ] r = encoder . encode ( c ) ; if ( type == Character . SURROGATE || type == Character . PRIVATE_USE ) { if", "gt": "( r . length != 0 )", "prediction": "( r == null )\n", "label": 1}
{"id": 5109, "input": "<s> package config ; import java . util . Properties ; public class DefaultConfig extends Properties { public DefaultConfig ( ) {", "gt": "setProperty ( \"volume\" , \"0\" ) ;", "prediction": "super ( ) ;\n", "label": 0}
{"id": 16065, "input": "<s> package org . eclipse . ui . internal ; import java . io . IOException ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . CommandManager ; import org . eclipse . core . commands . common . EventManager ; import org . eclipse . core . commands . contexts . ContextManager ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionDelta ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IExtensionRegistry ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IRegistryChangeEvent ; import org . eclipse . core . runtime . IRegistryChangeListener ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . ExternalActionManager ; import org . eclipse . jface . action . ExternalActionManager . CommandCallback ; import org . eclipse . jface . action . ExternalActionManager . IActiveChecker ; import org . eclipse . jface . action . ExternalActionManager . IExecuteApplicable ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . bindings . BindingManager ; import org . eclipse . jface . bindings . BindingManagerEvent ; import org . eclipse . jface . bindings . IBindingManagerListener ; import org . eclipse . jface . databinding . swt . SWTObservables ; import org . eclipse . jface . dialogs . ErrorDialog ; import org .", "gt": "eclipse . jface . dialogs . IDialogConstants ;", "prediction": "eclipse . swt . SWT ;\n", "label": 1}
{"id": 7510, "input": "<s> public class T6182630c { static class Foo < X > { public X x ; public void m ( X x ) { } } interface Bar { } < T extends Foo , S extends Foo & Bar", "gt": "> void test1 ( T t , S s )", "prediction": ">\n", "label": 0}
{"id": 16066, "input": "<s> package de . uos . igf . db3d . dbms . api ; public class DBMSException extends DB3DException { public DBMSException ( ) { super ( ) ; } public DBMSException ( String message ) { super ( message ) ; } public DBMSException (", "gt": "String message , Throwable cause )", "prediction": "Throwable cause )\n", "label": 1}
{"id": 7015, "input": "<s> package com . redhat . ceylon . importjar ; import java . io . File ; import javax . annotation . PostConstruct ; import com . redhat . ceylon . cmr . api . ArtifactContext ; import com . redhat . ceylon . cmr . api . Logger ; import com . redhat . ceylon . cmr . api . RepositoryManager ; import com . redhat . ceylon . cmr . ceylon . CeylonUtils ; import com . redhat . ceylon . cmr . impl . CMRException ; import com . redhat . ceylon . common . tool . Argument ; import com . redhat . ceylon . common . tool . Description ; import com . redhat . ceylon . common . tool . Option ; import com . redhat . ceylon . common . tool . OptionArgument ; import com . redhat . ceylon . common . tool . Tool ; import com . redhat . ceylon . common . tool . Summary ; @ Summary ( \"Imports a jar file into a Ceylon module repository\" ) @ Description ( \"Imports the given `<jar-file>` using the module name and version \" + \"given by `<module>` into the repository named by the \" + \"`--out` option.\\n\" + \"\\n\" + \"`<module>` is a module name and version separated with a slash, for example \" + \"`com.example.foobar/1.2.0`.\\n\" + \"\\n\" + \"`<jar-file>` is the name of the Jar file to import.\" ) public class CeylonImportJarTool implements Tool { private String module ; private String version ; private String out ; private String user ; private String pass ; private String jarFile ; private boolean verbose ; private Logger log = new CMRLogger ( ) ; public CeylonImportJarTool ( ) { } CeylonImportJarTool ( String moduleSpec , String out , String user , String pass , String jarFile , boolean verbose ) { parseModuleSpec ( moduleSpec ) ; this . out = out ; this . user = user ; this . pass = pass ; this . jarFile = jarFile ; this . verbose = verbose ; checkJarFile ( ) ; } @ OptionArgument ( argumentName = \"name\" ) @ Description ( \"Sets the user name for use with an authenticated output repository.\" ) public void setUser ( String user ) { this . user = user ; } public String getPass ( ) { return pass ; } @ OptionArgument ( argumentName = \"secret\" ) @ Description ( \"Sets the password for use with an authenticated output repository.\" ) public void setPass ( String pass ) { this . pass = pass ; } public boolean isVerbose ( ) { return verbose ; } @ Option @ Description ( \"Produce verbose output.\" ) public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public String getOut ( ) { return out ; } @ OptionArgument ( argumentName = \"dir-or-url\" ) @ Description ( \"Specifies the module repository (which must be publishable) \" + \"into which the jar file should be imported. \" + \"(default: `./modules`)\" ) public void setOut ( String out ) { this . out = out ; } @ Argument ( argumentName = \"module\" , multiplicity = \"1\" , order = 0 ) public void setModuleSpec ( String module ) { parseModuleSpec ( module ) ; } @ Argument ( argumentName = \"jar-file\" , multiplicity = \"1\" , order = 1 ) public void setFile ( String jarFile ) { this . jarFile = jarFile ; } @ PostConstruct public void checkJarFile ( ) { if ( jarFile == null || jarFile . isEmpty ( ) ) throw new ImportJarException ( \"error.jarFile.empty\" ) ; File f = new File ( jarFile ) ; if ( ! f . exists ( ) ) throw new ImportJarException ( \"error.jarFile.doesNotExist\" ) ; if ( f . isDirectory ( ) ) throw new ImportJarException ( \"error.jarFile.isDirectory\" ) ; if ( ! f . canRead ( ) ) throw new ImportJarException ( \"error.jarFile.notReadable\" ) ; if ( ! f . getName ( ) . toLowerCase ( ) . endsWith ( \".jar\" ) ) throw new ImportJarException ( \"error.jarFile.notJar\" ) ; } private void parseModuleSpec ( String moduleSpec ) { if ( moduleSpec == null || moduleSpec . isEmpty ( ) ) throw new ImportJarException ( \"error.moduleSpec.empty\" ) ; int sep = moduleSpec . indexOf ( \"/\" ) ; if ( sep != - 1 ) { this . module = moduleSpec . substring ( 0 , sep ) ; if ( this . module . isEmpty ( ) ) throw new ImportJarException ( \"error.moduleSpec.noName\" ) ; this . version = moduleSpec . substring ( sep + 1 ) ; if ( this . version . isEmpty ( ) ) throw new ImportJarException ( \"error.moduleSpec.noVersion\" ) ; } else { if ( ! \"default\" . equals ( moduleSpec )", "gt": ") throw new ImportJarException ( \"error.moduleSpec.missingVersion\" ) ;", "prediction": ")\n", "label": 0}
{"id": 16075, "input": "<s> package org . tartarus . snowball . ext ; import org . tartarus . snowball . SnowballProgram ; import org . tartarus . snowball . Among ; public class German2Stemmer extends SnowballProgram { private Among a_0 [ ] = { new Among ( \"\" , - 1 , 6 , \"\" , this ) , new Among ( \"ae\" , 0 , 2 , \"\" , this ) , new Among ( \"oe\" , 0 , 3 , \"\" , this ) , new Among ( \"qu\" , 0 , 5 , \"\" , this ) , new Among ( \"ue\" , 0 , 4 , \"\" , this ) , new Among ( \"\u00df\" , 0 , 1 , \"\" , this ) } ; private Among a_1 [ ] = { new Among ( \"\" , - 1 , 6 , \"\" , this ) , new Among ( \"U\" , 0 , 2 , \"\" , this ) , new Among ( \"Y\" , 0 , 1 , \"\" , this ) , new Among ( \"\u00e4\" , 0 , 3 , \"\" , this ) , new Among ( \"\u00f6\" , 0 , 4 , \"\" , this ) , new Among ( \"\u00fc\" , 0 , 5 , \"\" , this ) } ; private Among a_2 [ ] = { new Among ( \"e\" , - 1 , 1 , \"\" , this ) , new Among ( \"em\" , - 1 , 1 , \"\" , this ) , new Among ( \"en\" , - 1 , 1 , \"\" , this ) , new Among ( \"ern\" , - 1 , 1 , \"\" , this ) , new Among ( \"er\" , - 1 , 1 , \"\" , this ) , new Among ( \"s\" , - 1 , 2 , \"\" , this ) , new Among ( \"es\" , 5 , 1 , \"\" , this ) } ; private Among a_3 [ ] = { new Among ( \"en\" , - 1 , 1 , \"\" , this ) , new Among ( \"er\" , - 1 , 1 , \"\" , this ) , new Among ( \"st\" , - 1 , 2 , \"\" , this ) , new Among ( \"est\" , 2 , 1 , \"\" , this ) } ; private Among a_4 [ ] = { new Among ( \"ig\" , - 1 , 1 , \"\" , this ) , new Among ( \"lich\" , - 1 , 1 , \"\" , this ) } ; private Among a_5 [ ] = { new Among ( \"end\" , - 1 , 1 , \"\" , this ) , new Among ( \"ig\" , - 1 , 2 , \"\" , this ) , new Among ( \"ung\" , - 1 , 1 , \"\" , this ) , new Among ( \"lich\" , - 1 , 3 , \"\" , this ) , new Among ( \"isch\" , - 1 , 2 , \"\" , this ) , new Among ( \"ik\" , - 1 , 2 , \"\" , this ) , new Among ( \"heit\" , - 1 , 3 , \"\" , this ) , new Among ( \"keit\" , - 1 , 4 , \"\" , this ) } ; private static final char g_v [ ] = { 17 , 65 , 16 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 , 0 , 32 , 8 } ; private static final char g_s_ending [ ] = { 117 , 30 , 5 } ; private static final char g_st_ending [ ] = { 117 , 30 , 4 } ; private int I_x ; private int I_p2 ; private int I_p1 ; private void copy_from ( German2Stemmer other ) { I_x = other . I_x ; I_p2 = other . I_p2 ; I_p1 = other . I_p1 ; super . copy_from ( other ) ; } private boolean r_prelude ( ) { int among_var ; int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; v_1 = cursor ; replab0 : while ( true ) { v_2 = cursor ; lab1 : do { golab2 : while ( true ) { v_3 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v , 97 , 252 ) ) ) { break lab3 ; } bra = cursor ; lab4 : do { v_4 = cursor ; lab5 : do { if ( ! ( eq_s ( 1 , \"u\" ) ) ) { break lab5 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 252 ) ) ) { break lab5 ; } slice_from ( \"U\" ) ; break lab4 ; } while ( false ) ; cursor = v_4 ; if ( ! ( eq_s ( 1 , \"y\" ) ) ) { break lab3 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 252 ) ) ) { break lab3 ; } slice_from ( \"Y\" ) ; } while ( false ) ; cursor = v_3 ; break golab2 ; } while ( false ) ; cursor = v_3 ; if ( cursor >= limit ) { break lab1 ; } cursor ++ ; } continue replab0 ; } while ( false ) ; cursor = v_2 ; break replab0 ; } cursor = v_1 ; replab6 : while ( true ) { v_5 = cursor ; lab7 : do { bra = cursor ; among_var = find_among ( a_0 , 6 ) ; if ( among_var == 0 ) { break lab7 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab7 ; case 1 : slice_from ( \"ss\" ) ; break ; case 2 : slice_from ( \"\u00e4\" ) ; break ; case 3 : slice_from ( \"\u00f6\" ) ; break ; case 4 : slice_from ( \"\u00fc\" ) ; break ; case 5 : { int c = cursor + 2 ; if ( 0 > c || c > limit ) { break lab7 ; } cursor = c ; } break ; case 6 : if ( cursor >= limit ) { break lab7 ; } cursor ++ ; break ; } continue replab6 ; } while ( false ) ; cursor = v_5 ; break replab6 ; } return true ; } private boolean r_mark_regions ( ) { int v_1 ; I_p1 = limit ; I_p2 = limit ; v_1 = cursor ; { int c = cursor + 3 ; if ( 0 > c", "gt": "|| c > limit )", "prediction": "|| c > limit )\n", "label": 1}
{"id": 635, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . Bezahlung ; import java . text . DecimalFormat ; public class NumberFormatter { public static String formatNumber ( double number ) { DecimalFormat formatter = new DecimalFormat ( \"#000\" ) ; StringBuffer s = new StringBuffer ( formatter . format ( number ) ) ; s . insert ( s . length ( ) - 2 , \",\" ) ; return s . toString ( ) ; } public static String formatString ( String value ) { assert value != null : \"Vorbedingung verletzt, value != null\" ; value = value . replace ( \",\" , \"\" ) ; DecimalFormat formatter = new DecimalFormat ( \"#000\" ) ; StringBuffer s = new StringBuffer ( formatter .", "gt": "format ( Double . parseDouble ( value ) ) ) ;", "prediction": "format ( value ) ) ;\n", "label": 0}
{"id": 16076, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . search . ConstantScoreQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . xmlparser . DOMUtils ; import org . apache . lucene . xmlparser . FilterBuilderFactory ; import org . apache . lucene . xmlparser . ParserException ; import org . apache . lucene . xmlparser . QueryBuilder ; import org . w3c . dom . Element ; public class ConstantScoreQueryBuilder implements QueryBuilder { private FilterBuilderFactory filterFactory ; public ConstantScoreQueryBuilder ( FilterBuilderFactory filterFactory ) { this . filterFactory = filterFactory ; } public Query getQuery ( Element e ) throws ParserException { Element filterElem", "gt": "= DOMUtils . getFirstChildOrFail ( e ) ;", "prediction": "= ( Element ) e ;\n", "label": 1}
{"id": 6401, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import junit . framework . Assert ; import org . apache . commons . io . IOUtils ; import org . apache . maven . it . Verifier ; import org . junit . Test ; public class SpecificTargetTest extends XCodeTest { @ Test public void buildSpecificTarget ( ) throws Exception { final String testName = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getMethodName ( ) ; final File remoteRepositoryDirectory = getRemoteRepositoryDirectory ( getClass ( ) . getName ( ) ) ; prepareRemoteRepository ( remoteRepositoryDirectory ) ; Map < String , String > additionalSystemProperties = new HashMap < String , String > ( ) ; additionalSystemProperties . put ( \"xcode.app.defaultConfigurations\" , \"Release\" ) ; additionalSystemProperties . put ( \"xcode.app.defaultSdks\" , \"iphoneos\" ) ; additionalSystemProperties . put ( \"xcode.target\" , \"Target2\" ) ; Verifier verifier = test ( testName , new File ( getTestRootDirectory ( ) , \"multiple-targets/MultipleTargets\" ) , \"pom.xml\" , \"compile\" , THE_EMPTY_LIST , additionalSystemProperties , remoteRepositoryDirectory ) ; assertCorrectTargetBuild ( new File ( verifier . getBasedir ( ) , verifier . getLogFileName ( ) ) ) ; } private void assertCorrectTargetBuild ( File logFile ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( logFile ) ) ; try { String line ; boolean target1Built = false ; boolean target2Built = false ; while ( ( line = reader . readLine ( ) ) != null ) { target1Built |= line . equals ( \"=== BUILD NATIVE TARGET Target1 OF PROJECT MultipleTargets WITH CONFIGURATION Release ===\" ) ; target2Built |= line . equals ( \"=== BUILD NATIVE TARGET Target2 OF PROJECT MultipleTargets WITH CONFIGURATION Release ===\" ) ; } Assert . assertFalse ( \"Target1 must not be built\" , target1Built ) ; Assert . assertTrue ( \"Target2 must", "gt": "be built\" , target2Built ) ;", "prediction": "not be built\" , target2Built ) ;\n", "label": 0}
{"id": 16084, "input": "<s> package org . nuxeo . ecm . platform . notification . api ; import java . io . Serializable ; import java . util . List ; import java . util . Set ; public interface NotificationRegistry extends Serializable { void clear ( ) ; void registerNotification ( Notification notif , List < String > events ) ; void unregisterNotification ( Notification notif , List < String > events ) ; Set < String > getNotificationEventNames ( ) ;", "gt": "List < Notification > getNotificationsForEvent ( String eventId ) ;", "prediction": "}\n", "label": 1}
{"id": 8245, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface AccountPrefix extends IncludePropertiesAttribute { Account getAccount ( ) ; void setAccount", "gt": "( Account value ) ;", "prediction": "( Account account ) ;\n", "label": 0}
{"id": 16091, "input": "<s> package org . eclipse . swt . internal . widgets ; import java . io . StringReader ; import java . text . MessageFormat ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . eclipse . rap . rwt . SingletonUtil ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . helpers . DefaultHandler ; public class MarkupValidator { public static final String MARKUP_VALIDATION_DISABLED = \"org.eclipse.rap.rwt.markupValidationDisabled\" ; private static final Map < String , String [ ] > SUPPORTED_ELEMENTS = createSupportedElementsMap ( ) ; private final SAXParser saxParser ; public static MarkupValidator getInstance ( ) { return SingletonUtil . getSessionInstance ( MarkupValidator . class ) ; } public MarkupValidator ( ) { saxParser = createSAXParser ( ) ; } public void validate ( String text ) { StringBuilder markup = new StringBuilder ( ) ; markup . append ( \"<html>\" ) ; markup . append ( text ) ; markup . append ( \"</html>\" ) ; InputSource inputSource = new InputSource ( new StringReader ( markup . toString ( ) ) ) ; try { saxParser . parse ( inputSource , new MarkupHandler ( ) ) ; } catch ( RuntimeException exception ) { throw exception ; } catch ( Exception exception ) { throw new IllegalArgumentException ( \"Failed to parse markup text\" , exception ) ; } } private static SAXParser createSAXParser ( ) { SAXParser result = null ; SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; try { result = parserFactory . newSAXParser ( ) ; } catch ( Exception exception ) { throw new RuntimeException ( \"Failed to create SAX parser\" , exception ) ; } return result ; } private static Map < String , String [ ] > createSupportedElementsMap ( ) { Map < String , String [ ] > result = new HashMap < String , String [ ] > ( ) ; result . put ( \"html\" , new String [ 0 ] ) ; result . put ( \"br\" , new String [ 0 ] ) ; result . put ( \"b\" , new String [ ] { \"style\" } ) ; result . put ( \"strong\" , new String [ ] { \"style\" } ) ; result . put ( \"i\" , new String [ ] { \"style\" } ) ; result . put ( \"em\" , new String [ ] { \"style\" } ) ; result . put ( \"sub\" , new String [ ] { \"style\" } ) ; result . put ( \"sup\" , new String [ ] { \"style\" } ) ; result . put ( \"big\" , new String [ ] { \"style\" } ) ; result . put ( \"small\" , new String [ ] { \"style\" } ) ; result . put ( \"del\" , new String [ ] { \"style\" } ) ; result . put ( \"ins\" , new String [ ] { \"style\" } ) ; result . put ( \"code\" , new String [ ] { \"style\" } ) ; result . put ( \"samp\" , new String [ ] { \"style\" } ) ; result . put ( \"kbd\" , new String [ ] { \"style\" } ) ; result . put ( \"var\" , new String [ ] { \"style\" } ) ; result . put ( \"cite\" , new String [ ] { \"style\" } ) ; result . put ( \"dfn\" , new String [ ] { \"style\" } ) ; result . put ( \"q\" , new String [ ] { \"style\" } ) ; result . put ( \"abbr\" , new String [ ] { \"style\" , \"title\" } ) ; result . put ( \"span\" , new String [ ] { \"style\" } ) ; result . put ( \"img\" , new String [ ] { \"style\" , \"src\" , \"width\" , \"height\" , \"title\" , \"alt\" } ) ; result . put ( \"a\" , new String [ ] { \"style\" , \"href\" , \"target\" , \"title\" } ) ; return result ; } private static class MarkupHandler extends DefaultHandler { @ Override public void startElement ( String uri , String localName , String name , Attributes attributes ) { checkSupportedElements ( name , attributes ) ; checkSupportedAttributes ( name , attributes ) ; checkMandatoryAttributes ( name , attributes ) ; } private static void checkSupportedElements ( String elementName , Attributes attributes ) { if ( ! SUPPORTED_ELEMENTS . containsKey ( elementName ) ) { throw new IllegalArgumentException ( \"Unsupported element in markup text: \" + elementName ) ; } } private static void checkSupportedAttributes ( String elementName , Attributes attributes ) { if ( attributes . getLength ( ) > 0 ) { List < String > supportedAttributes = Arrays . asList ( SUPPORTED_ELEMENTS . get ( elementName ) ) ; int index = 0 ; String attributeName =", "gt": "attributes . getQName ( index ) ;", "prediction": "attributes . getLocalName ( ) ;\n", "label": 1}
{"id": 4644, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse .", "gt": "emf . ecore . EObject ;", "prediction": "swt . SWT ;\n", "label": 0}
{"id": 16093, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . Attribute ; import org . fuzzydb . attrs . util . Range3D ; import org . fuzzydb . dto . dimensions . IPoint3D ; import org . fuzzydb . dto . dimensions . IRange3D ; public abstract class RangePreference3D extends Attribute implements IRange3D { public IPoint3D getMax ( ) { return range3d", "gt": ". getMax ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4618, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . materialien ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . FSK ; public class FilmTest { @ Test public void testeKonstruktoren ( ) { Film f = new Film ( \"Titel\" , 90 , FSK . FSK16 , true ) ; assertEquals ( \"Titel\" , f . getTitel ( ) ) ; assertEquals ( 90 , f . getLaenge ( ) ) ; assertEquals ( FSK . FSK16 , f . getFSK ( ) ) ;", "gt": "assertTrue ( f . hatUeberlaenge ( ) ) ;", "prediction": "}\n", "label": 0}
{"id": 16094, "input": "<s> package org . eclipse . rap . ui . internal . servlet ; import java . util . * ; public final class EntryPointParameters { private static final Map < String , String > parametersById = new HashMap < String , String > ( ) ; public static void register ( String id , String parameter ) { parametersById . put ( id , parameter ) ; } public static void clear ( ) { parametersById . clear ( ) ; } public", "gt": "static String getById ( String id )", "prediction": "EntryPointParameters ( )\n", "label": 1}
{"id": 3623, "input": "<s> import java . io . * ; public class T6863746 { public static void main ( String ... args ) throws Exception { new T6863746 ( ) . run ( ) ; } public void run ( ) throws Exception { String [ ] args = { \"-c\" , \"java.lang.Object\" } ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javap . Main . run ( args , pw ) ; pw . close ( ) ; String", "gt": "out = sw . toString ( ) ;", "prediction": "s = sw . toString ( ) ;\n", "label": 0}
{"id": 16098, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . jboss . seam . contexts . Contexts ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo", "gt": ". ecm . core . api . DocumentModel ;", "prediction": ". ecm . automation . core . annotations . Produces ;\n", "label": 1}
{"id": 6345, "input": "<s> package org . ofbiz . webapp . event ; import java . lang . reflect . Method ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public class JavaEventHandler implements EventHandler { public static final String module = JavaEventHandler . class . getName ( ) ; private Map < String , Class < ? > > eventClassMap = FastMap . newInstance ( ) ; public void init ( ServletContext context ) throws EventHandlerException { } public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse response ) throws EventHandlerException { Class < ? > eventClass = this . eventClassMap . get ( event . path ) ; if ( eventClass == null ) { synchronized ( this ) { eventClass = this . eventClassMap . get ( event . path ) ; if ( eventClass == null ) { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; eventClass = loader . loadClass ( event . path ) ; } catch ( ClassNotFoundException e ) { Debug . logError ( e , \"Error loading class with name: \" + event . path + \", will not be able to run event...\" , module ) ; } if ( eventClass != null ) { eventClassMap . put ( event . path , eventClass ) ; } } } } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"[Set path/method]: \" + event . path + \" / \" + event . invoke , module ) ; Class < ? > [ ] paramTypes = new Class < ? > [ ] { HttpServletRequest . class , HttpServletResponse . class } ; Debug . logVerbose ( \"*[[Event invocation]]*\" , module ) ; Object [ ] params = new Object [ ] { request , response } ; return invoke ( event . path , event . invoke , eventClass , paramTypes , params ) ; } private String invoke ( String eventPath , String eventMethod , Class < ? > eventClass , Class < ? > [ ] paramTypes , Object [ ] params ) throws EventHandlerException { if ( eventClass == null ) { throw new EventHandlerException ( \"Error invoking event, the class \" + eventPath + \" was not found\" ) ; } if ( eventPath == null || eventMethod == null ) { throw new EventHandlerException ( \"Invalid event method or path; call initialize()\" ) ; } Debug . logVerbose ( \"[Processing]: JAVA Event\" , module ) ; try { Method m = eventClass . getMethod ( eventMethod , paramTypes ) ; String eventReturn = ( String ) m . invoke ( null , params ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"[Event Return]: \" + eventReturn , module ) ; return eventReturn ; } catch ( java . lang . reflect . InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t != null ) { Debug . logError ( t , \"Problems Processing Event\" , module ) ; throw new EventHandlerException ( \"Problems processing event: \" + t . toString ( ) , t ) ; } else { Debug . logError ( e , \"Problems Processing Event\" , module ) ; throw new EventHandlerException ( \"Problems processing event: \" + e . toString ( ) , e ) ; } } catch ( Exception e ) { Debug . logError ( e , \"Problems Processing Event\" , module ) ; throw new EventHandlerException ( \"Problems processing event:", "gt": "\" + e . toString ( ) , e ) ;", "prediction": "\" + e . toString ( ) , e ) ;\n", "label": 0}
{"id": 16099, "input": "<s> package org . json ; public class CDL { private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c == ' ' || c == '\\t' ) ; switch ( c ) { case 0 : return null ; case '\"' : case '\\'' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '\\n' || c == '\\r' ) { throw x . syntaxError ( \"Missing close quote '\" + q + \"'.\" ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case ',' : x . back ( ) ; return \"\" ; default : x . back ( ) ; return x . nextTo ( ',' ) ; } } public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { char c = x . next ( ) ; if ( c == ',' ) { break ; } if ( c != ' ' ) { if ( c == '\\n' || c == '\\r' || c == 0 ) { return ja ; } throw x . syntaxError ( \"Bad character '\" + c + \"' (\" + ( int ) c + \").\" ) ; } } } } public static JSONObject rowToJSONObject ( JSONArray names , JSONTokener x ) throws JSONException { JSONArray ja = rowToJSONArray ( x ) ; return ja != null ? ja . toJSONObject ( names ) : null ; } public static JSONArray toJSONArray ( String string ) throws JSONException { return toJSONArray ( new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONTokener x ) throws JSONException { return toJSONArray ( rowToJSONArray ( x ) , x ) ; } public static JSONArray toJSONArray ( JSONArray names , String string ) throws JSONException { return toJSONArray ( names , new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; } public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . indexOf ( ',' ) >= 0 || s . indexOf ( '\\n' ) >= 0 || s . indexOf ( '\\r' ) >= 0 || s . indexOf ( 0 ) >= 0 || s . charAt ( 0 ) == '\"' ) { sb . append ( '\"' ) ; int length = s . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = s . charAt ( j ) ; if ( c >= ' ' && c != '\"' ) { sb . append ( c ) ; } } sb . append ( '\"' ) ; } else { sb . append ( s ) ; } } } sb . append ( '\\n' ) ; return sb . toString ( ) ; } public static String toString ( JSONArray ja ) throws JSONException { JSONObject jo = ja . optJSONObject ( 0 ) ; if ( jo != null ) { JSONArray names = jo . names ( ) ; if ( names != null ) { return rowToString ( names ) + toString ( names , ja ) ; } } return null ; } public static String toString ( JSONArray names , JSONArray ja ) throws JSONException { if ( names == null ||", "gt": "names . length ( ) == 0 )", "prediction": "names . length ( ) == 0 )\n", "label": 1}
{"id": 8676, "input": "<s> package org . parboiled ; public interface SkippableAction < V >", "gt": "extends Action < V >", "prediction": "\n", "label": 0}
{"id": 16103, "input": "<s> package org . fuzzydb . attrs . decorators ; import org . fuzzydb . attrs . enums . EnumMultipleValue ; import org . fuzzydb . attrs . internal . BaseAttribute ; public class EnumMultiAttributeDecorator extends EnumAttributeDecorator { private static final long serialVersionUID = 1L ; public EnumMultiAttributeDecorator ( String name , String [ ] strings ) { super ( name , strings ) ; } @ Override public String getValueString ( BaseAttribute attr ) { EnumMultipleValue val = ( EnumMultipleValue ) attr ; StringBuilder str = new StringBuilder ( ) ; for ( short index : val . getValues ( ) ) { str . append ( getStringFor ( index ) ) . append ( \", \" ) ; } return str . substring ( 0 , str .", "gt": "length ( ) - 2 ) ;", "prediction": "length ( ) - 1 ) ;\n", "label": 1}
{"id": 1886, "input": "<s> package com . sun . tools . javac . util ; import java . util . * ; public class Context { public static class Key < T > { } public static interface Factory < T > { T make ( Context c ) ; } ; private Map < Key < ? > , Object > ht = new HashMap < Key < ? > , Object > ( ) ; public < T > void put ( Key < T > key , Factory < T > fac ) { checkState ( ht ) ; Object old = ht . put ( key , fac ) ; if ( old != null ) throw new AssertionError ( \"duplicate context value\" ) ; checkState ( ft ) ; ft . put ( key , fac ) ; } public < T > void put ( Key < T > key , T data ) { if ( data instanceof Factory < ? > ) throw new AssertionError ( \"T extends Context.Factory\" ) ; checkState ( ht ) ; Object old = ht . put ( key , data ) ; if ( old != null && ! ( old instanceof Factory < ? > ) && old != data && data != null ) throw new AssertionError ( \"duplicate context value\" ) ; } public < T > T get ( Key < T > key ) { checkState ( ht ) ; Object o = ht . get ( key ) ; if ( o instanceof Factory < ? > ) { Factory < ? > fac = ( Factory < ? > ) o ; o = fac . make ( this ) ; if ( o instanceof Factory < ? > ) throw new AssertionError ( \"T extends Context.Factory\" ) ; Assert . check ( ht . get ( key ) == o ) ; } return Context . < T > uncheckedCast ( o ) ; } public Context ( ) { } private Map < Key < ? > , Factory < ? > > ft = new HashMap < Key < ? > , Factory < ? > > ( ) ; public Context ( Context prev ) { kt . putAll ( prev . kt ) ; ft . putAll ( prev . ft ) ; ht . putAll ( prev . ft ) ; } private Map < Class < ? > , Key < ? > > kt = new HashMap < Class < ? > , Key < ? > > ( ) ; private < T > Key < T > key ( Class < T > clss ) { checkState ( kt ) ; Key < T > k = uncheckedCast ( kt . get ( clss ) ) ; if ( k == null ) { k = new Key < T > ( ) ; kt . put ( clss , k ) ; } return k ; } public < T > T get ( Class < T > clazz ) { return get ( key ( clazz ) ) ; } public < T > void put ( Class < T > clazz , T data ) { put ( key ( clazz ) , data ) ; } public < T > void put ( Class < T > clazz , Factory < T > fac ) { put ( key ( clazz ) , fac ) ; } @ SuppressWarnings ( \"unchecked\" ) private static < T > T uncheckedCast ( Object o ) { return ( T ) o ; } public void dump ( ) { for ( Object value : ht . values ( ) ) System . err . println ( value == null ? null : value . getClass ( ) ) ; } public void clear ( ) { ht = null ; kt = null ; ft = null ; } private static void checkState ( Map < ? , ? > t ) { if ( t == null ) throw new IllegalStateException ( ) ; } public static class SourceLanguage { public enum Language { JAVA , CEYLON } private static ThreadLocal < ArrayList < Language > > theStack = new ThreadLocal < ArrayList < Language > > ( ) { protected", "gt": "ArrayList < Language > initialValue ( )", "prediction": "ArrayList < Language > stack = new ArrayList < Language > ( ) ;\n", "label": 0}
{"id": 16104, "input": "<s> package org . eclipse . jface . viewers ; import java . text . Collator ; public class ViewerSorter extends ViewerComparator { protected Collator collator ; public ViewerSorter ( ) { this ( Collator .", "gt": "getInstance ( ) ) ;", "prediction": "getInstance ( collator ) ) ;\n", "label": 1}
{"id": 3345, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import java . awt . * ; public class PgsMenuBarUI extends BasicMenuBarUI { public static ComponentUI createUI ( JComponent c ) { return new PgsMenuBarUI ( ) ; } public void paint ( Graphics g , JComponent b ) { if ( b . isOpaque ( ) ) { if ( PgsUtils . isFlat ( \"MenuBar\" ) ) { g .", "gt": "setColor ( b . getBackground ( ) ) ;", "prediction": "setColor ( Color . red ) ;\n", "label": 0}
{"id": 16107, "input": "<s> package org . powerbot . game . api . methods ; import java . awt . Canvas ; import java . awt . Point ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . methods . widget . WidgetComposite ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . RegionOffset ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . interactive . Player ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSGroundByts ; import org . powerbot . game . client . RSGroundInfo ; import org . powerbot . game . client . RSInfo ; import org . powerbot . game . client . TileData ; public class Calculations { public static class Toolkit { public float absoluteX , absoluteY ; public float xMultiplier , yMultiplier ; } public static class Viewport { public float xOff , xX , xY , xZ ; public float yOff , yX , yY , yZ ; public float zOff , zX , zY , zZ ; } public static final int [ ] SIN_TABLE = new int [ 0x4000 ] ; public static final int [ ] COS_TABLE = new int [ 0x4000 ] ; static { final double d = 0.00038349519697141029D ; for ( int i = 0 ; i < 0x4000 ; i ++ ) { Calculations . SIN_TABLE [ i ] = ( int ) ( 32768D * Math . sin ( i * d ) ) ; Calculations . COS_TABLE [ i ] = ( int ) ( 32768D * Math . cos ( i * d ) ) ; } } public static int calculateTileHeight ( final int x , final int y , int plane ) { final Client client = Context . client ( ) ; final int x1 = x > > 9 ; final int y1 = y > > 9 ; try { final byte [ ] [ ] [ ] settings = ( byte [ ] [ ] [ ] ) ( ( RSGroundByts ) ( ( RSInfo ) client . getRSGroundInfo ( ) ) . getGroundBytes ( ) ) . getBytes ( ) ; if ( settings != null && x1 >= 0 && x1 < 104 && y1 >= 0 && y1 < 104 ) { if ( plane <= 3 && ( settings [ 1 ] [ x1 ] [ y1 ] & 2 ) != 0 ) { ++ plane ; } final TileData [ ] planes = ( TileData [ ] ) ( ( RSGroundInfo ) ( ( RSInfo ) client . getRSGroundInfo ( ) ) . getRSGroundInfo ( ) ) . getTileData ( ) ; if ( planes != null && plane < planes . length && planes [ plane ] != null ) { final int [ ] [ ] heights = planes [ plane ] . getHeights ( ) ; if ( heights != null ) { final int x2 = x & 0x200 - 1 ; final int y2 = y & 0x200 - 1 ; final int start_h = heights [ x1 ] [ y1 ] * ( 0x200 - x2 ) + heights [ x1 + 1 ] [ y1 ] * x2 > > 9 ; final int end_h = heights [ x1 ] [ 1 + y1 ] * ( 0x200 - x2 ) + heights [ x1 + 1 ] [ y1 + 1 ] * x2 > > 9 ; return start_h * ( 512 - y2 ) + end_h * y2 > > 9 ; } } } } catch ( final NullPointerException ignored ) { } return 0 ; } public static Point groundToScreen ( final int x , final int y , final int plane , final int height ) { if ( x < 512 || y < 512 || x > 52224 || y > 52224 ) { return new Point ( - 1 , - 1 ) ; } final int z = calculateTileHeight ( x , y , plane ) - height ; return worldToScreen ( x , z , y ) ; } public static Point worldToScreen ( final int x , final int y , final int z ) { final Context bot = Context . get ( ) ; final Toolkit toolkit = bot . getToolkit ( ) ; final Viewport viewport = bot . getViewport ( ) ; final float _z = ( viewport . zOff + ( viewport . zX * x + viewport . zY * y + viewport . zZ * z ) ) ; final float _x = ( viewport . xOff + ( viewport . xX * x + viewport . xY * y + viewport . xZ * z ) ) ; final float _y = ( viewport . yOff + ( viewport . yX * x + viewport . yY * y + viewport . yZ * z ) ) ; if ( _x >= - _z && _x <= _z && _y >= - _z && _y <= _z ) { return new Point ( Math . round ( toolkit . absoluteX + ( toolkit . xMultiplier * _x ) / _z ) , Math . round ( toolkit . absoluteY + ( toolkit . yMultiplier * _y ) / _z ) ) ; } return new Point ( - 1 , - 1 ) ; } public static Point worldToMap ( double x , double y ) { final Client client = Context", "gt": ". client ( ) ;", "prediction": ". client ( ) ;\n", "label": 1}
{"id": 2365, "input": "<s> package com . sun", "gt": ". mirror . util ;", "prediction": ". xml . parsers ;\n", "label": 0}
{"id": 16111, "input": "<s> package org . eclipse . ui . tests . stress ; import junit . framework . Test ; import junit . framework . TestSuite ; public class OpenCloseTestSuite extends TestSuite { public static Test suite ( ) {", "gt": "return new OpenCloseTestSuite ( ) ;", "prediction": "return new OpenCloseTestSuite ( ) ;\n", "label": 1}
{"id": 7305, "input": "<s> import java . awt . Polygon ; import java . awt . geom . AffineTransform ; import java . awt . geom . Area ; import java . awt . geom . PathIterator ; import java . io . * ; import java . util . StringTokenizer ; import java . util . Vector ; class p4 { public static int translate ( String s ) { return ( int ) ( Double . parseDouble ( s ) * 100 ) ; } public static void main ( String args [ ] ) throws Exception { String s ; while ( true ) { int max = Integer . parseInt ( readLine ( ) . trim ( ) ) ; if ( max == 0 ) { return ; } Polygon pol = new Polygon ( ) ; for ( int i = 0 ; i != max ; i ++ ) { s = readLine ( ) . trim ( ) ; String p [ ] = split ( s ) ; pol . addPoint ( translate ( p [ 0 ] ) , translate ( p [ 1 ] ) ) ; } Area a = new Area ( pol ) ; double z = calculateArea ( a ) ; z /= 10000 ; z = Math . round ( z * 100 ) ; long zz = ( long ) ( z ) ; long inteira = zz / 100 ; long corte = zz % 100 ; System . out . print ( inteira + \".\" ) ; if ( corte == 0 ) { System . out . print ( \"00\" ) ; } else if ( corte < 10 ) { System . out . print ( \"0\" + corte ) ; } else { System . out . print ( corte ) ; } System . out . println ( ) ; } } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { return buffer . readLine ( ) ; } static BufferedReader buffer = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static double calculateArea ( Area validArea ) { double a = 0.0 ; if ( validArea . isEmpty ( ) ) { return 0 ; } PathIterator pi = validArea . getPathIterator ( new AffineTransform ( ) ) ; Vector points = new Vector ( ) ; while ( ! pi . isDone ( ) ) { double [ ] point = new double [ 6 ] ; int mode = pi . currentSegment ( point ) ; if ( mode == PathIterator . SEG_MOVETO ) { if ( points . size ( ) != 0 ) { a += calculaArea ( points ) ; } double [ ] p = new double [ 2 ] ; p [ 0 ] = point [ 0 ] ; p [ 1 ] = point [ 1 ] ; points . addElement ( p ) ; } else if ( mode == PathIterator . SEG_LINETO ) { double [ ] p = new double [ 2 ] ; p [ 0 ] = point [ 0 ] ; p [ 1 ] = point [ 1 ] ; points . addElement ( p ) ; } else if ( mode == PathIterator . SEG_CLOSE ) { a += calculaArea ( points ) ; } else { throw new SecurityException ( ) ; } pi . next ( ) ; } return ( Math . abs ( a ) ) ; } static private double calculaArea ( Vector points ) { double [ ] p = ( double [ ] ) points . elementAt ( 0 ) ; double area = 0.0 ; double p2 [ ] , p3 [ ] , cima ; for ( int i = 1 ; i != points . size ( ) - 1 ; i ++ ) { p2 = ( double", "gt": "[ ] ) points . elementAt ( i ) ;", "prediction": "[ ] ) points . elementAt ( i ) ;\n", "label": 0}
{"id": 16112, "input": "<s> package org . eclipse . ui ; public class MultiPartInitException extends WorkbenchException { private IWorkbenchPartReference [ ] references ; private PartInitException [ ] exceptions ; public MultiPartInitException ( IWorkbenchPartReference [ ] references , PartInitException [ ] exceptions ) { super ( exceptions [ findSingleException ( exceptions ) ] . getStatus ( ) ) ; this . references = references ; this . exceptions = exceptions ; } public IWorkbenchPartReference [ ] getReferences ( ) { return references ; } public PartInitException [ ] getExceptions ( ) { return exceptions ; } private static int findSingleException ( PartInitException [ ] exceptions ) { int index = - 1 ; for ( int i = 0 ; i < exceptions . length ; i ++ ) { if ( exceptions [ i ] != null ) { if ( index == - 1 ) { index = i ; } else", "gt": "throw new IllegalArgumentException ( ) ;", "prediction": "\n", "label": 1}
{"id": 4498, "input": "<s> import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . PrintWriter ; import java . sql . Timestamp ; import java . util . Map ; public class LoggerPlugin implements ClickerConsumerInterface { private PrintWriter pw ; private boolean running ; private ConsumerFrame parent ; private File currentLog ; private String currentQuestion ; public LoggerPlugin ( ) { currentQuestion = \"\" ; } @ Override public void setParent ( ConsumerFrame parent ) { this . parent = parent ; } @ Override public String declareConsumptions ( ) { return \"Logging\" ; } @ Override public void setActiveStatus ( boolean status ) { running = status ; if ( running ) { File logDirectory = new File ( \"./logs\" ) ; if ( ! logDirectory . exists ( ) ) { if ( logDirectory . mkdir ( ) ) { System . out . println ( \"Made a directory at: \" + logDirectory . toString ( ) ) ; } else { System . out . println ( \"Log directory is: \" + logDirectory . toString ( ) ) ; } } currentLog = new File ( \"./logs/\" + System .", "gt": "currentTimeMillis ( ) + \".txt\" ) ;", "prediction": "currentTimeMillis ( ) + \".txt\" ) ;\n", "label": 0}
{"id": 16122, "input": "<s> package org . apache . sqoop . manager ; import static com . cloudera . sqoop . lib . DelimiterSet . NULL_CHAR ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import com . cloudera . sqoop . config . ConfigurationConstants ; import com . cloudera . sqoop . config . ConfigurationHelper ; import com . cloudera . sqoop . util . DirectImportUtils ; public final class MySQLUtils { private MySQLUtils ( ) { } public static final Log LOG = LogFactory . getLog ( MySQLUtils . class . getName ( ) ) ; public static final String MYSQL_DUMP_CMD = \"mysqldump\" ; public static final String MYSQL_IMPORT_CMD = \"mysqlimport\" ; public static final String OUTPUT_FIELD_DELIM_KEY = \"sqoop.output.field.delim\" ; public static final String OUTPUT_RECORD_DELIM_KEY = \"sqoop.output.record.delim\" ; public static final String OUTPUT_ENCLOSED_BY_KEY = \"sqoop.output.enclosed.by\" ; public static final String OUTPUT_ESCAPED_BY_KEY = \"sqoop.output.escaped.by\" ; public static final String OUTPUT_ENCLOSE_REQUIRED_KEY = \"sqoop.output.enclose.required\" ; public static final String TABLE_NAME_KEY = ConfigurationHelper . getDbInputTableNameProperty ( ) ; public static final String CONNECT_STRING_KEY = ConfigurationHelper . getDbUrlProperty ( ) ; public static final String USERNAME_KEY = ConfigurationHelper . getDbUsernameProperty ( ) ; public static final String PASSWORD_KEY = ConfigurationHelper . getDbPasswordProperty ( ) ; public static final String WHERE_CLAUSE_KEY = ConfigurationHelper . getDbInputConditionsProperty ( ) ; public static final String EXTRA_ARGS_KEY = \"sqoop.mysql.extra.args\" ; public static final String MYSQL_DEFAULT_CHARSET = \"ISO_8859_1\" ; public static boolean outputDelimsAreMySQL ( Configuration conf ) { return ',' == ( char ) conf . getInt ( OUTPUT_FIELD_DELIM_KEY , NULL_CHAR ) && '\\n' == ( char ) conf . getInt ( OUTPUT_RECORD_DELIM_KEY , NULL_CHAR ) && '\\'' == ( char ) conf . getInt ( OUTPUT_ENCLOSED_BY_KEY , NULL_CHAR ) && '\\\\' == ( char ) conf . getInt ( OUTPUT_ESCAPED_BY_KEY , NULL_CHAR ) && ! conf . getBoolean ( OUTPUT_ENCLOSE_REQUIRED_KEY , false ) ; } public static String writePasswordFile ( Configuration conf ) throws IOException { String tmpDir = conf . get ( ConfigurationConstants . PROP_JOB_LOCAL_DIRECTORY , \"/tmp/\" ) ; File tempFile = File . createTempFile ( \"mysql-cnf\" , \".cnf\" , new File ( tmpDir ) ) ; DirectImportUtils . setFilePermissions ( tempFile , \"0600\" ) ; String password = conf . get ( PASSWORD_KEY ) ; BufferedWriter w = new BufferedWriter ( new OutputStreamWriter", "gt": "( new FileOutputStream ( tempFile ) ) ) ;", "prediction": "( new FileOutputStream ( tempFile ) ) ) ;\n", "label": 1}
{"id": 4634, "input": "<s> package org . ofbiz . accounting . finaccount ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . entity . util . EntityUtilProperties ; import org . ofbiz . base . util . * ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . finaccount . FinAccountHelper ; import java . util . * ; import java . math . BigDecimal ; import javolution . util . FastMap ; public class FinAccountProductServices { public static final String module = FinAccountProductServices . class . getName ( ) ; public static final String resourceOrderError = \"OrderErrorUiLabels\" ; public static final String resourceError = \"AccountingErrorUiLabels\" ; public static Map < String , Object > createPartyFinAccountFromPurchase ( DispatchContext dctx , Map < String , Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; GenericValue orderItem = ( GenericValue ) context . get ( \"orderItem\" ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; String orderId = orderItem . getString ( \"orderId\" ) ; String orderItemSeqId = orderItem . getString ( \"orderItemSeqId\" ) ; GenericValue orderHeader ; try { orderHeader = orderItem . getRelatedOne ( \"OrderHeader\" , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Unable to get OrderHeader from OrderItem\" , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceOrderError , \"OrderCannotGetOrderHeader\" , UtilMisc . toMap ( \"orderId\" , orderId ) , locale ) ) ; } String productId = orderItem . getString ( \"productId\" ) ; GenericValue featureAndAppl ; try { List < GenericValue > featureAndAppls = delegator . findByAnd ( \"ProductFeatureAndAppl\" , UtilMisc . toMap ( \"productId\" , productId , \"productFeatureTypeId\" , \"TYPE\" , \"productFeatureApplTypeId\" , \"STANDARD_FEATURE\" ) , null , false ) ; featureAndAppls = EntityUtil . filterByDate ( featureAndAppls ) ; featureAndAppl = EntityUtil . getFirst ( featureAndAppls ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( e . getMessage ( ) ) ; } String finAccountTypeId = \"BALANCE_ACCOUNT\" ; String finAccountName = \"Customer Financial Account\" ; if ( featureAndAppl != null ) { if ( UtilValidate . isNotEmpty ( featureAndAppl . getString ( \"idCode\" ) ) ) { finAccountTypeId = featureAndAppl . getString ( \"idCode\" ) ; } if ( UtilValidate . isNotEmpty ( featureAndAppl . getString ( \"description\" ) ) ) { finAccountName = featureAndAppl . getString ( \"description\" ) ; } } GenericValue finAccountType ; try { finAccountType = delegator . findOne ( \"FinAccountType\" , UtilMisc . toMap ( \"finAccountTypeId\" , finAccountTypeId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( e . getMessage ( ) ) ; } String replenishEnumId = finAccountType . getString ( \"replenishEnumId\" ) ; OrderReadHelper orh = new OrderReadHelper ( orderHeader ) ; String currency = orh . getCurrency ( ) ; if ( currency == null ) { currency = EntityUtilProperties . getPropertyValue ( \"general.properties\" , \"currency.uom.id.default\" , \"USD\" , delegator ) ; } String productStoreId = null ; if ( orderHeader != null ) { productStoreId = orh . getProductStoreId ( ) ; } if ( productStoreId == null ) { Debug . logFatal ( \"Unable to create financial accout; no productStoreId on OrderHeader : \" + orderId , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceError , \"AccountingFinAccountCannotCreate\" , UtilMisc . toMap ( \"orderId\" , orderId ) , locale ) ) ; } GenericValue billToParty = orh . getBillToParty ( ) ; String partyId = null ; if ( billToParty != null ) { partyId = billToParty . getString ( \"partyId\" ) ; } List < GenericValue > payPrefs = orh . getPaymentPreferences ( ) ; String paymentMethodId = null ; if ( payPrefs != null ) { for ( GenericValue pref : payPrefs ) { String type = pref . getString ( \"paymentMethodTypeId\" ) ; if ( \"CREDIT_CARD\" . equals ( type ) || \"EFT_ACCOUNT\" . equals ( type ) ) { paymentMethodId = pref . getString ( \"paymentMethodId\" ) ; } } } GenericValue partyGroup = null ; GenericValue person = null ; GenericValue party = null ; if ( billToParty != null ) { try { party = billToParty . getRelatedOne ( \"Party\" , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; } if ( party != null ) { String partyTypeId = party . getString ( \"partyTypeId\" ) ; if ( \"PARTY_GROUP\" . equals ( partyTypeId ) ) { partyGroup = billToParty ; } else if ( \"PERSON\" . equals ( partyTypeId ) ) { person = billToParty ; } } } Map < String , Object > expContext = FastMap . newInstance ( ) ; expContext . put ( \"orderHeader\" , orderHeader ) ; expContext . put ( \"orderItem\" , orderItem ) ; expContext . put ( \"party\" , party ) ; expContext . put ( \"person\" , person ) ; expContext", "gt": ". put ( \"partyGroup\" , partyGroup ) ;", "prediction": ". put ( \"productId\" , productId ) ;\n", "label": 0}
{"id": 16132, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . dom . client . Style . Visibility ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . uibinder . client . UiTemplate ; import com . google . gwt . user . client . ui . Anchor ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . Widget ; class NavBar extends Composite { @ UiTemplate ( \"NavBar.ui.xml\" ) interface Binder extends UiBinder < Widget , NavBar > { } private static final Binder binder = GWT . create ( Binder . class ) ; @ UiField Element countLabel ; @ UiField Anchor newerButton ; @ UiField Anchor olderButton ; private final MailList outer ; public NavBar ( MailList outer ) { initWidget ( binder . createAndBindUi ( this ) ) ; this . outer = outer ; } public void update ( int startIndex , int count , int max ) { setVisibility ( newerButton , startIndex != 0 ) ; setVisibility ( olderButton , startIndex + MailList . VISIBLE_EMAIL_COUNT < count ) ; countLabel . setInnerText ( \"\" + ( startIndex + 1 ) + \" - \" + max + \" of \" + count ) ; } @ UiHandler ( \"newerButton\" ) void onNewerClicked ( ClickEvent event ) {", "gt": "outer . newer ( ) ;", "prediction": "setVisibility ( olderButton , startIndex != 0 ) ;\n", "label": 1}
{"id": 6096, "input": "<s> package javax . tools ; import java . io . File ; import java . io . IOException ; import java . util . * ; public interface StandardJavaFileManager extends JavaFileManager { boolean isSameFile ( FileObject a , FileObject b ) ; Iterable < ? extends JavaFileObject > getJavaFileObjectsFromFiles ( Iterable < ? extends File > files ) ; Iterable < ? extends JavaFileObject > getJavaFileObjects ( File ... files ) ; Iterable < ? extends JavaFileObject > getJavaFileObjectsFromStrings ( Iterable < String > names ) ; Iterable <", "gt": "? extends JavaFileObject > getJavaFileObjects ( String ... names ) ;", "prediction": "? extends JavaFileObject > getJavaFileObjectsFromStrings ( String ... names ) ;\n", "label": 0}
{"id": 16138, "input": "<s> package org . eclipse . swt . events ; import static org . mockito . Mockito . mock ; import junit . framework . TestCase ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Widget ; public class TreeEvent_Test extends TestCase { public void testUntypedEventConstructor ( ) { Event event = new Event ( ) ; event . display = mock ( Display . class ) ; event . widget = mock ( Widget . class ) ; event", "gt": ". time = 7 ;", "prediction": ". data = new Object ( ) ;\n", "label": 1}
{"id": 2615, "input": "<s> package org . ofbiz . pos . device . impl ; import java . util . List ; import jpos . JposException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . pos . adaptor . DataEventAdaptor ; import org . ofbiz . pos . config . ButtonEventConfig ; import org . ofbiz . pos . device . GenericDevice ; import org . ofbiz . pos . screen . PosScreen ; public class Keyboard extends GenericDevice { public static final String module = CashDrawer . class . getName ( ) ; public Keyboard ( String deviceName , int timeout ) { super ( deviceName , timeout ) ; this . control = new jpos . POSKeyboard ( ) ; } @ Override protected void initialize ( ) throws JposException { Debug . logInfo ( \"Keyboard [\" + control . getPhysicalDeviceName ( ) + \"] Claimed : \" + control . getClaimed ( ) , module ) ; final jpos . POSKeyboard keyboard = ( jpos . POSKeyboard ) control ; keyboard . addDataListener ( new DataEventAdaptor ( ) { @ Override public void dataOccurred ( jpos . events . DataEvent event ) { Debug . logInfo ( \"POSKeyboard DataEvent - \" + event . getWhen ( ) , module ) ; try { int keyCode = keyboard . getPOSKeyData ( ) ; Debug . logInfo ( \"Received KeyCode From POSKeyboard DataEvent : \" + keyCode , module ) ; if ( keyCode == - 1 ) { return ; } if ( PosScreen . currentScreen . isLocked ( ) && 500 != keyCode ) { Debug . logInfo ( \"PosScreen is locked; not running POSKeyboard Event!\" , module ) ; return ; } List < String > buttonEvents = ButtonEventConfig . findButtonKeyAssign ( keyCode ) ; if ( UtilValidate . isNotEmpty ( buttonEvents ) ) { Debug . logInfo ( \"Key -> Button Mapping(s) Found [\" + keyCode + \"]\" , module ) ; try { ButtonEventConfig . invokeButtonEvents ( buttonEvents , PosScreen . currentScreen ) ; } catch", "gt": "( ButtonEventConfig . ButtonEventNotFound e )", "prediction": "( Exception e )\n", "label": 0}
{"id": 16139, "input": "<s> import com . sun . tools . doclets . Taglet ; import com . sun . javadoc . * ; import java . util . Map ; import java . io . * ; public class ExampleTaglet implements Taglet { private static final String NAME = \"example\" ; private static final String HEADER = \"example To Do:\" ; public String getName ( ) { return NAME ; } public boolean inField ( ) { return true ; } public boolean inConstructor ( ) { return true ; } public boolean inMethod ( ) { return true ; } public boolean inOverview ( ) { return true ; } public boolean inPackage ( ) { return true ; } public boolean inType ( ) { return true ; } public boolean isInlineTag ( ) { return false ; } public static void register ( Map tagletMap ) { ExampleTaglet tag = new ExampleTaglet ( ) ; Taglet t = ( Taglet ) tagletMap . get ( tag . getName ( ) ) ; if ( t != null ) { tagletMap . remove ( tag . getName ( ) ) ; } tagletMap . put ( tag . getName ( ) , tag ) ; } public String toString ( Tag tag ) { return createHTML ( readFile ( tag . text ( ) ) ) ; } public String toString ( Tag [ ] tags ) { if ( tags . length == 0 ) { return null ; } return createHTML ( readFile ( tags [ 0 ] . text ( ) ) ) ; } String createHTML ( String theString ) { if ( theString != null ) { String dd = \"<script type=\\\"text/javascript\\\">\\n\" + \"<!--\\n\" + \"document.getElementsByTagName('html')[0].className = 'isjs';\" + \"function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;\" + \"dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }\\n\" + \"-->\\n</script>\" ; return dd + \"\\n<div id=\\\"test\\\" class=\\\"toggleList\\\">\" + \"<dl><dt onclick=\\\"toggle(this);\\\"><span>+</span>Example</dt>\" + \"<dd><pre>\" + theString", "gt": "+ \"</pre>\" + \"</dd></dl></div>\" ;", "prediction": "+ \"</pre>\" ;\n", "label": 1}
{"id": 4124, "input": "<s> public class FirstChar2 { public static void main ( String [ ] args ) { System .", "gt": "out . println ( \"Hello world!\" ) ;", "prediction": "exit ( 0 ) ;\n", "label": 0}
{"id": 16141, "input": "<s> package org . eclipse . ui . tests . session ; import junit . framework . TestCase ; import org . eclipse . core . resources . IProject ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . tests . harness . util . FileUtil ; public class Bug95357Test extends TestCase { private static final String BUG95357PROJECT = \"Bug95357project\" ; private static final int FILE_MAX = 8 ; private IWorkbenchWindow fWin ; private IWorkbenchPage fActivePage ; private IProject fProject ; private IWorkbench fWorkbench ; private String [ ] itsFilename ; public Bug95357Test ( String testName ) { super ( testName ) ; fWorkbench = PlatformUI . getWorkbench ( ) ; fProject = null ; } private void setupFilenames ( String ext ) { itsFilename = new String [ Bug95357Test . FILE_MAX ] ; for ( int i = 0 ; i < Bug95357Test . FILE_MAX ; ++ i ) { itsFilename [ i ] = \"test\" + i + ext ; } } protected void setUp ( ) throws Exception { fWin = fWorkbench . getActiveWorkbenchWindow ( ) ; fActivePage = fWin . getActivePage ( ) ; fProject = FileUtil . createProject ( Bug95357Test . BUG95357PROJECT ) ; } private void multipleEditorsOpen ( ) { IEditorReference [ ] editors = fActivePage . getEditorReferences ( ) ; assertEquals ( Bug95357Test . FILE_MAX , editors . length ) ; for ( int i = 0 ; i < editors . length - 1 ; i ++ ) { assertNull ( \"Editor \" + i + \" \" + editors [ i ] . getName ( ) + \" should not be active\" , editors [ i ] . getEditor ( false ) ) ; } assertNotNull ( editors [ editors . length - 1 ] . getEditor ( false ) ) ; assertNotNull ( editors [ 0 ] . getEditor ( true ) ) ; } private void multipleStacksOnStartup ( ) { IEditorReference lastFile = null ; IEditorReference secondLastFile = null ; IEditorReference [ ] editors = fActivePage . getEditorReferences ( ) ; assertEquals ( Bug95357Test . FILE_MAX , editors . length ) ; for ( int i = 0 ; i < editors . length ; i ++ ) { if ( itsFilename [ itsFilename . length - 1 ] . equals ( editors [ i ] . getName ( ) ) ) { lastFile = editors [ i ] ; } else if ( itsFilename [ itsFilename . length - 2 ] . equals ( editors [ i ] . getName ( ) ) ) { secondLastFile = editors [ i ] ; } } assertNotNull ( lastFile . getEditor ( false ) ) ; assertNotNull ( secondLastFile . getEditor ( false ) ) ; for ( int i = 0 ; i < editors . length ; ++ i ) { if ( editors [ i ] != lastFile && editors [ i ] != secondLastFile ) { assertNull ( \"For file \" + i + \" \" + editors [ i ] . getName ( ) , editors", "gt": "[ i ] . getEditor ( false ) ) ;", "prediction": "[ i ] . getEditor ( false ) ) ;\n", "label": 1}
{"id": 7492, "input": "<s> package org . ofbiz . pos . jpos . service ; import java . util . Map ; import java . util . HashMap ; import java . util . Enumeration ; import java . awt . event . KeyListener ; import java . awt . event . KeyEvent ; import java . lang . reflect . Field ; import jpos . JposException ; import jpos . POSKeyboardConst ; import jpos . JposConst ; import jpos . events . DataEvent ; import jpos . services . EventCallbacks ; import org . ofbiz . pos . adaptor . KeyboardReceiver ; import org . ofbiz . pos . adaptor . KeyboardAdaptor ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilValidate ; public class KeyboardService extends BaseService implements jpos . services . POSKeyboardService17 , KeyboardReceiver , KeyListener { public static final String module = KeyboardService . class . getName ( ) ; protected boolean autoDisable = false ; protected boolean received = false ; protected int eventTypes = POSKeyboardConst . KBD_ET_DOWN ; protected int keyEvent = - 1 ; protected int keyData = - 1 ; protected KeyEvent lastEvent = null ; protected Map < Integer , PosKey > keyMapping = null ; public KeyboardService ( ) { KeyboardAdaptor . getInstance ( this , KeyboardAdaptor . KEYBOARD_DATA ) ; } @ Override public void open ( String deviceName , EventCallbacks ecb ) throws JposException { super . open ( deviceName , ecb ) ; this . keyMapping = new HashMap < Integer , PosKey > ( ) ; Enumeration < String > props = UtilGenerics . cast ( entry . getPropertyNames ( ) ) ; while ( props . hasMoreElements ( ) ) { String propName = props . nextElement ( ) ; if ( propName . startsWith ( \"key.\" ) ) { String propValue = ( String ) entry . getPropertyValue ( propName ) ; propName = propName . substring ( 4 ) ; PosKey key = new PosKey ( propName , propValue ) ; keyMapping . put ( key . hashCode ( ) , key ) ; } } } public boolean getCapKeyUp ( ) throws JposException { return false ; } public boolean getAutoDisable ( ) throws JposException { return this . autoDisable ; } public void setAutoDisable ( boolean b ) throws JposException { this . autoDisable = b ; } public int getEventTypes ( ) throws JposException { return this . eventTypes ; } public void setEventTypes ( int i ) throws JposException { if ( i == POSKeyboardConst . KBD_ET_DOWN ) this . eventTypes = i ; } public int getPOSKeyData ( ) throws JposException { if ( ! received ) { throw new JposException ( JposConst . JPOS_PS_UNKNOWN , \"No data received\" ) ; } return keyData ; } public int getPOSKeyEventType ( ) throws JposException { if ( ! received ) { throw new JposException ( JposConst . JPOS_PS_UNKNOWN , \"No data received\" ) ; } return this . keyEvent ; } public void clearInput ( ) throws JposException { this . keyEvent = - 1 ; this . keyData = - 1 ; this . received = false ; } public int getCapPowerReporting ( ) throws JposException { return 0 ; } public int getPowerNotify ( ) throws JposException { return 0 ; } public void setPowerNotify ( int i ) throws JposException { } public int getPowerState ( ) throws JposException { return 0 ; } public synchronized void receiveData ( int [ ] codes , char [ ] chars ) { if ( lastEvent != null ) { KeyEvent thisEvent = lastEvent ; PosKey thisKey = new PosKey ( thisEvent ) ; PosKey mappedKey = keyMapping . get ( thisKey . hashCode ( ) ) ; if ( mappedKey != null && mappedKey . checkModifiers ( thisEvent . getModifiersEx ( ) ) ) { this . received = true ; this . keyData = mappedKey . getMappedCode ( ) ; DataEvent event = new DataEvent ( this , 0 ) ; this . fireEvent ( event ) ; } } else { Debug . logInfo ( \"Last Event is null??\" , module ) ; } } public void keyPressed ( KeyEvent event ) { this . keyEvent = POSKeyboardConst . KBD_KET_KEYDOWN ; this . lastEvent = event ; } public void keyTyped ( KeyEvent event ) { } public void keyReleased ( KeyEvent event ) { if ( this . eventTypes == POSKeyboardConst . KBD_ET_DOWN_UP ) { this . keyEvent = POSKeyboardConst . KBD_KET_KEYDOWN ; this . lastEvent = event ; } } class PosKey { private int keyCode , mappedCode ; private boolean alt , ctrl , shift ; public PosKey ( KeyEvent event ) { this . keyCode = event . getKeyCode ( ) ; this . mappedCode = - 1 ; int modifiersEx = event . getModifiersEx ( ) ; this . shift = this . checkShift ( modifiersEx ) ; this . ctrl = this . checkCtrl ( modifiersEx ) ; this . alt = this . checkAlt ( modifiersEx ) ; } public PosKey ( String keyName , String mappedValue ) throws JposException { String keyDef = null ; String keyMod = null ; if ( keyName . indexOf ( \"+\" ) != - 1 ) { keyDef = keyName . substring ( 0 , keyName . indexOf ( \"+\" ) ) . trim ( ) ; keyMod = keyName . substring ( keyName . indexOf (", "gt": "\"+\" ) + 1 ) ;", "prediction": "\"+\" ) + 1 , keyName . length ( ) ) ;\n", "label": 0}
{"id": 16142, "input": "<s> package org . restlet . example . ext . rdf . foaf . resources ; import java . util . Map ; import java . util . TreeMap ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . example . ext . rdf . foaf . objects . Contact ; import org . restlet . example . ext . rdf . foaf . objects . User ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Delete ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; import org . restlet . resource . ResourceException ; public class ContactResource extends BaseResource { private Contact contact ; private User user ; @ Override public void doInit ( ) { final String userId = ( String ) getRequestAttributes ( ) . get ( \"userId\" ) ; this . user = getObjectsFacade ( ) . getUserById ( userId ) ; if ( user != null ) { final String contactId = ( String ) getRequestAttributes ( ) . get ( \"contactId\" ) ; this . contact = getObjectsFacade ( ) . getContactById ( contactId ) ; } setExisting ( this . contact != null ) ; } @ Delete public void removeContact ( ) throws ResourceException { getObjectsFacade ( ) . deleteContact ( this . user , this . contact ) ; getResponse ( ) . redirectSeeOther ( getRequest ( ) . getResourceRef ( ) . getParentRef ( ) ) ; } @ Put public void storeContact ( Representation entity ) throws ResourceException { final Form form = new Form ( entity ) ; this . contact . setFirstName ( form . getFirstValue ( \"firstName\" ) ) ; this . contact . setLastName ( form . getFirstValue ( \"lastName\" ) ) ; this . contact . setImage ( form . getFirstValue ( \"image\" ) ) ; this . contact . setNickname ( form . getFirstValue ( \"nickname\" ) ) ; this . contact . setFoafUri ( form . getFirstValue ( \"foafUri\" ) ) ; getObjectsFacade ( ) . updateContact ( this . user , this . contact ) ; getResponse ( ) . redirectSeeOther ( getRequest ( ) . getResourceRef ( ) ) ; } @ Get ( \"html\" ) public Representation toHtml ( Variant variant ) throws ResourceException { final Map < String , Object > dataModel = new TreeMap < String , Object > ( ) ; dataModel . put ( \"user\" , this . user ) ; dataModel . put ( \"contact\" , this . contact ) ; dataModel . put ( \"resourceRef\" , getRequest ( ) . getResourceRef ( ) ) ; dataModel . put ( \"rootRef\" ,", "gt": "getRequest ( ) . getRootRef ( ) ) ;", "prediction": "getRequest ( ) . getRootRef ( ) ) ;\n", "label": 1}
{"id": 3059, "input": "<s> package ar . com . fdvs . dj . domain ; import java . awt . Color ; import java . util . HashMap ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Page ; import ar . com . fdvs . dj . domain . entities . Entity ; public class DynamicReportOptions extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public static final Integer DEFAULT_HEADER_HEIGHT = new Integer ( 30 ) ; public static final Integer DEFAULT_HEADER_VARIABLES_HEIGHT = new Integer ( 20 ) ; public static final Integer DEFAULT_FOOTER_VARIABLES_HEIGHT = new Integer ( 20 ) ; public static final Integer DEFAULT_DETAIL_HEIGHT = new Integer ( 15 ) ; private Integer headerHeight = DEFAULT_HEADER_HEIGHT ; private Integer headerVariablesHeight = DEFAULT_HEADER_HEIGHT ; private Integer footerVariablesHeight = DEFAULT_FOOTER_VARIABLES_HEIGHT ; private Integer detailHeight = DEFAULT_DETAIL_HEIGHT ; private Integer leftMargin = DEFAULT_HEADER_HEIGHT ; private Integer rightMargin = new Integer ( 10 ) ; private Integer topMargin = new Integer ( 20 ) ; private Integer bottomMargin = new Integer ( 10 ) ; private Integer columnsPerPage = new Integer ( 1 ) ; private Integer columnSpace = new Integer ( 0 ) ; private boolean useFullPageWidth = false ; private Page page = Page . Page_A4_Portrait ( ) ; private boolean printBackgroundOnOddRows = false ; private Style oddRowBackgroundStyle = new StyleBuilder ( false , \"defaultOddRowStyle\" ) . setBackgroundColor ( new Color ( 200 , 200 , 200 ) ) . build ( ) ; private Integer titleHeight = DEFAULT_HEADER_HEIGHT ; private boolean titleNewPage = false ; private boolean summaryNewPage = false ; private Integer subtitleHeight = DEFAULT_DETAIL_HEIGHT ; private boolean showDetailBand = true ; private boolean printColumnNames = true ; private boolean ignorePagination = false ; private Style defaultHeaderStyle = new Style ( \"defaultHeaderStyle\" ) ; private Style defaultDetailStyle = new Style ( \"defaultDetailStyle\" ) ; private Style defaultFooterStyle = new Style ( \"defaultFooterStyle\" ) ; private Style defaultGroupHeaderStyle = new Style ( \"defaultGroupHeaderStyle\" ) ; private Style defaultGroupFooterStyle = new Style ( \"defaultGroupFooterStyle\" ) ; private HashMap imageBanners = new HashMap ( ) ; private HashMap firstPageImageBanners = new HashMap ( ) ; public HashMap getImageBanners ( ) { return imageBanners ; } public Integer getFooterVariablesHeight ( ) { return footerVariablesHeight ; } public void setFooterVariablesHeight ( Integer footerHeight ) { if ( footerHeight == null ) footerHeight = DEFAULT_FOOTER_VARIABLES_HEIGHT ; this . footerVariablesHeight = footerHeight ; } public Integer getHeaderHeight ( ) { return headerHeight ; } public void setHeaderHeight ( Integer headerHeight ) { if ( headerHeight == null", "gt": ") headerHeight = DEFAULT_HEADER_HEIGHT ;", "prediction": ") headerHeight = DEFAULT_HEADER_HEIGHT ;\n", "label": 0}
{"id": 16143, "input": "<s> package org . seage . metaheuristic . fireflies ; public abstract class FireflyOperator { abstract public double getDistance ( Solution s1 , Solution s2 ) ; abstract public void attract ( Solution s0 , Solution s1 , int iter ) ; public abstract Solution randomSolution ( ) ; public abstract void randomSolution ( Solution solution ) ; public abstract", "gt": "void modifySolution ( Solution solution ) ;", "prediction": "Solution getRandomSolution ( ) ;\n", "label": 1}
{"id": 4260, "input": "<s> package pkg1 ; import java . io . IOException ; import java . io . Serializable ; public class C1 implements Serializable { @ Deprecated public boolean undecorated = false ; private String title ; public static enum ModalExclusionType { NO_EXCLUDE , APPLICATION_EXCLUDE } ; public C1 ( String title , boolean test ) { } public C1 ( String title ) { } public void setUndecorated ( boolean undecorated ) { }", "gt": "public void readObject ( ) throws IOException", "prediction": "public void setTitle ( String title )\n", "label": 0}
{"id": 16144, "input": "<s> package org . apache . lucene . search . spans ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Set ; public class SpanNotQuery extends SpanQuery implements Cloneable { private SpanQuery include ; private SpanQuery exclude ; public SpanNotQuery ( SpanQuery include , SpanQuery exclude ) { this . include = include ; this . exclude = exclude ; if ( ! include . getField ( ) . equals ( exclude . getField ( ) ) ) throw new IllegalArgumentException ( \"Clauses must have same field.\" ) ; } public SpanQuery getInclude ( ) { return include ; } public SpanQuery getExclude ( ) { return exclude ; } public String getField ( ) { return include . getField ( ) ; } public Collection getTerms ( ) { return include . getTerms ( ) ; } public void extractTerms ( Set terms ) { include . extractTerms ( terms ) ; } public String toString ( String field ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( \"spanNot(\" ) ; buffer . append ( include . toString ( field ) ) ; buffer . append ( \", \" ) ; buffer . append ( exclude . toString ( field ) ) ; buffer . append ( \")\" ) ; buffer . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return buffer . toString ( ) ; } public Object clone ( ) { SpanNotQuery spanNotQuery = new SpanNotQuery ( ( SpanQuery ) include . clone ( ) , ( SpanQuery ) exclude . clone ( ) ) ; spanNotQuery . setBoost ( getBoost ( ) ) ; return spanNotQuery ; } public Spans getSpans ( final IndexReader reader ) throws IOException { return new Spans ( ) { private Spans includeSpans = include . getSpans ( reader ) ; private boolean moreInclude = true ; private Spans excludeSpans = exclude . getSpans ( reader ) ; private boolean moreExclude = excludeSpans . next ( ) ; public boolean next ( ) throws IOException { if ( moreInclude ) moreInclude = includeSpans . next ( ) ; while ( moreInclude && moreExclude ) { if ( includeSpans . doc ( ) > excludeSpans . doc ( ) ) moreExclude = excludeSpans . skipTo ( includeSpans . doc ( ) ) ; while ( moreExclude && includeSpans . doc ( ) == excludeSpans . doc ( ) && excludeSpans . end ( ) <= includeSpans . start ( ) ) { moreExclude = excludeSpans . next ( ) ; } if ( ! moreExclude || includeSpans . doc ( ) != excludeSpans . doc ( ) || includeSpans . end ( ) <= excludeSpans . start ( ) ) break ; moreInclude = includeSpans . next ( ) ; } return moreInclude ; } public boolean skipTo ( int target ) throws IOException { if ( moreInclude ) moreInclude = includeSpans . skipTo ( target ) ; if ( ! moreInclude ) return false ; if ( moreExclude && includeSpans . doc ( ) > excludeSpans . doc ( ) ) moreExclude = excludeSpans . skipTo ( includeSpans . doc ( ) ) ; while ( moreExclude && includeSpans . doc ( ) == excludeSpans . doc ( ) && excludeSpans . end ( ) <= includeSpans . start ( ) ) { moreExclude = excludeSpans . next ( ) ; } if ( ! moreExclude || includeSpans . doc ( ) != excludeSpans . doc ( ) || includeSpans . end ( ) <= excludeSpans . start ( ) ) return true ; return next ( ) ; } public int doc ( ) { return includeSpans . doc ( ) ; } public int start ( ) { return includeSpans . start ( ) ; } public int end ( ) { return includeSpans . end ( ) ; } public Collection getPayload ( ) throws IOException { ArrayList result = null ; if ( includeSpans . isPayloadAvailable ( ) ) { result = new ArrayList ( includeSpans . getPayload ( ) ) ; } return result ; } public boolean isPayloadAvailable ( ) { return includeSpans . isPayloadAvailable ( ) ; } public String toString ( ) { return \"spans(\" + SpanNotQuery . this . toString ( ) + \")\" ; } } ; } public Query rewrite ( IndexReader reader ) throws IOException { SpanNotQuery clone = null ; SpanQuery rewrittenInclude = ( SpanQuery ) include . rewrite ( reader ) ; if ( rewrittenInclude != include ) { clone = ( SpanNotQuery ) this . clone ( ) ; clone . include = rewrittenInclude ; } SpanQuery rewrittenExclude = ( SpanQuery ) exclude . rewrite ( reader ) ; if ( rewrittenExclude != exclude ) { if ( clone == null ) clone", "gt": "= ( SpanNotQuery ) this . clone ( ) ;", "prediction": "= ( SpanNotQuery ) this . clone ( ) ;\n", "label": 1}
{"id": 8035, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . ResourceAttributes ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ResourceAttributesTest extends XtextTest { @ Test public void testNone ( ) { testParserRule ( \"resourceattributes - \" , getRule ( ) ) ; } @ Test public void testAll ( ) { testParserRule ( \"resourceattributes * \" , getRule ( ) ) ; } @ Test public void testEmpty ( ) { testParserRule ( \"resourceattributes\" , getRule ( ) ) ; } @ Test public void testSomeEnumerated ( ) { testParserRule ( \"resourceattributes booking workinghours\" , getRule ( ) ) ; } @ Test public void testAllEnumerated ( ) { testParserRule ( \"resourceattributes vacation booking workinghours\" , getRule ( ) ) ; } @ Test public void testEnumeratedOnlyOnce ( ) { testParserRuleErrors (", "gt": "\"resourceattributes vacation vacation\" , getRule ( ) ) ;", "prediction": "\"resourceattributes - \" , getRule ( ) ) ;\n", "label": 0}
{"id": 16145, "input": "<s> package org . restlet . ext . jaxrs ; import static org . restlet . ext . jaxrs . internal . util . Util . append ; import static org . restlet . ext . jaxrs . internal . util . Util . getPathTemplateWithoutRegExps ; import static org . restlet . ext . jaxrs . internal . util . Util . indexBeginMatrixOfLastSegment ; import static org . restlet . ext . jaxrs . internal . util . Util . notEndsWith ; import static org . restlet . ext . jaxrs . internal . util . Util . notStartsWith ; import java . io . IOException ; import java . lang . reflect . Method ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . ws . rs . Path ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriBuilderException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnClassException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnMethodException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . ext . jaxrs . internal . todo . NotYetImplementedException ; import org . restlet . ext . jaxrs . internal . util . EncodeOrCheck ; import org . restlet . routing . Template ; import org . restlet . util . Resolver ; public abstract class AbstractUriBuilder extends UriBuilder { private class ArrayVariableResolver extends Resolver < String > { private final boolean encoding ; private int i = 0 ; private final Map < String , String > retrievedValues = new HashMap < String , String > ( ) ; private final Object [ ] values ; ArrayVariableResolver ( Object [ ] values , boolean encoding ) { this . values = values ; this . encoding = encoding ; } @ Override public String resolve ( String variableName ) { String varValue = this . retrievedValues . get ( variableName ) ; if ( varValue == null ) { if ( this . i >= this . values . length ) { throw new IllegalArgumentException ( \"The value given array contains not enough elements (contains \" + this . values . length + \", but need at least \" + ( this . i + 1 ) + \")\" ) ; } final Object value = this . values [ this . i ] ; if ( value == null ) { throw new IllegalArgumentException ( \"The given array contains null value at position", "gt": "(\" + this . i + \")\" ) ;", "prediction": "\" + this . i ) ;\n", "label": 1}
{"id": 6998, "input": "<s> package dbprocess ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; public class RemovalProcess { private final Connection conn ; private static RemovalProcess instance ; protected RemovalProcess ( final Connection conn ) throws SQLException { this . conn = conn ; } protected static synchronized RemovalProcess getInstance ( final Connection conn ) { if ( instance == null ) { try { instance = new RemovalProcess ( conn ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return instance ; } protected final void removeBookFromCatalogue ( final long bookIsbn ) throws SQLException { if ( bookIsbn < 0 ) { return ; } Statement stmt = conn . createStatement ( ) ; Statement stmt2 = conn . createStatement ( ) ; stmt . execute ( \"DELETE FROM tblBook WHERE ISBN=\" + bookIsbn + \";\" ) ; stmt2 . execute ( \"DELETE FROM tblBookRental WHERE BookISBN=\" + bookIsbn + \";\" ) ; } protected final boolean removeUser ( final String username ) throws SQLException { Statement stmt = conn . createStatement ( ) ; stmt . execute ( \"DELETE FROM \" + \"tblUser WHERE UserName=\\\"\" + username + \"\\\"\" ) ; stmt . execute ( \"DELETE FROM \" + \"tblAccountInfo WHERE UserName=\\\"\" + username + \"\\\"\" ) ; DatabaseProcess db = DatabaseProcess . getInstance ( ) ; return ! db . checkUser ( username , null ) ; } protected final boolean removeShoppingCart ( final String userName ) throws SQLException { Statement stmt = conn . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( \"SELECT * FROM \" + \"tblShoppingCart WHERE UserName = \\\"\" + userName + \"\\\"\" ) ; Statement stmt2 = conn . createStatement ( ) ; if ( rs . next ( ) ) { stmt2 . execute ( \"DELETE FROM tblCartContent \" + \"WHERE CartNumber = \" + rs . getInt ( \"CartNumber\" ) ) ; stmt2 . execute ( \"DELETE FROM tblShoppingCart \" + \"WHERE CartNumber = \" + rs . getInt ( \"CartNumber\" ) ) ; return true ; } return false ; } protected final boolean removeBookFromUser ( final String username , final long isbn ) throws SQLException { Statement stmt = conn . createStatement ( ) ; stmt . execute ( \"DELETE FROM tblBookRental \" + \"WHERE UserName=\\\"\" + username", "gt": "+ \"\\\" AND BookISBN=\" + isbn ) ;", "prediction": "+ \"\\\"\" ) ;\n", "label": 0}
{"id": 16153, "input": "<s> package org . fuzzydb . attrs ; import org . fuzzydb . attrs . internal . BaseAttribute ; public interface IDecorator { public abstract String getAttrName ( ) ; public abstract String getValueString ( BaseAttribute attr ) ; public abstract String render", "gt": "( BaseAttribute attr ) ;", "prediction": "( BaseAttribute attr ) ;\n", "label": 1}
{"id": 306, "input": "<s> enum EnumPrivateConstructor { RED ( 255 , 0 , 0 ) , GREEN ( 0 , 255 , 0 ) , BLUE ( 0 , 0 , 255 ) ; private int r , g , b ; private EnumPrivateConstructor ( int r , int g , int b ) {", "gt": "this . r = r ;", "prediction": "this . r = r ;\n", "label": 0}
{"id": 16155, "input": "<s> package org . apache . lucene . store ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; public class TestLock extends LuceneTestCase { public void testObtain ( ) { LockMock lock = new LockMock ( ) ; Lock . LOCK_POLL_INTERVAL = 10 ; try { lock . obtain ( Lock . LOCK_POLL_INTERVAL ) ; fail ( \"Should have failed to obtain lock\" ) ; } catch ( IOException e ) { assertEquals ( \"should attempt to lock more", "gt": "than once\" , lock . lockAttempts , 2 ) ;", "prediction": "\" , e . getMessage ( ) ) ;\n", "label": 1}
{"id": 1049, "input": "<s> @ interface Anno { String value ( ) ; } @ Anno ( System . getProperty", "gt": "( \"user.dir\" ) ) class AttrMustBeConstant", "prediction": "( \"line.separator\" ) ) public String getLineSeparator ( )\n", "label": 0}
{"id": 16157, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Sash ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . internal . dnd . SwtUtil ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . part . MultiEditor ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . statushandlers . StatusManager ; public abstract class PartPane extends LayoutPart implements IPropertyListener , Listener , IPropertyChangeListener { public static final String PROP_ZOOMED = \"zoomed\" ; private boolean isZoomed = false ; private MenuManager paneMenuManager ; private ListenerList listeners = new ListenerList ( ) ; private ListenerList partListeners = new ListenerList ( ) ; protected IWorkbenchPartReference partReference ; protected WorkbenchPage page ; protected Composite control ; private boolean inLayout = true ; private boolean busy ; public static class Sashes { public Sash left ; public Sash right ; public Sash top ; public Sash bottom ; } public PartPane ( IWorkbenchPartReference partReference , WorkbenchPage workbenchPage ) { super ( partReference . getId ( ) ) ; this . partReference = partReference ; this . page = workbenchPage ; } public void addSizeMenuItem ( Menu menu , int index ) { MenuItem item = new MenuItem ( menu , SWT . CASCADE , index ) ; item . setText ( WorkbenchMessages . get ( ) . PartPane_size ) ; Menu sizeMenu = new Menu ( menu ) ; item . setMenu ( sizeMenu ) ; addSizeItems ( sizeMenu ) ; } public void createControl ( Composite parent ) { if ( getControl ( ) != null ) { return ; } partReference . addPropertyListener ( this ) ; partReference . addPartPropertyListener ( this ) ; control = new Composite ( parent , SWT . NONE ) ; control . setLayout ( new FillLayout ( ) ) ; control . setVisible ( false ) ; control . moveAbove ( null ) ; createTitleBar ( ) ; control . addListener ( SWT . Activate , this ) ; } protected abstract void createTitleBar ( ) ; public void dispose ( ) { super . dispose ( ) ; if ( ( control != null ) && ( ! control . isDisposed ( ) ) ) { control . removeListener ( SWT . Activate , this ) ; try { control . dispose ( ) ; } catch ( RuntimeException ex ) { StatusUtil . handleStatus ( ex , StatusManager . LOG ) ; } control = null ; } if ( ( paneMenuManager != null ) ) { paneMenuManager . dispose ( ) ; paneMenuManager = null ; } partReference . removePropertyListener ( this ) ; partReference . removePartPropertyListener ( this ) ; } abstract public void doHide ( ) ; protected void doZoom ( ) { if ( isDocked ( ) ) { page . toggleZoom ( partReference ) ; } } public Rectangle getBounds ( ) { return getControl ( ) . getBounds ( ) ; } public Control getControl ( ) { return control ; } public IWorkbenchPartReference getPartReference ( ) { return partReference ; } public void handleEvent ( Event event ) { if ( event . type == SWT . Activate ) { if ( inLayout ) { requestActivation ( ) ; } } } public boolean isZoomed ( ) { return isZoomed ; } public void moveAbove ( Control refControl ) { if ( getControl ( ) != null ) { getControl ( ) . moveAbove ( refControl ) ; } } public void requestActivation ( ) { IWorkbenchPart part = partReference . getPart ( true ) ; if ( part instanceof MultiEditor ) { return ; } this . page . requestActivation ( part ) ; }", "gt": "public void setContainer ( ILayoutContainer container )", "prediction": "public boolean isZoomed ( )\n", "label": 1}
{"id": 6046, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . engine . client . event . EventCenter ; import org . gk . ui . client . com . grid . column . gkImageColumnConfig ; import com . extjs . gxt . ui . client . core . Template ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; import com . extjs . gxt . ui . client . widget . tips . ToolTipConfig ; import com . google . gwt . user . client . ui . Image ; public class GImageFieldBuilder extends GridFieldBuilder { public GImageFieldBuilder ( String img ) { super ( img ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; ColumnConfig cc = new gkImageColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ; String showTip = x . getAttribute ( \"showTip\" , \"false\" ) ; if ( Boolean . parseBoolean ( showTip ) ) { ToolTipConfig config = new ToolTipConfig ( ) ; config . setMouseOffset ( new int [ ] { 0 , 0 } ) ; config . setAnchor ( \"left\" ) ; Image image = new Image ( x . getValue ( ) ) ; config . setTemplate ( new Template ( getHtml ( x . getValue ( ) , image . getWidth ( ) , image . getHeight ( ) ) ) ) ; field . setToolTip ( config ) ; } field . addListener ( Events", "gt": ". OnClick , new Listener < BaseEvent > ( )", "prediction": ". Created ( ) ) ;\n", "label": 0}
{"id": 16160, "input": "<s> package org . mitre . oauth2 . service . impl ; import org . mitre . oauth2 . model . AuthorizationCodeEntity ; import org . mitre . oauth2 . repository . AuthorizationCodeRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . oauth2 . common . exceptions . InvalidGrantException ; import org . springframework . security . oauth2 . common . util . RandomValueStringGenerator ; import org . springframework . security . oauth2 . provider . code . AuthorizationCodeServices ; import org . springframework . security . oauth2 . provider . code . AuthorizationRequestHolder ; import org . springframework . stereotype . Service ; @ Service public class DefaultOAuth2AuthorizationCodeService implements AuthorizationCodeServices { @ Autowired private AuthorizationCodeRepository repository ; private RandomValueStringGenerator generator = new RandomValueStringGenerator ( ) ; @ Override public String createAuthorizationCode ( AuthorizationRequestHolder authentication ) { String code = generator . generate ( ) ; AuthorizationCodeEntity entity = new AuthorizationCodeEntity ( code , authentication ) ; repository", "gt": ". save ( entity ) ;", "prediction": ". save ( entity ) ;\n", "label": 1}
{"id": 5157, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import java . awt . Color ; import java . util . List ; import org . jfree . chart . plot . PlotOrientation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . dataset . CategoryDataset ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . chart . plot . LinePlot ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; public class DJLineChartBuilder extends AbstractChartBuilder { public DJLineChartBuilder setOperation ( byte operation ) { this . chart . setOperation ( operation ) ; return this ; } public DJLineChartBuilder setLink ( DJHyperLink link ) { this . chart . setLink ( link ) ; return this ; } public DJLineChartBuilder setBackColor ( Color backColor ) { this . chart . getOptions ( ) . setBackColor ( backColor ) ; return this ; } public DJLineChartBuilder setHeight ( int height ) { this . chart . getOptions ( ) . setHeight ( height ) ; return this ; } public DJLineChartBuilder setWidth ( int width ) { this . chart . getOptions ( ) . setWidth ( width ) ; return this ; } public DJLineChartBuilder setCentered ( boolean centered ) { this . chart . getOptions ( ) . setCentered ( centered ) ; return this ; } public DJLineChartBuilder setPosition ( byte position ) { this . chart . getOptions ( ) . setPosition ( position ) ; return this ; } public DJLineChartBuilder setY ( int y ) { this . chart . getOptions ( ) . setY ( y ) ; return this ; } public DJLineChartBuilder setX ( int x ) { this . chart . getOptions ( ) . setX ( x ) ; return this ; } public DJLineChartBuilder setShowLegend ( boolean showLegend ) { this . chart . getOptions ( ) . setShowLegend ( new Boolean ( showLegend ) ) ; return this ; } public DJLineChartBuilder setTitleColor ( Color titleColor ) { this . chart . getOptions ( ) . setTitleColor ( titleColor ) ; return this ; } public DJLineChartBuilder setSubtitleColor ( Color subtitleColor ) { this . chart . getOptions ( ) . setSubtitleColor ( subtitleColor ) ; return this ; } public DJLineChartBuilder setLegendColor ( Color legendColor ) { this . chart . getOptions ( ) . setLegendColor ( legendColor ) ; return this ; } public DJLineChartBuilder setLegendBackgroundColor ( Color legendBackgroundColor ) { this . chart . getOptions ( ) . setLegendBackgroundColor ( legendBackgroundColor ) ; return this ; } public DJLineChartBuilder setTheme ( String theme ) { this . chart . getOptions ( ) . setTheme ( theme ) ; return this ; } public DJLineChartBuilder setTitleFont ( Font titleFont ) { this . chart . getOptions ( ) . setTitleFont ( titleFont ) ; return this ; } public DJLineChartBuilder setSubtitleFont ( Font subtitleFont ) { this . chart . getOptions ( ) . setSubtitleFont ( subtitleFont ) ; return this ; } public DJLineChartBuilder setLegendFont ( Font legendFont ) { this . chart . getOptions ( ) . setLegendFont ( legendFont ) ; return this ; } public DJLineChartBuilder setLegendPosition ( byte legendPosition ) { this . chart . getOptions ( ) . setLegendPosition ( legendPosition ) ; return this ; } public DJLineChartBuilder setTitlePosition ( byte titlePosition ) { this . chart . getOptions ( ) . setTitlePosition ( titlePosition ) ; return this ; } public DJLineChartBuilder setTitle ( String title ) { this . chart . getOptions ( ) . setTitleExpression ( new LiteralExpression ( title ) ) ; return this ; } public DJLineChartBuilder setTitle ( StringExpression titleExpression ) { this . chart . getOptions ( ) . setTitleExpression ( titleExpression ) ; return this ; } public DJLineChartBuilder setSubtitle ( String subtitle ) { this . chart . getOptions ( ) . setSubtitleExpression ( new LiteralExpression ( subtitle ) ) ; return this ; } public DJLineChartBuilder setSubtitle ( StringExpression subtitleExpression ) { this . chart . getOptions ( ) . setSubtitleExpression ( subtitleExpression ) ; return this ; } public DJLineChartBuilder setLineStyle ( byte lineStyle ) { this . chart . getOptions ( ) . setLineStyle ( lineStyle ) ; return this ; } public DJLineChartBuilder setLineWidth ( float lineWidth ) { this . chart . getOptions ( ) . setLineWidth ( new Float ( lineWidth ) ) ; return this ; } public DJLineChartBuilder setLineColor ( Color lineColor ) { this . chart . getOptions ( ) . setLineColor ( lineColor ) ; return this ; } public DJLineChartBuilder setPadding ( int padding ) { this . chart . getOptions ( ) . setPadding ( new Integer ( padding ) ) ; return this ; } public DJLineChartBuilder setCustomizerClass ( String customizerClass ) { this . chart . getOptions ( ) . setCustomizerClass ( customizerClass ) ; return this ; } public DJLineChartBuilder setCategory ( PropertyColumn category ) { getDataset ( ) . setCategory ( category ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column ) { getDataset ( ) . addSerie ( column ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column , String label ) { getDataset ( ) . addSerie ( column , label ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column , StringExpression labelExpression ) { getDataset ( ) . addSerie ( column , labelExpression ) ; return this ; } public DJLineChartBuilder setUseSeriesAsCategory ( boolean useSeriesAsCategory ) { getDataset ( ) . setUseSeriesAsCategory ( useSeriesAsCategory ) ; return this ; } public DJLineChartBuilder setLabelRotation ( double labelRotation ) { this . getPlot ( ) . setLabelRotation ( new Double ( labelRotation ) ) ; return this ; } public DJLineChartBuilder setOrientation ( PlotOrientation orientation ) { getPlot ( ) . setOrientation ( orientation ) ; return this ; } public DJLineChartBuilder addSeriesColor ( Color color ) { getPlot ( ) . addSeriesColor ( color ) ; return this ; } public DJLineChartBuilder setSeriesColors ( List seriesColors ) { getPlot ( ) . setSeriesColors ( seriesColors ) ; return this ; } public DJLineChartBuilder setCategoryAxisFormat ( DJAxisFormat categoryAxisFormat ) {", "gt": "getPlot ( ) . setCategoryAxisFormat ( categoryAxisFormat ) ;", "prediction": "this . getDataset ( ) . setCategoryAxisFormat ( categoryAxisFormat ) ;\n", "label": 0}
{"id": 16162, "input": "<s> package com . emf4sw . owl . transform . owl2ecore ; import static com . atl . common . models . Models . register ; import static com . atl . common . trans . Transformations . transform ; import static com . atl . common . utils . Preconditions . checkNotNull ; import java . util . Map ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . m2m . atl . core . emf . EMFModel ; import com . atl . common . models . Models ; import com . atl . common . trans . Transformation ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . transform . OWLTransformations ; public class OWL2Ecore implements Transformation < Resource , Resource > { static { register ( OWLPackage . eINSTANCE . eResource ( ) ) ; } public OWL2Ecore ( ) { } public OWL2Ecore ( Map < String , Object > options ) { } static { register ( OWLPackage . eINSTANCE . eResource ( ) ) ; } public Resource apply ( Resource arg ) { checkNotNull ( arg , \"Cannot execute transformation \" + this + \",", "gt": "cause input null.\" ) ;", "prediction": "input is null\" ) ;\n", "label": 1}
{"id": 8083, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Main { static int maxLg = 200 ; static BigNum tres [ ] = new BigNum [ 2000 ] ; static BigNum doisPot [ ] = new BigNum [ 2000 ] ; static int posi = 0 ; static int posb [ ] = new int [ 2000 ] ; public static void main ( String args [ ] ) throws Exception { String s ; tres [ 0 ] = BigNum . ONE ; tres [ 1 ] = new BigNum ( 3 ) ; doisPot [ 0 ] = BigNum . TWO ; doisPot [ 1 ] = new BigNum ( 2 ) ; for ( int i = 2 ; i != 1000 ; i ++ ) { tres [ i ] = tres [ i - 1 ] . multiply ( 3 ) ; doisPot [ i ] = doisPot [ i - 1 ] . multiply ( 2 ) ; } while ( ( s = readLine ( ) ) != null ) { s = s . trim ( ) ; if ( s . equals ( \"1\" ) ) { System . out . println ( \"{ }\" ) ; continue ; } else if ( s . equals ( \"2\" ) ) { System . out . println ( \"{ 1 }\" ) ; continue ; } else if ( s . equals ( \"0\" ) ) { return ; } BigNum b = new BigNum ( s ) ; System . out . print ( \"{\" ) ; posi = 0 ; tenta ( b ) ; for ( int i = 0 ; i != posi ; i ++ ) { if ( i != 0 ) { System . out . print ( \", \" + tres [ posb [ i ] ] ) ; } else { System . out . print ( \" \" + tres [ posb [ i ] ] ) ; } } System . out . println ( \" }\" ) ; } } private static void tenta ( BigNum b ) { if ( b . equals ( BigNum . ONE ) ) { return ; } else if ( b . equals ( BigNum . ZERO ) ) { return ; } else if ( b . equals ( BigNum . TWO ) ) { posb [ posi ++ ] = 0 ; return ; } int aelevar = 1 ; int antigo = - 1 ; int doisElevadoAoUltimo = 0 ; BigNum val = new BigNum ( 2 ) ; while ( val . compareTo ( b ) < 0 ) { aelevar ++ ; antigo = doisElevadoAoUltimo ; doisElevadoAoUltimo ++ ; val = val . add ( doisPot [ doisElevadoAoUltimo ] ) ; } BigNum c = b . menos ( doisPot [ doisElevadoAoUltimo ] ) ; if ( c . compareTo ( b ) > 0 ) { System . exit ( 0 ) ; } tenta ( c ) ; posb [ posi ++ ] = aelevar - 1 ; } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; } lin [ lg ++ ] += car ; } if ( ( car < 0 ) && ( lg == 0 ) ) { return ( null ) ; } return ( new String ( lin , 0 , lg ) ) ; } static long [ ] splitLongLine ( String s ) { String [ ] l = split ( s ) ; long v [ ] = new long [ l . length ] ; for ( int i = 0 ; i != l . length ; i ++ ) { v [ i ] = Long . valueOf ( l [ i ] ) . longValue ( ) ; } return v ; } } class BigNum { String my ; static final int MAX = 1000 ; static final long QUOTE = 100000 ; static final int QUOTE_SIZE = 5 ; static BigNum ONE = new BigNum ( 1 ) ; static BigNum ZERO = new BigNum ( 0 ) ; static BigNum TWO = new BigNum ( 2 ) ; int max = 0 ; long [ ] mag ; BigNum ( int i ) { mag = new long [ MAX ] ; for ( int z = 0 ; z != MAX ; z ++ ) { mag [ z ] = 0 ; } while ( i != 0 ) { mag [ max ++ ] = i % QUOTE ; i /= QUOTE ; } this . my = calcString ( ) ; } BigNum ( String s ) { this ( 0 ) ; s = s . trim ( ) ; int size = s . length ( ) ; int p = 0 ; for ( ; s . charAt ( p ) == 0 && p != size ; p ++ ) ; if ( p == size ) { return ; } int i = size ; String st ; while ( true ) { if ( i - p <= QUOTE_SIZE ) { mag [ max ++ ] = Integer . parseInt ( s . substring ( p , i ) ) ; break ; } st = s . substring ( i - QUOTE_SIZE , i ) ; mag [ max ++ ] = Integer . parseInt ( st ) ; i -= QUOTE_SIZE ; } if", "gt": "( mag [ max - 1 ] == 0 )", "prediction": "( i == size )\n", "label": 0}
{"id": 16163, "input": "<s> package models ; import play . db . jpa . Model ; import javax . persistence . Entity ; @ Entity public class Article extends Model { public String name ; public Article ( String name ) {", "gt": "this . name = name ;", "prediction": "super ( name ) ;\n", "label": 1}
{"id": 3635, "input": "<s> package com . midtro . platform . modules . assets ; import java . util . Map ; public interface Assembler { void assemble ( String assetName , String fileName , AssetConfig config , Map < String , Asset < ?", "gt": "> > store ) throws Exception ;", "prediction": "> > assets ) ;\n", "label": 0}
{"id": 16165, "input": "<s> package org . apache . sqoop . hbase ; import java . io . Closeable ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import org . apache . hadoop . conf . Configurable ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hbase . client . HTable ; import org . apache . hadoop . hbase . client . Put ; import org . apache . hadoop . util . ReflectionUtils ; import com . cloudera . sqoop . lib . FieldMappable ; import com . cloudera . sqoop . lib . FieldMapProcessor ; import com . cloudera . sqoop . lib . ProcessingException ; public class HBasePutProcessor implements Closeable , Configurable , FieldMapProcessor { public static final String TABLE_NAME_KEY = \"sqoop.hbase.insert.table\" ; public static final String COL_FAMILY_KEY = \"sqoop.hbase.insert.column.family\" ; public static final String ROW_KEY_COLUMN_KEY = \"sqoop.hbase.insert.row.key.column\" ; public static final String TRANSFORMER_CLASS_KEY = \"sqoop.hbase.insert.put.transformer.class\" ; private Configuration conf ; private PutTransformer putTransformer ; private String tableName ; private HTable table ; public HBasePutProcessor ( ) { } @ Override @ SuppressWarnings ( \"unchecked\" ) public void setConf ( Configuration config ) { this . conf = config ; Class < ? extends PutTransformer > xformerClass = ( Class < ? extends PutTransformer > ) this . conf . getClass ( TRANSFORMER_CLASS_KEY , ToStringPutTransformer . class ) ; this . putTransformer = ( PutTransformer ) ReflectionUtils . newInstance ( xformerClass , this . conf ) ; if ( null == putTransformer ) { throw new RuntimeException ( \"Could not instantiate PutTransformer.\" ) ; } this . putTransformer . setColumnFamily ( conf . get ( COL_FAMILY_KEY , null ) ) ; this . putTransformer . setRowKeyColumn ( conf . get ( ROW_KEY_COLUMN_KEY , null ) ) ; this . tableName = conf . get ( TABLE_NAME_KEY , null ) ; try { this . table = new HTable ( conf , this . tableName ) ; } catch ( IOException ioe ) { throw new RuntimeException ( \"Could not access HBase table \" + tableName , ioe ) ; } this . table . setAutoFlush ( false ) ; } @ Override public Configuration getConf ( ) { return this . conf ; } @ Override public void accept ( FieldMappable record ) throws IOException , ProcessingException { Map < String , Object > fields = record . getFieldMap ( ) ; List < Put > putList = putTransformer . getPutCommand ( fields ) ; if ( null != putList ) { for ( Put put : putList ) { this", "gt": ". table . put ( put ) ;", "prediction": ". putList . add ( put ) ;\n", "label": 1}
{"id": 3378, "input": "<s> package org . ofbiz . sql ; import java . util . List ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . util . StringUtil ; @ SourceMonitored public final class ListCondition extends Condition { private final Value left ; private final String op ; private final List < Value > values ; public ListCondition ( Value left , String op , List < Value > values ) { this . left = left ; this . op = op . toLowerCase ( ) ; this . values = values ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public Value getLeft ( ) { return left ; } public String getOp ( ) { return op ; } public List < Value > getValues ( ) { return values ; } @ Override public boolean equals ( Object o ) { if ( o instanceof ListCondition ) { ListCondition other = ( ListCondition ) o ; return left . equals ( other . left ) && op . equals ( other . op ) && values . equals ( other . values ) ; } else { return false ; } } public", "gt": "StringBuilder appendTo ( StringBuilder sb )", "prediction": "String toString ( )\n", "label": 0}
{"id": 16167, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . util . Date ; import java . util . Properties ; import org . apache . lucene . document . DateTools ; public class DocData { private String name ; private String body ; private String title ; private String date ; private Properties props ; public void clear ( ) { name = null ; body = null ; title = null ; date = null ; props = null ; } public String getBody ( ) { return body ; } public String getDate ( ) { return date ; } public String getName ( ) { return name ; } public Properties getProps ( ) { return props ; } public String getTitle ( ) { return title ; } public void setBody ( String body ) { this . body = body ; } public void", "gt": "setDate ( Date date )", "prediction": "setTitle ( String title )\n", "label": 1}
{"id": 7203, "input": "<s> package p ; import p . Tree . * ; public class TreeInfo { public static void declarationFor ( final Tree tree ) { class DeclScanner extends TreeScanner < Error > { public void scan ( Tree tree ) { } } DeclScanner", "gt": "s = new DeclScanner ( ) ;", "prediction": "( Tree tree )\n", "label": 0}
{"id": 16179, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . jface . preference . IPreferencePageContainer ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; public class DynamicPreferencePage implements IWorkbenchPreferencePage { public DynamicPreferencePage ( ) { super ( ) ; } public void init ( IWorkbench workbench ) { } public Point computeSize ( ) { return null ; } public boolean isValid ( ) { return false ; } public boolean okToLeave ( ) { return false ; } public boolean performCancel ( ) { return false ; } public boolean performOk ( ) { return false ; }", "gt": "public void setContainer ( IPreferencePageContainer preferencePageContainer )", "prediction": "}\n", "label": 1}
{"id": 4986, "input": "<s> class DivZero { public static final int ONE = 1 ; public int i1 = 1 / 0 ; public static final int i2 = 1 / 0 ; public int i3 = 1 % 0 ; public static final int i4 = 1 % 0 ; public static final int i5 = 1 / ( 1 - 1 ) ; public static final int i6 = 1 / ( ONE - 1 ) ; public static final int i7 = 1 / ( ONE - ONE ) ; public static final int i8 = 1 % ( 1 - 1 ) ; public static final int i9 = 1 % ( ONE - 1 ) ; public static final int i10 = 1 % ( ONE - ONE ) ; public static final long ONEL = 1L ; public long l1 = 1L / 0L ; public static final long l2 = 1L / 0L ; public long l3 = 1L % 0L ; public static final long l4 = 1L % 0L ; public static final long l5 = 1L / ( 1L - 1L ) ; public static final long l6 = 1L / ( ONEL - 1L ) ; public static final long l7 = 1L / ( ONEL - ONEL ) ; public static final long l8 = 1L % ( 1L - 1L ) ; public static final long l9 = 1L % ( ONEL - 1L ) ; public static final long l10 = 1L % ( ONEL - ONEL ) ; static void m ( ) { int mi1 = 1 / 0 ; int mi2 = 1 % 0 ; mi1 /= 0 ; mi1 %= 0 ; long ml1 = 1L / 0L ; long ml2 = 1L % 0L ; ml1 /= 0L ; ml1 %= 0L ; } } @ SuppressWarnings ( \"divzero\" ) class DivZero2 { public static final int ONE = 1 ; public int i1 = 1 / 0 ; public static final int i2 = 1 / 0 ; public int i3 = 1 % 0 ; public static final int i4 = 1 % 0 ; public static final int i5 = 1 / ( 1 - 1 ) ; public static final int i6 = 1 / ( ONE - 1 ) ; public static final int i7 = 1 / ( ONE - ONE ) ; public static final int i8 = 1 % ( 1 - 1 ) ; public static final int i9 = 1", "gt": "% ( ONE - 1 ) ;", "prediction": "/ ( 1 - 1 ) ;\n", "label": 0}
{"id": 16180, "input": "<s> package monbulk . shared . Model ; import java . util . ArrayList ; import java . util . Iterator ; public class StackedCategories { public class ItemData { private String CategoryName ; private String CategoryID ; private IPojo CategoryHTML ; public ItemData ( String cName , String cID , IPojo cHTML ) { this . CategoryName = cName ; this . CategoryID = cID ; this . CategoryHTML = cHTML ; } public ItemData ( String cName , String cID ) { this . CategoryName = cName ; this . CategoryID = cID ; this . CategoryHTML = null ; } public IPojo getPOJO ( ) { return this . CategoryHTML ; } public void setHTML ( IPojo HTML ) { this . CategoryHTML = HTML ; } public String getID ( ) { return this . CategoryID ; } public void setID ( String ID ) { this . CategoryID = ID ; } public String getName ( ) { return this . CategoryName ; } public void setName ( String Name ) { this . CategoryName = Name ; } } public class ParentCategory { private ItemData CategoryParent ; private ArrayList < ItemData > ChildCategories ; public ParentCategory ( String ParentCategoryName , String ParentCategoryID ) { this . CategoryParent = new ItemData ( ParentCategoryName , ParentCategoryID ) ; this . ChildCategories = new ArrayList < ItemData > ( ) ; } public void AddChild ( String cName , String cID , IPojo cHTML ) { ItemData tmpItem = new ItemData ( cName , cID , cHTML ) ; this . ChildCategories . add ( tmpItem ) ; } public Boolean RemoveChild ( String cName ) { Iterator < ItemData > i = ChildCategories . iterator ( ) ; while ( i . hasNext ( ) ) { ItemData tmpItem = ( ItemData ) i . next ( ) ; if ( tmpItem . CategoryName . equals ( cName ) ) { this . ChildCategories . remove ( tmpItem ) ; return true ; } } return false ; } public ItemData getChildItemForName ( String childName ) { Iterator < ItemData > i = ChildCategories . iterator ( ) ; while ( i . hasNext ( ) ) { ItemData tmpItem = ( ItemData ) i . next ( ) ; if ( tmpItem . CategoryName . equals ( childName ) ) { return tmpItem ; } } return null ; } public ItemData getChildItemForID ( String ID ) { Iterator < ItemData > i = ChildCategories . iterator ( ) ; while ( i . hasNext ( ) ) { ItemData tmpItem = i . next ( ) ; if ( tmpItem . CategoryID . equals ( ID ) ) { return tmpItem ; } } return null ; } public ArrayList < ItemData > getChildItems ( ) { return this . ChildCategories ; } public ArrayList < String > getChildTitles ( ) { Iterator < ItemData > i = this . ChildCategories . iterator ( ) ; ArrayList < String > titles = new ArrayList < String > ( ) ; while ( i . hasNext ( ) ) { ItemData tmpItem = i . next ( ) ; titles . add ( tmpItem . CategoryName ) ; } return titles ; } public ItemData getParent ( ) { return CategoryParent ; } } private ArrayList < ParentCategory > ParentCategories ; public StackedCategories ( ) { this . ParentCategories = new ArrayList < ParentCategory > ( ) ; } public void addParent ( String ID , String Name ) { ParentCategory tmpItem = new ParentCategory", "gt": "( Name , ID ) ;", "prediction": "( ID , Name ) ;\n", "label": 1}
{"id": 1797, "input": "<s> package y ; public final class R3 { x . B . C a = null ; x . C b = null ; R1 c", "gt": "= new R1 ( ) ;", "prediction": "= null ;\n", "label": 0}
{"id": 16182, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . fragments ; import com . xtremelabs . androidtohackui . bubbles . models . BubbleTitleBarElements ; public interface IBubbleFragment { BubbleTitleBarElements getBubbleActionBarElements ( ) ;", "gt": "void setFragmentHandler ( IBubbleFragmentHandler handler ) ;", "prediction": "}\n", "label": 1}
{"id": 1452, "input": "<s> import java . util . Collection ; import java . util . Collections ; public class T6650759c { static interface A { } static interface B < X extends A > { } static interface C < X extends A , Y extends B < X > > { } public static < T extends A , U extends B < T > > Collection < C < T ,", "gt": "U > > get ( U u )", "prediction": "U > > getC ( )\n", "label": 0}
{"id": 16183, "input": "<s> package org . eclipse . ui . browser ; import org . eclipse . ui . PartInitException ; public interface IWorkbenchBrowserSupport { int LOCATION_BAR = 1 << 1 ; int NAVIGATION_BAR = 1 << 2 ; int STATUS = 1 << 3 ; int PERSISTENT = 1 << 4 ; int AS_EDITOR = 1 << 5 ; int AS_VIEW = 1 << 6 ; int AS_EXTERNAL = 1 << 7 ; IWebBrowser createBrowser ( int style , String browserId , String name , String", "gt": "tooltip ) throws PartInitException ;", "prediction": "description ) ;\n", "label": 1}
{"id": 9972, "input": "<s> package org . gk . engine . client . build . form ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class FormBuilder extends Builder { public FormBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode (", "gt": "List < UIGen > nodeList , Node node )", "prediction": "Node node )\n", "label": 0}
{"id": 16186, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . ecore . EObject ; public interface DatatypeDefinition extends EObject { DataRange getDataRange ( ) ; void setDataRange ( DataRange value ) ; OWLDatatype getDatatype ( ) ; void", "gt": "setDatatype ( OWLDatatype value ) ;", "prediction": "setDatatype ( OWLDatatype value ) ;\n", "label": 1}
{"id": 4934, "input": "<s> package com . matburt . mobileorg . Gui . Capture ; import android . app . Activity ; import android . os . Bundle ; import android . text . TextUtils ; import android . view . LayoutInflater ; import android . view . View ; import android . view . ViewGroup ; import android . widget . TableLayout ; import com . actionbarsherlock . app . SherlockFragment ; import com . actionbarsherlock . view . Menu ; import com . actionbarsherlock . view . MenuInflater ; import com . actionbarsherlock . view . MenuItem ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Gui . Capture . DateTableRow . DateTableRowListener ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgNodePayload ; import com . matburt . mobileorg . OrgData . OrgNodeTimeDate ; public class DatesFragment extends SherlockFragment { private final String DATES_SCHEDULED = \"scheduled\" ; private final String DATES_DEADLINE = \"deadline\" ; private final String DATES_TIMESTAMP = \"timestamp\" ; private TableLayout datesView ; private boolean isModifiable = true ; DateTableRow scheduledEntry = null ; DateTableRow deadlineEntry = null ; DateTableRow timestampEntry = null ; private OrgNode node ; private OnDatesModifiedListener mListener ; public interface OnDatesModifiedListener { public void onDatesModified ( ) ; } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; try { mListener = ( OnDatesModifiedListener ) activity ; } catch ( ClassCastException e ) { throw new ClassCastException ( activity . toString ( ) + \" must implement OnDatesModifiedListener\" ) ; } } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { super . onCreateView ( inflater , container , savedInstanceState ) ; setHasOptionsMenu ( true ) ; this . datesView = new TableLayout ( getActivity ( ) ) ; return datesView ; } @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; EditActivity editActivity = ( EditActivity ) getActivity ( ) ; this . node = editActivity . getOrgNode ( ) ; if ( savedInstanceState != null ) restoreInstanceState ( savedInstanceState ) ; else setupDates ( ) ; setModifable ( editActivity . isPayloadEditable ( ) ) ; editActivity . invalidateOptionsMenu ( ) ; } public void setupDates ( ) { removeDateEntries ( ) ; OrgNodePayload payload = this . node . getOrgNodePayload ( ) ; payload . getCleanedPayload ( ) ; addDateScheduled ( payload . getScheduled ( ) ) ; addDateDeadline ( payload . getDeadline ( ) ) ; addDateTimestamp ( payload . getTimestamp ( ) ) ; } @ Override public void onSaveInstanceState ( Bundle outState ) { super . onSaveInstanceState ( outState ) ; outState . putString ( DATES_SCHEDULED , getScheduled ( ) ) ; outState . putString ( DATES_DEADLINE , getDeadline ( ) ) ; outState . putString ( DATES_TIMESTAMP , getTimestamp ( ) ) ; } public void restoreInstanceState ( Bundle savedInstanceState ) { if ( savedInstanceState != null ) { String scheduled = savedInstanceState . getString ( DATES_SCHEDULED ) ; if ( scheduled != null ) addDateScheduled ( scheduled ) ; String deadline = savedInstanceState . getString ( DATES_DEADLINE ) ; if ( deadline != null ) addDateDeadline ( deadline ) ; String timestamp = savedInstanceState . getString ( DATES_TIMESTAMP ) ; if ( timestamp != null ) addDateTimestamp ( timestamp ) ; } } private void addDateTimestamp ( String date ) { if ( date == null || TextUtils . isEmpty ( date ) == false ) this . timestampEntry = getDateTableRow ( date , OrgNodeTimeDate . TYPE . Timestamp ) ; } private void addDateScheduled ( String date ) { if ( date == null || TextUtils . isEmpty ( date ) == false ) this . scheduledEntry = getDateTableRow ( date , OrgNodeTimeDate . TYPE . Scheduled ) ; } private void addDateDeadline ( String date ) { if ( date == null || TextUtils . isEmpty ( date ) == false ) this . deadlineEntry = getDateTableRow ( date , OrgNodeTimeDate . TYPE . Deadline ) ; } private DateTableRow getDateTableRow ( String date , OrgNodeTimeDate . TYPE type ) { DateTableRow dateEntry = new DateTableRow ( getActivity ( ) ) ; OrgNodeTimeDate timeDate = new OrgNodeTimeDate ( type ) ; timeDate . parseDate ( date ) ; dateEntry . init ( this , datesView , timeDate ) ; dateEntry . setDateTableRowListener ( new DateTableRowListener ( ) { @ Override public void onDateTableRowModified ( OrgNodeTimeDate . TYPE type ) { announceDateModified ( type ) ; } } ) ; return dateEntry ; } private void removeDateEntries ( ) { if ( this . scheduledEntry != null ) { datesView . removeView ( scheduledEntry ) ; scheduledEntry = null ; } if ( this . deadlineEntry != null ) { datesView . removeView ( deadlineEntry ) ; deadlineEntry = null ; } if ( this . timestampEntry != null ) { datesView . removeView ( timestampEntry ) ; timestampEntry = null ; } } public void setModifable ( boolean enabled ) { if ( this . scheduledEntry != null ) this . scheduledEntry . setModifiable ( enabled ) ; if ( this . timestampEntry != null ) this . timestampEntry . setModifiable ( enabled ) ; if ( this . deadlineEntry != null ) this . deadlineEntry . setModifiable ( enabled ) ; this . isModifiable = enabled ; } private void announceDateModified ( OrgNodeTimeDate . TYPE type ) { OrgNodePayload payload = this . node . getOrgNodePayload ( ) ; switch ( type ) { case Scheduled : payload . insertOrReplaceDate ( type , getScheduled ( ) ) ; break ; case Deadline : payload . insertOrReplaceDate ( type , getDeadline ( ) ) ; break ; case Timestamp : payload . insertOrReplaceDate ( type ,", "gt": "getTimestamp ( ) ) ;", "prediction": "getTimestamp ( ) ) ;\n", "label": 0}
{"id": 16190, "input": "<s> package org . apache . lucene . search . highlight ; import java . io . IOException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . apache . lucene . analysis . CachingTokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . memory . MemoryIndex ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . util . StringHelper ; public class QueryScorer implements Scorer { private float totalScore ; private Set foundTerms ; private Map fieldWeightedSpanTerms ; private float maxTermWeight ; private int position = - 1 ; private String defaultField ; private TermAttribute termAtt ; private PositionIncrementAttribute posIncAtt ; private boolean expandMultiTermQuery = true ; private Query query ; private String field ; private IndexReader reader ; private boolean skipInitExtractor ; private boolean wrapToCaching = true ; public QueryScorer ( Query query ) { init ( query , null , null , true ) ; } public QueryScorer ( Query query , String field ) { init ( query , field , null , true ) ; } public QueryScorer ( Query query , IndexReader reader , String field ) { init ( query , field , reader , true ) ; } public QueryScorer ( Query query , IndexReader reader , String field , String defaultField ) { this . defaultField = StringHelper . intern ( defaultField ) ; init ( query , field , reader , true ) ; } public QueryScorer ( Query query , String field , String defaultField ) { this . defaultField = StringHelper . intern ( defaultField ) ; init ( query , field , null , true ) ; } public QueryScorer ( WeightedSpanTerm [ ] weightedTerms ) { this . fieldWeightedSpanTerms = new HashMap ( weightedTerms . length ) ; for ( int i = 0 ; i < weightedTerms . length ; i ++ ) { WeightedSpanTerm existingTerm = ( WeightedSpanTerm ) fieldWeightedSpanTerms . get ( weightedTerms [ i ] . term ) ; if ( ( existingTerm == null ) || ( existingTerm . weight < weightedTerms [ i ] . weight ) ) { fieldWeightedSpanTerms . put ( weightedTerms [ i ] . term , weightedTerms [ i ] ) ; maxTermWeight = Math . max ( maxTermWeight , weightedTerms [ i ] . getWeight ( ) ) ; } } skipInitExtractor = true ; } public float getFragmentScore ( ) { return totalScore ; } public float getMaxTermWeight ( ) { return maxTermWeight ; } public float getTokenScore ( ) { position += posIncAtt . getPositionIncrement ( ) ; String termText = termAtt . term ( ) ; WeightedSpanTerm weightedSpanTerm ; if ( ( weightedSpanTerm = ( WeightedSpanTerm ) fieldWeightedSpanTerms . get ( termText ) ) == null ) { return 0 ; } if ( weightedSpanTerm . positionSensitive && ! weightedSpanTerm . checkPosition ( position ) ) { return 0 ; } float score = weightedSpanTerm . getWeight ( ) ; if ( ! foundTerms . contains ( termText ) ) { totalScore += score ; foundTerms . add ( termText ) ; } return score ; } public TokenStream init ( TokenStream tokenStream ) throws IOException { position = - 1 ; termAtt = ( TermAttribute ) tokenStream . addAttribute ( TermAttribute . class ) ; posIncAtt = ( PositionIncrementAttribute ) tokenStream . addAttribute ( PositionIncrementAttribute . class ) ; if ( ! skipInitExtractor ) { if ( fieldWeightedSpanTerms != null ) { fieldWeightedSpanTerms . clear ( ) ; } return initExtractor ( tokenStream ) ; } return null ; } public WeightedSpanTerm getWeightedSpanTerm ( String token ) { return ( WeightedSpanTerm ) fieldWeightedSpanTerms . get ( token ) ; } private void init ( Query query , String field , IndexReader reader , boolean expandMultiTermQuery ) { this . reader = reader ; this . expandMultiTermQuery = expandMultiTermQuery ; this . query = query ;", "gt": "this . field = field ;", "prediction": "this . field = field ;\n", "label": 1}
{"id": 8086, "input": "<s> package org . parboiled . trees ; import java . util . List ; public interface GraphNode <", "gt": "T extends GraphNode < T > >", "prediction": "T >\n", "label": 0}
{"id": 16193, "input": "<s> package org . apache . lucene . swing . models ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import javax . swing . AbstractListModel ; public class BaseListModel extends AbstractListModel { private List data = new ArrayList ( ) ; public BaseListModel ( Iterator iterator ) { while ( iterator . hasNext ( ) ) { data . add ( iterator . next ( ) ) ; } } public int getSize ( ) {", "gt": "return data . size ( ) ;", "prediction": "return data . size ( ) ;\n", "label": 1}
{"id": 7591, "input": "<s> package com . midtro . platform . modules . assets ; public enum MountType { FILE ( \"file\" ) , CACHE ( \"cache\" ) , URL ( \"url\" ) ; private final String key ; private", "gt": "MountType ( String key )", "prediction": "final String path ;\n", "label": 0}
{"id": 16197, "input": "<s> package org . nuxeo . ecm . directory . api . ui ; import java . io . Serializable ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . directory . DirectoryException ; import org . nuxeo . ecm . directory . api . DirectoryService ;", "gt": "public interface DirectoryUIDeleteConstraint extends Serializable", "prediction": "import org . nuxeo . runtime . api . Framework ;\n", "label": 1}
{"id": 1753, "input": "<s> package org . gk . engine . client . event . attrib ; import org . gk . ui . client . com . form . gkFormPanel ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . form . Field ; public class ClearAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof gkFormPanel ) { ( ( gkFormPanel ) com ) . clear ( ) ; } else if ( com instanceof Field ) { Field field = ( Field ) com ; field . clear ( ) ; field .", "gt": "fireEvent ( Events . Change ) ;", "prediction": "setValue ( value ) ;\n", "label": 0}
{"id": 16198, "input": "<s> package org . restlet ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . CacheDirective ; import org . restlet . data . MediaType ; import org . restlet . data . RecipientInfo ; import org . restlet . data . Warning ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; public abstract class Message { private volatile ConcurrentMap < String , Object > attributes ; private volatile List < CacheDirective > cacheDirectives ; private volatile Date date ; private volatile Representation entity ; private volatile String entityText ; private volatile Uniform onError ; private volatile Uniform onSent ; private volatile List < RecipientInfo > recipientsInfo ; private volatile List < Warning > warnings ; public Message ( ) { this ( ( Representation ) null ) ; } public Message ( Representation entity ) { this . attributes = null ; this . cacheDirectives = null ; this . date = null ; this . entity = entity ; this . entityText = null ; this . onSent = null ; this . recipientsInfo = null ; this . warnings = null ; } public ConcurrentMap < String , Object > getAttributes ( ) { ConcurrentMap < String , Object > r = this . attributes ; if ( r == null ) { synchronized ( this ) { r = this . attributes ; if ( r == null ) { this . attributes = r = new ConcurrentHashMap < String , Object > ( ) ; } } } return this . attributes ; } public List < CacheDirective > getCacheDirectives ( ) { List < CacheDirective > r = this . cacheDirectives ; if ( r == null ) { synchronized ( this ) { r = this . cacheDirectives ; if ( r == null ) { this . cacheDirectives = r = new CopyOnWriteArrayList < CacheDirective > ( ) ; } } } return r ; } public Date getDate ( ) { return date ; } public Representation getEntity ( ) { return this . entity ; } public String getEntityAsText ( ) { if ( this . entityText == null ) { try { this . entityText = ( getEntity ( ) == null ) ? null : getEntity ( ) . getText ( ) ; } catch ( java . io . IOException e ) { Context . getCurrentLogger ( ) . log ( java . util . logging . Level . FINE , \"Unable to get the entity text.\" , e ) ; } } return this . entityText ; } public Uniform getOnError ( ) { return onError ; } public Uniform getOnSent ( ) { return onSent ; } public List < RecipientInfo > getRecipientsInfo ( ) { List < RecipientInfo > r = this . recipientsInfo ; if ( r == null ) { synchronized ( this ) { r = this . recipientsInfo ; if ( r == null ) { this . recipientsInfo = r = new CopyOnWriteArrayList < RecipientInfo > ( ) ; } } } return r ; } public List < Warning > getWarnings ( ) { List < Warning > r = this . warnings ; if ( r == null ) { synchronized ( this ) { r = this . warnings ; if ( r == null ) { this . warnings = r = new CopyOnWriteArrayList < Warning > ( ) ; } } } return r ; } public abstract boolean isConfidential ( ) ; public boolean isEntityAvailable ( ) { boolean result = ( getEntity ( ) != null ) && getEntity ( ) . isAvailable ( ) ; return result ; } public void release ( ) { if ( getEntity ( ) != null ) { getEntity ( ) . release ( ) ; } } public void setAttributes ( Map < String , Object > attributes ) { synchronized ( getAttributes ( ) ) { if ( attributes != getAttributes ( ) ) { getAttributes ( ) . clear ( ) ; if ( attributes != null ) { getAttributes ( ) . putAll ( attributes ) ; } } } } public void setCacheDirectives (", "gt": "List < CacheDirective > cacheDirectives )", "prediction": "List < CacheDirective > cacheDirectives )\n", "label": 1}
{"id": 278, "input": "<s> package org . ofbiz . ebaystore ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import net . sf . json . JSONObject ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . event . EventHandlerException ; import com . ebay . sdk . ApiContext ; import com . ebay . sdk . ApiException ; import com . ebay . sdk . SdkException ; import com . ebay . sdk . SdkSoapException ; import com . ebay . sdk . call . GetStoreOptionsCall ; import com . ebay . soap . eBLBaseComponents . CategoryType ; import com . ebay . soap . eBLBaseComponents . GetStoreOptionsRequestType ; import com . ebay . soap . eBLBaseComponents . GetStoreOptionsResponseType ; import com . ebay . soap . eBLBaseComponents . StoreColorSchemeType ; import com . ebay . soap . eBLBaseComponents . StoreColorType ; import com . ebay . soap . eBLBaseComponents . StoreFontType ; import com . ebay . soap . eBLBaseComponents . StoreThemeArrayType ; import com . ebay . soap . eBLBaseComponents . StoreThemeType ; import com . ebay . soap . eBLBaseComponents . StoreCustomCategoryType ; public class EbayStoreOptions { private static final String module = EbayStoreOptions . class . getName ( ) ; public static String retrieveThemeColorSchemeByThemeId ( HttpServletRequest request , HttpServletResponse response ) { Locale locale = UtilHttp . getLocale ( request ) ; HttpSession session = request . getSession ( true ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; GetStoreOptionsRequestType req = null ; GetStoreOptionsResponseType resp = null ; StoreThemeArrayType returnedBasicThemeArray = null ; try { Map < String , Object > paramMap = UtilHttp . getCombinedMap ( request ) ; if ( paramMap . get ( \"productStoreId\" ) != null ) { String themeId = ( String ) paramMap . get ( \"themeId\" ) ; GetStoreOptionsCall call = new GetStoreOptionsCall ( EbayStoreHelper . getApiContext ( ( String ) paramMap . get ( \"productStoreId\" ) , locale , delegator ) ) ; req = new GetStoreOptionsRequestType ( ) ; resp = ( GetStoreOptionsResponseType ) call . execute ( req ) ; if ( resp != null && \"SUCCESS\" . equals ( resp . getAck ( ) . toString ( ) ) ) { returnedBasicThemeArray = resp . getBasicThemeArray ( ) ; StoreThemeType [ ] storeBasicTheme = returnedBasicThemeArray . getTheme ( ) ; int i = 0 ; String colorSchemeId = themeId . substring ( themeId . indexOf ( \"-\" ) + 1 ) ; themeId = themeId . substring ( 0 , themeId . indexOf ( \"-\" ) ) ; Map < String , Object > storeColorSchemeMap = FastMap . newInstance ( ) ; while ( i < storeBasicTheme . length ) { StoreThemeType storeThemeType = storeBasicTheme [ i ] ; if ( themeId . equals ( storeThemeType . getThemeID ( ) . toString ( ) ) ) { StoreColorSchemeType colorSchemeType = storeThemeType . getColorScheme ( ) ; if ( colorSchemeType != null ) { if ( colorSchemeId . equals ( colorSchemeType . getColorSchemeID ( ) . toString ( ) ) ) { StoreColorType storeColor = colorSchemeType . getColor ( ) ; storeColorSchemeMap . put ( \"storeColorAccent\" , storeColor . getAccent ( ) ) ; storeColorSchemeMap . put ( \"storeColorPrimary\" , storeColor . getPrimary ( ) ) ; storeColorSchemeMap . put ( \"storeColorSecondary\" , storeColor . getSecondary ( ) ) ; StoreFontType storeFontType = colorSchemeType . getFont ( ) ; storeColorSchemeMap . put ( \"storeFontTypeNameFaceColor\" , storeFontType . getNameColor ( ) ) ; storeColorSchemeMap . put ( \"storeFontTypeFontFaceValue\" , storeFontType . getNameFace ( ) . value ( ) ) ; storeColorSchemeMap . put ( \"storeFontTypeSizeFaceValue\" , storeFontType . getNameSize ( ) . value ( ) ) ; storeColorSchemeMap . put ( \"storeFontTypeTitleColor\" , storeFontType . getTitleColor ( ) ) ; storeColorSchemeMap . put ( \"storeFontTypeFontTitleValue\" , storeFontType . getTitleFace ( ) . value ( ) ) ; storeColorSchemeMap . put ( \"storeFontSizeTitleValue\" , storeFontType . getTitleSize ( ) . value ( ) ) ; storeColorSchemeMap .", "gt": "put ( \"storeFontTypeDescColor\" , storeFontType . getDescColor ( ) ) ;", "prediction": "put ( \"storeFontSizeSecondary\" , storeFontType . getSecondary ( ) ) ;\n", "label": 0}
{"id": 16199, "input": "<s> package org . eclipse . jface . tests . labelProviders ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . tests . viewers . TestElement ; import org . eclipse . jface . tests . viewers . ViewerTestCase ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . widgets . Control ; public abstract class CompositeLabelProviderTest extends ViewerTestCase { class LabelTableContentProvider implements IStructuredContentProvider { public Object [ ] getElements ( Object inputElement ) { return fRootElement . getChildren ( ) ; } public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } } Color background ; Color foreground ; Font font ; public CompositeLabelProviderTest ( String name ) { super ( name ) ; } void initializeColors ( Control parent ) { background = parent . getDisplay", "gt": "( ) . getSystemColor ( SWT . COLOR_RED ) ;", "prediction": "( ) . getSystemColor ( SWT . COLOR_BACKGROUND ) ;\n", "label": 1}
{"id": 6745, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . util . Collection ; import java . util . ArrayList ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . ReferenceType ; import com . sun . mirror . util . DeclarationVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; @ SuppressWarnings ( \"deprecation\" ) public class TypeParameterDeclarationImpl extends DeclarationImpl implements TypeParameterDeclaration { protected TypeSymbol sym ; TypeParameterDeclarationImpl ( AptEnv env , TypeSymbol sym ) { super ( env , sym ) ; this . sym = sym ; } public String toString ( ) { return toString ( env , ( Type . TypeVar ) sym . type ) ; } public Collection < ReferenceType > getBounds ( ) { ArrayList < ReferenceType > res = new ArrayList < ReferenceType > ( ) ; for ( Type t : env . jctypes . getBounds ( ( Type . TypeVar ) sym . type ) ) { res . add ( ( ReferenceType ) env . typeMaker . getType ( t ) ) ; } return res ; } public Declaration getOwner ( ) { Symbol owner = sym . owner ; return ( ( owner . kind & Kinds . TYP ) != 0 ) ? env . declMaker . getTypeDeclaration ( ( ClassSymbol ) owner ) : env . declMaker . getExecutableDeclaration ( ( MethodSymbol ) owner ) ; } public void accept ( DeclarationVisitor v ) { v . visitTypeParameterDeclaration ( this ) ; } static String toString ( AptEnv env , Type . TypeVar tv ) { StringBuilder s = new StringBuilder ( ) ; s . append ( tv ) ; boolean first = true ; for ( Type bound : getExtendsBounds ( env , tv ) ) { s . append ( first ? \" extends \" : \" & \" ) ; s . append ( env . typeMaker . typeToString ( bound ) ) ; first = false ; } return s . toString ( ) ; } private static Iterable < Type > getExtendsBounds", "gt": "( AptEnv env , Type . TypeVar tv )", "prediction": "( Symbol owner )\n", "label": 0}
{"id": 16200, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . model ; public class BuildrTask { private String name ; private String description ; public BuildrTask ( String name , String description ) { this . name = name ; this . description = description ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public", "gt": "void setDescription ( String description )", "prediction": "void setDescription ( String description )\n", "label": 1}
{"id": 1524, "input": "<s> package org . ofbiz . content . content ; import org . ofbiz . base . util . StringUtil ; public interface ContentWrapper {", "gt": "public StringUtil . StringWrapper get ( String contentTypeId ) ;", "prediction": "public String getContent ( ) ;\n", "label": 0}
{"id": 16204, "input": "<s> package tk . blackwolf12333 . grieflog . commands ; import java . util . Arrays ; import java . util . List ; import org . bukkit . ChatColor ; import org . bukkit . command . CommandSender ; import tk . blackwolf12333 . grieflog . utils . config . ConfigHandler ; public class GLogBp { String [ ] helpTxt = { ChatColor . RED + \"++++++++++ [GriefLog-BlockProtection] +++++++++++++\" , \"Commands:\" , ChatColor . GOLD + \"/glog bp help\" + ChatColor . DARK_GRAY + \"Gives this help text.\" , ChatColor . GOLD + \"/glog bp listfriends: \" + ChatColor . DARK_GRAY + \"This lists the friends on your friendslist.\" , ChatColor . GOLD + \"/glog bp addfriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This adds a friend to your friendslist so that he can break your blocks.\" , ChatColor . GOLD + \"/glog bp removefriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This removes a friend from your friendslist.\" } ; public boolean onCommand ( CommandSender sender , String cmdLabel , String [ ] args ) { if ( args [ 1 ] . equalsIgnoreCase ( \"listfriends\" ) ) { List < String > friends = ConfigHandler . getFriends ( sender . getName ( ) ) ; sender . sendMessage ( ChatColor . AQUA + \"This are your current friends: \" ) ; for ( int i = 0 ; i < friends . size ( ) ; i ++ ) { sender . sendMessage ( ChatColor . AQUA + friends . get ( i ) ) ; } return true ; } if ( args [ 1 ] . equalsIgnoreCase ( \"addfriend\" ) ) { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . size ( ) == 0 ) { String [ ] list = new String [ ] { args [ 2 ] } ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , Arrays . asList ( list ) ) ; } else { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . contains ( args [ 2 ] ) ) { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Player \" + args [ 2 ] + \" is allready on your friends list.\" ) ; } else { List < String > friends = ConfigHandler . friendsConfig . getStringList ( sender . getName ( ) ) ; friends . add ( args [ 0 ] ) ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , friends ) ; sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Friend \" + args [ 2 ] + \" added to friends list.\" ) ; } } ConfigHandler . saveFriendsConfig ( ) ; return true ; } if ( args [ 1 ] . equalsIgnoreCase ( \"removefriend\" ) ) { if ( ConfigHandler . getFriends ( sender . getName ( ) ) == null ) { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] You don't have any friends added yet.\" ) ; return true ; } else { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . contains ( args [ 2 ] ) ) { List < String > friends = ConfigHandler . friendsConfig . getStringList ( sender . getName ( ) ) ; friends . remove ( args [ 2 ] ) ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , friends ) ; ConfigHandler . saveFriendsConfig ( ) ; sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Player \" + args [ 2 ] + \" is removed from your friends list.\" ) ; return true ; } else { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] \" + args [ 2", "gt": "] + \" is not on your friends list.\" ) ;", "prediction": "] + \" is removed from friends list.\" ) ;\n", "label": 1}
{"id": 2123, "input": "<s> package org . remast . baralga . gui . panels ; import info . clearthought . layout . TableLayout ; import java . beans . PropertyChangeEvent ; import javax . swing . BorderFactory ; import javax . swing . JLabel ; import javax . swing . JPanel ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . model . ProjectActivity ; import org . remast . swing . JTextEditor ; import org . remast . swing . util . GuiConstants ; @ SuppressWarnings ( \"serial\" ) public class DescriptionPanelEntry extends JPanel { private ProjectActivity activity ; private JTextEditor editor ; private JLabel activityLabel ; private PresentationModel model ; public DescriptionPanelEntry ( final ProjectActivity activity , final PresentationModel model ) { this . activity = activity ; this . model = model ; initialize ( ) ; } private void initialize ( ) { activityLabel = new JLabel ( String . valueOf ( activity ) ) ; int border = 5 ; final double [ ] [ ] size = { { border , TableLayout . FILL , border } , { 12 , TableLayout . PREFERRED", "gt": ", border , TableLayout . FILL , border }", "prediction": "_WIDTH }\n", "label": 0}
{"id": 16205, "input": "<s> package knowevo . myvizster . util ; import java . awt . event . ActionEvent ; import javax . swing . AbstractAction ; import javax . swing . AbstractButton ; import knowevo . myvizster . Vizster ; public class ToggleLinkHighlighting extends AbstractAction { private Vizster vizster ; public", "gt": "ToggleLinkHighlighting ( Vizster vizster )", "prediction": "ToggleLinkHighlighting ( Vizster vizster )\n", "label": 1}
{"id": 9134, "input": "<s> public class DefAssignBoolean_6 { public static void main ( String [ ] args ) { boolean b3 , b4 ; boolean r = false ; boolean t = true ; if ( ( r || ( b4 = r ) ) != ( r || ( b4 =", "gt": "t ) ) ) r = b4 ;", "prediction": "t ) ) )\n", "label": 0}
{"id": 16206, "input": "<s> package org . eclipse . swt . graphics ; import java . io . * ; import org . eclipse . swt . * ; import org . eclipse . swt . widgets . Control ; public class GC extends Resource { private final GCDelegate delegate ; private boolean advanced ; private int antialias ; private int textAntialias ; public GC ( Drawable drawable ) { this ( drawable , SWT . NONE ) ; } public GC ( Drawable drawable , int style ) { super ( determineDevice ( drawable ) ) ; if ( drawable == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } delegate = determineDelegate ( drawable ) ; antialias = SWT . DEFAULT ; textAntialias = SWT . DEFAULT ; } public void setFont ( Font font ) { checkDisposed ( ) ; if ( font != null && font . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } Font newFont = font != null ? font : delegate . getDefaultFont ( ) ; delegate . setFont ( newFont ) ; } public Font getFont ( ) { checkDisposed ( ) ; return delegate . getFont ( ) ; } public int getCharWidth ( char ch ) { checkDisposed ( ) ; return delegate . stringExtent ( Character . toString ( ch ) ) . x ; } public Point stringExtent ( String string ) { checkDisposed ( ) ; if ( string == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } return delegate . stringExtent ( string ) ; } public Point textExtent ( String string ) { checkDisposed ( ) ; if ( string == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } return delegate . textExtent ( string , 0 ) ; } public FontMetrics getFontMetrics ( ) { checkDisposed ( ) ; return new FontMetrics ( delegate . getFont ( ) ) ; } public void setBackground ( Color color ) { checkDisposed ( ) ; if ( color == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( color . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setBackground ( color ) ; } public Color getBackground ( ) { checkDisposed ( ) ; return delegate . getBackground ( ) ; } public void setForeground ( Color color ) { checkDisposed ( ) ; if ( color == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( color . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setForeground ( color ) ; } public Color getForeground ( ) { checkDisposed ( ) ; return delegate . getForeground ( ) ; } public Rectangle getClipping ( ) { checkDisposed ( ) ; return delegate . getClipping ( ) ; } public void setAlpha ( int alpha ) { checkDisposed ( ) ; if ( alpha >= 0 && alpha <= 255 && delegate . getAlpha ( ) != alpha ) { delegate . setAlpha ( alpha ) ; advanced = true ; } } public int getAlpha ( ) { checkDisposed ( ) ; return delegate . getAlpha ( ) ; } public void setLineWidth ( int lineWidth ) { checkDisposed ( ) ; if ( delegate . getLineWidth ( ) != lineWidth ) { delegate . setLineWidth ( lineWidth ) ; } } public int getLineWidth ( ) { checkDisposed ( ) ; return delegate . getLineWidth ( ) ; } public void setLineCap ( int lineCap ) { checkDisposed ( ) ; if ( delegate . getLineCap ( ) != lineCap ) { switch ( lineCap ) { case SWT . CAP_ROUND : case SWT . CAP_FLAT : case SWT . CAP_SQUARE : break ; default : SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setLineCap ( lineCap ) ; } } public int getLineCap ( ) { checkDisposed ( ) ; return delegate . getLineCap ( ) ; } public void setLineJoin ( int lineJoin ) { checkDisposed ( ) ; if ( delegate . getLineJoin ( ) != lineJoin ) { switch ( lineJoin ) { case SWT . JOIN_MITER : case SWT . JOIN_ROUND : case SWT . JOIN_BEVEL : break ; default : SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setLineJoin ( lineJoin ) ; } } public int getLineJoin ( ) { checkDisposed ( ) ; return delegate . getLineJoin ( ) ; } public void setLineAttributes ( LineAttributes attributes ) { checkDisposed ( ) ; if ( attributes == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } setLineWidth ( ( int ) attributes . width ) ; setLineCap ( attributes . cap ) ; setLineJoin ( attributes . join ) ; advanced = true ; } public LineAttributes getLineAttributes ( ) { checkDisposed ( ) ; int lineWidth = delegate . getLineWidth ( ) ; int lineCap = delegate . getLineCap ( ) ; int lineJoin = delegate . getLineJoin ( ) ; return new LineAttributes ( lineWidth", "gt": ", lineCap , lineJoin ) ;", "prediction": ", lineCap , lineJoin ) ;\n", "label": 1}
{"id": 8801, "input": "<s> import java . io . * ; import java . net . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . tools . * ; import javax . tools . JavaCompiler . CompilationTask ; public class T7031108 extends JavacTestingAbstractProcessor { public static void main ( String ... args ) throws Exception { new T7031108 ( ) . run ( ) ; } static final JavaSource pC = new JavaSource ( \"p/C.java\" , \"package p;\\n\" + \"class C {\\n\" + \"    void m() {\\n\" + \"        new Runnable() {\\n\" + \"            public void run() {\\n\" + \"                new Runnable() {\\n\" + \"                    public void run() { }\\n\" + \"                };\\n\" + \"            }\\n\" + \"        };\\n\" + \"    }\\n\" + \"}\" ) ; static final JavaSource dummy = new JavaSource ( \"Dummy.java\" , \"class Dummy { }\" ) ; void run ( ) throws Exception { JavaCompiler comp = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = comp . getStandardFileManager ( null , null , null ) ; File cwd = new File ( \".\" ) ; fm . setLocation ( StandardLocation . CLASS_OUTPUT , Arrays . asList ( cwd ) ) ; compile ( comp , fm , null , null , pC ) ; fm . setLocation ( StandardLocation . ANNOTATION_PROCESSOR_PATH , fm . getLocation ( StandardLocation . CLASS_PATH ) ) ; fm . setLocation ( StandardLocation . CLASS_PATH , Arrays . asList ( cwd ) ) ; compile ( comp , fm , null , getClass ( ) . getName ( ) , dummy ) ; File pC_class = new File ( new File ( \"p\" ) , \"C.class\" ) ; pC_class . delete ( ) ; DiagnosticCollector < JavaFileObject > dc = new DiagnosticCollector < JavaFileObject > ( ) ; compile ( comp , fm , dc , getClass ( ) . getName ( ) , dummy ) ; List < Diagnostic < ? extends JavaFileObject > > diags = dc . getDiagnostics ( ) ; System . err . println ( diags ) ; switch ( diags . size ( ) ) { case 0 : throw new Exception ( \"no diagnostics received\" ) ; case 1 : String code =", "gt": "diags . get ( 0 ) . getCode ( ) ;", "prediction": "( String ) diags . get ( 0 ) ;\n", "label": 0}
{"id": 16208, "input": "<s> package org . nuxeo . ecm . automation . core . test ; import static org . junit . Assert . assertEquals ; import static org . nuxeo . ecm . directory . localconfiguration . DirectoryConfigurationConstants . DIRECTORY_CONFIGURATION_FIELD ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . lang . StringUtils ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . OperationParameters ; import org . nuxeo . ecm . automation . core . operations . FetchContextDocument ; import org . nuxeo . ecm . automation . core . operations . services . GetDirectoryEntries ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . PathRef ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; import org . nuxeo . ecm . core . api . localconfiguration . LocalConfigurationService ; import org . nuxeo . ecm . core . test . CoreFeature ; import org . nuxeo . ecm . core . test . DefaultRepositoryInit ; import org . nuxeo . ecm . core . test . annotations . BackendType ; import org . nuxeo . ecm . core . test . annotations . Granularity ; import org . nuxeo . ecm . core . test . annotations . RepositoryConfig ; import org . nuxeo . ecm . directory . api . DirectoryService ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import org . nuxeo . runtime . test . runner . LocalDeploy ; import com . google . inject . Inject ; @ RunWith ( FeaturesRunner . class ) @ Features ( CoreFeature . class ) @ RepositoryConfig ( repositoryName = \"default\" , type = BackendType . H2 , init = DefaultRepositoryInit . class , user = \"Administrator\" ,", "gt": "cleanup = Granularity . METHOD ) @ Deploy (", "prediction": "required = false ) public class DefaultRepositoryConfig\n", "label": 1}
{"id": 4653, "input": "<s> package com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_0 ; public class SCM { private String connection ; private String revision ; public String getConnection ( ) { return connection ; } public void setConnection ( String connection ) { this . connection = connection ; } public String getRevision ( ) { return revision ; } public void setRevision ( String revision ) { this . revision = revision ; } @ Override public String toString ( ) { return \"SCM", "gt": "[connection=\" + connection + \", revision=\" + revision + \"]\" ;", "prediction": ": \" + connection ;\n", "label": 0}
{"id": 16219, "input": "<s> package org . nuxeo . ecm . automation . features ; import org . nuxeo . ecm . automation . core . scripting . Functions ; import org . osgi . framework . BundleActivator ; import org . osgi . framework . BundleContext ; public class Activator implements BundleActivator { @ Override", "gt": "public void start ( BundleContext context ) throws Exception", "prediction": "public void activate ( BundleContext context )\n", "label": 1}
{"id": 4641, "input": "<s> package com . atlassian . crowd . integration . exception ; @ SuppressWarnings ( \"serial\" ) public class InvalidPrincipalException extends org . apache . axis . AxisFault implements java . io . Serializable { public InvalidPrincipalException ( ) { } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof InvalidPrincipalException ) ) return false ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( InvalidPrincipalException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://exception.integration.crowd.atlassian.com\" , \"InvalidPrincipalException\" ) ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class < ? > _javaType ,", "gt": "javax . xml . namespace . QName _xmlType )", "prediction": "javax . xml . namespace . QName _xmlType )\n", "label": 0}
{"id": 16221, "input": "<s> package com . corundumstudio . socketio . messages ; import java . io . IOException ; import org . jboss . netty . channel . Channel ; import com . corundumstudio . socketio . MessageHandler ; public abstract class BaseMessage { public abstract void", "gt": "handleMessage ( MessageHandler handler , Channel channel ) throws IOException ;", "prediction": "handleMessage ( Message message ) ;\n", "label": 1}
{"id": 4256, "input": "<s> package me . moocar . logbackgelf ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . slf4j . MDC ; import java . net . URL ; import java . util . Random ; public class IntegrationTest { private static final String longMessage = createLongMessage ( ) ; private static String createLongMessage ( ) { Random rand = new Random ( ) ; StringBuilder str = new StringBuilder ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { char theChar = ( char ) ( rand . nextInt ( 30 ) + 65 ) ; for ( int j = 0 ; j < 80 ; j ++ ) { str . append ( theChar ) ; } str . append ( '\\n' ) ; } return str . toString ( ) ; } @ Test public void test ( ) { Logger logger = LoggerFactory . getLogger (", "gt": "this . getClass ( ) ) ;", "prediction": "IntegrationTest . class ) ;\n", "label": 0}
{"id": 16229, "input": "<s> package org . eclipse . rap . rwt . internal . protocol ; import java . util . Map ; public interface IClientObject { void create ( String type ) ; void set ( String name , int value ) ; void set ( String name , double value ) ; void set ( String name , boolean value ) ; void set ( String name , String value ) ; void set ( String name , Object value ) ; void listen ( String eventType , boolean listen ) ; void call ( String method , Map < String , Object > properties ) ;", "gt": "void destroy ( ) ;", "prediction": "}\n", "label": 1}
{"id": 3260, "input": "<s> package ar . com . fdvs . dj . test . crosstab ; import java . awt . Color ; import java . util . Date ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJCrosstabColumn ; import ar . com . fdvs . dj . domain . DJCrosstabRow ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . CrosstabBuilder ; import ar . com . fdvs . dj . domain . builders . CrosstabColumnBuilder ; import ar . com . fdvs . dj . domain . builders . CrosstabRowBuilder ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Page ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . test . BaseDjReportTest ; import ar . com . fdvs . dj . test . TestRepositoryProducts ; import ar . com . fdvs . dj . util . SortUtils ; public class CrosstabReportTest3 extends BaseDjReportTest { private Style totalHeader ; private Style colAndRowHeaderStyle ; private Style mainHeaderStyle ; private Style totalStyle ; private Style measureStyle ; public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 80 , true ) . addGroups ( 1 ) . setGroupLayout ( 1 , GroupLayout . DEFAULT_WITH_HEADER ) . addFooterVariable ( 1 , 7 , DJCalculation . SUM , null ) . addFooterVariable ( 1 , 6 , DJCalculation . SUM , null ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setPageSizeAndOrientation ( Page . Page_A4_Landscape ( ) ) . setPrintColumnNames ( false ) . setUseFullPageWidth ( true ) ; initStyles ( ) ; DJCrosstab djcross = createCrosstab ( ) ; drb . addHeaderCrosstab ( 1 , djcross ) ; DynamicReport dr = drb . build ( ) ; DJGroup g = ( DJGroup ) dr . getColumnsGroups ( ) . get ( 0 ) ; g . setHeaderHeight ( new Integer ( 40 ) ) ; params . put ( \"sr\" , SortUtils . sortCollection ( TestRepositoryProducts . getDummyCollection ( ) , djcross ) ) ; return dr ; } private DJCrosstab createCrosstab ( ) { CrosstabBuilder cb = new CrosstabBuilder ( ) ; cb . setHeight ( 100 ) . setWidth ( 500 ) . setHeaderStyle ( mainHeaderStyle ) . setDatasource ( \"sr\" , DJConstants . DATA_SOURCE_ORIGIN_PARAMETER , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) . setUseFullWidth ( true ) . setColorScheme ( 2 ) . setAutomaticTitle ( true )", "gt": ". setCellBorder ( Border . THIN ) ;", "prediction": ";\n", "label": 0}
{"id": 16230, "input": "<s> package org . restlet . example . book . restlet . ch08", "gt": ". gae . common ;", "prediction": ". sec3 . common ;\n", "label": 1}
{"id": 4598, "input": "<s> package org . ofbiz . content . openoffice ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import com . sun . star . beans . PropertyValue ; import com . sun . star . beans . XPropertySet ; import com . sun . star . bridge . XUnoUrlResolver ; import com . sun . star . container . XNameAccess ; import com . sun . star . frame . XComponentLoader ; import com . sun . star . frame . XStorable ; import com . sun . star . lang . XComponent ; import com . sun . star . lang . XMultiComponentFactory ; import com . sun . star . uno . UnoRuntime ; import com . sun . star . uno . XComponentContext ; import com . sun . star . uri . ExternalUriReferenceTranslator ; public class OpenOfficeWorker { public static final String module = OpenOfficeWorker . class . getName ( ) ; public static XMultiComponentFactory getRemoteServer ( String host , String port ) throws IOException , Exception { if ( UtilValidate . isEmpty ( host ) ) host = UtilProperties . getPropertyValue ( \"openoffice-uno\" , \"oo.host\" , \"localhost\" ) ; if ( UtilValidate . isEmpty ( port ) ) port = UtilProperties . getPropertyValue ( \"openoffice-uno\" , \"oo.port\" , \"8100\" ) ; XMultiComponentFactory xmulticomponentfactory = null ; XComponentContext xcomponentcontext = null ; Object objectUrlResolver = null ; XUnoUrlResolver xurlresolver = null ; Object objectInitial = null ; try { xcomponentcontext = com . sun . star . comp . helper . Bootstrap . createInitialComponentContext ( null ) ; xmulticomponentfactory = xcomponentcontext . getServiceManager ( ) ; objectUrlResolver = xmulticomponentfactory . createInstanceWithContext ( \"com.sun.star.bridge.UnoUrlResolver\" , xcomponentcontext ) ; xurlresolver = ( XUnoUrlResolver ) UnoRuntime . queryInterface ( XUnoUrlResolver . class , objectUrlResolver ) ; String url = \"uno:socket,host=\" + host + \",port=\" + port + \";urp;StarOffice.ServiceManager\" ; objectInitial = xurlresolver . resolve ( url ) ; xmulticomponentfactory = ( XMultiComponentFactory ) UnoRuntime . queryInterface ( XMultiComponentFactory . class , objectInitial ) ; } catch ( Exception e ) { String errMsg = \"Error connecting to OpenOffice with host [\" + host + \"] and port [\" + port + \"]: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; throw new IllegalArgumentException ( errMsg ) ; } return xmulticomponentfactory ; } public static String listFilterNamesEvent ( HttpServletRequest request , HttpServletResponse response ) { XMultiComponentFactory factory = null ; try { factory = getRemoteServer ( \"localhost\" , \"8100\" ) ; List filterList = getFilterNames ( factory ) ; request . setAttribute ( \"filterList\" , filterList ) ; } catch ( IOException e ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , e . getMessage ( ) ) ; return \"error\" ; } catch ( Exception e ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , e . getMessage ( ) ) ; return \"error\" ; } return \"success\" ; } public static List getFilterNames ( XMultiComponentFactory xmulticomponentfactory ) throws Exception { XPropertySet xPropertySet = ( XPropertySet ) UnoRuntime . queryInterface ( XPropertySet . class , xmulticomponentfactory ) ; Object oDefaultContext = xPropertySet", "gt": ". getPropertyValue ( \"DefaultContext\" ) ;", "prediction": ". getDefaultContext ( ) ;\n", "label": 0}
{"id": 16231, "input": "<s> package org . springframework . tenancy . web ; import java . io . IOException ; import java . util . List ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import org . springframework . tenancy . context . TenancyContext ; import org . springframework . tenancy . context . TenancyContextHolder ; import org . springframework . tenancy . core . Tenant ; import org . springframework . tenancy . provider . DefaultTenantProvider ; import org . springframework . tenancy . provider . TenantProvider ; import org . springframework . web . filter . GenericFilterBean ; public class TenancyContextIntegrationFilter extends GenericFilterBean { private List < TenantIdentificationStrategy > tenantIdentificationStrategyChain ; private TenantProvider tenantProvider = new DefaultTenantProvider ( ) ; @ Override public void doFilter ( ServletRequest req , ServletResponse res , FilterChain chain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) req ; TenancyContext contextBeforeChainExecution = determineTenancyContext ( request ) ; try { TenancyContextHolder . setContext ( contextBeforeChainExecution ) ; chain . doFilter ( req , res ) ; } finally {", "gt": "TenancyContextHolder . clearContext ( ) ;", "prediction": "TenancyContextHolder . clearContext ( ) ;\n", "label": 1}
{"id": 5371, "input": "<s> package api . requests ; public class DJ { private Number id ; private String name ; public Number getId ( ) { return this . id ; } public String getName ( ) { return this . name ; } @ Override public String toString ( ) { return \"DJ [getId=\" + getId ( ) + \", getName=\" + getName", "gt": "( ) + \"]\" ;", "prediction": "( ) + \"]\" ;\n", "label": 0}
{"id": 16235, "input": "<s> package org . restlet . example . firstResource ; public class Item { private String description ; private String name ; public Item ( String name ) { super ( ) ; setName ( name ) ; } public Item ( String name , String description ) { super ( ) ; setName ( name ) ; setDescription ( description ) ; } public String getDescription ( ) { return description ; } public String getName ( ) { return name ; } public", "gt": "void setDescription ( String description )", "prediction": "void setDescription ( String description )\n", "label": 1}
{"id": 6833, "input": "<s> import java . io . File ; public class TestDocFileDir extends JavadocTester { private static final String BUG_ID = \"4258405-4973606\" ; private static final String [ ] [ ] TEST1 = { { BUG_ID + \"-1\" + FS + \"pkg\" + FS + \"doc-files\" + FS + \"testfile.txt\" , \"This doc file did not get trashed.\" } } ; private static final String [ ] [ ] NEGATED_TEST1 = NO_TEST ; private static final String [ ] [ ] TEST2 = { { BUG_ID + \"-2\" + FS + \"pkg\" + FS + \"doc-files\" + FS + \"subdir-used1\" + FS + \"testfile.txt\" , \"passed\" } , { BUG_ID + \"-2\" + FS + \"pkg\" + FS + \"doc-files\" + FS + \"subdir-used2\" + FS + \"testfile.txt\" , \"passed\" } , } ; private static final String [ ] [ ] NEGATED_TEST2 = { { BUG_ID + \"-2\" + FS + \"pkg\" + FS + \"doc-files\" + FS + \"subdir-excluded1\" + FS + \"testfile.txt\" , \"passed\" } , { BUG_ID + \"-2\" + FS + \"pkg\" + FS + \"doc-files\" + FS + \"subdir-excluded2\" + FS + \"testfile.txt\" , \"passed\" } , } ; private static final String [ ] [ ] TEST0 = { { \"pkg\" + FS + \"doc-files\" + FS + \"testfile.txt\" , \"This doc file did not get trashed.\" } } ; private static final String [ ] [ ] NEGATED_TEST0 = { } ; private static final String [ ] ARGS1 = new String [ ] { \"-d\" , BUG_ID + \"-1\" , \"-sourcepath\" , \"blah\" + String . valueOf ( File . pathSeparatorChar ) + BUG_ID + \"-1\" + String . valueOf ( File . pathSeparatorChar ) + \"blah\" , \"pkg\" } ; private static final String [", "gt": "] ARGS2 = new String [ ]", "prediction": "] ARGS2 = new String [ ]\n", "label": 0}
{"id": 16236, "input": "<s> package org . mitre . jwt . signer . impl ; import static org . junit . Assert . assertEquals ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . security . NoSuchAlgorithmException ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mitre . jwt . model . Jwt ; import org . mitre . jwt . model . JwtClaims ; import org . mitre . jwt . model . JwtHeader ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import com . google . gson . JsonIOException ; import com . google . gson . JsonObject ; import com . google . gson . JsonParser ; import com . google . gson . JsonSyntaxException ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { \"classpath:test-context.xml\" } ) public class PlaintextSignerTest { URL claimsUrl = this . getClass", "gt": "( ) . getResource ( \"/jwt/claims\" ) ;", "prediction": "( ) . getResource ( \"claims.xml\" ) ;\n", "label": 1}
{"id": 9648, "input": "<s> package org . ofbiz . order . shoppingcart . product ; import java . math . BigDecimal ; import java . math . MathContext ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javax . servlet . ServletRequest ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . shoppingcart . CartItemModifyException ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . order . shoppingcart . ShoppingCartEvents ; import org . ofbiz . order . shoppingcart . ShoppingCartItem ; import org . ofbiz . product . product . ProductContentWrapper ; import org . ofbiz . product . product . ProductSearch ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . calendar . RecurrenceInfo ; import org . ofbiz . service . calendar . RecurrenceInfoException ; import com . ibm . icu . util . Calendar ; public class ProductPromoWorker { public static final String module = ProductPromoWorker . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static final int decimals = UtilNumber . getBigDecimalScale ( \"order.decimals\" ) ; public static final int rounding = UtilNumber . getBigDecimalRoundingMode ( \"order.rounding\" ) ; public static final MathContext generalRounding = new MathContext ( 10 ) ; public static List < GenericValue > getStoreProductPromos ( Delegator delegator , LocalDispatcher dispatcher , ServletRequest request ) { List < GenericValue > productPromos = FastList . newInstance ( ) ; Timestamp nowTimestamp = UtilDateTime . nowTimestamp ( ) ; HttpServletRequest req = null ; ShoppingCart cart = null ; try { req = ( HttpServletRequest ) request ; cart = ShoppingCartEvents . getCartObject ( req ) ; } catch ( ClassCastException cce ) { Debug . logError ( \"Not a HttpServletRequest, no shopping cart found.\" , module ) ; return null ; } catch ( IllegalArgumentException e ) { Debug . logError ( e , module ) ; return null ; } boolean condResult = true ; try { String productStoreId = cart . getProductStoreId ( ) ; GenericValue productStore = null ; try { productStore = delegator . findOne ( \"ProductStore\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Error looking up store with id \" + productStoreId , module ) ; } if ( productStore == null ) { Debug . logWarning ( UtilProperties . getMessage ( resource_error , \"OrderNoStoreFoundWithIdNotDoingPromotions\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , cart . getLocale ( ) ) , module ) ; return productPromos ; } if ( productStore != null ) { Iterator < GenericValue > productStorePromoAppls = UtilMisc . toIterator ( EntityUtil . filterByDate ( productStore . getRelated ( \"ProductStorePromoAppl\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , UtilMisc . toList ( \"sequenceNum\" ) , true ) , true ) ) ; while ( productStorePromoAppls != null && productStorePromoAppls . hasNext ( ) ) { GenericValue productStorePromoAppl = productStorePromoAppls . next ( ) ; if ( UtilValidate . isNotEmpty ( productStorePromoAppl . getString ( \"manualOnly\" ) ) && \"Y\" . equals ( productStorePromoAppl . getString ( \"manualOnly\" ) ) ) { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Skipping promotion with id [\" + productStorePromoAppl . getString ( \"productPromoId\" ) + \"] because it is applied to the store with ID \" + productStoreId + \" as a manual only promotion.\" , module ) ; continue ; } GenericValue productPromo = productStorePromoAppl . getRelatedOne ( \"ProductPromo\" , true ) ; List < GenericValue > productPromoRules = productPromo . getRelated ( \"ProductPromoRule\" , null , null , true ) ; if ( productPromoRules != null ) { Iterator < GenericValue > promoRulesItr = productPromoRules . iterator ( ) ; while ( condResult && promoRulesItr != null && promoRulesItr . hasNext ( ) ) { GenericValue promoRule = promoRulesItr . next ( ) ; Iterator < GenericValue > productPromoConds = UtilMisc . toIterator ( promoRule . getRelated ( \"ProductPromoCond\" , null , UtilMisc . toList ( \"productPromoCondSeqId\" ) , true ) ) ; while ( condResult && productPromoConds != null && productPromoConds . hasNext ( ) ) { GenericValue productPromoCond = productPromoConds . next ( ) ; if ( \"PPIP_PARTY_ID\" . equals ( productPromoCond . getString ( \"inputParamEnumId\" ) ) ) { condResult = checkCondition ( productPromoCond , cart , delegator , dispatcher , nowTimestamp ) ; } else if ( \"PPIP_PARTY_GRP_MEM\" . equals ( productPromoCond . getString ( \"inputParamEnumId\" ) ) ) { condResult = checkCondition ( productPromoCond , cart , delegator , dispatcher , nowTimestamp ) ; } else if ( \"PPIP_PARTY_CLASS\" . equals ( productPromoCond . getString ( \"inputParamEnumId\" ) ) ) { condResult = checkCondition ( productPromoCond , cart , delegator , dispatcher , nowTimestamp ) ; } else if ( \"PPIP_ROLE_TYPE\" . equals (", "gt": "productPromoCond . getString ( \"inputParamEnumId\" ) ) )", "prediction": "productPromoCond . getString ( \"inputParamEnumId\" ) ) )\n", "label": 0}
{"id": 16238, "input": "<s> package org . apache . lucene . queryParser . standard ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; final public class QueryParserUtil { public static Query parse ( String [ ] queries , String [ ] fields , Analyzer analyzer ) throws QueryNodeException { if ( queries . length != fields . length ) throw new IllegalArgumentException ( \"queries.length != fields.length\" ) ; BooleanQuery bQuery = new BooleanQuery ( ) ; StandardQueryParser qp = new StandardQueryParser ( ) ; qp . setAnalyzer ( analyzer ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Query q = qp . parse ( queries [ i ] , fields [ i ] ) ; if ( q != null && ( ! ( q instanceof BooleanQuery ) || ( ( BooleanQuery ) q ) . getClauses ( ) . length > 0 ) ) { bQuery . add ( q , BooleanClause . Occur . SHOULD ) ; } } return bQuery ; } public static Query parse ( String query , String [ ] fields , BooleanClause . Occur [ ] flags , Analyzer analyzer ) throws QueryNodeException { if ( fields . length != flags . length ) throw new IllegalArgumentException ( \"fields.length != flags.length\" ) ; BooleanQuery bQuery = new BooleanQuery ( ) ; StandardQueryParser qp = new StandardQueryParser ( ) ; qp . setAnalyzer ( analyzer ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Query q = qp . parse ( query , fields [ i ] ) ; if ( q != null && ( ! ( q instanceof BooleanQuery ) || ( ( BooleanQuery ) q ) . getClauses ( ) . length > 0 ) ) { bQuery .", "gt": "add ( q , flags [ i ] ) ;", "prediction": "add ( q , BooleanClause . Occur . SHOULD ) ;\n", "label": 1}
{"id": 7714, "input": "<s> package controllers ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import java . util . Map ; import org . scribe . builder . ServiceBuilder ; import org . scribe . builder . api . LinkedInApi ; import org . scribe . model . OAuthRequest ; import org . scribe . model . Response ; import org . scribe . model . Token ; import org . scribe . model . Verb ; import org . scribe . model . Verifier ; import org . scribe . oauth . OAuthService ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import play . Logger ; import play . Play ; import play . cache . Cache ; import play . exceptions . UnexpectedException ; import play . libs . XML ; import play . modules . linkedin . LinkedInProfile ; import play . mvc . Controller ; import play . mvc . Router ; public class LinkedInController extends Controller { public static String getApiKey ( ) { return Play . configuration . getProperty ( \"linkedin.apiKey\" ) ; } public static String getSecret ( ) { return Play . configuration . getProperty ( \"linkedin.secret\" ) ; } public static String getModel ( ) { return Play . configuration . getProperty ( \"linkedin.model\" ) ; } public static String getLandUrl ( ) { return Play . configuration . getProperty ( \"linkedin.landUrl\" ) ; } public static String getLoginUrl ( ) { OAuthService service = getService ( ) ; Token token = service . getRequestToken ( ) ; Logger . info ( \"Request Token - \" + token . getToken ( ) + \" with secret \" + token . getSecret ( ) ) ; Cache . add ( token . getToken ( ) , token . getSecret ( ) ) ; return service . getAuthorizationUrl ( token ) ; } public static void login ( ) { String url = getLoginUrl ( ) ; Logger . info ( \"Redirect: \" + url ) ; redirect ( url ) ; } private static OAuthService getService ( ) { return new ServiceBuilder ( ) . provider ( LinkedInApi . class ) . apiKey ( getApiKey ( ) ) . apiSecret ( getSecret ( ) ) . callback ( Router . getFullUrl ( \"LinkedInController.callback\" ) ) . build ( ) ; } private static OAuthService getServiceNoCallback ( ) { return new ServiceBuilder ( ) . provider ( LinkedInApi . class ) . apiKey ( getApiKey ( ) ) . apiSecret ( getSecret ( ) ) . build ( ) ; } public static void callback ( ) { OAuthService service = getServiceNoCallback ( ) ; Logger . info ( \"LinkedIn Callback - Params: \" + params ) ; String oauthToken = params . get ( \"oauth_token\" ) ; String oauthVerifier = params . get ( \"oauth_verifier\" ) ; Verifier verifier = new Verifier ( oauthVerifier ) ; Logger . info ( \"Token: \" + oauthToken ) ; Logger . info ( \"Verifier: \" + oauthVerifier ) ; Token accessToken = service . getAccessToken ( new Token ( oauthToken , Cache . get ( oauthToken , String . class ) ) , verifier ) ; Logger . info ( \"LinkedIn Access Token: \" + accessToken ) ; if ( accessToken != null && accessToken . getToken ( ) != null ) { String url = \"http://api.linkedin.com/v1/people/~:(id,first-name,last-name,industry,picture-url,headline)\" ; OAuthRequest request = new OAuthRequest ( Verb . GET , url ) ; service . signRequest ( accessToken , request ) ; Response response = request . send ( ) ; String responseBody = response . getBody ( ) ; Logger . info ( \"Response Body: %s\" , responseBody ) ; if ( response == null || response . getCode ( ) != 200 ) { String msg = \"\" ; if ( response != null ) { msg = response . getBody ( ) ; } throw new UnexpectedException ( msg ) ; } Map < String , String > data = new HashMap < String , String > ( ) ; Document doc = XML . getDocument ( responseBody ) ; Node person = doc . getElementsByTagName ( \"person\" ) . item ( 0 ) ; NodeList list = person . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node n = list . item ( i ) ; data . put ( n . getNodeName ( ) , n . getTextContent ( ) ) ; } LinkedInProfile p = new LinkedInProfile ( data . get ( \"id\" ) , data . get ( \"first-name\" ) , data . get ( \"last-name\" ) , data . get ( \"industry\" ) , data . get ( \"picture-url\" ) , data . get ( \"headline\" ) , accessToken . getToken ( ) ) ; Logger . info ( \"Profile Data Map: %s\" , data ) ; Logger . info ( \"Profile Data Object: %s\" , p ) ; try { Class model = Class . forName ( getModel ( ) ) ; Method method = model . getMethod ( \"linkedinOAuthCallback\" , new Class [ ] { LinkedInProfile . class } ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { method . invoke ( null , p ) ; } else { throw new UnexpectedException ( \"Method linkedinOAuthCallback method needs", "gt": "to be static\" ) ;", "prediction": "to be static\" ) ;\n", "label": 0}
{"id": 16240, "input": "<s> package br . org . archimedes . fillet ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . helper . FactoryTester ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . Selection ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import java . util . Collections ; import java . util . HashSet ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class FilletFactoryTest extends FactoryTester { private CommandFactory factory ; private Drawing drawing ; private Selection firstSelection ; private Line line1 ; private Line line2 ; private Selection secondSelection ; private Selection multipleSelection ; @ Before public void setUp ( ) throws Exception { line1 = new Line ( 0.0 , 1.0 , 0.0 , 2.0 ) ; line2 = new Line ( 1.0 , 0.0 , 2.0 , 0.0 ) ; factory = new FilletFactory ( ) ; drawing = new Drawing ( \"Drawing\" ) ; drawing . putElement ( line1 , drawing . getCurrentLayer ( ) ) ; drawing . putElement ( line2 , drawing . getCurrentLayer ( ) ) ; firstSelection = new Selection ( new Rectangle ( - 0.5 , 0.5 , 0.5 , 1.5 ) ) ; firstSelection . add ( line1 ) ; secondSelection = new Selection ( new Rectangle ( 0.5 , - 0.5 , 1.5 , 0.5 ) ) ; secondSelection . add ( line2 ) ; multipleSelection = new Selection ( new Rectangle ( - 0.5 , - 0.5 , 1.5 , 1.5 ) ) ; multipleSelection . add ( line1 ) ; multipleSelection . add ( line2 ) ; br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( drawing ) ; } @ After public void tearDown ( ) throws Exception { br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( null ) ; } @ Test public void canFilletSelectingTwoElements ( ) throws Exception { assertBegin ( factory , false ) ; assertTrue ( br . org . archimedes . Utils . getController ( ) . getCurrentSelectedElements ( ) . isEmpty ( ) ) ; assertInvalidNext ( factory , null ) ;", "gt": "assertInvalidNext ( factory , new Object ( ) ) ;", "prediction": "assertInvalidNext ( factory , null ) ;\n", "label": 1}
{"id": 9259, "input": "<s> package org . globaleaks . android . net ; public interface ProgressListener { void transferred", "gt": "( long num ) ;", "prediction": "( TransferEvent event ) ;\n", "label": 0}
{"id": 16243, "input": "<s> package org . fuzzydb . expressions ; import org . fuzzydb . core . exceptions . ArchException ; public class SubExpr extends BinaryExpr { private static final long serialVersionUID = 3257571689419257908L ; public SubExpr ( ComparableExpr < Scalar > left , ComparableExpr < Scalar > right ) { super ( left , right ) ; } @ Override public Scalar evaluate ( ExprContext context ) { Scalar l = left . evaluate ( context ) ; Scalar r = right", "gt": ". evaluate ( context ) ;", "prediction": ". evaluate ( context ) ;\n", "label": 1}
{"id": 1558, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface ShiftsTask extends TaskAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 16256, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . dialogs . IWorkingSetEditWizard ; import org . eclipse . ui . dialogs . IWorkingSetNewWizard ; import org . eclipse . ui . dialogs . IWorkingSetSelectionDialog ; public interface IWorkingSetManager { public static final String CHANGE_WORKING_SET_ADD = \"workingSetAdd\" ; public static final String CHANGE_WORKING_SET_REMOVE = \"workingSetRemove\" ; public static final String CHANGE_WORKING_SET_CONTENT_CHANGE = \"workingSetContentChange\" ; public static final String CHANGE_WORKING_SET_NAME_CHANGE = \"workingSetNameChange\" ; public static final String CHANGE_WORKING_SET_LABEL_CHANGE = \"workingSetLabelChange\" ; public static final String CHANGE_WORKING_SET_UPDATER_INSTALLED = \"workingSetUpdaterInstalled\" ; public static final String CHANGE_WORKING_SET_UPDATER_UNINSTALLED = \"workingSetUpdaterUninstalled\" ; public void addPropertyChangeListener ( IPropertyChangeListener listener ) ; public void addRecentWorkingSet ( IWorkingSet workingSet ) ; public void addWorkingSet ( IWorkingSet workingSet ) ; public IWorkingSet createWorkingSet ( String name , IAdaptable [ ] elements ) ; public IWorkingSet createAggregateWorkingSet ( String name , String label , IWorkingSet [ ] components ) ; public IWorkingSet createWorkingSet ( IMemento memento ) ; public IWorkingSetEditWizard createWorkingSetEditWizard ( IWorkingSet workingSet ) ; public IWorkingSetNewWizard createWorkingSetNewWizard ( String [ ] workingSetIds ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parentShell , boolean multi ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parentShell , boolean multi , String [ ] workingsSetIds ) ; public IWorkingSet [ ] getRecentWorkingSets ( ) ; public IWorkingSet getWorkingSet ( String name ) ; public IWorkingSet [ ] getWorkingSets ( ) ;", "gt": "public IWorkingSet [ ] getAllWorkingSets ( ) ;", "prediction": "public IWorkingSet getWorkingSet ( String name ) ;\n", "label": 1}
{"id": 9067, "input": "<s> package org . ofbiz . base . concurrent . test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . ScheduledExecutorService ; import org . ofbiz . base . concurrent . DependencyPool ; import org . ofbiz . base . concurrent . ExecutionPool ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; @ SourceMonitored public class DependencyPoolTests extends GenericTestCaseBase { public DependencyPoolTests ( String name ) { super ( name ) ; } public void testDependencyPool ( ) throws Exception { ScheduledExecutorService executor = ExecutionPool . getExecutor ( new ThreadGroup ( \"DependencyPoolTests\" ) , getName ( ) , - 2 , true ) ; DependencyPool < Integer , TestItem , String > pool = new DependencyPool < Integer , TestItem , String > ( executor ) ; int itemSize = 100 , depMax = 5 , subMax = 3 ; List < TestItem > items = new ArrayList < TestItem > ( itemSize ) ; List < TestItem > previousItems = new ArrayList < TestItem > ( itemSize ) ; for ( int i = 0 ; i < itemSize ; i ++ ) { int depSize = ( int ) ( Math . random ( ) * Math . min ( depMax , itemSize - i - 1 ) ) ; List < Integer > deps = new ArrayList < Integer > ( depSize ) ; for ( int j = i + 1 , k = 0 ; j < itemSize && k < depSize ; j ++ ) { if ( Math . random ( ) * ( itemSize - j ) / ( depSize - k + 1 ) < 1 ) { deps . add ( j ) ; k ++ ; } } int subSize = ( int ) ( Math . random ( ) * Math . min ( subMax , i ) ) ; List < TestItem > subItems = new ArrayList < TestItem > ( subSize ) ; OUTER : for ( int j = 0 ; j < previousItems . size ( ) && subItems . size ( ) < subSize ; ) { if ( Math . random ( ) * j < 1 ) { TestItem previousItem = previousItems . get ( j ) ; for ( int k = 0 ; k < deps . size ( ) ; k ++ ) { if ( previousItem . getDependencies ( ) . contains ( deps . get ( k ) ) ) { j ++ ; continue OUTER ; } } subItems . add ( previousItem ) ; previousItems . remove ( j ) ; } else { j ++ ; } } TestItem item = new TestItem ( pool , Integer . valueOf ( i ) , Integer . toString ( i ) , deps , subItems ) ; items . add ( item ) ; previousItems . add ( item ) ; } pool . addAll ( items ) ; pool . start ( ) ; pool . await ( ) ; assertEquals ( \"result count\" , itemSize , pool . getResultCount ( ) ) ; for ( int i = 0 ; i < itemSize ; i ++ ) { TestItem item = items . get ( i ) ; assertEquals ( \"item(\" + i + \") result\" , Integer . toString ( i ) , pool . getResult ( item ) ) ; } executor . shutdown ( ) ; } private static class TestItem implements DependencyPool . Item < TestItem , Integer , String > { private final DependencyPool < Integer , TestItem , String > pool ; private final Integer key ; private final String result ; private final Collection < Integer > dependencies ; private final Collection < TestItem > subItems ; protected TestItem ( DependencyPool < Integer , TestItem , String > pool , Integer key , String result , Collection < Integer > dependencies , Collection < TestItem > subItems ) { this . pool = pool ; this . key = key ; this . result = result ; this", "gt": ". dependencies = dependencies ;", "prediction": ". dependencies = dependencies ;\n", "label": 0}
{"id": 16262, "input": "<s> package org . eclipse . rap . demo . controls ; import java . util . ArrayList ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ArrayContentProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . ListViewer ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . MenuAdapter ; import org . eclipse . swt . events . MenuEvent ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . List ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class ListTab extends ExampleTab { private static final java . util . List < String > ELEMENTS ; static { ELEMENTS = new ArrayList < String > ( ) ; String text = \"A very long item that demonstrates horizontal scrolling in a List\" ; ELEMENTS . add ( text ) ; text = \"An item with a linebreak\\n(converted to a whitespace)\" ; ELEMENTS . add ( text ) ; text = \"...and other control chars: \u0003 \\t \u0004 \u000f\" ; ELEMENTS . add ( text ) ; for ( int i = 1 ; i <= 25 ; i ++ ) { ELEMENTS . add ( \"Item \" + i ) ; } } private List list ; private List list2 ; private ListViewer listViewer ; public ListTab ( ) { super ( \"List\" ) ; } @ Override protected void createStyleControls ( final Composite parent ) { createStyleButton ( \"BORDER\" , SWT . BORDER ) ; createStyleButton ( \"SINGLE\" , SWT . SINGLE ) ; createStyleButton ( \"MULTI\" , SWT . MULTI ) ; createStyleButton ( \"H_SCROLL\" , SWT . H_SCROLL ) ; createStyleButton ( \"V_SCROLL\" , SWT . V_SCROLL ) ; createVisibilityButton ( ) ; createEnablementButton ( ) ; createFgColorButton ( ) ; createBgColorButton ( ) ; createBgImageButton ( ) ; createFontChooser ( ) ; createCursorCombo ( ) ; createSelectionButton ( ) ; Group group = new Group ( parent , SWT . NONE ) ; group . setText ( \"Manipulate Right List\" ) ; group . setLayout ( new GridLayout ( ) ) ; createAddItemsControls ( group ) ; createSetTopIndexControls ( group ) ; createGetTopIndexControls ( group ) ; createShowSelectionControls ( group ) ; createSelectAllButton ( group ) ; createDeselectAllButton ( group ) ; createSelectButton ( group ) ; createDeselectButton ( group ) ; createSetSelectionButton ( group ) ; } @ Override protected void createExampleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 2 , true ) ) ; int style = getStyle ( ) ; list = new List ( parent , style ) ; list . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Menu menu = new Menu ( list ) ; MenuItem menuItem = new MenuItem ( menu , SWT . PUSH ) ; menuItem . setText ( \"Context menu item\" ) ; list . setMenu ( menu ) ; listViewer = new ListViewer ( list ) ; listViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; listViewer . setLabelProvider ( new LabelProvider ( ) ) ; listViewer . setInput ( ELEMENTS ) ; list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetDefaultSelected ( SelectionEvent event ) { String item = list . getItem ( list . getSelectionIndex ( ) ) ; String message = \"Selected Item: \" + item ; MessageDialog . openInformation ( getShell ( ) , \"Selection\" , message ) ; } } ) ; registerControl ( list ) ; list2 = new List ( parent , style ) ; list2 . add ( \"Item 0\" ) ; list2 . add ( \"Item 1\" ) ; list2 . add ( \"Item 2\" ) ; list2 . setLayoutData ( new GridData ( GridData", "gt": ". FILL_BOTH ) ) ;", "prediction": ". FILL_BOTH ) ) ;\n", "label": 1}
{"id": 5661, "input": "<s> import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . code . Symtab ; import com . sun . tools . javac . code . Types ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . tree . JCTree . JCLiteral ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . tree . TreeMaker ; import static com . sun . tools . javac . code . TypeTags . * ; public class MakeLiteralTest { public static void main ( String ... args ) throws Exception { new MakeLiteralTest ( ) . run ( ) ; } void run ( ) throws Exception { Context context = new Context ( ) ; JavacFileManager . preRegister ( context ) ; Symtab syms = Symtab . instance ( context ) ; maker = TreeMaker . instance ( context ) ; types = Types . instance ( context ) ; test ( \"abc\" , CLASS , syms . stringType , \"abc\" ) ; test ( Boolean . FALSE , BOOLEAN , syms . booleanType , Integer . valueOf ( 0 ) ) ; test ( Boolean . TRUE , BOOLEAN , syms . booleanType , Integer . valueOf ( 1 ) ) ; test ( Byte . valueOf ( ( byte ) 1 ) , BYTE , syms . byteType , Byte . valueOf ( ( byte ) 1 ) ) ; test ( Character . valueOf ( 'a' ) , CHAR , syms . charType , Integer . valueOf ( 'a' ) ) ; test ( Double . valueOf ( 1d ) , DOUBLE , syms . doubleType , Double . valueOf ( 1d ) ) ; test ( Float . valueOf ( 1f ) , FLOAT , syms . floatType ,", "gt": "Float . valueOf ( 1f ) ) ;", "prediction": "Float . valueOf ( 1f ) ) ;\n", "label": 0}
{"id": 16265, "input": "<s> package org . restlet . test . ext . jaxrs . services . echo ; import java . awt . Point ; import javax . ws . rs . Consumes ; import javax . ws . rs . GET ; import javax . ws . rs . HeaderParam ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; @ Path ( value = EchoResource . path ) public interface EchoResource { public static final String path = \"echo\" ; @ GET @ Path ( \"point-header\" ) @ Consumes ( MediaType . APPLICATION_JSON ) Point echoPointHeaderParam ( @ HeaderParam ( \"point\" ) Point point ) ; @ GET @ Path ( \"point-query\" ) @ Consumes ( MediaType . APPLICATION_JSON ) Point echoPointQueryParam ( @ Deprecated @ QueryParam ( \"point\" ) Point point ) ; @ POST String echo", "gt": "( String input ) ;", "prediction": ";\n", "label": 1}
{"id": 1442, "input": "<s> package pkg1 ; import java . lang . annotation . * ; @ Retention ( RetentionPolicy", "gt": ". SOURCE ) public @ interface C3", "prediction": ". RUNTIME ) public class Package\n", "label": 0}
{"id": 16266, "input": "<s> package org . eclipse . jface . viewers ; public interface ITreeContentProvider extends IStructuredContentProvider { public Object [ ] getElements ( Object inputElement ) ; public Object [ ] getChildren ( Object parentElement ) ; public Object getParent", "gt": "( Object element ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9874, "input": "<s> package pkg1 ; import pkg2 . * ;", "gt": "public class C1 extends C2", "prediction": "import pkg3 . * ;\n", "label": 0}
{"id": 16279, "input": "<s> package org . restlet . example . book . restlet . ch02 . sec4 . sub2 ; import org . restlet . Application ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . Protocol ; import org . restlet . routing . Router ; public class MailServerApplication extends Application { public static void main ( String [ ] args ) throws Exception { Server mailServer = new Server ( Protocol . HTTP , 8111 ) ; mailServer . setNext ( new MailServerApplication ( ) ) ; mailServer . start ( ) ; } public MailServerApplication ( ) { setName ( \"RESTful Mail Server\" ) ; setDescription ( \"Example for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; } @ Override public Restlet createInboundRoot ( ) { Tracer tracer = new Tracer ( getContext ( ) ) ; Blocker blocker = new Blocker ( getContext ( ) ) ; blocker . getBlockedAddresses ( ) . add ( \"127.0.0.1\" ) ; blocker . setNext ( tracer ) ; Router router = new Router ( getContext ( ) ) ; router . attach ( \"http://localhost:8111/\" , tracer ) ; router . attach ( \"http://localhost:8111/accounts/\" , tracer ) ; router . attach (", "gt": "\"http://localhost:8111/accounts/{accountId}\" , blocker ) ;", "prediction": "\"/accounts\" , tracer ) ;\n", "label": 1}
{"id": 5676, "input": "<s> package org . bombusim . util ; import java . io . ByteArrayOutputStream ; public final class strconv { private strconv ( ) { } public static final String convCp1251ToUnicode ( final String s ) { if ( s == null ) return null ; StringBuilder b = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch > 0xbf ) ch += 0x410 - 0xc0 ; if ( ch == 0xa8 ) ch = 0x401 ; if ( ch == 0xb8 ) ch = 0x451 ; b . append ( ch ) ; } return b . toString ( ) ; } public static final String convUnicodeToCp1251 ( final String s ) { if ( s == null ) return null ; StringBuilder b = new StringBuilder ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch == 0x401 ) ch = 0xa8 ; if ( ch == 0x451 ) ch = 0xb8 ; if ( ch > 0x409 ) ch += 0xc0 - 0x410 ; b . append ( ch ) ; } return b . toString ( ) ; } @ Deprecated public final static String toBase64 ( String source ) { String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" ; int len = source . length ( ) ; char [ ] out = new char [ ( ( len + 2 ) / 3 ) * 4 ] ; for ( int i = 0 , index = 0 ; i < len ; i += 3 , index += 4 ) { boolean trip = false ; boolean quad = false ; int val = ( 0xFF & source . charAt ( i ) ) << 8 ; if ( ( i + 1 ) < len ) { val |= ( 0xFF & source . charAt ( i + 1 ) ) ; trip = true ; } val <<= 8 ; if ( ( i + 2 ) < len ) { val |= ( 0xFF & source . charAt ( i + 2 ) ) ; quad = true ; } out [ index + 3 ] = alphabet . charAt ( ( quad ? ( val & 0x3F ) : 64 ) ) ; val >>= 6 ; out [ index + 2 ] = alphabet . charAt ( ( trip ? ( val & 0x3F ) : 64 ) ) ; val >>= 6 ; out [ index + 1 ] = alphabet . charAt ( val & 0x3F ) ; val >>= 6 ; out [ index + 0 ] = alphabet . charAt ( val & 0x3F ) ; } return new String ( out ) ; } public final static String toBase64 ( byte source [ ] ) { return toBase64 ( source , source . length ) ; } public final static String toBase64 ( byte source [ ] , int len ) { String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" ; if ( len == 0 ) return null ; if ( len < 0 ) len = source . length ; char [ ] out = new char [ ( ( len + 2 ) / 3 ) * 4 ] ; for ( int i = 0 , index = 0 ; i < len ; i += 3 , index += 4 ) { boolean trip = false ; boolean quad = false ; int val = ( 0xFF & source [ i ] ) << 8 ; if ( ( i + 1 ) < len ) { val |= ( 0xFF & source [ i + 1 ] ) ; trip = true ; } val <<= 8 ; if ( ( i + 2 ) < len ) { val |= ( 0xFF & source [ i + 2 ] ) ; quad = true ; } out [ index + 3 ] = alphabet . charAt ( ( quad ? ( val & 0x3F ) : 64 ) ) ; val >>= 6 ; out [ index + 2 ] = alphabet . charAt ( ( trip ? ( val & 0x3F ) : 64 ) ) ; val >>= 6 ; out [ index + 1 ] = alphabet . charAt (", "gt": "val & 0x3F ) ;", "prediction": "val & 0x3F ) ;\n", "label": 0}
{"id": 16281, "input": "<s> package org . nuxeo . theme . bank ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . StreamingOutput ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . apache . commons . io . IOUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . theme . presets . PaletteIdentifyException ; import org . nuxeo . theme . presets . PaletteParseException ; import org . nuxeo . theme . presets . PaletteParser ; import org . nuxeo . theme . resources . BankManager ; import org . nuxeo . theme . resources . BankUtils ; public class Utils { private static final Log log = LogFactory . getLog ( Utils . class ) ; private static final List < String > PRESET_CATEGORIES = Arrays . asList ( \"color\" , \"background\" , \"font\" , \"border\" ) ; public static List < String > getCollections ( String bankName ) throws IOException { return BankManager . getCollections ( bankName ) ; } public static List < String > getItemsInCollection ( String bankName , String collection , String typeName ) throws IOException { return BankManager . getItemsInCollection ( bankName , collection , typeName ) ; } public static List < String > listSkinsInCollection ( String bankName , String collection ) throws IOException { Map < String , Object > info ; info = BankManager . getInfo ( bankName , collection , \"style\" ) ; List < String > skins = new ArrayList < String > ( ) ; if ( info != null ) { for ( Map . Entry < String , Object > entry : info . entrySet ( ) ) { String resource = entry . getKey ( ) ; Map value = ( Map ) entry . getValue ( ) ; Boolean isSkin = false ; if ( value . containsKey ( \"skin\" ) ) { isSkin = ( Boolean ) value . get ( \"skin\" ) ; } if ( isSkin ) { skins . add ( resource ) ; } } } return skins ; } public static Properties getPresetProperties ( String bank , String collection , String category ) { String path = String . format ( \"%s/%s/preset/%s\" , bank , collection , category ) ; File file ; try { file =", "gt": "BankManager . getFile ( path ) ;", "prediction": "new File ( path ) ;\n", "label": 1}
{"id": 7891, "input": "<s> package annComma ; @ ann1 ( isStatic = false , type = \"class\" , ) class TestM4 { @ ann1 ( type = \"class\" , isStatic = false , ) public void myMethod ( ) { System . out . println", "gt": "( \" In side the myMethod\" ) ;", "prediction": "( \"myMethod\" ) ;\n", "label": 0}
{"id": 16283, "input": "<s> package com . poetry . model ; import java . util . ArrayList ; import java . util . Collection ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . Id ; import javax . persistence . Transient ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . security . core . authority . SimpleGrantedAuthority ; import org . springframework . security . core . userdetails . UserDetails ; import com . fasterxml . jackson . annotation . JsonIgnore ; import escode . util . CollectionUtils ; @ Entity public class Poet implements UserDetails { private static final long serialVersionUID = 7403546217867181618L ; protected static String DEFAULT_AUTHORITY = \"ROLE_USER\" ; @ Id protected String username ; @ Column ( name = \"pen_name\" ) protected String penName ; protected String icon ; protected String email ; @ JsonIgnore protected String password ; @ JsonIgnore protected String authority = DEFAULT_AUTHORITY ; @ Transient protected int nPoetries ; @ Transient protected int nBookmark ; @ Transient protected int nFollowings ; @ Transient protected int nFollowers ; @ Transient protected boolean bBlock ; public Poet ( ) { } public Poet ( final String username , final String penName ) { this ( username , penName , null ) ; } public Poet ( final String username , final String penName , final String password ) { this ( username , penName , password , null ) ; } public Poet ( final String username , final String penName , final String password , final String authority ) { this . username = username ; this . penName = penName ; this . password = password ; if ( null == authority ) { return ; } setAuthority ( authority ) ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String name ) { this . username = name ; } public String getPenName ( ) { return penName ; } public void setPenName ( String penName ) { this . penName = penName ; } public String getIcon ( ) { return this . icon ; } public void setIcon ( final String icon ) { this . icon = icon ; } public String getPassword ( ) { return this . password ; } public void setPassword ( String password ) { this . password = password ; } public void setAuthority ( final String authority ) { this . authority = authority ; } public String getAuthority ( ) { return this . authority ; } public void setAuthorities ( final Collection < GrantedAuthority > authorities ) { if ( null == authorities ) { this . authority = null ; } this . authority = CollectionUtils . concatenate ( authorities , \",\" ) ; } @ JsonIgnore public Collection < GrantedAuthority > getAuthorities ( ) { if ( null == this . authority ) { return null ; } final ArrayList < GrantedAuthority > ret = new ArrayList < GrantedAuthority > ( ) ; for ( final String auth : this . authority . split ( \",\" ) ) { ret . add ( new SimpleGrantedAuthority ( auth . trim ( ) ) ) ; } return ret ; } @ JsonIgnore public boolean isAccountNonExpired ( ) { return true ; } @ JsonIgnore public boolean isAccountNonLocked ( ) { return true ; } @ JsonIgnore public boolean isCredentialsNonExpired ( ) { return true ; } @ JsonIgnore public boolean isEnabled ( ) { return true ; } public int getTheNumberOfPoetries ( ) { return this . nPoetries ; } public void setTheNumberOfPoetries ( final int nPoetries ) { this . nPoetries = nPoetries ; } public int getTheNumberOfBookmarks ( ) { return this . nBookmark ; } public void setTheNumberOfBookmarks ( final int nClips ) { this . nBookmark = nClips ; } public int getTheNumberOfFollowings ( ) { return this . nFollowings ; } public void setTheNumberOfFollowings ( final int nFollowings ) { this . nFollowings = nFollowings ; } public int getTheNumberOfFollowers ( ) { return this . nFollowers ; } public void setTheNumberOfFollowers ( final int nFollowers ) { this . nFollowers = nFollowers ; } public boolean isBlock ( ) { return this . bBlock ; } public void setBlock ( final boolean bBlock ) { this . bBlock = bBlock ; } public String toString ( ) { return \"Poet[\"", "gt": "+ getUsername ( ) + \"]\" ;", "prediction": "+ this . username + \"]\" ;\n", "label": 1}
{"id": 7223, "input": "<s> class T6738538a { class C < T > { public T m ( ) { return null ; } } interface I < T > { public T m ( ) ; } class Crash", "gt": "< T extends C < ? > & I >", "prediction": "\n", "label": 0}
{"id": 16284, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . part . ViewPart ; public class DynamicView extends ViewPart { public DynamicView ( ) { super ( ) ; } public", "gt": "void createPartControl ( Composite parent )", "prediction": "DynamicView ( Composite parent )\n", "label": 1}
{"id": 838, "input": "<s> package com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 ; import javax . xml . bind . annotation . XmlType ; @ XmlType ( propOrder = { \"groupId\" , \"artifactId\" , \"version\" } ) public class Coordinates { private String groupId ; private String artifactId ; private String version ; public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getArtifactId ( ) { return artifactId ; } public void setArtifactId ( String artifactId ) { this . artifactId = artifactId ; } public String getVersion ( ) { return version ; } public void setVersion ( String version ) { this", "gt": ". version = version ;", "prediction": ". version = version ;\n", "label": 0}
{"id": 16287, "input": "<s> package org . fuzzydb . util ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class CsvTokeniser { private final static Pattern pCSVmain = Pattern . compile ( \"\\\\G(?:^|,)\\n\" + \"(?:\\n\" + \"# Either a double-quoted field...\\n\" + \"\\\" # field's opening quote\\n\" + \"( (?> [^\\\"]*+ ) (?> \\\"\\\" [^\\\"]*+ )*+ )\\n\" + \"\\\" # field's closing quote\\n\" + \"# ... or ...\\n\" + \"|\\n\" + \"# ... some non-quote/non-comma text ...\\n\" + \"( [^\\\",]*+ )\\n\" + \")\\n\" , Pattern . COMMENTS ) ; private final static Pattern pCSVquote = Pattern . compile ( \"\\\"\\\"\" ) ; private final Matcher mCSVmain = pCSVmain . matcher ( \"\" ) ; private final Matcher mCSVquote = pCSVquote . matcher ( \"\" ) ; private", "gt": "int missingStarts = 0 ;", "prediction": "final StringBuilder sb = new StringBuilder ( ) ;\n", "label": 1}
{"id": 5254, "input": "<s> public class T6569404a { static class Outer { public class Inner { } } static class Test < T extends Outer > { public Test ( T t ) { Outer . Inner inner = t . new Inner ( ) ; } } public static void main ( String [ ] args ) { new Test <", "gt": "Outer > ( new Outer ( ) ) ;", "prediction": "T > ( )\n", "label": 0}
{"id": 16288, "input": "<s> package com . rusticisoftware . cheddargetter . client ; import java . util . Date ; import org . w3c . dom . Element ; public class CGItem { protected String id ; protected String code ; protected String name ; protected int quantity ; protected int quantityIncluded ; protected boolean isPeriodic ; protected float overageAmount ; protected Date createdDatetime ; protected Date modifiedDatetime ; public String getId ( ) { return id ; } public String getCode ( ) { return code ; } public String getName ( ) { return name ; } public int getQuantity ( ) { return quantity ; } public int getQuantityIncluded ( ) { return quantityIncluded ; } public boolean isPeriodic ( ) { return isPeriodic ; } public float getOverageAmount ( ) { return overageAmount ; } public Date getCreatedDatetime ( ) { return createdDatetime ; } public Date getModifiedDatetime ( ) { return modifiedDatetime ; } public CGItem ( Element elem ) { this . id = elem . getAttribute ( \"id\" ) ; this . code = elem . getAttribute ( \"code\" ) ; this . name = XmlUtils . getNamedElemValue ( elem , \"name\" ) ; this . quantity = ( Integer ) XmlUtils . getNamedElemValue ( elem , \"quantity\" , Integer . class , 0 ) ; this . quantityIncluded = ( Integer ) XmlUtils . getNamedElemValue ( elem , \"quantityIncluded\" , Integer . class , 0 ) ; this . isPeriodic = ( Boolean ) XmlUtils . getNamedElemValue ( elem , \"isPeriodic\" , Boolean . class , false ) ; this . overageAmount = ( Float ) XmlUtils . getNamedElemValue ( elem", "gt": ", \"overageAmount\" , Float . class , 0.0f ) ;", "prediction": ", \"overageAmount\" , Float . class , 0 ) ;\n", "label": 1}
{"id": 567, "input": "<s> package org . ofbiz . service ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . security . Security ; @ SuppressWarnings ( \"serial\" ) public class ModelPermission implements Serializable { public static final String module = ModelPermission . class . getName ( ) ; public static final int PERMISSION = 1 ; public static final int ENTITY_PERMISSION = 2 ; public static final int ROLE_MEMBER = 3 ; public static final int PERMISSION_SERVICE = 4 ; public ModelService serviceModel = null ; public int permissionType = 0 ; public String nameOrRole = null ; public String action = null ; public String permissionServiceName = null ; public String permissionResourceDesc = null ; public Boolean auth ; public String clazz = null ; public boolean evalPermission ( DispatchContext dctx , Map < String , ? extends Object > context ) { GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Security security = dctx . getSecurity ( ) ; if ( userLogin == null ) { Debug . logInfo ( \"Secure service requested with no userLogin object\" , module ) ; return false ; } switch ( permissionType ) { case PERMISSION : return evalSimplePermission ( security , userLogin ) ; case ENTITY_PERMISSION : return evalEntityPermission ( security , userLogin ) ; case ROLE_MEMBER : return evalRoleMember ( userLogin ) ; case PERMISSION_SERVICE : return evalPermissionService ( serviceModel , dctx , context ) ; default : Debug . logWarning ( \"Invalid permission type [\" + permissionType + \"] for permission named : \" + nameOrRole + \" on service : \" + serviceModel . name , module ) ; return false ; } } private boolean evalSimplePermission ( Security security , GenericValue userLogin ) { if ( nameOrRole == null ) { Debug . logWarning ( \"Null permission name passed for evaluation\" , module ) ; return false ; } return security . hasPermission ( nameOrRole , userLogin ) ; } private boolean evalEntityPermission ( Security security , GenericValue userLogin ) { if ( nameOrRole == null ) { Debug . logWarning ( \"Null permission name passed for evaluation\" , module ) ; return false ; } if ( action == null ) { Debug . logWarning ( \"Null action passed for evaluation\" , module ) ; } return security . hasEntityPermission ( nameOrRole , action , userLogin ) ; } private boolean evalRoleMember ( GenericValue userLogin ) { if ( nameOrRole == null ) { Debug . logWarning ( \"Null role type name passed for evaluation\" , module ) ; return false ; } List < GenericValue > partyRoles = null ;", "gt": "if ( UtilValidate . isNotEmpty ( partyRoles ) )", "prediction": "try\n", "label": 0}
{"id": 16291, "input": "<s> package br . org . archimedes . io . xml . parsers ; import junit . framework . Assert ; import org . junit . Before ; import org . junit . Test ; import org . w3c . dom . Node ; import br . org . archimedes . dimension . Dimension ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; public class DimensionParserTest extends NPointParserTestHelper { private static final Double FONT_SIZE = 18.0 ; @ Before public void testGetLineParser ( ) { parser = new DimensionParser ( ) ; } @ Test public void testInvalidDimensionPoints ( ) throws Exception { final String xml_line = \"<dimension>\" + \"\t<point x=\\\"-64\\\" y=\\\"198\\\" /><point x=\\\"-64\\\" y=\\\"198\\\" />\" + \"<point x=\\\"-118.5\\\" y=\\\"210\\\" /><size>18.0</size>\" + \"</dimension>\" ; testFail ( xml_line ) ; } @ Test public void testInvalidNumberOfPointsInADimension ( ) throws Exception { final String xml_line = \"<dimension>\" + \"\t<point x=\\\"-64\\\" y=\\\"198\\\" />\" + \"</dimension>\" ; testFail ( xml_line ) ; } @ Test public void testParse ( ) throws Exception { final String xml_line = \"<dimension>\" + \"\t<point x=\\\"-64\\\" y=\\\"198\\\" /><point x=\\\"-173\\\" y=\\\"88\\\" />\" + \"<point x=\\\"-118.5\\\" y=\\\"210\\\" /><size>18.0</size>\" + \"</dimension>\" ; Node nodeLine = this . getNodeLine ( xml_line ) ; Element element = parser . parse ( nodeLine ) ; Assert . assertNotNull ( element ) ; Assert . assertEquals ( Dimension . class , element . getClass ( ) ) ; Dimension dimension = ( Dimension ) element ; Point p1 = new Point ( - 64 , 198 ) ; Point p2 = new Point ( -", "gt": "173 , 88 ) ;", "prediction": "68 , 68 ) ;\n", "label": 1}
{"id": 5235, "input": "<s> enum Color { red , green } public class EnumSwitch { static int f ( Color c ) { switch ( c ) { case red : return 1 ; case green : return 2 ; default : return 0 ; } } public static void main ( String [ ] args ) { f", "gt": "( Color . red ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 16292, "input": "<s> package org . restlet . engine . converter ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . nio . channels . ReadableByteChannel ; import java . util . List ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . FileRepresentation ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . ObjectRepresentation ; import org . restlet . representation . ReaderRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; public class DefaultConverter extends ConverterHelper { private static final VariantInfo VARIANT_ALL = new VariantInfo ( MediaType . ALL ) ; private static final VariantInfo VARIANT_FORM = new VariantInfo ( MediaType . APPLICATION_WWW_FORM ) ; private static final VariantInfo VARIANT_OBJECT = new VariantInfo ( MediaType . APPLICATION_JAVA_OBJECT ) ; private static final VariantInfo VARIANT_OBJECT_XML = new VariantInfo ( MediaType . APPLICATION_JAVA_OBJECT_XML ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; result = addObjectClass ( result , String . class ) ; result = addObjectClass ( result , InputStream . class ) ; result = addObjectClass ( result , Reader . class ) ; result = addObjectClass ( result , ReadableByteChannel . class ) ; if ( source . getMediaType ( ) != null ) { MediaType mediaType = source . getMediaType ( ) ; if ( MediaType . APPLICATION_JAVA_OBJECT . equals ( mediaType ) || MediaType . APPLICATION_JAVA_OBJECT_XML . equals ( mediaType ) ) { result = addObjectClass ( result , Object . class ) ; } else if ( MediaType . APPLICATION_WWW_FORM . equals ( mediaType ) ) { result = addObjectClass ( result , Form . class ) ; } } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( source != null ) { if ( String . class . isAssignableFrom ( source ) || StringRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( File . class . isAssignableFrom ( source ) || FileRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( InputStream . class . isAssignableFrom ( source ) || InputRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant", "gt": "( result , VARIANT_ALL ) ;", "prediction": "( result , VARIANT_FORM ) ;\n", "label": 1}
{"id": 8634, "input": "<s> package org . jjflyboy . tjpeditor . project . util ; import org . eclipse . emf . common . notify . Adapter ; import org . eclipse . emf . common . notify . Notifier ; import org . eclipse . emf . common . notify . impl . AdapterFactoryImpl ; import org . eclipse . emf . ecore . EObject ; import org . jjflyboy . tjpeditor . project . * ; public class ProjectAdapterFactory extends AdapterFactoryImpl { protected static ProjectPackage modelPackage ; public ProjectAdapterFactory ( ) { if ( modelPackage == null ) { modelPackage = ProjectPackage . eINSTANCE ; } } @ Override public boolean isFactoryForType ( Object object ) { if ( object == modelPackage ) { return true ; } if ( object instanceof EObject ) { return ( ( EObject ) object ) . eClass ( ) . getEPackage ( ) == modelPackage ; } return false ; } protected ProjectSwitch < Adapter > modelSwitch = new ProjectSwitch < Adapter > ( ) { @ Override public Adapter caseGlobal ( Global object ) { return createGlobalAdapter ( ) ; } @ Override public Adapter caseProperty ( Property object ) { return createPropertyAdapter ( ) ; } @ Override public Adapter caseAccount ( Account object ) { return createAccountAdapter ( ) ; } @ Override public Adapter caseAccountAttribute ( AccountAttribute object ) { return createAccountAttributeAdapter ( ) ; } @ Override public Adapter caseAccountPrefix ( AccountPrefix object ) { return createAccountPrefixAdapter ( ) ; } @ Override public Adapter caseAccountReport ( AccountReport object ) { return createAccountReportAdapter ( ) ; } @ Override public Adapter caseAccountRoot ( AccountRoot object ) { return createAccountRootAdapter ( ) ; } @ Override public Adapter caseProject ( Project object ) { return createProjectAdapter ( ) ; } @ Override public Adapter caseProjectAttribute ( ProjectAttribute object ) { return createProjectAttributeAdapter ( ) ; } @ Override public Adapter caseTask ( Task object ) { return createTaskAdapter ( ) ; } @ Override public Adapter caseTaskAttribute ( TaskAttribute object ) { return createTaskAttributeAdapter ( ) ; } @ Override public Adapter caseReport ( Report object ) { return createReportAdapter ( ) ; } @ Override public Adapter caseReportAttribute ( ReportAttribute object ) { return createReportAttributeAdapter ( ) ; } @ Override public Adapter caseIcalReport ( IcalReport object ) { return createIcalReportAdapter ( ) ; } @ Override public Adapter caseIcalReportAttribute ( IcalReportAttribute object ) { return createIcalReportAttributeAdapter ( ) ; } @ Override public Adapter caseExport ( Export object ) { return createExportAdapter ( ) ; } @ Override public Adapter caseExportAttribute ( ExportAttribute object ) { return createExportAttributeAdapter ( ) ; } @ Override public Adapter caseResource ( Resource object ) { return createResourceAdapter ( ) ; } @ Override public Adapter caseResourceAttribute ( ResourceAttribute object ) { return createResourceAttributeAdapter ( ) ; } @ Override public Adapter caseAllocate ( Allocate object ) { return createAllocateAdapter ( ) ; } @ Override public Adapter caseAllocateResource ( AllocateResource object ) { return createAllocateResourceAdapter ( ) ; } @ Override public Adapter caseAllocateResourceAttribute ( AllocateResourceAttribute object ) { return createAllocateResourceAttributeAdapter ( ) ; } @ Override public Adapter caseNavigator ( Navigator object ) { return createNavigatorAdapter ( ) ; } @ Override public Adapter caseNavigatorAttribute ( NavigatorAttribute object ) { return createNavigatorAttributeAdapter ( ) ; } @ Override public Adapter caseNewTask ( NewTask object ) { return createNewTaskAdapter ( ) ; } @ Override public Adapter caseNewTaskAttribute ( NewTaskAttribute object ) { return createNewTaskAttributeAdapter ( ) ; } @ Override public Adapter caseNikuReport ( NikuReport object ) { return createNikuReportAdapter ( ) ; } @ Override public Adapter caseNikuReportAttribute ( NikuReportAttribute object ) { return createNikuReportAttributeAdapter ( ) ; } @ Override public Adapter caseAlert ( Alert object ) { return createAlertAdapter ( ) ; } @ Override public Adapter caseAlternative ( Alternative object ) { return createAlternativeAdapter ( ) ; } @ Override public Adapter caseAuthor ( Author object ) { return createAuthorAdapter ( ) ; } @ Override public Adapter caseBalance ( Balance object ) { return createBalanceAdapter ( ) ; } @ Override public Adapter caseBooking ( Booking object ) { return createBookingAdapter ( ) ; } @ Override public", "gt": "Adapter caseBookingTask ( BookingTask object )", "prediction": "Adapter caseBookingAttribute ( BookingAttribute object )\n", "label": 0}
{"id": 16294, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . core . HashOperations ; import org . springframework . data . redis . core . RedisTemplate ; import static org . mockito . Matchers . anyCollection ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisHashTest extends RedisTestSupport { private RedisTemplate redisTemplate ; private HashOperations hashOperations ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { when ( redisTemplate . opsForHash ( ) ) . thenReturn ( hashOperations ) ; JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; hashOperations = mock ( HashOperations . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteHDEL ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"HDEL\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" ) ; verify ( hashOperations ) . delete ( \"key\" , \"field\" ) ; } @ Test public void shouldExecuteHEXISTS ( ) throws Exception { when ( hashOperations . hasKey ( anyString ( ) , anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HEXISTS\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" ) ; verify ( hashOperations ) . hasKey ( \"key\" , \"field\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteHINCRBY ( ) throws Exception { when ( hashOperations . increment ( anyString ( ) , anyString ( ) , anyLong ( ) ) ) . thenReturn ( 1L ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HINCRBY\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" , RedisConstants .", "gt": "VALUE , \"1\" ) ;", "prediction": "VALUE ) ;\n", "label": 1}
{"id": 5903, "input": "<s> package com . example . tutorial . batch ; import com . asakusafw . testdriver . BatchTestDriver ; import org . junit . Test ; public class TutorialBatchTest { @", "gt": "Test public void testExample ( ) throws Throwable", "prediction": "Before public void setUp ( ) throws Exception\n", "label": 0}
{"id": 16305, "input": "<s> package fr . inria . zvtm . engine ; import java . awt . AWTEvent ; import java . awt . event . AWTEventListener ; import java . awt . event . WindowEvent ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import java . util . Vector ; import java . util . Collections ; import javax . swing . JMenuBar ; import javax . swing . JPanel ; import javax . swing . JFrame ; import fr . inria . zvtm . animation . AnimationManager ; import fr . inria . zvtm . event . RepaintListener ; import fr . inria . zvtm . engine . portals . Portal ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . VText ; public class VirtualSpaceManager implements AWTEventListener { public void onMainFontUpdated ( ) { for ( int i = 0 ; i < allViews . length ; i ++ ) { allViews [ i ] . updateFont ( ) ; } Object g ; for ( Enumeration < VirtualSpace > e = allVirtualSpaces . elements ( ) ; e . hasMoreElements ( ) ; ) { for ( Enumeration e2 = e . nextElement ( ) . getAllGlyphs ( ) . elements ( ) ; e2 . hasMoreElements ( ) ; ) { g = e2 . nextElement ( ) ; if ( g instanceof VText ) { ( ( VText ) g ) . invalidate ( ) ; } } } repaint ( ) ; } public static short VIS_AND_SENS_GLYPHS = 0 ; public static short VISIBLE_GLYPHS = 1 ; public static short SENSITIVE_GLYPHS = 2 ; public static short ALL_GLYPHS = 3 ; static boolean debug = false ; protected Hashtable < String , VirtualSpace > allVirtualSpaces ; private List < VirtualSpace > virtualSpaceList ; protected View [ ] allViews ; protected Hashtable < String , Integer > name2viewIndex ; View activeView ; protected int activeViewIndex = - 1 ; boolean defaultMultiFill = false ; private final AnimationManager animationManager ; public static final VirtualSpaceManager INSTANCE = new VirtualSpaceManager ( ) ; private VirtualSpaceManager ( ) { if ( debug ) { System . out . println ( \"Debug mode ON\" ) ; } animationManager = new AnimationManager ( this ) ; allVirtualSpaces = new Hashtable < String , VirtualSpace > ( ) ; virtualSpaceList = new ArrayList ( 0 ) ; allViews = new View [ 0 ] ; name2viewIndex = new Hashtable < String , Integer > ( ) ; } public static void setDebug ( boolean b ) { debug = b ; } public static boolean debugModeON ( ) { return debug ; } public AnimationManager getAnimationManager ( ) { return animationManager ; } public void setDefaultDetectMultiFills ( boolean b ) { defaultMultiFill = b ; } public boolean getDefaultDetectMultiFills ( ) { return defaultMultiFill ; } Object activeJFrame = null ; public void eventDispatched ( AWTEvent e ) { if ( e . getID ( ) == WindowEvent . WINDOW_ACTIVATED ) { activeJFrame = e . getSource ( ) ; } } public void setActiveView ( View v ) { activeView = v ; if ( v != null ) { activeViewIndex = getViewIndex ( v . getName ( ) ) ; } else { activeViewIndex = - 1 ; } } public View getActiveView ( ) { return activeView ; }", "gt": "public Camera getActiveCamera ( )", "prediction": "public void setActiveView ( View v )\n", "label": 1}
{"id": 8819, "input": "<s> import java . util . Collections ; import java . util . List ; public class Test < A , B > { private List < A > getRelated ( B b ) { return Collections . emptyList ( ) ; } public < L extends List < ? super A > > L", "gt": "addOrCreate ( B b , L l )", "prediction": "getRelated ( L l )\n", "label": 0}
{"id": 16307, "input": "<s> package org . restlet . ext . velocity ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import org . apache . commons . collections . ExtendedProperties ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . resource . Resource ; import org . apache . velocity . runtime . resource . loader . ResourceLoader ; import org . restlet . representation . Representation ; public class RepresentationResourceLoader extends ResourceLoader { private static final Map < String , Representation > store = new ConcurrentHashMap < String , Representation > ( ) ; public static Map < String , Representation > getStore ( ) { return store ; } private final Representation defaultRepresentation ; public RepresentationResourceLoader ( Representation defaultRepresentation ) { this . defaultRepresentation = defaultRepresentation ; } @ Override public long getLastModified ( Resource resource ) { final Representation original = getStore ( ) . get ( resource . getName ( ) ) ; return ( original != null ) ? original . getModificationDate ( ) . getTime ( ) : 0 ; } @ Override public InputStream getResourceStream ( String name ) throws ResourceNotFoundException { InputStream result = null ; try { Representation resultRepresentation = getStore ( ) . get ( name ) ; if ( resultRepresentation == null ) { resultRepresentation = this . defaultRepresentation ; if ( resultRepresentation == null ) { throw new ResourceNotFoundException ( \"Could not locate resource '\" + name + \"'\" ) ; }", "gt": "result = resultRepresentation . getStream ( ) ;", "prediction": "}\n", "label": 1}
{"id": 4725, "input": "<s> package com . gisgraphy . client . nameformatters ; import com . gisgraphy . client . commons . NamePart ; import com . google . common . collect . ImmutableList ; public class VeryShortQualifiedNamesExtractor implements NamesExtractor { public ImmutableList < String > extractNames ( ImmutableList < NamePart > nameParts ) { if ( nameParts . size ( ) < 2 ) { throw new IllegalArgumentException ( \"There should be at least 2 NameParts : a Country and a name\" ) ; } return ImmutableList . of ( countryName ( nameParts ) , featureName ( nameParts ) ) ; } private String featureName ( ImmutableList < NamePart > nameParts ) { return nameParts . get ( nameParts . size ( ) - 1 ) . getName ( ) ; } private String", "gt": "countryName ( ImmutableList < NamePart > nameParts )", "prediction": "featureName ( ImmutableList < NamePart > nameParts )\n", "label": 0}
{"id": 16309, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec5 . sub2 ; import java . io . IOException ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . ext . jackson . JacksonRepresentation ; import org . restlet . ext . xstream . XstreamRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; public class MailServerResource extends ServerResource { @ Override protected void doInit ( ) throws ResourceException { getVariants ( ) . add ( new Variant ( MediaType . APPLICATION_XML ) ) ; getVariants ( ) . add ( new Variant ( MediaType . APPLICATION_JSON ) ) ; } @ Override protected Representation get ( Variant variant ) throws ResourceException { Representation result = null ; Mail mail = new Mail ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( ) . toString ( ) ) ; if ( MediaType . APPLICATION_XML . isCompatible ( variant . getMediaType ( ) ) ) { result = new XstreamRepresentation < Mail > ( mail ) ; } else if ( MediaType . APPLICATION_JSON . isCompatible ( variant . getMediaType ( ) ) ) { result = new JacksonRepresentation < Mail > ( mail ) ; } return result ; } @ Override protected Representation put ( Representation representation , Variant variant ) throws ResourceException { Mail mail = null ; try { if ( MediaType . APPLICATION_XML . isCompatible ( representation . getMediaType ( ) ) ) { mail = new XstreamRepresentation < Mail > ( representation , Mail . class ) . getObject ( ) ; System . out . println ( \"XML representation received\" ) ; } else if ( MediaType . APPLICATION_JSON . isCompatible ( representation . getMediaType ( ) ) ) { mail = new JacksonRepresentation < Mail > ( representation , Mail . class ) . getObject ( ) ; System . out . println ( \"JSON representation received\" ) ; } if ( mail != null ) { System . out . println (", "gt": "\"Status: \" + mail . getStatus ( ) ) ;", "prediction": "mail . toString ( ) ) ;\n", "label": 1}
{"id": 2910, "input": "<s> package com . sun . tools . javac . file ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import com . sun . tools . javac . util . Context ; public class CacheFSInfo extends FSInfo { public static void preRegister ( Context context ) { context . put ( FSInfo . class , new Context . Factory < FSInfo > ( ) { public FSInfo make ( Context c ) { FSInfo instance = new CacheFSInfo ( ) ; c . put ( FSInfo . class , instance ) ; return instance ; } } ) ; } public void clearCache ( ) { cache . clear ( ) ; } @ Override public File getCanonicalFile ( File file ) { Entry e = getEntry ( file ) ; return e . canonicalFile ; } @ Override public boolean exists ( File file ) { Entry e = getEntry ( file ) ; return e . exists ; } @ Override public boolean isDirectory ( File file ) { Entry e = getEntry ( file ) ; return e . isDirectory ; } @ Override public boolean isFile ( File file ) { Entry e = getEntry ( file ) ; return e . isFile ; } @ Override public List < File > getJarClassPath ( File file ) throws IOException { Entry e = getEntry ( file ) ; if ( e . jarClassPath == null ) e . jarClassPath = super", "gt": ". getJarClassPath ( file ) ;", "prediction": ". getJarClassPath ( file ) ;\n", "label": 0}
{"id": 16327, "input": "<s> package com . cloudera . sqoop . metastore ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . tool . SqoopTool ; public class JobData extends org . apache . sqoop . metastore . JobData { public JobData ( ) { super ( ) ; } public JobData", "gt": "( SqoopOptions options , SqoopTool sqoopTool )", "prediction": "( String name )\n", "label": 1}
