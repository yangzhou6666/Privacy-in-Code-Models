{"id": 8293, "input": "<s> package org . dawb . workbench . plotting . system ; import java . util . Collection ; import java . util . HashSet ; import org . csstudio . swt . xygraph . dataprovider . IDataProvider ; import org . csstudio . swt . xygraph . dataprovider . IDataProviderListener ; import org . csstudio . swt . xygraph . dataprovider . ISample ; import org . csstudio . swt . xygraph . dataprovider . Sample ; import org . csstudio . swt . xygraph . linearscale . Range ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . DatasetUtils ; import uk . ac . diamond . scisoft . analysis . dataset . DoubleDataset ; public class LightWeightDataProvider implements IDataProvider { private AbstractDataset x ; private AbstractDataset y ; private Range cachedXRange , cachedYRange ; public LightWeightDataProvider ( ) { } public LightWeightDataProvider ( final AbstractDataset x , final AbstractDataset y ) { this . x = x ; this . y = y ; } @ Override public int getSize ( ) { if ( y == null ) return 0 ; if ( y . getShape ( ) == null || y . getShape ( ) . length < 1 ) return 0 ; return y . getSize ( ) ; } @ Override public ISample getSample ( int index ) { if ( x == null || y == null ) return null ; try { final double xDat = x . getElementDoubleAbs ( index ) ; final double yDat = y . getElementDoubleAbs ( index ) ; return new Sample ( xDat , yDat ) ; } catch ( Throwable ne ) { return null ; } } @ Override public Range getXDataMinMax ( ) { if ( x == null ) return new Range ( 0 , 100 ) ; if ( cachedXRange != null ) return cachedXRange ; try { cachedXRange = new Range ( getMin ( x ) , getMax ( x ) ) ; return cachedXRange ; } catch ( Throwable ne ) { return new Range ( 0 , 100 ) ; } } @ Override public Range getYDataMinMax ( ) { if ( y == null ) return new Range ( 0 , 100 ) ; if ( cachedYRange != null ) return cachedYRange ; try { cachedYRange = new Range ( getMin ( y ) , getMax ( y ) ) ; return cachedYRange ; } catch ( Throwable ne ) { return new Range ( 0 , 100 ) ; } } private double getMin ( AbstractDataset a ) { return a . min ( true ) . doubleValue ( ) ; } private double getMax ( AbstractDataset a ) { return a . max ( true ) . doubleValue ( ) ; } @ Override public boolean isChronological ( ) { return false ; } private Collection < IDataProviderListener > listeners ; @ Override public void addDataProviderListener ( IDataProviderListener listener ) { if ( listeners == null ) listeners = new HashSet < IDataProviderListener > ( ) ; listeners . add ( listener ) ; } @ Override public boolean removeDataProviderListener ( IDataProviderListener listener ) { if ( listeners == null ) return false ; return listeners . remove ( listener ) ; } public void setData ( AbstractDataset xData , AbstractDataset yData ) { this . x = xData ; this . y = yData ; this . cachedXRange = null ; this . cachedYRange = null ; fireDataProviderListeners ( ) ; } private void fireDataProviderListeners ( ) { if ( listeners == null ) return ; for ( IDataProviderListener l : listeners ) { l . dataChanged ( this ) ; } } public AbstractDataset getY ( ) { return y ; } public AbstractDataset getX ( ) { return x ; } public void append ( Number xValue , Number yValue ) { final double [ ] xArray = x != null && x . getShape ( ) != null && x . getShape ( ) . length > 0 ? ( double [ ] ) DatasetUtils . cast ( x , AbstractDataset . FLOAT64 ) . getBuffer ( ) : new double [ 0 ] ; final double [ ] yArray = y != null && y . getShape ( ) != null && y . getShape ( ) . length > 0 ? ( double [ ] ) DatasetUtils . cast ( y , AbstractDataset . FLOAT64 ) . getBuffer ( ) : new double [ 0 ] ; final double [ ] xa = new double [ xArray .", "gt": "length + 1 ] ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 8, "input": "<s> package org . spliffy . server . apps . versions ; import org . spliffy . server . web . Services ; import", "gt": "org . spliffy . server . web . SpliffyCollectionResource ;", "prediction": ";\n", "label": 1}
{"id": 944, "input": "<s> package com . b3rwynmobile . fayeclient ; public class FayeHeartbeatThread extends Thread { private int delay ; private FayeClient client ; public FayeHeartbeatThread ( FayeClient client ) { super ( ) ; this . client = client ; } @ Override public void run ( ) { int sleepCount = 0 ;", "gt": "while ( sleepCount < delay )", "prediction": "}\n", "label": 0}
{"id": 13, "input": "<s> package com . talis . hbase . rdf . layout . hybrid ; import java . util . Iterator ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . FmtLayout ; public class FmtLayoutHybrid extends FmtLayout { public FmtLayoutHybrid ( String storeName , HBaseRdfConnection connection ) { super ( storeName , connection ) ; } @ Override protected void formatTables ( ) { try { Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while (", "gt": "iterTblNames . hasNext ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 1827, "input": "<s> package org . ofbiz . common . preferences ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import static org . ofbiz . base . util . UtilGenerics . checkMap ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; public class PreferenceServices { public static final String module = PreferenceServices . class . getName ( ) ; public static final String resource = \"PrefErrorUiLabels\" ; public static Map < String , Object > getUserPreference ( DispatchContext ctx , Map < String , ? > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( ! PreferenceWorker . isValidGetId ( ctx , context ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.permissionError\" , locale ) ) ; } Delegator delegator = ctx . getDelegator ( ) ; String userPrefTypeId = ( String ) context . get ( \"userPrefTypeId\" ) ; if ( UtilValidate . isEmpty ( userPrefTypeId ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.invalidArgument\" , locale ) ) ; } String userLoginId = PreferenceWorker . getUserLoginId ( context , true ) ; Map < String , String > fieldMap = UtilMisc . toMap ( \"userLoginId\" , userLoginId , \"userPrefTypeId\" , userPrefTypeId ) ; String userPrefGroupTypeId = ( String ) context . get ( \"userPrefGroupTypeId\" ) ; if ( UtilValidate . isNotEmpty ( userPrefGroupTypeId ) ) { fieldMap . put ( \"userPrefGroupTypeId\" , userPrefGroupTypeId ) ; } Map < String , Object > userPrefMap = null ; try { GenericValue preference = EntityUtil . getFirst ( delegator . findByAnd ( \"UserPreference\" , fieldMap , null , true ) ) ; if ( preference != null ) { userPrefMap = PreferenceWorker . createUserPrefMap ( preference ) ; } } catch ( GenericEntityException e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.readFailure\" , new Object [ ] { e . getMessage ( ) } , locale ) ) ; } catch ( GeneralException e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.readFailure\" , new Object [ ] { e . getMessage ( ) } , locale ) ) ; } Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"userPrefMap\" , userPrefMap ) ; if ( userPrefMap != null ) { Object userPrefValue = userPrefMap . get ( userPrefTypeId ) ; if ( userPrefValue != null ) { result . put ( \"userPrefValue\" , userPrefValue ) ; } } return result ; } public static Map < String , Object > getUserPreferenceGroup ( DispatchContext ctx , Map < String , ? > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( ! PreferenceWorker . isValidGetId ( ctx , context ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.permissionError\" , locale ) ) ; } Delegator delegator = ctx . getDelegator ( ) ; String userPrefGroupTypeId = ( String ) context . get ( \"userPrefGroupTypeId\" ) ; if ( UtilValidate . isEmpty ( userPrefGroupTypeId ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"getPreference.invalidArgument\" , locale ) ) ; } String userLoginId = PreferenceWorker . getUserLoginId ( context , false ) ; Map < String , Object > userPrefMap = null ; try { Map < String , String > fieldMap = UtilMisc . toMap ( \"userLoginId\" , \"_NA_\" ,", "gt": "\"userPrefGroupTypeId\" , userPrefGroupTypeId ) ;", "prediction": ") ;\n", "label": 0}
{"id": 20, "input": "<s> package org . restlet . ext . rdf ; import org . restlet . engine . util . SystemUtils ; public class Triple < T , U , V > { private volatile T first ; private volatile U second ; private volatile V third ; public Triple ( T first , U second , V third ) { this . first = first ; this . second = second ; this . third = third ; } @ Override public boolean equals ( Object other ) { boolean result = ( this == other ) ; if ( ! result && ( other instanceof Triple ) ) { Triple < ? , ? , ? > triple = ( Triple < ? , ? , ? > ) other ; if ( ( ( triple . getFirst ( ) == null ) && ( getFirst ( ) == null ) ) || ( ( getFirst ( ) != null ) && getFirst ( ) . equals ( triple . getFirst ( ) ) ) ) { if ( ( ( triple . getSecond ( ) == null ) && ( getSecond ( ) == null ) ) || ( ( getSecond ( ) != null ) && getSecond ( ) . equals", "gt": "( triple . getSecond ( ) ) ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 8674, "input": "<s> package b ; public class B { public", "gt": "a . A a ;", "prediction": "( ) ;\n", "label": 0}
{"id": 35, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . ArrayList ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TextCellEditor ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . TreeColumn ; public class Bug201002TreeViewerTest extends ViewerTestCase { public class MyModel { public MyModel parent ; public ArrayList child = new ArrayList ( ) ; public int counter ; public MyModel ( int counter , MyModel parent ) { this . parent = parent ; this . counter = counter ; } public String toString ( ) { String rv = \"Item \" ; if ( parent != null ) { rv = parent . toString ( ) + \".\" ; } rv += counter ; return rv ; } } public Bug201002TreeViewerTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { final TreeViewer treeViewer = new TreeViewer ( parent , SWT . FULL_SELECTION ) ; treeViewer . setContentProvider ( new ITreeContentProvider ( ) { public Object [ ] getElements ( Object inputElement ) { return ( ( MyModel ) inputElement ) . child . toArray ( ) ; } public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } public Object [ ] getChildren ( Object parentElement ) { return getElements ( parentElement ) ; } public Object getParent ( Object element ) { if ( element == null ) { return null ; } return ( ( MyModel ) element ) . parent ; } public boolean hasChildren ( Object element ) { return ( ( MyModel ) element ) . child . size ( ) > 0 ; } } ) ; treeViewer . setCellEditors ( new CellEditor [ ] { new TextCellEditor ( treeViewer . getTree ( ) ) } ) ; treeViewer . setColumnProperties ( new String [ ] { \"0\" } ) ; treeViewer . setCellModifier ( new ICellModifier ( ) { public boolean canModify ( Object element , String property ) { return true ; } public Object getValue ( Object element , String property ) { return \"\" ; } public void modify ( Object element , String property , Object value ) { } } ) ; new TreeColumn ( treeViewer . getTree ( ) , SWT . NONE ) . setWidth ( 200 ) ; return treeViewer ; } protected void setUpModel ( ) { } protected void setInput ( ) { MyModel root = new MyModel ( 0 , null ) ; root . counter = 0 ; MyModel tmp ; for ( int i = 1 ; i < 100 ; i ++ ) { tmp = new MyModel ( i , root ) ; root . child . add ( tmp ) ; for ( int j = 1 ; j < i ; j ++ ) { tmp . child . add", "gt": "( new MyModel ( j , tmp ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3873, "input": "<s> package opens . components . samples ; import java . util . LinkedList ; import java . util . List ; import org . apache . http . HttpResponse ; import org . json . JSONArray ; import org . json . JSONObject ; import opens . components . cache . FileCache ; import opens . components . http . HttpObjectRequest ; import opens . components . http . core . RequestQueue ; import android . app . Activity ; import android . os . Bundle ; import android . util . Log ; import android . widget . TextView ; public class SampleAppActivity extends Activity { public class TwitterTimelineRequest extends HttpObjectRequest < List < String > > { @ Override protected void onHttpResponseReceived ( HttpResponse response ) throws Exception { JSONArray jTimeline = getJSONArray ( response ) ; List < String > timeline = new LinkedList < String > ( ) ; for ( int i = 0 ; i < jTimeline . length ( ) ; i ++ ) { JSONObject element = jTimeline . getJSONObject ( i ) ; timeline . add ( element . getString ( \"text\" ) ) ; } setResponseObject ( timeline ) ; } } @ SuppressWarnings ( \"unused\" ) private void onTimelineRequestSuccess ( TwitterTimelineRequest request ) { List < String > timeline = request . getResponseObject ( ) ; TextView text = ( TextView ) findViewById ( R . id . text ) ; text . setText ( timeline . toString ( ) ) ; Log . d ( \"HTTP_REQUSEST\" , timeline .", "gt": "toString ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 44, "input": "<s> package org . eclipse . swt . internal . widgets . tabfolderkit ; import org . eclipse . rap . rwt . internal . theme . QxBoxDimensions ; import org . eclipse . rap . rwt . internal . theme . QxType ; import org . eclipse . rap . rwt . internal . theme . SimpleSelector ; import org . eclipse . rap . rwt . internal . theme . ThemeUtil ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . controlkit . ControlThemeAdapter ; import org . eclipse .", "gt": "swt . widgets . TabFolder ;", "prediction": ";\n", "label": 1}
{"id": 2773, "input": "<s> package org . gk . ui . client . com . grid . column ; import java . util . Date ; import org . gk . ui . client . com . form . gkDateField ; import org . gk . ui . client . com . utils . DateTimeUtils ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . CellEditor ; import com . extjs . gxt . ui . client . widget . grid . Grid ; public abstract class gkDateColumnConfig extends gkCellColumnConfig { public gkDateColumnConfig ( gkColumnInfo field ) { super ( field ) ; } @ Override protected Field createField ( ) { return new gkDateField ( ) { @ Override public void focus ( ) { if ( rendered ) { getFocusEl ( ) . focus ( ) ; onFocus ( new FieldEvent ( this ) ) ; } if ( ! hasFocus ) { fireEvent ( Events . Focus ) ; } } @ Override public void setFieldLabel ( String fieldLabel ) { super . setFieldLabel ( fieldLabel ) ; setHeader ( fieldLabel ) ; } @ Override protected void blur ( ) { if ( rendered ) { getFocusEl ( ) . blur ( ) ; } if ( hasFocus ) { fireEvent ( Events . Blur ) ; hasFocus = false ; } } } ; } @ Override protected CellEditor createCellEditor ( ) { final gkDateField df = ( gkDateField ) createField ( ) ; addListener ( df ) ; onField ( df ) ; return new CellEditor ( df ) { @ Override public String getDisplayValue ( Object value ) { if ( value != null && ! value . toString ( ) . equals ( \"\" ) ) { DateTimeUtils . setValue ( df , value . toString ( ) ) ; return df . getPropertyEditor ( ) . getStringValue ( df . getValue ( ) ) ; } return super . getDisplayValue ( value ) ; } @ Override protected void onBlur ( FieldEvent fe ) { if ( df . getDatePicker ( ) . isAttached ( ) ) { return ; } else { super . onBlur ( fe ) ; } } @ Override public Object preProcessValue ( Object value ) { if ( value == null || value . toString ( ) . equals ( \"\" ) ) { return null ; } DateTimeUtils . setValue ( df , value + \"\" ) ; return df . getValue ( ) ; } @ Override public Object postProcessValue ( Object value ) { if ( value == null ) { return \"\" ; }", "gt": "return DateTimeUtils . formatDate ( ( Date ) value ) ;", "prediction": "}\n", "label": 0}
{"id": 45, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; abstract class TermsHashConsumerPerThread { abstract void startDocument ( ) throws IOException ; abstract DocumentsWriter", "gt": ". DocWriter finishDocument ( ) throws IOException ;", "prediction": "\n", "label": 1}
{"id": 640, "input": "<s> class T6747671 < E > { static class B < X > { } class A < X > { class X { } class Z < Y > { } } A . X x1 ; A . Z z1 ; T6747671 . B < Integer > b1 ; T6747671 . B b2 ; A < String > . X x2 ; A < String > . Z < Integer > z2 ; A < B > . Z <", "gt": "A < B > > z3 ;", "prediction": ") ;\n", "label": 0}
{"id": 55, "input": "<s> package knowevo . myvizster . ui ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Toolkit ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . net . URL ; import java . util . Properties ; import javax . swing . Box ; import javax . swing . BoxLayout ; import javax . swing . ImageIcon ; import javax . swing . JButton ; import javax . swing . JComponent ; import javax . swing . JDialog ; import javax . swing . JLabel ; import javax . swing . JPasswordField ; import javax . swing . JTextField ; import javax . swing . SwingConstants ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . util . DBConnectAction ; public class LoginDialog extends JDialog { private static final int LABELW = 75 ; private static final int FIELDW = 200 ; private Vizster vizster ; private JLabel failL ; private JTextField curFields [ ] ; private boolean login = false ; public LoginDialog ( Vizster owner ) { super ( owner , \"Vizster Login\" , true ) ; vizster = owner ; curFields = null ; initUI ( ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; Dimension dialogSize = this . getPreferredSize ( ) ; setLocation ( screenSize . width / 2 - ( dialogSize . width / 2 ) , screenSize . height / 2 - ( dialogSize . height / 2 ) ) ; screenSize = dialogSize = null ; } private void initUI ( ) { getContentPane ( ) . setBackground ( Color . WHITE ) ; URL logoU = LoginDialog . class . getResource ( \"logo.png\" ) ; ImageIcon logoI = new ImageIcon ( logoU , \"Vizster Logo\" ) ; Dimension d = new Dimension ( LABELW + FIELDW , logoI . getIconHeight ( ) ) ; JLabel logoL = new JLabel ( logoI ) ; logoL . setIconTextGap ( 0 ) ; logoL . setPreferredSize ( d ) ; logoL . setMaximumSize ( d ) ; Box l = new Box ( BoxLayout . X_AXIS ) ; l . add ( logoL ) ; l . setPreferredSize ( d ) ; l . setMaximumSize ( d ) ; failL = new JLabel ( \"    \" , SwingConstants . CENTER ) ; failL . setForeground ( Color . RED ) ; d = new Dimension ( LABELW + FIELDW , 15 ) ; failL . setPreferredSize ( d ) ; failL . setMaximumSize ( d ) ; Box f = new Box ( BoxLayout . X_AXIS ) ; f . add ( Box . createHorizontalGlue ( ) ) ; f . add ( failL ) ; f . add ( Box . createHorizontalGlue ( ) ) ; f . setPreferredSize ( d ) ; f . setMaximumSize ( d ) ; JLabel inputL = new JLabel ( \"Login:\" , SwingConstants . RIGHT ) ; JLabel passwL = new JLabel ( \"Password:\" , SwingConstants . RIGHT ) ; JLabel dbhostL = new JLabel ( \"DB URL:\" , SwingConstants . RIGHT ) ; JLabel dbnameL = new JLabel ( \"DB Name:\" , SwingConstants . RIGHT ) ; String [ ] defs = loadLoginProperties ( ) ; JTextField inputF = new JTextField ( defs [ 0 ] ) ; JTextField passwF = new JPasswordField ( defs [ 1 ] ) ; JTextField dbhostF = new JTextField ( defs [ 2 ] ) ; JTextField dbnameF = new JTextField ( defs [ 3 ] ) ; curFields = new JTextField [ ] { inputF , passwF , dbhostF , dbnameF } ; final JButton loginB = new JButton ( \"Login\" ) ; final JButton cancelB = new JButton ( \"Cancel\" ) ; ActionListener al = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { LoginDialog . this . setVisible ( false ) ; } } ; loginB . addActionListener ( new DBConnectAction ( this ) ) ; cancelB . addActionListener ( al ) ; Box b = new Box ( BoxLayout . X_AXIS ) ; b . add ( Box . createHorizontalGlue ( ) ) ; b . add ( loginB ) ; b . add ( Box . createHorizontalStrut ( 5 ) ) ;", "gt": "b . add ( cancelB ) ;", "prediction": "}\n", "label": 1}
{"id": 8185, "input": "<s> class DUTry { void foo ( ) { int c = 1 ; int a = 3 ; final int a1 ; try { if ( a == 3 ) throw new Exception ( ) ; } catch ( Throwable e ) { System . out . println ( e ) ; a1 = 6 ; System", "gt": ". out . println ( a1 ) ;", "prediction": ";\n", "label": 0}
{"id": 61, "input": "<s> package org . nuxeo . ecm . platform . relations ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . GraphDescription ; import org . nuxeo . ecm .", "gt": "platform . relations . api . GraphFactory ;", "prediction": ";\n", "label": 1}
{"id": 8015, "input": "<s> package LizaCraft . Entity ; import org . bukkit . Art ; import org . bukkit . block . BlockFace ; import org . bukkit . entity . Painting ; import Liza . LizaPainting ; public class LizaCraftPainting extends LizaCraftEntity implements LizaPainting { public LizaCraftPainting ( Painting painting ) { super ( painting ) ; } @ Override public Painting getBukkitHandle ( ) { return ( Painting ) this . entity ; } @ Override public Art getArt ( ) { return this . getBukkitHandle ( ) . getArt ( ) ; } @ Override public boolean setArt ( Art art ) { return this . getBukkitHandle ( ) . setArt ( art ) ; } @ Override public boolean setArt ( Art", "gt": "art , boolean force )", "prediction": ")\n", "label": 0}
{"id": 62, "input": "<s> package org . apache . sqoop . manager ; import com . cloudera . sqoop . SqoopOptions ; public class ExportJobContext { private String tableName ; private String jarFile ; private SqoopOptions options ; private ConnManager manager ; public ExportJobContext ( final String table , final String jar , final SqoopOptions opts ) { this . tableName = table ; this . jarFile = jar ; this . options = opts ; } public String getTableName ( ) { return tableName ; } public String getJarFile ( ) { return jarFile ; } public SqoopOptions getOptions ( ) { return options ; } public void", "gt": "setConnManager ( ConnManager mgr )", "prediction": "( )\n", "label": 1}
{"id": 4996, "input": "<s> package org . ofbiz . entityext . synchronization ; import java . io . IOException ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . serialize . SerializeException ; import org . ofbiz . entity . serialize . XmlSerializer ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entityext . EntityGroupUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GeneralServiceException ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . xml . sax . SAXException ; public class EntitySyncContext { public static final String module = EntitySyncContext . class . getName ( ) ; public static final long defaultSyncSplitMillis = 10000 ; public static final long defaultOfflineSyncSplitMillis = 1800000 ; public static final long defaultSyncEndBufferMillis = 300000 ; public static final long defaultMaxRunningNoUpdateMillis = 7200000 ; public Delegator delegator ; public LocalDispatcher dispatcher ; public Map < String , ? extends Object > context ; public GenericValue userLogin ; public boolean isOfflineSync = false ; public String entitySyncId ; public GenericValue entitySync ; public String targetServiceName ; public String targetDelegatorName ; public Timestamp syncEndStamp ; public long offlineSyncSplitMillis = defaultOfflineSyncSplitMillis ; public long syncSplitMillis = defaultSyncSplitMillis ; public long syncEndBufferMillis = defaultSyncEndBufferMillis ; public long maxRunningNoUpdateMillis = defaultMaxRunningNoUpdateMillis ; public Timestamp lastSuccessfulSynchTime ; public List < ModelEntity > entityModelToUseList ; public Set < String > entityNameToUseSet ; public Timestamp currentRunStartTime ; public Timestamp currentRunEndTime ; public Map < String , Timestamp > nextEntityCreateTxTime = FastMap . newInstance ( ) ; public Map < String , Timestamp > nextEntityUpdateTxTime = FastMap . newInstance ( ) ; public Timestamp nextCreateTxTime = null ; public Timestamp nextUpdateTxTime = null ; public Timestamp nextRemoveTxTime = null ; public Timestamp startDate = null ; long toCreateInserted = 0 ; long toCreateUpdated = 0 ; long toCreateNotUpdated = 0 ; long toStoreInserted = 0 ; long toStoreUpdated = 0 ; long toStoreNotUpdated = 0 ; long toRemoveDeleted = 0 ; long toRemoveAlreadyDeleted = 0 ; long totalRowsExported = 0 ; long totalRowsToCreate = 0 ; long totalRowsToStore = 0 ; long totalRowsToRemove = 0 ; long totalRowsPerSplit = 0 ; long totalStoreCalls = 0 ; long totalSplits = 0 ; long perSplitMinMillis = Long . MAX_VALUE ; long perSplitMaxMillis = 0 ; long perSplitMinItems = Long . MAX_VALUE ; long perSplitMaxItems = 0 ; long splitStartTime = 0 ; public EntitySyncContext ( DispatchContext dctx , Map < String , ? extends Object > context ) throws SyncDataErrorException , SyncAbortException { this . context = context ; this . dispatcher = dctx . getDispatcher ( ) ; this . delegator = dctx . getDelegator ( ) ; String delegatorName = ( String ) context . get ( \"delegatorName\" ) ; if ( UtilValidate . isNotEmpty ( delegatorName ) ) { this . delegator = DelegatorFactory . getDelegator ( delegatorName ) ; } this . userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; this . entitySyncId = ( String ) context . get ( \"entitySyncId\" ) ; Debug . logInfo ( \"Creating EntitySyncContext with entitySyncId=\" + entitySyncId , module ) ; boolean beganTransaction = false ; try { beganTransaction = TransactionUtil . begin ( 7200 ) ; } catch ( GenericTransactionException e ) { throw new SyncDataErrorException ( \"Unable to begin JTA", "gt": "transaction\" , e ) ;", "prediction": ") ;\n", "label": 0}
{"id": 97, "input": "<s> package org . apache . lucene . analysis ; import org . apache . lucene . util . NumericUtils ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . analysis . tokenattributes . TypeAttribute ; public class TestNumericTokenStream extends BaseTokenStreamTestCase { static final long lvalue = 4573245871874382L ; static final int ivalue = 123456 ; public void testLongStream ( ) throws Exception { final NumericTokenStream stream = new NumericTokenStream ( ) . setLongValue ( lvalue ) ; final TermAttribute termAtt = ( TermAttribute ) stream . getAttribute ( TermAttribute . class ) ; final TypeAttribute typeAtt = ( TypeAttribute ) stream . getAttribute ( TypeAttribute . class ) ; for ( int shift = 0 ; shift < 64 ; shift += NumericUtils . PRECISION_STEP_DEFAULT ) { assertTrue ( \"New token is available\" , stream . incrementToken ( ) ) ; assertEquals ( \"Term is correctly encoded\" , NumericUtils . longToPrefixCoded ( lvalue , shift ) , termAtt . term ( ) ) ; assertEquals ( \"Type correct\" , ( shift == 0 ) ? NumericTokenStream . TOKEN_TYPE_FULL_PREC : NumericTokenStream . TOKEN_TYPE_LOWER_PREC , typeAtt . type ( ) ) ; } assertFalse ( \"No more tokens available\" , stream . incrementToken ( ) ) ; } public void testIntStream ( ) throws Exception { final NumericTokenStream stream = new NumericTokenStream ( ) . setIntValue ( ivalue ) ; final TermAttribute termAtt = ( TermAttribute ) stream . getAttribute ( TermAttribute . class ) ; final TypeAttribute typeAtt = ( TypeAttribute ) stream . getAttribute ( TypeAttribute . class ) ; for ( int shift = 0 ; shift < 32 ; shift += NumericUtils . PRECISION_STEP_DEFAULT ) { assertTrue ( \"New token is available\" , stream . incrementToken ( ) ) ; assertEquals ( \"Term is correctly encoded\" , NumericUtils . intToPrefixCoded ( ivalue , shift ) , termAtt . term ( ) ) ; assertEquals ( \"Type correct\" , ( shift == 0 ) ? NumericTokenStream . TOKEN_TYPE_FULL_PREC : NumericTokenStream . TOKEN_TYPE_LOWER_PREC , typeAtt . type ( ) ) ; } assertFalse ( \"No more tokens available\" , stream . incrementToken ( ) ) ; } public void testNotInitialized ( ) throws Exception { final NumericTokenStream stream = new NumericTokenStream ( ) ; try { stream . reset ( ) ; fail", "gt": "( \"reset() should not succeed.\" ) ;", "prediction": "}\n", "label": 1}
{"id": 2163, "input": "<s> package ar . com . fdvs . dj . test . crosstab ; import java . awt . Color ; import java . util . Date ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . CrosstabBuilder ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . test . BaseDjReportTest ; import ar . com . fdvs . dj . test . TestRepositoryProducts ; import ar . com . fdvs . dj . util . SortUtils ; public class CrosstabReportTest5 extends BaseDjReportTest { private Style totalHeaderStyle ; private Style colAndRowHeaderStyle ; private Style mainHeaderStyle ; private Style totalStyle ; private Style measureStyle ; private Style measureStyle2 ; private Style titleStyle ; public DynamicReport buildReport ( ) throws Exception { initStyles ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setPrintColumnNames ( false ) . setUseFullPageWidth ( true ) . setDefaultStyles ( titleStyle , null , null , null ) ; DJCrosstab djcross = new CrosstabBuilder ( ) . setHeight ( 200 ) . setWidth ( 500 ) . setHeaderStyle ( mainHeaderStyle ) . setDatasource ( \"sr\" , DJConstants . DATA_SOURCE_ORIGIN_PARAMETER , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) . setUseFullWidth ( true ) . setColorScheme ( DJConstants . COLOR_SCHEMA_GRAY ) . setAutomaticTitle ( true ) . setCellBorder ( Border . PEN_1_POINT ) . addRow ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , false ) . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , false ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , true ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , true ) . addMeasure ( \"id\" , Long . class . getName ( ) , DJCalculation . SUM , \"Id\" , measureStyle ) . addMeasure ( \"amount\" , Float . class . getName ( ) , DJCalculation . SUM , \"Amount\" , measureStyle2 ) . setRowStyles ( colAndRowHeaderStyle , totalStyle , totalHeaderStyle ) . setColumnStyles ( colAndRowHeaderStyle , totalStyle , totalHeaderStyle ) . setCellDimension ( 34 , 60 ) . setColumnHeaderHeight ( 30 ) . setRowHeaderWidth ( 80 ) . build ( ) ; drb . addHeaderCrosstab ( djcross ) ; DynamicReport dr = drb . build ( ) ; params . put ( \"sr\" , SortUtils . sortCollection ( TestRepositoryProducts . getDummyCollection ( ) , djcross ) ) ; return dr ; } private void initStyles ( ) { titleStyle = new StyleBuilder ( false ) . setFont ( Font . ARIAL_BIG_BOLD ) . setHorizontalAlign ( HorizontalAlign . LEFT ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setTransparency ( Transparency . OPAQUE ) . setBorderBottom ( Border . PEN_2_POINT ) . build ( ) ; totalHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . setTextColor ( Color . BLUE ) . build ( ) ; colAndRowHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . LEFT ) . setVerticalAlign ( VerticalAlign . TOP ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . build ( ) ; mainHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setFont ( Font . ARIAL_BIG_BOLD ) . setTextColor ( Color . BLACK ) . build ( ) ; totalStyle = new StyleBuilder ( false ) . setPattern ( \"#,###.##\" ) . setHorizontalAlign ( HorizontalAlign . RIGHT ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . build ( ) ; measureStyle = new StyleBuilder ( false ) . setPattern ( \"#,###.##\" ) . setHorizontalAlign ( HorizontalAlign . RIGHT ) . setFont ( Font . ARIAL_MEDIUM ) . build ( ) ; measureStyle2 = new StyleBuilder ( false ) . setPattern ( \"#,###.##\" ) . setHorizontalAlign ( HorizontalAlign . RIGHT ) . setFont ( new Font ( Font . MEDIUM , Font . _FONT_ARIAL , false , true , false ) ) . setTextColor ( Color . RED ) . build ( ) ; } public static void main ( String", "gt": "[ ] args ) throws Exception", "prediction": ")\n", "label": 0}
{"id": 133, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class ObjectActionContributorManager extends ObjectContributorManager { public ObjectActionContributorManager ( ) { super ( ) ; loadContributors ( ) ; } public boolean contributeObjectActions ( IWorkbenchPart part , IMenuManager popupMenu , ISelectionProvider selProv ) { ISelection selection = selProv . getSelection ( ) ; if ( selection == null ) { return false ; } List elements = null ; if ( selection instanceof IStructuredSelection ) { elements = ( ( IStructuredSelection ) selection ) . toList ( ) ; } else { elements = new ArrayList ( 1 ) ; elements . add ( selection ) ; } List contributors = getContributors ( elements ) ; if ( contributors . isEmpty ( ) ) { return false ; } boolean actualContributions = false ; ArrayList overrides = new ArrayList ( 4 ) ; for ( Iterator it = contributors . iterator ( ) ; it . hasNext ( ) ; ) { IObjectActionContributor contributor = ( IObjectActionContributor ) it . next ( ) ; if ( ! isApplicableTo ( elements , contributor ) ) { it . remove ( ) ; continue ; } if ( contributor . contributeObjectMenus ( popupMenu , selProv ) ) { actualContributions = true ; } contributor . contributeObjectActionIdOverrides ( overrides ) ; } for ( Iterator it = contributors . iterator ( ) ; it . hasNext ( ) ; ) { IObjectActionContributor contributor = ( IObjectActionContributor ) it . next ( ) ; if ( contributor . contributeObjectActions ( part , popupMenu , selProv , overrides ) ) { actualContributions = true ; } } return actualContributions ; }", "gt": "public static ObjectActionContributorManager getManager ( )", "prediction": "}\n", "label": 1}
{"id": 7490, "input": "<s> class T7013865 { public < X extends Number > void m ( X ... args ) { } public void m", "gt": "( Object ... args )", "prediction": "( )\n", "label": 0}
{"id": 135, "input": "<s> package com . cloudera . sqoop . hive ; public final class HiveTypes { private HiveTypes ( ) { } public static String toHiveType ( int sqlType ) { return org . apache . sqoop . hive . HiveTypes . toHiveType ( sqlType ) ; } public static boolean isHiveTypeImprovised ( int sqlType ) { return org . apache . sqoop . hive", "gt": ". HiveTypes . isHiveTypeImprovised ( sqlType ) ;", "prediction": ";\n", "label": 1}
{"id": 2911, "input": "<s> package org . ofbiz . product . inventory ; import java . math . BigDecimal ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityOperator ; public class InventoryWorker { public final static String module = InventoryWorker . class . getName ( ) ; public static List < GenericValue > getOutstandingPurchaseOrders ( String productId , Delegator delegator ) { try { List < EntityCondition > purchaseOrderConditions = UtilMisc . < EntityCondition > toList ( EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_COMPLETED\" ) , EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_CANCELLED\" ) , EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_REJECTED\" ) , EntityCondition . makeCondition ( \"itemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_COMPLETED\" ) , EntityCondition . makeCondition ( \"itemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_CANCELLED\" ) , EntityCondition . makeCondition ( \"itemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_REJECTED\" ) ) ; purchaseOrderConditions . add ( EntityCondition . makeCondition ( \"orderTypeId\" , EntityOperator . EQUALS , \"PURCHASE_ORDER\" ) ) ; purchaseOrderConditions . add ( EntityCondition . makeCondition ( \"productId\" , EntityOperator . EQUALS , productId ) ) ; List < GenericValue > purchaseOrders = delegator . findList ( \"OrderHeaderAndItems\" , EntityCondition . makeCondition ( purchaseOrderConditions , EntityOperator . AND ) , null , UtilMisc . toList ( \"estimatedDeliveryDate DESC\" , \"orderDate\" ) , null , false ) ; return purchaseOrders ; } catch ( GenericEntityException ex ) { Debug . logError ( \"Unable to find outstanding purchase orders for product [\" + productId + \"] due to \" + ex . getMessage ( ) + \" - returning null\" , module ) ; return null ; } } public static BigDecimal getOutstandingPurchasedQuantity ( String productId , Delegator delegator ) { BigDecimal qty = BigDecimal . ZERO ; List < GenericValue > purchaseOrders = getOutstandingPurchaseOrders ( productId , delegator ) ; if ( UtilValidate . isEmpty ( purchaseOrders ) ) { return qty ; } else { for ( GenericValue nextOrder : purchaseOrders ) { if ( nextOrder . get ( \"quantity\" ) != null ) { BigDecimal itemQuantity = nextOrder . getBigDecimal ( \"quantity\" ) ; BigDecimal cancelQuantity = BigDecimal . ZERO ; if ( nextOrder . get ( \"cancelQuantity\" ) != null ) { cancelQuantity = nextOrder . getBigDecimal ( \"cancelQuantity\" ) ; } itemQuantity = itemQuantity . subtract ( cancelQuantity ) ; if ( itemQuantity . compareTo ( BigDecimal . ZERO ) >= 0 ) { qty = qty . add ( itemQuantity ) ; } } } } return qty ; } public static Map < String , BigDecimal > getOutstandingProductQuantities ( Collection < String > productIds , String orderTypeId , Delegator delegator ) { Set < String > fieldsToSelect = UtilMisc . toSet ( \"productId\" , \"quantityOpen\" ) ; List < EntityCondition > condList = UtilMisc . < EntityCondition > toList ( EntityCondition . makeCondition ( \"orderTypeId\" , EntityOperator . EQUALS , orderTypeId ) , EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_COMPLETED\" ) , EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_REJECTED\" ) , EntityCondition . makeCondition ( \"orderStatusId\" , EntityOperator . NOT_EQUAL , \"ORDER_CANCELLED\" ) ) ; if ( productIds . size ( ) > 0 ) { condList . add ( EntityCondition . makeCondition ( \"productId\" , EntityOperator . IN , productIds ) ) ; } condList . add ( EntityCondition . makeCondition ( \"orderItemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_COMPLETED\" ) ) ; condList . add ( EntityCondition . makeCondition ( \"orderItemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_REJECTED\" ) ) ; condList . add ( EntityCondition . makeCondition ( \"orderItemStatusId\" , EntityOperator . NOT_EQUAL , \"ITEM_CANCELLED\" ) ) ; EntityConditionList < EntityCondition > conditions = EntityCondition . makeCondition ( condList , EntityOperator . AND ) ; Map < String , BigDecimal > results =", "gt": "FastMap . newInstance ( ) ;", "prediction": ";\n", "label": 0}
{"id": 138, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . core . databinding . property . value . DelegatingValueProperty ; import org . eclipse . jface . databinding . swt . ISWTObservableValue ; import org . eclipse . jface . databinding . swt . IWidgetValueProperty ; import org . eclipse . jface . databinding . swt . SWTObservables ; import org . eclipse . swt . widgets . Widget ; abstract class WidgetDelegatingValueProperty extends DelegatingValueProperty implements IWidgetValueProperty { RuntimeException notSupported ( Object source ) { return new IllegalArgumentException ( \"Widget [\" + source . getClass ( ) . getName ( ) + \"] is not supported.\" ) ; } public WidgetDelegatingValueProperty ( ) { } public WidgetDelegatingValueProperty ( Object valueType ) { super ( valueType ) ; } public", "gt": "ISWTObservableValue observe ( Widget widget )", "prediction": "}\n", "label": 1}
{"id": 7892, "input": "<s> package ar . com . fdvs . dj . test . properties ; import java . util . Date ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class DynamicPropertiesReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 , true ) . addGroups ( 2 ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setProperty ( \"myProp1\" , \"my propery 1\" ) . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; return dr ; } protected void exportReport ( ) throws Exception { assertTrue ( jr . getPropertiesMap ( ) . getPropertyNames ( ) . length > 0 ) ; } public static void main ( String [", "gt": "] args ) throws Exception", "prediction": ")\n", "label": 0}
{"id": 140, "input": "<s> package org . eclipse . ui . internal . decorators ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . internal . ObjectContributorManager ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . internal . util . Util ; public class LightweightDecoratorManager extends ObjectContributorManager { private class LightweightRunnable implements ISafeRunnable { private Object element ; private DecorationBuilder decoration ; private LightweightDecoratorDefinition decorator ; void setValues ( Object object , DecorationBuilder builder , LightweightDecoratorDefinition definition ) { element = object ; decoration = builder ; decorator = definition ; } public void handleException ( Throwable exception ) { IStatus status = StatusUtil . newStatus ( IStatus . ERROR , exception . getMessage ( ) , exception ) ; String message ; if ( decorator == null ) { message = WorkbenchMessages . get ( ) . DecoratorError ; } else { message = NLS . bind ( WorkbenchMessages . get ( ) . DecoratorWillBeDisabled , decorator . getName ( ) ) ; } WorkbenchPlugin . log ( message , status ) ; if ( decorator != null ) { decorator . crashDisable ( ) ; } clearReferences ( ) ; } public void run ( ) throws Exception { decorator . decorate ( element , decoration ) ; clearReferences ( ) ; } void clearReferences ( ) { decorator = null ; element = null ; decoration = null ; } } private LightweightRunnable runnable = new LightweightRunnable ( ) ; private LightweightDecoratorDefinition [ ] lightweightDefinitions ; private static final LightweightDecoratorDefinition [ ] EMPTY_LIGHTWEIGHT_DEF = new LightweightDecoratorDefinition [ 0 ] ; LightweightDecoratorManager ( LightweightDecoratorDefinition [ ] definitions ) { super ( ) ; lightweightDefinitions = definitions ; buildContributors ( ) ; } LightweightDecoratorDefinition [ ] getDefinitions ( ) { return lightweightDefinitions ; } private void buildContributors ( ) { for ( int i = 0 ; i < lightweightDefinitions . length ; i ++ ) { LightweightDecoratorDefinition decorator = lightweightDefinitions [ i ] ; String [ ] types = getTargetTypes ( decorator ) ; for ( int j = 0 ; j < types . length ; j ++ ) { registerContributor ( decorator , types [ j ] ) ; } } } public boolean addDecorator ( LightweightDecoratorDefinition decorator ) { if ( getLightweightDecoratorDefinition ( decorator . getId ( ) ) == null ) { LightweightDecoratorDefinition [ ] oldDefs = lightweightDefinitions ; lightweightDefinitions = new LightweightDecoratorDefinition [ lightweightDefinitions . length + 1 ] ; System . arraycopy ( oldDefs , 0 , lightweightDefinitions , 0 , oldDefs . length ) ; lightweightDefinitions [ oldDefs . length ] = decorator ; String [ ] types = getTargetTypes ( decorator ) ; for ( int i = 0 ; i < types . length ; i ++ ) { registerContributor ( decorator , types [ i ] ) ; } return true ; } return false ; } private String [ ] getTargetTypes ( LightweightDecoratorDefinition decorator ) { return decorator . getObjectClasses ( ) ; } public boolean removeDecorator ( LightweightDecoratorDefinition decorator ) { int idx = getLightweightDecoratorDefinitionIdx ( decorator . getId ( ) ) ; if ( idx != - 1 ) { LightweightDecoratorDefinition [ ] oldDefs = lightweightDefinitions ; Util . arrayCopyWithRemoval ( oldDefs , lightweightDefinitions = new LightweightDecoratorDefinition [ lightweightDefinitions", "gt": ". length - 1 ] , idx ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9950, "input": "<s> package com . matburt . mobileorg . test . OrgData ; import android . database . Cursor ; import android . test . ProviderTestCase2 ; import android . test . mock . MockContentResolver ; import com . matburt . mobileorg . OrgData . OrgDatabase ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProvider ; import com . matburt . mobileorg . OrgData . OrgContract . OrgData ; import com . matburt . mobileorg . test . util . OrgTestUtils ; import com . matburt . mobileorg . util . OrgNodeNotFoundException ; public class OrgDatabaseTest extends ProviderTestCase2 < OrgProvider > { private MockContentResolver resolver ; private OrgDatabase db ; public OrgDatabaseTest ( ) { super ( OrgProvider . class , OrgProvider . class . getName ( ) ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; this . resolver = getMockContentResolver ( ) ; this . db = new OrgDatabase ( getMockContext ( ) ) ; } @ Override protected void tearDown ( ) throws Exception { this . db . close ( ) ; } public void testNodeEquals ( ) { OrgNode node1 = OrgTestUtils . getDefaultOrgNode ( ) ; OrgNode node2 = OrgTestUtils . getDefaultOrgNode ( ) ; node1 . fileId = 300 ; node1 . parentId = 400 ; node1 . level = 3 ; node1 . id = 1000 ; assertTrue ( node1 . equals ( node2 ) ) ; node1 . name = \"hej\" ; assertFalse ( node1 . equals ( node2 ) ) ; } public void testFastInsertNodeSimple ( ) { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; long id = db . fastInsertNode ( node ) ; Cursor cursor = resolver . query ( OrgData . buildIdUri ( id ) , OrgData . DEFAULT_COLUMNS , null , null , null ) ; assertNotNull ( cursor ) ; assertEquals ( 1 , cursor . getCount ( ) ) ; assertTrue ( cursor . getColumnCount ( ) > 0 ) ; OrgNode insertedNode = new OrgNode ( ) ; try { insertedNode . set ( cursor ) ; } catch ( OrgNodeNotFoundException e ) { } cursor . close ( ) ; assertEquals ( \"\" , insertedNode . getPayload ( ) ) ; insertedNode . setPayload ( \"\" ) ; assertTrue ( node . equals ( insertedNode ) ) ; } public void testFastInsertNodePayloadSimple ( ) { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; long id = db . fastInsertNode ( node ) ; final String testPayload = \"this is a test payload\" ; db . fastInsertNodePayload ( id , testPayload ) ; Cursor cursor = resolver . query ( OrgData . buildIdUri ( Long . toString ( id ) ) , OrgData . DEFAULT_COLUMNS , null , null , null ) ; assertNotNull ( cursor ) ; assertEquals ( 1 , cursor . getCount ( ) ) ; assertTrue ( cursor . getColumnCount ( ) > 0 ) ; OrgNode insertedNode = new OrgNode ( ) ; try { insertedNode . set ( cursor ) ; } catch ( OrgNodeNotFoundException e ) { } cursor . close ( ) ; assertEquals ( testPayload , insertedNode . getPayload ( ) ) ; } public void testFastInsertNodePayloadUpdate ( ) { final String testPayload = \"second payload\" ; OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; long id = db . fastInsertNode ( node ) ; db . fastInsertNodePayload (", "gt": "id , \"first payload\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 142, "input": "<s> package Rio ; import java . io . PrintStream ; import java . util . HashMap ; import java . util . Random ; import edu . washington . cs . cse490h . lib . Callback ; import edu . washington . cs . cse490h . lib . Utility ; public class RIOTester extends RIONode { public static double getFailureRate ( ) { return 0 / 100.0 ; } public static double getDropRate ( ) { return 25 / 100.0 ; } public static double getDelayRate ( ) { return 50 / 100.0 ; } private HashMap < Integer , Integer > receivedNums ; private HashMap < Integer , Integer > nextNum ; private Random randNumGen ; private int numFinished ; public static int NUM_NODES = 10 ; private boolean failed = false ; @ Override public String packetBytesToString ( byte [ ] bytes ) { RIOPacket packet = RIOPacket . unpack ( bytes ) ; if ( packet == null ) { return super . packetBytesToString ( bytes ) ; } return packet . toString ( ) ; } @ Override public void start ( ) { logOutput ( \"Starting up...\" ) ; logSynopticEvent ( \"started\" ) ; receivedNums = new HashMap < Integer , Integer > ( ) ; nextNum = new HashMap < Integer , Integer > ( ) ; randNumGen = new Random ( ) ; numFinished = 0 ; } @ Override public void onCommand ( String command ) { if ( command . equals ( \"begin\" ) ) { for ( int i = 0 ; i < RIOTester . NUM_NODES ; ++ i ) { nextNum . put ( i , 0 ) ; } sendNextNum ( ) ; } return ; } @ Override public void onRIOReceive ( Integer from , int protocol , byte [ ] msg ) { if ( protocol != Protocol . RIOTEST_PKT ) { logError ( \"unknown protocol: \" + protocol ) ; return ; } Integer i = Integer . parseInt ( Utility . byteArrayToString ( msg ) ) ; Integer receivedNum = receivedNums . get ( from ) ; if ( receivedNum == null ) { if ( i == 0 ) { correctReceive ( from , 0 ) ; } else { failure ( from , i ) ; } } else { if ( i == receivedNum + 1 ) { correctReceive ( from , i ) ; } else { failure ( from , i ) ; } } } public void correctReceive ( int from , int i ) { logOutput ( \"Correctly Received \" + i + \" from \" + from ) ; receivedNums . put (", "gt": "from , i ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4186, "input": "<s> package de . javawi . jstun . attribute ; import de . javawi . jstun . util . Utility ; import de . javawi . jstun . util . UtilityException ; public class ErrorCode extends MessageAttribute { int responseCode ; String reason ; public ErrorCode ( ) { super ( MessageAttribute . MessageAttributeType . ErrorCode ) ; } public void setResponseCode ( int responseCode ) throws MessageAttributeException { switch ( responseCode ) { case 400 : reason = \"Bad Request\" ; break ; case 401 : reason = \"Unauthorized\" ; break ; case 420 : reason = \"Unkown Attribute\" ; break ; case 430 : reason = \"Stale Credentials\" ; break ; case 431 : reason = \"Integrity Check Failure\" ; break ; case 432 : reason = \"Missing Username\" ; break ; case 433 : reason = \"Use TLS\" ; break ; case 500 : reason = \"Server Error\" ; break ; case 600 : reason = \"Global Failure\" ; break ; default : throw new MessageAttributeException ( \"Response Code is not valid\" ) ; } this . responseCode = responseCode ; } public int getResponseCode ( ) { return responseCode ; } public String getReason ( ) { return reason ; } public byte [ ] getBytes ( ) throws UtilityException { int length = reason . length ( ) ; if ( ( length % 4 ) != 0 ) { length += 4 - ( length % 4 ) ; } length += 4 ; byte [ ] result = new byte [ length ] ; System . arraycopy ( Utility . integerToTwoBytes ( typeToInteger ( type ) ) , 0 , result , 0 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( length - 4 ) , 0 , result , 2 , 2 ) ; int classHeader = ( int ) Math . floor ( ( ( double ) responseCode ) / 100 ) ; result [ 6 ] = Utility . integerToOneByte ( classHeader ) ; result [ 7 ] = Utility . integerToOneByte ( responseCode % 100 ) ; byte [ ] reasonArray = reason . getBytes ( ) ; System . arraycopy ( reasonArray , 0 , result , 8 , reasonArray . length ) ; return result ; } public static ErrorCode parse ( byte [ ] data ) throws MessageAttributeParsingException { try { if ( data . length < 4 ) { throw new", "gt": "MessageAttributeParsingException ( \"Data array too short\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 160, "input": "<s> package org . apache . sqoop . tool ; import java . io . IOException ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . ResultSetMetaData ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . Types ; import java . util . List ; import java . util . Map ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . cli . OptionBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . util . StringUtils ; import com . cloudera . sqoop . Sqoop ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . cli . RelatedOptions ; import com . cloudera . sqoop . cli . ToolOptions ; import com . cloudera . sqoop . hive . HiveImport ; import com . cloudera . sqoop . manager . ImportJobContext ; import com . cloudera . sqoop . metastore . JobData ; import com . cloudera . sqoop . metastore . JobStorage ; import com . cloudera . sqoop . metastore . JobStorageFactory ; import com . cloudera . sqoop . util . AppendUtils ; import com . cloudera . sqoop . util . ImportException ; import org . apache . hadoop . fs . Path ; public class ImportTool extends com . cloudera . sqoop . tool . BaseSqoopTool { public static final Log LOG = LogFactory . getLog ( ImportTool . class . getName ( ) ) ; private CodeGenTool codeGenerator ; private boolean allTables ; private int checkColumnType ; public ImportTool ( ) { this ( \"import\" , false ) ; } public ImportTool ( String toolName , boolean allTables ) { super ( toolName ) ; this . codeGenerator = new CodeGenTool ( ) ; this . allTables = allTables ; } @ Override protected boolean init ( SqoopOptions sqoopOpts ) { boolean ret = super . init ( sqoopOpts ) ; codeGenerator . setManager ( manager ) ; return ret ; } public List < String > getGeneratedJarFiles ( ) { return this . codeGenerator . getGeneratedJarFiles ( ) ; } private boolean isIncremental ( SqoopOptions options ) { return ! options . getIncrementalMode ( ) . equals ( SqoopOptions . IncrementalMode . None ) ; }", "gt": "private void saveIncrementalState ( SqoopOptions options ) throws IOException", "prediction": "}\n", "label": 1}
{"id": 9961, "input": "<s> class T6910550c { void m ( Object [ ] x ) { } void m ( Object ... x ) { } { m ( ) ; } { m ( null ) ; } {", "gt": "m ( null , null ) ;", "prediction": "}\n", "label": 0}
{"id": 168, "input": "<s> package org . nuxeo . ecm . platform . relations . api . impl ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . relations . api . Node ; import org . nuxeo . ecm . platform . relations . api . QueryResult ; public class TestQueryResult { @ Test public void testInit ( ) { List < String > variableNames = new ArrayList < String > ( ) ; variableNames . add ( \"subject\" ) ; variableNames . add ( \"object\" ) ; List < Map < String , Node > > results = new ArrayList < Map < String , Node > > ( ) ; Map < String , Node > res1 = new HashMap < String , Node > ( ) ; res1 . put ( \"subject\" , new ResourceImpl ( \"http://toto\" ) ) ; res1 . put ( \"object\" , new ResourceImpl ( \"http://titi\" ) ) ; results . add ( res1 ) ; Map < String , Node > res2 = new HashMap < String , Node > ( ) ; res2 . put ( \"subject\" , new ResourceImpl ( \"http://toto\" ) ) ; res2 . put ( \"object\" , new LiteralImpl ( \"lalala\" ) ) ; results . add ( res2 ) ; Integer count = 2 ; QueryResult qr = new QueryResultImpl ( count , variableNames , results ) ; assertSame ( qr . getCount (", "gt": ") , 2 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 305, "input": "<s> package com . farpost . ldt ; public class TaskPrepareFailedException extends RuntimeException { public TaskPrepareFailedException ( Exception cause ) {", "gt": "super ( cause ) ;", "prediction": "\n", "label": 0}
{"id": 169, "input": "<s> package org . jscsi . utils ; public final class SerialArithmeticNumber implements Comparable < Integer > { private static final long MAXIMUM_VALUE = 0xFFFFFFFFL ; private long serialNumber ; public SerialArithmeticNumber ( ) { } public SerialArithmeticNumber ( final int startValue ) { if ( startValue < 0 || startValue > MAXIMUM_VALUE ) { throw new IllegalArgumentException ( startValue + \" is out of range.\" ) ; } serialNumber = startValue ; } public final int compareTo ( final int anotherSerialNumber ) { return compareTo ( new Integer ( anotherSerialNumber ) ) ; } public final synchronized int compareTo ( final Integer anotherSerialNumber ) { long diff = serialNumber - Utils . getUnsignedLong ( anotherSerialNumber . intValue ( ) ) ; if ( diff >= MAXIMUM_VALUE ) { diff -= ( MAXIMUM_VALUE + 1 ) ; } else if ( diff < - MAXIMUM_VALUE ) { diff += ( MAXIMUM_VALUE + 1 ) ; } return ( int ) diff ; } public", "gt": "final synchronized int getValue ( )", "prediction": "}\n", "label": 1}
{"id": 9083, "input": "<s> package com . asakusafw . example . jdbc . jobflow ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . CategorySummary ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ErrorRecord ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ItemInfo ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . SalesDetail ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . StoreInfo ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . CheckStore ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . JoinItemInfo ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . SetErrorMessage ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . SummarizeByCategory ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; @ JobFlow ( name = \"byCategory\" ) public class CategorySummaryJob extends FlowDescription { final In < SalesDetail > salesDetail ; final In < StoreInfo > storeInfo ; final In < ItemInfo > itemInfo ; final Out < CategorySummary > categorySummary ; final Out < ErrorRecord > errorRecord ; public CategorySummaryJob ( @ Import ( name = \"salesDetail\" , description = SalesDetailFromJdbc . class ) In < SalesDetail > salesDetail , @ Import ( name = \"storeInfo\" , description = StoreInfoFromJdbc . class ) In < StoreInfo > storeInfo , @ Import ( name = \"itemInfo\" , description = ItemInfoFromJdbc . class ) In < ItemInfo > itemInfo , @ Export ( name = \"categorySummary\" , description = CategorySummaryToJdbc . class ) Out < CategorySummary > categorySummary , @ Export ( name = \"errorRecord\" , description = ErrorRecordToJdbc . class ) Out < ErrorRecord > errorRecord ) { this . salesDetail = salesDetail ; this . storeInfo = storeInfo ; this . itemInfo = itemInfo ; this . categorySummary = categorySummary ; this . errorRecord = errorRecord ; } @ Override protected void describe ( ) { CoreOperatorFactory core =", "gt": "new CoreOperatorFactory ( ) ;", "prediction": ";\n", "label": 0}
{"id": 184, "input": "<s> package org . apache . sqoop . util ; @ SuppressWarnings ( \"serial\" ) public class ExitSecurityException extends SecurityException { private final int exitStatus ; public ExitSecurityException ( ) { super ( \"ExitSecurityException\" ) ; this . exitStatus = 0 ; } public ExitSecurityException ( final String message ) { super ( message ) ; this . exitStatus = 0 ; } public ExitSecurityException ( int status ) {", "gt": "super ( \"ExitSecurityException\" ) ;", "prediction": "}\n", "label": 1}
{"id": 3758, "input": "<s> package next . interfaces . controller . widgets ; import next . i . view . XBarItem . Type ; import next . i . view . XNavigationBar ; import next . interfaces . controller . GitXController ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . user . client . ui . VerticalPanel ; public class NavigationBarController extends GitXController { public NavigationBarController ( ) { setTitle ( \"Navigation Bar\" ) ; } @ Override public IsWidget getViewContent ( ) { VerticalPanel panel = new VerticalPanel ( ) ; panel . setWidth ( \"100%\" ) ; panel . getElement ( ) . getStyle ( ) . setProperty ( \"background\" , \"#f8f8f8\" ) ; panel . getElement ( ) . getStyle ( ) . setProperty ( \"padding\" , \"40px 20px\" ) ; XNavigationBar bar1 = new XNavigationBar ( ) ; bar1 . setTitle ( \"Bar One\" ) ; bar1 . getElement ( ) . getStyle ( ) . setProperty ( \"height\" , \"30px\" ) ; panel . add ( bar1 ) ; panel . add ( new HTML ( \"&nbsp;\" ) ) ; XNavigationBar bar2 = new XNavigationBar ( ) ; bar2 . setLeftTitle ( \"Back\" , Type . BACK_BUTTON ) ; bar2 . getLeftButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { Window . alert ( \"Back was tapped.\" ) ; } } ) ; bar2 . setTitle ( \"Bar Two\" ) ; panel . add ( bar2 ) ; panel . add ( new HTML ( \"&nbsp;\" ) ) ; XNavigationBar bar3 = new XNavigationBar ( ) ; bar3 . setTitle ( \"Bar Three\" ) ; bar3 . getElement ( ) . getStyle ( ) . setProperty ( \"height\" , \"60px\" ) ; bar3 . setLeftTitle ( \"Edit\" , Type . BUTTON ) ; bar3 . getLeftButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { Window . alert ( \"Edit was tapped.\" ) ; } } ) ; bar3 . setRightTitle ( \"Done\" ) ; bar3 . getRightButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { Window . alert ( \"Done was tapped.\" ) ; } } ) ;", "gt": "panel . add ( bar3 ) ;", "prediction": "}\n", "label": 0}
{"id": 187, "input": "<s> package org . nuxeo . ecm . virtualnavigation . action ; import static org . jboss . seam . ScopeType . CONVERSATION ; import static org . jboss . seam . annotations . Install . FRAMEWORK ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Install ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Observer ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . annotations . intercept . BypassInterceptors ; import org . jboss . seam . core . Events ; import org . nuxeo . ecm . core . api . impl . DocumentModelImpl ; import org . nuxeo . ecm . virtualnavigation . service . NavTreeService ; import org . nuxeo . ecm . webapp . directory . DirectoryTreeManager ; import org . nuxeo . ecm . webapp . helpers . EventNames ; import org . nuxeo . ecm . webapp . seam . NuxeoSeamHotReloader ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"multiNavTreeManager\" ) @ Scope ( CONVERSATION ) @ Install ( precedence = FRAMEWORK ) public class MultiNavTreeManager implements Serializable { private static final long serialVersionUID = 1L ; public static final String STD_NAV_TREE = \"CONTENT_TREE\" ; public static final String STD_NAV_TREE_LABEL = \"label.content.tree\" ; protected List < NavTreeDescriptor > availableNavigationTrees ; protected Long availableNavigationTreesTimestamp ; protected String selectedNavigationTree ; protected String thePath = \"\" ; @ In ( required = false , create = true ) protected DirectoryTreeManager directoryTreeManager ; @ In ( create = true ) protected NuxeoSeamHotReloader seamReload ; @ In ( create = true ) protected Map < String , String > messages ; public List < NavTreeDescriptor > getAvailableNavigationTrees ( ) { if ( availableNavigationTrees == null || shouldResetCache ( ) ) { availableNavigationTrees = new ArrayList < NavTreeDescriptor > ( ) ; availableNavigationTrees . add ( new NavTreeDescriptor ( STD_NAV_TREE , STD_NAV_TREE_LABEL ) ) ; NavTreeService navTreeService = Framework . getLocalService ( NavTreeService . class ) ; availableNavigationTrees . addAll ( navTreeService . getTreeDescriptors ( ) ) ; availableNavigationTreesTimestamp = navTreeService . getLastModified ( ) ; } return availableNavigationTrees ; } protected boolean shouldResetCache ( ) { NavTreeService navTreeService = Framework . getLocalService ( NavTreeService . class ) ; if ( seamReload . isDevModeSet ( ) && seamReload . shouldResetCache ( navTreeService , availableNavigationTreesTimestamp ) ) { return true ; } return false ; } @ Factory ( value = \"selectedNavigationTree\" , scope = ScopeType . EVENT ) public String getSelectedNavigationTree ( ) { if ( selectedNavigationTree == null ) { setSelectedNavigationTree ( STD_NAV_TREE ) ; } return selectedNavigationTree ; } @ Factory ( value = \"selectedNavigationTreeDescriptor\" , scope = ScopeType . EVENT ) public NavTreeDescriptor getSelectedNavigationTreeDescriptor ( ) { String navTreeName = getSelectedNavigationTree ( ) ; for ( NavTreeDescriptor desc : getAvailableNavigationTrees ( ) ) { if ( desc . getTreeId ( ) . equals ( navTreeName ) ) { return desc ; } } return null ; } public", "gt": "void setSelectedNavigationTree ( String selectedNavigationTree )", "prediction": "}\n", "label": 1}
{"id": 1122, "input": "<s> package com . midtro . platform . modules . assets . task ; import java . util . Map ; import com . midtro . platform . modules . assets . Assembler ; import com . midtro . platform . modules . assets . Asset ; import com . midtro . platform . modules . assets . AssetConfig ; import com . midtro . platform . modules . assets . AssetManager ; import com . midtro . platform . modules . assets . IndexEntry ; import com . midtro . platform . modules . loader . LoadTask ; import com . midtro . platform . modules . loader . LoaderCallback ; public class AssetLoadTask implements LoadTask { private final AssetManager manager ; public AssetLoadTask ( AssetManager manager ) { this . manager = manager ; } @ Override public void execute ( LoaderCallback callback ) throws Exception { final Map < String , Asset < ? > > store = manager . getStore ( ) ; final AssetConfig config = manager . getConfig ( ) ; for ( IndexEntry entry : manager . getIndex ( ) ) { final Assembler assembler = manager . getAssemblers ( ) . get ( entry . getType ( ) ) ; if ( assembler == null ) { throw new Exception ( \"Assembler is not configured\" ) ; } assembler . assemble ( entry . getName ( ) , entry", "gt": ". getFileName ( ) , config , store ) ;", "prediction": ") ;\n", "label": 0}
{"id": 203, "input": "<s> package org . fuzzydb . util ; public abstract class BlockProcessor { int blockSize ; public BlockProcessor ( int blockSize ) { this . blockSize = blockSize ; } public void process ( int number ) { for ( int i = 0 ; i < number ; i ++ ) { everyTime ( i ) ; if ( i % blockSize == blockSize - 1 || i == number - 1 ) { everyBlock ( i ) ; } } blocksComplete ( ) ; }", "gt": "abstract public void everyTime ( int count ) ;", "prediction": "}\n", "label": 1}
{"id": 2591, "input": "<s> public class T5080917 { static interface I { } static class X { } static class A extends X implements I { } static class B extends X implements I { } void test ( A", "gt": "a , B b )", "prediction": ")\n", "label": 0}
{"id": 204, "input": "<s> package org . fuzzydb . server . internal . server . txlog ; import java . io . File ; import java . io . FileFilter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; public class TxLogIterator implements Iterable < File > { private final File txDir ; private final long startVersion ; private final boolean allowNonExact ; private class IteratorImpl implements Iterator < File > { private final ArrayList < File > ascendingCandidates = new ArrayList < File > ( ) ; private long highestVersionApplied = - 1 ; public IteratorImpl ( ) { FileFilter fileFilter = new FileFilter ( ) { public boolean accept ( File file ) { if ( file . isDirectory ( ) ) { return false ; } String filename = file . getName ( ) ; int index = filename . indexOf ( '_' ) ; return ( index >= 2 && filename . startsWith ( \"t\" ) ) ; } } ; Collections . addAll ( ascendingCandidates , txDir . listFiles ( fileFilter ) ) ; Collections . sort ( ascendingCandidates , TransactionFileNameComparator . getInstance ( ) ) ; } public boolean hasNext ( ) { return ascendingCandidates . size ( ) > 0 ; } public File next ( ) { if ( ascendingCandidates . size (", "gt": ") == 0 ) return null ;", "prediction": ") )\n", "label": 1}
{"id": 8767, "input": "<s> import com . sun . source . tree . * ; public class TreeKindTest { public static void main ( String ... args ) { boolean ok = true ; for ( Tree . Kind k : Tree . Kind . values ( ) ) { Class < ? extends Tree > i = k . asInterface ( ) ; switch ( k ) { case POSTFIX_INCREMENT : case POSTFIX_DECREMENT : case PREFIX_INCREMENT : case PREFIX_DECREMENT : case UNARY_PLUS : case UNARY_MINUS : case BITWISE_COMPLEMENT : case LOGICAL_COMPLEMENT : ok = ok & verify ( k , i , i == UnaryTree . class ) ; break ; case MULTIPLY : case DIVIDE : case REMAINDER : case PLUS : case MINUS : case LEFT_SHIFT : case RIGHT_SHIFT : case UNSIGNED_RIGHT_SHIFT : case LESS_THAN : case GREATER_THAN : case LESS_THAN_EQUAL : case GREATER_THAN_EQUAL : case EQUAL_TO : case NOT_EQUAL_TO : case AND : case XOR : case OR : case CONDITIONAL_AND : case CONDITIONAL_OR : ok = ok & verify ( k , i , i == BinaryTree . class ) ; break ; case MULTIPLY_ASSIGNMENT : case DIVIDE_ASSIGNMENT : case REMAINDER_ASSIGNMENT : case PLUS_ASSIGNMENT : case MINUS_ASSIGNMENT : case LEFT_SHIFT_ASSIGNMENT : case RIGHT_SHIFT_ASSIGNMENT : case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT : case AND_ASSIGNMENT : case XOR_ASSIGNMENT : case OR_ASSIGNMENT : ok = ok & verify ( k , i , i == CompoundAssignmentTree . class ) ; break ; case INT_LITERAL : case LONG_LITERAL : case FLOAT_LITERAL : case DOUBLE_LITERAL : case BOOLEAN_LITERAL : case CHAR_LITERAL : case STRING_LITERAL : case NULL_LITERAL : ok = ok & verify ( k , i , i == LiteralTree . class ) ; break ; case UNBOUNDED_WILDCARD : case EXTENDS_WILDCARD : case SUPER_WILDCARD : ok = ok & verify ( k , i , i == WildcardTree . class ) ; break ; case INTERFACE : case ANNOTATION_TYPE : case ENUM : case CLASS : ok = ok & verify ( k , i , i == ClassTree . class ) ; break ; case OTHER : ok = ok & verify ( k , i , i == null ) ; break ; default : String ks = k . toString ( ) . replace ( \"_\" , \"\" ) + \"tree\" ; String iName = i . getName ( ) ; String is = iName . substring ( iName .", "gt": "lastIndexOf ( \".\" ) + 1 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 207, "input": "<s> package org . eclipse . ui . internal . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . dialogs . PreferencesUtil ; import org . eclipse . ui . handlers . HandlerUtil ; public final class ShowPreferencePageHandler extends AbstractHandler { public final Object execute ( final ExecutionEvent event ) { final String preferencePageId = event . getParameter ( IWorkbenchCommandConstants . WINDOW_PREFERENCES_PARM_PAGEID ) ; final", "gt": "IWorkbenchWindow activeWorkbenchWindow = HandlerUtil . getActiveWorkbenchWindow ( event ) ;", "prediction": "}\n", "label": 1}
{"id": 7626, "input": "<s> import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import javax . tools . * ; import com . sun . source . tree . Tree ; import com . sun . source . util . TreeScanner ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCCompilationUnit ; import com . sun . tools . javac . tree . JCTree . TypeBoundKind ; import com . sun . tools . javac . util . List ; public class SourceTreeScannerTest extends AbstractTreeScannerTest { public static void main ( String ... args ) { String testSrc = System . getProperty ( \"test.src\" ) ; File baseDir = ( testSrc == null ) ? null : new File ( testSrc ) ; boolean ok = new SourceTreeScannerTest ( ) . run ( baseDir , args ) ; if ( ! ok ) { if ( testSrc != null ) throw new Error ( \"failed\" ) ; else System . exit ( 1 ) ; } } int test ( JCCompilationUnit tree ) { return new ScanTester ( ) . test ( tree ) ; } private class ScanTester extends TreeScanner < Void , Void > { int test ( JCCompilationUnit tree ) { sourcefile = tree . sourcefile ; found = new HashSet < Tree > ( ) ; scan ( tree , null ) ; expect = new HashSet < Tree > ( ) ; reflectiveScan ( tree ) ; if ( found . equals ( expect ) ) { return found . size ( ) ; } error ( sourcefile . getName ( ) + \": differences found\" ) ; if ( found . size ( ) != expect . size ( ) ) error ( \"Size mismatch; found: \" + found . size ( ) + \", expected: \" + expect . size ( ) ) ; Set < Tree > missing = new HashSet < Tree > ( ) ; missing . addAll ( expect ) ; missing . removeAll ( found ) ; for ( Tree t : missing ) error ( sourcefile , t , \"missing\" ) ; Set < Tree > excess = new HashSet < Tree > ( ) ; excess . addAll ( found ) ; excess . removeAll ( expect ) ; for ( Tree t : excess ) error ( sourcefile , t , \"unexpected\" ) ; return 0 ; } @ Override public Void scan ( Tree tree , Void ignore ) { if ( tree == null ) return null ; found . add ( tree ) ; return super . scan ( tree , ignore ) ; } public void reflectiveScan ( Object o ) { if ( o == null ) return ; if ( o instanceof JCTree ) { JCTree tree = ( JCTree ) o ; expect . add ( tree ) ; for ( Field f : getFields ( tree ) ) { if ( TypeBoundKind . class . isAssignableFrom ( f . getType ( ) ) ) { continue ; } if ( JCTree . JCNewArray . class . isAssignableFrom ( tree . getClass ( ) ) && ( f . getName ( ) . equals ( \"annotations\" ) || f . getName ( ) . equals ( \"dimAnnotations\" ) ) ) { continue ; } try { reflectiveScan ( f . get ( tree ) ) ; } catch ( IllegalAccessException e ) { error ( e . toString ( ) ) ; } } } else if ( o instanceof List ) { List < ? > list = ( List < ? > ) o ; for ( Object item : list ) reflectiveScan ( item ) ; } else error ( \"unexpected item: \" + o ) ; } JavaFileObject sourcefile ; Set < Tree > found ;", "gt": "Set < Tree > expect ;", "prediction": "}\n", "label": 0}
{"id": 213, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import java . io . PrintStream ; public class TestFieldCache extends LuceneTestCase { protected IndexReader reader ; private static final int NUM_DOCS = 1000 ; public TestFieldCache ( String s ) { super ( s ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; RAMDirectory directory = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( directory , new WhitespaceAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; long theLong = Long . MAX_VALUE ; double theDouble = Double . MAX_VALUE ; byte theByte = Byte . MAX_VALUE ; short theShort = Short . MAX_VALUE ; int theInt = Integer . MAX_VALUE ; float theFloat = Float . MAX_VALUE ; for ( int i = 0 ; i < NUM_DOCS ; i ++ ) { Document doc = new Document ( ) ; doc . add ( new Field ( \"theLong\" , String . valueOf ( theLong -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; doc . add ( new Field ( \"theDouble\" , String . valueOf ( theDouble -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; doc . add ( new Field ( \"theByte\" , String . valueOf ( theByte -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; doc . add ( new Field ( \"theShort\" , String . valueOf ( theShort -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; doc . add ( new Field ( \"theInt\" , String . valueOf ( theInt -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; doc . add ( new Field ( \"theFloat\" , String . valueOf ( theFloat -- ) , Field . Store . NO , Field . Index . NOT_ANALYZED ) ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; reader = IndexReader . open ( directory ) ; } public void testInfoStream ( ) throws Exception { try { FieldCache cache = FieldCache . DEFAULT ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( 1024 ) ; cache . setInfoStream ( new PrintStream ( bos ) ) ; double [ ]", "gt": "doubles = cache . getDoubles ( reader , \"theDouble\" ) ;", "prediction": ";\n", "label": 1}
{"id": 8154, "input": "<s> package com . sun . tools . javac ; import java . io . * ; import java . net . * ; import java . util . * ; import java . util . concurrent . * ; import java . util . logging . Logger ; import javax . tools . * ; class Server implements Runnable { private final BufferedReader in ; private final OutputStream out ; private final boolean isSocket ; private static final JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; private static Logger logger = Logger . getLogger ( \"com.sun.tools.javac\" ) ; static class CwdFileManager extends ForwardingJavaFileManager < JavaFileManager > { String cwd ; CwdFileManager ( JavaFileManager fileManager ) { super ( fileManager ) ; } String getAbsoluteName ( String name ) { if ( new File ( name ) . isAbsolute ( ) ) { return name ; } else { return new File ( cwd , name ) . getPath ( ) ; } } } static StandardJavaFileManager fm = tool . getStandardFileManager ( null , null , null ) ; static { logger . setLevel ( java . util . logging . Level . SEVERE ) ; } private Server ( BufferedReader in , OutputStream out , boolean isSocket ) { this . in = in ; this . out = out ; this . isSocket = isSocket ; } private Server ( BufferedReader in , OutputStream out ) { this ( in , out , false ) ; } private Server ( Socket socket ) throws IOException , UnsupportedEncodingException { this ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , \"utf-8\" ) ) , socket . getOutputStream ( ) , true ) ; } public void run ( ) { List < String > args = new ArrayList < String > ( ) ; int res = - 1 ; try { String line = null ; try { line = in . readLine ( ) ; } catch ( IOException e ) { System . err . println ( e . getLocalizedMessage ( ) ) ; System . exit ( 0 ) ; line = null ; } String cwd = null ; while ( line != null ) { if ( line . startsWith ( \"PWD:\" ) ) { cwd = line . substring ( 4 ) ; } else if ( line . equals ( \"END\" ) ) { break ; } else if ( ! \"-XDstdout\" . equals ( line ) ) { args . add ( line ) ; } try { line = in . readLine ( ) ; } catch ( IOException e ) { System . err . println ( e . getLocalizedMessage ( ) ) ; System . exit ( 0 ) ; line = null ; } } Iterable < File > path = cwd == null ? null : Arrays . < File > asList ( new File ( cwd ) ) ; long msec = System . currentTimeMillis ( ) ; try { synchronized ( tool ) { for ( StandardLocation location : StandardLocation . values ( ) ) fm . setLocation ( location , path ) ; res = compile ( out , fm , args ) ; } } catch ( Throwable ex ) { logger . log ( java . util . logging . Level . SEVERE , args . toString ( ) , ex ) ; PrintWriter p = new PrintWriter ( out , true ) ; ex . printStackTrace ( p ) ; p . flush ( ) ; } if ( res >= 3 ) { logger . severe ( String . format ( \"problem: %s\" , args ) ) ; } else { logger . info ( String . format ( \"success: %s\" , args ) ) ; } msec -= System . currentTimeMillis ( ) ; logger . info ( String . format ( \"Real time: %sms\" , - msec ) ) ; } finally { if ( ! isSocket ) { try { in . close ( ) ; } catch ( IOException e ) { } } try { out . write ( String . format ( \"EXIT: %s%n\" , res ) . getBytes ( ) ) ; } catch ( IOException ex ) { logger . log ( java . util . logging . Level . SEVERE , args . toString ( ) , ex ) ; } try { out . flush ( ) ; out . close ( ) ; } catch ( IOException ex ) { logger . log ( java . util . logging . Level . SEVERE , args . toString ( ) , ex ) ; } logger . info ( String . format ( \"EXIT: %s\" , res ) ) ; } } public static void main ( String ... args ) throws FileNotFoundException { if ( args . length == 2 ) { for ( ; ; ) { throw new UnsupportedOperationException ( \"TODO\" ) ; } } else { ExecutorService pool = Executors . newCachedThreadPool ( ) ; try { ServerSocket socket = new ServerSocket ( 0xcafe , - 1 , null ) ; for ( ; ; ) { pool . execute ( new Server ( socket . accept ( ) ) ) ; } } catch ( IOException e ) { System . err . format (", "gt": "\"Error: %s%n\" , e . getLocalizedMessage ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 244, "input": "<s> package org . eclipse . jface . databinding . dialog ; import java . util . Collection ; import java . util . Iterator ; import org . eclipse . core . databinding . DataBindingContext ; import org . eclipse . core . databinding . ValidationStatusProvider ; import org . eclipse . core . databinding . observable . value . ComputedValue ; import org . eclipse . core . runtime . IStatus ; class MaxSeverityValidationStatusProvider extends ComputedValue { private Collection validationStatusProviders ; public MaxSeverityValidationStatusProvider ( DataBindingContext dbc ) { super ( ValidationStatusProvider . class ) ; this . validationStatusProviders = dbc . getValidationStatusProviders ( ) ; } protected Object calculate ( ) { int maxSeverity = IStatus . OK ; ValidationStatusProvider maxSeverityProvider = null ; for ( Iterator it = validationStatusProviders . iterator ( ) ; it", "gt": ". hasNext ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7523, "input": "<s> package org . ofbiz . service ; public class ExecutionServiceException extends org . ofbiz . base . util . GeneralException { public ExecutionServiceException ( ) { super ( ) ; } public ExecutionServiceException ( String str ) { super ( str ) ; } public ExecutionServiceException ( String str , Throwable nested ) { super ( str , nested ) ; }", "gt": "public ExecutionServiceException ( Throwable nested )", "prediction": "}\n", "label": 0}
{"id": 259, "input": "<s> package org . apache . lucene . index ; public class FieldReaderException extends RuntimeException { public FieldReaderException ( ) { } public FieldReaderException ( Throwable cause ) { super ( cause ) ; } public FieldReaderException ( String message ) { super ( message ) ; } public FieldReaderException ( String message , Throwable cause ) { super", "gt": "( message , cause ) ;", "prediction": "\n", "label": 1}
{"id": 3003, "input": "<s> package com . example . business . jobflow ; import com . example . business . modelgen . table . model . Shipment ;", "gt": "public class ShipmentFromDb extends DefaultDbImporterDescription", "prediction": "}\n", "label": 0}
{"id": 267, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . events . * ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . * ; public class ExpandBar extends Composite { private final class ExpandBarAdapter implements IExpandBarAdapter { public Rectangle getBounds ( ExpandItem item ) { int index = ExpandBar . this . indexOf ( item ) ; return ExpandBar . this . getItem ( index ) . getBounds ( ) ; } public boolean isVScrollbarVisible ( ) { return ExpandBar . this . isVScrollbarVisible ( ) ; } public Rectangle getBottomSpacingBounds ( ) { return ExpandBar . this . getBottomSpacingBounds ( ) ; } } private final class ResizeListener extends ControlAdapter { public void controlResized ( ControlEvent event ) { layoutItems ( 0 , true ) ; } } ExpandItem focusItem ; int spacing ; int allItemsHeight ; int charHeight ; private transient IExpandBarAdapter expandBarAdapter ; private final ItemHolder < ExpandItem > itemHolder ; private final ResizeListener resizeListener ; public ExpandBar ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; spacing = 4 ; resizeListener = new ResizeListener ( ) ; addControlListener ( resizeListener ) ; itemHolder = new ItemHolder < ExpandItem > ( ExpandItem . class ) ; } public void addExpandListener ( ExpandListener listener ) { checkWidget ( ) ; if ( listener == null ) { error ( SWT . ERROR_NULL_ARGUMENT ) ; } TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Expand , typedListener ) ; addListener ( SWT . Collapse , typedListener ) ; } public void removeExpandListener ( ExpandListener listener ) { checkWidget ( ) ; if ( listener == null ) { error ( SWT . ERROR_NULL_ARGUMENT ) ; } removeListener ( SWT . Expand , listener ) ; removeListener ( SWT . Collapse , listener ) ; } public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; int height = 0 , width = 0 ; int itemCount = getItemCount ( ) ; if ( wHint == SWT . DEFAULT || hHint == SWT . DEFAULT ) { if ( itemCount > 0 ) { height += spacing ; for ( int i = 0 ; i < itemCount ; i ++ ) { ExpandItem item = getItem ( i ) ; height += item . getHeaderHeight ( ) ; if ( item . expanded ) { height += item . height ; } height += spacing ; int barPreferredWidth = item . getPreferredWidth ( ) + 2 * spacing ; width = Math . max ( width , barPreferredWidth ) ; } } } if ( width == 0 ) { width = DEFAULT_WIDTH ; } if ( height == 0 ) { height = DEFAULT_HEIGHT ; } if ( wHint != SWT . DEFAULT ) { width = wHint ; } if ( hHint != SWT . DEFAULT ) { height = hHint ; } int border = getBorderWidth ( ) ; width += border * 2 ; height += border * 2 ; if ( ( style & SWT . V_SCROLL ) != 0 ) { width += getVerticalBar ( ) . getSize ( ) . x ; } return new Point ( width , height ) ; } void createItem ( ExpandItem item , int style , int index ) { itemHolder . insert ( item , index ) ; if ( focusItem == null ) { focusItem = item ; } layoutItems ( index , true ) ; } void destroyItem ( ExpandItem item ) { int index = 0 ; int itemCount = getItemCount ( ) ; for ( int i = 0 ; i < itemCount ; i ++ ) { if ( getItem ( i ) == item ) { index = i ; } } if ( index != itemCount ) { if ( item == focusItem ) { int focusIndex = index > 0 ? index - 1 : 1 ; if ( focusIndex < itemCount ) { focusItem = getItem ( focusIndex ) ; } else { focusItem = null ; } } itemHolder . remove ( item ) ; layoutItems ( index , true ) ; } } Control findBackgroundControl ( ) { Control control = super . findBackgroundControl ( ) ; if ( ! isAppThemed ( ) ) { if ( control == null ) { control = this ; } } return control ; } int getBandHeight ( ) { return Math . max ( ExpandItem . CHEVRON_SIZE , charHeight ) ; } public ExpandItem getItem ( int index ) { checkWidget ( ) ;", "gt": "return itemHolder . getItem ( index ) ;", "prediction": "}\n", "label": 1}
{"id": 1799, "input": "<s> import java . util . Collections ; public class T6650759f { interface A < X extends A > { } static abstract class B < X extends B > implements A < X > { } static abstract class C < X extends D > extends B < X > { } static class D extends C < D > { } < X extends B , Y extends B < X > > Iterable < X >", "gt": "m ( Y node )", "prediction": ")\n", "label": 0}
{"id": 271, "input": "<s> package de . uos . igf . db3d . junittests . dbms . geom ; import java . util . HashSet ; import java . util . Set ; import junit . framework . TestCase ; import de . uos . igf . db3d . dbms . api . GeometryException ; import de . uos . igf . db3d . dbms . api . UpdateException ; import de . uos . igf . db3d . dbms . geom . * ; import de . uos . igf . db3d . dbms . model3d . SegmentElt3D ; import de . uos . igf . db3d . dbms . model3d . SegmentNet3D ; import de . uos . igf . db3d . dbms . model3d . SegmentNet3DComp ; import de . uos . igf . db3d . dbms . model3d . SegmentNetBuilder ; public class SegmentTestCase extends TestCase { public void testEquals ( ) { SegmentElt3D seg1 = new SegmentElt3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; SegmentElt3D seg2 = new SegmentElt3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; assertTrue ( seg1 . equals ( seg2 ) ) ; SegmentElt3D seg3 = new SegmentElt3D ( new Point3D ( 3.0 , 1.0 , 1.0 ) , new Point3D ( 1.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; assertTrue ( seg1 . equals ( seg3 ) ) ; } public void testIntersection ( ) { ScalarOperator sop = new ScalarOperator ( ) ; SegmentElt3D seg1 = new SegmentElt3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; SegmentElt3D seg2 = new SegmentElt3D ( new Point3D ( 3.0 , 1.0 , 1.0 ) , new Point3D ( 5.0 , 2.0 , 1.0 ) , new ScalarOperator ( ) ) ; SimpleGeoObj result = seg1 . intersection ( seg2 , sop ) ; assertTrue ( result instanceof Point3D ) ; if ( result instanceof Point3D ) { Point3D resultPoint = ( Point3D ) result ; assertTrue ( resultPoint . isEqual ( new Point3D ( 3.0 , 1.0 , 1.0 ) , sop ) ) ; } seg1 = new SegmentElt3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; seg2 = new SegmentElt3D ( new Point3D ( 3.0 , 1.0 , 1.0 ) , new Point3D ( 5.0 , 1.0 , 1.0 ) , new ScalarOperator ( ) ) ; result = seg1 . intersection ( seg2 , new ScalarOperator ( ) ) ; assertTrue ( result instanceof Point3D ) ; if ( result instanceof Point3D ) { Point3D resultPoint = ( Point3D ) result ; assertTrue ( resultPoint . isEqual ( new Point3D ( 3.0 , 1.0 , 1.0 ) , sop ) ) ; } } public void testDisjunctNetComponent ( ) throws UpdateException { ScalarOperator sop = new ScalarOperator ( ) ; SegmentNetBuilder segNetBuilder = new SegmentNetBuilder ( sop ) ; SegmentElt3D seg1 = new SegmentElt3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , sop ) ; SegmentElt3D seg2 = new SegmentElt3D ( new Point3D ( 3.0 , 1.0 , 1.0 ) , new Point3D ( 5.0 , 1.0 , 1.0 ) , sop ) ; SegmentElt3D seg3 = new SegmentElt3D ( new Point3D ( 5.0 , 1.0 , 1.0 ) , new Point3D ( 7.0 , 1.0 , 1.0 ) , sop ) ; segNetBuilder . addComponent ( new SegmentElt3D [ ] { seg1 , seg2 , seg3 } ) ; SegmentNet3D segNet3D = segNetBuilder . getSegmentNet ( ) ; SegmentNet3DComp segComp = segNet3D . getComponent ( 0 ) ; assertTrue ( segComp . countElements ( ) == 3 ) ; GeometryException ge = null ; try { segComp . addElt ( new Segment3D ( new Point3D ( 4.0 , 1.0 , 1.0 ) , new Point3D ( 5.0 , 1.0 , 1.0 ) , new", "gt": "ScalarOperator ( ) ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2053, "input": "<s> package org . ofbiz . securityext . thirdparty . truition ; import java . util . Collection ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javax . servlet . http . Cookie ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . party . contact . ContactHelper ; public class TruitionCoReg { public static final String module = TruitionCoReg . class . getName ( ) ; public static final String logPrefix = \"Truition Cookie Info: \" ; public static String truitionReg ( HttpServletRequest req , HttpServletResponse resp ) { HttpSession session = req . getSession ( ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; StringBuffer cookieNameB = new StringBuffer ( ) ; StringBuffer cookieValue = new StringBuffer ( ) ; if ( ! truitionEnabled ( ) ) { return \"success\" ; } boolean cookieOk = false ; if ( userLogin != null ) { cookieOk = TruitionCoReg . makeTruitionCookie ( userLogin , cookieNameB , cookieValue ) ; } String domainName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.domain.name\" ) ; String cookiePath = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.cookie.path\" ) ; String cookieName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.cookie.name\" ) ; int time = ( int ) UtilProperties . getPropertyNumber ( \"truition.properties\" , \"truition.cookie.time\" ) ; if ( UtilValidate . isEmpty ( domainName ) ) { Debug . logError ( \"Truition is not properly configured; domainName missing; see truition.properties\" , module ) ; return \"error\" ; } if ( UtilValidate . isEmpty ( cookiePath ) ) { Debug . logError ( \"Truition is not properly configured; cookiePath missing; see truition.properties\" , module ) ; return \"error\" ; } if ( UtilValidate . isEmpty ( cookieName ) ) { Debug . logError ( \"Truition is not properly configured; cookieName missing; see truition.properties\" , module ) ; return \"error\" ; } if ( time == 0 ) { Debug . logError ( \"Truition is not properly configured; cookieTime missing; see trution.properties\" , module ) ; return \"error\" ; } String thisValue = cookieValue . toString ( ) ; thisValue = thisValue . replaceAll ( \"\\n\" , \"\" ) ; thisValue = thisValue . replaceAll ( \"\\r\" , \"\" ) ; if ( cookieOk ) { try { Cookie tru = new Cookie ( cookieName , URLEncoder . encode ( thisValue , \"UTF-8\" ) ) ; tru . setDomain ( domainName ) ; tru . setPath ( cookiePath ) ; tru . setMaxAge ( time ) ; resp . addCookie ( tru ) ; Debug . logInfo ( \"Set Truition Cookie [\" + tru . getName ( ) + \"/\" + tru . getDomain ( ) + \" @ \" + tru . getPath ( ) + \"] - \" + tru . getValue ( ) , module ) ; } catch ( UnsupportedEncodingException e ) { Debug . logError ( e , module ) ; return \"error\" ; } } return \"success\" ; } public static String truitionLogoff ( HttpServletRequest req , HttpServletResponse resp ) { String domainName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.domain.name\" ) ; String cookieName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.cookie.name\" ) ; if ( UtilValidate . isEmpty ( domainName ) ) { Debug . logError ( \"Truition is not properly configured; domainName missing; see truition.properties\" , module ) ; return \"error\" ; } if ( UtilValidate . isEmpty ( cookieName ) ) { Debug . logError ( \"Truition is not properly configured; cookieName missing; see truition.properties\" , module ) ; return \"error\" ; } if ( truitionEnabled ( ) ) { Cookie [ ] cookies = req . getCookies ( ) ; for ( int i = 0 ; i < cookies . length ; i ++ ) { if ( cookieName . equals ( cookies [ i ] . getName ( ) ) ) { cookies [ i ] . setMaxAge ( 0 ) ; resp . addCookie ( cookies [ i ] ) ; Debug . logInfo ( \"Set truition cookie [\" + cookieName + \" to expire now.\" , module ) ; } } } return \"success\" ; } public static String truitionRedirect ( HttpServletRequest req , HttpServletResponse resp ) { String redirectUrlName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.redirect.urlName\" ) ; String redirectUrl = req . getParameter ( redirectUrlName ) ; Debug . logInfo ( \"Redirect to : \" + redirectUrl , module ) ; if ( truitionEnabled ( ) && redirectUrl != null ) { try { resp . sendRedirect ( redirectUrl ) ; } catch ( IOException e ) { Debug . logError ( e , module ) ; req . setAttribute ( \"_ERROR_MESSAGE_\" , e . getMessage ( ) ) ; return \"error\" ; } Debug . logInfo ( \"Sending truition redirect - \" + redirectUrl , module ) ; return \"redirect\" ; } return \"success\" ; } public static boolean makeTruitionCookie ( GenericValue userLogin , StringBuffer cookieName , StringBuffer cookieValue ) { String domainName = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.domain.name\" ) ; String siteId = UtilProperties . getPropertyValue ( \"truition.properties\" , \"truition.siteId\" ) ; if ( UtilValidate . isEmpty ( domainName ) ) { Debug . logError ( \"Truition is not properly configured; domainName missing; see truition.properties!\" , module ) ; return false ; } if ( UtilValidate . isEmpty ( siteId ) ) { Debug . logError ( \"Truition is not properly configured; siteId missing; see truition.properties!\" , module ) ; return false ; } String nickName = userLogin . getString ( \"userLoginId\" ) ; String password = userLogin . getString ( \"currentPassword\" ) ; String partyId = userLogin . getString ( \"partyId\" ) ; Debug . logInfo ( logPrefix + \"nickName: \" + nickName , module ) ; Debug . logInfo ( logPrefix + \"password: \" + password , module ) ; Debug . logInfo ( logPrefix + \"partyId: \" + partyId , module ) ; GenericValue party = null ; try { party = userLogin . getRelatedOne ( \"Party\" , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; } if ( party != null ) { String title = null ; String firstName = null ; String lastName = null ; if ( \"PERSON\" . equals ( party . getString ( \"partyTypeId\" ) ) ) { GenericValue person = null ; try { person", "gt": "= party . getRelatedOne ( \"Person\" , false ) ;", "prediction": ";\n", "label": 0}
{"id": 274, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; public interface MailResource { @ Get public MailRepresentation retrieve ( ) ; @", "gt": "Put public void store ( MailRepresentation mail ) ;", "prediction": "\n", "label": 1}
{"id": 4213, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . translate ; import java . util . EventListener ; public interface TranslationListener extends EventListener { void onActivate ( TranslationEvent evt ) ; void", "gt": "translateBefore ( TranslationEvent evt ) ;", "prediction": "}\n", "label": 0}
{"id": 292, "input": "<s> package org . apache . lucene . index ; import java . io . Reader ; final class ReusableStringReader extends Reader { int upto ; int left ; String s ; void init ( String s ) { this . s = s ; left = s . length ( ) ; this . upto = 0 ; } public int read ( char [ ] c ) { return read ( c , 0 , c . length ) ; } public int read ( char [ ] c , int off , int len ) { if ( left > len ) { s . getChars ( upto , upto + len", "gt": ", c , off ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2653, "input": "<s> package org . gk . engine . client . build . layout ; import java . util . List ; import com . extjs . gxt . ui . client . util . Margins ; import com . extjs . gxt . ui . client . widget . layout . LayoutData ; import com . extjs . gxt . ui . client . widget . layout . RowData ; import com . google . gwt . xml . client . Node ; public class XRowData extends XLayoutData { protected String data ; public XRowData ( Node node , List subNodes ) { super ( node , subNodes ) ; data = super . getAttribute ( \"data\" , \"1,1,0\" ) ; } public String getData ( ) { return data ; } @ Override public LayoutData getLayoutData ( ) { String [ ] dataArray = getData ( ) . split ( \",\" ) ; double args1 = Double . parseDouble ( dataArray [ 0 ] ) ; double args2 = Double . parseDouble ( dataArray [ 1 ] ) ; RowData rd = null ; if ( dataArray . length == 3 ) { int args3 = Integer . parseInt ( dataArray [ 2 ] ) ; rd = new RowData ( args1 , args2 , new Margins ( args3 ) ) ; } else { int top = Integer . parseInt ( dataArray", "gt": "[ 2 ] ) ;", "prediction": ") ;\n", "label": 0}
{"id": 293, "input": "<s> package org . fuzzydb . server . internal . server ; public interface IOManager { public", "gt": "void beginIO ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 2750, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . javadoc . * ; public interface WriterFactory { public abstract ConstantsSummaryWriter getConstantsSummaryWriter ( ) throws Exception ; public abstract PackageSummaryWriter getPackageSummaryWriter ( PackageDoc packageDoc , PackageDoc prevPkg , PackageDoc nextPkg ) throws Exception ; public abstract ClassWriter getClassWriter ( ClassDoc classDoc , ClassDoc prevClass , ClassDoc nextClass , ClassTree classTree ) throws Exception ; public abstract AnnotationTypeWriter getAnnotationTypeWriter ( AnnotationTypeDoc annotationType , Type prevType , Type nextType ) throws Exception ; public abstract MethodWriter getMethodWriter ( ClassWriter classWriter ) throws Exception ; public abstract AnnotationTypeOptionalMemberWriter getAnnotationTypeOptionalMemberWriter ( AnnotationTypeWriter annotationTypeWriter ) throws Exception ;", "gt": "public abstract AnnotationTypeRequiredMemberWriter getAnnotationTypeRequiredMemberWriter ( AnnotationTypeWriter annotationTypeWriter ) throws Exception ;", "prediction": "}\n", "label": 0}
{"id": 304, "input": "<s> package org . eclipse . jface . tests . fieldassist ; import junit . framework . TestCase ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public abstract class AbstractFieldAssistTestCase extends TestCase { private AbstractFieldAssistWindow window ; private Shell anotherShell ; private int originalShellCount ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Display display = getDisplay ( ) ; anotherShell = new Shell ( display ) ; new Text ( anotherShell , SWT . SINGLE ) ; anotherShell . open ( ) ; spinEventLoop ( ) ; originalShellCount = display . getShells ( ) . length ; window = createFieldAssistWindow ( ) ; assertNotNull ( window ) ; } protected void tearDown ( ) throws Exception { if ( window != null ) { spinEventLoop ( ) ; } closeFieldAssistWindow ( ) ; anotherShell . close ( ) ; super . tearDown ( ) ; } protected Display getDisplay ( ) { Display display = Display . getCurrent ( ) ; if ( display == null ) display = Display . getDefault ( ) ; return display ; } protected void closeFieldAssistWindow ( ) { if ( window != null ) { window . close ( ) ; window = null ; } } protected abstract AbstractFieldAssistWindow createFieldAssistWindow ( ) ; protected AbstractFieldAssistWindow getFieldAssistWindow ( ) { return window ; } protected void spinEventLoop ( ) { Display disp = getDisplay ( ) ; while ( disp . readAndDispatch ( ) ) { ; } } protected void ensurePopupIsUp ( ) { if ( window . getAutoActivationDelay ( ) == 0 ) { spinEventLoop ( ) ; } else { long time = System . currentTimeMillis ( ) ; long target = time + window . getAutoActivationDelay ( ) ; while ( target > time ) { spinEventLoop ( ) ; time = System . currentTimeMillis ( ) ; } try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { } spinEventLoop ( ) ; } } protected void sendFocusInToControl ( ) { window . getFieldAssistControl ( ) . setFocus ( ) ; spinEventLoop ( ) ; } protected void sendFocusElsewhere ( ) { anotherShell . setFocus ( ) ; spinEventLoop ( ) ; } protected void sendFocusToPopup ( ) { getFieldAssistWindow (", "gt": ") . getContentProposalAdapter ( ) . setProposalPopupFocus ( ) ;", "prediction": ")\n", "label": 1}
{"id": 3125, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface", "gt": "Summary extends StatusStatusSheetAttribute , StatusTimesheetAttribute", "prediction": ";\n", "label": 0}
{"id": 310, "input": "<s> package org . fuzzydb . server . internal . pager ; import java . util . Date ; public interface PagerMBean { public int getLoadedPages ( ) ; public int getOutstandingPurges ( ) ; public int getPurgeInterval ( ) ; public void setPurgeInterval ( int millisecs ) ;", "gt": "public int getMinPagesPerPurge ( ) ;", "prediction": "}\n", "label": 1}
{"id": 2099, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; import junit . framework . Assert ; import org . junit . Test ; public class XCodePrepareMojoTest extends XCodeTest { @ Test public void testPrepare ( ) throws Exception { final String testName = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getMethodName ( ) ; final File remoteRepositoryDirectory = getRemoteRepositoryDirectory ( getClass ( ) . getName ( ) ) ; prepareRemoteRepository ( remoteRepositoryDirectory ) ; new XCodeLifecycleTest ( ) . test ( testName , new File ( getTestRootDirectory ( ) , \"straight-forward/MyLibrary\" ) , \"pom.xml\" , \"deploy\" , null , THE_EMPTY_MAP , remoteRepositoryDirectory ) ; final Map < String , String > additionalSystemParameters = new HashMap < String , String > ( ) ; additionalSystemParameters . put ( \"configuration\" , \"Release\" ) ; additionalSystemParameters . put ( \"sdk\" , \"iphoneos\" ) ; test ( testName , new File ( getTestRootDirectory ( ) , \"straight-forward/MyApp\" ) , \"pom.xml\" , \"com.sap.prd.mobile.ios.mios:xcode-maven-plugin:\" + getMavenXcodePluginVersion ( ) + \":prepare-xcode-build\" , THE_EMPTY_LIST , additionalSystemParameters , remoteRepositoryDirectory ) ; final String configuration = \"Release\" ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/libs/\" + configuration + \"-iphoneos/\" + Constants . GROUP_ID + \"/MyLibrary/libMyLibrary.a\" ) . exists ( ) ) ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/bundles/\" + Constants . GROUP_ID + \"/MyLibrary/MyLibrary.bundle\" ) . exists ( ) ) ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/bundles/\" + Constants . GROUP_ID + \"/MyLibrary/MyLibrary.bundle/test.txt\" ) . exists ( ) ) ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/bundles/\" + Constants . GROUP_ID + \"/MyLibrary/MyLibrary.raw.bundle/test.txt\" ) . exists ( ) ) ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/bundles/\" + Constants . GROUP_ID + \"/MyLibrary/MyLibrary.raw.bundle/testDirectory/test.txt\" ) . exists ( ) ) ; Assert . assertTrue ( new File ( getTestExecutionDirectory ( testName , \"MyApp\" ) , \"target/bundles/\" + Constants . GROUP_ID +", "gt": "\"/MyLibrary/Resources/Another.bundle/test.txt\" ) . exists ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 331, "input": "<s> package org . ntu . rtsearch . datacollected . api ; import org . scribe . builder . api . DefaultApi10a ; import org . scribe . model . Token ; public class TwitterApi extends DefaultApi10a { private static final String AUTHORIZE_URL = \"https://api.twitter.com/oauth/authorize?oauth_token=%s\" ; @ Override public String getAccessTokenEndpoint ( ) { return \"http://api.twitter.com/oauth/access_token\" ; } public String getRequestTokenEndpoint ( ) { return \"http://api.twitter.com/oauth/request_token\" ; } @ Override public", "gt": "String getAuthorizationUrl ( Token requestToken )", "prediction": "( )\n", "label": 1}
{"id": 3645, "input": "<s> import java . lang . annotation . * ; import java . math . BigDecimal ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; @ P0 @ P1 @ P2 @ S1 public class Plurality extends JavacTestingAbstractProcessor { private boolean executed = false ; public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ! roundEnv . processingOver ( ) ) { executed = true ; Element e = elements . getTypeElement ( \"Plurality\" ) ; Class [ ] classes = null ; P0 p0 = e . getAnnotation ( P0 . class ) ; try { classes = p0 . value ( ) ; } catch ( MirroredTypesException mtse ) { if ( mtse instanceof MirroredTypeException ) { throw new RuntimeException ( \"Wrong exception type!\" ) ; } List < ? extends TypeMirror > types = mtse . getTypeMirrors ( ) ; if ( types . size ( ) != 0 ) throw new RuntimeException ( \"List size != 0: \" + types ) ; } P1 p1 = e . getAnnotation ( P1 . class ) ; try { classes = p1 . value ( ) ; } catch ( MirroredTypesException mtse ) { if ( mtse instanceof MirroredTypeException ) { throw new RuntimeException ( \"Wrong exception type!\" ) ; } List < ? extends TypeMirror > types = mtse . getTypeMirrors ( ) ; if ( types . size ( ) != 1 ) throw new RuntimeException ( \"List size != 1: \" + types ) ; checkTypeListMatchesClasses ( types , this . getClass ( ) . getAnnotation ( P1 . class ) . value ( ) ) ; } P2 p2 = e . getAnnotation ( P2 . class ) ; try { classes = p2 . value ( ) ; } catch ( MirroredTypesException mtse ) { if ( mtse instanceof MirroredTypeException ) { throw new RuntimeException ( \"Wrong exception type!\" ) ; } List < ? extends TypeMirror > types = mtse . getTypeMirrors ( ) ; if ( types . size ( ) != 2 ) throw new RuntimeException ( \"List size != 2: \" + types ) ; checkTypeListMatchesClasses ( types , this . getClass ( ) . getAnnotation ( P2 . class ) . value ( ) ) ; } Class < ? > clazz = null ; S1 s1 = e . getAnnotation ( S1 . class ) ; try { clazz = s1 . value ( ) ; } catch ( MirroredTypesException mtse ) { List < ? extends TypeMirror > types = mtse . getTypeMirrors ( ) ; if ( types . size ( ) != 1 ) throw new RuntimeException ( \"List size != 1: \" + types ) ; Class < ? > [ ] clazzes = new Class < ? > [ 1 ] ; clazzes [ 0 ] = this . getClass ( ) . getAnnotation ( S1 . class ) . value ( ) ; checkTypeListMatchesClasses ( types , clazzes ) ; } try { clazz = s1 . value ( ) ; } catch ( MirroredTypeException mte ) { TypeMirror type = mte . getTypeMirror ( ) ; if ( type == null ) { throw new RuntimeException ( \"Expected null\" ) ; } List < TypeMirror > types = new ArrayList < > ( ) ; types . add ( type ) ; Class < ? > [ ] clazzes = new Class < ? > [ 1 ] ; clazzes [ 0 ] = this . getClass ( ) . getAnnotation ( S1 . class ) . value ( ) ; checkTypeListMatchesClasses ( types , clazzes ) ; } } else { if ( ! executed ) { throw new RuntimeException ( \"Didn't seem to do anything!\" ) ; } } return true ; } private static void checkTypeListMatchesClasses ( List < ? extends TypeMirror > types , Class < ? > [ ] classes ) { if ( types . size ( ) != classes . length ) throw new RuntimeException ( \"Size mismatch:\\n\\t\" + types + \"\\n\\t\" + Arrays . toString ( classes ) ) ; int i = - 1 ; for ( Class < ? > clazz : classes ) { i ++ ; String canonicalName = clazz . getCanonicalName ( ) ; String toStringName = types . get ( i ) . toString ( ) ; if ( ! canonicalName . equals ( toStringName ) ) throw new RuntimeException ( \"Mismatched names: \"", "gt": "+ canonicalName + \"\\t\" + toStringName ) ;", "prediction": ") ;\n", "label": 0}
{"id": 343, "input": "<s> package org . eclipse . ui . internal . tweaklets ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IWorkbenchPart ; public class AllowGrabFocus extends GrabFocus { public boolean grabFocusAllowed ( IWorkbenchPart part ) { return true ; } public void", "gt": "init ( Display display )", "prediction": "( )\n", "label": 1}
{"id": 1742, "input": "<s> class UplevelPrivateConstants { class Inner { private String value ; Inner ( int code ) { switch ( code ) { case VAL1 : value = \"value1\" ; break ; case VAL2 : value = \"value2\" ; break ; case VAL3", "gt": ": value = \"value3\" ;", "prediction": ";\n", "label": 0}
{"id": 344, "input": "<s> package org . jscsi . target . example ; import java . io . File ; import java . io . IOException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import javax . xml . parsers . ParserConfigurationException ; import org . jscsi . target . Configuration ; import org . jscsi . target . TargetServer ; import org . xml . sax . SAXException ; public class CallableStart { public static void main (", "gt": "String [ ] args ) throws SAXException , ParserConfigurationException , IOException", "prediction": ")\n", "label": 1}
{"id": 2129, "input": "<s> package org . ofbiz . entity ; import javolution . context . ObjectFactory ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import freemarker . ext . beans . BeansWrapper ; import freemarker . ext . beans . MapModel ; import freemarker . ext . beans . StringModel ; import freemarker . template . TemplateModel ; import freemarker . template . TemplateModelException ; @ SuppressWarnings ( \"serial\" ) public class GenericValueHtmlWrapper extends GenericValue { protected static final ObjectFactory < GenericValueHtmlWrapper > genericValueHtmlWrapperFactory = new ObjectFactory < GenericValueHtmlWrapper > ( ) { @ Override protected GenericValueHtmlWrapper create ( ) { return new GenericValueHtmlWrapper ( ) ; } } ; public static GenericValueHtmlWrapper create ( GenericValue value ) { GenericValueHtmlWrapper newValue = genericValueHtmlWrapperFactory . object ( ) ; try { newValue . init ( value ) ; } catch ( RuntimeException e ) { Debug . logError ( e , \"Error in init for clone of value: \" + value , module ) ; throw e ; } return newValue ; } @ Override public Object get ( Object name ) { Object value = super . get ( name ) ; if ( value instanceof String ) { return StringUtil . htmlEncoder . encode ( ( String ) value ) ; } else { return value ; } } public static class GenericValueHtmlWrapperForFtl extends MapModel { public GenericValueHtmlWrapperForFtl ( GenericValue gv , BeansWrapper wrapper ) { super ( gv , wrapper ) ; }", "gt": "@ Override public TemplateModel get ( String key )", "prediction": "}\n", "label": 0}
{"id": 373, "input": "<s> package org . eclipse . rap . rwt . cluster . test . entrypoints ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . swt . SWT ; import org . eclipse . swt . browser . Browser ; import org . eclipse . swt . custom . CBanner ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . custom . CLabel ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . custom . SashForm ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . CoolBar ; import org . eclipse . swt . widgets . CoolItem ; import org . eclipse . swt . widgets . DateTime ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . List ; import org . eclipse . swt . widgets . ProgressBar ; import org . eclipse . swt . widgets . Scale ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Slider ; import org . eclipse . swt . widgets . Spinner ; import org . eclipse . swt . widgets . TabFolder ; import org . eclipse . swt . widgets . TabItem ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . ToolBar ; import org . eclipse . swt . widgets . ToolItem ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeColumn ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . swt . widgets . Widget ; @ SuppressWarnings ( { \"unused\" , \"restriction\" } ) public class WidgetsEntryPoint implements IEntryPoint { private Shell shell ; public int createUI ( ) { Display display = new Display ( ) ; shell = new Shell ( display ) ; shell . setMaximized ( true ) ; shell . setLayout ( new RowLayout ( ) ) ; createButton ( ) ; createBrowser ( ) ; createCBanner ( ) ; createCTabFolder ( ) ; createCLabel ( ) ; createCombo ( ) ; createCCombo ( ) ; createComposite ( ) ; createCoolBar ( ) ; createDateTime ( ) ; createGroup ( ) ; createLabel ( ) ; createLink ( ) ; createList ( ) ; createProgressBar ( ) ; createSashForm ( ) ; createScale ( ) ; createSlider ( ) ; createSpinner ( ) ; createTabFolder ( ) ; createTable ( ) ; createText ( ) ; createToolBar ( ) ; createTree ( ) ; obtainAccessibles ( ) ; shell . open ( ) ; return 0 ; } private void obtainAccessibles ( ) { AllWidgetTreeVisitor . accept ( shell , new WidgetTreeVisitor ( ) { public boolean visit ( Widget widget ) { if ( widget instanceof Control ) { Control control = ( Control ) widget ; control . getAccessible ( ) ; } return true ; } } ) ; } private void createProgressBar ( ) { new ProgressBar ( shell , SWT . NONE ) ; } private void createList ( ) { new List ( shell , SWT . NONE ) ; } private void createLink ( ) { new Link ( shell , SWT . NONE ) ; } private void createTree ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; new TreeItem ( tree , SWT . NONE ) ; new TreeColumn ( tree , SWT . NONE ) ; } private void createToolBar ( ) { ToolBar toolBar = new ToolBar ( shell , SWT . NONE ) ; new ToolItem ( toolBar , SWT . PUSH ) ; } private void createText ( ) { new Text ( shell , SWT . SINGLE ) ; new Text ( shell , SWT . MULTI ) ; new Text ( shell , SWT . PASSWORD ) ; } private void createTable ( ) { Table table = new Table ( shell , SWT . NONE ) ; new TableItem ( table , SWT . NONE ) ; new TableColumn ( table , SWT . NONE ) ; } private void createTabFolder ( ) { TabFolder tabFolder = new TabFolder ( shell , SWT . NONE ) ; new TabItem ( tabFolder , SWT . NONE ) ; } private void createSpinner ( ) { new Spinner ( shell , SWT . NONE ) ; } private void createSlider ( ) { new Slider ( shell , SWT . NONE ) ; } private void createScale ( ) { new Scale ( shell , SWT . NONE ) ; } private void createSashForm ( ) { SashForm sashForm = new SashForm ( shell , SWT . NONE ) ; new Label ( sashForm , SWT . NONE ) ; new Label ( sashForm , SWT . NONE ) ; sashForm . setWeights ( new int [ ] { 30 , 70 } ) ; } private void createLabel ( ) { new Label ( shell , SWT . NONE ) ; } private void createGroup ( ) { new Group ( shell , SWT . NONE ) ; } private void createButton ( ) { new Button ( shell , SWT . PUSH ) ; new Button ( shell , SWT . RADIO ) ; new Button ( shell , SWT . CHECK ) ; new Button ( shell , SWT . TOGGLE ) ; } private void createDateTime ( ) { new DateTime ( shell , SWT . DATE ) ; new DateTime ( shell , SWT . TIME ) ; new DateTime ( shell , SWT . CALENDAR ) ; } private void createCoolBar ( ) { CoolBar coolBar = new CoolBar ( shell , SWT . NONE ) ; new CoolItem", "gt": "( coolBar , SWT . NONE ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3949, "input": "<s> package org . remast . baralga . gui . panels . table ; import org . remast . baralga . gui . BaralgaMain ; import org . remast . baralga . gui . model . report . HoursByProject ; import org . remast . util . TextResourceBundle ; import ca . odell . glazedlists . gui . TableFormat ; public class HoursByProjectTableFormat implements TableFormat < HoursByProject > { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaMain . class ) ; public final int getColumnCount ( ) { return 2 ; } public final String getColumnName ( final int column ) { switch ( column ) { case 0 : return textBundle . textFor ( \"HoursByDayProjectFormat.ProjectHeading\" ) ; case 1 : return textBundle . textFor ( \"HoursByDayProjectFormat.HoursHeading\" ) ; default : return null ; } } public Object getColumnValue ( final HoursByProject baseObject , final int column ) { switch ( column ) { case 0 : return baseObject . getProject ( ) ; case 1 :", "gt": "return ( Double ) baseObject . getHours ( ) ;", "prediction": ";\n", "label": 0}
{"id": 377, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . * ; public class RenderDispose_Test extends TestCase { @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakeNewRequest ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testDisposeNotYetInitialized ( ) { Display display = new Display ( ) ; final Composite shell = new Shell ( display , SWT . NONE ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Fixture . fakeNewRequest ( display ) ; ILifeCycle lifeCycle = RWTFactory . getLifeCycleFactory ( ) . getLifeCycle ( ) ; lifeCycle . addPhaseListener ( new PhaseListener ( ) { private static final long serialVersionUID = 1L ; public void beforePhase ( PhaseEvent event ) { Button button = new Button ( shell , SWT . PUSH ) ; button . dispose ( ) ; } public void afterPhase ( PhaseEvent event ) { } public PhaseId getPhaseId ( ) { return PhaseId . RENDER ; } } ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Message message = Fixture . getProtocolMessage ( ) ; assertEquals ( 1 , message . getRequestCounter ( ) ) ; assertEquals ( 0", "gt": ", message . getOperationCount ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10100, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface Maximum extends LimitsAttribute", "prediction": "}\n", "label": 0}
{"id": 378, "input": "<s> package com . optify . service . exception ; public class InternalException extends RuntimeException { private static final long serialVersionUID = 1L ; public InternalException ( ) { }", "gt": "public InternalException ( Throwable cause )", "prediction": "}\n", "label": 1}
{"id": 8201, "input": "<s> @ interface An { int a ( ) ; } class T { static { An an = null ; java . lang .", "gt": "annotation . Annotation at = an ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 384, "input": "<s> package org . apache . lucene . search . payloads ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . English ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . QueryUtils ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . CheckHits ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . DefaultSimilarity ; import org . apache . lucene . search . spans . SpanTermQuery ; import org . apache . lucene . search . spans . Spans ; import org . apache . lucene . search . spans . TermSpans ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . LowerCaseTokenizer ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . tokenattributes . PayloadAttribute ; import org . apache . lucene . index . Payload ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import java . io . Reader ; import java . io . IOException ; public class TestPayloadTermQuery extends LuceneTestCase { private IndexSearcher searcher ; private BoostingSimilarity similarity = new BoostingSimilarity ( ) ; private byte [ ] payloadField = new byte [ ] { 1 } ; private byte [ ] payloadMultiField1 = new byte [ ] { 2 } ; private byte [ ] payloadMultiField2 = new byte [ ] { 4 } ; protected RAMDirectory directory ; public TestPayloadTermQuery ( String s ) { super ( s ) ; } private class PayloadAnalyzer extends Analyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { TokenStream result = new LowerCaseTokenizer ( reader ) ; result = new PayloadFilter ( result , fieldName ) ; return result ; } } private class PayloadFilter extends TokenFilter { String fieldName ; int numSeen = 0 ; PayloadAttribute payloadAtt ; public PayloadFilter ( TokenStream input , String fieldName ) { super ( input ) ; this . fieldName = fieldName ; payloadAtt = ( PayloadAttribute ) addAttribute ( PayloadAttribute . class ) ; } public boolean incrementToken ( ) throws IOException { boolean hasNext = input . incrementToken ( ) ; if ( hasNext ) { if", "gt": "( fieldName . equals ( \"field\" ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 2756, "input": "<s> package com . asakusafw . example . direct . seqfile . batch ; import com . asakusafw . example . direct . seqfile . jobflow . CategorySummaryJob ; import com . asakusafw . vocabulary . batch . Batch ; import com . asakusafw . vocabulary . batch . BatchDescription ; @", "gt": "Batch ( name = \"example.summarizeSales\" ) public class SummarizeBatch extends BatchDescription", "prediction": ";\n", "label": 0}
{"id": 387, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . rap . rwt . internal . protocol . ProtocolUtil ; import org . eclipse . swt . internal . SerializableCompatibility ; public final class RWTRequestVersionControl implements SerializableCompatibility { private static final Integer INITIAL_REQUEST_ID = new Integer ( - 1 ) ; static final String REQUEST_COUNTER = \"requestCounter\" ; public static RWTRequestVersionControl getInstance ( ) { return SingletonUtil . getSessionInstance ( RWTRequestVersionControl . class ) ; } private Integer requestId ; private RWTRequestVersionControl ( ) { requestId = INITIAL_REQUEST_ID ; } public boolean isValid ( ) { String sentRequestId = ProtocolUtil . readHeadPropertyValue ( REQUEST_COUNTER ) ; boolean initialRequest = sentRequestId == null ; boolean invalidVersionState = INITIAL_REQUEST_ID . equals ( requestId ) && sentRequestId != null ; boolean requestIdEquals = requestId . toString ( ) . equals ( sentRequestId ) ; return ! invalidVersionState && ( initialRequest || requestIdEquals ) ; } public Integer nextRequestId ( ) { requestId = new Integer ( requestId . intValue ( ) + 1 ) ; return requestId ; } public Integer getCurrentRequestId ( ) { return requestId ; } public void setCurrentRequestId ( Integer version ) {", "gt": "this . requestId = version ;", "prediction": "\n", "label": 1}
{"id": 4913, "input": "<s> class T7034511a { interface A < T > { void foo ( T x ) ; } interface B < T > extends A < T [ ] > { } static abstract class C implements B < Integer > { < T extends B < ? > >", "gt": "void test ( T x , String [ ] ss )", "prediction": ")\n", "label": 0}
{"id": 389, "input": "<s> package org . restlet . test . connector ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . MediaType ; import org . restlet . data . Protocol ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . restlet . routing . Router ; import org . restlet . test . RestletTestCase ; public class RiapConnectorsTestCase extends RestletTestCase { public void testRiapConnectors ( ) { Component component = new Component ( ) ; component . getServers ( ) . add ( Protocol . RIAP ) ; component . getClients ( ) . add ( Protocol . RIAP ) ; Application app = new Application ( ) { @ Override public Restlet createInboundRoot ( ) { Router router = new Router ( getContext ( ) ) ; router . attach ( \"/testA\" , new Restlet ( getContext ( ) ) { @ Override public void handle ( Request request , Response response ) { response . setEntity ( \"hello, world\" , MediaType . TEXT_PLAIN ) ; } } ) ; router . attach ( \"/testB\" , new Restlet ( getContext ( ) ) { public void handle ( Request request , Response response ) { ClientResource resource = new ClientResource ( \"riap://component/app/testA\" ) ; try { response . setEntity ( resource . get ( ) . getText ( ) , MediaType . TEXT_PLAIN ) ; } catch ( Exception e ) { } } } ) ; return router ; } } ; component . getInternalRouter ( ) . attach ( \"/app\" , app ) ; try {", "gt": "component . start ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6953, "input": "<s> package org . ofbiz . entity . config ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . config . ResourceLoader ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . GenericEntityConfException ; import org . ofbiz . entity . GenericEntityException ; import org . w3c . dom . Element ; public class EntityConfigUtil { public static final String module = EntityConfigUtil . class . getName ( ) ; public static final String ENTITY_ENGINE_XML_FILENAME = \"entityengine.xml\" ; private static volatile AtomicReference < EntityConfigUtil > configRef = new AtomicReference < EntityConfigUtil > ( ) ; private final String txFactoryClass ; private final String txFactoryUserTxJndiName ; private final String txFactoryUserTxJndiServerName ; private final String txFactoryTxMgrJndiName ; private final String txFactoryTxMgrJndiServerName ; private final String connFactoryClass ; private final Boolean debugXAResources ; private final Map < String , ResourceLoaderInfo > resourceLoaderInfos = new HashMap < String , ResourceLoaderInfo > ( ) ; private final Map < String , DelegatorInfo > delegatorInfos = new HashMap < String , DelegatorInfo > ( ) ; private final Map < String , EntityModelReaderInfo > entityModelReaderInfos = new HashMap < String , EntityModelReaderInfo > ( ) ; private final Map < String , EntityGroupReaderInfo > entityGroupReaderInfos = new HashMap < String , EntityGroupReaderInfo > ( ) ; private final Map < String , EntityEcaReaderInfo > entityEcaReaderInfos = new HashMap < String , EntityEcaReaderInfo > ( ) ; private final Map < String , EntityDataReaderInfo > entityDataReaderInfos = new HashMap < String , EntityDataReaderInfo > ( ) ; private final Map < String , FieldTypeInfo > fieldTypeInfos = new HashMap < String , FieldTypeInfo > ( ) ; private final Map < String , DatasourceInfo > datasourceInfos = new HashMap < String , DatasourceInfo > ( ) ; private static Element getXmlRootElement ( ) throws GenericEntityConfException { try { return ResourceLoader . getXmlRootElement ( ENTITY_ENGINE_XML_FILENAME ) ; } catch ( GenericConfigException e ) { throw new GenericEntityConfException ( \"Could not get entity engine XML root element\" , e ) ; } } static { try { initialize ( getXmlRootElement ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , \"Error loading entity config XML file \" + ENTITY_ENGINE_XML_FILENAME , module ) ; } } public static void reinitialize ( ) throws GenericEntityException { try { ResourceLoader . invalidateDocument ( ENTITY_ENGINE_XML_FILENAME ) ; initialize ( getXmlRootElement ( ) ) ; } catch ( Exception e ) { throw new GenericEntityException ( \"Error reloading entity config XML file \" + ENTITY_ENGINE_XML_FILENAME , e ) ; } } public static void initialize ( Element rootElement ) throws GenericEntityException { configRef . set ( new EntityConfigUtil ( rootElement ) ) ; } private EntityConfigUtil ( Element rootElement ) throws GenericEntityException { Element transactionFactoryElement = UtilXml . firstChildElement ( rootElement , \"transaction-factory\" ) ; if ( transactionFactoryElement == null ) { throw new GenericEntityConfException ( \"ERROR: no transaction-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME ) ; } txFactoryClass = transactionFactoryElement . getAttribute ( \"class\" ) ; Element userTxJndiElement = UtilXml . firstChildElement ( transactionFactoryElement , \"user-transaction-jndi\" ) ; if ( userTxJndiElement != null ) { txFactoryUserTxJndiName = userTxJndiElement . getAttribute ( \"jndi-name\" ) ; txFactoryUserTxJndiServerName = userTxJndiElement . getAttribute ( \"jndi-server-name\" ) ; } else { txFactoryUserTxJndiName = null ; txFactoryUserTxJndiServerName = null ; } Element txMgrJndiElement = UtilXml . firstChildElement ( transactionFactoryElement , \"transaction-manager-jndi\" ) ; if ( txMgrJndiElement != null ) { txFactoryTxMgrJndiName = txMgrJndiElement . getAttribute ( \"jndi-name\" ) ; txFactoryTxMgrJndiServerName = txMgrJndiElement . getAttribute ( \"jndi-server-name\" ) ; } else { txFactoryTxMgrJndiName = null ; txFactoryTxMgrJndiServerName = null ; } Element connectionFactoryElement = UtilXml . firstChildElement ( rootElement , \"connection-factory\" ) ; if ( connectionFactoryElement == null ) { throw new GenericEntityConfException ( \"ERROR: no connection-factory definition was found in \" + ENTITY_ENGINE_XML_FILENAME ) ; } connFactoryClass = connectionFactoryElement . getAttribute ( \"class\" ) ; Element debugXaResourcesElement = UtilXml . firstChildElement ( rootElement , \"debug-xa-resources\" ) ; if ( debugXaResourcesElement == null ) { debugXAResources = false ; } else { debugXAResources = \"true\" . equals ( debugXaResourcesElement . getAttribute ( \"value\" ) ) ; } for ( Element curElement : UtilXml . childElementList ( rootElement , \"resource-loader\" ) ) { ResourceLoaderInfo resourceLoaderInfo = new ResourceLoaderInfo ( curElement ) ; resourceLoaderInfos . put ( resourceLoaderInfo . name , resourceLoaderInfo ) ; } for ( Element curElement : UtilXml . childElementList ( rootElement , \"delegator\" ) ) { DelegatorInfo delegatorInfo = new DelegatorInfo ( curElement ) ; delegatorInfos . put ( delegatorInfo . name , delegatorInfo ) ; } for ( Element curElement : UtilXml . childElementList ( rootElement , \"entity-model-reader\" ) ) { EntityModelReaderInfo entityModelReaderInfo = new EntityModelReaderInfo ( curElement ) ; entityModelReaderInfos . put ( entityModelReaderInfo . name , entityModelReaderInfo ) ; } for ( Element curElement : UtilXml . childElementList ( rootElement , \"entity-group-reader\" ) ) { EntityGroupReaderInfo entityGroupReaderInfo = new EntityGroupReaderInfo ( curElement ) ; entityGroupReaderInfos . put ( entityGroupReaderInfo . name , entityGroupReaderInfo ) ; } for ( Element curElement : UtilXml", "gt": ". childElementList ( rootElement , \"entity-eca-reader\" ) )", "prediction": ") ;\n", "label": 0}
{"id": 393, "input": "<s> package org . eclipse . ui . forms . widgets ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . events . FocusAdapter ; import org . eclipse . swt . events . FocusEvent ; import org . eclipse . swt . events . KeyAdapter ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . ui . forms . FormColors ; import org . eclipse . ui . forms . HyperlinkGroup ; import org . eclipse . ui . forms . IFormColors ; import org . eclipse . ui . internal . forms . widgets . FormFonts ; import org . eclipse . ui . internal . forms . widgets . FormUtil ; public class FormToolkit { public static final String KEY_DRAW_BORDER = \"FormWidgetFactory.drawBorder\" ; public static final String TREE_BORDER = \"treeBorder\" ; public static final String TEXT_BORDER = \"textBorder\" ; private int borderStyle = SWT . NULL ; private FormColors colors ; private int orientation = Window . getDefaultOrientation ( ) ; private BoldFontHolder boldFontHolder ; private HyperlinkGroup hyperlinkGroup ; private boolean isDisposed = false ; VisibilityHandler visibilityHandler ; KeyboardHandler keyboardHandler ; private static class VisibilityHandler extends FocusAdapter { public void focusGained ( FocusEvent e ) { Widget w = e . widget ; if ( w instanceof Control ) { FormUtil . ensureVisible ( ( Control ) w ) ; } } } private static class KeyboardHandler extends KeyAdapter { public void keyPressed ( KeyEvent e ) { Widget w = e . widget ; if ( w instanceof Control ) { if ( e . doit ) FormUtil . processKey ( e . keyCode , ( Control ) w ) ; } } } private class BoldFontHolder { private Font normalFont ; private Font boldFont ; public BoldFontHolder ( ) { } public Font getBoldFont ( Font font ) { createBoldFont ( font ) ; return boldFont ; } private void createBoldFont ( Font font ) { if ( normalFont == null || ! normalFont . equals ( font ) ) { normalFont = font ; dispose ( ) ; } if ( boldFont == null ) { boldFont = FormFonts . getInstance ( ) . getBoldFont ( colors . getDisplay ( ) , normalFont ) ; } } public void dispose ( ) { if ( boldFont != null ) { FormFonts . getInstance ( ) . markFinished ( boldFont ) ; boldFont = null ; } } } public FormToolkit ( Display display ) { this ( new FormColors ( display ) ) ; } public FormToolkit ( FormColors colors ) { this . colors = colors ; initialize ( ) ; } public Button createButton ( Composite parent , String text , int style ) { Button button = new Button ( parent , style | SWT . FLAT | orientation ) ; if ( text != null ) button . setText ( text ) ; adapt ( button , true , true ) ; return button ; } public Composite createComposite ( Composite parent ) { return createComposite ( parent , SWT . NULL ) ; } public Composite createComposite ( Composite parent , int style ) { Composite composite = new LayoutComposite ( parent , style | orientation ) ; adapt ( composite ) ; return composite ; } public Composite createCompositeSeparator ( Composite parent ) { final Composite composite = new Composite ( parent , orientation ) ; if ( parent instanceof Section ) ( ( Section ) parent ) . setSeparatorControl ( composite ) ; return composite ; } public Label createLabel ( Composite parent , String text ) { return createLabel ( parent , text , SWT . NONE ) ; } public Label createLabel ( Composite parent , String text , int style ) { Label label = new Label ( parent , style | orientation ) ; if ( text != null ) label . setText ( text ) ; adapt ( label , false , false ) ; return label ; } public Hyperlink createHyperlink ( Composite parent , String text , int style ) { Hyperlink hyperlink = new Hyperlink ( parent , style | orientation ) ; if ( text != null ) hyperlink . setText ( text ) ; hyperlink . addFocusListener ( visibilityHandler ) ; hyperlink . addKeyListener ( keyboardHandler ) ; hyperlinkGroup . add ( hyperlink ) ; return hyperlink ; } public ImageHyperlink createImageHyperlink ( Composite parent , int style ) { ImageHyperlink hyperlink = new ImageHyperlink ( parent , style | orientation ) ; hyperlink . addFocusListener ( visibilityHandler ) ; hyperlink . addKeyListener ( keyboardHandler ) ; hyperlinkGroup . add ( hyperlink ) ; return hyperlink ; } public FormText createFormText ( Composite parent , boolean trackFocus ) { FormText engine = new FormText ( parent , SWT . WRAP | orientation ) ; engine . marginWidth = 1 ; engine . marginHeight = 0 ; engine . setHyperlinkSettings ( getHyperlinkGroup ( ) ) ; adapt ( engine , trackFocus , true ) ; engine . setMenu ( parent . getMenu ( ) ) ; return engine ; } public void adapt ( Control control , boolean trackFocus , boolean trackKeyboard ) { control . setBackground ( colors . getBackground ( ) ) ; control . setForeground ( colors . getForeground ( ) ) ; if ( control instanceof ExpandableComposite ) { ExpandableComposite ec = ( ExpandableComposite ) control ; if ( ec . toggle != null ) { if (", "gt": "trackFocus ) ec . toggle . addFocusListener ( visibilityHandler ) ;", "prediction": ") ;\n", "label": 1}
{"id": 213, "input": "<s> class T < X > { class U < Y > extends T < X > { < B > U ( ) { < Object > super ( ) ; } U ( int i ) { < Object > this ( ) ; } } class V < Z > extends U < Z > { < C > V ( T < X > t ) { t . < Object > super ( ) ; } } < A > T ( ) { } < K > void f ( K k ) { this . < Integer > f ( \"\" ) ; } public static void main ( String [ ] args ) { T < Integer > x = new < Object", "gt": "> T < Integer > ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 397, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Vector ; import com . googlecode . veloeclipse . vaulttec . ui . editor . VelocityEditorEnvironment ; public class Directive extends AbstractTreeNode implements IBlock { public static final int TYPE_SET = 0 ; public static final int TYPE_IF = 1 ; public static final int TYPE_ELSE = 2 ; public static final int TYPE_ELSEIF = 3 ; public static final int TYPE_END = 4 ; public static final int TYPE_FOREACH = 5 ; public static final int TYPE_INCLUDE = 6 ; public static final int TYPE_PARSE = 7 ; public static final int TYPE_MACRO = 8 ; public static final int TYPE_STOP = 9 ; public static final int TYPE_MACRO_CALL = 10 ; public static final int TYPE_USER_DIRECTIVE = 11 ; public static final String [ ] DIRECTIVES = { \"#set\" , \"#if\" , \"#else\" , \"#elseif\" , \"#end\" , \"#foreach\" , \"#include\" , \"#parse\" , \"#macro\" , \"#stop\" , \"#match\" } ; public static final String [ ] INDENT_DIRECTIVES = { \"if\" , \"else\" , \"elseif\" , \"foreach\" , \"macro\" } ; private int fType ; private String fName ; private ArrayList fParameters ; private String fId ; protected Vector fDirectives = new Vector ( ) ; public Directive ( int aType , String aName , String anId , ITreeNode aParent , int aStartLine , int anEndLine ) { super ( aParent , aStartLine , anEndLine ) ; fName = aName ; fType = aType ; fId = anId ; } public int getType ( ) { return fType ; } public static int getType ( String aName ) { for ( int i = 0 ; i < DIRECTIVES . length ; i ++ ) { if ( Directive . DIRECTIVES [ i ] . equals ( aName ) ) { return i ; } } if ( VelocityEditorEnvironment . getParser ( ) . isUserDirective ( aName ) ) { return TYPE_USER_DIRECTIVE ; } return TYPE_MACRO_CALL ; } public String getId ( ) { return fId ; } public void addParameter ( String aParameter ) { if ( fParameters == null ) { fParameters = new ArrayList ( ) ; } fParameters . add ( aParameter ) ; } public ArrayList getParameters ( ) { return fParameters ; } public void addDirective ( Directive aDirective ) { fDirectives . add ( aDirective ) ; } public String getName ( ) { return ( ( fType < TYPE_MACRO_CALL ) ? ( DIRECTIVES [ fType ] + ( ( fType != TYPE_ELSE ) ? ( \" (\" + fName + \")\" ) : \"\" ) ) : ( \"#\" + fName ) ) ; } public boolean hasChildren ( ) { return ! fDirectives . isEmpty ( ) ; } public Object [ ] getChildren ( ) { return fDirectives . toArray ( ) ; } public boolean accept ( ITreeVisitor aVisitor ) { boolean more = true ; Iterator iter = fDirectives . iterator ( ) ;", "gt": "while ( more && iter . hasNext ( ) )", "prediction": "}\n", "label": 1}
{"id": 8112, "input": "<s> package com . midtro . platform . math ; public class Vector2 { public int x ; public int y ; public Vector2 ( ) { } public Vector2 ( final int [ ] coords ) { x = coords [ 0 ] ; y = coords [ 1 ] ; } public Vector2 ( final Vector2 other ) { this ( other . x , other . y ) ; } public Vector2 ( final int x , final int y ) { this . x = x ; this . y = y ; } public void set ( final Vector2 other ) { set ( other . x , other . y ) ; } public void set ( final int x , final int y ) { this . x = x ; this . y = y ; } public Vector2 copy ( ) { return new Vector2 ( x , y ) ; } @ Override public String toString ( ) { return \"<\" + x + \", \" + y + \">\" ; } public float distance ( final Vector2 other ) { final int dx = other . x - x ; final int dy = other . y - y ; return ( int ) Math . sqrt ( ( dx * dx ) + ( dy * dy ) ) ; } @ Override public int hashCode ( ) { return 997 * ( x ) ^ 991 * ( y ) ; } @ Override public boolean equals ( final Object other ) { if ( other instanceof Vector2 ) {", "gt": "final Vector2 o = ( ( Vector2 ) other ) ;", "prediction": "\n", "label": 0}
{"id": 399, "input": "<s> package com . codeslap . test . persistence ; import com . codeslap . persistence . Constraint ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class ConstraintsTest extends SqliteTest { @ Test public void testConstraints ( ) { List < ExampleAutoincrement > list = new ArrayList < ExampleAutoincrement > ( ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < 50 ; i ++ ) { ExampleAutoincrement foo = new ExampleAutoincrement ( ) ; foo . name = \"Foo bar \" + i ; foo . number = random . nextInt ( ) ; foo . decimal = random . nextFloat ( ) ; foo . bool = i < 25 ; foo . blob = foo . name . getBytes ( ) ; list . add ( foo ) ; } getAdapter ( ) . storeCollection ( list , null ) ; ExampleAutoincrement sample = new ExampleAutoincrement ( ) ; sample . bool = true ; List < ExampleAutoincrement > all = getAdapter ( ) . findAll ( sample ) ; assertEquals ( list . size ( ) / 2 , all . size ( ) ) ; Constraint constraint = new Constraint ( ) . limit ( 2 ) . groupBy ( \"name\" ) . orderBy ( \"number DESC\" ) ; List < ExampleAutoincrement > found = getAdapter ( ) . findAll ( sample , constraint ) ; assertEquals ( 2 , found . size ( ) ) ; assertTrue ( found . get ( 0 ) . number >= found . get (", "gt": "1 ) . number ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 4731, "input": "<s> package com . atlassian . crowd . integration . exception ; @ SuppressWarnings ( \"serial\" ) public class ApplicationAccessDeniedException extends org . apache . axis . AxisFault implements java . io . Serializable { public ApplicationAccessDeniedException ( ) { } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ApplicationAccessDeniedException ) ) return false ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ApplicationAccessDeniedException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace .", "gt": "QName ( \"http://exception.integration.crowd.atlassian.com\" , \"ApplicationAccessDeniedException\" ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 404, "input": "<s> package org . nuxeo . ecm . platform . task . web ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . nuxeo . ecm . platform . task . TaskService ; import org .", "gt": "nuxeo . runtime . api . Framework ;", "prediction": "eclipse . eclipse . ;\n", "label": 1}
{"id": 3561, "input": "<s> package api . notifications ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URL ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import api . soup . MySoup ; public class Results { private String encoding ; private Number fileCount ; private String format ; private Boolean freeTorrent ; private Number groupCategoryId ; private Number groupId ; private String groupName ; private Number groupYear ; private Boolean hasCue ; private Boolean hasLog ; private Number leechers ; private String logInDb ; private Number logScore ; private String media ; private String notificationTime ; private String remasterTitle ; private Number remasterYear ; private Boolean scene ; private Number seeders ; private Number size ; private Number snatched ; private Number torrentId ; private String torrentTags ; private Boolean unread ; public String getEncoding ( ) { return encoding ; } public Number getFileCount ( ) { return fileCount ; } public String getFormat ( ) { return format ; } public Boolean isFreeTorrent ( ) { return freeTorrent ; } public Number getGroupCategoryId ( ) { return groupCategoryId ; } public Number getGroupId ( ) { return groupId ; } public String getGroupName ( ) { return groupName ; } public Number getGroupYear ( ) { return groupYear ; } public Boolean hasCue ( ) { return hasCue ; } public Boolean hasLog ( ) { return hasLog ; } public Number getLeechers ( ) { return leechers ; } public String getLogInDb ( ) { return logInDb ; } public Number getLogScore ( ) { return logScore ; } public String getMedia ( ) { return media ; } public String getNotificationTime ( ) { return notificationTime ; } public String getRemasterTitle ( ) { return remasterTitle ; } public Number getRemasterYear ( ) { return remasterYear ; } public Boolean isScene ( ) { return scene ; } public Number getSeeders ( ) { return seeders ; } public Number getSize ( ) { return size ; } public Number getSnatched ( ) { return snatched ; } public Number getTorrentId ( ) { return torrentId ; } public String getTorrentTags ( ) { return torrentTags ; } public Boolean isUnread ( ) { return unread ; } public String getMediaFormatEncoding ( ) { String log = hasLog ? \" - \" + logScore . toString ( ) : \"\" ; String cue = hasCue ? \" - \" + \"Cue\" : \"\" ; return this . getMedia ( ) + \" - \" + this . getFormat ( ) + \" - \" + this . getEncoding ( ) + log + cue ; } public String getRemaster ( ) { return this . getRemasterYear ( ) + \" - \" + this . getRemasterTitle ( ) ; } public String getDownloadLink ( ) { String site = MySoup . getSite ( ) ; String authKey = MySoup . getAuthKey ( ) ; String passKey = MySoup . getPassKey ( ) ; String downloadLink = site + \"torrents.php?action=download&id=\" + torrentId + \"&authkey=\" + authKey + \"&torrent_pass=\" + passKey ; return downloadLink ; } public void downloadFile ( String url , String path ) throws IOException { String name = \"Unknown \" + \"(\" + getMediaFormatEncoding ( ) + \")\" ; URL u ; u = new URL ( getDownloadLink ( ) ) ; ReadableByteChannel rbc = Channels . newChannel ( u . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( path + name + \".torrent\" ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , 1 << 24 ) ; System . out . println ( \"Downloaded \" + name + \"", "gt": "to \" + path ) ;", "prediction": ") ;\n", "label": 0}
{"id": 410, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . SerializableCompatibility ; public class Event implements SerializableCompatibility { public Display display ; public Widget widget ; public int type ; public int detail ; public Widget item ; public int index ; public GC gc ; public int x ; public int y ; public int width ; public int height ; public int count ; public int time ; public int button ; public char character ; public int keyCode ; public int stateMask ; public int start , end ; public String text ; public boolean doit = true ; public Object data ; public Rectangle getBounds ( ) { return new Rectangle ( x , y , width , height ) ; } public void setBounds ( Rectangle rect ) { this", "gt": ". x = rect . x ;", "prediction": "\n", "label": 1}
{"id": 1423, "input": "<s> package com . sun . tools . javac . sym ; import com . sun . tools . javac . api . JavacTaskImpl ; import com . sun . tools . javac . code . Kinds ; import com . sun . tools . javac . code . Scope ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Attribute ; import com . sun . tools . javac . code . Symtab ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . jvm . ClassReader ; import com . sun . tools . javac . jvm . ClassWriter ; import com . sun . tools . javac . jvm . Pool ; import com . sun . tools . javac . processing . JavacProcessingEnvironment ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . Pair ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . EnumSet ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . ResourceBundle ; import java . util . Set ; import javax . annotation . processing . AbstractProcessor ; import javax . annotation . processing . RoundEnvironment ; import javax . annotation . processing . SupportedAnnotationTypes ; import javax . annotation . processing . SupportedOptions ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . ElementKind ; import javax . lang . model . element . TypeElement ; import javax . tools . Diagnostic ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileManager . Location ; import javax . tools . JavaFileObject ; import static javax . tools . JavaFileObject . Kind . CLASS ; import javax . tools . StandardJavaFileManager ; import javax . tools . StandardLocation ; import javax . tools . ToolProvider ; @ SupportedOptions ( { \"com.sun.tools.javac.sym.Jar\" , \"com.sun.tools.javac.sym.Dest\" } ) @ SupportedAnnotationTypes ( \"*\" ) public class CreateSymbols extends AbstractProcessor { static Set < String > getLegacyPackages ( ) { ResourceBundle legacyBundle = ResourceBundle . getBundle ( \"com.sun.tools.javac.resources.legacy\" ) ; Set < String > keys = new HashSet < String > ( ) ; for ( Enumeration < String > e = legacyBundle . getKeys ( ) ; e . hasMoreElements ( ) ; ) keys . add ( e . nextElement ( ) ) ; return keys ; } public boolean process ( Set < ? extends TypeElement > tes , RoundEnvironment renv ) { try { if ( renv . processingOver ( ) ) createSymbols ( ) ; } catch ( IOException e ) { processingEnv . getMessager ( ) . printMessage ( Diagnostic . Kind . ERROR , e . getLocalizedMessage ( ) ) ; } catch ( Throwable t ) { Throwable cause = t . getCause ( ) ; if ( cause == null ) cause = t ; processingEnv . getMessager ( ) . printMessage ( Diagnostic . Kind . ERROR , cause . getLocalizedMessage ( ) ) ; } return true ; } void createSymbols ( ) throws IOException { Set < String > legacy = getLegacyPackages ( ) ; Set < String > legacyProprietary = getLegacyPackages ( ) ; Set < String > documented = new HashSet < String > ( ) ; Set < PackageSymbol > packages = ( ( JavacProcessingEnvironment ) processingEnv ) . getSpecifiedPackages ( ) ; String jarName = processingEnv .", "gt": "getOptions ( ) . get ( \"com.sun.tools.javac.sym.Jar\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 431, "input": "<s> package org . eclipse . ui . tests . api ; import junit . framework . TestCase ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . PlatformUI ; public class IPerspectiveDescriptorTest extends TestCase { private IPerspectiveDescriptor [ ] fPerspectives ; public IPerspectiveDescriptorTest ( String testName ) { super ( testName ) ; } public void setUp ( ) { fPerspectives = PlatformUI . getWorkbench ( ) . getPerspectiveRegistry ( ) . getPerspectives ( ) ; } public void testGetId ( ) { for ( int i = 0 ; i < fPerspectives . length ; i ++ ) { String id = fPerspectives [", "gt": "i ] . getId ( ) ;", "prediction": ";\n", "label": 1}
{"id": 1978, "input": "<s> class AnonInnerException_3 { void foo ( ) throws Exception { class Inner extends AnonInnerExceptionAux { } ; AnonInnerExceptionAux x =", "gt": "new Inner ( ) ;", "prediction": ";\n", "label": 0}
{"id": 433, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . document . Document ; import org . apache . lucene . index . CorruptIndexException ; public class Hit implements java . io . Serializable { private Document doc = null ; private boolean resolved = false ; private Hits hits = null ; private int hitNumber ; Hit ( Hits hits , int hitNumber ) { this . hits = hits ; this . hitNumber = hitNumber ; } public Document getDocument ( ) throws CorruptIndexException , IOException { if ( ! resolved ) fetchTheHit ( ) ; return doc ; } public float getScore ( ) throws IOException { return hits . score ( hitNumber ) ; } public int getId ( ) throws IOException { return hits . id ( hitNumber ) ; } private void fetchTheHit ( ) throws CorruptIndexException , IOException { doc = hits . doc ( hitNumber ) ; resolved = true ; } public float getBoost ( ) throws CorruptIndexException , IOException { return getDocument ( ) . getBoost ( ) ; } public String get ( String name ) throws CorruptIndexException , IOException { return getDocument ( ) . get ( name ) ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( \"Hit<\" ) ;", "gt": "buffer . append ( hits . toString ( ) ) ;", "prediction": "}\n", "label": 1}
{"id": 9500, "input": "<s> class CantApplyDiamond < T extends Number > { CantApplyDiamond ( T t ) { } < U > CantApplyDiamond ( T t , U u ) { } void m ( ) { CantApplyDiamond < ? > x = new CantApplyDiamond <", "gt": "> ( \"\" ) ;", "prediction": ";\n", "label": 0}
{"id": 434, "input": "<s> package org . eclipse . ui . internal . actions ; import org . eclipse . jface . action . Action ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory . IWorkbenchAction ; import org . eclipse . ui . internal . IWorkbenchGraphicConstants ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchImages ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . util . PrefUtil ; public class HelpContentsAction extends Action implements IWorkbenchAction { private IWorkbenchWindow workbenchWindow ; public HelpContentsAction ( ) { this ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ) ; } public HelpContentsAction ( IWorkbenchWindow window ) { if ( window == null ) { throw new IllegalArgumentException ( ) ; } this . workbenchWindow = window ; setActionDefinitionId ( IWorkbenchCommandConstants . HELP_HELP_CONTENTS ) ; String overrideText = PrefUtil . getAPIPreferenceStore ( ) . getString ( IWorkbenchPreferenceConstants . HELP_CONTENTS_ACTION_TEXT ) ; if ( \"\" . equals ( overrideText ) ) { setText (", "gt": "WorkbenchMessages . get ( ) . HelpContentsAction_text ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5974, "input": "<s> package org . ofbiz . shipment . shipment ; import java . io . IOException ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; public class ShipmentEvents { public static final String module = ShipmentEvents . class . getName ( ) ; public static String viewShipmentPackageRouteSegLabelImage ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String shipmentId = request . getParameter ( \"shipmentId\" ) ; String shipmentRouteSegmentId = request . getParameter ( \"shipmentRouteSegmentId\" ) ; String shipmentPackageSeqId = request . getParameter ( \"shipmentPackageSeqId\" ) ; GenericValue shipmentPackageRouteSeg = null ; try { shipmentPackageRouteSeg = delegator . findOne ( \"ShipmentPackageRouteSeg\" , UtilMisc . toMap ( \"shipmentId\" , shipmentId , \"shipmentRouteSegmentId\" , shipmentRouteSegmentId , \"shipmentPackageSeqId\" , shipmentPackageSeqId ) , false ) ; } catch ( GenericEntityException e ) { String errorMsg = \"Error looking up ShipmentPackageRouteSeg: \" + e . toString ( ) ; Debug . logError ( e , errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } if ( shipmentPackageRouteSeg == null ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , \"Could not find ShipmentPackageRouteSeg where shipmentId=[\" + shipmentId + \"], shipmentRouteSegmentId=[\" + shipmentRouteSegmentId + \"], shipmentPackageSeqId=[\" + shipmentPackageSeqId + \"]\" ) ; return \"error\" ; } byte [ ] bytes = shipmentPackageRouteSeg . getBytes ( \"labelImage\" ) ; if ( bytes == null || bytes . length == 0 ) { request . setAttribute ( \"_ERROR_MESSAGE_\" , \"The ShipmentPackageRouteSeg was found where shipmentId=[\" + shipmentId + \"], shipmentRouteSegmentId=[\" + shipmentRouteSegmentId + \"], shipmentPackageSeqId=[\" + shipmentPackageSeqId + \"], but there was no labelImage on the value.\" ) ; return \"error\" ; } try { UtilHttp . streamContentToBrowser ( response , bytes , \"image/gif\" ) ; } catch ( IOException e1 ) { try { UtilHttp . streamContentToBrowser ( response , bytes , \"image/png\" ) ; } catch ( IOException e2 ) { String errorMsg = \"Error writing labelImage to OutputStream: \" + e2 . toString ( ) ; Debug . logError ( e2 , errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } } return \"success\" ; } public static String checkForceShipmentReceived ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; GenericValue userLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"userLogin\" ) ; String shipmentId = request . getParameter ( \"shipmentIdReceived\" ) ; String forceShipmentReceived = request . getParameter ( \"forceShipmentReceived\" ) ; if ( UtilValidate . isNotEmpty ( shipmentId ) && \"Y\" . equals ( forceShipmentReceived ) ) { try { Map < String , Object > inputMap = UtilMisc . < String , Object > toMap ( \"shipmentId\" , shipmentId , \"statusId\" , \"PURCH_SHIP_RECEIVED\" ) ; inputMap . put ( \"userLogin\" , userLogin ) ; dispatcher", "gt": ". runSync ( \"updateShipment\" , inputMap ) ;", "prediction": "}\n", "label": 0}
{"id": 435, "input": "<s> package org . restlet . engine . util ; public class AlphaNumericComparator extends AlphabeticalComparator { private static final long serialVersionUID = 1L ; @ Override public int compare ( final String uri0 , final String uri1 ) { int ptr = 0 ; int msd = 0 ; int diff = 0 ; char a , b ; final int llength = uri0 . length ( ) ; final int rlength = uri1 . length ( ) ; final int min ; if ( rlength < llength ) { min = rlength ; } else { min = llength ; } boolean rAtEnd , rHasNoMoreDigits ; while ( ptr < min ) { a = uri0 . charAt ( ptr ) ; b = uri1 . charAt ( ptr ) ; diff = a - b ; if ( ( a >= '9' ) || ( b >= '9' ) || ( a <= '0' ) || ( b <= '0' ) ) { if ( diff != 0 ) { return diff ; } msd = 0 ; } else { if ( msd == 0 ) { msd = diff ; } rAtEnd = rlength - ptr < 2 ; if ( llength - ptr < 2 ) { if ( rAtEnd ) { return msd ; } if ( ! isNotDigit ( a ) && ! isNotDigit ( b ) ) return diff ; return - 1 ; } if ( rAtEnd ) { if ( ! isNotDigit ( a ) &&", "gt": "! isNotDigit ( b ) ) return diff ;", "prediction": "\n", "label": 1}
{"id": 5068, "input": "<s> public interface Element < E extends Element < E , P , V > , P extends PlainForm < E , P , V > , V extends VariableForm", "gt": "< E , P , V > >", "prediction": ")\n", "label": 0}
{"id": 455, "input": "<s> package org . nuxeo . ecm . platform . annotations . configuration . service ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . annotations . gwt . server", "gt": ". configuration . UserInfoMapper ;", "prediction": ";\n", "label": 1}
{"id": 627, "input": "<s> import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; class Main { static int maxLg = 200 ; static Hashtable connections = new Hashtable ( ) ; static Vector v ; static Hashtable parents = new Hashtable ( ) ; static String l [ ] ; static Vector queue = new Vector ( ) ; Main ( ) throws NumberFormatException , IOException { connections . clear ( ) ; int cs = Integer . parseInt ( readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i != cs ; i ++ ) { String l [ ] = split ( readLine ( ) . trim ( ) ) ; if ( ! connections . containsKey ( l [ 0 ] ) ) { connections . put ( l [ 0 ] , new Vector ( ) ) ; } if ( ! connections . containsKey ( l [ 1 ] ) ) { connections . put ( l [ 1 ] , new Vector ( ) ) ; } ( ( Vector ) connections . get ( l [ 0 ] ) ) . addElement ( l [ 1 ] ) ; ( ( Vector ) connections . get ( l [ 1 ] ) ) . addElement ( l [ 0 ] ) ; } l = split ( readLine ( ) . trim ( ) ) ; parents . clear ( ) ; String from = l [ 0 ] , to = l [ 1 ] ; parents . put ( from , from ) ; if ( ! connections . containsKey ( from ) || ! connections . containsKey ( to ) ) { System . out . println ( \"No route\" ) ; return ; } queue . removeAllElements ( ) ; queue . addElement ( from ) ; while ( queue . size ( ) != 0 ) { String next = ( String ) queue . elementAt ( 0 ) ; queue . removeElementAt ( 0 ) ; v = ( ( Vector ) connections . get ( next ) ) ; for ( int i = 0 ; i != v . size ( ) ; i ++ ) { String overNext = ( String ) v . elementAt ( i ) ; if ( overNext . equals ( to ) ) { String t = next , s = \"\" ; while ( t != from ) { s = parents . get ( t ) + \" \" + t + \"\\n\" + s ; t = ( String ) parents . get ( t ) ; } s += ( next + \" \" + to ) ; System . out . println ( s ) ; return ; } if ( ! parents . containsKey ( overNext ) ) { queue . addElement ( overNext ) ; parents . put ( overNext , next ) ; } } } System . out . println ( \"No route\" ) ; } public static void main ( String args [ ] ) throws Exception { int caso = 0 ; do { if ( caso ++ != 0 ) { System . out . println ( ) ; } new Main ( ) ; } while ( readLine ( ) != null ) ; } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String", "gt": "readLine ( ) throws IOException", "prediction": "( )\n", "label": 0}
{"id": 458, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; public class CountingSearchTestTask extends SearchTask { public static int numSearches = 0 ; public static long startMillis ; public static long lastMillis ; public static long prevLastMillis ; public CountingSearchTestTask ( PerfRunData runData ) { super ( runData ) ; } public int doLogic ( ) throws Exception { int res = super . doLogic ( ) ; incrNumSearches ( ) ; return res ; } private static synchronized void incrNumSearches ( ) { prevLastMillis = lastMillis ; lastMillis = System . currentTimeMillis ( ) ; if", "gt": "( 0 == numSearches )", "prediction": "( ) ;\n", "label": 1}
{"id": 1349, "input": "<s> package de . inovex . android . widgets ; import android . content . Context ; import android . content . res . TypedArray ; import android . graphics . Camera ; import android . graphics . Canvas ; import android . graphics . Color ; import android . graphics . Paint ; import android . support . v4 . view . MotionEventCompat ; import android . support . v4 . view . ViewConfigurationCompat ; import android . support . v4 . view . ViewPager ; import android . util . AttributeSet ; import android . view . MotionEvent ; import android . view . View ; import android . view . ViewConfiguration ; import android . view . animation . DecelerateInterpolator ; import android . view . animation . Transformation ; import com . nineoldandroids . animation . Animator ; import com . nineoldandroids . animation . Animator . AnimatorListener ; import com . nineoldandroids . animation . ObjectAnimator ; public class ViewPager3D extends ViewPager { final static float DEFAULT_OVERSCROLL_ROTATION = 2f ; final static int DEFAULT_OVERSCROLL_TRANSLATION = 150 ; final static int DEFAULT_SWIPE_TRANSLATION = 100 ; final static float DEFAULT_SWIPE_ROTATION = 3 ; final private static int DEFAULT_OVERSCROLL_ANIMATION_DURATION = 400 ; final private static boolean DEFAULT_ANIMATE_ALPHA = true ; @ SuppressWarnings ( \"unused\" ) private final static String DEBUG_TAG = ViewPager . class . getSimpleName ( ) ; private final static int INVALID_POINTER_ID = - 1 ; private final static double RADIANS = 180f / Math . PI ; private class OverscrollEffect { private float mOverscroll ; private Animator mAnimator ; public void setPull ( final float deltaDistance ) { mOverscroll = deltaDistance ; invalidate ( ) ; } private void onRelease ( ) { if ( mAnimator != null && mAnimator . isRunning ( ) ) { mAnimator . addListener ( new AnimatorListener ( ) { @ Override public void onAnimationStart ( Animator animation ) { } @ Override public void onAnimationRepeat ( Animator animation ) { } @ Override public void onAnimationEnd ( Animator animation ) { startAnimation ( 0 ) ; } @ Override public void onAnimationCancel ( Animator animation ) { } } ) ; mAnimator . cancel ( ) ; } else { startAnimation ( 0 ) ; } } private void startAnimation ( final float target ) { mAnimator = ObjectAnimator . ofFloat ( this , \"pull\" , mOverscroll , target ) ; mAnimator . setInterpolator ( new DecelerateInterpolator ( ) ) ; final float scale = Math . abs ( target - mOverscroll ) ; mAnimator . setDuration ( ( long ) ( DEFAULT_OVERSCROLL_ANIMATION_DURATION * scale ) ) ; mAnimator . start ( ) ; } private boolean isOverscrolling ( ) { if ( mScrollPosition == 0 && mOverscroll < 0 ) { return true ; } final boolean isLast = ( getAdapter ( ) . getCount ( )", "gt": "- 1 ) == mScrollPosition ;", "prediction": ";\n", "label": 0}
{"id": 473, "input": "<s> package fr . inria . zvtm . engine ; import java . awt . Graphics ; import java . awt . image . BufferedImage ; import javax . swing . JPanel ; import fr . inria . zvtm . event . RepaintListener ; public class ZVTMJPanel extends JPanel { BufferedImage backBuffer ; public View parent ; RepaintListener repaintListener ; public ZVTMJPanel ( ) { super ( ) ; } public void setBackBuffer ( BufferedImage backBuffer ) { this . backBuffer = backBuffer ; } public void setParent ( View parent ) { this . parent = parent ; } public void setRepaintListener ( RepaintListener repaintListener ) { this . repaintListener = repaintListener ; } @ Override public void paint ( Graphics g ) { if ( backBuffer != null ) { g . drawImage ( backBuffer , 0 , 0 , this ) ; if ( repaintListener != null ) { repaintListener . viewRepainted (", "gt": "this . parent ) ;", "prediction": ") ;\n", "label": 1}
{"id": 230, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import java . text . FieldPosition ; import java . text . Format ; import java . text . NumberFormat ; import java . text . ParsePosition ; import java . util . Locale ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJChart ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . ImageBanner ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DJChartBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class FullFeatureReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorder ( Border . PEN_2_POINT ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitleStyle ( titleStyle ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( true ) . setPrintColumnNames ( false ) . setOddRowBackgroundStyle ( oddRowStyle ) . addFirstPageImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/logo_fdv_solutions_60.jpg\" , new Integer ( 197 ) , new Integer ( 60 ) , ImageBanner . ALIGN_LEFT ) . addFirstPageImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/dynamicJasper_60.jpg\" , new Integer ( 300 ) , new Integer ( 60 ) , ImageBanner . ALIGN_RIGHT ) . addImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/logo_fdv_solutions_60.jpg\" , new Integer ( 100 ) , new Integer ( 30 ) , ImageBanner . ALIGN_LEFT ) . addImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/dynamicJasper_60.jpg\" , new Integer ( 150 ) , new Integer ( 30 ) ,", "gt": "ImageBanner . ALIGN_RIGHT ) ;", "prediction": ") ;\n", "label": 0}
{"id": 490, "input": "<s> package org . robotframework . text . ui . outline ; import org . eclipse . xtext . ui . editor . outline . IOutlineNode ; import org . eclipse . xtext . ui . editor . outline . impl . DefaultOutlineTreeProvider ; import org . robotframework . text . space . Keyword ; import org . robotframework . text . space . KeywordSetting ; import org . robotframework . text . space . ListVariable ; import org . robotframework . text . space . RobotStep ; import org . robotframework . text . space . Setting ; import org . robotframework . text . space . TestCase ; import org . robotframework . text . space . TestCaseSetting ; public class SpaceOutlineTreeProvider extends DefaultOutlineTreeProvider { protected boolean _isLeaf ( ListVariable modelElement ) { return true ; } protected boolean _isLeaf ( TestCaseSetting modelElement ) { return true ; } protected boolean _isLeaf ( Setting modelElement ) { return true ; } protected boolean _isLeaf ( RobotStep modelElement ) { return true ; } protected void _createChildren ( IOutlineNode parentNode , Keyword modelElement ) { for ( KeywordSetting setting : modelElement . getSettings ( ) ) { createNode ( parentNode , setting . getSetting ( ) ) ; } for ( RobotStep step : modelElement . getSteps ( ) ) { createNode ( parentNode , step ) ; } } protected void _createChildren ( IOutlineNode parentNode , TestCase modelElement ) { for (", "gt": "TestCaseSetting setting : modelElement . getSettings ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 6892, "input": "<s> public class T6531090b { static class A { public void a1 ( ) { } protected void a2 ( ) { } void a3 ( ) { } public A a1 ; protected A a2 ; A a3 ; } static class B extends A { public void b1 ( ) { } protected void b2 ( ) { } void b3 ( ) { } public B b1 ; protected B b2 ; B b3 ; } static interface I { void i ( ) ; } static interface I1 { void i1 ( ) ; } static class E extends B implements I , I1 { public void i ( ) { } public void i1 ( ) { } } static class C < W extends B & I1 , T extends W > { T t ; W w ; C ( W w , T t ) { this . w = w ; this . t = t ; } } public static void main ( String ... args ) { C < E , E > c = new C < E , E > ( new E ( ) , new E ( ) ) ; testMemberMethods ( c ) ; testMemberFields ( c ) ; } static void testMemberMethods ( C < ? extends A , ? extends I > arg ) { arg . t . a1 ( ) ; arg . t . a2 ( ) ; arg . t . a3 ( ) ; arg . t . b1 ( ) ; arg . t . b2 ( ) ; arg . t . b3 ( ) ; arg . t . i1 ( ) ; arg . w . a1 ( ) ; arg . w . a2 ( ) ; arg . w . a3 ( ) ; arg . w . b1 ( ) ; arg . w . b2 ( ) ; arg . w . b3 ( ) ; arg . w . i1 ( ) ; } static void testMemberFields ( C < ? extends A , ? extends I > arg ) { A ta ; B tb ; ta = arg . t . a1 ; ta = arg . t . a2 ;", "gt": "ta = arg . t . a3 ;", "prediction": "}\n", "label": 0}
{"id": 501, "input": "<s> package org . fuzzydb . client . internal ; import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . fuzzydb . core . query . RetrieveSpec ; import org . fuzzydb . core . query . RetrieveSpecItem ; public class RetrieveSpecImpl implements RetrieveSpec , Serializable { private static final long serialVersionUID = 1L ; private final HashMap < Class < ? extends Object > , HashMap < String , RetrieveSpecItem > > map = new HashMap < Class < ? extends Object > , HashMap < String , RetrieveSpecItem > > ( ) ; public void add ( Class < ? extends Object > clazz , String fieldName , Object key ) { HashMap < String , RetrieveSpecItem > submap = map . get ( clazz ) ; if ( submap == null ) { submap = new HashMap < String , RetrieveSpecItem > ( ) ; map . put ( clazz , submap ) ; } RetrieveSpecItem item = submap . get ( fieldName ) ; if ( item == null ) { item = new RetrieveSpecItemImpl ( fieldName ) ; submap . put ( fieldName , item ) ; } item . add ( key ) ; } public void addAll ( Class < ? extends Object > clazz , String fieldName , Collection < Object > keys ) { HashMap < String , RetrieveSpecItem > submap = map . get ( clazz ) ; if ( submap == null ) { submap = new HashMap < String , RetrieveSpecItem > ( ) ; map . put (", "gt": "clazz , submap ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7833, "input": "<s> class HashMap extends AbstractMap { static final int DEFAULT_INITIAL_CAPACITY = 16 ; static final int MAXIMUM_CAPACITY = 1 << 30 ; static final float DEFAULT_LOAD_FACTOR = 0.75f ; transient Entry [ ] table ; transient int size ; int threshold ; final float loadFactor ; transient volatile int modCount ; public HashMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < 0 ) throw new IllegalArgumentException ( \"Illegal initial capacity: \" + initialCapacity ) ; if ( initialCapacity > MAXIMUM_CAPACITY ) initialCapacity = MAXIMUM_CAPACITY ; if ( loadFactor <= 0 || Float . isNaN ( loadFactor ) ) throw new IllegalArgumentException ( \"Illegal load factor: \" + loadFactor ) ; int capacity = 1 ; while ( capacity < initialCapacity ) capacity <<= 1 ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; table = new Entry [ capacity ] ; init ( ) ; } public HashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public HashMap ( ) { this . loadFactor = DEFAULT_LOAD_FACTOR ; threshold = ( int ) ( DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR ) ; table = new Entry [ DEFAULT_INITIAL_CAPACITY ] ; init ( ) ; } public HashMap ( HashMap m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + 1 , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR ) ; putAllForCreate ( m ) ; } void init ( ) { } static final Object NULL_KEY = new Object ( ) ; static Object maskNull ( Object key ) { return ( key == null ? NULL_KEY : key ) ; } static Object unmaskNull ( Object key ) { return ( key == NULL_KEY ? null : key ) ; } static int hash ( Object x ) { int h = x . hashCode ( ) ; h += ~ ( h << 9 ) ; h ^= ( h > > > 14 ) ; h += ( h << 4 ) ; h ^= ( h > > > 10 ) ; return h ; } static boolean eq ( Object x , Object y ) { return x == y || x . equals ( y ) ; } static int indexFor ( int h , int length ) { return h & ( length - 1 ) ; } public int size ( ) { return size ; } public boolean isEmpty ( ) { return size == 0 ; } public Object get ( Object key ) { Object k = maskNull ( key ) ; int hash = hash ( k ) ; int i = indexFor ( hash , table . length ) ; Entry e = table [ i ] ; while ( true ) { if ( e == null ) return e ; if ( e . hash == hash && eq ( k , e . key ) ) return e . value ; e = e . next ; } } public boolean containsKey ( Object key ) { Object k = maskNull ( key ) ; int hash = hash ( k ) ; int i = indexFor ( hash , table . length ) ; Entry e = table [ i ] ; while ( e != null ) { if ( e . hash == hash && eq ( k , e . key ) ) return true ; e = e . next ; } return false ; } Entry getEntry ( Object key ) { Object k = maskNull ( key ) ; int hash = hash ( k ) ; int i = indexFor ( hash , table . length ) ; Entry e = table [ i ] ; while ( e != null && ! ( e . hash == hash && eq ( k , e . key ) ) ) e = e . next ; return e ; } public Object put ( Object key , Object value ) { Object k = maskNull ( key ) ; int hash = hash ( k ) ; int i = indexFor ( hash , table . length ) ; for ( Entry e = table [ i ] ; e != null ; e = e . next ) { if ( e . hash == hash && eq ( k , e . key ) ) { Object oldValue = e . value ; e . value = value ; e . recordAccess ( this ) ; return oldValue ; } } modCount ++ ; addEntry ( hash , k , value , i ) ; return null ; } private void putForCreate ( Object key , Object value ) { Object k = maskNull ( key ) ; int hash = hash ( k ) ; int i = indexFor ( hash , table . length ) ; for ( Entry e = table [ i ] ; e != null ; e = e . next ) { if ( e . hash == hash && eq ( k , e . key ) ) { e . value = value ; return ; } } createEntry ( hash , k , value , i ) ; } void putAllForCreate ( HashMap m ) { for ( Iterator i = m .", "gt": "entrySet ( ) . iterator ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 524, "input": "<s> package com . abhyrama . smushit ; import java . io . File ; import java . io . FileFilter ; import java . io . IOException ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class SmushImages { protected final String rootDirectory ; protected final Set < String > acceptedFileExtensions ; protected boolean verbose ; protected FileFilter imageFileFilter ; protected FileFilter directoryFilter ; protected boolean dryRun ; protected List < SmushItResultVo > smushItResultVos = new LinkedList < SmushItResultVo > ( ) ; public SmushImages ( String rootDirectory , Set < String > acceptedFileExtensions ) { this . rootDirectory = rootDirectory ; this . acceptedFileExtensions = acceptedFileExtensions ; } public FileFilter getImageFileFilter ( ) { return imageFileFilter ; } public void setImageFileFilter ( FileFilter imageFileFilter ) { this . imageFileFilter = imageFileFilter ; } public FileFilter getDirectoryFilter ( ) { return directoryFilter ; } public void setDirectoryFilter ( FileFilter directoryFilter ) { this . directoryFilter = directoryFilter ; } public boolean isVerbose ( ) { return verbose ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public List < SmushItResultVo > smush ( ) throws IOException { this . smushHelper ( new File ( this . rootDirectory ) ) ; return this . smushItResultVos ; } public boolean isDryRun ( ) { return dryRun ; } public void setDryRun ( boolean dryRun ) { this . dryRun = dryRun ; } protected void smushHelper ( File directory ) throws IOException { if ( this . verbose ) { System . out . println ( \"Smushing files in directory - \" + directory . toString ( ) ) ; } File [ ] images = directory . listFiles ( this . imageFileFilter ) ; if ( images . length > 0 ) { SmushIt smushIt = new SmushIt ( ) ; smushIt . setVerbose ( this . verbose ) ; smushIt . addFiles ( this . arrayToList ( images ) ) ; List < SmushItResultVo > smushItResultVos = smushIt . smush ( ) ; this . smushItResultVos . addAll ( smushItResultVos ) ; if ( ! this . dryRun ) { this . replaceWithSmushedImages ( directory , smushItResultVos ) ; } } File [ ] directories = directory . listFiles ( this . directoryFilter ) ; if ( directories . length > 0 ) { for ( File ddirectory : directories ) { this . smushHelper ( ddirectory ) ; } } } protected List < String > arrayToList ( File [ ] files ) { List < String > fileNames = new LinkedList < String > ( ) ; for ( File file : files ) { fileNames . add ( file . toString ( ) ) ; } return fileNames ; } protected void replaceWithSmushedImages ( File directory , List < SmushItResultVo > smushItResultVos ) throws IOException { ImageDownloader imageDownloader = new ImageDownloader ( directory . toString ( ) ) ; imageDownloader . setVerbose ( this . verbose ) ; List < SmushItResultVo > smushedImages = new LinkedList < SmushItResultVo > ( ) ; for ( SmushItResultVo smushItResultVo : smushItResultVos ) { if ( smushItResultVo . getSmushedImageUrl ( ) != null ) { smushedImages . add ( smushItResultVo ) ; } } imageDownloader . download ( smushedImages ) ; } public static final String IMAGE_DIR_COMMAND_LINE_OPTION = \"imageDir\" ; public static final String VERBOSE_COMMAND_LINE_OPTION = \"verbose\" ; public static final String DRY_RUN_COMMAND_LINE_OPTION = \"dryRun\" ; public static final String IMAGE_EXTENSION_COMMAND_LINE_OPTION = \"imgExtensions\" ; public static final String COMMAND_LINE_OPTION_TRUE = \"true\" ; public static final String COMMAND_LINE_OPTION_FALSE = \"false\" ; public static void main ( String [ ] args ) throws IOException { if ( args . length == 0 ) { printUsageInstructions ( ) ; System . exit ( 0 ) ; } Map < String , String > options = processCommandLineArguments ( args ) ; if ( ! ( options . containsKey ( IMAGE_DIR_COMMAND_LINE_OPTION ) ) ) { displayErrorAndExit ( \"\\nError:Please specify the directory containing the images to be smushed\" ) ; } boolean verbose = false ; if ( options . containsKey ( VERBOSE_COMMAND_LINE_OPTION ) ) { String verboseOptionValue = options . get ( VERBOSE_COMMAND_LINE_OPTION ) ; if ( ! ( COMMAND_LINE_OPTION_TRUE . equals ( verboseOptionValue ) || COMMAND_LINE_OPTION_FALSE . equals ( verboseOptionValue ) ) ) { displayErrorAndExit ( \"\\nError:Verbose option value should be either true or false\" ) ; } verbose = Boolean . valueOf ( verboseOptionValue ) ; } boolean dryRun = false ; if ( options . containsKey ( DRY_RUN_COMMAND_LINE_OPTION ) ) { String dryRunOptionValue = options . get ( DRY_RUN_COMMAND_LINE_OPTION ) ; if ( ! ( COMMAND_LINE_OPTION_TRUE . equals ( dryRunOptionValue ) || COMMAND_LINE_OPTION_FALSE . equals ( dryRunOptionValue ) ) ) { displayErrorAndExit ( \"\\nError:Dry run option value should be either true or false\" ) ; } dryRun = Boolean . valueOf ( dryRunOptionValue ) ; }", "gt": "String rootDirectory = options . get ( IMAGE_DIR_COMMAND_LINE_OPTION ) ;", "prediction": "}\n", "label": 1}
{"id": 1523, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . StatusSheetReport ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class StatusSheetReportTest extends XtextTest { @ Test public void testAllAttributes ( ) { String text = \"statussheetreport \\\"report.tji\\\" { \" + \"end 2011-09-11 \" + \"hideresource \\\"logical expression\\\" \" + \"hidetask \\\"logical expression\\\" \" + \"period 2010-01-16 + 4 m \" + \"sortresources tree \" + \"sorttasks tree \" + \"start 2011-10-11 \" + \"} \" ; testParserRule ( text , StatusSheetReport . class . getSimpleName ( ) ) ; } @ Test public void testAllAttributesMixed ( ) { String text = \"statussheetreport \\\"report.tji\\\" { \" + \"period 2010-01-16 + 4 m \" + \"sortresources tree \" + \"hidetask \\\"logical expression\\\" \" + \"sorttasks tree \" + \"start 2011-10-11 \" + \"end 2011-09-11 \" + \"hideresource \\\"logical expression\\\"", "gt": "\" + \"start 2012-10-11 \" + \"} \" ;", "prediction": ") ;\n", "label": 0}
{"id": 532, "input": "<s> package org . eclipse . rap . rwt . internal . client ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap . rwt . client . Client ; import org . eclipse . rap . rwt . client . WebClient ; public class WebClientProvider implements ClientProvider { public boolean", "gt": "accept ( HttpServletRequest request )", "prediction": "\n", "label": 1}
{"id": 2510, "input": "<s> package LizaCraft . Entity ; import java . util . Collection ; import org . bukkit . entity . ThrownPotion ; import org . bukkit . potion . PotionEffect ; import Liza . LizaThrownPotion ; public class LizaCraftThrownPotion extends LizaCraftProjectile implements LizaThrownPotion { public LizaCraftThrownPotion ( ThrownPotion potion ) { super ( potion ) ; } @ Override public ThrownPotion getBukkitHandle ( ) { return ( ThrownPotion ) this . entity ; } @ Override public Collection < PotionEffect > getEffects ( ) { return this", "gt": ". getBukkitHandle ( ) . getEffects ( ) ;", "prediction": ";\n", "label": 0}
{"id": 547, "input": "<s> package org . eclipse . ui . tests . api . workbenchpart ; import org . eclipse . core . commands . common . EventManager ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPartConstants ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . PlatformUI ; public class RawIViewPart extends EventManager implements IViewPart { private IViewSite site ; private String title = \"SomeTitle\" ; public RawIViewPart ( ) { super ( ) ; } public IViewSite getViewSite ( ) { return site ; } public void setTitle ( String newTitle ) { title = newTitle ; firePropertyChange ( IWorkbenchPartConstants . PROP_TITLE ) ; } public void init ( IViewSite site ) throws PartInitException { this . site = site ; } public void", "gt": "init ( IViewSite site , IMemento memento ) throws PartInitException", "prediction": "( ) ;\n", "label": 1}
{"id": 2013, "input": "<s> package com . sun . tools . javah ; import javax . lang . model . element . ExecutableElement ; import javax . lang . model . element . TypeElement ; import javax . lang . model . element . VariableElement ; import javax . lang . model . util . Elements ; import javax . lang . model . util . Types ; public class Mangle { public static class Type { public static final int CLASS = 1 ; public static final int FIELDSTUB = 2 ; public static final int FIELD = 3 ; public static final int JNI = 4 ; public static final int SIGNATURE = 5 ; public static final int METHOD_JDK_1 = 6 ; public static final int METHOD_JNI_SHORT = 7 ; public static final int METHOD_JNI_LONG = 8 ; } ; private Elements elems ; private Types types ; Mangle ( Elements elems , Types types ) { this . elems = elems ; this . types = types ; } public final String mangle ( CharSequence name , int mtype ) { StringBuffer result = new StringBuffer ( 100 ) ; int length = name . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char ch = name . charAt ( i ) ; if ( isalnum ( ch ) ) { result . append ( ch ) ; } else if ( ( ch == '.' ) && mtype == Mangle . Type . CLASS ) { result . append ( '_' ) ; } else if ( ( ch == '$' ) && mtype == Mangle . Type . CLASS ) { result . append ( '_' ) ; result . append ( '_' ) ; } else if ( ch == '_' && mtype == Mangle . Type . FIELDSTUB ) { result . append ( '_' ) ; } else if ( ch == '_' && mtype == Mangle . Type . CLASS ) { result . append ( '_' ) ; } else if ( mtype == Mangle . Type . JNI ) { String esc = null ; if ( ch == '_' ) esc = \"_1\" ; else if ( ch == '.' ) esc = \"_\" ; else if ( ch == ';' ) esc = \"_2\" ; else if ( ch == '[' ) esc = \"_3\" ; if ( esc != null ) { result . append ( esc ) ; } else { result . append ( mangleChar ( ch ) ) ; } } else if ( mtype == Mangle . Type . SIGNATURE ) { if ( isprint ( ch ) ) { result . append ( ch ) ; } else { result . append ( mangleChar ( ch ) ) ; } } else { result . append ( mangleChar ( ch ) ) ; } } return result . toString ( ) ; } public String mangleMethod ( ExecutableElement method , TypeElement clazz , int mtype ) throws TypeSignature . SignatureException { StringBuffer result = new StringBuffer ( 100 ) ; result . append ( \"Java_\" ) ; if ( mtype == Mangle . Type . METHOD_JDK_1 ) { result . append ( mangle ( clazz . getQualifiedName ( ) , Mangle . Type . CLASS ) ) ; result . append ( '_' ) ; result . append ( mangle ( method . getSimpleName ( ) , Mangle . Type . FIELD ) ) ; result . append ( \"_stub\" ) ; return result . toString ( ) ; } result . append ( mangle ( getInnerQualifiedName ( clazz ) , Mangle . Type . JNI ) ) ; result . append ( '_' ) ; result . append ( mangle ( method . getSimpleName ( ) , Mangle . Type . JNI ) ) ; if ( mtype == Mangle . Type . METHOD_JNI_LONG ) { result . append ( \"__\" ) ; String typesig = signature ( method ) ; TypeSignature newTypeSig = new TypeSignature ( elems ) ; String sig = newTypeSig . getTypeSignature ( typesig , method . getReturnType ( ) ) ; sig = sig . substring ( 1 ) ; sig = sig . substring (", "gt": "0 , sig . lastIndexOf ( ')' ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 552, "input": "<s> package org . eclipse . xtext . xdoc ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . xtext . ISetup ; import org . eclipse . emf . ecore . resource . Resource ; import com . google . inject . Guice ; import com . google . inject . Injector ; @ SuppressWarnings ( \"all\" ) public class XdocStandaloneSetupGenerated implements ISetup { public Injector createInjectorAndDoEMFRegistration ( ) { if ( ! Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . containsKey ( \"ecore\" ) ) Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"ecore\" , new org . eclipse . emf . ecore . xmi . impl . EcoreResourceFactoryImpl ( ) ) ; if ( ! Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . containsKey ( \"xmi\" ) ) Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"xmi\" , new org . eclipse . emf . ecore . xmi . impl . XMIResourceFactoryImpl ( ) ) ; if ( ! EPackage . Registry . INSTANCE . containsKey ( org . eclipse . xtext . XtextPackage . eNS_URI ) ) EPackage . Registry . INSTANCE . put ( org . eclipse . xtext . XtextPackage . eNS_URI , org . eclipse . xtext . XtextPackage . eINSTANCE ) ; Injector injector = createInjector ( ) ; register ( injector ) ; return injector ; } public Injector createInjector ( ) { return Guice . createInjector ( new org . eclipse . xtext . xdoc . XdocRuntimeModule ( ) ) ; } public void register ( Injector injector ) { org . eclipse . xtext . resource . IResourceFactory resourceFactory = injector . getInstance ( org . eclipse . xtext . resource . IResourceFactory . class ) ; org . eclipse . xtext . resource . IResourceServiceProvider serviceProvider = injector . getInstance ( org . eclipse . xtext . resource . IResourceServiceProvider . class ) ; Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"xdoc\" , resourceFactory ) ; org . eclipse . xtext . resource . IResourceServiceProvider . Registry . INSTANCE . getExtensionToFactoryMap ( ) .", "gt": "put ( \"xdoc\" , serviceProvider ) ;", "prediction": ";\n", "label": 1}
{"id": 6761, "input": "<s> package org . ofbiz . order . order ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . Date ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . ListIterator ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralRuntimeException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . ResourceBundleMapWrapper ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . thirdparty . paypal . ExpressCheckoutEvents ; import org . ofbiz . product . product . ProductContentWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelParam ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import com . ibm . icu . util . Calendar ; public class OrderReturnServices { public static final String module = OrderReturnServices . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static final String resourceProduct = \"ProductUiLabels\" ; private static BigDecimal ZERO = BigDecimal . ZERO ; private static int decimals = - 1 ; private static int rounding = - 1 ; static { decimals = UtilNumber . getBigDecimalScale ( \"invoice.decimals\" ) ; rounding = UtilNumber . getBigDecimalRoundingMode ( \"invoice.rounding\" ) ; if ( decimals != - 1 ) ZERO = ZERO . setScale ( decimals ) ; } public static Map < String , Object > getReturnItemInitialCost ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String returnId = ( String ) context . get ( \"returnId\" ) ; String returnItemSeqId = ( String ) context . get ( \"returnItemSeqId\" ) ; Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"initialItemCost\" , getReturnItemInitialCost ( delegator , returnId , returnItemSeqId ) ) ; return result ; } public static Map < String , Object > getOrderAvailableReturnedTotal ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String orderId = ( String ) context . get ( \"orderId\" ) ; OrderReadHelper orh = null ; try { orh = new OrderReadHelper ( delegator , orderId ) ; } catch ( IllegalArgumentException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } BigDecimal adj = ( BigDecimal ) context . get ( \"adjustment\" ) ; if ( adj == null ) { adj = ZERO ; } Boolean countNewReturnItems = ( Boolean ) context . get ( \"countNewReturnItems\" ) ; if ( countNewReturnItems == null ) { countNewReturnItems = Boolean . FALSE ; } BigDecimal returnTotal = orh . getOrderReturnedTotal ( countNewReturnItems . booleanValue ( ) ) ; BigDecimal orderTotal = orh . getOrderGrandTotal ( ) ; BigDecimal available = orderTotal . subtract ( returnTotal ) . subtract ( adj ) ; Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"availableReturnTotal\" , available ) ; result . put ( \"orderTotal\" , orderTotal ) ; result . put ( \"returnTotal\" , returnTotal ) ; return result ; } public static BigDecimal getReturnItemInitialCost ( Delegator delegator , String returnId , String returnItemSeqId ) { if ( delegator == null || returnId == null || returnItemSeqId == null ) { throw new IllegalArgumentException ( \"Method parameters cannot contain nulls\" ) ; } Debug . logInfo ( \"Finding the initial item cost for return item : \" + returnId + \" / \" + returnItemSeqId , module ) ; BigDecimal itemCost = BigDecimal . ZERO ; GenericValue returnItem = null ; try { returnItem = delegator . findOne ( \"ReturnItem\" , UtilMisc . toMap ( \"returnId\" , returnId , \"returnItemSeqId\" , returnItemSeqId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; throw new GeneralRuntimeException ( e . getMessage ( ) ) ; } Debug . logInfo ( \"Return item value object - \" + returnItem , module ) ; if ( returnItem != null ) { String orderId = returnItem . getString ( \"orderId\" ) ; String orderItemSeqId = returnItem . getString ( \"orderItemSeqId\" ) ; if ( orderItemSeqId != null && orderId != null ) { Debug . logInfo ( \"Found order item reference\" , module ) ; List < GenericValue > itemIssue = null ; try { itemIssue = delegator . findByAnd ( \"ItemIssuance\" , UtilMisc . toMap ( \"orderId\" , orderId , \"orderItemSeqId\" , orderItemSeqId ) , null , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; throw new GeneralRuntimeException (", "gt": "e . getMessage ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 558, "input": "<s> package org . eclipse . ui . activities ; public interface IIdentifierListener { void identifierChanged", "gt": "( IdentifierEvent identifierEvent ) ;", "prediction": ";\n", "label": 1}
{"id": 5972, "input": "<s> package org . dawb . workbench . ui . editors . test ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . axis . IAxis ; import org . dawb . workbench . plotting . system . LightWeightPlottingSystem ; import org . dawb . workbench . ui . editors . AsciiEditor ; import org . dawb . workbench . ui . editors . PlotDataEditor ; import org . eclipse . core . filesystem . EFS ; import org . eclipse . core . filesystem . IFileStore ; import org . eclipse . core . runtime . Platform ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . ide . FileStoreEditorInput ; import org . junit . Test ; import org . osgi . framework . Bundle ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . LongDataset ; import fable . framework . toolbox . EclipseUtils ; public class SWTXYAxisTest { @ Test public void testChoerant1 ( ) throws Throwable { createAxisTest ( createTestArraysCoherant ( 10 , 1000 , \"Long set \" ) , false ) ; } @ Test public void testChoerant2 ( ) throws Throwable { createAxisTest ( createTestArraysCoherant ( 5 , 1000 , \"Long set \" ) , true ) ; } @ Test public void testRandom1 ( ) throws Throwable { createAxisTest ( createTestArraysRandom ( 10 , 1000 ) , false ) ; } @ Test public void testRandom2 ( ) throws Throwable { createAxisTest ( createTestArraysRandom ( 5 , 1000 ) , true ) ; } private void createAxisTest ( final List < AbstractDataset > ys , boolean multipleAxes ) throws Throwable { final Bundle bun = Platform . getBundle ( \"org.dawb.workbench.ui.test\" ) ; String path = ( bun . getLocation ( ) + \"src/org/dawb/workbench/ui/editors/test/ascii.dat\" ) ; path = path . substring ( \"reference:file:\" . length ( ) ) ; if ( path . startsWith ( \"/C:\" ) ) path = path . substring ( 1 ) ; final IWorkbenchPage page = EclipseUtils . getPage ( ) ; final IFileStore externalFile = EFS . getLocalFileSystem ( ) . fromLocalFile ( new File ( path ) ) ; final IEditorPart part = page . openEditor ( new FileStoreEditorInput ( externalFile ) , AsciiEditor . ID ) ; final AsciiEditor editor = ( AsciiEditor ) part ; final PlotDataEditor plotter = ( PlotDataEditor ) editor . getActiveEditor ( ) ; final AbstractPlottingSystem sys = plotter . getPlottingSystem ( ) ; if ( ! ( sys instanceof LightWeightPlottingSystem ) ) throw new Exception ( \"This test is designed for \" + LightWeightPlottingSystem . class . getName ( ) ) ; page . setPartState ( EclipseUtils . getPage ( ) . getActivePartReference ( ) , IWorkbenchPage . STATE_MAXIMIZED ) ; sys . clear ( ) ; AbstractDataset indices = AbstractDataset . arange ( 0 , ys . get ( 0 ) . getSize ( ) , 1 , AbstractDataset . INT32 ) ; if ( ! multipleAxes ) { final IAxis primaryY = sys . getSelectedYAxis ( ) ; final IAxis alternateYaxis = sys . createAxis ( \"Alternate\" , true ,", "gt": "SWT . LEFT ) ;", "prediction": ") ;\n", "label": 0}
{"id": 583, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage ; import com . puppycrawl . tools . checkstyle . BaseCheckTestCase ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class UnusedPrivateFieldCheckTest extends BaseCheckTestCase { public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedPrivateFieldCheck . class ) ; final String [ ] expected = { \"10:17: Unused private field 'mUnreadPrimitive'.\" , \"16:19: Unused private field 'mUnreadArray'.\" , \"20:17: Unused private field 'mUnused2'.\" , \"22:30: Unused private field 'SUNUSED'.\" , \"64:17: Unused private field 'mUnused'.\" , } ; verify ( checkConfig , getPath ( \"usage/InputUnusedField.java\" ) , expected ) ; } public void testIgnoreFormat ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig", "gt": "( UnusedPrivateFieldCheck . class ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 5235, "input": "<s> enum Color { red , green } public class EnumSwitch { static int f ( Color c ) { switch ( c ) { case red : return 1 ; case green : return 2 ; default : return 0 ; } } public static void main (", "gt": "String [ ] args )", "prediction": ")\n", "label": 0}
{"id": 594, "input": "<s> package fr . inria . zvtm . glyphs ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics2D ; import java . awt . Stroke ; import java . awt . Shape ; import java . awt . geom . AffineTransform ; import java . util . ArrayList ; import java . util . List ; import fr . inria . zvtm . engine . Camera ; public class SemZoomGlyph extends Glyph { private final ArrayList < Glyph > glyphs ; private final ArrayList < Double > transitions ; public SemZoomGlyph ( List < Glyph > glyphs , List < Double > transitions ) { if ( glyphs == null ) { throw new IllegalArgumentException ( \"null array of Glyphs\" ) ; } if ( transitions . size ( ) != ( glyphs . size ( ) - 1 ) ) { throw new IllegalArgumentException ( \"incorrect number of transitions (\" + ( glyphs . size ( ) - 1 ) + \" transitions expected)\" ) ; } this . glyphs = new ArrayList < Glyph > ( glyphs ) ; this . transitions = new ArrayList < Double > ( transitions ) ; } @ Override public boolean fillsView ( double w , double h , int camIndex ) { return false ; } @ Override public short mouseInOut ( int jpx , int jpy , int camIndex , double cvx , double cvy ) { return NO_CURSOR_EVENT ; } @ Override public void resetMouseIn ( ) { } @ Override public void resetMouseIn ( int i ) { } @ Override public boolean coordInside ( int jpx , int jpy , int camIndex , double cvx , double cvy ) { return true ; } @ Override public void removeCamera ( int index ) { for ( Glyph glyph : glyphs ) { glyph . removeCamera ( index ) ; } } @ Override public void addCamera ( int index ) { for ( Glyph glyph : glyphs ) { glyph . addCamera ( index ) ; } } @ Override public void initCams ( int nbCam ) { for ( Glyph glyph : glyphs ) { glyph . initCams ( nbCam ) ; } } @ Override public void drawForLens ( Graphics2D g , int vW , int vH , int i , Stroke stdS , AffineTransform stdT , int dx , int dy ) { Glyph glyph = selectChild ( i ) ; glyph . drawForLens ( g , vW , vH , i , stdS , stdT , dx , dy ) ; } @ Override public void draw ( Graphics2D g , int vW , int vH , int i , Stroke stdS , AffineTransform stdT , int dx , int dy ) {", "gt": "Glyph glyph = selectChild ( i ) ;", "prediction": ";\n", "label": 1}
{"id": 7185, "input": "<s> package org . ofbiz . service . calendar ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import com . ibm . icu . util . Calendar ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastSet ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; public class ExpressionUiHelper { public static final int Occurrence [ ] = { 1 , 2 , 3 , 4 , 5 , - 1 , - 2 , - 3 , - 4 - 5 } ; public static List < ? > getOccurrenceList ( ) { return Arrays . asList ( Occurrence ) ; } public static List < Map < String , Object > > getDayValueList ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . DAY_OF_WEEK , tempCal . getFirstDayOfWeek ( ) ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( \"EEEE\" , locale ) ; List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) { result . add ( UtilMisc . toMap ( \"description\" , ( Object ) dateFormat . format ( tempCal . getTime ( ) ) , \"value\" , tempCal . get ( Calendar . DAY_OF_WEEK ) ) ) ; tempCal . roll ( Calendar . DAY_OF_WEEK , 1 ) ; } return result ; } public static int getFirstDayOfWeek ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; return tempCal . getFirstDayOfWeek ( ) ; } public static int getLastDayOfWeek ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . DAY_OF_WEEK , tempCal . getFirstDayOfWeek ( ) ) ; tempCal . roll ( Calendar . DAY_OF_WEEK , - 1 ) ; return tempCal . get ( Calendar . DAY_OF_WEEK ) ; } public static List < Map < String , Object > > getMonthValueList ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . MONTH , Calendar . JANUARY ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( \"MMMM\" , locale ) ; List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 13 ) ; for ( int i = Calendar . JANUARY ; i <= tempCal . getActualMaximum ( Calendar . MONTH ) ; i ++ ) { result . add ( UtilMisc . toMap ( \"description\" , ( Object ) dateFormat . format ( tempCal . getTime ( ) ) , \"value\" , i ) ) ; tempCal . roll ( Calendar . MONTH , 1 ) ; } return result ; } public static List < Map < String , Object > > getFrequencyValueList ( Map < String , Object > uiLabelMap ) { List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 6 ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonSecond\" ) , \"value\" , Calendar . SECOND ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonMinute\" ) , \"value\" , Calendar . MINUTE ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonHour\" ) , \"value\" , Calendar . HOUR_OF_DAY ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonDay\" ) , \"value\" , Calendar . DAY_OF_MONTH ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonMonth\" ) , \"value\" , Calendar . MONTH ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonYear\" ) ,", "gt": "\"value\" , Calendar . YEAR ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 615, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . editor ; import org . nuxeo . ecm . platform . gwt . client . ui . View ; public class DocumentViewPage implements EditorPage { public String getName ( ) { return \"view\" ; }", "gt": "public View getView ( )", "prediction": "}\n", "label": 1}
{"id": 4149, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface NewArrayTree extends ExpressionTree { Tree getType ( ) ; List < ? extends ExpressionTree > getDimensions ( ) ; List < ? extends", "gt": "ExpressionTree > getInitializers ( ) ;", "prediction": "\n", "label": 0}
{"id": 625, "input": "<s> package com . emf4sw . owl . impl . notify ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . impl . AdapterImpl ; import org . eclipse . emf . ecore . EObject ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . ObjectProperty ; import com . emf4sw . owl . Ontology ; import com . emf4sw . owl . vocabulary . OWL ; import com . emf4sw . rdf . Node ; import com . emf4sw . rdf . vocabulary . RDF ; import com . emf4sw . rdf . vocabulary . RDFS ; public abstract class ClassPropertyTripleAdapter extends AdapterImpl { public ClassPropertyTripleAdapter ( ) { } @ Override public void notifyChanged ( Notification msg ) { super . notifyChanged ( msg ) ; } protected void addPropertyTypeTriple ( Notification msg , Ontology ontology , String type ) { final boolean value = msg . getNewBooleanValue ( ) ; if ( value ) ontology . addTriple ( ( Node ) msg . getNotifier ( ) , ontology . getProperty ( RDF . type ) , ontology . getResource ( type ) ) ; } protected void addPropertyValueTriple ( Notification msg , Ontology ontology , String type ) { if ( ontology == null || ontology . getProperty ( type ) == null ) return ; final Object value = msg . getNewValue ( ) ; if ( value != null ) { ontology . addTriple ( ( Node ) msg . getNotifier ( ) , ontology . getProperty ( type ) , ( Node ) value ) ; } } public static class ObjectPropertyTripleAdapter extends ClassPropertyTripleAdapter { public ObjectPropertyTripleAdapter ( ) { } @ Override public void notifyChanged ( Notification msg ) { switch ( msg . getEventType ( ) ) { case Notification . ADD : case Notification . ADD_MANY : if ( msg . getNotifier ( ) instanceof EObject ) { Ontology ontology = ( Ontology ) ( ( EObject ) msg . getNotifier ( ) ) . eContainer ( ) ; switch ( msg . getFeatureID ( ObjectProperty . class ) ) { case OWLPackage . OBJECT_PROPERTY__DOMAIN : addPropertyValueTriple ( msg , ontology , RDFS . domain ) ; break ; case OWLPackage . OBJECT_PROPERTY__RANGE : addPropertyValueTriple ( msg , ontology , RDFS . range ) ; break ; case OWLPackage . OBJECT_PROPERTY__SUB_PROPERTY_OF : addPropertyValueTriple ( msg , ontology , RDFS . subPropertyOf ) ; break ; case OWLPackage . OBJECT_PROPERTY__EQUIVALENT_PROPERTIES : addPropertyValueTriple ( msg , ontology , OWL . equivalentProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__DISJOINT_PROPERTIES : addPropertyValueTriple ( msg , ontology , OWL . propertyDisjointWith ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_FUNCTIONAL : addPropertyTypeTriple ( msg , ontology , OWL . FunctionalProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_INVERSE_FUNCTIONAL : addPropertyTypeTriple ( msg , ontology , OWL . InverseFunctionalProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_SYMMETRIC : addPropertyTypeTriple ( msg , ontology , OWL . SymmetricProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_ASYMMETRIC : addPropertyTypeTriple ( msg , ontology , OWL . AsymmetricProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_TRANSITIVE : addPropertyTypeTriple ( msg , ontology , OWL . TransitiveProperty ) ; break ; case OWLPackage . OBJECT_PROPERTY__IS_REFLEXIVE : addPropertyTypeTriple ( msg , ontology ,", "gt": "OWL . ReflexiveProperty ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6055, "input": "<s> package com . gisgraphy . client . nameformatters ; import com . gisgraphy . client . commons . NamePart ; import com . google . common . collect . ImmutableList ; public class ShortUsStyleNamesExtractor implements NamesExtractor { public ImmutableList < String > extractNames ( ImmutableList < NamePart > nameParts ) { if ( nameParts . size ( ) < 3 ) { throw new IllegalArgumentException ( \"There should be at least 3 NameParts : a Country, a first-order administrative division, and a name\" ) ; } return ImmutableList . of ( adm1Code ( nameParts ) , featureName ( nameParts ) ) ; } private String featureName ( ImmutableList < NamePart > nameParts ) { return nameParts . get ( nameParts . size ( ) - 1 ) . getName ( ) ; } private String adm1Code ( ImmutableList < NamePart > nameParts ) { return nameParts .", "gt": "get ( 1 ) . getFriendlyCode ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 642, "input": "<s> package org . eclipse . jface . internal . databinding . viewers ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; public class CheckboxTreeViewerUpdater extends TreeViewerUpdater { private final CheckboxTreeViewer checkboxViewer ; CheckboxTreeViewerUpdater ( CheckboxTreeViewer viewer ) { super ( viewer ) ; checkboxViewer = viewer ; } public void move ( Object parent , Object element , int oldPosition , int newPosition ) { if ( isElementOrderPreserved ( ) ) { boolean wasChecked = checkboxViewer . getChecked ( element ) ; boolean wasGrayed = checkboxViewer . getGrayed ( element ) ; super . move ( parent , element", "gt": ", oldPosition , newPosition ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4243, "input": "<s> package MultipleInheritance ; import java . util . * ; interface XList1 extends List , Collection { } interface XList2 < E > extends List < E > , Collection < E > { } interface XList3 < E > extends List < E > , Collection < E > { public < T > T [ ]", "gt": "toArray ( T [ ] target ) ;", "prediction": "\n", "label": 0}
{"id": 651, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . IToolItemAdapter ; import org . eclipse . swt . internal . widgets . toolbarkit . ToolBarThemeAdapter ; public class ToolItem extends Item { private static final int DEFAULT_WIDTH = 24 ; private static final int DEFAULT_HEIGHT = 22 ; private final ToolBar parent ; private boolean selected ; private Control control ; private int width ; private boolean computedWidth ; private String toolTipText ; private boolean visible ; private Image disabledImage ; private Image hotImage ; private transient IToolItemAdapter toolItemAdapter ; public ToolItem ( ToolBar parent , int style ) { this ( checkNull ( parent ) , checkStyle ( style ) , parent . getItemCount ( ) ) ; } public ToolItem ( ToolBar parent , int style , int index ) { super ( parent , checkStyle ( style ) ) ; this . parent = parent ; this . visible = true ; computedWidth = true ; parent . createItem ( this , index ) ; computeInitialWidth ( ) ; } public ToolBar getParent ( ) { checkWidget ( ) ; return parent ; } public void setText ( String text ) { checkWidget ( ) ; if ( text == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( ( style & SWT . SEPARATOR ) == 0 ) { super . setText ( text ) ; parent . layoutItems ( ) ; } } public void setImage ( Image image ) { checkWidget ( ) ; if ( ( style & SWT . SEPARATOR ) == 0 ) { super . setImage ( image ) ; parent . layoutItems ( ) ; } } public void setDisabledImage ( Image image ) { checkWidget ( ) ; if ( ( style & SWT . SEPARATOR ) == 0 ) { disabledImage = image ; parent . layoutItems ( ) ; } } public Image getDisabledImage ( ) { checkWidget ( ) ; return disabledImage ; } public void setHotImage ( Image image ) { checkWidget ( ) ; if ( ( style & SWT . SEPARATOR ) == 0 ) { hotImage = image ; parent . layoutItems ( ) ; } } public Image getHotImage ( ) { checkWidget ( ) ; return hotImage ; } public void setControl ( Control control ) { checkWidget ( ) ; if ( control != null ) { if ( control . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( control . getParent ( ) != parent ) { SWT . error ( SWT . ERROR_INVALID_PARENT ) ; } } if ( ( style & SWT . SEPARATOR ) != 0 ) { if ( this . control != null && ! this . control . isDisposed ( ) ) { this . control . setVisible ( false ) ; } this . control = control ; if ( this . control != null ) { this . control . setVisible ( true ) ; } resizeControl ( ) ; } } public Control getControl ( ) { checkWidget ( ) ; return control ; } public void setToolTipText ( String string ) { checkWidget ( ) ; toolTipText = string ; } public String getToolTipText ( ) { checkWidget ( ) ; return toolTipText ; } public void setEnabled ( boolean enabled ) { checkWidget ( ) ; if ( enabled ) { state &= ~ DISABLED ; } else { state |= DISABLED ; } } public boolean getEnabled ( ) { checkWidget ( ) ; return ( state & DISABLED ) == 0 ; } public boolean isEnabled ( ) { checkWidget ( ) ; return getEnabled ( ) && parent . isEnabled ( ) ; } public Rectangle getBounds ( ) { checkWidget ( ) ; Rectangle clientArea = parent . getClientArea ( ) ; int left = clientArea . x ; int top = clientArea . y ; int width = getWidth ( ) ; int height = getHeight ( ) ; int index = parent . indexOf ( this ) ; if ( ( parent . style & SWT . VERTICAL ) != 0 ) { if ( index > 0 ) { Rectangle upperSiblingBounds = parent . getItem ( index - 1 ) . getBounds ( ) ; top += upperSiblingBounds . y + upperSiblingBounds . height ; top += getToolBarSpacing ( ) ; } else { top += parent . getToolBarPadding ( ) . y ; } int innerParentWidth = parent . getSize ( ) . x - parent . getToolBarPadding ( ) . width ; left += parent . getToolBarPadding ( ) . x + innerParentWidth / 2 - width / 2 ; left = Math . max ( left , 0 ) ; } else { if ( index > 0 ) { Rectangle leftSiblingBounds = parent . getItem ( index - 1 ) . getBounds ( ) ; left += leftSiblingBounds . x + leftSiblingBounds . width ; left += getToolBarSpacing ( ) ; } else { left += parent . getToolBarPadding ( ) . x ; } int innerParentHeight = parent . getSize ( ) . y - parent . getToolBarPadding ( ) . height - parent .", "gt": "getBorderWidth ( ) * 2 ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8436, "input": "<s> package com . sun . tools . javac . comp ; import java . util . * ; import java . util . Set ; import javax . lang . model . element . ElementKind ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . jvm . * ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . jvm . Target ; import com . sun . tools . javac . code . Lint . LintCategory ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . tree . JCTree . * ; import com . sun . tools . javac . code . Type . * ; import com . sun . source . tree . IdentifierTree ; import com . sun . source . tree . MemberSelectTree ; import com . sun . source . tree . TreeVisitor ; import com . sun . source . util . SimpleTreeVisitor ; import static com . sun . tools . javac . code . Flags . * ; import static com . sun . tools . javac . code . Kinds . * ; import static com . sun . tools . javac . code . TypeTags . * ; public class Attr extends JCTree . Visitor { protected static final Context . Key < Attr > attrKey = new Context . Key < Attr > ( ) ; final Names names ; final Log log ; final Symtab syms ; final Resolve rs ; final Infer infer ; final Check chk ; final MemberEnter memberEnter ; final TreeMaker make ; final ConstFold cfolder ; final Enter enter ; final Target target ; final Types types ; final JCDiagnostic . Factory diags ; final Annotate annotate ; final DeferredLintHandler deferredLintHandler ; public static Attr instance ( Context context ) { Attr instance = context . get ( attrKey ) ; if ( instance == null ) instance = new Attr ( context ) ; return instance ; } protected Attr ( Context context ) { context . put ( attrKey , this ) ; names = Names . instance ( context ) ; log = Log . instance ( context ) ; syms = Symtab . instance ( context ) ; rs = Resolve . instance ( context ) ; chk = Check . instance ( context ) ; memberEnter = MemberEnter . instance ( context ) ; make = TreeMaker . instance ( context ) ; enter = Enter . instance ( context ) ; infer = Infer . instance ( context ) ; cfolder = ConstFold . instance ( context ) ; target = Target . instance ( context ) ; types = Types . instance ( context ) ; diags = JCDiagnostic . Factory . instance ( context ) ; annotate = Annotate . instance ( context ) ; deferredLintHandler = DeferredLintHandler . instance ( context ) ; Options options = Options . instance ( context ) ; Source source = Source . instance ( context ) ; allowGenerics = source . allowGenerics ( ) ; allowVarargs = source . allowVarargs ( ) ; allowEnums = source . allowEnums ( ) ; allowBoxing = source . allowBoxing ( ) ; allowCovariantReturns = source . allowCovariantReturns ( ) ; allowAnonOuterThis = source . allowAnonOuterThis ( ) ; allowStringsInSwitch = source . allowStringsInSwitch ( ) ; sourceName = source . name ; relax = ( options . isSet ( \"-retrofit\" ) || options . isSet ( \"-relax\" ) ) ; findDiamonds = options . get ( \"findDiamond\" ) != null && source . allowDiamond ( ) ; useBeforeDeclarationWarning = options . isSet ( \"useBeforeDeclarationWarning\" ) ; } boolean relax ; boolean allowGenerics ; boolean allowVarargs ; boolean allowEnums ; boolean allowBoxing ; boolean allowCovariantReturns ; boolean allowAnonOuterThis ; boolean findDiamonds ; static final boolean allowDiamondFinder = true ; boolean useBeforeDeclarationWarning ; boolean allowStringsInSwitch ; String sourceName ; Type check ( JCTree tree , Type owntype , int ownkind , int pkind , Type pt ) { if ( owntype . tag != ERROR && pt . tag != METHOD && pt . tag != FORALL ) { if ( ( ownkind & ~ pkind ) == 0 ) { owntype = chk . checkType ( tree . pos ( ) , owntype , pt , errKey ) ; } else { log . error ( tree . pos ( ) , \"unexpected.type\" , kindNames ( pkind ) , kindName ( ownkind ) ) ; owntype = types . createErrorType ( owntype ) ; } } tree . type = owntype ; return owntype ; } boolean isAssignableAsBlankFinal ( VarSymbol v , Env < AttrContext > env ) { Symbol owner = env . info . scope . owner ; return v . owner == owner || ( ( owner . name == names . init || owner . kind == VAR || ( owner . flags ( ) & BLOCK ) != 0 ) && v . owner == owner . owner && ( ( v . flags ( ) & STATIC ) != 0 ) == Resolve . isStatic ( env ) ) ; } void checkAssignable ( DiagnosticPosition pos , VarSymbol v , JCTree base , Env < AttrContext > env ) { if ( ( v . flags ( ) & FINAL ) != 0 && ( ( v . flags ( ) & HASINIT ) != 0 || ! ( ( base == null || ( base . getTag ( ) == JCTree . IDENT && TreeInfo . name ( base ) == names . _this ) ) && isAssignableAsBlankFinal ( v , env ) ) ) ) { if ( v . isResourceVariable ( ) ) { log . error ( pos , \"try.resource.may.not.be.assigned\" , v ) ; } else { log . error ( pos , \"cant.assign.val.to.final.var\" , v ) ; } } else if ( ( v . flags ( ) & EFFECTIVELY_FINAL ) != 0 ) { v . flags_field &= ~ EFFECTIVELY_FINAL ; } } boolean isStaticReference ( JCTree tree ) { if ( tree . getTag ( ) == JCTree . SELECT ) { Symbol lsym = TreeInfo . symbol ( (", "gt": "( JCFieldAccess ) tree ) . selected ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 666, "input": "<s> package org . eclipse . jface . databinding . dialog ; import org . eclipse . core . databinding . ValidationStatusProvider ; import org . eclipse . jface . dialogs . IMessageProvider ; public interface IValidationMessageProvider { public", "gt": "String getMessage ( ValidationStatusProvider statusProvider ) ;", "prediction": "\n", "label": 1}
{"id": 3962, "input": "<s> import com . test . Test$Test$Test ; public class T6397652 { Object", "gt": "obj = new Test$Test$Test ( ) ;", "prediction": "\n", "label": 0}
{"id": 667, "input": "<s> package org . fuzzydb . util . context ; public interface ApplicationContext { public Object get ( String name ) ; public void", "gt": "set ( String name , Object objInstance ) ;", "prediction": "( )\n", "label": 1}
{"id": 5890, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; public class DocletAbortException extends RuntimeException {", "gt": "private static final long serialVersionUID = - 9131058909576418984L ;", "prediction": "\n", "label": 0}
{"id": 680, "input": "<s> package org . apache . lucene . analysis . fr ; import java . io . StringReader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . util . Version ; public class TestFrenchAnalyzer extends BaseTokenStreamTestCase { public void testAnalyzer ( ) throws Exception { FrenchAnalyzer fa = new FrenchAnalyzer ( Version . LUCENE_CURRENT ) ; boolean iaeFlag = false ; try { fa . tokenStream ( \"dummy\" , null ) ; } catch ( IllegalArgumentException iae ) { iaeFlag = true ; } assertEquals ( iaeFlag , true ) ; iaeFlag = false ; try { fa . tokenStream ( null , new StringReader ( \"dummy\" ) ) ; } catch ( IllegalArgumentException iae ) { iaeFlag = true ; } assertEquals ( iaeFlag , true ) ; assertAnalyzesTo ( fa , \"\" , new String [ ] { } ) ; assertAnalyzesTo ( fa , \"chien chat cheval\" , new String [ ] { \"chien\" , \"chat\" , \"cheval\" } ) ; assertAnalyzesTo ( fa , \"chien CHAT CHEVAL\" , new String [ ] { \"chien\" , \"chat\" , \"cheval\" } ) ; assertAnalyzesTo ( fa , \"  chien  ,? + = -  CHAT /: > CHEVAL\" , new String [ ] { \"chien\" , \"chat\" , \"cheval\" } ) ; assertAnalyzesTo ( fa , \"chien++\" , new String [ ] { \"chien\" } ) ; assertAnalyzesTo ( fa , \"mot \\\"entreguillemet\\\"\" , new String [ ] { \"mot\" , \"entreguillemet\" } ) ; assertAnalyzesTo ( fa , \"Jean-Fran\u00e7ois\" , new String [ ] { \"jean\" , \"fran\u00e7ois\" } ) ; assertAnalyzesTo ( fa , \"le la chien les aux chat du des \u00e0 cheval\" , new String [ ] { \"chien\" , \"chat\" , \"cheval\" } ) ; assertAnalyzesTo ( fa , \"lances chismes habitable chiste \u00e9l\u00e9ments captifs\" , new String [ ] { \"lanc\" , \"chism\" , \"habit\" , \"chist\" , \"\u00e9l\u00e9ment\" , \"captif\" } ) ; assertAnalyzesTo ( fa , \"finissions souffrirent rugissante\" , new String [ ] { \"fin\" , \"souffr\" , \"rug\" } ) ; assertAnalyzesTo ( fa , \"C3PO aujourd'hui oeuf \u00ef\u00e2\u00f6\u00fb\u00e0\u00e4 anticonstitutionnellement Java++ \" , new String [ ] { \"c3po\" , \"aujourd'hui\" , \"oeuf\" , \"\u00ef\u00e2\u00f6\u00fb\u00e0\u00e4\" , \"anticonstitutionnel\" , \"jav\" } ) ; assertAnalyzesTo ( fa , \"33Bis 1940-1945 1940:1945 (---i+++)*\" , new String [ ] { \"33bis\" , \"1940-1945\" , \"1940\" , \"1945\" , \"i\" } ) ; } public void testReusableTokenStream ( ) throws Exception { FrenchAnalyzer fa = new FrenchAnalyzer ( ) ; assertAnalyzesToReuse ( fa , \"le la chien les", "gt": "aux chat du des \u00e0 cheval\" , new String [ ]", "prediction": ") ;\n", "label": 1}
{"id": 8559, "input": "<s> public class T6869075 { static class Foo < X > { X x ; Foo ( X x ) { this . x = x ; } } static void test1 ( Foo < String > foo ) { String start = foo . x ; equals ( foo . x += \"foo\" , start + \"foo\" ) ; } static void test2 ( Foo < String > foo ) { String start = foo . x ; equals ( ( foo . x += \"foo\" ) , ( start + \"foo\" ) ) ; } static void test3 ( Foo < String > foo ) { String start = foo . x ; equals ( ( ( foo . x += \"foo\" ) ) , ( ( start + \"foo\" ) ) ) ; } public static void main ( String [ ] args ) { test1 ( new Foo < String > ( \"Hello!\" ) ) ; test2 ( new Foo < String > ( \"Hello!\" ) ) ; test3 ( new Foo < String > ( \"Hello!\" ) ) ; } static void equals ( String found , String req ) { if ( ! found . equals ( req ) ) { throw new AssertionError ( \"Error (expected: \" + req + \" - found: \"", "gt": "+ found + \")\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 685, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import org . eclipse . rap . rwt . internal . theme . AppearancesUtil ; import junit . framework . TestCase ; public class AppearancesUtil_Test extends TestCase { public void testReadAppearanceFile ( ) throws Exception { String input = \"some ignored content here {\\n\" + \"// any chars before ... BEGIN TEMPLATE ... and after are ok ...\\n\" + \"This is the real content, line 1\\n\" + \"and line 2\\n\" + \"// this does not hurt END TEMPLATE and this does not hurt, too...\\n\" + \"} and some more ignored content\\n\" ; InputStream inStream = new ByteArrayInputStream ( input . getBytes ( ) ) ; String content = AppearancesUtil", "gt": ". readAppearanceFile ( inStream ) ;", "prediction": ";\n", "label": 1}
{"id": 3802, "input": "<s> import java . io . * ; import java . util . * ; public class T6715251 { public static void main ( String ... args ) throws Exception { new T6715251 ( ) . run ( ) ; } void run ( ) throws Exception { String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; test ( 2 ) ; test ( 0 , \"-help\" ) ; test ( 0 , \"-version\" ) ; test ( 0 , \"-fullversion\" ) ; test ( 0 , \"-classpath\" , testClasses , \"T6715251\" ) ; if ( errors > 0 ) throw new Exception ( errors + \" errors received\" ) ; } void test ( int expect , String ... args ) { int rc = javap ( args ) ; if ( rc != expect ) error ( \"bad result: expected: \" + expect + \", found \" + rc + \"\\n\" + log ) ; }", "gt": "int javap ( String ... args )", "prediction": "}\n", "label": 0}
{"id": 687, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackManager ; import org . eclipse . rap . rwt . internal . util . SerializableLock ; import org . eclipse . rap . rwt . lifecycle . UICallBack ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . internal . Compatibility ; import org . eclipse . swt . internal . SerializableCompatibility ; public class Synchronizer implements SerializableCompatibility { Display display ; int messageCount ; RunnableLock [ ] messages ; Object messageLock = new SerializableLock ( ) ; Thread syncThread ; static final int GROW_SIZE = 4 ; static final int MESSAGE_LIMIT = 64 ; static final boolean IS_CARBON = \"carbon\" . equals ( SWT . getPlatform ( ) ) ; static final boolean IS_COCOA = \"cocoa\" . equals ( SWT . getPlatform ( ) ) ; static final boolean IS_GTK = \"gtk\" . equals ( SWT . getPlatform ( ) ) ; public Synchronizer ( Display display ) { this . display = display ; } void addLast ( RunnableLock lock ) { boolean wake = false ; synchronized ( messageLock ) { if ( messages == null ) messages = new RunnableLock [ GROW_SIZE ] ; if ( messageCount == messages . length ) { RunnableLock [ ] newMessages = new RunnableLock [ messageCount + GROW_SIZE ] ; System . arraycopy ( messages , 0 , newMessages , 0 , messageCount ) ; messages = newMessages ; } messages [ messageCount ++ ] = lock ; if ( messageCount == 1 ) { UICallBack . runNonUIThreadWithFakeContext ( display , new Runnable ( ) { public void run ( ) { UICallBackManager . getInstance ( ) . setHasRunnables ( true ) ; } } ) ; } runnableAdded ( lock . runnable ) ; wake = messageCount == 1 ; } if ( wake ) display . wakeThread ( ) ; } protected void runnableAdded ( Runnable runnable ) { } protected void asyncExec ( Runnable runnable ) { if ( runnable == null ) { if ( ! ( IS_CARBON || IS_GTK || IS_COCOA ) ) { display . wake ( ) ; return ; } } addLast ( new RunnableLock ( runnable ) ) ; } int getMessageCount ( ) { synchronized ( messageLock ) { return messageCount ; } } void releaseSynchronizer ( ) { RunnableLock runnableLock = removeFirst ( ) ; while ( runnableLock != null ) { if ( runnableLock . thread != null ) { runnableLock . runnable = null ; synchronized ( runnableLock ) { runnableLock . notify ( ) ; } } runnableLock = removeFirst ( ) ; } messages = null ; messageLock = null ; syncThread = null ; } RunnableLock removeFirst ( ) { synchronized ( messageLock ) { if ( messageCount == 0 ) return null ; RunnableLock lock = messages [ 0 ] ; System . arraycopy ( messages , 1 , messages , 0 , -- messageCount ) ; messages [ messageCount ] = null ; if ( messageCount == 0 ) { if ( messages . length > MESSAGE_LIMIT ) messages = null ; } if ( messageCount == 0 ) { UICallBack . runNonUIThreadWithFakeContext ( display , new Runnable ( ) { public void run ( ) { UICallBackManager . getInstance ( ) . setHasRunnables ( false ) ; } } ) ; } return lock ; } } boolean runAsyncMessages ( ) { return runAsyncMessages ( false ) ; } boolean runAsyncMessages ( boolean all ) { boolean run = false ; do { RunnableLock lock = removeFirst ( ) ; if ( lock == null ) return run ; run = true ; synchronized ( lock ) { syncThread = lock . thread ; try { lock . run ( ) ; } catch ( ThreadDeath t ) { throw t ; } catch ( Throwable t ) { lock . throwable = t ; SWT . error ( SWT . ERROR_FAILED_EXEC , t ) ; } finally { syncThread = null ; lock . notifyAll ( ) ; } } } while ( all ) ; return run ; } protected void syncExec ( Runnable runnable ) { RunnableLock lock = null ;", "gt": "synchronized ( display . getDeviceLock ( ) )", "prediction": "}\n", "label": 1}
{"id": 7940, "input": "<s> package org . gk . engine . client . event . attrib ; import org . gk . ui . client . com . form . gkFormPanel ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . form . Field ; public class ReadOnlyAttribute implements IAttribute { @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof Field ) { Field field = ( Field ) com ; value = field . isReadOnly ( ) ; } return value ; } @ Override public void setAttributeValue ( Component", "gt": "com , Object value )", "prediction": ")\n", "label": 0}
{"id": 725, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class ModifyEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public", "gt": "ModifyEvent ( Event event )", "prediction": "( ) ;\n", "label": 1}
{"id": 972, "input": "<s> package thymeleafexamples . thvsjsp . web . controller ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . RequestMapping ; @ Controller public class Index { public Index ( ) { super ( ) ; } @ RequestMapping ( { \"/\" }", "gt": ") public String showSubscription ( )", "prediction": ")\n", "label": 0}
{"id": 727, "input": "<s> package org . eclipse . rap . internal . design . example . business . builder ; import org . eclipse . rap . internal . design . example . ILayoutSetConstants ; import org . eclipse . rap . internal . design . example . builder . DummyBuilder ; import org . eclipse . rap . ui . interactiondesign . layout . ElementBuilder ; import org . eclipse . rap . ui . interactiondesign . layout . model . LayoutSet ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . FormAttachment ; import org . eclipse . swt . layout . FormData ; import org . eclipse . swt . layout . FormLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; public class HeaderBuilder extends ElementBuilder { private static final int LOGOSPACING = 20 ; private Image left ; private Image leftBg ; private Image logo ; private Image right ; private Image rightBg ; private Image wave ; private FormData fdLogo ; private Control toolBar ; private Composite leftArea ; private Composite waveArea ; public HeaderBuilder ( Composite parent , String layoutSetId ) { super ( parent , layoutSetId ) ; initLayoutData ( ) ; } private void initLayoutData ( ) { LayoutSet set = getLayoutSet ( ) ; left = createImage ( set . getImagePath ( ILayoutSetConstants . HEADER_LEFT ) ) ; leftBg = createImage ( set . getImagePath ( ILayoutSetConstants . HEADER_LEFT_BG ) ) ; right = createImage ( set . getImagePath ( ILayoutSetConstants . HEADER_RIGHT ) ) ; rightBg = createImage ( set . getImagePath ( ILayoutSetConstants . HEADER_RIGHT_BG ) ) ; wave = createImage ( set . getImagePath ( ILayoutSetConstants . HEADER_WAVE ) ) ; ElementBuilder builder = new DummyBuilder ( null , ILayoutSetConstants . SET_ID_LOGO ) ; logo = builder . getImage ( ILayoutSetConstants . LOGO ) ; LayoutSet layoutSet = ( LayoutSet ) builder . getAdapter ( LayoutSet . class ) ; fdLogo = layoutSet . getPosition ( ILayoutSetConstants . LOGO_POSITION ) ; } public void addControl ( Control control , Object layoutData ) { toolBar = control ; toolBar . setLayoutData ( layoutData ) ; } public void addControl ( Control control , String positionId ) { } public void addImage ( Image image , Object layoutData ) { } public void addImage ( Image image , String positionId ) { } public void build ( ) { getParent ( ) . setLayout ( new FormLayout ( ) ) ; getParent ( ) . setBackgroundMode ( SWT . INHERIT_FORCE ) ; Label leftLabel = new Label ( getParent ( ) , SWT . NONE ) ; leftLabel . setImage ( left ) ; FormData fdLeftLabel = new FormData ( ) ; leftLabel . setLayoutData ( fdLeftLabel ) ; fdLeftLabel . left = new FormAttachment ( 0 , 0 ) ; fdLeftLabel . top = new FormAttachment ( 0 , 0 ) ; fdLeftLabel . width = left . getBounds ( ) . width ; fdLeftLabel . height = left . getBounds ( ) . height ; leftArea = new Composite ( getParent ( ) , SWT . NONE ) ; leftArea . setLayout ( new FormLayout ( ) ) ; leftArea . setBackgroundImage ( leftBg ) ; FormData fdLeftArea = new FormData ( ) ; leftArea . setLayoutData ( fdLeftArea ) ; fdLeftArea . left = new FormAttachment ( leftLabel ) ; fdLeftArea . top = new FormAttachment ( 0 , 0 ) ; fdLeftArea . height = leftBg . getBounds ( ) . height ; waveArea = new Composite ( getParent ( ) , SWT . NONE ) ; waveArea . setLayout ( new FormLayout ( ) ) ; waveArea . setBackgroundImage ( wave ) ; final FormData fdWaveArea = new FormData ( ) ; waveArea . setLayoutData ( fdWaveArea ) ; fdWaveArea . left = new FormAttachment ( leftArea ) ; fdWaveArea . top = new FormAttachment ( 0 , 0 ) ; fdWaveArea . width = wave . getBounds ( ) . width ; fdWaveArea . height = wave .", "gt": "getBounds ( ) . height ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 3457, "input": "<s> package org . ofbiz . entity ; @ SuppressWarnings ( \"serial\" ) public class GenericCreateException extends GenericEntityException { public GenericCreateException ( ) { super ( ) ; } public GenericCreateException ( String str ) { super ( str ) ; } public GenericCreateException ( String str , Throwable nested ) { super", "gt": "( str , nested ) ;", "prediction": "\n", "label": 0}
{"id": 732, "input": "<s> package pdgame ; public interface Player { String getID ( ) ; int makeMove ( ) ; void setScore ( int myMove , int oppMove , int myScore", "gt": ", int oppScore , String oppID ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6576, "input": "<s> public class T6425594 { static int x = T6425594 . x ; static final int y = z ;", "gt": "static final int z = 0 ;", "prediction": "}\n", "label": 0}
{"id": 738, "input": "<s> package org . eclipse . ui . internal . menus ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . jface . action . ContributionManager ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . ui . ISourceProvider ; import org . eclipse . ui . menus . AbstractContributionFactory ; import org . eclipse . ui . services . IServiceLocator ; public final class SlaveMenuService extends InternalMenuService { private Collection providers = new ArrayList ( ) ; private Collection factories = new ArrayList ( ) ; private final InternalMenuService parent ; private IServiceLocator serviceLocator ; private Set restrictionExpression ; public SlaveMenuService ( InternalMenuService parent , final IServiceLocator serviceLocator , Set restrictions ) { restrictionExpression = restrictions ; this . parent = parent ; this . serviceLocator = serviceLocator ; } public void populateContributionManager ( ContributionManager mgr , String uri ) { parent . populateContributionManager ( serviceLocator , restrictionExpression , mgr , uri , true ) ; } public void populateContributionManager ( ContributionManager mgr , String uri , boolean recurse ) { parent . populateContributionManager ( serviceLocator , restrictionExpression , mgr , uri , recurse ) ; } public IEvaluationContext getCurrentState ( ) { return parent . getCurrentState ( ) ; } public void addContributionFactory ( AbstractContributionFactory cache ) { if ( ! factories . contains ( cache ) ) { factories . add ( cache ) ; } parent . addContributionFactory ( cache ) ; } public void releaseContributions ( ContributionManager mgr ) { parent . releaseContributions ( mgr ) ; } public void removeContributionFactory ( AbstractContributionFactory factory ) { factories . remove ( factory ) ; parent . removeContributionFactory ( factory ) ; } public void dispose ( ) { if ( ! providers . isEmpty ( ) ) { Object [ ] array = providers . toArray ( ) ; for ( int i = 0 ;", "gt": "i < array . length ;", "prediction": "}\n", "label": 1}
{"id": 980, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . platzverkauf ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . util . Set ; import javax . swing . JPanel ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Platz ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Kinosaal ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Vorstellung ; public class PlatzVerkaufsWerkzeug { private PlatzVerkaufsWerkzeugUI _ui ; private Vorstellung _vorstellung ; public PlatzVerkaufsWerkzeug ( ) { _ui = new PlatzVerkaufsWerkzeugUI ( ) ; registriereUIAktionen ( ) ; setVorstellung ( null ) ; } public JPanel getUIPanel ( ) { return _ui . getUIPanel ( ) ; } private void registriereUIAktionen ( ) { _ui . getVerkaufenButton ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { verkaufePlaetze ( _vorstellung ) ; } } ) ; _ui . getStornierenButton ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { stornierePlaetze ( _vorstellung ) ; } } ) ; _ui . getPlatzplan ( ) . addPlatzSelectionListener ( new PlatzSelectionListener ( ) { @ Override public void auswahlGeaendert ( PlatzSelectionEvent event ) { reagiereAufNeuePlatzAuswahl ( event . getAusgewaehltePlaetze ( ) ) ; } } ) ; } private void reagiereAufNeuePlatzAuswahl ( Set < Platz > plaetze ) { _ui . getVerkaufenButton ( ) . setEnabled ( istVerkaufenMoeglich ( plaetze ) ) ; _ui . getStornierenButton ( ) . setEnabled ( istStornierenMoeglich ( plaetze ) ) ; aktualisierePreisanzeige ( plaetze ) ; } private void aktualisierePreisanzeige ( Set < Platz > plaetze ) { if ( istVerkaufenMoeglich ( plaetze ) ) {", "gt": "int preis = _vorstellung . getPreisFuerPlaetze ( plaetze ) ;", "prediction": "}\n", "label": 0}
{"id": 743, "input": "<s> package com . cloudera . sqoop . tool ; public class MergeTool extends", "gt": "org . apache . sqoop . tool . MergeTool", "prediction": ";\n", "label": 1}
{"id": 5783, "input": "<s> package org . xbill . DNS ; import java . util . * ; public class SetResponse { static final int UNKNOWN = 0 ; static final int NXDOMAIN = 1 ; static final int NXRRSET = 2 ; static final int DELEGATION = 3 ; static final int CNAME = 4 ; static final int DNAME = 5 ; static final int SUCCESSFUL = 6 ; private static final SetResponse unknown = new SetResponse ( UNKNOWN ) ; private static final SetResponse nxdomain = new SetResponse ( NXDOMAIN ) ; private static final SetResponse nxrrset = new SetResponse ( NXRRSET ) ; private int type ; private Object data ; private SetResponse ( ) { } SetResponse ( int type , RRset rrset ) { if ( type < 0 || type > 6 ) throw new IllegalArgumentException ( \"invalid type\" ) ; this . type = type ; this . data = rrset ; } SetResponse ( int type ) { if ( type < 0 || type > 6 ) throw new IllegalArgumentException ( \"invalid type\" ) ; this . type = type ; this . data = null ; } static SetResponse ofType ( int type ) { switch ( type ) { case UNKNOWN : return unknown ; case NXDOMAIN : return nxdomain ; case NXRRSET : return nxrrset ; case DELEGATION : case CNAME : case DNAME : case SUCCESSFUL : SetResponse sr = new SetResponse ( ) ; sr . type = type ; sr . data = null ; return sr ; default : throw new IllegalArgumentException ( \"invalid type\" ) ; } } void addRRset ( RRset rrset ) { if ( data == null ) data = new ArrayList ( ) ; List", "gt": "l = ( List ) data ;", "prediction": ";\n", "label": 0}
{"id": 756, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . editor ; import org . nuxeo . ecm . platform . gwt . client . model . Url ; import org . nuxeo . ecm . platform . gwt . client . ui . SmartView ; import org . nuxeo . ecm . platform . gwt . client . ui . View ; import com . smartgwt . client . types . ContentsType ; import com . smartgwt . client . widgets . Canvas ; import com . smartgwt . client . widgets . HTMLPane ; public class UrlView implements Editor { public boolean acceptInput ( Object input ) { return input instanceof Url ; } public View getView ( ) { EditorView view = new EditorView ( ) ; return view ; } static class EditorView extends SmartView { private static int cnt = 0 ; public EditorView ( ) { super ( \"iframe#\" + ( cnt ++ ) ) ; } @ Override protected Canvas createWidget ( ) { HTMLPane html = new HTMLPane ( ) ; html . setContentsType ( ContentsType . PAGE ) ; html . setWidth100 ( ) ; html . setHeight100 ( ) ; return html ; } @ Override protected void inputChanged ( ) { refresh ( ) ; }", "gt": "@ Override public void refresh ( )", "prediction": "}\n", "label": 1}
{"id": 864, "input": "<s> import jns . Simulator ; import jns . agent . MPTCP ; import jns . agent . MPTCPAgent ; import jns . agent . RandomSink ; import jns . agent . RandomSource ; import jns . command . LinkStateCommand ; import jns . command . StopCommand ; import jns . element . * ; import jns . trace . JavisTrace ; import jns . trace . Trace ; import jns . util . IPAddr ; import jns . util . Preferences ; import jns . util . Protocols ; import jns . util . Status ; import java . io . IOException ; public class Test_MPTCP_LinkDown { public static void main ( String args [ ] ) { Preferences . mode = 1 ; Trace trace = null ; try { trace = new JavisTrace ( \"test_mptcp_linkdown.jvs\" ) ; } catch ( IOException e ) { System . out . println ( \"Could not create test_mptcp_linkdown.jvs!\" ) ; } Simulator sim = Simulator . getInstance ( ) ; sim . setTrace ( trace ) ; Node A = new Node ( \"A\" ) ; sim . attachWithTrace ( A , trace ) ; Node B = new Node ( \"B\" ) ; sim . attachWithTrace ( B , trace ) ; Node C = new Node ( \"C\" ) ; sim . attachWithTrace ( C , trace ) ; Node D = new Node ( \"D\" ) ; sim . attachWithTrace ( D , trace ) ; Node E = new Node ( \"E\" ) ; sim . attachWithTrace ( E , trace ) ; Node F = new Node ( \"F\" ) ; sim . attachWithTrace ( F , trace ) ; Node G = new Node ( \"G\" ) ; sim . attachWithTrace ( G , trace ) ; Node H = new Node ( \"H\" ) ; sim . attachWithTrace ( H , trace ) ; Interface ABIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 1 ) ) ; A . attach ( ABIface ) ; sim . attachWithTrace ( ABIface , trace ) ; Interface ACIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 10 ) ) ; A . attach ( ACIface ) ; sim . attachWithTrace ( ACIface , trace ) ; Interface ADIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 20 ) ) ; A . attach ( ADIface ) ; sim . attachWithTrace ( ADIface , trace ) ; Interface BAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BAIface ) ; sim . attachWithTrace ( BAIface , trace ) ; Interface BEIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BEIface ) ; sim . attachWithTrace ( BEIface , trace ) ; Interface CAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CAIface ) ; sim . attachWithTrace ( CAIface , trace ) ; Interface CFIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CFIface ) ; sim . attachWithTrace ( CFIface , trace ) ; Interface DAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DAIface ) ; sim . attachWithTrace ( DAIface , trace ) ; Interface DGIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DGIface ) ; sim . attachWithTrace ( DGIface , trace ) ; Interface EBIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 5 ) ) ; E . attach ( EBIface ) ; sim . attachWithTrace ( EBIface , trace ) ; Interface EHIface = new DuplexInterface ( new IPAddr (", "gt": "192 , 168 , 0 , 5 ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 761, "input": "<s> package org . restlet . engine . header ; import java . io . IOException ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; import org . restlet . data . Parameter ; import org . restlet . util . Series ; public class ContentTypeReader extends HeaderReader < ContentType > { public ContentTypeReader ( String header ) { super ( header ) ; } private ContentType createContentType ( StringBuilder mediaType , Series < Parameter > parameters ) { CharacterSet characterSet = null ; if ( parameters != null ) { String charSet = parameters . getFirstValue ( \"charset\" ) ; if ( charSet != null ) { parameters . removeAll ( \"charset\" ) ; characterSet = new CharacterSet ( charSet ) ; } return new ContentType ( new MediaType ( mediaType . toString ( ) , parameters ) , characterSet ) ; } return new ContentType ( new MediaType ( mediaType . toString ( ) ) , null ) ; } @ Override public ContentType readValue ( ) throws IOException { ContentType result = null ; boolean readingMediaType = true ; boolean readingParamName = false ; boolean readingParamValue = false ; StringBuilder mediaTypeBuffer = new StringBuilder ( ) ; StringBuilder paramNameBuffer = null ; StringBuilder paramValueBuffer = null ; Series < Parameter > parameters = null ; String nextValue = readRawValue ( ) ; int nextIndex = 0 ; if ( nextValue != null ) { int nextChar = nextValue . charAt ( nextIndex ++ ) ; while ( result == null ) { if ( readingMediaType ) { if ( nextChar == - 1 ) { if ( mediaTypeBuffer . length ( ) > 0 ) { result = createContentType ( mediaTypeBuffer , null ) ; paramNameBuffer = new StringBuilder ( ) ; } else { } } else if ( nextChar == ';' ) { if ( mediaTypeBuffer . length ( ) > 0 ) { readingMediaType = false ; readingParamName = true ; paramNameBuffer = new StringBuilder ( ) ; parameters = new Series < Parameter > ( Parameter . class ) ; } else { throw new IOException ( \"Empty mediaType name detected.\" ) ; } } else if ( HeaderUtils . isSpace ( nextChar ) ) { } else if ( HeaderUtils . isText ( nextChar ) ) { mediaTypeBuffer . append ( ( char ) nextChar ) ; } else { throw new IOException ( \"The \" + ( char ) nextChar + \" character isn't allowed in a media type name.\" ) ; } } else if ( readingParamName ) { if ( nextChar == '=' ) { if ( paramNameBuffer . length ( ) > 0 ) { readingParamName = false ; readingParamValue = true ; paramValueBuffer = new StringBuilder ( ) ; } else { throw new IOException ( \"Empty parameter name detected.\" ) ; } } else if ( nextChar == - 1 ) { if ( paramNameBuffer . length ( ) > 0 ) { parameters . add ( Parameter . create ( paramNameBuffer , null ) ) ; result = createContentType ( mediaTypeBuffer , parameters ) ; } else if ( paramNameBuffer . length ( ) == 0 ) { result = createContentType ( mediaTypeBuffer , parameters ) ; } else { throw new IOException ( \"Empty parameter name detected.\" ) ; } } else if ( nextChar == ';' ) { parameters . add ( Parameter . create ( paramNameBuffer , null ) ) ; paramNameBuffer = new StringBuilder ( ) ; readingParamName = true ; readingParamValue = false ; } else if ( HeaderUtils . isSpace ( nextChar ) && ( paramNameBuffer . length ( ) == 0 ) ) { } else if ( HeaderUtils . isTokenChar ( nextChar ) ) { paramNameBuffer . append ( ( char ) nextChar ) ; } else { throw new IOException ( \"The \\\"\" + ( char ) nextChar + \"\\\" character isn't allowed in a media type parameter name.\" ) ; } } else if ( readingParamValue ) { if ( nextChar == - 1 ) { if ( paramValueBuffer . length ( ) > 0 ) { parameters . add ( Parameter . create ( paramNameBuffer , paramValueBuffer ) ) ; result = createContentType ( mediaTypeBuffer , parameters ) ; } else { throw new IOException ( \"Empty parameter value detected\" ) ; } } else if ( nextChar == ';' ) { parameters . add ( Parameter . create ( paramNameBuffer , paramValueBuffer ) ) ; paramNameBuffer =", "gt": "new StringBuilder ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3961, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; } public static boolean start ( RootDoc root ) { try { for ( PackageDoc pkg : root . specifiedPackages ( ) ) { for ( ClassDoc cd : pkg . ordinaryClasses ( ) ) { for ( ConstructorDoc c : cd . constructors ( ) ) { tester . println ( c ) ; tester . println ( ) ; for ( Parameter p : c . parameters ( ) ) { tester . printParameter ( p ) ; } tester . println ( ) ; } for ( MethodDoc m : cd . methods ( ) ) { tester . println ( m ) ; tester . println ( ) ; for ( Parameter p : m . parameters ( ) ) { tester", "gt": ". printParameter ( p ) ;", "prediction": ";\n", "label": 0}
{"id": 796, "input": "<s> package br . org . archimedes . io . svg . elements ; import static org . junit . Assert . assertEquals ; import java . io . ByteArrayOutputStream ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . infiniteline . InfiniteLine ; public class InfiniteLineExporterTest extends Tester { private InfiniteLineExporter exporter ; private ByteArrayOutputStream stream ; private InfiniteLine infiniteline ; @ Before public void setUp ( ) throws Exception { exporter = new InfiniteLineExporter ( ) ; stream = new ByteArrayOutputStream ( ) ; infiniteline = new InfiniteLine ( 0.0 , - 1.0", "gt": ", 1.0 , 0.0 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7242, "input": "<s> package org . hackreduce . models ; import java . io . StringReader ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . hadoop . io . Text ; import org . w3c . dom . CharacterData ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; public class BixiRecord { Logger LOG = Logger . getLogger ( BixiRecord . class . getName ( ) ) ; private static SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat ( \"dd_MM_yyyy__HH_mm_ss\" ) ; private Date date ; private int stationId ; private String name ; private String terminalName ; private double latitude ; private double longitude ; private boolean installed ; private boolean locked ; private Date installDate ; private Date removalDate ; private boolean temporary ; private int nbBikes ; private int nbEmptyDocks ; public BixiRecord ( String xmlFilename , String xml ) throws IllegalArgumentException { String filename = xmlFilename . endsWith ( \".xml\" ) ? xmlFilename . replace ( \".xml\" , \"\" ) : xmlFilename ; try { DocumentBuilder docBuilder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; InputSource is = new InputSource ( ) ; is . setCharacterStream ( new StringReader ( xml ) ) ; Document doc = docBuilder . parse ( is ) ; NodeList stationList = doc . getElementsByTagName ( \"station\" ) ; if ( stationList . getLength ( ) != 1 ) throw new IllegalArgumentException ( ) ; Element station = ( Element ) stationList . item ( 0 ) ; setStationId ( Integer . parseInt ( getStringFromTag ( station , \"id\" ) ) ) ; setName ( getStringFromTag ( station , \"name\" ) ) ; setTerminalName ( getStringFromTag ( station , \"terminalName\" ) ) ; setLatitude ( Double . parseDouble ( getStringFromTag ( station , \"lat\" ) ) ) ; setLongitude ( Double . parseDouble ( getStringFromTag ( station , \"long\" ) ) ) ; setInstalled ( Boolean . parseBoolean ( getStringFromTag ( station , \"installed\" ) ) ) ; setLocked ( Boolean . parseBoolean ( getStringFromTag ( station , \"locked\" ) ) ) ; String installDateString = getStringFromTag ( station , \"installDate\" ) ; if ( installDateString != null ) setInstallDate ( new Date ( Long . parseLong ( installDateString ) ) ) ; String removalDateString = getStringFromTag ( station , \"removalDate\" ) ; if ( removalDateString != null ) setRemovalDate ( new Date ( Long . parseLong ( removalDateString ) ) ) ; String dateString = getStringFromTag ( station , \"date\" ) ; if ( dateString != null ) setDate ( new Date ( Long . parseLong ( dateString ) ) ) ; setTemporary ( Boolean . parseBoolean ( getStringFromTag ( station , \"temporary\" ) ) ) ; setNbBikes ( Integer . parseInt ( getStringFromTag ( station , \"nbBikes\" ) ) ) ; setNbEmptyDocks ( Integer . parseInt ( getStringFromTag ( station , \"nbEmptyDocks\" ) ) ) ; } catch ( Exception e ) { LOG . log ( Level . WARNING , e . getMessage ( ) , e ) ; throw new IllegalArgumentException ( \"Couldn't create a \" + getClass ( ) . getName ( ) + \" record from the given XML\" ) ; } if ( getDate ( ) == null ) { try { setDate ( SIMPLE_DATE_FORMAT . parse ( filename ) ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( \"Couldn't extract the date from the XML filename: \" + xmlFilename ) ; } } } private String getStringFromTag ( Element rootElement , String tagname ) { NodeList list = rootElement . getElementsByTagName ( tagname ) ; if ( list . getLength ( ) > 0 ) { Element element = ( Element ) list . item ( 0 ) ; Node child = element . getFirstChild ( ) ; if ( child instanceof CharacterData ) { CharacterData cd = ( CharacterData ) child ; return cd . getData ( ) ; } } return null ; } public BixiRecord ( Text xmlFilename , Text xml ) throws IllegalArgumentException { this ( xmlFilename . toString ( ) , xml . toString ( ) ) ; } public Date getDate ( ) { return date ; } public void setDate ( Date date ) { this . date = date ; } public int getStationId ( ) { return stationId ; } public void setStationId ( int stationId ) { this . stationId = stationId ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getTerminalName ( ) { return terminalName ; } public void", "gt": "setTerminalName ( String terminalName )", "prediction": "( )\n", "label": 0}
{"id": 816, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . BitSet ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermDocs ; import org . apache . lucene . index . TermEnum ; import org . apache . lucene . util . OpenBitSet ; public class DuplicateFilter extends Filter { String fieldName ; int keepMode = KM_USE_FIRST_OCCURRENCE ; public static final int KM_USE_FIRST_OCCURRENCE = 1 ; public static final int KM_USE_LAST_OCCURRENCE = 2 ; int processingMode = PM_FULL_VALIDATION ; public static final int PM_FULL_VALIDATION = 1 ; public static final int PM_FAST_INVALIDATION = 2 ; public DuplicateFilter ( String fieldName ) { this ( fieldName , KM_USE_LAST_OCCURRENCE , PM_FULL_VALIDATION ) ; } public DuplicateFilter ( String fieldName , int keepMode , int processingMode ) { this . fieldName = fieldName ; this . keepMode = keepMode ; this . processingMode = processingMode ; } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { if ( processingMode == PM_FAST_INVALIDATION ) { return fastBits ( reader ) ; } else { return correctBits ( reader ) ; } } private OpenBitSet correctBits ( IndexReader reader ) throws IOException { OpenBitSet bits = new OpenBitSet ( reader . maxDoc ( ) ) ; Term startTerm = new Term ( fieldName ) ; TermEnum te = reader . terms ( startTerm ) ; if ( te != null ) { Term currTerm = te . term ( ) ; while ( ( currTerm != null ) && ( currTerm . field ( ) == startTerm . field ( ) ) ) { int lastDoc = - 1 ; TermDocs td = reader . termDocs ( currTerm ) ; if ( td . next ( ) ) { if ( keepMode == KM_USE_FIRST_OCCURRENCE ) { bits . set ( td . doc ( ) ) ; } else { do { lastDoc = td . doc ( ) ; } while ( td . next ( ) ) ; bits . set ( lastDoc ) ; } } if ( ! te . next ( ) ) { break ; } currTerm = te . term ( ) ; } } return bits ; } private OpenBitSet fastBits ( IndexReader reader ) throws IOException { OpenBitSet bits = new OpenBitSet ( reader . maxDoc ( ) ) ; bits . set ( 0 , reader . maxDoc ( ) ) ; Term startTerm = new Term ( fieldName ) ; TermEnum te = reader . terms ( startTerm ) ; if ( te != null ) { Term currTerm = te . term ( ) ; while ( ( currTerm != null ) && ( currTerm . field ( ) == startTerm . field ( ) ) ) { if ( te . docFreq ( ) > 1 ) { int lastDoc = - 1 ; TermDocs td = reader . termDocs ( currTerm ) ; td . next ( ) ; if ( keepMode == KM_USE_FIRST_OCCURRENCE ) { td . next ( ) ; } do { lastDoc = td . doc ( ) ; bits . clear ( lastDoc ) ; } while ( td . next ( ) ) ; if ( keepMode == KM_USE_LAST_OCCURRENCE ) { bits . set ( lastDoc ) ; } } if ( ! te . next ( ) ) { break ; } currTerm = te . term ( ) ; } } return bits ; } public static void main ( String [ ] args ) throws Exception { IndexReader r = IndexReader . open ( \"/indexes/personCentricAnon\" ) ; long start = System . currentTimeMillis ( ) ; DuplicateFilter df = new DuplicateFilter ( \"vehicle.vrm\" , KM_USE_LAST_OCCURRENCE , PM_FAST_INVALIDATION ) ; BitSet b = df . bits ( r ) ; long end = System . currentTimeMillis ( ) - start ; System . out . println ( b . cardinality ( ) + \" in \" + end + \" ms \" ) ; } public String getFieldName ( ) { return fieldName ; } public void setFieldName ( String fieldName ) { this . fieldName = fieldName ; } public int getKeepMode ( ) { return keepMode ; } public void setKeepMode ( int keepMode ) { this . keepMode = keepMode ; } public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ( obj == null ) || ( obj . getClass ( ) != this . getClass ( )", "gt": ") ) return false ;", "prediction": ") ;\n", "label": 1}
{"id": 369, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import java . text . SimpleDateFormat ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . taglets . * ; public class HtmlDocletWriter extends HtmlDocWriter { public String relativePath = \"\" ; public String relativepathNoSlash = \"\" ; public String path = \"\" ; public String filename = \"\" ; public int displayLength = 0 ; public ConfigurationImpl configuration ; protected boolean printedAnnotationHeading = false ; public HtmlDocletWriter ( ConfigurationImpl configuration , String filename ) throws IOException { super ( configuration , filename ) ; this . configuration = configuration ; this . filename = filename ; } public HtmlDocletWriter ( ConfigurationImpl configuration , String path , String filename , String relativePath ) throws IOException { super ( configuration , path , filename ) ; this . configuration = configuration ; this . path = path ; this . relativePath = relativePath ; this . relativepathNoSlash = DirectoryManager . getPathNoTrailingSlash ( this . relativePath ) ; this . filename = filename ; } public String replaceDocRootDir ( String htmlstr ) { int index = htmlstr . indexOf ( \"{@\" ) ; if ( index < 0 ) { return htmlstr ; } String lowerHtml = htmlstr . toLowerCase ( ) ; index = lowerHtml . indexOf ( \"{@docroot}\" , index ) ; if ( index < 0 ) { return htmlstr ; } StringBuilder buf = new StringBuilder ( ) ; int previndex = 0 ; while ( true ) { if ( configuration . docrootparent . length ( ) > 0 ) { index = lowerHtml . indexOf ( \"{@docroot}/..\" , previndex ) ; if ( index < 0 ) { buf . append ( htmlstr . substring ( previndex ) ) ; break ; } buf . append ( htmlstr . substring ( previndex , index ) ) ; previndex = index + 13 ; buf . append ( configuration . docrootparent ) ; if ( previndex < htmlstr . length ( ) && htmlstr . charAt ( previndex ) != '/' ) { buf . append ( DirectoryManager . URL_FILE_SEPARATOR ) ; } } else { index = lowerHtml . indexOf ( \"{@docroot}\" , previndex ) ; if ( index < 0 ) { buf . append ( htmlstr . substring ( previndex ) ) ; break ; } buf . append ( htmlstr . substring ( previndex , index ) ) ; previndex = index + 10 ; buf . append ( relativepathNoSlash ) ; if ( relativepathNoSlash . length ( ) > 0 && previndex < htmlstr . length ( ) && htmlstr . charAt ( previndex ) != '/' ) { buf . append ( DirectoryManager . URL_FILE_SEPARATOR ) ; } } } return buf . toString ( ) ; } public void printNoFramesTargetHyperLink ( String link , String where , String target , String label , boolean strong ) { script ( ) ; println ( \"  <!--\" ) ; println ( \"  if(window==top) {\" ) ; println ( \"    document.writeln('\" + getHyperLinkString ( link , where , label , strong , \"\" , \"\" , target ) + \"');\" ) ; println ( \"  }\" ) ; println ( \"  //-->\" ) ; scriptEnd ( ) ; noScript ( ) ; println ( \"  \" + getHyperLinkString ( link , where , label , strong , \"\" , \"\" , target ) ) ; noScriptEnd ( ) ; println ( DocletConstants . NL ) ; } public Content getAllClassesLinkScript ( String id ) { HtmlTree script = new HtmlTree ( HtmlTag . SCRIPT ) ; script . addAttr ( HtmlAttr . TYPE , \"text/javascript\" ) ; String scriptCode = \"<!--\" + DocletConstants . NL + \"  allClassesLink = document.getElementById(\\\"\" + id + \"\\\");\" + DocletConstants . NL + \"  if(window==top) {\" + DocletConstants . NL + \"    allClassesLink.style.display = \\\"block\\\";\" + DocletConstants . NL + \"  }\" + DocletConstants . NL + \"  else {\" + DocletConstants . NL + \"    allClassesLink.style.display = \\\"none\\\";\" + DocletConstants . NL + \"  }\" + DocletConstants . NL + \"  //-->\" + DocletConstants . NL ; Content scriptContent = new RawHtml ( scriptCode ) ; script . addContent ( scriptContent ) ; Content div = HtmlTree . DIV ( script ) ; return div ; } private void addMethodInfo ( MethodDoc method , Content dl ) { ClassDoc [ ] intfacs = method . containingClass ( ) . interfaces ( ) ; MethodDoc overriddenMethod = method . overriddenMethod ( ) ; if ( ( intfacs . length > 0 && new ImplementedMethods ( method , this . configuration ) . build ( ) . length > 0 ) || overriddenMethod != null ) { MethodWriterImpl . addImplementsInfo ( this , method , dl ) ; if ( overriddenMethod != null ) { MethodWriterImpl . addOverridden ( this , method . overriddenType ( ) , overriddenMethod , dl ) ; } } } protected void addTagsInfo ( Doc doc , Content htmltree ) { if ( configuration . nocomment ) { return ; } Content dl = new HtmlTree ( HtmlTag . DL ) ; if ( doc instanceof MethodDoc ) { addMethodInfo ( ( MethodDoc ) doc , dl ) ; } TagletOutputImpl output = new TagletOutputImpl ( \"\" ) ; TagletWriter . genTagOuput ( configuration . tagletManager , doc , configuration . tagletManager . getCustomTags ( doc ) , getTagletWriterInstance ( false ) , output ) ; String outputString = output . toString ( ) . trim ( ) ; if ( ! outputString . isEmpty ( ) ) { Content resultString = new", "gt": "RawHtml ( outputString ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 833, "input": "<s> package org . apache . lucene . ant ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . StringWriter ; public class TextDocument { private String contents ; public TextDocument ( File file ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; StringWriter sw = new StringWriter ( ) ; String line = br . readLine ( ) ; while ( line != null ) { sw . write ( line ) ; line = br . readLine ( ) ; } br . close ( ) ; contents = sw . toString ( ) ; sw . close ( ) ; } public static Document Document ( File f ) throws IOException { TextDocument", "gt": "textDoc = new TextDocument ( f ) ;", "prediction": ";\n", "label": 1}
{"id": 1040, "input": "<s> package org . ofbiz . widget . cache ; public class GenericWidgetOutput { public static final String module = GenericWidgetOutput . class . getName ( ) ; protected String output ; public GenericWidgetOutput ( String output ) { this", "gt": ". output = output ;", "prediction": "\n", "label": 0}
{"id": 855, "input": "<s> package org . fuzzydb . server . internal . server ; import java . nio . ByteBuffer ; import org . fuzzydb . client . internal . comms . messages . DeleteStoreCmd ; import org . fuzzydb . core . exceptions . ArchException ; import org . fuzzydb . io . core . MessageSink ; import org . fuzzydb . io . core . messages . Command ; public class ServerDeleteStoreTransaction extends ServerTransaction { public ServerDeleteStoreTransaction ( ServerTransactionCoordinator stc , MessageSink source ) { super ( stc , source ) ; } @ Override public void setWriteCommand ( Command command , ByteBuffer packet ) { assert ( command instanceof DeleteStoreCmd ) ; super . setWriteCommand ( command , packet ) ; } @ Override protected void doCommitChecks ( ) { String storeName = getStoreName ( ) ; stc .", "gt": "getRepository ( ) . getStore ( storeName ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8795, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . SupplementTask ; import org . jjflyboy . tjpeditor . project . Task ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class TaskTest extends XtextTest { public TaskTest ( ) { super ( \"TaskTest\" ) ; } @ Test public void testAllAttributes ( ) { String text = \"task t1 \\\"Task One\\\" {\" + \" allocate res1 \" + \"booking testresource 2007-01-08-13:00 +4h \" + \"charge 1.2 perday \" + \"chargeset account5 40 \" + \"\\n\" + \"complete 20 \" + \"depends task4 \" + \"duration 5 min \" + \"effort 4 w \" + \"end 2011-06-30 \" + \"endcredit 5 \" + \"\\n\" + \"fail \\\" some logical expression \\\" \" + \"flags flag23  \" + \"journalentry 2011-11-12 \\\"T2.1 Yellow\\\" { alert red summary \\\"yes er jsbr dp,r yrcy\\\" } \" + \"length 10 w \" + \"limits { weeklymax 2d } \" + \"maxend 2008-01-09 \" + \"maxstart 2011-01-09 \" + \"milestone \" + \"minend 2012-01-09 \" + \"minstart 2010-01-09 \" + \"note \\\"this is a note\\\" \" + \"period 2010-01-16 + 4 m \" + \"precedes junktask \" + \"priority 10 \" + \"projectid proj \" + \"purge precedes \" + \"responsible fred \" + \"scheduled \" + \"scheduling alap \" + \"shifts shiftA 2010-01-16 + 4 m \" + \"start 2010-01-19 \" + \"supplement task tough.one \" + \"task subtask \\\"Sub task\\\" \" + \"warn \\\"logical expression\\\" \" + \"}\" ; testParserRule ( text , Task . class . getSimpleName ( ) ) ; } @ Test public void testSupplement ( ) { String text = \"supplement task t1 { allocate res1 }\" ; testParserRule ( text , SupplementTask . class . getSimpleName ( ) ) ; } @ Test public void taskDependsRootReferenceTest ( ) { ignoreFormattingDifferences ( ) ; testFile ( \"taskDependsRootReference.tjp\" ) ; } @ Test public void taskDependsDeepReferenceTest ( ) { ignoreFormattingDifferences ( ) ; testFile ( \"taskDependsDeepReference.tjp\" ) ; } @ Test public void taskDependsRelativeReferenceToGlobalTest ( ) { ignoreFormattingDifferences ( ) ; testFileNoSerializer ( \"taskDependsRelativeReferenceToGlobal.tjp\" ) ; } @ Test public void taskDependsDeepRelativeReferenceToMiddleTest ( ) { ignoreFormattingDifferences ( ) ; testFileNoSerializer ( \"taskDependsDeepRelativeReferenceToMiddle.tjp\" ) ; } @ Test public void taskDependsBrokenRelativeReferenceNoBangsTest ( ) { ignoreFormattingDifferences ( ) ; assertConstraints ( testFileNoSerializer ( \"taskDependsBrokenRelativeReferenceNoBangs.tjp\" ) . oneOfThemContains ( \"Couldn't resolve reference to", "gt": "Task 'middle1.bottom1'\" ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 867, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . dynamichelpers . IExtensionChangeHandler ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . internal . intro . IIntroConstants ; import org . eclipse . ui . internal . intro . IntroDescriptor ; import org . eclipse . ui . internal . intro . IntroMessages ; import org . eclipse . ui . intro . IIntroManager ; import org . eclipse . ui . intro . IIntroPart ; import org . eclipse . ui . intro . IntroContentDetector ; public class WorkbenchIntroManager implements IIntroManager { private final Workbench workbench ; WorkbenchIntroManager ( Workbench workbench ) { this . workbench = workbench ; workbench . getExtensionTracker ( ) . registerHandler ( new IExtensionChangeHandler ( ) { public void addExtension ( IExtensionTracker tracker , IExtension extension ) { } public void removeExtension ( IExtension source , Object [ ] objects ) { for ( int i = 0 ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof IIntroPart ) { closeIntro ( ( IIntroPart ) objects [ i ] ) ; } } } } , null ) ; } private IIntroPart introPart ; public boolean closeIntro ( IIntroPart part ) { if ( introPart == null || ! introPart . equals ( part ) ) { return false ; } IViewPart introView = getViewIntroAdapterPart ( ) ; if ( introView != null ) { IWorkbenchPage page = introView . getSite ( ) . getPage ( ) ; IViewReference reference = page . findViewReference ( IIntroConstants . INTRO_VIEW_ID ) ; page . hideView ( introView ) ; if ( reference == null || reference . getPart ( false ) == null ) { introPart = null ; return true ; } return false ; } introPart = null ; return true ; } public IIntroPart showIntro ( IWorkbenchWindow preferredWindow , boolean standby ) { if ( preferredWindow == null ) { preferredWindow = this . workbench . getActiveWorkbenchWindow ( ) ; } if ( preferredWindow == null ) { return null ; } ViewIntroAdapterPart viewPart = getViewIntroAdapterPart ( ) ; if ( viewPart == null ) { createIntro ( preferredWindow ) ; } else { try { IWorkbenchPage page = viewPart . getSite ( ) . getPage ( ) ; IWorkbenchWindow window = page . getWorkbenchWindow ( ) ; if ( ! window . equals ( preferredWindow ) ) { window . getShell ( ) . setActive ( ) ; } page . showView ( IIntroConstants . INTRO_VIEW_ID ) ; } catch ( PartInitException e ) { WorkbenchPlugin . log ( \"Could not open intro\" , new Status ( IStatus . ERROR , WorkbenchPlugin . PI_WORKBENCH , IStatus . ERROR , \"Could not open intro\" , e ) ) ; } } setIntroStandby ( introPart , standby ) ; return introPart ; } boolean isIntroInWindow ( IWorkbenchWindow testWindow ) { ViewIntroAdapterPart viewPart = getViewIntroAdapterPart ( ) ; if ( viewPart == null ) { return false ; } IWorkbenchWindow window = viewPart . getSite ( ) . getWorkbenchWindow ( ) ; if ( window . equals ( testWindow ) ) { return true ; } return false ; } private void createIntro ( IWorkbenchWindow preferredWindow ) { if ( this . workbench . getIntroDescriptor ( ) == null ) { return ; } IWorkbenchPage workbenchPage = preferredWindow . getActivePage ( ) ; if ( workbenchPage == null ) { return ; } try { workbenchPage . showView ( IIntroConstants . INTRO_VIEW_ID ) ; } catch ( PartInitException e ) { WorkbenchPlugin . log ( IntroMessages . get ( ) . Intro_could_not_create_part , new Status ( IStatus . ERROR , WorkbenchPlugin . PI_WORKBENCH , IStatus . ERROR , IntroMessages . get ( ) . Intro_could_not_create_part , e ) ) ; } } public void setIntroStandby ( IIntroPart part , boolean standby ) { if ( introPart == null || ! introPart . equals ( part ) ) { return ; } ViewIntroAdapterPart viewIntroAdapterPart = getViewIntroAdapterPart ( ) ; if ( viewIntroAdapterPart == null ) { return ; } PartPane pane = ( ( PartSite ) viewIntroAdapterPart . getSite ( ) ) . getPane ( ) ; if ( standby == ! pane . isZoomed ( ) ) { viewIntroAdapterPart . setStandby ( standby ) ; return ; } viewIntroAdapterPart . getSite ( ) . getPage ( ) . toggleZoom ( pane . getPartReference ( ) ) ; } public boolean isIntroStandby ( IIntroPart part ) { if ( introPart == null || ! introPart . equals ( part ) ) { return false ; } ViewIntroAdapterPart viewIntroAdapterPart = getViewIntroAdapterPart ( ) ; if ( viewIntroAdapterPart == null ) { return false ; } WorkbenchPage page = ( WorkbenchPage ) viewIntroAdapterPart . getSite ( ) . getPage ( ) ; IViewReference reference = page . findViewReference ( IIntroConstants . INTRO_VIEW_ID ) ; if ( page . isFastView ( reference ) ) return true ; return ! ( ( PartSite ) viewIntroAdapterPart . getSite ( ) ) . getPane ( ) . isZoomed ( ) ; } public IIntroPart getIntro ( ) { return introPart ; } ViewIntroAdapterPart getViewIntroAdapterPart ( ) { IWorkbenchWindow [ ] windows = this . workbench . getWorkbenchWindows ( ) ; for ( int i = 0 ; i < windows . length ; i ++ ) { IWorkbenchWindow window = windows [ i ] ; WorkbenchPage page = ( WorkbenchPage ) window . getActivePage ( ) ; if ( page == null ) { continue ; } IPerspectiveDescriptor [ ] perspDescs = page . getOpenPerspectives ( ) ; for ( int j = 0 ; j < perspDescs . length ; j ++ ) { IPerspectiveDescriptor descriptor = perspDescs [ j ] ; IViewReference reference = page . findPerspective ( descriptor ) . findView ( IIntroConstants . INTRO_VIEW_ID ) ; if ( reference != null ) { IViewPart part = reference . getView ( false ) ;", "gt": "if ( part != null && part instanceof ViewIntroAdapterPart )", "prediction": "}\n", "label": 1}
{"id": 3829, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . ShiftsResource ; public class ShiftsResourceImpl extends ResourceAttributeImpl implements ShiftsResource { protected ShiftsResourceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE", "gt": ". getShiftsResource ( ) ;", "prediction": ";\n", "label": 0}
{"id": 880, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . ui . internal . decorators . LightweightActionDescriptor ; import org . eclipse . ui . internal . registry . ActionSetDescriptor ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . internal . registry . RegistryReader ; public class PluginActionSetReader extends RegistryReader { private List cache = new ArrayList ( ) ; public PluginActionSetReader ( ) { super ( ) ; } protected LightweightActionDescriptor createActionDescriptor ( IConfigurationElement element ) { return new LightweightActionDescriptor ( element ) ; } public LightweightActionDescriptor [ ] readActionDescriptors ( ActionSetDescriptor actionSet ) { readElements ( new IConfigurationElement [ ] {", "gt": "actionSet . getConfigurationElement ( ) }", "prediction": ") ;\n", "label": 1}
{"id": 2271, "input": "<s> package org . parboiled . transform ; import org . parboiled . common . ImmutableList ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import java . io . Console ; import java . io . IOException ; import java . util . List ; import static org . testng . Assert . assertEquals ; public class InstructionGroupPreparerTest extends TransformationTest { private final List < RuleMethodProcessor > processors = ImmutableList . of ( new UnusedLabelsRemover ( ) , new ReturnInstructionUnifier ( ) , new InstructionGraphCreator ( ) , new ImplicitActionsConverter ( ) , new InstructionGroupCreator ( ) , new InstructionGroupPreparer ( ) ) ; @ BeforeClass public void setup ( ) throws IOException { setup ( TestParser . class ) ; } @ Test ( dependsOnGroups = \"primary\" ) public void testRuleWithComplexActionSetup ( ) throws Exception { RuleMethod method = processMethod ( \"RuleWithComplexActionSetup\" , processors ) ; assertEquals ( method . getGroups ( ) . size ( ) , 3 ) ; InstructionGroup group = method . getGroups ( ) . get ( 1 ) ; assertEquals ( group . getName ( ) , \"Action$LmzJHalG7AngCUsX\" ) ; assertEquals ( group . getFields ( ) . size ( ) , 3 ) ; assertEquals ( group . getFields ( ) . get ( 0 ) . desc , \"I\" ) ; assertEquals ( group . getFields ( ) . get ( 1 ) . desc , \"I\" ) ; assertEquals ( group . getFields ( ) . get ( 2 ) . desc , \"I\" ) ; group = method . getGroups ( ) . get ( 2 ) ; assertEquals ( group . getName ( ) , \"Action$OrG2zjbz0MYoT8sO\" ) ; assertEquals ( group . getFields ( ) . size ( ) , 5 ) ; assertEquals ( group . getFields ( ) . get ( 0 ) . desc , \"Lorg/parboiled/transform/TestParser$$parboiled;\" ) ; assertEquals ( group . getFields ( ) . get ( 1 ) . desc , \"I\" ) ; assertEquals ( group . getFields ( ) . get ( 2 ) . desc , \"Lorg/parboiled/support/Var;\" ) ; assertEquals ( group . getFields ( ) . get ( 3 )", "gt": ". desc , \"I\" ) ;", "prediction": ";\n", "label": 0}
{"id": 891, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . xmlparser . ParserException ; import org . apache . lucene . xmlparser . QueryBuilder ; import org", "gt": ". w3c . dom . Element ;", "prediction": ";\n", "label": 1}
{"id": 3638, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface RollupResource extends ReportAttribute , IcalReportAttribute , ExportAttribute { LogicalExpression getExpression ( ) ; void setExpression", "gt": "( LogicalExpression value ) ;", "prediction": ";\n", "label": 0}
{"id": 911, "input": "<s> package com . talis . hbase . rdf . layout . verticalpartitioning ; import java . util . Iterator ; import org . apache . hadoop . hbase . client . Get ; import org . apache . hadoop . hbase . client . HTable ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . Scan ; import org . apache . hadoop . hbase . util . Bytes ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; import com . hp . hpl . jena . util . iterator . NullIterator ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . TableQueryRunnerBase ; import com . talis . hbase . rdf . layout . TableQueryRunnerBasics ; import com . talis . hbase . rdf . util . HBaseUtils ; public class QueryRunnerVP extends TableQueryRunnerBase implements TableQueryRunnerBasics { public QueryRunnerVP ( String storeName , HBaseRdfConnection connection ) { super ( storeName , connection ) ; } @ Override public ExtendedIterator < Triple > tableFind ( Node sm , Node pm , Node om , String tblPrefix , String tblType ) { ExtendedIterator < Triple > trIter = NullIterator . instance ( ) ; try { StringBuilder sb = new StringBuilder ( name ( ) ) ; sb . append ( \"-\" ) ; sb . append ( tblPrefix ) ; sb . append ( \"-\" ) ; sb . append ( HBaseUtils . getNameOfNode ( pm ) ) ; if ( tblType . equalsIgnoreCase ( \"sub\" ) ) { Get res = new Get ( Bytes . toBytes ( sm . toString ( ) ) ) ; if ( pm . isConcrete ( ) ) { sb . append ( TableDescSubjects . SUBJECT_TBL_NAME ) ; HTable table = tables ( ) . get ( sb . toString ( ) ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) trIter = new HBaseRdfSingleRowIterator ( rr , sm , pm , om , pm . toString ( ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ; } else { trIter = new HBaseRdfAllTablesIterator ( ) ; Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while ( iterTblNames . hasNext ( ) ) { String tblName = iterTblNames . next ( ) ; String mapPrefix = processTblName ( tblName , tblPrefix , \"subjects\" , \"objects\" ) ; if ( mapPrefix == null ) continue ; HTable table = tables ( ) . get ( tblName ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) ( ( HBaseRdfAllTablesIterator ) trIter ) . addIter ( new HBaseRdfSingleRowIterator ( rr , sm , pm , om , getPredicateMapping ( tblName ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ) ; tblName = null ; mapPrefix = null ; } ( ( HBaseRdfAllTablesIterator ) trIter ) . closeIter ( ) ; } res = null ; } else if ( tblType . equalsIgnoreCase ( \"obj\" ) ) { Get res = new Get ( Bytes . toBytes ( om . toString ( ) ) ) ; if ( pm . isConcrete ( ) ) { sb . append ( TableDescObjects . OBJECT_TBL_NAME ) ; HTable table = tables ( ) . get ( sb . toString ( ) ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) trIter = new HBaseRdfSingleRowIterator ( rr , sm , pm , om , pm . toString ( ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ; } else { trIter = new HBaseRdfAllTablesIterator ( ) ; Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while ( iterTblNames . hasNext ( ) ) { String tblName = iterTblNames . next ( ) ; String mapPrefix = processTblName ( tblName , tblPrefix , \"objects\" , \"subjects\" ) ; if ( mapPrefix == null ) continue ; HTable table = tables ( ) . get ( tblName ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) ( ( HBaseRdfAllTablesIterator ) trIter ) . addIter ( new HBaseRdfSingleRowIterator ( rr , sm , pm , om , getPredicateMapping ( tblName ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ) ; tblName = null ; mapPrefix = null ; } ( ( HBaseRdfAllTablesIterator ) trIter ) . closeIter ( ) ; } res = null ; } else if ( tblType . equalsIgnoreCase ( \"pred\" ) ) { Scan", "gt": "scanner = new Scan ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9859, "input": "<s> package org . parboiled . matchers ; import org . parboiled . BaseParser ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . errors . GrammarException ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class FirstOfStringsMatcherTest extends TestNgParboiledTest < Object > { @ BuildParseTree static class Parser extends BaseParser < Object > { public Rule Test1 ( ) { return FirstOf ( \"Abc\" , \"Ab\" , \"Bcd\" ) ; } public Rule Test2 ( ) { return FirstOf ( \"Abc\" , \"Abd\" , \"Bcd\" ) ; } public Rule Test3 ( ) { return FirstOf ( \"Ab\" , \"Abc\" , \"Bcd\" ) ; } } @ Test public void testCreateRecords ( ) { StringBuilder sb = new StringBuilder ( ) ; printRecord ( FirstOfStringsMatcher . createRecord ( 0 , toArrayOfCharArray ( \"\" + \"Alpha\" , \"Beta\" , \"Bertram\" , \"Claudia\" , \"ClaudiaVon\" , \"Charlie\" , \"Delta\" , \"Delto\" , \"x\" ) ) , \"\" , sb ) ; assertEquals ( sb . toString ( ) , \"\\n\" + \"Alpha\\n\" + \"Be\\n\" + \"  rtram\\n\" + \"  ta\\n\" + \"C\\n\" + \" harlie\\n\" + \" laudia|Von\\n\" + \"Delt\\n\" + \"    a\\n\" + \"    o\\n\" + \"x\\n\" ) ; } @ Test public void testFirstOfStringsMatcher ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; test ( parser . Test1 ( ) , \"Abc\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test1] 'Abc'\\n\" ) ; test ( parser . Test1 ( ) , \"Ab\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test1] 'Ab'\\n\" ) ; test ( parser . Test1 ( ) , \"Bcd\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test1] 'Bcd'\\n\" ) ; test ( parser . Test2 ( ) , \"Abc\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test2] 'Abc'\\n\" ) ; test ( parser . Test2 ( ) , \"Abd\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test2] 'Abd'\\n\" ) ; test ( parser . Test2 ( ) , \"Bcd\" ) . hasNoErrors ( ) . hasParseTree ( \"[Test2] 'Bcd'\\n\" ) ; } @ Test ( expectedExceptions = GrammarException . class ) public void testFirstOfStringsFail ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; test ( parser . Test3 ( ) , \"Abc\" ) . hasNoErrors ( ) . hasParseTree ( \"\" ) ; } private char [ ] [ ] toArrayOfCharArray ( String ... strings ) { char [ ] [ ] chars = new char [ strings . length ] [ ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { chars [ i ] = strings [ i ] . toCharArray ( ) ; } return chars ; } private void printRecord ( FirstOfStringsMatcher . Record rec , String indent , StringBuilder sb ) { if ( rec == null ) { sb . append ( '\\n' ) ; return ; } if ( rec . complete ) sb . append ( '|' ) ; if (", "gt": "rec . chars . length == 1 )", "prediction": ") ;\n", "label": 0}
{"id": 927, "input": "<s> package org . nuxeo . ecm . platform . annotations . repository . service ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . List ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . ClientRuntimeException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . event . DocumentEventTypes ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventContext ; import org . nuxeo . ecm . platform . annotations . api . Annotation ; import org . nuxeo . ecm . platform . annotations . api . AnnotationsService ; import org . nuxeo . ecm . platform . annotations . repository . URNDocumentViewTranslator ; import org . nuxeo . runtime . api . Framework ; public class ResetCheckedoutGraphListener implements GraphManagerEventListener { protected final URNDocumentViewTranslator translator = new URNDocumentViewTranslator ( ) ; protected final GraphManagerEventListener copyManager = new DocumentVersionnedGraphManager ( ) ; public void manage ( Event event ) { copyManager . manage ( event ) ; if ( ! DocumentEventTypes . DOCUMENT_CHECKEDIN . equals ( event . getName ( ) ) ) { return ; } final EventContext context = event . getContext ( ) ; final CoreSession session = context . getCoreSession ( ) ; final DocumentModel doc = ( DocumentModel ) context . getArguments ( ) [ 0 ] ; final String repo = doc . getRepositoryName ( ) ; try { removeGraphFor ( session , repo , doc , ( NuxeoPrincipal ) context . getPrincipal ( ) ) ; } catch ( Throwable e ) { throw new ClientRuntimeException ( \"Cannot remove annotations from checked-out version of \" + doc . getPathAsString ( ) , e ) ; } } protected void removeGraphFor ( CoreSession session , String repositoryName , DocumentModel doc , NuxeoPrincipal user ) throws URISyntaxException , ClientException { URI uri = translator . getNuxeoUrn ( repositoryName , doc . getId ( ) ) ; AnnotationsService service = Framework . getLocalService ( AnnotationsService . class ) ; List < Annotation > annotations = service", "gt": ". queryAnnotations ( uri , null , user ) ;", "prediction": ";\n", "label": 1}
{"id": 9013, "input": "<s> package pkg ; @ AnnotationType ( optional = \"Class Annotation\" , required = 1994 ) @ AnnotationTypeUndocumented ( optional = \"Class Annotation\" , required = 1994 ) public class AnnotationTypeUsage { @ AnnotationType ( optional = \"Field Annotation\" , required = 1994 ) @ AnnotationTypeUndocumented ( optional = \"Field Annotation\" , required = 1994 ) public int field ; @ AnnotationType ( optional = \"Constructor Annotation\" , required = 1994 ) @ AnnotationTypeUndocumented ( optional = \"Constructor Annotation\" , required = 1994 ) public AnnotationTypeUsage ( ) { } public AnnotationTypeUsage ( @ AnnotationType ( optional = \"Constructor Param Annotation\" , required = 1994 ) int documented , @ AnnotationTypeUndocumented ( optional = \"Constructor Param Annotation\" , required = 1994 ) int undocmented ) { } @ AnnotationType ( optional = \"Method Annotation\" , required = 1994 ) @ AnnotationTypeUndocumented ( optional = \"Method Annotation\" ,", "gt": "required = 1994 ) public void method ( )", "prediction": ") ;\n", "label": 0}
{"id": 933, "input": "<s> package org . eclipse . ui ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface", "gt": ". wizard . IWizard ;", "prediction": ";\n", "label": 1}
{"id": 2741, "input": "<s> package com . sun . tools . javap ; import java . net . URI ; import java . text . DateFormat ; import java . util . Collection ; import java . util . Date ; import java . util . List ; import com . sun . tools . classfile . AccessFlags ; import com . sun . tools . classfile . Attribute ; import com . sun . tools . classfile . Attributes ; import com . sun . tools . classfile . ClassFile ; import com . sun . tools . classfile . Code_attribute ; import com . sun . tools . classfile . ConstantPool ; import com . sun . tools . classfile . ConstantPoolException ; import com . sun . tools . classfile . ConstantValue_attribute ; import com . sun . tools . classfile . Descriptor ; import com . sun . tools . classfile . DescriptorException ; import com . sun . tools . classfile . Exceptions_attribute ; import com . sun . tools . classfile . Field ; import com . sun . tools . classfile . Method ; import com . sun . tools . classfile . Signature ; import com . sun . tools . classfile . Signature_attribute ; import com . sun . tools . classfile . SourceFile_attribute ; import com . sun . tools . classfile . Type ; import com . sun . tools . classfile . Type . ArrayType ; import com . sun . tools . classfile . Type . ClassSigType ; import com . sun . tools . classfile . Type . ClassType ; import com . sun . tools . classfile . Type . MethodType ; import com . sun . tools . classfile . Type . SimpleType ; import com . sun . tools . classfile . Type . TypeParamType ; import com . sun . tools . classfile . Type . WildcardType ; import static com . sun . tools . classfile . AccessFlags . * ; public class ClassWriter extends BasicWriter { static ClassWriter instance ( Context context ) { ClassWriter instance = context . get ( ClassWriter . class ) ; if ( instance == null ) instance = new ClassWriter ( context ) ; return instance ; } protected ClassWriter ( Context context ) { super ( context ) ; context . put ( ClassWriter . class , this ) ; options = Options . instance ( context ) ; attrWriter = AttributeWriter . instance ( context ) ; codeWriter = CodeWriter . instance ( context ) ; constantWriter = ConstantWriter . instance ( context ) ; } void setDigest ( String name , byte [ ] digest ) { this . digestName = name ; this . digest = digest ; } void setFile ( URI uri ) { this . uri = uri ; } void setFileSize ( int size ) { this . size = size ; } void setLastModified ( long lastModified ) { this . lastModified = lastModified ; } protected ClassFile getClassFile ( ) { return classFile ; } protected void setClassFile ( ClassFile cf ) { classFile = cf ; constant_pool = classFile . constant_pool ; } protected Method getMethod ( ) { return method ; } protected void setMethod ( Method m ) { method = m ; } public void write ( ClassFile cf ) { setClassFile ( cf ) ; if ( ( options . sysInfo || options . verbose ) && ! options . compat ) { if ( uri != null ) { if ( uri . getScheme ( ) . equals ( \"file\" ) ) println ( \"Classfile \" + uri . getPath ( ) ) ; else println ( \"Classfile \" + uri ) ; } indent ( + 1 ) ; if ( lastModified != - 1 ) { Date lm = new Date ( lastModified ) ; DateFormat df = DateFormat . getDateInstance ( ) ; if ( size > 0 ) { println ( \"Last modified \" + df . format ( lm ) + \"; size \" + size + \" bytes\" ) ; } else { println ( \"Last modified \" + df . format ( lm ) ) ; } } else if ( size > 0 ) { println ( \"Size \" + size + \" bytes\" ) ; } if ( digestName != null && digest != null ) { StringBuilder sb = new StringBuilder ( ) ; for ( byte b : digest ) sb . append ( String . format ( \"%02x\" , b ) ) ; println ( digestName + \" checksum \" + sb ) ; } } Attribute sfa = cf . getAttribute ( Attribute . SourceFile ) ; if ( sfa instanceof SourceFile_attribute ) { println ( \"Compiled from \\\"\" + getSourceFile ( ( SourceFile_attribute ) sfa ) + \"\\\"\" ) ; } if ( ( options . sysInfo || options . verbose ) && ! options . compat ) { indent ( - 1 ) ; } String name = getJavaName ( classFile ) ; AccessFlags flags = cf . access_flags ; writeModifiers ( flags . getClassModifiers ( ) ) ; if ( classFile . isClass ( ) ) print ( \"class \" ) ; else if ( classFile . isInterface ( ) ) print ( \"interface \" ) ; print ( name ) ; Signature_attribute sigAttr = getSignature ( cf . attributes ) ; if ( sigAttr == null ) { if ( classFile . isClass ( ) && classFile . super_class != 0 ) { String sn = getJavaSuperclassName ( cf ) ; if ( ! sn . equals ( \"java.lang.Object\" ) ) { print ( \" extends \" ) ; print ( sn ) ; } } for ( int i = 0 ; i < classFile . interfaces . length ; i ++ ) { print ( i == 0 ? ( classFile . isClass ( ) ? \" implements \" : \" extends \" ) : \",\" ) ; print ( getJavaInterfaceName ( classFile , i ) ) ; } } else { try { Type t = sigAttr . getParsedSignature ( ) .", "gt": "getType ( constant_pool ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 943, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import java . util . ArrayList ; import java . util . List ; import org . restlet . data . Reference ; import org . restlet . example . book . restlet . ch09 . common . MailRepresentation ; import org . restlet . example . book . restlet . ch09 . common . MailsResource ; import org . restlet . ext . wadl . WadlServerResource ; public class MailsServerResource extends WadlServerResource implements MailsResource { public List < MailRepresentation > retrieve ( ) { List < MailRepresentation > mails = new ArrayList < MailRepresentation > ( ) ; MailRepresentation mail = new MailRepresentation ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( ) . toString ( ) ) ; mails . add ( mail ) ; return mails ; } public void add ( MailRepresentation mail ) { System . out . println ( \"Status: \" + mail . getStatus ( ) ) ; System . out . println ( \"Subject: \" + mail", "gt": ". getSubject ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8223, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Flags extends Property , AccountAttribute , TaskAttribute , ReportAttribute", "gt": ", ResourceAttribute , StatusStatusSheetAttribute , StatusTimesheetAttribute", "prediction": ";\n", "label": 0}
{"id": 946, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . service . IServiceStore ; public final class ServiceStore implements IServiceStore { private final Map < String , Object > attributes ; public ServiceStore ( ) { attributes = new HashMap < String , Object > ( ) ; } public Object getAttribute ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; return attributes . get ( name ) ; } public void setAttribute ( String name , Object value ) { ParamCheck . notNull ( name , \"name\" ) ; attributes . put ( name , value ) ; } public void", "gt": "removeAttribute ( String name )", "prediction": "( )\n", "label": 1}
{"id": 4544, "input": "<s> package com . redhat . ceylon . tools . help . model ; import java . util . Collections ; import java . util . List ; public class OptionsSection implements Documentation { private String title ; private List < Option > options = Collections . emptyList ( ) ; public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public List < Option > getOptions ( ) { return options ; } public void setOptions ( List < Option > options ) { this", "gt": ". options = options ;", "prediction": "\n", "label": 0}
{"id": 950, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . jface . action . IMenuCreator ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . ui . IActionDelegate ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . IWorkbenchWindowPulldownDelegate ; import org . eclipse . ui . IWorkbenchWindowPulldownDelegate2 ; import org . eclipse . ui . WorkbenchException ; public class WWinPluginPulldown extends WWinPluginAction { private final IMenuCreator menuProxy ; private class MenuProxy implements IMenuCreator { private class MenuLoader implements ISafeRunnable { private final Control control ; private final IWorkbenchWindowPulldownDelegate delegate ; private Menu menu = null ; private final Menu parent ; private MenuLoader ( final IWorkbenchWindowPulldownDelegate2 delegate , final Menu parent ) { this . delegate = delegate ; this . parent = parent ; this . control = null ; } private MenuLoader ( final IWorkbenchWindowPulldownDelegate delegate , final Control parent ) { this . delegate = delegate ; this . parent = null ; this . control = parent ; } private Menu getMenu ( ) { return menu ; } public void handleException ( Throwable exception ) { } public void run ( ) throws Exception { if ( parent == null ) { menu = delegate . getMenu ( control ) ; } else { menu = ( ( IWorkbenchWindowPulldownDelegate2 ) delegate ) . getMenu ( parent ) ; } } } public Menu getMenu ( Control parent ) { IWorkbenchWindowPulldownDelegate delegate = getPulldownDelegate ( ) ; if ( delegate != null ) { final MenuLoader menuLoader = new MenuLoader ( delegate , parent ) ; SafeRunner . run ( menuLoader ) ; return menuLoader . getMenu ( ) ; } return null ; } public Menu getMenu ( Menu parent ) { IWorkbenchWindowPulldownDelegate delegate = getPulldownDelegate ( ) ; if ( delegate instanceof IWorkbenchWindowPulldownDelegate2 ) { IWorkbenchWindowPulldownDelegate2 delegate2 = ( IWorkbenchWindowPulldownDelegate2 ) delegate ; final MenuLoader menuLoader = new MenuLoader ( delegate2 , parent ) ; SafeRunner . run ( menuLoader ) ; return menuLoader . getMenu ( ) ; } return null ; } public void dispose ( ) { } } public WWinPluginPulldown ( IConfigurationElement actionElement ,", "gt": "IWorkbenchWindow window , String id , int style )", "prediction": ")\n", "label": 1}
{"id": 6463, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . javadoc . * ; public class TextTag implements Tag { protected final String text ; protected final String name = \"Text\" ; protected final Doc holder ; public TextTag ( Doc holder , String text ) { super ( ) ; this . holder = holder ; this . text = text ; } public String name ( ) { return name ; } public Doc holder ( ) { return holder ; } public String kind ( ) { return name ; } public String text ( ) { return text ; } public String toString ( ) { return name + \":\" + text ; } public Tag [ ] inlineTags ( ) { return new Tag [ ] { this } ; } public Tag [ ] firstSentenceTags ( ) { return new Tag [ ] { this } ; }", "gt": "public SourcePosition position ( )", "prediction": "}\n", "label": 0}
{"id": 956, "input": "<s> package org . spliffy . server . web . templating ; import com . bradmcevoy . common . Path ; import java . util . HashMap ; import java . util . Map ; public class WebResource { private Map < String , String > atts = new HashMap < > ( ) ; private final Path webPath ; private String tag ; private String body ; public WebResource ( Path webPath ) { this . webPath = webPath ; } public String getTag ( ) { return tag ; } public void setTag ( String tag ) { this . tag = tag ; } public Map < String , String > getAtts ( ) { return atts ; } public void setAtts ( Map < String , String > atts ) { this . atts = atts ; } public String getBody ( ) { return body ; } public void setBody ( String body ) { this . body = body ; } public String toHtml ( String themeName ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<\" ) . append ( tag ) . append ( \" \" ) ; for ( Map . Entry < String , String > entry : atts . entrySet ( ) ) { String adjustedValue = adjustRelativePath ( entry . getKey ( ) , entry . getValue ( ) , themeName ) ; sb . append ( entry . getKey ( ) ) . append ( \"=\\\"\" ) . append ( adjustedValue ) . append ( \"\\\" \" ) ; } if ( body != null && body . length ( ) > 0 ) { sb . append ( \">\" ) . append ( body ) . append ( \"</\" ) . append ( tag ) . append ( \">\" ) ; } else { sb . append ( \"/>\" ) ; } return sb . toString ( ) ; } private String adjustRelativePath ( String name , String value , String themeName ) { if ( name . equals ( \"href\" ) || name . equals ( \"src\" ) ) { if ( value != null && value . length ( ) > 0 ) { if ( ! value . startsWith ( \"/\" ) && ! value . startsWith ( \"http\" ) ) { return evaluateRelativePath ( value , themeName ) ; } } } return value ; } private", "gt": "String evaluateRelativePath ( String value , String themeName )", "prediction": "}\n", "label": 1}
{"id": 9606, "input": "<s> package ar . com . fdvs . dj . test ; import java . util . Date ; import net . sf . jasperreports . engine . JasperPrint ; import net . sf . jasperreports . engine . JasperReport ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . BarcodeTypes ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . ImageScaleMode ; public class BarcodeColumnReportTest extends BaseDjReportTest { private JasperPrint jp ; private JasperReport jr ; public DynamicReport buildReport ( ) throws Exception { Style style = new StyleBuilder ( true ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . build ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 20 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 , true ) . addBarcodeColumn ( \"Bar-Code\" , \"amount\" , Long . class . getName ( ) , BarcodeTypes . USD3 , true , false , null , 100 , true , ImageScaleMode . FILL , null ) . addGroups ( 1 ) . setDetailHeight ( 30 ) . addField ( \"productLine\" , String . class . getName ( ) ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; return dr ; } public static void main ( String [ ] args ) throws Exception { BarcodeColumnReportTest test = new BarcodeColumnReportTest ( ) ; test . testReport ( ) ; JasperViewer . viewReport ( test . jp ) ; JasperDesignViewer . viewReportDesign", "gt": "( test . jr ) ;", "prediction": ";\n", "label": 0}
{"id": 957, "input": "<s> package org . eclipse . ui . internal . dialogs ; import org . eclipse . jface . preference . PreferenceNode ; import org . eclipse . ui . internal . IObjectContributor ; public interface IPropertyPageContributor extends IObjectContributor { public PreferenceNode contributePropertyPage ( PropertyPageManager manager", "gt": ", Object object ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5170, "input": "<s> package com . asakusafw . example . direct . seqfile . jobflow . format ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; import java . util . Calendar ; import org . junit . Test ; import com . asakusafw . runtime . value . DateTime ; public class SalesDetailSeqFileFormatTest { @ Test public void testToDateTime ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( 2012 , 5 - 1 , 8 , 23 , 59 , 49 ) ; java . util . Date from = new java . util . Date ( cal . getTimeInMillis ( ) ) ; SalesDetailSeqFileFormat f = new SalesDetailSeqFileFormat ( ) ; DateTime r = f . toDateTime ( from ) ; assertThat ( r . toString ( ) , is ( \"2012-05-08 23:59:49\" ) ) ; } @ Test public void testToUtilDate ( ) { DateTime from = new DateTime ( 2012 , 5 , 8 , 23 , 59 , 49 ) ; SalesDetailSeqFileFormat f = new SalesDetailSeqFileFormat ( ) ; java . util . Date r = f", "gt": ". toUtilDate ( from ) ;", "prediction": ";\n", "label": 0}
{"id": 971, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs . debug ; import java . io . ByteArrayInputStream ; import javax . ws . rs . FormParam ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Response ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . common . xmap . XMap ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . OperationChainContribution ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . PathRef ; import org . nuxeo . ecm . webengine . jaxrs . session . SessionFactory ; import org . nuxeo . ecm . webengine . jaxrs . views . TemplateView ; import org . nuxeo . runtime . api . Framework ; public class DebugResource { private static final Log log = LogFactory . getLog ( DebugResource . class ) ; static final XMap xmap = new XMap ( ) ; static { xmap . register ( OperationChainContribution . class ) ; } public AutomationService getOperationService ( ) { return Framework . getLocalService ( AutomationService . class ) ; } public String getOperationsListAsJson ( ) throws Exception { return JsonWriter . exportOperations ( ) ; } @ GET @ Produces ( \"text/html\" ) public Object doGet ( ) { return new TemplateView ( this , \"index.ftl.html\" ) ; } @ GET @ Produces ( \"text/plain\" ) @ Path ( \"doc\" ) public Object doGetText ( ) throws Exception { return getOperationsListAsJson ( ) ; } @ GET @ Produces ( \"application/json\" ) public Object doGetJSON ( ) throws Exception { return getOperationsListAsJson ( ) ; } @ POST public Response doPost ( @ FormParam ( \"input\" ) String input , @ FormParam ( \"chain\" ) String chainXml ) { CoreSession session = SessionFactory . getSession ( ) ; if ( ! ( ( NuxeoPrincipal ) session . getPrincipal ( ) ) . isAdministrator ( ) ) { return Response . status ( 403 ) . build ( ) ; } try { ByteArrayInputStream in = new ByteArrayInputStream ( chainXml . getBytes ( ) ) ; OperationChainContribution contrib =", "gt": "( OperationChainContribution ) xmap . load ( in ) ;", "prediction": ";\n", "label": 1}
{"id": 10014, "input": "<s> package com . sun . tools . javadoc ; import com . sun . javadoc . * ; import com . sun . tools . javac . code . Attribute ; import com . sun . tools . javac . code . Symbol . VarSymbol ; import com . sun . tools . javac . code . Type ; class ParameterImpl implements Parameter { private final DocEnv env ; private final VarSymbol sym ; private final com . sun . javadoc . Type type ; ParameterImpl ( DocEnv env , VarSymbol sym ) { this . env = env ; this . sym = sym ; this . type = TypeMaker . getType ( env , sym . type , false ) ; } public com . sun . javadoc . Type type ( ) { return type ; } public String name ( ) { return sym . toString ( ) ; } public String typeName ( ) { return ( type instanceof ClassDoc || type instanceof TypeVariable ) ? type . typeName ( ) : type . toString ( ) ; } public String toString ( ) { return typeName ( ) + \" \" + sym ; } public AnnotationDesc [ ] annotations ( ) { AnnotationDesc res [ ] = new AnnotationDesc [ sym . getAnnotationMirrors (", "gt": ") . length ( ) ] ;", "prediction": ") ;\n", "label": 0}
{"id": 973, "input": "<s> package org . nuxeo . ecm . platform . domsync . core . events ; import java . io . Serializable ; public abstract class DOMMutationEvent implements Serializable { private static final long serialVersionUID = - 2969614822761407105L ; private final String target ; protected DOMMutationEvent ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof DOMMutationEvent ) { return target . equals ( ( ( DOMMutationEvent ) obj", "gt": ") . target ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2344, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . redhat . ceylon . compiler . java . codegen . AbstractTransformer . BoxingStrategy ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . ParameterList ; import com . redhat . ceylon . compiler . typechecker . model . ProducedReference ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . TypeParameter ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCClassDecl ; import com . sun . tools . javac . tree . JCTree . JCExpression ; import com . sun . tools . javac . tree . JCTree . JCNewClass ; import com . sun . tools . javac . tree . JCTree . JCStatement ; import com . sun . tools . javac . tree . JCTree . JCTypeCast ; import com . sun . tools . javac . tree . JCTree . JCVariableDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . Name ; import static com . redhat . ceylon . compiler . java . codegen . AbstractTransformer . JT_EXTENDS ; import static com . redhat . ceylon . compiler . java . codegen . AbstractTransformer . JT_NO_PRIMITIVES ; import static com . redhat . ceylon . compiler . java . codegen . AbstractTransformer . JT_CLASS_NEW ; public class CallableBuilder { private final AbstractTransformer gen ; private ProducedType typeModel ; private List < JCStatement > body ; private ParameterList paramLists ; private CallableBuilder ( CeylonTransformer gen ) { this . gen = gen ; } public static CallableBuilder methodReference ( CeylonTransformer gen , Tree . Term expr , ParameterList parameterList ) { JCExpression fnCall ; InvocationBuilder invocationBuilder = InvocationBuilder . forCallableInvocation ( gen , expr , parameterList ) ; boolean prevCallableInv = gen . expressionGen ( ) . withinCallableInvocation ( true ) ; try { fnCall = invocationBuilder . build ( ) ; } finally { gen . expressionGen ( ) . withinCallableInvocation ( prevCallableInv ) ; } CallableBuilder cb = new CallableBuilder ( gen ) ; cb . paramLists = parameterList ; cb . typeModel = expr . getTypeModel ( ) ; cb . body = List . < JCStatement > of ( gen . make ( ) . Return ( fnCall ) ) ; return cb ; } public static CallableBuilder anonymous ( CeylonTransformer gen , Tree . Expression expr , ParameterList parameterList , ProducedType callableTypeModel ) { JCExpression transformedExpr = gen . expressionGen ( ) . transformExpression ( expr ) ; final List < JCStatement > stmts = List . < JCStatement > of ( gen . make ( ) . Return ( transformedExpr ) ) ; return methodArgument ( gen , callableTypeModel , parameterList , stmts ) ; } public static CallableBuilder methodArgument ( CeylonTransformer gen , ProducedType callableTypeModel , ParameterList parameterList , List < JCStatement > stmts ) { CallableBuilder cb = new CallableBuilder ( gen ) ; cb . paramLists = parameterList ; cb . typeModel = callableTypeModel ; cb . body = prependVarsForArgs ( gen , parameterList , stmts ) ; return cb ; } public static CallableBuilder mpl ( CeylonTransformer gen , ProducedType typeModel , ParameterList parameterList , List < JCStatement > body ) { CallableBuilder cb = new CallableBuilder ( gen ) ; cb . paramLists = parameterList ; cb . typeModel = typeModel ; if ( body == null ) { body = List . < JCStatement > nil ( ) ; } body = prependVarsForArgs ( gen , parameterList , body ) ; cb . body = body ; return cb ; } private static List < JCStatement > prependVarsForArgs ( CeylonTransformer gen , ParameterList parameterList , List < JCStatement > body ) { int ii = 0 ; for ( Parameter p : parameterList . getParameters ( ) ) { JCExpression init = unpickCallableParameter ( gen , null , p , null , ii , parameterList . getParameters ( ) . size ( ) ) ; JCVariableDecl varDef = gen . make ( ) . VarDef ( gen . make ( ) . Modifiers ( Flags . FINAL ) , gen . names ( ) . fromString ( p . getName ( ) ) , gen . makeJavaType ( p . getType ( ) , Boolean . TRUE . equals ( p . getUnboxed ( ) ) ? 0 : JT_NO_PRIMITIVES ) , init ) ; body = body . prepend ( varDef ) ; ii ++ ; } return body ; } public JCNewClass build ( ) { MethodDefinitionBuilder callMethod = MethodDefinitionBuilder . callable ( gen ) ; callMethod . isOverride ( true ) ; callMethod . modifiers ( Flags . PUBLIC ) ; ProducedType returnType = gen . getReturnTypeOfCallable ( typeModel ) ; callMethod . resultType ( gen . makeJavaType ( returnType , JT_NO_PRIMITIVES ) , null ) ; int numParams = paramLists . getParameters ( ) . size ( ) ; switch ( numParams ) { case 3 : callMethod . parameter ( makeCallableCallParam ( 0 ,", "gt": "numParams - 3 ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 986, "input": "<s> package br . org . archimedes . curvedshape ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import java . util . ArrayList ; public abstract class CurvedShape extends Element { protected Point centerPoint ; public Point getCenter ( ) { return centerPoint ; } public abstract double getRadius ( ) ; protected void drawCurvedShape ( OpenGLWrapper wrapper , Point center , double initialAngle , double endingAngle ) { ArrayList < Point > points = new ArrayList < Point > ( ) ; double increment = Math . PI / 360 ; for ( double angle = initialAngle ; angle <= endingAngle ; angle += increment ) { double x = center . getX ( ) + this . getRadius ( ) * Math . cos ( angle ) ; double y = center . getY ( ) + this . getRadius ( ) * Math . sin ( angle ) ; points . add ( new Point ( x , y ) ) ; } double x = center . getX ( ) + this . getRadius ( ) * Math . cos ( endingAngle ) ; double y = center . getY ( ) + this . getRadius", "gt": "( ) * Math . sin ( endingAngle ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1056, "input": "<s> package me . chester . minitruco . android . bluetooth ; import java . io . IOException ; import java . io . InputStream ; import me . chester . minitruco . core . Carta ; import me . chester . minitruco . core . Jogador ; import android . bluetooth . BluetoothSocket ; import android . util . Log ; public class JogadorBluetooth extends Jogador implements Runnable { private InputStream in ; private BluetoothSocket socket ; private ServidorBluetoothActivity servidor ; private Thread threadProcessaMensagens ; public JogadorBluetooth ( BluetoothSocket socket , ServidorBluetoothActivity servidor ) { this . socket = socket ; this . servidor = servidor ; threadProcessaMensagens = new Thread ( this ) ; threadProcessaMensagens . start ( ) ; } public void run ( ) { while ( getPosicao ( ) == 0 ) { Thread . yield ( ) ; } int c = 0 ; StringBuffer sbLinha = new StringBuffer ( ) ; try { in = socket . getInputStream ( ) ; do { while ( in != null && in . available ( ) == 0 ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { } } if ( in == null ) break ; c = in . read ( ) ; if ( c != BluetoothBaseActivity . SEPARADOR_REC ) { sbLinha . append ( ( char ) c ) ; } else { if ( sbLinha . length ( ) > 0 ) { Log . w ( \"MINITRUCO\" , \"Linha acumulada: \" + sbLinha . toString ( ) ) ; char tipoNotificacao = sbLinha . charAt ( 0 ) ; String [ ] args = sbLinha . toString ( ) . split ( \" \" ) ; switch ( tipoNotificacao ) { case 'J' : Carta [ ] cartas = getCartas ( ) ; for ( int i = 0 ; i < cartas . length ; i ++ ) { if ( cartas [ i ] != null && cartas [ i ] . toString ( ) . equals ( args [ 1 ] ) ) { cartas [ i ] . setFechada ( args . length > 2 && args [ 2 ] . equals ( \"T\" ) ) ; jogo . jogaCarta ( this , cartas [ i ] ) ; } } break ; case 'H' : jogo . decideMao11 ( this , args [ 1 ] . equals ( \"T\" ) ) ; break ; case 'T' : jogo . aumentaAposta ( this ) ; break ; case 'D' : jogo . respondeAumento ( this , true ) ; break ; case 'A' : jogo . abortaJogo ( getPosicao ( ) ) ; break ; case 'C' : jogo . respondeAumento ( this , false ) ; break ; } sbLinha . setLength ( 0 ) ; } } } while ( in != null ) ; } catch ( IOException e ) { Log . w ( \"MINITRUCO\" , e ) ; } Log . w ( \"MINITRUCO\" , \"encerrando loop JogadorBT\" ) ; } void finaliza ( ) { in = null ; } public synchronized void enviaMensagem ( String linha ) { servidor . enviaMensagem ( getPosicao ( ) - 2 , linha ) ; } public void cartaJogada ( Jogador j , Carta c ) { String param ; if ( c . isFechada ( ) ) { if ( j . equals ( this ) ) { param = \" \" + c + \" T\" ; } else { param = \"\" ; } } else { param = \" \" + c . toString ( ) ; } enviaMensagem ( \"J \" + j . getPosicao ( ) + param ) ; } public void inicioMao ( ) { StringBuffer comando = new StringBuffer ( \"M\" ) ; for ( int i = 0 ; i <= 2 ; i ++ ) comando . append ( \" \" + getCartas ( ) [ i ] ) ; if ( ! jogo . isManilhaVelha ( ) ) { comando . append ( \" \" + jogo . cartaDaMesa ) ; } enviaMensagem ( comando . toString ( ) ) ; } public void inicioPartida ( int p1 , int p2 ) { enviaMensagem ( \"P\" ) ; } public void vez ( Jogador j , boolean podeFechada ) { enviaMensagem ( \"V \" + j . getPosicao ( ) + ' ' + ( podeFechada ? 'T' : 'F' ) ) ; } public void pediuAumentoAposta ( Jogador j , int valor ) { enviaMensagem ( \"T \" + j . getPosicao ( ) + ' ' + valor ) ; } public void aceitouAumentoAposta ( Jogador j , int valor ) { enviaMensagem ( \"D \" + j . getPosicao ( ) + ' ' + valor ) ; } public void recusouAumentoAposta ( Jogador j ) { enviaMensagem ( \"C \" + j . getPosicao ( ) ) ; } public void rodadaFechada ( int numRodada , int resultado , Jogador jogadorQueTorna ) { enviaMensagem ( \"R \" + resultado + ' ' + jogadorQueTorna . getPosicao ( ) ) ; } public void maoFechada ( int [ ] pontosEquipe ) { enviaMensagem ( \"O \" + pontosEquipe [ 0 ] + ' ' + pontosEquipe [ 1 ] ) ; } public void decidiuMao11 ( Jogador j , boolean aceita ) { enviaMensagem ( \"H \" + j . getPosicao ( ) + ( aceita ? \" T\" : \" F\" ) ) ; } public void informaMao11 ( Carta [ ] cartasParceiro ) { StringBuffer sbComando = new StringBuffer ( \"F \" ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { sbComando . append ( cartasParceiro [ i ] ) ; if ( i != 2 ) sbComando . append ( ' ' ) ; } enviaMensagem ( sbComando . toString ( ) ) ; } public void jogoFechado ( int numEquipeVencedora ) { enviaMensagem ( \"G \" + numEquipeVencedora ) ; finaliza ( ) ; } public void jogoAbortado ( int posicao ) { enviaMensagem ( \"A \" + posicao ) ; finaliza ( ) ; } public void jogoAbortadoPorComando ( ) { enviaMensagem ( \"AB\" ) ; } public void setGameLevel ( int gameLevel ) { } public void setNickEstrategia ( ) { }", "gt": "public String getNickEstrategia ( )", "prediction": "}\n", "label": 0}
{"id": 1000, "input": "<s> package org . eclipse . swt . custom ; import static org . mockito . Mockito . mock ; import java . util . ArrayList ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . events . TypedEvent ; import org . eclipse . swt . events . VerifyEvent ; import org . eclipse . swt . events . VerifyListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; public class CCombo_Test extends TestCase { private boolean listenerCalled ; private Display display ; private Shell shell ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testDeselect ( ) { CCombo combo = new CCombo ( shell , SWT . NONE ) ; combo . add ( \"item1\" ) ; combo . add ( \"item2\" ) ; combo . add ( \"item3\" ) ; combo . select ( 1 ) ; combo . deselect ( 1 ) ; assertEquals ( - 1 , combo . getSelectionIndex ( ) ) ; combo . select ( 1 ) ; combo . deselect ( 0 ) ; assertEquals ( 1 , combo . getSelectionIndex ( ) ) ; } public void testGetText ( ) { CCombo combo = new CCombo ( shell , SWT . READ_ONLY ) ; combo . add ( \"item1\" ) ; combo . add ( \"item2\" ) ; combo . add ( \"item3\" ) ; assertEquals ( combo . getText ( ) , \"\" ) ; combo . select ( 2 ) ; assertEquals ( combo . getText ( ) , \"item3\" ) ; combo . deselectAll ( ) ; assertEquals ( combo . getText ( ) , \"\" ) ; combo = new CCombo ( shell , SWT . NONE ) ; String [ ] cases = { \"\" , \"fred\" , \"fredfred\" } ; for ( int i = 0 ; i < cases . length ; i ++ ) { combo . setText ( cases [ i ] ) ; assertTrue ( \":a:\" + String . valueOf ( i ) , cases [ i ] . equals ( combo . getText ( ) ) ) ; } } public void testTextLimit ( ) { CCombo combo = new CCombo ( shell , SWT . NONE ) ; combo . setTextLimit ( - 1 ) ; assertEquals ( Combo . LIMIT , combo . getTextLimit ( ) ) ; combo . setTextLimit ( - 20 ) ; assertEquals ( Combo . LIMIT , combo . getTextLimit ( ) ) ; combo . setTextLimit ( - 12345 ) ; assertEquals ( Combo . LIMIT , combo . getTextLimit ( ) ) ; combo . setTextLimit ( 20 ) ;", "gt": "assertEquals ( 20 , combo . getTextLimit ( ) ) ;", "prediction": "}\n", "label": 1}
{"id": 4069, "input": "<s> package com . atlassian . crowd . integration . exception ; @ SuppressWarnings ( \"serial\" ) public class InvalidTokenException extends org . apache . axis . AxisFault implements java . io . Serializable { public InvalidTokenException ( ) { } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof InvalidTokenException ) ) return false ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( InvalidTokenException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://exception.integration.crowd.atlassian.com\" , \"InvalidTokenException\" ) ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer", "gt": "( _javaType , _xmlType , typeDesc ) ;", "prediction": ";\n", "label": 0}
{"id": 1005, "input": "<s> package org . seage . aal . algorithm ; public abstract class AlgorithmAdapterImpl implements IAlgorithmAdapter { protected boolean _algorithmStarted = false ; protected boolean _algorithmStopped = false ; public void startSearching ( boolean async ) throws Exception { if ( _algorithmStarted && ! _algorithmStopped ) throw new Exception ( \"Algorithm already started, running.\" ) ; _algorithmStarted = false ; if ( async == true ) { new Thread", "gt": "( new Runnable ( )", "prediction": "( ) ;\n", "label": 1}
{"id": 6868, "input": "<s> import java . util . * ; class CastTest { private class AA < T > { } private class AB < T > extends AA < T > { } private class AC < T > extends AA < Vector < T > > { } private class AD < T > extends AA < Vector < ? extends T > > { } private class AE < T > extends AA < Vector < ? super T > > { } private class AF", "gt": "< T > extends AA < T [ ] >", "prediction": "\n", "label": 0}
{"id": 1018, "input": "<s> package com . cloudera . sqoop . cli ; public class ToolOptions extends org . apache .", "gt": "sqoop . cli . ToolOptions", "prediction": "( ) ;\n", "label": 1}
{"id": 4618, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . materialien ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . FSK ; public class FilmTest { @ Test public void testeKonstruktoren ( ) { Film f = new Film ( \"Titel\" , 90 , FSK . FSK16 , true ) ; assertEquals ( \"Titel\" , f . getTitel ( ) ) ; assertEquals ( 90 ,", "gt": "f . getLaenge ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1021, "input": "<s> package org . eclipse . ui . internal . activities . ws ; import org . eclipse . ui . activities . ITriggerPoint ; public abstract class AbstractTriggerPoint implements ITriggerPoint { public boolean equals ( Object obj ) { if ( obj instanceof ITriggerPoint ) { return getId ( ) . equals ( (", "gt": "( ITriggerPoint ) obj ) . getId ( ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 10082, "input": "<s> package org . gk . engine . client . utils ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; import com . extjs . gxt . ui . client . widget . grid . ColumnModel ; import com . extjs . gxt . ui . client . widget . grid . Grid ; public class GridUtils { public static int getColumnIdx ( Grid grid , String id ) { ColumnModel cm = grid . getColumnModel ( ) ; int size = cm . getColumnCount ( ) ; for ( int i = 0 ; i < size ; i ++ ) { ColumnConfig cc = cm . getColumn ( i ) ; if ( cc . getId ( ) . equals ( id", "gt": ") ) return i ;", "prediction": ") ;\n", "label": 0}
{"id": 1052, "input": "<s> package org . apache . lucene . analysis . ngram ; import java . io . StringReader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; public class EdgeNGramTokenizerTest extends BaseTokenStreamTestCase { private StringReader input ; public void setUp ( ) throws Exception { super . setUp ( ) ; input = new StringReader ( \"abcde\" ) ; } public void testInvalidInput ( ) throws Exception { boolean gotException = false ; try { new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , 0 , 0 ) ; } catch ( IllegalArgumentException e ) { gotException = true ; } assertTrue ( gotException ) ; } public void testInvalidInput2 ( ) throws Exception { boolean gotException = false ; try { new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , 2 , 1 ) ; } catch ( IllegalArgumentException e ) { gotException = true ; } assertTrue ( gotException ) ; } public void testInvalidInput3 ( ) throws Exception { boolean gotException = false ; try { new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , - 1 , 2 ) ; } catch ( IllegalArgumentException e ) { gotException = true ; } assertTrue ( gotException ) ; } public void testFrontUnigram ( ) throws Exception { EdgeNGramTokenizer tokenizer = new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , 1 , 1 ) ; assertTokenStreamContents ( tokenizer , new String [ ] { \"a\" } , new int [ ] { 0 } , new int [ ] { 1 } , new Integer ( 5 ) ) ; } public void testBackUnigram ( ) throws Exception { EdgeNGramTokenizer tokenizer = new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . BACK , 1 , 1 ) ; assertTokenStreamContents ( tokenizer , new String [ ] { \"e\" } , new int [ ] { 4 } , new int [ ] { 5 } , new Integer ( 5 ) ) ; } public void testOversizedNgrams ( ) throws Exception { EdgeNGramTokenizer tokenizer = new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , 6 , 6 ) ; assertTokenStreamContents ( tokenizer , new String [ 0 ] , new int [ 0 ] , new int [ 0 ] , new Integer ( 5 ) ) ; } public void testFrontRangeOfNgrams ( ) throws Exception { EdgeNGramTokenizer tokenizer = new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . FRONT , 1 , 3 ) ; assertTokenStreamContents ( tokenizer , new String [ ] { \"a\" , \"ab\" , \"abc\" } , new int [ ] { 0 , 0 , 0 } , new int [ ] { 1 , 2 , 3 } , new Integer ( 5 ) ) ; } public void testBackRangeOfNgrams ( ) throws Exception { EdgeNGramTokenizer tokenizer = new EdgeNGramTokenizer ( input , EdgeNGramTokenizer . Side . BACK , 1 , 3 ) ; assertTokenStreamContents (", "gt": "tokenizer , new String [ ]", "prediction": ") ;\n", "label": 1}
{"id": 4103, "input": "<s> package org . papaours . yama . services . impl ; import java . io . FileNotFoundException ; import java . io . FileReader ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Unmarshaller ; import org . papaours . yama . model . YamaImportedQuiz ; import org . papaours . yama . model . YamaQuiz ; import org . papaours . yama . services . ImportQuizService ; public class ImportQuizServiceImpl implements ImportQuizService { public YamaImportedQuiz importQuiz (", "gt": "final String sourceXmlFilePath ) throws JAXBException , FileNotFoundException", "prediction": ") ;\n", "label": 0}
{"id": 1063, "input": "<s> package org . modelgoon . core ; import org . modelgoon . core . ui . CreationCommand ; import org . modelgoon . core . ui . RootElementEditPart ; public class CreateNoteCommand extends CreationCommand { RootElementEditPart < ? > packageDiagramEditPart ; public CreateNoteCommand ( final RootElementEditPart < ? > packageDiagramEditPart ) { super ( ) ; this . packageDiagramEditPart = packageDiagramEditPart ; } @ Override public void attachNewElement ( final ModelElement newObject ) { this . packageDiagramEditPart . getModelElement ( ) .", "gt": "addNote ( ( Note ) newObject ) ;", "prediction": ";\n", "label": 1}
{"id": 4439, "input": "<s> package org . ofbiz . entity . model ; import java . io . PrintWriter ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TimeZone ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilPlist ; import org . ofbiz . base . util . UtilTimer ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . jdbc . DatabaseUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class ModelEntity extends ModelInfo implements Comparable < ModelEntity > , Serializable { public static final String module = ModelEntity . class . getName ( ) ; public static final String STAMP_FIELD = \"lastUpdatedStamp\" ; public static final String STAMP_TX_FIELD = \"lastUpdatedTxStamp\" ; public static final String CREATE_STAMP_FIELD = \"createdStamp\" ; public static final String CREATE_STAMP_TX_FIELD = \"createdTxStamp\" ; protected ModelReader modelReader = null ; protected String entityName = \"\" ; protected String tableName = \"\" ; protected String packageName = \"\" ; protected String dependentOn = \"\" ; protected Integer sequenceBankSize = null ; protected List < ModelField > fields = FastList . newInstance ( ) ; protected Map < String , ModelField > fieldsMap = null ; protected List < ModelField > pks = FastList . newInstance ( ) ; protected List < ModelField > nopks = FastList . newInstance ( ) ; protected List < ModelRelation > relations = FastList . newInstance ( ) ; protected List < ModelIndex > indexes = FastList . newInstance ( ) ; protected ModelEntity specializationOfModelEntity = null ; protected Map < String , ModelEntity > specializedEntities = FastMap . newInstance ( ) ; protected Set < String > viewEntities = FastSet . newInstance ( ) ; protected boolean doLock = false ; protected boolean noAutoStamp = false ; protected boolean neverCache = false ; protected boolean neverCheck = false ; protected boolean autoClearCache = true ; protected Boolean hasFieldWithAuditLog = null ; protected String location = \"\" ; public ModelEntity ( ) { } protected ModelEntity ( ModelReader reader ) { this . modelReader = reader ; } protected ModelEntity ( ModelReader reader , ModelInfo def ) { super ( def ) ; this . modelReader = reader ; } protected ModelEntity ( ModelReader reader , Element entityElement , ModelInfo def ) { this ( reader , def ) ; populateFromAttributes ( entityElement ) ; } public ModelEntity ( ModelReader reader , Element entityElement , UtilTimer utilTimer , ModelInfo def ) { this ( reader , entityElement , def ) ; if ( utilTimer != null ) utilTimer . timerString ( \"  createModelEntity: before general/basic info\" ) ; this . populateBasicInfo ( entityElement ) ; if ( utilTimer != null ) utilTimer . timerString ( \"  createModelEntity: before fields\" ) ; for ( Element fieldElement : UtilXml . childElementList ( entityElement , \"field\" ) ) { ModelField field = reader . createModelField ( fieldElement ) ; if", "gt": "( field != null )", "prediction": "( ) ;\n", "label": 0}
{"id": 1064, "input": "<s> package org . eclipse . ui . menus ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . services . IServiceLocator ; public abstract class UIElement { private IServiceLocator serviceLocator ; protected UIElement ( IServiceLocator serviceLocator ) throws IllegalArgumentException { if ( serviceLocator == null ) throw new IllegalArgumentException ( ) ; this . serviceLocator = serviceLocator ; } public abstract void", "gt": "setText ( String text ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6708, "input": "<s> public class TestThrowsTagInheritence extends JavadocTester { private static final String BUG_ID = \"4684827-4633969\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"Foo.html\" , \"Test 1 passes.\" } } ; private static final String [ ] [ ] NEGATED_TEST = { { BUG_ID + FS + \"C.html\" , \"Test 1 fails.\" } } ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , SRC_DIR + FS + \"C.java\" , SRC_DIR + FS + \"I.java\" , SRC_DIR + FS + \"Foo.java\" , SRC_DIR + FS + \"Iface.java\" } ; public static void main ( String [ ] args ) { TestThrowsTagInheritence tester = new TestThrowsTagInheritence ( ) ; run ( tester , ARGS", "gt": ", TEST , NEGATED_TEST ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1070, "input": "<s> package br . org . archimedes . text ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.text.messages\" ; public static String Cancel ; public static String Created ; public static String ExpectedDist ; public static String ExpectedPoint ; public static String ExpectedText ; public static String Iteration1 ; public static String Iteration2 ; public static String Iteration3 ; static { NLS . initializeMessages (", "gt": "BUNDLE_NAME , Messages . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4068, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . kasse ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Datum ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Kino ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Tagesplan ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Vorstellung ; import de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . Beobachter ; import de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . datumswaehler . DatumAuswaehlWerkzeug ; import de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . platzverkauf . PlatzVerkaufsWerkzeug ; import de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . vorstellungswaehler . VorstellungAuswaehlWerkzeug ; public class KassenWerkzeug { private Kino _kino ; private KassenWerkzeugUI _ui ; private PlatzVerkaufsWerkzeug _platzVerkaufsWerkzeug ; private DatumAuswaehlWerkzeug _datumAuswaehlWerkzeug ; private VorstellungAuswaehlWerkzeug _vorstellungAuswaehlWerkzeug ; public KassenWerkzeug ( Kino kino ) { assert kino != null : \"Vorbedingung verletzt: kino != null\" ; _kino = kino ; _platzVerkaufsWerkzeug = new PlatzVerkaufsWerkzeug ( ) ; _datumAuswaehlWerkzeug = new DatumAuswaehlWerkzeug ( ) ; _vorstellungAuswaehlWerkzeug = new VorstellungAuswaehlWerkzeug ( ) ; _ui = new KassenWerkzeugUI ( _platzVerkaufsWerkzeug . getUIPanel ( ) , _datumAuswaehlWerkzeug . getUIPanel ( )", "gt": ", _vorstellungAuswaehlWerkzeug . getUIPanel ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 1073, "input": "<s> package org . gatein . common . util ; import org . gatein . common . net . media . MediaType ; public class ContentInfo { private final MediaType mediaType ; public ContentInfo ( MediaType mediaType ) {", "gt": "if ( mediaType == null )", "prediction": "\n", "label": 1}
{"id": 2641, "input": "<s> package org . ofbiz . order . shoppinglist ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Date ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityTypeUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . shoppingcart . CartItemModifyException ; import org . ofbiz . order . shoppingcart . CheckOutHelper ; import org . ofbiz . order . shoppingcart . ItemNotFoundException ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . product . config . ProductConfigWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . calendar . RecurrenceInfo ; import org . ofbiz . service . calendar . RecurrenceInfoException ; import com . ibm . icu . util . Calendar ; public class ShoppingListServices { public static final String module = ShoppingListServices . class . getName ( ) ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static Map < String , Object > setShoppingListRecurrence ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator", "gt": "= dctx . getDelegator ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1081, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . server ; import java . util . LinkedList ; import java . util . List ; import javax . servlet . http . HttpSession ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . cluster . testfixture . test . TestEntryPoint ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class DelegatingServletEngine_Test extends TestCase { private static class TestServletEngine implements IServletEngine { static final String START = \"start\" ; static final String STOP = \"stop\" ; static final String GET_PORT = \"getPort\" ; static final String GET_SESSIONS = \"getSessions\" ; List < String > invocations ; public TestServletEngine ( ) { invocations = new LinkedList < String > ( ) ; } public void start ( Class < ? extends IEntryPoint > entryPointClass ) throws Exception { invocations . add ( START ) ; } public void stop ( ) throws Exception { invocations . add ( STOP ) ; } public void stop ( int timeout ) throws Exception { invocations . add ( STOP ) ; } public int getPort ( ) { invocations . add ( GET_PORT ) ; return 0 ; } public HttpSession [ ] getSessions ( ) { invocations . add ( GET_SESSIONS ) ; return null ; } } private TestServletEngine testServletEngine ; public void testGetDelegate ( ) { TestServletEngine delegate = new TestServletEngine ( ) ; DelegatingServletEngine engine = new DelegatingServletEngine ( delegate ) ; assertSame ( delegate , engine . getDelegate ( ) ) ; } public void testStartWithNullEntryPointClass ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; try { engine . start ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testStartDelegates ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; engine . start ( TestEntryPoint . class ) ; assertEquals ( TestServletEngine . START , testServletEngine . invocations . get ( 0 ) ) ; } public void testStartMultipleTimes ( ) throws Exception { IServletEngine engine = startServletEngine ( TestEntryPoint . class ) ; try { engine . start ( TestEntryPoint . class ) ; fail ( ) ; } catch ( IllegalStateException e ) { } } public void testGetSessionsDelegates ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; engine . start ( TestEntryPoint . class ) ; engine . getSessions ( ) ; assertTrue ( testServletEngine . invocations . contains ( TestServletEngine . START ) ) ; } public void testGetSessionsAfterStop ( ) throws Exception { IServletEngine engine = startServletEngine ( TestEntryPoint . class ) ; engine . stop ( ) ; try { engine . getSessions ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testStopDelegates ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; engine . start ( TestEntryPoint . class ) ; engine . stop ( ) ; assertTrue ( testServletEngine . invocations . contains ( TestServletEngine . STOP ) ) ; } public void testStopTimeoutDelegates ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; engine . start ( TestEntryPoint . class ) ; engine . stop ( 0 ) ; assertTrue ( testServletEngine . invocations . contains ( TestServletEngine . STOP ) ) ; } public void testGetPortDelegates ( ) throws Exception { IServletEngine engine = new DelegatingServletEngine ( testServletEngine ) ; engine . start ( TestEntryPoint . class ) ; engine . getPort ( ) ; assertTrue ( testServletEngine . invocations . contains", "gt": "( TestServletEngine . GET_PORT ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1301, "input": "<s> class T6881645 { Object o = new Object ( ) { < Z > void m ( Class < Z > x ) { } void test ( ) { m (", "gt": "( Class ) null ) ;", "prediction": ")\n", "label": 0}
{"id": 1107, "input": "<s> package org . restlet . test . resource ; import java . io . IOException ; import org . restlet . data . Status ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Finder ; import org . restlet . resource . ResourceException ; import org . restlet . test . RestletTestCase ; public class AnnotatedResource3TestCase extends RestletTestCase { private ClientResource clientResource ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Finder finder = new Finder ( ) ; finder . setTargetClass ( MyResource3 . class ) ; this . clientResource = new ClientResource ( \"http://local\" ) ; this . clientResource . setNext ( finder ) ; } @ Override protected void tearDown ( ) throws Exception { clientResource = null ; super . tearDown ( ) ; } public void testGet ( ) throws IOException , ResourceException { Status status = null ; try { clientResource . get ( ) ; status = clientResource . getStatus ( ) ; } catch ( ResourceException e ) { status = e . getStatus ( ) ; } assertEquals ( Status .", "gt": "CLIENT_ERROR_NOT_FOUND , status ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2544, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . WeeklyMin ; public class WeeklyMinImpl extends LimitsAttributeImpl implements WeeklyMin { protected WeeklyMinImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return", "gt": "ProjectPackage . eINSTANCE . getWeeklyMin ( ) ;", "prediction": "\n", "label": 0}
{"id": 1111, "input": "<s> package org . nuxeo . ecm . platform . picture . core . libraryselector ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . picture . core . ImageUtils ; @ XObject", "gt": "( \"ImageUtils\" ) public class ImageUtilsDescriptor", "prediction": ";\n", "label": 1}
{"id": 7442, "input": "<s> package org . ofbiz . content . webapp . ftl ; import java . io . IOException ; import java . io . Writer ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . content . content . ContentUrlFilter ; import freemarker . core . Environment ; import freemarker . ext . beans . BeanModel ; import freemarker . ext . beans . NumberModel ; import freemarker . ext . beans . StringModel ; import freemarker . template . SimpleNumber ; import freemarker . template . SimpleScalar ; import freemarker . template . TemplateModelException ; import freemarker . template . TemplateTransformModel ; public class OfbizContentAltUrlTransforms implements TemplateTransformModel { public final static String module = OfbizContentAltUrlTransforms . class . getName ( ) ; @ SuppressWarnings ( \"unchecked\" ) public String getStringArg ( Map args , String key ) { Object o = args . get ( key ) ; if ( o instanceof SimpleScalar ) { return ( ( SimpleScalar ) o ) . getAsString ( ) ; } else if ( o instanceof StringModel ) { return ( ( StringModel ) o ) . getAsString ( ) ; } else if ( o instanceof SimpleNumber ) { return ( ( SimpleNumber ) o ) . getAsNumber ( ) . toString ( ) ; } else if ( o instanceof NumberModel ) { return ( ( NumberModel ) o ) . getAsNumber ( ) . toString ( ) ; } return null ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public Writer getWriter ( final Writer out , final Map args ) throws TemplateModelException , IOException { final StringBuilder buf = new StringBuilder ( ) ; return new Writer ( out ) { public void write ( char [ ] cbuf , int off , int len ) throws IOException { buf . append ( cbuf , off , len ) ; } public void flush ( ) throws IOException { out . flush ( ) ; } public void close ( ) throws IOException { try { Environment env = Environment . getCurrentEnvironment ( ) ; BeanModel req = ( BeanModel ) env . getVariable ( \"request\" ) ; BeanModel res = ( BeanModel ) env . getVariable ( \"response\" ) ; if ( req != null ) { String", "gt": "contentId = getStringArg ( args , \"contentId\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1113, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . util . PriorityQueue ; public class ParallelMultiSearcher extends MultiSearcher { private Searchable [ ] searchables ; private int [ ] starts ; public ParallelMultiSearcher ( Searchable [ ] searchables ) throws IOException { super ( searchables ) ; this . searchables = searchables ; this . starts = getStarts ( ) ; } public int docFreq ( Term term ) throws IOException { return super . docFreq ( term ) ; } public TopDocs search ( Weight weight , Filter filter , int nDocs ) throws IOException { HitQueue hq = new HitQueue ( nDocs , false ) ; int totalHits = 0 ; MultiSearcherThread [ ] msta = new MultiSearcherThread [ searchables . length ] ; for ( int i = 0 ; i < searchables . length ; i ++ ) { msta [ i ] = new MultiSearcherThread ( searchables [ i ] , weight , filter , nDocs , hq , i , starts , \"MultiSearcher thread #\" + ( i + 1 ) ) ; msta [ i ] . start ( ) ; } for ( int i = 0 ; i < searchables . length ; i ++ ) { try { msta [ i ] . join ( ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( ie ) ; } IOException ioe = msta [ i ] . getIOException ( ) ; if ( ioe == null ) { totalHits += msta [ i ] . hits ( ) ; } else { throw ioe ; } } ScoreDoc [ ] scoreDocs = new ScoreDoc [ hq . size ( ) ] ; for ( int i = hq . size ( ) - 1 ; i >= 0 ; i -- ) scoreDocs [ i ] = ( ScoreDoc ) hq . pop ( ) ; float maxScore = ( totalHits == 0 ) ? Float . NEGATIVE_INFINITY : scoreDocs [ 0 ] . score ; return new TopDocs ( totalHits , scoreDocs , maxScore ) ; } public TopFieldDocs search ( Weight weight , Filter filter , int nDocs , Sort sort ) throws IOException { FieldDocSortedHitQueue hq = new FieldDocSortedHitQueue ( null , nDocs ) ; int totalHits = 0 ; MultiSearcherThread [ ] msta = new MultiSearcherThread [ searchables . length ] ; for ( int i = 0 ; i < searchables . length ; i ++ ) { msta [ i ] = new MultiSearcherThread ( searchables [ i ] , weight , filter , nDocs , hq , sort , i , starts , \"MultiSearcher thread #\" + ( i + 1 ) ) ; msta [ i ] . start ( ) ; } float maxScore = Float . NEGATIVE_INFINITY ; for ( int i = 0 ; i < searchables . length ; i ++ ) { try { msta [ i ] . join ( ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( ie ) ; } IOException ioe = msta [ i ] . getIOException ( ) ; if ( ioe == null ) { totalHits += msta [ i ] . hits ( ) ; maxScore = Math . max ( maxScore , msta [ i ] . getMaxScore ( ) ) ; } else { throw ioe ; } } ScoreDoc [ ] scoreDocs = new ScoreDoc [ hq . size ( ) ] ; for ( int i = hq . size ( ) - 1 ; i >= 0 ; i -- ) scoreDocs [ i ] = ( ScoreDoc ) hq . pop ( ) ; return new TopFieldDocs ( totalHits , scoreDocs , hq . getFields ( ) , maxScore ) ; } public void search ( Weight weight , Filter filter , final Collector collector ) throws IOException { for ( int i = 0 ; i < searchables . length ; i ++ ) { final int start = starts [ i ] ; final Collector hc = new Collector ( ) { public void setScorer ( Scorer scorer ) throws IOException { collector . setScorer ( scorer ) ; } public void collect ( int doc , int [ ] sorts ) throws IOException { collector . collect ( doc , sorts ) ; } public void setNextReader ( IndexReader reader , int docBase ) throws IOException { collector . setNextReader ( reader , start + docBase ) ; } public boolean acceptsDocsOutOfOrder ( ) { return collector . acceptsDocsOutOfOrder ( ) ; } } ; searchables [ i ] . search ( weight , filter , hc ) ; } } public Query rewrite ( Query original ) throws IOException { return super . rewrite ( original ) ; } } class MultiSearcherThread extends Thread { private Searchable searchable ; private Weight weight ; private Filter filter ; private int nDocs ; private TopDocs docs ; private int i ; private PriorityQueue hq ; private int [ ] starts ; private IOException ioe ; private Sort sort ; public MultiSearcherThread ( Searchable searchable , Weight weight , Filter filter , int nDocs , HitQueue hq , int i , int [ ] starts , String name ) { super ( name ) ; this . searchable = searchable ; this . weight = weight ; this . filter = filter ; this . nDocs = nDocs ; this . hq = hq ; this . i = i ; this . starts = starts ; } public MultiSearcherThread ( Searchable searchable , Weight weight , Filter filter , int nDocs , FieldDocSortedHitQueue hq , Sort sort , int i , int [ ]", "gt": "starts , String name )", "prediction": ") ;\n", "label": 1}
{"id": 4207, "input": "<s> package com . sun . source . util ; import com . sun . source . tree . * ; public class TreePathScanner < R , P > extends TreeScanner < R , P > { public R scan ( TreePath path , P p ) { this . path = path ; try { return path . getLeaf ( ) . accept ( this , p ) ; } finally { this . path = null ; } } @ Override public R scan ( Tree tree , P p ) { if ( tree", "gt": "== null ) return null ;", "prediction": ")\n", "label": 0}
{"id": 1114, "input": "<s> package scenes . TitleScene . GUI ; import graphics . NES ; import graphics . Sprite ; import java . awt . Graphics ; import scenes . HUD ; import scenes . TitleScene . System . IntroState ; import scenes . TitleScene . System . TitleSystem ; public class TitleGUI extends HUD { private Intro intro ; private TitleScreen ts ; private Sprite arrow = NES . ARROW ; public TitleGUI ( TitleSystem t ) { parent = t ; intro = new Intro ( ) ; ts = new TitleScreen ( ) ; intro . setParent ( t ) ; ts . setParent ( t ) ; } @ Override public void update ( ) { if ( parent . getState ( ) instanceof IntroState ) intro . update ( ) ; } @ Override public void paint ( Graphics g ) { int [ ] curPos ; if ( parent . getState ( ) instanceof IntroState ) { clearColor = NES . BLUE ; intro . paint ( g ) ; curPos = intro . updateArrowPosition ( 0 ) ; } else { clearColor = null ; ts . paint ( g ) ; curPos = ts . updateArrowPosition ( parent . getState ( )", "gt": ". getIndex ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 710, "input": "<s> package org . ofbiz . entity . transaction ; import java . sql . Connection ; import java . sql . SQLException ; import javax . transaction . HeuristicMixedException ; import javax . transaction . HeuristicRollbackException ; import javax . transaction . InvalidTransactionException ; import javax . transaction . NotSupportedException ; import javax . transaction . RollbackException ; import javax . transaction . SystemException ; import javax . transaction . Transaction ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import org . ofbiz . base . util . Debug ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . ConnectionFactory ; public class DumbFactory implements TransactionFactoryInterface { public static final String module = DumbFactory . class . getName ( ) ; public TransactionManager getTransactionManager ( ) { return new TransactionManager ( ) { public void begin ( ) throws NotSupportedException , SystemException { } public void commit ( ) throws RollbackException , HeuristicMixedException , HeuristicRollbackException , SecurityException , IllegalStateException , SystemException { } public int getStatus ( ) throws SystemException { return TransactionUtil . STATUS_NO_TRANSACTION ; } public Transaction getTransaction ( ) throws SystemException { return null ; } public void resume ( Transaction transaction ) throws InvalidTransactionException , IllegalStateException , SystemException { } public void rollback ( ) throws IllegalStateException , SecurityException , SystemException { } public void setRollbackOnly ( ) throws IllegalStateException , SystemException { } public void setTransactionTimeout ( int i ) throws SystemException { } public Transaction", "gt": "suspend ( ) throws SystemException", "prediction": "\n", "label": 0}
{"id": 1115, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . expressions . EvaluationResult ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . ExpressionInfo ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . handlers . HandlerUtil ; public class ShowViewMenuHandler extends AbstractEvaluationHandler { private Expression enabledWhen ; public ShowViewMenuHandler ( ) { registerEnablement ( ) ; } public Object execute ( ExecutionEvent event ) throws ExecutionException { IWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; if ( part != null ) { IWorkbenchPartSite site = part . getSite ( ) ; if ( site instanceof PartSite ) { PartPane pane = ( ( PartSite ) site ) . getPane ( ) ; pane . showPaneMenu ( ) ; } } return null ; } protected Expression getEnabledWhenExpression ( ) { if ( enabledWhen == null ) { enabledWhen = new Expression ( ) { public EvaluationResult evaluate ( IEvaluationContext context ) throws CoreException { IWorkbenchPart part = InternalHandlerUtil . getActivePart ( context ) ; if ( part != null ) { PartPane pane = ( ( PartSite ) part . getSite ( ) ) . getPane ( ) ; if ( ( pane instanceof ViewPane ) && ( ( ViewPane", "gt": ") pane ) . hasViewMenu ( ) )", "prediction": ") )\n", "label": 1}
{"id": 7688, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . preferences ; import org . eclipse . gmf . runtime . diagram . ui . preferences . DiagramsPreferencePage ; import org . msl . simple . gmfmap", "gt": ". simplemappings . diagram . part . SimplemapDiagramEditorPlugin ;", "prediction": ";\n", "label": 0}
{"id": 1133, "input": "<s> package org . gatein . common . util . typedmap ; import org . gatein . common . util . AbstractTypedMap ; import junit . framework . Assert ; import junit . framework . AssertionFailedError ; public class KeyConverter extends AbstractTypedMap . Converter < String , Long > { public static final String NULL = \"null\" ; public static final String UNCHECKED = \"unchecked\" ; public static final String IAE = \"iae\" ; public static final String CCE = \"cce\" ; protected Long getInternal ( String external ) throws IllegalArgumentException , ClassCastException { Assert . assertNotNull ( external ) ; if ( NULL . equals ( external ) ) { return null ; } if ( UNCHECKED . equals ( external ) ) { throw new CustomRuntimeException ( ) ; } if ( IAE . equals ( external ) ) { throw new IllegalArgumentException ( ) ; } if ( CCE . equals ( external ) ) { throw new ClassCastException ( ) ; } if ( \"zero\" . equals ( external ) ) { return ( long ) 0 ; } else if ( \"one\" . equals ( external ) ) { return ( long ) 1 ; } else if ( \"two\" . equals ( external ) ) { return ( long ) 2 ; } else if ( \"three\" . equals ( external ) ) { return ( long ) 3 ; } throw new AssertionFailedError ( ) ; } protected String getExternal ( Long internal ) { Assert . assertNotNull ( internal ) ; if ( NULL . equals ( internal ) ) { return null ; } if", "gt": "( UNCHECKED . equals ( internal ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 6160, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . ui . client . com . grid . column . gkButtonColumnConfig ; import org . gk . ui . client . com . toolbar . gkButton ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . button . ToggleButton ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class GButtonBuilder extends GridFieldBuilder { public GButtonBuilder ( String btn ) { super ( btn ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; final String confirm = x . getAttribute ( \"confirm\" , \"false\" ) ; final String icon = getField ( ) . getAttribute ( \"icon\" , \"icsc-edit\" ) ; final String toggle = getField ( ) . getAttribute ( \"toggle\" , \"false\" ) ; final String toggleGroup = getField ( ) . getAttribute ( \"toggleGroup\" , \"\" ) ; x . setCellEditor ( \"false\" ) ; gkButtonColumnConfig cc = new gkButtonColumnConfig ( x ) { @ Override public Button createButton ( ) { Button btn = null ; if ( Boolean . parseBoolean ( toggle ) ) { btn", "gt": "= new ToggleButton ( x . getLabel ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 1134, "input": "<s> package org . eclipse . swt . custom ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . * ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . * ; public class TreeEditor extends ControlEditor { Tree tree ; TreeItem item ; int column = 0 ; ControlListener columnListener ; TreeListener treeListener ; Runnable timer ; static final int TIMEOUT = 1500 ; public TreeEditor ( Tree tree ) { super ( tree ) ; this . tree = tree ; columnListener = new ControlListener ( ) { public void controlMoved ( ControlEvent e ) { layout ( ) ; } public void controlResized ( ControlEvent e ) { layout ( ) ; } } ; timer = new SerializableRunnable ( ) { public void run ( ) { layout ( ) ; } } ; treeListener = new TreeListener ( ) { final Runnable runnable = new SerializableRunnable ( ) { public void run ( ) { if ( editor == null || editor . isDisposed ( ) ) return ; if ( TreeEditor . this . tree . isDisposed ( ) ) return ; layout ( ) ; editor . setVisible ( true ) ; } } ; public void treeCollapsed ( TreeEvent e ) { if ( editor == null || editor . isDisposed ( ) ) return ; editor . setVisible ( false ) ; e . widget . getDisplay ( ) . asyncExec ( runnable ) ; } public void treeExpanded ( TreeEvent e ) { if ( editor == null || editor . isDisposed ( ) ) return ; editor . setVisible ( false ) ; e . widget . getDisplay ( ) . asyncExec ( runnable ) ; } } ; tree . addTreeListener ( treeListener ) ; grabVertical = true ; } Rectangle computeBounds ( ) { if ( item == null || column == - 1 || item . isDisposed ( ) ) return new Rectangle ( 0 , 0 , 0 , 0 ) ; Rectangle cell = item . getBounds ( column ) ; Rectangle rect = item . getImageBounds ( column ) ; if ( rect . width > 0 ) { cell . width -= rect . width + rect . x - cell . x ; cell . x = rect . x + rect . width ; } Rectangle area", "gt": "= tree . getClientArea ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5395, "input": "<s> package org . ofbiz . testtools ; import java . util . List ; import java . util . Map ; import junit . framework . AssertionFailedError ; import junit . framework . TestResult ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . testtools . OFBizTestCase ; import org . w3c . dom . Element ; public class ServiceTest extends OFBizTestCase { public static final String module = ServiceTest . class . getName ( ) ; protected String serviceName ; public ServiceTest ( String caseName , Element mainElement ) { super ( caseName ) ; this . serviceName = mainElement . getAttribute ( \"service-name\" ) ; } @ Override public int countTestCases ( ) { return 1 ; } @ Override public void run ( TestResult result ) { result . startTest ( this ) ; try { Map < String , Object > serviceResult = dispatcher . runSync ( serviceName , UtilMisc . toMap ( \"test\" , this , \"testResult\" , result ) ) ; String errorMessage = ( String ) serviceResult . get ( ModelService . ERROR_MESSAGE ) ; if ( UtilValidate . isNotEmpty ( errorMessage ) ) { result . addFailure ( this , new AssertionFailedError ( errorMessage ) ) ; } List < Object > errorMessageList = UtilGenerics . checkList ( serviceResult . get ( ModelService . ERROR_MESSAGE_LIST ) ) ; if ( UtilValidate", "gt": ". isNotEmpty ( errorMessageList ) )", "prediction": ";\n", "label": 0}
{"id": 1138, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . DateTime ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; class DateTimeTab extends ExampleTab { private static final String PROP_CONTEXT_MENU = \"contextMenu\" ; private static final String PROP_SELECTION_LISTENER = \"selectionListener\" ; DateTime dateTime1 ; Group group1 , group2 ; DateTimeTab ( ) { super ( \"DateTime\" ) ; setDefaultStyle ( SWT . BORDER | SWT . DATE | SWT . MEDIUM ) ; } @ Override protected void createStyleControls ( Composite parent ) { group1 = new Group ( styleComp , SWT . SHADOW_IN ) ; group1 . setText ( \"Type\" ) ; group1 . setLayout ( new RowLayout ( SWT . VERTICAL ) ) ; createStyleButton ( group1 , \"DATE\" , SWT . DATE , SWT . RADIO , true ) ; createStyleButton ( group1 , \"TIME\" , SWT . TIME , SWT . RADIO , false ) ; createStyleButton ( group1 , \"CALENDAR\" , SWT . CALENDAR , SWT . RADIO , false ) ; group2 = new Group ( styleComp , SWT . SHADOW_IN ) ; group2 . setText ( \"Details\" ) ; group2 . setLayout ( new RowLayout ( SWT . VERTICAL ) ) ; createStyleButton ( group2 , \"SHORT\" , SWT . SHORT , SWT . RADIO , false ) ; createStyleButton ( group2 , \"MEDIUM\" , SWT . MEDIUM , SWT . RADIO , true ) ; createStyleButton ( group2 , \"LONG\" , SWT . LONG , SWT . RADIO , false ) ; createStyleButton ( \"DROP_DOWN\" , SWT . DROP_DOWN , false ) ; createStyleButton ( \"BORDER\" , SWT . BORDER , true ) ; createVisibilityButton ( ) ; createEnablementButton ( ) ; createFontChooser ( ) ; createFgColorButton ( ) ; createBgColorButton ( ) ; createPropertyCheckbox ( \"Add Context Menu\" , PROP_CONTEXT_MENU ) ; createPropertyCheckbox ( \"Add Selection Listener\" , PROP_SELECTION_LISTENER ) ; } @ Override protected void createExampleControls ( Composite parent ) { parent . setLayout ( new RowLayout ( SWT . VERTICAL ) ) ; int style = getStyle ( ) | getStyle ( group1 ) | getStyle ( group2 ) ; dateTime1 = new DateTime ( parent , style ) ; if ( hasCreateProperty ( PROP_CONTEXT_MENU ) ) { Menu dateTimeMenu = new Menu ( dateTime1 ) ; MenuItem dateTimeMenuItem = new MenuItem ( dateTimeMenu , SWT . PUSH ) ; dateTimeMenuItem . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { String message = \"You requested a context menu for the DateTime\" ; MessageDialog . openInformation ( dateTime1 . getShell ( ) , \"Information\" , message ) ; } } ) ; dateTimeMenuItem", "gt": ". setText ( \"DateTime context menu item\" ) ;", "prediction": ";\n", "label": 1}
{"id": 7198, "input": "<s> package org . xbill . DNS ; public class PTRRecord extends SingleCompressedNameBase { private static final long serialVersionUID = - 8321636610425434192L ; PTRRecord ( ) { } Record getObject ( ) { return new PTRRecord ( ) ; } public PTRRecord ( Name name , int dclass , long ttl , Name target ) { super ( name , Type . PTR , dclass", "gt": ", ttl , target , \"target\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1148, "input": "<s> package org . eclipse . swt . internal . widgets ; import static org . mockito . Mockito . mock ; import java . io . IOException ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . rap . rwt . internal . lifecycle . * ; import org . eclipse . rap . rwt . internal . protocol . IClientObjectAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . * ; public class WidgetAdapter_Test extends TestCase { private Display display ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testGetAdapterForDisplay ( ) { Object adapter1 = display . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter1 instanceof IWidgetAdapter ) ; Object adapter2 = display . getAdapter ( IWidgetAdapter . class ) ; assertSame ( adapter1 , adapter2 ) ; display . dispose ( ) ; display = new Display ( ) ; Object adapter3 = display . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter3 != adapter2 ) ; } public void testGetAdapterForShell ( ) { Composite shell = new Shell ( display , SWT . NONE ) ; Object adapter1 = shell . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter1 instanceof IWidgetAdapter ) ; shell = new Shell ( display , SWT . NONE ) ; Object adapter2 = shell . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter1 != adapter2 ) ; } public void testGetAdapterForButton ( ) { Composite shell = new Shell ( display , SWT . NONE ) ; Button button1 = new Button ( shell , SWT . PUSH ) ; Object adapter1 = button1 . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter1 instanceof IWidgetAdapter ) ; Button button2 = new Button ( shell , SWT . PUSH ) ; Object adapter2 = button2 . getAdapter ( IWidgetAdapter . class ) ; assertTrue ( adapter1 != adapter2 ) ; } public void testId ( ) { IWidgetAdapter adapter1 = display . getAdapter ( IWidgetAdapter . class ) ; display . dispose ( ) ; display = new Display ( ) ; IWidgetAdapter adapter2 = display", "gt": ". getAdapter ( IWidgetAdapter . class ) ;", "prediction": ";\n", "label": 1}
{"id": 9140, "input": "<s> package com . gisgraphy . client . nameformatters ; import static com . gisgraphy . client . commons . NameProviderObjectMother . losAngelesNameProvider ; import org . junit . Assert ; import org . junit . Test ; public class FullyQualifiedNamesExtractorTest { @ Test public void shouldExtractAllNames ( ) { Assert . assertEquals ( \"[United States, California, Los Angeles county, Los Angeles]\" , new FullyQualifiedNamesExtractor ( ) . extractNames ( losAngelesNameProvider ( ) . getFullyQualifiedNameParts (", "gt": ") ) . toString ( ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 1151, "input": "<s> package org . eclipse . swt . internal . widgets . canvaskit ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . internal . graphics . GCOperation ; import org . eclipse . swt . internal . graphics . IGCAdapter ; import org . eclipse . swt . internal . graphics . ImageFactory ; import org . eclipse . swt . widgets . Canvas ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; public class GCOperationWriter_Test extends TestCase { private Display display ; private Canvas canvas ; private GC gc ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakeResponseWriter ( ) ; display = new Display ( ) ; Shell control = new Shell ( display ) ; canvas = new Canvas ( control , SWT . NONE ) ; gc = new GC ( canvas ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testSetLineWidth ( ) { gc . setLineWidth ( 13 ) ; JSONArray ops = getGCOperations ( canvas ) ; assertEquals ( \"\\\"lineWidth\\\",13\" , getOperation ( 0 , ops ) ) ; } public void testSetLineWidthZero ( ) { gc . setLineWidth ( 10 ) ; gc . setLineWidth ( 0 ) ; JSONArray ops = getGCOperations ( canvas ) ; assertEquals ( \"\\\"lineWidth\\\",10\" , getOperation ( 0 , ops ) ) ; assertEquals ( \"\\\"lineWidth\\\",1\" , getOperation ( 1 , ops ) ) ; } public void testForeground ( ) { gc . setForeground ( new Color ( display , 155 , 11 , 24 ) ) ; JSONArray ops = getGCOperations ( canvas ) ; assertEquals ( \"\\\"strokeStyle\\\",[155,11,24,255]\" , getOperation ( 0 , ops ) ) ; } public void testBackground ( ) { gc . setBackground ( new Color ( display , 155 , 11 , 24 ) ) ; JSONArray ops = getGCOperations ( canvas ) ; assertEquals", "gt": "( \"\\\"fillStyle\\\",[155,11,24,255]\" , getOperation ( 0 , ops ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8667, "input": "<s> package javax . lang . model . util ; import javax . lang . model . type . * ; import javax . annotation . processing . SupportedSourceVersion ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; @ SupportedSourceVersion ( RELEASE_7 ) public class SimpleTypeVisitor7 < R , P", "gt": "> extends SimpleTypeVisitor6 < R , P >", "prediction": ") ;\n", "label": 0}
{"id": 1156, "input": "<s> package org . jscsi", "gt": ". parser . asynchronous ;", "prediction": ";\n", "label": 1}
{"id": 390, "input": "<s> package org . ofbiz . entity ; @ SuppressWarnings ( \"serial\" ) public class GenericNoSuchEntityException extends GenericEntityException { public GenericNoSuchEntityException ( ) { super ( ) ; } public GenericNoSuchEntityException ( String str ) {", "gt": "super ( str ) ;", "prediction": "\n", "label": 0}
{"id": 1164, "input": "<s> package org . eclipse . jface . viewers ; public interface IIndexableLazyContentProvider extends ILazyContentProvider { public int findElement", "gt": "( Object element ) ;", "prediction": ";\n", "label": 1}
{"id": 1119, "input": "<s> package silent . unchecked ; class SilentUnchecked { void f ( Class c ) { g ( c ) ; }", "gt": "void g ( Class < ? > c )", "prediction": "}\n", "label": 0}
{"id": 1182, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . File ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . resources . ResourceDirectory ; public class ResourceDirectory_Test extends TestCase { private File tempDir ; private ResourceDirectory writer ; @ Override protected void setUp ( ) { tempDir = FileTestUtil . createTempDir ( ) ; writer = new ResourceDirectory ( ) ; } @ Override protected void tearDown ( ) { FileTestUtil . delete ( tempDir ) ; } public void testConfigurationSetsResourceDirectory ( ) { writer . configure ( tempDir . getAbsolutePath ( ) ) ; assertEquals ( tempDir , writer . getDirectory ( ) . getParentFile ( ) ) ; } public void testConfigurationDoesNotCreateResourceDirectory ( ) { writer . configure ( tempDir . getAbsolutePath ( ) ) ; assertFalse ( writer . getDirectory ( ) . exists ( ) ) ; } public void testConfigurationFailsWithNullParameter ( ) { try { writer . configure ( null ) ; } catch ( NullPointerException expected ) { } } public void testGetDirectoryFailsIfNotConfigured ( ) { try { writer . getDirectory ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testDirectoryCreated ( ) { writer . configure (", "gt": "tempDir . getAbsolutePath ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7359, "input": "<s> class BoundBug { class C { } class B < T extends C > { void foo ( ) { B < ? super T > con = null ; B < ? extends T > cov = null ; B < ? > biv = null ; B < T > inv = null ; } } static { B < ? super C > con = null ; B < ? extends C > cov = null ; B", "gt": "< ? > biv = null ;", "prediction": "}\n", "label": 0}
{"id": 1196, "input": "<s> package org . fuzzydb . server . internal . server ; import java . io . Serializable ; import java . util . concurrent . ConcurrentHashMap ; import org . fuzzydb . server . internal . common . InitializingBean ; public class Namespaces implements Serializable , InitializingBean { private static final long serialVersionUID = 1L ; private final ServerStore store ; private final ConcurrentHashMap < Integer , Namespace > tableIdToNamespace = new ConcurrentHashMap < Integer , Namespace > ( ) ; private final ConcurrentHashMap < String , Namespace > namespaces = new ConcurrentHashMap < String , Namespace > ( ) ; public Namespaces ( ServerStore store ) { this . store = store ; } public Namespace getNamespaceFromTableId ( int tableId ) { return tableIdToNamespace . get ( tableId ) ; } public Namespace getNamespace ( String name ) { return namespaces . get ( name ) ; } public Namespace createNamespace ( String name ) { Namespace namespace = new Namespace ( this , name ) ; namespaces . put ( name , namespace ) ; namespace . initialise ( ) ; return namespace ; } public int getNextTableId ( Namespace namespace ) { int tableId = store . nextTableId ( ) ; tableIdToNamespace . put ( tableId , namespace ) ; return tableId ; } public ServerStore getStore ( ) { return store ; } public synchronized void initialise ( ) { for ( Namespace namespace : namespaces . values ( ) ) { namespace . initialise ( ) ; } } public String getPath ( ) { return store . getPath ( ) ; } public int getStoreId ( ) { return store . getStoreId ( ) ; } public boolean deletePersistentData ( ) { boolean success = true ; for ( Namespace namespace : namespaces . values ( ) ) {", "gt": "success &= namespace . deletePersistentData ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7116, "input": "<s> package org . remast . util ; import org . apache . commons . lang . StringEscapeUtils ; public abstract class StringUtils { private StringUtils ( ) { } private static final String XML_TAG_PATTERN = \"<[^<>]+>\" ; public static String stripXmlTags ( final String xml ) { if ( org . apache . commons . lang . StringUtils . isBlank ( xml ) ) { return xml ; } String strippedXml = xml . replaceAll ( XML_TAG_PATTERN , org . apache . commons . lang . StringUtils . EMPTY ) ;", "gt": "strippedXml = StringEscapeUtils . unescapeXml ( strippedXml ) ;", "prediction": "}\n", "label": 0}
{"id": 1203, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec1 ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) {", "gt": "this . accountRef = accountRef ;", "prediction": "\n", "label": 1}
{"id": 5450, "input": "<s> package exceptions ; public class IntermediateException extends Exception { public IntermediateException ( String string ) { super ( string ) ; } private static final", "gt": "long serialVersionUID = 2424325131372839737L ;", "prediction": "( )\n", "label": 0}
{"id": 1217, "input": "<s> package org . eclipse . jface . viewers . deferred ; import java . io . Serializable ; import java . util . Iterator ; import java . util . LinkedList ; final class ChangeQueue implements Serializable { public static final int ADD = 0 ; public static final int REMOVE = 1 ; public static final int SET = 2 ; public static final int UPDATE = 3 ; public static final class Change { private int type ; private Object [ ] elements ; public Change ( int type , Object [ ] elements ) { this . type = type ; this . elements = elements ; } public int getType ( ) { return type ; } public Object [ ] getElements ( ) { return elements ; } } private LinkedList queue = new LinkedList ( ) ; public synchronized void enqueue ( int type , Object [ ] elements ) { enqueue ( new Change ( type , elements ) ) ; } public synchronized void enqueue ( Change toQueue ) { if ( toQueue . type == SET ) { LinkedList newQueue = new LinkedList ( ) ; for ( Iterator iter = queue . iterator ( ) ; iter . hasNext ( ) ; ) { Change next = ( Change ) iter . next ( ) ; if ( next . getType ( ) == ADD || next . getType ( ) == REMOVE || next . getType ( ) == SET ) { continue ; } newQueue . add ( next ) ; } queue = newQueue ; } queue . add ( toQueue ) ; } public synchronized Change dequeue ( ) { Change result = ( Change ) queue", "gt": ". removeFirst ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2635, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . entities . Entity ; import net . sf . jasperreports . charts . design . JRDesignPiePlot ; import net . sf . jasperreports . engine . JRChartPlot ; public class PiePlot extends AbstractPiePlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public void transform ( DynamicJasperDesign design , JRChartPlot", "gt": "plot , String name )", "prediction": ") ;\n", "label": 0}
{"id": 1218, "input": "<s> package org . eclipse . rap . rwt . apache . batik . util . io ; import java . io . IOException ; import java . io . InputStream ; @ SuppressWarnings ( \"all\" ) public class UTF8Decoder extends AbstractCharDecoder { protected final static byte [ ] UTF8_BYTES = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; protected int nextChar = - 1 ; public UTF8Decoder ( InputStream is ) { super ( is ) ; } public int readChar ( ) throws IOException { if ( nextChar != - 1 ) { int result = nextChar ; nextChar = - 1 ; return result ; } if ( position == count ) { fillBuffer ( ) ; } if ( count == - 1 ) { return END_OF_STREAM ; } int b1 = buffer [ position ++ ] & 0xff ; switch ( UTF8_BYTES [ b1 ] ) { default : charError ( \"UTF-8\" ) ; case 1 : return b1 ; case 2 : if ( position == count ) { fillBuffer ( ) ; } if ( count == - 1 ) { endOfStreamError ( \"UTF-8\" ) ; } return ( ( b1 & 0x1f ) << 6 ) | ( buffer [ position ++ ] & 0x3f ) ; case 3 : if ( position == count ) { fillBuffer ( ) ; } if ( count == - 1 ) { endOfStreamError ( \"UTF-8\" ) ; } int b2 = buffer [ position ++ ] ; if ( position == count ) { fillBuffer ( ) ; } if ( count == - 1 ) { endOfStreamError ( \"UTF-8\" ) ; } int b3 = buffer [ position ++ ] ; if ( ( b2 & 0xc0 )", "gt": "!= 0x80 || ( b3 & 0xc0 ) != 0x80 )", "prediction": "\n", "label": 1}
{"id": 9882, "input": "<s> interface I1 { int f ( ) ; } interface I2 { void f ( ) ; } interface", "gt": "InconsistentInheritedSignature extends I1 , I2", "prediction": "}\n", "label": 0}
{"id": 1240, "input": "<s> package tk . blackwolf12333 . grieflog . utils ; import java . util . List ; import tk . blackwolf12333 . grieflog . data . BaseData ; public class ResultPage { List < BaseData > page ; int pagenumber ; public ResultPage ( List < BaseData > list , int pagenumber ) { this . page = list ; this . pagenumber = pagenumber ; } public BaseData", "gt": "[ ] getPage ( )", "prediction": ";\n", "label": 1}
{"id": 8161, "input": "<s> public class NullQualifiedSuper2 { NullQualifiedSuper2 u = null ; class a { int a1 = 5 ; } class c extends a { c ( ) { u . super ( ) ; } }", "gt": "public static void main ( String [ ] args )", "prediction": "}\n", "label": 0}
{"id": 1245, "input": "<s> package org . jscsi . target . settings ; public final class TextKeyword { public static final String AUTH_METHOD = \"AuthMethod\" ; public static final String DATA_DIGEST = \"DataDigest\" ; public static final String DATA_PDU_IN_ORDER = \"DataPDUInOrder\" ; public static final String DATA_SEQUENCE_IN_ORDER = \"DataSequenceInOrder\" ; public static final String DEFAULT_TIME_2_RETAIN = \"DefaultTime2Retain\" ; public static final String DEFAULT_TIME_2_WAIT = \"DefaultTime2Wait\" ; public static final String ERROR_RECOVERY_LEVEL = \"ErrorRecoveryLevel\" ; public static final String FIRST_BURST_LENGTH = \"FirstBurstLength\" ; public static final String HEADER_DIGEST = \"HeaderDigest\" ; public static final String IF_MARKER = \"IFMarker\" ; public static final String IF_MARK_INT = \"IFMarkInt\" ; public static final String IMMEDIATE_DATA = \"ImmediateData\" ; public static final String INITIAL_R_2_T = \"InitialR2T\" ; public static final String INITIATOR_ALIAS = \"InitiatorAlias\" ; public static final String INITIATOR_NAME = \"InitiatorName\" ; public static final String MAX_BURST_LENGTH = \"MaxBurstLength\" ; public static final String MAX_CONNECTIONS = \"MaxConnections\" ; public static final String MAX_OUTSTANDING_R_2_T = \"MaxOutstandingR2T\" ; public static final String MAX_RECV_DATA_SEGMENT_LENGTH = \"MaxRecvDataSegmentLength\" ; public static final String OF_MARKER = \"OFMarker\" ; public static final String OF_MARK_INT = \"OFMarkInt\" ; public static final String SEND_TARGETS = \"SendTargets\" ; public static final String SESSION_TYPE = \"SessionType\" ; public", "gt": "static final String TARGET_ADDRESS = \"TargetAddress\" ;", "prediction": "void ( ) ;\n", "label": 1}
{"id": 6123, "input": "<s> package org . dawb . workbench . ui . perspective ; import org . eclipse . ui . IFolderLayout ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveFactory ; public class DataBrowsingPerspective implements IPerspectiveFactory { public static final String ID = \"org.edna.workbench.application.perspective.DataPerspective\" ; public void createInitialLayout ( IPageLayout layout ) { addFastViews ( layout ) ; addViewShortcuts ( layout ) ; addPerspectiveShortcuts ( layout ) ; String editorArea = layout . getEditorArea ( ) ; IFolderLayout navigatorFolder = layout . createFolder ( \"navigator-folder\" , IPageLayout . LEFT , 0.2f , editorArea ) ; navigatorFolder . addView ( \"org.eclipse.ui.navigator.ProjectExplorer\" ) ; navigatorFolder . addView ( \"uk.ac.diamond.sda.navigator.views.FileView\" ) ; { IFolderLayout folderLayout = layout . createFolder ( \"folder\" , IPageLayout . RIGHT , 0.6f , IPageLayout . ID_EDITOR_AREA ) ; folderLayout . addView ( \"org.dawb.workbench.views.dataSetView\" ) ; folderLayout", "gt": ". addView ( \"org.dawb.workbench.plotting.views.toolPageView.2D\" ) ;", "prediction": ";\n", "label": 0}
{"id": 1261, "input": "<s> package org . eclipse . jface . tests . viewers ; public interface ITestModelListener { public", "gt": "void testModelChanged ( TestModelChange change ) ;", "prediction": "\n", "label": 1}
{"id": 4567, "input": "<s> package org . hackreduce . examples . wikipedia ; import java . io . IOException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . util . ToolRunner ; import org . hackreduce . mappers . ModelMapper ; import org . hackreduce . mappers . WikipediaMapper ; import org . hackreduce . mappers . XMLInputFormat ; import org . hackreduce . mappers . XMLRecordReader ; import org . hackreduce . models . WikipediaRecord ; public class RecordCounter extends org . hackreduce . examples . RecordCounter { public enum Count { TOTAL_RECORDS , UNIQUE_KEYS } public static class RecordCounterMapper extends WikipediaMapper < Text , LongWritable > { public static final Text TOTAL_COUNT = new Text ( \"total\" ) ; public", "gt": "static final LongWritable ONE_COUNT = new LongWritable ( 1 ) ;", "prediction": "void ( ) ;\n", "label": 0}
{"id": 1262, "input": "<s> package org . fuzzydb . attrs . byteencoding ; import org . fuzzydb . attrs . internal . AttrDefinitionMgr ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . util . ByteArray ; public abstract class CompactAttrCodec { public enum AttrFunction { attribute , constraint } public static final int NOT_FOUND = - 1 ; protected static final int ATTR_ID_OFFSET = 0 ; protected static final int ATTR_ID_SIZE = 2 ; protected static final int PAYLOAD_OFFSET = ATTR_ID_OFFSET + ATTR_ID_SIZE ; private static final int LENGTH_OFFSET = PAYLOAD_OFFSET ; private static final int FUNCTION_MASK = 0x00008000 ; private static final int FN_ATTRIBUTE = 0x00008000 ; protected static final int FN_CONSTRAINT = 0x00000000 ; protected static final int INCL_NOT_SPECD_MASK = 0x00004000 ; protected static final int INCL_NOT_SPECD_YES = 0x00004000 ; protected static final int INCL_NOT_SPECD_NO = 0x00000000 ; abstract public IAttribute getDecoded ( ByteArray bytes , int index ) ; abstract public void encodeToByteArray ( ByteArray bytes , int attrId , Object value ) ; public static AttrFunction getAttrFunction ( int attrId ) { switch ( attrId & FUNCTION_MASK ) { case FN_ATTRIBUTE : return AttrFunction . attribute ; case FN_CONSTRAINT : return AttrFunction . constraint ; default : return null ; } } static public int getLength ( ByteArray bytes , int index , int headerWord ) { boolean isConstraint = CompactAttrCodec . getAttrFunction ( headerWord ) == AttrFunction . constraint ; switch ( AttrDefinitionMgr . getAttrType ( headerWord ) ) { case booleanValue : return isConstraint ? BooleanConstraintCodec . BOOLEAN_SIZE : BooleanCodec . BOOLEAN_SIZE ; case enumExclusiveValue : return isConstraint ? bytes . getByte ( index + LENGTH_OFFSET ) : EnumCodec . EXCLUSIVE_ENUM_SIZE ; case floatValue : return isConstraint ? bytes . getByte ( index + LENGTH_OFFSET ) : FloatCodec . FLOAT_SIZE ; case floatRangePrefValue : case enumMultiValue : default : int length = bytes . getByte ( index + LENGTH_OFFSET ) ; return length ; } } static public int getHeaderWord ( ByteArray bytes , int index ) { int header = bytes . getShort ( index + ATTR_ID_OFFSET ) ; return header ; } static public int getAttrId ( int headerWord ) { return AttrDefinitionMgr . getAttrIndexAndType ( headerWord ) ; } static public void setAttrId ( ByteArray bytes , int index , int attrId ) { assert ( attrId < 65536 ) ; bytes . putShort ( index + ATTR_ID_OFFSET , ( short ) ( attrId | FN_ATTRIBUTE ) ) ; } static public int findAttrInBuf ( ByteArray bytes , int attrId ) { int i = 0 ; while ( i < bytes . size ( ) ) { int headerWord = getHeaderWord (", "gt": "bytes , i ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6176, "input": "<s> package com . buycentives . jrelax ; import org . restlet . data . Status ; public class CouchDbException extends RuntimeException { private Status status ; public CouchDbException ( Status status ) { this . status = status ; } public CouchDbException ( String message , Status status ) { super ( message ) ;", "gt": "this . status = status ;", "prediction": "}\n", "label": 0}
{"id": 1265, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IPerspectiveListener ; import org . eclipse . ui . IPluginContribution ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . IIdentifier ; import org . eclipse . ui . activities . IIdentifierListener ; import org . eclipse . ui . activities . IWorkbenchActivitySupport ; import org . eclipse . ui . activities . IdentifierEvent ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . views . IViewDescriptor ; class LayoutHelper { private LayoutHelper ( ) { } public static final void addViewActivator ( PageLayout pageLayout , final String viewId ) { if ( viewId == null ) { return ; } ViewFactory viewFactory = pageLayout . getViewFactory ( ) ; final IWorkbenchPage partPage = viewFactory . getWorkbenchPage ( ) ; if ( partPage == null ) { return ; } final IPerspectiveDescriptor partPerspective = pageLayout . getDescriptor ( ) ; IWorkbenchActivitySupport support = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; IViewDescriptor descriptor = viewFactory . getViewRegistry ( ) . find ( viewId ) ; if ( ! ( descriptor instanceof IPluginContribution ) ) { return ; } IIdentifier identifier = support . getActivityManager ( ) . getIdentifier ( WorkbenchActivityHelper . createUnifiedId ( ( IPluginContribution ) descriptor ) ) ; identifier . addIdentifierListener ( new IIdentifierListener ( ) { public void identifierChanged ( IdentifierEvent identifierEvent ) { if ( identifierEvent . hasEnabledChanged ( ) ) { IIdentifier thisIdentifier = identifierEvent . getIdentifier ( ) ; if ( thisIdentifier . isEnabled ( ) ) {", "gt": "thisIdentifier . removeIdentifierListener ( this ) ;", "prediction": "}\n", "label": 1}
{"id": 9874, "input": "<s> package pkg1 ; import pkg2 . * ;", "gt": "public class C1 extends C2", "prediction": "}\n", "label": 0}
{"id": 1277, "input": "<s> package com . yahoo . platform . yui . compressor ; import java . io . * ; import java . util . List ; import org . mozilla . javascript . EvaluatorException ; public final class TestAdapter { public static List parseString ( String input ) throws EvaluatorException , IOException { Reader inputReader = new StringReader ( input ) ; TestErrorReporter reporter = new TestErrorReporter ( ) ; List tokens = JavaScriptCompressor . parse ( inputReader , reporter ) ; return tokens ; } public", "gt": "static String getLiteralString ( int type )", "prediction": "}\n", "label": 1}
{"id": 7488, "input": "<s> package org . parboiled ; import org . parboiled . parserunners . RecoveringParseRunner ; import org . testng . annotations . Test ; import static org . testng . Assert . assertFalse ; import static org . testng . Assert . assertTrue ; public class CurrentCharTest { public static class Parser extends BaseParser < Object > { public Rule Clause ( ) { return Sequence ( currentChar ( ) == 'a' , ANY , EOI ) ; } } @ Test public void test ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; assertFalse ( new RecoveringParseRunner ( parser . Clause ( ) )", "gt": ". run ( \"a\" ) . hasErrors ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 1283, "input": "<s> package org . ntu . rtsearch . crawler ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . json . JSONException ; import org . json . JSONObject ; import org . ntu . rtsearch . datacollected . Constants ; import org . ntu . rtsearch . datacollected . Resource ; import org . ntu . rtsearch . utils . CommonLogger ; import org . ntu . rtsearch . utils . EmailUtil ; import org . scribe . model . OAuthRequest ; import org . scribe . model . Response ; import org . scribe . model . Token ; import org . scribe . model . Verb ; import org . scribe . oauth . OAuthService ; public class UserInfoCrawler { private static final int BUFFER_SIZE = 2097152 ; private OAuthService service = Resource . getService ( ) ; private static List < String > userIdList = new ArrayList < String > ( ) ; static { try { BufferedReader br = new BufferedReader ( new FileReader ( Constants . USER_ID_FILE_PATH ) ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { userIdList . add ( line ) ; } br . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void findOmittedUserId ( ) { try { Set < String > userIdSet = new HashSet < String > ( ) ; BufferedReader br = new BufferedReader ( new FileReader ( Constants . USER_INFO_FILE_PATH ) , BUFFER_SIZE ) ; String line = null ; while ( ( line = br . readLine ( ) ) != null ) { JSONObject obj = new JSONObject ( line ) ; userIdSet . add ( obj . getString ( \"id\" ) ) ; } br . close ( ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( Constants . USERID_OMITTED ) , BUFFER_SIZE ) ; for ( String userId : userIdList ) { if ( ! userIdSet . contains ( userId ) ) bw . write ( userId ) ; } bw . flush ( ) ; bw . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } public void getUserInfo ( int offset , String postfix , int startIdx , int endIdx ) { CommonLogger . logger . info ( \"--------begin users' information collection--------\" ) ; OAuthRequest req = null ; BufferedWriter userInfoWriter = null , errorWriter = null ; String tName = Thread . currentThread ( ) . getName ( ) ; try { userInfoWriter = new BufferedWriter ( new FileWriter ( Constants . USER_INFO_FILE_PATH , true ) , 2097152 ) ; errorWriter = new BufferedWriter ( new FileWriter ( Constants . ERROR_WRITER , true ) ) ; Token token = Resource . getToken ( 0 ) ; String userId = null ; int cnt = 0 , tokenIdx = 0 ; for ( int i = startIdx ; i < endIdx ; i ++ ) { userId = userIdList . get ( i ) ; req = new OAuthRequest ( Verb . GET , Constants . USER_INFO_URL + userId ) ; service . signRequest ( token , req ) ; Response resp = req . send ( ) ; if ( resp . getCode ( ) == 200 ) { CommonLogger . logger . info ( tName + \" get info", "gt": "for useId: \" + userId ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6342, "input": "<s> package com . mapr . stats ; import org . apache . mahout . math . jet . random . AbstractContinousDistribution ; import org . apache . mahout . math . jet . random . Gamma ; import org . uncommons . maths . random . MersenneTwisterRNG ; import java . util . Random ; public class BetaDistribution extends AbstractContinousDistribution { private final Gamma gAlpha ; private final Gamma gBeta ; private double alpha , beta ; public BetaDistribution ( double alpha , double beta , Random random ) { this . alpha = alpha ; this . beta = beta ; gAlpha = new Gamma ( alpha , 1 , random ) ; gBeta = new Gamma ( beta , 1 , random ) ; } public BetaDistribution ( double alpha , double beta ) { this ( alpha , beta , new MersenneTwisterRNG ( ) ) ; } @ Override public double nextDouble ( ) { double x = gAlpha . nextDouble ( alpha , 1 ) ; double y = gBeta . nextDouble ( beta , 1 ) ; return x / ( x + y ) ; } public double nextDouble ( double alpha , double beta ) { double x = gAlpha . nextDouble ( alpha , 1 ) ; double y = gBeta . nextDouble ( beta , 1 ) ; return x / ( x + y ) ; } @ Override public double pdf ( double x ) { return Math . pow ( x , alpha - 1 ) * Math . pow ( 1 - x , beta - 1 ) / org . apache . mahout . math . jet . stat . Gamma . beta ( alpha , beta ) ; } public double logPdf ( double x ) { return x * ( alpha - 1 ) + ( 1 - x ) * ( beta - 1 ) - Math . log ( org . apache . mahout . math . jet . stat . Gamma . beta ( alpha , beta ) ) ; } @ Override public double cdf ( double x ) { return org . apache . mahout . math . jet . stat . Gamma . incompleteBeta ( alpha , beta , x ) ; } public void", "gt": "setAlpha ( double alpha )", "prediction": "( ) ;\n", "label": 0}
{"id": 1288, "input": "<s> package org . fuzzydb . client . internal ; import java . util . ArrayList ; import java . util . NoSuchElementException ; import org . fuzzydb . client . exceptions . NotImplementedException ; import org . fuzzydb . client . internal . comms . messages . QueryCmd ; import org . fuzzydb . client . internal . comms . messages . QueryFetchCmd ; import org . fuzzydb . client . internal . comms . messages . QueryRsp ; import org . fuzzydb . core . exceptions . ArchException ; import org . fuzzydb . core . query . ResultIterator ; import org . fuzzydb . expressions . LogicExpr ; import org . fuzzydb . io . core . messages . Command ; public class ResultIteratorImpl < E > implements ResultIterator < E > { private ArrayList < Object > results ; private boolean moreResults ; private boolean active = false ; private final ResultSetImpl < E > parent ; private final TransactionImpl transaction ; private final Class < E > clazz ; private final LogicExpr index ; private final LogicExpr expr ; private final int fetchSize ; private final String namespace ; private boolean disposed = false ; private int qid ; public ResultIteratorImpl ( ResultSetImpl < E > parent , TransactionImpl transaction , String namespace , Class < E > clazz , LogicExpr index , LogicExpr expr , int fetchSize ) { this . parent = parent ; this . transaction = transaction ; this . clazz = clazz ; this . index = index ; this . expr = expr ; this . namespace = namespace ; this . fetchSize = fetchSize ; } @ Override protected void finalize ( ) { dispose ( ) ; } private void activate ( ) { if ( active ) return ; StoreImpl store = transaction . getStore ( ) ; active = true ; int cid = store . getNextId ( ) ; qid = store . getNextId ( ) ; Command cmd = new QueryCmd ( store . getStoreId ( ) , namespace , cid , transaction . getTid ( ) , qid , clazz , index , expr , fetchSize ) ; QueryRsp rsp = ( QueryRsp ) transaction . execute ( cmd ) ; results", "gt": "= rsp . getResults ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8555, "input": "<s> class SunProprietary { sun .", "gt": "misc . Unsafe x ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1290, "input": "<s> package org . eclipse . jface . viewers ; import java . io . Serializable ; import java . util . ArrayList ; public abstract class ViewerFilter implements Serializable { protected ViewerFilter ( ) { } public Object [ ] filter ( Viewer viewer , Object parent , Object [ ] elements ) { int size = elements . length ; ArrayList out = new ArrayList ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { Object element = elements [ i ] ; if ( select ( viewer , parent , element ) ) { out . add ( element ) ; } } return out . toArray ( ) ; } public Object [ ] filter ( Viewer viewer , TreePath parentPath , Object [ ] elements ) { return filter ( viewer , parentPath . getLastSegment ( ) , elements ) ; } public boolean isFilterProperty", "gt": "( Object element , String property )", "prediction": "( )\n", "label": 1}
{"id": 1958, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface", "gt": "NumberFormat extends ProjectAttribute , ReportAttribute , NikuReportAttribute", "prediction": ";\n", "label": 0}
{"id": 1294, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Button ; public class ButtonSelectionProperty extends WidgetBooleanValueProperty { public ButtonSelectionProperty ( ) { super ( SWT . Selection ) ; } boolean doGetBooleanValue ( Object source ) { return ( ( Button )", "gt": "source ) . getSelection ( ) ;", "prediction": ";\n", "label": 1}
{"id": 500, "input": "<s> package org . ofbiz . common . login ; import java . util . Map ; import java . util . Properties ; import javax . naming . Context ; import javax . naming . NamingException ; import javax . naming . directory . DirContext ; import javax . naming . directory . InitialDirContext ; import javax . transaction . Transaction ; import org . ofbiz . base . crypto . HashCrypt ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . service . DispatchContext ; public class LdapAuthenticationServices { public static final String module = LdapAuthenticationServices . class . getName ( ) ; public static boolean userLogin ( DispatchContext ctx , Map < String , ? > context ) { Debug . logVerbose ( \"Starting LDAP authentication\" , module ) ; Properties env = UtilProperties . getProperties ( \"jndiLdap\" ) ; String username = ( String ) context . get ( \"login.username\" ) ; if ( username == null ) { username = ( String ) context . get ( \"username\" ) ; } String password = ( String ) context . get ( \"login.password\" ) ; if ( password == null ) { password = ( String ) context . get ( \"password\" ) ; } String dn = null ; Delegator delegator = ctx . getDelegator ( ) ; boolean isServiceAuth = context . get ( \"isServiceAuth\" ) != null && ( ( Boolean ) context . get ( \"isServiceAuth\" ) ) . booleanValue ( ) ; GenericValue userLogin = null ; try { userLogin = delegator . findOne ( \"UserLogin\" , isServiceAuth , \"userLoginId\" , username ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e , \"\" , module ) ; } if ( userLogin != null ) { dn = userLogin . getString ( \"userLdapDn\" ) ; } if ( UtilValidate . isEmpty ( dn ) ) { String dnTemplate = ( String ) env . get ( \"ldap.dn.template\" ) ; if ( dnTemplate != null ) { dn = dnTemplate . replace ( \"%u\" , username ) ; } Debug . logVerbose ( \"Using DN template: \" + dn , module ) ; } else { Debug . logVerbose ( \"Using UserLogin.userLdapDn: \" + dn , module ) ; } env . put ( Context . SECURITY_PRINCIPAL , dn ) ; env . put ( Context . SECURITY_CREDENTIALS , password ) ; try { DirContext ldapCtx = new InitialDirContext ( env ) ; ldapCtx . close ( ) ; } catch ( NamingException e ) { Debug . logVerbose ( \"LDAP authentication failed: \" + e . getMessage ( ) , module ) ; return false ; } Debug . logVerbose ( \"LDAP authentication succeeded\" , module ) ; if ( ! \"true\" . equals ( env .", "gt": "get ( \"ldap.synchronize.passwords\" ) ) )", "prediction": ") ;\n", "label": 0}
{"id": 1299, "input": "<s> package org . apache . lucene . store . instantiated ; import org . apache . lucene . document . Document ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public class InstantiatedDocument implements Serializable { private static long serialVersionUID = 1l ; private Document document ; public InstantiatedDocument ( ) { this . document = new Document ( ) ; } public InstantiatedDocument ( Document document ) { this . document = document ; } private Integer documentNumber ; private Map < String , List < InstantiatedTermDocumentInformation > > vectorSpace ; public Integer getDocumentNumber ( ) { return documentNumber ; } void setDocumentNumber ( Integer documentNumber ) { this . documentNumber = documentNumber ; } public Map < String , List < InstantiatedTermDocumentInformation > > getVectorSpace ( ) { return vectorSpace ; } public void setVectorSpace ( Map < String , List < InstantiatedTermDocumentInformation > > vectorSpace ) { this . vectorSpace = vectorSpace ; } public Document getDocument ( ) { return document ; } public String toString ( ) { return document", "gt": ". toString ( ) ;", "prediction": ";\n", "label": 1}
{"id": 10129, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Enderman ; public interface LizaEnderman extends Enderman { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities (", "gt": "double x , double y , double z ) ;", "prediction": ")\n", "label": 0}
{"id": 1300, "input": "<s> package org . fuzzydb . util ; import java . util . logging . Formatter ; import java . util . logging . LogRecord ; @ Deprecated public class LogFormatter extends Formatter { static private long startMillis ; public LogFormatter ( ) { super ( ) ; } @ Override public String format ( LogRecord record ) { final String newline = System . getProperty ( \"line.separator\" ) ; StringBuilder buf = new StringBuilder ( ) ; appendTime ( buf , record ) ; buf . append ( ' ' ) . append ( record . getLevel ( ) . toString ( ) ) ; buf . append ( ' ' ) . append ( record . getMessage ( ) ) . append ( newline ) ; return buf . toString ( ) ; } private void appendTime ( StringBuilder buf , LogRecord record ) { long millisNow = record . getMillis ( ) ; if ( startMillis == 0 ) { synchronized ( LogFormatter . class ) { if ( startMillis == 0 ) { startMillis = millisNow ; } } } long millis", "gt": "= millisNow - startMillis ;", "prediction": ";\n", "label": 1}
{"id": 8470, "input": "<s> package org . remast . swing . util ; public class LabeledItem < E extends Comparable < E > > implements Comparable < LabeledItem < E > > { private final E item ; private String label ; public LabeledItem ( final E item ) { if ( item == null ) { throw new IllegalArgumentException ( \"Item may not be null.\" ) ; } this . item = item ; } public LabeledItem ( final E item , final String label ) { if ( item == null || label == null ) { throw new IllegalArgumentException ( \"Neither item nor label may be null.\" ) ; } this . item = item ; this . label = label ; } public E getItem ( ) { return item ; } public String getLabel ( ) { return label ; } @ Override public String toString ( ) { if ( label != null ) { return label ; } return String . valueOf ( this . item ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public boolean equals ( final Object obj ) { if ( obj == null || ! ( obj instanceof LabeledItem ) ) { return false ; } @ SuppressWarnings ( \"unchecked\" ) final LabeledItem < E > that = ( LabeledItem", "gt": "< E > ) obj ;", "prediction": ") ;\n", "label": 0}
{"id": 1304, "input": "<s> package org . fuzzydb . expressions ; import org . fuzzydb . core . exceptions . ArchException ; public class MultExpr extends BinaryExpr { private static final long serialVersionUID = 3257564018674710840L ; public MultExpr ( ComparableExpr < Scalar > left , ComparableExpr < Scalar > right ) { super ( left , right ) ; } @ Override public Scalar evaluate ( ExprContext context ) { Scalar l = left . evaluate ( context ) ; Scalar r = right . evaluate ( context ) ; return", "gt": "l . mult ( r ) ;", "prediction": ";\n", "label": 1}
{"id": 38, "input": "<s> class NonStaticFieldExpr1 { public int x ; int y", "gt": "= NonStaticFieldExpr1 . x ;", "prediction": ";\n", "label": 0}
{"id": 1324, "input": "<s> package org . seage . problem . sat . antcolony2 ; import org . seage . problem . sat . antcolony . * ; import org . seage . metaheuristic . antcolony . AntColony ; import org . seage . problem . sat . Formula ; import org . seage . problem . sat . FormulaReader ; public class SatAntColonyTest2 { public static void main ( String [ ] args ) throws Exception { String path = \"data/uf20/my.cnf\" ; Formula formula = FormulaReader . readFormula ( path ) ; double qantumPheromone = 0.01 , evaporation = 0.05 , defaultPheromone = 1 ; SatGraph2 graph = new SatGraph2 ( formula , evaporation , defaultPheromone ) ; System . out . println ( \"formula literals: \" + formula . getLiteralCount ( ) ) ; System . out . println ( \"graph nodes: \" + graph . getNodeList ( )", "gt": ". size ( ) ) ;", "prediction": ";\n", "label": 1}
{"id": 6774, "input": "<s> package opens . components . cache ; import opens . components . cache . serializers . CacheSerializer ; public abstract class Cache { public abstract Object get ( String key , CacheSerializer serializer ) ; public abstract void put ( String key , Object value , CacheSerializer serializer ) ; public", "gt": "abstract void remove ( String key ) ;", "prediction": "\n", "label": 0}
{"id": 1344, "input": "<s> package org . nuxeo . ecm . platform . syndication . serializer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import net . sf . json . JSON ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import net . sf . json . JSONSerializer ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . platform . syndication . translate . TranslationHelper ; import org . restlet . data . MediaType ; import org . restlet . data . Response ; public class DMJSONSerializer extends AbstractDocumentModelSerializer { @ Override public String serialize ( ResultSummary summary , DocumentModelList docList , List < String > columnsDefinition , HttpServletRequest req ) throws ClientException { return serialize ( summary , docList , columnsDefinition , req , null , null ) ; } public String serialize ( ResultSummary summary , DocumentModelList docList , List < String > columnsDefinition , HttpServletRequest req , List < String > labels , String lang ) throws ClientException { if ( docList == null ) { return EMPTY_LIST ; } Map < String , Object > all = new HashMap < String , Object > ( ) ; all . put ( \"summary\" , summary ) ; List < Map < String , String > > struct = new ArrayList < Map < String , String > > ( ) ; for ( DocumentModel doc : docList ) { Map < String , String > resDoc = new HashMap < String , String > ( ) ; resDoc . put ( \"id\" , doc . getId ( ) ) ; for ( String colDef : columnsDefinition ) { ResultField res = getDocumentProperty ( doc , colDef ) ; resDoc . put ( res . getName ( ) , res . getValue ( ) ) ; } struct . add ( resDoc ) ; } all . put ( \"data\" , struct ) ; if ( lang != null && labels != null ) { Map < String , String > translations = new HashMap < String , String > ( ) ; for ( String key : labels ) { translations . put ( key , TranslationHelper . getLabel ( key , lang ) ) ; } all . put ( \"translations\" , translations ) ; } return makeJSON ( all ) ; } protected static String makeJSON ( Map < String , Object > all ) { JSON jsonRes = JSONSerializer . toJSON ( all ) ; if ( jsonRes instanceof JSONObject ) { JSONObject jsonOb = ( JSONObject ) jsonRes ; return jsonOb . toString ( 2 ) ; } else if ( jsonRes instanceof JSONArray ) { JSONArray jsonOb = ( JSONArray ) jsonRes ; return jsonOb . toString ( 2 ) ; } else { return null ; } } @ Override public void serialize ( ResultSummary summary , DocumentModelList docList , String columnsDefinition , Response res , HttpServletRequest req ) throws ClientException { String json = serialize ( summary , docList , columnsDefinition , req ) ; res . setEntity ( json , MediaType . TEXT_PLAIN ) ; } @ Override public void serialize ( ResultSummary summary , DocumentModelList docList , String columnsDefinition , Response res , HttpServletRequest req , List < String > labels , String lang ) throws ClientException { List < String > cols = new ArrayList < String > ( ) ; if ( columnsDefinition != null ) { cols = Arrays . asList ( columnsDefinition . split ( colDefinitonDelimiter ) ) ; } String json = serialize ( summary , docList , cols , req", "gt": ", labels , lang ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7964, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . field . XField ; import com . extjs . gxt . ui . client . widget . grid . HeaderGroupConfig ; public class GHeaderGroupBuilder extends GridFieldBuilder { public GHeaderGroupBuilder ( String fieldType ) { super ( fieldType ) ; } @ Override public Object create ( ) { XField x = getField ( ) . clone ( ) ; String label = x . getLabel ( ) ; String row = x . getAttribute ( \"row\" , \"0\" ) ; String col = x . getAttribute ( \"col\" , \"0\" ) ; String colSpan = x . getAttribute ( \"colSpan\" , \"0\" ) ; String rowSpan = x . getAttribute (", "gt": "\"rowSpan\" , \"0\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1374, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . xtext . xdoc . xdoc . Section ; import org . eclipse . xtext . xdoc . xdoc . SectionRef ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class SectionRefImpl extends SectionImpl implements SectionRef { protected Section section ; protected SectionRefImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return XdocPackage . Literals . SECTION_REF ; } public Section getSection ( ) { if ( section != null && section . eIsProxy ( ) ) { InternalEObject oldSection = ( InternalEObject ) section ; section = ( Section ) eResolveProxy ( oldSection ) ; if ( section != oldSection ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , XdocPackage . SECTION_REF__SECTION , oldSection , section ) ) ; } } return section ; } public Section basicGetSection ( ) { return section ; } public void setSection ( Section newSection ) { Section oldSection = section ; section = newSection ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , XdocPackage . SECTION_REF__SECTION , oldSection , section ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case XdocPackage . SECTION_REF__SECTION : if ( resolve ) return getSection ( ) ; return basicGetSection ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case XdocPackage . SECTION_REF__SECTION : setSection ( ( Section ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case XdocPackage . SECTION_REF__SECTION :", "gt": "setSection ( ( Section ) null ) ;", "prediction": ";\n", "label": 1}
{"id": 3355, "input": "<s> package org . parboiled . matchers ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; import org . parboiled . trees . GraphNode ; public interface Matcher extends Rule , GraphNode < Matcher > { String getLabel ( ) ; boolean hasCustomLabel ( ) ; boolean isNodeSuppressed ( ) ; boolean areSubnodesSuppressed ( ) ; boolean isNodeSkipped ( ) ; boolean areMismatchesMemoed ( ) ; MatcherContext getSubContext ( MatcherContext context ) ; < V > boolean match ( MatcherContext < V > context ) ; void setTag ( Object tagObject ) ; Object getTag ( ) ; < R > R accept (", "gt": "MatcherVisitor < R > visitor ) ;", "prediction": ")\n", "label": 0}
{"id": 1375, "input": "<s> package org . eclipse . ui . internal . activities ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . eclipse . ui . activities . IIdentifier ; import org . eclipse . ui . activities . IIdentifierListener ; import org . eclipse . ui . activities . IdentifierEvent ; import org . eclipse . ui . internal . util . Util ; final class Identifier implements IIdentifier { private final static int HASH_FACTOR = 89 ; private final static int HASH_INITIAL = Identifier . class . getName ( ) . hashCode ( ) ; private final static Set strongReferences = new HashSet ( ) ; private Set activityIds = Collections . EMPTY_SET ; private transient String [ ] activityIdsAsArray = { } ; private boolean enabled ; private transient int hashCode = HASH_INITIAL ; private String id ; private List identifierListeners ; private transient String string ; Identifier ( String id ) { if ( id == null ) { throw new NullPointerException ( ) ; } this . id = id ; } public void addIdentifierListener ( IIdentifierListener identifierListener ) { if ( identifierListener == null ) { throw new NullPointerException ( ) ; } if ( identifierListeners == null ) { identifierListeners = new ArrayList ( ) ; } if ( ! identifierListeners . contains ( identifierListener ) ) { identifierListeners . add ( identifierListener ) ; } strongReferences . add ( this ) ; } public int compareTo ( Object object ) { Identifier castedObject = ( Identifier ) object ; int compareTo = Util . compare ( activityIdsAsArray , castedObject . activityIdsAsArray ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( enabled , castedObject . enabled ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( id , castedObject . id ) ; } } return compareTo ; } public boolean equals ( Object object ) { if ( ! ( object instanceof Identifier ) ) { return false ; } final Identifier castedObject = ( Identifier ) object ; if ( ! Util . equals ( activityIds , castedObject . activityIds ) ) { return false ; } if ( ! Util . equals ( enabled , castedObject . enabled ) ) { return false ; } return Util . equals ( id , castedObject . id ) ; } void fireIdentifierChanged ( IdentifierEvent identifierEvent ) { if ( identifierEvent == null ) { throw new NullPointerException ( ) ; } if ( identifierListeners != null ) { for ( int i = 0 ; i < identifierListeners . size ( ) ; i ++ ) { ( ( IIdentifierListener ) identifierListeners . get ( i ) ) . identifierChanged ( identifierEvent ) ; } } } public Set getActivityIds ( ) { return activityIds ; } public String getId ( ) { return id ; } public int hashCode ( ) { if ( hashCode == HASH_INITIAL ) { hashCode = hashCode * HASH_FACTOR + Util . hashCode ( activityIds ) ; hashCode = hashCode * HASH_FACTOR + Util . hashCode ( enabled ) ; hashCode = hashCode * HASH_FACTOR", "gt": "+ Util . hashCode ( id ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3115, "input": "<s> package jns . trace ; import jns . Simulator ; import jns . element . * ; import jns . element . Element ; import jns . element . Link ; import jns . element . Node ; import jns . util . Preferences ; import java . io . BufferedWriter ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . zip . GZIPOutputStream ; public class JavisTrace extends Trace { private Hashtable m_handlers ; private BufferedWriter m_writer ; public JavisTrace ( String filename ) throws IOException { super ( ) ; m_handlers = new Hashtable ( ) ; registerHandler ( \"LinkEvent\" , new JavisLinkHandler ( ) ) ; registerHandler ( \"HopEvent\" , new JavisPacketHandler ( ) ) ; registerHandler ( \"ReceiveEvent\" , new JavisPacketHandler ( ) ) ; registerHandler ( \"EnqueueEvent\" , new JavisPacketHandler ( ) ) ; registerHandler ( \"DequeueEvent\" , new JavisPacketHandler ( ) ) ; registerHandler ( \"LinkDropEvent\" , new JavisPacketHandler ( ) ) ; registerHandler ( \"QueueDropEvent\" , new JavisPacketHandler ( ) ) ; if ( filename . endsWith ( \".gz\" ) ) m_writer = new BufferedWriter ( new OutputStreamWriter ( new GZIPOutputStream ( new FileOutputStream ( filename ) ) ) ) ; else m_writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( filename ) ) ) ; } public void writePreamble ( ) throws IOException { m_writer . write ( \"# Trace file generated by JNS Version \" + Preferences . VERSION + \".\" ) ; m_writer . newLine ( ) ; Enumeration e = Simulator . getInstance ( ) . enumerateElements ( ) ; while ( e . hasMoreElements ( ) ) { Element curelement = ( Element ) e . nextElement ( ) ; if ( curelement instanceof Node ) { Node node = ( Node ) curelement ; m_writer . write ( \"n -t * \" ) ; m_writer . write ( \"-a \" + node . getNumber ( ) + \" \" ) ; m_writer . write ( \"-s \" + node . getNumber ( ) + \" \" ) ; m_writer . write ( \"-S UP -v circle -c black\" ) ; m_writer . newLine ( ) ; } else if ( curelement instanceof Link ) { Link link = ( Link ) curelement ; m_writer . write ( \"l -t * \" ) ; m_writer . write ( \"-s \" + link . getOutgoingInterface ( ) . getNode ( ) . getNumber ( ) + \" \" ) ; m_writer . write ( \"-d \" + link . getIncomingInterface ( ) . getNode ( ) . getNumber ( ) + \" \" ) ; m_writer . write ( \"-S UP \" ) ; m_writer . write ( \"-r \" + link . getBandwidth", "gt": "( ) + \" \" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1411, "input": "<s> package org . restlet . ext . rdf ; import org . restlet . engine . util . SystemUtils ; public class Couple < T , U > { private volatile T first ; private volatile U second ; public Couple ( T first , U second ) { this . first = first ; this . second = second ; } @ Override public boolean equals ( Object other ) { boolean result = ( this == other ) ; if ( ! result && ( other instanceof Couple ) ) { Couple < ? , ? > couple = ( Couple < ? , ? > ) other ; if ( ( ( couple . getFirst ( ) == null ) && ( getFirst ( ) == null ) ) || ( ( getFirst ( ) != null ) && getFirst ( ) . equals ( couple . getFirst ( ) ) ) ) { result = ( ( ( couple . getSecond ( ) == null ) && ( getSecond ( ) == null ) ) || ( ( getSecond ( ) != null ) && getSecond ( ) . equals ( couple . getSecond ( ) ) ) ) ; } } return result ; } public T getFirst ( ) { return first ; } public U getSecond ( ) { return second ; } @ Override public int hashCode ( ) { return SystemUtils . hashCode", "gt": "( getFirst ( ) , getSecond ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1235, "input": "<s> package domain ; import java . io . Serializable ; import javax . persistence . * ; import java . util . Date ; @ Entity @ Table ( name = \"exam_result\" ) public class ExamResult implements Serializable { private static final long serialVersionUID = 1L ; @ Id @ SequenceGenerator ( name = \"EXAM_RESULT_ID_GENERATOR\" , sequenceName = \"EXAM_RESULT_ID_SEQ\" ) @ GeneratedValue ( strategy = GenerationType . SEQUENCE , generator = \"EXAM_RESULT_ID_GENERATOR\" ) private Integer id ; private Boolean passed ; @ Column ( name = \"points_natural\" ) private Integer pointsNatural ; @ Column ( name = \"points_real\" ) private double pointsReal ; @ Column ( name = \"result_type\" ) private ResultType resultType ; @ Temporal ( TemporalType . DATE ) @ Column ( name = \"time_set\" ) private Date timeSet ; @ ManyToOne private Exam exam ; @ ManyToOne private Student student ; public ExamResult ( ) { } public Integer getId ( ) { return this . id ; } public void setId ( Integer id ) { this . id = id ; } public Boolean getPassed ( ) { return this . passed ; } public void setPassed ( Boolean passed ) { this . passed = passed ; } public Integer getPointsNatural ( ) { return this . pointsNatural ; } public void setPointsNatural ( Integer pointsNatural ) { this . pointsNatural = pointsNatural ; } public double getPointsReal ( ) { return this . pointsReal ; } public void setPointsReal ( double pointsReal ) { this . pointsReal = pointsReal ; } public ResultType getResultType ( ) { return this . resultType ; } public void setResultType ( ResultType resultType ) { this . resultType = resultType ; } public Date getTimeSet ( ) { return this . timeSet ; } public void", "gt": "setTimeSet ( Date timeSet )", "prediction": "( ) ;\n", "label": 0}
{"id": 1412, "input": "<s> package com . emf4sw . rdf . impl ; import org . eclipse . emf . ecore . EClass ; import com . emf4sw . rdf . Datatype ; import com . emf4sw . rdf . RDFPackage ; public class DatatypeImpl extends ResourceImpl implements Datatype { protected DatatypeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) {", "gt": "return RDFPackage . Literals . DATATYPE ;", "prediction": "\n", "label": 1}
{"id": 4375, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Shifts ; import org . jjflyboy . tjpeditor . project . ShiftsLimit ; public class ShiftsImpl extends ShiftsResourceImpl implements Shifts { protected EList < ShiftsLimit > limits ; protected ShiftsImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getShifts ( ) ; } public EList < ShiftsLimit > getLimits ( ) { if ( limits == null ) { limits = new EObjectContainmentEList < ShiftsLimit > ( ShiftsLimit . class , this , ProjectPackage . SHIFTS__LIMITS ) ; } return limits ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . SHIFTS__LIMITS : return ( ( InternalEList < ? > ) getLimits ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet (", "gt": "int featureID , boolean resolve , boolean coreType )", "prediction": ")\n", "label": 0}
{"id": 1425, "input": "<s> package org . eclipse . ui ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . swt . graphics . Image ; public interface IWorkbenchPartReference { public IWorkbenchPart getPart ( boolean restore ) ; public String getTitle ( ) ; public Image getTitleImage ( ) ; public String getTitleToolTip ( ) ; public String getId ( ) ; public void addPropertyListener ( IPropertyListener listener ) ; public void removePropertyListener ( IPropertyListener listener ) ; public IWorkbenchPage getPage ( ) ; public String getPartName ( ) ; public String getContentDescription ( ) ; public boolean isDirty ( ) ; public String getPartProperty ( String key ) ; public", "gt": "void addPartPropertyListener ( IPropertyChangeListener listener ) ;", "prediction": "\n", "label": 1}
{"id": 121, "input": "<s> package org . dawb . workbench . plotting . system . swtxy ; import java . util . List ; import java . util . Map ; import org . csstudio . swt . xygraph . figures . XYGraph ; import org . csstudio . swt . xygraph . undo . XYGraphConfigCommand ; import org . csstudio . swt . xygraph . undo . XYGraphMemento ; import org . dawb . workbench . plotting . system . swtxy . selection . AbstractSelectionRegion ; public class XYRegionConfigCommand extends XYGraphConfigCommand { public XYRegionConfigCommand ( XYGraph xyGraph ) { super ( xyGraph ) ; previousXYGraphMem = new XYRegionMemento ( ) ; afterXYGraphMem = new XYRegionMemento ( ) ; createDefaultSettings ( ) ; final Map < String , AbstractSelectionRegion > regionList = ( ( RegionArea ) xyGraph . getPlotArea ( ) ) . getRegionMap ( ) ; for ( String name : regionList . keySet ( ) ) { ( ( XYRegionMemento ) previousXYGraphMem ) . addRegionMemento ( new RegionBean ( ) ) ; ( ( XYRegionMemento ) afterXYGraphMem ) . addRegionMemento ( new RegionBean ( ) ) ; } } protected void saveXYGraphPropsToMemento ( XYGraph xyGraph , XYGraphMemento memento ) { super . saveXYGraphPropsToMemento ( xyGraph , memento ) ; int i = 0 ; final List < AbstractSelectionRegion > regionList = ( ( RegionArea ) xyGraph . getPlotArea ( ) ) . getRegions ( ) ; final List < RegionBean > regionBeanList = ( ( XYRegionMemento ) memento ) . getRegionBeanList ( ) ; for ( AbstractSelectionRegion region : regionList ) { saveRegionPropsToMemento ( region , regionBeanList . get ( i ) ) ; ++ i ; } } protected void restoreXYGraphPropsFromMemento ( XYGraph xyGraph , XYGraphMemento memento ) { super . restoreXYGraphPropsFromMemento ( xyGraph , memento ) ; int i = 0 ; for ( RegionBean rb : ( ( XYRegionMemento ) memento ) . getRegionBeanList ( ) ) { restoreRegionPropsFromMemento ( ( ( RegionArea ) xyGraph . getPlotArea ( ) ) . getRegions ( ) . get (", "gt": "i ) , rb ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1427, "input": "<s> package org . eclipse . xtext . xdoc . generator ; import com . google . common . base . Objects ; import com . google . inject . Inject ; import java . io . File ; import java . util . Arrays ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . xtend2 . lib . StringConcatenation ; import org . eclipse . xtext . generator . IFileSystemAccess ; import org . eclipse . xtext . xdoc . generator . Outlets ; import org . eclipse . xtext . xdoc . generator . PlainText ; import org . eclipse . xtext . xdoc . generator . util . EclipseNamingExtensions ; import org . eclipse . xtext . xdoc . xdoc . AbstractSection ; import org . eclipse . xtext . xdoc . xdoc . Document ; import org . eclipse . xtext . xdoc . xdoc . Section ; import org . eclipse . xtext . xdoc . xdoc . TextOrMarkup ; @ SuppressWarnings ( \"all\" ) public class PHPPhoenixGenerator { @ Inject private EclipseNamingExtensions ene ; @ Inject private PlainText pt ; protected void _generatePHP ( final AbstractSection as , final IFileSystemAccess fsa ) { Resource _eResource = as . eResource ( ) ; URI _uRI = _eResource . getURI ( ) ; URI _trimFileExtension = _uRI . trimFileExtension ( ) ; String _lastSegment = _trimFileExtension . lastSegment ( ) ; String _plus = ( _lastSegment + \".php\" ) ; StringConcatenation _builder = new StringConcatenation ( ) ; _builder . append ( \"<?php require_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/app.class.php\\\");\\trequire_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/nav.class.php\\\"); \\trequire_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/menu.class.php\\\"); \\t$App \\t= new App();\\t$Nav\\t= new Nav();\\t$Menu \\t= new Menu();\\t\\tinclude($App->getProjectCommon());    # All on the same line to unclutter the user\\'s desktop\\'\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"include(\\\"include.php\\\");\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"$pageTitle \\t\\t= \\\"\" ) ; TextOrMarkup _title = as . getTitle ( ) ; CharSequence _genPlainText = this . pt . genPlainText ( _title ) ; _builder . append ( _genPlainText , \"\t\" ) ; _builder . append ( \"\\\";\" ) ; _builder . newLineIfNotEmpty ( ) ; _builder . append ( \"\\t\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"$html = file_get_contents(\\'\" ) ; String _resourceURL = this . ene . getResourceURL ( as ) ; _builder . append ( _resourceURL , \"\t\" ) ; _builder . append ( \"\\');\" ) ; _builder . newLineIfNotEmpty ( ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"$Nav->setLinkList(array());\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; CharSequence _genScriptsAndStyles = this . genScriptsAndStyles ( as ) ; _builder . append ( _genScriptsAndStyles , \"\t\" ) ; _builder . newLineIfNotEmpty ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"# Generate the web page\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"$App->generatePage(\\\"Nova\\\", $Menu, NULL, $pageAuthor, $pageKeywords, $pageTitle, $html);\" ) ; _builder . newLine ( ) ; _builder . append ( \"?>\" ) ; _builder . newLine ( ) ; fsa . generateFile ( _plus , Outlets . WEB_SITE , _builder ) ; } protected void _generatePHP ( final Document doc , final IFileSystemAccess fsa ) { StringConcatenation _builder = new StringConcatenation ( ) ; _builder . append ( \"<?php require_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/app.class.php\\\");\\trequire_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/nav.class.php\\\"); \\trequire_once($_SERVER[\\'DOCUMENT_ROOT\\'] . \\\"/eclipse.org-common/system/menu.class.php\\\"); \\t$App \\t= new App();\\t$Nav\\t= new Nav();\\t$Menu \\t= new Menu();\\t\\tinclude($App->getProjectCommon());    # All on the same line to unclutter the user\\'s desktop\\'\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"include(\\\"include.php\\\");\" ) ; _builder . newLine ( ) ; _builder . append ( \"\\t\" ) ; CharSequence _genScriptsAndStyles = this . genScriptsAndStyles ( doc ) ; _builder . append ( _genScriptsAndStyles , \"\t\" ) ; _builder . newLineIfNotEmpty ( ) ; _builder . append ( \"\\t\" ) ; _builder . append ( \"$pageTitle \\t\\t= \\\"\" ) ; TextOrMarkup _title = doc . getTitle ( ) ; CharSequence _genPlainText = this . pt . genPlainText ( _title ) ; _builder . append ( _genPlainText , \"\t\" ) ;", "gt": "_builder . append ( \"\\\";\" ) ;", "prediction": "}\n", "label": 1}
{"id": 1934, "input": "<s> package org . ofbiz . widget ; import java . io . Serializable ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . TimeZone ; import java . util . regex . PatternSyntaxException ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . w3c . dom . Element ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . ScriptUtil ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . collections . ResourceBundleMapWrapper ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . finder . ByAndFinder ; import org . ofbiz . entity . finder . ByConditionFinder ; import org . ofbiz . entity . finder . EntityFinderUtil ; import org . ofbiz . entity . finder . PrimaryKeyFinder ; import org . ofbiz . entity . util . EntityUtilProperties ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; @ SuppressWarnings ( \"serial\" ) public abstract class ModelWidgetAction implements Serializable { public static final String module = ModelWidgetAction . class . getName ( ) ; protected ModelWidget modelWidget ; protected ModelWidgetAction ( ) { } public ModelWidgetAction ( ModelWidget modelWidget , Element actionElement ) { this . modelWidget = modelWidget ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Reading widget action with name: \" + actionElement . getNodeName ( ) , module ) ; } public abstract void runAction ( Map < String , Object > context ) throws GeneralException ; public static List < ModelWidgetAction > readSubActions ( ModelWidget modelWidget , Element parentElement ) { List < ? extends Element > actionElementList = UtilXml . childElementList ( parentElement ) ; List < ModelWidgetAction > actions = new ArrayList < ModelWidgetAction > ( actionElementList . size ( ) ) ; for ( Element actionElement : actionElementList ) { if ( \"set\" . equals ( actionElement . getNodeName ( ) ) ) { actions . add ( new SetField ( modelWidget , actionElement ) ) ; } else if ( \"property-map\" . equals ( actionElement . getNodeName ( ) ) ) { actions . add ( new PropertyMap ( modelWidget , actionElement ) ) ; } else if ( \"property-to-field\" . equals ( actionElement . getNodeName ( ) ) ) { actions . add ( new PropertyToField ( modelWidget , actionElement ) ) ; } else if ( \"script\" . equals ( actionElement . getNodeName ( ) ) ) { actions . add ( new Script ( modelWidget , actionElement ) ) ; } else if ( \"service\" . equals ( actionElement . getNodeName ( ) ) ) { actions . add", "gt": "( new Service ( modelWidget , actionElement ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1438, "input": "<s> import java . util . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; ArrayList < ArrayList < String > > lines = new ArrayList < ArrayList < String > > ( ) ; while ( in . hasNextLine ( ) ) { String line = in . nextLine ( ) ; lines . add ( Parse ( line ) ) ; } ArrayList < String > formatted = Format ( lines ) ; for ( String s : formatted ) { System . out . println ( s ) ; } } static ArrayList < String > Parse ( String s ) { int idx = 0 ; int startIdx = 0 ; boolean isWord = false ; ArrayList < String > words = new ArrayList < String > ( ) ; for ( idx = 0 ; idx < s . length ( ) ; ++ idx ) { if ( s . charAt ( idx ) == ' ' ) { if ( isWord ) { isWord = false ; words . add ( s . substring ( startIdx , idx ) ) ; } } else { if ( ! isWord ) { isWord = true ; startIdx = idx ; } } } if ( isWord ) { words . add ( s . substring ( startIdx , s . length ( ) ) ) ; } return words ; } static ArrayList < String > Format ( ArrayList < ArrayList < String > > lines ) { ArrayList < String > formatted = new ArrayList < String > ( ) ; for ( int i = 0 ; i < lines . size ( ) ; ++ i ) { formatted . add ( \"\" ) ; } int maxWords = 0 ; for ( ArrayList < String > line : lines ) { maxWords = Math . max ( line . size (", "gt": ") , maxWords ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2012, "input": "<s> import java . io . * ; public class T6907575 { public static void main ( String ... args ) throws Exception { new T6907575 ( ) . run ( ) ; } void run ( ) throws Exception { String testSrc = System . getProperty ( \"test.src\" ) ; String testClasses = System . getProperty ( \"test.classes\" ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; GetDeps gd = new GetDeps ( ) ; gd . run ( pw , \"-classpath\" , testClasses , \"-t\" , \"-p\" , \"p\" , \"p/C1\" ) ; pw . close ( ) ; System . out . println ( sw ) ; String ref = readFile ( new File ( testSrc , \"T6907575.out\" ) ) ; diff ( sw . toString ( ) . replaceAll ( \"[\\r\\n]+\" , \"\\n\" ) , ref ) ; } void diff ( String actual , String ref ) throws Exception { System . out . println (", "gt": "\"EXPECT:>>>\" + ref + \"<<<\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1445, "input": "<s> package org . apache . lucene . util ; import junit . framework . TestCase ; import java . util . Random ; public class TestStringIntern extends LuceneTestCase { String [ ] testStrings ; String [ ] internedStrings ; Random r = newRandom ( ) ; private String randStr ( int len ) { char [ ] arr = new char [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { arr [ i ] = ( char ) ( 'a' + r . nextInt ( 26 ) ) ; } return new String ( arr ) ; } private void makeStrings ( int sz ) { testStrings = new String [ sz ] ; internedStrings = new String [ sz ] ; for ( int i = 0 ; i < sz ; i ++ ) { testStrings [ i ] = randStr ( r . nextInt ( 8 ) + 3 ) ; } } public void testStringIntern ( ) throws InterruptedException { makeStrings ( 1024 * 10 ) ; int nThreads = 20 ; final int iter = 1000000 ; final boolean newStrings = true ; Thread [ ] threads = new Thread [ nThreads ] ; for ( int i = 0 ; i < nThreads ; i ++ ) { final", "gt": "int seed = i ;", "prediction": ";\n", "label": 1}
{"id": 2422, "input": "<s> class KindnameConstructor { KindnameConstructor ( Integer x ) { } void m ( ) {", "gt": "new KindnameConstructor ( \"\" )", "prediction": "}\n", "label": 0}
{"id": 1451, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermEnum ; public abstract class FilteredTermEnum extends TermEnum { protected Term currentTerm = null ; protected TermEnum actualEnum = null ; public FilteredTermEnum ( ) { } protected abstract boolean termCompare ( Term term ) ; public abstract float difference ( ) ; protected abstract boolean endEnum ( ) ; protected void setEnum ( TermEnum actualEnum ) throws IOException { this . actualEnum = actualEnum ; Term term = actualEnum . term ( ) ; if ( term != null && termCompare ( term ) ) currentTerm = term ; else next ( ) ; } public int docFreq ( ) { if ( currentTerm == null ) return - 1 ; assert actualEnum != null ; return actualEnum . docFreq ( ) ; } public boolean next ( ) throws IOException { if ( actualEnum == null ) return false ; currentTerm = null ; while ( currentTerm == null ) { if ( endEnum ( ) ) return false ; if ( actualEnum . next ( ) ) { Term term = actualEnum", "gt": ". term ( ) ;", "prediction": ";\n", "label": 1}
{"id": 562, "input": "<s> package org . jjflyboy . tjpeditor . parser . antlr ; import com . google . inject . Inject ; import org . eclipse . xtext . parser . antlr . XtextTokenStream ; import org . jjflyboy . tjpeditor . services . ProjectGrammarAccess ; public class ProjectParser extends org . eclipse . xtext . parser . antlr . AbstractAntlrParser { @ Inject private ProjectGrammarAccess grammarAccess ; @ Override protected void setInitialHiddenTokens ( XtextTokenStream tokenStream ) { tokenStream . setInitialHiddenTokens ( \"RULE_WS\" , \"RULE_ML_COMMENT\" , \"RULE_SL_COMMENT\" ) ; } @ Override protected org . jjflyboy . tjpeditor . parser . antlr . internal . InternalProjectParser", "gt": "createParser ( XtextTokenStream stream )", "prediction": ";\n", "label": 0}
{"id": 1461, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . settings ; import com . digitalsanctum . idea . plugins . buildr . BuildrBundle ; import com . intellij . openapi . options . ConfigurationException ; import com . intellij . openapi . options . UnnamedConfigurable ; import javax . swing . * ; import java . util . ArrayList ; import java . util . List ; public class BuildrSettingsPane { private JPanel generatedPanel ; private JTabbedPane settingsTabbedPane ; private List < UnnamedConfigurable > configurableList = new ArrayList < UnnamedConfigurable > ( ) ; public JComponent getPanel ( ) { settingsTabbedPane . setBackground ( generatedPanel . getBackground ( ) ) ; final GeneralSettingsTab generalTab = new GeneralSettingsTab ( ) ; configurableList . add ( generalTab ) ; settingsTabbedPane . addTab ( BuildrBundle . message ( \"settings.plugin.general.tab.title\" ) , generalTab . getContentPanel ( ) ) ; return generatedPanel ; } public void apply ( ) throws ConfigurationException { for ( UnnamedConfigurable configurable : configurableList ) { configurable . apply ( ) ; } } public void reset ( ) { for ( UnnamedConfigurable configurable : configurableList ) { configurable . reset ( ) ; } } public boolean isModified ( ) { for ( UnnamedConfigurable configurable : configurableList ) { if ( configurable . isModified ( ) ) { return true ; } } return false ; }", "gt": "public void validate ( ) throws ConfigurationException", "prediction": "}\n", "label": 1}
{"id": 716, "input": "<s> package org . gk . engine . client . event . attrib ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . form . TriggerField ; public class EditableAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof TriggerField ) { ( ( TriggerField ) com ) . setEditable ( Boolean . parseBoolean ( value + \"\" ) ) ; } } @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if", "gt": "( com instanceof TriggerField )", "prediction": "( ) ;\n", "label": 0}
{"id": 1466, "input": "<s> package org . nuxeo . ecm . platform . relations ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . GraphDescription ; import org . nuxeo . ecm . platform . relations . api . GraphFactory ; public class CoreGraphFactory implements GraphFactory { @", "gt": "Override public Graph createGraph ( GraphDescription graphDescription , CoreSession session )", "prediction": ";\n", "label": 1}
{"id": 5351, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface Caption extends ReportAttribute", "prediction": "}\n", "label": 0}
{"id": 1476, "input": "<s> package com . ovea . i18n ; import java . util . List ; public interface I18NBundle { List < String > keys ( ) ; boolean hasKey ( String key ) ; String message ( String key , Object", "gt": "... params ) throws MissingMessageException ;", "prediction": ")\n", "label": 1}
{"id": 8663, "input": "<s> package org . msl . simple . gmf . migrate . ui ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PlatformUI ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimpleMapEditorDiagramEditorUtil ; public class MigrateToSimpleMapAction implements IObjectActionDelegate { private IWorkbenchPart targetPart ; private IStructuredSelection sselection ; public void setActivePart ( IAction action , IWorkbenchPart targetPart ) { this . targetPart = targetPart ; } public void selectionChanged ( IAction action , ISelection selection ) { action", "gt": ". setEnabled ( false ) ;", "prediction": "\n", "label": 0}
{"id": 1479, "input": "<s> package org . modelgoon . jdt . wizards ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . ui . internal . IWorkbenchGraphicConstants ; import org . eclipse . ui . internal . WorkbenchImages ; public class CreateMultipleAssociationWizard extends Wizard { public CreateMultipleAssociationWizard ( ) { super ( ) ; } @ Override public void addPages ( ) { super . addPages ( ) ; addPage ( new MultipleAssociationWizardPage ( ) ) ; setWindowTitle ( \"Create Multiple Association\" ) ; setDefaultPageImageDescriptor ( WorkbenchImages . getImageDescriptor (", "gt": "IWorkbenchGraphicConstants . IMG_WIZBAN_NEW_WIZ ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 4437, "input": "<s> package org . bombusim . lime . data ; import android . content . Context ; import android . database . Cursor ; import android . support . v4 . content . AsyncTaskLoader ; public abstract class SimpleCursorLoader extends AsyncTaskLoader < Cursor > { private Cursor mCursor ; public SimpleCursorLoader ( Context context ) { super ( context ) ; } @ Override public abstract Cursor loadInBackground ( ) ; @ Override public void deliverResult ( Cursor cursor ) { if ( isReset ( ) ) { if ( cursor != null ) { cursor . close ( ) ; } return ; } Cursor oldCursor = mCursor ; mCursor = cursor ; if ( isStarted ( ) ) { super . deliverResult ( cursor ) ; } if ( oldCursor != null && oldCursor != cursor && ! oldCursor . isClosed ( ) ) { oldCursor . close ( ) ; } } @ Override protected void onStartLoading ( ) { if ( mCursor != null ) { deliverResult ( mCursor ) ; } if ( takeContentChanged ( ) || mCursor == null ) { forceLoad ( ) ; } } @ Override protected void onStopLoading ( ) { cancelLoad ( ) ; } @ Override public void onCanceled ( Cursor cursor ) { if ( cursor != null && ! cursor . isClosed ( ) ) { cursor . close ( ) ; } } @ Override protected void onReset ( ) {", "gt": "super . onReset ( ) ;", "prediction": "\n", "label": 0}
{"id": 1508, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . * ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import java . util . * ; public class TestLazyBug extends LuceneTestCase { public static int NUM_DOCS = 500 ; public static int NUM_FIELDS = 100 ; private static String [ ] data = new String [ ] { \"now\" , \"is the time\" , \"for all good men\" , \"to come to the aid\" , \"of their country!\" , \"this string contains big chars:{\u0111 \u0222 \u0333 \u1111 \u2222 \u3333}\" , \"this string is a bigger string, mary had a little lamb, little lamb, little lamb!\" } ; private static Set dataset = new HashSet ( Arrays . asList ( data ) ) ; private static String MAGIC_FIELD = \"f\" + ( NUM_FIELDS / 3 ) ; private static FieldSelector SELECTOR = new FieldSelector ( ) { public FieldSelectorResult accept ( String f ) { if ( f . equals ( MAGIC_FIELD ) ) { return FieldSelectorResult . LOAD ; } return FieldSelectorResult . LAZY_LOAD ; } } ; private Directory makeIndex ( ) throws RuntimeException { Directory dir = new RAMDirectory ( ) ; try { Random r = newRandom ( ) ; Analyzer analyzer = new SimpleAnalyzer ( ) ; IndexWriter writer = new IndexWriter ( dir , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; writer . setUseCompoundFile ( false ) ; for ( int d = 1 ; d <= NUM_DOCS ; d ++ ) { Document doc = new Document ( ) ; for ( int f = 1 ; f <= NUM_FIELDS ; f ++ ) { doc . add ( new Field ( \"f\" + f , data [ f % data . length ] + '#' + data [ r . nextInt ( data . length ) ] , Field . Store . YES , Field . Index . ANALYZED ) ) ; } writer . addDocument ( doc ) ; } writer . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return dir ; } public void doTest ( int [ ] docs ) throws Exception { Directory dir = makeIndex ( ) ; IndexReader reader = IndexReader . open ( dir ) ; for ( int i = 0 ; i < docs . length ; i ++ ) { Document d = reader . document ( docs [ i ] , SELECTOR ) ; d . get ( MAGIC_FIELD ) ; List fields = d . getFields ( ) ; for ( Iterator fi = fields . iterator ( ) ; fi . hasNext ( ) ; ) { Fieldable f = null ; try { f = ( Fieldable ) fi . next ( ) ; String fname = f . name ( ) ; String", "gt": "fval = f . stringValue ( ) ;", "prediction": "}\n", "label": 1}
{"id": 3583, "input": "<s> package com . redhat . ceylon . compiler . loader ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . redhat . ceylon . compiler . typechecker . tree . Visitor ; public abstract class SourceDeclarationVisitor extends Visitor { abstract public void loadFromSource ( Tree . Declaration decl ) ; @ Override public void visit ( Tree . AnyClass that ) { loadFromSource ( that ) ; } @ Override public void visit ( Tree . AnyInterface that ) { loadFromSource ( that ) ; } @ Override public void visit ( Tree . ObjectDefinition that ) { loadFromSource ( that ) ; } @ Override public void visit", "gt": "( Tree . AnyMethod that )", "prediction": "( )\n", "label": 0}
{"id": 1511, "input": "<s> package com . googlecode . veloeclipse . preferences ; import org . eclipse . jface . preference . BooleanFieldEditor ; import org . eclipse . jface . preference . FieldEditorPreferencePage ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; import com . googlecode . veloeclipse . vaulttec . ui . VelocityPlugin ; public class GeneralPreferencePage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { public static final String P_CASE = \"USE_UPPER_CASE\" ; public static final String P_Completion = \"AUTO_COMPLETION\" ; public GeneralPreferencePage ( ) { super ( FieldEditorPreferencePage . GRID ) ; setPreferenceStore ( VelocityPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; setDescription ( \"General settings\" ) ; initializeDefaults ( ) ; } private void initializeDefaults ( ) { IPreferenceStore", "gt": "store = getPreferenceStore ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3742, "input": "<s> package com . sun . tools . javac . api ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . net . URI ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . lang . model . element . NestingKind ; import javax . tools . Diagnostic ; import javax . tools . FileObject ; import javax . tools . JavaFileManager ; import javax . tools . JavaFileManager . Location ; import javax . tools . JavaFileObject ; import com . sun . source . util . TaskEvent ; import com . sun . source . util . TaskListener ; import com . sun . tools . javac . util . ClientCodeException ; import com . sun . tools . javac . util . Context ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import javax . lang . model . element . Modifier ; import javax . tools . DiagnosticListener ; import javax . tools . JavaFileObject . Kind ; public class ClientCodeWrapper { @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . TYPE ) public @ interface Trusted { } public static ClientCodeWrapper instance ( Context context ) { ClientCodeWrapper instance = context . get ( ClientCodeWrapper . class ) ; if ( instance == null ) instance = new ClientCodeWrapper ( context ) ; return instance ; } Map < Class < ? > , Boolean > trustedClasses ; protected ClientCodeWrapper ( Context context ) { trustedClasses = new HashMap < Class < ? > , Boolean > ( ) ; } public JavaFileManager wrap ( JavaFileManager fm ) { if ( isTrusted ( fm ) ) return fm ; return new WrappedJavaFileManager ( fm ) ; } public FileObject wrap ( FileObject fo ) { if ( isTrusted ( fo ) ) return fo ; return new WrappedFileObject ( fo ) ; } FileObject unwrap ( FileObject fo ) { if ( fo instanceof WrappedFileObject ) return ( ( WrappedFileObject ) fo ) . clientFileObject ; else return fo ; } public JavaFileObject wrap ( JavaFileObject fo ) { if ( isTrusted ( fo ) ) return fo ; return new WrappedJavaFileObject ( fo ) ; } public Iterable < JavaFileObject > wrapJavaFileObjects ( Iterable < ? extends JavaFileObject > list ) { List < JavaFileObject > wrapped = new ArrayList < JavaFileObject > ( ) ; for ( JavaFileObject fo : list", "gt": ") wrapped . add ( wrap ( fo ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1559, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import java . util . SortedSet ; import javax . ws . rs . CookieParam ; import javax . ws . rs . GET ; import javax . ws . rs . HeaderParam ; import javax . ws . rs . MatrixParam ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . PathSegment ; import org . restlet . test . ext . jaxrs . services . tests . ListParamTest ; @ Path ( \"/listParams\" ) public class ListParamService { @ GET @ Path ( \"cookie\" ) @ Produces ( \"text/plain\" ) public String getCookie ( @ CookieParam ( \"c\" ) String c , @ CookieParam ( \"cc\" ) List < String > cc ) { return \"c=\" + c + \"\\ncc=\" + cc ; } @ GET @ Path ( \"header\" ) @ Produces ( \"text/plain\" ) public String getHeader ( @ HeaderParam ( \"h\" ) String h , @ HeaderParam ( \"hh\" ) Set < String > hh ) { return \"h=\" + h + \"\\nhh=\" + hh ; } @ GET @ Path ( \"matrix\" ) @ Produces ( \"text/plain\" ) public String getMatrix ( @ MatrixParam ( \"m\" ) String m , @ MatrixParam ( \"mm\" ) Collection < String > mm ) { return \"m=\" + m + \"\\nmm=\" + mm ; } public ListParamService getOther ( ) { return new ListParamService ( ) ; } @ GET @ Path ( \"path/{p}/{p}/{pp}/{pp}\" ) @ Produces ( \"text/plain\" ) public String getPath ( @ PathParam ( \"p\" ) PathSegment p , @ PathParam ( \"pp\" ) SortedSet < PathSegment > pp ) { return \"p=\"", "gt": "+ p + \"\\npp=\" + pp ;", "prediction": ";\n", "label": 1}
{"id": 2860, "input": "<s> package Liza ; import org . bukkit . entity . FallingSand ;", "gt": "public interface LizaFallingSand extends FallingSand", "prediction": "}\n", "label": 0}
{"id": 1564, "input": "<s> package org . jscsi . target . scsi . lun ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . ISerializable ; import org . jscsi . target . util . ReadWrite ; public class LogicalUnitNumber implements ISerializable { public static final int SIZE = 8 ; private final byte [ ] bytes ; public LogicalUnitNumber ( final long logicalUnitNumber ) { bytes = ReadWrite . longToBytes ( logicalUnitNumber ) ; } public void serialize ( ByteBuffer byteBuffer , int index ) {", "gt": "byteBuffer . position ( index ) ;", "prediction": "\n", "label": 1}
{"id": 2531, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectId ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ProjectIdImpl extends TaskAttributeImpl implements ProjectId { protected static final String PROJECT_ID_EDEFAULT = null ; protected String projectId = PROJECT_ID_EDEFAULT ; protected ProjectIdImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getProjectId ( ) ; } public String getProjectId ( ) { return projectId ; } public void setProjectId ( String newProjectId ) { String oldProjectId = projectId ; projectId = newProjectId ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . PROJECT_ID__PROJECT_ID , oldProjectId , projectId ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . PROJECT_ID__PROJECT_ID : return getProjectId ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . PROJECT_ID__PROJECT_ID : setProjectId ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . PROJECT_ID__PROJECT_ID : setProjectId ( PROJECT_ID_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . PROJECT_ID__PROJECT_ID : return PROJECT_ID_EDEFAULT == null ? projectId !=", "gt": "null : ! PROJECT_ID_EDEFAULT . equals ( projectId ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1571, "input": "<s> package org . nuxeo . ecm . core . rest ; import java . util . List ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . VersionModel ; import org . nuxeo . ecm . webengine . WebException ; import org . nuxeo . ecm . webengine . model . WebAdapter ; import org . nuxeo . ecm . webengine . model . exceptions . WebResourceNotFoundException ; import org . nuxeo . ecm . webengine . model . impl . DefaultAdapter ; @ WebAdapter ( name = \"versions\" , type = \"VersionService\" , targetType = \"Document\" , targetFacets = { \"Versionable\" } ) public class VersionService extends DefaultAdapter { @ GET public Object doGet ( ) { return getTarget ( ) . getView ( \"versions\" ) ; } @ Path ( \"last\" ) public DocumentObject getLastVersion ( ) { try { DocumentObject dobj = ( DocumentObject ) getTarget ( ) ; DocumentModel doc = dobj . getDocument ( ) ; DocumentModel v = dobj . getCoreSession ( ) . getLastDocumentVersion ( doc . getRef ( ) ) ; if ( v != null ) { return dobj . newDocument ( v ) ; } } catch ( Exception e ) { throw WebException . wrap ( e ) ; } throw new WebResourceNotFoundException ( \"No version found for \" + ( ( DocumentObject ) getTarget ( ) ) . getDocument ( ) . getPath ( ) ) ; } @ Path ( \"{label}\" ) public DocumentObject getVersion ( @ PathParam ( \"label\" ) String label ) { try { DocumentObject dobj = ( DocumentObject ) getTarget ( ) ; DocumentModel doc = dobj . getDocument ( ) ; List < VersionModel > versions = dobj . getCoreSession ( ) . getVersionsForDocument ( doc . getRef ( ) ) ; for ( VersionModel v : versions ) { if ( label . equals ( v . getLabel ( ) ) ) { return dobj . newDocument ( dobj . getCoreSession ( ) . getDocumentWithVersion ( doc . getRef ( ) , v ) ) ; } } } catch ( Exception e ) {", "gt": "throw WebException . wrap ( e ) ;", "prediction": "\n", "label": 1}
{"id": 4615, "input": "<s> package api . torrents . torrents ; public class Artists { private Number id ; private String name ; public Number getId ( ) { return this . id ; } public String getName ( ) {", "gt": "return this . name ;", "prediction": "\n", "label": 0}
{"id": 1587, "input": "<s> package org . eclipse . ui . forms ; public abstract class AbstractFormPart implements IFormPart { private IManagedForm managedForm ; private boolean dirty = false ; private boolean stale = true ; public void initialize ( IManagedForm form ) { this . managedForm = form ; } public IManagedForm getManagedForm ( ) { return managedForm ; } public void dispose ( ) { } public void commit ( boolean onSave ) { dirty = false ; } public boolean setFormInput ( Object input ) { return false ; }", "gt": "public void setFocus ( )", "prediction": "}\n", "label": 1}
{"id": 6877, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . javadoc . * ; public interface AnnotationTypeOptionalMemberWriter extends AnnotationTypeRequiredMemberWriter { public void", "gt": "addDefaultValueInfo ( MemberDoc member , Content annotationDocTree ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1591, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . Image ; public final class DeviceResourceManager extends AbstractResourceManager { private Device device ; private Image missingImage ; public Device getDevice ( ) { return device ; } public DeviceResourceManager ( Device device ) { this . device = device ; } protected Object allocate ( DeviceResourceDescriptor descriptor ) throws DeviceResourceException { return descriptor . createResource ( device ) ; } protected void deallocate ( Object resource , DeviceResourceDescriptor descriptor ) { descriptor . destroyResource ( resource ) ; } protected Image getDefaultImage ( ) { if ( missingImage == null ) { missingImage = ImageDescriptor . getMissingImageDescriptor", "gt": "( ) . createImage ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 5619, "input": "<s> package org . ofbiz . widget . html ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . taglib . ContentUrlTag ; import org . ofbiz . widget . ModelWidget ; import org . ofbiz . widget . WidgetWorker ; import org . ofbiz . widget . menu . MenuStringRenderer ; import org . ofbiz . widget . menu . ModelMenu ; import org . ofbiz . widget . menu . ModelMenuItem ; import org . ofbiz . widget . menu . ModelMenuItem . Image ; import org . ofbiz . widget . menu . ModelMenuItem . Link ; public class HtmlMenuRenderer extends HtmlWidgetRenderer implements MenuStringRenderer { HttpServletRequest request ; HttpServletResponse response ; protected String userLoginIdAtPermGrant ; protected boolean userLoginIdHasChanged = true ; protected String permissionErrorMessage = \"\" ; public static final String module = HtmlMenuRenderer . class . getName ( ) ; protected HtmlMenuRenderer ( ) { } public HtmlMenuRenderer ( HttpServletRequest request , HttpServletResponse response ) { this . request = request ; this . response = response ; } public void appendOfbizUrl ( Appendable writer , String location ) throws IOException { ServletContext ctx = ( ServletContext ) request . getAttribute ( \"servletContext\" ) ; if ( ctx == null ) { HttpSession session = request . getSession ( ) ; if ( session != null ) { ctx = session . getServletContext ( ) ; } else { } if ( ctx == null ) { throw new RuntimeException ( \"ctx is null. location:\" + location ) ; } } Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; if ( delegator == null ) { } RequestHandler rh = ( RequestHandler ) ctx . getAttribute ( \"_REQUEST_HANDLER_\" ) ; String s = rh . makeLink ( this . request , this . response , location ) ; if ( s . indexOf ( \"null\" ) >= 0 ) { } writer . append ( s ) ; } public void appendContentUrl ( Appendable writer , String location ) throws IOException { ServletContext ctx = ( ServletContext ) this . request . getAttribute ( \"servletContext\" ) ; if ( ctx == null ) { HttpSession session = request . getSession ( ) ; if ( session != null ) { ctx = session . getServletContext ( ) ; } else { } if ( ctx == null ) { throw new RuntimeException ( \"ctx is null. location:\" + location ) ; } this . request . setAttribute ( \"servletContext\" , ctx ) ; } Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; if ( delegator == null ) { } StringBuilder buffer = new StringBuilder ( ) ; ContentUrlTag . appendContentPrefix ( this . request , buffer ) ; writer . append ( buffer . toString ( ) ) ; writer . append ( location ) ; } public void appendTooltip ( Appendable writer , Map < String , Object > context , ModelMenuItem modelMenuItem ) throws IOException { String tooltip = modelMenuItem . getTooltip ( context ) ; if ( UtilValidate . isNotEmpty ( tooltip ) ) { writer . append ( \"<span class=\\\"\" ) ; String tooltipStyle = modelMenuItem . getTooltipStyle ( ) ; if ( UtilValidate . isNotEmpty ( tooltipStyle ) ) { writer . append ( tooltipStyle ) ; } else { writer . append ( \"tooltip\" ) ; } writer . append ( \"\\\"\" ) ; writer . append ( tooltip ) ; writer . append ( \"</span>\" ) ; } } public void renderFormatSimpleWrapperRows ( Appendable writer , Map < String , Object > context , Object menuObj ) throws IOException { List < ModelMenuItem > menuItemList = ( ( ModelMenu ) menuObj ) . getMenuItemList ( ) ; for ( ModelMenuItem currentMenuItem : menuItemList ) { renderMenuItem ( writer , context , currentMenuItem ) ; } } public void renderMenuItem ( Appendable writer , Map < String , Object > context , ModelMenuItem menuItem ) throws IOException { boolean hideThisItem = isHideIfSelected ( menuItem , context ) ; if ( hideThisItem ) return ; String style = menuItem . getWidgetStyle ( ) ; if ( menuItem . isSelected ( context ) ) { style = menuItem . getSelectedStyle ( ) ; if ( UtilValidate . isEmpty ( style ) ) { style = \"selected\" ; } } if ( menuItem . getDisabled ( ) || this . isDisableIfEmpty ( menuItem , context ) ) { style = menuItem . getDisabledTitleStyle ( ) ; } writer . append ( \"  <li\" ) ; String alignStyle = menuItem . getAlignStyle ( ) ; if ( UtilValidate . isNotEmpty ( style ) || UtilValidate . isNotEmpty ( alignStyle ) ) { writer . append ( \" class=\\\"\" ) ; if ( UtilValidate . isNotEmpty ( style ) ) { writer . append ( style ) . append ( \" \" ) ; } if ( UtilValidate . isNotEmpty ( alignStyle ) ) { writer . append ( alignStyle ) ; } writer . append ( \"\\\"\" ) ; } String toolTip = menuItem . getTooltip ( context ) ; if ( UtilValidate . isNotEmpty ( toolTip ) ) { writer . append ( \" title=\\\"\" ) . append ( toolTip ) . append ( \"\\\"\" ) ; } writer . append ( \">\" ) ; Link link = menuItem . getLink ( ) ; if ( link != null ) { renderLink ( writer , context , link ) ; } else { String txt = menuItem . getTitle ( context ) ; StringUtil . SimpleEncoder simpleEncoder = ( StringUtil . SimpleEncoder ) context", "gt": ". get ( \"simpleEncoder\" ) ;", "prediction": ";\n", "label": 0}
{"id": 1594, "input": "<s> package org . nuxeo . theme . test . webwidgets ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . theme . webwidgets . Provider ; import org . nuxeo . theme . webwidgets . ProviderException ; import org . nuxeo . theme . webwidgets . Widget ; import org . nuxeo . theme . webwidgets . WidgetState ; public class TestDefaultProvider { @ Test public void testCreateWidget ( ) throws ProviderException { Provider provider = new FakeDefaultProvider ( ) ; Widget widget1 = provider . createWidget ( \"test widget\" ) ; Widget widget2 = provider . createWidget ( \"test widget 2\" ) ; assertEquals ( \"test widget\" , widget1 . getName ( ) ) ; assertEquals ( \"test widget 2\" , widget2 . getName ( ) ) ; assertEquals ( \"0\" , widget1 . getUid ( ) ) ; assertEquals ( \"1\" , widget2 . getUid ( ) ) ; } @ Test public void testGetWidgetByUid ( ) throws ProviderException { Provider provider = new FakeDefaultProvider ( ) ; Widget widget1 = provider . createWidget ( \"test widget\" ) ; Widget widget2 = provider . createWidget ( \"test widget 2\" ) ; assertEquals ( widget1 , provider . getWidgetByUid ( \"0\" ) ) ; assertEquals ( widget2 , provider . getWidgetByUid ( \"1\" ) ) ; } @ Test public void testAddAndGetWidgets ( ) throws ProviderException { Provider provider = new FakeDefaultProvider ( ) ; Widget widget1 = provider . createWidget ( \"test widget\" ) ; Widget widget2 = provider . createWidget ( \"test widget 2\" ) ; provider . addWidget ( widget1 , \"region A\" , 0 ) ; provider . addWidget ( widget2 , \"region B\" , 0 ) ; assertEquals ( \"region A\" , provider . getRegionOfWidget ( widget1 ) ) ; assertEquals ( \"region B\" , provider . getRegionOfWidget ( widget2 ) ) ; assertTrue ( provider . getWidgets ( \"region A\" ) . contains ( widget1 ) ) ; assertTrue ( provider . getWidgets ( \"region B\" ) . contains ( widget2 ) ) ; assertFalse ( provider . getWidgets ( \"region A\" ) . contains ( widget2 ) ) ; assertFalse ( provider . getWidgets ( \"region B\" ) . contains ( widget1 ) ) ; assertEquals ( 0 , provider . getWidgets ( \"region A\" ) . indexOf ( widget1 ) ) ; assertEquals ( 0 , provider . getWidgets ( \"region B\" ) . indexOf ( widget2 ) ) ; Widget widget3 = provider . createWidget ( \"test widget 2\" ) ; provider . addWidget ( widget3 , \"region A\" , 1 ) ; assertEquals ( 1 , provider . getWidgets ( \"region A\" ) . indexOf ( widget3 ) ) ; } @ Test public void testReorderWidget ( ) throws ProviderException { Provider provider = new FakeDefaultProvider ( ) ; Widget widget1 = provider . createWidget ( \"test widget\" ) ; Widget widget2 = provider . createWidget ( \"test widget\" ) ; Widget widget3 = provider . createWidget ( \"test widget\" ) ; provider . addWidget ( widget1 , \"region A\" , 0 ) ; provider . addWidget ( widget2 , \"region A\" , 1 ) ; provider . addWidget ( widget3 , \"region A\" , 2 ) ; assertEquals ( 0 , provider . getWidgets ( \"region A\" ) . indexOf ( widget1 ) ) ; assertEquals ( 1 , provider . getWidgets ( \"region A\" ) . indexOf ( widget2 ) ) ; assertEquals ( 2 , provider . getWidgets ( \"region A\" ) . indexOf ( widget3 ) ) ; provider . reorderWidget ( widget2 , 0 ) ; assertEquals ( 0 , provider . getWidgets ( \"region A\" ) . indexOf ( widget2 ) ) ; assertEquals ( 1 , provider . getWidgets ( \"region A\" ) . indexOf ( widget1 ) ) ; assertEquals ( 2 , provider . getWidgets ( \"region A\" )", "gt": ". indexOf ( widget3 ) ) ;", "prediction": ";\n", "label": 1}
{"id": 5932, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class Synthetic_attribute extends Attribute { Synthetic_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; } public Synthetic_attribute ( ConstantPool constant_pool ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . Synthetic ) ) ; }", "gt": "public Synthetic_attribute ( int name_index )", "prediction": "}\n", "label": 0}
{"id": 1610, "input": "<s> package org . nuxeo . ecm . platform . localconfiguration . theme ; import static org . jboss . seam . ScopeType . CONVERSATION ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import javax . faces . component . UIComponent ; import javax . faces . component . ValueHolder ; import javax . faces . event . AbortProcessingException ; import javax . faces . event . ActionEvent ; import javax . faces . model . SelectItem ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Install ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . theme . Manager ; import org . nuxeo . theme . localconfiguration . LocalThemeConfig ; import org . nuxeo . theme . localconfiguration . LocalThemeHelper ; import org . nuxeo . theme . perspectives . PerspectiveManager ; import org . nuxeo . theme . perspectives . PerspectiveType ; import org . nuxeo . theme . styling . service . ThemeStylingService ; import org . nuxeo . theme . styling . service . descriptors . Flavor ; import org . nuxeo . theme . themes . ThemeManager ; @ Name ( \"themeConfigurationActions\" ) @ Scope ( CONVERSATION ) @ Install ( precedence = Install . FRAMEWORK ) public class ThemeConfigurationActions implements Serializable { private static final long serialVersionUID = 1L ; private static final Log log = LogFactory . getLog ( ThemeConfigurationActions . class ) ; @ In ( create = true ) protected transient NavigationContext navigationContext ; protected String theme ; @ Deprecated public List < SelectItem > getAvailableThemes ( ) { List < SelectItem > themes = new ArrayList < SelectItem > ( ) ; for ( String theme : ThemeManager . getThemeNames ( \"jsf-facelets\" ) ) { themes . add ( new SelectItem ( theme , theme ) ) ; } return themes ; } @ Deprecated public List < SelectItem > getAvailablePages ( ) { List < SelectItem > pages = new ArrayList < SelectItem > ( ) ; if ( theme != null && ! theme . equals ( \"\" ) ) { for ( String pageName : Manager . getThemeManager ( ) . getPageNames ( theme ) ) { pages . add ( new SelectItem ( pageName , pageName ) ) ; } } return pages ; } @ Deprecated public List < SelectItem > getAvailablePerspectives ( ) { List < SelectItem > selectItemList = new ArrayList < SelectItem > ( ) ; for ( PerspectiveType perspectiveType : PerspectiveManager . listPerspectives ( ) ) { selectItemList . add ( new SelectItem ( perspectiveType . name , perspectiveType . title ) ) ; } return selectItemList ; } @ Deprecated public void themeChange ( ActionEvent event ) { UIComponent select = event . getComponent ( ) . getParent ( ) ; if ( select instanceof ValueHolder ) { theme = ( String ) ( ( ValueHolder ) select ) . getValue ( ) ; } else { log . error ( \"Bad component returned \" + select ) ; throw new AbortProcessingException ( \"Bad component returned \" + select ) ; } } public String getConfigurationLayout ( ) { Boolean useOldThemeConf = Boolean . valueOf ( Framework . getProperty ( LocalThemeConfig . OLD_THEME_CONFIGURATION_PROPERTY ) ) ; if ( Boolean . TRUE . equals ( useOldThemeConf ) ) { return \"old_theme_configuration\" ; } return \"theme_configuration\" ; } public List < Flavor > getAvailableFlavors ( String themePage ) { ThemeStylingService service", "gt": "= getStylingService ( ) ;", "prediction": ";\n", "label": 1}
{"id": 245, "input": "<s> package ar . com . fdvs . dj . test ; import java . util . Date ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroupVariable ; public class TotalingReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style headerStyle1 = new StyleBuilder ( false ) . setFont ( Font . ARIAL_BIG ) . setBorderBottom ( Border . THIN ) . setPaddingTop ( new Integer ( 15 ) ) . build ( ) ; Style headerStyle2 = new StyleBuilder ( false ) . setFont ( Font . ARIAL_SMALL ) . setPaddingLeft ( new Integer ( 20 ) ) . build ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 70 , headerStyle1 , headerStyle1 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 70 , headerStyle2 , headerStyle2 ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 ) . addGroups ( 2 ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setPrintBackgroundOnOddRows ( false ) . setPrintColumnNames ( false ) . setShowDetailBand ( false ) . setUseFullPageWidth ( true ) ; Style hstyle1 = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . RIGHT ) . setBorderBottom ( Border . THIN ) . build ( ) ; Style hstyle2 = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . RIGHT ) . setFont ( Font . ARIAL_SMALL ) . build ( ) ; drb . getGroup ( 0 ) . addHeaderVariable ( new DJGroupVariable ( drb . getColumn ( 2 ) , DJCalculation . SUM , hstyle1 ) ) ; drb . getGroup ( 1 ) . addHeaderVariable ( new DJGroupVariable ( drb . getColumn ( 2 ) , DJCalculation . SUM , hstyle2 ) ) ; drb . getGroup ( 0 ) . setLayout ( GroupLayout . VALUE_IN_HEADER ) ; drb . getGroup ( 0 ) . setHeaderVariablesHeight ( new Integer ( 20 ) ) ; drb . getGroup ( 1 ) . setHeaderVariablesHeight ( new Integer ( 15 ) ) ; DynamicReport dr = drb . build ( ) ; return dr ; } public static void main ( String [ ] args ) throws Exception { TotalingReportTest test =", "gt": "new TotalingReportTest ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1611, "input": "<s> package org . nuxeo . ecm . wiki . listener ; import static org . nuxeo . ecm . wiki . rendering . WikiPageLinkResolver . PAGE_LINK_PATTERN ; import java . io . StringReader ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . model . PropertyException ; import org . nuxeo . ecm . core . api . model . PropertyNotFoundException ; import org . nuxeo . ecm . core . rest . DocumentObject ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . QNameResource ; import org . nuxeo . ecm . platform . relations . api . RelationManager ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . api . impl . LiteralImpl ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . ecm . platform . relations . api . impl . StatementImpl ; import org . nuxeo . ecm . platform . relations . api . util . RelationConstants ; import org . nuxeo . ecm . platform . relations . api . util . RelationHelper ; import org . nuxeo . ecm . webengine . model . WebContext ; import org . nuxeo . ecm . wiki . WikiTypes ; import org . wikimodel . wem . WikiParserException ; import org . wikimodel . wem . common . CommonWikiParser ; public class WikiHelper { public static final Resource HAS_LINK_TO = new ResourceImpl ( \"http://www.nuxeo.org/wiki/hasLinkTo\" ) ; private WikiHelper ( ) { } public static List < String > getWordLinks ( DocumentModel doc ) { try { String content = ( String ) doc . getPropertyValue ( WikiTypes . PROP_WIKI_CONTENT ) ; StringBuffer collector = new StringBuffer ( ) ; WordExtractor extractor = new WordExtractor ( collector ) ; CommonWikiParser parser = new CommonWikiParser ( ) ; try { parser . parse ( new StringReader ( content ) , extractor ) ; } catch ( WikiParserException e ) { e . printStackTrace ( ) ; } return getWordLinks ( collector . toString ( ) ) ; } catch ( PropertyNotFoundException e ) { } catch ( ClientException e ) { } return null ; } public static void updateRelations ( DocumentModel doc ) { List < String > list = getWordLinks ( doc ) ; List < Statement > stmts = RelationHelper . getStatements ( doc , HAS_LINK_TO ) ; try { RelationManager rm = RelationHelper . getRelationManager ( ) ; Graph graph = rm . getGraphByName ( RelationConstants . GRAPH_NAME ) ; if ( stmts != null ) { graph . remove ( stmts ) ; stmts . clear ( ) ; } else { stmts = new ArrayList < Statement > ( ) ; } if ( list != null ) { QNameResource docResource = RelationHelper . getDocumentResource ( doc ) ; for (", "gt": "String word : list )", "prediction": ") ;\n", "label": 1}
{"id": 9480, "input": "<s> package org . ofbiz . base . util . string ; import static de . odysseus . el . tree . impl . Scanner . Symbol . END_EVAL ; import static de . odysseus . el . tree . impl . Scanner . Symbol . FLOAT ; import static de . odysseus . el . tree . impl . Scanner . Symbol . START_EVAL_DEFERRED ; import static de . odysseus . el . tree . impl . Scanner . Symbol . START_EVAL_DYNAMIC ; import javax . el . ELContext ; import javax . el . ELException ; import javax . el . ExpressionFactory ; import javax . el . PropertyNotFoundException ; import de . odysseus . el . ExpressionFactoryImpl ; import de . odysseus . el . misc . LocalMessages ; import de . odysseus . el . tree . Bindings ; import de . odysseus . el . tree . Tree ; import de . odysseus . el . tree . TreeStore ; import de . odysseus . el . tree . impl . Builder ; import de . odysseus . el . tree . impl . Cache ; import de . odysseus . el . tree . impl . Parser ; import de . odysseus . el . tree . impl . Parser . ParseException ; import de . odysseus . el . tree . impl . Scanner . ScanException ; import de . odysseus . el . tree . impl . Scanner . Symbol ; import de . odysseus . el . tree . impl . ast . AstBracket ; import de . odysseus . el . tree . impl . ast . AstDot ; import de . odysseus . el . tree . impl . ast . AstEval ; import de . odysseus . el . tree . impl . ast . AstIdentifier ; import de . odysseus . el . tree . impl . ast . AstNode ; import org . ofbiz . base . util . Debug ; public class JuelConnector { protected static final String module = JuelConnector . class . getName ( ) ; public static ExpressionFactory newExpressionFactory ( ) { return new ExpressionFactoryImpl ( new TreeStore ( new ExtendedBuilder ( ) , new Cache ( 1000 ) ) ) ; } public static class ExtendedAstBracket extends AstBracket { public ExtendedAstBracket ( AstNode base , AstNode property , boolean lvalue , boolean strict ) { super ( base , property , lvalue , strict ) ; } @ Override public void setValue ( Bindings bindings , ELContext context , Object value ) throws ELException { if ( ! lvalue ) { throw new ELException ( LocalMessages . get ( \"error.value.set.rvalue\" ) ) ; } Object base = null ; try { base = prefix . eval ( bindings , context ) ; } catch ( Exception e ) { } Object property = getProperty ( bindings , context ) ; if ( property == null && strict ) { throw new PropertyNotFoundException ( LocalMessages . get ( \"error.property.property.notfound\" , \"null\" , base ) ) ; } if ( base == null ) { base = UelUtil . autoVivifyListOrMap ( property ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"ExtendedAstBracket.setValue auto-vivify base: \" + base + \", property = \" + property , module ) ; } prefix . setValue ( bindings , context , base ) ; } context . getELResolver ( ) . setValue ( context , base , property , value ) ; if ( ! context . isPropertyResolved ( ) ) { throw new PropertyNotFoundException ( LocalMessages . get ( \"error.property.property.notfound\" , property , base ) ) ; } } } public static class ExtendedAstDot extends AstDot { public ExtendedAstDot ( AstNode base , String property , boolean lvalue ) { super ( base , property , lvalue ) ; } @ Override public void setValue ( Bindings bindings , ELContext context , Object value ) throws ELException { if ( ! lvalue ) { throw new ELException ( LocalMessages . get ( \"error.value.set.rvalue\" ) ) ; } Object base = null ; try { base = prefix . eval ( bindings , context ) ; } catch ( Exception e ) { } Object property = getProperty ( bindings , context ) ; if ( property == null && strict ) { throw new PropertyNotFoundException ( LocalMessages . get ( \"error.property.property.notfound\" , \"null\" , base ) ) ; } if ( base == null ) { base = UelUtil . autoVivifyListOrMap ( property ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"ExtendedAstDot.setValue auto-vivify base: \" + base + \", property = \" + property , module ) ; } prefix . setValue ( bindings , context , base ) ; } context . getELResolver ( ) . setValue ( context , base , property , value ) ; if ( ! context . isPropertyResolved ( ) ) { throw new PropertyNotFoundException ( LocalMessages . get ( \"error.property.property.notfound\" , property , base ) ) ; } } } protected static class ExtendedParser extends Parser { public ExtendedParser ( Builder context , String input ) { super ( context , input ) ; } @ Override protected AstEval eval ( boolean required , boolean deferred ) throws ScanException , ParseException { AstEval v = null ; Symbol start_eval = deferred ? START_EVAL_DEFERRED : START_EVAL_DYNAMIC ; if ( this . getToken ( ) . getSymbol ( ) == start_eval ) { consumeToken ( ) ; AstNode node = expr ( true ) ; try { consumeToken ( END_EVAL ) ; } catch ( ParseException e ) { if ( this . getToken ( ) . getSymbol ( ) == FLOAT && node instanceof AstIdentifier ) { String mapKey = this . getToken ( ) . getImage ( ) . replace ( \".\" , \"\" ) ; node = createAstDot ( node , mapKey , true ) ; consumeToken ( ) ; consumeToken ( END_EVAL ) ; } else { throw e ; } } v = new AstEval ( node , deferred ) ; } else if ( required ) { fail ( start_eval ) ; } return v ; } @ Override protected AstBracket createAstBracket ( AstNode base , AstNode property , boolean lvalue , boolean strict ) { return new ExtendedAstBracket ( base , property , lvalue , strict ) ; } @ Override protected AstDot createAstDot ( AstNode base , String property , boolean lvalue ) { return new ExtendedAstDot ( base , property , lvalue ) ; } } @ SuppressWarnings ( \"serial\" ) protected static class ExtendedBuilder extends Builder { @ Override", "gt": "public Tree build ( String expression ) throws ELException", "prediction": "\n", "label": 0}
{"id": 1612, "input": "<s> package org . restlet . test . ext . odata . cafe ; import java . util . List ; import org . restlet . test . ext . odata . cafe . Contact ; import org . restlet . test . ext . odata . cafe . Item ; public class Cafe { private String city ; private String companyName ; private String id ; private String name ; private int zipCode ; private Contact contact ; private List < Item > items ; public Cafe ( ) { super ( ) ; } public Cafe ( String id ) { this ( ) ; this . id = id ; } public String getCity ( ) { return city ; } public String getCompanyName ( ) { return companyName ; } public String getId ( ) { return id ; } public String getName ( ) { return name ; } public int getZipCode ( ) { return zipCode ; } public Contact getContact ( ) { return contact ; } public", "gt": "List < Item > getItems ( )", "prediction": "}\n", "label": 1}
{"id": 4594, "input": "<s> public class Boxing2 { void f ( ) {", "gt": "Long l = 12 ;", "prediction": ";\n", "label": 0}
{"id": 1620, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . lucene . benchmark . BenchmarkTestCase ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . utils . Config ; public class CreateIndexTaskTest extends BenchmarkTestCase { private PerfRunData createPerfRunData ( String infoStreamValue ) throws Exception { Properties props = new Properties ( ) ; props . setProperty ( \"print.props\" , \"false\" ) ; props . setProperty ( \"directory\" , \"RAMDirectory\" ) ; props . setProperty ( \"writer.info.stream\" , infoStreamValue ) ; Config config = new Config ( props ) ; return new PerfRunData ( config ) ; } public void testInfoStream_SystemOutErr ( ) throws Exception { PrintStream curOut = System . out ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; System . setOut ( new PrintStream ( baos ) ) ; try { PerfRunData runData = createPerfRunData ( \"SystemOut\" ) ; CreateIndexTask cit = new CreateIndexTask ( runData ) ; cit . doLogic ( ) ; new CloseIndexTask ( runData ) . doLogic ( ) ; assertTrue ( baos . size ( ) > 0 ) ; } finally { System . setOut ( curOut ) ; } PrintStream curErr = System . err ; baos . reset ( ) ; System . setErr ( new PrintStream ( baos ) ) ; try { PerfRunData runData = createPerfRunData ( \"SystemErr\" ) ; CreateIndexTask cit = new CreateIndexTask ( runData ) ; cit . doLogic ( ) ; new CloseIndexTask ( runData ) . doLogic ( ) ; assertTrue ( baos . size ( ) > 0 ) ; } finally { System . setErr ( curErr ) ; } } public void testInfoStream_File ( ) throws Exception { File outFile = new File ( getWorkDir ( ) , \"infoStreamTest\" ) ; PerfRunData runData = createPerfRunData ( outFile . getAbsolutePath ( ) ) ; new CreateIndexTask ( runData ) . doLogic ( ) ; new CloseIndexTask ( runData ) . doLogic ( ) ; assertTrue ( outFile . length (", "gt": ") > 0 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9628, "input": "<s> import java . io . * ; import java . util . * ; public class TestPkgInfo { enum OptKind { NONE ( null ) , ALWAYS ( \"-Xpkginfo:always\" ) , NONEMPTY ( \"-Xpkginfo:nonempty\" ) , LEGACY ( \"-Xpkginfo:legacy\" ) ; OptKind ( String opt ) { this . opt = opt ; } final String opt ; } ; public static void main ( String ... args ) throws Exception { new TestPkgInfo ( ) . run ( args ) ; } public void run ( String ... args ) throws Exception { boolean [ ] booleanValues = { false , true } ; for ( OptKind ok : OptKind . values ( ) ) { for ( boolean sr : booleanValues ) { for ( boolean cr : booleanValues ) { for ( boolean rr : booleanValues ) { try { test ( ok , sr , cr , rr ) ; } catch ( Exception e ) { error ( \"Exception: \" + e ) ; } if ( errors > 0 ) throw new AssertionError ( ) ; } } } } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void test ( OptKind ok , boolean sr , boolean cr , boolean rr ) throws Exception { count ++ ; System . err . println ( \"Test \" + count + \": ok:\" + ok + \" sr:\" + sr + \" cr:\" + cr + \" rr:\" + rr ) ; StringBuilder sb = new StringBuilder ( ) ; if ( sr ) sb . append ( \"@SR\\n\" ) ; if ( cr ) sb . append ( \"@CR\\n\" ) ; if ( rr ) sb . append ( \"@RR\\n\" ) ; sb . append ( \"package p;\\n\" ) ; sb . append ( \"\\n\" ) ; sb . append ( \"import java.lang.annotation.*;\\n\" ) ; sb . append ( \"@Retention(RetentionPolicy.SOURCE)  @interface SR { }\\n\" ) ; sb . append ( \"@Retention(RetentionPolicy.CLASS)   @interface CR { }\\n\" ) ; sb . append ( \"@Retention(RetentionPolicy.RUNTIME) @interface RR { }\\n\" ) ; File tmpDir = new File ( \"tmp.test\" + count ) ; File classesDir = new File ( tmpDir , \"classes\" ) ; classesDir . mkdirs ( ) ; File pkginfo_java = new File ( new File ( tmpDir , \"src\" ) , \"package-info.java\" ) ; writeFile ( pkginfo_java , sb . toString ( ) ) ; List < String > opts = new ArrayList < String > ( ) ; List < File > files = new ArrayList < File > ( ) ; opts . add ( \"-d\" ) ; opts . add ( classesDir . getPath ( ) ) ; if ( ok . opt != null ) opts . add ( ok . opt ) ; files . add ( pkginfo_java ) ; compile ( opts , files ) ; File pkginfo_class = new File ( new File ( classesDir , \"p\" ) , \"package-info.class\" ) ; boolean exists = pkginfo_class . exists ( ) ; boolean expected ; switch ( ok ) { case ALWAYS : expected = true ; break ; case LEGACY : case NONE : expected = ( sr || cr || rr ) ; break ; case NONEMPTY : expected = ( cr || rr ) ; break ; default : throw new IllegalStateException ( ) ; } if ( exists && ! expected ) error ( \"package-info.class found but not expected\" ) ; if ( ! exists && expected ) error ( \"package-info.class expected but not found\" ) ; } void compile ( List < String > opts , List < File > files ) throws Exception { System . err . println ( \"javac: \" + opts + \" \" + files ) ; List < String > args = new ArrayList < String > ( ) ; args . addAll ( opts ) ; for ( File f : files ) args . add ( f . getPath ( ) ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javac . Main . compile ( args . toArray ( new String [ args . size ( ) ] ) , pw ) ; pw . flush ( ) ; if ( sw . getBuffer ( ) . length ( ) > 0 ) System . err . println ( sw . toString ( ) ) ; if ( rc != 0 ) throw new Exception ( \"compilation failed: rc=\" + rc ) ; } void writeFile ( File f , String body ) throws Exception { if ( f . getParentFile ( ) != null ) f . getParentFile ( ) . mkdirs ( ) ; Writer out = new FileWriter ( f ) ; try { out . write ( body ) ; } finally { out", "gt": ". close ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1625, "input": "<s> package org . fuzzydb . server . internal . table ; import org . fuzzydb . client . exceptions . KeyCollisionException ; import org . fuzzydb . client . exceptions . ObjectExistsException ; import org . fuzzydb . client . exceptions . UnknownObjectException ; import org . fuzzydb . client . exceptions . WriteCollisionException ; import org . fuzzydb . client . internal . MetaObject ; import org . fuzzydb . client . internal . RefImpl ; import org . fuzzydb . server . internal . server . Namespace ; public interface UserTable < T > extends Iterable < MetaObject < T > > { void initialise ( ) ; long allocNewIds ( int count ) ; void create ( MetaObject < T > mo ) ; void update ( MetaObject < T > mo ) throws UnknownObjectException ; void delete ( RefImpl < T > ref ) throws UnknownObjectException ; void testCanCreate ( MetaObject < T > mo ) throws ObjectExistsException , KeyCollisionException ; void testCanUpdate ( MetaObject < T > mo ) throws UnknownObjectException , WriteCollisionException , KeyCollisionException ; void testCanDelete ( RefImpl < T > ref ) throws UnknownObjectException ; MetaObject < T > getObject (", "gt": "RefImpl < T > ref ) throws UnknownObjectException ;", "prediction": ")\n", "label": 1}
{"id": 2583, "input": "<s> class Test extends Test { Inference x = 1 ; { if", "gt": "( x == 1 )", "prediction": "( ) ;\n", "label": 0}
{"id": 1638, "input": "<s> package org . w3c . css . sac ; public interface SelectorList { public", "gt": "int getLength ( ) ;", "prediction": "\n", "label": 1}
{"id": 1976, "input": "<s> package LizaCraft ; import java . io . File ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import java . util . UUID ; import org . bukkit . BlockChangeDelegate ; import org . bukkit . Chunk ; import org . bukkit . ChunkSnapshot ; import org . bukkit . Difficulty ; import org . bukkit . Effect ; import org . bukkit . Location ; import org . bukkit . TreeType ; import org . bukkit . World ; import org . bukkit . WorldType ; import org . bukkit . block . Biome ; import org . bukkit . block . Block ; import org . bukkit . entity . Arrow ; import org . bukkit . entity . CreatureType ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Item ; import org . bukkit . entity . LightningStrike ; import org . bukkit . entity . LivingEntity ; import org . bukkit . entity . Player ; import org . bukkit . generator . BlockPopulator ; import org . bukkit . generator . ChunkGenerator ; import org . bukkit . inventory . ItemStack ; import org . bukkit . plugin . Plugin ; import org . bukkit . util . Vector ; import Liza . LizaWorld ; public class LizaCraftWorld implements LizaWorld { private World world ; public LizaCraftWorld ( World world ) { this . world = world ; } @ Override public boolean createExplosion ( Location arg0 , float arg1 ) { return this . world . createExplosion ( arg0 , arg1 ) ; } @ Override public boolean createExplosion ( Location arg0 , float arg1 , boolean arg2 ) { return this . world . createExplosion ( arg0 , arg1 , arg2 ) ; } @ Override public boolean createExplosion ( double arg0 , double arg1 , double arg2 , float arg3 ) { return this . world . createExplosion ( arg0 , arg1 , arg2 , arg3 ) ; } @ Override public boolean createExplosion ( double arg0 , double arg1 , double arg2 , float arg3 , boolean arg4 ) { return this . world . createExplosion ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; } @ Override public Item dropItem ( Location arg0 , ItemStack arg1 ) { return this . world . dropItem ( arg0 , arg1 ) ; } @ Override public Item dropItemNaturally ( Location arg0 , ItemStack arg1 ) { return this . world . dropItemNaturally ( arg0 , arg1 ) ; } @ Override public boolean generateTree ( Location arg0 , TreeType arg1 ) { return this . world . generateTree ( arg0 , arg1 ) ; } @ Override public boolean generateTree ( Location arg0 , TreeType arg1 , BlockChangeDelegate arg2 ) { return this . world . generateTree ( arg0 , arg1 , arg2 ) ; } @ Override public boolean getAllowAnimals ( ) { return this . world . getAllowAnimals ( ) ; } @ Override public boolean getAllowMonsters ( ) { return this . world . getAllowMonsters ( ) ; } @ Override public Biome getBiome ( int arg0 , int arg1 ) { return this . world . getBiome ( arg0 , arg1 ) ; } @ Override public Block getBlockAt ( Location arg0 ) { return this . world . getBlockAt ( arg0 ) ; } @ Override public Block getBlockAt ( int arg0 , int arg1 , int arg2 ) { return this . world . getBlockAt ( arg0 , arg1 , arg2 ) ; } @ Override public int getBlockTypeIdAt ( Location arg0 ) { return this . world . getBlockTypeIdAt ( arg0 ) ; } @ Override public int getBlockTypeIdAt ( int arg0 , int arg1 , int arg2 ) { return this . world . getBlockTypeIdAt ( arg0 , arg1 , arg2 ) ; } @ Override public Chunk getChunkAt ( Location arg0 ) { return this . world . getChunkAt ( arg0 ) ; } @ Override public Chunk getChunkAt ( Block arg0 ) { return this . world . getChunkAt ( arg0 ) ; } @ Override public Chunk getChunkAt ( int arg0 , int arg1 ) { return this . world . getChunkAt ( arg0 , arg1 ) ; } @ Override public Difficulty getDifficulty ( ) { return this . world . getDifficulty ( ) ; } @ Override public ChunkSnapshot getEmptyChunkSnapshot ( int arg0 , int arg1 , boolean arg2 , boolean arg3 ) { return this . world . getEmptyChunkSnapshot ( arg0 , arg1 , arg2 , arg3 ) ; } @ Override public List < Entity > getEntities ( ) { return this . world . getEntities ( ) ; } @ Override public Environment getEnvironment ( ) { return this . world . getEnvironment ( ) ; } @ Override public long getFullTime ( ) { return this . world . getFullTime ( ) ; } @ Override public ChunkGenerator getGenerator ( ) { return this . world . getGenerator ( ) ; } @ Override public Block getHighestBlockAt ( Location arg0 ) { return this . world . getHighestBlockAt ( arg0 ) ; } @ Override public Block getHighestBlockAt ( int arg0 , int arg1 ) { return this . world . getHighestBlockAt ( arg0 , arg1 ) ; } @ Override public int getHighestBlockYAt ( Location arg0 ) { return this . world . getHighestBlockYAt ( arg0 ) ; } @ Override public int getHighestBlockYAt ( int arg0 , int arg1 ) { return this . world . getHighestBlockYAt ( arg0 , arg1 ) ; } @ Override public double getHumidity ( int arg0 , int arg1 ) { return this . world . getHumidity ( arg0 , arg1 ) ; } @ Override public long getId ( ) { return this . world . getId ( ) ; } @ Override public boolean getKeepSpawnInMemory ( ) { return this . world . getKeepSpawnInMemory ( ) ; } @ Override public List < LivingEntity > getLivingEntities ( ) { return this . world . getLivingEntities ( ) ; } @ Override public Chunk [ ] getLoadedChunks ( ) { return this . world . getLoadedChunks ( ) ; } @ Override public int getMaxHeight ( ) { return this . world . getMaxHeight ( ) ; } @ Override public String getName ( ) { return this . world . getName ( ) ; } @ Override", "gt": "public boolean getPVP ( )", "prediction": "}\n", "label": 0}
{"id": 1645, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . commands . common . EventManager ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IPerspectiveListener ; import org . eclipse . ui . IPerspectiveListener2 ; import org . eclipse . ui . IPerspectiveListener3 ; import org . eclipse . ui . IPerspectiveListener4 ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . internal . misc . UIStats ; public class PerspectiveListenerList extends EventManager { public PerspectiveListenerList ( ) { super ( ) ; } public void addPerspectiveListener ( IPerspectiveListener l ) { addListenerObject ( l ) ; } private void fireEvent ( SafeRunnable runnable , IPerspectiveListener listener , IPerspectiveDescriptor perspective , String description ) { String label = null ; if ( UIStats . isDebugging ( UIStats . NOTIFY_PERSPECTIVE_LISTENERS ) ) { label = description + perspective . getId ( ) ; UIStats . start ( UIStats . NOTIFY_PERSPECTIVE_LISTENERS , label ) ; } Platform . run ( runnable ) ; if ( UIStats . isDebugging ( UIStats . NOTIFY_PERSPECTIVE_LISTENERS ) ) { UIStats . end ( UIStats . NOTIFY_PERSPECTIVE_LISTENERS , listener , label ) ; } } public void firePerspectiveActivated ( final IWorkbenchPage page , final IPerspectiveDescriptor perspective ) { Object [ ] array = getListeners ( ) ; for ( int nX = 0 ; nX < array . length ; nX ++ ) { final IPerspectiveListener l = ( IPerspectiveListener ) array [ nX ] ; fireEvent ( new SafeRunnable ( ) { public void run ( ) { l . perspectiveActivated ( page , perspective ) ; } } , l , perspective , \"activated::\" ) ; } } public void firePerspectivePreDeactivate ( final IWorkbenchPage page , final IPerspectiveDescriptor perspective ) { Object [ ] array = getListeners ( ) ; for ( int nX = 0 ; nX < array . length ; nX ++ ) { if ( array [ nX ] instanceof IPerspectiveListener4 ) { final IPerspectiveListener4 l4 = ( IPerspectiveListener4 ) array [ nX ] ; fireEvent ( new SafeRunnable ( ) { public void run ( ) { l4 . perspectivePreDeactivate ( page , perspective ) ; } } , l4 , perspective , \"pre-deactivate::\" ) ; } } } public void firePerspectiveDeactivated ( final IWorkbenchPage page , final IPerspectiveDescriptor perspective ) { Object [ ] array = getListeners ( ) ; for ( int nX = 0 ; nX < array . length ; nX ++ ) { if ( array [ nX ] instanceof IPerspectiveListener3 ) { final IPerspectiveListener3 l3 = ( IPerspectiveListener3 ) array [ nX ] ; fireEvent ( new SafeRunnable ( ) { public void run ( ) { l3 . perspectiveDeactivated ( page , perspective ) ; } } , l3 , perspective , \"deactivated::\" ) ; } } } public void firePerspectiveChanged ( final IWorkbenchPage page , final IPerspectiveDescriptor perspective , final String changeId ) { Object [", "gt": "] array = getListeners ( ) ;", "prediction": "\n", "label": 1}
{"id": 10040, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . util . ArrayList ; import java . util . Collection ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . DeclarationVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . code . Symbol . MethodSymbol ; @ SuppressWarnings ( \"deprecation\" ) public class ConstructorDeclarationImpl extends ExecutableDeclarationImpl implements ConstructorDeclaration { ConstructorDeclarationImpl ( AptEnv env , MethodSymbol sym ) { super ( env , sym ) ; } public String getSimpleName ( ) { return sym . enclClass ( ) . name", "gt": ". toString ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1653, "input": "<s> package org . eclipse . ui . internal ; import java . util . Set ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . views . IStickyViewDescriptor ; import org . eclipse . ui . views . IViewRegistry ; public class StickyViewManager implements IStickyViewManager { private IWorkbenchPage page ; public StickyViewManager ( IWorkbenchPage page ) { this . page = page ; } public static IStickyViewManager getInstance ( IWorkbenchPage page ) { IStickyViewManager stickyViewMan ; IPreferenceStore preferenceStore = PrefUtil . getAPIPreferenceStore ( ) ; boolean enable32Behavior = preferenceStore . getBoolean ( IWorkbenchPreferenceConstants . ENABLE_32_STICKY_CLOSE_BEHAVIOR ) ; if ( enable32Behavior ) stickyViewMan = new StickyViewManager32 ( page ) ; else stickyViewMan = new StickyViewManager ( page ) ; return stickyViewMan ; } public void add ( String perspectiveId , Set stickyViewSet ) { } public void clear ( ) { } public void remove ( String perspectiveId ) { } public void restore ( IMemento memento ) { } public void save ( IMemento memento ) { } public void update ( Perspective oldPersp , Perspective newPersp ) { if ( oldPersp == null || newPersp == null ) { return ; } IViewRegistry viewReg = WorkbenchPlugin . getDefault ( ) . getViewRegistry ( ) ; IStickyViewDescriptor [ ] stickyDescs = viewReg . getStickyViews ( ) ; IViewReference [ ] oldPerspectiveViewReferences = oldPersp . getViewReferences ( ) ; IViewReference [ ] newPerspectiveViewReferences = newPersp . getViewReferences ( ) ; for ( int i = 0 ; i < stickyDescs . length ; i ++ ) { final String", "gt": "viewId = stickyDescs [ i ] . getId ( ) ;", "prediction": ". get ( ) ;\n", "label": 1}
{"id": 2019, "input": "<s> package org . gk . engine . client . build . layout ; import java . util . List ; import org . gk . engine . client . utils . IRegExpUtils ; import com . extjs . gxt . ui . client . widget . layout . FormData ; import com . extjs . gxt . ui . client . widget . layout . LayoutData ; import com . google . gwt . xml . client . Node ; public class XFormData extends XLayoutData { protected String width ; protected String height ; public XFormData ( Node node , List subNodes ) { super ( node , subNodes ) ; width = super . getAttribute ( \"width\" , \"\" ) ; height = super . getAttribute ( \"height\" , \"\" ) ; } public String getWidth ( ) { return width ; } public String getHeight ( ) { return height ; } @ Override public LayoutData getLayoutData ( ) { FormData fd = new FormData ( ) ; if ( width . matches ( IRegExpUtils . INTEGER ) ) { fd . setWidth ( Integer . parseInt ( width ) ) ; } if ( height . matches ( IRegExpUtils . INTEGER ) ) { fd . setHeight ( Integer .", "gt": "parseInt ( height ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1660, "input": "<s> package org . restlet . example . book . restlet . ch10 . sec3 . server ; import java . util . HashMap ; import java . util . Map ; import org . restlet . Application ; import org . restlet . Restlet ; import org . restlet . example . book . restlet . ch10 . sec3 . model . Account ; import org . restlet . example . book . restlet . ch10 . sec3 . model . Contact ; import org . restlet . routing . Router ; public class MailServerApplication extends Application { private final Map < String , Account > accounts = new HashMap < String , Account > ( ) ; public MailServerApplication ( ) { setName ( \"RESTful Mail API application\" ) ; setDescription ( \"Example API for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; Account homer = new Account ( ) ; homer . setFirstName ( \"Homer\" ) ; homer . setLastName ( \"Simpson\" ) ; homer . setLogin ( \"chunkylover53\" ) ; homer . setNickName ( \"Personal mailbox of Homer\" ) ; homer . setSenderName ( \"Homer\" ) ; homer . setEmailAddress ( \"homer@simpson.org\" ) ; homer . getContacts ( ) . add ( new Contact ( \"/accounts/bretzels34/\" ) ) ; homer . getContacts ( ) . add ( new Contact ( \"/accounts/jojo10/\" ) ) ; homer . getContacts ( ) . add ( new Contact ( \"/accounts/lisa1984/\" ) ) ; getAccounts ( ) . put ( \"chunkylover53\" , homer ) ; Account marge = new Account ( ) ; marge . setFirstName ( \"Marjorie\" ) ; marge . setLastName ( \"Simpson\" ) ; marge . setLogin ( \"bretzels34\" ) ; marge . setNickName ( \"Personal mailbox of Marge\" ) ; marge . setSenderName ( \"Marge\" ) ; marge . setEmailAddress ( \"homer@simpson.org\" ) ; marge . getContacts ( ) . add ( new Contact ( \"/accounts/chunkylover53/\" ) ) ; marge . getContacts ( ) . add ( new Contact ( \"/accounts/jojo10/\" ) ) ; marge . getContacts ( ) . add ( new Contact ( \"/accounts/lisa1984/\" ) ) ; getAccounts ( ) . put ( \"bretzels34\" , marge ) ; Account bart = new Account ( ) ; bart . setFirstName ( \"Bartholomew\" ) ; bart . setLastName ( \"Simpson\" ) ; bart . setLogin ( \"jojo10\" ) ; bart . setNickName ( \"Personal mailbox of Bart\" ) ; bart . setSenderName ( \"Bart\" ) ; bart . setEmailAddress ( \"bart@simpson.org\" ) ; bart . getContacts ( ) . add ( new Contact ( \"/accounts/chunkylover53/\" ) ) ; bart . getContacts ( ) . add ( new Contact ( \"/accounts/bretzels34/\" ) ) ; bart . getContacts ( ) . add ( new Contact ( \"/accounts/lisa1984/\" ) ) ; getAccounts ( ) . put ( \"jojo10\" , bart ) ; Account lisa = new Account ( ) ; lisa . setFirstName ( \"Lisa\" ) ; lisa . setLastName ( \"Simpson\" ) ; lisa . setLogin ( \"lisa1984\" ) ; lisa . setNickName ( \"Personal mailbox of Lisa\" ) ; lisa . setSenderName ( \"Lisa\" ) ; lisa . setEmailAddress ( \"lisa@simpson.org\" ) ; lisa . getContacts ( ) . add ( new Contact ( \"/accounts/chunkylover53/\" ) ) ; lisa . getContacts ( ) . add ( new", "gt": "Contact ( \"/accounts/bretzels34/\" ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7638, "input": "<s> package org . dawb . workbench . plotting . tools . history ; import java . util . List ; import org . dawb . common . gpu . Operator ; import org . eclipse . swt . graphics . RGB ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; class HistoryBean { private AbstractDataset data ; private List < AbstractDataset > axes ; private Operator operator ; private int weighting = 100 ; private AbstractDataset xdata ; private AbstractDataset ydata ; private RGB plotColour ; private String plotName ; private String traceName ; private boolean selected ; private boolean modifiable = true ; public String createTraceName ( ) { return getTraceName ( ) + \" (\" + getPlotName ( ) + \")\" ; } public String getTraceKey ( ) { if ( fixedImageKey != null ) return fixedImageKey ; createFixedKey ( true ) ; return fixedImageKey ; } private String fixedImageKey ; public void setFixedImageKey ( String key ) { this . fixedImageKey = key ; } public AbstractDataset getXdata ( ) { return xdata ; } public AbstractDataset getData ( ) { return data ; } public void setData ( AbstractDataset data ) { this . data = data ; } public void setXdata ( AbstractDataset xdata ) { this . xdata = xdata ; } public boolean isSelected ( ) { return selected ; } public void setSelected ( boolean selected ) { this . selected = selected ; } public String getPlotName ( ) { return plotName ; } public void setPlotName ( String parentPlotName ) { this . plotName = parentPlotName ; createFixedKey ( false ) ; } private void createFixedKey ( boolean force ) { if ( fixedImageKey == null && traceName != null && plotName != null ) { fixedImageKey = getTraceName ( ) + \":\" + getPlotName ( ) ; } if ( force && fixedImageKey == null ) { fixedImageKey = getTraceName ( ) + \":\" + getPlotName ( ) ; } } public String getTraceName ( ) { return traceName ; } public void setTraceName ( String originalTraceName ) { this . traceName = originalTraceName ; createFixedKey ( false ) ; } public AbstractDataset getYdata ( ) { return ydata ; } public void setYdata ( AbstractDataset data ) { this . ydata = data ; } public RGB getPlotColour ( ) { return plotColour ; } public void setPlotColour ( RGB plotColour ) { this . plotColour = plotColour ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( axes == null ) ? 0 : axes . hashCode ( ) ) ; result = prime * result + ( ( data == null ) ? 0 : data . hashCode ( ) ) ; result = prime * result + ( ( fixedImageKey == null ) ? 0 : fixedImageKey . hashCode ( ) ) ; result = prime * result + ( modifiable ? 1231 : 1237 ) ; result = prime * result + ( ( operator == null ) ? 0 : operator . hashCode ( ) ) ; result = prime * result + ( ( plotColour == null ) ? 0 : plotColour . hashCode ( ) ) ; result = prime * result + ( ( plotName == null ) ? 0 : plotName . hashCode ( ) ) ; result = prime * result + ( selected ? 1231 : 1237 ) ; result = prime * result + ( ( traceName == null ) ? 0 : traceName . hashCode ( ) ) ; result = prime * result + weighting ; result = prime * result + ( ( xdata == null ) ? 0 : xdata . hashCode ( ) ) ; result = prime * result + ( ( ydata == null ) ? 0 : ydata", "gt": ". hashCode ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1664, "input": "<s> package org . restlet . ext . odata . internal ; import java . util . Iterator ; import org . restlet . data . Reference ; import org . restlet . ext . odata . Query ; import org . restlet . ext . odata . Service ; public class EntryIterator < E > implements Iterator < E > { private Class < ? > entityClass ; private Iterator < E > iterator ; private Reference nextPage ; private Service service ; public EntryIterator ( Service service , Iterator < E > iterator , Reference nextPage , Class < ? > entityClass ) { super ( ) ; this . iterator = iterator ; this . nextPage = nextPage ; this . service = service ; this . entityClass = entityClass ; } @ SuppressWarnings ( \"unchecked\" ) public boolean hasNext ( ) { boolean result = false ; if ( iterator != null ) { result = iterator . hasNext ( ) ; } if ( ! result && nextPage != null ) { Query < E > query = service . createQuery ( nextPage . toString ( ) , ( Class < E > ) entityClass ) ; iterator = query . iterator ( ) ; if ( iterator != null ) { result = iterator . hasNext ( ) ; } nextPage = null ; } return result ; } public E next ( ) { E result = null ; if ( iterator != null ) { if ( iterator . hasNext ( ) ) { result =", "gt": "iterator . next ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4, "input": "<s> package com . sun . tools . javadoc ; import com . sun . javadoc . * ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Symbol . ClassSymbol ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . code . TypeTags ; import com . sun . tools . javac . code . Type . ClassType ; class PrimitiveType implements com . sun . javadoc . Type { private final String name ; static final PrimitiveType voidType = new PrimitiveType ( \"void\" ) ; static final PrimitiveType booleanType = new PrimitiveType ( \"boolean\" ) ; static final PrimitiveType byteType = new PrimitiveType ( \"byte\" ) ; static final PrimitiveType charType = new PrimitiveType ( \"char\" ) ; static final PrimitiveType shortType = new PrimitiveType ( \"short\" ) ; static final PrimitiveType intType = new PrimitiveType ( \"int\" ) ; static final PrimitiveType longType = new PrimitiveType ( \"long\" ) ; static final PrimitiveType floatType = new PrimitiveType ( \"float\" ) ; static final PrimitiveType doubleType = new PrimitiveType ( \"double\" ) ; static final PrimitiveType errorType = new PrimitiveType ( \"\" ) ; PrimitiveType ( String name ) { this . name = name ; } public String typeName ( ) { return name ; } public String qualifiedTypeName ( ) { return name ; } public String simpleTypeName ( ) { return name ; } public String dimension ( ) { return \"\" ; } public ClassDoc asClassDoc ( ) { return null ; } public AnnotationTypeDoc asAnnotationTypeDoc ( ) { return null ; } public ParameterizedType asParameterizedType ( ) { return null ; } public TypeVariable asTypeVariable ( ) { return null ; }", "gt": "public WildcardType asWildcardType ( )", "prediction": "}\n", "label": 0}
{"id": 1672, "input": "<s> package org . eclipse . ui . internal . activities ; public class PatternUtil { public static String quotePattern ( String pattern ) { final String START = \"\\\\Q\" ; final String STOP = \"\\\\E\" ; final int STOP_LENGTH = 2 ; int stopIndex = pattern . indexOf ( STOP ) ; if ( stopIndex < 0 ) { return START + pattern + STOP ; } String result = START ; for ( int position = 0 ; ; ) { stopIndex = pattern . indexOf (", "gt": "STOP , position ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7264, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . IcalReportAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class IcalReportAttributeImpl extends MinimalEObjectImpl . Container implements IcalReportAttribute { protected IcalReportAttributeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage .", "gt": "eINSTANCE . getIcalReportAttribute ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 1678, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers . provider ; import javax . ws . rs . core . MediaType ; public interface ContextResolver { public javax . ws . rs . ext", "gt": ". ContextResolver < ? > getContextResolver ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5742, "input": "<s> package org . jjflyboy . tjpeditor . parser . antlr . internal ; import org . eclipse . xtext . * ; import org . eclipse . xtext . parser . * ; import org . eclipse . xtext . parser . impl . * ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . common . util . Enumerator ; import org . eclipse . xtext . parser . antlr . AbstractInternalAntlrParser ; import org . eclipse . xtext . parser . antlr . XtextTokenStream ; import org . eclipse . xtext . parser . antlr . XtextTokenStream . HiddenTokens ; import org . eclipse . xtext . parser . antlr . AntlrDatatypeRuleToken ; import org . jjflyboy . tjpeditor . services . ProjectGrammarAccess ; import org . antlr . runtime . * ; import java . util . Stack ; import java . util . List ; import java . util . ArrayList ; import java . util . Map ; import java . util . HashMap ; @ SuppressWarnings ( \"all\" ) public class InternalProjectParser extends AbstractInternalAntlrParser { public static final String [ ] tokenNames = new String [ ] { \"<invalid>\" , \"<EOR>\" , \"<DOWN>\" , \"<UP>\" , \"RULE_ID\" , \"RULE_STRING\" , \"RULE_INT\" , \"RULE_ISODATE\" , \"RULE_TIME\" , \"RULE_FLOAT\" , \"RULE_SL_COMMENT\" , \"RULE_ML_COMMENT\" , \"RULE_WS\" , \"RULE_ANY_OTHER\" , \"'.'\" , \"'account'\" , \"'{'\" , \"'}'\" , \"'accountprefix'\" , \"'accountreport'\" , \"'accountroot'\" , \"'project'\" , \"'task'\" , \"'icalreport'\" , \"'export'\" , \"'resource'\" , \"'allocate'\" , \"','\" , \"'navigator'\" , \"'newtask'\" , \"'nikureport'\" , \"'alert'\" , \"'author'\" , \"'balance'\" , \"'overtime'\" , \"'sloppy'\" , \"'booking'\" , \"'caption'\" , \"'cellcolor'\" , \"'celltext'\" , \"'center'\" , \"'charge'\" , \"'chargeset'\" , \"'columns'\" , \"'complete'\" , \"'copyright'\" , \"'credit'\" , \"'currency'\" , \"'currencyformat'\" , \"'dailymax'\" , \"'dailymin'\" , \"'dailyworkinghours'\" , \"'definitions'\" , \"'*'\" , \"'-'\" , \"'flags'\" , \"'resources'\" , \"'tasks'\" , \"'projectids'\" , \"'depends'\" , \"'details'\" , \"'duration'\" , \"'efficiency'\" , \"'effort'\" , \"'email'\" , \"'end'\" , \"'endcredit'\" , \"'epilog'\" , \"'reference'\" , \"'date'\" , \"'richtext'\" , \"'text'\" , \"'inherit'\" , \"'scenariospecific'\" , \"'extend'\" , \"'fail'\" , \"'fontcolor'\" , \"'footer'\" , \"'formats'\" , \"'hasalert'\" , \"'hasalert_'\" , \"'('\" , \"')'\" , \"'isactive'\" , \"'isactive_'\" , \"'ischildof'\" , \"'ischildof_'\" , \"'isdependencyof'\" , \"'isdependencyof_'\" , \"'isdutyof'\" , \"'isdutyof_'\" , \"'isfeatureof'\" , \"'isfeatureof_'\" , \"'isleaf'\" , \"'isleaf_'\" , \"'ismilestone'\" , \"'ismilestone_'\" , \"'isongoing'\" , \"'isongoing_'\" , \"'isresource'\" , \"'isresource_'\" , \"'isresponsbilityof'\" , \"'isresponsbilityof_'\" , \"'istask'\" , \"'istask_'\" , \"'treelevel'\" , \"'treelevel_'\" , \"'gapduration'\" , \"'gaplength'\" , \"'header'\" , \"'headline'\" , \"'hideaccount'\" , \"'hidejournalentry'\" , \"'hidereport'\" , \"'hideresource'\" , \"'hidetask'\" , \"'include'\" , \"'+'\" , \"'journalattributes'\" , \"'property'\" , \"'timesheet'\" , \"'propertyid'\" , \"'summary'\" , \"'journalentry'\" , \"'journalmode'\" , \"'left'\" , \"'length'\" , \"'limits'\" , \"'listitem'\" , \"'listtype'\" , \"'loadunit'\" , \"'|'\" , \"'&'\" , \"'='\" , \"'!='\" , \"'false'\" , \"'true'\" , \"'macro'\" , \"'managers'\" , \"'mandatory'\" , \"'maxend'\" , \"'maximum'\" , \"'maxstart'\" , \"'milestone'\" , \"'minimum'\" , \"'minend'\" , \"'minstart'\" , \"'monthlymax'\" , \"'monthlymin'\" , \"'note'\" , \"'now'\" , \"'numberformat'\" , \"'period'\" , \"'persistent'\" , \"'precedes'\" , \"'priority'\" , \"'projectid'\" , \"'prolog'\" , \"'purge'\" , \"'rate'\" , \"'remaining'\" , \"'reportprefix'\" , \"'resourceattributes'\" , \"'vacation'\" , \"'workinghours'\" , \"'resourceprefix'\" , \"'resourcereport'\" , \"'resourceroot'\" , \"'responsible'\" , \"'right'\" , \"'rollupaccount'\" , \"'rollupresource'\" , \"'rolluptask'\" , \"'scale'\" , \"'hour'\" , \"'day'\" , \"'week'\" , \"'month'\" , \"'quarter'\" , \"'year'\" , \"'scenario'\" , \"'active'\" , \"'scenarios'\" , \"'scheduled'\" , \"'scheduling'\" , \"'select'\" , \"'selfcontained'\" , \"'shift'\" , \"'replace'\" , \"'timezone'\" , \"'shifts'\" , \"'shorttimeformat'\" , \"'tree'\" , \"'sortaccounts'\" , \"'sortjournalentries'\" , \"'sortresources'\" , \"'sorttasks'\" , \"'start'\" , \"'status'\" , \"'statussheet'\" , \"'statussheetreport'\" , \"'supplement'\" , \"'report'\" , \"'tagfile'\" , \"'taskattributes'\" , \"'taskprefix'\" , \"'taskreport'\" , \"'taskroot'\" , \"'textreport'\" , \"'timeformat'\" , \"'timeoff'\" , \"'timesheetreport'\" , \"'timingresolution'\" , \"'min'\" , \"'title'\" , \"'tooltip'\" , \"'trackingscenario'\" , \"'warn'\" , \"'weekstartssunday'\" , \"'weekstartsmonday'\" , \"'weeklymax'\" , \"'weeklymin'\" , \"'width'\" , \"'work'\" , \"'off'\" , \"'yearlyworkingdays'\" , \"'!'\" , \"'+='\" , \"'||'\" , \"'&&'\" , \"'=='\" , \"'instanceof'\" , \"'>='\" , \"'<='\" , \"'>'\" , \"'<'\" , \"'->'\" , \"'..'\" , \"'**'\" , \"'/'\" , \"'%'\" , \"'as'\" , \"'?.'\" , \"'*.'\" , \"'['\" , \"']'\" , \"';'\" , \"'if'\" , \"'else'\" , \"'switch'\" , \"':'\" , \"'default'\" , \"'case'\" , \"'for'\" , \"'while'\" , \"'do'\" , \"'var'\" , \"'val'\" , \"'super'\" , \"'::'\" , \"'new'\" , \"'null'\" , \"'typeof'\" , \"'throw'\" , \"'return'\" , \"'try'\" , \"'finally'\" , \"'catch'\" , \"'=>'\" , \"'?'\" , \"'extends'\" , \"'journalAttributes'\" , \"'reports'\" , \"'vacations'\" , \"'onstart'\" , \"'onend'\" , \"'perhour'\" , \"'perday'\" , \"'perweek'\" , \"'journal'\" , \"'journal_sub'\" , \"'status_down'\" , \"'status_up'\" , \"'alerts_down'\" , \"'bullets'\" , \"'comma'\" , \"'numbered'\" , \"'up'\" , \"'down'\" , \"'yes'\" , \"'no'\" , \"'csv'\" , \"'html'\" , \"'niku'\" , \"'days'\" , \"'hours'\" , \"'longauto'\" , \"'minutes'\" , \"'months'\" , \"'shortauto'\" , \"'weeks'\" , \"'years'\" , \"'maxloaded'\" , \"'minloaded'\" , \"'minallocated'\" , \"'order'\" , \"'random'\" , \"'alertmessage'\" , \"'alertsummar'\" , \"'alerttrend'\" , \"'chart'\" , \"'completed'\" , \"'criticalness'\" , \"'cost'\" , \"'daily'\" , \"'duties'\" , \"'effortdone'\" , \"'effortleft'\" , \"'followers'\" , \"'freetime'\" , \"'freework'\" , \"'fte'\" , \"'headcount'\" , \"'hierarchindex'\" , \"'hourly'\" , \"'id'\" , \"'index'\" , \"'line'\" , \"'monthly'\" , \"'name'\" , \"'pathcriticalness'\" , \"'precursor'\" , \"'quarterly'\" , \"'revenue'\" , \"'seqno'\" , \"'targets'\" , \"'wbs'\" , \"'weekly'\" , \"'yearly'\" , \"'red'\" , \"'yellow'\" , \"'green'\" , \"'alap'\" , \"'asap'\" , \"'h'\" , \"'d'\" , \"'w'\" , \"'m'\" , \"'y'\" , \"'mon'\" , \"'tue'\" , \"'wed'\" , \"'thu'\" , \"'fri'\" , \"'sat'\" , \"'sun'\" } ; public static final int RULE_ID = 4 ; public static final int T__159 = 159 ; public static final int T__158 = 158 ; public static final int T__259 = 259 ; public static final int T__258 = 258 ; public static final int T__257 = 257 ; public static final int RULE_ANY_OTHER = 13 ; public static final int T__262 = 262 ; public static final int T__263 = 263 ; public static final int T__160 = 160 ; public static final int T__260 = 260 ; public static final int T__261 = 261 ; public static final int T__266 = 266 ; public static final int T__267 = 267 ; public static final int T__264 = 264 ; public static final int T__265 = 265 ; public static", "gt": "final int T__167 = 167 ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1683, "input": "<s> package monbulk . shared . util ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map . Entry ; import monbulk . shared . Model . pojo . pojoMetaData ; public class HtmlFormatter { public static String GetHTMLTab ( ) { return \"\\t\" ; } public static String GetHTMLTabs ( int numTabs ) { int i = 0 ; String Tabs = \"\" ; while ( i < numTabs ) { Tabs = Tabs + GetHTMLTab ( ) ; i ++ ; } return Tabs ; } public static String GetHTMLNewline ( ) { return \"\\n\" ; } public static String GetHTMLMetaData ( String FormatType , String MetaDataName ) { if ( FormatType == \"tcl\" ) { return \":metadata < :definition -requirement mandatory \" + MetaDataName + \" > \\\\\" ; } return \"\" ; } public static String GetHTMLMetaData ( String FormatType , String MetaDataName , String isMandatory ) { if ( FormatType == \"tcl\" ) { if ( isMandatory == \"true\" ) { return \":metadata < :definition -requirement mandatory \" + MetaDataName + \" > \\\\\" ; } else { return \":metadata < :definition \" + MetaDataName + \" > \\\\\" ; } } return \"\" ; } public static String GetHTMLMetaDataList ( String FormatType , ArrayList < String > MetaDataNames , int Tabs ) { String Output = \"\" ; if ( MetaDataNames != null ) { Iterator < String > i = MetaDataNames . iterator ( ) ; while ( i . hasNext ( ) ) { String tmpStr = i . next ( ) ; Output = Output + GetHTMLTabs ( Tabs ) + GetHTMLMetaData ( FormatType , tmpStr ) + GetHTMLNewline ( ) ; } } return Output ; } public static String GetHTMLMetaDataList ( String FormatType , HashMap < String , pojoMetaData > MetaDataNames , int Tabs ) { String Output = \"\" ; if ( MetaDataNames != null ) { Iterator < Entry < String , pojoMetaData > > i = MetaDataNames . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Entry < String , pojoMetaData > tmpStr = i . next ( ) ; pojoMetaData tmpItem = tmpStr . getValue ( ) ; Output = Output + GetHTMLTabs ( Tabs ) + GetHTMLMetaData ( FormatType , tmpItem . getFieldVale ( pojoMetaData . MetaDataNameField ) , tmpItem . getFieldVale ( pojoMetaData . IsMandatoryField ) ) + GetHTMLNewline ( ) ; } } return Output ; } public static String GetHTMLMetaDataList ( String FormatType , HashMap < String , pojoMetaData > MetaDataNames , int Tabs , Boolean splitPublic ) { StringBuilder publicOutput = new StringBuilder ( ) ; publicOutput . append ( HtmlFormatter . GetHTMLTabs ( Tabs ) + \":public < \\\\\" + HtmlFormatter . GetHTMLNewline ( ) ) ; StringBuilder privateOutput = new StringBuilder ( ) ; privateOutput . append ( HtmlFormatter . GetHTMLTabs ( Tabs ) + \":private < \\\\\" + HtmlFormatter . GetHTMLNewline ( ) ) ; String output = \"\" ; if ( splitPublic ) { if ( MetaDataNames != null ) { Iterator < Entry < String , pojoMetaData > > i = MetaDataNames . entrySet ( ) . iterator ( ) ; int countPublic = 0 ; int countPrivate = 0 ; while ( i . hasNext ( ) ) { Entry < String , pojoMetaData > tmpStr = i . next ( ) ; pojoMetaData tmpItem = tmpStr . getValue ( ) ; if ( tmpItem . getFieldVale ( pojoMetaData . IsPublicField ) == \"true\" ) { publicOutput . append ( GetHTMLTabs ( Tabs + 1 ) + GetHTMLMetaData ( FormatType , tmpItem . getFieldVale ( pojoMetaData . MetaDataNameField ) , tmpItem . getFieldVale ( pojoMetaData . IsMandatoryField ) ) + GetHTMLNewline ( ) ) ; countPublic ++ ; } else { privateOutput . append ( GetHTMLTabs ( Tabs + 1 ) + GetHTMLMetaData ( FormatType , tmpItem . getFieldVale ( pojoMetaData . MetaDataNameField ) , tmpItem . getFieldVale ( pojoMetaData . IsMandatoryField ) ) + GetHTMLNewline ( ) ) ; countPrivate ++ ; } } if ( countPublic > 0 ) { publicOutput . append ( HtmlFormatter . GetHTMLTabs ( Tabs ) + \">\\\\\" + HtmlFormatter . GetHTMLNewline ( ) ) ; output = publicOutput . toString ( ) ; } if ( countPrivate > 0 ) { privateOutput . append ( HtmlFormatter . GetHTMLTabs ( Tabs ) + \">\\\\\" + HtmlFormatter . GetHTMLNewline ( ) ) ; output = output + privateOutput . toString ( ) ; } } return output ; } else { return GetHTMLMetaDataList ( FormatType , MetaDataNames , Tabs ) ; } } public static String GetHTMLUtilityScript ( String FormatType ) { String Output = \"\" ; Output = Output + GetHTMLTabs ( 1 ) + \"proc getMethodId { methodName } {\" + GetHTMLNewline ( ) ; Output = Output + GetHTMLTabs ( 2 ) + \"set methodId \\\"\\\"\" + GetHTMLNewline ( ) ; Output = Output + GetHTMLTabs ( 2 ) + \"set r [om.pssd.method.find :name $methodName]\" + GetHTMLNewline ( ) ; Output = Output + GetHTMLTabs ( 2 ) + \"return [xvalue id", "gt": "$r]\" + GetHTMLNewline ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7877, "input": "<s> package org . dawb . workbench . ui . views ; import java . util . ArrayList ; import java . util . List ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . PlotType ; import org . dawb . common . ui . slicing . SliceComponent ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . workbench . ui . editors . CheckableObject ; import org . dawb . workbench . ui . editors . IDatasetEditor ; import org . dawb . workbench . ui . editors . IPlotUpdateParticipant ; import org . dawb . workbench . ui . editors . PlotDataComponent ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IResourceChangeEvent ; import org . eclipse . core . resources . IResourceChangeListener ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . SashForm ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . part . FileEditorInput ; import org . eclipse . ui . part . Page ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . io . IMetaData ; public class PlotDataPage extends Page implements IPlotUpdateParticipant , IAdaptable { private final static Logger logger = LoggerFactory . getLogger ( PlotDataPage . class ) ; private IDatasetEditor editor ; private PlotDataComponent dataSetComponent ; private IResourceChangeListener resourceListener ; private SliceComponent sliceComponent ; private Composite content ; public PlotDataPage ( IDatasetEditor ed ) { this . editor = ed ; } @ Override public void createControl ( Composite parent ) { this . content = new Composite ( parent , SWT . NONE ) ; content . setLayout ( new GridLayout ( 1 , true ) ) ; final SashForm form = new SashForm ( content , SWT . VERTICAL ) ; form . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; this . dataSetComponent = new PlotDataComponent ( editor ) ; dataSetComponent . setFileName ( editor . getEditorInput ( ) . getName ( ) ) ; dataSetComponent . createPartControl ( form ) ; if ( dataSetComponent . getDataReductionAction ( ) != null ) { getSite ( ) . getActionBars ( ) . getToolBarManager ( ) . add ( dataSetComponent . getDataReductionAction ( ) ) ; getSite ( ) . getActionBars ( ) . getToolBarManager ( ) . add ( new Separator ( \"data.reduction.separator\" ) ) ; } final List < IAction > extras = new ArrayList < IAction > ( 7 ) ; extras . addAll ( dataSetComponent . getDimensionalActions ( ) ) ; for ( IAction iAction : extras ) { getSite ( ) . getActionBars ( ) . getToolBarManager ( ) . add ( iAction ) ; if ( iAction . getText ( ) != null && iAction . getText ( ) . toLowerCase ( ) . contains ( \"preference\" ) ) { getSite ( ) . getActionBars ( ) . getMenuManager ( ) . add ( iAction ) ; } } getSite ( ) . setSelectionProvider ( dataSetComponent . getViewer ( ) ) ; dataSetComponent . addSelectionListener ( new ISelectionChangedListener ( ) { @ Override public void selectionChanged ( final SelectionChangedEvent event ) { @ SuppressWarnings ( \"unchecked\" ) final List < CheckableObject > sels = ( ( StructuredSelection ) event . getSelection ( ) ) . toList ( ) ; if ( sels != null ) editor . updatePlot ( sels . toArray ( new CheckableObject [ sels . size ( ) ] ) , PlotDataPage . this , true ) ; } } ) ; try { IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; this . resourceListener = new IResourceChangeListener ( ) { public", "gt": "void resourceChanged ( IResourceChangeEvent event )", "prediction": ";\n", "label": 0}
{"id": 1691, "input": "<s> package bad . robot . refactoring . chapter1 ; public class RegularPrice extends Price { @ Override public int getPriceCode ( ) { return Movie . REGULAR ; } @ Override public double getCharge ( int daysRented ) { double amount = 2 ; if ( daysRented > 2 ) amount += ( daysRented", "gt": "- 2 ) * 1.5 ;", "prediction": ") ;\n", "label": 1}
{"id": 163, "input": "<s> public class QualifiedOuterThis2 { class TableCellEditor extends X { TableCellEditor ( ) { super ( new Object ( ) { public String xyz ( ) { return QualifiedOuterThis2 . this", "gt": ". toString ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 1708, "input": "<s> package templates . util ; import java . io . File ; import java . io . IOException ; import java . util . Iterator ; import javax . imageio . ImageIO ; import javax . imageio . ImageReader ; import javax . imageio . metadata . IIOMetadata ; import javax . imageio . stream . ImageInputStream ; import org . eclipse . emf . common . util . URI ; import org . eclipse . xtext . xdoc . xdoc . ImageRef ; import org . w3c . dom . Node ; public class PDFImageUtil { public static String calcStyle ( ImageRef ref ) throws IOException { URI uri = ref . eResource ( ) . getURI ( ) ; URI inPath = URI . createURI ( ref . getPath ( ) ) . resolve ( uri ) ; ImageInputStream img = ImageIO . createImageInputStream ( new File ( inPath . toFileString ( ) ) ) ; Iterator < ImageReader > imageReaders = ImageIO . getImageReaders ( img ) ; ImageReader ir = imageReaders . next ( ) ; ir . setInput ( img ) ; IIOMetadata imageMetadata = ir . getImageMetadata ( 0 ) ; Node n = imageMetadata . getAsTree ( \"javax_imageio_1.0\" ) ; float ppmm = 2.835f ; for ( Node cn = n . getFirstChild ( ) ; cn != null ; cn = cn . getNextSibling ( ) ) { if ( cn . getNodeName ( ) . equals ( \"Dimension\" ) ) { for ( Node ccn = cn . getFirstChild ( ) ; ccn != null ; ccn = ccn . getNextSibling ( ) ) { if ( ccn . getNodeName ( ) . equals ( \"HorizontalPixelSize\" ) ) { ppmm = 1 / Float . parseFloat ( ccn . getAttributes ( ) . item ( 0 ) . getNodeValue ( ) ) ; } } } } int width = ir . getWidth ( 0 ) ; float effectiveWidth = width / ppmm ;", "gt": "if ( effectiveWidth > 140 )", "prediction": "}\n", "label": 1}
{"id": 4240, "input": "<s> package org . ofbiz . base . container ; import org . apache . log4j . Logger ; import org . ofbiz . base . container . ContainerConfig . Container . Property ; import org . ofbiz . base . container . groovy . GroovyService ; import org . ofbiz . base . container . groovy . GroovyShellService ; public class GroovyShellContainer implements Container { private static final Logger log = Logger . getLogger ( GroovyShellContainer . class ) ; private String name ; private String configFileLocation = null ; private GroovyService gsh = null ; @ Override public void init ( String [ ] args , String name , String configFile ) { this . name = name ; configFileLocation = configFile ; } @ Override public boolean start ( ) throws ContainerException { int port = getTelnetPort ( ) ; gsh = new GroovyShellService ( port ) ; gsh . launchInBackground ( ) ; log . info ( \"Started Groovy telnet service on port [\" + port + \"].\" ) ; log . info ( \"NOTICE: The Groovy service port is not secure.", "gt": "Please protect it.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1712, "input": "<s> package org . jscsi . target", "gt": ". scsi . cdb ;", "prediction": ";\n", "label": 1}
{"id": 3918, "input": "<s> package me . moocar . logbackgelf ; import org . junit . Before ; import org . junit . Test ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Arrays ; import java . util . List ; import static org . junit . Assert . * ; public class ChunkTest { private PayloadChunker createsPackets ; private static final byte [ ] CHUNKED_GELF_ID = new byte [ ] { 0x1e , 0x0f } ; private static final int CHUNKED_GELF_ID_LENGTH = CHUNKED_GELF_ID . length ; public final static int SEQ_NUM_LENGTH = 2 ; public final static int SEQ_LENGTH = 2 ; public final static int MESSAGE_ID_LENGTH = 8 ; private static final int HEADER_LENGTH = CHUNKED_GELF_ID_LENGTH + MESSAGE_ID_LENGTH + SEQ_NUM_LENGTH + SEQ_LENGTH ; private static final int DEFAULT_THRESHOLD = 3 ; private static final int MAX_CHUNKS = 127 ; @ Before public void setup ( ) throws NoSuchAlgorithmException { createsPackets = new PayloadChunker ( DEFAULT_THRESHOLD , MAX_CHUNKS , new MessageIdProvider ( MESSAGE_ID_LENGTH , MessageDigest . getInstance ( \"MD5\" ) , \"localhost\" ) , new ChunkFactory ( CHUNKED_GELF_ID , true ) ) ; } @ Test public void test1ByteMoreThanThreshold ( ) { List < byte [ ] > packets = go ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } ) ; assertEquals ( 2 , packets . size ( ) ) ; byte [ ] firstPacket = packets . get ( 0 ) ; assertTrue ( DEFAULT_THRESHOLD != firstPacket . length ) ; assertEquals ( DEFAULT_THRESHOLD + HEADER_LENGTH , firstPacket . length ) ; assertArrayEquals ( CHUNKED_GELF_ID , Arrays . copyOfRange ( firstPacket , 0 , CHUNKED_GELF_ID_LENGTH ) ) ; int count = 0 ; for ( byte [ ] packet : packets ) { assertEquals ( count , getSeqNumber ( packets , count ) ) ; assertEquals ( 2 , getNumChunks ( packet ) ) ; count ++ ; } } @ Test public void testThreeChunks ( ) { List < byte [ ] > packets = go ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ) ; assertEquals ( 3 , packets . size ( ) ) ; for ( byte [ ] packet : packets ) { assertEquals ( DEFAULT_THRESHOLD + HEADER_LENGTH , packet . length ) ; } } @ Test public void testMessageIdsDifferent ( ) { List < byte [ ] > packets1 = go ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ) ; List < byte [ ] > packets2 = go ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ) ; byte [ ] messageId1 = Arrays . copyOfRange ( packets1 . get ( 0 ) , 2 , 10 ) ; byte [ ] messageId2 = Arrays . copyOfRange ( packets2 . get ( 0 ) , 2 , 10 ) ; assertFalse ( Arrays . equals ( messageId1 , messageId2 ) ) ; } @ Test public void shouldCutoffAfterMaxChunks ( ) { byte [ ] payload = createMassivePayload ( ) ; List < byte [ ] > packets = go ( payload ) ; assertEquals ( MAX_CHUNKS , packets .", "gt": "size ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1726, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture ; import java . lang . reflect . Field ; import javax . servlet . http . HttpSession ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleUtil ; import org . eclipse . rap . rwt . internal . lifecycle . UITestUtil ; import org . eclipse . rap . rwt . internal . service . SessionStoreImpl ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . swt . widgets . Display ; @ SuppressWarnings ( \"restriction\" ) public class ClusterTestHelper { public static void enableUITests ( boolean enable ) { try { Field field = UITestUtil . class . getDeclaredField ( \"enabled\" ) ; field . setAccessible ( true ) ; field . set ( null , Boolean . valueOf ( enable ) ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Failed to change enablement of UI Tests\" , e ) ; } } public static HttpSession getFirstSession ( IServletEngine servletEngine ) { return servletEngine . getSessions ( ) [ 0 ] ; }", "gt": "public static ISessionStore getFirstSessionStore ( IServletEngine servletEngine )", "prediction": "}\n", "label": 1}
{"id": 4875, "input": "<s> package pkg1 ; public class C6 { public UsedClass fieldInC6 ; public UsedClass", "gt": "methodInC6 ( UsedClass p )", "prediction": "( )\n", "label": 0}
{"id": 1729, "input": "<s> package org . apache . lucene . store ; import java . io . IOException ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; public class ChecksumIndexInput extends IndexInput { IndexInput main ; Checksum digest ; public ChecksumIndexInput ( IndexInput main ) { this . main = main ; digest = new CRC32 ( ) ; } public byte readByte ( ) throws IOException { final byte b = main . readByte ( ) ; digest . update ( b ) ; return b ; } public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { main . readBytes ( b , offset , len ) ; digest . update ( b , offset , len ) ; } public long getChecksum ( ) { return digest . getValue ( ) ; } public void close ( ) throws IOException { main . close ( ) ; } public long getFilePointer ( ) { return main . getFilePointer ( ) ; } public void seek ( long pos ) {", "gt": "throw new RuntimeException ( \"not allowed\" ) ;", "prediction": "\n", "label": 1}
{"id": 7916, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Author ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Resource ; public class AuthorImpl extends StatusStatusSheetAttributeImpl implements Author { protected Resource resource ; protected AuthorImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getAuthor ( ) ; } public Resource getResource ( ) { if ( resource != null && resource . eIsProxy ( ) ) { InternalEObject oldResource = ( InternalEObject ) resource ; resource = ( Resource ) eResolveProxy ( oldResource ) ; if ( resource != oldResource ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . AUTHOR__RESOURCE , oldResource , resource ) ) ; } } return resource ; } public Resource basicGetResource ( ) { return resource ; } public void setResource ( Resource newResource ) { Resource oldResource = resource ; resource = newResource ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . AUTHOR__RESOURCE , oldResource , resource ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . AUTHOR__RESOURCE : if ( resolve ) return getResource ( ) ; return basicGetResource ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . AUTHOR__RESOURCE : setResource ( ( Resource ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . AUTHOR__RESOURCE : setResource ( ( Resource ) null ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean", "gt": "eIsSet ( int featureID )", "prediction": "( )\n", "label": 0}
{"id": 1734, "input": "<s> package org . eclipse . swt . events ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Shell ; public class ShellEvent_Test extends TestCase { private static final String SHELL_CLOSED = \"shellClosed|\" ; private String log ; private Display display ; private Shell shell ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; log = \"\" ; display = new Display ( ) ; shell = new Shell ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testUntypedEventConstructor ( ) throws Exception { Event event = new Event ( ) ; event . display = display ; event . widget = shell ; event . doit = false ; event . data = new Object ( ) ; ShellEvent shellEvent = new ShellEvent ( event ) ; EventTestHelper . assertFieldsEqual ( shellEvent , event ) ; } public void testAddRemoveClosedListener ( ) { ShellListener listener = new ShellAdapter ( ) { public void shellClosed ( ShellEvent event ) { log += SHELL_CLOSED ; } } ; shell . addShellListener ( listener ) ; shell . close ( ) ; assertEquals ( SHELL_CLOSED , log ) ; } public void testRemoveCloseListener ( ) { ShellListener listener = new ShellAdapter ( ) { public void shellClosed ( ShellEvent event ) { log += SHELL_CLOSED ; } } ; shell . addShellListener ( listener ) ; shell . removeShellListener ( listener ) ; shell . close ( ) ; assertEquals ( \"\" , log ) ; } public void testDenyClose ( ) { ShellListener listener = new ShellAdapter ( ) { public void shellClosed ( ShellEvent event ) { assertTrue (", "gt": "event . doit ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5202, "input": "<s> package com . mapr . storm ; import backtype . storm . tuple . Tuple ; import com . google . common . collect . Sets ; import org . junit . Test ; import java . io . FileNotFoundException ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import static org . junit . Assert . assertEquals ; public class CounterBoltTest { @ Test public void testShort ( ) throws FileNotFoundException , InterruptedException { CounterBolt cb = new CounterBolt ( 100 , 5 ) ; final Fake . Clock clock = Fake . clock ( ) ; List < Fake . AnchoredTuple > out = new ArrayList < Fake . AnchoredTuple > ( ) ; Set < Tuple > acks = Sets . newHashSet ( ) ; Set < Tuple > failures = Sets . newHashSet ( ) ; cb . prepare ( null , null , Fake . collector ( out , acks , failures ) ) ; Tuple t1 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x1\" ) ; Tuple t2 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x2\" ) ; Tuple t3 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x3\" ) ; Tuple t4 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x4\" ) ; Tuple t5 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x5\" ) ; Tuple t6 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x6\" ) ; Tuple t7 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x7\" ) ; Tuple t8 = Fake . tuple ( \"key\" , \"t1\" , \"value\" , \"x8\" ) ; cb . execute ( t1 ) ; clock . advance ( 10 ) ; cb . execute ( t1 ) ; clock . advance ( 10 ) ; cb . execute ( t2 ) ; clock . advance ( 10 ) ; cb . execute ( t1 ) ; clock . advance ( 10 ) ; cb .", "gt": "execute ( t3 ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 1745, "input": "<s> package org . w3c . css . sac ; public interface Condition { public static final short SAC_AND_CONDITION = 0 ; public static final short SAC_OR_CONDITION = 1 ; public static final short SAC_NEGATIVE_CONDITION = 2 ; public static final short SAC_POSITIONAL_CONDITION = 3 ; public static final short SAC_ATTRIBUTE_CONDITION = 4 ; public static final short SAC_ID_CONDITION = 5 ; public static final short SAC_LANG_CONDITION = 6 ; public static final short SAC_ONE_OF_ATTRIBUTE_CONDITION = 7 ;", "gt": "public static final short SAC_BEGIN_HYPHEN_ATTRIBUTE_CONDITION = 8 ;", "prediction": "}\n", "label": 1}
{"id": 9404, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleSubNodeImpl extends SimpleNodeImpl implements SimpleSubNode { protected SimpleSubNodeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_SUB_NODE ; } @ SuppressWarnings ( \"unchecked\" ) public EList < SimpleChildNode > getChildren ( ) { return ( EList < SimpleChildNode > ) eGet ( SimplemappingsPackage", "gt": ". Literals . SIMPLE_PARENT_NODE__CHILDREN , true ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1752, "input": "<s> package org . eclipse . ui . presentations ; import org . eclipse . swt . graphics . Rectangle ; public final class StackDropResult { private Rectangle snapRectangle ; private Object cookie ; public StackDropResult ( Rectangle snapRectangle , Object cookie ) { this", "gt": ". snapRectangle = snapRectangle ;", "prediction": ";\n", "label": 1}
{"id": 5427, "input": "<s> package org . gk . engine . client . utils ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . JsonConvert ; import com . extjs . gxt . ui . client . util . Format ; import com . google . gwt . json . client . JSONParser ; import com . google . gwt . json . client . JSONValue ; public class StringUtils { public static EventObject toEventObject ( String eventId , String jsonString ) { JSONValue val = JSONParser . parseLenient ( jsonString ) ; EventObject eo = null ; if ( jsonString . startsWith ( \"{\" ) ) { eo = new EventObject ( eventId , JsonConvert . jsonToMap ( val . isObject ( ) ) ) ; } else if ( jsonString . startsWith ( \"[\" ) ) { eo = new EventObject ( eventId , JsonConvert . jsonToList ( val .", "gt": "isArray ( ) ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1772, "input": "<s> package org . restlet . test . resource ; import org . restlet . resource . Get ; public interface MyResource13 { @ Get ( \"?shallow\" )", "gt": "public LightContact retrieveLight ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8658, "input": "<s> package org . gk . ui . client . com . utils ; import java . util . Iterator ; import java . util . Map ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanel . TreeNode ; import com . google . gwt . xml . client . Element ; import com . google . gwt . xml . client . Node ; public class TreeUtils { private static void appendNodeId ( TreeNode node , StringBuffer sb ) { String id = node . getModel ( ) . get ( gkXMLTreePanelIC . ID ) ; if ( id == null || id . equals ( \"\" ) ) { id = node . getModel ( ) . get ( gkXMLTreePanelIC . NAME ) ; } sb . append ( id ) ; } public static String getNodeId ( TreeNode node ) { int idx = - 1 ; StringBuffer sb = new StringBuffer ( ) ; appendNodeId ( node , sb ) ; if ( node . getParent ( ) != null ) { idx = node . getParent ( ) . indexOf ( node ) ; } return sb . append ( \":\" ) . append ( idx ) + \"\" ; } public static String getNodeId ( TreeNode putNode , TreeNode node , int seq ) { StringBuffer sb = new StringBuffer ( ) ; int idx = seq ; if ( idx >= 0 ) { idx = putNode . getParent ( ) . indexOf ( putNode ) + seq ; putNode = putNode . getParent ( ) ; } appendNodeId ( putNode , sb ) ; return sb . append ( \":\" ) . append ( idx ) + \"\" ; } public static String getPath ( TreeNode node ) { int idx = - 1 ; StringBuffer sb = new StringBuffer ( ) ; _getPath ( node , sb ) ; if ( node . getParent ( ) != null ) { idx = node . getParent ( ) . indexOf ( node ) ; } return sb . append ( \":\" ) . append ( idx ) + \"\" ; } public static String getPath ( TreeNode putNode , TreeNode node , int seq ) { StringBuffer sb = new StringBuffer ( ) ; int idx = seq ; if ( idx >= 0 ) { idx = putNode . getParent ( ) . indexOf ( putNode ) + seq ; putNode = putNode . getParent ( ) ; } _getPath ( putNode , sb ) ; String nodeName = node . getModel ( ) . get ( gkXMLTreePanelIC . NAME ) ; return sb . append ( '/' ) . append ( nodeName ) . append ( \":\" ) . append ( idx ) + \"\" ; } private static void _getPath ( TreeNode node , StringBuffer sbuf ) { String name = node . getModel ( ) . get ( gkXMLTreePanelIC . NAME ) ; sbuf . insert ( 0 , \"/\" + name ) ; if ( node . getParent ( ) != null ) { _getPath ( node . getParent ( ) , sbuf ) ; } } public static void updateSelectNode ( gkXMLTreePanelIC tree , Map v ) { ModelData md = tree . getTree ( ) . getSelectionModel ( ) . getSelectedItem ( ) ; Node parentNode = md . get ( gkXMLTreePanelIC . NODE ) ; String name = ( String ) v . get ( gkXMLTreePanelIC . NAME ) ; Element newNode = parentNode . getOwnerDocument ( ) . createElement ( name ) ; parentNode . appendChild ( newNode ) ; Iterator < String > it", "gt": "= v . keySet ( ) . iterator ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1801, "input": "<s> package org . jscsi . parser . datasegment ; import static org . testng . AssertJUnit . assertFalse ; import static org . testng . AssertJUnit . assertEquals ; import static org . testng . AssertJUnit . assertNotNull ; import static org . testng . AssertJUnit . assertTrue ; import org . testng . annotations . Test ; import java . nio . ByteBuffer ; public final class TextParameterDataSegmentTest { private static final int CHUNK_SIZE = 3 ; @ Test public final void testConstructor1 ( ) { final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( dataSegment ) ; assertEquals ( 0 , dataSegment . getLength ( ) ) ; } @ Test public final void testClear ( ) throws Exception { final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( dataSegment ) ; assertTrue ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; dataSegment . add ( OperationalTextKey . HEADER_DIGEST , \"Yes\" ) ; assertFalse ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; dataSegment . clear ( ) ; assertNotNull ( dataSegment ) ; assertTrue ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; } @ Test public final void testAdd ( ) throws Exception { final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( dataSegment ) ; dataSegment . add ( OperationalTextKey . DATA_DIGEST , \"Yes\" ) ; dataSegment . add ( OperationalTextKey . HEADER_DIGEST , \"No\" ) ; dataSegment . add ( OperationalTextKey . MAX_CONNECTIONS , \"50\" ) ; assertEquals ( 3 , dataSegment . getSettings ( ) . entrySet ( ) . size ( ) ) ; assertFalse ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; } @ Test public final void testAddAll ( ) throws Exception { final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( dataSegment ) ; dataSegment . add ( OperationalTextKey . DATA_DIGEST , \"Yes\" ) ; dataSegment . add ( OperationalTextKey . HEADER_DIGEST , \"No\" ) ; dataSegment . add ( OperationalTextKey . MAX_CONNECTIONS , \"50\" ) ; assertEquals ( 3 , dataSegment . getSettings ( ) . entrySet ( ) . size ( ) ) ; assertFalse ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; final TextParameterDataSegment anotherDataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( anotherDataSegment ) ; anotherDataSegment . addAll ( dataSegment . getSettings ( ) ) ; assertNotNull ( anotherDataSegment ) ; assertEquals ( 3 , anotherDataSegment . getSettings ( ) . entrySet ( ) . size ( ) ) ; assertFalse ( anotherDataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; } @ Test public final void testEquals ( ) throws Exception { final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( dataSegment ) ; assertEquals ( 0 , dataSegment . getLength ( ) ) ; dataSegment . add ( OperationalTextKey . DATA_DIGEST , \"Yes\" ) ; dataSegment . add ( OperationalTextKey . HEADER_DIGEST , \"No\" ) ; dataSegment . add ( OperationalTextKey . MAX_CONNECTIONS , \"50\" ) ; assertEquals ( 3 , dataSegment . getSettings ( ) . entrySet ( ) . size ( ) ) ; assertFalse ( dataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; final TextParameterDataSegment anotherDataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ; assertNotNull ( anotherDataSegment ) ; anotherDataSegment . add ( OperationalTextKey . HEADER_DIGEST , \"No\" ) ; anotherDataSegment . add ( OperationalTextKey . DATA_DIGEST , \"Yes\" ) ; anotherDataSegment . add ( OperationalTextKey . MAX_CONNECTIONS , \"50\" ) ; assertEquals ( 3 , anotherDataSegment . getSettings ( ) . entrySet ( ) . size ( ) ) ; assertFalse ( anotherDataSegment . getSettings ( ) . entrySet ( ) . isEmpty ( ) ) ; assertTrue ( dataSegment . equals ( anotherDataSegment ) ) ; } @ Test public final void testUnEquals ( ) throws Exception {", "gt": "final TextParameterDataSegment dataSegment = new TextParameterDataSegment ( CHUNK_SIZE ) ;", "prediction": "\n", "label": 1}
{"id": 8585, "input": "<s> package org . ofbiz . crowd ; import java . rmi . RemoteException ; import javax . xml . rpc . ServiceException ; import org . ofbiz . crowd . security . SecurityServerHttpBindingStub ; import org . ofbiz . crowd . security . SecurityServerLocator ; import org . ofbiz . crowd . user . UserWrapper ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilProperties ; import com . atlassian . crowd . integration . authentication . AuthenticatedToken ; import com . atlassian . crowd . integration . authentication . ApplicationAuthenticationContext ; import com . atlassian . crowd . integration . authentication . PasswordCredential ; import com . atlassian . crowd . integration . authentication . ValidationFactor ; import com . atlassian . crowd . integration . soap . SOAPPrincipal ; import com . atlassian . crowd . integration . exception . InvalidAuthorizationTokenException ; import com . atlassian . crowd . integration . exception . ObjectNotFoundException ; import com . atlassian . crowd . integration . exception . InvalidAuthenticationException ; import com . atlassian . crowd . integration . exception . InactiveAccountException ; import com . atlassian . crowd . integration . exception . ApplicationAccessDeniedException ; public abstract class CrowdWorker { private static final String module = CrowdWorker . class . getName ( ) ; protected String callAuthenticate ( String user , String password ) throws RemoteException { SecurityServerHttpBindingStub stub = getStub ( ) ; AuthenticatedToken token = getToken ( stub ) ; String userToken ; try { userToken = stub . authenticatePrincipalSimple ( token , user , password ) ; } catch ( InvalidAuthenticationException e ) { return null ; } catch ( InvalidAuthorizationTokenException e ) { Debug . logError ( e , module ) ; throw e ; } catch ( ApplicationAccessDeniedException e ) { Debug . logError ( e , module ) ; throw e ; } catch ( InactiveAccountException e ) { return null ; } catch ( RemoteException e ) { Debug . logError ( e , module ) ; throw e ; } return userToken ; } protected UserWrapper callGetUser ( String user ) throws RemoteException { SecurityServerHttpBindingStub stub = getStub ( ) ; AuthenticatedToken token = getToken ( stub ) ; SOAPPrincipal principal ; try { principal = stub . findPrincipalByName ( token , user ) ; } catch ( InvalidAuthorizationTokenException e ) { Debug . logError ( e , module ) ; throw e ; } catch ( ObjectNotFoundException e ) { Debug . logError ( e , module ) ; throw e ; } catch ( RemoteException e ) { Debug . logError ( e , module ) ; throw e ; } String [ ] groups ; try { groups = stub . findGroupMemberships ( token , user ) ; } catch ( InvalidAuthorizationTokenException e ) { Debug . logError ( e , module ) ; throw e ; } catch ( ObjectNotFoundException e ) { groups = new String [ 0 ] ; } catch ( RemoteException e ) { Debug . logError ( e , module ) ; throw e ; } return new UserWrapper ( principal , groups ) ; } protected void callUpdatePassword ( String user , String password ) throws RemoteException { PasswordCredential credential = new PasswordCredential ( ) ; credential . setCredential ( password ) ; credential . setEncryptedCredential ( false ) ; SecurityServerHttpBindingStub stub = getStub ( ) ; AuthenticatedToken token = getToken ( stub ) ; try { stub . updatePrincipalCredential (", "gt": "token , user , credential ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1815, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . marshaling ; public abstract class AbstractDefaultXMLMarshaler { protected static final String publisherSerializerNS = \"http://www.nuxeo.org/publisher\" ; protected static final String publisherSerializerNSPrefix = \"nxpub\" ; protected String cleanUpXml ( String data ) { if ( data == null ) { return null ; } if ( data . startsWith", "gt": "( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 1284, "input": "<s> package org . gk . engine . client . build ; import java . util . List ; import jfreecode . gwt . event . client . bus . EventBusIfc ; import jfreecode . gwt . event . client . bus . JsonConvert ; import org . gk . engine . client . IEngine ; import org . gk . engine . client . event . EventCenter ; import org . gk . engine . client . event . EventListener ; import org . gk . engine . client . gen . UIGen ; import org . gk . engine . client . utils . IRegExpUtils ; import org . gk . engine . client . utils . NodeUtils ; import org . gk . ui . client . com . IC ; import com . extjs . gxt . ui . client . core . XDOM ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . fx . Resizable ; import com . extjs . gxt . ui . client . widget . BoxComponent ; import com . extjs . gxt . ui . client . widget . Component ; import com . google . gwt . json . client . JSONArray ; import com . google . gwt . json . client . JSONObject ; import com . google . gwt . json . client . JSONParser ; import com . google . gwt . json . client . JSONValue ; import com . google . gwt . xml . client . Node ; public abstract class XComponent implements UIGen { public static final String DATA = \"_gk_data\" ; protected EventBusIfc bus = IEngine . bus ; protected String tag ; protected String content ; protected String id , type ; protected String width , height , enable , visible ; protected String init , bean , borders ; protected String tabIndex , style , title , clazz ; protected String resizable , preserveRatio , data ; protected String maxHeight , maxWidth , minHeight , minWidth ; protected Node node ; protected List widgets ; public XComponent ( ) { } public XComponent ( Node node , List widgets ) { this . node = node ; this . widgets = widgets ; tag = node . getNodeName ( ) ; id = getAttribute ( \"id\" , tag + \"-\" + XDOM . getUniqueId ( ) ) ; type = getAttribute ( \"type\" , \"unknownComType\" ) ; width = getAttribute ( \"width\" , \"\" ) ; height = getAttribute ( \"height\" , \"\" ) ; enable = getAttribute ( \"enable\" , \"true\" ) ; visible = getAttribute ( \"visible\" , \"true\" ) ; init = getAttribute ( \"init\" , \"\" ) ; bean = getAttribute ( \"bean\" , \"\" ) ; borders = getAttribute ( \"borders\" , \"false\" ) ; tabIndex = getAttribute ( \"tabIndex\" , \"\" ) ; style = getAttribute ( \"style\" , \"\" ) ; clazz = getAttribute ( \"class\" , \"_none_\" ) ; title = getAttribute ( \"title\" , \"\" ) ; data = getAttribute ( \"data\" , \"\" ) ; resizable = getAttribute ( \"resizable\" , \"false\" ) ; preserveRatio = getAttribute ( \"preserveRatio\" , \"false\" ) ; maxHeight = getAttribute ( \"maxHeight\" , \"\" ) ; maxWidth = getAttribute ( \"maxWidth\" , \"\" ) ; minHeight = getAttribute ( \"minHeight\" , \"\" ) ; minWidth = getAttribute ( \"minWidth\" , \"\" ) ; EngineDataStore . addUIGenNode ( id , this ) ; } public Object getData ( ) { try { char startChar = data . length ( ) > 0 ? data . charAt ( 0 ) : ' ' ; if ( startChar == '{' || startChar == '[' ) { JSONValue jsonObj = JSONParser . parseLenient ( data ) ; if ( jsonObj instanceof JSONObject ) { return JsonConvert . jsonToMap ( ( JSONObject ) jsonObj ) ; } else { return JsonConvert . jsonToList ( ( JSONArray ) jsonObj ) ; } } else { return data ; } } catch ( Exception e ) { return \"JSONParser exception!\" + e . getMessage ( ) + \",data [\" + data + \"]\" ; } } public String getTag ( ) { return tag ; } public String getContent ( ) { return content ; } public String getId ( ) { return id ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getWidth ( ) { return width ; } public String getHeight ( ) { return height ; } public String getEnable ( ) { return enable ; } public void setEnable ( String enable ) { this . enable = enable ; } public String getVisible ( ) { return visible ; } public void setVisible ( String hide ) { this . visible = hide ; } public String getInit ( ) { return init ; } public String getBean ( ) { return bean ; } public String getBorders ( ) { return borders ; } public String getTabIndex ( ) { return tabIndex ; } public String getStyle ( ) { return style ; } public String getClazz ( ) { return clazz ; } public String getTitle ( ) { return title ; } public Node getNode ( ) { return node ; } public String getResizable ( ) { return resizable ; } public String getPreserveRatio ( ) { return preserveRatio ; } public String getMaxHeight ( ) { return maxHeight ; } public String getMaxWidth ( ) { return maxWidth ; } public String getMinHeight ( ) { return minHeight ; } public String getMinWidth ( ) { return minWidth ; } public List getWidgets ( ) { return widgets ; } @ Override public void init ( ) { EventCenter . exec ( id , init , this , null ) ; } public void onInfo ( String eventId , String content ) { Object info ; if ( JsonConvert . isJSONString ( content ) ) { info = JsonConvert . jsonString2Object ( content ) ; } else { info = content ; } Component com = getComponent ( ) ; if ( com instanceof IC ) { ( ( IC ) com ) . setInfo ( info ) ; } } protected void initComponent ( Component com ) { com . setId ( id ) ; if ( !", "gt": "width . equals ( \"\" ) )", "prediction": ") ;\n", "label": 0}
{"id": 1841, "input": "<s> package org . eclipse . ui . tests . operations ; import org . eclipse . core . commands . operations . IOperationHistory ; import org . eclipse . core . commands . operations . IUndoContext ; import org . eclipse . core . commands . operations . IUndoableOperation ; import org . eclipse . core . commands . operations . ObjectUndoContext ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class WorkbenchOperationHistoryTests extends UITestCase { IUndoContext context , contextA , contextB ; IOperationHistory history ; IUndoableOperation op1 , op2 , op3 , op4 , op5 , op6 ; public WorkbenchOperationHistoryTests ( String name ) { super ( name ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; history = PlatformUI . getWorkbench ( ) . getOperationSupport ( ) . getOperationHistory ( ) ; context = PlatformUI . getWorkbench ( ) . getOperationSupport ( ) . getUndoContext ( ) ; contextA = new ObjectUndoContext ( \"A\" ) ; contextB = new ObjectUndoContext ( \"B\" ) ; op1 = new TestOperation ( \"op1\" ) ; op1 . addContext ( context ) ; op2 = new TestOperation ( \"op2\" ) ; op2 . addContext ( context ) ; op2 . addContext ( contextA ) ; op3 = new TestOperation ( \"op3\" ) ; op3 . addContext ( contextB ) ; op4 = new TestOperation ( \"op4\" ) ; op4 . addContext ( context ) ; op5 = new TestOperation ( \"op5\" ) ; op5 . addContext ( contextA ) ; op6 = new TestOperation ( \"op6\" ) ; op6 . addContext ( context ) ; op6 . addContext ( contextB ) ; history . execute ( op1 , null , null ) ; history . execute ( op2 , null , null ) ; history . execute ( op3 , null , null ) ; history . execute ( op4 , null , null ) ; history . execute ( op5 , null , null ) ; history . execute (", "gt": "op6 , null , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9778, "input": "<s> enum E2 { A ( 1 ) , B ( 2 ) { } , C ( 3 ) { void m ( ) { } } ;", "gt": "E2 ( int i )", "prediction": "}\n", "label": 0}
{"id": 1849, "input": "<s> package org . fuzzydb . attrs . layout ; import org . fuzzydb . attrs . simple . FloatConstraint ; import org . fuzzydb . attrs . simple . FloatValue ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; public class FloatConstraintCodec extends LayoutConstraintCodec { private static final int FLOAT_MIN_VALUE_OFFSET = 0 ; private static final int FLOAT_MAX_VALUE_OFFSET = 1 ; private static final int FLOAT_CONSTRAINT_LENGTH = 2 ; private static FloatConstraintCodec instance = null ; public static synchronized FloatConstraintCodec getInstance ( ) { if ( instance == null ) { instance = new FloatConstraintCodec ( ) ; } return instance ; } @ Override public void encode ( LayoutAttrMap < IAttributeConstraint > map , int attrId , Object value ) { int index = map . getIndexForFloatsWrite ( attrId , FLOAT_CONSTRAINT_LENGTH ) ; FloatConstraint constraint = ( FloatConstraint ) value ; if ( constraint . isIncludesNotSpecified ( ) ) { ( ( LayoutConstraintMap ) map ) . setIncludesNotSpecified ( attrId ) ; } map . getFloats ( ) [ index + FLOAT_MIN_VALUE_OFFSET ] = constraint . getMin ( ) ; map . getFloats ( ) [ index + FLOAT_MAX_VALUE_OFFSET ] = constraint . getMax ( ) ; } @ Override public IAttributeConstraint getDecoded ( LayoutAttrMap < IAttributeConstraint > map , int attrId ) { int index = map . getIndexQuick ( attrId ) ; boolean inclNS = ( ( LayoutConstraintMap ) map ) . getIncludesNotSpecified ( attrId ) ; float min = map . getFloats ( ) [ index + FLOAT_MIN_VALUE_OFFSET ] ; float max = map . getFloats ( ) [ index + FLOAT_MAX_VALUE_OFFSET ] ; return new FloatConstraint ( attrId , min , max , inclNS ) ; } @ Override protected boolean expandInternal ( LayoutConstraintMap map , IAttribute attr , int attrId ) { float v = ( ( FloatValue ) attr ) . getValue ( ) ; int index = map . getIndexQuick ( attrId ) ; float min =", "gt": "map . getFloats ( ) [ index + FLOAT_MIN_VALUE_OFFSET ] ;", "prediction": ";\n", "label": 1}
{"id": 8588, "input": "<s> package org . ofbiz . catalina . container ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; import javax . net . ssl . TrustManager ; import javax . net . ssl . X509TrustManager ; import org . apache . tomcat . util . net . AbstractEndpoint ; import org . apache . tomcat . util . net . ServerSocketFactory ; import org . apache . tomcat . util . net . jsse . JSSEImplementation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . SSLUtil ; import org . ofbiz . base . util . UtilValidate ; public class SSLImpl extends JSSEImplementation { public static final String module = SSLImpl . class . getName ( ) ; protected ServerSocketFactory ssFactory = null ; protected TrustManager [ ] allow ; public SSLImpl ( ) throws ClassNotFoundException { super ( ) ; this . allow = new TrustManager [ ] { new AllowTrustManager ( ) } ; Debug . logInfo ( \"SSLImpl loaded; using custom ServerSocketFactory\" , module ) ; } @ Override public ServerSocketFactory getServerSocketFactory ( AbstractEndpoint endpoint ) { if ( UtilValidate . isEmpty (", "gt": "this . ssFactory ) )", "prediction": ") ;\n", "label": 0}
{"id": 1851, "input": "<s> package com . onarandombox . MultiversePortals . commands ; import java . util . List ; import org . bukkit . ChatColor ; import org . bukkit . command . CommandSender ; import org . bukkit . entity . Player ; import org . bukkit . inventory . ItemStack ; import org . bukkit . permissions . PermissionDefault ; import com . onarandombox . MultiversePortals . MultiversePortals ; public class WandCommand extends PortalCommand { public WandCommand ( MultiversePortals plugin ) { super ( plugin ) ; this . setName ( \"Gives a Portal Creation Wand\" ) ; this . setCommandUsage ( \"/mvp wand\" ) ; this . setArgRange ( 0 , 1 ) ; this . addKey ( \"mvp wand\" ) ; this . addKey ( \"mvpwand\" ) ; this . addKey ( \"mvpw\" ) ; this . setPermission ( \"multiverse.portal.givewand\" , \"Gives you the wand that MV uses. This will only work if you are NOT using WorldEdit.\" , PermissionDefault . OP ) ; } @ Override public void runCommand ( CommandSender sender , List < String > args ) { if ( args . size ( ) > 0 ) { String arg = args . get ( 0 ) ; if ( arg . equals ( \"enable\" ) ) { this . plugin . setWandEnabled ( true ) ; } else if ( arg . equals ( \"disable\" ) ) { this . plugin . setWandEnabled ( false ) ; } else if ( arg . equals ( \"toggle\" ) ) { this . plugin . setWandEnabled ( ! this . plugin . isWandEnabled ( ) ) ; } else { sender . sendMessage ( ChatColor . RED + \"You must specify one of 'enable,' 'disable,' or 'toggle!'\" ) ; } return ; } if ( sender instanceof Player ) { Player p = ( Player ) sender ; if ( this . plugin . getWEAPI ( ) != null ) { p . sendMessage ( ChatColor . GREEN + \"Cool!\" + ChatColor . WHITE + \" You're using\" + ChatColor . AQUA + \" WorldEdit! \" ) ; p . sendMessage ( \"Just use \" + ChatColor . GOLD + \"the WorldEdit wand \" + ChatColor . WHITE + \"to perform portal selections!\" ) ; return ; } int itemType = this . plugin . getMainConfig ( ) . getInt ( \"wand\" , MultiversePortals . DEFAULT_WAND ) ; ItemStack wand = new ItemStack ( itemType , 1 ) ; if ( p . getItemInHand ( ) . getAmount ( ) == 0 ) { p . setItemInHand ( wand ) ; p . sendMessage ( \"You have been given a \" + ChatColor . GREEN + \"Multiverse Portal Wand(\" + wand .", "gt": "getType ( ) + \")!\" ) ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 6682, "input": "<s> import java . io . PrintStream ; class SynthName1 { public static void main ( String args [ ] ) { run ( args , System . out ) ; } public static void run ( String args [ ] , PrintStream out ) { int res1 , res2 ; Intf ob = meth ( 1 , 2 ) ; res1 = ob . getFirst ( ) ; res2 = ob . getSecond ( ) ; if ( res1 == 1 && res2 == 2 ) return ; out . println ( \"Failed:  res1=\" + res1 + \", res2=\" + res2 ) ; throw new Error ( \"test failed!\" ) ; } interface Intf { int getFirst ( ) ; int getSecond ( ) ; } static Intf meth ( final int prm1 , final int zzz ) { class InnClass implements Intf { int val$prm1 = prm1 ; int val$zzz = zzz ; int locVar ; public int getFirst ( ) { locVar = val$prm1 ; return prm1 ; }", "gt": "public int getSecond ( )", "prediction": "}\n", "label": 0}
{"id": 1861, "input": "<s> package org . eclipse . rap . rwt ; public abstract class SessionSingletonBase { public static < T > T", "gt": "getInstance ( Class < T > type )", "prediction": "\n", "label": 1}
{"id": 6341, "input": "<s> package dk . brics . automaton ; import java . util . regex . MatchResult ; public class AutomatonMatcher implements MatchResult { AutomatonMatcher ( final CharSequence chars , final RunAutomaton automaton ) { this . chars = chars ; this . automaton = automaton ; } private final RunAutomaton automaton ; private final CharSequence chars ; private int matchStart = - 1 ; private int matchEnd = - 1 ; public boolean find ( ) { int begin ; switch ( getMatchStart ( ) ) { case - 2 : return false ; case - 1 : begin = 0 ; break ; default : begin = getMatchEnd ( ) ; if ( begin == getMatchStart ( ) ) { begin += 1 ; if ( begin > getChars ( ) . length ( ) ) { setMatch ( - 2 , - 2 ) ; return false ; } } } int match_start ; int match_end ; if ( automaton . isAccept ( automaton . getInitialState ( ) ) ) { match_start = begin ; match_end = begin ; } else { match_start = - 1 ; match_end = - 1 ; } int l = getChars ( ) . length ( ) ; while ( begin < l ) { int p = automaton . getInitialState ( ) ; for ( int i = begin ; i < l ; i ++ ) { final int new_state = automaton . step ( p , getChars ( ) . charAt ( i ) ) ; if ( new_state == - 1 ) { break ; } else if ( automaton . isAccept ( new_state ) ) { match_start = begin ; match_end = ( i + 1 ) ; } p = new_state ; } if ( match_start != - 1 ) { setMatch ( match_start , match_end ) ; return true ; } begin += 1 ; } if ( match_start != - 1 ) { setMatch ( match_start , match_end ) ; return true ; } else { setMatch ( - 2 , - 2 ) ; return false ; } } private void setMatch ( final int matchStart , final int matchEnd ) throws IllegalArgumentException { if ( matchStart > matchEnd ) { throw new IllegalArgumentException ( \"Start must be less than or equal to end: \" + matchStart + \", \" + matchEnd ) ; } this . matchStart = matchStart ; this . matchEnd = matchEnd ; } private int getMatchStart ( ) { return matchStart ; } private int getMatchEnd ( ) { return matchEnd ; } private CharSequence getChars ( ) { return chars ; } public int end ( ) throws IllegalStateException { matchGood ( ) ; return matchEnd ; } public int end ( final int group ) throws IndexOutOfBoundsException , IllegalStateException { onlyZero ( group ) ; return end ( ) ; } public String group ( ) throws IllegalStateException { matchGood ( ) ; return chars . subSequence ( matchStart , matchEnd ) . toString ( ) ; } public String group ( final int group ) throws IndexOutOfBoundsException , IllegalStateException { onlyZero ( group ) ; return group ( ) ; } public int groupCount ( ) { return 0 ; } public int start ( ) throws IllegalStateException { matchGood ( ) ; return matchStart ; } public int start ( int group ) throws IndexOutOfBoundsException , IllegalStateException { onlyZero ( group ) ; return start ( ) ; }", "gt": "public MatchResult toMatchResult ( )", "prediction": "}\n", "label": 0}
{"id": 1874, "input": "<s> package org . seage . metaheuristic . sannealing ; public interface IMoveManager { Solution", "gt": "getModifiedSolution ( Solution solution ) ;", "prediction": ";\n", "label": 1}
{"id": 9014, "input": "<s> class Example { public void example ( ) { } public static void example ( Object o ) { } } class Test extends Example {", "gt": "@ Override public void example ( )", "prediction": "if ( )\n", "label": 0}
{"id": 1875, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . util . LuceneTestCase ; import java . io . IOException ; public class TestIndexWriterMerging extends LuceneTestCase { public void testLucene ( ) throws IOException { int num = 100 ; Directory indexA = new MockRAMDirectory ( ) ; Directory indexB = new MockRAMDirectory ( ) ; fillIndex ( indexA , 0 , num ) ; boolean fail = verifyIndex ( indexA , 0 ) ; if ( fail ) { fail ( \"Index a is invalid\" ) ; } fillIndex ( indexB , num , num ) ; fail = verifyIndex ( indexB , num ) ; if ( fail ) { fail ( \"Index b is invalid\" ) ; } Directory merged = new MockRAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( merged , new StandardAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; writer . setMergeFactor ( 2 ) ; writer . addIndexes ( new Directory [ ] { indexA , indexB } ) ; writer . close ( ) ; fail = verifyIndex ( merged , 0 ) ; merged . close ( ) ; assertFalse ( \"The merged index is invalid\" , fail ) ; } private boolean verifyIndex ( Directory directory , int startAt ) throws IOException { boolean fail = false ; IndexReader reader = IndexReader . open ( directory ) ; int max = reader . maxDoc ( ) ; for ( int i = 0 ; i < max ; i ++ ) { Document temp = reader . document ( i ) ; if ( ! temp . getField ( \"count\" ) . stringValue ( ) . equals ( ( i + startAt ) + \"\" ) ) { fail = true ; System . out . println ( \"Document \" + ( i + startAt ) + \" is returning document \" + temp . getField ( \"count\" ) . stringValue ( ) ) ; } } reader", "gt": ". close ( ) ;", "prediction": ". get ( ) ;\n", "label": 1}
{"id": 8994, "input": "<s> package org . bombusim . xmpp . handlers ; import java . io . IOException ; import org . bombusim . xmpp . XmppError ; import org . bombusim . xmpp . XmppObject ; import org . bombusim . xmpp . XmppObjectListener ; import org . bombusim . xmpp . XmppStream ; import org . bombusim . xmpp . exception . XmppException ; import org . bombusim . xmpp . stanza . Iq ; public class IqFallback extends XmppObjectListener { @ Override public int blockArrived ( XmppObject data , XmppStream stream ) throws IOException , XmppException { try { Iq f = ( Iq ) data ; String from = f . getAttribute ( \"from\" ) ; String type = f . getTypeAttribute ( ) ; if ( type . equals ( \"result\" ) ) { return BLOCK_REJECTED ; } if ( type . equals ( \"error\" ) ) { return BLOCK_REJECTED ; } XmppError err = new XmppError ( XmppError . FEATURE_NOT_IMPLEMENTED , null ) ; f . setAttribute ( \"to\" , from ) ; f . setAttribute ( \"from\" , null ) ; f . setAttribute ( \"type\" , \"error\" ) ; f . setAttribute ( \"xml:lang\" , null ) ;", "gt": "f . addChild ( err . construct ( ) ) ;", "prediction": "}\n", "label": 0}
{"id": 1879, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . feeds . QueryMaker ; public class SearchTravTask extends ReadTask { protected int traversalSize = Integer . MAX_VALUE ; public SearchTravTask ( PerfRunData runData ) { super ( runData ) ; } public boolean withRetrieve ( ) { return false ; } public boolean withSearch ( ) { return true ; } public boolean withTraverse ( ) { return true ; } public boolean withWarm ( ) { return false ; } public QueryMaker getQueryMaker ( ) { return getRunData ( ) . getQueryMaker ( this ) ; } public int traversalSize ( ) { return traversalSize ; }", "gt": "public void setParams ( String params )", "prediction": "}\n", "label": 1}
{"id": 7510, "input": "<s> public class T6182630c { static class Foo < X > { public X x ; public void m ( X x ) { } } interface Bar { } < T extends Foo , S extends Foo & Bar > void test1 ( T t , S s ) { t . m (", "gt": "t . x ) ;", "prediction": ") ;\n", "label": 0}
{"id": 1931, "input": "<s> package org . nuxeo . connect . update . live . commands ; import java . io . IOException ; import org . junit . runner . RunWith ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . PackageUpdateService ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import org . nuxeo . runtime .", "gt": "test . runner . RuntimeFeature ;", "prediction": ";\n", "label": 1}
{"id": 1411, "input": "<s> @ interface An < T > {", "gt": "int a ( ) ;", "prediction": "}\n", "label": 0}
{"id": 1940, "input": "<s> package org . seage . problem . qap . fireflies ; import org . seage . problem . qap . fireflies . * ; import org . seage . metaheuristic . fireflies . * ; public class QapSwapMove implements Move { public int customer ; public int movement ; public QapSwapMove ( int customer , int movement ) { this . customer = customer ; this . movement = movement ; } public void operateOn ( Solution soln ) { Integer [ ] assign = ( ( QapSolution ) soln ) . _assign ; int pos1 = - 1 ; int pos2 = - 1 ; for ( int i = 0 ; i < assign . length && pos1 < 0 ; i ++ ) if ( assign [ i ] == customer ) pos1 = i ; pos2 = pos1 + movement ; int cust2 = assign [ pos2 ] ; assign [ pos1 ] = cust2 ; assign [ pos2 ] = customer ; }", "gt": "public int hashCode ( )", "prediction": "}\n", "label": 1}
{"id": 1001, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree . JCAnnotation ; import com . sun . tools . javac . tree . JCTree . JCExpression ; import com . sun . tools . javac . tree . JCTree . JCVariableDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . Name ; public class ParameterDefinitionBuilder { private final AbstractTransformer gen ; private long modifiers ; private JCExpression type ; private List < JCAnnotation > typeAnnos ; private boolean sequenced ; private boolean defaulted ; private final String name ; private String aliasedName ; private boolean noAnnotations = false ; private boolean built = false ; private ParameterDefinitionBuilder ( AbstractTransformer gen , String name ) { this . gen = gen ; this . name = name ; } static ParameterDefinitionBuilder instance ( AbstractTransformer gen , String name ) { return new ParameterDefinitionBuilder ( gen , name ) ; } public ParameterDefinitionBuilder modifiers ( long mods ) { this . modifiers |= mods ; return this ; } public ParameterDefinitionBuilder type ( JCExpression type , List < JCAnnotation > typeAnnos ) { this . type = type ; this . typeAnnos = typeAnnos ; return this ; } public ParameterDefinitionBuilder sequenced ( boolean sequenced ) { this . sequenced = sequenced ; return this ; } public ParameterDefinitionBuilder aliasName ( String aliasedName ) { this . aliasedName = aliasedName ; return this ; } public ParameterDefinitionBuilder defaulted ( boolean defaulted ) { this . defaulted = defaulted ; return this ; } public ParameterDefinitionBuilder noAnnotations ( ) { noAnnotations = true ; return this ; } public JCVariableDecl build ( ) { if ( built ) { throw new IllegalStateException ( ) ; } built = true ; List < JCAnnotation > annots =", "gt": "List . nil ( ) ;", "prediction": ";\n", "label": 0}
{"id": 1947, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; import com . puppycrawl . tools . checkstyle . api . ScopeUtils ; import com . puppycrawl . tools . checkstyle . api . TokenTypes ; public class UnusedLocalVariableCheck extends AbstractUsageCheck { public int [ ] getDefaultTokens ( ) { return new int [ ] { TokenTypes . VARIABLE_DEF , } ; } public String getErrorKey ( ) { return \"unused.local\" ; } public boolean mustCheckReferenceCount ( DetailAST aAST ) {", "gt": "return ScopeUtils . isLocalVariableDef ( aAST ) ;", "prediction": "\n", "label": 1}
{"id": 3506, "input": "<s> package org . dawb . workbench . plotting . tools . profile ; import java . util . Collection ; import ncsa . hdf . object . Group ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . tool . IDataReductionToolPage . DataReductionInfo ; import org . dawb . common . ui . plot . tool . IDataReductionToolPage . DataReductionSlice ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . gda . extensions . loaders . H5Utils ; import org . dawb . hdf5 . IHierarchicalDataFile ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . DatasetUtils ; import uk . ac . diamond . scisoft . analysis . roi . ROIProfile ; import uk . ac . diamond . scisoft . analysis . roi . SectorROI ; public class RadialProfileTool extends SectorProfileTool { @ Override protected AbstractDataset [ ] getXAxis ( final SectorROI sroi , AbstractDataset [ ] integrals ) { final AbstractDataset xi = DatasetUtils . linSpace ( sroi . getRadius ( 0 ) , sroi . getRadius ( 1 ) , integrals [ 0 ] . getSize ( ) , AbstractDataset . FLOAT64 ) ; xi . setName ( \"Radius (pixel)\" ) ; if ( ! sroi . hasSeparateRegions ( ) ) return new AbstractDataset [ ] { xi } ; final AbstractDataset xii = DatasetUtils . linSpace ( sroi . getRadius ( 0 ) , sroi . getRadius ( 1 ) , integrals [ 1 ] . getSize ( ) , AbstractDataset . FLOAT64 ) ; xii . setName ( \"Radius (pixel)\" ) ; return new AbstractDataset [ ] { xi , xii } ; } @ Override protected AbstractDataset [ ] getIntegral ( AbstractDataset data , AbstractDataset mask , SectorROI sroi , IRegion region , boolean isDrag ) { AbstractDataset [ ] profile = ROIProfile . sector ( data , mask , sroi , true , false , isDrag ) ; if ( profile == null ) return null ; final AbstractDataset integral = profile [ 0 ] ; integral . setName ( \"Radial Profile \" + region . getName ( ) ) ; if ( profile . length >= 3 && profile [ 2 ] != null && sroi . hasSeparateRegions ( ) ) { final AbstractDataset reflection = profile [ 2 ] ; reflection . setName ( \"Symmetry \" + region . getName ( ) ) ; return new AbstractDataset [ ] { integral , reflection } ; } else { return new AbstractDataset [ ] { integral } ; } } @ Override public DataReductionInfo export ( DataReductionSlice slice ) throws Exception {", "gt": "final IImageTrace image = getImageTrace ( ) ;", "prediction": "\n", "label": 0}
{"id": 1949, "input": "<s> package io . beancounter . profiles ; import com . google . inject . Guice ; import com . google . inject . Injector ; import junit . framework . Assert ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import redis . clients . jedis . JedisPool ; import io . beancounter . commons . helper . jedis . JedisPoolFactory ; import io . beancounter . commons . model . UserProfile ; import java . util . UUID ; public class JedisProfilesIntegrationTest { private Profiles profiles ; @ BeforeClass public void setUp ( ) { Injector injector = Guice . createInjector ( new ProfilesModule ( ) ) ; profiles = injector . getInstance ( Profiles . class ) ; JedisPool pool = injector . getInstance ( JedisPoolFactory . class ) . build ( ) ; pool . getResource ( ) . flushAll ( ) ; } @ Test public void testStoreUserProfile ( ) throws ProfilesException { UserProfile testProfile = getTestUserProfile ( ) ; profiles . store ( testProfile ) ; UserProfile profileRetrieved = profiles . lookup ( testProfile . getUserId ( ) ) ; Assert . assertEquals", "gt": "( testProfile , profileRetrieved ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4133, "input": "<s> package pkg2 ; import pkg1 . * ; import java . io . Serializable ; public class C2 implements Serializable { public C1 field ; public static final String CONSTANT1 = \"C2\" ; public", "gt": "C1 method ( C1 param )", "prediction": "void ( )\n", "label": 0}
{"id": 1952, "input": "<s> package org . apache . lucene . analysis . el ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . StopFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . standard . StandardTokenizer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . util . Version ; import java . io . IOException ; import java . io . Reader ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public final class GreekAnalyzer extends Analyzer { private static char A = 6 ; private static char B = 7 ; private static char G = 8 ; private static char D = 9 ; private static char E = 10 ; private static char Z = 11 ; private static char H = 12 ; private static char TH = 13 ; private static char I = 14 ; private static char K = 15 ; private static char L = 16 ; private static char M = 17 ; private static char N = 18 ; private static char KS = 19 ; private static char O = 20 ; private static char P = 21 ; private static char R = 22 ; private static char S = 24 ; private static char T = 25 ; private static char Y = 26 ; private static char F = 27 ; private static char X = 28 ; private static char PS = 29 ; private static char W = 30 ; private static char [ ] [ ] GREEK_STOP_WORDS = { { O } , { H } , { T , O } , { O , I } , { T , A } , { T , O , Y } , { T , H , S } , { T , W , N } , { T , O , N } , { T , H , N } , { K , A , I } , { K , I } , { K } , { E , I , M , A , I } , { E , I , S , A , I } , { E , I , N , A , I } , { E , I , M , A , S , T , E } , { E , I , S , T , E } , { S , T , O } , { S , T , O , N } , { S , T , H } , { S , T , H , N } , { M , A } , { A , L , L , A } , { A , P , O } , { G , I , A } , { P , R , O , S } , { M , E } , { S , E } , { W , S } , { P , A , R , A } , { A , N , T , I } , { K , A , T , A } , { M , E , T , A } , { TH , A } , { N , A } , { D , E } , { D , E , N } , { M , H } , { M , H , N } , { E , P , I } , { E , N , W } , { E , A , N } , { A , N } , { T , O , T , E } , { P , O , Y } , { P , W , S } , { P , O , I , O , S } , { P , O , I , A } , { P , O , I , O } , { P , O , I , O , I } , { P , O , I , E , S } , { P , O , I , W , N } , { P , O , I , O , Y , S } , { A , Y , T , O , S } , { A , Y , T , H } , { A , Y , T , O } , { A , Y , T , O , I } , { A , Y , T , W , N } , { A , Y , T , O , Y , S } , { A , Y , T , E , S } , { A , Y , T , A } , { E , K , E , I , N , O , S } , { E , K , E , I , N , H } , { E , K , E , I , N , O } , { E , K , E , I , N , O , I } , { E , K ,", "gt": "E , I , N , E , S }", "prediction": ") ;\n", "label": 1}
{"id": 3843, "input": "<s> package com . matburt . mobileorg . Gui . Capture ; import java . util . ArrayList ; import android . app . AlertDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . util . AttributeSet ; import android . view . View ; import android . widget . AdapterView ; import android . widget . EditText ; import android . widget . Spinner ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . util . OrgUtils ; public class LocationEntry extends Spinner { public final String createHeading = \"Create new\" ; private OrgNode node ; private LocationFragment locationFragment ; private ArrayList < String > data ; private boolean disableSpinnerListener = false ; public LocationEntry ( Context context ) { super ( context ) ; } public LocationEntry ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public void init ( OrgNode node , LocationFragment locationFragment , ArrayList < String > data , String selection ) { this . node = node ; this . locationFragment = locationFragment ; this . data = data ; if ( node == null ) ; else this . data . add ( \"\" ) ; setupSpinner ( selection ) ; setOnItemSelectedListener ( listener ) ; } private OnItemSelectedListener listener = new OnItemSelectedListener ( ) { @ Override public void onItemSelected ( AdapterView < ? > parentView , View selectedItemView , int position , long id ) { if ( disableSpinnerListener ) return ; String selection = ( String ) getSelectedItem ( ) ; if ( selection .", "gt": "equals ( createHeading ) ) promptForNewFile ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 1968, "input": "<s> package org . eclipse . rap . rwt . widgets ; import org . eclipse . swt . internal . SerializableCompatibility ; public interface BrowserCallback extends SerializableCompatibility { void evaluationSucceeded ( Object result ) ;", "gt": "void evaluationFailed ( Exception exception ) ;", "prediction": "}\n", "label": 1}
{"id": 1703, "input": "<s> import java . io . IOException ; public class BadTwrSyntax implements AutoCloseable { public static void main ( String ... args ) throws Exception { try ( BadTwr twrflow = new BadTwr ( ) ; ; ) { System . out . println ( twrflow . toString ( ) ) ; } try ( BadTwr twrflow = new BadTwr ( ) ; ) { System .", "gt": "out . println ( twrflow . toString ( ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 1971, "input": "<s> package org . nuxeo . ecm . webengine . base ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import org . nuxeo . ecm . webengine . model . View ; import org . nuxeo . ecm . webengine . model . WebAdapter ; import org . nuxeo . ecm . webengine . model . impl . DefaultAdapter ; @ WebAdapter ( name = \"views\" , type = \"ViewService\" ) @ Produces ( \"text/html; charset=UTF-8\" ) public class ViewService extends DefaultAdapter { @ GET public Object doGet ( ) { return \"View Service: TODO - display", "gt": "the list of existing views\" ;", "prediction": ";\n", "label": 1}
{"id": 9880, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Fail ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class FailImpl extends TaskAttributeImpl implements Fail { protected LogicalExpression expression ; protected FailImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getFail ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . FAIL__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . FAIL__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . FAIL__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . FAIL__EXPRESSION , newExpression , newExpression ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . FAIL__EXPRESSION : return basicSetExpression ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet (", "gt": "int featureID , boolean resolve , boolean coreType )", "prediction": ")\n", "label": 0}
{"id": 2007, "input": "<s> package org . jscsi . parser . datasegment ; import java . nio . ByteBuffer ; final class BinaryDataSegment extends AbstractDataSegment { public BinaryDataSegment ( final int chunkSize ) { super ( chunkSize ) ; } public final int deserialize ( final ByteBuffer src , final int len ) { resizeBuffer ( src . remaining ( ) , false ) ; dataBuffer . rewind ( ) ; transferBytes ( src , dataBuffer , len ) ; return dataBuffer . limit ( ) ; } public final int append ( final ByteBuffer src , final int len ) { if ( src == null ) { throw new NullPointerException ( ) ; } dataBuffer . position ( length ) ; resizeBuffer ( length + len , true ) ; transferBytes ( src , dataBuffer , len ) ; return dataBuffer . limit ( ) ; } private final void transferBytes ( final ByteBuffer src ,", "gt": "final ByteBuffer dst , final int len )", "prediction": ")\n", "label": 1}
{"id": 8438, "input": "<s> package org . ofbiz . service . calendar ; public class TemporalExpressionPrinter implements TemporalExpressionVisitor { protected final TemporalExpression expression ; protected final StringBuilder sb = new StringBuilder ( ) ; protected int indentSize = 2 ; protected int currentIndent = 0 ; public TemporalExpressionPrinter ( TemporalExpression expression ) { this . expression = expression ; } public TemporalExpressionPrinter ( TemporalExpression expression , int indentSize ) { this . expression = expression ; if ( indentSize > 0 ) { this . indentSize = indentSize ; } } protected void appendExpression ( TemporalExpression expression ) { appendIndent ( ) ; this . sb . append ( expression ) ; this . sb . append ( \"\\n\" ) ; } protected void appendIndent ( ) { for ( int i = 0 ; i < this . currentIndent ; i ++ ) { this . sb . append ( \" \" ) ; } } protected void indent ( ) { this . currentIndent += this . indentSize ; } @ Override public String toString ( ) { this . expression . accept ( this ) ; return this . sb . toString ( ) ; } protected void unIndent ( ) { this . currentIndent -= this . indentSize ; } @ Override public void visit ( TemporalExpressions . DateRange expr ) { appendExpression ( expr ) ; } @ Override public void visit ( TemporalExpressions . DayInMonth expr ) { appendExpression ( expr ) ; } @ Override public void visit ( TemporalExpressions . DayOfMonthRange expr ) { appendExpression ( expr ) ; } @ Override public void visit ( TemporalExpressions . DayOfWeekRange expr ) { appendExpression ( expr ) ; } @ Override public void visit ( TemporalExpressions . Difference expr ) { appendIndent ( ) ; this . sb . append ( \"Difference [\" ) ; this . sb . append ( expr . getId ( ) ) ; this . sb . append ( \"]:\\n\" ) ; indent ( ) ; appendIndent ( ) ; this . sb . append ( \"Include:\\n\" ) ; indent ( ) ; expr . included . accept ( this ) ; unIndent ( ) ; appendIndent ( ) ; this . sb . append ( \"Exclude:\\n\" ) ; indent ( ) ; expr . excluded . accept ( this ) ; unIndent ( ) ; unIndent ( ) ; } @ Override public void visit ( TemporalExpressions . Frequency expr ) { appendExpression ( expr ) ; } @ Override public void", "gt": "visit ( TemporalExpressions . HourRange expr )", "prediction": "( )\n", "label": 0}
{"id": 2014, "input": "<s> package sk . m217 . actionbarcompat ; import android . content . Context ; public interface SimpleMenuPresenter { public void initForMenu ( Context context , SimpleMenu menu ) ; public void updateMenuView ( SimpleMenu menu , SimpleMenuItem item , int change ) ; public boolean expandItemActionView", "gt": "( SimpleMenu menu , SimpleMenuItem item ) ;", "prediction": "( )\n", "label": 1}
{"id": 8294, "input": "<s> package jns . element ; import jns . trace . Trace ; public class DuplexLink extends Link { private SimplexLink m_link1 , m_link2 ; public DuplexLink ( int bandwidth , double delay ) { m_link1 = new SimplexLink ( bandwidth , delay ) ; m_link2 = new SimplexLink ( bandwidth , delay ) ; } public DuplexLink ( int bandwidth , double delay , double error ) { m_link1 = new SimplexLink ( bandwidth , delay , error ) ; m_link2 = new SimplexLink ( bandwidth , delay , error ) ; } public void dump ( ) { System . out . println ( \"DuplexLink: \" ) ; m_link1 . dump ( ) ; m_link2 . dump ( ) ; } public void attach ( Trace trace ) { m_link1 . attach ( trace ) ; m_link2 . attach ( trace ) ; } public void update ( ) { } public SimplexLink getSimplexLink1 ( ) { return m_link1 ; } public SimplexLink getSimplexLink2 ( ) { return m_link2 ; } public void setStatus ( int status ) { m_link1 . setStatus ( status ) ; m_link2", "gt": ". setStatus ( status ) ;", "prediction": ";\n", "label": 0}
{"id": 2018, "input": "<s> package org . nuxeo . ecm . platform . preview . adapter . factories ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . blobholder . BlobHolder ; import org . nuxeo . ecm . platform . preview . adapter . PreviewAdapterFactory ; import org . nuxeo . ecm . platform . preview . adapter . base . ConverterBasedHtmlPreviewAdapter ; import org . nuxeo . ecm . platform . preview . api . HtmlPreviewAdapter ; public class FileBasedPreviewAdapterFactory implements PreviewAdapterFactory { public HtmlPreviewAdapter getAdapter ( DocumentModel doc ) { ConverterBasedHtmlPreviewAdapter adapter = new ConverterBasedHtmlPreviewAdapter ( ) ; adapter . setAdaptedDocument ( doc ) ; BlobHolder bh = doc . getAdapter ( BlobHolder . class ) ; if ( bh == null ) { if ( doc . hasSchema ( \"file\" ) ) { adapter . setDefaultPreviewFieldXPath ( \"file:content\" ) ; } else { adapter .", "gt": "setDefaultPreviewFieldXPath ( \"files:files/0/file\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 3621, "input": "<s> import java . io . * ; class T7022711 { public static void main ( String args [ ] ) throws Exception { try ( DataInputStream is = new DataInputStream ( new FileInputStream", "gt": "( \"x\" ) ) )", "prediction": ") ;\n", "label": 0}
{"id": 2019, "input": "<s> package org . restlet . ext . rdf . internal . n3 ; import java . io . IOException ; import java . io . Writer ; import java . util . Map ; import org . restlet . data . Reference ; import org . restlet . ext . rdf . Graph ; import org . restlet . ext . rdf . GraphHandler ; import org . restlet . ext . rdf . Link ; import org . restlet . ext . rdf . Literal ; import org . restlet . ext . rdf . internal . RdfConstants ; import org . restlet . ext . rdf . internal . turtle . Context ; public class RdfN3Writer extends GraphHandler { private Context context ; private Reference precPredicate ; private Reference precSource ; private Writer writer ; private boolean writingExtraDot ; public RdfN3Writer ( Writer writer ) throws IOException { super ( ) ; this . context = new Context ( ) ; this . writer = writer ; Map < String , String > prefixes = context . getPrefixes ( ) ; prefixes . put ( RdfConstants . RDF_SCHEMA . toString ( ) , \"rdf\" ) ; prefixes . put ( RdfConstants . RDF_SYNTAX . toString ( ) , \"rdfs\" ) ; prefixes . put ( \"http://www.w3.org/2000/10/swap/grammar/bnf#\" , \"cfg\" ) ; prefixes . put ( \"http://www.w3.org/2000/10/swap/grammar/n3#\" , \"n3\" ) ; prefixes . put ( \"http://www.w3.org/2000/10/swap/list#\" , \"list\" ) ; prefixes . put ( \"http://www.w3.org/2000/10/swap/pim/doc#\" , \"doc\" ) ; prefixes . put ( \"http://www.w3.org/2002/07/owl#\" , \"owl\" ) ; prefixes . put ( \"http://www.w3.org/2000/10/swap/log#\" , \"log\" ) ; prefixes . put ( \"http://purl.org/dc/elements/1.1/\" , \"dc\" ) ; prefixes . put ( \"http://www.w3.org/2001/XMLSchema#\" , \"type\" ) ; for ( String key : prefixes . keySet ( ) ) { this . writer . append ( \"@prefix \" ) . append ( prefixes . get ( key ) ) . append ( \": <\" ) . append ( key ) . append ( \">.\\n\" ) ; } this . writer . append ( \"@keywords a, is, of, has.\\n\" ) ; } @ Override public void endGraph ( ) throws IOException { this . writer . write ( \".\\n\" ) ; this . writer . flush ( ) ; } @ Override public void link ( Graph source , Reference typeRef , Literal target ) { try { this . writer . write ( \"{\" ) ; write ( source ) ; this . writer . write ( \"} \" ) ; write ( typeRef , this . context . getPrefixes ( ) ) ; this . writer . write ( \" \" ) ; write ( target ) ; this . precSource = null ; this . precPredicate = typeRef ; this . writingExtraDot = true ; } catch ( IOException e ) { org . restlet . Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to \" + e . getMessage ( ) ) ; } } @ Override public void link ( Graph source , Reference typeRef , Reference target ) { try { this . writer . write ( \"{\" ) ; write ( source ) ; this . writer . write ( \"} \" ) ; write ( typeRef , this . context . getPrefixes ( ) ) ; this . writer . write ( \" \" ) ; write ( target , this . context . getPrefixes ( ) ) ; this . precSource = null ; this . precPredicate = typeRef ; this . writingExtraDot = true ; } catch ( IOException e ) { org . restlet . Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to \" + e . getMessage ( ) ) ; } } @ Override public void link ( Reference source , Reference typeRef , Literal target ) { try { if ( source . equals ( this . precSource ) ) { if ( typeRef . equals ( this . precPredicate ) ) { this . writer . write ( \", \" ) ; } else { this . writer . write ( \"; \" ) ; write ( typeRef , this . context . getPrefixes ( ) ) ; this . writer . write ( \" \" ) ; } } else { if ( this . writingExtraDot ) { this . writer . write ( \".\\n\" ) ; } write ( source , this . context . getPrefixes ( ) ) ; this . writer . write ( \" \" ) ; write ( typeRef , this . context . getPrefixes ( ) ) ; this . writer . write ( \" \" ) ; } write ( target ) ; this . precSource = source ;", "gt": "this . precPredicate = typeRef ;", "prediction": "}\n", "label": 1}
{"id": 7083, "input": "<s> package org . ofbiz . minilang . operation ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Element ; public class SimpleMapProcess { public static final String module = SimpleMapProcess . class . getName ( ) ; String field = \"\" ; List < SimpleMapOperation > simpleMapOperations = FastList . newInstance ( ) ; public SimpleMapProcess ( Element simpleMapProcessElement ) { this . field = simpleMapProcessElement . getAttribute ( \"field\" ) ; readOperations ( simpleMapProcessElement ) ; } public void exec ( Map < String , Object > inMap , Map < String , Object > results , List < Object > messages , Locale locale , ClassLoader loader ) { for ( SimpleMapOperation simpleMapOperation : simpleMapOperations ) { simpleMapOperation . exec ( inMap , results , messages , locale , loader ) ; } } public String getFieldName ( ) { return field ; } void readOperations ( Element simpleMapProcessElement ) { List < ? extends Element > operationElements = UtilXml . childElementList ( simpleMapProcessElement ) ; if ( UtilValidate . isNotEmpty ( operationElements ) ) { for ( Element curOperElem : operationElements ) { String nodeName = curOperElem . getNodeName ( ) ; if ( \"validate-method\" . equals ( nodeName ) ) { simpleMapOperations . add ( new ValidateMethod ( curOperElem , this ) ) ; } else if ( \"compare\" . equals ( nodeName ) ) { simpleMapOperations . add ( new Compare ( curOperElem , this ) ) ; } else if ( \"compare-field\" . equals ( nodeName ) ) { simpleMapOperations . add ( new CompareField ( curOperElem , this ) ) ; } else if ( \"regexp\" . equals ( nodeName ) ) { simpleMapOperations . add ( new Regexp ( curOperElem , this ) ) ; } else if ( \"not-empty\" . equals ( nodeName ) ) { simpleMapOperations . add (", "gt": "new NotEmpty ( curOperElem , this ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2020, "input": "<s> package org . eclipse . swt . internal . widgets . tablekit ; import static org . eclipse . rap . rwt . internal . protocol . ProtocolUtil . readCallPropertyValueAsString ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . readEventPropertyValue ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import java . io . IOException ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ProtocolUtil ; import org . eclipse . rap . rwt . internal . util . NumberFormatUtil ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . events . EventLCAUtil ; import org . eclipse . swt . internal . widgets . * ; import org . eclipse . swt . widgets . * ; public final class TableLCA extends AbstractWidgetLCA { private static final String TYPE = \"rwt.widgets.Grid\" ; private static final String [ ] ALLOWED_STYLES = new String [ ] { \"SINGLE\" , \"MULTI\" , \"CHECK\" , \"FULL_SELECTION\" , \"HIDE_SELECTION\" , \"VIRTUAL\" , \"NO_SCROLL\" , \"NO_RADIO_GROUP\" , \"BORDER\" } ; private static final String PROP_ITEM_COUNT = \"itemCount\" ; private static final String PROP_ITEM_HEIGHT = \"itemHeight\" ; private static final String PROP_ITEM_METRICS = \"itemMetrics\" ; private static final String PROP_COLUMN_COUNT = \"columnCount\" ; private static final String PROP_TREE_COLUMN = \"treeColumn\" ; private static final String PROP_FIXED_COLUMNS = \"fixedColumns\" ; private static final String PROP_HEADER_HEIGHT = \"headerHeight\" ; private static final String PROP_HEADER_VISIBLE = \"headerVisible\" ; private static final String PROP_LINES_VISIBLE = \"linesVisible\" ; private static final String PROP_TOP_ITEM_INDEX = \"topItemIndex\" ; private static final String PROP_FOCUS_ITEM = \"focusItem\" ; private static final String PROP_SCROLL_LEFT = \"scrollLeft\" ; private static final String PROP_SELECTION = \"selection\" ; private static final String PROP_SORT_DIRECTION = \"sortDirection\" ; private static final String PROP_SORT_COLUMN = \"sortColumn\" ; private static final String PROP_SCROLLBARS_VISIBLE = \"scrollBarsVisible\" ; private static final String PROP_SCROLLBARS_SELECTION_LISTENER = \"scrollBarsSelection\" ; private static final String PROP_SELECTION_LISTENER = \"selection\" ; private static final String PROP_ALWAYS_HIDE_SELECTION = \"alwaysHideSelection\" ; private static final String PROP_ENABLE_CELL_TOOLTIP = \"enableCellToolTip\" ; private static final String PROP_CELL_TOOLTIP_TEXT = \"cellToolTipText\" ; private static final String PROP_MARKUP_ENABLED = \"markupEnabled\" ; private static final int ZERO = 0 ; private static final String [ ] DEFAULT_SELECTION = new String [ 0 ] ; private static final", "gt": "boolean [ ] DEFAULT_SCROLLBARS_VISIBLE = new boolean [ ]", "prediction": "____________________________________________________________________________________________________\n", "label": 1}
{"id": 9196, "input": "<s> package com . deliciousdroid . activity ; import com . deliciousdroid . Constants ; import com . deliciousdroid . R ; import com . deliciousdroid . providers . BookmarkContentProvider ; import com . deliciousdroid . util . SyncUtils ; import android . content . ContentResolver ; import android . content . Context ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import android . preference . Preference ; import android . preference . Preference . OnPreferenceChangeListener ; import android . preference . Preference . OnPreferenceClickListener ; import android . preference . PreferenceActivity ; import android . provider . Settings ; import android . widget . Toast ; public class Preferences extends PreferenceActivity { private Context mContext ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . preferences ) ; mContext = this ; Preference synctimePref = ( Preference ) findPreference ( \"pref_synctime\" ) ; synctimePref . setOnPreferenceChangeListener ( new OnPreferenceChangeListener ( ) { public boolean onPreferenceChange ( Preference preference , Object value ) { long time = Long . parseLong ( ( String ) value ) ; SyncUtils . removePeriodicSync ( BookmarkContentProvider . AUTHORITY , Bundle . EMPTY , mContext ) ; if ( time != 0 ) { SyncUtils . addPeriodicSync ( BookmarkContentProvider . AUTHORITY , Bundle . EMPTY , time , mContext ) ; } return true ; } } ) ; Preference syncPref = ( Preference ) findPreference ( \"pref_forcesync\" ) ; syncPref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) { public boolean onPreferenceClick ( Preference preference ) { Toast . makeText ( mContext , \"Syncing...\" , Toast . LENGTH_LONG ) . show ( ) ; ContentResolver . requestSync ( null , BookmarkContentProvider . AUTHORITY , Bundle . EMPTY ) ; return true ; } } ) ; Preference accountPref = ( Preference ) findPreference ( \"pref_accountsettings\" ) ; accountPref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) { public boolean onPreferenceClick ( Preference preference ) { Intent i = new Intent ( Settings . ACTION_SYNC_SETTINGS ) ; i . putExtra ( Settings . EXTRA_AUTHORITIES , new String [ ] { BookmarkContentProvider . AUTHORITY } ) ; mContext . startActivity ( i ) ; return true ; } } ) ; Preference licensePref = ( Preference ) findPreference ( \"pref_license\" ) ; licensePref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) { public boolean onPreferenceClick ( Preference preference ) { Uri link = Uri . parse ( \"http://www.gnu.org/licenses/gpl-3.0.txt\" ) ; Intent i = new Intent ( Intent . ACTION_VIEW , link ) ; startActivity ( i ) ; return true ; } } ) ; Preference helpPref = ( Preference ) findPreference ( \"pref_help\" ) ; helpPref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) { public boolean onPreferenceClick ( Preference preference ) { Uri link = Uri . parse ( \"http://code.google.com/p/deliciousdroid/wiki/Manual\" ) ; Intent i = new Intent ( Intent . ACTION_VIEW , link ) ; startActivity ( i ) ; return true ; } } ) ; Preference donatePref = ( Preference ) findPreference ( \"pref_donate\" ) ; donatePref . setOnPreferenceClickListener ( new OnPreferenceClickListener ( ) {", "gt": "public boolean onPreferenceClick ( Preference preference )", "prediction": "\n", "label": 0}
{"id": 2031, "input": "<s> package org . apache . lucene . analysis ; import java . io . IOException ; public abstract class CharFilter extends CharStream { protected CharStream input ; protected CharFilter ( CharStream in ) { input = in ; } protected int correct ( int currentOff ) { return currentOff ; } public final int correctOffset ( int currentOff ) { return input . correctOffset ( correct ( currentOff ) ) ; } public void close ( ) throws IOException { input . close ( ) ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { return input . read ( cbuf , off , len ) ; } public boolean markSupported ( ) { return input . markSupported ( ) ; } public", "gt": "void mark ( int readAheadLimit ) throws IOException", "prediction": "}\n", "label": 1}
{"id": 2910, "input": "<s> package com . sun . tools . javac . file ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import com . sun . tools . javac . util . Context ; public class CacheFSInfo extends FSInfo { public static void preRegister ( Context context ) { context . put ( FSInfo . class , new Context . Factory < FSInfo > ( ) { public FSInfo make ( Context c ) { FSInfo instance = new CacheFSInfo ( ) ; c . put ( FSInfo . class , instance ) ; return instance ; } } ) ; } public void clearCache ( ) { cache . clear ( ) ; } @ Override public File getCanonicalFile ( File file ) { Entry e = getEntry ( file ) ; return e . canonicalFile ; } @ Override public boolean exists ( File file ) { Entry e = getEntry ( file ) ; return e . exists ; } @ Override public boolean isDirectory ( File file ) { Entry e = getEntry ( file ) ; return e . isDirectory ; } @ Override public boolean isFile ( File file ) { Entry e = getEntry ( file ) ; return e . isFile ; } @ Override public List < File > getJarClassPath ( File file ) throws IOException { Entry e = getEntry ( file ) ; if ( e . jarClassPath == null ) e . jarClassPath = super . getJarClassPath ( file ) ; return e . jarClassPath ; } private Entry getEntry ( File file ) { Entry e = cache . get ( file ) ; if ( e == null ) { e = new Entry ( ) ; e . canonicalFile = super . getCanonicalFile ( file ) ; e . exists = super . exists ( file ) ; e . isDirectory = super . isDirectory ( file ) ; e . isFile = super . isFile ( file ) ; cache . put (", "gt": "file , e ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2033, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import java . util . Calendar ; import java . util . Date ; import org . eclipse . jface . databinding . swt . WidgetValueProperty ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . DateTime ; public class DateTimeSelectionProperty extends WidgetValueProperty { public DateTimeSelectionProperty ( ) { super ( SWT . Selection ) ; } public Object getValueType ( ) { return Date . class ; } private static final ThreadLocal calendar = new ThreadLocal ( ) { protected Object initialValue ( ) { return Calendar . getInstance ( ) ; } } ; protected Object doGetValue ( Object source ) { DateTime dateTime = ( DateTime ) source ; Calendar cal = ( Calendar ) calendar . get ( ) ; cal . clear ( ) ; if ( ( dateTime . getStyle ( ) & SWT . TIME ) != 0 ) { cal . set ( Calendar . HOUR_OF_DAY , dateTime . getHours ( ) ) ; cal . set ( Calendar . MINUTE , dateTime . getMinutes ( ) ) ; cal . set ( Calendar . SECOND , dateTime . getSeconds ( ) ) ; } else { cal . set ( Calendar . YEAR , dateTime . getYear ( ) ) ; cal . set ( Calendar . MONTH ,", "gt": "dateTime . getMonth ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4789, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . gmf . mappings . NodeMapping ; public interface SimpleChildReference extends SimpleNodeReference , SimpleChildNode { NodeMapping getReferencedChild ( ) ; void setReferencedChild ( NodeMapping value ) ; SimpleNode getReferencedSimpleNode ( ) ;", "gt": "void setReferencedSimpleNode ( SimpleNode value ) ;", "prediction": "}\n", "label": 0}
{"id": 2034, "input": "<s> package org . eclipse . ui . tests . performance ; import junit . framework . Test ; import junit . framework . TestSuite ; public class EditorPerformanceSuite extends TestSuite { public static final String [ ] EDITOR_FILE_EXTENSIONS = { \"perf_basic\" , \"perf_outline\" , \"java\" } ; public static final String [ ] [ ] EDITOR_SWITCH_PAIRS = { { \"perf_outline\" , \"java\" } , { \"perf_basic\" , \"perf_outline\" } } ; public static Test suite ( ) { return new EditorPerformanceSuite ( ) ; } public EditorPerformanceSuite ( ) { addOpenCloseScenarios ( ) ; addSwitchScenarios ( ) ; addOpenMultipleScenarios ( true ) ;", "gt": "addOpenMultipleScenarios ( false ) ;", "prediction": "}\n", "label": 1}
{"id": 7407, "input": "<s> package com . shopzilla . api . client . model ; import java . util . List ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; public class Offer { private Long id ; private Long mid ; private Long pid ; private Price price ; private Price originalPrice ; private Price totalPrice ; private Long categoryId ; private String title ; private String description ; private String URL ; private String detailURL ; private String rawMerchantUrl ; private String sku ; private Boolean bidded ; private Boolean showLogo ; private String merchantLogoUrl ; private String shipType ; private Price shipAmount ; private Price shipCost ; private Price tax ; private String stock ; private String condition ; private String bidAmt ; private boolean mature ; private Merchant merchant ; private List < Attribute > attributes ; @ Override public String toString ( ) { return \"Offer{\" + \"bidded=\" + bidded + \", id=\" + id + \", mid=\" + mid + \", pid=\" + pid + \", price=\" + price + \", originalPrice=\" + originalPrice + \", totalPrice=\" + totalPrice + \", categoryId=\" + categoryId + \", title='\" + title + '\\'' + \", description='\" + description + '\\'' + \", URL='\" + URL + '\\'' + \", detailURL='\" + detailURL + '\\'' + \", rawMerchantUrl='\" + rawMerchantUrl + '\\'' + \", sku='\" + sku + '\\'' + \", showLogo=\" + showLogo + \", merchantLogoUrl=\" + merchantLogoUrl + \", shipType='\" + shipType + '\\'' + \", shipAmount=\" + shipAmount + \", shipCost=\" + shipCost + \", tax=\" + tax + \", stock='\" + stock + '\\'' + \", condition='\" + condition + '\\'' + \", merchant=\" + merchant + \", bidAmt=\" + bidAmt + \", mature=\" + mature + '}' ; } @ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( o == null || ! ( o instanceof Offer ) ) { return false ; } Offer rhs = ( Offer ) o ; return new EqualsBuilder ( ) . append ( id , rhs . id ) . isEquals ( ) ; } @ Override public int hashCode ( ) { return new HashCodeBuilder ( ) . append ( id ) . toHashCode ( ) ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getMid ( ) { return mid ; } public void setMid ( Long mid ) { this . mid = mid ; } public Price getPrice ( ) { return price ; } public void setPrice ( Price price ) { this . price = price ; } public Long getCategoryId ( ) { return categoryId ; } public void setCategoryId ( Long categoryId ) { this . categoryId = categoryId ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getURL ( ) { return URL ; } public void setURL ( String uRL ) { URL = uRL ; } public String getDetailURL ( ) { return detailURL ; } public void setDetailURL ( String detailURL ) { this . detailURL = detailURL ; } public String getRawMerchantUrl ( ) { return rawMerchantUrl ; } public void setRawMerchantUrl ( String rawMerchantUrl ) { this . rawMerchantUrl = rawMerchantUrl ; } public Merchant getMerchant ( ) { return merchant ; } public void setMerchant ( Merchant merchant ) { this . merchant = merchant ; } public Boolean isBidded ( ) { return bidded ; } public void setBidded ( Boolean bidded ) { this . bidded = bidded ; } public String getSku ( ) { return sku ; } public void setSku ( String sku ) { this . sku = sku ; } public Boolean getShowLogo ( ) { return showLogo ; } public void setShowLogo ( Boolean showLogo ) { this . showLogo = showLogo ; } public Price getShipAmount ( ) { return shipAmount ; } public void setShipAmount ( Price shipAmount ) { this . shipAmount = shipAmount ; } public String getShipType ( ) { return shipType ; } public void setShipType ( String shipType ) { this . shipType = shipType ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) { this . condition = condition ; } public Price getOriginalPrice ( ) { return originalPrice ; } public void setOriginalPrice ( Price originalPrice ) { this . originalPrice = originalPrice ; } public Price getShipCost ( ) { return shipCost ; } public void setShipCost ( Price shipCost ) { this . shipCost = shipCost ; } public String getStock ( ) { return stock ; } public void setStock ( String stock ) { this . stock = stock ; } public Price getTax ( ) { return tax ; } public void setTax ( Price tax ) { this . tax = tax ; } public Price getTotalPrice ( ) { return totalPrice ; } public void setTotalPrice ( Price totalPrice ) { this . totalPrice = totalPrice ; } public String getBidAmt ( ) { return bidAmt ; }", "gt": "public void setBidAmt ( String bidAmt )", "prediction": "}\n", "label": 0}
{"id": 2040, "input": "<s> package org . restlet . ext . servlet . internal ; import java . io . File ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; import java . util . Set ; import java . util . logging . Level ; import javax . servlet . ServletContext ; import org . restlet . Context ; import org . restlet . data . MediaType ; import org . restlet . engine . local . Entity ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . Representation ; import org . restlet . service . MetadataService ; public class ServletWarEntity extends Entity { private List < Entity > children = null ; private final boolean directory ; private final String fullName ; private final String path ; private final ServletContext servletContext ; public ServletWarEntity ( ServletContext servletContext , String path , MetadataService metadataService ) { super ( metadataService ) ; this . children = null ; this . servletContext = servletContext ; this . path = path ; if ( path . endsWith ( \"/\" ) ) { this . directory = true ; this . fullName = path . substring ( 0 , path . length ( ) - 1 ) ; Set < ? > childPaths = getServletContext ( ) . getResourcePaths ( path ) ; if ( childPaths != null && ! childPaths . isEmpty ( ) ) { this . children = new ArrayList < Entity > ( ) ; for ( Object childPath : childPaths ) { if ( ! childPath . equals ( this . path ) ) { this . children . add ( new ServletWarEntity ( this . servletContext , ( String ) childPath , metadataService ) ) ; } } } } else { this . fullName = path ; Set < ? > childPaths = getServletContext ( ) . getResourcePaths ( path ) ; if ( childPaths != null && ! childPaths . isEmpty ( ) ) { this . directory = true ; this . children = new ArrayList < Entity > ( ) ; for ( Object childPath : childPaths ) { if ( ! childPath . equals ( this . path ) ) { this . children . add ( new ServletWarEntity ( this . servletContext , ( String ) childPath , metadataService ) ) ; } } } else { this . directory = false ; } } } @ Override public boolean exists ( ) { boolean result = false ; try { result = ( isDirectory ( ) && getChildren ( ) != null ) || ( isNormal ( ) && getServletContext ( ) . getResource ( this . path ) != null ) ; } catch ( MalformedURLException e ) { Context . getCurrentLogger ( ) . log ( Level . WARNING , \"Unable to test the existence of the WAR resource\" , e ) ; } return result ; } @ Override public List < Entity > getChildren ( ) { return this . children ; } @ Override public String getName ( ) { int index = this . fullName", "gt": ". lastIndexOf ( \"/\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 116, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class AnnotationDefault_attribute extends Attribute { AnnotationDefault_attribute ( ClassReader cr , int name_index , int length ) throws IOException , Annotation . InvalidAnnotation { super ( name_index , length ) ; default_value = Annotation . element_value . read ( cr ) ; } public AnnotationDefault_attribute ( ConstantPool constant_pool , Annotation . element_value default_value ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . AnnotationDefault ) , default_value ) ; } public AnnotationDefault_attribute ( int name_index , Annotation . element_value default_value ) { super (", "gt": "name_index , default_value . length ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2052, "input": "<s> package controllers . camel ; import java . util . ArrayList ; import java . util . List ; import javax . inject . Inject ; import org . apache . camel . CamelContext ; import org . apache . camel . Endpoint ; import org . apache . camel . Route ; import org . apache . camel . RoutesBuilder ; import org . apache . camel . builder . RouteBuilder ; import play . Logger ; import play . modules . camel . CamelPlugin ; import play . mvc . Controller ; public class CamelApplication extends Controller { public static void index ( ) { List < Route > routes = CamelPlugin . getCamelContext ( )", "gt": ". getRoutes ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7925, "input": "<s> package com . sun . tools . javadoc ; import java . lang . reflect . Modifier ; import java . text . CollationKey ; import com . sun . javadoc . * ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . tree . JCTree . JCMethodDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Position ; public abstract class ExecutableMemberDocImpl extends MemberDocImpl implements ExecutableMemberDoc { protected final MethodSymbol sym ; public ExecutableMemberDocImpl ( DocEnv env , MethodSymbol sym , String rawDocs , JCMethodDecl tree , Position . LineMap lineMap ) { super ( env , sym , rawDocs , tree , lineMap ) ; this . sym = sym ; } public ExecutableMemberDocImpl ( DocEnv env , MethodSymbol sym ) { this ( env , sym , null , null , null ) ; } protected long getFlags ( ) { return sym . flags ( ) ; } protected ClassSymbol getContainingClass ( ) { return sym . enclClass ( ) ; } public boolean isNative ( ) { return Modifier . isNative ( getModifiers ( ) ) ; } public boolean isSynchronized ( ) { return Modifier . isSynchronized ( getModifiers ( ) ) ; } public boolean isVarArgs ( ) { return ( ( sym . flags ( ) & Flags . VARARGS ) != 0 && ! env . legacyDoclet ) ; } public boolean isSynthetic ( ) { return ( ( sym . flags ( ) & Flags . SYNTHETIC ) != 0 ) ; } public boolean isIncluded ( ) { return containingClass ( ) . isIncluded ( ) && env . shouldDocument ( sym ) ; } public ThrowsTag [ ] throwsTags ( ) { return comment ( ) . throwsTags ( ) ; } public ParamTag [ ] paramTags ( ) { return comment ( ) . paramTags ( ) ; } public ParamTag [ ] typeParamTags ( ) { return env . legacyDoclet ? new ParamTag [ 0 ] : comment ( ) . typeParamTags ( ) ; } public ClassDoc [ ] thrownExceptions ( ) { ListBuffer < ClassDocImpl > l = new ListBuffer < ClassDocImpl > ( ) ; for ( Type ex : sym . type . getThrownTypes ( ) ) { ex = env . types . erasure ( ex ) ; ClassDocImpl cdi = env . getClassDoc ( ( ClassSymbol ) ex . tsym ) ; if ( cdi != null ) l . append ( cdi ) ; } return l . toArray ( new ClassDocImpl [ l . length ( ) ] ) ; } public com . sun . javadoc . Type [ ] thrownExceptionTypes ( ) { return TypeMaker . getTypes ( env , sym . type . getThrownTypes ( ) ) ; } public Parameter [ ] parameters ( ) { List < VarSymbol > params = sym . params ( ) ; Parameter result [ ] = new Parameter [ params . length ( ) ] ; int i = 0 ; for ( VarSymbol param : params ) { result [ i ++ ] = new ParameterImpl ( env , param ) ; } return result ; } public TypeVariable [ ] typeParameters ( ) { if ( env . legacyDoclet ) { return new TypeVariable [ 0 ] ; } TypeVariable res [ ] = new TypeVariable [ sym . type . getTypeArguments ( ) . length ( ) ] ; TypeMaker . getTypes ( env , sym . type . getTypeArguments ( ) , res ) ; return res ; } public String signature ( ) { return makeSignature ( true ) ; } public String flatSignature ( ) { return makeSignature ( false ) ; } private String makeSignature ( boolean full ) { StringBuilder result = new StringBuilder ( ) ; result . append ( \"(\" ) ; for ( List < Type > types = sym", "gt": ". type . getParameterTypes ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2059, "input": "<s> package org . jscsi . initiator . example ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Random ; import org . jscsi . exception . ConfigurationException ; import org . jscsi . exception . NoSuchSessionException ; import org . jscsi . exception . TaskExecutionException ; import org . jscsi . initiator . Configuration ; import org . jscsi . initiator . Initiator ; public class SingleThreadedReadWrite { public static void main ( final String [ ] args ) throws NoSuchSessionException , TaskExecutionException , ConfigurationException { int numBlocks = 50 ; int address = 12345 ; ByteBuffer writeData = ByteBuffer . allocate ( 512 * numBlocks ) ; ByteBuffer readData = ByteBuffer . allocate ( 512 * numBlocks ) ; Random random = new Random ( System . currentTimeMillis ( ) ) ; random . nextBytes ( writeData . array ( ) ) ; String target = \"testing-xen2-disk1\" ; Initiator initiator = new Initiator ( Configuration . create ( ) ) ; initiator . createSession ( target ) ; initiator . write ( target , writeData , address , writeData . capacity ( ) ) ; initiator . read ( target , readData , address , readData . capacity ( ) ) ; initiator . closeSession ( target ) ; if ( ! Arrays . equals ( writeData . array ( )", "gt": ", readData . array ( ) ) )", "prediction": ") ;\n", "label": 1}
{"id": 4102, "input": "<s> package com . sun . tools . doclets . formats . html ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . builders . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class AnnotationTypeWriterImpl extends SubWriterHolderWriter implements AnnotationTypeWriter { protected AnnotationTypeDoc annotationType ; protected Type prev ; protected Type next ; public AnnotationTypeWriterImpl ( AnnotationTypeDoc annotationType , Type prevType , Type nextType ) throws Exception { super ( ConfigurationImpl . getInstance ( ) , DirectoryManager . getDirectoryPath ( annotationType . containingPackage ( ) ) , annotationType . name ( ) + \".html\" , DirectoryManager . getRelativePath ( annotationType . containingPackage ( ) . name ( ) ) ) ; this . annotationType = annotationType ; configuration . currentcd = annotationType . asClassDoc ( ) ; this . prev = prevType ; this . next = nextType ; } protected Content getNavLinkPackage ( ) { Content linkContent = getHyperLink ( \"package-summary.html\" , \"\" , packageLabel ) ; Content li = HtmlTree . LI ( linkContent ) ; return li ; } protected Content getNavLinkClass ( ) { Content li = HtmlTree . LI ( HtmlStyle . navBarCell1Rev , classLabel ) ; return li ; } protected Content getNavLinkClassUse ( ) { Content linkContent = getHyperLink ( \"class-use/\" + filename , \"\" , useLabel ) ; Content li = HtmlTree . LI ( linkContent ) ; return li ; } public Content getNavLinkPrevious ( ) { Content li ; if ( prev != null ) { Content prevLink = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS , prev . asClassDoc ( ) , \"\" , configuration . getText ( \"doclet.Prev_Class\" ) , true ) ) ) ; li = HtmlTree . LI ( prevLink ) ; } else li = HtmlTree . LI ( prevclassLabel ) ; return li ; } public Content getNavLinkNext ( ) { Content li ; if ( next != null ) { Content nextLink = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS , next . asClassDoc ( ) , \"\" , configuration . getText ( \"doclet.Next_Class\" ) , true ) ) ) ; li = HtmlTree . LI ( nextLink ) ; } else li = HtmlTree . LI ( nextclassLabel ) ; return li ; } public Content getHeader ( String header ) { String pkgname = ( annotationType . containingPackage ( ) != null ) ? annotationType . containingPackage ( ) . name ( ) : \"\" ; String clname = annotationType . name ( ) ; Content bodyTree = getBody ( true , getWindowTitle ( clname ) ) ; addTop ( bodyTree ) ; addNavLinks ( true , bodyTree ) ; bodyTree . addContent ( HtmlConstants . START_OF_CLASS_DATA ) ; HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . header ) ; if ( pkgname . length ( ) > 0 ) { Content pkgNameContent = new StringContent ( pkgname ) ; Content pkgNameDiv = HtmlTree . DIV ( HtmlStyle . subTitle , pkgNameContent ) ; div . addContent ( pkgNameDiv ) ; } LinkInfoImpl linkInfo = new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS_HEADER , annotationType , false ) ; Content headerContent = new StringContent ( header ) ; Content heading = HtmlTree . HEADING ( HtmlConstants .", "gt": "CLASS_PAGE_HEADING , true , HtmlStyle . title , headerContent ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2074, "input": "<s> package org . seage . grammar . iif ; import org . seage . grammar . Symbol ; import org . seage . grammar . GrammarRule ; import org . seage . grammar . NonterminalSymbol ; import java . util . * ; public class StatementDummyGrammarRule extends GrammarRule { private static final long serialVersionUID = 5468523999599985427L ; public StatementDummyGrammarRule ( int uniqueId ) { super ( new NonterminalSymbol ( \"STATEMENT\" ) , new Vector < Symbol > ( ) , uniqueId ) ; } public Object eval ( HashMap < ? , ? >", "gt": "symbolTable , NonterminalSymbol treePos ) throws Exception", "prediction": ") ;\n", "label": 1}
{"id": 2822, "input": "<s> class NotEnclClass { Object o", "gt": "= Object . this ;", "prediction": ";\n", "label": 0}
{"id": 2101, "input": "<s> package org . fuzzydb . util . context ; public interface IShutdown {", "gt": "void shutdown ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9857, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface PurgeReport extends ReportAttribute {", "gt": "PurgeReportAttribute getListAttribute ( ) ;", "prediction": "if ( )\n", "label": 0}
{"id": 2129, "input": "<s> package monbulk . shared . Services ; import java . util . ArrayList ; import com . google . gwt . core . client . GWT ; import monbulk . shared . util . MonbulkEnums ; import monbulk . shared . util . MonbulkEnums . ServiceNames ; public abstract class DictionaryService implements iService { public static DictionaryService get ( ) { try { DictionaryService service = ( DictionaryService ) ServiceRegistry . getService ( ServiceNames . Dictionary ) ; return service ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( e . toString ( ) ) ; } return null ; } public interface GetDictionaryHandler { public void onGetDictionary ( Dictionary dictionary ) ; } public interface DictionaryExistsHandler { public void onDictionaryExists ( String name , boolean exists ) ; } public interface GetDictionaryListHandler { public void onGetDictionaryList ( ArrayList < String > dictionaries ) ; } public interface RemoveDictionaryHandler { public void onRemoveDictionary ( String name ) ; } public interface CreateDictionaryHandler { public void onCreateDictionary ( String name ) ; } public interface AddEntryHandler { public void onAddEntry ( Dictionary dictionary , Dictionary . Entry entry ) ; } public interface AddEntriesHandler { public void onAddEntries ( Dictionary dictionary ) ; } public abstract void dictionaryExists ( String name , DictionaryExistsHandler handler ) ; public", "gt": "abstract void removeDictionary ( String name , RemoveDictionaryHandler handler ) ;", "prediction": "\n", "label": 1}
{"id": 5495, "input": "<s> public class Capture { final int k ; Capture ( int n ) { k = n ; } public static void main ( String args [ ] ) { final int j ; int k1 = new Capture ( 2 + ( j = 3 ) ) { int get ( ) { return k + j ; } } . get ( ) ; if ( k1 != 8 ) throw new Error (", "gt": "\"k1 = \" + k1 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2137, "input": "<s> package org . nuxeo . ecm . automation . client . jaxrs . spi . auth ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Date ; import java . util . Random ; import org . nuxeo . ecm . automation . client . jaxrs . spi . Connector ; import org . nuxeo . ecm . automation . client . jaxrs . spi . Request ; import org . nuxeo . ecm . automation . client . jaxrs . spi . RequestInterceptor ; import org . nuxeo . ecm . automation . client . jaxrs . util . Base64 ; public class PortalSSOAuthInterceptor implements RequestInterceptor { protected final String secret ; protected final String username ; public PortalSSOAuthInterceptor ( String secretKey , String userName ) { this . secret = secretKey ; this . username = userName ; } @ Override public void processRequest ( Request request , Connector connector ) { long ts = new Date ( ) . getTime ( ) ; long random = new Random ( ts ) . nextInt ( ) ; String clearToken = String . format ( \"%d:%d:%s:%s\" , ts , random , secret , username ) ; byte [ ] hashedToken ; try { hashedToken = MessageDigest . getInstance ( \"MD5\" ) . digest ( clearToken . getBytes ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new Error ( \"Cannot compute token\" , e ) ; } String base64HashedToken = Base64 . encode ( hashedToken ) ; request . put ( \"NX_TS\" , String . valueOf ( ts ) ) ; request . put ( \"NX_RD\" , String . valueOf ( random ) ) ; request .", "gt": "put ( \"NX_TOKEN\" , base64HashedToken ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6387, "input": "<s> package org . gk . engine . client . event ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBusIfc ; import jfreecode . gwt . event . client . bus . JsonConvert ; import org . gk . engine . client . IEngine ; import org . gk . engine . client . build . XComponent ; import org . gk . engine . client . build . js . XJavaScript ; import org . gk . engine . client . event . attrib . IAttribute ; import org . gk . engine . client . exception . GKEngineException ; import org . gk . engine . client . exception . InvalidValueException ; import org . gk . engine . client . i18n . EngineMessages ; import org . gk . engine . client . utils . ComponentUtils ; import org . gk . ui . client . com . form . gkMap ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . Info ; import com . google . gwt . core . client . JavaScriptObject ; import com . google . gwt . json . client . JSONArray ; import com . google . gwt . json . client . JSONObject ; public abstract class EventHandler implements IHandler { private final static String JAVASCRIPT = \"_gk_js_\" ; protected EventBusIfc bus = IEngine . bus ; private static Map < String , IHandler > handlerGroup = EventFactory . createHandlerGroup ( ) ; private static Map < String , IAttribute > attributeGroup = EventFactory . createAttributeGroup ( ) ; private static Map < String , EventType > eventTypeGroup = EventFactory . createEventTypeGroup ( ) ; private static IHandler getHandler ( String cmd ) { if ( ! handlerGroup . containsKey ( cmd ) ) { throw new GKEngineException ( EngineMessages . msg . error_handlerNotFound ( cmd ) ) ; } return handlerGroup . get ( cmd ) ; } private static IAttribute getAttribute ( String cmd ) { String key = cmd . toLowerCase ( ) ; if ( ! attributeGroup . containsKey ( key ) ) { Info . display ( EngineMessages . msg . warning ( ) , EngineMessages . msg . error_attributeNotImplement ( cmd ) ) ; } return attributeGroup . get ( key ) ; } public static EventType getEventType ( String eventType ) { String key = eventType . toLowerCase ( ) ; if ( ! eventTypeGroup . containsKey ( key ) ) { Info . display ( EngineMessages . msg . warning ( ) , EngineMessages . msg . error_eventTypeNotSupport ( eventType ) ) ; } return eventTypeGroup . get ( key ) ; } public static void doProcess ( String xComId , EventData ed , XComponent xCom , BaseEvent be ) { IHandler handler = EventHandler . getHandler ( ed . getCmd ( ) ) ; handler . process ( xComId , ed . getSources ( ) , ed . getTargets ( ) , xCom , be ) ; } public static Object getAttributeValue ( String id ) { Object value = null ; String [ ] dot = id . split ( IEventConstants . SPLIT_DOT ) ; Component com = ComponentUtils . findComponent ( dot [ 0 ] ) ; if ( com != null ) { if ( dot . length == 2 ) { value = getAttributeValue ( com , dot [ 1 ] ) ; } else if ( dot . length == 1 ) { value = getAttributeValue ( com ) ; } } return value ; } public static Object getAttributeValue ( Component com , String attribute ) { Object value = null ; IAttribute attrib = getAttribute ( attribute ) ; if ( attrib != null ) { value = attrib . getAttributeValue ( com ) ; } return value ; } public static Object getAttributeValue ( Component com ) { return getAttributeValue ( com , IEventConstants . ATTRIB_VALUE ) ; } public static void setAttributeValue ( String id , Object value ) { if ( id . equals ( JAVASCRIPT ) ) { new XJavaScript ( value + \"\" ) . createScriptNodeToExecute ( ) ; } else { String [ ] dot = id . split ( IEventConstants . SPLIT_DOT ) ; Component com = ComponentUtils . findComponent ( dot [ 0 ] ) ; if ( com != null ) { if ( dot . length == 2 ) { setAttributeValue ( com , dot [ 1 ] , value ) ; } else if ( dot . length == 1 ) { setAttributeValue ( com , value ) ; } } } } public static void setAttributeValue ( Component com , String attribute , Object value ) { IAttribute attrib = getAttribute ( attribute ) ; if ( attrib != null ) { try { attrib . setAttributeValue ( com , value ) ; } catch ( Exception e ) { throw new InvalidValueException ( EngineMessages . msg . error_invalidValue ( com . getId ( ) , value ) ) ; } } } public static void setAttributeValue ( Component com , Object value ) { setAttributeValue ( com , IEventConstants . ATTRIB_VALUE , value ) ; } protected Object eval ( String content ) { Object result = null ; if ( JsonConvert . isJSONString ( content ) ) { result = JsonConvert . jsonString2Object ( content ) ; } else { result = doEval ( content ) ; } return result ; } private native static Object doEval ( String content ) ; protected String prepareEventId ( List events ) { StringBuffer eventId = new StringBuffer ( \"\" ) ; if ( ! events . isEmpty ( ) ) { for ( Object value : events ) { EventValue ev = EventFactory . convertToEventValue ( value ) ; String content = ev . getContent ( ) ; switch ( ev . getType ( ) ) { case EXPR : eventId . append ( eval ( content ) ) ; break ; case ID : if ( content . matches ( \"\\\\w+\\\\.\\\\w+\" ) ) { eventId . append ( content ) ; } else { eventId . append ( getAttributeValue ( content ) ) ; } break ; case STRING : eventId . append ( content ) ; default : break ; } } } return eventId . toString ( ) ; } protected Map prepareInfo ( String srcId , List events ) { Map info = new gkMap ( ) ; info . put ( \"src\" , srcId ) ; info . put ( \"url\" , getURL ( ) ) ; if", "gt": "( ! events . isEmpty ( ) )", "prediction": "( )\n", "label": 0}
{"id": 2143, "input": "<s> package org . fusesource . hawtjournal . api ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicInteger ; import org . fusesource . hawtbuf . Buffer ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; public class JournalTest { protected static final int DEFAULT_MAX_BATCH_SIZE = 1024 * 1024 * 4 ; private Journal journal ; private File dir ; @ Before public void setUp ( ) throws Exception { dir = new File ( \"target/tests/JournalTest\" ) ; if ( dir . exists ( ) ) { deleteFilesInDirectory ( dir ) ; } else { dir . mkdirs ( ) ; } journal = new Journal ( ) ; journal . setDirectory ( dir ) ; configure ( journal ) ; journal . open ( ) ; } @ After public void tearDown ( ) throws Exception { journal . close ( ) ; deleteFilesInDirectory ( dir ) ; dir . delete ( ) ; } @ Test public void testLogWritingAndReplaying ( ) throws Exception { int iterations = 10 ; for ( int i = 0 ; i < iterations ; i ++ ) { boolean sync = i % 2 == 0 ? true : false ; journal . write ( ByteBuffer . wrap ( new String ( \"DATA\" + i ) . getBytes ( \"UTF-8\" ) ) , sync ) ; } int i = 0 ; for ( Location location : journal ) { ByteBuffer buffer = journal . read ( location ) ; assertEquals ( \"DATA\" + i ++ , new String ( buffer . array ( ) , \"UTF-8\" ) ) ; } } @ Test public void testLogRecovery ( ) throws Exception { int iterations = 10 ; for ( int i = 0 ; i < iterations ; i ++ ) { boolean sync = i % 2 == 0 ? true : false ; journal . write ( ByteBuffer . wrap ( new String ( \"DATA\" + i ) . getBytes ( \"UTF-8\" ) ) , sync ) ; } journal . close ( ) ; journal . open ( ) ; int i = 0 ; for ( Location location : journal ) { ByteBuffer buffer = journal . read ( location ) ; assertEquals ( \"DATA\" + i ++ , new String ( buffer . array ( ) , \"UTF-8\" ) ) ; } } @ Test public void testLogSpanningMultipleFiles ( ) throws Exception { int iterations = 1000 ; for ( int i = 0 ; i < iterations ; i ++ ) { boolean sync = i % 2 == 0 ? true : false ; journal . write ( ByteBuffer . wrap ( new String ( \"DATA\" + i ) . getBytes ( \"UTF-8\" ) ) , sync ) ; } int i = 0 ; for ( Location location : journal ) { ByteBuffer buffer = journal . read ( location ) ; assertEquals ( \"DATA\" + i ++ , new String ( buffer . array ( ) , \"UTF-8\" ) ) ; } } @ Test public void testLogCompaction ( ) throws Exception { int iterations = 1000 ; for ( int i = 0 ; i < iterations / 2 ; i ++ ) { boolean sync = i % 2 == 0 ? true : false ; Location toDelete = journal . write ( ByteBuffer . wrap ( new String ( \"DATA\" + i ) . getBytes ( \"UTF-8\" ) ) , sync ) ; journal . delete ( toDelete ) ; } for ( int i = iterations / 2 ; i < iterations ; i ++ ) { boolean sync = i % 2 == 0 ? true : false ; journal . write ( ByteBuffer . wrap ( new String ( \"DATA\" + i ) . getBytes ( \"UTF-8\" ) ) , sync ) ; } int preCleanupFiles = journal .", "gt": "getFiles ( ) . size ( ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6345, "input": "<s> package org . ofbiz . webapp . event ; import java . lang . reflect . Method ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public class JavaEventHandler implements EventHandler { public static final String module = JavaEventHandler . class . getName ( ) ; private Map < String , Class < ? > > eventClassMap = FastMap . newInstance ( ) ; public void init ( ServletContext context ) throws EventHandlerException { } public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse response ) throws EventHandlerException { Class < ? > eventClass = this . eventClassMap . get ( event . path ) ; if ( eventClass == null ) { synchronized ( this ) { eventClass = this . eventClassMap . get ( event . path ) ; if ( eventClass == null ) { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; eventClass = loader . loadClass ( event . path ) ; } catch ( ClassNotFoundException e ) { Debug . logError ( e , \"Error loading class with name: \" + event . path + \", will not be able to run event...\" , module ) ; } if ( eventClass != null ) { eventClassMap . put ( event . path , eventClass ) ; } } } } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"[Set path/method]: \" + event . path + \" / \" + event . invoke , module ) ; Class < ? > [ ] paramTypes = new Class < ? > [ ] { HttpServletRequest . class , HttpServletResponse . class } ; Debug . logVerbose ( \"*[[Event invocation]]*\" , module ) ; Object [ ] params = new Object [ ] { request , response } ; return invoke ( event . path , event . invoke", "gt": ", eventClass , paramTypes , params ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2146, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . spy ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyZeroInteractions ; import junit . framework . TestCase ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ArmEvent ; import org . eclipse . swt . events . ArmListener ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . DragDetectEvent ; import org . eclipse . swt . events . DragDetectListener ; import org . eclipse . swt . events . ExpandEvent ; import org . eclipse . swt . events . ExpandListener ; import org . eclipse . swt . events . FocusEvent ; import org . eclipse . swt . events . FocusListener ; import org . eclipse . swt . events . HelpEvent ; import org . eclipse . swt . events . HelpListener ; import org . eclipse . swt . events . KeyAdapter ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . KeyListener ; import org . eclipse . swt . events . MenuDetectEvent ; import org . eclipse . swt . events . MenuDetectListener ; import org . eclipse . swt . events . MenuEvent ; import org . eclipse . swt . events . MenuListener ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseListener ; import org . eclipse . swt . events . PaintEvent ; import org . eclipse . swt . events . PaintListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org .", "gt": "eclipse . swt . events . ShellAdapter ;", "prediction": "eclipse . eclipse . ;\n", "label": 1}
{"id": 2996, "input": "<s> package org . gk . engine . client . build . tree ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventObject ; import org . gk . engine . client . build . panel . XContentPanel ; import org . gk . engine . client . event . EventCenter ; import org . gk . engine . client . gen . UIGen ; import org . gk . engine . client . res . UIRes ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . tree . xml . gkXMLTreeGridIC ; import com . extjs . gxt . ui . client . data . BaseTreeModel ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . TreeGridEvent ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; import com . extjs . gxt . ui . client . widget . grid . ColumnModel ; import com . extjs . gxt . ui . client . widget . grid . HeaderGroupConfig ; import com . extjs . gxt . ui . client . widget . treegrid . TreeGridCellRenderer ; import com . google . gwt . resources . client . ImageResource ; import com . google . gwt . user . client . ui . AbstractImagePrototype ; import com . google . gwt . xml . client . Node ; public class XTreeGrid extends XContentPanel { protected String name , value ; protected String autoExpand ; protected String onClick ; public XTreeGrid ( Node node , List < UIGen > widgets ) { super ( node , widgets ) ; name = super . getAttribute ( \"name\" , \"ROOT\" ) ; value = super . getAttribute ( \"value\" , \"ROOT\" ) ; autoExpand = super . getAttribute ( \"autoExpand\" , \"\" ) ; onClick = super . getAttribute ( \"onClick\" , \"\" ) ; } @ Override public Component build ( ) { final List fields = new gkList < ColumnConfig > ( ) ; final List header = new gkList < Map > ( ) ; final List aggRow = new gkList < Map > ( ) ; Iterator < UIGen > it = widgets . iterator ( ) ; boolean isSetRender = false ; while ( it . hasNext ( ) ) { UIGen ui = it . next ( ) ; Component com = ui . build ( ) ; Object obj = com . getData ( \"columnConfig\" ) ; if ( obj instanceof ColumnConfig ) { if ( isSetRender == false ) { ( ( ColumnConfig ) obj ) .", "gt": "setRenderer ( new TreeGridCellRenderer < ModelData > ( ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 2161, "input": "<s> package com . corundumstudio . socketio . transport ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import org . jboss . netty . channel . ChannelFuture ; import org . jboss . netty . channel . ChannelFutureListener ; import org . jboss . netty . channel . ChannelHandler . Sharable ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . MessageEvent ; import org . jboss . netty . channel . SimpleChannelUpstreamHandler ; import org . jboss . netty . util . CharsetUtil ; import com . corundumstudio . socketio . SocketIOPipelineFactory ; @ Sharable public class FlashPolicyHandler extends SimpleChannelUpstreamHandler { private final ChannelBuffer requestBuffer = ChannelBuffers . copiedBuffer ( \"<policy-file-request/>\" , CharsetUtil . UTF_8 ) ; private final ChannelBuffer responseBuffer = ChannelBuffers . copiedBuffer ( \"<?xml version=\\\"1.0\\\"?>\" + \"<!DOCTYPE cross-domain-policy SYSTEM \\\"/xml/dtds/cross-domain-policy.dtd\\\">\" + \"<cross-domain-policy> \" + \"   <site-control permitted-cross-domain-policies=\\\"master-only\\\"/>\" + \"   <allow-access-from domain=\\\"*\\\" to-ports=\\\"*\\\" />\" + \"</cross-domain-policy>\" , CharsetUtil . UTF_8 ) ; @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { ChannelBuffer inBuffer = ( ChannelBuffer ) e . getMessage ( ) ; ChannelBuffer data = inBuffer . slice ( 0 , requestBuffer . readableBytes ( ) ) ; if ( data . equals ( requestBuffer ) ) { ChannelFuture f = e . getChannel ( ) . write ( responseBuffer ) ; f . addListener", "gt": "( ChannelFutureListener . CLOSE ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8354, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Credit extends AccountAttribute { String getDate ( ) ; void setDate ( String value ) ; String getDescription ( ) ; void setDescription ( String value ) ; float getAmount ( ) ; void setAmount", "gt": "( float value ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2181, "input": "<s> package org . eclipse . swt . internal . widgets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . internal . SerializableCompatibility ; public final class ListModel implements SerializableCompatibility { private static final int [ ] EMPTY_SELECTION = new int [ 0 ] ; private final boolean single ; private final java . util . List < String > items ; private int [ ] selection ; public ListModel ( boolean single ) { this . single = single ; items = new ArrayList < String > ( ) ; selection = EMPTY_SELECTION ; } public int getSelectionIndex ( ) { int result = - 1 ; if ( selection . length > 0 ) { result = selection [ 0 ] ; } return result ; } public int [ ] getSelectionIndices ( ) { int [ ] result = new int [ selection . length ] ; System . arraycopy ( selection , 0 , result , 0 , selection . length ) ; return result ; } public int getSelectionCount ( ) { return selection . length ; } public void setSelection ( int selection ) { deselectAll ( ) ; if ( selection >= 0 && selection <= getItemCount ( ) - 1 ) { this . selection = new int [ ] { selection } ; } } public void setSelection ( int [ ] selection ) { if ( selection == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } deselectAll ( ) ; int length = selection . length ; if ( single ) { int end = getItemCount ( ) - 1 ; if ( length == 1 && selection [ 0 ] >= 0 && selection [ 0 ] <= end ) { this . selection = new int [ ] { selection [ 0 ] } ; } } else { int end = getItemCount ( ) - 1 ; int newLength = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( selection [ i ] >= 0 && selection [ i ] <= end ) { newLength ++ ; } } this . selection = new int [ newLength ] ; int pos = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( selection [ i ] >= 0 && selection [ i ] <= end ) { this . selection [ pos ] = selection [ i ] ; pos ++ ; } } } } public void setSelection ( int start , int end ) { deselectAll ( ) ; if ( end >= 0 && start <= end && start <= getItemCount ( ) - 1 ) { if ( single ) { if ( start == end ) { this . selection = new int [ ] { start } ; } } else { int first =", "gt": "Math . max ( 0 , start ) ;", "prediction": ";\n", "label": 1}
{"id": 7826, "input": "<s> package org . parboiled . parserunners ; import org . parboiled . BaseParser ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class RecoveryErrorActionsTest extends TestNgParboiledTest < Object > { @ BuildParseTree public static class Parser extends BaseParser < Object > { Rule Clause ( ) { return Sequence ( Seq ( ) , EOI ) ; } Rule Seq ( ) { return Sequence ( A ( ) , B ( ) , C ( ) , D ( ) ) ; } Rule A ( ) { return Sequence ( 'a' , push ( match ( ) ) ) ; } Rule B ( ) { return Sequence ( 'b' , push ( match ( ) ) ) ; } Rule C ( ) { return Sequence ( 'c' , push ( 1 ) ) ; } Rule D ( ) { return Sequence ( 'd' , push ( 2.0 ) ) ; } } @ Test public void testRecoveryErrorActions1 ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; testWithRecovery ( parser . Clause ( ) , \"abcd\" ) . hasNoErrors ( ) . hasResult ( \"a\" , \"b\" , 1 , 2.0 ) ; } @ Test public void testRecoveryErrorActions2 ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; testWithRecovery ( parser . Clause ( ) , \"axcd\" ) . hasErrors ( \"\" + \"Invalid input 'x', expected B (line 1, pos 2):\\n\" + \"axcd\\n\" + \" ^\\n\" ) . hasResult ( \"a\" , \"b\" , 1 , 2.0 ) ; } @ Test public void testRecoveryErrorActions3 ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; testWithRecovery ( parser . Clause ( ) , \"axx\" ) . hasErrors ( \"\" + \"Invalid input 'x...', expected B (line 1, pos 2):\\n\" + \"axx\\n\" + \" ^^\\n\" ) . hasResult ( \"a\" , \"\" , 1 , 2.0 ) ; } @ Test public void testRecoveryErrorActions4 ( ) { Parser parser = Parboiled . createParser (", "gt": "Parser . class ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2207, "input": "<s> package org . eclipse . ui . services ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . ui . ISources ; public interface IEvaluationService extends IServiceWithSources { public static final String RESULT = \"org.eclipse.ui.services.result\" ; public static final String PROP_NOTIFYING = \"org.eclipse.ui.services.notifying\" ; public void addServiceListener ( IPropertyChangeListener listener ) ; public void removeServiceListener ( IPropertyChangeListener listener ) ; public IEvaluationReference addEvaluationListener ( Expression expression , IPropertyChangeListener listener , String property ) ; public void addEvaluationReference ( IEvaluationReference ref ) ; public void", "gt": "removeEvaluationListener ( IEvaluationReference ref ) ;", "prediction": "( )\n", "label": 1}
{"id": 1279, "input": "<s> package gui ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . ScrollPaneConstants ; public class DisplayScrollPane extends JScrollPane { private static final long serialVersionUID = - 2561392613587167883L ; private final int scrollSpeed = 20 ; public DisplayScrollPane ( final JPanel innerPanel ) { super (", "gt": "innerPanel , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_NEVER ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2214, "input": "<s> package org . nuxeo . ecm . automation . core . events ; import java . util . List ; import java . util . Set ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventContext ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; public class EventHandlerRegistry { private static final Log log = LogFactory . getLog ( OperationEventListener . class ) ; protected final AutomationService svc ; protected EventRegistry handlers ; protected EventRegistry pchandlers ; public EventHandlerRegistry ( AutomationService svc ) { this . svc = svc ; handlers = new EventRegistry ( ) ; pchandlers = new EventRegistry ( ) ; } public List < EventHandler > getEventHandlers ( String eventId ) { return handlers . lookup ( ) . get ( eventId ) ; } public List < EventHandler > getPostCommitEventHandlers ( String eventId ) { return pchandlers . lookup ( ) . get ( eventId ) ; } public void putEventHandler ( EventHandler handler ) { handlers . addContribution ( handler ) ; } public synchronized void putPostCommitEventHandler ( EventHandler handler ) { pchandlers . addContribution ( handler ) ; } public synchronized void removePostCommitEventHandler ( EventHandler handler ) { pchandlers . removeContribution ( handler ) ; } public synchronized void removeEventHandler ( EventHandler handler ) { handlers . removeContribution ( handler ) ; } public synchronized void clear ( ) { handlers = new EventRegistry ( ) ; pchandlers = new EventRegistry ( ) ; } public Set < String > getPostCommitEventNames ( ) { return pchandlers . lookup ( ) . keySet ( ) ; } public boolean acceptEvent ( Event event , List < EventHandler > handlers ) { if ( handlers == null || handlers . isEmpty ( ) ) { return false ; } EventContext ectx = event . getContext ( ) ; OperationContext ctx ; if ( ectx instanceof DocumentEventContext ) { ctx = new OperationContext ( ectx . getCoreSession ( ) ) ; ctx . setInput ( ( ( DocumentEventContext ) ectx ) . getSourceDocument ( ) ) ; } else { ctx = new OperationContext ( ) ; } ctx . put ( \"Event\" , event ) ; for ( EventHandler handler : handlers ) { try { if ( handler . isEnabled ( ctx , ectx ) ) { return true ; } } catch ( Exception e ) { log . error ( \"Failed to check event \" + event . getName ( ) + \" using chain: \" + handler . getChainId ( ) , e ) ; } } return false ; } public void handleEvent ( Event event , List < EventHandler > handlers , boolean saveSession ) { if ( handlers == null || handlers . isEmpty ( ) ) { return ; } EventContext ectx = event . getContext ( ) ; OperationContext ctx = null ; for ( EventHandler handler : handlers ) { if ( ectx instanceof DocumentEventContext ) { ctx = new OperationContext ( ectx . getCoreSession ( ) ) ; ctx . setInput ( ( ( DocumentEventContext ) ectx ) . getSourceDocument ( ) ) ; } else { ctx = new OperationContext ( ) ; } ctx . put ( \"Event\" , event ) ; ctx . setCommit ( saveSession ) ; try { if ( handler . isEnabled ( ctx , ectx ) ) { svc . run ( ctx , handler . getChainId ( ) ) ; } } catch ( Exception e ) { log . error ( \"Failed to handle event \" + event . getName ( ) + \" using chain: \" + handler", "gt": ". getChainId ( ) , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4127, "input": "<s> package org . ofbiz . pos . screen ; import java . util . Iterator ; import java . util . Locale ; import java . util . Map ; import javax . swing . DefaultListModel ; import javax . swing . ListSelectionModel ; import javolution . util . FastMap ; import net . xoetrope . swing . XButton ; import net . xoetrope . swing . XDialog ; import net . xoetrope . swing . XList ; import net . xoetrope . xui . XPage ; import net . xoetrope . xui . events . XEventHelper ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . pos . PosTransaction ; @ SuppressWarnings ( \"serial\" ) public class LoadSale extends XPage { public static final String module = LoadSale . class . getName ( ) ; protected static PosScreen m_pos = null ; protected XDialog m_dialog = null ; static protected Map < String , String > m_saleMap = FastMap . newInstance ( ) ; protected XList m_salesList = null ; protected XButton m_cancel = null ; protected XButton m_add = null ; protected XButton m_replace = null ; protected XButton m_delete = null ; protected XButton m_replaceAndDelete = null ; protected DefaultListModel m_listModel = null ; protected static PosTransaction m_trans = null ; public LoadSale ( Map < String , String > saleMap , PosTransaction trans , PosScreen page ) { m_saleMap . putAll ( saleMap ) ; m_trans = trans ; m_pos = page ; } public void openDlg ( ) { m_dialog = ( XDialog ) pageMgr . loadPage ( m_pos . getScreenLocation ( ) + \"/dialog/loadsale\" ) ; m_dialog . setCaption ( UtilProperties . getMessage ( PosTransaction . resource , \"PosLoadASale\" , Locale . getDefault ( ) ) ) ; m_salesList = ( XList ) m_dialog . findComponent ( \"salesList\" ) ; XEventHelper . addMouseHandler ( this , m_salesList , \"saleDoubleClick\" ) ; m_cancel = ( XButton ) m_dialog . findComponent ( \"BtnCancel\" ) ; m_add = ( XButton ) m_dialog . findComponent ( \"BtnAdd\" ) ; m_replace = ( XButton ) m_dialog . findComponent ( \"BtnReplace\" ) ; m_delete = ( XButton ) m_dialog . findComponent ( \"BtnDelete\" ) ; m_replaceAndDelete = ( XButton ) m_dialog . findComponent ( \"BtnReplaceAndDelete\" ) ; XEventHelper . addMouseHandler ( this , m_cancel , \"cancel\" ) ; XEventHelper . addMouseHandler ( this , m_replace , \"replaceSale\" ) ; XEventHelper . addMouseHandler ( this , m_add , \"addSale\" ) ; XEventHelper . addMouseHandler ( this , m_delete , \"deleteShoppingList\" ) ; XEventHelper . addMouseHandler ( this , m_replaceAndDelete , \"replaceSaleAndDeleteShoppingList\" ) ; m_listModel = new DefaultListModel ( ) ; for ( Map . Entry < String , String > o : m_saleMap . entrySet ( ) ) { m_listModel . addElement ( o . getValue ( ) . toString ( ) ) ; } m_salesList . setModel ( m_listModel ) ; m_salesList . setVisibleRowCount ( - 1 ) ; m_salesList . ensureIndexIsVisible ( m_salesList . getItemCount ( ) ) ; m_salesList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; m_salesList . setToolTipText ( UtilProperties . getMessage ( PosTransaction . resource , \"PosLoadSaleListDblClickTip\" , Locale . getDefault ( ) ) ) ; m_dialog . pack ( ) ; m_salesList . requestFocusInWindow ( ) ; m_dialog . showDialog ( this ) ; } public synchronized void saleDoubleClick ( ) { if ( wasMouseDoubleClicked ( ) ) { String sale = selectedSale ( ) ; if ( null != sale ) { replaceSaleAndDeleteShoppingList_ ( ) ; } } } public synchronized void cancel ( ) { if ( wasMouseClicked ( ) ) { closeDlg ( ) ; } } public synchronized void addSale ( ) { if ( wasMouseClicked ( ) ) { addSale_ ( ) ; } } private synchronized void addSale_ ( ) { String sale = selectedSale ( ) ; if ( null != sale ) { addListToCart ( sale , true ) ; } } public synchronized void replaceSale ( ) { if ( wasMouseClicked ( ) ) { replaceSale_ ( ) ; } }", "gt": "private synchronized void replaceSale_ ( )", "prediction": "}\n", "label": 0}
{"id": 2239, "input": "<s> package org . apache . lucene . util ; import org . apache . lucene . search . DocIdSetIterator ; public class OpenBitSetIterator extends DocIdSetIterator { protected final static int [ ] bitlist = { 0x0 , 0x1 , 0x2 , 0x21 , 0x3 , 0x31 , 0x32 , 0x321 , 0x4 , 0x41 , 0x42 , 0x421 , 0x43 , 0x431 , 0x432 , 0x4321 , 0x5 , 0x51 , 0x52 , 0x521 , 0x53 , 0x531 , 0x532 , 0x5321 , 0x54 , 0x541 , 0x542 , 0x5421 , 0x543 , 0x5431 , 0x5432 , 0x54321 , 0x6 , 0x61 , 0x62 , 0x621 , 0x63 , 0x631 , 0x632 , 0x6321 , 0x64 , 0x641 , 0x642 , 0x6421 , 0x643 , 0x6431 , 0x6432 , 0x64321 , 0x65 , 0x651 , 0x652 , 0x6521 , 0x653 , 0x6531 , 0x6532 , 0x65321 , 0x654 , 0x6541 , 0x6542 , 0x65421 , 0x6543 , 0x65431 , 0x65432 , 0x654321 , 0x7 , 0x71 , 0x72 , 0x721 , 0x73 , 0x731 , 0x732 , 0x7321 , 0x74 , 0x741 , 0x742 , 0x7421 , 0x743 , 0x7431 , 0x7432 , 0x74321 , 0x75 , 0x751 , 0x752 , 0x7521 , 0x753 , 0x7531 , 0x7532 , 0x75321 , 0x754 , 0x7541 , 0x7542 , 0x75421 , 0x7543 , 0x75431 , 0x75432 , 0x754321 , 0x76 , 0x761 , 0x762 , 0x7621 , 0x763 , 0x7631 , 0x7632 , 0x76321 , 0x764 , 0x7641 , 0x7642 , 0x76421 , 0x7643 , 0x76431 , 0x76432 , 0x764321 , 0x765 , 0x7651 , 0x7652 , 0x76521 , 0x7653 , 0x76531 , 0x76532 , 0x765321 , 0x7654 , 0x76541 , 0x76542 , 0x765421 , 0x76543 , 0x765431 , 0x765432 , 0x7654321 , 0x8 , 0x81 , 0x82 , 0x821 , 0x83 , 0x831 , 0x832 , 0x8321 , 0x84 , 0x841 , 0x842 , 0x8421 , 0x843 , 0x8431 , 0x8432 , 0x84321 , 0x85 , 0x851 , 0x852 , 0x8521 , 0x853 , 0x8531 , 0x8532 , 0x85321 , 0x854 , 0x8541 , 0x8542 , 0x85421 , 0x8543 , 0x85431 , 0x85432 , 0x854321 , 0x86 , 0x861 , 0x862 , 0x8621 , 0x863 , 0x8631 , 0x8632 , 0x86321 , 0x864 , 0x8641 , 0x8642 , 0x86421 , 0x8643 , 0x86431 , 0x86432 , 0x864321 , 0x865 , 0x8651 , 0x8652 , 0x86521 , 0x8653 , 0x86531 , 0x86532 , 0x865321 , 0x8654 , 0x86541 , 0x86542 , 0x865421 , 0x86543 , 0x865431 , 0x865432 , 0x8654321 , 0x87 , 0x871 , 0x872 , 0x8721 , 0x873 , 0x8731 , 0x8732 , 0x87321 , 0x874 , 0x8741 , 0x8742 , 0x87421 , 0x8743 , 0x87431 , 0x87432 , 0x874321 , 0x875 , 0x8751 , 0x8752 , 0x87521 , 0x8753 , 0x87531 , 0x87532 , 0x875321 , 0x8754 , 0x87541 , 0x87542 , 0x875421 , 0x87543 , 0x875431 , 0x875432 , 0x8754321 , 0x876 , 0x8761 , 0x8762 , 0x87621 , 0x8763 , 0x87631 , 0x87632 , 0x876321 , 0x8764 , 0x87641 , 0x87642 , 0x876421 , 0x87643 , 0x876431 , 0x876432 , 0x8764321 , 0x8765 , 0x87651 , 0x87652 , 0x876521 , 0x87653 , 0x876531 , 0x876532 , 0x8765321 , 0x87654 , 0x876541 , 0x876542 , 0x8765421 , 0x876543 , 0x8765431 , 0x8765432 , 0x87654321 } ; private final long [ ] arr ; private final int words ; private int i = - 1 ; private long word ; private int wordShift ; private int indexArray ; private int curDocId = - 1 ; public OpenBitSetIterator ( OpenBitSet obs ) { this ( obs . getBits ( ) , obs . getNumWords ( ) ) ; } public OpenBitSetIterator ( long [ ] bits , int numWords ) { arr = bits ; words = numWords ; } private void shift ( ) { if ( ( int ) word == 0 ) { wordShift += 32 ; word = word > > > 32 ; } if ( ( word & 0x0000FFFF ) == 0 ) { wordShift += 16 ; word >>>= 16 ; } if ( ( word & 0x000000FF ) == 0 ) { wordShift += 8 ; word >>>= 8 ; } indexArray = bitlist [ ( int ) word & 0xff ] ; } public boolean next ( ) { return nextDoc ( ) != NO_MORE_DOCS ; } public int nextDoc ( ) { if ( indexArray == 0 ) { if ( word != 0 ) { word >>>= 8 ; wordShift += 8 ; } while ( word == 0 ) { if ( ++ i >= words ) { return curDocId = NO_MORE_DOCS ; } word = arr [ i ] ; wordShift = - 1 ; } shift ( ) ; } int bitIndex = ( indexArray & 0x0f ) + wordShift ; indexArray >>>= 4 ; return curDocId = ( i << 6 ) + bitIndex ; } public boolean skipTo ( int target ) { return advance ( target ) != NO_MORE_DOCS ; } public int advance ( int target ) { indexArray = 0 ; i = target > > 6 ; if ( i >= words ) { word = 0 ; return curDocId = NO_MORE_DOCS ; } wordShift = target & 0x3f ; word = arr [ i ] > > > wordShift ; if ( word != 0 ) { wordShift -- ; } else { while ( word == 0 ) {", "gt": "if ( ++ i >= words )", "prediction": "\n", "label": 1}
{"id": 4676, "input": "<s> package src ; import java . io . File ; import org . bukkit . event . block . BlockBreakEvent ; import org . bukkit . event . player . PlayerJoinEvent ; import org . bukkit . event . player . PlayerQuitEvent ; import LizaCraft . LizaCraftTestModule ; public class BobTest { public static void main ( String [ ] args ) { File plugin = new File ( \"bobplugin.jar\" ) ; if ( plugin . exists ( ) ) { LizaCraftTestModule testModule = new LizaCraftTestModule ( \"Bob's Test\" ) ; testModule . startModule ( ) ; testModule . getServer ( ) ; testModule . enableEvents ( ) ; testModule . getEventListener ( ) . registerEvent ( PlayerJoinEvent . class ) ; testModule . getEventListener ( ) . registerEvent ( BlockBreakEvent . class ) ; testModule . getEventListener ( ) . registerEvent ( PlayerQuitEvent . class ) ; testModule . waitForEvent ( PlayerJoinEvent . class ) ; testModule . waitForEvent ( BlockBreakEvent . class ) ; testModule . getServer ( ) . broadcastMessage ( \"Loading plugin now\" ) ; testModule . loadPlugin ( plugin ) ; testModule . waitForEvent ( BlockBreakEvent . class ) ; testModule . getServer ( ) . broadcastMessage ( \"Disabling plugin now\" ) ; testModule . disablePlugin ( plugin ) ; testModule . waitForEvent ( PlayerQuitEvent . class ) ; } else { System .", "gt": "out . println ( \"File not found!\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 2255, "input": "<s> package org . restlet . example . book . restlet .", "gt": "ch05 . sec4 . common ;", "prediction": ";\n", "label": 1}
{"id": 2023, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . matchervisitors . MatcherVisitor ; import org . parboiled . support . Chars ; public class AnyMatcher extends AbstractMatcher { public AnyMatcher ( ) { super ( \"ANY\" ) ; } public boolean match ( MatcherContext context ) { switch ( context . getCurrentChar ( ) ) { case Chars . DEL_ERROR : case Chars . INS_ERROR : case Chars . RESYNC : case Chars . RESYNC_START : case Chars . RESYNC_END : case Chars . RESYNC_EOI : case Chars . EOI : return false ; } context . advanceIndex ( 1 ) ; context . createNode ( ) ; return true ; } public < R", "gt": "> R accept ( MatcherVisitor < R > visitor )", "prediction": "( )\n", "label": 0}
{"id": 2272, "input": "<s> package org . nuxeo . ecm . platform . audit . api ; import java . util . Date ; import java . util . List ; import java . util . Map ; public interface AuditReader { List < LogEntry > getLogEntriesFor ( String uuid ) ; List < LogEntry > getLogEntriesFor ( String uuid , Map < String , FilterMapEntry > filterMap , boolean doDefaultSort ) ; LogEntry getLogEntryByID ( long id ) ; List < LogEntry > queryLogs ( String [ ] eventIds , String dateRange ) ; List < LogEntry > queryLogsByPage ( String [ ] eventIds , String dateRange , String category , String path , int pageNb , int pageSize ) ; List < LogEntry > queryLogsByPage ( String [ ] eventIds , String dateRange , String [ ] category , String path , int pageNb , int pageSize ) ; List < LogEntry > queryLogsByPage ( String [ ] eventIds , Date limit , String category , String path , int pageNb , int pageSize ) ; List < LogEntry > queryLogsByPage ( String [ ] eventIds , Date limit , String [ ] category , String path , int", "gt": "pageNb , int pageSize ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2766, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . text . JTextComponent ; import javax . swing . border . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import javax . swing . plaf . metal . * ; import java . awt . * ; public class PgsBorders { public static class Generic extends AbstractBorder implements UIResource { private Insets insets ; private Color color ; public Generic ( Insets insets , Color color ) { this . insets = insets ; this . color = color ; } public void paintBorder ( Component c , Graphics g , int x , int y , int width , int height ) { g . setColor ( color ) ; if ( insets . left != 0 ) { g . fillRect ( x , y , x + insets . left , y + height ) ; } if ( insets . right != 0 ) { g . fillRect ( x + width - insets . right , y , x + width , y + height ) ; } if ( insets . top != 0 ) { g . fillRect ( x , y , x + width , x + insets . top ) ; } if ( insets . bottom != 0 ) { g . fillRect ( x , y + height - insets . bottom , x + width , y + height ) ; } } public Insets getBorderInsets ( Component c ) { return insets ; } public Insets getBorderInsets ( Component c , Insets insets ) { return insets ; } } private static Border buttonBorder ; public static Border getButtonBorder ( ) { if ( buttonBorder == null ) { buttonBorder = new BorderUIResource . CompoundBorderUIResource ( new ButtonBorder ( ) , new BasicBorders . MarginBorder ( ) ) ; } return buttonBorder ; } private static class ButtonBorder extends AbstractBorder implements UIResource { protected static final Insets INSETS = new Insets ( 3 , 4 , 3 , 4 ) ; protected static final Insets NO_INSETS = new Insets ( 0 , 0 , 0 , 0 ) ; public void paintBorder ( Component c , Graphics g , int x , int y , int w , int h ) { AbstractButton button = ( AbstractButton ) c ; ButtonModel model = button . getModel ( ) ; if ( model . isEnabled ( ) ) { if ( model . isRollover ( ) && PlafOptions . isPaintRolloverButtonBorder ( ) ) { PgsUtils . drawRolloverButtonBorder ( g , x , y , w , h ) ; } else { PgsUtils . drawButtonBorder ( g , x , y , w , h ) ; } } else { PgsUtils . drawDisabledBorder ( g , x , y , w - 1 , h - 1 ) ; } } public Insets getBorderInsets ( Component c ) { if ( ( ( AbstractButton ) c ) . isBorderPainted ( ) ) { return INSETS ; } return NO_INSETS ; } public Insets getBorderInsets ( Component c , Insets newInsets ) { if ( ( ( AbstractButton ) c ) . isBorderPainted ( ) ) { return getBorderInsets ( c , newInsets , INSETS ) ; } return getBorderInsets ( c , newInsets , NO_INSETS ) ; } public Insets getBorderInsets ( Component c , Insets newInsets , Insets oldInsets ) { newInsets . top = oldInsets . top ; newInsets . left = oldInsets . left ; newInsets . bottom = oldInsets . bottom ; newInsets . right = oldInsets . right ; return newInsets ; } } private static Border textFieldBorder ; public static Border getTextFieldBorder ( ) { if ( textFieldBorder == null ) { textFieldBorder = new BorderUIResource . CompoundBorderUIResource ( new TextFieldBorder ( ) , new BasicBorders . MarginBorder ( ) ) ; } return textFieldBorder ; } private static class TextFieldBorder extends AbstractBorder { private static final Insets INSETS = new Insets ( 1 , 1 , 1 , 1 ) ; public void paintBorder ( Component c , Graphics g , int x , int y ,", "gt": "int w , int h )", "prediction": ") ;\n", "label": 0}
{"id": 2280, "input": "<s> package com . talis . hbase . rdf . examples . benchmarks . sp2b ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . talis . hbase . rdf . HBaseRdfFactory ; import com . talis . hbase . rdf . Store ; public class Sp2BenchQ11 { public static void main ( String [ ] args ) { Store store = HBaseRdfFactory . connectStore ( args [ 0 ] ) ; Model model = HBaseRdfFactory . connectNamedModel ( store , args [ 1 ] ) ; int numOfRuns = new Integer ( args [ 2 ] ) . intValue ( ) ; for ( int i = 1 ; i <= numOfRuns ; i ++ ) { long count = 0L ; long startTime = System . nanoTime ( ) ; try { String queryString = \" PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> \" + \" SELECT ?ee \" + \" WHERE { \" + \" \t\t\t?publication rdfs:seeAlso ?ee \" + \"\t\t} \" + \" ORDER BY ?ee \" + \" LIMIT 10 \" + \" OFFSET 50\t\" ; QueryExecution qexec = QueryExecutionFactory . create ( queryString , model ) ; ResultSet rs = qexec . execSelect ( ) ; while (", "gt": "rs . hasNext ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 4842, "input": "<s> package com . sun . tools . javac . util ; import java . util . Set ; import java . util . Locale ; import javax . tools . Diagnostic ; import com . sun . tools . javac . api . DiagnosticFormatter ; import com . sun . tools . javac . api . DiagnosticFormatter . Configuration ; import com . sun . tools . javac . api . DiagnosticFormatter . Configuration . DiagnosticPart ; import com . sun . tools . javac . api . DiagnosticFormatter . Configuration . MultilineLimit ; import com . sun . tools . javac . api . DiagnosticFormatter . PositionKind ; public class ForwardingDiagnosticFormatter < D extends Diagnostic < ? > , F extends DiagnosticFormatter < D > > implements DiagnosticFormatter < D > { protected F formatter ; protected ForwardingConfiguration configuration ; public ForwardingDiagnosticFormatter ( F formatter ) { this . formatter = formatter ; this . configuration = new ForwardingConfiguration ( formatter . getConfiguration ( ) ) ; } public F getDelegatedFormatter ( ) { return formatter ; } public Configuration getConfiguration ( ) { return configuration ; } public boolean displaySource ( D diag ) { return formatter . displaySource ( diag ) ; } public String format ( D diag , Locale l ) { return formatter . format ( diag , l ) ; } public String formatKind ( D diag , Locale l ) { return formatter . formatKind ( diag , l ) ; } public String formatMessage ( D diag , Locale l ) { return formatter . formatMessage ( diag , l ) ; } public String formatPosition ( D diag , PositionKind pk , Locale l ) { return formatter . formatPosition ( diag , pk , l ) ; } public String formatSource (", "gt": "D diag , boolean fullname , Locale l )", "prediction": ")\n", "label": 0}
{"id": 2313, "input": "<s> package org . gatein . common . util ; import org . gatein . common . net . media . MediaType ; public class MarkupInfo extends ContentInfo { private final String charset ; public MarkupInfo ( MediaType mediaType , String charset ) { super ( mediaType ) ; if", "gt": "( charset == null )", "prediction": "( )\n", "label": 1}
{"id": 3808, "input": "<s> package hotspot . evil . util ; public class RuntimeProperties { public static final int VM_ARCH_DATA_MODEL ; public static final String VM_NAME ; public static final String OS_ARCH ; public static final Endian CPU_ENDIAN ; public static final int OBJECT_HEADER_SIZE ; static { VM_ARCH_DATA_MODEL = getArchDataModel ( ) ; VM_NAME = getVMName ( ) ; OS_ARCH = getOSArch ( ) ; CPU_ENDIAN = Endian . current ( ) ; OBJECT_HEADER_SIZE = Unsafes . getObjectHeaderSize ( ) ; } private static int getArchDataModel ( ) { String archDataModelStr = System . getProperty ( \"sun.arch.data.model\" ) ; int archDataModel ; try { archDataModel = Integer . parseInt ( archDataModelStr ) ; } catch ( NumberFormatException nfe ) { archDataModel = - 1 ; } return archDataModel ; } private static String getVMName ( ) {", "gt": "return System . getProperty ( \"java.vm.name\" ) ;", "prediction": "\n", "label": 0}
{"id": 2336, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . web . ejb ; import static org . jboss . seam . ScopeType . CONVERSATION ; import static org . jboss . seam . ScopeType . EVENT ; import java . io . Serializable ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Observer ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . annotations . intercept . BypassInterceptors ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . platform . userworkspace . constants . UserWorkspaceConstants ; import org . nuxeo . ecm . webapp . helpers . EventNames ; @ Scope ( CONVERSATION ) @ Name ( \"userWorkspaceChecker\" ) public class UserWorkspaceCheckerActionsBean implements Serializable { private static final long serialVersionUID = 1L ; @ In ( create = true ) protected transient NavigationContext navigationContext ; @ In ( required = false , create = true ) protected transient CoreSession documentManager ; protected Boolean isUserWorkspace ; protected String currentPersonalWorkspacePath ; @ Factory ( value = \"isUserWorkspace\" , scope = EVENT ) public Boolean computeIsUserWorkspace ( ) { if ( isUserWorkspace == null && navigationContext . getCurrentDocument ( ) != null ) { isUserWorkspace = navigationContext . getCurrentDocument ( ) . getPathAsString ( ) . contains ( UserWorkspaceConstants . USERS_PERSONAL_WORKSPACES_ROOT ) ; } return isUserWorkspace ; } @ Factory ( value = \"currentPersonalWorkspacePath\" , scope = EVENT ) public String getCurrentPersonalWorkspace ( ) throws ClientException { if ( currentPersonalWorkspacePath == null && Boolean . TRUE . equals ( isUserWorkspace ) ) { Path path = navigationContext . getCurrentDocument ( ) . getPath ( ) ; String lastSegment = \"\" ; while ( ! path . isRoot ( ) || ! path . isEmpty ( ) ) { if ( UserWorkspaceConstants . USERS_PERSONAL_WORKSPACES_ROOT . equals ( path . lastSegment ( ) ) ) { if ( lastSegment . isEmpty ( ) ) { currentPersonalWorkspacePath = \"\" ; } else { currentPersonalWorkspacePath = path . append ( lastSegment ) . toString ( ) ; } return currentPersonalWorkspacePath ; } else { lastSegment = path . lastSegment ( ) ; } path = path . removeLastSegments ( 1 ) ; } } return currentPersonalWorkspacePath ; } @ Observer ( value = { EventNames .", "gt": "USER_ALL_DOCUMENT_TYPES_SELECTION_CHANGED , EventNames . LOCATION_SELECTION_CHANGED }", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6411, "input": "<s> public class TestLinkTaglet extends JavadocTester { private static final String BUG_ID = \"4732864-6280605\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" , SRC_DIR + FS + \"checkPkg\" + FS + \"B.java\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"Qualified Link: <a href=\\\"../pkg/C.InnerC.html\\\" title=\\\"class in pkg\\\"><code>C.InnerC</code></a>.<br/>\\n\" + \" Unqualified Link1: <a href=\\\"../pkg/C.InnerC.html\\\" title=\\\"class in pkg\\\"><code>C.InnerC</code></a>.<br/>\\n\" + \" Unqualified Link2: <a href=\\\"../pkg/C.InnerC.html\\\" title=\\\"class in pkg\\\"><code>C.InnerC</code></a>.<br/>\\n\" + \" Qualified Link: <a href=\\\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\\\"><code>method(pkg.C.InnerC, pkg.C.InnerC2)</code></a>.<br/>\\n\" + \" Unqualified Link: <a href=\\\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\\\"><code>method(C.InnerC, C.InnerC2)</code></a>.<br/>\\n\" + \" Unqualified Link: <a href=\\\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\\\"><code>method(InnerC, InnerC2)</code></a>.<br/>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.InnerC.html\" , \"Link to member in outer class: <a href=\\\"../pkg/C.html#MEMBER\\\"><code>C.MEMBER</code></a> <br/>\\n\" + \" Link to member in inner class: <a href=\\\"../pkg/C.InnerC2.html#MEMBER2\\\"><code>C.InnerC2.MEMBER2</code></a> <br/>\\n\" + \" Link to another inner class: <a href=\\\"../pkg/C.InnerC2.html\\\" title=\\\"class in pkg\\\"><code>C.InnerC2</code></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.InnerC2.html\" , \"<dl>\" + NL + \"<dt>Enclosing class:</dt>\" + NL + \"<dd><a href=\\\"../pkg/C.html\\\" title=\\\"class in pkg\\\">C</a></dd>\" + NL + \"</dl>\" } , } ; private static final String [ ] [ ] NEGATED_TEST = { {", "gt": "WARNING_OUTPUT , \"Tag @see: reference not found: A\" }", "prediction": "return ;\n", "label": 0}
{"id": 2344, "input": "<s> package com . talis . hbase . rdf . layout . verticalpartitioning ; import java . util . Iterator ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . FmtLayout ; public class FmtLayoutVerticallyPartitioned extends FmtLayout { public FmtLayoutVerticallyPartitioned ( String storeName , HBaseRdfConnection connection ) { super ( storeName , connection ) ; } @ Override protected void formatTables ( ) { try { Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while ( iterTblNames . hasNext ( ) ) { String", "gt": "tblName = iterTblNames . next ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8137, "input": "<s> package org . ofbiz . widget ; import java . io . IOException ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . LocalDispatcher ; public interface ContentWorkerInterface { public GenericValue getCurrentContentExt ( Delegator delegator , List < Map < String , ? extends Object > > trail , GenericValue userLogin , Map < String , Object > ctx , Boolean nullThruDatesOnly , String contentAssocPredicateId ) throws GeneralException ; public GenericValue getWebSitePublishPointExt ( Delegator delegator , String contentId , boolean ignoreCache ) throws GenericEntityException ; public String getMimeTypeIdExt ( Delegator delegator , GenericValue view , Map < String , Object > ctx ) ; public void renderContentAsTextExt ( LocalDispatcher dispatcher , Delegator delegator , String contentId , Appendable out , Map < String , Object > templateContext , Locale locale , String mimeTypeId , boolean cache ) throws GeneralException , IOException ; public String renderContentAsTextExt ( LocalDispatcher dispatcher , Delegator delegator , String contentId , Map < String , Object > templateContext , Locale locale , String mimeTypeId , boolean cache ) throws GeneralException , IOException ; public void renderSubContentAsTextExt ( LocalDispatcher dispatcher , Delegator delegator , String contentId , Appendable out , String mapKey , Map < String , Object > templateContext , Locale locale , String mimeTypeId ,", "gt": "boolean cache ) throws GeneralException , IOException ;", "prediction": ") ;\n", "label": 0}
{"id": 2349, "input": "<s> package org . nuxeo . theme . webwidgets ; import org . nuxeo . theme . fragments . AbstractFragment ; import org . nuxeo . theme . models . Model ; import org . nuxeo . theme . properties . FieldInfo ; public final class AreaFragment extends AbstractFragment { @ FieldInfo ( type = \"string\" , label = \"region name\" , description = \"The name of the region.\" , required = true ) public String name = \"\" ; @ FieldInfo ( type = \"selection\" , label = \"provider\" , source = \"web widget providers\" , description = \"The widget provider.\" , required = true ) public String provider = \"default\" ; @ FieldInfo ( type = \"selection\" , label = \"decoration\" , source = \"web widget decorations\" , description = \"The panel and widget decoration.\" , required = true ) public String decoration = \"default\" ; @ FieldInfo ( type = \"integer\" , label = \"maximum number of widgets\" , description = \"The maximum number of widgets allowed in this", "gt": "area.\" ) public Integer maxItems ;", "prediction": ";\n", "label": 1}
{"id": 1861, "input": "<s> import com . sun . tools . javac . code . BoundKind ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Symbol . * ; import java . lang . reflect . Array ; public class GenericTypeWellFormednessTest extends TypeHarness { static int executedCount = 0 ; static int ignoredCount = 0 ; InstantiableType [ ] rows ; Type [ ] columns ; static class InstantiableType { protected Type type ; public InstantiableType ( Type type ) { this . type = type ; } Type inst ( Type clazz ) { return type ; } } enum Result { OK ( true ) , FAIL ( false ) , IGNORE ( false ) ; boolean value ; Result ( boolean value ) { this . value = value ; } } static final Result T = Result . OK ; static final Result F = Result . FAIL ; static final Result I = Result . IGNORE ; Result [ ] [ ] isValidInstantiation = { { T , T , F , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , F , F , F , F , F } , { T , T , F , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , F , F , F , F , F } , { T , T , F , T , T , T , T } , { T , T , I , I , I , I , I } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , T , F , F , F , F } , { T , T , F , F , F , F , F } , { T , T , F , F , F , F , F } , { T , T", "gt": ", T , F , F , F , F }", "prediction": ") ;\n", "label": 0}
{"id": 2355, "input": "<s> package org . eclipse . jface . fieldassist ; import java . io . Serializable ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Control ; public interface IControlContentAdapter extends Serializable { public void setControlContents ( Control control , String contents , int cursorPosition ) ; public void insertControlContents (", "gt": "Control control , String contents , int cursorPosition ) ;", "prediction": ")\n", "label": 1}
{"id": 8021, "input": "<s> import java . io . IOException ; import java . io . OutputStream ; import android . graphics . Bitmap ; import android . graphics . Bitmap . Config ; import android . graphics . Canvas ; import android . graphics . Paint ; public class AnimatedGifEncoder { protected int width ; protected int height ; protected int x = 0 ; protected int y = 0 ; protected int transparent = - 1 ; protected int transIndex ; protected int repeat = - 1 ; protected int delay = 0 ; protected boolean started = false ; protected OutputStream out ; protected Bitmap image ; protected byte [ ] pixels ; protected byte [ ] indexedPixels ; protected int colorDepth ; protected byte [ ] colorTab ; protected boolean [ ] usedEntry = new boolean [ 256 ] ; protected int palSize = 7 ; protected int dispose = - 1 ; protected boolean closeStream = false ; protected boolean firstFrame = true ; protected boolean sizeSet = false ; protected int sample = 10 ; public void setDelay ( int ms ) { delay = ms / 10 ; } public void setDispose ( int code ) { if ( code >= 0 ) { dispose = code ; } } public void setRepeat ( int iter ) { if ( iter >= 0 ) { repeat = iter ; } } public void setTransparent ( int c ) { transparent = c ; } public boolean addFrame ( Bitmap im ) { if ( ( im == null ) || ! started ) { return false ; } boolean ok = true ; try { if ( ! sizeSet ) { setSize ( im . getWidth ( ) , im . getHeight ( ) ) ; } image = im ; getImagePixels ( ) ; analyzePixels ( ) ; if ( firstFrame ) { writeLSD ( ) ; writePalette ( ) ; if ( repeat >= 0 ) { writeNetscapeExt ( ) ; } } writeGraphicCtrlExt ( ) ; writeImageDesc ( ) ; if ( ! firstFrame ) { writePalette ( ) ; } writePixels ( ) ; firstFrame = false ; } catch ( IOException e ) { ok = false ; } return ok ; } public boolean finish ( ) { if ( ! started ) return false ; boolean ok = true ; started = false ; try { out . write ( 0x3b ) ; out . flush ( ) ; if ( closeStream ) { out . close ( ) ; } } catch ( IOException e ) { ok = false ; } transIndex = 0 ; out = null ; image = null ; pixels = null ; indexedPixels = null ; colorTab = null ; closeStream = false ; firstFrame = true ; return ok ; } public void setFrameRate ( float fps ) { if ( fps != 0f ) { delay = ( int ) ( 100 / fps ) ; } } public void setQuality ( int quality ) { if ( quality", "gt": "< 1 ) quality = 1 ;", "prediction": ")\n", "label": 0}
{"id": 2376, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . gwt . client . util ; public class Point { private int x ; private int y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } public Point ( ) { this ( 0 , 0 ) ; } public void move", "gt": "( int x , int y )", "prediction": "( )\n", "label": 1}
{"id": 3643, "input": "<s> import java . io . IOException ; import java . net . URI ; import java . util . Arrays ; import java . util . Collections ; import java . util . Set ; import javax . annotation . processing . AbstractProcessor ; import javax . annotation . processing . RoundEnvironment ; import javax . annotation . processing . SupportedAnnotationTypes ; import javax . annotation . processing . SupportedSourceVersion ; import javax . annotation . processing . ProcessingEnvironment ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . ExecutableElement ; import javax . lang . model . element . TypeElement ; import javax . lang . model . type . ExecutableType ; import javax . lang . model . type . DeclaredType ; import javax . lang . model . type . TypeMirror ; import javax . lang . model . util . Elements ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . ToolProvider ; public class T6468404 extends ToolTester { void test ( String ... args ) { System . err . println ( \"Compiling with sources:\" ) ; task = tool . getTask ( null , fm , null , null , null , Collections . singleton ( new DummyFO ( \"C\" ) ) ) ; task . setProcessors ( Collections . singleton ( new P ( ) ) ) ; if ( ! task . call ( ) ) throw new AssertionError ( ) ; System . err . println ( \"Compiling with binaries w/o -g:\" ) ; task = tool . getTask ( null , fm , null , null , null , Collections . singleton ( new DummyFO ( \"Dummy\" ) ) ) ; task . setProcessors ( Collections . singleton ( new P ( ) ) ) ; if ( ! task . call ( ) ) throw new AssertionError ( ) ; task = tool . getTask ( null , fm , null , Arrays . asList ( \"-g\" ) , null , Collections . singleton ( new DummyFO ( \"C\" ) ) ) ; if ( ! task . call ( ) ) throw new AssertionError ( ) ; System . err . println ( \"Compiling with binaries w/ -g:\" ) ; task = tool . getTask ( null , fm , null , null , null , Collections . singleton ( new DummyFO ( \"Dummy\" ) ) ) ; task . setProcessors ( Collections . singleton ( new P ( ) ) ) ; if ( ! task . call ( ) ) throw new AssertionError ( ) ; } public static void main ( String ... args ) { new T6468404 ( ) . test ( args ) ; } } class DummyFO extends SimpleJavaFileObject { String n ; public DummyFO ( String n ) { super ( URI . create ( \"nowhere:/\" + n + \".java\" ) , JavaFileObject . Kind . SOURCE ) ; this . n = n ; } public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { return \"public class \" + n + \" {\" + n + \"(java.util.List<String> l) {}}\" ; } } @ SupportedAnnotationTypes ( \"*\" ) class P extends AbstractProcessor { boolean ran = false ; Elements elements ; @ Override public synchronized void init ( ProcessingEnvironment processingEnv ) { super . init ( processingEnv ) ; elements = processingEnv . getElementUtils ( ) ; } ExecutableElement getFirstMethodIn ( String name ) { return ( ExecutableElement ) elements . getTypeElement ( name ) . getEnclosedElements ( ) . get ( 0 ) ; } boolean isParameterized ( TypeMirror type ) { return ! ( ( DeclaredType ) type ) . getTypeArguments ( ) . isEmpty ( ) ; } @ Override public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ! ran ) { ran = true ; ExecutableElement m = getFirstMethodIn ( \"C\" ) ; System . err . println ( \"method: \" + m ) ; TypeMirror type = ( DeclaredType ) m . getParameters ( ) . get", "gt": "( 0 ) . asType ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2379, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . util . Map ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task . standalone . commands . FlushJaasCachePlaceholder ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . reload . ReloadService ; public class FlushJaasCache extends FlushJaasCachePlaceholder { @ Override protected Command doRun ( Task task , Map <", "gt": "String , String > prefs ) throws PackageException", "prediction": ")\n", "label": 1}
{"id": 4925, "input": "<s> package org . gk . ui . client . com . form ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import org . gk . ui . client . com . CoreIC ; import org . gk . ui . client . com . IC ; import com . extjs . gxt . ui . client . Style . IconAlign ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . KeyListener ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . Window ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . form . AdapterField ; import com . extjs . gxt . ui . client . widget . form . LabelField ; import com . extjs . gxt . ui . client . widget . form . TextField ; import com . google . gwt . event . dom . client . KeyCodes ; public class gkTagFieldIC extends AdapterField implements IC { protected CoreIC core ; private LayoutContainer hpAll ; private LayoutContainer hp ; private List < String > tagValues ; private Window w ; @ Override public void linkInfo ( Object info ) { throw new RuntimeException ( \"not implemented yet!\" ) ; } public interface Event { String ADDITEM = \".addItem\" ; String DELITEM = \".delItem\" ; String SELITEM = \".selItem\" ; } public String addItem ( ) { return getId ( ) + Event . ADDITEM ; } public String delItem ( ) { return getId ( ) + Event . DELITEM ; } public String selItem ( ) { return getId ( ) + Event . SELITEM ; } @ Override public CoreIC core ( ) { return core ; } @ Override public Object getInfo ( ) { return tagValues ; } @ Override public void setInfo ( Object info ) { if ( info instanceof List ) { tagValues = ( List ) info ; tagsEvents ( ) ; } } public gkTagFieldIC ( String id ) { super ( null ) ; setId ( id ) ; core = new CoreIC ( this ) ; core . init ( ) ; hpAll = new LayoutContainer ( ) ; widget = hpAll ; tagValues = new ArrayList < String > ( ) ; init ( ) ; setHideLabel ( true ) ; } public gkTagFieldIC ( String id , String label ) { super ( null ) ; setId ( id ) ; core = new CoreIC ( this ) ; core . init ( ) ; hpAll = new LayoutContainer ( ) ; widget = hpAll ; tagValues = new ArrayList < String > ( ) ; init ( ) ; setLabelSeparator ( \"\" ) ; setFieldLabel ( label ) ; } @ Override public void bindEvent ( ) { core . subscribe ( addItem ( ) , new EventProcess ( ) { @ Override public void execute ( String eventId , EventObject eo ) { tagsEvents ( eo ) ; } } ) ; core . subscribe ( delItem ( ) , new EventProcess ( ) { @ Override public void execute ( String eventId , EventObject eo ) { tagsEvents ( eo ) ; } } ) ; } private void init ( ) { setHeight ( 30 ) ; hp = new LayoutContainer ( ) ; final Button addBtn = new Button ( ) ; addBtn . setIconStyle ( \"icsc-create\" ) ; addBtn . setIconAlign ( IconAlign . TOP ) ; addBtn . setStyleAttribute ( \"margin\" , \"1px 6px 5px 1px;\" ) ; addBtn . setStyleAttribute ( \"float\" , \"left\" ) ; hpAll . add ( hp ) ; hpAll . add ( addBtn ) ; w = new Window ( ) ; w . setHeading ( \"Add \" + getFieldLabel ( ) ) ; w . setMinWidth ( 10 ) ; w . setMinHeight ( 10 ) ; w . setWidth ( 195 ) ; w . setHeight ( 60 ) ; w . setResizable ( false ) ; w . setVisible ( false ) ; final TextField < String > tf = new TextField < String > ( ) ; tf . setSize ( 181 , 28 ) ; tf . focus ( ) ; tf . setInputStyleAttribute ( \"border-style\" , \"solid\" ) ; tf . setInputStyleAttribute ( \"display\" , \"inline-block;\" ) ; w . add ( tf ) ; addBtn . addListener ( Events . OnMouseDown , new Listener < BaseEvent > ( ) { @ Override public void handleEvent ( BaseEvent be ) { if ( w . isVisible ( ) ) { w . hide ( ) ; } } } ) ; addBtn . addListener ( Events . OnMouseUp , new Listener < BaseEvent > ( ) { @ Override public void handleEvent ( BaseEvent be ) { if ( ! w . isVisible ( ) ) { int left = addBtn . getAbsoluteLeft ( ) - 20 ; int top = addBtn . getAbsoluteTop ( ) - 70 ; if ( top < 0 ) { top = 1 ; left = addBtn . getAbsoluteLeft ( ) + 30 ; } w . setPagePosition ( left , top ) ; w . show ( ) ; } } } ) ; tf . addKeyListener ( new KeyListener ( ) { @ Override public void componentKeyDown ( ComponentEvent event ) { if ( event . getKeyCode ( ) == KeyCodes . KEY_ENTER ) { if ( tf . getValue ( ) != null && ! tf . getValue ( ) . equals ( \"\" ) && ! isExit ( tf . getValue ( ) ) ) { tagValues . add ( tf", "gt": ". getValue ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2386, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . net . URLConnection ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Map ; import org . eclipse . rap . rwt . internal . RWTProperties ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . resources . IResourceManager ; public class ResourceManagerImpl implements IResourceManager { private final ResourceDirectory resourceDirectory ; private final Map < String , Resource > resources ; private final ThreadLocal < ClassLoader > contextLoader ; private static final class Resource { private final String charset ; private final Integer version ; public Resource ( String charset , Integer version ) { this . charset = charset ; this . version = version ; } public String getCharset ( ) { return charset ; } public Integer getVersion ( ) { return version ; } } public ResourceManagerImpl ( ResourceDirectory resourceDirectory ) { this . resourceDirectory = resourceDirectory ; resources = new Hashtable < String , Resource > ( ) ; contextLoader = new ThreadLocal < ClassLoader > ( ) ; } public Integer findVersion ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; Integer result = null ; Resource resource = resources . get ( name ) ; if ( resource != null ) { result = resource . getVersion ( ) ; } return result ; } public void register ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; internalRegister ( name , null , RegisterOptions . NONE ) ; } public void register ( String name , String charset ) { ParamCheck . notNull ( name , \"name\" ) ; ParamCheck . notNull ( charset , \"charset\" ) ; internalRegister ( name , charset , RegisterOptions . NONE ) ; } public void register ( String name , String charset , RegisterOptions options ) { ParamCheck . notNull ( name , \"name\" ) ; ParamCheck . notNull ( charset , \"charset\" ) ; ParamCheck . notNull ( options , \"options\" ) ; internalRegister ( name , charset , options ) ; } public void register ( String name , InputStream is ) { ParamCheck . notNull ( name , \"name\" ) ; ParamCheck . notNull ( is , \"is\" ) ; internalRegister ( name , is , null , RegisterOptions . NONE ) ; } public void register ( String name , InputStream is , String charset , RegisterOptions options ) { ParamCheck . notNull ( name , \"name\" ) ; ParamCheck . notNull ( is , \"is\" ) ; ParamCheck . notNull ( charset , \"charset\" ) ; ParamCheck . notNull ( options , \"options\" ) ; internalRegister ( name , is , charset , options ) ; } public boolean unregister ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; boolean result = false ; Resource resource = resources . remove ( name ) ; if ( resource != null ) { result = true ; Integer version = resource . getVersion ( ) ; File file = getDiskLocation ( name , version ) ; file . delete ( ) ; } return result ; } public String getCharset ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; Resource resource = resources . get ( name ) ; return resource . getCharset ( ) ; } public boolean isRegistered ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; return resources . containsKey ( name ) ; } public String getLocation ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; if ( ! resources . containsKey ( name ) ) { throw new IllegalArgumentException ( \"Resource", "gt": "does not exist: \" + name ) ;", "prediction": ") ;\n", "label": 1}
{"id": 595, "input": "<s> package org . ofbiz . sql . test ; import java . util . List ; import org . ofbiz . sql . ConstantValue ; import org . ofbiz . sql . CountAllFunction ; import org . ofbiz . sql . AggregateFunction ; import org . ofbiz . sql . FieldValue ; import org . ofbiz . sql . FunctionCall ; import org . ofbiz . sql . MathValue ; import org . ofbiz . sql . NumberValue ; import org . ofbiz . sql . ParameterValue ; import org . ofbiz . sql . StaticValue ; import org . ofbiz . sql . StringValue ; import org . ofbiz . sql . Value ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; @ SourceMonitored public class ValuesTest extends GenericTestCaseBase { private static final FieldValue fv1 = new FieldValue ( \"partyId\" ) ; private static final FieldValue fv2 = new FieldValue ( \"a\" , \"partyId\" ) ; private static final FieldValue fv3 = new FieldValue ( null , \"partyId\" ) ; private static final FieldValue fv4 = new FieldValue ( null , \"firstName\" ) ; private static final NumberValue < Long > nv1 = NumberValue . valueOf ( 1 ) ; private static final NumberValue < Double > nv2 = NumberValue . valueOf ( 2D ) ; private static final NumberValue < Long > nv3 = NumberValue . valueOf ( 3 ) ; public ValuesTest ( String name ) { super ( name ) ; } private static < V extends Value > void basicTest ( String label , Class < V > clz , V v , String defaultName , String s , V o , boolean matches ) { if ( v instanceof StaticValue ) { assertEquals ( label + \":default-name\" , defaultName , ( ( StaticValue ) v ) . getDefaultName ( ) ) ; } assertEquals ( label + \":toString\" , s , v . toString ( ) ) ; assertNotEquals ( label + \":not-equals-this\" , v , ValuesTest . class ) ; if ( o != null ) { if ( matches ) { assertEquals ( label + \":equals\" , o , v ) ; } else { assertNotEquals ( label + \":not-equals\" , o , v ) ; } } ValueVisitorRecorder visitor = new ValueVisitorRecorder ( ) ; v . accept ( visitor ) ; v . accept ( visitor ) ; assertEquals ( label + \":visited\" , 2 , visitor . counts . remove ( clz ) . intValue ( ) ) ; assertTrue ( label + \":nothing-else-visited\" , visitor . counts . isEmpty ( ) ) ; } private static void countAllFunctionTest ( String label , CountAllFunction v , String tableName , String s , CountAllFunction o , boolean matches ) { assertEquals ( label + \":left\" , tableName , v . getTableName ( ) ) ; basicTest ( label , CountAllFunction . class , v , \"COUNT\" , s , o , matches ) ; } public void testCountAllFunction ( ) { CountAllFunction v1 = new CountAllFunction ( \"a\" ) ; countAllFunctionTest ( \"v1\" , v1 , \"a\" , \"COUNT(a.*)\" , null , false ) ; CountAllFunction v2 = new CountAllFunction ( null ) ; countAllFunctionTest ( \"v2\" , v2 , null , \"COUNT(*)\" , v1 , false ) ; CountAllFunction v3 = new CountAllFunction ( \"a\" ) ; countAllFunctionTest ( \"v3\" , v3 , \"a\" , \"COUNT(a.*)\" , v1 , true ) ; } private static void aggregateFunctionTest ( String label , AggregateFunction v , String name , boolean isDistinct , FieldValue fv , String s , AggregateFunction o , boolean matches ) { assertEquals ( label + \":name\" , name , v . getName ( ) ) ; assertEquals ( label + \":left\" , isDistinct , v . isDistinct ( ) ) ; assertEquals ( label + \":field-value\" , fv , v . getValue ( ) ) ; basicTest ( label , AggregateFunction . class , v , name , s , o , matches ) ; } public void testAggregateFunction ( ) { AggregateFunction v1 = new AggregateFunction ( \"COUNT\" , false , fv2 ) ; aggregateFunctionTest ( \"v1\" , v1 , \"COUNT\" , false , fv2 , \"COUNT(a.partyId)\" , null , false ) ; AggregateFunction v2 = new AggregateFunction ( \"COUNT\" , true , fv2 ) ; aggregateFunctionTest ( \"v2\" , v2 , \"COUNT\" , true , fv2 , \"COUNT(DISTINCT a.partyId)\" , v1 , false ) ; AggregateFunction v3 = new AggregateFunction ( \"COUNT\" , true , fv1 ) ; aggregateFunctionTest ( \"v3\" , v3 , \"COUNT\" , true , fv1 , \"COUNT(DISTINCT partyId)\" , v1 , false ) ; AggregateFunction v4 = new AggregateFunction ( \"COUNT\" , false , fv1 ) ; aggregateFunctionTest ( \"v4\" , v4 , \"COUNT\" , false , fv1 , \"COUNT(partyId)\" , v1 , false ) ; AggregateFunction v5 = new AggregateFunction ( \"MAX\" , false , fv2 ) ; aggregateFunctionTest ( \"v5\" , v5 , \"MAX\" , false , fv2 , \"MAX(a.partyId)\" , v1 , false ) ; AggregateFunction v6 = new AggregateFunction ( \"COUNT\" , false , fv2 ) ; aggregateFunctionTest ( \"v6\" , v6 , \"COUNT\" , false , fv2 , \"COUNT(a.partyId)\" , v1 , true ) ; } private static void fieldValueTest ( String label , FieldValue v , String tableName , String fieldName , String s , FieldValue o , boolean matches ) { assertEquals ( label + \":table-name\" , tableName , v . getTableName ( ) ) ; assertEquals ( label + \":field-name\" , fieldName , v . getFieldName ( ) ) ; basicTest ( label , FieldValue . class , v , fieldName , s , o , matches ) ; } public void testFieldValue ( ) { fieldValueTest ( \"fv1\" , fv1 , null , \"partyId\" , \"partyId\" , null , false ) ; fieldValueTest ( \"fv2\" , fv2 , \"a\" , \"partyId\" , \"a.partyId\" ,", "gt": "fv1 , false ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2398, "input": "<s> package org . apache . lucene . search . payloads ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . DisjunctionMaxQuery ; import org . apache . lucene . search . FilteredQuery ; import org . apache . lucene . search . MultiPhraseQuery ; import org . apache . lucene . search . PhraseQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . spans . SpanNearQuery ; import org . apache . lucene . search . spans . SpanOrQuery ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . search . spans . SpanTermQuery ; import org . apache . lucene . search . spans . Spans ; public class PayloadSpanUtil { private IndexReader reader ; public PayloadSpanUtil ( IndexReader reader ) { this . reader = reader ; } public Collection getPayloadsForQuery ( Query query ) throws IOException { Collection payloads = new ArrayList ( ) ; queryToSpanQuery ( query , payloads ) ; return payloads ; } private void queryToSpanQuery ( Query query , Collection payloads ) throws IOException { if ( query instanceof BooleanQuery ) { BooleanClause [ ] queryClauses = ( ( BooleanQuery ) query ) . getClauses ( ) ; for ( int i = 0 ; i < queryClauses . length ; i ++ ) { if ( ! queryClauses [ i ] . isProhibited ( ) ) { queryToSpanQuery ( queryClauses [ i ] . getQuery ( ) , payloads ) ; } } } else if ( query instanceof PhraseQuery ) { Term [ ] phraseQueryTerms = ( ( PhraseQuery ) query ) . getTerms ( ) ; SpanQuery [ ] clauses = new SpanQuery [ phraseQueryTerms . length ] ; for ( int i = 0 ; i < phraseQueryTerms . length ; i ++ ) { clauses [ i ] = new SpanTermQuery ( phraseQueryTerms [ i ] ) ; } int slop = ( ( PhraseQuery ) query ) . getSlop ( ) ; boolean inorder = false ; if ( slop == 0 ) { inorder = true ; } SpanNearQuery sp = new SpanNearQuery ( clauses , slop , inorder ) ; sp . setBoost ( query . getBoost ( ) ) ; getPayloads ( payloads , sp ) ; } else if ( query instanceof TermQuery ) { SpanTermQuery stq = new SpanTermQuery ( ( ( TermQuery ) query ) . getTerm ( ) ) ; stq . setBoost ( query . getBoost ( ) ) ; getPayloads ( payloads , stq ) ; } else if ( query instanceof SpanQuery ) { getPayloads ( payloads , ( SpanQuery ) query ) ; } else if ( query instanceof FilteredQuery ) { queryToSpanQuery ( ( ( FilteredQuery ) query ) . getQuery ( ) , payloads ) ; } else if ( query instanceof DisjunctionMaxQuery ) { for ( Iterator iterator = ( ( DisjunctionMaxQuery ) query ) . iterator ( ) ; iterator . hasNext ( ) ; ) { queryToSpanQuery ( ( Query ) iterator . next ( ) , payloads ) ; } } else if ( query instanceof MultiPhraseQuery ) { final MultiPhraseQuery mpq = ( MultiPhraseQuery ) query ; final List termArrays = mpq . getTermArrays ( ) ; final int [ ] positions = mpq . getPositions ( ) ; if ( positions . length > 0 ) { int maxPosition = positions [ positions . length - 1 ] ; for ( int i = 0 ; i < positions . length - 1 ; ++ i ) { if ( positions [ i ] > maxPosition ) { maxPosition = positions [ i ] ; } } final List [ ] disjunctLists = new List [ maxPosition + 1 ] ; int distinctPositions = 0 ; for ( int i = 0 ; i < termArrays . size ( ) ; ++ i ) { final Term [ ] termArray = ( Term [ ] ) termArrays . get ( i ) ; List disjuncts = disjunctLists [ positions [ i ] ] ; if ( disjuncts == null ) { disjuncts = ( disjunctLists [ positions [ i ] ] = new ArrayList ( termArray . length ) ) ; ++ distinctPositions ; } for ( int j = 0 ; j < termArray . length ; ++ j ) { disjuncts . add ( new SpanTermQuery ( termArray [ j ] ) ) ; } } int positionGaps = 0 ; int position = 0 ; final SpanQuery [ ] clauses = new SpanQuery [ distinctPositions ] ; for ( int i = 0 ; i < disjunctLists . length ; ++ i ) { List disjuncts = disjunctLists [ i ] ; if ( disjuncts != null ) { clauses [ position ++ ] = new SpanOrQuery ( ( SpanQuery [ ] ) disjuncts . toArray ( new SpanQuery [ disjuncts . size ( ) ] ) ) ; } else { ++ positionGaps ; } } final int slop = mpq . getSlop ( ) ; final boolean inorder = ( slop == 0 ) ; SpanNearQuery sp = new SpanNearQuery ( clauses , slop + positionGaps , inorder ) ; sp . setBoost ( query . getBoost ( ) ) ; getPayloads ( payloads , sp ) ; } } } private void getPayloads ( Collection payloads , SpanQuery query ) throws IOException { Spans spans = query . getSpans ( reader ) ; while ( spans . next ( ) == true ) { if ( spans . isPayloadAvailable ( ) ) { Collection payload = spans . getPayload ( ) ; Iterator it = payload . iterator ( ) ; while (", "gt": "it . hasNext ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 9408, "input": "<s> interface iclss01004_1 { abstract int foo", "gt": "( int par ) ;", "prediction": ";\n", "label": 0}
{"id": 2411, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage . transmogrify ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; public class ArrayDef implements IClass { private final static IVariable LENGTH_MEMBER = new ArrayLengthMember ( ) ; private IClass _type ; public ArrayDef ( IClass type ) { _type = type ; } public IClass getType ( ) { return _type ; } public IClass getSuperclass ( ) { return new ArrayDef ( getType ( ) . getSuperclass ( ) ) ; } public IClass [ ] getInterfaces ( ) { return new IClass [ 0 ] ; } public IClass [ ] getInnerClasses ( ) { return new IClass [ 0 ] ; } public IClass getClassDefinition ( String name ) { return null ; } public IMethod getMethodDefinition ( String name , ISignature signature ) { return new ExternalClass ( Object . class ) . getMethodDefinition ( name , signature ) ; } public IVariable getVariableDefinition ( String name ) { IVariable result = null ; if ( name . equals ( \"length\" ) ) { result = LENGTH_MEMBER ; } return result ; } public void addSubclass ( ClassDef subclass ) { } public void addReference ( Reference reference ) { } public Iterator getReferences ( ) { return new Vector ( ) . iterator ( ) ; } public int getNumReferences ( ) { return 0 ; } public List getSubclasses ( ) { return new ArrayList ( ) ; }", "gt": "public void addImplementor ( ClassDef implementor )", "prediction": "}\n", "label": 1}
{"id": 9517, "input": "<s> class T4718142a { public static void main ( String [ ] args ) { final int i ; for ( int n = 0 ; n < 10 ; n ++ ) { b : { try { if ( true ) break b ; } finally { i = n ; System . out . println ( \"i", "gt": "= \" + i ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2412, "input": "<s> package nehsics . world ; import nehsics . force . * ; import java . util . * ; public class Bonder extends WorldAdapter { private Set < SpringForce > forces = new HashSet < SpringForce > ( ) ; public void beginStep ( World world , double dt ) { for ( SpringForce", "gt": "s : forces ) s . calculateForce ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8703, "input": "<s> package b ; public abstract class", "gt": "CrossPackageImplB extends a . CrossPackageImplA", "prediction": ") ;\n", "label": 0}
{"id": 2414, "input": "<s> package org . apache . sqoop . io ; import java . io . File ; import java . io . IOException ; import org . apache . hadoop . util . Shell ; import org . apache . log4j . Logger ; public class NamedFifo { private static final Logger LOG = Logger . getLogger ( NamedFifo . class ) ; private File fifoFile ; public NamedFifo ( String pathname ) { this . fifoFile = new File ( pathname ) ; } public NamedFifo ( File fifo ) { this . fifoFile = fifo ; } public File getFile ( ) { return this . fifoFile ; } public void create ( ) throws IOException { create ( 0600 ) ; } public void create ( int permissions ) throws IOException { String filename = fifoFile . toString ( ) ; String modeStr = Integer . toString ( permissions , 8 ) ; try { String output = Shell . execCommand ( \"mknod\" , \"--mode=0\" + modeStr , filename , \"p\" ) ; LOG", "gt": ". info ( \"mknod output:\\n\" + output ) ;", "prediction": "}\n", "label": 1}
{"id": 9946, "input": "<s> package org . dawb . workbench . plotting . tools . fitting ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import org . dawb . workbench . plotting . Activator ; import org . dawb . workbench . plotting . preference . FittingConstants ; import org . eclipse . core . runtime . IProgressMonitor ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . IAnalysisMonitor ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . DatasetUtils ; import uk . ac . diamond . scisoft . analysis . fitting . Generic1DFitter ; import uk . ac . diamond . scisoft . analysis . fitting . functions . APeak ; import uk . ac . diamond . scisoft . analysis . fitting . functions . CompositeFunction ; import uk . ac . diamond . scisoft . analysis . fitting . functions . Gaussian ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IPeak ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IdentifiedPeak ; import uk . ac . diamond . scisoft . analysis . fitting . functions . Lorentzian ; import uk . ac . diamond . scisoft . analysis . fitting . functions . Offset ; import uk . ac . diamond . scisoft . analysis . fitting . functions . PearsonVII ; import uk . ac . diamond . scisoft . analysis . fitting . functions . PseudoVoigt ; import uk . ac . diamond . scisoft . analysis . optimize . GeneticAlg ; import uk . ac . diamond . scisoft . analysis . optimize . IOptimizer ; import uk . ac . diamond . scisoft . analysis . roi . RectangularROI ; public class FittingUtils { private static Logger logger = LoggerFactory . getLogger ( FittingUtils . class ) ; public static FittedPeaks getFittedPeaks ( final FittedPeaksInfo info ) throws Exception { List < CompositeFunction > composites = null ; final IOptimizer optimizer = getOptimizer ( ) ; if ( getPeaksRequired ( ) == 1 ) { double lowOffset = info . getY ( ) . min ( ) . doubleValue ( ) ; double highOffset = ( Double ) info . getY ( ) . mean ( ) ; Offset offset = new Offset ( lowOffset , highOffset ) ; double fwhmApprox = info . getX ( ) . peakToPeak ( ) . doubleValue ( ) / 2.0 ; IdentifiedPeak iniPeak = new IdentifiedPeak ( ( ( Number ) info . getX ( ) . mean ( ) ) . doubleValue ( ) , info . getX ( ) . min ( ) . doubleValue ( ) , info . getX ( ) . max ( ) . doubleValue ( ) , info . getX ( ) . peakToPeak ( ) . doubleValue ( ) * info . getY ( ) . max ( ) . doubleValue ( ) , info . getY ( ) . max ( ) . doubleValue ( ) , 0 , info . getX ( ) . getSize ( ) - 1 , Arrays . asList ( new Double [ ] { info . getX ( ) . min ( ) . doubleValue ( ) + fwhmApprox , info . getX ( ) . max ( ) . doubleValue ( ) - fwhmApprox } ) ) ; iniPeak . setFWHM ( fwhmApprox ) ; Constructor < ? extends APeak > ctor = getPeakType ( ) . getClass ( ) . getConstructor ( IdentifiedPeak . class ) ; APeak localPeak = ctor . newInstance ( iniPeak ) ; CompositeFunction comp = new CompositeFunction ( ) ; comp . addFunction ( localPeak ) ; comp . addFunction ( offset ) ; optimizer . optimize ( new AbstractDataset [ ] { info . getX ( ) } , info . getY ( ) , comp ) ; composites = new ArrayList < CompositeFunction > ( 1 ) ; composites . add ( comp ) ; } else { composites = Generic1DFitter . fitPeakFunctions ( info . getIdentifiedPeaks ( ) , info . getX ( ) , info . getY ( ) , getPeakType ( ) , optimizer , getSmoothing ( ) , getPeaksRequired ( ) , 0.0 , false , false , new IAnalysisMonitor ( ) { @ Override public boolean hasBeenCancelled ( ) { return info . getMonitor ( ) . isCanceled ( ) ; } } ) ; } if ( composites == null || composites . isEmpty ( ) ) return null ; final FittedPeaks bean = new FittedPeaks ( ) ; for ( CompositeFunction function : composites ) { final IPeak peak = function . getPeak ( 0 ) ; if ( info . getMonitor ( ) . isCanceled ( ) ) return null ; double w = peak . getFWHM ( ) ; final double position = peak . getPosition ( ) ; RectangularROI bounds = new RectangularROI ( position - w / 2 , 0 , w , 0 , 0 ) ; final AbstractDataset [ ] pf = getPeakFunction ( info . getX ( ) , info . getY ( ) , function ) ; bean . addFittedPeak ( new FittedPeak ( function , bounds , pf ) ) ; } bean . setOptimizer ( optimizer ) ; return bean ; } public static List < IdentifiedPeak > getIdentifiedPeaks ( final FittedPeaks fittedPeaks , final AbstractDataset", "gt": "x , final IProgressMonitor monitor ) throws Exception", "prediction": ")\n", "label": 0}
{"id": 2440, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . TreeColumn ; import org . eclipse . swt . widgets . TreeItem ; public interface ITreeAdapter { void setScrollLeft ( int left ) ; int getScrollLeft ( ) ; void setTopItemIndex ( int topItemIndex ) ; int getTopItemIndex ( ) ; boolean hasHScrollBar ( ) ; boolean hasVScrollBar ( ) ; boolean isCached ( TreeItem item ) ; Point getItemImageSize ( int index ) ; int getCellLeft ( int index ) ; int getCellWidth ( int index ) ; int getTextOffset", "gt": "( int index ) ;", "prediction": "( )\n", "label": 1}
{"id": 2079, "input": "<s> class ImproperTypeParamMissing { class Outer < S > { class Inner < T > { } } void m ( ) { Object o", "gt": "= ( Outer < ? > . Inner ) null ;", "prediction": "\n", "label": 0}
{"id": 2464, "input": "<s> package org . eclipse . ui . part ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IActionBars ; public interface IPage { public void createControl ( Composite parent ) ; public void dispose ( ) ; public Control getControl ( ) ; public void setActionBars", "gt": "( IActionBars actionBars ) ;", "prediction": "( )\n", "label": 1}
{"id": 5785, "input": "<s> package com . shopzilla . api . client . model ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . builder . ToStringStyle ; import java . math . BigDecimal ; public class Merchant { private String name ; private Long id ; private BigDecimal overallRating ; private Integer certification ; @ Override public int hashCode ( ) { return new HashCodeBuilder ( ) . append ( id ) . toHashCode ( ) ; } @ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( o == null || ! ( o instanceof Merchant ) ) { return false ; } Merchant rhs = ( Merchant ) o ; return new EqualsBuilder ( ) . append ( id , rhs . id ) . isEquals ( ) ; } @ Override public String toString ( ) { return new ToStringBuilder ( this , ToStringStyle . SHORT_PREFIX_STYLE ) . append ( \"id\" , id ) . append ( \"name\" , name ) . append ( \"overallRating\" , overallRating ) . append ( \"certification\" , certification ) . toString ( ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public BigDecimal getOverallRating ( ) { return overallRating ; } public", "gt": "void setOverallRating ( BigDecimal overallRating )", "prediction": "( )\n", "label": 0}
{"id": 2472, "input": "<s> package ldapconn ; import java . util . Hashtable ; import javax . naming . Context ; import javax . naming . NamingEnumeration ; import javax . naming . NamingException ; import javax . naming . directory . Attributes ; import javax . naming . directory . SearchControls ; import javax . naming . directory . SearchResult ; import javax . naming . ldap . InitialLdapContext ; import javax . naming . ldap . LdapContext ; public class LDAPTest { public static class LDAP { static String ATTRIBUTE_FOR_USER = \"sAMAccountName\" ; public Attributes getDisplayName ( String username , String password , String _domain , String host , String dn , String searchName ) throws NamingException { String returnedAtts [ ] = { \"name\" } ; String searchFilter = \"(&(objectClass=user)(\" + ATTRIBUTE_FOR_USER + \"=\" + searchName + \"))\" ; SearchControls searchCtls = new SearchControls ( ) ; searchCtls . setReturningAttributes ( returnedAtts ) ; searchCtls . setSearchScope ( SearchControls . SUBTREE_SCOPE ) ; String searchBase = dn ; Hashtable environment = new Hashtable ( ) ; environment . put ( Context . INITIAL_CONTEXT_FACTORY , \"com.sun.jndi.ldap.LdapCtxFactory\" ) ; environment . put ( Context . PROVIDER_URL , \"ldap://\" +", "gt": "host + \":389\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9925, "input": "<s> package org . ofbiz . content . layout ; import java . io . File ; import java . nio . ByteBuffer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastMap ; import org . apache . commons . fileupload . FileItem ; import org . apache . commons . fileupload . FileUploadException ; import org . apache . commons . fileupload . disk . DiskFileItemFactory ; import org . apache . commons . fileupload . servlet . ServletFileUpload ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . service . ServiceUtil ; public class LayoutWorker { public static final String module = LayoutWorker . class . getName ( ) ; public static final String err_resource = \"ContentErrorUiLabels\" ; public static Map < String , Object > uploadImageAndParameters ( HttpServletRequest request , String uploadField ) { Locale locale = UtilHttp . getLocale ( request ) ; Map < String , Object > results = FastMap . newInstance ( ) ; Map < String , String > formInput = FastMap . newInstance ( ) ; results . put ( \"formInput\" , formInput ) ; ServletFileUpload fu = new ServletFileUpload ( new DiskFileItemFactory ( 10240 , new File ( new File ( \"runtime\" ) , \"tmp\" ) ) ) ; List < FileItem > lst = null ; try { lst = UtilGenerics . checkList ( fu . parseRequest ( request ) ) ; } catch ( FileUploadException e4 ) { return ServiceUtil . returnError ( e4 . getMessage ( ) ) ; } if ( lst . size ( ) == 0 ) { String errMsg = UtilProperties . getMessage ( err_resource , \"layoutEvents.no_files_uploaded\" , locale ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( err_resource , \"layoutEvents.no_files_uploaded\" , locale ) ) ; } FileItem fi = null ; FileItem imageFi = null ; for ( int i = 0 ; i < lst . size ( ) ; i ++ ) { fi = lst . get ( i ) ; String fieldName = fi . getFieldName ( ) ; String fieldStr = fi . getString ( ) ; if ( fi . isFormField ( ) ) { formInput . put ( fieldName , fieldStr ) ; request . setAttribute ( fieldName , fieldStr ) ; } if ( fieldName . equals ( uploadField ) ) { imageFi = fi ; results . put ( \"uploadMimeType\" , fi . getContentType ( ) ) ; } } if ( imageFi == null ) { String errMsg = UtilProperties . getMessage ( err_resource , \"layoutEvents.image_null\" , UtilMisc . toMap ( \"imageFi\" ,", "gt": "imageFi ) , locale ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2511, "input": "<s> package br . org . archimedes . model ; import java . io . File ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Observable ; import java . util . Observer ; import java . util . Set ; import java . util . Stack ; import org . eclipse . swt . opengl . GLCanvas ; import br . org . archimedes . Constant ; import br . org . archimedes . Utils ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . model . Workspace ; import br . org . archimedes . gui . opengl . Color ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . gui . swt . Messages ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . IntersectionManager ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . rcp . extensionpoints . IntersectionManagerEPLoader ; public class Drawing extends Observable implements Observer { private String title ; private File file ; private Stack < UndoableCommand > undoHistory ; private Stack < UndoableCommand > redoHistory ; private Selection selection ; private boolean saved ; private boolean centerToOpen ; private Layer currentLayer ; private double zoom ; private Point viewportPosition ; private Map < String , Layer > layers ; private Layer helperLayer ; public Drawing ( String title ) { this ( title , null ) ; } public Drawing ( String title , Map < String , Layer > layers ) { this ( title , layers , false ) ; } public Drawing ( String title , Map < String , Layer > layers , boolean centerToOpen ) { this . title = title ; this . selection = new Selection ( ) ; this . zoom = 1.0 ; this . viewportPosition = new Point ( 0.0 , 0.0 ) ; this . undoHistory = new Stack < UndoableCommand > ( ) ; this . redoHistory = new Stack < UndoableCommand > ( ) ; this . setSaved ( false ) ; this . centerToOpen = centerToOpen ; this . helperLayer = new Layer ( Constant . WHITE , \"Helper Layer\" , LineStyle . CONTINUOUS , 1.0 ) ; if ( layers == null || layers . isEmpty ( ) ) { this . layers = new HashMap < String , Layer > ( ) ; this . currentLayer = new Layer ( Constant . WHITE , Messages . bind ( Messages . LayerEditor_Layer , 0 ) , LineStyle . CONTINUOUS , 1.0 ) ; this . layers . put ( currentLayer . getName ( ) , currentLayer ) ; currentLayer . addObserver ( this ) ; } else { this . layers = new HashMap < String , Layer > ( layers ) ; Collection < Layer > values = this . layers . values ( ) ; this . currentLayer = values . iterator ( ) . next ( ) ; for ( Layer layer : values ) { layer . addObserver ( this ) ; } } } public synchronized Drawing clone ( ) { Map < String , Layer > cloneLayers = new HashMap < String , Layer > ( ) ; for ( Layer layer : layers . values ( ) ) { Layer clone = layer . clone ( ) ; cloneLayers . put ( layer . getName ( ) , clone ) ; for ( Element element : layer . getElements ( ) ) { try { clone . putElement ( element . clone ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } Drawing clone = new Drawing ( title , cloneLayers ) ; clone . setViewportPosition ( viewportPosition . clone ( ) ) ; clone . setZoom ( zoom ) ; try { clone . setCurrentLayer ( getLayerNames ( ) . indexOf ( currentLayer . getName ( ) ) ) ; } catch ( IllegalActionException e ) { e . printStackTrace ( ) ; } return clone ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( this . file == null ) ? 0 : this . file . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Drawing other = ( Drawing ) obj ; if ( this . file == null || ! this . file . equals ( other . file ) ) return false ; return true ; } public void removeElement ( Element element ) throws NullArgumentException , IllegalActionException { if ( element == null ) { throw new NullArgumentException ( ) ; } Layer layer = element . getLayer ( ) ; if ( layer != null && ! layer . isLocked ( ) ) { layer . removeElement ( element ) ; } else { throw new IllegalActionException ( ) ; } Selection selection = getSelection ( ) ; selection . remove ( element ) ; setChanged ( ) ; notifyObservers ( ) ; } public Collection < Element > getUnlockedContents ( ) { Collection < Element > elements = new ArrayList < Element > ( ) ; for ( Layer layer : layers . values ( ) ) { if ( ! layer . isLocked ( ) ) { elements . addAll ( layer . getElements ( ) ) ; } } elements . addAll ( helperLayer . getElements ( ) ) ; return Collections . unmodifiableCollection ( elements ) ; } public Collection < Element > getVisibleContents ( ) { Collection < Element > elements = new ArrayList < Element > ( ) ; for ( Layer layer : layers . values ( ) ) { if ( layer . isVisible ( ) ) { elements . addAll ( layer . getElements ( ) ) ; } } elements . addAll ( helperLayer . getElements ( ) ) ; return Collections . unmodifiableCollection ( elements ) ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Set < Element > getSelectionInside ( Rectangle rect ) throws NullArgumentException { Set < Element >", "gt": "selection = new HashSet < Element > ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4105, "input": "<s> package ar . com . fdvs . dj . domain . constants ; import net . sf . jasperreports . engine . design . JRDesignImage ; public class ImageScaleMode extends BaseDomainConstant { private static final long serialVersionUID = 1L ; private byte value = JRDesignImage . SCALE_IMAGE_RETAIN_SHAPE ; public static ImageScaleMode NO_RESIZE = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_CLIP ) ; public static ImageScaleMode FILL = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_FILL_FRAME ) ; public static ImageScaleMode FILL_PROPORTIONALLY = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_RETAIN_SHAPE ) ; public byte getValue ( ) { return value ; } private ImageScaleMode ( byte mode ) { this", "gt": ". value = mode ;", "prediction": ";\n", "label": 0}
{"id": 2527, "input": "<s> package org . eclipse . swt . internal . widgets . menukit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import java . io . IOException ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IShellAdapter ; import org . eclipse . swt . widgets . Decorations ; import org . eclipse . swt . widgets . Menu ; final class MenuBarLCA extends MenuDelegateLCA { private static final String PROP_PARENT = \"parent\" ; void preserveValues ( Menu menu ) { MenuLCAUtil . preserveValues ( menu ) ; preserveProperty ( menu , PROP_PARENT , getParent ( menu ) ) ; } void readData ( Menu menu ) { MenuLCAUtil . readMenuEvent ( menu ) ; WidgetLCAUtil . processHelp ( menu ) ; } void renderInitialization ( Menu menu ) throws IOException { MenuLCAUtil . renderInitialization ( menu ) ; } void renderChanges ( Menu menu ) throws IOException { MenuLCAUtil . renderChanges ( menu ) ; renderProperty ( menu , PROP_PARENT , getParent ( menu ) , null ) ; renderBounds ( menu ) ; } private static void renderBounds ( Menu menu ) { Decorations parent = getParent ( menu ) ; if ( parent != null ) { WidgetLCAUtil . renderBounds ( menu , getBounds ( menu ) ) ; } } private static Decorations getParent ( Menu menu ) { Decorations result = null ; if ( menu . getParent ( ) . getMenuBar ( ) == menu ) { result = menu . getParent ( ) ; } return result ; } private static Rectangle getBounds ( Menu menu ) { Rectangle result = new Rectangle ( 0 , 0 , 0 , 0 ) ; Decorations parent = getParent ( menu ) ; if ( parent != null ) { IShellAdapter shellAdapter = parent . getAdapter ( IShellAdapter . class ) ; result = shellAdapter", "gt": ". getMenuBounds ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8333, "input": "<s> package org . remast . baralga . gui ; import info . clearthought . layout . TableLayout ; import java . awt . Image ; import java . awt . event . ComponentAdapter ; import java . awt . event . ComponentEvent ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import javax . swing . ImageIcon ; import javax . swing . JFrame ; import javax . swing . JMenu ; import javax . swing . JMenuBar ; import javax . swing . JMenuItem ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JToolBar ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . actions . AboutAction ; import org . remast . baralga . gui . actions . AbstractBaralgaAction ; import org . remast . baralga . gui . actions . AddActivityAction ; import org . remast . baralga . gui . actions . ExitAction ; import org . remast . baralga . gui . actions . ExportCsvAction ; import org . remast . baralga . gui . actions . ExportExcelAction ; import org . remast . baralga . gui . actions . ExportXmlAction ; import org . remast . baralga . gui . actions . ICalExportAction ; import org . remast . baralga . gui . actions . ImportXmlAction ; import org . remast . baralga . gui . actions . ManageProjectsAction ; import org . remast . baralga . gui . actions . SettingsAction ; import org . remast . baralga . gui . events . BaralgaEvent ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . gui . panels . ActivityPanel ; import org . remast . baralga . gui . panels . ReportPanel ; import org . remast . baralga . gui . settings . UserSettings ; import org . remast . util . TextResourceBundle ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . google . common . eventbus . Subscribe ; @ SuppressWarnings ( \"serial\" ) public class MainFrame extends JFrame { @ SuppressWarnings ( \"unused\" ) private static final Logger log = LoggerFactory . getLogger ( MainFrame . class ) ; private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( MainFrame . class ) ; private static final Image NORMAL_ICON = new ImageIcon ( BaralgaMain . class . getResource ( \"/icons/Baralga-Tray.gif\" ) ) . getImage ( ) ; private static final Image ACTIVE_ICON = new ImageIcon ( BaralgaMain . class . getResource ( \"/icons/Baralga-Tray-Green.png\" ) ) . getImage ( ) ; private final PresentationModel model ; private JToolBar toolBar = null ; private JPanel currentActivityPanel = null ; private ReportPanel reportPanel ; private JMenuBar mainMenuBar = null ; private JMenu fileMenu = null ; private JMenu helpMenu = null ; private JMenu exportMenu = null ; private JMenu importMenu = null ; private", "gt": "JMenu editMenu = null ;", "prediction": ";\n", "label": 0}
{"id": 2546, "input": "<s> package org . nuxeo . ecm . platform . publisher . helper ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; public interface RootSectionFinder {", "gt": "void reset ( ) ;", "prediction": ";\n", "label": 1}
{"id": 133, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . util . Collection ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . TypeMirror ; import com . sun . mirror . util . DeclarationVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . VarSymbol ; @ SuppressWarnings ( \"deprecation\" ) public class ParameterDeclarationImpl extends DeclarationImpl implements ParameterDeclaration { protected VarSymbol sym ; ParameterDeclarationImpl ( AptEnv env , VarSymbol sym ) { super ( env , sym ) ; this . sym = sym ; } public String toString ( ) { return getType ( ) + \" \" + sym . name ; } public boolean equals ( Object obj ) { if ( obj instanceof ParameterDeclarationImpl ) { ParameterDeclarationImpl that = ( ParameterDeclarationImpl ) obj ; return sym . owner == that . sym . owner && sym . name == that . sym . name && env == that . env ; } else { return false ; } } public int hashCode ( ) { return sym . owner . hashCode ( ) + sym . name . hashCode ( ) + env . hashCode ( ) ; } public TypeMirror getType ( ) { return env . typeMaker .", "gt": "getType ( sym . type ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 2575, "input": "<s> package com . talis . hbase . rdf . util ; import static org . openjena . atlas . lib . Lib . hashCodeObject ; import static org . openjena . atlas . lib . StrUtils . str ; import org . openjena . atlas . lib . Lib ; public class Pair < A , B > { A a ; B b ; public Pair ( A a , B b ) { this . a = a ; this . b = b ; } public A getLeft ( ) { return a ; } public B getRight ( ) { return b ; } public A car ( ) { return a ; } public B cdr ( ) { return b ; } @ Override public int hashCode ( ) { return hashCodeObject ( car ( ) ) ^ hashCodeObject ( cdr ( ) ) << 1 ; } @ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( ! ( other instanceof Pair < ? , ?", "gt": "> ) ) return false ;", "prediction": ") ;\n", "label": 1}
{"id": 4870, "input": "<s> interface I1 { int f ( ) ; } interface I2 { void f ( ) ; }", "gt": "interface InconsistentReturn extends I1 , I2", "prediction": "}\n", "label": 0}
{"id": 2576, "input": "<s> package org . eclipse . ui . internal . cheatsheets . registry ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . * ; import org . eclipse . ui . IPluginContribution ; import org . eclipse . ui . internal . cheatsheets . ICheatSheetResource ; import org . eclipse . ui . model . AdaptableList ; import org . eclipse . ui . model . IWorkbenchAdapter ; import org . eclipse . ui . model . WorkbenchAdapter ; public class CheatSheetCollectionElement extends WorkbenchAdapter implements IPluginContribution { private String pluginId ; private String id ; private String name ; private CheatSheetCollectionElement parent ; private AdaptableList cheatsheets = new AdaptableList ( ) ; private List childCollections = new ArrayList ( ) ; public CheatSheetCollectionElement ( String pluginId , String id , String name , CheatSheetCollectionElement parent ) { this . name = name ; this . pluginId = pluginId ; this . id = id ; this . parent = parent ; } public void add ( IAdaptable a ) { if ( a instanceof CheatSheetElement ) { cheatsheets . add ( a ) ; } else { childCollections . add ( a ) ; } } public CheatSheetCollectionElement findChildCollection ( IPath searchPath ) { Object [ ] children = getChildren ( ) ; String searchString = searchPath . segment ( 0 ) ; for ( int i = 0 ; i < children . length ; ++ i ) { CheatSheetCollectionElement currentCategory = ( CheatSheetCollectionElement ) children [ i ] ; if ( currentCategory . getLabel ( null ) . equals ( searchString ) ) { if ( searchPath . segmentCount ( ) == 1 ) return currentCategory ; return currentCategory . findChildCollection ( searchPath . removeFirstSegments ( 1 ) ) ; } } return null ; } public CheatSheetElement findCheatSheet ( String searchId , boolean recursive ) { Object [ ] cheatsheets = getCheatSheets ( ) ; for ( int i = 0 ; i < cheatsheets . length ; ++ i ) { CheatSheetElement currentCheatSheet = ( CheatSheetElement ) cheatsheets [ i ] ; if ( currentCheatSheet . getID ( ) . equals ( searchId ) ) return currentCheatSheet ; } if ( ! recursive ) return null ; for ( Iterator iterator = childCollections . iterator ( ) ; iterator . hasNext ( ) ; ) { CheatSheetCollectionElement child = ( CheatSheetCollectionElement ) iterator . next ( ) ; CheatSheetElement result = child . findCheatSheet ( searchId , true ) ; if ( result != null ) return result ; } return null ; } public Object getAdapter ( Class adapter ) { if ( adapter == IWorkbenchAdapter . class ) { return this ; } return Platform . getAdapterManager ( ) . getAdapter ( this , adapter ) ; } public String getId ( ) { return id ; } public String getLabel ( Object o ) { return name ; } public", "gt": "Object getParent ( Object o )", "prediction": "}\n", "label": 1}
{"id": 3666, "input": "<s> package api . top ; import java . util . List ; import api . soup . MySoup ; public class Results { private String artist ; private Number data ; private String encoding ; private String format ; private Number groupCategory ; private Number groupId ; private String groupName ; private Number groupYear ; private boolean hasCue ; private boolean hasLog ; private Number leechers ; private String media ; private String remasterTitle ; private boolean scene ; private Number seeders ; private Number snatched ; private List < String > tags ; private Number torrentId ; private Number year ; private String name ; public String getName ( ) { return name ; } public String getArtist ( ) { return this . artist ; } public Number getData ( ) { return this . data ; } public String getEncoding ( ) { return this . encoding ; } public String getFormat ( ) { return this . format ; } public Number getGroupCategory ( ) { return this . groupCategory ; } public Number getGroupId ( ) { return this . groupId ; } public String getGroupName ( ) { return this . groupName ; } public Number getGroupYear ( ) { return this . groupYear ; } public boolean getHasCue ( ) { return this . hasCue ; } public boolean getHasLog ( ) { return this . hasLog ; } public Number getLeechers ( ) { return this . leechers ; } public String getMedia ( ) { return this . media ; } public String getRemasterTitle ( ) { return this . remasterTitle ; } public boolean getScene ( ) { return this . scene ; } public Number getSeeders ( ) { return this . seeders ; } public Number getSnatched ( ) { return this . snatched ; } public List", "gt": "< String > getTags ( )", "prediction": ";\n", "label": 0}
{"id": 2586, "input": "<s> package org . spliffy . sync . event ; import com .", "gt": "ettrema . event . Event ;", "prediction": "org . eclipse . eclipse . ;\n", "label": 1}
{"id": 480, "input": "<s> package com . gisgraphy . client . continent ; import static com . gisgraphy . client . continent . Continent . continent ; import com . gisgraphy . client . continent . Continent ; public class ContinentObjectMother { public static Continent europe ( ) { return continent ( \"EU\" ) . withName ( \"Europe\" ) ; } public static Continent northAmericaContinent ( ) { return continent (", "gt": "\"NA\" ) . withName ( \"North America\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2600, "input": "<s> package xxx ; public class D { void bar ( ) { A a = null ; a", "gt": ". foo ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4296, "input": "<s> package qualifiedNewScope ; class A { class B { } public static void main ( String [ ] args ) { new A ( ) { }", "gt": ". new B ( )", "prediction": "}\n", "label": 0}
{"id": 2613, "input": "<s> package org . nuxeo . connect . download . tests ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import org . nuxeo . common . utils . FileUtils ; import org . nuxeo . runtime . test . WorkingDirectoryConfigurator ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import org . nuxeo . runtime . test . runner . JettyFeature ; import org . nuxeo . runtime . test . runner . RuntimeFeature ; import org . nuxeo . runtime . test . runner . RuntimeHarness ; import org . nuxeo . runtime . test . runner . SimpleFeature ; @ Deploy ( { \"org.nuxeo.connect.client.wrapper:OSGI-INF/runtimeserver-contrib.xml\" , \"org.nuxeo.connect.client.wrapper:OSGI-INF/connect-client-framework.xml\" } ) @ Features ( { JettyFeature . class } ) public class DownloadFeature extends SimpleFeature implements WorkingDirectoryConfigurator { @ Override public void initialize ( FeaturesRunner runner ) throws Exception { runner . getFeature ( RuntimeFeature . class ) . getHarness ( ) . addWorkingDirectoryConfigurator ( this ) ; } public void configure ( RuntimeHarness", "gt": "harness , File workingDir ) throws IOException", "prediction": ")\n", "label": 1}
{"id": 7896, "input": "<s> class T6956758pos { interface I { } static class C { < T extends C & I > T cloneObject ( T object ) throws Exception { return", "gt": "( T ) object . clone ( ) ;", "prediction": ";\n", "label": 0}
{"id": 2624, "input": "<s> package org . powerbot . game . api . methods . widget ; import java . awt . Dimension ; import java . awt . Rectangle ; import java . util . ArrayList ; import java . util . Arrays ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . Calculations ; import org . powerbot . game . api . methods . Settings ; import org . powerbot . game . api . methods . Walking ; import org . powerbot . game . api . methods . Widgets ; import org . powerbot . game . api . methods . input . Keyboard ; import org . powerbot . game . api . methods . interactive . NPCs ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . methods . node . Menu ; import org . powerbot . game . api . methods . node . SceneEntities ; import org . powerbot . game . api . methods . tab . Inventory ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Timer ; import org . powerbot . game . api . wrappers . Entity ; import org . powerbot . game . api . wrappers . Identifiable ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . interactive . NPC ; import org . powerbot . game . api . wrappers . node . Item ; import org . powerbot . game . api . wrappers . node . SceneObject ; import org . powerbot . game . api . wrappers . widget . Widget ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; public class Bank { public static final int [ ] BANK_NPC_IDS = new int [ ] { 44 , 45 , 166 , 494 , 495 , 496 , 497 , 498 , 499 , 553 , 909 , 953 , 958 , 1036 , 1360 , 1702 , 2163 , 2164 , 2354 , 2355 , 2568 , 2569 , 2570 , 2617 , 2618 , 2619 , 2718 , 2759 , 3046 , 3198 , 3199 , 3293 , 3416 , 3418 , 3824 , 4456 , 4457 , 4458 , 4459 , 4519 , 4907 , 5257 , 5258 , 5259 , 5260 , 5488 , 5776 , 5777 , 5901 , 6200 , 6362 , 7049 , 7050 , 7605 , 8948 , 9710 , 13932 , 14707 , 14923 , 14924 , 14925 , 15194 } ; public static final int [ ] BANK_BOOTH_IDS = new int [ ] { 782 , 2213 , 3045 , 5276 , 6084 , 10517 , 11338 , 11758 , 12759 , 12798 , 12799 , 12800 , 12801 , 14369 , 14370 , 16700 , 19230 , 20325 , 20326 , 20327 , 20328 , 22819 , 24914 , 25808 , 26972 , 29085 , 34752 , 35647 , 36262 , 36786 , 37474 , 49018 , 49019 , 52397 , 52589 } ; public static final int [ ] BANK_COUNTER_IDS = new int [ ] { 42217 , 42377 , 42378 } ; public static final int [ ] BANK_CHEST_IDS = new int [ ] { 2693 , 4483 , 8981 , 12308 , 14382 , 20607 , 21301 , 27663 , 42192 , 57437 , 62691 } ; public static final int [ ] UNDEPOSITABLE_ITEM_IDS = new int [ ] { 2528 , 6796 , 14664 , 23713 , 23714 , 23715 , 23716 , 23717 , 23718 , 23719 , 23720 , 23721 , 23722 , 23723 , 23724 , 23725 , 23726 , 23727 , 23728 , 23729 , 23730 , 23731 , 23732 , 23733 , 23734 , 23735 , 23736 , 23737 , 23738 , 23739 , 23740 , 23741 , 23742 , 23743 , 23744 , 23745 , 23746 , 23747 , 23748 , 23749 , 23750 , 23751 , 23752 , 23753 , 23754 , 23755 , 23756 , 23757 , 23758 , 23759 , 23760 , 23761 , 23762 , 23763 , 23764 , 23765 , 23766 , 23767 , 23768 , 23769 , 23770 , 23771 , 23773 , 23774 , 23775 , 23776 , 23777 , 23778 , 23779 , 23780 , 23781 , 23782 , 23783 , 23784 , 23785 , 23786 , 23787 , 23788 , 23789 , 23790 , 23791 , 23792 , 23793 , 23794 , 23795 , 23796 , 23797 , 23798 , 23799 , 23800 , 23801 , 23802 , 23803 , 23804 , 23805 , 23806 , 23807 , 23808 , 23809 , 23810 , 23811 , 23812 , 23813 , 23814 , 23815 , 23816 , 23817 , 24154 , 24155 } ; public static final Tile [ ] UNREACHABLE_BANK_TILES = new Tile [ ] { new Tile ( 3191 , 3445 , 0 ) , new Tile ( 3180 , 3433 , 0 ) } ; public static final int WIDGET_BANK = 762 ; public static final int WIDGET_SLOTS_CONTAINER = 95 ; public static final int WIDGET_SCROLLBAR = 116 ; public static final int WIDGET_BUTTON_CLOSE_BANK = 45 ; public static", "gt": "final int WIDGET_BUTTON_DEPOSIT_INVENTORY = 34 ;", "prediction": "( ) ;\n", "label": 1}
{"id": 5055, "input": "<s> package com . sun . tools . doclets . internal . toolkit . taglets ; import com . sun . javadoc . * ; public class DocRootTaglet extends BaseInlineTaglet { public DocRootTaglet ( ) { name = \"docRoot\" ; } public TagletOutput getTagletOutput ( Tag tag , TagletWriter writer ) { return writer", "gt": ". getDocRootOutput ( ) ;", "prediction": ";\n", "label": 0}
{"id": 2625, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; public interface ITableAdapter { int getCheckWidthWithMargin ( ) ; int getCheckWidth ( ) ; int getCheckLeft ( ) ; int getItemImageWidth ( int columnIndex ) ; int getFocusIndex ( ) ; void setFocusIndex ( int focusIndex ) ; int getColumnLeftOffset ( int columnIndex ) ; int getLeftOffset ( ) ; void setLeftOffset ( int leftOffset ) ; void checkData ( ) ; void checkData ( int index ) ; int getColumnLeft ( TableColumn column ) ; int getDefaultColumnWidth ( ) ; boolean isItemVisible ( TableItem item ) ; boolean", "gt": "isItemVirtual ( int index ) ;", "prediction": "}\n", "label": 1}
{"id": 674, "input": "<s> package org . jboss . arquillian . android . impl ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . jboss . arquillian . android . api . AndroidBridge ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . android . api . AndroidExecutionException ; import org . jboss . arquillian . android . configuration . AndroidConfigurationException ; import org . jboss . arquillian . android . configuration . AndroidExtensionConfiguration ; import org . jboss . arquillian . android . configuration . AndroidSdk ; import org . jboss . arquillian . android . spi . event . AndroidBridgeInitialized ; import org . jboss . arquillian . android . spi . event . AndroidDeviceReady ; import org . jboss . arquillian . android . spi . event . AndroidVirtualDeviceAvailable ; import org . jboss . arquillian . android . spi . event . AndroidVirtualDeviceCreated ; import org . jboss . arquillian . core . api . Event ; import org . jboss . arquillian . core . api . InstanceProducer ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . core . api . annotation . Observes ; import org . jboss . arquillian . test . spi . annotation . SuiteScoped ; public class AndroidDeviceSelector { private static Logger log = Logger . getLogger ( AndroidDeviceSelector . class . getName ( ) ) ; @ Inject @ SuiteScoped private InstanceProducer < AndroidDevice > androidDevice ; @ Inject private Event < AndroidVirtualDeviceCreated > avdCreated ; @ Inject private Event < AndroidVirtualDeviceAvailable > avdAvailable ; @ Inject private Event < AndroidDeviceReady > androidDeviceReady ; @ SuppressWarnings ( \"serial\" ) public void getOrCreateAndroidDevice ( @ Observes AndroidBridgeInitialized event , ProcessExecutor executor , AndroidExtensionConfiguration configuration , AndroidSdk sdk ) throws AndroidConfigurationException , AndroidExecutionException { String avdName = configuration . getAvdName ( ) ; String serialId = configuration . getSerialId ( ) ; AndroidBridge bridge = event . getBridge ( ) ; AndroidDevice device = checkIfRealDeviceIsConnected ( bridge , serialId ) ; if ( device != null ) { androidDevice . set ( device ) ; androidDeviceReady . fire ( new AndroidDeviceReady ( device ) ) ; return ; } Set < String > devices = getAvdDeviceNames ( executor , sdk ) ; if ( ! devices . contains ( avdName ) || configuration . isForce ( ) ) { if ( log . isLoggable ( Level . FINE ) ) { log . fine ( \"Creating an Android virtual device named \" + avdName ) ; } Validate . notNullOrEmpty ( configuration . getSdSize ( ) , \"Memory SD card size must be defined\" ) ; try { executor . execute ( new HashMap < String , String > ( ) { { put ( \"Do you wish to create a custom hardware profile [no]\" , \"no\\n\" ) ; } } , sdk . getAndroidPath ( ) , \"create\" , \"avd\" , \"-n\" , avdName , \"-t\" , \"android-\" + configuration . getApiLevel ( ) , \"-f\" , \"-p\" , avdName , \"-c\" , configuration . getSdSize ( ) ) ; } catch ( InterruptedException e ) { throw new AndroidExecutionException ( \"Unable to create a new AVD Device\" , e ) ; } catch ( ExecutionException e ) { throw new AndroidExecutionException ( \"Unable to create a new AVD Device\" , e ) ; } log . info ( \"Android virtual device \" + avdName + \" was created\" ) ; avdCreated . fire ( new AndroidVirtualDeviceCreated ( avdName ) ) ; } else { log . info ( \"Android virtual device \" + avdName + \" already exists, will be reused in tests\" ) ; avdAvailable . fire ( new AndroidVirtualDeviceAvailable ( avdName ) ) ; } } private AndroidDevice checkIfRealDeviceIsConnected ( AndroidBridge bridge , String serialId ) { if ( serialId == null || serialId . trim ( ) . isEmpty ( ) ) { return null ; } for ( AndroidDevice device : bridge . getDevices ( ) ) { if ( serialId . equals ( device . getSerialNumber ( ) ) ) { return device ; } } log . warning ( \"SerialId \" + serialId + \" was specified, however no such device was connected. Trying to connect to an emulator instead.\" ) ; return null ; } private Set < String > getAvdDeviceNames ( ProcessExecutor executor , AndroidSdk sdk ) throws AndroidExecutionException { final Pattern deviceName = Pattern . compile ( \"[\\\\s]*Name: ([^\\\\s]+)[\\\\s]*\" ) ; Set < String > names = new HashSet <", "gt": "String > ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2636, "input": "<s> package org . eclipse . rap . examples . pages ; import org . eclipse . rap . examples . ExampleUtil ; import org . eclipse . rap . examples . IExamplePage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; public class GridLayoutExample implements IExamplePage { private Composite layoutArea ; private boolean propEqualWidth ; private boolean propPrefSize ; public void createControl ( final Composite parent ) { parent . setLayout ( ExampleUtil . createMainLayout ( 1 ) ) ; createLayoutArea ( parent ) ; createControlButtons ( parent ) ; } private void createLayoutArea ( Composite parent ) { if ( layoutArea == null || layoutArea . isDisposed ( ) ) { layoutArea = new Composite ( parent , SWT . NONE ) ; layoutArea . setLayout ( ExampleUtil . createFillLayout ( true ) ) ; layoutArea . setLayoutData ( ExampleUtil . createFillData ( ) ) ; } Control [ ] children = layoutArea . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { children [ i ] . dispose ( ) ; } createLayoutComp ( layoutArea ) ; layoutArea . layout ( ) ; } private void createLayoutComp ( final Composite parent ) { Composite composite = new Composite ( parent , SWT . NONE ) ; composite . setLayout ( ExampleUtil . createGridLayoutWithoutMargin ( 1 , false ) ) ; Composite layoutComp = new Composite ( composite , SWT . BORDER ) ; if ( ! propPrefSize ) { layoutComp . setLayoutData ( ExampleUtil . createFillData ( ) ) ; }", "gt": "GridLayout layout = new GridLayout ( 3 , propEqualWidth ) ;", "prediction": "}\n", "label": 1}
{"id": 7402, "input": "<s> package org . ofbiz . entityext ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastSet ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelViewEntity ; public class EntityGroupUtil { public static final String module = EntityGroupUtil . class . getName ( ) ; public static Set < String > getEntityNamesByGroup ( String entityGroupId , Delegator delegator , boolean requireStampFields ) throws GenericEntityException { Set < String > entityNames = FastSet . newInstance ( ) ; List < GenericValue > entitySyncGroupIncludes = delegator . findByAnd ( \"EntityGroupEntry\" , UtilMisc . toMap ( \"entityGroupId\" , entityGroupId ) , null , false ) ; List < ModelEntity > modelEntities = getModelEntitiesFromRecords ( entitySyncGroupIncludes , delegator , requireStampFields ) ; for ( ModelEntity modelEntity : modelEntities ) { entityNames . add ( modelEntity . getEntityName ( ) ) ; } return entityNames ; } public static List < ModelEntity > getModelEntitiesFromRecords ( List < GenericValue > entityGroupEntryValues , Delegator delegator , boolean requireStampFields ) throws GenericEntityException { List < ModelEntity > entityModelToUseList = FastList . newInstance ( ) ; for ( String entityName : delegator . getModelReader ( ) . getEntityNames ( ) ) { ModelEntity modelEntity = delegator . getModelEntity ( entityName ) ; if ( modelEntity instanceof ModelViewEntity ) { continue ; } if ( requireStampFields && ( ! modelEntity . isField ( ModelEntity . STAMP_FIELD ) || ! modelEntity . isField ( ModelEntity . STAMP_TX_FIELD ) ) ) { continue ; } if ( entityGroupEntryValues . size ( ) == 0 ) { entityModelToUseList . add ( modelEntity ) ; } else { boolean matchesInclude = false ; boolean matchesExclude = false ; boolean matchesAlways = false ; Iterator < GenericValue > entitySyncIncludeIter = entityGroupEntryValues . iterator ( ) ; while ( entitySyncIncludeIter . hasNext ( ) ) { GenericValue entitySyncInclude = entitySyncIncludeIter . next ( ) ; String entityOrPackage = entitySyncInclude . getString ( \"entityOrPackage\" ) ; boolean matches = false ; if ( entityName . equals ( entityOrPackage ) ) { matches = true ; } else if ( modelEntity . getPackageName ( ) . startsWith ( entityOrPackage ) ) { matches = true ; } if ( matches ) { if ( \"ESIA_INCLUDE\" . equals ( entitySyncInclude . getString ( \"applEnumId\" ) ) ) { matchesInclude = true ; } else if ( \"ESIA_EXCLUDE\" . equals", "gt": "( entitySyncInclude . getString ( \"applEnumId\" ) ) )", "prediction": "( ) ;\n", "label": 0}
{"id": 2639, "input": "<s> package org . restlet . test . ext . wadl ; import org . restlet . ext . wadl . WadlApplication ; import org . restlet . ext . wadl . WadlComponent ; import org . restlet . test . RestletTestCase ; public class WadlTestCase extends RestletTestCase { public void testWadl ( ) throws Exception { WadlComponent comp = new WadlComponent ( \"clap://class/org/restlet/test/ext/wadl/YahooSearch.wadl\" ) ; WadlApplication app = ( WadlApplication ) comp . getHosts ( ) . get ( 0 ) . getRoutes ( ) . get ( 0 ) . getNext ( ) ; assertNotNull ( app ) ; assertEquals ( app . getInboundRoot ( ) , app . getRouter ( ) ) ; assertNotNull (", "gt": "app . getInboundRoot ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9594, "input": "<s> public class TestExternalOverridenMethod extends JavadocTester { private static final String BUG_ID = \"4857717\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"XReader.html\" , \"<dt><strong>Overrides:</strong></dt>\" + NL + \"<dd><code><a href=\\\"http://java.sun.com/j2se/1.4.1/docs/api/java/io/FilterReader.html?is-external=true#read()\\\" \" + \"title=\\\"class or interface in java.io\\\">read</a></code>&nbsp;in class&nbsp;<code>\" + \"<a href=\\\"http://java.sun.com/j2se/1.4.1/docs/api/java/io/FilterReader.html?is-external=true\\\" \" + \"title=\\\"class or interface in java.io\\\">FilterReader</a></code></dd>\" } , { BUG_ID + FS + \"pkg\" + FS + \"XReader.html\" , \"<dt><strong>Specified by:</strong></dt>\" + NL + \"<dd><code><a href=\\\"http://java.sun.com/j2se/1.4.1/docs/api/java/io/DataInput.html?is-external=true#readInt()\\\" \" + \"title=\\\"class or interface in java.io\\\">readInt</a></code>&nbsp;in interface&nbsp;<code>\" + \"<a href=\\\"http://java.sun.com/j2se/1.4.1/docs/api/java/io/DataInput.html?is-external=true\\\" \" + \"title=\\\"class or interface in java.io\\\">DataInput</a></code></dd>\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"-linkoffline\"", "gt": ", \"http://java.sun.com/j2se/1.4.1/docs/api\" , SRC_DIR , \"pkg\" }", "prediction": ") ;\n", "label": 0}
{"id": 2647, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . concurrent . TimeUnit ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . core . RedisCallback ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . ValueOperations ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisStringTest extends RedisTestSupport { private ValueOperations valueOperations ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { when ( redisTemplate . opsForValue ( ) ) . thenReturn ( valueOperations ) ; JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; valueOperations = mock ( ValueOperations . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteSET ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"SET\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUE , \"value\" ) ; verify ( valueOperations ) . set ( \"key\" , \"value\" ) ; } @ Test public void shouldExecuteSETNX ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"SETNX\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUE , \"value\" ) ; verify ( valueOperations ) . setIfAbsent ( \"key\" , \"value\" ) ; } @ Test public void shouldExecuteSETEX ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"SETEX\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" , RedisConstants . VALUE , \"value\" ) ; verify ( valueOperations ) . set ( \"key\" , \"value\" , 10 , TimeUnit . SECONDS ) ; } @ Test public void shouldExecuteSETRANGE ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"SETRANGE\" , RedisConstants . KEY , \"key\" , RedisConstants . OFFSET , \"10\" , RedisConstants . VALUE , \"value\" ) ; verify ( valueOperations ) . set ( \"key\" , \"value\" , 10 ) ; } @ Test public void shouldExecuteGETRANGE ( ) throws Exception { when ( valueOperations . get ( anyString ( ) , anyLong ( ) , anyLong ( ) ) ) . thenReturn ( \"test\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"GETRANGE\" , RedisConstants . KEY , \"key\" , RedisConstants . START , \"2\" , RedisConstants . END , \"4\" ) ; verify ( valueOperations ) . get ( \"key\" , 2 , 4 ) ; assertEquals ( \"test\" , result ) ; } @ Test public void shouldExecuteSETBIT ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"SETBIT\" , RedisConstants . KEY , \"key\" , RedisConstants . OFFSET , \"10\" , RedisConstants . VALUE , \"0\" ) ; verify ( redisTemplate ) . execute ( any ( RedisCallback . class ) ) ; } @ Test public void shouldExecuteGETBIT ( ) throws Exception { when ( redisTemplate . execute ( any ( RedisCallback . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"GETBIT\" , RedisConstants . KEY , \"key\" , RedisConstants . OFFSET , \"2\" ) ; verify ( redisTemplate ) . execute ( any ( RedisCallback . class ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteGET ( ) throws Exception { when ( valueOperations . get ( \"key\" ) ) . thenReturn ( \"value\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"GET\" , RedisConstants . KEY , \"key\" ) ; verify ( valueOperations ) . get ( \"key\" ) ; assertEquals ( \"value\" , result ) ; } @ Test", "gt": "public void shouldExecuteAPPEND ( ) throws Exception", "prediction": "( ) ;\n", "label": 1}
{"id": 7125, "input": "<s> package org . parboiled . examples . calculators ; import org . parboiled . Parboiled ; import org . parboiled . common . StringBuilderSink ; import org . parboiled . support . ParsingResult ; import org . testng . annotations . Test ; import org . parboiled . parserunners . TracingParseRunner ; import static org . parboiled . common . Predicates . * ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; import static org . parboiled . support . Filters . rules ; import static org . parboiled . support . Filters . rulesBelow ; import static org . testng . Assert . assertEquals ; public class TracingParseRunnerTest { @ Test public void testTracingParseRunner ( ) { CalculatorParser1 parser = Parboiled . createParser ( CalculatorParser1 . class ) ; StringBuilderSink log = new StringBuilderSink ( ) ; TracingParseRunner < Integer > runner = new TracingParseRunner < Integer > ( parser . InputLine ( ) ) . withFilter ( and ( rules ( parser . Number ( ) , parser . Parens ( ) ) , not ( rulesBelow ( parser . Digits ( ) ) ) ) ) . withLog ( log ) ; ParsingResult < Integer > result = runner . run ( \"2*(4+5\" ) ; assertEquals ( printParseErrors ( result ) , \"\" + \"Invalid input 'EOI', expected Digit, '*', '/', '+', '-' or ')' (line 1, pos 7):\\n\" + \"2*(4+5\\n\" + \"      ^\\n\" ) ; assertEquals ( log . toString ( ) , \"Starting new parsing run\\n\" + \"InputLine/Expression/Term/Factor/Number/Digits, matched, cursor at 1:2 after \\\"2\\\"\\n\" + \"..(4)../Number/Number_Action1, matched, cursor at 1:2 after \\\"2\\\"\\n\" + \"..(4)../Number, matched, cursor at 1:2 after \\\"2\\\"\\n\" + \"..(2)../Term/ZeroOrMore/FirstOf/Sequence/Factor/Number/Digits, failed, cursor at 1:3 after \\\"2*\\\"\\n\" + \"..(7)../Number, failed, cursor at 1:3 after \\\"2*\\\"\\n\" + \"..(6)../Factor/Parens/'(', matched, cursor at 1:4 after \\\"2*(\\\"\\n\" + \"..(7)../Parens/Expression/Term/Factor/Number/Digits, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(11)../Number/Number_Action1, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(11)../Number, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(10)../Factor, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(9)../Term/ZeroOrMore/FirstOf/Sequence/'*', failed, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(12)../Sequence, failed, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(11)../FirstOf/Sequence/'/', failed, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(12)../Sequence, failed, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(11)../FirstOf, failed, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(10)../ZeroOrMore, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(9)../Term, matched, cursor at 1:5 after \\\"2*(4\\\"\\n\" + \"..(8)../Expression/ZeroOrMore/FirstOf/Sequence/'+', matched, cursor at 1:6 after \\\"2*(4+\\\"\\n\" + \"..(11)../Sequence/Term/Factor/Number/Digits, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(14)../Number/Number_Action1, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(14)../Number, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(13)../Factor, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(12)../Term/ZeroOrMore/FirstOf/Sequence/'*', failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(15)../Sequence, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(14)../FirstOf/Sequence/'/', failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(15)../Sequence, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(14)../FirstOf, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(13)../ZeroOrMore, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(12)../Term, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(11)../Sequence/Expression_Action1, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(11)../Sequence, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(10)../FirstOf, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(9)../ZeroOrMore/FirstOf/Sequence/'+', failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(11)../Sequence, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(10)../FirstOf/Sequence/'-', failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(11)../Sequence, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(10)../FirstOf, failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(9)../ZeroOrMore, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(8)../Expression, matched, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(7)../Parens/')', failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" + \"..(7)../Parens,", "gt": "failed, cursor at 1:7 after \\\"2*(4+5\\\"\\n\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2665, "input": "<s> package org . eclipse . ui . tests . dialogs ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . IPreferencePage ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . preferences . IWorkbenchPreferenceContainer ; import org . eclipse . ui . preferences . IWorkingCopyManager ; import org . eclipse . ui . preferences . WorkingCopyManager ; public class PreferenceDialogWrapper extends PreferenceDialog implements IWorkbenchPreferenceContainer { public PreferenceDialogWrapper ( Shell parentShell , PreferenceManager manager ) { super ( parentShell , manager ) ; } public", "gt": "boolean showPage ( IPreferenceNode node )", "prediction": "}\n", "label": 1}
{"id": 5139, "input": "<s> package com . sun . tools . javac . comp ; import java . util . HashMap ; import java . util . Map ; import java . util . LinkedHashMap ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . tree . JCTree . * ; import static com . sun . tools . javac . code . Flags . * ; import static com . sun . tools . javac . code . Kinds . * ; import static com . sun . tools . javac . code . TypeTags . * ; public class Flow extends TreeScanner { protected static final Context . Key < Flow > flowKey = new Context . Key < Flow > ( ) ; private final Names names ; private final Log log ; private final Symtab syms ; private final Types types ; private final Check chk ; private TreeMaker make ; private final Resolve rs ; private Env < AttrContext > attrEnv ; private Lint lint ; private final boolean allowImprovedRethrowAnalysis ; private final boolean allowImprovedCatchAnalysis ; public static Flow instance ( Context context ) { Flow instance = context . get ( flowKey ) ; if ( instance == null ) instance = new Flow ( context ) ; return instance ; } protected Flow ( Context context ) { context . put ( flowKey , this ) ; names = Names . instance ( context ) ; log = Log . instance ( context ) ; syms = Symtab . instance ( context ) ; types = Types . instance ( context ) ; chk = Check . instance ( context ) ; lint = Lint . instance ( context ) ; rs = Resolve . instance ( context ) ; Source source = Source . instance ( context ) ; allowImprovedRethrowAnalysis = source . allowImprovedRethrowAnalysis ( ) ; allowImprovedCatchAnalysis = source . allowImprovedCatchAnalysis ( ) ; } private boolean alive ; Bits inits ; Bits uninits ; HashMap < Symbol , List < Type > > preciseRethrowTypes ; Bits uninitsTry ; Bits initsWhenTrue ; Bits initsWhenFalse ; Bits uninitsWhenTrue ; Bits uninitsWhenFalse ; VarSymbol [ ] vars ; JCClassDecl classDef ; int firstadr ; int nextadr ; List < Type > thrown ; List < Type > caught ; Scope unrefdResources ; boolean loopPassTwo = false ; static class PendingExit { JCTree tree ; Bits inits ; Bits uninits ; Type thrown ; PendingExit ( JCTree tree , Bits inits , Bits uninits ) { this . tree = tree ; this . inits = inits . dup ( ) ; this . uninits = uninits . dup ( ) ; } PendingExit ( JCTree tree , Type thrown ) { this . tree = tree ; this . thrown = thrown ; } } ListBuffer < PendingExit > pendingExits ; void errorUncaught ( ) { for ( PendingExit exit = pendingExits . next ( ) ; exit != null ; exit = pendingExits . next ( ) ) { if ( classDef != null && classDef . pos == exit . tree . pos ) { log . error ( exit . tree . pos ( ) , \"unreported.exception.default.constructor\" , exit . thrown ) ; } else if ( exit . tree . getTag ( ) == JCTree . VARDEF && ( ( JCVariableDecl ) exit . tree ) . sym . isResourceVariable ( ) ) { log . error ( exit . tree . pos ( ) , \"unreported.exception.implicit.close\" , exit . thrown , ( ( JCVariableDecl ) exit .", "gt": "tree ) . sym . name ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2671, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor ; import java . util . HashSet ; import java . util . Set ; import java . util . Vector ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . text . IAutoEditStrategy ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentPartitioner ; import org . eclipse . jface . text . ITextDoubleClickStrategy ; import org . eclipse . jface . text . ITextHover ; import org . eclipse . jface . text . contentassist . ContentAssistant ; import org . eclipse . jface . text . contentassist . IContentAssistant ; import org . eclipse . jface . text . presentation . IPresentationReconciler ; import org . eclipse . jface . text . presentation . PresentationReconciler ; import org . eclipse . jface . text . reconciler . IReconciler ; import org . eclipse . jface . text . reconciler . MonoReconciler ; import org . eclipse . jface . text . rules . DefaultDamagerRepairer ; import org . eclipse . jface . text . rules . FastPartitioner ; import org . eclipse . jface . text . source . IAnnotationHover ; import org . eclipse . jface . text . source . ISourceViewer ; import org . eclipse . jface . text . source . SourceViewerConfiguration ; import org . eclipse . ui . internal . editors . text . EditorsPlugin ; import org . eclipse . ui . texteditor . AbstractDecoratedTextEditorPreferenceConstants ; import com . googlecode . veloeclipse . editor . VelocityCompletionProcessor ; import com . googlecode . veloeclipse . editor . VelocityEditor ; import com . googlecode . veloeclipse . scanner . HTMLScanner ; import com . googlecode . veloeclipse . scanner . HTMLScriptScanner ; import com . googlecode . veloeclipse . scanner . HTMLTagScanner ; import com . googlecode . veloeclipse . scanner . NonRuleBasedDamagerRepairer ; import com . googlecode . veloeclipse . scanner . VelocityPartitionScanner ; import com . googlecode . veloeclipse . ui . editor . xml . IEditorConfiguration ; import com . googlecode . veloeclipse . ui . editor . xml . VelocityAutoIndentStrategy ; import com . googlecode . veloeclipse . ui . editor . xml . WholePartitionDamagerRepairer ; import com . googlecode . veloeclipse . vaulttec . ui . IColorConstants ; import com . googlecode . veloeclipse . vaulttec . ui . VelocityColorProvider ; import com . sun . org . apache . xerces . internal . impl . XMLScanner ; public class VelocityConfiguration extends SourceViewerConfiguration implements IEditorConfiguration { public static final String [ ] PREFORMATTED_PARTITIONS = { IEditorConfiguration . SCRIPT_PARTITION , IEditorConfiguration . CDATA_PARTITION , IEditorConfiguration . PROC_INST_PARTITION , IEditorConfiguration . MULTI_LINE_COMMENT } ; public static final String [ ] ESCAPED_PARTITIONS = { IEditorConfiguration . CDATA_PARTITION , IEditorConfiguration . PROC_INST_PARTITION , IEditorConfiguration . MULTI_LINE_COMMENT , IEditorConfiguration . COMMENT_PARTITION } ; public static final String [ ] CDATA_PARTITIONS = { IEditorConfiguration . CDATA_PARTITION } ; private static Set fEMPTY_TAG_SET ; static { fEMPTY_TAG_SET = new HashSet ( ) ; for ( int i = 0 ; i < com . googlecode . veloeclipse . ui . editor . xml . IHTMLConstants . EMPTY_TAGS . length ; i ++ ) { fEMPTY_TAG_SET . add ( com . googlecode . veloeclipse . ui . editor . xml . IHTMLConstants . EMPTY_TAGS [ i ] ) ; } } private VelocityEditor fEditor ; private VelocityAutoIndentStrategy fAutoIndentStrategy ; private HTMLTagScanner fTagScanner ; private HTMLScriptScanner fScriptScanner ; private HTMLScanner fScanner ; VelocityColorProvider cp = null ; public VelocityConfiguration ( VelocityEditor anEditor ) { fEditor = anEditor ; } public String [ ] getConfiguredContentTypes ( ISourceViewer aSourceViewer ) { return VelocityPartitionScanner . TYPES ; } public IDocumentPartitioner createDocumentPartitioner ( ) { return new FastPartitioner ( new VelocityPartitionScanner ( ) , VelocityPartitionScanner . TYPES ) ; } public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , String contentType ) { if ( fAutoIndentStrategy == null ) { fAutoIndentStrategy = new VelocityAutoIndentStrategy ( this , sourceViewer ) ; } return new IAutoEditStrategy [ ] { fAutoIndentStrategy } ; } public ITextHover getTextHover ( ISourceViewer aSourceViewer , String aContentType ) { ITextHover hover ; if ( aContentType . equals ( IDocument . DEFAULT_CONTENT_TYPE ) || aContentType . equals ( IEditorConfiguration . TAG_PARTITION ) || aContentType . equals ( IEditorConfiguration . PARSED_STRING ) ) { hover = new VelocityTextHover ( fEditor ) ; } else { hover = null ; } return hover ; } public IAnnotationHover getAnnotationHover ( ISourceViewer aSourceViewer ) { return new VelocityAnnotationHover ( ) ; } public IContentAssistant getContentAssistant ( ISourceViewer aSourceViewer ) { ContentAssistant assistant = new ContentAssistant ( ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , true ) , IDocument . DEFAULT_CONTENT_TYPE ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . PARSED_STRING ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . CDATA_PARTITION ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . DOC_COMMENT ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . MULTI_LINE_COMMENT ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . PROC_PARTITION ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , true ) , IEditorConfiguration . SCRIPT_PARTITION ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , false ) , IEditorConfiguration . SINGLE_LINE_COMMENT ) ; assistant . setContentAssistProcessor ( new VelocityCompletionProcessor ( fEditor , true ) , IEditorConfiguration . TAG_PARTITION ) ; assistant . enableAutoInsert ( true ) ; assistant . enableAutoActivation ( true ) ; return assistant ; } public", "gt": "ITextDoubleClickStrategy getDoubleClickStrategy ( ISourceViewer aSourceViewer , String aContentType )", "prediction": "}\n", "label": 1}
{"id": 6306, "input": "<s> package fr . telecom . scrapbook . filters ; public class BlackWhiteFilter implements IImageFilter { public Image process ( Image imageIn ) { int r , g , b , corfinal ; for ( int x = 0 ; x < imageIn . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < imageIn . getHeight ( ) ; y ++ ) { r = imageIn . getRComponent ( x , y ) ; g = imageIn . getGComponent ( x , y ) ; b = imageIn", "gt": ". getBComponent ( x , y ) ;", "prediction": ";\n", "label": 0}
{"id": 2672, "input": "<s> package org . apache . lucene . search . regex ; public interface RegexQueryCapable {", "gt": "void setRegexImplementation ( RegexCapabilities impl ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1682, "input": "<s> import java . util . Iterator ; class T6400189c < T > { interface A < X > extends Iterable < X > { Iterator < X > iterator ( ) ; } interface A2 < Y > extends A < Y > { Iterator < Y > iterator ( ) ; } static abstract class B < Z > implements A < Z > { public abstract Iterator", "gt": "< Z > iterator ( ) ;", "prediction": "\n", "label": 0}
{"id": 2678, "input": "<s> package org . eclipse . ui . internal . preferences ; import java . util . Set ; public interface IPropertyMap { public Set keySet ( ) ; public Object getValue ( String propertyId , Class propertyType ) ; public boolean isCommonProperty ( String propertyId ) ; public boolean propertyExists ( String propertyId ) ; public void setValue", "gt": "( String propertyId , Object newValue ) ;", "prediction": "( )\n", "label": 1}
{"id": 3058, "input": "<s> package org . dawb . workbench . plotting . system . swtxy ; import java . text . NumberFormat ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import org . csstudio . swt . xygraph . figures . Annotation ; import org . csstudio . swt . xygraph . figures . Axis ; import org . csstudio . swt . xygraph . figures . IAnnotationLabelProvider ; import org . csstudio . swt . xygraph . figures . Legend ; import org . csstudio . swt . xygraph . figures . PlotArea ; import org . csstudio . swt . xygraph . figures . Trace ; import org . csstudio . swt . xygraph . figures . XYGraph ; import org . csstudio . swt . xygraph . linearscale . AbstractScale . LabelSide ; import org . dawb . common . services . ImageServiceBean . ImageOrigin ; import org . dawb . common . ui . plot . axis . IAxis ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . workbench . plotting . Activator ; import org . dawb . workbench . plotting . preference . PlottingConstants ; import org . dawb . workbench . plotting . system . swtxy . selection . AbstractSelectionRegion ; import org . eclipse . draw2d . Layer ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . graphics . PaletteData ; public class XYRegionGraph extends XYGraph { public XYRegionGraph ( ) { super ( ) ; removeAxis ( primaryXAxis ) ; removeAxis ( primaryYAxis ) ; primaryYAxis = new AspectAxis ( \"Y-Axis\" , true ) ; primaryYAxis . setTickLabelSide ( LabelSide . Primary ) ; primaryYAxis . setAutoScaleThreshold ( 0.1 ) ; addAxis ( primaryYAxis ) ; primaryXAxis = new AspectAxis ( \"X-Axis\" , false ) ; primaryXAxis . setTickLabelSide ( LabelSide . Primary ) ; addAxis ( primaryXAxis ) ; try { this . showLegend = Activator . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PlottingConstants . XY_SHOWLEGEND ) ; } catch ( NullPointerException ne ) { this . showLegend = true ; } } @ Override protected PlotArea createPlotArea ( XYGraph xyGraph ) { return new RegionArea ( this ) ; } public void addRegion ( final AbstractSelectionRegion region ) { getRegionArea ( ) . addRegion ( region ) ; } public void removeRegion ( final AbstractSelectionRegion region ) { getRegionArea ( ) . removeRegion ( region ) ; } public void renameRegion ( final AbstractSelectionRegion region , String name ) { getRegionArea ( ) . renameRegion ( region , name ) ; } public void setSelectionProvider ( final ISelectionProvider provider ) { getRegionArea ( ) . setSelectionProvider ( provider ) ; } public AbstractSelectionRegion createRegion ( String name , IAxis xAxis , IAxis yAxis , RegionType regionType , boolean startingWithMouseEvent ) throws Exception { return getRegionArea ( ) . createRegion ( name , xAxis , yAxis , regionType , startingWithMouseEvent ) ; } public void disposeRegion ( final AbstractSelectionRegion region ) { getRegionArea ( ) . disposeRegion ( region ) ; } public ImageTrace createImageTrace ( String name , Axis xAxis , Axis yAxis ) { RegionArea ra = ( RegionArea ) getPlotArea ( ) ; return ra . createImageTrace ( name , xAxis , yAxis ) ; } public void addImageTrace ( final ImageTrace trace ) { getRegionArea ( ) . addImageTrace ( trace ) ; } public void removeImageTrace ( final ImageTrace trace ) { getRegionArea ( ) . removeImageTrace ( trace ) ; } public boolean addRegionListener ( IRegionListener l ) { return getRegionArea ( ) . addRegionListener ( l ) ; } public boolean removeRegionListener ( IRegionListener l ) { return getRegionArea ( ) . removeRegionListener ( l ) ; } public AbstractSelectionRegion getRegion ( String name ) { return getRegionArea ( ) . getRegion ( name ) ; } public void clearRegions ( ) { getRegionArea ( ) . clearRegions ( ) ; } public List < AbstractSelectionRegion > getRegions ( ) { return getRegionArea ( ) . getRegions ( ) ; } public void clearRegionTool ( ) { getRegionArea ( ) . clearRegionTool ( ) ; } public void clearImageTraces ( ) { getRegionArea ( ) . clearImageTraces ( ) ; } public RegionArea getRegionArea ( ) { return ( RegionArea", "gt": ") getPlotArea ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2682, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . client . util ; import com . google . gwt . dom . client . Document ; import com . google . gwt . dom . client . Node ; import com . google . gwt . dom . client . NodeList ; public class Visitor { private final NodeProcessor processor ; private boolean processing = true ; private boolean partialVisit = false ; private Node startNode ; private Node endNode ; public Visitor ( NodeProcessor visitor ) { this . processor = visitor ; } public void process ( Node node ) { visit ( node ) ; } public void process ( Document document ) { visit ( document ) ; } public void process ( Node startNode , Node endNode ) { this . processing = false ; partialVisit = true ; this . startNode = startNode ; this . endNode = endNode ; visit ( startNode . getOwnerDocument ( ) ) ; } public void visit ( Node node ) { if ( startNode == node ) { processing = true ; } else if ( endNode == node ) { processing = false ; } if ( processor . doBreak ( ) ) { return ; } NodeList list = node . getChildNodes ( ) ; if ( list ==", "gt": "null || list . getLength ( ) == 0 )", "prediction": ") ;\n", "label": 1}
{"id": 7414, "input": "<s> package org . ofbiz . base . util . template ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . Writer ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Date ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . TimeZone ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . cache . UtilCache ; import freemarker . cache . TemplateLoader ; import freemarker . core . Environment ; import freemarker . ext . beans . BeanModel ; import freemarker . ext . beans . BeansWrapper ; import freemarker . template . Configuration ; import freemarker . template . SimpleHash ; import freemarker . template . SimpleScalar ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import freemarker . template . TemplateExceptionHandler ; import freemarker . template . TemplateModel ; import freemarker . template . TemplateModelException ; public class FreeMarkerWorker { public static final String module = FreeMarkerWorker . class . getName ( ) ; private static final UtilCache < String , Template > cachedTemplates = UtilCache . createUtilCache ( \"template.ftl.general\" , 0 , 0 , false ) ; private static final BeansWrapper defaultOfbizWrapper = configureBeansWrapper ( new BeansWrapper ( ) ) ; private static final Configuration defaultOfbizConfig = makeConfiguration ( defaultOfbizWrapper ) ; public static BeansWrapper getDefaultOfbizWrapper ( ) { return defaultOfbizWrapper ; } public static < T extends BeansWrapper > T configureBeansWrapper ( T wrapper ) { wrapper . setNullWildcards ( true ) ; return wrapper ; } public static Configuration makeConfiguration ( BeansWrapper wrapper ) { Configuration newConfig = new Configuration ( ) ; newConfig . setObjectWrapper ( wrapper ) ; newConfig . setSharedVariable ( \"Static\" , wrapper . getStaticModels ( ) ) ; newConfig . setLocalizedLookup ( false ) ; newConfig . setSharedVariable ( \"StringUtil\" , new BeanModel ( StringUtil . INSTANCE , wrapper ) ) ; newConfig . setTemplateLoader ( new FlexibleTemplateLoader ( ) ) ; newConfig . setAutoImports ( UtilProperties . getProperties ( \"freemarkerImports\" ) ) ; newConfig . setTemplateExceptionHandler ( new FreeMarkerWorker . OFBizTemplateExceptionHandler ( ) ) ; try { newConfig . setSetting ( \"datetime_format\" , \"yyyy-MM-dd HH:mm:ss.SSS\" ) ; newConfig . setSetting ( \"number_format\" , \"0.##########\" ) ; } catch ( TemplateException e ) { Debug . logError ( \"Unable to set date/time and number formats in FreeMarker: \" + e , module ) ; } ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Enumeration < URL > resources ; try { resources = loader . getResources ( \"freemarkerTransforms.properties\" ) ; } catch ( IOException e ) { Debug . logError ( e , \"Could not load list of freemarkerTransforms.properties\" , module ) ; throw UtilMisc . initCause ( new InternalError ( e . getMessage ( ) ) , e ) ; } while ( resources . hasMoreElements ( ) ) { URL propertyURL = resources . nextElement ( ) ; Debug . logInfo ( \"loading properties: \" + propertyURL , module ) ; Properties props = UtilProperties . getProperties ( propertyURL ) ; if ( UtilValidate . isEmpty ( props ) ) { Debug . logError ( \"Unable to locate properties file \" + propertyURL , module ) ; } else { loadTransforms ( loader , props , newConfig ) ; } } return newConfig ; } protected static void loadTransforms ( ClassLoader loader , Properties props , Configuration config ) { for ( Iterator < Object > i = props . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key", "gt": "= ( String ) i . next ( ) ;", "prediction": ";\n", "label": 0}
{"id": 2685, "input": "<s> package net . slipcor . banvote ; public class BVDebugger extends BVLogger { private final boolean active ; public BVDebugger ( boolean bActive ) { active = bActive ; } @ Override protected boolean isEmpty ( String s ) { if ( ! active || ( s == null )", "gt": "|| ( s . equals ( \"\" ) ) )", "prediction": "\n", "label": 1}
{"id": 195, "input": "<s> package ar . com . fdvs . dj . domain . builders ; public class ChartBuilderException extends BuilderException { private static final long serialVersionUID = - 1129855787917213375L ;", "gt": "public ChartBuilderException ( String message )", "prediction": "}\n", "label": 0}
{"id": 2698, "input": "<s> package cs224n . util ; import java . util . * ; import java . io . Serializable ; public abstract class MapFactory < K , V > implements Serializable { public static class HashMapFactory < K , V > extends MapFactory < K , V > { public Map < K , V > buildMap ( ) { return new HashMap < K , V > ( ) ; } } public static class IdentityHashMapFactory < K , V > extends MapFactory < K , V > { public Map < K , V > buildMap ( ) { return new IdentityHashMap < K , V > ( ) ; } } public static class TreeMapFactory < K , V > extends MapFactory < K , V > { public Map < K , V > buildMap ( ) { return new TreeMap < K , V > ( ) ; } } public static class WeakHashMapFactory < K , V > extends MapFactory < K , V > { public Map < K", "gt": ", V > buildMap ( )", "prediction": "\n", "label": 1}
{"id": 8697, "input": "<s> import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import java . util . * ; import com . sun . source . tree . * ; import com . sun . source . util . * ; public class TestResourceElement extends JavacTestingAbstractProcessor implements AutoCloseable { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ! roundEnv . processingOver ( ) ) { Trees trees = Trees . instance ( processingEnv ) ; for ( Element rootElement : roundEnv . getRootElements ( ) ) { TreePath treePath = trees . getPath ( rootElement ) ; VariableScanner varScanner = new VariableScanner ( trees ) ; varScanner . scan ( trees . getTree ( rootElement ) , treePath . getCompilationUnit ( ) ) ; if ( varScanner . getTrvElement ( ) == null ) { throw new AssertionError ( \"Element is", "gt": "null for 'trv'\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2726, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . internal . SWTEventListener ; public interface ShellListener extends SWTEventListener { public void shellActivated ( ShellEvent e ) ; public void", "gt": "shellClosed ( ShellEvent e ) ;", "prediction": "( )\n", "label": 1}
{"id": 4838, "input": "<s> class NullAppend { { String s", "gt": "= null + null ;", "prediction": ";\n", "label": 0}
{"id": 2727, "input": "<s> package org . restlet . representation ; import java . io . IOException ; import java . nio . channels . ReadableByteChannel ; import java . nio . channels . WritableByteChannel ; import org . restlet . data . MediaType ; import org . restlet . engine . io . NioUtils ; public class ReadableRepresentation extends ChannelRepresentation { private volatile ReadableByteChannel channel ; public ReadableRepresentation ( ReadableByteChannel readableChannel , MediaType mediaType ) { this ( readableChannel , mediaType , UNKNOWN_SIZE ) ; } public ReadableRepresentation ( ReadableByteChannel channel , MediaType mediaType , long expectedSize ) { super ( mediaType ) ; setSize ( expectedSize ) ; this", "gt": ". channel = channel ;", "prediction": "\n", "label": 1}
{"id": 890, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; public class WebSocketException extends Exception { private static final long serialVersionUID = 1L ; public WebSocketException ( String message ) { super ( message ) ; } public", "gt": "WebSocketException ( String message , Throwable t )", "prediction": "}\n", "label": 0}
{"id": 2742, "input": "<s> package org . fuzzydb . server . internal . search ; import java . util . ArrayList ; import org . fuzzydb . attrs . search . SearchSpecImpl ; public interface Search { public ArrayList < NextItem > getNextResults ( int limit ) ; public", "gt": "boolean isMoreResults ( ) ;", "prediction": "\n", "label": 1}
{"id": 7279, "input": "<s> package com . shopzilla . api . service ; import com . shopzilla . services . catalog . ProductResponse ; import org . springframework . oxm . Marshaller ; import org . springframework . oxm . Unmarshaller ; import org . springframework . oxm . XmlMappingException ; import javax . xml . bind . JAXBException ; import javax . xml . transform . stream . StreamSource ; import java . io . IOException ; import java . io . InputStream ; public class ProductService { private Marshaller marshaller ; private Unmarshaller unmarshaller ; public ProductResponse xmlInputStreamToJava ( InputStream in ) throws IOException , JAXBException { try { ProductResponse productResponse = ( ProductResponse ) unmarshaller . unmarshal ( new StreamSource ( in ) ) ; System . out . println (", "gt": "\"productResponse = \" + productResponse ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2747, "input": "<s> package de . uos . igf . db3d . dbms . api ; public class ContainmentException extends UpdateException { public ContainmentException ( ) { super ( ) ; } public ContainmentException ( String arg0 ) { super ( arg0 ) ; } public ContainmentException ( Throwable arg0 ) { super ( arg0 ) ; } public", "gt": "ContainmentException ( String arg0 , Throwable arg1 )", "prediction": "}\n", "label": 1}
{"id": 8361, "input": "<s> package com . mobeelizer . mobile . android . model ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyString ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . stubbing . OngoingStubbing ; import org . powermock . api . mockito . PowerMockito ; import org . powermock . core . classloader . annotations . PrepareForTest ; import org . powermock . modules . junit4 . PowerMockRunner ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . DatabaseUtils ; import android . database . sqlite . SQLiteDatabase ; import android . util . Log ; import com . mobeelizer . java . api . MobeelizerCredential ; import com . mobeelizer . java . api . MobeelizerErrorsBuilder ; import com . mobeelizer . java . api . MobeelizerField ; import com . mobeelizer . java . api . MobeelizerFieldCredentials ; import com . mobeelizer . java . definition . MobeelizerModelCredentialsDefinition ; import com . mobeelizer . java . model . MobeelizerFieldImpl ; import com . mobeelizer . java . model . MobeelizerModelImpl ; import com . mobeelizer . java . sync . MobeelizerJsonEntity ; import com . mobeelizer . java . sync . MobeelizerJsonEntity . ConflictState ; import com . mobeelizer . mobile . android . TestEntity ; import com . mobeelizer . mobile . android . TestSimpleEntity ; @ RunWith ( PowerMockRunner . class ) @ PrepareForTest ( { MobeelizerAndroidModel . class , ContentValues . class , Log . class , DatabaseUtils . class , HashMap . class , MobeelizerAndroidField . class , MobeelizerErrorsBuilder . class , MobeelizerFieldImpl . class , MobeelizerErrorsBuilder . class } ) public class MobeelizerModelDefinitionImplTest { private MobeelizerFieldImpl field ; private MobeelizerAndroidField field2 ; private MobeelizerAndroidModel definition ; private MobeelizerAndroidModel simpleDefinition ; private SQLiteDatabase database ; private ContentValues values ; private UUID uuid ; private ContentValues deletedValues ; private Set < MobeelizerField > fields ; private MobeelizerErrorsBuilder errors ; @ Before public void init ( ) throws Exception { PowerMockito . mockStatic ( Log . class ) ; PowerMockito . when ( Log . class , \"i\" , anyString ( ) , anyString ( ) ) . thenReturn ( 0 ) ; MobeelizerFieldCredentials allCredentials = mock ( MobeelizerFieldCredentials . class ) ; when ( allCredentials . getCreateAllowed ( ) ) . thenReturn ( MobeelizerCredential . ALL ) ; when ( allCredentials . getUpdateAllowed ( ) ) . thenReturn ( MobeelizerCredential . ALL ) ; when ( allCredentials . getReadAllowed ( ) ) . thenReturn ( MobeelizerCredential . ALL ) ; field = PowerMockito . mock ( MobeelizerFieldImpl . class ) ; when ( field . getName ( ) ) . thenReturn ( \"field\" ) ; when ( field . getCredentials ( ) ) . thenReturn ( allCredentials ) ; field2 = mock ( MobeelizerAndroidField . class ) ; when ( field2 . getName ( ) ) . thenReturn ( \"field\" ) ; when ( field2 . getCredentials ( ) ) . thenReturn ( allCredentials ) ; PowerMockito . whenNew ( MobeelizerAndroidField . class ) . withArguments ( field ) . thenReturn ( field2 ) ; fields = new HashSet < MobeelizerField > ( ) ; fields . add ( field ) ; database = mock ( SQLiteDatabase . class ) ; deletedValues = mock ( ContentValues . class ) ; values = mock ( ContentValues . class ) ; PowerMockito . whenNew ( ContentValues . class ) . withNoArguments ( ) . thenReturn ( deletedValues , values ) ; MobeelizerModelCredentialsDefinition credentials = mock ( MobeelizerModelCredentialsDefinition . class ) ; when ( credentials . getCreateAllowed ( ) )", "gt": ". thenReturn ( MobeelizerCredential . ALL ) ;", "prediction": ";\n", "label": 0}
{"id": 2772, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import org . eclipse . rap . rwt . internal . theme . QxBoxDimensions ; import junit . framework . TestCase ; public class QxBoxDimensions_Test extends TestCase { public void testIllegalArguments ( ) { try { QxBoxDimensions . valueOf ( ( String ) null ) ; fail ( \"NPE expected\" ) ; } catch ( NullPointerException e ) { } try { QxBoxDimensions . valueOf ( \"\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } try { QxBoxDimensions . valueOf ( \" 23px\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } try { QxBoxDimensions . valueOf ( \"23em\" ) ; fail ( \"IAE expected\" ) ; } catch ( IllegalArgumentException e ) { } } public void testZero ( ) { assertSame ( QxBoxDimensions . ZERO , QxBoxDimensions . valueOf ( \"0\" ) ) ; assertSame ( QxBoxDimensions . ZERO , QxBoxDimensions . valueOf ( \"0 0\" ) ) ; assertEquals ( 0 , QxBoxDimensions . ZERO . top ) ; assertEquals ( 0 , QxBoxDimensions . ZERO . right ) ; assertEquals ( 0 , QxBoxDimensions . ZERO . bottom ) ; assertEquals ( 0 , QxBoxDimensions . ZERO . left ) ; } public void test1Value ( ) { QxBoxDimensions dim23px = QxBoxDimensions . valueOf ( \"23px\" ) ; assertEquals ( 23 , dim23px . top ) ; assertEquals ( 23 , dim23px . right ) ; assertEquals ( 23 , dim23px . bottom ) ; assertEquals ( 23 , dim23px . left ) ; QxBoxDimensions dimNeg1 = QxBoxDimensions . valueOf ( \"-1\" ) ; assertEquals ( - 1 , dimNeg1 . top ) ; assertEquals ( - 1 , dimNeg1 . right ) ; assertEquals ( - 1 , dimNeg1 . bottom ) ; assertEquals ( - 1 , dimNeg1 . left ) ; } public void test2Values ( ) { QxBoxDimensions dimensions = QxBoxDimensions . valueOf ( \"0 2\" ) ; assertEquals ( 0 , dimensions . top ) ; assertEquals ( 2 , dimensions . right ) ; assertEquals ( 0 , dimensions . bottom ) ; assertEquals ( 2 , dimensions . left ) ; } public void test3Values ( ) { QxBoxDimensions dimensions = QxBoxDimensions . valueOf ( \"1 2 3px\" ) ; assertEquals ( 1 , dimensions . top ) ; assertEquals ( 2 , dimensions . right ) ; assertEquals ( 3 , dimensions . bottom ) ; assertEquals ( 2 , dimensions . left ) ; } public void test4Values ( ) { QxBoxDimensions dimensions = QxBoxDimensions . valueOf ( \"0px 1px 2px 3px\" ) ; assertEquals ( 0 , dimensions . top ) ; assertEquals ( 1 , dimensions . right ) ; assertEquals ( 2 , dimensions . bottom ) ; assertEquals ( 3 , dimensions . left ) ; } public void testDefaultString ( ) { QxBoxDimensions dim0123 = QxBoxDimensions . create ( 0 , 1 , 2 , 3 ) ; assertEquals ( \"0px 1px 2px 3px\" , dim0123 . toDefaultString ( ) ) ; QxBoxDimensions dim123 = QxBoxDimensions . create ( 1 , 2 , 3 , 2 ) ; assertEquals ( \"1px 2px 3px\" , dim123 . toDefaultString ( ) ) ; QxBoxDimensions dim01 = QxBoxDimensions . create ( 0 , 1 , 0 , 1 ) ; assertEquals ( \"0px 1px\" , dim01 . toDefaultString ( ) ) ; QxBoxDimensions dim1 = QxBoxDimensions . create ( 1 , 1 , 1 , 1 ) ; assertEquals ( \"1px\" , dim1 . toDefaultString ( ) ) ; } public void testHashCode ( ) { QxBoxDimensions dim1 = QxBoxDimensions . create ( 1 , 1 , 0 , 0 ) ; QxBoxDimensions dim2 = QxBoxDimensions . create ( 0", "gt": ", 25 , 0 , 0 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5406, "input": "<s> package com . redhat . ceylon . ceylondoc ; import static com . redhat . ceylon . ceylondoc . Util . getDoc ; import java . io . IOException ; import java . io . Writer ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . Package ; public class ModuleDoc extends CeylonDoc { private Module module ; public ModuleDoc ( CeylonDocTool tool , Writer writer , Module module ) throws IOException { super ( module , tool , writer ) ; this . module = module ; } public void generate ( ) throws IOException { htmlHead ( ) ; overview ( ) ; summary ( ) ; packages ( ) ; } public void complete ( ) throws IOException { close ( \"body\" ) ; close ( \"html\" ) ; } private void htmlHead ( ) throws IOException { htmlHead ( \"Overview\" ) ; } private void overview ( ) throws IOException { writeNav ( module , module , DocType . MODULE ) ; } private void summary ( ) throws IOException { open ( \"div class='head summary'\" ) ; open ( \"h1 id='section-module'\" ) ; write ( \"Module \" ) ; around ( \"code\" , module . getNameAsString ( ) ) ; close ( \"h1\" ) ; writeSourceLink ( module ) ; close ( \"div\" ) ; around ( \"div class='doc'\" , getDoc ( module , linkRenderer ( ) ) ) ; writeBy ( Util . getAuthors ( module ) , false ) ; } private void packages ( ) throws IOException { openTable ( \"section-packages\" , \"Packages\" , \"Package\" , \"Description\" ) ; for ( Package pkg : tool . getPackages ( module ) ) { doc ( pkg ) ; } close ( \"table\" ) ; } private void doc (", "gt": "Package pkg ) throws IOException", "prediction": ") ;\n", "label": 0}
{"id": 2780, "input": "<s> package net . claribole . zgrviewer ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . svg . Metadata ; public class LElem { static final String PORT_SEPARATOR = \":\" ; String groupID ; String title ; String [ ] URLs ; String [ ] tooltips ; Glyph [ ] glyphs ; LElem ( ) { } LElem ( Metadata md ) { this . groupID = md . getClosestAncestorGroupID ( ) ; this . title = md . getTitle ( ) ; this . URLs = new String [ ] { md . getURL ( ) } ; this . tooltips = new String [ ] { md . getURLTitle ( ) } ; } public String getTitle ( ) { return title ; } public String getURL ( Glyph g ) { return URLs [ 0 ] ; } public String getTooltip ( Glyph g ) { return tooltips [ 0 ] ; }", "gt": "public String getGroupID ( )", "prediction": "}\n", "label": 1}
{"id": 8091, "input": "<s> package org . json ; import java . io . IOException ; import java . io . Writer ; public class JSONWriter { private static final int maxdepth = 200 ; private boolean comma ; protected char mode ; private final JSONObject stack [ ] ; private int top ; protected Writer writer ; public JSONWriter ( Writer w ) { this . comma = false ; this . mode = 'i' ; this . stack = new JSONObject [ maxdepth ] ; this . top = 0 ; this . writer = w ; } private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( \"Null pointer\" ) ; } if ( this . mode == 'o' || this . mode == 'a' ) { try { if ( this . comma && this . mode == 'a' ) { this . writer . write ( ',' ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == 'o' ) { this . mode = 'k' ; } this . comma = true ; return this ; } throw new JSONException ( \"Value out of sequence.\" ) ; } public JSONWriter array ( ) throws JSONException { if ( this . mode == 'i' || this . mode == 'o' || this . mode == 'a' ) { this . push ( null ) ; this . append ( \"[\" ) ; this . comma = false ; return this ; } throw new JSONException ( \"Misplaced array.\" ) ; } private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == 'a' ? \"Misplaced endArray.\" : \"Misplaced endObject.\" ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . comma = true ; return this ; } public JSONWriter endArray ( ) throws JSONException { return this . end ( 'a' , ']' ) ; } public JSONWriter endObject ( ) throws JSONException { return this . end ( 'k' , '}' ) ; } public JSONWriter key", "gt": "( String string ) throws JSONException", "prediction": "\n", "label": 0}
{"id": 2801, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; import org . restlet . data . Preference ; import org . restlet . data . Status ; import org . restlet . representation . Representation ; import org . restlet . test . ext . jaxrs . services . resources . SimpleTrain ; import org . restlet . test . ext . jaxrs . util . TestUtils ; public class SimpleTrainTest extends JaxRsTestCase { private static final boolean ONLY_M2 = false ; private static final boolean ONLY_TEXT_ALL = false ; private static final Preference < MediaType > PREF_TEXTPLAIN_QUAL05 = new Preference < MediaType > ( MediaType . TEXT_PLAIN , 0.5f ) ; @ Override protected Application getApplication ( ) { return new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( SimpleTrain . class ) ; } } ; } public void testGetHtmlText ( ) throws Exception { if ( ! ONLY_M2 && ! ONLY_TEXT_ALL ) { final Response response = get ( MediaType . TEXT_HTML ) ; sysOutEntityIfError ( response ) ; assertTrue ( response . getStatus ( ) . isSuccess ( ) ) ; final Representation entity = response . getEntity ( ) ; assertEquals ( SimpleTrain . RERP_HTML_TEXT , entity . getText ( ) ) ; assertEqualMediaType ( MediaType . TEXT_HTML , entity . getMediaType ( ) ) ; } } public void testGetPlainText ( ) throws Exception { if ( ! ONLY_M2 && ! ONLY_TEXT_ALL ) { final Response response = get ( MediaType . TEXT_PLAIN ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; final Representation entity = response . getEntity ( ) ; assertEquals ( SimpleTrain . RERP_PLAIN_TEXT , entity . getText ( ) ) ; assertEqualMediaType ( MediaType . TEXT_PLAIN , entity . getMediaType ( ) ) ; } } public void testGetTextAll ( ) throws Exception { if ( ONLY_M2 ) { return ; } Response response = get ( MediaType . TEXT_ALL ) ; sysOutEntityIfError ( response ) ; Representation representation = response . getEntity ( ) ; final MediaType mediaType = representation . getMediaType ( ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertTrue ( mediaType . equals ( MediaType . TEXT_PLAIN , true ) || mediaType . equals ( MediaType . TEXT_HTML , true ) ) ; response = get ( MediaType . TEXT_PLAIN ) ; sysOutEntityIfError ( response ) ; assertTrue ( response . getStatus ( ) . isSuccess ( ) ) ; representation = response . getEntity ( ) ; assertEquals ( SimpleTrain . RERP_PLAIN_TEXT , representation . getText ( ) ) ; assertEqualMediaType ( MediaType . TEXT_PLAIN , representation ) ; } public void testGetTextMultiple1 ( ) throws Exception { if ( ! ONLY_M2 && ! ONLY_TEXT_ALL ) { final Response response = accessServer ( Method . GET , SimpleTrain . class , TestUtils . createList ( new Object [ ] { PREF_TEXTPLAIN_QUAL05 , MediaType . TEXT_CALENDAR } ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; final Representation entity = response . getEntity ( ) ; assertEqualMediaType ( MediaType . TEXT_PLAIN , entity . getMediaType ( ) ) ; assertEquals ( SimpleTrain . RERP_PLAIN_TEXT , entity . getText ( ) ) ; } } public void testGetTextMultiple2 ( ) throws Exception { if ( ONLY_TEXT_ALL ) { return ; } final Response response = accessServer ( Method . GET , SimpleTrain . class , TestUtils . createList ( new Object [ ] { PREF_TEXTPLAIN_QUAL05 , MediaType . TEXT_HTML } ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; final Representation representation = response . getEntity ( ) ; assertEqualMediaType ( MediaType . TEXT_HTML , representation . getMediaType ( ) ) ; assertEquals ( SimpleTrain . RERP_HTML_TEXT , representation . getText ( ) ) ; } public void testHead ( ) throws Exception { if ( ! ONLY_M2 && ! ONLY_TEXT_ALL ) { final Response responseHead = accessServer ( Method . HEAD , SimpleTrain . class , TestUtils . createList ( new Object [ ] { PREF_TEXTPLAIN_QUAL05 , MediaType . TEXT_HTML } ) ) ; final Response responseGett = accessServer ( Method . GET , SimpleTrain . class , TestUtils . createList ( new Object [ ] { PREF_TEXTPLAIN_QUAL05 , MediaType . TEXT_HTML } ) ) ; assertEquals ( Status . SUCCESS_OK , responseHead . getStatus ( ) ) ; assertEquals ( Status . SUCCESS_OK , responseGett . getStatus ( ) ) ; final Representation entityHead = responseHead . getEntity ( ) ; final Representation entityGett = responseGett . getEntity ( ) ; assertNotNull ( entityHead ) ; assertNotNull ( entityGett ) ; assertEqualMediaType ( MediaType . TEXT_HTML", "gt": ", entityGett . getMediaType ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1157, "input": "<s> package org . parboiled . matchervisitors ; import org . parboiled . MatcherContext ; import org . parboiled . matchers . * ; import org . parboiled . support . Chars ; import java . util . ArrayList ; import java . util . List ; public class FollowMatchersVisitor extends DefaultMatcherVisitor < Boolean > { private final CanMatchEmptyVisitor canMatchEmptyVisitor = new CanMatchEmptyVisitor ( ) ; private final List < Matcher > followMatchers = new ArrayList < Matcher > ( ) ; private MatcherContext context ; public List < Matcher > getFollowMatchers ( MatcherContext currentContext ) { followMatchers . clear ( ) ; context = currentContext . getParent ( ) ; while ( context != null ) { boolean complete = context . getMatcher ( ) . accept ( this ) ; if ( complete ) return followMatchers ; context = context . getParent ( ) ; } return followMatchers ; } @ Override public Boolean visit ( OneOrMoreMatcher matcher ) { followMatchers . add ( matcher . subMatcher ) ; return false ; } @ Override public Boolean visit ( SequenceMatcher matcher ) { for ( int i = context . getIntTag ( ) + 1 ; i < matcher . getChildren ( ) . size ( ) ; i ++ ) { Matcher child = matcher . getChildren ( ) . get ( i ) ; followMatchers . add ( child ) ; if ( ! child . accept ( canMatchEmptyVisitor ) ) return true ; } return false ; } @ Override public Boolean visit ( ZeroOrMoreMatcher matcher ) { followMatchers . add ( matcher . subMatcher ) ; return false ; } @ Override public Boolean", "gt": "defaultValue ( AbstractMatcher matcher )", "prediction": ";\n", "label": 0}
{"id": 2821, "input": "<s> package org . apache . lucene . analysis . ar ; public class ArabicStemmer { public static final char ALEF = '\u0627' ; public static final char BEH = '\u0628' ; public static final char TEH_MARBUTA = '\u0629' ; public static final char TEH = '\u062a' ; public static final char FEH = '\u0641' ; public static final char KAF = '\u0643' ; public static final char LAM = '\u0644' ; public static final char NOON = '\u0646' ; public static final char HEH = '\u0647' ; public static final char WAW = '\u0648' ; public static final char YEH = '\u064a' ; public static final char prefixes [ ] [ ] = { ( \"\" + ALEF + LAM ) . toCharArray ( ) , ( \"\" + WAW + ALEF + LAM ) . toCharArray ( ) , ( \"\" + BEH + ALEF + LAM ) . toCharArray ( ) , ( \"\" + KAF + ALEF + LAM ) . toCharArray ( ) , ( \"\" + FEH + ALEF + LAM ) . toCharArray ( ) , ( \"\" + LAM + LAM ) . toCharArray ( ) , ( \"\" + WAW ) . toCharArray ( ) , } ; public static final char suffixes [ ] [ ] = { ( \"\" + HEH + ALEF ) . toCharArray ( ) , ( \"\" + ALEF + NOON ) . toCharArray ( ) , ( \"\" + ALEF + TEH ) . toCharArray ( ) , ( \"\" + WAW + NOON ) . toCharArray ( ) , ( \"\" + YEH + NOON ) . toCharArray ( ) , ( \"\" + YEH + HEH ) . toCharArray ( ) , ( \"\" + YEH + TEH_MARBUTA ) . toCharArray ( ) , ( \"\" + HEH ) . toCharArray ( ) , ( \"\" + TEH_MARBUTA ) . toCharArray ( ) , ( \"\" + YEH ) . toCharArray ( ) , } ; public int stem ( char s [ ] , int len ) { len = stemPrefix ( s , len ) ; len = stemSuffix ( s , len ) ; return len ; } public int stemPrefix ( char s [ ] , int len ) { for ( int i = 0 ; i < prefixes . length ; i ++ ) if ( startsWith ( s , len , prefixes [ i ] ) ) return deleteN ( s , 0 , len , prefixes [ i ] . length ) ; return len ; } public int stemSuffix ( char s [ ] , int len ) { for ( int i = 0 ; i < suffixes . length ; i ++ ) if ( endsWith ( s , len , suffixes [ i ] ) ) len = deleteN ( s , len - suffixes [ i ] . length , len , suffixes [ i ] . length ) ; return len ; } boolean startsWith ( char s [ ] , int len , char prefix [ ] ) { if (", "gt": "prefix . length == 1 && len < 4 )", "prediction": ") ;\n", "label": 1}
{"id": 265, "input": "<s> package javax . lang . model . util ; import java . util . List ; import javax . lang . model . element . * ; import javax . lang . model . type . TypeMirror ; import static javax . lang . model . SourceVersion . * ; import javax . lang . model . SourceVersion ; import javax . annotation . processing . SupportedSourceVersion ; @ SupportedSourceVersion ( RELEASE_6 ) public abstract class AbstractAnnotationValueVisitor6 < R , P > implements AnnotationValueVisitor < R , P > { protected AbstractAnnotationValueVisitor6 ( ) { } public final R visit ( AnnotationValue av , P p ) { return av . accept ( this , p ) ; } public final R visit ( AnnotationValue av ) { return av . accept ( this , null ) ; } public R visitUnknown ( AnnotationValue av , P p ) {", "gt": "throw new UnknownAnnotationValueException ( av , p ) ;", "prediction": "}\n", "label": 0}
{"id": 2829, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class Shortcuts_BinderImpl_GenBundle_ie8_default_InlineClientBundleGenerator implements org . restlet . example . book . restlet . ch09 . client . Shortcuts_BinderImpl_GenBundle { private static Shortcuts_BinderImpl_GenBundle_ie8_default_InlineClientBundleGenerator _instance0 = new Shortcuts_BinderImpl_GenBundle_ie8_default_InlineClientBundleGenerator ( ) ; private void contactsgroupInitializer ( ) { contactsgroup = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"contactsgroup\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( externalImage ) , 0 , 0 , 31 , 22 , false , false ) ; } private static class contactsgroupInitializer { static { _instance0 . contactsgroupInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return contactsgroup ; } } public com . google . gwt . resources . client . ImageResource contactsgroup ( ) { return contactsgroupInitializer . get ( ) ; } private void gradientInitializer ( ) { gradient = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"gradient\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( externalImage0 ) , 0 , 0 , 1 , 64 , false , true ) ; } private static class gradientInitializer { static { _instance0 . gradientInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return gradient ; } } public com . google . gwt . resources . client . ImageResource gradient ( ) { return gradientInitializer . get ( ) ; } private void mailboxesgroupInitializer ( ) { mailboxesgroup = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"mailboxesgroup\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( externalImage1 ) , 0 , 0 , 31 , 22 , false , false ) ; } private static class mailboxesgroupInitializer { static { _instance0 . mailboxesgroupInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return mailboxesgroup ; } } public com . google . gwt . resources . client . ImageResource mailboxesgroup ( ) { return mailboxesgroupInitializer . get ( ) ; } private void tasksgroupInitializer ( ) { tasksgroup = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"tasksgroup\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( externalImage2 ) , 0 , 0 , 31 , 22 , false , false ) ; } private static class tasksgroupInitializer { static { _instance0 . tasksgroupInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return tasksgroup ; } } public com . google . gwt . resources . client . ImageResource tasksgroup ( ) { return tasksgroupInitializer . get ( ) ; } private void contactsgroupIe6DataInitializer ( ) { contactsgroupIe6Data = new com . google . gwt . resources . client . impl . DataResourcePrototype ( \"contactsgroupIe6Data\" , com . google . gwt . safehtml", "gt": ". shared . UriUtils . fromTrustedString ( \"data:image/gif;base64,R0lGODlhHwAWAPeIACMjIycnJwwMDBoaGhAQEBUVFR4eHk1NTSwsLHx8fLW1tcjIyG9vb3Z2drKysrOzs76+vre3t0hISLCwsAcHB3NzczExMampqcXFxb+/v3l5eW1tba+vrz8/P4CAgMPDw6urq62trTU1NZqamqOjo5aWlsbGxp2dnTo6OomJibq6uri4uKenp0NDQ4ODg8HBwZCQkLy8vI2NjYaGhv7+/sTExGxsbAICAvn5+dHR0fPz84uLi3R0dNra2jAwMPr6+mpqauHh4VhYWLGxsaioqDY2NpeXl9bW1o+Pj4yMjP39/fb29p+fn4iIiKampp6enn9/f+Pj4+/v793d3bS0tMnJyff39+zs7O7u7vj4+KWlpa6urs/Pz2tra0BAQNDQ0Ds7Oy0tLcfHx4eHh729vVxcXMvLy+np6YKCgtjY2EZGRvDw8NXV1ZiYmJmZmd7e3s7OzpSUlOfn525ubkxMTPX19aGhobu7u1tbW+bm5vz8/IGBgbm5ufLy8oqKil5eXvHx8UFBQZKSklFRUVZWVl9fX1paWmRkZP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAIgALAAAAAAfABYAAAj/ABEJHEgQkZQ9AG4oBACjoMOHBYtQmEiRAg+IDs9kIMKiI4sEAkKKFBkE48AsEC6oXOmFgMuXL0uYFBhlCIibOMEU2MmTp5oNNoI2gPCjYJotIZIq7TCgqVOnPjZIldrgSMEeQzho1eokgIGvYMGGYUC2LBUlBL9MWMs2CYC3cOMCqEC37pM+A39gcMC374UAgAMLLtKgsOESWAgueMC48YMUCCJLjuyDgYbLmJPIIQjohYLPoBXQsUC6tAVCCVKrTuAnT0E2EWLLVqFAhO3bgUp42M0bjRg9Ba3UWEGceA0lf1AoVw6jyhgX0KGz0PHwiIrrKmK8QcSgg3fvXHBouZlBfsaOHBB7kInBPsMaHXhayJdvB9GHHSnyE6HuEAccCAACmAMQEhRooARtYICEDAw6QENBNNSRQwYUZsCHDGUcoOGGGwpRQRMwwOCGGTgMdEUQC7yg4h0pCDHIizDGGCMQO8RRQgRTLEHDBzzyyMEhhAQp5JBEBmkIFEYYwcQENZiAwZMKGiLllFRWSWUXI2SZ5QImdGmCIIWEKeaYZI45xwloornAmmuWcMibcMYpZ5w8kGCnnQEBADs=\" ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5096, "input": "<s> package org . ofbiz . order . shoppingcart . product ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . order . shoppingcart . ShoppingCartEvents ; import org . ofbiz . order . shoppingcart . WebShoppingCart ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . webapp . website . WebSiteWorker ; public class ProductStoreCartAwareEvents { public static final String module = ProductStoreCartAwareEvents . class . getName ( ) ; public static String setSessionProductStore ( HttpServletRequest request , HttpServletResponse response ) { Map < String , Object > parameters = UtilHttp . getParameterMap ( request ) ; String productStoreId = ( String ) parameters . get ( \"productStoreId\" ) ; try { ProductStoreCartAwareEvents . setSessionProductStore ( productStoreId , request ) ; } catch ( Exception e ) { String errMsg = \"Problem setting new store: \" + e . toString ( ) ; Debug . logError ( e , errMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } return \"success\" ; } public static void setSessionProductStore ( String productStoreId , HttpServletRequest request ) { if ( productStoreId == null ) { return ; } HttpSession session = request . getSession ( ) ; String oldProductStoreId = ( String ) session . getAttribute ( \"productStoreId\" ) ; if ( productStoreId . equals ( oldProductStoreId ) ) { return ; } Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; GenericValue productStore = ProductStoreWorker . getProductStore ( productStoreId , delegator ) ; if ( productStore == null ) { throw new IllegalArgumentException ( \"Cannot set session ProductStore, passed productStoreId [\" + productStoreId + \"] is not valid/not found.\" ) ; } GenericValue webSite = WebSiteWorker . getWebSite ( request ) ; if ( webSite == null ) { throw new IllegalArgumentException ( \"Cannot set session ProductStore, could not find WebSite record based on web.xml setting.\" ) ; } String allowProductStoreChange = webSite . getString ( \"allowProductStoreChange\" ) ; if ( ! \"Y\" . equals ( allowProductStoreChange ) ) { throw new IllegalArgumentException ( \"Cannot set session ProductStore, changing ProductStore not allowed for WebSite [\" + webSite . getString ( \"webSite\" ) + \"].\" ) ; } session . setAttribute ( \"productStoreId\" , productStoreId ) ; session . removeAttribute ( \"CURRENT_CATALOG_ID\" ) ; UtilHttp . setCurrencyUomIfNone ( session , productStore . getString ( \"defaultCurrencyUomId\" ) ) ; UtilHttp . setLocaleIfNone ( session , productStore . getString ( \"defaultLocaleString\" ) ) ; ShoppingCart cart = ShoppingCartEvents . getCartObject ( request ) ; if ( ! productStoreId .", "gt": "equals ( cart . getProductStoreId ( ) ) )", "prediction": ") ;\n", "label": 0}
{"id": 2831, "input": "<s> package org . eclipse . swt . internal . widgets . datetimekit ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . controlkit . ControlThemeAdapter ; import org . eclipse . swt . widgets . DateTime ; public final class DateTimeThemeAdapter extends ControlThemeAdapter { public int getSpinnerButtonWidth ( DateTime dateTime ) { int upButtonWidth = getCssDimension ( \"DateTime-UpButton\" , \"width\" , dateTime ) ; int downButtonWidth =", "gt": "getCssDimension ( \"DateTime-DownButton\" , \"width\" , dateTime ) ;", "prediction": ";\n", "label": 1}
{"id": 9497, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; public class NoCopyByteArrayOutputStream extends ByteArrayOutputStream { public NoCopyByteArrayOutputStream ( ) { super ( ) ; } public NoCopyByteArrayOutputStream ( int size ) { super ( size ) ; } public InputStream getInputStream ( ) { return new ByteArrayInputStream (", "gt": "buf , 0 , count ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2843, "input": "<s> package org . nuxeo . ecm . wiki ; public class WikiTypes { public static final String WIKI = \"Wiki\" ; public static final String WIKIPAGE = \"WikiPage\" ; public static final String BLOGPOST = \"BlogPost\" ; public static final String BLOGSITE = \"BlogSite\" ; @ Deprecated public static final String SCHEMA_WIKIPAGE = \"wikiPage\" ; public static final String SCHEMA_WIKISITE = \"wikiSite\" ; public static", "gt": "final String SCHEMA_BLOGSITE = \"blogSite\" ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1231, "input": "<s> package org . xbill . DNS ; import java . util . EventListener ; public interface ResolverListener extends EventListener {", "gt": "void receiveMessage ( Object id , Message m ) ;", "prediction": "\n", "label": 0}
{"id": 2849, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . core . expressions . PropertyTester ; public class ListElementPropertyTester extends PropertyTester { public static final String ATTR_NAME = \"name\" ; public boolean test ( Object receiver , String property , Object", "gt": "[ ] args , Object expectedValue )", "prediction": ") ;\n", "label": 1}
{"id": 7768, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class LinearMinusHalfTransferFunction extends AbstractTransferFunction { @ Override public double getPoint ( double value ) { return Math . abs", "gt": "( ( value - 0.5 ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2854, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . IOException ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import org . apache . sqoop . util . LoggingUtils ; import com . cloudera . sqoop . mapreduce . db . DBConfiguration ; import com . cloudera . sqoop . lib . SqoopRecord ; public abstract class AsyncSqlRecordWriter < K extends SqoopRecord , V > extends RecordWriter < K , V > { private static final Log LOG = LogFactory . getLog ( AsyncSqlRecordWriter . class ) ; private Connection connection ; private Configuration conf ; protected final int rowsPerStmt ; private List < SqoopRecord > records ; private AsyncSqlOutputFormat . AsyncSqlExecThread execThread ; private boolean startedExecThread ; public AsyncSqlRecordWriter ( TaskAttemptContext context ) throws ClassNotFoundException , SQLException { this . conf = context . getConfiguration ( ) ; this . rowsPerStmt = conf . getInt ( AsyncSqlOutputFormat . RECORDS_PER_STATEMENT_KEY , AsyncSqlOutputFormat . DEFAULT_RECORDS_PER_STATEMENT ) ; int stmtsPerTx = conf . getInt ( AsyncSqlOutputFormat . STATEMENTS_PER_TRANSACTION_KEY , AsyncSqlOutputFormat . DEFAULT_STATEMENTS_PER_TRANSACTION ) ; DBConfiguration dbConf = new DBConfiguration ( conf ) ; this . connection = dbConf . getConnection ( ) ; this . connection . setAutoCommit ( false ) ; this . records = new ArrayList < SqoopRecord > ( this . rowsPerStmt ) ; this . execThread = new AsyncSqlOutputFormat . AsyncSqlExecThread ( connection , stmtsPerTx ) ; this . execThread . setDaemon ( true ) ; this . startedExecThread = false ; } protected final Connection getConnection ( ) { return this . connection ; } protected final Configuration getConf ( ) { return this . conf ; } protected boolean isBatchExec ( ) { return false ; } protected abstract PreparedStatement getPreparedStatement ( List < SqoopRecord > userRecords ) throws SQLException ; private void execUpdate ( boolean commit , boolean stopThread ) throws InterruptedException , SQLException { if ( ! startedExecThread ) { this . execThread . start ( ) ; this . startedExecThread = true ; } PreparedStatement stmt = null ; boolean successfulPut = false ; try { if ( records . size ( ) > 0 ) { stmt = getPreparedStatement ( records ) ; this . records . clear ( ) ; } AsyncSqlOutputFormat . AsyncDBOperation op = new AsyncSqlOutputFormat . AsyncDBOperation ( stmt , isBatchExec ( ) , commit , stopThread ) ; execThread . put ( op ) ; successfulPut = true ; } finally { if ( ! successfulPut && null != stmt ) { stmt . close ( ) ; } } SQLException lastException = execThread . getLastError ( ) ; if ( null != lastException ) { LoggingUtils . logAll ( LOG , lastException ) ; throw lastException ; } } @ Override public void close ( TaskAttemptContext context ) throws IOException , InterruptedException { try { try { execUpdate ( true , true ) ; execThread . join ( ) ; } catch ( SQLException sqle ) { throw new IOException ( sqle ) ; } SQLException lastErr = execThread . getLastError ( ) ; if ( null != lastErr ) { throw new IOException ( lastErr ) ; } } finally { try { closeConnection ( context ) ; } catch ( SQLException sqle ) { throw new IOException ( sqle ) ; } } } public void closeConnection ( TaskAttemptContext context ) throws SQLException { this . connection . close ( ) ; } @ Override public void write ( K key , V value ) throws InterruptedException , IOException { try { records . add ( ( SqoopRecord ) key . clone ( ) ) ; if ( records . size ( ) >= this . rowsPerStmt ) { execUpdate ( false , false ) ; } } catch ( CloneNotSupportedException cnse ) { throw new IOException ( \"Could not", "gt": "buffer record\" , cnse ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9255, "input": "<s> package com . redhat . ceylon . ant ; public class Rep { public String url ; public void setUrl ( String url ) { this", "gt": ". url = url ;", "prediction": "\n", "label": 0}
{"id": 2856, "input": "<s> package org . jscsi . parser . scsi ; import java . nio . ByteBuffer ; public final class SCSICommandDescriptorBlockParser { private static final int DEFAULT_CDB_LENGTH = 16 ; private SCSICommandDescriptorBlockParser ( ) { super ( ) ; } private static final byte READ_OP_CODE = 0x28 ; private static final byte READ_CAPACITY_OP_CODE = 0x25 ; private static final byte WRITE_OP_CODE = 0x2A ; private static final int LOGICAL_BLOCK_ADDRESS_OFFSET = 2 ; private static final int TRANSFER_LENGTH_OFFSET = 7 ; public static final ByteBuffer createReadMessage ( final int logicalBlockAddress , final short transferLength ) { return createReadWriteMessage ( READ_OP_CODE , logicalBlockAddress , transferLength ) ; } public static final ByteBuffer createWriteMessage ( final int logicalBlockAddress , final short transferLength ) { return createReadWriteMessage ( WRITE_OP_CODE , logicalBlockAddress , transferLength ) ; } private static final ByteBuffer createReadWriteMessage ( final byte opCode , final int logicalBlockAddress", "gt": ", final short transferLength )", "prediction": ") ;\n", "label": 1}
{"id": 6816, "input": "<s> import java . util . ArrayList ; import java . util . List ; class Unchecked { void m ( ) { List l = new ArrayList < String > ( ) ; l . add ( \"abc\" ) ; } } @ SuppressWarnings ( \"unchecked\" ) class Unchecked2 { void m ( ) { List l = new ArrayList < String > ( ) ; l . add ( \"abc\" ) ; } } class Unchecked3 { @ SuppressWarnings ( \"unchecked\" ) void m ( ) { List l =", "gt": "new ArrayList < String > ( ) ;", "prediction": ";\n", "label": 0}
{"id": 2861, "input": "<s> package br . org . archimedes . intersectors ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . intersections . interfaces . Intersector ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; public class LinePolylineIntersector implements Intersector { public Collection < Point > getIntersections ( Element element , Element otherElement ) throws NullArgumentException { Line baseLine ; Polyline polyline ; if ( element == null || otherElement == null ) throw new NullArgumentException ( ) ; if ( element . getClass ( ) == Line . class ) { baseLine", "gt": "= ( Line ) element ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6640, "input": "<s> package org . ofbiz . accounting . payment ; import java . math . BigDecimal ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class BillingAccountWorker { public static final String module = BillingAccountWorker . class . getName ( ) ; public static final String resourceError = \"AccountingUiLabels\" ; private static BigDecimal ZERO = BigDecimal . ZERO ; private static int decimals = - 1 ; private static int rounding = - 1 ; static { decimals = UtilNumber . getBigDecimalScale ( \"order.decimals\" ) ; rounding = UtilNumber . getBigDecimalRoundingMode ( \"order.rounding\" ) ; if ( decimals != - 1 ) ZERO = ZERO . setScale ( decimals ) ; } public static List < Map < String , Object > > makePartyBillingAccountList ( GenericValue userLogin , String currencyUomId , String partyId , Delegator delegator , LocalDispatcher dispatcher ) throws GeneralException { List < Map < String , Object > > billingAccountList = FastList . newInstance ( ) ; Map < String , Object > agentResult = dispatcher . runSync ( \"getRelatedParties\" , UtilMisc . < String , Object > toMap ( \"userLogin\" , userLogin , \"partyIdFrom\" , partyId , \"roleTypeIdFrom\" , \"AGENT\" , \"roleTypeIdTo\" , \"CUSTOMER\" , \"partyRelationshipTypeId\" , \"AGENT\" , \"includeFromToSwitched\" , \"Y\" ) ) ; if ( ServiceUtil . isError ( agentResult ) ) { throw new GeneralException ( \"Error while finding party BillingAccounts when getting Customers that this party is an agent of: \" + ServiceUtil . getErrorMessage ( agentResult ) ) ; } List < String > relatedPartyIdList = UtilGenerics . checkList ( agentResult . get ( \"relatedPartyIdList\" ) ) ; EntityCondition barFindCond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"partyId\" , EntityOperator . IN , relatedPartyIdList ) , EntityCondition . makeCondition ( \"roleTypeId\" , EntityOperator . EQUALS , \"BILL_TO_CUSTOMER\" ) ) , EntityOperator . AND ) ; List < GenericValue > billingAccountRoleList = delegator . findList ( \"BillingAccountRole\" , barFindCond , null , null , null , false ) ; billingAccountRoleList = EntityUtil . filterByDate ( billingAccountRoleList ) ; if ( billingAccountRoleList . size ( ) > 0 ) { BigDecimal totalAvailable = BigDecimal . ZERO ; for ( GenericValue billingAccountRole : billingAccountRoleList ) { GenericValue billingAccountVO = billingAccountRole . getRelatedOne ( \"BillingAccount\" , false ) ; java . sql . Timestamp thruDate = billingAccountVO . getTimestamp ( \"thruDate\" ) ; if ( ( thruDate != null ) && UtilDateTime . nowTimestamp ( ) . after ( thruDate ) ) continue ; if ( currencyUomId . equals ( billingAccountVO . getString ( \"accountCurrencyUomId\" ) ) ) { BigDecimal accountBalance = BillingAccountWorker . getBillingAccountBalance ( billingAccountVO ) ; Map < String , Object > billingAccount = new HashMap < String , Object > ( billingAccountVO ) ; BigDecimal accountLimit = getAccountLimit ( billingAccountVO ) ; billingAccount . put ( \"accountBalance\" , accountBalance ) ; BigDecimal accountAvailable = accountLimit . subtract ( accountBalance ) ; totalAvailable = totalAvailable . add ( accountAvailable ) ; billingAccountList . add ( billingAccount ) ; } } Collections . sort ( billingAccountList , new BillingAccountComparator ( ) ) ; } return billingAccountList ; } public static BigDecimal getAccountLimit ( GenericValue billingAccount ) throws GenericEntityException { if ( billingAccount . getBigDecimal ( \"accountLimit\" ) != null ) { return billingAccount . getBigDecimal ( \"accountLimit\" ) ; } else { Debug . logWarning ( \"Billing Account [\" + billingAccount . getString ( \"billingAccountId\" ) + \"] does not have", "gt": "an account limit defined, assuming zero.\" , module ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2863, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; class RestoreScrolledCompositeOriginsVisitor extends AllWidgetTreeVisitor { public boolean doVisit ( Widget widget ) { if ( widget instanceof ScrolledComposite ) { restoreOrigin ( ( ScrolledComposite ) widget ) ; restoreContentSize ( ( ScrolledComposite ) widget ) ; } return true ; } private void restoreOrigin ( ScrolledComposite composite ) { Point oldOrigin = getBufferedOrigin ( composite ) ; if ( oldOrigin != null ) { composite . setOrigin ( oldOrigin ) ; composite . setData ( TextSizeRecalculation . KEY_SCROLLED_COMPOSITE_ORIGIN , null ) ; } } private void restoreContentSize ( ScrolledComposite composite ) { Control content = composite . getContent ( ) ; if ( content != null ) { restoreContentSize ( content ) ; } } private void restoreContentSize ( Control content ) { Point size = getBufferedContentSize ( content ) ; if ( size != null ) { content . setSize ( size ) ; content . setData ( TextSizeRecalculation . KEY_SCROLLED_COMPOSITE_CONTENT_SIZE , null ) ; } } private Point getBufferedContentSize ( Control content ) { return ( Point ) content . getData ( TextSizeRecalculation . KEY_SCROLLED_COMPOSITE_CONTENT_SIZE ) ; } private Point getBufferedOrigin ( ScrolledComposite composite ) { return ( Point ) composite .", "gt": "getData ( TextSizeRecalculation . KEY_SCROLLED_COMPOSITE_ORIGIN ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 3045, "input": "<s> class T6711619a { static class A { private void a ( ) { } private A a ; } static class B extends A { private B b ( ) { } private B b ; } static interface I { void i ( ) ; } static interface I1 { void i1 ( ) ; } static class E extends B implements I , I1 { public void i ( ) { } public void i1 ( ) { } } static class C < W extends B & I1 , T extends W > { T t ; W w ; C ( W w , T t ) { this . w = w ; this . t = t ; } } static void testMemberMethods ( C < ? extends A , ? extends I > arg ) { arg . t . a ( ) ; arg . t . b ( ) ; } static void testMemberFields ( C < ? extends A , ? extends I > arg ) { A ta ; B tb ; ta = arg . t . a ; tb = arg . t . b ; ta = arg . w . a ; tb", "gt": "= arg . w . b ;", "prediction": ";\n", "label": 0}
{"id": 2873, "input": "<s> package org . restlet . test . ext . sip ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; public class SipTests extends TestCase { public static Test suite ( ) { final TestSuite suite = new TestSuite ( ) ; suite . setName ( \"SIP extension\" ) ; suite . addTestSuite ( AddressTestCase . class ) ; suite . addTestSuite ( AvailabilityTestCase . class ) ; suite . addTestSuite ( EventTypeTestCase . class ) ; suite .", "gt": "addTestSuite ( SipRecipientInfoTestCase . class ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 5487, "input": "<s> public interface A { public", "gt": "A test ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2879, "input": "<s> package tk . blackwolf12333 . grieflog . data ; public class OldVersionException extends IllegalArgumentException { private static final long serialVersionUID = 286259095553845437L ; public", "gt": "OldVersionException ( String s )", "prediction": "( ) ;\n", "label": 1}
{"id": 3028, "input": "<s> package annot . annot2 ; public @ interface AnnotSimple2 { String value", "gt": "( ) default \"default\" ;", "prediction": ";\n", "label": 0}
{"id": 2880, "input": "<s> package com . talis . hbase . rdf . layout . hash ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . StoreBase ; import com . talis . hbase . rdf . layout . TableDescLayouts ; import com . talis . hbase . rdf . store . StoreFormatter ; import com . talis", "gt": ". hbase . rdf . store . StoreLoader ;", "prediction": ";\n", "label": 1}
{"id": 2165, "input": "<s> class T6680106 { class A0 { } class A1 < T extends T [ ] > { } class A2 < T extends S [ ] , S extends T [ ] > { } class A3 < T extends S [ ] , S extends U [ ] , U extends T [ ] > { } class A5 < T extends A0 & T [ ] > { } class A6 < T extends A0 & S [ ] ,", "gt": "S extends A0 & T [ ] >", "prediction": ") ;\n", "label": 0}
{"id": 2886, "input": "<s> package org . eclipse . rap . rwt . internal . theme . css ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . theme . QxBorder ; import org . eclipse . rap . rwt . internal . theme . QxType ; import org . eclipse . rap . rwt . internal . theme . WidgetMatcher ; import org . eclipse . rap . rwt . internal . theme . WidgetMatcher . Constraint ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Widget ; public class WidgetMatcher_Test extends TestCase { public void testWidgetMatcher ( ) { WidgetMatcher matcher = new WidgetMatcher ( ) ; matcher . addStyle ( \"BORDER\" , SWT . BORDER ) ; matcher . addStyle ( \"PUSH\" , SWT . PUSH ) ; matcher . addStyle ( \"TOGGLE\" , SWT . TOGGLE ) ; matcher . addState ( \"selected\" , new Constraint ( ) { public boolean matches ( Widget widget ) { Button button = ( Button ) widget ; return button . getSelection ( ) ; } } ) ; ConditionalValue value1 = new ConditionalValue ( new String [ ] { \"[BORDER\" , \"[TOGGLE\" , \":selected\" } , QxBorder . create ( 2 , \"solid\" , \"red\" ) ) ; ConditionalValue value2 = new ConditionalValue ( new String [ ] { \"[BORDER\" , \"[TOGGLE\" } , QxBorder . create ( 2 , \"dotted\" , \"blue\" ) ) ; ConditionalValue value3 = new ConditionalValue ( new String [ ] { \".special\" } , QxBorder . create ( 1 , \"solid\" , \"green\" ) ) ; ConditionalValue [ ] values = new ConditionalValue [ ] { value1 , value2 , value3 } ; Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; Widget button1 = new Button ( shell , SWT . TOGGLE ) ; QxType result = matcher . select ( values , button1 ) ; assertNull ( result ) ; Button button2 = new Button ( shell , SWT . TOGGLE | SWT . BORDER ) ; result = matcher . select ( values , button2 ) ; assertEquals ( value2 . value , result ) ; button2 . setSelection ( true ) ; result = matcher . select ( values , button2 ) ; assertEquals ( value1 . value , result ) ; button2 . setData ( RWT . CUSTOM_VARIANT , \"special\" ) ; result = matcher . select ( values , button2 ) ; assertEquals ( value1 . value , result ) ; Button button3 = new Button ( shell , SWT . TOGGLE ) ; button3 . setData ( RWT . CUSTOM_VARIANT , \"special\" ) ; result = matcher . select ( values , button3 ) ; assertEquals ( value3 . value , result ) ; button3 . setData ( RWT . CUSTOM_VARIANT , \"other\" ) ; result = matcher . select ( values , button3 ) ; assertNull ( result ) ; } @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; } @ Override protected", "gt": "void tearDown ( ) throws Exception", "prediction": "( )\n", "label": 1}
{"id": 4302, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . util . Collections ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleChildReferenceEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLabelNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLinkMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleTopNodeEditPart ; public class SimplemapDiagramUpdater { public static List < SimplemapNodeDescriptor > getSemanticChildren ( View view ) { switch ( SimplemapVisualIDRegistry . getVisualID ( view ) ) { case SimpleMappingEditPart . VISUAL_ID : return getSimpleMapping_79SemanticChildren ( view ) ; case SimpleTopNodeEditPart . VISUAL_ID : return getSimpleTopNode_1001SemanticChildren ( view ) ; case SimpleCompartmentEditPart . VISUAL_ID : return getSimpleCompartment_2002SemanticChildren ( view ) ; case SimpleSubNodeEditPart . VISUAL_ID : return getSimpleSubNode_2003SemanticChildren ( view ) ; } return Collections . emptyList ( ) ; } public static List < SimplemapNodeDescriptor > getSimpleMapping_79SemanticChildren ( View view ) { if ( ! view . isSetElement ( ) ) { return Collections . emptyList ( ) ; } SimpleMapping modelElement = ( SimpleMapping ) view . getElement ( ) ; LinkedList < SimplemapNodeDescriptor > result = new LinkedList < SimplemapNodeDescriptor > ( ) ; for ( Iterator < ? > it = modelElement . getChildren ( ) . iterator ( ) ; it . hasNext ( ) ; ) { SimpleChildNode childElement = ( SimpleChildNode ) it . next ( ) ; int visualID = SimplemapVisualIDRegistry . getNodeVisualID ( view , childElement ) ; if ( visualID == SimpleTopNodeEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } if ( visualID == SimpleLinkMappingEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } } return result ; } public static List < SimplemapNodeDescriptor > getSimpleTopNode_1001SemanticChildren ( View view ) { if ( ! view . isSetElement ( ) ) { return Collections . emptyList ( ) ; } SimpleTopNode modelElement = ( SimpleTopNode ) view . getElement ( ) ; LinkedList < SimplemapNodeDescriptor > result = new LinkedList < SimplemapNodeDescriptor > ( ) ; for ( Iterator < ? > it = modelElement . getChildren ( ) . iterator ( ) ; it . hasNext ( ) ; ) { SimpleChildNode childElement = ( SimpleChildNode ) it . next ( ) ; int visualID = SimplemapVisualIDRegistry . getNodeVisualID ( view , childElement ) ; if ( visualID == SimpleLabelNodeEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } if ( visualID == SimpleCompartmentEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } if ( visualID == SimpleChildReferenceEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } if ( visualID == SimpleSubNodeEditPart . VISUAL_ID ) { result . add ( new SimplemapNodeDescriptor ( childElement , visualID ) ) ; continue ; } } return result ; } public static List < SimplemapNodeDescriptor > getSimpleCompartment_2002SemanticChildren ( View view ) { if ( ! view . isSetElement ( ) ) { return Collections . emptyList ( ) ; } SimpleCompartment modelElement = ( SimpleCompartment ) view . getElement ( ) ; LinkedList < SimplemapNodeDescriptor > result = new LinkedList < SimplemapNodeDescriptor > ( ) ; for ( Iterator < ? > it = modelElement . getChildren (", "gt": ") . iterator ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 2897, "input": "<s> package org . eclipse . ui . tests . api ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; public class MockSelectionProvider implements ISelectionProvider { private List listeners = new ArrayList ( 3 ) ; public void fireSelection ( ) { fireSelection ( new SelectionChangedEvent ( this", "gt": ", StructuredSelection . EMPTY ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1981, "input": "<s> public class T6481655 { public static < T > T getT ( T t ) { return t ; } public static void main ( String ... s ) { T6481655 . < String", "gt": "> getT ( \"\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 2902, "input": "<s> package de . uos . igf . db3d . dbms . api ; public final class FactoryException extends DBMSException { public FactoryException ( ) { super ( ) ; } public FactoryException ( String message ) { super ( message ) ; } public FactoryException ( String message , Throwable cause ) { super ( message , cause ) ; } public FactoryException ( Throwable cause ) {", "gt": "super ( cause ) ;", "prediction": "\n", "label": 1}
{"id": 3609, "input": "<s> package enumswitch1 ; enum E1 { a , b , c , d , e } class EnumSwitch1 { void f ( E1 e1 ) { switch ( e1 ) { case a :", "gt": "case d : default : break ;", "prediction": ";\n", "label": 0}
{"id": 2923, "input": "<s> package org . apache . lucene . index ; import java . util . Iterator ; import java . util . Collection ; import java . io . File ; import java . io . IOException ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . _TestUtil ; public class TestSnapshotDeletionPolicy extends LuceneTestCase { public static final String INDEX_PATH = \"test.snapshots\" ; public void testSnapshotDeletionPolicy ( ) throws Exception { File dir = new File ( System . getProperty ( \"tempDir\" ) , INDEX_PATH ) ; try { _TestUtil . rmDir ( dir ) ; Directory fsDir = FSDirectory . open ( dir ) ; runTest ( fsDir ) ; fsDir . close ( ) ; } finally { _TestUtil . rmDir ( dir ) ; } MockRAMDirectory dir2 = new MockRAMDirectory ( ) ; runTest ( dir2 ) ; dir2 . close ( ) ; } public void testReuseAcrossWriters ( ) throws Exception { Directory dir = new MockRAMDirectory ( ) ; SnapshotDeletionPolicy dp = new SnapshotDeletionPolicy ( new KeepOnlyLastCommitDeletionPolicy ( ) ) ; IndexWriter writer = new IndexWriter ( dir , true , new StandardAnalyzer ( ) , dp ) ; writer . setMaxBufferedDocs ( 2 ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"content\" , \"aaa\" , Field . Store . YES , Field . Index . ANALYZED , Field . TermVector . WITH_POSITIONS_OFFSETS ) ) ; for ( int i = 0 ; i < 7 ; i ++ ) writer . addDocument ( doc ) ; IndexCommit cp = ( IndexCommit ) dp . snapshot ( ) ; copyFiles ( dir , cp ) ; writer . close ( ) ; copyFiles ( dir , cp ) ; writer = new IndexWriter ( dir , true , new StandardAnalyzer ( ) , dp ) ; copyFiles ( dir , cp ) ; for ( int i = 0 ; i < 7 ; i ++ ) writer . addDocument ( doc ) ; copyFiles ( dir , cp ) ; writer . close ( ) ; copyFiles ( dir , cp ) ; dp . release ( ) ; writer = new IndexWriter ( dir , true , new StandardAnalyzer ( ) , dp ) ; writer . close ( ) ; try { copyFiles ( dir , cp ) ; fail ( \"did not hit expected IOException\" ) ; } catch ( IOException ioe ) { } dir . close ( ) ; } private void runTest ( Directory dir ) throws Exception { final long stopTime = System . currentTimeMillis ( ) + 1000 ; SnapshotDeletionPolicy dp = new SnapshotDeletionPolicy (", "gt": "new KeepOnlyLastCommitDeletionPolicy ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8483, "input": "<s> package Liza ; import org . bukkit . entity . Painting ;", "gt": "public interface LizaPainting extends Painting", "prediction": "}\n", "label": 0}
{"id": 2938, "input": "<s> package org . eclipse . ui . forms . internal . widgets . formtextkit ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . IResourceManager . RegisterOptions ; public final class FormTextAdapterResource implements IResource { public String getCharset ( ) { return \"UTF-8\" ; }", "gt": "public ClassLoader getLoader ( )", "prediction": "}\n", "label": 1}
{"id": 4237, "input": "<s> package org . ofbiz . accounting . thirdparty . orbital ; import java . math . BigDecimal ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . accounting . payment . PaymentGatewayServices ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import com . paymentech . orbital . sdk . configurator . Configurator ; import com . paymentech . orbital . sdk . interfaces . RequestIF ; import com . paymentech . orbital . sdk . interfaces . ResponseIF ; import com . paymentech . orbital . sdk . interfaces . TransactionProcessorIF ; import com . paymentech . orbital . sdk . request . FieldNotFoundException ; import com . paymentech . orbital . sdk . request . Request ; import com . paymentech . orbital . sdk . transactionProcessor . TransactionException ; import com . paymentech . orbital . sdk . transactionProcessor . TransactionProcessor ; import com . paymentech . orbital . sdk . util . exceptions . InitializationException ; public class OrbitalPaymentServices { public static String module = OrbitalPaymentServices . class . getName ( ) ; private static int decimals = UtilNumber . getBigDecimalScale ( \"invoice.decimals\" ) ; private static int rounding = UtilNumber . getBigDecimalRoundingMode ( \"invoice.rounding\" ) ; public final static String resource = \"AccountingUiLabels\" ; public static String APPROVED = \"Approved\" ; public static String DECLINED = \"Declined\" ; public static String ERROR = \"Error\" ; public static final String BIN_VALUE = \"000002\" ; public static TransactionProcessorIF tp = null ; public static ResponseIF response = null ; public static RequestIF request = null ; public static Map < String , Object > ccAuth ( DispatchContext ctx , Map < String , Object > context ) { Delegator delegator = ctx . getDelegator ( ) ; Map < String , Object > results = ServiceUtil . returnSuccess ( ) ; Map < String , Object > props = buildOrbitalProperties ( context , delegator ) ; props . put ( \"transType\" , \"AUTH_ONLY\" ) ; try { request = new Request ( RequestIF . NEW_ORDER_TRANSACTION ) ; } catch ( InitializationException e ) { Debug . logError ( \"Error in request initialization\" , module ) ; e . printStackTrace ( ) ; } buildAuthOrAuthCaptureTransaction ( context , delegator , props , request , results ) ; Map < String , Object > validateResults = validateRequest ( context , props , request ) ; String respMsg = ( String ) validateResults . get ( ModelService . RESPONSE_MESSAGE ) ; if ( ModelService . RESPOND_ERROR . equals ( respMsg ) ) { results . put ( ModelService . ERROR_MESSAGE , \"Validation Failed - invalid values\" ) ; return results ; } initializeTransactionProcessor ( ) ; Map < String , Object > processCardResponseContext = processCard ( request ) ; printTransResult ( ( ResponseIF", "gt": ") processCardResponseContext . get ( \"processCardResponse\" ) ) ;", "prediction": ")\n", "label": 0}
{"id": 2966, "input": "<s> package com . yahoo . ycsb . measurements . exporter ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . codehaus . jackson . JsonFactory ; import org . codehaus . jackson . JsonGenerator ; import org . codehaus . jackson . impl . DefaultPrettyPrinter ; public class JSONMeasurementsExporter implements MeasurementsExporter { private JsonFactory factory = new JsonFactory ( ) ; private JsonGenerator g ; public JSONMeasurementsExporter ( OutputStream os ) throws IOException { BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( os ) ) ; g = factory . createJsonGenerator ( bw ) ; g . setPrettyPrinter ( new DefaultPrettyPrinter ( ) ) ; } public void write ( String metric , String measurement , int i ) throws IOException { g . writeStartObject ( ) ; g . writeStringField ( \"metric\" , metric ) ; g . writeStringField ( \"measurement\" , measurement ) ; g . writeNumberField ( \"value\" , i ) ; g . writeEndObject ( ) ; } public void write ( String metric , String measurement , double d ) throws IOException { g . writeStartObject ( ) ; g . writeStringField ( \"metric\" , metric ) ; g . writeStringField (", "gt": "\"measurement\" , measurement ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6525, "input": "<s> package com . mapr . stats ; import java . util . Random ; class BetaBayesFactory extends BanditFactory { @ Override public BayesianBandit createBandit ( int bandits , Random gen ) { return new BetaBayesModel", "gt": "( bandits , gen ) ;", "prediction": ";\n", "label": 0}
{"id": 2975, "input": "<s> package org . eclipse . ui . tests . propertysheet ; import org . eclipse . core . runtime . IAdapterFactory ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . views . properties . IPropertySheetPage ; import org . eclipse . ui . views . properties . PropertySheetPage ; public class TestPropertySheetPage extends PropertySheetPage implements IPropertySheetPage , IAdapterFactory { private ISelection fSelection ; private IWorkbenchPart fPart ; public Object getAdapter ( Object adaptableObject , Class adapterType ) { fSelection = null ; fPart = null ; return this ; } public Class [ ] getAdapterList ( ) { return new Class [ ] { IPropertySheetPage . class } ; } public void", "gt": "selectionChanged ( IWorkbenchPart part , ISelection selection )", "prediction": "( )\n", "label": 1}
{"id": 8170, "input": "<s> package org . ofbiz . webapp . taglib ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . servlet . jsp . JspTagException ; import javax . servlet . jsp . JspWriter ; import javax . servlet . jsp . PageContext ; import javax . servlet . jsp . tagext . BodyContent ; import javax . servlet . jsp . tagext . BodyTagSupport ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilGenerics ; @ SuppressWarnings ( \"serial\" ) public class IteratorTag extends BodyTagSupport { public static final String module = IteratorTag . class . getName ( ) ; protected Iterator < ? extends Object > iterator = null ; protected String name = null ; protected String property = null ; protected Object element = null ; protected Class < ? > type = null ; protected int limit = 0 ; protected int offset = 0 ; protected boolean expandMap = false ; public void setName ( String name ) { this . name = name ; } public void setProperty ( String property ) { this . property = property ; } public void setType ( String type ) throws ClassNotFoundException { this . type = ObjectType . loadClass ( type ) ; } public void setLimit ( int limit ) { this . limit = limit ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setExpandMap ( String expMap ) { expandMap = \"true\" . equals ( expMap ) ; } public void setIterator ( Iterator < ? extends Object > iterator ) { this . iterator = iterator ; } public String getName ( ) { return name ; } public String getProperty ( ) { return property ; } public Object getElement ( ) { return element ; } public Iterator < ? extends Object > getIterator ( ) { return this . iterator ; } public String getType ( ) { return type . getName ( ) ; } public int getLimit ( ) { return this . limit ; } public int getOffset ( ) { return this . offset ; } public String getExpandMap ( ) { return expandMap ? \"true\" : \"false\" ; } @ Override public int doStartTag ( ) throws JspTagException { Debug . logVerbose ( \"Starting Iterator Tag...\" , module ) ; if ( ! defineIterator ( ) ) return SKIP_BODY ; Debug . logVerbose ( \"We now have an iterator.\" , module ) ; if ( defineElement ( ) ) return EVAL_BODY_AGAIN ; else return SKIP_BODY ; } @ Override public int doAfterBody ( ) { if ( defineElement ( ) ) { return EVAL_BODY_AGAIN ; } else { return SKIP_BODY ; } } @ Override public int doEndTag ( ) { try {", "gt": "BodyContent body = getBodyContent ( ) ;", "prediction": "}\n", "label": 0}
{"id": 2977, "input": "<s> package knowevo . springbox . gephibox ; import java . awt . Color ; import java . io . * ; import java . sql . * ; import java . util . * ; import knowevo . springbox . DBBuilder ; import knowevo . springbox . ScoreMachine ; import org . gephi . data . attributes . api . AttributeController ; import org . gephi . data . attributes . api . AttributeModel ; import org . gephi . graph . api . * ; import org . gephi . io . exporter . api . * ; import org . gephi . io . exporter . preview . * ; import org . gephi . io . importer . api . Container ; import org . gephi . io . importer . api . EdgeDefault ; import org . gephi . io . importer . api . ImportController ; import org . gephi . io . importer . plugin . database . EdgeListDatabaseImpl ; import org . gephi . io . importer . plugin . database . ImporterEdgeList ; import org . gephi . io . processor . plugin . DefaultProcessor ; import org . gephi . layout . plugin . force . StepDisplacement ; import org . gephi . layout . plugin . force . yifanHu . YifanHuLayout ; import org . gephi . preview . api . PreviewController ; import org . gephi . preview . api . PreviewModel ; import org . gephi . preview . api . PreviewProperty ; import org . gephi . preview . types . EdgeColor ; import org . gephi . preview . types . DependantOriginalColor ; import org . gephi . project . api . ProjectController ; import org . gephi . project . api . Workspace ; import org . openide . util . Lookup ; public class GephiDBBuilder extends DBBuilder { private ProjectController pc ; private Workspace workspace ; private GraphModel graphModel ; private AttributeModel attributeModel ; private Graph gephiGraph ; private SVGExporter exporter ; private ExportController ec ; private PreviewModel previewModel ; public static void getGraphFor ( ScoreMachine sm , String name , int max_depth , String out , boolean peers_only ) throws SQLException { GephiDBBuilder dbb = new GephiDBBuilder ( sm ) ; dbb . buildGraph ( name , max_depth , peers_only ) ; dbb . convertGraph ( ) ; dbb . converge ( 100 ) ; dbb . export ( out ) ; } private GephiDBBuilder ( ScoreMachine sm ) { super ( sm ) ; try { pc = Lookup . getDefault ( ) . lookup ( ProjectController . class ) ; pc . newProject ( ) ; workspace = pc . getCurrentWorkspace ( ) ; graphModel = Lookup . getDefault ( ) . lookup ( GraphController . class ) . getModel ( ) ; attributeModel = Lookup . getDefault ( ) . lookup ( AttributeController . class ) . getModel ( ) ; gephiGraph = graphModel . getDirectedGraph ( ) ; ec = Lookup . getDefault ( ) . lookup ( ExportController . class ) ; exporter = ( SVGExporter ) ec . getExporter ( \"svg\" ) ; exporter . setWorkspace ( workspace ) ; previewModel = Lookup . getDefault ( ) . lookup ( PreviewController . class ) . getModel ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void export ( String name ) { try { ec . exportFile ( new File ( name ) , exporter ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } public void converge ( int times ) { YifanHuLayout layout = new YifanHuLayout ( null ,", "gt": "new StepDisplacement ( 1f ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 560, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Definitions extends ExportAttribute { boolean isAll ( ) ; void setAll ( boolean value ) ; boolean isNone ( ) ; void", "gt": "setNone ( boolean value ) ;", "prediction": "}\n", "label": 0}
{"id": 2988, "input": "<s> package br . org . archimedes . io . xml ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.io.xml.messages\" ; public static String XMLExporter_NoExporter ; public static String XMLFilePickerPage_BrowseButtonText ; public static String XMLFilePickerPage_BrowseButtonTooltip ; public static String XMLFilePickerPage_ChooseExportFile ;", "gt": "public static String XMLFilePickerPage_DialogText ;", "prediction": "}\n", "label": 1}
{"id": 4225, "input": "<s> package com . gisgraphy . client . language ; import com . gisgraphy . client . language . Iso639Language ; public class IsoLanguageObjectMother { public static Iso639Language frenchIsoLanguage ( ) { return Iso639Language . isoLanguage ( \"Fran\u00e7ais\" ) . withAlpha3 ( \"fra\" ) . withAlpha2Code ( \"fr\" ) ; } public static Iso639Language englishIsoLanguage ( ) { return Iso639Language . isoLanguage ( \"English\" ) . withAlpha3 ( \"eng\" ) . withAlpha2Code ( \"en\" ) ; } public static Iso639Language spanishIsoLanguage ( ) { return Iso639Language . isoLanguage ( \"Spanish\" ) . withAlpha3 ( \"spa\" ) . withAlpha2Code ( \"es\" ) ; }", "gt": "public static Iso639Language hawaiianIsoLanguage ( )", "prediction": "}\n", "label": 0}
{"id": 2992, "input": "<s> package org . eclipse . rap . demo . wizard ; import org . eclipse . jface . wizard . IWizardPage ; import org . eclipse . jface . wizard . WizardPage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . * ; class ComplaintsPage extends WizardPage { private Button yes ; private Button no ; public ComplaintsPage ( ) { super ( \"Complaints\" ) ; setTitle ( \"Complaints\" ) ; } public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NONE ) ; composite . setLayout ( new GridLayout ( 1 , true ) ) ; new Label ( composite , SWT . LEFT ) . setText ( \"Do you have complaints?\" ) ; Composite yesNo = new Composite ( composite , SWT . NONE ) ; yesNo . setLayout", "gt": "( new FillLayout ( SWT . VERTICAL ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3612, "input": "<s> import jns . Simulator ; import jns . element . * ; import jns . util . * ; public class Test_Structure { public static void main ( String args [ ] ) { Simulator sim = Simulator . getInstance ( ) ; Node src = new Node ( \"Source node\" ) ; Node router = new Node ( \"Router\" ) ; Node dest = new Node ( \"Destination node\" ) ; sim . attach ( src ) ; sim . attach ( router ) ; sim . attach ( dest ) ; Interface src_iface = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 10 ) ) ; src . attach ( src_iface ) ; Interface dest_iface = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 20 ) ) ; dest . attach ( dest_iface ) ; sim . attach ( src_iface ) ; sim . attach ( dest_iface ) ; Interface route_iface192 = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 1 ) ) ; Interface route_iface128 = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 1 ) ) ; router . attach ( route_iface192 ) ; router . attach ( route_iface128 ) ;", "gt": "sim . attach ( route_iface192 ) ;", "prediction": "}\n", "label": 0}
{"id": 2996, "input": "<s> package org . agoncal . book . javaee7 . chapter21 . ex23 ; import javax . jws . WebService ; @ WebService public class CardValidator23 { public boolean validate ( CreditCard23 creditCard ) { String lastDigit = creditCard . getNumber ( ) . substring ( creditCard . getNumber ( ) . length ( ) - 1 , creditCard . getNumber ( ) . length ( ) ) ; return Integer . parseInt (", "gt": "lastDigit ) % 2 != 0 ;", "prediction": ") ;\n", "label": 1}
{"id": 7452, "input": "<s> package Liza ; import org . bukkit . entity . Silverfish ;", "gt": "public interface LizaSilverfish extends Silverfish", "prediction": "}\n", "label": 0}
{"id": 3003, "input": "<s> package org . eclipse . ui . internal . testing ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . internal . PartSite ; import org . eclipse . ui . testing . IWorkbenchPartTestable ; public class WorkbenchPartTestable implements IWorkbenchPartTestable { private Composite composite ;", "gt": "public WorkbenchPartTestable ( PartSite partSite )", "prediction": "}\n", "label": 1}
{"id": 5287, "input": "<s> package com . matburt . mobileorg . test . util ; public class OrgTestFiles { public static class SimpleOrgFiles { public static final String [ ] tags = { \"Home\" , \"Computer\" , \"Errands\" } ; public static final String [ ] todos = { \"TODO\" , \"DONE\" } ; public static final String [ ] files = { \"GTD.org\" } ; public static final String [ ] priorities = { \"A\" , \"B\" , \"C\" } ; public static final String indexFile = \"#+READONLY\\n\" + \"#+TODO: TODO | DONE\\n\" + \"#+TAGS: { Home Computer Errands } \\n\" + \"#+ALLPRIORITIES: A B C\\n\" + \"* [[file:GTD.org][GTD.org]]\\n\" ; public static final String checksumsFile = \"25aade750f6b60aa1df155fcbb357191  index.org\\n\" + \"42055316a0808ad634d7981653cf4400faddb91f  GTD.org\" ; public static final String orgFileTopHeading = \"top heading\" ; public static final String orgFileChildHeading = \"child heading\" ; public static final String orgFile = \"* \" + orgFileTopHeading + \"\\n** \" + orgFileChildHeading ; } public static final String indexFileWithEmptyDrawers = \"#+READONLY\\n\" + \"#+TODO:\\n\" + \"#+TAGS:\\n\" + \"#+ALLPRIORITIES:\\n\" + \"* [[file:GTD.org][GTD.org]]\\n\" ; public static class ComplexOrgFiles { public static final String indexFile = \"#+READONLY\\n\" + \"#+TODO: TODO NEXT PLAN RSCH GOAL DEFERRED WAIT | SOMEDAY CANC DONE\\n\" + \"#+TAGS: { Home Computer Online Phone Errands } { Agenda Read Listen Watch Code }\\n\" + \"#+ALLPRIORITIES: A B C\\n\" + \"* [[file:agendas.org][Agenda Views]]\\n\" ; public static final String checksumsFile = \"25aade750f6b60aa1df155fcbb357191  index.org\\n\" + \"42055316a0808ad634d7981653cf4400faddb91f  GTD.org\\n\" + \"c864f7e1d6df18434738276a45c896cb  agendas.org\" ; public static final String orgFile = \"* new\\n** test\" ; public static final String agendasFile = \"* new 1\\n** test2\" ; } public static class OrgIndexWithFileDirectorySpaces { public static final String fileAlias = \"Mixed Todo.org\" ; public static final String filename = \"Mixed Activities/Mixed Todo.org\" ; public static final String filenameWithoutAlias = \"Mixed Activities/Mixed Todo.org\" ; public static final String indexFile = \"#+READONLY\\n\" + \"#+TODO: TODO | DONE\\n\" + \"#+TAGS: { Home Computer Errands } \\n\" + \"#+ALLPRIORITIES: A B C\\n\" + \"* [[file:\" + filename + \"][\" + fileAlias + \"]]\\n\" + \"* [[file:\" + filenameWithoutAlias", "gt": "+ \"][\" + filenameWithoutAlias + \"]]\" ;", "prediction": ") ;\n", "label": 0}
{"id": 3019, "input": "<s> package monbulk . MethodBuilder . client . view ; import java . util . ArrayList ; import monbulk . shared . Architecture . IPresenter ; import monbulk . shared . Architecture . IView ; import monbulk . shared . Events . DragEvent ; import monbulk . shared . Model . IPojo ; import monbulk . shared . Model . pojo . pojoMethod ; import com . google . gwt . core . client . GWT ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . HasText ; import com . google . gwt . user . client . ui . HorizontalPanel ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . PushButton ; import com . google . gwt . user . client . ui . Widget ; public class MethodMenuItem extends Composite implements HasText , IView { private static MethodMenuItemUiBinder uiBinder = GWT . create ( MethodMenuItemUiBinder . class ) ; interface MethodMenuItemUiBinder extends UiBinder < Widget , MethodMenuItem > { } @ UiField Label lblMenuMethodName ; @ UiField PushButton btnMenuEditMethod ; @ UiField PushButton btnMenuCloneMethod ; @ UiField HorizontalPanel _hlContainer ; private String _MethodID ; private String _MethodName ; private IPresenter _presenter ; private int _Index ; private pojoMethod _DataObject ; private final String ActiveStyleName = \"hlActiveMenuContainer\" ; private final String PassiveStyleName = \"hlPassiveMenuContainer\" ; public MethodMenuItem ( pojoMethod tmpMethod , int Index ) { initWidget ( uiBinder . createAndBindUi ( this ) ) ; try { this . _Index = Index ; this . _DataObject = tmpMethod ; this . setText ( this . _DataObject . getFieldVale ( pojoMethod . MethodNameField ) ) ; this . setID ( this . _DataObject . getMethodID ( ) ) ; } catch ( Exception ex ) { GWT . log ( \"Error Occurs @ MethodMenuItem.Construct\" + ex . getMessage ( ) ) ; } } @ UiHandler ( \"btnMenuEditMethod\" ) void onClick ( ClickEvent e ) { this . _presenter . FireDragEvent ( new DragEvent ( this . _MethodName , \"EditMethod\" , this . _Index , ( IPojo ) this . _DataObject ) ) ; } @ UiHandler ( \"btnMenuCloneMethod\" ) void onClick2 ( ClickEvent e ) { this . _presenter . FireDragEvent ( new DragEvent ( this . _MethodName , \"CloneMethod\" , this . _Index , ( IPojo ) this . _DataObject ) ) ; } public void setText ( String text ) { if ( text != null ) { lblMenuMethodName . setText ( text ) ; this . _MethodName = text ; } else { lblMenuMethodName", "gt": ". setText ( \"Unknown\" ) ;", "prediction": ";\n", "label": 1}
{"id": 6595, "input": "<s> package com . sun . tools . doclets . formats . html ; import com . sun . tools . doclets . internal . toolkit . util . links . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class LinkFactoryImpl extends LinkFactory { private HtmlDocletWriter m_writer ; public LinkFactoryImpl ( HtmlDocletWriter writer ) { m_writer = writer ; } protected LinkOutput getOutputInstance ( ) { return new LinkOutputImpl ( ) ; } protected LinkOutput getClassLink ( LinkInfo linkInfo ) { LinkInfoImpl classLinkInfo = ( LinkInfoImpl ) linkInfo ; boolean noLabel = linkInfo . label == null || linkInfo . label . length ( ) == 0 ; ClassDoc classDoc = classLinkInfo . classDoc ; String title = ( classLinkInfo . where == null || classLinkInfo . where . length ( ) == 0 ) ? getClassToolTip ( classDoc , classLinkInfo . type != null && ! classDoc . qualifiedTypeName ( ) . equals ( classLinkInfo . type . qualifiedTypeName ( ) ) ) : \"\" ; StringBuffer label = new StringBuffer ( classLinkInfo . getClassLinkLabel ( m_writer . configuration ) ) ; classLinkInfo . displayLength += label . length ( ) ; Configuration configuration = ConfigurationImpl . getInstance ( ) ; LinkOutputImpl linkOutput = new LinkOutputImpl ( ) ; if ( classDoc . isIncluded ( ) ) { if ( configuration . isGeneratedDoc ( classDoc ) ) { String filename = pathString ( classLinkInfo ) ; if ( linkInfo . linkToSelf || ! ( linkInfo . classDoc . name ( ) + \".html\" ) . equals ( m_writer . filename ) ) { linkOutput . append ( m_writer . getHyperLinkString ( filename , classLinkInfo . where , label . toString ( ) , classLinkInfo . isStrong , classLinkInfo . styleName , title , classLinkInfo . target ) ) ; if ( noLabel && ! classLinkInfo . excludeTypeParameterLinks ) { linkOutput . append ( getTypeParameterLinks ( linkInfo ) . toString ( ) ) ; } return linkOutput ; } } } else { String crossLink = m_writer . getCrossClassLink ( classDoc . qualifiedName ( ) , classLinkInfo . where , label . toString ( ) , classLinkInfo . isStrong , classLinkInfo . styleName , true ) ; if ( crossLink != null ) { linkOutput . append ( crossLink ) ; if ( noLabel && ! classLinkInfo . excludeTypeParameterLinks ) { linkOutput . append ( getTypeParameterLinks ( linkInfo ) . toString ( ) ) ; } return linkOutput ; } } linkOutput . append ( label . toString ( ) ) ; if ( noLabel && ! classLinkInfo . excludeTypeParameterLinks ) { linkOutput . append ( getTypeParameterLinks ( linkInfo ) . toString ( ) ) ; } return linkOutput ; } protected LinkOutput getTypeParameterLink ( LinkInfo linkInfo , Type typeParam ) { LinkInfoImpl typeLinkInfo = new LinkInfoImpl ( linkInfo . getContext ( ) , typeParam ) ; typeLinkInfo . excludeTypeBounds = linkInfo . excludeTypeBounds ; typeLinkInfo . excludeTypeParameterLinks = linkInfo . excludeTypeParameterLinks ; typeLinkInfo . linkToSelf = linkInfo . linkToSelf ; LinkOutput output = getLinkOutput ( typeLinkInfo ) ; ( ( LinkInfoImpl ) linkInfo ) . displayLength += typeLinkInfo . displayLength ; return output ; } private String getClassToolTip ( ClassDoc classDoc , boolean isTypeLink ) { Configuration configuration = ConfigurationImpl . getInstance ( ) ; if ( isTypeLink ) { return configuration . getText ( \"doclet.Href_Type_Param_Title\" , classDoc . name ( ) ) ; } else if ( classDoc . isInterface ( ) ) { return configuration . getText ( \"doclet.Href_Interface_Title\" , Util . getPackageName ( classDoc . containingPackage ( ) ) ) ; } else if ( classDoc . isAnnotationType ( ) ) { return configuration . getText ( \"doclet.Href_Annotation_Title\" , Util . getPackageName ( classDoc . containingPackage ( ) ) ) ; } else if ( classDoc . isEnum ( ) ) { return configuration . getText ( \"doclet.Href_Enum_Title\" , Util . getPackageName ( classDoc . containingPackage ( ) ) ) ; } else { return configuration . getText ( \"doclet.Href_Class_Title\" , Util . getPackageName ( classDoc . containingPackage ( ) ) ) ; } } private String pathString ( LinkInfoImpl linkInfo ) { if ( linkInfo", "gt": ". context == LinkInfoImpl . PACKAGE_FRAME )", "prediction": ")\n", "label": 0}
{"id": 3039, "input": "<s> package org . jscsi . parser . logout ; import java . util . HashMap ; import java . util . Map ; public enum LogoutResponse { CONNECTION_CLOSED_SUCCESSFULLY ( ( byte ) 0 ) , CID_NOT_FOUND ( ( byte ) 1 ) , CONNECTION_RECOVERY_NOT_SUPPORTED ( ( byte ) 2 ) , CLEANUP_FAILED ( ( byte ) 3 ) ; private final byte value ; private static Map < Byte , LogoutResponse > mapping ; static { LogoutResponse . mapping = new HashMap < Byte , LogoutResponse > ( ) ; for ( LogoutResponse s : values ( ) ) { LogoutResponse . mapping . put ( s . value , s ) ; } } private LogoutResponse ( final byte newValue ) { value = newValue ; } public final byte value ( ) { return value ; } public static", "gt": "final LogoutResponse valueOf ( final byte value )", "prediction": "( )\n", "label": 1}
{"id": 1340, "input": "<s> package org . ofbiz . entity ; import java . io . PrintWriter ; import java . io . Serializable ; import java . math . BigDecimal ; import java . nio . ByteBuffer ; import java . sql . Blob ; import java . sql . SQLException ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . Observable ; import java . util . ResourceBundle ; import java . util . TreeSet ; import javolution . lang . Reusable ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . crypto . HashCrypt ; import org . ofbiz . base . util . Base64 ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . TimeDuration ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . LocalizedMap ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . jdbc . SqlJdbcUtil ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . model . ModelFieldType ; import org . ofbiz . entity . model . ModelViewEntity ; import org . ofbiz . entity . model . ModelViewEntity . ModelAlias ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class GenericEntity extends Observable implements Map < String , Object > , LocalizedMap < Object > , Serializable , Comparable < GenericEntity > , Cloneable , Reusable { public static final String module = GenericEntity . class . getName ( ) ; public static final GenericEntity NULL_ENTITY = new NullGenericEntity ( ) ; public static final NullField NULL_FIELD = new NullField ( ) ; protected String delegatorName = null ; protected transient Delegator internalDelegator = null ; protected Map < String , Object > fields = FastMap . newInstance ( ) ; protected String entityName = null ; protected transient ModelEntity modelEntity = null ; protected boolean modified = false ; protected boolean generateHashCode = true ; protected int cachedHashCode = 0 ; protected boolean mutable = true ; protected boolean isFromEntitySync = false ; protected GenericEntity ( ) { } public static GenericEntity createGenericEntity ( ModelEntity modelEntity ) { if ( modelEntity == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null modelEntity parameter\" ) ; } GenericEntity newEntity = new GenericEntity ( ) ; newEntity . init ( modelEntity ) ; return newEntity ; } public static GenericEntity createGenericEntity ( Delegator delegator , ModelEntity modelEntity , Map < String , ? extends Object > fields ) { if ( modelEntity == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null modelEntity parameter\" ) ; } GenericEntity newEntity = new GenericEntity ( ) ; newEntity . init ( delegator , modelEntity , fields ) ; return newEntity ; } public static GenericEntity createGenericEntity ( GenericEntity value ) { if ( value == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null value parameter\" ) ; } GenericEntity newEntity = new GenericEntity ( ) ; newEntity . init ( value ) ; return newEntity ; } protected void init ( ModelEntity modelEntity ) { if ( modelEntity == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null modelEntity parameter\" ) ; } this . modelEntity = modelEntity ; this . entityName = modelEntity . getEntityName ( ) ; if ( this . entityName == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null entityName in the modelEntity parameter\" ) ; } } protected void init ( Delegator delegator , ModelEntity modelEntity , Map < String , ? extends Object > fields ) { if ( modelEntity == null ) { throw new IllegalArgumentException ( \"Cannot create a GenericEntity with a null modelEntity parameter\" ) ; } this . modelEntity = modelEntity ; this .", "gt": "entityName = modelEntity . getEntityName ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 3047, "input": "<s> package org . eclipse . swt . graphics ; abstract class GCDelegate { abstract void setBackground ( Color color ) ; abstract Color getBackground ( ) ; abstract void setForeground ( Color color ) ; abstract Color getForeground ( ) ; abstract void setFont ( Font font ) ; abstract Font getFont ( ) ; abstract Font getDefaultFont ( ) ; abstract void setAlpha ( int alpha ) ; abstract int getAlpha ( ) ; abstract void setLineWidth ( int lineWidth ) ; abstract int getLineWidth ( ) ; abstract void setLineCap ( int lineCap ) ; abstract int getLineCap ( ) ; abstract void setLineJoin ( int lineJoin ) ; abstract int getLineJoin ( ) ; abstract Rectangle getClipping ( ) ; abstract Point stringExtent ( String string ) ; abstract Point textExtent ( String string , int wrapWidth ) ; abstract void drawPoint ( int x , int y ) ; abstract void drawLine ( int x1 , int y1 , int x2 , int y2 ) ; abstract void drawPolyline ( int [ ] pointArray , boolean close , boolean fill ) ; abstract void drawRectangle ( Rectangle bounds , boolean fill ) ; abstract void drawRoundRectangle ( Rectangle bounds , int", "gt": "arcWidth , int arcHeight , boolean fill ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2808, "input": "<s> package org . remast . swing . table ; import java . awt . Color ; import java . awt . Component ; import javax . swing . JTable ; import javax . swing . table . TableCellRenderer ; import javax . swing . table . TableModel ; @ SuppressWarnings ( \"serial\" ) public class JHighligthedTable extends JTable { public static final Color BEIGE = new Color ( 245 , 245 , 220 ) ; public JHighligthedTable ( TableModel tableModel ) { super ( tableModel ) ; } public Component prepareRenderer ( TableCellRenderer renderer , int row , int column ) { Component returnComp = super . prepareRenderer ( renderer , row , column ) ; if ( ! returnComp . getBackground ( ) . equals ( getSelectionBackground ( ) ) ) { Color backgroundColor = ( row % 2 == 0 ?", "gt": "BEIGE : Color . WHITE ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3068, "input": "<s> package co . diji . solr ; import org . apache . solr . common . SolrDocument ; import org . apache . solr . common . SolrDocumentList ; import org . apache . solr . common . util . NamedList ; import org . apache . solr . common . util . XML ; import java . io . Writer ; import java . io . IOException ; import java . util . * ; import org . apache . lucene . document . Fieldable ; import org . elasticsearch . common . joda . time . DateTime ; import org . elasticsearch . common . joda . time . format . DateTimeFormat ; import org . elasticsearch . common . joda . time . format . DateTimeFormatter ; final public class XMLWriter { public static final char [ ] XML_START1 = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" . toCharArray ( ) ; public static final char [ ] XML_START2_NOSCHEMA = ( \"<response>\\n\" ) . toCharArray ( ) ; private final Writer writer ; private final DateTimeFormatter dateFormat = DateTimeFormat . forPattern ( \"yyyy-MM-dd'T'HH:mm:ss'Z'\" ) ; public XMLWriter ( Writer writer ) { this . writer = writer ; } public void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , true ) ; } public void writeAttr ( String name , String val , boolean escape ) throws IOException { if ( val != null ) { writer . write ( ' ' ) ; writer . write ( name ) ; writer . write ( \"=\\\"\" ) ; if ( escape ) { XML . escapeAttributeValue ( val , writer ) ; } else { writer . write ( val ) ; } writer . write ( '\"' ) ; } } public void startTag ( String tag , Map < String , String > attributes , boolean closeTag , boolean escape ) throws IOException { writer . write ( '<' ) ; writer . write ( tag ) ; if ( ! attributes . isEmpty ( ) ) { for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { writeAttr ( entry . getKey ( ) , entry . getValue ( ) , escape ) ; } } if ( closeTag ) { writer . write ( \"/>\" ) ; } else { writer . write ( '>' ) ; } } public void writeCdataTag ( String tag , Map < String , String > attributes , String cdata , boolean escapeCdata , boolean escapeAttr ) throws IOException { writer . write ( '<' ) ; writer . write ( tag ) ; if ( ! attributes . isEmpty ( ) ) { for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { writeAttr ( entry . getKey ( ) , entry . getValue ( ) , escapeAttr ) ; } } writer . write ( '>' ) ; if ( cdata != null && cdata . length ( ) > 0 ) { if ( escapeCdata ) { XML . escapeCharData ( cdata , writer ) ; } else { writer . write ( cdata , 0 , cdata . length ( ) ) ; } } writer . write ( \"</\" ) ; writer . write ( tag ) ; writer . write ( '>' ) ; } public void startTag ( String tag , String name , boolean closeTag ) throws IOException { writer . write ( '<' ) ; writer .", "gt": "write ( tag ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 4418, "input": "<s> package com . toedter . gwt . demo . contacts . client ; import java . util . List ; import com . google . gwt . place . shared . PlaceController ; import com . google . web . bindery . event . shared . EventBus ; import com . toedter . gwt . demo . contacts . client . ui . IContactDetailsView ; import com . toedter . gwt . demo . contacts . client . ui . IContactListView ; import com . toedter . gwt . demo . contacts", "gt": ". client . ui . IToolBarView ;", "prediction": ";\n", "label": 0}
{"id": 3100, "input": "<s> package org . eclipse . ui . internal . layout ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; class CellLayoutUtil { private static Point zero = new Point ( 0 , 0 ) ; private static Point minimumShellSize ; private static CellData defaultData = new CellData ( ) ; static Point computeMinimumSize ( Composite toCompute ) { if ( toCompute instanceof Shell ) { if ( minimumShellSize == null ) { Shell testShell = new Shell ( ( Shell ) toCompute , SWT . DIALOG_TRIM | SWT . RESIZE ) ; testShell . setSize ( 0 , 0 ) ; minimumShellSize = testShell . getSize ( ) ; testShell", "gt": ". dispose ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4462, "input": "<s> package org . gk . engine . client . event . attrib ; import org . gk . engine . client . build . grid . XGridField ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class LabelAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof Field ) { ( ( Field ) com ) . setFieldLabel ( \"\" + value ) ; } else if ( com instanceof Button ) { ( ( Button ) com ) . setText ( ( String ) value ) ; } else if ( com . getData ( XGridField . COLUMN_CONFIG ) instanceof ColumnConfig ) { ColumnConfig cc = ( ColumnConfig ) com . getData ( XGridField . COLUMN_CONFIG ) ; cc . fireEvent ( Events . HeaderChange , new BaseEvent ( \"\" + value ) ) ; } } @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof Field ) { Field field = ( Field ) com ; value = field . getFieldLabel ( ) ; } else if ( com instanceof Button ) { Button", "gt": "btn = ( Button ) com ;", "prediction": ";\n", "label": 0}
{"id": 3128, "input": "<s> package org . restlet . ext . odata . internal . edm ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; public class ODataType extends NamedObject implements Comparable < ODataType > { private boolean abstractType ; private ODataType baseType ; private List < ComplexProperty > complexProperties ; private List < Property > properties ; private Schema schema ; public ODataType ( String name ) { super ( name ) ; } public int compareTo ( ODataType o ) { if ( o == null ) { return 1 ; } int result = 0 ; String s1 = getFullClassName ( ) ; String s2 = o . getFullClassName ( ) ; if ( s1 != null ) { result = s1 . compareTo ( s2 ) ; } else if ( s2 != null ) { result = - 1 * s2 . compareTo ( s1 ) ; } return result ; } public ODataType getBaseType ( ) { return baseType ; } public String getClassName ( ) { return getNormalizedName ( ) . substring ( 0 , 1 ) . toUpperCase ( ) + getNormalizedName ( ) . substring ( 1 ) ; } public List < ComplexProperty > getComplexProperties ( ) { if ( complexProperties == null ) { complexProperties = new ArrayList < ComplexProperty > ( ) ; } return complexProperties ; } public String getFullClassName ( ) { return getPackageName ( ) + \".\" + getClassName ( ) ; } public Set < String > getImportedJavaClasses ( ) { Set < String > result = new TreeSet < String > ( ) ; for ( Property property : getProperties ( ) ) { if ( property . getType ( ) != null ) { result . addAll ( property . getType ( ) . getImportedJavaClasses ( ) ) ; } } for (", "gt": "ComplexProperty property : getComplexProperties ( ) )", "prediction": ")\n", "label": 1}
{"id": 1336, "input": "<s> package org . jjflyboy . tjpeditor . project ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . Enumerator ; public enum ReportFormat implements Enumerator { CSV ( 0 , \"CSV\" , \"csv\" ) , HTML ( 1 , \"HTML\" , \"html\" ) , NIKU ( 2 , \"NIKU\" , \"niku\" ) ; public static final int CSV_VALUE = 0 ; public static final int HTML_VALUE = 1 ; public static final int NIKU_VALUE = 2 ; private static final ReportFormat [ ] VALUES_ARRAY = new ReportFormat [ ] { CSV , HTML , NIKU , } ; public static final List < ReportFormat > VALUES = Collections . unmodifiableList ( Arrays . asList ( VALUES_ARRAY ) ) ; public static ReportFormat get ( String literal ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { ReportFormat result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( literal ) ) { return result ; } } return null ; } public static ReportFormat getByName ( String name ) {", "gt": "for ( int i = 0 ;", "prediction": "\n", "label": 0}
{"id": 3139, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import org . restlet . test . ext . jaxrs . services . others . Person ; import org . restlet . test .", "gt": "ext . jaxrs . services . tests . PersonsTest ;", "prediction": ";\n", "label": 1}
{"id": 6220, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import java . util . Map ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class GroupsAndExpressionReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorderBottom ( Border . PEN_1_POINT ) ; headerStyle . setBackgroundColor ( Color . gray ) ; headerStyle . setTextColor ( Color . white ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; headerStyle . setTransparency ( Transparency . OPAQUE ) ; Style headerVariables = new Style ( ) ; headerVariables . setFont ( Font . ARIAL_SMALL_BOLD ) ; headerVariables . setBorderBottom ( Border . THIN ) ; headerVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; headerVariables . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitleStyle ( titleStyle ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( false ) . setGrandTotalLegend ( \"Grand Total\" ) . setGrandTotalLegendStyle ( headerVariables ) . setOddRowBackgroundStyle ( oddRowStyle ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 100 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( titleStyle ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaProductLine = ColumnBuilder . getNew ( ) . setColumnProperty ( \"productLine\" , String . class . getName ( ) ) . setTitle ( \"Product Line\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"Item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . setStyle ( importeStyle ) . setHeaderStyle ( headerStyle", "gt": ") . build ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3143, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . ToolTip ; public class ToolTipTab extends ExampleTab { private ToolTip toolTip ; private boolean toolTipAutoHide ; private String toolTipText ; private String toolTipMessage ; private Point toolTipLocation ; private boolean toolTipSelectionListener ; private final SelectionListener selectionListener ; public ToolTipTab ( ) { super ( \"ToolTip\" ) ; toolTipText = \"\" ; toolTipMessage = \"\" ; selectionListener = new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { ToolTipTab . this . log ( \"\" + event ) ; } } ; } @ Override protected void createStyleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 1 , false ) ) ; createStyleButton ( \"BALLOON\" , SWT . BALLOON ) ; createStyleButton ( \"ICON_ERROR\" , SWT . ICON_ERROR ) ; createStyleButton ( \"ICON_INFORMATION\" , SWT . ICON_INFORMATION ) ; createStyleButton ( \"ICON_WARNING\" , SWT . ICON_WARNING ) ; createAutoHideButton ( ) ; createTextInput ( ) ; createMessageInput ( ) ; createLocationInput ( ) ; createSelectionListenerButton ( ) ; } @ Override protected void createExampleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 1 , false ) ) ; Button button = new Button ( parent , SWT . PUSH ) ; button . setText ( \"Show ToolTip\" ) ; button . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { if ( toolTip != null ) { toolTip . dispose ( ) ; } toolTip = new ToolTip ( parent . getShell ( ) , getStyle ( ) ) ; toolTip . setVisible ( true ) ; toolTip . setAutoHide ( toolTipAutoHide ) ; toolTip . setText ( toolTipText ) ; toolTip . setMessage ( toolTipMessage ) ; if ( toolTipLocation != null ) { toolTip . setLocation ( toolTipLocation ) ; } updateSelectionListener ( ) ; } } ) ; } private void createTextInput ( ) { Composite group = new Composite ( styleComp , SWT . NONE ) ; group . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; group . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( group , SWT . NONE ) . setText ( \"Text\" ) ; Text text = new Text ( group , SWT . BORDER ) ; text . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; text . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent event ) { Text text = ( Text ) event . widget ; toolTipText = text . getText ( ) ; } } ) ; } private void createMessageInput ( ) { Composite group = new Composite ( styleComp , SWT . NONE ) ; group . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; group . setLayout ( new GridLayout ( 2 , false ) ) ; Label label = new Label ( group , SWT . NONE ) ; label . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , false , false ) ) ; label . setText ( \"Message\" ) ; Text text = new Text ( group , SWT . BORDER | SWT . MULTI ) ; GridData gridData = new GridData ( SWT . FILL , SWT . FILL , true , true ) ; gridData . heightHint = 150 ; text . setLayoutData ( gridData ) ; text . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent event ) { Text text = ( Text ) event . widget ; toolTipMessage = text . getText ( ) ; } } ) ; } private void createLocationInput ( ) { Composite group = new Composite ( styleComp , SWT . NONE ) ; group . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; group . setLayout ( new GridLayout ( 4 , false ) ) ; new Label ( group , SWT . NONE ) . setText ( \"Location X\" ) ; final Text textX = new Text ( group , SWT . BORDER ) ; new Label ( group , SWT .", "gt": "NONE ) . setText ( \"Y\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7401, "input": "<s> package com . sun", "gt": ". mirror . declaration ;", "prediction": ";\n", "label": 0}
{"id": 3157, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . core . exceptions . ArchException ; public class RetrieveByKeyCmd extends TransactionCommand { private static final long serialVersionUID = 1L ; private final Comparable < ? > key ; private final String fieldName ; private final String namespace ; private final String forClass ; private RetrieveByKeyCmd ( ) { super ( - 1 , - 1 , - 1 ) ; this . key = null ; this . fieldName = null ; this . namespace = null ; this . forClass = null ; } public RetrieveByKeyCmd ( int storeId , String namespace , int cid , int tid , Class < ? > forClass , final Comparable < ? > key , final String fieldName ) { super ( storeId , cid , tid ) ; this . key = key ; this . fieldName = fieldName ; this . namespace = namespace ; this . forClass = forClass . getCanonicalName ( ) ; } public String getFieldName ( ) { return fieldName ; } public Comparable < ? > getKey ( ) { return key ; } public String getNamespace ( ) { return namespace ; } public Class < ? > getForClass ( ) { try { return Class .", "gt": "forName ( forClass ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1928, "input": "<s> package org . gk . engine . client . build . menu ; import java . util . Iterator ; import java . util . List ; import org . gk . engine . client . gen . UIGen ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . menu . Menu ; import com . extjs . gxt . ui . client . widget . menu . MenuItem ; import com . google . gwt . xml . client . Node ; public class XMenuItem extends XItem { protected String text ; protected String icon ; public XMenuItem ( Node node , List widgets ) { super ( node , widgets ) ; text = super . getAttribute ( \"text\" , \"\" ) ; icon = super . getAttribute (", "gt": "\"icon\" , \"\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3159, "input": "<s> package org . restlet . ext . jaxrs ; import java . util . Collection ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Component ; import org . restlet . Context ; import org . restlet . Restlet ; import org . restlet . security . Authenticator ; public class JaxRsApplication extends org . restlet . Application { private volatile Authenticator authenticator ; private volatile JaxRsRestlet jaxRsRestlet ; public JaxRsApplication ( ) { this ( ( Context ) null ) ; } public JaxRsApplication ( Context context ) { super ( context ) ; this . jaxRsRestlet = new JaxRsRestlet ( context , getMetadataService ( ) ) ; } public JaxRsApplication ( javax . ws . rs . core . Application appConfig ) throws IllegalArgumentException { add ( appConfig ) ; } public boolean add ( Application appConfig ) throws IllegalArgumentException { if ( appConfig == null ) { throw new IllegalArgumentException ( \"The ApplicationConfig must not be null\" ) ; } final JaxRsRestlet jaxRsRestlet = this . jaxRsRestlet ; final Set < Class < ? > > classes = appConfig . getClasses ( ) ; final Set < Object > singletons = appConfig . getSingletons ( ) ; boolean everythingFine = true ; if ( singletons != null ) { for ( final Object singleton : singletons ) { if ( singleton != null && ! classes . contains ( singleton . getClass ( ) ) ) { everythingFine &= jaxRsRestlet . addSingleton ( singleton ) ; } } } if ( classes != null ) { for ( final Class < ? > clazz : classes ) { everythingFine &= jaxRsRestlet . addClass ( clazz ) ; } } return everythingFine ; } @ Override public Restlet createInboundRoot ( ) { Restlet", "gt": "restlet = this . jaxRsRestlet ;", "prediction": "\n", "label": 1}
{"id": 4350, "input": "<s> package org . gk . ui . client . com . form ; import org . gk . ui . client . com . i18n . Msg ; import com . extjs . gxt . ui . client . data . BaseModelData ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . store . StoreEvent ; import com . extjs . gxt . ui . client . util . DateWrapper ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; public class gkTimeField extends ComboBox { private int period = 30 ; public gkTimeField ( ) { setTriggerAction ( ComboBox . TriggerAction . ALL ) ; setValueField ( \"value\" ) ; store = genListStore ( period ) ; doQuery ( \"\" , false ) ; addListener ( Events . Select , new Listener ( ) { @ Override public void handleEvent ( BaseEvent be ) { collapse ( ) ; } } ) ; setLazyRender ( false ) ; } public void set15MinPeriod ( ) { period = 15 ; setStore ( genListStore ( period ) ) ; } public String getTimeValue ( ) { String timeValue = \"\" ; if ( ! \"\" . equals ( getRawValue ( ) ) ) { timeValue = getRawValue ( ) . replaceAll ( \":\" , \"\" ) ; } else { timeValue = getValue ( ) == null ? \"\" : getValue ( ) . get ( \"value\" ) . toString ( ) ; } return timeValue ; } public void setTimeValue ( String timeValue ) { if ( ! timeValue . equals ( \"\" ) ) { ModelData m = new BaseModelData ( ) ; m . set ( \"text\" , timeValue . substring ( 0 , 2 ) + \":\" + timeValue . substring ( 2 ) ) ; m . set ( \"value\" , timeValue ) ; setValue ( m ) ; } } private ListStore genListStore ( int period ) { ModelData m = new BaseModelData ( ) ; ListStore timeDatas = new ListStore < ModelData > ( ) ; String timeFormat ; String timeValue ; for ( int i = 0 ; i < 24 ; i ++ ) { for ( int j = 0 ; j < 59 ; j += period ) { timeFormat = format ( i ) + \":\" + format ( j ) ; timeValue = format ( i ) + format ( j ) ; m . set ( \"text\" , timeFormat ) ; m . set ( \"value\" , timeValue ) ; timeDatas . add ( m ) ; m = new BaseModelData ( ) ; } } return timeDatas ; } private String format ( int i ) { String rtn ; if ( i < 10 ) { rtn = \"0\" + String . valueOf ( i ) ; } else { rtn = String . valueOf ( i ) ; } return rtn ; } @ Override protected void onLoad ( StoreEvent se ) { expand ( ) ; selectByValue ( getRawValue ( ) ) ; } @ Override protected boolean selectByValue ( String value ) { ModelData r = findModel ( getDisplayField ( ) , value ) ; if ( r != null ) { select ( r ) ; return false ; } else { if ( \"\" . equals ( value ) ) { DateWrapper wrap = new DateWrapper ( ) ; int startMinute = wrap . getMinutes ( ) - wrap . getMinutes ( ) % period ; value = format ( wrap . getHours ( ) ) + \":\" + format ( startMinute ) ; } for ( int i = 0 ; i < store . getCount ( ) ; i ++ ) { ModelData m = store . getAt ( i ) ; Object obj = m . get ( getDisplayField ( ) ) ; if ( obj . toString ( ) . compareTo ( value ) > 0 ) { select", "gt": "( i - 1 ) ;", "prediction": ";\n", "label": 0}
{"id": 3163, "input": "<s> import java . util . ArrayList ; import java . util . Iterator ; public class Signal { private String signalName ; private boolean value ; private ArrayList < Gate > listenGates ; private int previousTime ; public Signal ( String signalName ) { this . signalName = signalName ; value = false ; listenGates = new ArrayList < Gate > ( ) ; previousTime = 0 ; } public void save ( Gate name ) { listenGates . add ( name ) ; } public boolean getValue ( ) { return value ; } public void setValue ( boolean wert ) { value = wert ; if ( listenGates . isEmpty ( ) ) { System . out . println ( \"Value of \" + signalName + \" is: \" + value ) ; } else { for ( Gate gatter : listenGates ) { gatter . calculate ( ) ; } } } public void setValue ( boolean v , int t ) { value = v ; if ( listenGates . isEmpty ( ) ) { FullTimingSimulator . updateSignalList ( signalName , this ) ; FullTimingSimulator . ganzeSignallisteAusgeben ( t ) ; } else { FullTimingSimulator . updateSignalList ( signalName , this ) ; FullTimingSimulator . ganzeSignallisteAusgeben ( t ) ; Iterator < Gate > it = listenGates . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) . calculate ( t ) ; } } previousTime = t ; } public String getName ( ) { return signalName ; } public int getPreviousTime ( ) { return previousTime ; } public String toString ( ) { int wert ; if ( this . getValue ( ) == true ) { wert = 1 ; } else { wert = 0 ; } ;", "gt": "String output = \"\" ;", "prediction": "}\n", "label": 1}
{"id": 3819, "input": "<s> public class AssignmentDifferentTypes4 { public static void main ( String [ ] args ) { Ref < Der > derexact = null ; Ref < Base > baseexact = null ; Ref < ? extends Der > derext = null ; Ref < ? extends Base > baseext = null ; Ref < ?", "gt": "super Der > dersuper = null ;", "prediction": ";\n", "label": 0}
{"id": 3165, "input": "<s> package org . restlet . ext . javamail ; import java . io . IOException ; import javax . mail . Message ; import javax . mail . MessagingException ; import org . restlet . data . MediaType ; import org . restlet . ext . xml . DomRepresentation ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import com . sun . mail . pop3 . POP3Folder ; public class MessagesRepresentation extends DomRepresentation { public MessagesRepresentation ( Message [ ] messages , POP3Folder inbox ) throws IOException , MessagingException { super (", "gt": "MediaType . APPLICATION_XML ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9569, "input": "<s> package org . msl . simple . gmfmap . diagram . properties . figure ; import org . eclipse . gmf . gmfgraph . Figure ; public class FigureBackgroundPropertiesSection extends ElementWithFigurePropertySection { @ Override", "gt": "protected Object transformSelection ( Object selected )", "prediction": ";\n", "label": 0}
{"id": 3177, "input": "<s> package org . gatein . common . p3p ; public final class P3PConstants { public enum TelecomType { TELEPHONE ( TELECOM_TELEPHONE ) , FAX ( TELECOM_FAX ) , MOBILE ( TELECOM_MOBILE ) , PAGER ( TELECOM_PAGER ) ; private final String prefix ; TelecomType ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } } public enum TelecomInfo { INTCODE ( TELECOM_INTCODE ) , LOCCODE ( TELECOM_LOCCODE ) , NUMBER ( TELECOM_NUMBER ) , EXT ( TELECOM_EXT ) , COMMENT ( TELECOM_COMMENT ) ; private final String name ; TelecomInfo ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public enum PostalInfo { NAME ( POSTAL_NAME ) , STREET ( POSTAL_STREET ) , CITY ( POSTAL_CITY ) , STATEPROV ( POSTAL_STATEPROV ) , POSTALCODE ( POSTAL_POSTALCODE ) , COUNTRY ( POSTAL_COUNTRY ) , ORGANIZATION ( POSTAL_ORGANIZATION ) ; private final String name ; PostalInfo ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public enum OnlineInfo { EMAIL ( ONLINE_EMAIL ) , URI ( ONLINE_URI ) ; private final String name ; OnlineInfo ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } private static final String POSTAL_NAME = \"postal.name\" ; private static final String POSTAL_STREET = \"postal.street\" ; private static final String POSTAL_CITY = \"postal.city\" ; private static final String POSTAL_STATEPROV = \"postal.stateprov\" ; private static final String POSTAL_POSTALCODE = \"postal.postalcode\" ; private static final String POSTAL_COUNTRY = \"postal.country\" ; private static final String POSTAL_ORGANIZATION = \"postal.organization\" ; private static final String TELECOM_TELEPHONE = \"telecom.telephone.\" ; private static final String TELECOM_FAX = \"telecom.fax.\" ; private static final String TELECOM_MOBILE = \"telecom.mobile.\" ; private static final String TELECOM_PAGER = \"telecom.pager.\" ; private static final String TELECOM_INTCODE = \"intcode\" ; private static final String TELECOM_LOCCODE = \"loccode\" ; private static final String TELECOM_NUMBER = \"number\" ; private static final String TELECOM_EXT = \"ext\" ; private static final String TELECOM_COMMENT = \"comment\" ; private static final String ONLINE_URI = \"online.uri\" ; private static final String ONLINE_EMAIL = \"online.email\" ; public static final String INFO_USER_BDATE = \"user.bdate\" ; private static final String INFO_USER_BDATE_YMD = INFO_USER_BDATE + \".ymd\" ; public static final String INFO_USER_BDATE_YMD_YEAR = INFO_USER_BDATE_YMD + \".year\" ; public static final String INFO_USER_BDATE_YMD_MONTH = INFO_USER_BDATE_YMD + \".month\" ; public static final String INFO_USER_BDATE_YMD_DAY = INFO_USER_BDATE_YMD + \".day\" ; private static final String INFO_USER_BDATE_HMS = INFO_USER_BDATE + \".hms\" ; public static final String INFO_USER_BDATE_HMS_HOUR = INFO_USER_BDATE_HMS + \".hour\" ; public static final String INFO_USER_BDATE_HMS_MINUTE = INFO_USER_BDATE_HMS + \".minute\" ; public static final String INFO_USER_BDATE_HMS_SECOND = INFO_USER_BDATE_HMS + \".second\" ; public static final String INFO_USER_BDATE_FRACTIONSECOND = INFO_USER_BDATE + \".fractionsecond\" ; public static final String INFO_USER_BDATE_TIMEZONE = INFO_USER_BDATE + \".timezone\" ; public static final String INFO_USER_GENDER = \"user.gender\" ; public static final String INFO_USER_EMPLOYER = \"user.employer\" ; public static final String INFO_USER_DEPARTMENT = \"user.department\" ; public static final String INFO_USER_JOB_TITLE = \"user.jobtitle\" ; public static final String INFO_USER_NAME_PREFIX = \"user.name.prefix\" ; public static final String INFO_USER_NAME_GIVEN = \"user.name.given\" ; public static final String INFO_USER_NAME_FAMILY = \"user.name.family\" ; public static final String INFO_USER_NAME_MIDDLE = \"user.name.middle\" ; public static final String INFO_USER_NAME_SUFFIX = \"user.name.suffix\" ; public static final String INFO_USER_NAME_NICKNAME = \"user.name.nickName\" ; public static final String INFO_USER_LOGIN_ID = \"user.login.id\" ; private static final String INFO_USER_HOME_PREFIX = \"user.home-info.\" ; public static final String INFO_USER_HOME_INFO_POSTAL_NAME = INFO_USER_HOME_PREFIX + POSTAL_NAME ; public static final String INFO_USER_HOME_INFO_POSTAL_STREET = INFO_USER_HOME_PREFIX + POSTAL_STREET ; public static final String INFO_USER_HOME_INFO_POSTAL_CITY = INFO_USER_HOME_PREFIX + POSTAL_CITY ; public static final String INFO_USER_HOME_INFO_POSTAL_STATEPROV = INFO_USER_HOME_PREFIX + POSTAL_STATEPROV ; public static final String", "gt": "INFO_USER_HOME_INFO_POSTAL_POSTALCODE = INFO_USER_HOME_PREFIX + POSTAL_POSTALCODE ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2363, "input": "<s> package domain ; import java . io . Serializable ; import javax . persistence . * ; @ Entity public class Email implements Serializable { private static final long serialVersionUID = 1L ; @ Id private String email ; private Boolean preferred ; @ ManyToOne private Student student ; public Email ( ) { } public String getEmail ( ) { return this . email ; } public void setEmail ( String email ) { this . email = email ; } public Boolean getPreferred ( ) { return this . preferred ; } public void setPreferred ( Boolean preferred ) { this . preferred = preferred ; } public Student getStudent ( ) { return this . student ; } public void setStudent ( Student student ) {", "gt": "this . student = student ;", "prediction": "\n", "label": 0}
{"id": 3181, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . widgets . Item ; public interface IItemHolderAdapter < T extends Item > { void add ( T item ) ; void", "gt": "insert ( T item , int index ) ;", "prediction": "}\n", "label": 1}
{"id": 368, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public abstract class RuntimeParameterAnnotations_attribute extends Attribute { RuntimeParameterAnnotations_attribute ( ClassReader cr , int name_index , int length ) throws IOException , Annotation . InvalidAnnotation { super ( name_index , length ) ; int num_parameters = cr . readUnsignedByte ( ) ; parameter_annotations = new Annotation [ num_parameters ] [ ] ; for ( int p = 0 ; p < parameter_annotations . length ; p ++ ) { int num_annotations = cr . readUnsignedShort ( ) ; Annotation [ ] annotations = new Annotation [ num_annotations ] ; for ( int i = 0 ; i < num_annotations ; i ++ ) annotations [ i ] = new Annotation ( cr ) ; parameter_annotations [ p ] = annotations ; } } protected RuntimeParameterAnnotations_attribute ( int name_index , Annotation [ ] [ ] parameter_annotations ) { super ( name_index , length ( parameter_annotations ) ) ; this . parameter_annotations = parameter_annotations ; } private static int", "gt": "length ( Annotation [ ] [ ] anno_arrays )", "prediction": ";\n", "label": 0}
{"id": 3193, "input": "<s> package org . apache . lucene . index ; final class IndexFileNames { static final String SEGMENTS = \"segments\" ; static final String SEGMENTS_GEN = \"segments.gen\" ; static final String DELETABLE = \"deletable\" ; static final String NORMS_EXTENSION = \"nrm\" ; static final String FREQ_EXTENSION = \"frq\" ; static final String PROX_EXTENSION = \"prx\" ; static final String TERMS_EXTENSION = \"tis\" ; static final String TERMS_INDEX_EXTENSION = \"tii\" ; static final String FIELDS_INDEX_EXTENSION = \"fdx\" ; static final String FIELDS_EXTENSION = \"fdt\" ; static final String VECTORS_FIELDS_EXTENSION = \"tvf\" ; static final String VECTORS_DOCUMENTS_EXTENSION = \"tvd\" ; static final String VECTORS_INDEX_EXTENSION = \"tvx\" ; static final String COMPOUND_FILE_EXTENSION = \"cfs\" ; static final String COMPOUND_FILE_STORE_EXTENSION = \"cfx\" ; static final String DELETES_EXTENSION = \"del\" ; static final String FIELD_INFOS_EXTENSION = \"fnm\" ; static final String PLAIN_NORMS_EXTENSION = \"f\" ; static final String SEPARATE_NORMS_EXTENSION = \"s\" ; static final String GEN_EXTENSION = \"gen\" ; static final String INDEX_EXTENSIONS [ ] = new String [ ] { COMPOUND_FILE_EXTENSION , FIELD_INFOS_EXTENSION , FIELDS_INDEX_EXTENSION , FIELDS_EXTENSION , TERMS_INDEX_EXTENSION , TERMS_EXTENSION , FREQ_EXTENSION , PROX_EXTENSION , DELETES_EXTENSION , VECTORS_INDEX_EXTENSION , VECTORS_DOCUMENTS_EXTENSION , VECTORS_FIELDS_EXTENSION , GEN_EXTENSION , NORMS_EXTENSION , COMPOUND_FILE_STORE_EXTENSION , } ; static final String [ ] INDEX_EXTENSIONS_IN_COMPOUND_FILE = new String [ ] { FIELD_INFOS_EXTENSION , FIELDS_INDEX_EXTENSION , FIELDS_EXTENSION , TERMS_INDEX_EXTENSION , TERMS_EXTENSION , FREQ_EXTENSION , PROX_EXTENSION , VECTORS_INDEX_EXTENSION , VECTORS_DOCUMENTS_EXTENSION , VECTORS_FIELDS_EXTENSION , NORMS_EXTENSION } ; static final String [ ] STORE_INDEX_EXTENSIONS = new String [ ] { VECTORS_INDEX_EXTENSION , VECTORS_FIELDS_EXTENSION , VECTORS_DOCUMENTS_EXTENSION , FIELDS_INDEX_EXTENSION , FIELDS_EXTENSION } ; static final String [ ] NON_STORE_INDEX_EXTENSIONS = new String [ ] { FIELD_INFOS_EXTENSION , FREQ_EXTENSION , PROX_EXTENSION , TERMS_EXTENSION , TERMS_INDEX_EXTENSION , NORMS_EXTENSION } ; static final String COMPOUND_EXTENSIONS [ ] = new String [ ] { FIELD_INFOS_EXTENSION , FREQ_EXTENSION , PROX_EXTENSION , FIELDS_INDEX_EXTENSION , FIELDS_EXTENSION , TERMS_INDEX_EXTENSION , TERMS_EXTENSION } ; static final String VECTOR_EXTENSIONS [ ] = new String [ ] { VECTORS_INDEX_EXTENSION , VECTORS_DOCUMENTS_EXTENSION , VECTORS_FIELDS_EXTENSION } ; static final String fileNameFromGeneration ( String base , String extension , long gen ) { if ( gen", "gt": "== SegmentInfo . NO )", "prediction": ") ;\n", "label": 1}
{"id": 1705, "input": "<s> package org . meqantt . message ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . junit . Test ; import org . meqantt . message . PingRespMessage ; import org . meqantt . message . Message . Header ; public class PingRespMessageTest { @ Test public void isDeserializedCorrectly ( ) throws IOException { Header header = new Header ( ( byte ) 0xD0 ) ; InputStream", "gt": "in = new ByteArrayInputStream ( new byte [ ]", "prediction": ";\n", "label": 0}
{"id": 3210, "input": "<s> package org . jscsi . scsi . protocol . mode ; import static org . junit . Assert . fail ; import org . jscsi . scsi . protocol . Serializer ; import org . jscsi . scsi . protocol . SerializerTest ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; public class ModePageTest { private static final String DEFAULT_PACKAGE = \"org.jscsi.scsi.protocol.mode\" ; private static Serializer serializer ; private static String CONTROL_A = \"Control,\" + \"ParametersSavable=1:std,\" + \"SubPageFormat=1:0b0,\" + \"PageCode=6:0x0A,\" + \"PageLength=8:0x0A,\" + \"TST=3:std,\" + \"TMF_ONLY=1:std,\" + \"reserved=1:0x00,\" + \"D_SENSE=1:std,\" + \"GLTSD=1:std,\" + \"RLEC=1:std,\" + \"QueueAlgorithmModifier=4:0x00,\" + \"reserved=1:0x00,\" + \"QERR=2:0x00,\" + \"reserved=1:0x00,\" + \"reserved=1:0x00,\" + \"RAC=1:0x00,\" + \"UA_INTLCK_CTRL=2:0x00,\" + \"SWP=1:0x00,\" + \"reserved=3:0x00,\" + \"ATO=1:0x00,\" + \"TAS=1:0x00,\" + \"reserved=3:0x00,\" + \"AutoloadMode=3:0x00,\" + \"reserved=16:0x00,\" + \"BusyTimeoutPeriod=16:0x00,\" + \"ExtendedSelfTestCompletionTime=16:0x00\" ; private static String CONTROL_B = \"Control,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b0,\" + \"PageCode=6:0x0A,\" + \"PageLength=8:0x0A,\" + \"TST=3:0x00,\" + \"TMF_ONLY=1:0x00,\" + \"reserved=1:0x00,\" + \"D_SENSE=1:0x00,\" + \"GLTSD=1:0x00,\" + \"RLEC=1:0x00,\" + \"QueueAlgorithmModifier=4:std,\" + \"reserved=1:0x00,\" + \"QERR=2:std,\" + \"reserved=1:0x00,\" + \"reserved=1:0x00,\" + \"RAC=1:std,\" + \"UA_INTLCK_CTRL=2:std,\" + \"SWP=1:std,\" + \"reserved=3:0x00,\" + \"ATO=1:0x00,\" + \"TAS=1:0x00,\" + \"reserved=3:0x00,\" + \"AutoloadMode=3:0x00,\" + \"reserved=16:0x00,\" + \"BusyTimeoutPeriod=16:0x00,\" + \"ExtendedSelfTestCompletionTime=16:0x00\" ; private static String CONTROL_C = \"Control,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b0,\" + \"PageCode=6:0x0A,\" + \"PageLength=8:0x0A,\" + \"TST=3:0x00,\" + \"TMF_ONLY=1:0x00,\" + \"reserved=1:0x00,\" + \"D_SENSE=1:0x00,\" + \"GLTSD=1:0x00,\" + \"RLEC=1:0x00,\" + \"QueueAlgorithmModifier=4:std,\" + \"reserved=1:0x00,\" + \"QERR=2:std,\" + \"reserved=1:0x00,\" + \"reserved=1:0x00,\" + \"RAC=1:0x00,\" + \"UA_INTLCK_CTRL=2:0x00,\" + \"SWP=1:0x00,\" + \"reserved=3:0x00,\" + \"ATO=1:std,\" + \"TAS=1:std,\" + \"reserved=3:0x00,\" + \"AutoloadMode=3:std,\" + \"reserved=16:0x00,\" + \"BusyTimeoutPeriod=16:std,\" + \"ExtendedSelfTestCompletionTime=16:std\" ; private static String CONTROL_EXTENSION = \"ControlExtension,\" + \"ParametersSavable=1:std,\" + \"SubPageFormat=1:0b01,\" + \"PageCode=6:0x0A,\" + \"SubPageCode=8:0x01,\" + \"PageLength=16:0x1C,\" + \"reserved=5:0x00,\" + \"TCMOS=1:std,\" + \"SCSIP=1:std,\" + \"IALUAE=1:std,\" + \"reserved=4:0x00,\" + \"InitialPriority=4:0x00,\" + \"reserved=32:0x00,\" + \"reserved=32:0x00,\" + \"reserved=32:0x00,\" + \"reserved=32:0x00,\" + \"reserved=32:0x00,\" + \"reserved=32:0x00,\" + \"reserved=16:0x00\" ; private static String INFORMATIONAL_EXCEPTIONS_CONTROL_A = \"InformationalExceptionsControl,\" + \"ParametersSavable=1:std,\" + \"SubPageFormat=1:0b00,\" + \"PageCode=6:0x1C,\" + \"PageLength=8:0x0A,\" + \"PERF=1:std,\" + \"reserved=1:0x00,\" + \"EBF=1:std,\" + \"EWASC=1:std,\" + \"DEXCPT=1:std,\" + \"TEST=1:std,\" + \"reserved=1:0x00,\" + \"LOGERR=1:std,\" + \"reserved=4:0x00,\" + \"MRIE=4:std,\" + \"IntervalTimer=32:0x00,\" + \"ReportCount=32:0x00\" ; private static String INFORMATIONAL_EXCEPTIONS_CONTROL_B = \"InformationalExceptionsControl,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b00,\" + \"PageCode=6:0x1C,\" + \"PageLength=8:0x0A,\" + \"PERF=1:0x00,\" + \"reserved=1:0x00,\" + \"EBF=1:0x00,\" + \"EWASC=1:0x00,\" + \"DEXCPT=1:0x00,\" + \"TEST=1:0x00,\" + \"reserved=1:0x00,\" + \"LOGERR=1:0x00,\" + \"reserved=4:0x00,\" + \"MRIE=4:0x00,\" + \"IntervalTimer=32:std,\" + \"ReportCount=32:std\" ; private static String CACHING_A = \"Caching,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b00,\" + \"PageCode=6:0x08,\" + \"PageLength=8:0x12,\" + \"IC=1:std,\" + \"ABPF=1:std,\" + \"CAP=1:std,\" + \"DISC=1:std,\" + \"SIZE=1:std,\" + \"WCE=1:std,\" + \"MF=1:std,\" + \"RCD=1:std,\" + \"DemandReadRetentionPriority=4:0x00,\" + \"WriteRetentionPriority=4:0x00,\" + \"DisablePrefetchTransferLength=16:0x00,\" + \"MinimumPrefetch=16:0x00,\" + \"MaximumPrefetch=16:0x00,\" + \"MaximumPrefetchCeiling=16:0x00,\" + \"FSW=1:0x00,\" + \"LBCSS=1:0x00,\" + \"DRA=1:0x00,\" + \"reserved=4:0x00,\" + \"NV_DIS=1:0x00,\" + \"NumberOfCacheSegments=8:0x00,\" + \"CacheSegmentSize=16:0x00,\" + \"reserved=32:0x00\" ; private static String CACHING_B = \"Caching,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b00,\" + \"PageCode=6:0x08,\" + \"PageLength=8:0x12,\" + \"IC=1:0x00,\" + \"ABPF=1:0x00,\" + \"CAP=1:0x00,\" + \"DISC=1:0x00,\" + \"SIZE=1:0x00,\" + \"WCE=1:0x00,\" + \"MF=1:0x00,\" + \"RCD=1:0x00,\" + \"DemandReadRetentionPriority=4:std,\" + \"WriteRetentionPriority=4:std,\" + \"DisablePrefetchTransferLength=16:std,\" + \"MinimumPrefetch=16:std,\" + \"MaximumPrefetch=16:std,\" + \"MaximumPrefetchCeiling=16:std,\" + \"FSW=1:0x00,\" + \"LBCSS=1:0x00,\" + \"DRA=1:0x00,\" + \"reserved=4:0x00,\" + \"NV_DIS=1:0x00,\" + \"NumberOfCacheSegments=8:0x00,\" + \"CacheSegmentSize=16:0x00,\" + \"reserved=32:0x00\" ; private static String CACHING_C = \"Caching,\" + \"ParametersSavable=1:0x00,\" + \"SubPageFormat=1:0b00,\" + \"PageCode=6:0x08,\" + \"PageLength=8:0x12,\" + \"IC=1:0x00,\" + \"ABPF=1:0x00,\" + \"CAP=1:0x00,\" + \"DISC=1:0x00,\" + \"SIZE=1:0x00,\" + \"WCE=1:0x00,\" + \"MF=1:0x00,\" + \"RCD=1:0x00,\" + \"DemandReadRetentionPriority=4:0x00,\" + \"WriteRetentionPriority=4:0x00,\" + \"DisablePrefetchTransferLength=16:0x00,\" + \"MinimumPrefetch=16:0x00,\" + \"MaximumPrefetch=16:0x00,\" + \"MaximumPrefetchCeiling=16:0x00,\" + \"FSW=1:std,\" + \"LBCSS=1:std,\" + \"DRA=1:std,\" + \"reserved=4:std,\" + \"NV_DIS=1:std,\" + \"NumberOfCacheSegments=8:std,\" + \"CacheSegmentSize=16:std,\" + \"reserved=32:0x00\" ; private static String READ_WRITE_ERROR_RECOVERY = \"ReadWriteErrorRecovery,\" + \"ParametersSavable=1:std,\" + \"SubPageFormat=1:0b0,\" + \"PageCode=6:0x01,\" + \"PageLength=8:0x0A,\" + \"AWRE=1:std,\" + \"ARRE=1:std,\" + \"TB=1:std,\" + \"RC=1:std,\" + \"EER=1:std,\" + \"PER=1:std,\" + \"DTE=1:std,\" + \"DCR=1:std,\" + \"ReadRetryCount=8:std,\" + \"reserved=32:0x00,\" + \"WriteRetryCount=8:std,\" + \"reserved=8:0x00,\" + \"RecoveryTimeLimit=16:std\" ; @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { serializer = new StaticModePageRegistry ( ) ; } @ AfterClass public static void tearDownAfterClass ( ) throws Exception { } @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { } private void runTest ( String specification ) { try { new SerializerTest ( serializer , DEFAULT_PACKAGE , specification ) . runTest ( ) ; } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } @ Test public void parseControl ( ) { runTest ( CONTROL_A ) ; runTest ( CONTROL_B ) ; runTest ( CONTROL_C ) ; } @ Test public void parseControlExtension ( ) { runTest ( CONTROL_EXTENSION ) ; } @", "gt": "Test public void parseInformationalExceptionsControl ( )", "prediction": "}\n", "label": 1}
{"id": 3936, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . PurgeResource ; import org . jjflyboy . tjpeditor . project . PurgeResourceAttribute ; public class PurgeResourceImpl extends ResourceAttributeImpl implements PurgeResource { protected static final PurgeResourceAttribute LIST_ATTRIBUTE_EDEFAULT = PurgeResourceAttribute . FAIL ; protected PurgeResourceAttribute listAttribute = LIST_ATTRIBUTE_EDEFAULT ; protected PurgeResourceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getPurgeResource ( ) ; } public PurgeResourceAttribute getListAttribute ( ) { return listAttribute ; } public void setListAttribute ( PurgeResourceAttribute newListAttribute ) { PurgeResourceAttribute oldListAttribute = listAttribute ; listAttribute = newListAttribute == null ? LIST_ATTRIBUTE_EDEFAULT : newListAttribute ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . PURGE_RESOURCE__LIST_ATTRIBUTE , oldListAttribute , listAttribute ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . PURGE_RESOURCE__LIST_ATTRIBUTE : return getListAttribute ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int", "gt": "featureID , Object newValue )", "prediction": ")\n", "label": 0}
{"id": 3220, "input": "<s> package com . mycompany . checks ; import java . io . File ; import com . puppycrawl . tools . checkstyle . api . * ; public class LimitImplementationFiles extends AbstractFileSetCheck { private int max = 100 ; public void setMax ( int aMax ) { max = aMax ; } public void process ( File [ ] files ) { if ( files != null && files . length > max ) { final String path = files [ max ] . getPath ( ) ; getMessageCollector ( ) . reset ( ) ; MessageDispatcher dispatcher = getMessageDispatcher ( ) ; dispatcher . fireFileStarted ( path ) ; log ( 0 , \"max.files.exceeded\" , new", "gt": "Integer ( max ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9201, "input": "<s> package com . redhat . ceylon . tools . help ; import com . redhat . ceylon . common . tool . ArgumentModel ; import com . redhat . ceylon . common . tool . OptionModel ; import com . redhat . ceylon . common . tool . OptionModel . ArgumentType ; import com . redhat . ceylon . tools . help . model . DescribedSection ; import com . redhat . ceylon . tools . help . model . Doc ; import com . redhat . ceylon . tools . help . model . Option ; import com . redhat . ceylon . tools . help . model . OptionsSection ; import com . redhat . ceylon . tools . help . model . SynopsesSection ; import com . redhat . ceylon . tools . help . model . Synopsis ; import com . redhat . ceylon . tools . help . model . Synopsis . NameAndSubtool ; import com . redhat . ceylon . tools . help . model . Visitor ; public class HtmlVisitor implements Visitor { private final Html html ; private boolean hadFirstArgument ; private boolean hadOptions ; HtmlVisitor ( Appendable out ) { this . html = new Html ( out ) ; } Html getHtml ( ) { return html ; } @ Override public void start ( Doc doc ) { html . open ( \"html\" , \"head\" ) ; html . open ( \"title\" ) . text ( doc . getInvocation ( ) ) . close ( \"title\" ) . text ( \"\\n\" ) ; html . tag ( \"link rel='stylesheet'type='text/css' href='doc-tool.css'\" ) . text ( \"\\n\" ) ; html . close ( \"head\" ) . text ( \"\\n\" ) ; html . open ( \"body\" ) . text ( \"\\n\" ) ; html . open ( \"h1\" ) . text ( doc . getInvocation ( ) ) . close ( \"h1\" ) ; html . text ( \"\\n\" ) ; } @ Override public void end ( Doc doc ) { html . close ( \"body\" , \"html\" ) ; } @ Override public void visitAdditionalSection ( DescribedSection describedSection ) { describedSection ( describedSection ) ; } private void describedSection ( DescribedSection describedSection ) { html . open ( \"div class='section'\" ) ; html . text ( \"\\n\" ) ; html . markdown ( describedSection . getTitle ( ) ) . text ( \"\\n\" ) ; html . markdown ( describedSection . getDescription ( ) ) ; html . close ( \"div\" ) . text ( \"\\n\\n\" ) ; } @ Override public void startOptions ( OptionsSection optionsSection ) { html . open ( \"div class='section section-options'\" ) . text ( \"\\n\" ) ; html . open ( \"h2\" ) . text ( optionsSection . getTitle ( ) ) . close ( \"h2\" ) . text ( \"\\n\" ) ; html . open ( \"dl\" ) ; } @ Override public void visitOption ( Option option ) { String longName = option . getLongName ( ) ; String shortName = option . getShortName ( ) ; String argumentName = option . getArgumentName ( ) ; ArgumentType argumentType = option . getOption ( ) . getArgumentType ( ) ; html . open ( \"dt class='option'\" ) ; html . open ( \"code id='long\" + longName + \"'\" ) . text ( longName ) ; if ( argumentType == ArgumentType . OPTIONAL ) { html . text ( \"[\" ) ; } if ( argumentType != ArgumentType . NOT_ALLOWED ) { html . text ( \"=\" ) . text ( argumentName ) ; } if ( argumentType == ArgumentType . OPTIONAL ) { html . text ( \"]\" ) ; } html . close ( \"code\" ) ; if ( shortName != null ) { html . text ( \", \" ) ; html . open ( \"code id='short\" + shortName + \"'\" ) . text ( shortName ) ; if ( argumentType != ArgumentType . NOT_ALLOWED ) { html . text ( \" \" ) ; if ( argumentType == ArgumentType . OPTIONAL ) { html . text ( \"[\" ) ; } html . text ( argumentName ) ; if ( argumentType == ArgumentType . OPTIONAL ) { html . text ( \"]\" ) ; } } html . close ( \"code\" ) ; } html . close ( \"dt\" ) . text ( \"\\n\" ) ; html . open ( \"dd class='option-description'\" ) ; html . markdown ( option . getDescription ( ) ) ; html . close ( \"dd\" ) . text ( \"\\n\" ) ; } @ Override public void endOptions ( OptionsSection optionsSection ) { html . close ( \"dl\" ) . text ( \"\\n\" ) ; html . close ( \"div\" ) . text ( \"\\n\\n\" ) ; } @ Override public void visitSummary ( DescribedSection summarySection ) { describedSection ( summarySection ) ; } @ Override public void startSynopses ( SynopsesSection synopsesSection ) { html . open ( \"div class='section section-synopsis'\" ) . text ( \"\\n\" ) ; html . open ( \"h2\" ) . text ( synopsesSection . getTitle ( ) ) . close ( \"h2\" ) . text ( \"\\n\" ) ; } private void longOptionSynopsis ( String string ) { html . link ( string , \"#long\" + string ) ; } private void shortOptionSynopsis ( String string ) { html . link ( string , \"#short\" + string ) ; } private void argumentSynopsis ( String name ) { html . link ( name , \"#arg\" + name ) ; } private String multiplicity ( ArgumentModel < ? > argument , String name ) { name = \"<\" + name + \">\" ; if ( argument . getMultiplicity ( ) . isMultivalued ( ) ) { name += \"...\" ; } return name ; } @ Override public void startSynopsis ( Synopsis synopsis ) { hadFirstArgument = false ; hadOptions = false ; html . open ( \"div class='synopsis'\" , \"code\" ) ; html . text ( synopsis . getInvocation ( ) + \" \" ) ; } @ Override public void endSynopsis ( Synopsis synopsis ) { html . close ( \"code\" , \"div\" ) . text ( \"\\n\" ) ; } @ Override public void visitSynopsisArgument ( ArgumentModel < ? > argument ) { if ( ! hadFirstArgument ) { html", "gt": ". text ( \" [--]\" ) ;", "prediction": ";\n", "label": 0}
{"id": 3227, "input": "<s> package org . gatein . common . net . media ; public final class MediaType { public static final MediaType TEXT_HTML = new MediaType ( TypeDef . TEXT , SubtypeDef . HTML ) ; public static final MediaType TEXT_JAVASCRIPT = new MediaType ( TypeDef . TEXT , SubtypeDef . JAVASCRIPT ) ; public static final MediaType TEXT_CSS = new MediaType ( TypeDef . TEXT , SubtypeDef . CSS ) ; public static final MediaType APPLICATION_X_WWW_FORM_URLENCODED = new MediaType ( TypeDef . APPLICATION , SubtypeDef . X_WWW_FORM_URLENCODED ) ; public static final MediaType MULTIPART_FORM_DATA_MEDIA_TYPE = new MediaType ( TypeDef . MULTIPART , SubtypeDef . FORM_DATA ) ; public static MediaType create ( String mediaTypeName ) throws IllegalArgumentException { if ( mediaTypeName == null ) { throw new IllegalArgumentException ( \"No null media type value accepted\" ) ; } int slashIndex = mediaTypeName . indexOf ( '/' ) ; if ( slashIndex == - 1 ) { throw new IllegalArgumentException ( \"The media type \" + mediaTypeName + \" does not contain a /\" ) ; } String typeName = mediaTypeName . substring ( 0 , slashIndex ) ; String subtypeName = mediaTypeName . substring ( slashIndex + 1 ) ; return create ( typeName , subtypeName ) ; } public static MediaType create ( String typeName , String subtypeName ) throws IllegalArgumentException { if ( typeName == null ) { throw new IllegalArgumentException ( \"No null type name accepted\" ) ; } if ( subtypeName == null ) { throw new IllegalArgumentException ( \"No null subtype name accepted\" ) ; } TypeDef type = TypeDef . create ( typeName ) ; if ( type == null ) { throw new IllegalArgumentException ( \"Type not recognized in content type \" + typeName + \"/\" + subtypeName ) ; } SubtypeDef subtype = SubtypeDef . create ( subtypeName ) ; return new MediaType ( type , subtype ) ; } public static MediaType create ( TypeDef type , SubtypeDef subtype ) throws IllegalArgumentException { if ( type == null ) { throw new IllegalArgumentException ( \"No null type accepted\" ) ; } if ( subtype == null ) { throw new IllegalArgumentException ( \"No null subtype accepted\" ) ; } return new MediaType ( type , subtype ) ; } private final TypeDef type ; private final SubtypeDef subtype ; private volatile Integer hashCode ; private volatile String toString ; private volatile String value ; MediaType ( TypeDef type , SubtypeDef subtype ) { this . type = type ; this . subtype = subtype ; } public TypeDef getType ( ) { return type ; } public SubtypeDef getSubtype ( ) { return subtype ; } public String getValue ( ) { if ( value == null ) { value = type . getName ( ) + \"/\" + subtype . getName ( ) ; } return value ; } public int hashCode ( ) { if ( hashCode == null ) { hashCode = type . hashCode ( ) + subtype . hashCode ( ) ; } return hashCode ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof MediaType ) { MediaType that", "gt": "= ( MediaType ) obj ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6619, "input": "<s> package org . gk . engine . client . build ; import java . util . List ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcessImpl ; import org . gk . engine . client . IEngine ; import org . gk . engine . client . gen . UIGen ; import com . google . gwt . xml . client . Node ; import com . google . gwt . xml . client . NodeList ; public abstract class Builder { protected static INodeProvider nProvider ; public static void attach ( INodeProvider np ) { nProvider = np ; BuilderFactory . createBuilders ( ) ; BuilderFactory . createLayoutBuilders ( ) ; BuilderFactory . createFormFieldBuilders ( ) ; BuilderFactory . createGridFieldBuilders ( ) ; } public Builder ( String processNodeName ) { String [ ] nName = processNodeName . split ( \",\" ) ;", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 0}
{"id": 3230, "input": "<s> package org . apache . sqoop . util ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public final class JdbcUrl { public static final Log LOG = LogFactory . getLog ( JdbcUrl . class . getName ( ) ) ; private JdbcUrl ( ) { } public static String getDatabaseName ( String connectString ) { try { String sanitizedString = null ; int schemeEndOffset = connectString . indexOf ( \"://\" ) ; if ( - 1 == schemeEndOffset ) { sanitizedString = \"http://\" + connectString ; LOG . warn ( \"Could not find database access scheme in connect string \" + connectString ) ; } else { sanitizedString = \"http\" + connectString . substring ( schemeEndOffset ) ; } URL connectUrl = new URL ( sanitizedString ) ; String databaseName = connectUrl . getPath ( ) ; if ( null == databaseName ) { return null ; } while ( databaseName . startsWith ( \"/\" ) ) { databaseName = databaseName . substring ( 1 ) ; } return databaseName ; } catch ( MalformedURLException mue ) { LOG . error ( \"Malformed connect string URL: \" + connectString + \"; reason is \" + mue . toString ( ) ) ; return null ; } } public static String getHostName ( String connectString ) { try { String sanitizedString = null ; int schemeEndOffset = connectString . indexOf ( \"://\" ) ; if ( - 1 == schemeEndOffset ) { sanitizedString = connectString ; } else { sanitizedString = \"http\" + connectString . substring ( schemeEndOffset ) ; }", "gt": "URL connectUrl = new URL ( sanitizedString ) ;", "prediction": "}\n", "label": 1}
{"id": 7068, "input": "<s> package com . farpost . ldt ; import java . lang . reflect . InvocationTargetException ; import java . util . Map ; public interface Task { void prepare ( ) throws Exception ; void execute ( ) throws Exception ; void cleanup ( ) throws Exception ; void setParameters (", "gt": "Map < String , String > parameters ) throws IllegalArgumentException ;", "prediction": ") ;\n", "label": 0}
{"id": 3240, "input": "<s> package utility ; import org . lwjgl . LWJGLException ; import org . lwjgl . input . Keyboard ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import org . lwjgl . opengl . GL11 ; public class CameraTest { public static void main ( String args [ ] ) throws LWJGLException { Display . setVSyncEnabled ( true ) ; Display . setDisplayMode ( new DisplayMode ( 640 , 480 ) ) ; Display . setResizable ( true ) ; Display . create ( ) ; EulerCamera camera = new EulerCamera . Builder ( ) . setAspectRatio ( 640f / 480f ) . setFieldOfView ( 60 ) . build ( ) ; camera . applyPerspectiveMatrix ( ) ; camera . applyOptimalStates ( ) ; Mouse . setGrabbed ( true ) ; while ( ! Display . isCloseRequested ( ) ) { GL11 . glViewport ( 0 , 0 , Display . getWidth ( ) , Display . getHeight ( ) ) ; camera . setAspectRatio ( ( float ) Display . getWidth ( ) / Display . getHeight ( ) ) ; if ( Display . wasResized ( ) ) { camera . applyPerspectiveMatrix ( ) ; } while ( Keyboard . next ( ) ) {", "gt": "if ( Keyboard . isKeyDown ( Keyboard . KEY_ESCAPE ) )", "prediction": "}\n", "label": 1}
{"id": 3687, "input": "<s> package com . sun . tools . javadoc ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . util . HashSet ; import java . util . Set ; import javax . tools . FileObject ; import javax . tools . JavaFileManager . Location ; import javax . tools . StandardJavaFileManager ; import javax . tools . StandardLocation ; import com . sun . javadoc . * ; import static com . sun . javadoc . LanguageVersion . * ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . code . Kinds ; import com . sun . tools . javac . code . Scope ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . code . Type . ClassType ; import com . sun . tools . javac . code . TypeTags ; import com . sun . tools . javac . comp . AttrContext ; import com . sun . tools . javac . comp . Env ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCClassDecl ; import com . sun . tools . javac . tree . JCTree . JCFieldAccess ; import com . sun . tools . javac . tree . JCTree . JCImport ; import com . sun . tools . javac . tree . TreeInfo ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Names ; import com . sun . tools . javac . util . Position ; import static com . sun . tools . javac . code . Kinds . * ; public class ClassDocImpl extends ProgramElementDocImpl implements ClassDoc { public final ClassType type ; protected final ClassSymbol tsym ; boolean isIncluded = false ; private SerializedForm serializedForm ; public ClassDocImpl ( DocEnv env , ClassSymbol sym ) { this ( env , sym , null , null , null ) ; } public ClassDocImpl ( DocEnv env , ClassSymbol sym , String documentation , JCClassDecl tree , Position . LineMap lineMap ) { super ( env , sym , documentation , tree , lineMap ) ; this . type = ( ClassType ) sym . type ; this . tsym = sym ; } protected long getFlags ( ) { return getFlags ( tsym ) ; } static long getFlags ( ClassSymbol clazz ) { while ( true ) { try { return clazz . flags ( ) ; } catch ( CompletionFailure ex ) { } } } static boolean isAnnotationType ( ClassSymbol clazz ) { return ( getFlags ( clazz ) & Flags . ANNOTATION ) != 0 ; } protected ClassSymbol getContainingClass ( ) { return tsym . owner . enclClass ( ) ; } @ Override public boolean isClass ( ) { return ! Modifier . isInterface ( getModifiers ( ) ) ; } @ Override public boolean isOrdinaryClass ( ) { if ( isEnum ( ) || isInterface ( ) || isAnnotationType ( ) ) { return false ; } for ( Type t = type ; t . tag == TypeTags . CLASS ; t = env . types . supertype ( t ) ) { if ( t . tsym == env . syms . errorType . tsym || t . tsym == env . syms . exceptionType . tsym ) { return false ; } } return true ; } @ Override public boolean isEnum ( ) { return ( getFlags ( ) & Flags . ENUM ) != 0 && ! env . legacyDoclet ; } @ Override public boolean isInterface ( ) { return Modifier . isInterface ( getModifiers ( ) ) ; } @ Override public boolean isException ( ) { if ( isEnum ( ) || isInterface ( ) || isAnnotationType ( ) ) { return false ; } for ( Type t = type ;", "gt": "t . tag == TypeTags . CLASS ;", "prediction": "}\n", "label": 0}
{"id": 3256, "input": "<s> package org . nuxeo . ecm . platform . relations . descriptors ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XNodeMap ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . relations . api . GraphDescription ; import org . nuxeo . runtime . api . Framework ; @ XObject ( \"graph\" ) public class GraphDescriptor implements GraphDescription , Serializable { private static final long serialVersionUID = 1L ; @ XNode ( \"@name\" ) public String name ; @ XNode ( \"@type\" ) public String graphType ; public Map < String , String > options = new HashMap < String , String > ( ) ; @ XNodeMap ( value = \"namespaces/namespace\" , key = \"@name\" , type = HashMap . class , componentType = String . class ) public Map < String , String > namespaces = new HashMap < String , String > ( ) ; @ Override public String getName ( ) { return name ; } @ Override public String getGraphType ( ) { return graphType ; } @ Override public Map < String , String > getOptions ( ) { return options ; } @ XNodeMap ( value = \"option\" , key = \"@name\" , type = HashMap . class , componentType = String . class ) public void setOptions ( Map < String , String > options ) { Map < String , String > map = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > entry : options . entrySet ( ) ) { String value = entry", "gt": ". getValue ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5369, "input": "<s> package com . sun . source . tree ; public interface InstanceOfTree extends ExpressionTree { ExpressionTree getExpression ( ) ;", "gt": "Tree getType ( ) ;", "prediction": "}\n", "label": 0}
{"id": 3266, "input": "<s> package org . eclipse . rap . demo . databinding ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . * ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . part . ViewPart ; public class DatabindingSnippetsView extends ViewPart { public static final int UNDEFINDED = - 1 ; public static final int GROUP_WIDTH = 700 ; public static final int TOP_MARGIN = 5 ; public static final int VIEW_MIN_HEIGHT = 200 ; public static final int GROUP_MARGIN_HEIGHT = 5 ; public static final int GROUP_MARGIN_WIDTH = 5 ; public static final int STD_LABEL_WIDTH = 80 ; public static final int STD_LABEL_WIDTH_LARGE = 110 ; public static final int STD_TEXT_WIDTH = 95 ; public static final int STD_TEXT_WIDTH_LARGE = 200 ; public void createPartControl ( final Composite parent ) { FormLayout formLayout = new FormLayout ( ) ; formLayout . marginHeight = GROUP_MARGIN_HEIGHT ; formLayout . marginWidth = GROUP_MARGIN_WIDTH ; parent . setLayout ( new FormLayout ( ) ) ; Snippet000HelloWorld snippet000 = new Snippet000HelloWorld ( parent , SWT . NONE ) ; FormData data = new FormData ( GROUP_WIDTH , SWT . DEFAULT ) ; data . top = new FormAttachment ( 0 , TOP_MARGIN ) ; data . left = new FormAttachment ( 0 , GROUP_MARGIN_WIDTH ) ; snippet000 . setLayoutData ( data ) ; Snippet001NestedSelectionWithCombo snippet001 = new Snippet001NestedSelectionWithCombo", "gt": "( parent , SWT . NONE ) ;", "prediction": ";\n", "label": 1}
{"id": 2527, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Egg ; public interface LizaEgg extends Egg { List < LizaEntity > getNearbyLizaEntities", "gt": "( double x , double y , double z ) ;", "prediction": ";\n", "label": 0}
{"id": 3273, "input": "<s> package org . nuxeo . ecm . platform . audit . ws . jaws ; public class AuditException extends org . apache . axis . AxisFault implements java . io . Serializable { private java . lang . String message1 ; public AuditException ( ) { } public AuditException ( java . lang . String message1 ) { this . message1 = message1 ; } public java . lang . String getMessage1 ( ) { return message1 ; } public void setMessage1 ( java . lang . String message1 ) { this . message1 = message1 ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof AuditException ) ) return false ; AuditException other = ( AuditException ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . message1 == null && other . getMessage1 ( ) == null ) || ( this . message1 != null && this . message1 . equals ( other . getMessage1 ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getMessage1 ( ) != null ) { _hashCode += getMessage1 ( ) . hashCode ( ) ; } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( AuditException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://ws.audit.platform.ecm.nuxeo.org/jaws\" , \"AuditException\" ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"message1\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://ws.audit.platform.ecm.nuxeo.org/jaws\" , \"message\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://www.w3.org/2001/XMLSchema\" , \"string\" ) ) ; elemField . setNillable ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml", "gt": ". namespace . QName _xmlType )", "prediction": ";\n", "label": 1}
{"id": 5767, "input": "<s> package gui ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . Toolkit ; import javax . swing . JFrame ; public class LoginFrame extends JFrame { private static final long serialVersionUID = 2269971701250845501L ; private final int windowWidth = 800 ; private final int windowHeight = 600 ; public LoginFrame ( ) { this . setTitle ( \"NextBooks 2.0\" ) ; this . setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; this . setSize ( new Dimension ( windowWidth , windowHeight ) ) ; Dimension dim = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int x = ( dim . width - windowWidth ) / 2 ; int y = ( dim . height", "gt": "- windowHeight ) / 2 ;", "prediction": ") ;\n", "label": 0}
{"id": 3278, "input": "<s> package org . restlet . ext . jaxrs . internal . provider ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import javax . ws . rs . Consumes ; import javax . ws . rs . Produces ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import org . restlet . data . Form ; import org . restlet . engine . io . BioUtils ; import org . restlet . ext . jaxrs . internal . core . UnmodifiableMultivaluedMap ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . wrappers . provider . ProviderWrapper ; import org . restlet . representation . Representation ; @ Provider @ Consumes ( \"application/x-www-form-urlencoded\" ) @ Produces ( \"application/x-www-form-urlencoded\" ) public class WwwFormMmapProvider extends AbstractProvider < MultivaluedMap < String , String > > { @ Override public long getSize ( MultivaluedMap < String , String > mmap , Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { return - 1 ; } @ Override protected Class < ? > supportedClass ( ) { return MultivaluedMap . class ; } @ Override public void writeTo ( MultivaluedMap < String , String > mmap , Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException { Form form = Converter . toForm ( mmap ) ; Representation formRepr = form . getWebRepresentation ( ) ; BioUtils . copy ( formRepr . getStream ( ) , entityStream ) ; } @ Override public MultivaluedMap < String , String > readFrom ( Class < MultivaluedMap < String , String > > type , Type genericType , Annotation [ ] annotations , MediaType mediaType , MultivaluedMap < String , String > httpResponseHeaders , InputStream entityStream ) throws IOException { Form form = WwwFormFormProvider .", "gt": "getForm ( mediaType , entityStream ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8160, "input": "<s> class ImproperTypeInnerRawParam { class Outer < S > { class Inner < T > { } } void m ( ) { Object o = ( Outer . Inner <", "gt": "? > ) null ;", "prediction": ") ;\n", "label": 0}
{"id": 3284, "input": "<s> package org . agoncal . book . javaee7 . chapter22 . ex04 ; import javax . persistence . * ; @ Entity @ Table ( name = \"ex58_item\" ) public class Item04 { @ Id @ GeneratedValue protected Long id ; @ Column ( nullable = false ) protected String title ; @ Column ( nullable = false ) protected Float price ; protected String description ; public Item04 ( ) { } public Item04 ( String title , Float price , String description ) { this . title = title ; this . price = price ; this . description = description ; } public Long getId ( ) { return id ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Float getPrice ( ) { return price ; } public void", "gt": "setPrice ( Float price )", "prediction": "( )\n", "label": 1}
{"id": 7233, "input": "<s> import java . lang . reflect . * ; import java . io . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Scope . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . file . JavacFileManager ; import static com . sun . tools . javac . code . Kinds . * ; public class HashCollisionTest { public static void main ( String ... args ) throws Exception { new HashCollisionTest ( ) . run ( ) ; } void run ( ) throws Exception { Context context = new Context ( ) ; JavacFileManager . preRegister ( context ) ; names = Names . instance ( context ) ; symtab = Symtab . instance ( context ) ; Scope emptyScope = new Scope ( symtab . unnamedPackage ) ; Field sHashMask = Scope . class . getDeclaredField ( \"hashMask\" ) ; sHashMask . setAccessible ( true ) ; scopeHashMask = sHashMask . getInt ( emptyScope ) ; log ( \"scopeHashMask: \" + scopeHashMask ) ; Name entry = names . fromString ( \"Entry\" ) ; Name outerName ; Name innerName ; StringBuilder sb = new StringBuilder ( \"C\" ) ; int i = 0 ; do { sb . append ( Integer . toString ( i % 10 ) ) ; innerName = names . fromString ( sb + \"$Entry\" ) ; } while ( ! clash ( entry , innerName ) && ( ++ i ) < MAX_TRIES ) ; if ( clash ( entry , innerName ) ) { log ( \"Detected expected hash collision for \" + entry + \" and \" + innerName + \" after \" + i + \" tries\" ) ; } else { throw new Exception ( \"No potential collision found after \" + i + \" tries\" ) ; } outerName = names . fromString ( sb . toString ( ) ) ; ClassSymbol cc = createClass ( names . fromString ( \"C\" ) , symtab . unnamedPackage ) ; ClassSymbol ce = createClass ( entry , cc ) ; PackageSymbol p = new PackageSymbol ( names . fromString ( \"p\" ) , symtab . rootPackage ) ; p . members_field = new Scope ( p ) ; ClassSymbol inner = createClass ( innerName , p ) ; ClassSymbol outer = createClass ( outerName , p ) ; log ( \"createStarImportScope\" ) ; Scope starImportScope ; Method importAll ; PackageSymbol pkg = new PackageSymbol ( names . fromString ( \"pkg\" ) , symtab . rootPackage ) ; try { Class < ? > c = Class . forName ( \"com.sun.tools.javac.code.Scope$StarImportScope\" ) ; Constructor ctor = c . getDeclaredConstructor ( new Class [ ] { Symbol . class } ) ; importAll = c . getDeclaredMethod ( \"importAll\" , new Class [ ] { Scope . class } ) ; starImportScope = ( Scope ) ctor . newInstance ( new Object [ ] { pkg } ) ; } catch ( ClassNotFoundException e ) { starImportScope = new ImportScope ( pkg ) ; importAll = null ; }", "gt": "dump ( \"initial\" , starImportScope ) ;", "prediction": "}\n", "label": 0}
{"id": 3287, "input": "<s> package org . restlet . example . ext . jaxrs ; import java . util . HashSet ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . example . ext . jaxrs . employees . EmployeesResource ; public class ExampleApplication extends Application { public ExampleApplication ( ) { } @ Override public Set < Class < ? > > getClasses ( ) { final Set < Class < ? > > rrcs = new HashSet < Class < ? > > ( ) ; rrcs . add ( EasyRootResource . class ) ; rrcs .", "gt": "add ( EmployeesResource . class ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7463, "input": "<s> package org . ofbiz . minilang ; @ SuppressWarnings ( \"serial\" ) public class MiniLangException extends org . ofbiz . base . util . GeneralException { public MiniLangException ( ) { super ( ) ; } public MiniLangException ( String str ) { super ( str ) ; } public MiniLangException ( String str , Throwable nested ) { super ( str , nested ) ; }", "gt": "public MiniLangException ( Throwable nested )", "prediction": "}\n", "label": 0}
{"id": 3293, "input": "<s> package org . nuxeo . ecm . platform . task ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; @ XObject ( \"taskPersister\" ) public class TaskPersisterDescriptor { @ XNode", "gt": "( \"@path\" ) private String path ;", "prediction": ";\n", "label": 1}
{"id": 8231, "input": "<s> package com . redhat . ceylon . tools . help ; import org . tautua . markdownpapers . ast . CharRef ; import org . tautua . markdownpapers . ast . Code ; import org . tautua . markdownpapers . ast . CodeSpan ; import org . tautua . markdownpapers . ast . CodeText ; import org . tautua . markdownpapers . ast . Document ; import org . tautua . markdownpapers . ast . Emphasis ; import org . tautua . markdownpapers . ast . Header ; import org . tautua . markdownpapers . ast . Image ; import org . tautua . markdownpapers . ast . InlineUrl ; import org . tautua . markdownpapers . ast . Item ; import org . tautua . markdownpapers . ast . Line ; import org . tautua . markdownpapers . ast . LineBreak ; import org . tautua . markdownpapers . ast . Link ; import org . tautua . markdownpapers . ast . List ; import org . tautua . markdownpapers . ast . Node ; import org . tautua . markdownpapers . ast . Paragraph ; import org . tautua . markdownpapers . ast . Quote ; import org . tautua . markdownpapers . ast . Resource ; import org . tautua . markdownpapers . ast . Ruler ; import org . tautua . markdownpapers . ast . Tag ; import org . tautua . markdownpapers . ast . Text ; import com . redhat . ceylon . common . tool . WordWrap ; class PlaintextMarkdownVisitor extends AbstractMarkdownVisitor { private WordWrap out ; private int headerLevel = - 1 ; private boolean inCode ; public PlaintextMarkdownVisitor ( WordWrap out ) { this . out = out ; } @ Override public void visit ( Header node ) { final Node parent = node . jjtGetParent ( ) ; for ( int ii = 0 ; ii < parent . jjtGetNumChildren ( ) ; ii ++ ) { if ( parent . jjtGetChild ( ii ) == node ) { if ( ii == 0 ) { continue ; } } } switch ( node . getLevel ( ) ) { case 1 : case 2 : out . setIndent ( 0 ) ; break ; case 3 : out . setIndent ( 3 ) ; break ; case 4 : out . setIndent ( 5 ) ; break ; case 5 : out . setIndent ( 6 ) ; break ; case 6 : default : out . setIndent ( 7 ) ; break ; } if ( ! ( node . jjtGetParent ( ) instanceof Document && Markdown . getIndexInParent ( node ) == 0 ) ) { out . newline ( ) ; } switch ( node", "gt": ". getLevel ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 3308, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . client . view ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . platform . annotations . gwt . client . AnnotationConstant ; import org . nuxeo . ecm . platform . annotations . gwt . client . configuration . AnnotationDefinition ; import org . nuxeo . ecm . platform . annotations . gwt . client . configuration . WebConfiguration ; import org . nuxeo . ecm . platform . annotations . gwt . client . configuration . filter . TypeFilter ; import org . nuxeo . ecm . platform . annotations . gwt . client . controler . AnnotationController ; import org . nuxeo . ecm . platform . annotations . gwt . client . model . Annotation ; import org . nuxeo . ecm . platform . annotations . gwt . client . util . XPointerFactory ; import org . nuxeo . ecm . platform . annotations . gwt . client . view . i18n . TranslationConstants ; import com . allen_sauer . gwt . log . client . Log ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Document ; import com . google . gwt . dom . client . Element ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . Button ; import com . google . gwt . user . client . ui . ClickListener ; import com . google . gwt . user . client . ui . DockPanel ; import com . google . gwt . user . client . ui . HorizontalPanel ; import com . google . gwt . user . client . ui . KeyboardListenerAdapter ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . ListBox ; import com . google . gwt . user . client . ui . PopupPanel ; import com . google . gwt . user . client . ui . TextArea ; import com . google . gwt . user . client . ui . VerticalPanel ; import com . google . gwt . user . client . ui . Widget ; public class NewAnnotationPopup extends PopupPanel { private class AnnotationTextArea extends TextArea { public AnnotationTextArea ( ) { addKeyboardListener ( new KeyboardListenerAdapter ( ) { public void onKeyUp ( Widget sender , char keyCode , int modifiers ) { String content = getText ( ) ; if ( content . trim ( ) . equals ( \"\" ) ) { submit . setEnabled ( false ) ; } else { submit . setEnabled ( true ) ; } } @ SuppressWarnings ( \"deprecation\" ) @ Override public void onKeyPress ( Widget sender , char keyCode , int modifiers ) { TextArea ta = ( TextArea ) sender ; String content = ta . getText ( ) ; if ( Character . isLetterOrDigit ( keyCode ) || Character . isSpace ( keyCode ) ) { if ( content . length ( ) >= AnnotationConstant . MAX_ANNOTATION_TEXT_LENGTH ) { ta . cancelKey ( ) ; } } } } ) ; setCharacterWidth ( 30 ) ; setVisibleLines ( 6 ) ; } } private final AnnotationController controller ; public String selectedAnnotationType = null ; private final ListBox listBox = new ListBox ( ) ; private final List < ListBox > fieldListBoxes = new ArrayList < ListBox > ( ) ; private final", "gt": "VerticalPanel verticalPanel = new VerticalPanel ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2258, "input": "<s> package org . ofbiz . base . util . collections ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; public abstract class GenericMapCollection < K , V , M extends Map < K , V > , I > implements Collection < I > { protected final M source ; public GenericMapCollection ( M source ) { this . source = source ; } public boolean add ( I item ) { throw new UnsupportedOperationException ( ) ; } public boolean addAll ( Collection < ? extends I > collection ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { source . clear ( ) ; } public boolean containsAll ( Collection < ? > collection ) { for ( Object item : collection ) { if ( ! contains ( item ) ) return false ; } return true ; } public boolean isEmpty ( ) { return source . isEmpty ( ) ; } public final Iterator < I > iterator ( ) { return iterator ( true ) ; } protected abstract Iterator < I > iterator ( boolean noteAccess ) ; public boolean removeAll ( Collection < ? > collection ) { int count = 0 ; for ( Object item : collection ) { if ( remove ( item ) ) count ++ ; } return count > 0 ; } public boolean retainAll ( Collection < ? > collection ) { int count = 0 ; Iterator < I > it = iterator ( false ) ; while ( it . hasNext ( ) ) { I item = it . next ( ) ; if ( ! collection . contains ( item ) ) { it . remove ( ) ; count ++ ; } } return count > 0 ; } public int size ( ) { return source . size ( ) ; } public Object [ ] toArray ( ) { List < I > list = FastList . newInstance ( ) ; Iterator < I > it = iterator ( false ) ; while ( it . hasNext ( ) ) { list . add ( it . next ( ) ) ; } return list . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] array ) { List < Object > list = FastList . newInstance ( ) ; Iterator < I > it = iterator ( false ) ; while (", "gt": "it . hasNext ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 3324, "input": "<s> package org . nuxeo . ecm . webapp . notification . email ; import static org . jboss . seam . ScopeType . EVENT ; import java . io . Serializable ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . faces . context . FacesContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Out ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . international . StatusMessage ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . event . DocumentEventCategories ; import org . nuxeo . ecm . core . api . event . DocumentEventTypes ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventProducer ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; import org . nuxeo . ecm . platform . ec . notification . NotificationConstants ; import org . nuxeo . ecm . platform . types . adapter . TypeInfo ; import org . nuxeo . ecm . platform . usermanager . UserManager ; import org . nuxeo . ecm . webapp . base . InputController ; import org . nuxeo . ecm . webapp . security . PrincipalListManager ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"emailNotifSenderAction\" ) @ Scope ( EVENT ) public class EmailNotificationSenderActionsBean extends InputController implements EmailNotificationSenderActions , Serializable { private static final Log log = LogFactory . getLog ( EmailNotificationSenderActionsBean . class ) ; private static final long serialVersionUID = 2125646683248052737L ; @ In ( create = true ) transient UserManager userManager ; @ In ( create = true , required = false ) transient CoreSession documentManager ; @ In ( required = false ) @ Out ( required = false ) private String mailSubject ; @ In ( required = false ) @ Out ( required = false ) private String mailContent ; @ In ( required = false ) @ Out ( required = false ) private String currentDocumentFullUrl ; @ In ( create = true ) @ Out private PrincipalListManager principalListManager ; @ Out ( required = false ) private String fromEmail ; @ Out ( required = false ) private List < NuxeoPrincipal > toEmail ; public String send ( ) { if ( mailSubject == null || mailSubject . trim ( ) . length ( ) == 0 ) { facesMessages . add ( StatusMessage . Severity . ERROR , resourcesAccessor . getMessages ( ) . get ( \"label.email.subject.empty\" ) ) ; return null ; } if ( principalListManager . getSelectedUserListEmpty ( ) ) { facesMessages . add ( StatusMessage . Severity . ERROR , resourcesAccessor . getMessages ( ) . get ( \"label.email.nousers.selected\" ) ) ; return null ; } for ( String user : principalListManager . getSelectedUsers ( ) ) { try { sendNotificationEvent ( user , mailSubject , mailContent ) ; } catch ( ClientException e ) { facesMessages . add ( StatusMessage . Severity . ERROR , resourcesAccessor . getMessages ( ) . get ( \"label.email.send.failed\" ) ) ; return null ; } } facesMessages . add ( StatusMessage . Severity . INFO , resourcesAccessor . getMessages ( ) . get ( \"label.email.send.ok\" ) ) ; DocumentModel cDoc = navigationContext . getCurrentDocument ( ) ; if ( cDoc == null ) { return null ; } else { TypeInfo typeInfo = cDoc . getAdapter ( TypeInfo . class ) ; if ( typeInfo != null ) { return typeInfo . getDefaultView ( ) ; } else { return null ; } } } private void sendNotificationEvent ( String user , String theMailSubject , String theMailContent ) throws ClientException { Map < String , Serializable > options = new HashMap < String , Serializable > ( ) ; String prefix = principalListManager . getPrincipalType ( user ) == PrincipalListManager . USER_TYPE ? \"user:\" : \"group:\" ; String recipient = prefix + user ; options . put ( NotificationConstants . RECIPIENTS_KEY , new String [ ] { recipient } ) ; options . put ( \"subject\" , theMailSubject ) ; options . put ( \"content\" , theMailContent ) ; options . put ( \"category\" , DocumentEventCategories . EVENT_CLIENT_NOTIF_CATEGORY ) ; NuxeoPrincipal currentUser = ( NuxeoPrincipal ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getUserPrincipal ( ) ; DocumentEventContext ctx = new DocumentEventContext ( documentManager , currentUser , navigationContext . getCurrentDocument ( ) ) ; ctx . setProperties ( options ) ; Event event = ctx . newEvent ( DocumentEventTypes . EMAIL_DOCUMENT_SEND ) ;", "gt": "EventProducer evtProducer = null ;", "prediction": "}\n", "label": 1}
{"id": 9354, "input": "<s> package com . asakusafw . example . summarization . gateway ; import com . asakusafw . example . summarization . modelgen . dmdl . csv . AbstractReceiptCsvInputDescription ; public class ReceiptFromCSV extends AbstractReceiptCsvInputDescription {", "gt": "@ Override public String getBasePath ( )", "prediction": "( ) ;\n", "label": 0}
{"id": 3328, "input": "<s> package org . eclipse . ui . internal . keys ; import java . io . IOException ; import java . util . Collection ; import java . util . Map ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . jface . bindings . Binding ; import org . eclipse . jface . bindings . BindingManager ; import org . eclipse . jface . bindings . IBindingManagerListener ; import org . eclipse . jface . bindings . Scheme ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . jface . bindings . keys . SWTKeySupport ; import org . eclipse . jface . bindings . keys . formatting . KeyFormatterFactory ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . keys . IBindingService ; public final class BindingService implements IBindingService { private final BindingManager bindingManager ; private final BindingPersistence bindingPersistence ; private WorkbenchKeyboard keyboard ; private IWorkbench workbench ; public BindingService ( final BindingManager bindingManager , final ICommandService commandService , final IWorkbench workbench ) { if ( bindingManager == null ) { throw new NullPointerException ( \"Cannot create a binding service with a null manager\" ) ; } if ( commandService == null ) { throw new NullPointerException ( \"Cannot create a binding service with a null command service\" ) ; } this . bindingManager = bindingManager ; this . workbench = workbench ; this . bindingPersistence = new BindingPersistence ( bindingManager , commandService ) ; keyboard = new WorkbenchKeyboard ( workbench ) ; final Display display = workbench . getDisplay ( ) ; final Listener listener = keyboard . getKeyDownFilter ( ) ; display . addFilter ( SWT . KeyDown , listener ) ; KeyFormatterFactory . setDefault ( SWTKeySupport . getKeyFormatterForPlatform ( ) ) ; } public final void addBinding ( final Binding binding ) { bindingManager . addBinding ( binding ) ; } public final void dispose ( ) { if ( keyboard == null || workbench == null ) return ; final Listener listener = keyboard . getKeyDownFilter ( ) ; final Display display = workbench . getDisplay ( ) ; if ( display != null ) { display . removeFilter ( SWT . KeyDown , listener ) ; display . removeFilter (", "gt": "SWT . Traverse , listener ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4192, "input": "<s> package org . ofbiz . entityext . eca ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . service . DispatchContext ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class EntityEcaCondition implements java . io . Serializable { public static final String module = EntityEcaCondition . class . getName ( ) ; protected String lhsValueName , rhsValueName ; protected String operator ; protected String compareType ; protected String format ; protected boolean constant = false ; protected EntityEcaCondition ( ) { } public EntityEcaCondition ( Element condition , boolean constant ) { this . lhsValueName = condition . getAttribute ( \"field-name\" ) ; this . constant = constant ; if ( constant ) { this . rhsValueName = condition . getAttribute ( \"value\" ) ; } else { this . rhsValueName = condition . getAttribute ( \"to-field-name\" ) ; } this . operator = condition . getAttribute ( \"operator\" ) ; this . compareType = condition . getAttribute ( \"type\" ) ; this . format = condition . getAttribute ( \"format\" ) ; if ( lhsValueName == null ) lhsValueName = \"\" ; if ( rhsValueName == null ) rhsValueName = \"\" ; } public boolean eval ( DispatchContext dctx , GenericEntity value ) throws GenericEntityException { if ( dctx == null || value == null || dctx . getClassLoader ( ) == null ) { throw new GenericEntityException ( \"Cannot have null Value or DispatchContext!\" ) ; } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( this . toString ( ) , module ) ; Object lhsValue = value . get ( lhsValueName ) ; Object rhsValue ; if ( constant ) { rhsValue = rhsValueName ; } else { rhsValue = value . get ( rhsValueName ) ; } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Comparing : \" + lhsValue + \" \" + operator + \" \" + rhsValue , module ) ; List < Object > messages = FastList . newInstance ( ) ; Boolean cond = ObjectType . doRealCompare ( lhsValue , rhsValue , operator , compareType , format , messages , null , dctx . getClassLoader ( ) , constant ) ; if ( messages . size ( ) > 0 ) { for ( Object message : messages ) { Debug . logWarning ( ( String ) message , module ) ; } } if ( cond != null ) { return cond . booleanValue ( ) ; } else { return false ; } } @ Override public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( \"[\" ) . append ( lhsValueName ) . append ( \"]\" ) ; buf . append ( \"[\" ) . append ( operator ) . append ( \"]\" ) ; buf . append ( \"[\" ) . append ( rhsValueName ) . append ( \"]\" ) ; buf . append ( \"[\" ) . append ( constant ) . append ( \"]\" ) ; buf . append ( \"[\" ) . append ( compareType ) . append ( \"]\" ) ; buf . append ( \"[\" ) . append ( format ) . append ( \"]\" ) ;", "gt": "return buf . toString ( ) ;", "prediction": "}\n", "label": 0}
{"id": 3359, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . certificate ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public", "gt": "void setContent ( String content )", "prediction": "}\n", "label": 1}
{"id": 7204, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class LimitsTest extends XtextTest { @ Test public void testDailyMaxLimits ( ) { testParserRule ( \"limits { dailymax 2h weeklymax 6h monthlymax 2.5d }\" , \"Limits\" ) ; } @ Test public void testCompoundLimits ( ) { testParserRule ( \"limits { maximum 4h { end 2011-10-10 start 2011-10-10 } weeklymax 6h }\" , \"Limits\" ) ; } @", "gt": "Test public void testMaxLimitsByDay ( )", "prediction": "}\n", "label": 0}
{"id": 3360, "input": "<s> package com . rabbitmq . messagepatterns . unicast ; public interface ReceivedMessage extends Message {", "gt": "public boolean isRedelivered ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 5085, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . WeekStarts ; public class WeekStartsImpl extends ProjectAttributeImpl implements WeekStarts { protected static final boolean SUNDAY_EDEFAULT = false ; protected boolean sunday = SUNDAY_EDEFAULT ; protected static final boolean MONDAY_EDEFAULT = false ; protected boolean monday = MONDAY_EDEFAULT ; protected WeekStartsImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getWeekStarts ( ) ; } public boolean isSunday ( ) { return sunday ; } public void setSunday ( boolean newSunday ) { boolean oldSunday = sunday ; sunday = newSunday ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . WEEK_STARTS__SUNDAY , oldSunday , sunday ) ) ; } public boolean isMonday ( ) { return monday ; } public void setMonday ( boolean newMonday ) { boolean oldMonday = monday ; monday = newMonday ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . WEEK_STARTS__MONDAY , oldMonday , monday ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . WEEK_STARTS__SUNDAY : return isSunday ( ) ; case ProjectPackage . WEEK_STARTS__MONDAY : return isMonday ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . WEEK_STARTS__SUNDAY : setSunday ( ( Boolean ) newValue ) ; return ; case ProjectPackage . WEEK_STARTS__MONDAY : setMonday ( ( Boolean ) newValue ) ; return ; } super", "gt": ". eSet ( featureID , newValue ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3380, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . secret ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; }", "gt": "public void setContent ( String content )", "prediction": "}\n", "label": 1}
{"id": 8724, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . CellText ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class CellTextImpl extends ColumnAttributeImpl implements CellText { protected static final String TEXT_EDEFAULT = null ; protected String text = TEXT_EDEFAULT ; protected LogicalExpression expresssion ; protected CellTextImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getCellText ( ) ; } public String getText ( ) { return text ; } public void setText ( String newText ) { String oldText = text ; text = newText ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . CELL_TEXT__TEXT , oldText , text ) ) ; } public LogicalExpression getExpresssion ( ) { return expresssion ; } public NotificationChain basicSetExpresssion ( LogicalExpression newExpresssion , NotificationChain msgs ) { LogicalExpression oldExpresssion = expresssion ; expresssion = newExpresssion ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . CELL_TEXT__EXPRESSSION , oldExpresssion , newExpresssion ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpresssion ( LogicalExpression newExpresssion ) { if ( newExpresssion != expresssion ) { NotificationChain msgs = null ; if ( expresssion != null ) msgs = ( ( InternalEObject ) expresssion ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . CELL_TEXT__EXPRESSSION , null , msgs ) ; if ( newExpresssion != null ) msgs = ( ( InternalEObject ) newExpresssion ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . CELL_TEXT__EXPRESSSION , null , msgs ) ; msgs = basicSetExpresssion ( newExpresssion , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . CELL_TEXT__EXPRESSSION , newExpresssion , newExpresssion ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . CELL_TEXT__EXPRESSSION : return basicSetExpresssion ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . CELL_TEXT__TEXT : return getText ( ) ; case ProjectPackage . CELL_TEXT__EXPRESSSION : return getExpresssion ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . CELL_TEXT__TEXT : setText", "gt": "( ( String ) newValue ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3395, "input": "<s> package org . apache . lucene . queryParser . surround . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermEnum ; import org . apache . lucene . index . IndexReader ; import java . io . IOException ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; public class SrndTruncQuery extends SimpleTerm { public SrndTruncQuery ( String truncated , char unlimited , char mask ) { super ( false ) ; this . truncated = truncated ; this . unlimited = unlimited ; this . mask = mask ; truncatedToPrefixAndPattern ( ) ; } private final String truncated ; private final char unlimited ; private final char mask ; private String prefix ; private Pattern pattern ; public String getTruncated ( ) { return truncated ; } public String toStringUnquoted ( ) { return getTruncated ( ) ; } protected boolean matchingChar ( char c ) { return ( c != unlimited ) && ( c != mask ) ; } protected void appendRegExpForChar ( char c , StringBuffer re ) { if ( c == unlimited ) re . append ( \".*\" ) ; else if ( c == mask ) re . append ( \".\" ) ; else re . append ( c ) ; } protected void truncatedToPrefixAndPattern ( ) { int i = 0 ; while ( ( i < truncated . length ( ) ) && matchingChar ( truncated . charAt ( i ) ) ) { i ++ ; } prefix = truncated . substring ( 0 , i ) ; StringBuffer re = new StringBuffer ( ) ; while ( i < truncated . length ( ) ) { appendRegExpForChar ( truncated . charAt ( i ) , re ) ; i ++ ; } pattern = Pattern . compile ( re . toString ( ) ) ; } public void visitMatchingTerms ( IndexReader reader , String fieldName , MatchingTermVisitor mtv ) throws IOException { boolean expanded = false ; int prefixLength = prefix . length ( ) ; TermEnum enumerator = reader . terms ( new Term ( fieldName , prefix ) ) ; Matcher matcher = pattern . matcher ( \"\" ) ; try { do { Term term = enumerator . term ( ) ; if ( term != null ) { String text = term . text ( ) ; if ( ( ! text . startsWith ( prefix ) ) || ( ! term . field ( ) . equals ( fieldName ) ) ) { break ; } else { matcher . reset ( text . substring ( prefixLength ) ) ; if ( matcher . matches ( ) ) { mtv . visitMatchingTerm ( term ) ; expanded = true ; } } } } while ( enumerator . next ( ) ) ; } finally { enumerator . close ( ) ;", "gt": "matcher . reset ( ) ;", "prediction": "}\n", "label": 1}
{"id": 9437, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Snowman ; public interface LizaSnowman extends Snowman { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet <", "gt": "Byte > transparent , int maxDistance ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3403, "input": "<s> package org . apache . lucene . store . instantiated ; import java . io . IOException ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermEnum ; import org . apache . lucene . index . TermPositionVector ; import org . apache . lucene . index . TermPositions ; import org . apache . lucene . util . BitVector ; public class InstantiatedIndex implements Serializable { private static final long serialVersionUID = 1l ; private long version = System . currentTimeMillis ( ) ; private InstantiatedDocument [ ] documentsByNumber ; private BitVector deletedDocuments ; private Map < String , Map < String , InstantiatedTerm > > termsByFieldAndText ; private InstantiatedTerm [ ] orderedTerms ; private Map < String , byte [ ] > normsByFieldNameAndDocumentNumber ; private FieldSettings fieldSettings ; public InstantiatedIndex ( ) { initialize ( ) ; } void initialize ( ) { termsByFieldAndText = new HashMap < String , Map < String , InstantiatedTerm > > ( ) ; fieldSettings = new FieldSettings ( ) ; orderedTerms = new InstantiatedTerm [ 0 ] ; documentsByNumber = new InstantiatedDocument [ 0 ] ; normsByFieldNameAndDocumentNumber = new HashMap < String , byte [ ] > ( ) ; } public InstantiatedIndex ( IndexReader sourceIndexReader ) throws IOException { this ( sourceIndexReader , null ) ; } public InstantiatedIndex ( IndexReader sourceIndexReader , Set < String > fields ) throws IOException { if ( ! sourceIndexReader . isOptimized ( ) ) { System . out . println ( ( \"Source index is not optimized.\" ) ) ; } initialize ( ) ; Collection < String > allFieldNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . ALL ) ; Collection < String > indexedNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . INDEXED ) ; for ( String name : indexedNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . indexed = true ; } Collection < String > indexedNoVecNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . INDEXED_NO_TERMVECTOR ) ; for ( String name : indexedNoVecNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storeTermVector = false ; setting . indexed = true ; } Collection < String > indexedVecNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . INDEXED_WITH_TERMVECTOR ) ; for ( String name : indexedVecNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storeTermVector = true ; setting . indexed = true ; } Collection < String > payloadNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . STORES_PAYLOADS ) ; for ( String name : payloadNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storePayloads = true ; } Collection < String > termVecNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . TERMVECTOR ) ; for ( String name : termVecNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storeTermVector = true ; } Collection < String > termVecOffsetNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . TERMVECTOR_WITH_OFFSET ) ; for ( String name : termVecOffsetNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storeOffsetWithTermVector = true ; } Collection < String > termVecPosNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . TERMVECTOR_WITH_POSITION ) ; for ( String name : termVecPosNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storePositionWithTermVector = true ; } Collection < String > termVecPosOffNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . TERMVECTOR_WITH_POSITION_OFFSET ) ; for ( String name : termVecPosOffNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . storeOffsetWithTermVector = true ; setting . storePositionWithTermVector = true ; } Collection < String > unindexedNames = sourceIndexReader . getFieldNames ( IndexReader . FieldOption . UNINDEXED ) ; for ( String name : unindexedNames ) { FieldSetting setting = fieldSettings . get ( name , true ) ; setting . indexed = false ; } documentsByNumber = new InstantiatedDocument [ sourceIndexReader . maxDoc ( ) ] ; if ( sourceIndexReader . hasDeletions ( ) ) { deletedDocuments = new BitVector ( sourceIndexReader . maxDoc ( ) ) ; } for ( int i = 0 ; i <", "gt": "sourceIndexReader . maxDoc ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6472, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Report ; import org . jjflyboy . tjpeditor . project . ReportPrefix ; public class ReportPrefixImpl extends IncludePropertiesAttributeImpl implements ReportPrefix { protected Report report ; protected ReportPrefixImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getReportPrefix ( ) ; } public Report getReport ( ) { if ( report != null && report . eIsProxy ( ) ) { InternalEObject oldReport = ( InternalEObject ) report ; report = ( Report ) eResolveProxy ( oldReport ) ; if ( report != oldReport ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . REPORT_PREFIX__REPORT , oldReport , report ) ) ; } } return report ; } public Report basicGetReport ( ) { return report ; } public void setReport ( Report newReport ) { Report oldReport = report ; report = newReport ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . REPORT_PREFIX__REPORT , oldReport , report ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . REPORT_PREFIX__REPORT : if ( resolve ) return getReport ( ) ; return basicGetReport ( ) ; } return super", "gt": ". eGet ( featureID , resolve , coreType ) ;", "prediction": ";\n", "label": 0}
{"id": 3406, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; public class StringToInteger implements TypeAdapter { public Object getAdaptedValue ( OperationContext ctx", "gt": ", Object objectToAdapt ) throws TypeAdaptException", "prediction": ")\n", "label": 1}
{"id": 266, "input": "<s> package com . sun . mirror . type ; import java . util . Collection ; import com . sun . mirror . declaration . TypeDeclaration ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface DeclaredType extends ReferenceType { TypeDeclaration getDeclaration ( ) ; DeclaredType getContainingType ( ) ; Collection < TypeMirror > getActualTypeArguments ( ) ; Collection < InterfaceType", "gt": "> getSuperinterfaces ( ) ;", "prediction": ";\n", "label": 0}
{"id": 3448, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import javax . ws . rs . Path ; import javax . ws . rs . core . Application ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . ClientInfo ; import org . restlet . data . Conditions ; import org . restlet . data . Cookie ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; import org . restlet . data . Preference ; import org . restlet . data . Protocol ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . header . Header ; import org . restlet . ext . jaxrs . JaxRsApplication ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . representation . Representation ; import org . restlet . test . ext . jaxrs . server . RestletServerTestCase ; import org . restlet . test . ext . jaxrs . util . OrderedReadonlySet ; import org . restlet . test . ext . jaxrs . util . TestUtils ; @ SuppressWarnings ( \"all\" ) public abstract class JaxRsTestCase extends RestletServerTestCase { public static void assertAllowedMethod ( Response optionsResponse , Method ... methods ) { if ( optionsResponse . getStatus ( ) . isError ( ) ) { assertEquals ( Status . SUCCESS_OK , optionsResponse . getStatus ( ) ) ; } final Set < Method > expectedMethods = new HashSet < Method > ( Arrays . asList ( methods ) ) ; if ( expectedMethods . contains ( Method . GET ) ) { expectedMethods . add ( Method . HEAD ) ; } final List < Method > allowedMethods = new ArrayList < Method > ( optionsResponse . getAllowedMethods ( ) ) ; for ( final Method method : methods ) { assertTrue ( \"allowedMethod must contain \" + method , allowedMethods . contains ( method ) ) ; } assertEquals ( \"allowedMethods.size invalid\" , expectedMethods . size ( ) , allowedMethods . size ( ) ) ; } public static void assertEmptyEntity ( Response response ) throws IOException { if ( response . getEntity ( ) != null ) { assertEquals ( null , response . getEntity ( ) . getText ( ) ) ; } } public static void assertEqualMediaType ( MediaType expected , MediaType actual ) { expected = Converter . getMediaTypeWithoutParams ( expected ) ; actual = Converter . getMediaTypeWithoutParams ( actual ) ; assertEquals ( expected , actual ) ; } public static void assertEqualMediaType ( MediaType expected , Representation actualEntity ) { if ( actualEntity == null ) fail ( \"The entity must not be null, if a media type should be read\" ) ; assertEqualMediaType ( expected , actualEntity . getMediaType ( ) ) ; } public static void assertEqualMediaType ( MediaType expected , Response actualResponse ) { if ( actualResponse == null ) fail ( \"The response must not be null, if an entity should be read\" ) ; assertEqualMediaType ( expected , actualResponse . getEntity ( ) ) ; } public static Collection < Preference < MediaType > > createPrefColl ( MediaType accMediaType , float mediaTypeQuality ) { if ( accMediaType == null ) { return Collections . emptyList ( ) ; } return Collections . singleton ( new Preference < MediaType > ( accMediaType , mediaTypeQuality ) ) ; } public static boolean jaxRxImplementorCheck ( int dayOfMonth , int month ) { return jaxRxImplementorCheck ( dayOfMonth , month , 2009 ) ; } public static boolean jaxRxImplementorCheck ( int dayOfMonth , int month , int year ) { final Date afterDate = new Date ( year - 1900 , month - 1 , dayOfMonth ) ; if", "gt": "( new Date ( ) . after ( afterDate ) )", "prediction": "( )\n", "label": 1}
{"id": 1206, "input": "<s> interface A { int m ( ) ; } interface B { String m ( ) ; } interface", "gt": "TypesIncompatible extends A , B", "prediction": "\n", "label": 0}
{"id": 3453, "input": "<s> package org . eclipse . xtext . xdoc . util ; import java . io . File ; public interface ParserTestConstants { public static final String TEST_FILE_DIR = \"testfiles\" + File . separatorChar ; public static final String DNL = \"\\n\\n\" ; public static final String CHAPTER_HEAD = \"chapter[foo]\\n\\n\" ; public", "gt": "static final String DOC_HEAD = \"document[foo]\\n\\n\" ;", "prediction": "void ( ) ;\n", "label": 1}
{"id": 6885, "input": "<s> package com . redhat . ceylon . compiler . java . util ; import java . util . HashMap ; import java . util . Map ; import com . sun . tools . javac . main . OptionName ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . Options ; public class Timer { private long programStart ; private String currentTask ; private long currentTaskStart ; private boolean verbose ; private final Map < String , IgnoredCategory > ignoredCategories = new HashMap < String , IgnoredCategory > ( ) ; private static final Context . Key < Timer > timerKey = new Context . Key < Timer > ( ) ; public static Timer instance ( Context context ) { Timer instance = ( Timer ) context . get ( timerKey ) ; if ( instance == null ) { instance = new Timer ( context ) ; context . put ( timerKey , instance ) ; } return instance ; } public Timer ( boolean verbose ) { setup ( verbose ) ; } private Timer ( Context context ) { Options options = Options . instance ( context ) ; verbose = options . get ( OptionName . VERBOSE ) != null || options . get ( OptionName . VERBOSE + \":benchmark\" ) != null ; } private void setup ( boolean verbose ) { } public void init ( ) { programStart = System . currentTimeMillis ( ) ; if ( verbose ) log ( \"Program start\" , programStart ) ; } public void end ( ) { if ( ! verbose ) return ; log ( \"Program end\" ) ; } public void startTask ( String name ) { if ( ! verbose ) return ; if ( currentTask != null ) endTask ( ) ; currentTask = name ; currentTaskStart = System . currentTimeMillis ( ) ; log ( \"Task \" + currentTask + \" start\" ) ; } public void log ( String string ) { if ( ! verbose ) return ; log ( string , System . currentTimeMillis ( ) ) ; } private void log ( String string , long now ) { long delta = now - programStart ; System . err . println ( \"[\" + delta + \"ms] \" + string ) ; } public void endTask ( ) { if ( ! verbose ) return ; long time = System . currentTimeMillis ( ) ; long delta = time - currentTaskStart ; log ( \"Task \" + currentTask + \" end: \" + delta + \"ms\" ) ; printIgnoredCategories ( ) ; currentTask = null ; } public void startIgnore ( String category ) { if ( ! verbose ) return ; IgnoredCategory ignoredCategory = ignoredCategories . get ( category ) ;", "gt": "if ( ignoredCategory == null )", "prediction": "}\n", "label": 0}
{"id": 3465, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; public interface ITableItemAdapter { Color [ ] getCellBackgrounds ( ) ; Color [ ] getCellForegrounds ( ) ; Font [", "gt": "] getCellFonts ( ) ;", "prediction": "\n", "label": 1}
{"id": 2777, "input": "<s> package org . remast . util ; import java . text . MessageFormat ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import org . apache . commons . lang . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public final class TextResourceBundle { private static final Logger log = LoggerFactory . getLogger ( TextResourceBundle . class ) ; private ResourceBundle resourceBundle = null ; private Class < ? > clazz ; private TextResourceBundle ( final Class < ? > clazz ) { if ( clazz == null ) { throw new IllegalArgumentException ( \"Parameter clazz may not be null.\" ) ; } this . clazz = clazz ; try { final String [ ] superPackageNames = StringUtils . split ( clazz . getPackage ( ) . getName ( ) , '.' ) ; String currentPackageName = \"\" ; if ( superPackageNames . length > 0 ) { currentPackageName = superPackageNames [ superPackageNames . length - 1 ] ; } resourceBundle = ResourceBundle . getBundle ( clazz . getPackage ( ) . getName ( ) + \".\" + StringUtils . capitalize ( currentPackageName ) + \"Texts\" , Locale . getDefault ( ) , clazz . getClassLoader ( ) ) ; } catch ( MissingResourceException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; } } public static TextResourceBundle getBundle ( final Class < ? > clazz ) { if ( clazz == null ) { throw new IllegalArgumentException ( \"Parameter clazz may not be null.\" ) ; } final TextResourceBundle textBundle = new TextResourceBundle ( clazz ) ; return textBundle ; } public String textFor ( final String key ) { try { if ( resourceBundle == null ) { return '!' + key + '!' ; } return resourceBundle . getString ( key ) ; } catch ( MissingResourceException e ) { log . error ( \"Could not resolve text for class \" + clazz . getName ( ) + \" and key \\\"\" + key + \"\\\".\" , e ) ; return '!' + key + '!' ; } } public String textFor ( final String key ,", "gt": "final Object ... arguments )", "prediction": ")\n", "label": 0}
{"id": 3483, "input": "<s> package org . eclipse . ui . part ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . util . Tracing ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . jface . dialogs . IPageChangeProvider ; import org . eclipse . jface . dialogs . IPageChangedListener ; import org . eclipse . jface . dialogs . PageChangedEvent ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . TraverseEvent ; import org . eclipse . swt . events . TraverseListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Item ; import org . eclipse . ui . IEditorActionBarContributor ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IPartService ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . handlers . IHandlerService ; import org . eclipse . ui . internal . PartSite ; import org . eclipse . ui . internal . misc . Policy ; import org . eclipse . ui . internal . services . INestable ; import org . eclipse . ui . internal . services . IServiceLocatorCreator ; import org . eclipse . ui . internal . util . Util ; import org . eclipse . ui . services . IDisposable ; import org . eclipse . ui . services . IServiceLocator ; public abstract class MultiPageEditorPart extends EditorPart implements IPageChangeProvider { private static final String COMMAND_NEXT_SUB_TAB = \"org.eclipse.ui.navigate.nextSubTab\" ; private static final String COMMAND_PREVIOUS_SUB_TAB = \"org.eclipse.ui.navigate.previousSubTab\" ; protected static final", "gt": "int PAGE_CONTAINER_SITE = 65535 ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1804, "input": "<s> package ar . com . fdvs . dj . test . domain ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class Statistic { private Date date ; private String name ; private float percentage ; private float average ; private float amount ; public static List dummy3 = new ArrayList ( ) ; static { dummy3 . add ( new DummyLevel3 ( \"name1\" , new Long ( 1 ) ) ) ; dummy3 . add ( new DummyLevel3 ( \"name2\" , new Long ( 2 ) ) ) ; dummy3 . add ( new DummyLevel3 ( \"name3\" , new Long ( 3 ) ) ) ; dummy3 . add ( new DummyLevel3 ( \"name3\" , new Long ( 4 ) ) ) ; } public Statistic ( ) { super ( ) ; } public Statistic ( Date date , String name , float percentage , float average , float amount ) { super ( ) ; this . date = date ; this . name = name ;", "gt": "this . percentage = percentage ;", "prediction": "}\n", "label": 0}
{"id": 3484, "input": "<s> package org . nuxeo . ecm . automation . core . operations . services ; import java . util . List ; import java . util . Locale ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . nuxeo . common . utils . i18n . I18NUtils ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . impl . blob . ByteArrayBlob ; import org . nuxeo . ecm . platform . actions . Action ; import org . nuxeo . ecm . platform . actions . ActionContext ; import org . nuxeo . ecm . platform . actions . ejb . ActionManager ; @ Operation ( id = GetActions . ID , category = Constants . CAT_SERVICES , label = \"List available actions\" , description = \"Retrieve list of available actions for a given category. Action context is built based on the Operation context (currentDocument will be fetched from Context if not provided as input). If this operation is executed in a chain that initialized the Seam context, it will be used for Action context\" ) public class GetActions { private static final String SEAM_ACTION_CONTEXT = \"seamActionContext\" ; public static final String ID = \"Actions.GET\" ; @ Context protected CoreSession session ; @ Context protected OperationContext ctx ; @ Context protected AutomationService automation ; @ Context protected ActionManager actionService ; @ Param ( name = \"category\" , required = true ) protected String category ; @ Param ( name = \"lang\" , required = false ) protected String lang ; protected DocumentModel getCurrentDocumentFromContext ( ) throws Exception { String cdRef = ( String ) ctx . get ( \"currentDocument\" ) ; return automation . getAdaptedValue ( ctx , cdRef , DocumentModel . class ) ; } protected ActionContext getActionContext ( DocumentModel currentDocument ) throws Exception { if ( ctx . containsKey ( SEAM_ACTION_CONTEXT ) ) { return ( ActionContext ) ctx . get ( SEAM_ACTION_CONTEXT ) ; } ActionContext actionContext = new ActionContext ( ) ; actionContext . setDocumentManager ( session ) ; actionContext . setCurrentPrincipal ( ( NuxeoPrincipal ) session . getPrincipal ( ) ) ; if ( currentDocument != null ) { actionContext . setCurrentDocument ( currentDocument ) ; } else { actionContext . setCurrentDocument ( getCurrentDocumentFromContext ( ) ) ; } actionContext . putAll ( ctx ) ; return actionContext ; } protected Locale getLocale ( ) { if ( lang == null ) { lang = ( String ) ctx . get ( \"lang\" ) ; } if ( lang == null ) { lang = \"en\" ; } return new Locale ( lang ) ; } protected String", "gt": "translate ( String key )", "prediction": "( )\n", "label": 1}
{"id": 3444, "input": "<s> package org . dawb . workbench . ui . project ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . jface . dialogs . IDialogPage ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . wizard . WizardPage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; public class DataNewProjectWizardPage extends WizardPage { private Text projectName ; private Button examples ; private ISelection selection ; public DataNewProjectWizardPage ( ISelection selection ) { super ( \"wizardPage\" ) ; setTitle ( \"Create new data project\" ) ; setDescription ( \"A project marked as a data project.\" ) ; this . selection = selection ; } public void createControl ( Composite parent ) { Composite container = new Composite ( parent , SWT . NULL ) ; GridLayout layout = new GridLayout ( ) ; container . setLayout ( layout ) ; layout . numColumns = 2 ; layout . verticalSpacing = 9 ; Label lblprojectName = new Label ( container , SWT . NULL ) ; lblprojectName . setText ( \"&Project name:\" ) ; projectName = new Text ( container , SWT . BORDER | SWT . SINGLE ) ; projectName . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , false , false , 1 , 1 ) ) ; projectName . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; projectName . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { dialogChanged ( ) ; } } ) ; Label lblExamples = new Label ( container , SWT . NULL ) ; lblExamples . setText ( \"&Create example data\" ) ; examples = new Button ( container , SWT . CHECK ) ; examples . setSelection ( false ) ; dialogChanged ( ) ; setControl ( container ) ; } private void dialogChanged ( ) { final String projectName = getProjectName ( ) ; if ( projectName == null || \"\" . equals ( projectName ) ) { updateStatus ( \"Please set the project name\" ) ; return ; } final IProject project = ResourcesPlugin . getWorkspace ( ) . getRoot (", "gt": ") . getProject ( projectName ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3492, "input": "<s> package litil . lexer ; import java . util . * ; public class StructuredLexer implements Lexer { private final Lexer lexer ; private final String indentUnit ; private int lastIndent = 0 ; private Deque < Token > tokens = new LinkedList < Token > ( ) ; public StructuredLexer ( Lexer lexer , String indentUnit ) { this . lexer = lexer ; this . indentUnit = indentUnit ; } public Token pop ( ) throws LexingException { if ( ! tokens . isEmpty ( ) ) { return tokens . poll ( ) ; } Token tk = lexer . pop ( ) ; if ( tk . type == Token . Type . INDENT ) { int iSize = indentSize ( tk . text ) ; if ( iSize == - 1 ) { System . err . println ( tk ) ; throw new LexingException ( \"Invalid line indentation width (\" + tk . text . length ( ) + \", not a multiple of \" + indentUnit . length ( ) + \")\" , getCurrentLine ( ) , tk . row , tk . col ) ; } else if ( iSize - lastIndent > 1 ) { throw new LexingException ( \"Invalid indent level (increased by \" + ( iSize - lastIndent ) + \")\" , getCurrentLine ( ) , tk . row , tk . col ) ; } lastIndent = iSize ; return tk ; } else if ( tk . type == Token . Type . DEINDENT ) { int diSize = indentSize ( tk . text ) ; if ( diSize == - 1 ) { throw new LexingException ( \"Invalid line indentation width (\" + tk . text . length ( ) + \", not a multiple of \" + indentUnit . length ( ) + \")\" , getCurrentLine ( ) , tk . row , tk . col ) ; } if ( lastIndent - diSize > 0 ) { produceVirtualIndents ( lastIndent , diSize , tk ) ; lastIndent = diSize ; return tokens . poll ( ) ; } } else if ( tk . type == Token . Type . EOF ) { if ( lastIndent > 1 ) { produceVirtualIndents ( lastIndent , 0 , tk ) ; lastIndent = 0 ; return tokens . poll ( ) ; } } return tk ; } private void produceVirtualIndents ( int fromLevel , int toLevel , Token tk ) { for ( int i = 0 ; i < fromLevel - toLevel ; i ++ ) { int level = fromLevel - toLevel - i - 1 ; tokens . addLast ( new Token ( Token . Type . DEINDENT , genIndent ( level ) , tk . row , tk . col ) ) ; } } private String genIndent ( int size ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i ++ ) { res . append ( indentUnit ) ; } return res . toString ( ) ; }", "gt": "private int indentSize ( String indent )", "prediction": "}\n", "label": 1}
{"id": 1675, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . AccountShare ; import org . jjflyboy . tjpeditor . project . ChargeSet ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ChargeSetImpl extends TaskAttributeImpl implements ChargeSet { protected EList < AccountShare > accountShares ; protected ChargeSetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getChargeSet ( ) ; } public EList < AccountShare > getAccountShares ( ) { if ( accountShares == null ) { accountShares = new EObjectContainmentEList < AccountShare > ( AccountShare . class , this , ProjectPackage . CHARGE_SET__ACCOUNT_SHARES ) ; } return accountShares ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . CHARGE_SET__ACCOUNT_SHARES : return ( ( InternalEList < ? > ) getAccountShares ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . CHARGE_SET__ACCOUNT_SHARES : return getAccountShares ( ) ; } return super", "gt": ". eGet ( featureID , resolve , coreType ) ;", "prediction": ";\n", "label": 0}
{"id": 3504, "input": "<s> package org . nuxeo . ecm . automation . client . model ; import java . io . Serializable ; import java . util . Date ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; public class PropertyMap implements Serializable { private static final long serialVersionUID = - 3260084599278006841L ; protected final LinkedHashMap < String , Object > map ; public PropertyMap ( ) { map = new LinkedHashMap < String , Object > ( ) ; } public PropertyMap ( PropertyMap props ) { map = new LinkedHashMap < String , Object > ( props . map ) ; } public PropertyMap ( Map < String , Object > map ) { this . map = new LinkedHashMap < String , Object > ( map ) ; } public PropertyMap ( int size ) { map = new LinkedHashMap < String , Object > ( size ) ; } public String getString ( String key ) { return getString ( key , null ) ; } public Boolean getBoolean ( String key ) { return getBoolean ( key , null ) ; } public Long getLong ( String key ) { return getLong ( key , null ) ; } public Double getDouble ( String key ) { return getDouble ( key , null ) ; } public Date getDate ( String key ) { return getDate ( key , null ) ; } public PropertyList getList ( String key ) { return getList ( key , null ) ; } public PropertyMap getMap ( String key ) { return getMap ( key , null ) ; } public String getString ( String key , String defValue ) { return PropertiesHelper . getString ( map . get ( key ) , defValue ) ; } public Blob getBlob ( String key ) { Object v = map . get ( key ) ; if ( v == null ) { return null ; } if ( v instanceof Blob ) { return ( Blob ) v ; } throw new IllegalArgumentException ( \"Property '\" + key + \"' is not a blob\" ) ; } public Boolean getBoolean ( String key , Boolean defValue ) { return PropertiesHelper . getBoolean ( map . get ( key ) , defValue ) ; } public Long getLong ( String key , Long defValue ) { return PropertiesHelper . getLong ( map . get ( key ) , defValue ) ; } public Double getDouble ( String key , Double defValue ) { return PropertiesHelper . getDouble ( map . get ( key ) , defValue ) ; } public Date getDate ( String key , Date defValue ) { return PropertiesHelper . getDate ( map . get ( key ) , defValue ) ; } public PropertyList getList ( String key , PropertyList defValue ) { return PropertiesHelper . getList ( map . get ( key ) , defValue ) ; } public PropertyMap getMap ( String key , PropertyMap defValue ) { return PropertiesHelper . getMap ( map . get ( key ) , defValue ) ; } public Object get ( String key ) { return map . get ( key ) ; } public Set < String > getKeys ( ) { return map . keySet ( ) ; } public int size ( ) { return map . size ( ) ; } public boolean isEmpty ( ) { return map . isEmpty ( ) ; } public void set ( String key , String value ) { if ( value == null ) { map . remove ( key ) ; } map . put ( key , value ) ; } public void set ( String key , Boolean value ) { if ( value == null ) { map . remove ( key ) ; } map . put ( key , value . toString ( ) ) ; } public void set ( String key , Long value ) { if ( value == null ) { map . remove ( key ) ; } map . put ( key , value . toString ( ) ) ; } public void set ( String key , Double value ) { if ( value == null ) { map . remove ( key ) ; } map . put ( key , value . toString ( ) ) ; } public void set ( String key , Date value ) { if ( value == null ) { map", "gt": ". remove ( key ) ;", "prediction": "\n", "label": 1}
{"id": 92, "input": "<s> abstract public class T5049523 { abstract < T > T choose ( boolean b , T t1 , T t2 ) ; abstract < T > Class < ? extends T > m ( Class < T > c ) ; < T > void test ( Class < ? extends T > clazz ) { boolean b = clazz . isInterface ( ) ; Class < ? extends T > c1 = b ? m ( clazz ) : clazz ; Class < ? extends T > c2 = choose ( b , m", "gt": "( clazz ) , clazz ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3531, "input": "<s> package gui ; import java . awt . * ; import java . util . Random ; import javax . swing . * ; import lolspace . GameWorld ; public class ScoreView extends JPanel { private static final long serialVersionUID = 4108750243244518957L ; private static final Random RANDOM = new Random ( ) ; private JLabel scoresLabel ; private JLabel quotesLabel ; private static final String [ ] quotes = { \"you are beautiful\" , \"you are doing great\" , \"\" , \"<3\" , \":-)\" , \";)\" , \"super\" , \"GOGOGOGO!!!\" , \"great move!\" , \"let's go!\" , \"stay positive\" , \"keep it up\" , \":D\" , \"a lol a day\" , \"thx 4 being u\" , \"you are loved\" , \"find a friend in everyone\" } ; private static final String [ ] almostGOquotes = { \"watch out!\" , \"do not want\" , \"whoa!!\" , \"be careful\" , \"holy moly\" } ; private Color myBackground ; public ScoreView ( ) { Color midnightblue = new Color ( 25 , 25 , 112 ) ; this . setForeground ( midnightblue ) ; Color gainsboro = new Color ( 220 , 220 , 220 ) ; this . myBackground = gainsboro ; this . setBackground ( myBackground ) ; scoresLabel = new JLabel ( \"Score: \" ) ; quotesLabel = new JLabel ( \"\" ) ; setLayout ( new FlowLayout ( FlowLayout . LEFT , 10 , 10 ) ) ; this . setPreferredSize ( new Dimension ( 100 , 42 ) ) ; this . add ( scoresLabel ) ; this . add ( quotesLabel ) ; } public void update ( GameWorld gw ) { int score = gw . getScore ( ) ; scoresLabel . setText ( \"Score: \" + score ) ; if ( gw . isGameOver ( ) || ! gw . isRunning ( ) ) { quotesLabel .", "gt": "setText ( \"game over idiot\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1904, "input": "<s> package org . ofbiz . entity . config ; import org . w3c . dom . Element ; public class FieldTypeInfo extends NamedInfo { public Element resourceElement ; public FieldTypeInfo ( Element element ) {", "gt": "super ( element ) ;", "prediction": "\n", "label": 0}
{"id": 3533, "input": "<s> package br . org . archimedes . model ; import java . util . Collection ; import java . util . Collections ; import java . util . LinkedList ; import java . util . Observable ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . opengl . Color ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; public class Layer extends Observable { private Color color ; private Color printColor ; private String name ; private LineStyle lineStyle ; private double thickness ; private Collection < Element > elements ; private boolean locked ; private boolean visible ; private final String xmlToSave ; public String getXmlToSave ( ) { return this . xmlToSave ; } public Layer ( Color color , String name , LineStyle lineStyle , double thickness , String xmlToSave ) { this . color = color ; this . printColor = color ; if ( Constant . WHITE . equals ( color ) ) { printColor = Constant . BLACK ; } this . name = name ; this . lineStyle = lineStyle ; this . thickness = thickness ; this . elements = new LinkedList < Element > ( ) ; this . locked = false ; this . visible = true ; this . xmlToSave = xmlToSave ; } public Layer ( Color color , String name , LineStyle lineStyle , double thickness ) { this ( color , name , lineStyle , thickness , null ) ; } public Layer clone ( ) { Layer clone = new Layer ( color . clone ( ) , name , lineStyle , thickness ) ; clone . printColor = printColor . clone ( ) ; return clone ; } public Color getColor ( ) { return color ; } public void setColor ( Color color ) { this . color = color ; } public LineStyle getLineStyle ( ) { return lineStyle ; } public void setLineStyle ( LineStyle lineStyle ) { this . lineStyle = lineStyle ; } public String getName ( ) { return name ; } public void setName ( String name ) { String oldName = this . name ; this . name = name ; setChanged ( ) ; notifyObservers ( oldName ) ; } public double getThickness ( ) { return thickness ; } public void setThickness ( double thickness ) { this . thickness = thickness ; } public boolean contains ( Element element ) { boolean result = false ; if ( elements . contains ( element ) ) { result = true ; } return result ; } public void putElement ( Element element ) throws NullArgumentException , IllegalActionException { if ( element == null ) { throw new NullArgumentException ( ) ; } if ( elements . contains ( element ) ) { throw new IllegalActionException ( ) ; } elements . add ( element ) ; element . setLayer ( this ) ; } public boolean removeElement ( Element element ) throws NullArgumentException , IllegalActionException { if ( element == null ) { throw new NullArgumentException ( ) ; } if ( ! elements . contains ( element ) ) { throw new IllegalActionException ( ) ; } boolean removed = elements . remove ( element ) ; return removed ; } public Collection < Element > getElements ( ) { return Collections . unmodifiableCollection ( elements ) ; } public void clear ( ) { elements . clear ( ) ; } public boolean isLocked ( ) {", "gt": "return ( locked || ! visible ) ;", "prediction": "\n", "label": 1}
{"id": 3694, "input": "<s> package org . ofbiz . webtools ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import java . net . MalformedURLException ; import java . net . URL ; import java . sql . Timestamp ; import java . text . NumberFormat ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . ResourceBundle ; import java . util . Set ; import java . util . TreeSet ; import javax . xml . parsers . ParserConfigurationException ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilPlist ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilURL ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilProperties . UtilResourceBundle ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . model . ModelFieldType ; import org . ofbiz . entity . model . ModelIndex ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . model . ModelReader ; import org . ofbiz . entity . model . ModelRelation ; import org . ofbiz . entity . model . ModelUtil ; import org . ofbiz . entity . model . ModelViewEntity ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityDataAssert ; import org", "gt": ". ofbiz . entity . util . EntityDataLoader ;", "prediction": ";\n", "label": 0}
{"id": 3535, "input": "<s> package org . seage . problem . jssp ; public class JobInfo { private int _id ; private int _priority ; public JobInfo ( int id , int priority ) { _id = id ; _priority = priority ; } public int getID ( ) { return _id ; }", "gt": "public int getPriority ( )", "prediction": "}\n", "label": 1}
{"id": 2936, "input": "<s> import java . util . * ; import javax . annotation . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SuppressWarnings ( \"\" ) public class A extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { Messager m = processingEnv . getMessager ( ) ; for ( TypeElement anno : annotations ) { for ( Element e : roundEnv . getElementsAnnotatedWith ( anno ) ) m . printMessage ( Diagnostic . Kind . ERROR", "gt": ", \"test\" , e ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3550, "input": "<s> package org . apache . lucene . search ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class HitIterator implements Iterator { private Hits hits ; private int hitNumber = 0 ; HitIterator ( Hits hits ) { this . hits = hits ; } public boolean hasNext ( ) { return hitNumber < hits . length ( ) ; } public Object next ( ) { if ( hitNumber == hits . length ( )", "gt": ") throw new NoSuchElementException ( ) ;", "prediction": ")\n", "label": 1}
{"id": 4393, "input": "<s> package org . hackreduce . examples . bixi ; import java . io . IOException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . util . ToolRunner ; import org . hackreduce . mappers . BixiMapper ; import org . hackreduce . mappers . ModelMapper ; import org . hackreduce . mappers . XMLInputFormat ; import org . hackreduce . mappers . XMLRecordReader ; import org . hackreduce . models . BixiRecord ; public class RecordCounter extends org . hackreduce . examples . RecordCounter { public enum Count { TOTAL_RECORDS , UNIQUE_KEYS } public static class RecordCounterMapper extends BixiMapper < Text , LongWritable > { public static final Text TOTAL_COUNT = new Text ( \"total\" ) ; public static final LongWritable ONE_COUNT = new LongWritable ( 1 ) ; @ Override protected void map ( BixiRecord record", "gt": ", Context context ) throws IOException , InterruptedException", "prediction": ")\n", "label": 0}
{"id": 3562, "input": "<s> package org . mitre . jwt . encryption ; import org . apache . commons . lang . StringUtils ; public enum JweAlgorithms { CS256 ( \"256\" ) , CS384 ( \"384\" ) , CS512 ( \"512\" ) , A128GCM ( \"GCM\" ) , A256GCM ( \"GCM\" ) , A128CBC ( \"CBC\" ) , A256CBC ( \"CBC\" ) ; private final String value ; JweAlgorithms ( String value ) { this . value = value ; } public static String getByName ( String name ) { for ( JweAlgorithms correspondingType : JweAlgorithms . values ( ) ) { if ( correspondingType . toString ( ) . equals ( name ) ) { return correspondingType . value ; } } throw new IllegalArgumentException ( \"JweAlgorithm name \" + name + \" does not have a corresponding JweAlgorithm: expected one of [\" + StringUtils . join ( JweAlgorithms . values ( ) ,", "gt": "\", \" ) + \"]\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5813, "input": "<s> package util . list ; import com . sun . tools . javac . util . List ; public class FromArray { public static void test ( String ... args ) { List < String > ss = List . from ( args ) ; if ( args != null ) { for ( String s : args ) { if ( s != ss . head ) throw new AssertionError ( \"s != ss.head (\" + s + \", \" + ss . head + \")\" ) ; ss = ss . tail ; } } if ( ! ss . isEmpty ( ) ) throw new AssertionError ( \"!ss.isEmpty (\" + ss + \")\" ) ; } public static void", "gt": "main ( String ... args )", "prediction": "( )\n", "label": 0}
{"id": 3589, "input": "<s> package org . robotframework . text . formatting ; import org . eclipse . xtext . formatting . impl . AbstractDeclarativeFormatter ; import org . eclipse . xtext . formatting . impl . FormattingConfig ; public class SpaceFormatter extends AbstractDeclarativeFormatter {", "gt": "@ Override protected void configureFormatting ( FormattingConfig c )", "prediction": "return ;\n", "label": 1}
{"id": 181, "input": "<s> package org . ofbiz . base . util ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Locale ; import com . ibm . icu . text . RuleBasedNumberFormat ; public class UtilNumber { public static String module = UtilNumber . class . getName ( ) ; private static final String arithmeticPropertiesFile = \"arithmetic.properties\" ; private static final int DEFAULT_BD_SCALE = 2 ; private static final int DEFAULT_BD_ROUNDING_MODE = BigDecimal . ROUND_HALF_UP ; public static int getBigDecimalScale ( String file , String property ) { if ( UtilValidate . isEmpty ( file ) ) return DEFAULT_BD_SCALE ; if ( UtilValidate . isEmpty ( property ) ) return DEFAULT_BD_SCALE ; int scale = - 1 ; String value = UtilProperties . getPropertyValue ( file , property ) ; if ( value != null ) { try { scale = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { } } if ( scale == - 1 ) { Debug . logWarning ( \"Could not set decimal precision from \" + property + \"=\" + value + \". Using default scale of \" + DEFAULT_BD_SCALE + \".\" , module ) ; scale = DEFAULT_BD_SCALE ; } return scale ; } public static int getBigDecimalScale ( String property ) { return getBigDecimalScale ( arithmeticPropertiesFile , property ) ; } public static int getBigDecimalRoundingMode ( String file , String property ) { if ( UtilValidate . isEmpty ( file ) ) return DEFAULT_BD_SCALE ; if ( UtilValidate . isEmpty ( property ) ) return DEFAULT_BD_ROUNDING_MODE ; String value = UtilProperties . getPropertyValue ( file , property ) ; int mode = roundingModeFromString ( value ) ; if ( mode == - 1 ) { Debug . logWarning ( \"Could not set decimal rounding mode from \" + property + \"=\" + value + \". Using default mode of \" + DEFAULT_BD_SCALE + \".\" , module ) ; return DEFAULT_BD_ROUNDING_MODE ; } return mode ; } public static int getBigDecimalRoundingMode ( String property ) { return getBigDecimalRoundingMode ( arithmeticPropertiesFile , property ) ; } public static int roundingModeFromString ( String value ) { if ( value == null ) return - 1 ; value = value . trim ( ) ; if ( \"ROUND_HALF_UP\" . equals ( value ) ) return BigDecimal . ROUND_HALF_UP ; else if ( \"ROUND_HALF_DOWN\" . equals ( value ) ) return BigDecimal . ROUND_HALF_DOWN ; else if ( \"ROUND_HALF_EVEN\" . equals ( value ) ) return BigDecimal . ROUND_HALF_EVEN ; else if ( \"ROUND_UP\" . equals ( value ) ) return BigDecimal . ROUND_UP ; else if ( \"ROUND_DOWN\" . equals ( value ) ) return BigDecimal . ROUND_DOWN ; else if ( \"ROUND_CEILING\" . equals ( value ) ) return BigDecimal . ROUND_CEILING ; else if ( \"ROUND_FLOOR\" . equals ( value ) ) return BigDecimal . ROUND_FLOOR ; else if ( \"ROUND_UNNECCESSARY\" . equals ( value ) ) return BigDecimal . ROUND_UNNECESSARY ; return - 1 ; } public static final String ruleSet_en_US = \"%dollars-and-cents:\\n\" + \"    x.0: << [and >%%cents>];\\n\" + \"    0.x: >%%cents>;\\n\" + \"    0: zero dollars; one dollar; =%%main= dollars;\\n\" + \"%%main:\\n\" + \"    zero; one; two; three; four; five; six; seven; eight; nine;\\n\" + \"    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;\\n\" + \"        seventeen; eighteen; nineteen;\\n\" + \"    20: twenty[->>];\\n\" + \"    30: thirty[->>];\\n\" + \"    40: forty[->>];\\n\" + \"    50: fifty[->>];\\n\" + \"    60: sixty[->>];\\n\" + \"    70: seventy[->>];\\n\" + \"    80: eighty[->>];\\n\" + \"    90: ninety[->>];\\n\" + \"    100: << hundred[ >>];\\n\" + \"    1000: << thousand[ >>];\\n\" + \"    1,000,000: << million[ >>];\\n\" + \"    1,000,000,000: << billion[ >>];\\n\" + \"    1,000,000,000,000: << trillion[ >>];\\n\" + \"    1,000,000,000,000,000: =#,##0=;\\n\" + \"%%cents:\\n\" + \"    100: <%%main< cent[s];\\n\" + \"%dollars-and-hundredths:\\n\" + \"    x.0: <%%main< and >%%hundredths>/100;\\n\" + \"%%hundredths:\\n\" + \"    100: <00<;\\n\" ; public static final String ruleSet_th_TH = \"%bahts-and-stangs:\\n\" + \"    x.0: << [and >%%stangs>];\\n\" + \"    0.x: >%%stangs>;\\n\" + \"    0: zero bahts; one baht; =%%main= bahts;\\n\" + \"%%main:\\n\" + \"    zero; one; two; three; four; five; six; seven; eight; nine;\\n\" + \"    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;\\n\" + \"        seventeen; eighteen; nineteen;\\n\" + \"    20: twenty[->>];\\n\" + \"    30: thirty[->>];\\n\" + \"    40: forty[->>];\\n\" + \"    50: fifty[->>];\\n\" + \"    60: sixty[->>];\\n\" + \"    70: seventy[->>];\\n\" + \"    80: eighty[->>];\\n\" + \"    90: ninety[->>];\\n\" + \"    100: << hundred[ >>];\\n\" + \"    1000: << thousand[ >>];\\n\" + \"    1,000,000: << million[ >>];\\n\" + \"    1,000,000,000: << billion[ >>];\\n\" + \"    1,000,000,000,000: << trillion[ >>];\\n\" + \"    1,000,000,000,000,000: =#,##0=;\\n\" + \"%%stangs:\\n\" + \"    100: <%%main< stang[s];\\n\" + \"%bahts-and-hundredths:\\n\" + \"    x.0: <%%main< and >%%hundredths>/100;\\n\" + \"%%hundredths:\\n\" + \"    100: <00<;\\n\" ; public static HashMap < Locale , String > rbnfRuleSets ; static { rbnfRuleSets = new HashMap < Locale , String > ( ) ; rbnfRuleSets . put ( Locale . US , ruleSet_en_US ) ; rbnfRuleSets . put ( new Locale ( \"th\" ) , ruleSet_th_TH ) ; } public static String formatRuleBasedAmount ( double amount , String rule , Locale locale ) { String ruleSet = rbnfRuleSets . get ( locale ) ; if ( ruleSet == null ) { Debug . logWarning ( \"Cannot format rule based amount for locale \" + locale . toString ( ) + \" because rule set for that locale does not exist\" , module ) ; return \"\" ; } RuleBasedNumberFormat formatter = new RuleBasedNumberFormat ( ruleSet , locale ) ; String result = \"\" ; try { result = formatter . format ( amount , rule ) ; }", "gt": "catch ( Exception e )", "prediction": "}\n", "label": 0}
{"id": 3596, "input": "<s> package org . eclipse . jface . preference ; import java . io . Serializable ; import org . eclipse . jface . dialogs . DialogPage ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . FontMetrics ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; public abstract class FieldEditor implements Serializable { public static final String IS_VALID = \"field_editor_is_valid\" ; public static final String VALUE = \"field_editor_value\" ; protected static final int HORIZONTAL_GAP = 8 ; private IPreferenceStore preferenceStore = null ; private String preferenceName ; private boolean isDefaultPresented = false ; private String labelText ; private Label label ; private IPropertyChangeListener propertyChangeListener ; private DialogPage page ; protected FieldEditor ( ) { } protected FieldEditor ( String name , String labelText , Composite parent ) { init ( name , labelText ) ; createControl ( parent ) ; } protected abstract void adjustForNumColumns ( int numColumns ) ; protected void applyFont ( ) { } protected void checkParent ( Control control , Composite parent ) { Assert . isTrue ( control . getParent ( ) == parent , \"Different parents\" ) ; } protected void clearErrorMessage ( ) { if ( page != null ) { page . setErrorMessage ( null ) ; } } protected void clearMessage ( ) { if ( page != null ) { page . setMessage ( null ) ; } } protected int convertHorizontalDLUsToPixels ( Control control , int dlus ) { GC gc = new GC ( control ) ; gc . setFont ( control . getFont ( ) ) ; int averageWidth = gc . getFontMetrics ( ) . getAverageCharWidth ( ) ; gc . dispose ( ) ; double horizontalDialogUnitSize = averageWidth * 0.25 ; return ( int ) Math . round ( dlus * horizontalDialogUnitSize ) ; } protected int convertVerticalDLUsToPixels ( Control control , int dlus ) { GC gc = new GC ( control ) ; gc . setFont ( control . getFont ( ) ) ; int height = gc . getFontMetrics ( ) . getHeight ( ) ; gc . dispose ( ) ; double verticalDialogUnitSize = height * 0.125 ; return ( int ) Math . round ( dlus * verticalDialogUnitSize ) ; } protected void createControl ( Composite parent ) { GridLayout layout = new GridLayout ( ) ; layout . numColumns = getNumberOfControls ( ) ; layout . marginWidth = 0 ; layout . marginHeight = 0 ; layout . horizontalSpacing = HORIZONTAL_GAP ; parent . setLayout ( layout ) ; doFillIntoGrid ( parent , layout . numColumns ) ; } public void dispose ( ) { } protected abstract void doFillIntoGrid ( Composite parent , int numColumns ) ; protected abstract void doLoad ( ) ; protected abstract void doLoadDefault ( ) ; protected abstract void doStore ( ) ; public void fillIntoGrid ( Composite parent , int numColumns ) { Assert . isTrue ( numColumns >= getNumberOfControls ( ) ) ; Assert . isTrue ( parent . getLayout ( ) instanceof GridLayout ) ; doFillIntoGrid ( parent , numColumns ) ; } protected void fireStateChanged ( String property , boolean oldValue , boolean newValue ) { if ( oldValue == newValue ) { return ; } fireValueChanged ( property , oldValue ? Boolean . TRUE : Boolean . FALSE , newValue ? Boolean . TRUE : Boolean . FALSE ) ; } protected void fireValueChanged ( String property , Object oldValue , Object newValue ) { if ( propertyChangeListener == null ) { return ; } propertyChangeListener . propertyChange ( new PropertyChangeEvent ( this , property , oldValue , newValue ) ) ; } public String getFieldEditorFontName ( ) { return JFaceResources . DIALOG_FONT ; } protected Label getLabelControl ( ) { return label ; } public Label getLabelControl ( Composite parent ) { if ( label == null ) { label = new Label ( parent , SWT . LEFT ) ; label . setFont ( parent . getFont ( ) ) ; String text = getLabelText ( ) ; if ( text != null ) { label . setText ( text ) ; } label . addDisposeListener ( new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent event ) { label = null ; } } ) ; } else { checkParent ( label , parent ) ; } return label ; } public String getLabelText ( ) { return labelText ; } public abstract", "gt": "int getNumberOfControls ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 8707, "input": "<s> package org . ofbiz . product . product ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . GeneralRuntimeException ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . content . content . ContentWrapper ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . LocalDispatcher ; public class ProductContentWrapper implements ContentWrapper { public static final String module = ProductContentWrapper . class . getName ( ) ; public static final String SEPARATOR = \"::\" ; private static final UtilCache < String , String > productContentCache = UtilCache . createUtilCache ( \"product.content.rendered\" , true ) ; public static ProductContentWrapper makeProductContentWrapper ( GenericValue product , HttpServletRequest request ) { return new ProductContentWrapper ( product , request ) ; } LocalDispatcher dispatcher ; protected GenericValue product ; protected Locale locale ; protected String mimeTypeId ; public ProductContentWrapper ( LocalDispatcher dispatcher , GenericValue product , Locale locale , String mimeTypeId ) { this . dispatcher = dispatcher ; this . product = product ; this . locale = locale ; this . mimeTypeId = mimeTypeId ; } public ProductContentWrapper ( GenericValue product , HttpServletRequest request ) { this . dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; this . product = product ; this . locale = UtilHttp . getLocale ( request ) ; this . mimeTypeId = \"text/html\" ; } public StringUtil . StringWrapper get ( String productContentTypeId ) { if ( this . product == null ) { Debug . logWarning ( \"Tried to get ProductContent for type [\" + productContentTypeId + \"] but the product field in the ProductContentWrapper is null\" , module ) ; return null ; } return StringUtil . makeStringWrapper ( getProductContentAsText ( this . product , productContentTypeId , locale , mimeTypeId , null , null , this . product . getDelegator ( ) , dispatcher ) ) ; } public static String getProductContentAsText ( GenericValue product , String productContentTypeId , HttpServletRequest request ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; return getProductContentAsText ( product , productContentTypeId , UtilHttp . getLocale ( request ) , \"text/html\" , null , null , product . getDelegator ( ) , dispatcher ) ; } public static String getProductContentAsText ( GenericValue product , String productContentTypeId , Locale locale , LocalDispatcher dispatcher ) { return getProductContentAsText ( product , productContentTypeId , locale , null , null , null , null , dispatcher ) ; } public static String getProductContentAsText ( GenericValue product , String productContentTypeId , Locale locale , String mimeTypeId , String partyId , String roleTypeId , Delegator delegator , LocalDispatcher dispatcher ) { if ( product == null ) { return null ; } String candidateFieldName = ModelUtil . dbNameToVarName ( productContentTypeId ) ; String cacheKey = productContentTypeId + SEPARATOR + locale + SEPARATOR + mimeTypeId + SEPARATOR + product . get ( \"productId\" ) ; try { String cachedValue = productContentCache . get ( cacheKey ) ; if ( cachedValue != null ) { return cachedValue ; } Writer outWriter = new StringWriter ( ) ; getProductContentAsText ( null , product , productContentTypeId , locale , mimeTypeId , partyId , roleTypeId ,", "gt": "delegator , dispatcher , outWriter ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3600, "input": "<s> package com . rabbitmq . messagepatterns . unicast ; public interface ConnectorStateListener {", "gt": "public void connectorStateChanged ( Connector sender , ConnectorState state ) ;", "prediction": "( )\n", "label": 1}
{"id": 20, "input": "<s> public class T6650759k { static class A < X extends A > { } static class B < X extends B , Y extends A > { } < U extends A < U > , V extends B < V , U > > Object m ( Class", "gt": "< V > c )", "prediction": ")\n", "label": 0}
{"id": 3634, "input": "<s> package org . restlet . example . book . restlet . ch09 . common ; import org . restlet . resource . Get ; public interface ContactResource { @", "gt": "Get public ContactRepresentation retrieve ( ) ;", "prediction": ";\n", "label": 1}
{"id": 278, "input": "<s> package org . ofbiz . ebaystore ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import net . sf . json . JSONObject ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . event . EventHandlerException ; import com . ebay . sdk . ApiContext ; import com . ebay . sdk . ApiException ; import com . ebay . sdk . SdkException ; import com . ebay . sdk . SdkSoapException ; import com . ebay . sdk . call . GetStoreOptionsCall ; import com . ebay . soap . eBLBaseComponents . CategoryType ; import com . ebay . soap . eBLBaseComponents . GetStoreOptionsRequestType ; import com . ebay . soap . eBLBaseComponents . GetStoreOptionsResponseType ; import com . ebay . soap . eBLBaseComponents . StoreColorSchemeType ; import com . ebay . soap . eBLBaseComponents . StoreColorType ; import com . ebay . soap . eBLBaseComponents . StoreFontType ; import com . ebay . soap . eBLBaseComponents . StoreThemeArrayType ; import com . ebay . soap . eBLBaseComponents . StoreThemeType ; import com . ebay . soap . eBLBaseComponents . StoreCustomCategoryType ; public class EbayStoreOptions { private static final String module = EbayStoreOptions . class . getName ( ) ; public static String retrieveThemeColorSchemeByThemeId ( HttpServletRequest request , HttpServletResponse response ) { Locale locale = UtilHttp . getLocale ( request ) ; HttpSession session = request . getSession ( true ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; GetStoreOptionsRequestType req = null ; GetStoreOptionsResponseType resp = null ; StoreThemeArrayType returnedBasicThemeArray = null ; try { Map < String , Object > paramMap = UtilHttp . getCombinedMap ( request ) ; if ( paramMap . get ( \"productStoreId\" ) != null ) { String themeId = ( String ) paramMap . get ( \"themeId\" ) ; GetStoreOptionsCall call = new GetStoreOptionsCall ( EbayStoreHelper . getApiContext ( ( String ) paramMap . get ( \"productStoreId\" ) , locale , delegator ) ) ; req = new GetStoreOptionsRequestType ( ) ; resp = ( GetStoreOptionsResponseType ) call . execute ( req ) ; if ( resp != null && \"SUCCESS\" . equals ( resp . getAck ( ) . toString ( ) ) ) { returnedBasicThemeArray = resp . getBasicThemeArray ( ) ; StoreThemeType [ ] storeBasicTheme = returnedBasicThemeArray . getTheme ( ) ; int i = 0 ; String colorSchemeId = themeId . substring ( themeId . indexOf ( \"-\" ) + 1 ) ; themeId = themeId . substring ( 0 , themeId . indexOf ( \"-\" ) ) ; Map < String , Object > storeColorSchemeMap = FastMap . newInstance ( ) ; while ( i < storeBasicTheme . length ) { StoreThemeType storeThemeType = storeBasicTheme [ i ] ; if ( themeId . equals ( storeThemeType . getThemeID ( ) . toString ( ) ) ) { StoreColorSchemeType colorSchemeType = storeThemeType . getColorScheme ( ) ; if ( colorSchemeType != null ) { if ( colorSchemeId . equals ( colorSchemeType . getColorSchemeID ( ) .", "gt": "toString ( ) ) )", "prediction": ") ;\n", "label": 0}
{"id": 3655, "input": "<s> package org . restlet . ext . servlet . internal ; import java . util . List ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Protocol ; import org . restlet . engine . ClientHelper ; public class ServletWarClient extends Client { private volatile ClientHelper helper ; public ServletWarClient ( Context parentContext , javax . servlet . ServletContext servletContext ) { super ( parentContext . createChildContext ( ) , ( List < Protocol > ) null ) ; getProtocols ( ) . add ( Protocol . WAR ) ; this . helper = new ServletWarClientHelper ( this , servletContext ) ; } private ClientHelper getHelper ( ) { return this . helper ; } @ Override public void handle ( Request request , Response response ) { super . handle ( request , response ) ; getHelper ( ) . handle ( request , response ) ; } @ Override public void start ( ) throws Exception { super . start ( ) ; getHelper ( ) . start ( ) ; } @ Override public void stop ( ) throws Exception {", "gt": "getHelper ( ) . stop ( ) ;", "prediction": "\n", "label": 1}
{"id": 5903, "input": "<s> package com . example . tutorial . batch ; import com . asakusafw . testdriver . BatchTestDriver ; import org . junit . Test ; public class TutorialBatchTest {", "gt": "@ Test public void testExample ( ) throws Throwable", "prediction": ";\n", "label": 0}
{"id": 3659, "input": "<s> package com . codeslap . persistence ; import android . content . Context ; import android . content . SharedPreferences ; import android . preference . PreferenceManager ; import com . codeslap . persistence . pref . Preference ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import java . util . Map ; class PrefsAdapterImpl implements PreferencesAdapter { private final Map < String , SharedPreferences > mPreferences = new HashMap < String , SharedPreferences > ( ) ; private final Context mContext ; private final String mName ; PrefsAdapterImpl ( Context context , String name ) { mContext = context ; mName = name ; } PrefsAdapterImpl ( Context context ) { this ( context , DEFAULT_PREFS ) ; } @ Override public < T > void store ( T bean ) { Class < ? > theClass = bean . getClass ( ) ; if ( ! PersistenceConfig . getPreference ( mName ) . belongsToPreferences ( theClass ) ) { throw new IllegalStateException ( \"This object is not associated with a preference persister\" ) ; } SharedPreferences . Editor editor = getSharedPreferences ( theClass ) . edit ( ) ; fillEditor ( editor , bean ) ; editor . commit ( ) ; } @ Override public < T > T retrieve ( Class < T > theClass ) { T bean ; try { bean = theClass . newInstance ( ) ; } catch ( Exception e ) { return null ; } try { for ( Field field : theClass . getDeclaredFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) { continue ; } field . setAccessible ( true ) ; Preference annotation = field . getAnnotation ( Preference . class ) ; String keyName ; if ( annotation == null ) { keyName = field . getName ( ) ; } else { keyName = annotation . value ( ) ; } boolean defaultEnabled = annotation != null && ! annotation . defaultValue ( ) . equals ( \"\" ) ; Object value = null ; Class < ? > type = field . getType ( ) ; if ( type == boolean . class || type == Boolean . class ) { boolean def = defaultEnabled && \"true\" . equals ( annotation . defaultValue ( ) ) ; value = getSharedPreferences ( theClass ) . getBoolean ( keyName , def ) ; } else if ( type == float . class || type == Float . class || type == double . class || type == Double . class ) { float def = defaultEnabled ? Float . parseFloat ( annotation . defaultValue ( ) ) : 0.0f ; value = getSharedPreferences ( theClass ) . getFloat ( keyName , def ) ; } else if ( type == Integer . class || type == int . class ) { int def = defaultEnabled ? Integer . parseInt ( annotation . defaultValue ( ) ) : 0 ; value = getSharedPreferences (", "gt": "theClass ) . getInt ( keyName , def ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1957, "input": "<s> package org . parboiled . errors ; import org . parboiled . buffers . InputBuffer ; public interface ParseError { InputBuffer getInputBuffer ( ) ; int getStartIndex ( ) ; int getEndIndex ( ) ;", "gt": "String getErrorMessage ( ) ;", "prediction": "}\n", "label": 0}
{"id": 3663, "input": "<s> package org . eclipse . ui . forms . internal . widgets ; import org . eclipse . swt", "gt": ". graphics . Rectangle ;", "prediction": ";\n", "label": 1}
{"id": 3482, "input": "<s> @ interface A { B b ( ) default @ B ( b2 = 1 , b2 = 2 ) ; B [ ] b_arr ( ) default { @ B ( ) , @ B ( b2 = 1 , b2 = 2 ) } ; } @ interface B { String b1 ( ) ; int b2 ( ) ; } @ A ( b = @ B ( b2 = 1 , b2 = 2 ) , b_arr = { @ B ( ) , @ B ( b2 = 1 , b2 = 2 ) }", "gt": ") class T6881115 < X >", "prediction": ";\n", "label": 0}
{"id": 3672, "input": "<s> package fr . inria . zvtm . lens ; public class L3FSFresnelLens extends FSFresnelLens { public L3FSFresnelLens ( ) { super ( ) ; } public L3FSFresnelLens ( float mm , int ns ) { super ( mm , ns ) ; } public L3FSFresnelLens ( float mm , int outerRadius , int innerRadius , int ns ) { super ( mm , outerRadius , innerRadius , ns ) ; } public L3FSFresnelLens ( float mm , int outerRadius , int innerRadius , int ns , int x , int y ) { super ( mm , outerRadius , innerRadius , ns , x , y ) ; } public void gf ( float x , float y , float [ ] g ) { d = Math . pow ( Math . pow ( Math . abs ( x - sw - lx ) , 3 ) + Math . pow ( Math . abs ( y - sh - ly ) , 3 ) , L3FSLinearLens . onethird ) ; if ( d <= LR2 ) g [ 0 ] = g [ 1 ] = MM ; else if ( d <= LR1 ) { for ( int i = 0 ; i < Ri . length ; i ++ ) { if ( d <= Ri [ i ] ) { g [ 0 ] = g [ 1 ] =", "gt": "MMi [ i ] ;", "prediction": ";\n", "label": 1}
{"id": 10035, "input": "<s> public class T6450290 { static class Box < X extends Box < ? , ? > , T extends X > { T value ; Box < X , T > same ; } static class A extends Box < A , A > { } static class B extends Box < B , B > { } public static void main ( String [ ] args ) { Box < ? , ? > b = new Box < Box < A , A > , Box < A , A > > ( ) ; b . value . same = new Box < B", "gt": ", B > ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3679, "input": "<s> package br . org . archimedes . interfaces ; import java . io . IOException ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Rectangle ; public interface ElementExporter < T extends Element > { public void exportElement ( T element ,", "gt": "Object outputObject ) throws IOException , NotSupportedException ;", "prediction": ")\n", "label": 1}
{"id": 2188, "input": "<s> package org . ofbiz . minilang . method . conditional ; import java . util . Collections ; import java . util . List ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class EmptyCondition extends MethodOperation implements Conditional { public static final String module = EmptyCondition . class . getName ( ) ; private final FlexibleMapAccessor < Object > fieldFma ; private final List < MethodOperation > elseSubOps ; private final List < MethodOperation > subOps ; public EmptyCondition ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; Element childElement = UtilXml . firstChildElement ( element ) ; if ( childElement != null && ! \"else\" . equals ( childElement . getTagName ( ) ) ) { this . subOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( element , simpleMethod ) ) ; } else { this . subOps = null ; } Element elseElement = UtilXml . firstChildElement ( element , \"else\" ) ; if ( elseElement != null ) { this . elseSubOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( elseElement , simpleMethod ) ) ; } else { this . elseSubOps = null ; } } @ Override public boolean checkCondition ( MethodContext methodContext ) throws MiniLangException { return ObjectType . isEmpty ( fieldFma . get ( methodContext . getEnvMap ( ) ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { if ( checkCondition ( methodContext ) ) { if ( this . subOps != null ) { return SimpleMethod . runSubOps ( subOps , methodContext ) ; } } else { if ( elseSubOps != null ) { return SimpleMethod . runSubOps ( elseSubOps , methodContext ) ; } } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { if ( this . subOps != null ) { for ( MethodOperation method : this . subOps ) { method . gatherArtifactInfo ( aic ) ; } } if ( this . elseSubOps != null ) { for ( MethodOperation method : this . elseSubOps ) { method . gatherArtifactInfo ( aic ) ; } } } public void prettyPrint ( StringBuilder messageBuffer , MethodContext methodContext ) { messageBuffer . append ( \"empty[\" ) ; messageBuffer . append ( fieldFma ) ; messageBuffer . append ( \"=\" ) ; messageBuffer . append ( fieldFma . get ( methodContext . getEnvMap ( ) ) ) ; messageBuffer . append ( \"]\" ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<if-empty \" ) ; sb . append ( \"field=\\\"\" ) . append", "gt": "( this . fieldFma ) . append ( \"\\\"/>\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3682, "input": "<s> package me . arboriginal . Creepersday ; import org . bukkit . World ; import org . bukkit . entity . Player ; import org . bukkit . event . EventHandler ; import org . bukkit . event . Listener ; import org . bukkit . event . player . PlayerBedLeaveEvent ; import org . bukkit . event . player . PlayerJoinEvent ; import org . bukkit . event . player . PlayerRespawnEvent ; public class CreepersdayPlayerListener implements Listener { private final Creepersday plugin ; public CreepersdayPlayerListener ( final Creepersday plugin ) { this . plugin = plugin ; } @ EventHandler public void onPlayerRespawn ( PlayerRespawnEvent event ) { plugin . getServer ( ) . getScheduler ( ) . scheduleAsyncDelayedTask ( plugin , new CreepersdayPlayerListenerRunnable ( event . getPlayer ( ) , \"respawn\" ) , 10L ) ; } @ EventHandler public void onPlayerJoin ( PlayerJoinEvent event ) { plugin . getServer ( ) . getScheduler ( ) . scheduleAsyncDelayedTask ( plugin , new CreepersdayPlayerListenerRunnable ( event . getPlayer ( ) , \"join\" ) , 10L ) ; } @ EventHandler public void onPlayerBedLeave ( PlayerBedLeaveEvent event ) { Player player = event . getPlayer ( ) ; if ( player != null ) { World world = player . getWorld ( ) ; if ( plugin . isCreepersday ( world ) ) { plugin . stopCreepersday ( world ) ; } else { if ( plugin . shouldCreepersdayStart ( world ) ) { plugin . startCreepersday ( world ) ; } } } } private class CreepersdayPlayerListenerRunnable implements Runnable { private String event ; private Player player ; public CreepersdayPlayerListenerRunnable ( Player player , String event ) { this . event = event ; this . player = player ; } @ Override public void run ( ) { if ( player != null ) {", "gt": "World world = player . getWorld ( ) ;", "prediction": "\n", "label": 1}
{"id": 4904, "input": "<s> package com . redhat . ceylon . tools . test ; import org . junit . runner . RunWith ; import org . junit . runners . Suite ; import org . junit . runners . Suite . SuiteClasses ; import com . redhat . ceylon . tools . test . ImportJarToolTest ; import com . redhat . ceylon . tools . bashcompletion . BashCompletionToolTest ; import com . redhat . ceylon . tools . help . DocToolToolTest ; import com . redhat . ceylon . tools . help . HelpToolTest ; import com . redhat . ceylon . tools . help . MarkdownTest ; import com . redhat . ceylon . tools", "gt": ". help . PlaintextTest ;", "prediction": ";\n", "label": 0}
{"id": 3693, "input": "<s> package org . restlet . test . resource ; public class GenericAnnotatedServerResource < E > extends AbstractGenericAnnotatedServerResource < E > { public", "gt": "E addResponse ( E representation )", "prediction": "( )\n", "label": 1}
{"id": 1099, "input": "<s> interface Comparable < T > { } interface List < E > { } class Comparator < T > { } class Collections { public static < T extends Object & Comparable < T > > int binarySearch ( List < T > list , T key ) { throw new Error ( ) ; } public static < T > int binarySearch ( List < T > list , T key , Comparator < T > c ) { throw new Error ( ) ; } } class Record implements Comparable { } class T { public static void main ( String [ ] arg ) { List records = null ;", "gt": "Record x = null ;", "prediction": "}\n", "label": 0}
{"id": 3696, "input": "<s> package org . restlet . data ; public abstract class Metadata { private final String description ; private final String name ; public Metadata ( String name ) { this ( name , null ) ; } public Metadata ( String name , String description ) { this . name = name ; this . description = description ; } @ Override public boolean equals ( Object object ) { return ( object instanceof Metadata ) && ( ( Metadata ) object ) . getName ( ) . equals ( getName ( ) ) ; } public String getDescription ( ) { return this . description ; } public String getName ( ) { return this . name ; } public", "gt": "abstract Metadata getParent ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 967, "input": "<s> package org . ofbiz . entity . model ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import javolution . util . FastList ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; @ SuppressWarnings ( \"serial\" ) public class ModelRelation extends ModelChild { protected String title ; protected String type ; protected String relEntityName ; protected String fkName ; protected List < ModelKeyMap > keyMaps = new ArrayList < ModelKeyMap > ( ) ; protected ModelEntity mainEntity = null ; protected boolean isAutoRelation = false ; public ModelRelation ( ) { title = \"\" ; type = \"\" ; relEntityName = \"\" ; fkName = \"\" ; } public ModelRelation ( String type , String title , String relEntityName , String fkName , List < ModelKeyMap > keyMaps ) { if ( title == null ) title = \"\" ; this . title = title ; this . type = type ; this . relEntityName = relEntityName ; this . fkName = fkName ; this . keyMaps . addAll ( keyMaps ) ; } public ModelRelation ( ModelEntity mainEntity , Element relationElement ) { this . mainEntity = mainEntity ; this . type = UtilXml . checkEmpty ( relationElement . getAttribute ( \"type\" ) ) . intern ( ) ; this . title = UtilXml . checkEmpty ( relationElement . getAttribute ( \"title\" ) ) . intern ( ) ; this . relEntityName = UtilXml . checkEmpty ( relationElement . getAttribute ( \"rel-entity-name\" ) ) . intern ( ) ; this . fkName = UtilXml . checkEmpty ( relationElement . getAttribute ( \"fk-name\" ) ) . intern ( ) ; this . description = StringUtil . internString ( UtilXml . childElementValue ( relationElement , \"description\" ) ) ; NodeList keyMapList = relationElement . getElementsByTagName ( \"key-map\" ) ; for ( int i = 0 ; i < keyMapList . getLength ( ) ; i ++ ) { Element keyMapElement = ( Element ) keyMapList . item ( i ) ; if ( keyMapElement . getParentNode ( ) == relationElement ) { ModelKeyMap keyMap = new ModelKeyMap ( keyMapElement ) ; if ( keyMap != null ) { this . keyMaps . add ( keyMap ) ; } } } } public String getCombinedName ( ) { return this . title + this . relEntityName ; } public String getTitle ( ) { return this . title ; } public void setTitle ( String title ) { if ( title == null ) { this . title = \"\" ; } else { this . title = title ; } } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getRelEntityName ( ) { return this . relEntityName ; } public void setRelEntityName ( String relEntityName ) { this . relEntityName = relEntityName ; } public String getFkName ( ) { return this . fkName ; } public void setFkName ( String fkName ) { this . fkName = fkName ; } @ Deprecated public void setMainEntity ( ModelEntity mainEntity ) { setModelEntity ( mainEntity ) ; } public Iterator < ModelKeyMap > getKeyMapsIterator ( ) { return this . keyMaps . iterator ( ) ; } public List < ModelKeyMap > getKeyMapsClone ( ) { List < ModelKeyMap > kmList = FastList . newInstance ( ) ; kmList . addAll ( this . keyMaps ) ; return kmList ; } public int getKeyMapsSize ( ) { return this . keyMaps . size ( ) ; } public ModelKeyMap getKeyMap ( int index ) { return this . keyMaps . get ( index ) ; } public void addKeyMap ( ModelKeyMap keyMap ) { this . keyMaps . add ( keyMap ) ; } public ModelKeyMap removeKeyMap ( int index ) { return this . keyMaps . remove ( index ) ; } public ModelKeyMap findKeyMap ( String fieldName ) { for ( ModelKeyMap keyMap : keyMaps ) { if ( keyMap . fieldName . equals ( fieldName ) ) return keyMap ; } return null ; } public ModelKeyMap findKeyMapByRelated ( String relFieldName ) { for ( ModelKeyMap keyMap : keyMaps ) { if ( keyMap . relFieldName . equals ( relFieldName ) ) return keyMap ; } return null ; } public String keyMapString ( String separator , String afterLast ) { StringBuilder stringBuilder = new StringBuilder ( \"\" ) ; if ( keyMaps . size ( ) < 1 ) { return \"\" ; } int i = 0 ; for ( ; i < keyMaps . size ( ) - 1 ; i ++ ) { stringBuilder . append ( keyMaps . get ( i ) . fieldName ) ; stringBuilder . append ( separator ) ; } stringBuilder . append ( keyMaps . get ( i ) . fieldName ) ; stringBuilder . append ( afterLast ) ; return stringBuilder . toString ( ) ; } public String keyMapUpperString ( String separator , String afterLast ) { if ( keyMaps . size ( ) < 1 ) return \"\" ; StringBuilder returnString = new StringBuilder ( keyMaps . size", "gt": "( ) * 10 ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 3702, "input": "<s> package br . org . archimedes . text ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . batik . svggen . font . Font ; import br . org . archimedes . Constant ; import br . org . archimedes . Geometrics ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . ReferencePoint ; import br . org . archimedes . model . Vector ; import br . org . archimedes . model . references . CirclePoint ; import br . org . archimedes . model . references . RhombusPoint ; public class Text extends Element { private Point originPoint ; private Point horizontalPoint ; private Point verticalPoint ; private String text ; private Font font ; private Double cachedWidth ; public Text ( String text , Point originPoint , Double size ) throws NullArgumentException , InvalidArgumentException { this ( text , originPoint , size , null ) ; } public Text ( String text , Point originPoint , Double size , Font font ) throws NullArgumentException , InvalidArgumentException { if ( text == null || originPoint == null ) { throw new NullArgumentException ( ) ; } if ( size <= 0 ) { throw new InvalidArgumentException ( ) ; } this . text = new String ( text ) ; this . originPoint = originPoint . clone ( ) ; this . horizontalPoint = originPoint . addVector ( new Vector ( new Point ( size , 0 ) ) ) ; this . verticalPoint = originPoint . addVector ( new Vector ( new Point ( 0 , size ) ) ) ; if ( font == null ) { this . font = Constant . DEFAULT_FONT ; } else { this . font = font ; } } @ Override public Text clone ( ) { Text clone = null ; try { clone = new Text ( new String ( text ) , originPoint . clone ( ) , getHeight ( ) , getFont ( ) ) ; applyRotation ( clone ) ; clone . setLayer ( getLayer ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return clone ; } private void applyRotation ( Text clone ) { clone . verticalPoint = verticalPoint . clone ( ) ; clone . horizontalPoint = horizontalPoint . clone ( ) ; } public double getWidth ( ) { if ( cachedWidth == null ) { OpenGLWrapper openGl = br . org . archimedes . Utils . getOpenGLWrapper ( ) ; cachedWidth = Double . valueOf ( openGl . calculateWidth ( font , new Vector ( originPoint , verticalPoint ) . getNorm (", "gt": ") , text ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 2202, "input": "<s> class T6910550d { < X > void m ( X x ) { } < Y >", "gt": "void m ( Y y )", "prediction": ";\n", "label": 0}
{"id": 3709, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" ) @ XmlRootElement ( name =", "gt": "\"GetListCollection\" ) public class GetListCollection", "prediction": ") ;\n", "label": 1}
{"id": 7846, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . PrintStream ; import java . util . Collection ; import java . util . List ; import java . util . Locale ; class XCodeContext { private final static String ls = System . getProperty ( \"line.separator\" ) ; private String projectName ; private List < String > buildActions ; private String codeSignIdentity ; private File projectRootDirectory ; private PrintStream out ; private String provisioningProfile ; private String target ; public String getProjectName ( ) { return projectName ; } public void setProjectName ( String projectName ) { raiseExceptionIfNullOrEmpty ( \"projectName\" , projectName ) ; this . projectName = projectName ; } public List < String > getBuildActions ( ) { return buildActions ; } public void setBuildActions ( List < String > buildActions ) { raiseExceptionIfInvalid ( \"buildActions\" , buildActions ) ; this . buildActions = buildActions ; } public String getCodeSignIdentity ( ) { return codeSignIdentity ; } public void setCodeSignIdentity ( String codeSignIdentity ) { if ( codeSignIdentity != null && codeSignIdentity . trim ( ) . isEmpty ( ) ) throw new IllegalArgumentException ( \"CodesignIdentity was empty: '\" + codeSignIdentity + \"'. If you want to use the code\" + \" sign identity defined in the xCode project configuration just do\" + \" not provide the 'codeSignIdentity' in your Maven settings.\" ) ; this . codeSignIdentity = codeSignIdentity ; } public File getProjectRootDirectory ( ) { return projectRootDirectory ; } public void setProjectRootDirectory ( File projectRootDirectory ) { this . projectRootDirectory = projectRootDirectory ; } public PrintStream getOut ( ) { return out ; } public void setOut ( PrintStream out ) { if ( out == null ) throw new IllegalArgumentException ( \"PrintStream for log handling is not available.\" ) ; this . out = out ; } public String getProvisioningProfile ( ) { return provisioningProfile ; } public void setProvisioningProfile ( String provisioningProfile ) { this . provisioningProfile = provisioningProfile ; } public String getTarget ( ) { return target ; } public void setTarget ( String target ) { this . target = target ; } @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"ProjectRootDirectory: \" ) . append ( getProjectRootDirectory ( ) ) . append ( ls ) ; sb . append ( \"ProjectName         : \" ) . append ( getProjectName ( ) ) . append ( ls ) ; sb . append ( \"BuildActions        : \" ) . append ( buildActions ) ; sb . append ( \"CodeSignIdentity    : \" ) . append ( codeSignIdentity ) ; sb . append ( \"ProvisioningProfile : \" ) . append ( provisioningProfile ) ; sb . append ( \"Target              : \" ) . append ( target ) ; return sb . toString ( ) ; } private static void raiseExceptionIfNullOrEmpty ( final String key , final String value ) { if ( value == null || value . length ( ) == 0 ) throw new IllegalArgumentException ( String . format ( Locale . ENGLISH , \"No %s provided. Was null or empty.\" , key ) ) ; } private static void raiseExceptionIfInvalid ( final String key , final Collection < String > collection ) { if ( collection == null || collection . size ( ) == 0 ) throw new IllegalArgumentException ( \"No build actions has been provided (Was either null or empty).\" ) ; for ( final String buildAction : collection ) { if ( buildAction == null || buildAction . length ( ) == 0 ) throw new IllegalArgumentException ( \"Build action array", "gt": "contained a null element or an empty element.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3726, "input": "<s> package org . gatein . common . i18n ; import java . util . Locale ; import java . util . ResourceBundle ; import java . util . MissingResourceException ; public class SimpleResourceBundleFactory implements ResourceBundleFactory { private String baseName ; private ClassLoader classLoader ; public SimpleResourceBundleFactory ( String baseName , ClassLoader classLoader ) throws IllegalArgumentException { if ( baseName == null ) { throw new IllegalArgumentException ( \"No base name provided\" ) ; } if ( classLoader == null ) { throw new IllegalArgumentException ( \"No classloader provided\" ) ; } this . baseName = baseName ; this . classLoader = classLoader ; } public ResourceBundle getBundle ( Locale locale ) throws IllegalArgumentException { if ( locale == null ) { throw new IllegalArgumentException ( \"No null locale accepted\" ) ; } try { return ResourceBundle . getBundle ( baseName", "gt": ", locale , classLoader ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7054, "input": "<s> package Liza ; import org . bukkit . entity . Slime ;", "gt": "public interface LizaSlime extends Slime", "prediction": "}\n", "label": 0}
{"id": 3730, "input": "<s> package org . eclipse . ui . views ; public interface IStickyViewDescriptor { public String getId ( ) ; public int getLocation ( ) ; public boolean isCloseable ( ) ;", "gt": "public boolean isMoveable ( ) ;", "prediction": "}\n", "label": 1}
{"id": 5568, "input": "<s> package ar . com . fdvs . dj . domain . builders ; import java . util . Iterator ; import ar . com . fdvs . dj . domain . ColumnProperty ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJGroupLabel ; import ar . com . fdvs . dj . domain . DJValueFormatter ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . DJGroupVariable ; import ar . com . fdvs . dj . domain . entities . DJGroupVariableDef ; import ar . com . fdvs . dj . domain . entities . Subreport ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class GroupBuilder { private DJGroup group = new DJGroup ( ) ; private Style defaultFooterVariableStyle ; private Style defaultHeaderVariableStyle ; public GroupBuilder ( ) { } public GroupBuilder ( String name ) { group . setName ( name ) ; } public DJGroup build ( ) { for ( Iterator iterator = group . getHeaderVariables ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { DJGroupVariable var = ( DJGroupVariable ) iterator . next ( ) ; if ( defaultHeaderVariableStyle != null ) var . setStyle ( defaultHeaderVariableStyle ) ; } for ( Iterator iterator = group . getFooterVariables ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { DJGroupVariable var = ( DJGroupVariable ) iterator . next ( ) ; if ( defaultFooterVariableStyle != null ) var . setStyle ( defaultFooterVariableStyle ) ; } return group ; } public GroupBuilder setCriteriaColumn ( PropertyColumn column ) { group . setColumnToGroupBy ( column ) ; return this ; } public GroupBuilder addHeaderVariable ( DJGroupVariable variable ) { group . addHeaderVariable ( variable ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , DJCalculation operation ) { group . addHeaderVariable ( new DJGroupVariable ( column , operation ) ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , DJCalculation operation , Style style ) { group . addHeaderVariable ( new DJGroupVariable ( column , operation , style ) ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , DJCalculation operation , Style style , DJValueFormatter formatter ) { group . addHeaderVariable ( new DJGroupVariable ( column , operation , style , formatter ) ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , DJCalculation operation , Style style , DJValueFormatter formatter , DJGroupLabel glabel1 ) { group . addHeaderVariable ( new DJGroupVariable ( column , operation , style , formatter , glabel1 ) ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , CustomExpression valueExpression ) { group . addHeaderVariable ( new DJGroupVariable ( column , valueExpression ) ) ; return this ; } public GroupBuilder addHeaderVariable ( AbstractColumn column , CustomExpression valueExpression , Style style ) { group . addHeaderVariable ( new DJGroupVariable ( column ,", "gt": "valueExpression , style ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3733, "input": "<s> package org . eclipse . ui . internal . cheatsheets . state ; import java . util . Hashtable ; import java . util . Properties ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . cheatsheets . ICheatSheetManager ; import org . eclipse . ui . internal . cheatsheets . data . CheatSheetSaveHelper ; import org . eclipse . ui . internal . cheatsheets . data . IParserTags ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetElement ; import org . eclipse . ui . internal . cheatsheets . views . CheatSheetManager ; public class MementoStateManager implements ICheatSheetStateManager { private IMemento memento ; private CheatSheetElement element ; private CheatSheetSaveHelper saveHelper = new CheatSheetSaveHelper ( ) ; private Properties props ; private ICheatSheetManager parentCsm ; public MementoStateManager ( IMemento memento , ICheatSheetManager parentCsm ) { this . memento = memento ; this . parentCsm = parentCsm ; } public Properties getProperties ( ) { if ( memento == null ) { return null ; } if", "gt": "( props == null )", "prediction": "( )\n", "label": 1}
{"id": 1673, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SupportedAnnotationTypes ( \"*\" ) public class AnnoProc extends AbstractProcessor { public boolean process ( Set < ? extends TypeElement > elems , RoundEnvironment renv ) { if ( ( ++ round ) == 1 ) { Filer filer = processingEnv . getFiler ( ) ; Messager messager = processingEnv . getMessager ( ) ; try { JavaFileObject fo = filer . createSourceFile ( \"Gen\" ) ; Writer out = fo . openWriter ( ) ; out . write ( \"class Gen { }\" ) ; out . close ( ) ; } catch ( IOException e ) { messager . printMessage ( Diagnostic .", "gt": "Kind . ERROR , e . toString ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3742, "input": "<s> package org . puredata . android . scenes ; import java . io . File ; import org . puredata . android . scenes . SceneDataBase . SceneColumn ; import android . content . Context ; import android . database . Cursor ; import android . graphics . drawable . Drawable ; import android . view . View ; import android . view . ViewGroup ; import android . widget . CursorAdapter ; import android . widget . ImageView ; import android . widget . TextView ; public class SceneListCursorAdapter extends CursorAdapter { public SceneListCursorAdapter ( Context context , Cursor cursor ) { super ( context , cursor ) ; } @ Override public void bindView ( View view , Context context , Cursor cursor ) { TextView textView = ( TextView ) view . findViewById ( android . R . id . text1 ) ; textView . setText ( SceneDataBase . getString ( cursor , SceneColumn . SCENE_TITLE ) ) ; textView = ( TextView ) view . findViewById ( android . R . id . text2 ) ; textView . setText ( SceneDataBase . getString ( cursor , SceneColumn . SCENE_ARTIST ) ) ; ImageView imageView = ( ImageView ) view . findViewById ( android . R . id . selectedIcon ) ; String sceneFolder = SceneDataBase . getString (", "gt": "cursor , SceneColumn . SCENE_DIRECTORY ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2168, "input": "<s> package com . redhat . ceylon . compiler . loader ; import java . util . Collections ; import java . util . List ; import javax . lang . model . type . TypeKind ; import com . redhat . ceylon . compiler . loader . mirror . ClassMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeMirror ; public class SimpleReflType implements TypeMirror { private String name ; private TypeKind kind ; public SimpleReflType ( String name , TypeKind kind ) { this . name = name ; this . kind = kind ; } @ Override public String getQualifiedName ( ) { return name ; } @ Override", "gt": "public List < TypeMirror > getTypeArguments ( )", "prediction": "}\n", "label": 0}
{"id": 3748, "input": "<s> package org . gatein . common . util ; import org . w3c . dom . Document ; import org . xml . sax . SAXException ; import org . gatein . common . io . IOTools ; import org . gatein . common . logging . Logger ; import org . gatein . common . logging . LoggerFactory ; import org . gatein . common . xml . XMLTools ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . ParserConfigurationException ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; public abstract class LoaderResource { protected final String location ; private final Logger log = LoggerFactory . getLogger ( getClass ( ) ) ; public LoaderResource ( String location ) { if ( location == null ) { throw new IllegalArgumentException ( ) ; } this . location = location ; } public abstract boolean exists ( ) ; public abstract InputStream asInputStream ( ) throws IllegalStateException ; public String getLocation ( ) { return location ; } public Document asDocument ( DocumentBuilder builder ) throws IllegalStateException { if ( ! exists ( ) ) { throw new IllegalStateException ( \"Resource \" + location + \" does not exist\" ) ; } InputStream in = null ; try { in = IOTools . safeBufferedWrapper ( asInputStream ( ) ) ; return builder . parse ( in ) ; } catch ( SAXException e ) { IllegalStateException ex = new IllegalStateException ( \"Cannot parse stream \" + location ) ; ex . initCause ( e ) ; throw ex ; } catch ( IOException e ) { IllegalStateException ex = new IllegalStateException ( \"Cannot access stream \" + location ) ; ex . initCause ( e ) ; throw ex ; } finally { IOTools . safeClose ( in ) ; } } public Properties asProperties ( ) throws IllegalStateException { return asProperties ( false ) ; } public Properties asProperties ( boolean xml ) throws IllegalStateException { if ( ! exists ( ) ) { throw new IllegalStateException ( \"Resource \" + location + \" does not exist\" ) ; } InputStream in = null ; log . debug ( \"Loading resource: \" + location ) ; try { in = IOTools . safeBufferedWrapper ( asInputStream ( ) ) ; Properties props ; if ( xml ) { DocumentBuilder builder = XMLTools . getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; Document doc = asDocument ( builder ) ; props = XMLTools . loadXMLProperties ( doc ) ; } else { props = new Properties ( ) ; props . load ( in ) ; } log . debug ( \"Finished loading resource: \" + location ) ; return props ; } catch ( ParserConfigurationException e ) { IllegalStateException ex = new IllegalStateException ( \"Cannot parse xml stream \" + location ) ; ex . initCause ( e ) ; throw ex ; } catch ( IOException e ) { IllegalStateException ex = new IllegalStateException ( \"Cannot access stream \" + location ) ; ex . initCause ( e ) ; throw ex ; } finally { IOTools . safeClose ( in ) ; } } public String asString ( ) throws IllegalStateException { return asString ( null ) ; } public String asString ( String enc ) throws IllegalStateException { if ( ! exists ( ) ) { throw new IllegalStateException ( \"Resource \" + location + \" does not exist\" ) ; } InputStream in = null ; log . debug ( \"Loading resource: \" + location ) ; try { in = IOTools . safeBufferedWrapper ( asInputStream ( ) ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( in . available ( ) ) ;", "gt": "IOTools . copy ( in , out ) ;", "prediction": "}\n", "label": 1}
{"id": 10105, "input": "<s> package org . ofbiz . base . util . collections . test ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . ofbiz . base . test . GenericTestCaseBase ; import org . ofbiz . base . util . collections . GenericMap ; import org . ofbiz . base . util . collections . GenericMapEntry ; import org . ofbiz . base . util . collections . IteratorWrapper ; public class GenericMapTest extends GenericTestCaseBase { @ SuppressWarnings ( \"serial\" ) public static class TestGenericMap < K , V > extends GenericMap < K , V > { private static final String [ ] countNames = { \"clearInternal\" , \"containsKey\" , \"get-true\" , \"get-false\" , \"isEmpty\" , \"iterator-true\" , \"iterator-false\" , \"putInternal\" , \"putAllIterator\" , \"removeInternal-true\" , \"removeInternal-false\" , \"size\" , } ; protected final Map < String , Integer > counts = new HashMap < String , Integer > ( ) ; protected final Map < K , V > proxyMap ; protected TestGenericMap ( ) { this ( null ) ; } protected TestGenericMap ( Map < K , V > srcMap ) { for ( String countName : countNames ) { counts . put ( countName , 0 ) ; } if ( srcMap != null ) { proxyMap = new HashMap < K , V > ( srcMap ) ; } else { proxyMap = new HashMap < K , V > ( ) ; } } private void incrementCallCount ( String name ) { counts . put ( name , counts . get ( name ) + 1 ) ; } public List < Integer > getCounts ( ) { List < Integer > result = new ArrayList < Integer > ( ) ; for ( String countName : countNames ) { result . add ( counts . get ( countName ) ) ; } return result ; } @ Override protected void clearInternal ( ) { incrementCallCount ( \"clearInternal\" ) ; proxyMap . clear ( ) ; } public boolean containsKey ( Object key ) { incrementCallCount ( \"containsKey\" ) ; return proxyMap . containsKey ( key ) ; } @ Override protected V get ( Object key , boolean noteAccess ) { incrementCallCount ( \"get-\" + noteAccess ) ; return proxyMap . get ( key ) ; } public boolean isEmpty ( ) { incrementCallCount ( \"isEmpty\" ) ; return proxyMap . isEmpty ( ) ; } @ Override protected Iterator < Map . Entry < K , V > > iterator ( final boolean noteAccess ) { incrementCallCount ( \"iterator-\" + noteAccess ) ; return new IteratorWrapper < Map . Entry < K , V > , Map . Entry < K , V > > ( proxyMap . entrySet ( ) . iterator ( ) ) { @ Override protected Map . Entry < K , V > convert ( Map . Entry < K , V > src ) { return new GenericMapEntry < K , V > ( TestGenericMap . this , src . getKey ( ) , noteAccess ) ; } @ Override protected void noteRemoval ( Map . Entry < K , V > dest , Map . Entry < K , V > src ) { } } ; } public V put ( K key , V value ) { incrementCallCount ( \"putInternal\" ) ; if ( ! proxyMap . containsKey ( key ) ) incrementModCount ( ) ; return proxyMap . put ( key , value ) ; } @ Override protected < KE extends K , VE extends V > void putAllIterator ( Iterator < Map . Entry < KE , VE > > it ) { incrementCallCount ( \"putAllIterator\" ) ; while ( it . hasNext ( ) ) { Map . Entry < KE , VE > entry = it . next ( ) ; proxyMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override protected V removeInternal ( Object key , boolean incrementModCount ) { incrementCallCount ( \"removeInternal-\" + incrementModCount ) ; if ( ! proxyMap . containsKey ( key ) ) return null ; if ( incrementModCount ) incrementModCount ( ) ; return proxyMap . remove ( key ) ; } public int size ( ) { incrementCallCount ( \"size\" ) ; return proxyMap . size ( ) ; } } public GenericMapTest ( String name ) { super ( name ) ; } public void testFoo ( ) throws Exception { TestGenericMap < String , Integer > map = new TestGenericMap < String , Integer > ( ) ; map . put ( \"a\" , 0 ) ; System . err . println ( \"put a\\t\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertEquals ( \"get a\" , Integer . valueOf ( 0 ) , map . get ( \"a\" ) ) ; map . put ( \"b\" , 1 ) ; System . err . println ( \"put b\\t\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertEquals ( \"get b\" , Integer . valueOf ( 1 ) , map . get ( \"b\" ) ) ; map . put ( \"c\" , 2 ) ; System . err . println ( \"put c\\t\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertEquals ( \"get c\" , Integer . valueOf ( 2 ) , map . get ( \"c\" ) ) ; map . put ( \"d\" , 3 ) ; System . err . println ( \"put d\\t\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertEquals ( \"get d\" , Integer . valueOf ( 3 ) , map . get ( \"d\" ) ) ; map . put ( \"c\" , 22 ) ; System . err . println ( \"put c-2\\t\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertEquals ( \"get c-2\" , Integer . valueOf ( 22 ) , map . get ( \"c\" ) ) ; map . remove ( \"b\" ) ; System . err . println ( \"remove b\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; assertNull ( \"null b\" , map . get ( \"b\" ) ) ; map . remove ( \"aaa\" ) ; System . err . println ( \"remove aaa\\tcounts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; System . err . println ( \"map=\" + map ) ; System . err . println ( \"counts=\" + map . getCounts ( ) + \", modCount=\" + map . getModCount ( ) ) ; new", "gt": "HashMap < String , Integer > ( map ) ;", "prediction": "}\n", "label": 0}
{"id": 3759, "input": "<s> package org . eclipse . swt . internal . events ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Widget ; public class EventFactory { public static Event newSelectionEvent ( Widget widget , Widget item , Rectangle bounds , int stateMask , String text , boolean doit , int detail ) { Event event = newEvent ( widget , SWT . Selection ) ; event . item = item ; event . setBounds ( bounds ) ; event . stateMask = stateMask ; event . text = text ; event . doit = doit ; event . detail = detail ; return event ; } public static Event newEvent ( Widget widget , int eventType ) { Event event = new Event ( ) ; event . type = eventType ; event", "gt": ". widget = widget ;", "prediction": ";\n", "label": 1}
{"id": 1662, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class TwoXMinusHalfTransferFunction extends AbstractTransferFunction { @ Override public double getPoint ( double value ) { double result = ( 2.0 * value ) - 0.5 ; if ( result < 0 ) return 0.0 ;", "gt": "if ( result > 1.0 ) return 1.0 ;", "prediction": "}\n", "label": 0}
{"id": 3761, "input": "<s> package com . onarandombox . MultiversePortals ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . bukkit . command . Command ; import org . bukkit . command . CommandSender ; import org . bukkit . configuration . Configuration ; import org . bukkit . configuration . file . FileConfiguration ; import org . bukkit . configuration . file . YamlConfiguration ; import org . bukkit . entity . Player ; import org . bukkit . permissions . Permission ; import org . bukkit . plugin . PluginManager ; import org . bukkit . plugin . java . JavaPlugin ; import com . onarandombox . MultiverseCore . MultiverseCore ; import com . onarandombox . MultiverseCore . api . MVPlugin ; import com . onarandombox . MultiverseCore . commands . HelpCommand ; import com . onarandombox . MultiverseCore . utils . DebugLog ; import com . onarandombox . MultiversePortals . commands . ConfigCommand ; import com . onarandombox . MultiversePortals . commands . CreateCommand ; import com . onarandombox . MultiversePortals . commands . DebugCommand ; import com . onarandombox . MultiversePortals . commands . InfoCommand ; import com . onarandombox . MultiversePortals . commands . ListCommand ; import com . onarandombox . MultiversePortals . commands . ModifyCommand ; import com . onarandombox . MultiversePortals . commands . RemoveCommand ; import com . onarandombox . MultiversePortals . commands . SelectCommand ; import com . onarandombox . MultiversePortals . commands . WandCommand ; import com . onarandombox . MultiversePortals . destination . PortalDestination ; import com . onarandombox . MultiversePortals . enums . PortalConfigProperty ; import com . onarandombox . MultiversePortals . listeners . MVPBlockListener ; import com . onarandombox . MultiversePortals . listeners . MVPCoreListener ; import com . onarandombox . MultiversePortals . listeners . MVPPlayerListener ; import com . onarandombox . MultiversePortals . listeners . MVPPluginListener ; import com . onarandombox . MultiversePortals . listeners . MVPVehicleListener ; import com . onarandombox . MultiversePortals . utils . PortalManager ; import com . pneumaticraft . commandhandler . multiverse . CommandHandler ; import com . sk89q . worldedit . bukkit . WorldEditAPI ; import com . sk89q . worldedit . bukkit . WorldEditPlugin ; public class MultiversePortals extends JavaPlugin implements MVPlugin { private static final Logger log = Logger . getLogger ( \"Minecraft\" ) ; private static final String logPrefix = \"[Multiverse-Portals] \" ; protected static DebugLog debugLog ; private MultiverseCore core ; private FileConfiguration MVPPortalConfig ; private FileConfiguration MVPConfig ; private CommandHandler commandHandler ; protected WorldEditAPI worldEditAPI = null ; private PortalManager portalManager ; private Map < Player , PortalPlayerSession > portalSessions ; public static final int DEFAULT_WAND = 271 ; private long portalCooldown = 0 ; private final static int requiresProtocol = 9 ; public static boolean UseOnMove = true ; public static boolean EnforcePortalAccess = true ; public static boolean WandEnabled = true ; public static boolean ClearOnRemove = false ; public static boolean TeleportVehicles = true ; public static List < Integer > FrameMaterials = null ; public void onLoad ( ) { getDataFolder ( ) . mkdirs ( ) ; } public void onEnable ( ) { this . core = ( MultiverseCore ) getServer ( ) . getPluginManager ( ) . getPlugin ( \"Multiverse-Core\" ) ; if ( this . core == null ) { log . info ( logPrefix + \"Multiverse-Core not found, will keep looking.\" ) ; getServer ( ) . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( this . core . getProtocolVersion ( ) < requiresProtocol ) { log . severe ( logPrefix + \"Your Multiverse-Core is OUT OF DATE\" ) ; log . severe ( logPrefix + \"This version of Multiverse Portals requires Protocol Level: \" + requiresProtocol ) ; log . severe ( logPrefix + \"Your of Core Protocol Level is: \" + this . core . getProtocolVersion ( ) ) ; log . severe ( logPrefix + \"Grab an updated copy at: \" ) ; log . severe ( logPrefix + \"http://bukkit.onarandombox.com/?dir=multiverse-core\" ) ; getServer ( ) . getPluginManager ( ) . disablePlugin ( this ) ; return ; } log . info ( logPrefix + \"- Version \" + this . getDescription ( ) . getVersion ( ) + \" Enabled - By \" + getAuthors ( ) ) ; debugLog = new DebugLog ( \"Multiverse-Portals\" , getDataFolder ( ) + File . separator + \"debug.log\" ) ; this . core . incrementPluginCount ( ) ; this . registerCommands ( ) ; this . createDefaultPerms ( ) ; this . portalManager = new PortalManager ( this ) ; this . portalSessions = new HashMap < Player , PortalPlayerSession > ( ) ; this . getCore ( ) . getDestFactory ( ) . registerDestinationType ( PortalDestination . class , \"p\" ) ; this . loadPortals ( ) ; this . loadConfig ( ) ; this . registerEvents ( ) ; this . checkForWorldEdit ( ) ; } private void registerEvents ( ) { MVPPluginListener pluginListener = new MVPPluginListener ( this ) ; MVPPlayerListener playerListener = new MVPPlayerListener ( this ) ; MVPBlockListener blockListener = new MVPBlockListener ( this ) ; MVPVehicleListener vehicleListener = new MVPVehicleListener ( this ) ; MVPCoreListener coreListener = new MVPCoreListener ( this ) ; PluginManager pm = getServer ( ) . getPluginManager ( ) ; pm . registerEvents ( pluginListener , this ) ; pm . registerEvents ( playerListener , this ) ; pm . registerEvents ( blockListener , this ) ; if ( MultiversePortals . TeleportVehicles ) { pm . registerEvents ( vehicleListener , this ) ; } pm . registerEvents ( coreListener , this ) ; } private void checkForWorldEdit ( ) { if ( this . getServer ( ) . getPluginManager ( ) . getPlugin ( \"WorldEdit\" ) != null ) { this . worldEditAPI = new WorldEditAPI ( ( WorldEditPlugin ) this . getServer ( ) . getPluginManager ( ) . getPlugin ( \"WorldEdit\" ) ) ; } } private void createDefaultPerms ( ) { if ( this . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.*\" ) == null ) { Permission perm = new Permission ( \"multiverse.portal.*\" ) ; this . getServer ( ) . getPluginManager ( ) . addPermission ( perm ) ; } if ( this . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.access.*\" ) == null ) { Permission perm = new Permission ( \"multiverse.portal.access.*\" ) ; this . getServer ( ) . getPluginManager ( ) . addPermission ( perm ) ; } if ( this . getServer ( ) .", "gt": "getPluginManager ( ) . getPermission ( \"multiverse.portal.fill.*\" ) == null )", "prediction": ") ;\n", "label": 1}
{"id": 3156, "input": "<s> package exceptions ; public class NoUsernameOrPasswordException extends Exception { private static final long serialVersionUID = 3996381168010389844L ; public NoUsernameOrPasswordException ( String message ) {", "gt": "super ( message ) ;", "prediction": "\n", "label": 0}
{"id": 3767, "input": "<s> package com . androidmapballoons . library ; import android . content . Context ; import android . view . Gravity ; import android . view . LayoutInflater ; import android . view . View ; import android . widget . FrameLayout ; import android . widget . ImageView ; import android . widget . LinearLayout ; import android . widget . TextView ; import com . example . tourapp . R ; import com . example . tourapp . R . id ; import com . example . tourapp . R . layout ; import com . google . android . maps . OverlayItem ; public class BalloonOverlayView < Item extends OverlayItem > extends FrameLayout { private LinearLayout layout ; private TextView title ; private TextView snippet ; public BalloonOverlayView ( Context context , int balloonBottomOffset ) { super ( context ) ; setPadding ( 10 , 0 , 10 , balloonBottomOffset ) ; layout = new LinearLayout ( context ) ; layout . setVisibility ( VISIBLE ) ; LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View v = inflater . inflate ( R . layout . balloon_overlay , layout ) ; title = ( TextView ) v . findViewById ( R . id . balloon_item_title ) ; snippet = ( TextView ) v . findViewById ( R . id . balloon_item_snippet ) ; ImageView close = ( ImageView ) v . findViewById ( R . id . close_img_button ) ; close . setOnClickListener ( new OnClickListener ( ) { public void onClick ( View v ) { layout . setVisibility ( GONE ) ; } } ) ; FrameLayout . LayoutParams params = new FrameLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; params . gravity = Gravity . NO_GRAVITY ; addView ( layout , params ) ; } public void setData ( Item item ) { layout . setVisibility ( VISIBLE ) ; if ( item . getTitle", "gt": "( ) != null )", "prediction": "( ) ;\n", "label": 1}
{"id": 7270, "input": "<s> package org . ofbiz . entity . sql ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityFieldValue ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . sql . BooleanCondition ; import org . ofbiz . sql . Condition ; import org . ofbiz . sql . ConditionList ; import org . ofbiz . sql . ConditionPlanner ; import org . ofbiz . sql . FieldValue ; import org . ofbiz . sql . Joiner ; import org . ofbiz . sql . NumberValue ; import org . ofbiz . sql . ParameterValue ; import org . ofbiz . sql . ParameterizedConditionException ; import org . ofbiz . sql . StringValue ; import org . ofbiz . sql . Value ; public class EntityConditionPlanner implements ConditionPlanner < EntityCondition > { public EntityCondition parse ( Condition condition , Map < String , ? extends Object > params ) throws ParameterizedConditionException { if ( condition == null ) return null ; if ( condition instanceof BooleanCondition ) { BooleanCondition bc = ( BooleanCondition ) condition ; return EntityCondition . makeCondition ( buildFieldValue ( bc . getLeft ( ) ) , EntityOperator . lookupComparison ( bc . getOp ( ) ) , buildValue ( bc . getRight ( ) , params ) ) ; } else if ( condition instanceof ConditionList ) { ConditionList cl = ( ConditionList ) condition ; List < EntityCondition > conditions = FastList . newInstance ( ) ; for ( Condition subCondition : cl ) { conditions . add ( parse ( subCondition , params ) ) ; } return EntityCondition . makeCondition ( conditions , cl . getJoiner ( ) == Joiner . AND ? EntityOperator . AND : EntityOperator . OR ) ; } else { throw new UnsupportedOperationException ( condition .", "gt": "toString ( ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 3777, "input": "<s> package org . apache . sqoop . io ; import java . io . IOException ; import java . io . InputStream ; import org . apache . commons . io . input . CloseShieldInputStream ; import org . apache . commons . io . input . CountingInputStream ; import org . apache . commons . io . input . ProxyInputStream ; public class FixedLengthInputStream extends ProxyInputStream { private CountingInputStream countingIn ; private long maxBytes ; public FixedLengthInputStream ( InputStream stream , long maxLen ) { super ( new CountingInputStream ( new CloseShieldInputStream ( stream ) ) ) ; this . countingIn = ( CountingInputStream ) this . in ; this . maxBytes = maxLen ; } private long consumed ( ) { return countingIn . getByteCount ( ) ; } private long toLimit ( ) { return maxBytes - consumed ( ) ; } @ Override public int available ( ) throws IOException { return ( int ) Math . min ( toLimit ( ) , countingIn . available ( ) ) ; } @ Override public int read ( ) throws IOException { if ( toLimit", "gt": "( ) > 0 )", "prediction": ")\n", "label": 1}
{"id": 821, "input": "<s> package org . ofbiz . base . config ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Collections ; import net . sourceforge . cobertura . coveragedata . CoverageDataFileHandler ; import net . sourceforge . cobertura . coveragedata . ProjectData ; import org . objectweb . asm . ClassReader ; import org . objectweb . asm . ClassVisitor ; import org . objectweb . asm . ClassWriter ; import org . ofbiz . base . start . Instrumenter ; public final class CoberturaInstrumenter implements Instrumenter { private static final Constructor < ? > INSTRUMENTER_CONSTRUCTOR ; private static final Method IS_INSTRUMENTED_METHOD ; static { try { Class < ? > clz = CoberturaInstrumenter . class . getClassLoader ( ) . loadClass ( \"net.sourceforge.cobertura.instrument.ClassInstrumenter\" ) ; INSTRUMENTER_CONSTRUCTOR = clz . getConstructor ( ProjectData . class , ClassVisitor . class , Collection . class , Collection . class ) ; INSTRUMENTER_CONSTRUCTOR . setAccessible ( true ) ; IS_INSTRUMENTED_METHOD = clz . getDeclaredMethod ( \"isInstrumented\" ) ; IS_INSTRUMENTED_METHOD . setAccessible ( true ) ; } catch ( Throwable t ) { throw ( InternalError ) new InternalError ( t . getMessage ( ) ) . initCause ( t ) ; } } protected File dataFile ; protected ProjectData projectData ; protected boolean forInstrumenting ; public File getDefaultFile ( ) throws IOException { return CoverageDataFileHandler . getDefaultDataFile ( ) ; } public void open ( File dataFile , boolean forInstrumenting ) throws IOException { System . setProperty ( \"net.sourceforge.cobertura.datafile\" , dataFile . toString ( ) ) ; this . forInstrumenting = forInstrumenting ; this . dataFile = dataFile ; if ( forInstrumenting ) { if ( dataFile . exists ( ) ) { projectData = CoverageDataFileHandler . loadCoverageData ( dataFile ) ; } else { projectData = new ProjectData ( ) ; } } } public void close ( ) throws IOException { if ( forInstrumenting ) { CoverageDataFileHandler . saveCoverageData ( projectData , dataFile ) ; } } public byte [ ] instrumentClass ( byte [ ] bytes ) throws IOException { if ( forInstrumenting ) { ClassReader cr = new ClassReader ( bytes ) ; ClassWriter cw = new", "gt": "ClassWriter ( ClassWriter . COMPUTE_MAXS ) ;", "prediction": ";\n", "label": 0}
{"id": 3799, "input": "<s> package org . nuxeo . ecm . platform . audit . job ; import java . util . Date ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . audit . api . AuditReader ; import org . nuxeo . ecm . platform . audit . api . job . JobHistoryHelper ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . test . NXRuntimeTestCase ; public class TestJobHistoryHelper extends NXRuntimeTestCase { @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.core.persistence\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.audit\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.audit.tests\" ) ; deployTestContrib ( \"org.nuxeo.ecm.platform.audit.tests\" , \"nxaudit-tests.xml\" ) ; fireFrameworkStarted ( ) ; } @ Test public void testLogger ( ) throws Exception { StringBuffer query = new StringBuffer ( \"from LogEntry log where \" ) ; query . append ( \" log.category='\" ) ; query . append ( \"MyExport\" ) ; query . append ( \"'  ORDER BY log.eventDate DESC\" ) ; AuditReader reader = Framework . getService ( AuditReader . class ) ; List result = reader . nativeQuery ( query . toString ( ) , 1 , 1 ) ; assertEquals ( 0 , result . size ( ) ) ; JobHistoryHelper helper = new JobHistoryHelper ( \"MyExport\" ) ; helper . logJobStarted ( ) ; helper . logJobFailed ( \"some error\" ) ; helper . logJobEnded ( ) ; result = reader . nativeQuery ( query . toString ( ) , 1 , 10 ) ; assertEquals ( 3 , result . size ( ) ) ; } @ Test public void testLoggerHelper ( ) throws Exception { JobHistoryHelper helper = new JobHistoryHelper ( \"MyExport2\" ) ; helper . logJobStarted ( ) ; Date exportDate = helper . getLastSuccessfulRun ( ) ; assertNull ( exportDate ) ; helper . logJobFailed ( \"some other error\" ) ; exportDate = helper . getLastSuccessfulRun ( ) ; assertNull ( exportDate ) ; helper . logJobEnded ( ) ; exportDate = helper . getLastSuccessfulRun ( ) ; assertNotNull ( exportDate ) ; Thread . sleep ( 3000 ) ; long t0 = System . currentTimeMillis ( ) ; exportDate = helper . getLastSuccessfulRun ( ) ; long loggedT0 = exportDate . getTime ( ) ; assertTrue ( loggedT0 < t0 ) ; helper . logJobEnded ( ) ; exportDate = helper . getLastSuccessfulRun ( ) ; long loggedT1 = exportDate", "gt": ". getTime ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3259, "input": "<s> public class T6611449 < S > { < T extends S > T6611449 ( T t1 ) { } < T extends S > T6611449 ( T t1 , T t2 ) { } < T extends S > void m1 ( T t1 ) { } < T extends S > void m2 ( T t1 , T t2 ) { } void test ( ) { new T6611449 < S > ( 1 ) ; new T6611449 < S > (", "gt": "1 , 1 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3816, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . restlet . test . ext . jaxrs . services . tests . InheritAnnotationTest ; @ Path ( \"1234\" ) public class InheritAnnotationTestService2 implements InheritAnnotationTestServiceInterface { public class GetTextResource { @ GET @ Produces ( \"text/plain\" ) public String get ( ) { return RETURN_STRING ; } } public class SubClassResource extends GetTextResource { @ Override public String get ( ) { return RETURN_STRING_SUB ; } @ Path ( \"sub\" ) public SubClassResource2 getSub ( ) { return new SubClassResource2 ( ) ; } } public class SubClassResource2 { @ GET @ Produces ( \"text/plain\" ) public String get ( ) { return RETURN_STRING_SUB2 ; } } public static final String RETURN_STRING = \"fromGetTextResource\" ; public static final String RETURN_STRING_SUB = \"fromGetTextExtResource\" ; public static", "gt": "final String RETURN_STRING_SUB2 = \"fromGetTextExt2Resource\" ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9485, "input": "<s> class DefAssignAfterIf_2 { void test ( ) { int i ; if ( false ) i = 3 ;", "gt": "System . out . println ( i ) ;", "prediction": "}\n", "label": 0}
{"id": 3829, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec2 . sub8 ; import java . io . IOException ; import org . restlet . data . Reference ; import org . restlet . ext . jaxb . JaxbRepresentation ; import org . restlet . representation . Representation ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; import org . restlet . resource . ServerResource ; public class MailServerResource extends ServerResource { @ Get public Representation toXml ( ) { Mail mail = new Mail ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( ) . toString ( ) ) ; JaxbRepresentation < Mail > result = new JaxbRepresentation < Mail > ( mail ) ; result . setFormattedOutput ( true ) ; return result ; } @", "gt": "Put public void store ( Representation rep ) throws IOException", "prediction": "}\n", "label": 1}
{"id": 1321, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface RollupAccount extends ReportAttribute {", "gt": "LogicalExpression getExpression ( ) ;", "prediction": "return ;\n", "label": 0}
{"id": 3831, "input": "<s> package br . org . archimedes . rcp ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; public interface ExtensionTagHandler { public void handleTag ( IConfigurationElement", "gt": "tag ) throws CoreException ;", "prediction": ")\n", "label": 1}
{"id": 8255, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . ClassWriter ; import org . parboiled . common . ImmutableList ; import java . util . List ; import static org . parboiled . transform . AsmUtils . * ; public class ParserTransformer { private ParserTransformer ( ) { } @ SuppressWarnings ( { \"unchecked\" } ) public static synchronized < T > Class < ? extends T > transformParser ( Class < T > parserClass ) throws Exception { checkArgNotNull ( parserClass , \"parserClass\" ) ; Class < ? > extendedClass = findLoadedClass ( getExtendedParserClassName ( parserClass . getName ( ) ) , parserClass . getClassLoader ( ) ) ; return ( Class < ? extends T > ) ( extendedClass != null ? extendedClass : extendParserClass ( parserClass ) . getExtendedClass ( ) ) ; } static ParserClassNode extendParserClass ( Class < ? > parserClass ) throws Exception { ParserClassNode classNode = new ParserClassNode ( parserClass ) ; new ClassNodeInitializer ( ) . process ( classNode ) ; runMethodTransformers ( classNode ) ; new ConstructorGenerator ( ) . process ( classNode ) ; defineExtendedParserClass ( classNode ) ; return classNode ; } @ SuppressWarnings ( { \"unchecked\" } ) private static void runMethodTransformers ( ParserClassNode classNode ) throws Exception { List < RuleMethodProcessor > methodProcessors = createRuleMethodProcessors ( ) ; for ( RuleMethod ruleMethod : classNode . getRuleMethods ( ) . values ( ) ) { if ( ! ruleMethod . hasDontExtend ( ) ) { for ( RuleMethodProcessor methodProcessor : methodProcessors ) {", "gt": "if ( methodProcessor . appliesTo ( classNode , ruleMethod ) )", "prediction": ";\n", "label": 0}
{"id": 3836, "input": "<s> package org . apache . lucene . store . instantiated ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermEnum ; import java . io . IOException ; import java . util . Arrays ; public class InstantiatedTermEnum extends TermEnum { private final InstantiatedIndexReader reader ; public InstantiatedTermEnum ( InstantiatedIndexReader reader ) { this . nextTermIndex = 0 ; this . reader = reader ; } public InstantiatedTermEnum ( InstantiatedIndexReader reader , int startPosition ) { this . reader = reader ; this . nextTermIndex = startPosition ; next ( ) ; } private int nextTermIndex ; private InstantiatedTerm term ; public boolean next ( ) { if ( reader . getIndex ( ) . getOrderedTerms ( ) . length <= nextTermIndex ) { return false ; } else { term = reader . getIndex ( ) . getOrderedTerms ( ) [ nextTermIndex ] ; nextTermIndex ++ ; return true ; } } public Term term ( ) { return term == null ? null : term . getTerm ( ) ; } public int docFreq ( ) { return term . getAssociatedDocuments ( ) . length ; } public void close ( ) { } public boolean skipTo ( Term target ) throws IOException { if ( reader . getIndex ( ) . getOrderedTerms ( ) . length == 0 ) { return false ; } InstantiatedTerm term = reader . getIndex ( ) . findTerm ( target ) ; if ( term != null ) { this . term = term ; nextTermIndex = term . getTermIndex ( ) + 1 ; return true ; } else { int pos = Arrays . binarySearch ( reader . getIndex ( ) . getOrderedTerms ( ) , target , InstantiatedTerm . termComparator ) ; if ( pos < 0 ) { pos = - 1 - pos ; } if ( pos > reader . getIndex ( ) . getOrderedTerms ( ) . length ) { return false ; } this . term = reader . getIndex ( )", "gt": ". getOrderedTerms ( ) [ pos ] ;", "prediction": ";\n", "label": 1}
{"id": 5506, "input": "<s> package com . sun . tools . javadoc ; import com . sun . javadoc . * ; import com . sun . tools . javac . code . Symbol . ClassSymbol ; import com . sun . tools . javac . code . Symbol . MethodSymbol ; import com . sun . tools . javac . tree . JCTree . JCMethodDecl ; import com . sun . tools . javac . util . Position ; public class ConstructorDocImpl extends ExecutableMemberDocImpl implements ConstructorDoc { public ConstructorDocImpl ( DocEnv env , MethodSymbol sym ) { super ( env , sym ) ; } public ConstructorDocImpl ( DocEnv env , MethodSymbol sym , String docComment , JCMethodDecl tree , Position . LineMap lineMap ) { super ( env , sym , docComment , tree , lineMap ) ; } public boolean isConstructor ( ) { return true ; } public String name ( ) { ClassSymbol c = sym . enclClass ( ) ; String n = c . name . toString ( ) ; for ( c = c .", "gt": "owner . enclClass ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3860, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . INullSelectionListener ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchWindow ; public class WindowPartSelectionTracker extends AbstractPartSelectionTracker implements IPageListener { private IWorkbenchWindow fWindow ; private final INullSelectionListener selListener = new INullSelectionListener ( ) { public void selectionChanged ( IWorkbenchPart part , ISelection selection ) { fireSelection ( part , selection ) ; } } ; private final INullSelectionListener postSelListener = new INullSelectionListener ( ) { public void selectionChanged ( IWorkbenchPart part , ISelection selection ) { firePostSelection ( part , selection ) ; } } ; public WindowPartSelectionTracker ( IWorkbenchWindow window , String partId ) { super ( partId ) ; setWindow ( window ) ; window . addPageListener ( this ) ; IWorkbenchPage [ ] pages = window . getPages ( ) ; for ( int i = 0 ; i < pages . length ; i ++ ) { pageOpened ( pages [ i ] ) ; } } public void pageActivated ( IWorkbenchPage page ) { } public void pageClosed ( IWorkbenchPage page ) { page . removeSelectionListener ( getPartId ( ) , selListener ) ; page . removePostSelectionListener ( getPartId ( ) , postSelListener ) ; } public void pageOpened ( IWorkbenchPage page ) { page . addSelectionListener ( getPartId ( ) , selListener ) ; page . addPostSelectionListener ( getPartId ( ) , postSelListener ) ; } private void", "gt": "setWindow ( IWorkbenchWindow window )", "prediction": "( ) ;\n", "label": 1}
{"id": 7308, "input": "<s> import org . parboiled . common . FileUtils ; import org . parboiled . common . ImmutableList ; import org . scalatest . testng . TestNGWrapperSuite ; import java . io . File ; import java . io . IOException ; import static scala . collection . JavaConversions . collectionAsScalaIterable ; @ SuppressWarnings ( \"unchecked\" ) public class ExamplesJavaTestWrapper extends TestNGWrapperSuite { public ExamplesJavaTestWrapper ( ) throws IOException { super ( collectionAsScalaIterable ( ImmutableList . of ( getSuiteFileName ( ) ) ) . toList ( ) ) ; } public static String getSuiteFileName ( ) throws IOException { File temp = File . createTempFile", "gt": "( \"parboiled_testng_suite\" , \".xml\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 3866, "input": "<s> package org . restlet . test . ext . jaxb ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlRootElement public class Sample { @ XmlElement ( name = \"value\" ) private String val ; public Sample ( ) { } public", "gt": "Sample ( String val )", "prediction": "void ( )\n", "label": 1}
{"id": 8502, "input": "<s> package org . ofbiz . base . crypto ; import java . security . NoSuchAlgorithmException ; import java . security . InvalidKeyException ; import java . security . InvalidAlgorithmParameterException ; import java . security . spec . InvalidKeySpecException ; import javax . crypto . Cipher ; import javax . crypto . IllegalBlockSizeException ; import javax . crypto . BadPaddingException ; import javax . crypto . SecretKey ; import javax . crypto . NoSuchPaddingException ; import javax . crypto . KeyGenerator ; import javax . crypto . SecretKeyFactory ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . DESedeKeySpec ; import org . ofbiz . base . util . GeneralException ; public class DesCrypt { public static final String module = DesCrypt . class . getName ( ) ; public static SecretKey generateKey ( ) throws NoSuchAlgorithmException { KeyGenerator keyGen = KeyGenerator . getInstance ( \"DESede\" ) ; return keyGen . generateKey ( ) ; } public static byte [ ] encrypt ( SecretKey key , byte [ ] bytes ) throws GeneralException { Cipher cipher = DesCrypt . getCipher ( key , Cipher . ENCRYPT_MODE ) ; byte [ ] encBytes = null ; try { encBytes = cipher . doFinal ( bytes ) ; } catch ( IllegalStateException e ) { throw new GeneralException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new GeneralException ( e ) ; } catch ( BadPaddingException e ) { throw new GeneralException ( e ) ; } return encBytes ; } public static byte [ ] decrypt ( SecretKey key , byte [ ] bytes ) throws GeneralException { Cipher cipher = DesCrypt . getCipher ( key , Cipher . DECRYPT_MODE ) ; byte [ ] decBytes = null ; try { decBytes = cipher . doFinal ( bytes ) ; } catch ( IllegalStateException e ) { throw new GeneralException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new GeneralException ( e ) ; } catch ( BadPaddingException e ) { throw new GeneralException ( e ) ; } return decBytes ; } public static SecretKey getDesKey ( byte [ ] rawKey ) throws GeneralException { SecretKeyFactory skf = null ; try { skf = SecretKeyFactory . getInstance ( \"DESede\" ) ; } catch ( NoSuchAlgorithmException e ) { throw new GeneralException ( e ) ; } if ( rawKey . length > 0 ) { DESedeKeySpec desedeSpec1 = null ; try { desedeSpec1 = new DESedeKeySpec ( rawKey ) ; } catch ( InvalidKeyException e ) {", "gt": "throw new GeneralException ( e ) ;", "prediction": "}\n", "label": 0}
{"id": 3891, "input": "<s> package org . eclipse . rap . internal . design . example . business . layoutsets ; import org . eclipse . rap . internal . design . example . ILayoutSetConstants ; import org . eclipse . rap . ui . interactiondesign . layout . model . ILayoutSetInitializer ; import org . eclipse . rap . ui . interactiondesign . layout . model . LayoutSet ; public class MenuBarInitializer implements ILayoutSetInitializer { public void initializeLayoutSet ( final LayoutSet layoutSet ) { String path = ILayoutSetConstants . IMAGE_PATH_BUSINESS ; layoutSet . addImagePath ( ILayoutSetConstants", "gt": ". MENUBAR_ARROW , path + \"menu_arrow.png\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 301, "input": "<s> import java . util . List ; import java . util . ArrayList ; public class T6253161 { @ SuppressWarnings ( \"unchecked\" ) public void anonymousMethod ( ) { List list = new ArrayList < String > ( ) { static final long serialVersionUID = 1 ; List list = new ArrayList < Integer > ( ) ; public List < Integer > getMyList ( ) { final List floatList = new ArrayList < Float > ( ) { List integerList = new ArrayList < Float > ( ) ; public List < Float > getMyList ( ) { for ( int i = 0 ; i < 10 ; i ++ ) integerList . add ( ( int ) ( ( Float . parseFloat ( i + \"\" ) )", "gt": "+ ( 1.11F ) ) ) ;", "prediction": ";\n", "label": 0}
{"id": 3895, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IPersistableElement ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . IWorkingSetManager ; import org . eclipse . ui . internal . util . Util ; public abstract class AbstractWorkingSet implements IAdaptable , IWorkingSet { protected static final String FACTORY_ID = \"org.eclipse.ui.internal.WorkingSetFactory\" ; static final String TAG_AGGREGATE = \"aggregate\" ; private String name ; protected ArrayList elements ; private IWorkingSetManager manager ; protected IMemento workingSetMemento ; private String label ; private String uniqueId ; private static int counter ; private boolean labelBoundToName ; public AbstractWorkingSet ( String name , String label ) { Assert . isNotNull ( name , \"name must not be null\" ) ; this . name = name ; this . label = label ; labelBoundToName = Util . equals ( name , label ) ; uniqueId = Long . toString ( System . currentTimeMillis ( ) ) + \"_\" + counter ++ ; } public Object getAdapter ( Class adapter ) { if ( adapter == IWorkingSet . class || adapter == IPersistableElement . class ) { return this ; } return Platform . getAdapterManager ( ) . getAdapter ( this , adapter ) ; } public String getName ( ) { return name ; } public void setName ( String newName ) { Assert . isNotNull ( newName , \"Working set name must not be null\" ) ; if ( manager != null ) { IWorkingSet wSet = manager . getWorkingSet ( newName ) ; if ( wSet != this ) { Assert . isTrue ( wSet == null , \"working set with same name already registered\" ) ; } } name = newName ; fireWorkingSetChanged ( IWorkingSetManager . CHANGE_WORKING_SET_NAME_CHANGE , null ) ; if ( labelBoundToName ) { setLabel ( newName ) ; } } public void connect ( IWorkingSetManager manager ) { Assert . isTrue ( this . manager == null , \"A working set can only be connected to one manager\" ) ; this . manager = manager ; } public void disconnect ( ) { this . manager = null ; } protected void fireWorkingSetChanged ( String property , Object oldValue ) { AbstractWorkingSetManager receiver = manager != null ? ( AbstractWorkingSetManager ) manager : ( AbstractWorkingSetManager ) WorkbenchPlugin . getDefault ( ) . getWorkingSetManager ( ) ; receiver . workingSetChanged ( this , property , oldValue ) ; } protected void internalSetElements ( IAdaptable [ ] newElements ) { Assert . isNotNull ( newElements , \"Working set elements array must not be null\" ) ; elements = new ArrayList ( newElements . length ) ; for ( int i = 0 ; i < newElements . length ; i ++ ) {", "gt": "elements . add ( newElements [ i ] ) ;", "prediction": "}\n", "label": 1}
{"id": 7053, "input": "<s> public class TestDocErrorReporter extends JavadocTester { private static final String BUG_ID = \"4927928\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"-encoding\" , \"xyz\" , SRC_DIR + FS + \"TestDocErrorReporter.java\" } ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final int EXPECTED_EXIT_CODE = 1 ; public static void main", "gt": "( String [ ] args )", "prediction": ";\n", "label": 0}
{"id": 3924, "input": "<s> package org . eclipse . ui . internal . cheatsheets . registry ; import org . eclipse . core . runtime . * ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . IPluginContribution ; import org . eclipse . ui . cheatsheets . CheatSheetListener ; import org . eclipse . ui . internal . cheatsheets . * ; import org . eclipse . ui . model . WorkbenchAdapter ; import org . eclipse . ui . model . IWorkbenchAdapter ; import org . osgi . framework . Bundle ; public class CheatSheetElement extends WorkbenchAdapter implements IAdaptable , IPluginContribution { private String contentFile ; private String id ; private String name ; private String description ; private IConfigurationElement configurationElement ; private String listenerClass ; private boolean composite ; private boolean registered = false ; private String contentXml ; private String href ; public CheatSheetElement ( String name ) { this . name = name ; } public Object getAdapter ( Class adapter ) { if ( adapter == IWorkbenchAdapter . class ) { return this ; } return Platform . getAdapterManager ( ) . getAdapter ( this , adapter ) ; } public IConfigurationElement getConfigurationElement ( ) { return configurationElement ; } public String getContentFile ( ) { return contentFile ; } public String getDescription ( ) { return description ; } public String getID ( ) { return id ; } public String getLabel ( Object element ) { return name ; } public String getListenerClass ( ) { return listenerClass ; } public void setConfigurationElement ( IConfigurationElement newConfigurationElement ) { configurationElement = newConfigurationElement ; } public void setContentFile ( String value ) { contentFile = value ; } public void setDescription ( String value ) { description = value ; } public void setID ( String value ) { id = value ; } public void setListenerClass ( String value ) { listenerClass = value ; } public CheatSheetListener createListenerInstance ( ) { if ( listenerClass == null || configurationElement == null ) { return null ; } Class extClass = null ; CheatSheetListener listener = null ; String pluginId = configurationElement . getContributor ( ) . getName ( ) ; try { Bundle bundle = Platform . getBundle ( pluginId ) ; extClass = bundle . loadClass ( listenerClass ) ; } catch ( Exception e ) { String message = NLS . bind ( Messages . get ( ) . ERROR_LOADING_CLASS , ( new Object [ ] { listenerClass } ) ) ; IStatus status = new Status ( IStatus . ERROR , ICheatSheetResource . CHEAT_SHEET_PLUGIN_ID", "gt": ", IStatus . OK , message , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7684, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; public class AnnotationTypeOptionalMemberBuilder extends AnnotationTypeRequiredMemberBuilder { private AnnotationTypeOptionalMemberBuilder ( Configuration configuration ) { super ( configuration ) ; } public static AnnotationTypeOptionalMemberBuilder getInstance ( Configuration configuration , ClassDoc classDoc , AnnotationTypeOptionalMemberWriter writer ) { AnnotationTypeOptionalMemberBuilder builder = new AnnotationTypeOptionalMemberBuilder ( configuration ) ; builder . classDoc = classDoc ; builder . writer = writer ; builder . visibleMemberMap = new VisibleMemberMap ( classDoc , VisibleMemberMap . ANNOTATION_TYPE_MEMBER_OPTIONAL , configuration . nodeprecated ) ; builder . members = new ArrayList < ProgramElementDoc > ( builder . visibleMemberMap . getMembersFor ( classDoc ) ) ; if ( configuration . getMemberComparator ( ) != null ) { Collections . sort ( builder . members , configuration . getMemberComparator ( ) ) ; } return builder ; } @ Override public String getName ( ) { return \"AnnotationTypeOptionalMemberDetails\" ; } public void buildAnnotationTypeOptionalMember ( XMLNode node , Content memberDetailsTree ) { buildAnnotationTypeMember ( node , memberDetailsTree ) ; } public void buildDefaultValueInfo ( XMLNode node , Content annotationDocTree ) { ( ( AnnotationTypeOptionalMemberWriter ) writer ) . addDefaultValueInfo ( ( MemberDoc", "gt": ") members . get ( currentMemberIndex ) , annotationDocTree ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3932, "input": "<s> package org . gatein . common . io ; import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPOutputStream ; import java . util . zip . GZIPInputStream ; public interface SerializationFilter { SerializationFilter TRIVIAL = new SerializationFilter ( ) { public < T > void serialize ( Serialization < T > serialization , T t , OutputStream out ) throws IllegalArgumentException , IOException { serialization . serialize ( t , out ) ; } public < T > T unserialize ( Serialization < T > serialization , InputStream in ) throws IllegalArgumentException , IOException { return serialization . unserialize ( in ) ; } } ; SerializationFilter COMPRESSOR = new SerializationFilter ( ) { public < T > void serialize ( Serialization < T > serialization , T t , OutputStream out ) throws IllegalArgumentException , IOException { GZIPOutputStream zos = new GZIPOutputStream ( out ) ; serialization . serialize ( t , zos ) ; zos . finish ( ) ; } public < T > T unserialize ( Serialization < T > serialization , InputStream", "gt": "in ) throws IllegalArgumentException , IOException", "prediction": ")\n", "label": 1}
{"id": 9151, "input": "<s> import java . io . * ; import java . util . * ; public class TestHelpOpts { public static void main ( String ... args ) throws Exception { new TestHelpOpts ( ) . run ( ) ; } void run ( ) throws Exception { Locale prev = Locale . getDefault ( ) ; try { Locale . setDefault ( Locale . ENGLISH ) ; String [ ] opts = { \"-h\" , \"-help\" , \"-?\" , \"--help\" } ; for ( String opt : opts ) test ( opt ) ; } finally { Locale . setDefault ( prev ) ; } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void test ( String opt ) { System . err . println ( \"test \" + opt ) ; String [ ] args = { opt } ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javah . Main . run ( args , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; if ( ! out . isEmpty ( ) ) System . err . println ( out ) ; if ( rc != 0 ) error ( \"Unexpected exit: rc=\" + rc ) ; String flat = out . replaceAll ( \"\\\\s+\" , \" \" ) ; if ( ! flat . contains ( \"Usage: javah [options] <classes> where [options] include:\" ) ) error ( \"expected text not found\" ) ; if ( flat . contains ( \"main.opt\" ) ) error ( \"key not found in resource bundle: \" + flat", "gt": ". replaceAll ( \".*(main.opt.[^ ]*).*\" , \"$1\" ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3970, "input": "<s> package org . jscsi . initiator . connection . state ; import java . util . LinkedList ; import java . util . Queue ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . data . DataOutParser ; import org . jscsi . parser . datasegment . IDataSegmentIterator ; import org . jscsi . parser . datasegment . IDataSegmentIterator . IDataSegmentChunk ; import org . jscsi . parser . datasegment . OperationalTextKey ; public final class WriteFirstBurstState extends AbstractState { private IDataSegmentIterator iterator ; private final int targetTransferTag ; private int dataSequenceNumber ; private int bufferOffset ; public WriteFirstBurstState ( final Connection initConnection , final IDataSegmentIterator initIterator , final int initTargetTransferTag , final int initDataSequenceNumber , final int initBufferOffset ) { super ( initConnection ) ; iterator = initIterator ; targetTransferTag = initTargetTransferTag ; dataSequenceNumber = initDataSequenceNumber ; bufferOffset = initBufferOffset ; } public final void execute ( ) throws InternetSCSIException { final Queue < ProtocolDataUnit > protocolDataUnits = new LinkedList < ProtocolDataUnit > ( ) ; ProtocolDataUnit protocolDataUnit ; DataOutParser dataOut ; IDataSegmentChunk dataSegmentChunk ; boolean finalFlag = false ; final int maxRecvDataSegmentLength = connection . getSettingAsInt ( OperationalTextKey . MAX_RECV_DATA_SEGMENT_LENGTH ) ; int bytes2Transfer = connection . getSettingAsInt ( OperationalTextKey . FIRST_BURST_LENGTH ) - bufferOffset ; while ( bytes2Transfer > 0 && iterator . hasNext ( ) ) { if ( bytes2Transfer <= maxRecvDataSegmentLength ) { dataSegmentChunk = iterator . next ( bytes2Transfer ) ; finalFlag = true ; } else { dataSegmentChunk = iterator . next ( maxRecvDataSegmentLength ) ; finalFlag = false ; } protocolDataUnit = protocolDataUnitFactory . create ( false , finalFlag , OperationCode . SCSI_DATA_OUT , connection . getSetting ( OperationalTextKey . HEADER_DIGEST ) , connection . getSetting ( OperationalTextKey . DATA_DIGEST ) ) ; protocolDataUnit . getBasicHeaderSegment ( ) . setInitiatorTaskTag ( connection . getSession ( ) . getInitiatorTaskTag ( ) ) ; dataOut = ( DataOutParser ) protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) ; dataOut . setTargetTransferTag ( targetTransferTag ) ; dataOut . setDataSequenceNumber ( dataSequenceNumber ++ ) ; dataOut . setBufferOffset ( bufferOffset ) ; bufferOffset += maxRecvDataSegmentLength ; protocolDataUnit . setDataSegment ( dataSegmentChunk ) ; protocolDataUnits . offer ( protocolDataUnit ) ; bytes2Transfer -= maxRecvDataSegmentLength ; } connection .", "gt": "send ( protocolDataUnits ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1918, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Timeoff extends NikuReportAttribute { String getId ( ) ; void setId ( String value ) ; String getName ( ) ; void", "gt": "setName ( String value ) ;", "prediction": "}\n", "label": 0}
{"id": 3984, "input": "<s> package org . nuxeo . ecm . admin . setup ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Map ; import org . junit . Before ; import org . junit . Test ; import org . nuxeo . common . Environment ; import org . nuxeo . common . utils . FileUtils ; import org . nuxeo . launcher . config . ConfigurationGenerator ; public class TestSetupWizardActionBean { private SetupWizardActionBean setupWizardActionBean ; private Map < String , String > parameters , advancedParameters ; private File nuxeoHome , nuxeoConf , expectedNuxeoConf ; @ Before public void setUp ( ) throws Exception { nuxeoHome = File . createTempFile ( \"nuxeo\" , null ) ; nuxeoHome . delete ( ) ; nuxeoHome . mkdirs ( ) ; System . setProperty ( Environment . NUXEO_HOME , nuxeoHome . getPath ( ) ) ; System . setProperty ( Environment . NUXEO_DATA_DIR , new File ( nuxeoHome , \"data\" ) . getPath ( ) ) ; System . setProperty ( Environment . NUXEO_LOG_DIR , new File ( nuxeoHome , \"log\" ) . getPath ( ) ) ; nuxeoConf = new File ( nuxeoHome , \"bin\" ) ; nuxeoConf . mkdirs ( ) ; nuxeoConf = new File ( nuxeoConf , \"nuxeo.conf\" ) ; FileUtils . copy ( FileUtils . getResourceFileFromContext ( \"configurator/nuxeo.conf\" ) , nuxeoConf ) ; System . setProperty ( ConfigurationGenerator . NUXEO_CONF , nuxeoConf . getPath ( ) ) ; FileUtils . copy ( FileUtils . getResourceFileFromContext ( \"templates/jboss\" ) , new File ( nuxeoHome , \"templates\" ) ) ; System . setProperty ( \"jboss.home.dir\" , nuxeoHome . getPath ( ) ) ; setupWizardActionBean = new SetupWizardActionBean ( ) ; setupWizardActionBean . getConfigurationGenerator ( ) ; } @ Test public void testReadParameters ( ) { parameters = setupWizardActionBean . getParameters ( ) ; advancedParameters = setupWizardActionBean . getAdvancedParameters ( ) ; assertEquals ( \"0.0.0.0\" , parameters . get ( \"nuxeo.bind.address\" ) ) ; assertNull ( advancedParameters . get ( \"nuxeo.bind.address\" ) ) ; assertNull ( parameters . get ( \"test.nuxeo.conf\" ) ) ; assertEquals ( \"true\" , advancedParameters . get ( \"test.nuxeo.conf\" ) ) ; assertNull ( parameters . get ( \"test.root.nuxeo.defaults\" ) ) ; assertEquals ( \"true\" , advancedParameters . get ( \"test.root.nuxeo.defaults\" ) ) ; assertNull ( parameters . get ( \"test.default.nuxeo.defaults\" ) ) ; assertEquals ( \"true\" , advancedParameters . get ( \"test.default.nuxeo.defaults\" ) ) ; } @ Test public void testSaveParameters ( ) throws IOException { parameters = setupWizardActionBean . getParameters ( ) ; advancedParameters = setupWizardActionBean . getAdvancedParameters ( ) ; parameters . put ( \"nuxeo.bind.address\" , \"127.0.0.1\" ) ; parameters . put ( ConfigurationGenerator . PARAM_TEMPLATE_DBNAME , \"postgresql\" ) ; advancedParameters . put ( \"test.default.nuxeo.defaults\" , \"false\" ) ; setupWizardActionBean . saveParameters ( ) ; System . out . println ( \"Generated nuxeoConf: \" + nuxeoConf ) ; expectedNuxeoConf = FileUtils . getResourceFileFromContext ( \"configurator/nuxeo.conf.expected\" ) ; BufferedReader bfNew = new BufferedReader ( new FileReader ( nuxeoConf ) ) ; BufferedReader bfExp = new BufferedReader ( new FileReader ( expectedNuxeoConf ) ) ; String newStr , expStr ; while ( ( newStr = bfNew . readLine ( ) ) != null ) { expStr = bfExp . readLine ( ) ; if ( newStr . startsWith ( ConfigurationGenerator . BOUNDARY_BEGIN ) ) { assertTrue ( expStr . startsWith ( ConfigurationGenerator", "gt": ". BOUNDARY_BEGIN ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3986, "input": "<s> package pkg ; public class C extends P { public void method ( ) throws T5 ,", "gt": "T6 , T7 , T8", "prediction": "( )\n", "label": 0}
{"id": 3996, "input": "<s> package sharepointapp ; import com . microsoft . schemas . sharepoint . soap . GetListItems ; import com . microsoft . schemas . sharepoint . soap . GetListItemsResponse ; import com . microsoft . schemas . sharepoint . soap . UpdateListItems ; import com . microsoft . schemas . sharepoint . soap . UpdateListItemsResponse . UpdateListItemsResult ; import com . sun . org . apache . xerces . internal . dom . ElementNSImpl ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . ws . BindingProvider ; import com . microsoft . schemas . sharepoint . soap . ListsSoap ; import com . microsoft . schemas . sharepoint . soap . Lists ; import com . microsoft . schemas . sharepoint . soap . UpdateListItems . Updates ; import java . net . Authenticator ; import java . util . HashMap ; import javax . xml . transform . dom . * ; import org . w3c . dom . * ; public class Manager { public static ListsSoap sharePointListsAuth ( String userName , String password , String sharePointWebServiceUrl ) throws Exception { ListsSoap port = null ; if ( userName != null && password != null && sharePointWebServiceUrl != null ) { try { Lists service = new Lists ( ) ; port = service . getListsSoap ( ) ; System . out . println ( \"Web Service Auth Username: \" + userName ) ; System . out . println ( \"Web Service URL: \" + sharePointWebServiceUrl ) ; NtlmAuthenticator authenticator = new NtlmAuthenticator ( userName , password ) ; Authenticator . setDefault ( authenticator ) ; ( ( BindingProvider ) port ) . getRequestContext ( ) . put ( BindingProvider . USERNAME_PROPERTY , authenticator . getPasswordAuthentication ( ) . getUserName ( ) ) ; ( ( BindingProvider ) port ) . getRequestContext ( ) . put ( BindingProvider . PASSWORD_PROPERTY , authenticator . getPasswordAuthentication ( ) . getPassword ( ) . toString ( ) ) ; ( ( BindingProvider ) port ) . getRequestContext ( ) . put ( BindingProvider . ENDPOINT_ADDRESS_PROPERTY , sharePointWebServiceUrl ) ; } catch ( Exception e ) { throw new Exception ( \"Error: \" + e . toString ( ) ) ; } } else { throw new Exception ( \"Couldn't authenticate: Invalid connection details given.\" ) ; } return port ; } public static void displaySharePointList ( ListsSoap port , String listName , ArrayList < String > listColumnNames , String rowLimit ) throws Exception { if ( port != null && listName != null && listColumnNames != null && rowLimit != null ) { try { String viewName = \"\" ; GetListItems . ViewFields viewFields = null ; GetListItems . Query query = null ; GetListItems . QueryOptions queryOptions = null ; String webID = \"\" ; GetListItemsResponse . GetListItemsResult result = port . getListItems ( listName , viewName , query , viewFields , rowLimit , queryOptions , webID ) ; Object listResult = result . getContent ( ) . get ( 0 ) ; if ( ( listResult != null ) && ( listResult instanceof ElementNSImpl ) ) { ElementNSImpl node = ( ElementNSImpl ) listResult ; NodeList list = node . getElementsByTagName ( \"z:row\" ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { NamedNodeMap attributes = list . item ( i ) . getAttributes ( ) ; System . out . println ( \"******** Item ID: \" + attributes . getNamedItem ( \"ows_ID\" ) . getNodeValue ( ) + \" ********\" ) ; for ( String columnName : listColumnNames ) { String internalColumnName = \"ows_\" + columnName ; if ( attributes . getNamedItem ( internalColumnName ) != null ) { System . out . println ( columnName + \": \" + attributes . getNamedItem ( internalColumnName ) . getNodeValue ( ) ) ; } else { } } } } else { throw new Exception ( listName + \" list response from SharePoint is either null or corrupt\\n\" ) ; } } catch ( Exception ex ) { throw new Exception ( \"Exception. See stacktrace.\" + ex . toString ( ) + \"\\n\" ) ; } } } public static void displaySharePointList ( ListsSoap port , String listName , ArrayList < String > listColumnNames , Document doc , String rowLimit ) throws Exception { if ( port != null && listName != null && listName != null && listColumnNames != null && doc != null ) { try { String viewName = \"\" ; GetListItems . ViewFields viewFields = null ; GetListItems", "gt": ". Query query = new GetListItems . Query ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7058, "input": "<s> package com . midtro . platform ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . midtro . platform . injection . DrawInjector ; import com . midtro . platform . injection . KeyInjector ; import com . midtro . platform . injection . MouseInjector ; import com . midtro . platform . injection . UpdateInjector ; import com . midtro . platform . modules . MessageHandler ; import com . midtro . platform . modules . MessageException ; import com . midtro . platform . modules . Module ; import com . midtro . platform . modules . assets . AssetManager ; public abstract class Application { private final Settings settings = new Settings ( ) ; private final Statistics statistics = new Statistics ( ) ; private final List < State > states = new ArrayList < State > ( ) ; private final List < DrawInjector > drawInjectors = new ArrayList < DrawInjector > ( ) ; private final List < UpdateInjector > updateInjectors = new ArrayList < UpdateInjector > ( ) ; private final List < MouseInjector > mouseInjectors = new ArrayList < MouseInjector > ( ) ; private final List < KeyInjector > keyInjectors = new ArrayList < KeyInjector > ( ) ; private final Map < String , MessageHandler > handlers = new HashMap < String , MessageHandler > ( ) ; private final AssetManager assetManager = new AssetManager ( settings . getAssetConfig ( ) ) ; private final Input input = new Input ( ) ; private String initialState ; private State currentState ; public abstract void configure ( Settings settings ) ; public abstract void addStates ( final List < State > list ) ; public abstract void addModules ( final List < Module > list ) ; public final void initialize ( ) { this . configure ( settings ) ; this . addStates ( states ) ; if ( states . isEmpty ( ) ) { throw new RuntimeException ( \"stateless\" ) ; } else if ( currentState == null ) { this . currentState = states . get ( 0 ) ; } this . initialState = currentState . getName ( ) ; final List < Module > modules = new ArrayList < Module > ( ) ; this . addModules ( modules ) ; for ( final Module module : modules ) { module . onRegister ( this ) ; } } public void sendMessage ( String name , Object ... params ) { if ( handlers . containsKey ( name ) ) { handlers . get ( name ) . handle ( this , params ) ; } else { throw new MessageException ( \"missing: \" + name ) ; } } public void addHandler ( String name , MessageHandler handler ) { if ( handlers . containsKey ( name ) ) { throw new MessageException (", "gt": "\"duplicate: \" + name ) ;", "prediction": ") ;\n", "label": 0}
{"id": 3999, "input": "<s> package org . eclipse . ui . services ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . ui .", "gt": "internal . services . IEvaluationResultCache ;", "prediction": ";\n", "label": 1}
{"id": 6707, "input": "<s> package org . jboss . arquillian . android . enricher ; import java . lang . annotation . Annotation ; import java . util . logging . Logger ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . core . api . Instance ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . test . api . ArquillianResource ; import org . jboss . arquillian . test . spi . enricher . resource . ResourceProvider ; public class AndroidDeviceResourceProvider implements ResourceProvider { private static final Logger log = Logger . getLogger ( AndroidDeviceResourceProvider . class . getName ( ) ) ; @ Inject Instance < AndroidDevice > androidDevice ; @ Override public boolean canProvide ( Class", "gt": "< ? > type )", "prediction": ")\n", "label": 0}
{"id": 4001, "input": "<s> package br . org . archimedes . io . svg ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . infiniteline . InfiniteLine ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . interfaces . Exporter ; import br . org . archimedes . io . svg . rcp . ElementExporterEPLoader ; import br . org . archimedes . io . svg . rcp . Messages ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Layer ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . rcp . extensionpoints . ElementEPLoader ; import br . org . archimedes . semiline . Semiline ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . util . Collection ; public class SVGExporter implements Exporter { public void exportDrawing ( Drawing drawing , OutputStream output ) throws IOException { String charset = \"UTF-8\" ; Rectangle boundaryRectangle = drawing . getBoundary ( ) ; if ( boundaryRectangle == null ) { boundaryRectangle = new Rectangle ( 0 , 0 , 0 , 0 ) ; } exportSVGHeader ( drawing , output , charset , boundaryRectangle ) ; writeLayersDefs ( drawing . getLayerMap ( ) . values ( ) , output , charset ) ; ElementEPLoader elementEPLoader = new ElementEPLoader ( ) ; ElementExporterEPLoader exporterLoader = new ElementExporterEPLoader ( ) ; for ( Layer layer : drawing . getLayerMap ( ) . values ( ) ) { String header = \"<g class=\\\"\" + escapeName ( layer . getName ( ) ) + \"\\\" fill=\\\"none\\\">\\n\" ; output . write ( header . getBytes ( charset ) ) ; for ( Element element : layer . getElements ( ) ) { String elementId = elementEPLoader . getElementId ( element ) ; ElementExporter < Element > exporter = exporterLoader . getExporter ( elementId ) ; if ( exporter == null ) { System . err . println ( Messages . bind ( Messages . SVGExporter_NoExporter , elementId ) ) ; } else { try { if ( element instanceof InfiniteLine || element instanceof Semiline ) { exporter . exportElement ( element , output , boundaryRectangle ) ; } else { exporter . exportElement ( element , output ) ; } } catch ( NotSupportedException e ) { e . printStackTrace ( ) ; } } } output . write ( \"</g>\\n\" . getBytes ( charset ) ) ; } output . write ( ( \"</svg>\" + \"\\n\" ) . getBytes ( charset ) ) ; output . close ( ) ; } private void exportSVGHeader ( Drawing drawing , OutputStream output , String charset , Rectangle boundaryRectangle ) throws IOException , UnsupportedEncodingException { StringBuilder drawingTag = new StringBuilder ( \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charset + \"\\\"?>\" + \"\\n\" ) ; drawingTag . append ( \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\"\" + \" viewBox=\\\"\" + ( int ) Math . ceil ( boundaryRectangle . getLowerLeft ( ) . getX ( ) ) + \" \" + ( int ) Math . ceil ( boundaryRectangle . getLowerLeft ( ) . getY ( ) ) + \" \" + ( int ) Math . ceil ( boundaryRectangle . getWidth ( ) ) + \" \" + ( int ) Math . ceil ( boundaryRectangle . getHeight ( ) ) + \"\\\">\" ) ; output . write ( drawingTag . toString ( ) . getBytes ( charset ) ) ; } private void writeLayersDefs ( Collection < Layer > layers , OutputStream output , String encoding ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; builder . append ( \"<defs>\\n\" + \"<style type=\\\"text/css\\\">\\n\" + \"<![CDATA[\\n\" ) ; for ( Layer layer : layers ) { String printColor = layer . getPrintColor ( ) . toHexString ( ) ; builder . append ( \".\" + escapeName ( layer . getName ( ) ) + \" {stroke:#\" + printColor + \";stroke-width:\" + ( ( int ) layer . getThickness ( ) ) + \"}\\n\" ) ; } builder", "gt": ". append ( \"]]>\\n\" + \"</style>\\n\" + \"</defs>\\n\" ) ;", "prediction": "}\n", "label": 1}
{"id": 3605, "input": "<s> public class DefAssignBoolean_16 { public static void main ( String [ ] args ) { int i = 777 , j ; boolean b ; if ( b = i < 0 || ( j = - 1 ) > 0 ) ; else", "gt": "if ( j != - 1 ) ;", "prediction": "\n", "label": 0}
{"id": 4007, "input": "<s> package io . beancounter . commons . model . activity . rai ; import java . lang . Object ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . UUID ; public class ContentItem extends io . beancounter . commons . model . activity . Object { private final static String BASE_URL = \"http://www.rai.tv/dl/RaiTV/programmi/media/ContentItem-\" ; private UUID id ; private String onEvent ; public ContentItem ( ) { super ( ) ; } public ContentItem ( UUID id , String name , String description ) throws MalformedURLException { super ( new URL ( BASE_URL + id + \".html\" ) ) ; this . id = id ; setName ( name ) ; setDescription ( description ) ; } public UUID getId ( ) { return id ; } public void setId ( UUID id ) { this . id = id ; } public String getOnEvent ( ) { return onEvent ; } public void setOnEvent ( String onEvent ) { this . onEvent = onEvent ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; ContentItem that = ( ContentItem ) o ; if ( id != null ? ! id . equals ( that . id ) : that . id != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result", "gt": "= super . hashCode ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9442, "input": "<s> package com . l7 . mitra . client . ui ; public interface MessageListener { public void onMessage ( String msg", "gt": ", long timeStamp ) ;", "prediction": ")\n", "label": 0}
{"id": 4016, "input": "<s> package editor . SpriteCreator ; import java . awt . Color ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . image . BufferedImage ; import java . io . File ; import java . util . Vector ; import javax . imageio . ImageIO ; import javax . swing . JButton ; import javax . swing . JComponent ; import javax . swing . JLabel ; import javax . swing . JList ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JSlider ; import javax . swing . JTextField ; import javax . swing . event . ChangeEvent ; import javax . swing . event . ChangeListener ; import map . Map ; import map . NPC ; import actors . Enemy ; public class SpriteCreatorGUI extends JPanel implements ActionListener , ChangeListener { SpritePic previewBox ; JButton newButton ; JButton saveButton ; JButton savePNGButton ; JButton loadButton ; JButton AddButton ; JButton RemButton ; JButton EdtButton ; JButton SftUpButton ; JButton SftDnButton ; JSlider direction ; JSlider walkCycle ; JList layerList ; JScrollPane layerListPane ; JTextField nameField ; final Vector < Layer > layers = new Vector < Layer > ( ) ; Enemy activeEnemy ; Font font = new Font ( \"Arial\" , 1 , 32 ) ; private JScrollPane previewPane ; public SpriteCreatorGUI ( ) { setLayout ( null ) ; JLabel l ; previewBox = new SpritePic ( this ) ; previewPane = new JScrollPane ( previewBox ) ; previewPane . setLocation ( 220 , 10 ) ; previewPane . setSize ( 420 , 365 ) ; previewPane . getViewport ( ) . setBackground ( Color . GRAY ) ; add ( previewPane ) ; l = new JLabel ( \"Name: \" ) ; l . setSize ( l . getPreferredSize ( ) ) ; l . setLocation ( 10 , 10 ) ; nameField = new JTextField ( \"\" ) ; nameField . setSize ( 200 , 24 ) ; nameField . setLocation ( 10 , 32 ) ; add ( l ) ; add ( nameField ) ; l = new JLabel ( \"Layers: \" ) ; l . setSize ( 200 , 16 ) ; l . setLocation ( 10 , 64 ) ; layerList = new JList ( layers ) ; layerListPane = new JScrollPane ( layerList ) ; layerListPane . setSize ( 200 , 228 ) ; layerListPane . setLocation ( 10 , 92 ) ; add ( l ) ; add ( layerListPane ) ; refreshList ( ) ; l = new JLabel ( \"Direction: \" ) ; l . setSize ( l . getPreferredSize ( ) ) ; l . setLocation ( 650 , 10 ) ; direction = new JSlider ( 0 , Map . DIRECTIONS ) ; direction . setPaintTicks ( true ) ; direction . setPaintLabels ( true ) ; direction . setSnapToTicks ( true ) ; direction . setSize ( 230 , 36 ) ; direction . setLocation ( 650 , 32 ) ; direction . addChangeListener ( this ) ; add ( direction ) ; add ( l ) ; l = new JLabel ( \"Walk Cycle Frame: \" ) ; l . setSize ( l . getPreferredSize ( ) ) ; l . setLocation ( 650 , 72 ) ; walkCycle = new JSlider ( 0 , NPC . WALKCYCLE ) ; walkCycle . setPaintTicks ( true ) ; walkCycle . setPaintLabels ( true ) ; walkCycle . setSnapToTicks ( true ) ; walkCycle . setSize ( 230 , 36 ) ; walkCycle . setLocation ( 650 , 92 ) ; walkCycle . addChangeListener ( this ) ; add ( walkCycle ) ; add ( l ) ; RemButton = new JButton ( \"-\" ) ; RemButton . setSize ( 48 , 24 ) ; RemButton . setLocation ( 210 - RemButton . getWidth ( ) , 350 ) ; AddButton = new JButton ( \"+\" ) ; AddButton . setSize ( 48 , 24 ) ; AddButton . setLocation ( RemButton . getX ( ) - AddButton . getWidth ( ) , 350 ) ; EdtButton = new JButton ( \"Edit\" ) ; EdtButton . setSize ( 100 , 24 ) ; EdtButton . setLocation ( 10 , 350 ) ; AddButton . addActionListener ( this ) ; RemButton . addActionListener ( this ) ; EdtButton . addActionListener ( this ) ; add ( AddButton ) ; add ( RemButton ) ; add ( EdtButton ) ; SftUpButton = new JButton ( \"\u2191\" ) ; SftUpButton . setSize ( 100 , 24 ) ; SftUpButton . setLocation ( 10 , 320 ) ; SftDnButton = new JButton ( \"\u2193\" ) ; SftDnButton . setSize ( 100 , 24 ) ; SftDnButton . setLocation ( 110 , 320 ) ; SftUpButton . addActionListener ( this ) ; SftDnButton . addActionListener ( this ) ; add ( SftUpButton ) ; add ( SftDnButton ) ; int [ ] buttonSize = { 230 , 24 } ; newButton = new JButton ( \"New\" ) ; newButton . setSize ( buttonSize [ 0 ] , buttonSize [ 1 ] ) ; newButton . setLocation ( 650 , 260 ) ; saveButton = new JButton ( \"Save\" ) ; saveButton . setSize ( buttonSize [ 0 ] , buttonSize [ 1 ] ) ; saveButton . setLocation ( 650 , 290 ) ; savePNGButton = new JButton ( \"Save as .PNG\" ) ; savePNGButton . setSize ( buttonSize [ 0 ] , buttonSize [ 1 ] ) ; savePNGButton . setLocation ( 650 , 320 ) ; loadButton = new JButton ( \"Load\" ) ; loadButton . setSize ( buttonSize [ 0 ] , buttonSize [ 1 ] ) ; loadButton . setLocation ( 650 , 350 ) ; newButton . addActionListener ( this ) ; saveButton . addActionListener ( this ) ; savePNGButton . addActionListener ( this ) ; loadButton . addActionListener ( this ) ; add ( newButton ) ; add ( saveButton ) ; add ( savePNGButton ) ; add ( loadButton ) ; } @ Override public void actionPerformed ( ActionEvent event ) { Object source =", "gt": "event . getSource ( ) ;", "prediction": ";\n", "label": 1}
{"id": 1234, "input": "<s> package org . ofbiz . accounting . thirdparty . authorizedotnet ; import java . math . BigDecimal ; import org . ofbiz . base . util . UtilValidate ; public class AuthorizeResponse { private String [ ] response ; private RespPositions pos ; private String rawResp ; public static final int AIM_RESPONSE = 1 ; public static final int CP_RESPONSE = 2 ; public static final String APPROVED = \"Approved\" ; public static final String DECLINED = \"Declined\" ; public static final String ERROR = \"Error\" ; public static final String RESPONSE_CODE = \"RESPONSE_CODE\" ; public static final String REASON_CODE = \"REASON_CODE\" ; public static final String REASON_TEXT = \"REASON_TEXT\" ; public static final String AUTHORIZATION_CODE = \"AUTHORIZATION_CODE\" ; public static final String AVS_RESULT_CODE = \"AVS_RESULT_CODE\" ; public static final String CVV_RESULT_CODE = \"CVV_RESULT_CODE\" ; public static final String TRANSACTION_ID = \"TRANSACTION_ID\" ; public static final String AMOUNT = \"AMOUNT\" ; private static final AIMRespPositions aimPos = new AIMRespPositions ( ) ; private static final CPRespPositions cpPos = new CPRespPositions ( ) ; public AuthorizeResponse ( String resp , int responseType ) { this ( resp , \"\\\\|\" , responseType ) ; } public AuthorizeResponse ( String resp , String delim , int responseType ) { this . rawResp = resp ; this . response = resp . split ( delim ) ; if ( responseType == CP_RESPONSE ) { pos = cpPos ; } else { pos = aimPos ; } } public boolean isApproved ( ) { return pos . getApprovalString ( ) . equals ( getResponseCode ( ) ) ; } public String getTransactionId ( ) { return getResponseField ( TRANSACTION_ID ) ; } public String getAuthorizationCode ( ) { return getResponseField ( AUTHORIZATION_CODE ) ; } public String getResponseCode ( ) { return getResponseField ( RESPONSE_CODE ) ; } public String getReasonCode ( ) { return getResponseField ( REASON_CODE ) ; } public String getReasonText ( ) { return getResponseField ( REASON_TEXT ) ; } public String getAvsResult ( ) { return getResponseField ( AVS_RESULT_CODE ) ; } public String getCvResult ( ) { return getResponseField ( CVV_RESULT_CODE ) ; } public BigDecimal getAmount ( ) { BigDecimal amount = BigDecimal . ZERO ; String amtStr = getResponseField ( AMOUNT ) ; if ( UtilValidate . isNotEmpty ( amtStr ) && ! UtilValidate . isAlphabetic ( amtStr ) ) { amount = new BigDecimal ( amtStr ) ; } return amount ; } public String getRawResponse ( ) { return this . rawResp ; } private String", "gt": "getResponseField ( String field )", "prediction": "( ) ;\n", "label": 0}
{"id": 4019, "input": "<s> package org . eclipse . ui . part ; import org . eclipse . jface . viewers . ISelection ; public class ShowInContext { private Object input ; private ISelection selection ; public ShowInContext ( Object input , ISelection selection ) { setInput ( input ) ; setSelection ( selection ) ; } public Object getInput ( ) { return input ; }", "gt": "public ISelection getSelection ( )", "prediction": "}\n", "label": 1}
{"id": 7018, "input": "<s> public class Template extends JavadocTester { private static final String BUG_ID = \"<BUG ID>\" ; private static final String OUTPUT_DIR = \"docs-\" + BUG_ID ; private static final String [ ] ARGS = new String [ ] { \"-d\" , OUTPUT_DIR , \"-sourcepath\" , SRC_DIR } ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; public static void main (", "gt": "String [ ] args )", "prediction": ") ;\n", "label": 0}
{"id": 4037, "input": "<s> package org . eclipse . ui . forms . widgets ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . * ; class LayoutComposite extends Composite { public LayoutComposite ( Composite parent , int style ) { super ( parent , style ) ; setMenu ( parent . getMenu ( ) ) ; } public Point computeSize ( int wHint , int hHint , boolean changed ) { Layout layout = getLayout ( ) ; if ( layout instanceof TableWrapLayout ) return ( ( TableWrapLayout ) layout ) . computeSize ( this , wHint , hHint , changed ) ; if ( layout instanceof ColumnLayout ) return ( ( ColumnLayout ) layout ) . computeSize ( this , wHint , hHint , changed ) ; return super . computeSize (", "gt": "wHint , hHint , changed ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8916, "input": "<s> package com . quirijngrootbluemink . iptools ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; public class WifiScanChartReciever extends BroadcastReceiver { WifiChannelChart wifiChart ; public WifiScanChartReciever ( WifiChannelChart wifiChart ) { super ( ) ; this . wifiChart = wifiChart ; } @ Override public void onReceive ( Context arg0 , Intent arg1 ) { wifiChart . setScanResults", "gt": "( wifiChart . wifi . getScanResults ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4047, "input": "<s> package org . eclipse . ui . tests . decorators ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . tests . TestPlugin ; public class TestLabelProvider implements ILabelProvider , IColorProvider , IFontProvider { Image image ; public Image getImage ( Object element ) { if ( image == null ) { TestPlugin plugin = TestPlugin . getDefault ( ) ; image = plugin . getImageDescriptor ( \"anything.gif\" ) . createImage ( ) ; } return image ; } public String getText ( Object element ) { return ( ( TestElement ) element ) . name ; } public Color getBackground ( Object element ) { int switchNumber = 0 ; if ( element instanceof TreeElement ) switchNumber = ( ( TreeElement ) element ) . level ; else switchNumber = ( ( TableElement ) element ) . index % 4 ; switch ( switchNumber ) { case 0 : return Display . getDefault ( ) . getSystemColor ( SWT . COLOR_YELLOW ) ; case 1 : return Display . getDefault ( ) . getSystemColor ( SWT . COLOR_GREEN ) ; case 2 : return Display . getDefault ( ) . getSystemColor ( SWT . COLOR_DARK_GREEN ) ; case 3 : return Display . getDefault ( ) . getSystemColor ( SWT . COLOR_BLACK ) ; default : break ; } return null ; } public Color getForeground ( Object element ) { int switchNumber = 0 ; if ( element instanceof TreeElement ) switchNumber = ( ( TreeElement ) element ) . level ; else switchNumber = ( ( TableElement ) element ) . index % 4 ; switch ( switchNumber ) { case 0 : return Display . getDefault ( ) . getSystemColor", "gt": "( SWT . COLOR_DARK_RED ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4959, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class ConstantsSummaryBuilder extends AbstractBuilder { public static final String ROOT = \"ConstantSummary\" ; public static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2 ; protected ConstantsSummaryWriter writer ; protected Set < ClassDoc > classDocsWithConstFields ; protected Set < String > printedPackageHeaders ; private PackageDoc currentPackage ; private ClassDoc currentClass ; private Content contentTree ; private ConstantsSummaryBuilder ( Configuration configuration ) { super ( configuration ) ; } public static ConstantsSummaryBuilder getInstance ( Configuration configuration , ConstantsSummaryWriter writer ) { ConstantsSummaryBuilder builder = new ConstantsSummaryBuilder ( configuration ) ; builder . writer = writer ; builder . classDocsWithConstFields = new HashSet < ClassDoc > ( ) ; return builder ; } public void build ( ) throws IOException { if ( writer == null ) { return ; } build ( LayoutParser . getInstance ( configuration ) . parseXML ( ROOT ) , contentTree ) ; } public String getName ( ) { return ROOT ; } public void buildConstantSummary ( XMLNode node , Content contentTree ) throws Exception { contentTree = writer . getHeader ( ) ; buildChildren ( node , contentTree ) ; writer . addFooter ( contentTree ) ; writer . printDocument ( contentTree ) ; writer . close ( ) ; } public void buildContents ( XMLNode node , Content contentTree ) { Content contentListTree = writer . getContentsHeader ( ) ; PackageDoc [ ] packages = configuration . packages ; printedPackageHeaders = new HashSet < String > ( ) ; for ( int i = 0 ; i < packages . length ; i ++ ) { if ( hasConstantField ( packages [ i ] ) && ! hasPrintedPackageIndex ( packages [ i ] . name ( ) ) ) { writer . addLinkToPackageContent ( packages [ i ] , parsePackageName ( packages [ i ] . name ( ) ) , printedPackageHeaders , contentListTree ) ; } } contentTree . addContent ( writer . getContentsList ( contentListTree ) ) ; } public void buildConstantSummaries ( XMLNode node , Content contentTree ) { PackageDoc [ ] packages = configuration . packages ; printedPackageHeaders = new HashSet < String > ( ) ; Content summariesTree = writer . getConstantSummaries ( ) ; for ( int i = 0 ; i < packages . length ; i ++ ) { if ( hasConstantField ( packages [ i ] ) ) { currentPackage = packages [ i ] ; buildChildren ( node , summariesTree ) ; } } contentTree . addContent ( summariesTree ) ; } public void buildPackageHeader ( XMLNode node , Content summariesTree ) { String parsedPackageName = parsePackageName ( currentPackage . name ( ) ) ; if ( ! printedPackageHeaders . contains ( parsedPackageName ) ) { writer . addPackageName ( currentPackage , parsePackageName ( currentPackage . name ( ) ) , summariesTree ) ; printedPackageHeaders . add ( parsedPackageName ) ; } } public void buildClassConstantSummary ( XMLNode node , Content summariesTree ) { ClassDoc [ ] classes = currentPackage . name ( ) . length ( ) > 0 ? currentPackage . allClasses ( ) : configuration . classDocCatalog . allClasses ( DocletConstants . DEFAULT_PACKAGE_NAME ) ; Arrays . sort ( classes ) ; Content classConstantTree = writer . getClassConstantHeader ( ) ; for ( int i = 0 ; i < classes . length ; i ++ ) { if ( ! classDocsWithConstFields . contains ( classes [ i ] ) || ! classes [ i ] . isIncluded ( ) ) { continue ; } currentClass = classes [ i ] ; buildChildren ( node , classConstantTree ) ; } summariesTree . addContent ( classConstantTree ) ; } public void buildConstantMembers ( XMLNode node , Content classConstantTree ) { new ConstantFieldBuilder ( currentClass ) . buildMembersSummary ( node , classConstantTree ) ; } private boolean hasConstantField ( PackageDoc pkg ) { ClassDoc [ ] classes ; if ( pkg . name ( ) . length", "gt": "( ) > 0 )", "prediction": ") ;\n", "label": 0}
{"id": 4061, "input": "<s> package org . eclipse . swt . internal . dnd ; import org . eclipse . swt . dnd . TransferData ; import org . eclipse . swt . widgets . Control ; public interface IDNDAdapter { void cancel ( ) ; boolean isCanceled ( ) ; void setDetailChanged ( Control control , int detail ) ; void cancelDetailChanged ( ) ; boolean hasDetailChanged ( ) ; int getDetailChangedValue ( ) ; Control getDetailChangedControl ( ) ; void setFeedbackChanged ( Control control , int feedback ) ; void cancelFeedbackChanged ( ) ; boolean hasFeedbackChanged ( ) ;", "gt": "int getFeedbackChangedValue ( ) ;", "prediction": "}\n", "label": 1}
{"id": 5356, "input": "<s> package com . redhat . ceylon . compiler . loader . mirror ; import java . util . List ; public interface ClassMirror extends AnnotatedMirror { boolean isPublic ( ) ; boolean isInterface ( ) ; boolean isAbstract ( ) ; boolean isStatic ( ) ; boolean isInnerClass ( ) ; boolean isAnonymous ( ) ; String getQualifiedName ( ) ; PackageMirror getPackage ( ) ; List < MethodMirror > getDirectMethods ( ) ; List < FieldMirror > getDirectFields ( ) ; List < TypeParameterMirror > getTypeParameters ( ) ; List < ClassMirror > getDirectInnerClasses ( ) ; TypeMirror getSuperclass ( ) ; ClassMirror getEnclosingClass ( ) ; List < TypeMirror > getInterfaces ( ) ;", "gt": "boolean isCeylonToplevelAttribute ( ) ;", "prediction": "}\n", "label": 0}
{"id": 4079, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . util . LuceneTestCase ; import java . io . IOException ; public class TestConcurrentMergeScheduler extends LuceneTestCase { private static final Analyzer ANALYZER = new SimpleAnalyzer ( ) ; private static class FailOnlyOnFlush extends MockRAMDirectory . Failure { boolean doFail = false ; public void setDoFail ( ) { this . doFail = true ; } public void clearDoFail ( ) { this . doFail = false ; } public void eval ( MockRAMDirectory dir ) throws IOException { if ( doFail ) { StackTraceElement [ ] trace = new Exception ( ) . getStackTrace ( ) ; for ( int i = 0 ; i < trace . length ; i ++ ) { if ( \"doFlush\" . equals ( trace [ i ] . getMethodName ( ) ) ) { throw new IOException ( \"now failing during flush\" ) ; } } } } } public void testFlushExceptions ( ) throws IOException { MockRAMDirectory directory = new MockRAMDirectory ( ) ; FailOnlyOnFlush failure = new FailOnlyOnFlush ( ) ; directory . failOn ( failure ) ; IndexWriter writer = new IndexWriter ( directory , true , ANALYZER , true ) ; ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler ( ) ; writer . setMergeScheduler ( cms ) ; writer . setMaxBufferedDocs ( 2 ) ; Document doc = new Document ( ) ; Field idField = new Field ( \"id\" , \"\" , Field . Store . YES , Field . Index . NOT_ANALYZED ) ; doc . add ( idField ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 20 ; j ++ ) { idField . setValue ( Integer . toString ( i * 20 + j ) ) ; writer . addDocument ( doc ) ; } writer . addDocument ( doc ) ; failure . setDoFail ( ) ; try { writer . flush ( ) ; fail ( \"failed to hit IOException\" ) ; } catch ( IOException ioe ) { failure . clearDoFail ( ) ; } } writer . close ( ) ; IndexReader reader = IndexReader . open ( directory ) ; assertEquals ( 200 , reader . numDocs ( ) ) ; reader . close ( ) ; directory . close ( ) ; } public void testDeleteMerging ( ) throws IOException { RAMDirectory directory = new MockRAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( directory , true , ANALYZER , true ) ; ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler ( ) ; writer . setMergeScheduler ( cms ) ; LogDocMergePolicy mp = new LogDocMergePolicy ( writer ) ; writer . setMergePolicy ( mp ) ; mp . setMinMergeDocs ( 1000 ) ; Document doc = new Document ( ) ; Field idField = new Field ( \"id\" , \"\" , Field . Store . YES , Field . Index . NOT_ANALYZED ) ; doc . add ( idField ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { idField . setValue ( Integer . toString ( i * 100 + j ) ) ; writer . addDocument ( doc ) ; } int delID = i ; while ( delID < 100 * ( 1 + i ) ) { writer . deleteDocuments ( new Term ( \"id\" , \"\" + delID ) ) ; delID += 10 ; } writer . flush ( ) ; } writer . close ( ) ; IndexReader reader = IndexReader . open ( directory ) ; assertEquals ( 450 , reader . numDocs ( ) ) ; reader . close ( ) ; directory . close ( ) ; } public void testNoExtraFiles ( ) throws IOException { RAMDirectory directory = new MockRAMDirectory ( ) ; for ( int pass = 0 ; pass < 2 ; pass ++ ) { boolean autoCommit = pass == 0 ; IndexWriter writer = new IndexWriter ( directory , autoCommit , ANALYZER , true ) ; for ( int iter = 0 ; iter < 7 ; iter ++ ) { ConcurrentMergeScheduler", "gt": "cms = new ConcurrentMergeScheduler ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8456, "input": "<s> package lizaTest ; import static org . junit . Assert . * ; import static org . mockito . Mockito . when ; import java . util . ArrayList ; import java . util . List ; import org . bukkit . Location ; import org . bukkit . World ; import org . bukkit . entity . Arrow ; import org . bukkit . entity . Boat ; import org . bukkit . entity . Chicken ; import org . bukkit . entity . Egg ; import org . bukkit . entity . Entity ; import org . bukkit . entity . ExperienceOrb ; import org . bukkit . entity . Fireball ; import org . bukkit . entity . Fish ; import org . bukkit . entity . Ghast ; import org . bukkit . entity . Giant ; import org . bukkit . entity . Snowball ; import org . bukkit . entity . TNTPrimed ; import org . bukkit . entity . ThrownPotion ; import org . bukkit . entity . Villager ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mockito ; import Liza . LizaEntity ; import Liza . LizaWorld ; import LizaCraft . LizaCraftWorld ; public class TestGetLizaEntityRange { private LizaWorld lizaWorld ; private World mockMCWorld ; private static int RADIUS = 15 ; private Arrow arrow ; private Boat boat ; private Chicken chicken ; private Egg egg ; private ExperienceOrb xpOrb ; private Villager testificate ; private ThrownPotion potion ; private Ghast ghast ; private Fish fish ; private Fireball fireball ; private Giant giant ; private TNTPrimed tnt ; private Snowball snowball ; private Location refPoint ; private List < Entity > entityList = new ArrayList < Entity > ( ) ; private List < Entity > farEntities = new ArrayList < Entity > ( ) ; private List < Entity > nearEntities = new ArrayList < Entity > ( ) ; @ Before public void setUp ( ) { this . mockMCWorld = Mockito . mock ( World . class ) ; this . setUpMockEntities ( ) ; this . refPoint = new Location ( this . mockMCWorld , 0 , 0 , 0 ) ; this . lizaWorld = new LizaCraftWorld ( this . mockMCWorld ) ; when ( this . mockMCWorld . getEntities ( ) ) . thenReturn ( this . entityList ) ; } private void setUpMockEntities ( ) { this . arrow = Mockito . mock ( Arrow . class ) ; this . boat = Mockito . mock ( Boat . class ) ; this . chicken = Mockito . mock ( Chicken . class ) ; this . egg = Mockito . mock ( Egg . class ) ; this . xpOrb = Mockito . mock ( ExperienceOrb . class ) ; this . testificate = Mockito . mock ( Villager . class ) ; this . potion = Mockito . mock ( ThrownPotion . class ) ; this . ghast = Mockito . mock ( Ghast . class ) ; this . fish = Mockito . mock ( Fish . class ) ; this . fireball = Mockito . mock ( Fireball . class ) ; this . giant = Mockito . mock ( Giant . class ) ; this . tnt = Mockito . mock ( TNTPrimed . class ) ; this . snowball = Mockito . mock ( Snowball . class ) ; when ( this . arrow . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , - 30 , 0 , 0 ) ) ; when ( this . boat . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , - 15 , 0 , 0 ) ) ; when ( this . chicken . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , 30 ) ) ; when ( this . egg . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , 15 ) ) ; when ( this . xpOrb . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , 5 ) ) ; when ( this . testificate . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , - 15 ) ) ; when ( this . potion . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , - 30 ) ) ; when ( this . ghast . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 15 , 0 , 0 ) ) ; when ( this . fish . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 30 , 0 , 0 ) ) ; when ( this . fireball . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 0 , 0 ) ) ; when ( this . giant . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 5 , 0 ) ) ; when ( this . tnt . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , 30 , 0 ) ) ; when ( this . snowball . getLocation ( ) ) . thenReturn ( new Location ( this . mockMCWorld , 0 , - 15 , 0 ) ) ; this . entityList . add ( this . arrow ) ; this . entityList . add ( this . boat ) ; this . entityList . add ( this . chicken ) ; this . entityList . add ( this . egg ) ; this . entityList . add ( this . xpOrb ) ; this . entityList . add ( this . testificate ) ; this . entityList . add ( this . potion ) ; this . entityList . add ( this . ghast ) ; this . entityList . add ( this . fish ) ; this . entityList . add ( this . fireball ) ; this . entityList . add ( this . giant ) ; this . entityList . add ( this . tnt ) ; this . entityList . add ( this . snowball ) ; this . farEntities . add ( this . arrow ) ; this . farEntities . add ( this . boat ) ; this . farEntities . add ( this . chicken ) ;", "gt": "this . farEntities . add ( this . egg ) ;", "prediction": "}\n", "label": 0}
{"id": 4094, "input": "<s> package org . eclipse . ui . tests . themes ; import java . util . List ; import java . util . Set ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . resource . ColorRegistry ; import org . eclipse . jface . resource . FontRegistry ; import org . eclipse . jface . resource . StringConverter ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . internal . themes . ThemeElementHelper ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . themes . ITheme ; import org . eclipse . ui . themes . IThemeManager ; public class ThemeAPITest extends ThemeTest { private static final String EXTENDED_THEME3 = \"extendedTheme3\" ; private static final String EXTENDED_THEME2 = \"extendedTheme2\" ; private static final String EXTENDED_THEME1 = \"extendedTheme1\" ; private static final String PLATFORMFONT = \"platformfont\" ; private static final String PLATFORMCOLOR = \"platformcolor\" ; private static final String NOOVERRIDEFONT = \"nooverridefont\" ; private static final String NOVALFONT = \"novalfont\" ; private static final String DEFAULTEDFONT3 = \"defaultedfont3\" ; private static final String DEFAULTEDFONT2 = \"defaultedfont2\" ; private static final String DEFAULTEDFONT = \"defaultedfont\" ; private static final String VALFONT = \"valfont\" ; private static final String DEFAULTEDCOLOR3 = \"defaultedcolor3\" ; private static final String DEFAULTEDCOLOR2 = \"adefaultedcolor2\" ; private static final String VALUE2 = \"value2\" ; private static final String OVERRIDE1 = \"override1\" ; private static final String NOOVERRIDECOLOR = \"nooverridecolor\" ; private static final String DEFAULTEDCOLOR = \"defaultedcolor\" ; private static final String SWTCOLOR = \"swtcolor\" ; private static final String FACTORYCOLOR = \"factorycolor\" ; private static final String RGBCOLOR = \"rgbcolor\" ; private static final String BOOL1 = \"bool1\" ; private static final String BOGUSKEY = \"BOGUSKEY\" ; private static final String INT1 = \"int1\" ; private static final String DATA2 = \"data2\" ; private static final String DATA1 = \"data1\" ; private static final String BAD_COLOR1 = \"badColor1\" ; private static final String BAD_COLOR2 = \"badColor2\" ; private static final String BAD_COLOR3 = \"badColor3\" ; public ThemeAPITest ( String testName ) { super ( testName ) ; } private void checkEvents ( ThemePropertyListener listener , Object source , Object oldObject , Object newObject ) { boolean array = oldObject instanceof Object [ ] ; List events = listener . getEvents ( ) ; assertEquals ( 2 , events . size ( ) ) ; PropertyChangeEvent event = ( PropertyChangeEvent ) events . get ( 0 ) ; assertEquals ( source , event . getSource ( ) ) ; if ( array ) { assertArrayEquals ( ( Object [ ] ) oldObject , ( Object [ ] ) event . getOldValue ( ) ) ; assertArrayEquals ( ( Object [ ] ) newObject , ( Object [ ] ) event . getNewValue ( ) ) ; } else { assertEquals ( oldObject , event . getOldValue ( ) ) ; assertEquals ( newObject , event . getNewValue ( ) ) ; } event = ( PropertyChangeEvent ) events . get ( 1 ) ; assertEquals ( source , event . getSource ( ) ) ; if ( array ) { assertArrayEquals ( ( Object [ ] ) oldObject , ( Object [ ] ) event . getNewValue ( ) ) ; assertArrayEquals ( ( Object [ ] ) newObject , ( Object [ ] ) event . getOldValue ( ) ) ; } else { assertEquals ( oldObject , event . getNewValue ( ) ) ; assertEquals ( newObject , event . getOldValue ( ) ) ; } } public void testBooleanDataConversion ( ) { ITheme defaultTheme = getDefaultTheme ( ) ; assertEquals ( false , defaultTheme . getBoolean ( DATA1 ) ) ; assertEquals ( false , defaultTheme . getBoolean ( DATA2 ) ) ; assertEquals ( false , defaultTheme . getBoolean ( INT1 ) ) ; assertEquals ( false , defaultTheme . getBoolean ( BOGUSKEY ) ) ; assertEquals ( true , defaultTheme . getBoolean ( BOOL1 ) ) ; } public void testColorCascadeEvents ( ) { ITheme currentTheme = fManager . getCurrentTheme ( ) ; assertNotNull ( currentTheme ) ; ThemePropertyListener managerListener = new ThemePropertyListener ( ) ; ThemePropertyListener themeListener = new ThemePropertyListener ( ) ; fManager . addPropertyChangeListener ( managerListener ) ; currentTheme . addPropertyChangeListener ( themeListener ) ; ColorRegistry colorRegistry = currentTheme . getColorRegistry ( ) ; RGB oldColor = colorRegistry . getRGB ( RGBCOLOR ) ; RGB newColor = new RGB ( 121 , 9 , 121 ) ; colorRegistry . put ( RGBCOLOR , newColor ) ; colorRegistry . put ( RGBCOLOR , oldColor ) ; checkEvents ( managerListener , colorRegistry , oldColor , newColor ) ; checkEvents ( themeListener , colorRegistry , oldColor , newColor ) ; fManager . removePropertyChangeListener ( managerListener ) ; currentTheme . removePropertyChangeListener ( themeListener ) ; } public void testColorPreferenceListener_def_swtcolor ( ) { IPreferenceStore store = PrefUtil . getInternalPreferenceStore ( ) ; ITheme defaultTheme = getDefaultTheme ( ) ; testOverrideColorPreference ( defaultTheme , store , SWTCOLOR ) ; } public void testColorPreferenceListener_def_rgbcolor ( ) { IPreferenceStore store = PrefUtil . getInternalPreferenceStore ( ) ; ITheme defaultTheme = getDefaultTheme ( ) ; testOverrideColorPreference ( defaultTheme , store , RGBCOLOR ) ; } public void testColorPreferenceListener_def_defaultedcolor ( ) { IPreferenceStore store = PrefUtil . getInternalPreferenceStore ( ) ; ITheme defaultTheme = getDefaultTheme ( ) ; testOverrideColorPreference ( defaultTheme , store , DEFAULTEDCOLOR ) ; } public void testColorPreferenceListener_def_nooverridecolor ( ) { IPreferenceStore store = PrefUtil . getInternalPreferenceStore ( ) ; ITheme defaultTheme = getDefaultTheme ( ) ; testOverrideColorPreference ( defaultTheme , store , NOOVERRIDECOLOR ) ; } public void testColorPreferenceListener_th1_swtcolor ( ) { IPreferenceStore store = PrefUtil . getInternalPreferenceStore ( ) ; ITheme theme1 = getTheme1 ( ) ; testOverrideColorPreference (", "gt": "theme1 , store , SWTCOLOR ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2828, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . parts ; import java . util . Collections ; import java . util . List ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . transaction . RunnableWithResult ; import org . eclipse . gef . AccessibleEditPart ; import org . eclipse . gef . EditPolicy ; import org . eclipse . gef . Request ; import org . eclipse . gef . requests . DirectEditRequest ; import org . eclipse . gef . tools . DirectEditManager ; import org . eclipse . gmf . runtime . common . ui . services . parser . IParser ; import org . eclipse . gmf . runtime . common . ui . services . parser . IParserEditStatus ; import org . eclipse . gmf . runtime . common . ui . services . parser . ParserEditStatus ; import org . eclipse . gmf . runtime . common . ui . services . parser . ParserOptions ; import org . eclipse . gmf . runtime . diagram . ui . editparts . CompartmentEditPart ; import org . eclipse . gmf . runtime . diagram . ui . editparts . IGraphicalEditPart ; import org . eclipse . gmf . runtime . diagram . ui . editparts . ITextAwareEditPart ; import org . eclipse . gmf . runtime . diagram . ui . editpolicies . LabelDirectEditPolicy ; import org . eclipse . gmf . runtime . diagram . ui . l10n . DiagramColorRegistry ; import org . eclipse . gmf . runtime . diagram . ui . requests . RequestConstants ; import org . eclipse . gmf . runtime . diagram . ui . tools . TextDirectEditManager ; import org . eclipse . gmf . runtime . draw2d . ui . figures . WrappingLabel ; import org . eclipse . gmf . runtime . emf . core . util . EObjectAdapter ; import org . eclipse . gmf . runtime . emf . ui . services . parser . ISemanticParser ; import org . eclipse . gmf . runtime . notation . FontStyle ; import org . eclipse . gmf . runtime . notation . NotationPackage ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . text . contentassist . IContentAssistProcessor ; import org . eclipse . jface . viewers . ICellEditorValidator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . accessibility . AccessibleEvent ; import org . eclipse . swt . graphics . Color ; import", "gt": "org . eclipse . swt . graphics . FontData ;", "prediction": ";\n", "label": 0}
{"id": 4101, "input": "<s> package org . puredata . android . io ; import java . io . IOException ; import org . puredata . android . service . R ; import org . puredata . android . utils . Properties ; import android . content . Context ; import android . media . AudioFormat ; import android . media . AudioManager ; import android . media . AudioRecord ; import android . media . AudioTrack ; import android . media . MediaPlayer ; import android . os . Process ; import android . util . Log ; public abstract class AudioWrapper { private static final String AUDIO_WRAPPER = \"AudioWrapper\" ; private static final int ENCODING = AudioFormat . ENCODING_PCM_16BIT ; private final AudioRecordWrapper rec ; private final AudioTrack track ; final short outBuf [ ] ; final int inputSizeShorts ; final int bufSizeShorts ; private Thread audioThread = null ; public AudioWrapper ( int sampleRate , int inChannels , int outChannels , int bufferSizePerChannel ) throws IOException { int channelConfig = VersionedAudioFormat . getOutFormat ( outChannels ) ; rec = ( inChannels == 0 ) ? null : new AudioRecordWrapper ( sampleRate , inChannels , bufferSizePerChannel ) ; inputSizeShorts = inChannels * bufferSizePerChannel ; bufSizeShorts = outChannels * bufferSizePerChannel ; outBuf = new short [ bufSizeShorts ] ; int bufSizeBytes = 2 * bufSizeShorts ; int trackSizeBytes = 2 * bufSizeBytes ; int minTrackSizeBytes = AudioTrack . getMinBufferSize ( sampleRate , channelConfig , ENCODING ) ; if ( minTrackSizeBytes <= 0 ) { throw new IOException ( \"bad AudioTrack parameters; sr: \" + sampleRate + \", ch: \" + outChannels + \", bufSize: \" + trackSizeBytes ) ; } while ( trackSizeBytes < minTrackSizeBytes ) trackSizeBytes += bufSizeBytes ; track = new AudioTrack ( AudioManager . STREAM_MUSIC , sampleRate , channelConfig , ENCODING , trackSizeBytes , AudioTrack . MODE_STREAM ) ; if ( track . getState ( ) != AudioTrack . STATE_INITIALIZED ) { track . release ( ) ; throw new IOException ( \"unable to initialize AudioTrack instance for sr: \" + sampleRate + \", ch: \" + outChannels + \", bufSize: \" + trackSizeBytes ) ; } } protected abstract int process ( short inBuffer [ ] , short outBuffer [ ] ) ; public synchronized void start ( Context context ) { avoidClickHack ( context ) ; audioThread = new Thread ( ) { @ Override public void run ( ) { Process . setThreadPriority ( Process . THREAD_PRIORITY_URGENT_AUDIO ) ; if ( rec != null ) rec . start ( ) ; track . play ( ) ; short inBuf [ ] ; try { inBuf = ( rec != null ) ? rec . take ( ) : new short [ inputSizeShorts ] ; } catch ( InterruptedException e ) { return ; } while ( ! Thread . interrupted ( ) ) { if ( process ( inBuf , outBuf ) != 0 ) break ; track . write ( outBuf , 0 , bufSizeShorts ) ; if ( rec != null ) { short newBuf [ ] = rec . poll ( ) ; if ( newBuf != null ) { inBuf = newBuf ; } else { Log . w ( AUDIO_WRAPPER , \"no input buffer available\" ) ; } } } if ( rec != null ) rec . stop ( ) ; track . stop ( ) ; } } ; audioThread . start ( ) ; } public synchronized void stop ( ) { if ( audioThread == null ) return ; audioThread . interrupt ( ) ; try { audioThread . join ( ) ; } catch ( InterruptedException e ) { } audioThread = null ; } public synchronized void release ( ) { stop ( ) ; track . release ( ) ; if ( rec != null ) rec . release ( ) ; } public synchronized boolean isRunning ( ) { return audioThread != null && audioThread . getState ( ) != Thread . State . TERMINATED ; } public synchronized int getAudioSessionId ( ) { int version = Properties . version ; if ( version >= 9 ) {", "gt": "return AudioSessionHandler . getAudioSessionId ( track ) ;", "prediction": "\n", "label": 1}
{"id": 7041, "input": "<s> package org . ofbiz . entity . config ; import java . util . List ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Element ; public class DatasourceInfo extends NamedInfo { public static final String module = DatasourceInfo . class . getName ( ) ; public String helperClass ; public String fieldTypeName ; public List < ? extends Element > sqlLoadPaths ; public List < ? extends Element > readDatas ; public Element datasourceElement ; public static final int TYPE_JNDI_JDBC = 1 ; public static final int TYPE_INLINE_JDBC = 2 ; public static final int TYPE_TYREX_DATA_SOURCE = 3 ; public static final int TYPE_OTHER = 4 ; public Element jndiJdbcElement ; public Element tyrexDataSourceElement ; public Element inlineJdbcElement ; public String schemaName = null ; public boolean useSchemas = true ; public boolean checkOnStart = true ; public boolean addMissingOnStart = false ; public boolean useFks = true ; public boolean useFkIndices = true ; public boolean checkPrimaryKeysOnStart = false ; public boolean checkForeignKeysOnStart = false ; public boolean checkFkIndicesOnStart = false ; public boolean usePkConstraintNames = true ; public int constraintNameClipLength = 30 ; public boolean useProxyCursor = false ; public String cursorName = \"p_cursor\" ; public int resultFetchSize = - 1 ; public String fkStyle = null ; public boolean useFkInitiallyDeferred = true ; public boolean useIndices = true ; public boolean useIndicesUnique = true ; public boolean checkIndicesOnStart = false ; public String joinStyle = null ; public boolean aliasViews = true ; public boolean alwaysUseConstraintKeyword = false ; public boolean dropFkUseForeignKeyKeyword = false ; public boolean useBinaryTypeForBlob = false ; public boolean useOrderByNulls = false ; public String tableType = null ; public String characterSet = null ; public String collate = null ; public int maxWorkerPoolSize = 1 ; public DatasourceInfo ( Element element ) { super ( element ) ; this . helperClass = element . getAttribute ( \"helper-class\" ) ; this . fieldTypeName = element . getAttribute ( \"field-type-name\" ) ; sqlLoadPaths = UtilXml . childElementList ( element , \"sql-load-path\" ) ; readDatas = UtilXml . childElementList ( element , \"read-data\" ) ; datasourceElement = element ; if ( datasourceElement == null ) { Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for schema-name (none)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for use-schemas (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for check-on-start (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for add-missing-on-start (false)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for check-pks-on-start (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for use-foreign-keys (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default use-foreign-key-indices (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for check-fks-on-start (false)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for check-fk-indices-on-start (false)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for use-pk-constraint-names (true)\" , module ) ; Debug . logWarning ( \"datasource def not found with name \" + this . name + \", using default for constraint-name-clip-length", "gt": "(30)\" , module ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4114, "input": "<s> package org . slf4j . impl ; import org . slf4j . IMarkerFactory ; import org . slf4j . MarkerFactory ; import org . slf4j . helpers . BasicMarkerFactory ; import org . slf4j . spi . MarkerFactoryBinder ; public class StaticMarkerBinder implements MarkerFactoryBinder { public static final StaticMarkerBinder SINGLETON = new StaticMarkerBinder ( ) ; private final IMarkerFactory markerFactory = new BasicMarkerFactory ( ) ; private StaticMarkerBinder ( ) { } public IMarkerFactory getMarkerFactory ( ) { return markerFactory ; }", "gt": "public String getMarkerFactoryClassStr ( )", "prediction": "}\n", "label": 1}
{"id": 5242, "input": "<s> class Test { int bi = 0B ; long bl = 0BL ;", "gt": "int xi = 0X ;", "prediction": "}\n", "label": 0}
{"id": 4120, "input": "<s> package org . restlet . ext . openid . internal ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . CookieSetting ; import org . restlet . data . Reference ; import org . restlet . routing . Filter ; @ Deprecated public class SetCallbackFilter extends Filter { private CacheLookup cache = null ; public SetCallbackFilter ( ) { } public SetCallbackFilter ( CacheLookup cache ) { this . cache = cache ; } @ Override protected int beforeHandle ( Request request , Response response ) { String cb = request . getOriginalRef ( ) . getQueryAsForm ( ) . getFirstValue ( CallbackCacheFilter . EXTERNAL_SERVER_COOKIE ) ; if ( cb != null && cb . length ( ) > 0 && response . getStatus ( ) . isSuccess ( ) ) { Reference ref = new Reference ( cb ) ; if ( ref . getQueryAsForm ( ) . removeFirst ( \"internal\" ) ) { getLogger ( ) . fine ( \"OpenID - setting internal cb cookie = \" + cb ) ; CookieSetting cs = new CookieSetting ( CallbackCacheFilter . INTERNAL_SERVER_COOKIE , cb ) ; response . getCookieSettings ( ) . add ( cs ) ; } else { getLogger ( ) . fine ( \"OpenID - setting external cb cookie = \" + cb ) ; CookieSetting cs = new CookieSetting ( CallbackCacheFilter . EXTERNAL_SERVER_COOKIE , cb ) ; response . getCookieSettings ( ) . add ( cs ) ; } } return super . beforeHandle ( request , response ) ; } @ Override protected int doHandle ( Request request , Response response ) { if ( cache != null ) { boolean found = cache . handleCached (", "gt": "request , response ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8643, "input": "<s> package pkg ; public class TestSuperSuperClass { public < P , Q > String testSuperSuperMethod ( int x1 , int x2 ) { return null ; } public < P , Q > String testSuperSuperMethod2 ( int", "gt": "x1 , int x2 )", "prediction": ")\n", "label": 0}
{"id": 4122, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . model ; public interface IBlock { void addDirective", "gt": "( Directive aDirective ) ;", "prediction": ";\n", "label": 1}
{"id": 5247, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Entity ; public interface LizaEntity extends Entity { public Entity getBukkitHandle ( ) ; List < LizaEntity > getNearbyLizaEntities ( double x", "gt": ", double y , double z ) ;", "prediction": ")\n", "label": 0}
{"id": 4144, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Layout ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . ui . internal . dnd . DragUtil ; import org . eclipse . ui . internal . dnd . SwtUtil ; import org . eclipse . ui . internal . layout . SizeCache ; public class ProxyControl { private Composite control ; private Control target = null ; private SizeCache targetCache = null ; private Control commonAncestor ; private boolean visible = true ; private DisposeListener disposeListener = new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { if ( e . widget == target || e . widget == control ) { setTargetControl ( null ) ; } } } ; private Listener visibilityListener = new Listener ( ) { public void handleEvent ( Event event ) { if ( target != null ) { visible = control . getVisible ( ) ; target . setVisible ( visible ) ; } } } ; public void setVisible ( boolean visible ) { } private ControlListener controlListener = new ControlListener ( ) { public void controlMoved ( ControlEvent e ) { ProxyControl . this . layout ( ) ; } public void controlResized ( ControlEvent e ) { } } ; public ProxyControl ( Composite parent ) { control = new Composite ( parent , SWT . NONE ) ; control . setVisible ( false ) ; control . setLayout ( new Layout ( ) { protected void layout ( Composite composite , boolean flushCache ) { ProxyControl . this", "gt": ". layout ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1868, "input": "<s> package com . redhat . ceylon . compiler . java . tools ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . api . JavacTaskImpl ; import com . sun . tools . javac . main . Main ; import com . sun . tools . javac . util . Context ; public class CeyloncTaskImpl extends JavacTaskImpl { CeyloncTaskImpl ( Main compilerMain , Iterable < String > flags , Context context , Iterable < String > classes , Iterable < ? extends JavaFileObject > fileObjects ) { super ( compilerMain", "gt": ", flags , context , classes , fileObjects ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4145, "input": "<s> package org . apache . sqoop . io ; import java . io . IOException ; import java . util . Map ; import java . util . TreeMap ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . cloudera . sqoop . io . LobFile ; public class LobReaderCache { public static final Log LOG = LogFactory . getLog ( LobReaderCache . class . getName ( ) ) ; private Map < Path , LobFile . Reader > readerMap ; public LobFile . Reader get ( Path path , Configuration conf ) throws IOException { LobFile . Reader reader = null ; Path canonicalPath = qualify ( path , conf ) ; synchronized ( this ) { reader = readerMap . remove ( canonicalPath ) ; } if ( null != reader && ! reader . isClosed ( ) ) { LOG . debug ( \"Using cached reader for \" + canonicalPath ) ; return reader ; } LOG . debug ( \"No cached reader available for \" + canonicalPath ) ; return LobFile . open ( path , conf ) ; } public void recycle ( LobFile . Reader reader ) throws IOException { Path canonicalPath = reader . getPath ( ) ; boolean cached = false ; synchronized ( this ) { if ( readerMap . get ( canonicalPath ) == null ) { LOG . debug ( \"Caching reader for path: \" + canonicalPath ) ; readerMap . put ( canonicalPath , reader ) ; cached = true ; } } if ( ! cached ) { LOG . debug ( \"Reader already present for path: \" + canonicalPath + \"; closing.\" ) ; reader . close ( ) ; } } @ Override protected synchronized void finalize ( ) throws Throwable { for ( LobFile . Reader r : readerMap . values ( ) ) { r . close ( ) ; } super . finalize ( ) ; } protected LobReaderCache ( ) { this . readerMap = new TreeMap < Path , LobFile . Reader > ( ) ; } public static Path qualify ( Path path , Configuration conf ) throws IOException { if", "gt": "( null == path )", "prediction": "( )\n", "label": 1}
{"id": 7287, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . DeprecatedAPIListBuilder ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class DeprecatedListWriter extends SubWriterHolderWriter { private static final String [ ] ANCHORS = new String [ ] { \"package\" , \"interface\" , \"class\" , \"enum\" , \"exception\" , \"error\" , \"annotation_type\" , \"field\" , \"method\" , \"constructor\" , \"enum_constant\" , \"annotation_type_member\" } ; private static final String [ ] HEADING_KEYS = new String [ ] { \"doclet.Deprecated_Packages\" , \"doclet.Deprecated_Interfaces\" , \"doclet.Deprecated_Classes\" , \"doclet.Deprecated_Enums\" , \"doclet.Deprecated_Exceptions\" , \"doclet.Deprecated_Errors\" , \"doclet.Deprecated_Annotation_Types\" , \"doclet.Deprecated_Fields\" , \"doclet.Deprecated_Methods\" , \"doclet.Deprecated_Constructors\" , \"doclet.Deprecated_Enum_Constants\" , \"doclet.Deprecated_Annotation_Type_Members\" } ; private static final String [ ] SUMMARY_KEYS = new String [ ] { \"doclet.deprecated_packages\" , \"doclet.deprecated_interfaces\" , \"doclet.deprecated_classes\" , \"doclet.deprecated_enums\" , \"doclet.deprecated_exceptions\" , \"doclet.deprecated_errors\" , \"doclet.deprecated_annotation_types\" , \"doclet.deprecated_fields\" , \"doclet.deprecated_methods\" , \"doclet.deprecated_constructors\" , \"doclet.deprecated_enum_constants\" , \"doclet.deprecated_annotation_type_members\" } ; private static final String [ ] HEADER_KEYS = new String [ ] { \"doclet.Package\" , \"doclet.Interface\" , \"doclet.Class\" , \"doclet.Enum\" , \"doclet.Exceptions\" , \"doclet.Errors\" , \"doclet.AnnotationType\" , \"doclet.Field\" , \"doclet.Method\" , \"doclet.Constructor\" , \"doclet.Enum_Constant\" , \"doclet.Annotation_Type_Member\" } ; private AbstractMemberWriter [ ] writers ; private ConfigurationImpl configuration ; public DeprecatedListWriter ( ConfigurationImpl configuration , String filename ) throws IOException { super ( configuration , filename ) ; this . configuration = configuration ; NestedClassWriterImpl classW = new NestedClassWriterImpl ( this ) ; writers = new AbstractMemberWriter [ ] { classW , classW , classW , classW , classW , classW , new FieldWriterImpl ( this ) , new MethodWriterImpl ( this ) , new ConstructorWriterImpl ( this ) , new EnumConstantWriterImpl ( this ) , new AnnotationTypeOptionalMemberWriterImpl ( this , null ) } ; } public static void generate ( ConfigurationImpl configuration ) { String filename = \"deprecated-list.html\" ; try { DeprecatedListWriter depr = new DeprecatedListWriter ( configuration , filename ) ; depr . generateDeprecatedListFile ( new DeprecatedAPIListBuilder ( configuration ) ) ; depr . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } protected void generateDeprecatedListFile ( DeprecatedAPIListBuilder deprapi ) throws IOException { Content body = getHeader ( ) ; body . addContent ( getContentsList ( deprapi ) ) ; String memberTableSummary ; String [ ] memberTableHeader = new String [ 1 ] ; HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . contentContainer ) ; for ( int i = 0 ; i < DeprecatedAPIListBuilder . NUM_TYPES ; i ++ ) { if ( deprapi . hasDocumentation ( i ) ) { addAnchor ( deprapi , i , div ) ; memberTableSummary = configuration . getText ( \"doclet.Member_Table_Summary\" , configuration . getText ( HEADING_KEYS [ i ] ) , configuration . getText ( SUMMARY_KEYS [ i ] ) ) ; memberTableHeader [ 0 ] = configuration . getText ( \"doclet.0_and_1\" , configuration . getText ( HEADER_KEYS [ i ] ) , configuration . getText ( \"doclet.Description\" ) ) ; if ( i == DeprecatedAPIListBuilder . PACKAGE ) addPackageDeprecatedAPI ( deprapi . getList ( i ) , HEADING_KEYS [ i ] , memberTableSummary , memberTableHeader , div ) ; else writers [ i - 1 ] . addDeprecatedAPI ( deprapi . getList ( i ) , HEADING_KEYS [ i ] , memberTableSummary , memberTableHeader , div ) ; } } body . addContent ( div ) ; addNavLinks ( false , body ) ; addBottom ( body ) ; printHtmlDocument ( null , true , body ) ; } private void addIndexLink ( DeprecatedAPIListBuilder builder , int type , Content contentTree ) { if ( builder . hasDocumentation ( type ) ) { Content li = HtmlTree . LI ( getHyperLink ( \"#\" + ANCHORS [ type ] , getResource ( HEADING_KEYS [ type ] ) ) ) ; contentTree . addContent ( li ) ; } } public Content getContentsList ( DeprecatedAPIListBuilder deprapi ) { Content headContent = getResource ( \"doclet.Deprecated_API\" ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . TITLE_HEADING , true , HtmlStyle . title , headContent ) ; Content div = HtmlTree . DIV ( HtmlStyle . header , heading ) ; Content headingContent = getResource ( \"doclet.Contents\" ) ; div . addContent ( HtmlTree . HEADING ( HtmlConstants . CONTENT_HEADING , true , headingContent ) ) ; Content ul = new HtmlTree ( HtmlTag . UL ) ; for", "gt": "( int i = 0 ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4147, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers ; public class ResourceObject { private final Object jaxRsResourceObject ; private final ResourceClass resourceClass ; ResourceObject ( Object jaxRsResourceObject , ResourceClass resourceClass ) { if ( jaxRsResourceObject == null ) { throw new IllegalArgumentException ( \"The JAX-RS resource object must not be null\" ) ; } if ( resourceClass == null ) { throw new IllegalArgumentException ( \"The ResourceClass must not be null\" ) ; } if ( jaxRsResourceObject instanceof ResourceObject ) { throw new IllegalArgumentException ( \"The given resource class object should not be an instance of the", "gt": "wrapping class ResourceObject\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4779, "input": "<s> package api . torrents . artist ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URL ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import api . soup . MySoup ; public class Torrent { private String encoding ; private Number fileCount ; private String format ; private boolean freeTorrent ; private Number groupId ; private boolean hasCue ; private Number hasFile ; private boolean hasLog ; private Number id ; private Number leechers ; private Number logScore ; private String media ; private String remasterRecordLabel ; private String remasterTitle ; private Number remasterYear ; private boolean remastered ; private boolean scene ; private Number seeders ; private Number size ; private Number snatched ; private String time ; public String getEncoding ( ) { return this . encoding ; } public Number getFileCount ( ) { return this . fileCount ; } public String getFormat ( ) { return this . format ; } public boolean isFreeTorrent ( ) { return this . freeTorrent ; } public Number getGroupId ( ) { return this . groupId ; } public boolean hasCue ( ) { return this . hasCue ; } public Number getHasFile ( ) { return this . hasFile ; } public boolean hasLog ( ) { return this . hasLog ; } public Number getId ( ) { return this . id ; } public Number getLeechers ( ) { return this . leechers ; } public Number getLogScore ( ) { return this . logScore ; } public String getMedia ( ) { return this . media ; } public String getRemasterRecordLabel ( ) { return this . remasterRecordLabel ; } public String getRemasterTitle ( ) { return this . remasterTitle ; } public Number getRemasterYear ( ) { return this . remasterYear ; } public boolean getRemastered ( ) { return this . remastered ; } public boolean isScene ( ) { return this . scene ; } public Number getSeeders ( ) { return this . seeders ; } public Number getSize ( ) { return this . size ; } public Number getSnatched ( ) { return this . snatched ; } public String getTime ( ) { return this . time ; } public String getMediaFormatEncoding ( ) { String log = hasLog ? \" - \" + logScore . toString ( ) : \"\" ; String cue = hasCue ? \" - \" + \"Cue\" : \"\" ; return this . getMedia ( ) + \" - \" + this . getFormat ( ) + \" - \" + this . getEncoding ( ) + log + cue ; } public String getRemaster ( ) { return this . getRemasterYear ( ) + \" - \" + this . getRemasterRecordLabel ( ) + \" / \" +", "gt": "this . getRemasterTitle ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4157, "input": "<s> package com . example . tourapp ; import android . app . Activity ; import android . content . Intent ; import android . net . Uri ; import android . os . Bundle ; import android . text . method . ScrollingMovementMethod ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . ImageView ; import android . widget . TextView ; public class Division extends Activity { private final String PACKAGE_NAME = \"com.example.tourapp\" ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . division ) ; TextView nameTV = ( TextView ) findViewById ( R . id . division_name ) ; TextView descriptionTV = ( TextView ) findViewById ( R . id . division_descript ) ; descriptionTV . setMovementMethod ( new ScrollingMovementMethod ( ) ) ; ImageView imageIV = ( ImageView ) findViewById ( R . id . divisionimage ) ; TextView phoneTV = ( TextView ) findViewById ( R . id . divisionphone ) ; TextView emailTV = ( TextView ) findViewById ( R . id . divisionemail ) ; TextView websiteTV = ( TextView ) findViewById ( R . id . divisionwebsite ) ; Bundle extras = getIntent ( ) . getExtras ( ) ; String divisionName = extras . getString ( \"name\" ) ; String", "gt": "divisionDescription = extras . getString ( \"description\" ) ;", "prediction": "}\n", "label": 1}
{"id": 3249, "input": "<s> package com . sun . mirror . util ; import com . sun . mirror . type . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public class SimpleTypeVisitor implements TypeVisitor { public SimpleTypeVisitor ( ) { } public void visitTypeMirror ( TypeMirror t ) { } public void visitPrimitiveType ( PrimitiveType t ) { visitTypeMirror ( t ) ; } public void visitVoidType ( VoidType t ) { visitTypeMirror ( t ) ; } public void visitReferenceType ( ReferenceType t ) { visitTypeMirror ( t ) ; } public void visitDeclaredType ( DeclaredType t ) { visitReferenceType ( t ) ; } public", "gt": "void visitClassType ( ClassType t )", "prediction": "}\n", "label": 0}
{"id": 4158, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . core . runtime . IExecutableExtensionFactory ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . ui . internal . ShowInMenu ; import org . eclipse . ui . internal . dialogs . DecoratorsPreferencePage ; import org . eclipse . ui . internal . dialogs . EditorsPreferencePage ; import org . eclipse . ui . internal . dialogs . PerspectivesPreferencePage ; import org . eclipse . ui . internal . dialogs . WorkbenchPreferencePage ; import org . eclipse . ui . internal . progress . ProgressView ; public class ExtensionFactory implements IExecutableExtensionFactory , IExecutableExtension { public static final String DECORATORS_PREFERENCE_PAGE = \"decoratorsPreferencePage\" ; public static final String EDITORS_PREFERENCE_PAGE = \"editorsPreferencePage\" ; public static final String PERSPECTIVES_PREFERENCE_PAGE = \"perspectivesPreferencePage\" ; public static final String PROGRESS_VIEW = \"progressView\" ; public static final String WORKBENCH_PREFERENCE_PAGE = \"workbenchPreferencePage\" ; public static final String SHOW_IN_CONTRIBUTION = \"showInContribution\" ; private IConfigurationElement config ; private String id ; private String propertyName ; public ExtensionFactory ( ) { } private Object configure ( Object obj ) throws CoreException { if ( obj instanceof IExecutableExtension ) { ( ( IExecutableExtension ) obj ) . setInitializationData ( config , propertyName , null ) ; } return obj ; } public Object create ( ) throws CoreException { if ( DECORATORS_PREFERENCE_PAGE . equals ( id ) ) { return configure ( new DecoratorsPreferencePage ( ) ) ; } if ( EDITORS_PREFERENCE_PAGE . equals ( id ) ) { return configure ( new EditorsPreferencePage ( ) ) ; } if ( PERSPECTIVES_PREFERENCE_PAGE . equals ( id ) ) { return configure ( new PerspectivesPreferencePage ( ) ) ; } if ( PROGRESS_VIEW . equals ( id ) ) { return configure ( new ProgressView ( ) ) ; } if ( WORKBENCH_PREFERENCE_PAGE . equals ( id ) ) { return configure ( new WorkbenchPreferencePage ( ) ) ; }", "gt": "if ( SHOW_IN_CONTRIBUTION . equals ( id ) )", "prediction": "}\n", "label": 1}
{"id": 3982, "input": "<s> class A < T extends A < T > > { class C { public T getT ( ) { return null ; } } }", "gt": "class B extends A < B >", "prediction": "}\n", "label": 0}
{"id": 4166, "input": "<s> package org . modelgoon . core . ui ; import java . util . List ; import org . eclipse . core . resources . IResource ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . gef . requests . CreationFactory ; public class ObjectCreationFactory implements CreationFactory { List < IResource > resources ; private final Point location = new Point ( ) ; ModelElementFactory modelElementFactory ; Diagram < ? > diagram ; public ObjectCreationFactory ( final Diagram < ? > diagram ) { this . diagram = diagram ; } public void setModelElementFactory ( final ModelElementFactory modelElementFactory ) { this . modelElementFactory = modelElementFactory ; } public final void setResources ( final List < IResource > javaResources ) { this . resources = javaResources ; } public final Point setLocation ( final Point point ) { this . location . setLocation ( point ) ; this . diagram . getRootFigure ( ) . translateToRelative ( this . location ) ; return this . location ; } public final Object getObjectType ( ) { return List . class ; } public final Object getNewObject ( ) { if ( this . modelElementFactory != null ) { return this . modelElementFactory . createObjectFromDroppedResources ( this .", "gt": "resources , this . location ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4946, "input": "<s> public class UninitThis { UninitThis ( String s , int i ) { this ( i == 0 ? s : \"foo\" ) ; } UninitThis ( String s ) { } public static void main", "gt": "( String ... args )", "prediction": "( )\n", "label": 0}
{"id": 4173, "input": "<s> package org . eclipse . jface . tests . viewers . interactive ; import org . eclipse . jface . tests . viewers . TestElement ; public class ChangeChildLabelAction extends TestSelectionAction { public ChangeChildLabelAction ( String label , TestBrowser browser ) { super ( label , browser ) ; } public", "gt": "void run ( TestElement element )", "prediction": "void ( )\n", "label": 1}
{"id": 9270, "input": "<s> package com . sun . tools . javac . api ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Writer ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . EnumSet ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Set ; import javax . lang . model . SourceVersion ; import javax . tools . * ; import com . sun . source . util . JavacTask ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . main . JavacOption . OptionKind ; import com . sun . tools . javac . main . JavacOption ; import com . sun . tools . javac . main . Main ; import com . sun . tools . javac . main . RecognizedOptions . GrumpyHelper ; import com . sun . tools . javac . main . RecognizedOptions ; import com . sun . tools . javac . util . ClientCodeException ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Options ; import com . sun . tools . javac . util . Pair ; public class JavacTool implements JavaCompiler { private final List < Pair < String , String > > options = new ArrayList < Pair < String , String > > ( ) ; private final Context dummyContext = new Context ( ) ; private final PrintWriter silent = new PrintWriter ( new OutputStream ( ) { public void write ( int b ) { } } ) ; private final Main sharedCompiler = new Main ( \"javac\" , silent ) ; { sharedCompiler . setOptions ( Options . instance ( dummyContext ) ) ; } @ Deprecated public JavacTool ( ) { } public static JavacTool create ( ) { return new JavacTool ( ) ; } private String argsToString ( Object ... args ) { String newArgs = null ; if ( args . length > 0 ) { StringBuilder sb = new StringBuilder ( ) ; String separator = \"\" ; for ( Object arg : args ) { sb . append ( separator ) . append ( arg . toString ( ) ) ; separator = File . pathSeparator ; } newArgs = sb . toString ( ) ; } return newArgs ; } private void setOption1 ( String name , OptionKind kind , Object ... args ) { String arg = argsToString ( args ) ; JavacOption option = sharedCompiler . getOption ( name ) ; if ( option == null || ! match ( kind , option . getKind ( ) ) ) throw new IllegalArgumentException ( name ) ; if ( ( args . length != 0 ) != option . hasArg ( ) ) throw new IllegalArgumentException ( name ) ; if ( option . hasArg ( ) ) { if ( option . process ( null , name , arg ) ) throw new IllegalArgumentException ( name ) ; } else { if ( option . process ( null , name ) ) throw new IllegalArgumentException ( name ) ; } options . add ( new Pair < String , String > ( name , arg ) ) ; } public void setOption ( String name , Object ... args ) { setOption1 ( name , OptionKind . NORMAL , args ) ; } public void setExtendedOption ( String name , Object ... args ) { setOption1 ( name , OptionKind . EXTENDED , args ) ; } private static boolean match ( OptionKind clientKind , OptionKind optionKind ) { return ( clientKind == ( optionKind == OptionKind . HIDDEN ? OptionKind . EXTENDED : optionKind ) ) ; } public JavacFileManager getStandardFileManager ( DiagnosticListener < ? super JavaFileObject > diagnosticListener , Locale locale , Charset charset ) { Context context = new Context ( ) ; context . put ( Locale . class , locale ) ; if ( diagnosticListener != null ) context . put ( DiagnosticListener . class , diagnosticListener ) ; PrintWriter pw = ( charset == null ) ? new PrintWriter ( System . err , true ) : new PrintWriter ( new OutputStreamWriter ( System . err , charset ) , true ) ; context . put ( Log . outKey , pw ) ; return new JavacFileManager ( context , true , charset ) ; } public JavacTask getTask ( Writer out , JavaFileManager fileManager , DiagnosticListener < ? super JavaFileObject > diagnosticListener , Iterable < String > options , Iterable < String > classes , Iterable < ? extends JavaFileObject > compilationUnits ) { try { Context context = new Context ( ) ; ClientCodeWrapper ccw = ClientCodeWrapper . instance ( context ) ; final String kindMsg = \"All compilation units must be of SOURCE kind\" ; if ( options != null ) for ( String option : options ) option . getClass ( ) ; if ( classes != null ) { for ( String cls : classes ) if ( ! SourceVersion . isName ( cls ) ) throw new IllegalArgumentException ( \"Not a valid class name: \" + cls ) ; } if ( compilationUnits != null ) { compilationUnits = ccw . wrapJavaFileObjects ( compilationUnits ) ; for ( JavaFileObject cu : compilationUnits ) { if ( cu . getKind ( ) != JavaFileObject . Kind . SOURCE ) throw new IllegalArgumentException ( kindMsg ) ; } } if ( diagnosticListener != null ) context . put ( DiagnosticListener . class , ccw . wrap ( diagnosticListener ) ) ; if ( out == null ) context . put ( Log . outKey , new PrintWriter ( System . err , true ) ) ; else context . put ( Log . outKey , new PrintWriter ( out , true ) ) ; if ( fileManager == null ) fileManager", "gt": "= getStandardFileManager ( diagnosticListener , null , null ) ;", "prediction": ";\n", "label": 0}
{"id": 4176, "input": "<s> package org . restlet . util ; import java . io . IOException ; public interface SelectionListener { public void onSelected (", "gt": "SelectionRegistration selectionRegistration ) throws IOException ;", "prediction": ") ;\n", "label": 1}
{"id": 7735, "input": "<s> import java . util . * ; class UncheckedFilename1 { List < String > list", "gt": "= new ArrayList ( ) ;", "prediction": ";\n", "label": 0}
{"id": 4188, "input": "<s> package bad . robot . refactoring . chapter1 ; public class ChildrensPrice extends Price { @ Override public int getPriceCode ( ) { return Movie . CHILDREN ; } @ Override double getCharge ( int daysRented ) { double amount = 1.5 ; if ( daysRented > 3 ) amount += ( daysRented", "gt": "- 3 ) * 1.5 ;", "prediction": ") ;\n", "label": 1}
{"id": 1362, "input": "<s> package org . gk . engine . client . event . attrib ; import org . gk . ui . client . com . grid . gkGridIC ; import com . extjs . gxt . ui . client . widget . Component ; public class CellAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { } @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof gkGridIC ) { gkGridIC grid = ( gkGridIC ) com ; int row = grid . getGrid ( ) . getView ( ) . getLastRowIndex ( ) ; int col = grid . getGrid ( ) . getView ( ) . getLastColIndex ( ) ; value = grid . getGrid ( ) . getView ( ) . getCell", "gt": "( row , col ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4190, "input": "<s> package org . fuzzydb . io . core . exceptions ; @ SuppressWarnings ( \"serial\" ) public class NotListeningException extends Exception { public NotListeningException ( ) { super ( ) ; }", "gt": "public NotListeningException ( Throwable cause )", "prediction": "}\n", "label": 1}
{"id": 1755, "input": "<s> package com . redhat . ceylon . itest ; import org . junit . Assert ; import org . junit . Ignore ; import org . junit . Test ; public class CeylonMdAntTest extends AntBasedTest { public CeylonMdAntTest ( ) throws Exception { super ( \"test/src/com/redhat/ceylon/itest/ceylonmd-ant.xml\" ) ; } @ Test public void testFoo ( ) throws Exception { AntResult result = ant ( \"foo\" ) ; Assert . assertEquals ( 0 , result . getStatusCode ( ) ) ; assertContains ( result . getStdout ( ) , \"RESULT version: 1.0\" ) ; assertContains ( result . getStdout ( ) , \"RESULT name: com.example.foo\" ) ; } @ Test public void testBar ( ) throws Exception { AntResult result = ant ( \"bar\" ) ; Assert . assertEquals ( 0 , result . getStatusCode ( ) ) ; assertContains ( result . getStdout ( ) , \"RESULT version: 1.0\" ) ; assertContains ( result . getStdout ( ) , \"RESULT name: com.example.bar\" ) ; } @ Test public void testBad ( ) throws Exception { AntResult result = ant ( \"bad\" ) ; Assert . assertEquals ( 0 , result . getStatusCode ( ) ) ; assertContains ( result . getStdout ( ) , \"RESULT version: 1.0\" ) ; assertContains ( result . getStdout ( ) , \"RESULT name: com.example.bad\" ) ; } @ Test @ Ignore ( \"We don't want this to break when we change the sdk tests\" ) public void testSdkTest ( ) throws Exception { AntResult result", "gt": "= ant ( \"sdk-test\" ) ;", "prediction": ";\n", "label": 0}
{"id": 4200, "input": "<s> package org . nuxeo . theme . webwidgets . samples ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . nuxeo . ecm . webengine . model . WebObject ; import org . nuxeo . ecm . webengine . model . impl . ModuleRoot ; @ Path ( \"/nxthemes-webwidgets-samples\" ) @ WebObject ( type = \"nxthemes-webwidgets-samples\" ) @ Produces (", "gt": "\"text/html\" ) public class Main extends ModuleRoot", "prediction": ") ;\n", "label": 1}
{"id": 8302, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalBooleanLiteral ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class LogicalBooleanLiteralImpl extends LogicalExpressionImpl implements LogicalBooleanLiteral { protected static final boolean IS_TRUE_EDEFAULT = false ; protected boolean isTrue = IS_TRUE_EDEFAULT ; protected LogicalBooleanLiteralImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getLogicalBooleanLiteral ( ) ; } public boolean isIsTrue ( ) { return isTrue ; } public void setIsTrue ( boolean newIsTrue ) { boolean oldIsTrue = isTrue ; isTrue = newIsTrue ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . LOGICAL_BOOLEAN_LITERAL__IS_TRUE , oldIsTrue , isTrue ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . LOGICAL_BOOLEAN_LITERAL__IS_TRUE : return isIsTrue ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . LOGICAL_BOOLEAN_LITERAL__IS_TRUE : setIsTrue ( ( Boolean ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . LOGICAL_BOOLEAN_LITERAL__IS_TRUE : setIsTrue ( IS_TRUE_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . LOGICAL_BOOLEAN_LITERAL__IS_TRUE : return isTrue != IS_TRUE_EDEFAULT ; } return", "gt": "super . eIsSet ( featureID ) ;", "prediction": ";\n", "label": 0}
{"id": 4211, "input": "<s> package org . eclipse . ui . internal . decorators ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ILabelDecorator ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . WorkbenchPlugin ; class FullDecoratorDefinition extends DecoratorDefinition { ILabelDecorator decorator ; FullDecoratorDefinition ( String identifier , IConfigurationElement element ) { super ( identifier , element ) ; } protected ILabelDecorator internalGetDecorator ( ) throws CoreException { if ( labelProviderCreationFailed ) { return null ; } final CoreException [ ] exceptions = new CoreException [ 1 ] ; if ( decorator == null ) { Platform . run ( new SafeRunnable ( NLS . bind ( WorkbenchMessages . get ( ) . DecoratorManager_ErrorActivatingDecorator , getName ( ) ) ) { public void run ( ) { try { decorator = ( ILabelDecorator ) WorkbenchPlugin . createExtension ( definingElement , DecoratorDefinition . ATT_CLASS ) ; decorator . addListener ( WorkbenchPlugin . getDefault ( ) . getDecoratorManager ( ) ) ; } catch ( CoreException exception ) { exceptions [ 0 ] = exception ; } } } ) ; } else { return decorator ; } if ( decorator == null ) { this . labelProviderCreationFailed = true ; setEnabled ( false ) ; } if ( exceptions [ 0 ] != null ) { throw exceptions [ 0 ] ; } return decorator ; } protected void refreshDecorator ( ) { if ( ! this . enabled && decorator != null ) { IBaseLabelProvider cached = decorator ; decorator = null ; disposeCachedDecorator ( cached ) ; } } Image decorateImage ( Image image , Object element ) { try { ILabelDecorator currentDecorator = internalGetDecorator ( ) ; if ( currentDecorator != null ) { return currentDecorator . decorateImage ( image , element ) ; } } catch ( CoreException exception ) { handleCoreException ( exception ) ; } return null ; } String decorateText ( String text , Object element ) { try { ILabelDecorator currentDecorator = internalGetDecorator ( ) ; if ( currentDecorator != null ) { return currentDecorator . decorateText ( text , element ) ; } } catch ( CoreException exception ) { handleCoreException ( exception ) ; } return null ; } public ILabelDecorator getDecorator ( ) { return decorator ; }", "gt": "protected IBaseLabelProvider internalGetLabelProvider ( ) throws CoreException", "prediction": "}\n", "label": 1}
{"id": 3915, "input": "<s> package org . ofbiz . entity . condition ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelReader ; public class EntityClause { private String firstEntity = \"\" ; private String secondEntity = \"\" ; private String firstField = \"\" ; private String secondField = \"\" ; private ModelEntity firstModelEntity = null ; private ModelEntity secondModelEntity = null ; private EntityOperator < ? , ? , ? > interFieldOperation = null ; private EntityOperator < ? , ? , ? > intraFieldOperation = null ; private Object value = null ; public EntityClause ( ) { } public EntityClause ( String firstEntity , String secondEntity , String firstField , String secondField , EntityOperator < ? , ? , ? > interFieldOperation , EntityOperator < ? , ? , ? > intraFieldOperation ) { this . firstEntity = firstEntity ; this . secondEntity = secondEntity ; this . firstField = firstField ; this . secondField = secondField ; this . interFieldOperation = interFieldOperation ; this . intraFieldOperation = intraFieldOperation ; } public EntityClause ( String firstEntity , String firstField , Object value , EntityOperator < ? , ? , ? > interFieldOperation , EntityOperator < ? , ? , ? > intraFieldOperation ) { this . firstEntity = firstEntity ; this . firstField = firstField ; this . value = value ; this . interFieldOperation = interFieldOperation ; this . intraFieldOperation = intraFieldOperation ; } public String getFirstEntity ( ) { return firstEntity ; } public String getSecondEntity ( ) { return secondEntity ; } public String getFirstField ( ) { return firstField ; } public String getSecondField ( ) { return secondField ; } public Object getValue ( ) { if ( value == null ) value = new Object ( ) ; return value ; } public < L , R , T > EntityOperator < L , R , T > getInterFieldOperation ( ) { return UtilGenerics . cast ( interFieldOperation ) ; } public < L , R , T > EntityOperator < L , R , T > getIntraFieldOperation ( ) { return UtilGenerics . cast ( intraFieldOperation ) ; } public void setFirstEntity ( String firstEntity ) { this . firstEntity = firstEntity ; } public void setSecondEntity ( String secondEntity ) { this . secondEntity = secondEntity ; } public void setFirstField ( String firstField ) { this . firstField = firstField ; } public void setSecondField ( String secondField ) { this . secondField = secondField ; } public < L , R , T > void setInterFieldOperation ( EntityOperator < L , R , T > interFieldOperation ) { this . interFieldOperation = interFieldOperation ; } public < L , R , T > void setIntraFieldOperation ( EntityOperator < L , R , T > intraFieldOperation ) {", "gt": "this . intraFieldOperation = intraFieldOperation ;", "prediction": "\n", "label": 0}
{"id": 4213, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; import org . eclipse . swt . graphics . * ; @ SuppressWarnings ( \"all\" ) final class LZWCodec { int bitsPerPixel , blockSize , blockIndex , currentByte , bitsLeft , codeSize , clearCode , endCode , newCodes , topSlot , currentSlot , imageWidth , imageHeight , imageX , imageY , pass , line , codeMask ; byte [ ] block , lineArray ; int [ ] stack , suffix , prefix ; LZWNode [ ] nodeStack ; LEDataInputStream inputStream ; LEDataOutputStream outputStream ; ImageData image ; ImageLoader loader ; boolean interlaced ; static final int [ ] MASK_TABLE = new int [ ] { 0x1 , 0x3 , 0x7 , 0xF , 0x1F , 0x3F , 0x7F , 0xFF , 0x1FF , 0x3FF , 0x7FF , 0xFFF } ; void decode ( ) { int code ; int oc = 0 ; int fc = 0 ; byte [ ] buf = new byte [ imageWidth ] ; int stackIndex = 0 ; int bufIndex = 0 ; int c ; while ( ( c = nextCode ( ) ) != endCode ) { if ( c == clearCode ) { codeSize = bitsPerPixel + 1 ; codeMask = MASK_TABLE [ bitsPerPixel ] ; currentSlot = newCodes ; topSlot = 1 << codeSize ; while ( ( c = nextCode ( ) ) == clearCode ) { } if ( c != endCode ) { oc = fc = c ; buf [ bufIndex ] = ( byte ) c ; bufIndex ++ ; if ( bufIndex == imageWidth ) { nextPutPixels ( buf ) ; bufIndex = 0 ; } } } else { code = c ; if ( code >= currentSlot ) { code = oc ; stack [ stackIndex ] = fc ; stackIndex ++ ; } while ( code >= newCodes ) { stack [ stackIndex ] = suffix [ code ] ; stackIndex ++ ; code = prefix [ code ] ; } stack [ stackIndex ] = code ; stackIndex ++ ; if ( currentSlot < topSlot ) { fc = code ; suffix [ currentSlot ] = fc ; prefix [ currentSlot ] = oc ; currentSlot ++ ; oc = c ; } if ( currentSlot >= topSlot ) { if ( codeSize < 12 ) { codeMask = MASK_TABLE [ codeSize ] ; codeSize ++ ; topSlot = topSlot + topSlot ; } } while ( stackIndex > 0 ) { stackIndex -- ; buf [ bufIndex ] = ( byte ) stack [ stackIndex ] ; bufIndex ++ ; if ( bufIndex == imageWidth ) { nextPutPixels ( buf ) ; bufIndex = 0 ; } } } } if ( bufIndex != 0 && line < imageHeight ) { nextPutPixels ( buf ) ; } } public void decode ( LEDataInputStream inputStream , ImageLoader loader , ImageData image , boolean interlaced , int depth ) { this . inputStream = inputStream ; this . loader = loader ; this . image = image ; this . interlaced = interlaced ; this . bitsPerPixel = depth ; initializeForDecoding ( ) ; decode ( ) ; } void encode ( ) { nextPutCode ( clearCode ) ; int lastPrefix = encodeLoop ( ) ; nextPutCode ( lastPrefix ) ; nextPutCode ( endCode ) ; if ( bitsLeft == 8 ) { block [ 0 ] = ( byte ) ( blockIndex - 1 ) ; } else { block [ 0 ] = ( byte ) ( blockIndex ) ; } writeBlock ( ) ; if ( block [ 0 ] != 0 ) { block [ 0 ] = 0 ; writeBlock ( ) ; } } public void encode ( LEDataOutputStream byteStream , ImageData image ) { this . outputStream = byteStream ; this . image = image ; initializeForEncoding ( ) ; encode ( ) ; } int encodeLoop ( ) { int pixel = nextPixel ( ) ; boolean found ; LZWNode node ; while ( true ) { int currentPrefix = pixel ; node = nodeStack [ currentPrefix ] ; found = true ; pixel = nextPixel ( ) ; if ( pixel < 0 ) return currentPrefix ; while ( found && ( node . children != null ) ) { node = node . children ; while ( found && ( node . suffix != pixel ) ) { if ( pixel < node . suffix ) { if ( node . left == null ) { node . left = new LZWNode ( ) ; found = false ; } node = node . left ; } else { if ( node . right == null ) { node . right = new LZWNode ( ) ; found = false ; } node = node . right ; } } if ( found ) { currentPrefix = node . code ; pixel = nextPixel ( ) ; if ( pixel < 0 ) return currentPrefix ; } } if ( found ) { node . children = new LZWNode ( ) ; node = node . children ; } node . children = null ; node . left = null ; node . right = null ; node . code = currentSlot ; node . prefix = currentPrefix ; node . suffix = pixel ; nextPutCode ( currentPrefix ) ; currentSlot ++ ; if ( currentSlot < 4096 ) { if ( currentSlot > topSlot ) { codeSize ++ ; codeMask = MASK_TABLE [ codeSize - 1 ] ; topSlot *= 2 ; } } else { nextPutCode ( clearCode ) ; for ( int i = 0 ; i < nodeStack . length ; i ++ ) nodeStack [ i ] . children = null ; codeSize = bitsPerPixel + 1 ; codeMask = MASK_TABLE [ codeSize - 1 ] ; currentSlot = newCodes ; topSlot = 1 << codeSize ; } } } void initializeForDecoding ( ) { pass = 1 ; line = 0 ; codeSize = bitsPerPixel + 1 ; topSlot = 1 << codeSize ; clearCode = 1 << bitsPerPixel ; endCode = clearCode + 1 ; newCodes = currentSlot = endCode + 1 ; currentByte = - 1 ; blockSize = bitsLeft = 0 ; blockIndex = 0 ; codeMask = MASK_TABLE [ codeSize - 1 ] ; stack = new", "gt": "int [ 4096 ] ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3531, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . xtext . common . types . JvmIdentifiableElement ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . XBinaryOperation ; public class XBinaryOperationImpl extends LogicalExpressionImpl implements XBinaryOperation { protected LogicalExpression leftOperand ; protected JvmIdentifiableElement feature ; protected LogicalExpression rightOperand ; protected XBinaryOperationImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getXBinaryOperation ( ) ; } public LogicalExpression getLeftOperand ( ) { return leftOperand ; } public NotificationChain basicSetLeftOperand ( LogicalExpression newLeftOperand , NotificationChain msgs ) { LogicalExpression oldLeftOperand = leftOperand ; leftOperand = newLeftOperand ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND , oldLeftOperand , newLeftOperand ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setLeftOperand ( LogicalExpression newLeftOperand ) { if ( newLeftOperand != leftOperand ) { NotificationChain msgs = null ; if ( leftOperand != null ) msgs = ( ( InternalEObject ) leftOperand ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND , null , msgs ) ; if ( newLeftOperand != null ) msgs = ( ( InternalEObject ) newLeftOperand ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND , null , msgs ) ; msgs = basicSetLeftOperand ( newLeftOperand , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND , newLeftOperand , newLeftOperand ) ) ; } public JvmIdentifiableElement getFeature ( ) { if ( feature != null && feature . eIsProxy ( ) ) { InternalEObject oldFeature = ( InternalEObject ) feature ; feature = ( JvmIdentifiableElement ) eResolveProxy ( oldFeature ) ; if ( feature != oldFeature ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . XBINARY_OPERATION__FEATURE , oldFeature , feature ) ) ; } } return feature ; } public JvmIdentifiableElement basicGetFeature ( ) { return feature ; } public void setFeature ( JvmIdentifiableElement newFeature ) { JvmIdentifiableElement oldFeature = feature ; feature = newFeature ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . XBINARY_OPERATION__FEATURE , oldFeature , feature ) ) ; } public LogicalExpression getRightOperand ( ) { return rightOperand ; } public NotificationChain basicSetRightOperand ( LogicalExpression newRightOperand , NotificationChain msgs ) { LogicalExpression oldRightOperand = rightOperand ; rightOperand = newRightOperand ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . XBINARY_OPERATION__RIGHT_OPERAND , oldRightOperand , newRightOperand ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setRightOperand ( LogicalExpression newRightOperand ) { if ( newRightOperand != rightOperand ) { NotificationChain msgs = null ; if ( rightOperand != null ) msgs = ( ( InternalEObject ) rightOperand ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . XBINARY_OPERATION__RIGHT_OPERAND , null , msgs ) ; if ( newRightOperand != null ) msgs = ( ( InternalEObject ) newRightOperand ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . XBINARY_OPERATION__RIGHT_OPERAND , null , msgs ) ; msgs = basicSetRightOperand ( newRightOperand , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . XBINARY_OPERATION__RIGHT_OPERAND , newRightOperand , newRightOperand ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND : return basicSetLeftOperand ( null , msgs ) ; case ProjectPackage . XBINARY_OPERATION__RIGHT_OPERAND : return basicSetRightOperand ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) {", "gt": "case ProjectPackage . XBINARY_OPERATION__LEFT_OPERAND : return getLeftOperand ( ) ;", "prediction": "}\n", "label": 0}
{"id": 4217, "input": "<s> package org . fuzzydb . util ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; public class ByteArray implements Serializable , Cloneable { private static final long serialVersionUID = 1L ; private byte [ ] bytes ; private int count ; public ByteArray ( ) { bytes = null ; } public ByteArray ( int initialSize ) { bytes = new byte [ initialSize ] ; } final public void putBoolean ( int index , boolean bool ) { assertCapacity ( index ) ; bytes [ index ] = bool ? ( byte ) 1 : ( byte ) 0 ; } final public void putByte ( int index , byte b ) { assertCapacity ( index ) ; bytes [ index ] = b ; } final public void putShort ( int index , short s ) { assertCapacity ( index + 1 ) ; bytes [ index + 1 ] = ( byte ) ( s > > > 0 ) ; bytes [ index + 0 ] = ( byte ) ( s > > > 8 ) ; } final public void putInt ( int index , int i ) { assertCapacity ( index + 3 ) ; bytes [ index + 3 ] = ( byte ) ( i > > > 0 ) ; bytes [ index + 2 ] = ( byte ) ( i > > > 8 ) ; bytes [ index + 1 ] = ( byte ) ( i > > > 16 ) ; bytes [ index + 0 ] = ( byte ) ( i > > > 24 ) ; } public void putLong ( int index , long l ) { assertCapacity ( index + 7 ) ; bytes [ index + 7 ] = ( byte ) ( l > > > 0 ) ; bytes [ index + 6 ] = ( byte ) ( l > > > 8 ) ; bytes [ index + 5 ] = ( byte ) ( l > > > 16 ) ; bytes [ index + 4 ] = ( byte ) ( l > > > 24 ) ; bytes [ index + 3 ] = ( byte ) ( l > > > 32 ) ; bytes [ index + 2 ] = ( byte ) ( l > > > 40 ) ; bytes [ index + 1 ] = ( byte ) ( l > > > 48 ) ; bytes [ index + 0 ] = ( byte ) ( l > > > 56 ) ; } final public void putFloat ( int index , float f ) { assertCapacity ( index + 3 ) ; int i = Float . floatToIntBits ( f ) ; bytes [ index + 3 ] = ( byte ) ( i > > > 0 ) ; bytes [ index + 2 ] = ( byte ) ( i > > > 8 ) ; bytes [ index + 1 ] = ( byte ) ( i > > > 16 ) ; bytes [ index + 0 ] = ( byte ) ( i > > > 24 ) ; } final public void join ( ByteArray bytes ) { byte [ ] a = bytes . getArray ( ) ; for ( byte b : a ) { int i = getIndexForWrite ( 1 ) ;", "gt": "putByte ( i , b ) ;", "prediction": "}\n", "label": 1}
{"id": 7398, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; import java . io . IOException ; import java . nio . channels . SocketChannel ; import org . codehaus . jackson . JsonFactory ; import org . codehaus . jackson . JsonGenerationException ; import org . codehaus . jackson . JsonGenerator ; import org . codehaus . jackson . map . JsonMappingException ; import org . codehaus . jackson . map . MappingJsonFactory ; import android . os . Handler ; import android . os . Looper ; import android . util . Log ; public class WampWriter extends WebSocketWriter { private static final boolean DEBUG = true ; private static final String TAG = WampWriter . class . getName ( ) ; private final JsonFactory mJsonFactory ; private final NoCopyByteArrayOutputStream mPayload ; public WampWriter ( Looper looper , Handler master , SocketChannel socket , WebSocketOptions options ) { super ( looper , master , socket , options ) ; mJsonFactory = new MappingJsonFactory ( ) ; mPayload = new NoCopyByteArrayOutputStream ( ) ; if ( DEBUG ) Log . d ( TAG , \"created\" ) ; } protected void processAppMessage ( Object msg ) throws WebSocketException , IOException { mPayload . reset ( ) ; JsonGenerator generator = mJsonFactory . createJsonGenerator ( mPayload ) ; try { if ( msg instanceof WampMessage . Call ) { WampMessage . Call call = ( WampMessage . Call ) msg ; generator . writeStartArray ( ) ; generator . writeNumber ( WampMessage . MESSAGE_TYPE_CALL ) ; generator . writeString ( call . mCallId ) ; generator . writeString ( call . mProcUri ) ; for ( Object arg : call . mArgs ) { generator . writeObject ( arg ) ; } generator . writeEndArray ( ) ; } else if ( msg instanceof WampMessage . Prefix ) { WampMessage . Prefix prefix = ( WampMessage . Prefix ) msg ; generator . writeStartArray ( ) ; generator . writeNumber ( WampMessage . MESSAGE_TYPE_PREFIX ) ; generator . writeString ( prefix . mPrefix ) ; generator . writeString ( prefix . mUri ) ; generator . writeEndArray ( ) ; } else if ( msg instanceof WampMessage . Subscribe ) { WampMessage . Subscribe subscribe = ( WampMessage . Subscribe ) msg ; generator . writeStartArray ( ) ; generator . writeNumber ( WampMessage . MESSAGE_TYPE_SUBSCRIBE ) ; generator . writeString ( subscribe . mTopicUri ) ; generator . writeEndArray ( ) ; } else if ( msg instanceof WampMessage . Unsubscribe ) { WampMessage . Unsubscribe unsubscribe = ( WampMessage . Unsubscribe ) msg ; generator . writeStartArray ( ) ; generator . writeNumber ( WampMessage . MESSAGE_TYPE_UNSUBSCRIBE ) ; generator . writeString ( unsubscribe . mTopicUri ) ; generator . writeEndArray ( ) ; } else if ( msg instanceof WampMessage . Publish ) { WampMessage . Publish publish = ( WampMessage . Publish ) msg ; generator . writeStartArray ( ) ; generator . writeNumber ( WampMessage . MESSAGE_TYPE_PUBLISH ) ; generator", "gt": ". writeString ( publish . mTopicUri ) ;", "prediction": "}\n", "label": 0}
{"id": 4250, "input": "<s> package org . nuxeo . ecm . platform . publisher . task ; import java . util . List ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . platform . task . Task ; import org . nuxeo . ecm . platform . task . TaskService ; import org . nuxeo . runtime . api . Framework ; class LookupStateByTask implements LookupState { @ Override public boolean isPublished ( DocumentModel doc , CoreSession session ) throws ClientException { List < Task > tasks = Framework . getLocalService ( TaskService . class ) . getTaskInstances ( doc , ( NuxeoPrincipal ) null , session ) ; for ( Task task : tasks ) { if ( task . getName ( )", "gt": ". equals ( CoreProxyWithWorkflowFactory . TASK_NAME ) )", "prediction": ") ;\n", "label": 1}
{"id": 4601, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import java . awt . Color ; import java . util . List ; import org . jfree . chart . plot . PlotOrientation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . dataset . XYDataset ; import ar . com . fdvs . dj . domain . chart . plot . AreaPlot ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; public class DJXYAreaChartBuilder extends AbstractChartBuilder { public DJXYAreaChartBuilder setOperation ( byte operation ) { this . chart . setOperation ( operation ) ; return this ; } public DJXYAreaChartBuilder setLink ( DJHyperLink link ) { this . chart . setLink ( link ) ; return this ; } public DJXYAreaChartBuilder setBackColor ( Color backColor ) { this . chart . getOptions ( ) . setBackColor ( backColor ) ; return this ; } public DJXYAreaChartBuilder setHeight ( int height ) { this . chart . getOptions ( ) . setHeight ( height ) ; return this ; } public DJXYAreaChartBuilder setWidth ( int width ) { this . chart . getOptions ( ) . setWidth ( width ) ; return this ; } public DJXYAreaChartBuilder setCentered ( boolean centered ) { this . chart . getOptions ( ) . setCentered ( centered ) ; return this ; } public DJXYAreaChartBuilder setPosition ( byte position ) { this . chart . getOptions ( ) . setPosition ( position ) ; return this ; } public DJXYAreaChartBuilder setY ( int y ) { this . chart . getOptions ( ) . setY ( y ) ; return this ; } public DJXYAreaChartBuilder setX ( int x ) { this . chart . getOptions ( ) . setX ( x ) ; return this ; } public DJXYAreaChartBuilder setShowLegend ( boolean showLegend ) { this . chart . getOptions ( ) . setShowLegend ( new Boolean ( showLegend ) ) ; return this ; } public DJXYAreaChartBuilder setTitleColor ( Color titleColor ) { this . chart . getOptions ( ) . setTitleColor ( titleColor ) ; return this ; } public DJXYAreaChartBuilder setSubtitleColor ( Color subtitleColor ) { this . chart . getOptions ( ) . setSubtitleColor ( subtitleColor ) ; return this ; } public DJXYAreaChartBuilder setLegendColor ( Color legendColor ) { this . chart . getOptions ( ) . setLegendColor ( legendColor ) ; return this ; } public DJXYAreaChartBuilder setLegendBackgroundColor ( Color legendBackgroundColor ) { this . chart . getOptions ( ) . setLegendBackgroundColor ( legendBackgroundColor ) ; return this ; } public DJXYAreaChartBuilder setTheme ( String theme ) { this . chart . getOptions ( ) . setTheme ( theme ) ; return this ; } public DJXYAreaChartBuilder setTitleFont ( Font titleFont ) { this . chart . getOptions ( ) . setTitleFont ( titleFont ) ; return this ; } public DJXYAreaChartBuilder setSubtitleFont ( Font subtitleFont ) { this . chart . getOptions ( ) . setSubtitleFont ( subtitleFont ) ; return this ; } public DJXYAreaChartBuilder setLegendFont ( Font legendFont ) { this . chart . getOptions ( ) . setLegendFont ( legendFont ) ; return this ; } public DJXYAreaChartBuilder setLegendPosition ( byte legendPosition ) { this . chart . getOptions ( ) . setLegendPosition ( legendPosition ) ; return this ; } public DJXYAreaChartBuilder setTitlePosition ( byte titlePosition ) { this . chart . getOptions ( ) . setTitlePosition ( titlePosition ) ; return this ; } public DJXYAreaChartBuilder setTitle ( String title ) { this . chart . getOptions ( ) . setTitleExpression ( new LiteralExpression ( title ) ) ; return this ; } public DJXYAreaChartBuilder setTitle ( StringExpression titleExpression ) { this . chart . getOptions ( ) . setTitleExpression ( titleExpression ) ; return this ; } public DJXYAreaChartBuilder setSubtitle ( String subtitle ) { this . chart . getOptions ( ) . setSubtitleExpression ( new LiteralExpression ( subtitle ) ) ; return this ; } public DJXYAreaChartBuilder setSubtitle ( StringExpression subtitleExpression ) { this . chart . getOptions ( ) . setSubtitleExpression ( subtitleExpression ) ; return this ; } public DJXYAreaChartBuilder setLineStyle ( byte lineStyle ) { this . chart . getOptions ( ) . setLineStyle ( lineStyle ) ; return this ; } public DJXYAreaChartBuilder setLineWidth ( float lineWidth ) { this . chart . getOptions ( ) . setLineWidth ( new Float ( lineWidth ) ) ; return this ; } public DJXYAreaChartBuilder setLineColor ( Color lineColor ) { this . chart . getOptions ( ) . setLineColor ( lineColor ) ; return this ; } public DJXYAreaChartBuilder setPadding ( int padding ) { this . chart . getOptions ( ) . setPadding ( new Integer ( padding ) ) ; return this ; } public DJXYAreaChartBuilder setCustomizerClass ( String customizerClass ) { this . chart . getOptions ( ) . setCustomizerClass ( customizerClass ) ; return this ; } public DJXYAreaChartBuilder setXValue ( PropertyColumn xValue ) { getDataset ( ) . setXValue ( xValue ) ; return this ; } public DJXYAreaChartBuilder addSerie ( AbstractColumn column ) { getDataset ( ) . addSerie ( column ) ; return this ; } public DJXYAreaChartBuilder addSerie ( AbstractColumn column , String label ) { getDataset ( ) . addSerie ( column , label ) ; return this ; } public DJXYAreaChartBuilder addSerie ( AbstractColumn column , StringExpression labelExpression ) { getDataset (", "gt": ") . addSerie ( column , labelExpression ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4266, "input": "<s> package br . org . archimedes . io . xml . elements ; import java . io . IOException ; import java . io . OutputStream ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . io . xml . XMLExporterHelper ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . polyline . Polyline ; public class PolylineXMLExporter implements ElementExporter < Polyline > { public void exportElement ( Polyline element , Object outputObject ) throws IOException { OutputStream output = ( OutputStream ) outputObject ; StringBuilder lineTag = new StringBuilder ( ) ; lineTag . append ( \"<polyline>\" ) ; for ( Point p : element . getPoints ( ) ) { lineTag . append ( XMLExporterHelper . xmlFor ( \"point\" , p ) ) ; } lineTag . append ( \"</polyline>\" ) ; output . write (", "gt": "lineTag . toString ( ) . getBytes ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3726, "input": "<s> package com . matburt . mobileorg . Gui ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . InputStreamReader ; import android . app . Activity ; import android . content . ActivityNotFoundException ; import android . content . Intent ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager . NameNotFoundException ; import android . os . Bundle ; import android . util . Log ; import android . widget . Toast ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . OrgData . OrgDatabase ; import com . matburt . mobileorg . OrgData . OrgFile ; import com . matburt . mobileorg . OrgData . OrgFileParser ; public class FileDecryptionActivity extends Activity { private static final String mApgPackageName = \"org.thialfihar.android.apg\" ; private static final int mMinRequiredVersion = 16 ; private static final String DECRYPT_AND_RETURN = \"org.thialfihar.android.apg.intent.DECRYPT_AND_RETURN\" ; private static final int DECRYPT_MESSAGE = 0x21070001 ; private static final String EXTRA_DATA = \"data\" ; private static final String EXTRA_DECRYPTED_MESSAGE = \"decryptedMessage\" ; private String filename ; private String name ; private String checksum ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( isAvailable ( ) == false ) return ; Intent intent = getIntent ( ) ; this . filename = intent . getStringExtra ( \"filename\" ) ; this . name = intent . getStringExtra ( \"filenameAlias\" ) ; this . checksum = intent . getStringExtra ( \"checksum\" ) ; byte [ ] data = intent . getByteArrayExtra ( \"data\" ) ; if ( data == null ) return ; Intent APGintent = new Intent ( DECRYPT_AND_RETURN ) ; APGintent . setType ( \"text/plain\" ) ; APGintent . putExtra ( FileDecryptionActivity . EXTRA_DATA , data ) ; try { startActivityForResult ( APGintent , DECRYPT_MESSAGE ) ; } catch ( ActivityNotFoundException e ) { Log . e ( \"MobileOrg\" , \"Error: \" + e . getMessage ( ) + \" while launching APG intent\" ) ; } } @ Override public void onActivityResult ( int requestCode , int resultCode , Intent intent ) { switch ( requestCode ) { case FileDecryptionActivity . DECRYPT_MESSAGE : if ( resultCode != RESULT_OK || intent == null ) return ; String decryptedData = intent . getStringExtra ( FileDecryptionActivity . EXTRA_DECRYPTED_MESSAGE ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( decryptedData . getBytes ( ) ) ) ) ; OrgDatabase db =", "gt": "new OrgDatabase ( this ) ;", "prediction": ";\n", "label": 0}
{"id": 4268, "input": "<s> package com . datastruct ; import java . awt . geom . Point2D ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Random ; import java . util . Vector ; import processing . core . PApplet ; import processing . core . PFont ; import com . math . CompPoint ; import com . math . Geom ; public class DCFace extends DoublyConnectedEdgeList { public Vector < DCHalfEdge > innerComponents ; private CompPoint focus ; public int color ; public DCFace ( CompPoint focus ) { this . focus = focus ; color = new Random ( ) . nextInt ( ) * 0xFFFFFF ; } public void setFocus ( CompPoint point ) { this . focus = point ; } public CompPoint getFocus ( ) { return this . focus ; } public int compareTo ( DCFace f ) { return 0 ; } public void orderEdges ( ) { int missedEdges = 0 ; Vector < DCHalfEdge > newEdges = new Vector < DCHalfEdge > ( 0 ) ; Collections . sort ( edges ) ; for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { DCHalfEdge repEdge = new DCHalfEdge ( edges . get ( i ) . start , edges . get ( i ) . end ) ; this . edges . set ( i , repEdge ) ; } Vector < CompPoint > dupVerticies = new Vector < CompPoint > ( 0 ) ; for ( int i = 0 ; i < this . edges . size ( ) ; i ++ ) { dupVerticies . add ( this . edges . get ( i ) . start ) ; dupVerticies . add ( this . edges . get ( i ) . end ) ; } Vector < CompPoint > verticies = Geom . removeDuplicateVerts ( this ) ; if ( edges . size ( ) == 1 ) { } else if ( verticies . size ( ) - edges . size ( ) == 1 ) { findUnconnectedEdges ( dupVerticies , verticies ) ; } else if ( verticies . size ( ) - edges . size ( ) == 0 ) { sortEdges ( verticies ) ; } else if ( verticies . size ( ) - edges . size ( ) == 2 ) { } } public void findUnconnectedEdges ( Vector < CompPoint > dupVerticies , Vector < CompPoint > verticies ) { Vector < CompPoint > unconnectedVerticies = new Vector < CompPoint > ( 0 ) ; Vector < DCHalfEdge > unconnectedEdges = new Vector < DCHalfEdge > ( 0 ) ; for ( int i = 0 ; i < verticies . size ( ) ; i ++ ) { dupVerticies . remove ( verticies . get ( i ) ) ; if ( ! dupVerticies . remove ( verticies . get ( i ) ) ) { unconnectedVerticies . add ( verticies . get ( i ) ) ; } } for ( int i = 0 ; i < this . edges . size ( ) ; i ++ ) { DCHalfEdge currentEdge = edges . get ( i ) ; for ( int j = 0 ; j < unconnectedVerticies . size ( ) ; j ++ ) { CompPoint vert = unconnectedVerticies . get ( j ) ; if ( currentEdge . start . compareTo ( vert ) == 0 || currentEdge . end . compareTo ( vert ) == 0 ) { unconnectedEdges . add ( currentEdge ) ; } } } this . edges . add ( new DCHalfEdge ( unconnectedVerticies . get ( 0 ) , unconnectedVerticies . get ( 1 ) ) ) ; sortEdges ( verticies ) ; } private void sortEdges ( Vector < CompPoint > verticies ) { DCHalfEdge highestEdge1 = null ; DCHalfEdge highestEdge2 = null ; Collections . sort ( verticies , new CmpY ( ) ) ; for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { if ( edges . get ( i ) . start . compareTo ( verticies . get ( 0 ) ) == 0 || edges . get ( i ) . end . compareTo ( verticies . get ( 0 ) ) == 0 ) { if ( highestEdge1 == null ) { highestEdge1 = edges", "gt": ". get ( i ) ;", "prediction": ";\n", "label": 1}
{"id": 10127, "input": "<s> package org . ofbiz . base . container . groovy ; import groovy . lang . Binding ; import java . util . Map ; import org . apache . log4j . Logger ; public abstract class GroovyService { protected Logger log = Logger . getLogger ( getClass ( ) ) ; private Map < String , Object > bindings ; private boolean launchAtStart ; private Thread serverThread ; public GroovyService ( ) { } public GroovyService ( Map < String , Object > bindings ) { this . bindings = bindings ; } public void launchInBackground ( ) { serverThread = new Thread ( ) { @ Override public void run ( ) { try { launch ( ) ; } catch ( Exception e ) { log . error ( \"Could not launch the Groovy service.\" , e ) ; } } } ; serverThread . setDaemon ( true ) ; serverThread . start ( ) ; } public abstract void launch ( ) ; protected Binding createBinding ( ) { return new Binding ( bindings ) ; } public void initialize ( ) { if ( launchAtStart ) { launchInBackground ( ) ; } } public void destroy ( ) { } public void", "gt": "setBindings ( final Map < String , Object > bindings )", "prediction": "( )\n", "label": 0}
{"id": 4285, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ;", "gt": "public interface Anchor extends Identifiable , MarkUp , MarkupInCode", "prediction": "}\n", "label": 1}
{"id": 5277, "input": "<s> package objects ; import java . awt . Font ; import javax . swing . JLabel ; public class ArtistBreadcrumb extends JLabel { public ArtistBreadcrumb ( String text , int index ) { setText ( text ) ; setFont ( new Font ( \"Tahoma\" ,", "gt": "Font . PLAIN , 12 ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4290, "input": "<s> package org . eclipse . ui . internal . menus ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import org . eclipse . core . expressions . Expression ; import org . eclipse . jface . action . ContributionManager ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . ui . internal . expressions . AlwaysEnabledExpression ; import org . eclipse . ui . menus . AbstractContributionFactory ; import org . eclipse . ui . menus . IContributionRoot ; final class ContributionRoot implements IContributionRoot { private List topLevelItems = new ArrayList ( ) ; private List itemsToExpressions = new ArrayList ( ) ; private InternalMenuService menuService ; Set restriction ; private ContributionManager mgr ; private AbstractContributionFactory factory ; public ContributionRoot ( InternalMenuService menuService , Set restriction , ContributionManager mgr , AbstractContributionFactory factory ) { this . menuService = menuService ; this . restriction = restriction ; this . mgr = mgr ; this . factory = factory ; } public void addContributionItem ( IContributionItem item , Expression visibleWhen ) { if ( item == null ) throw new IllegalArgumentException ( ) ; topLevelItems . add ( item ) ; if ( visibleWhen == null ) visibleWhen = AlwaysEnabledExpression . INSTANCE ; menuService . registerVisibleWhen ( item , visibleWhen , restriction , createIdentifierId ( item ) ) ; itemsToExpressions . add ( item ) ; } private String createIdentifierId ( IContributionItem item ) { String namespace = factory . getNamespace ( ) ; String identifierID = namespace != null ? namespace + '/' + item . getId ( ) : null ; return identifierID ; } public List getItems ( ) { return topLevelItems ; } public void release ( ) { for ( Iterator itemIter = itemsToExpressions . iterator ( ) ; itemIter . hasNext ( ) ; ) { IContributionItem item = ( IContributionItem ) itemIter . next ( ) ; menuService . unregisterVisibleWhen ( item , restriction ) ; item . dispose ( ) ; } } public void registerVisibilityForChild ( IContributionItem item , Expression visibleWhen ) { if (", "gt": "item == null ) throw new IllegalArgumentException ( ) ;", "prediction": ")\n", "label": 1}
{"id": 2724, "input": "<s> public class ParseConditional { public static void main ( String [ ] args ) { boolean condition = true ; int a = 1 ; int b = 2 ; int c = 3 ; int d = 4 ; a = condition ? b =", "gt": "c : c = d ;", "prediction": ";\n", "label": 0}
{"id": 4294, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . IOException ; import java . sql . SQLException ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import com . cloudera . sqoop . lib . SqoopRecord ; import com . cloudera . sqoop . mapreduce . ExportOutputFormat ; public class OracleExportOutputFormat < K extends SqoopRecord , V > extends ExportOutputFormat < K , V > { @ Override public RecordWriter < K , V > getRecordWriter ( TaskAttemptContext context ) throws IOException { try { return new OracleExportRecordWriter ( context ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } public class OracleExportRecordWriter extends ExportRecordWriter { public OracleExportRecordWriter ( TaskAttemptContext context ) throws ClassNotFoundException , SQLException { super ( context ) ; } @ Override protected String getInsertStatement ( int numRows ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"INSERT INTO \" + getTableName ( ) + \" \" ) ; int numSlots ; String [ ] colNames = getColumnNames ( ) ; if ( colNames != null ) { numSlots = colNames . length ; sb . append ( \"(\" ) ; boolean first = true ; for ( String col : colNames ) { if ( ! first ) { sb . append ( \", \" ) ; } sb . append ( col ) ; first = false ; } sb . append ( \") \" ) ; } else { numSlots = getColumnCount ( ) ; } StringBuilder sbRow = new StringBuilder ( ) ; sbRow . append ( \"SELECT \" ) ; for ( int i = 0 ; i < numSlots ; i ++ ) { if ( i != 0 ) { sbRow . append ( \", \" ) ; } sbRow . append ( \"?\" ) ; } sbRow . append ( \" FROM DUAL \" ) ; for ( int i = 0 ; i < numRows ; i ++ ) { if ( i != 0 ) { sb . append ( \"UNION ALL \" ) ; }", "gt": "sb . append ( sbRow ) ;", "prediction": "}\n", "label": 1}
{"id": 8595, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . RoundEnvironment ; import javax . annotation . processing . SupportedOptions ; import javax . lang . model . element . TypeElement ; import javax . tools . Diagnostic ; import com . sun . tools . javac . processing . JavacProcessingEnvironment ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . JavacMessages ; public class T6597678 extends JavacTestingAbstractProcessor { public static void main ( String ... args ) throws Exception { new T6597678 ( ) . run ( ) ; } void run ( ) throws Exception { String myName = T6597678 . class . getSimpleName ( ) ; File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; File file = new File ( testSrc , myName + \".java\" ) ; compile ( \"-proc:only\" , \"-processor\" , myName , file . getPath ( ) ) ; } void compile ( String ... args ) throws Exception { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javac . Main . compile ( args , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; if ( ! out . isEmpty ( ) ) System . err . println ( out ) ; if ( rc != 0 ) throw new Exception ( \"compilation failed unexpectedly: rc=\" + rc ) ; } @ Override public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { Context context = ( ( JavacProcessingEnvironment ) processingEnv ) . getContext ( ) ; Locale locale = context . get ( Locale . class ) ; JavacMessages messages = context . get ( JavacMessages . messagesKey ) ; round ++ ; if ( round == 1 ) { initialLocale = locale ; initialMessages = messages ; } else { checkEqual ( \"locale\" , locale , initialLocale ) ; checkEqual ( \"messages\" , messages , initialMessages ) ; } return true ; } < T > void checkEqual ( String label ,", "gt": "T actual , T expected )", "prediction": ")\n", "label": 0}
{"id": 4314, "input": "<s> package org . eclipse . ui . forms ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . forms . widgets . FormToolkit ; import org . eclipse . ui . forms . widgets . ScrolledForm ; public interface IManagedForm { public void initialize ( ) ; public FormToolkit getToolkit ( ) ; public ScrolledForm getForm ( ) ; public void reflow ( boolean changed ) ; public void fireSelectionChanged ( IFormPart part , ISelection selection ) ; IFormPart [ ] getParts ( ) ; void addPart ( IFormPart part ) ; void removePart ( IFormPart part ) ; boolean setInput ( Object input ) ; Object getInput ( ) ; boolean isDirty ( ) ;", "gt": "void dirtyStateChanged ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8525, "input": "<s> package org . xbill . DNS ; abstract class SingleCompressedNameBase extends SingleNameBase { private static final long serialVersionUID = - 236435396815460677L ; protected SingleCompressedNameBase ( ) { } protected SingleCompressedNameBase ( Name name , int type , int dclass , long ttl , Name singleName , String description ) { super ( name , type , dclass , ttl , singleName , description ) ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) { singleName .", "gt": "toWire ( out , c , canonical ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4318, "input": "<s> package org . restlet . representation ; import java . io . IOException ; import org . restlet . data . CharacterSet ; import org . restlet . data . Language ; import org . restlet . data . MediaType ; public class AppendableRepresentation extends StringRepresentation implements Appendable { private volatile StringBuilder appendableText ; public AppendableRepresentation ( ) { this ( null ) ; } public AppendableRepresentation ( CharSequence text ) { super ( text ) ; } public AppendableRepresentation ( CharSequence text , Language language ) { super ( text , language ) ; } public AppendableRepresentation ( CharSequence text , MediaType mediaType ) { super ( text , mediaType ) ; } public AppendableRepresentation ( CharSequence text , MediaType mediaType , Language language ) { super ( text , mediaType , language ) ; } public AppendableRepresentation ( CharSequence text , MediaType mediaType , Language language , CharacterSet characterSet ) { super ( text , mediaType , language , characterSet ) ; } public Appendable append ( char c ) throws IOException { if ( this . appendableText == null ) { this . appendableText = new StringBuilder ( c ) ; } else { this . appendableText . append ( c ) ; } return this ; } public Appendable append ( CharSequence csq ) throws IOException { if ( this . appendableText == null ) { this . appendableText = new StringBuilder ( csq ) ; } else { this . appendableText . append ( csq ) ; } return this ; } public Appendable append ( CharSequence csq , int start , int end ) throws IOException { if ( this . appendableText == null ) { this . appendableText = new StringBuilder ( ) ; } this . appendableText . append ( csq , start , end ) ; return this ; } @ Override public String getText ( ) { return ( this . appendableText == null ) ? null : this . appendableText . toString ( ) ; } @ Override public void setText ( CharSequence text ) { if ( text != null ) { if ( this . appendableText == null ) { this . appendableText = new StringBuilder ( text ) ; } else { this . appendableText . delete ( 0 , this . appendableText . length ( ) ) ; this . appendableText . append ( text ) ; } } else {", "gt": "this . appendableText = null ;", "prediction": "}\n", "label": 1}
{"id": 5800, "input": "<s> package com . extjs . gxt . ui . client . widget ; import java . util . Date ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . Style . Direction ; import com . extjs . gxt . ui . client . aria . FocusFrame ; import com . extjs . gxt . ui . client . core . CompositeElement ; import com . extjs . gxt . ui . client . core . CompositeFunction ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . core . XDOM ; import com . extjs . gxt . ui . client . event . ButtonEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . DatePickerEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FxEvent ; import com . extjs . gxt . ui . client . event . IconButtonEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . SelectionListener ; import com . extjs . gxt . ui . client . fx . FxConfig ; import com . extjs . gxt . ui . client . messages . XConstants ; import com . extjs . gxt . ui . client . util . DateWrapper ; import com . extjs . gxt . ui . client . util . KeyNav ; import com . extjs . gxt . ui . client . util . Size ; import com . extjs . gxt . ui . client . util . Util ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . button . IconButton ; import com . google . gwt . dom . client . Document ; import com . google . gwt . dom . client . NodeList ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . i18n . client . DateTimeFormat ; import com . google . gwt . i18n . client . LocaleInfo ; import com . google . gwt . i18n . client . constants . DateTimeConstants ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; import com . google . gwt . user . client . ui . Grid ; import com . google . gwt . user . client . ui . HasHorizontalAlignment ; @ SuppressWarnings ( \"deprecation\" ) public class DatePicker extends BoxComponent { public static final int CHINESE_YEAR = 1911 ; public static final int YEAR = 0 ; private int dateType = YEAR ; public int getDateType ( ) { return dateType ; } public void setDateType ( int dateType ) { this . dateType = dateType ; } public class DatePickerMessages { private String cancelText = GXT . MESSAGES . datePicker_cancelText ( ) ; private String maxText = GXT . MESSAGES . datePicker_maxText ( ) ; private String minText = GXT . MESSAGES . datePicker_minText ( ) ; private String monthYearText = GXT . MESSAGES . datePicker_monthYearText ( ) ; private String nextText = GXT . MESSAGES . datePicker_nextText ( ) ; private String okText = GXT . MESSAGES . datePicker_okText ( ) ; private String prevText = GXT . MESSAGES . datePicker_prevText ( ) ; private String todayText = GXT . MESSAGES . datePicker_todayText ( ) ; private String todayTip = GXT . MESSAGES . datePicker_todayTip ( DateTimeFormat . getShortDateFormat ( ) . format ( new Date ( ) ) ) ; public String getCancelText ( ) { return cancelText ; } public String getMaxText ( ) { return maxText ; } public String getMinText ( ) { return minText ; } public String getMonthYearText ( ) { return monthYearText ; } public String getNextText ( ) { return nextText ; } public String getOkText ( ) { return okText ; } public String getPrevText ( ) { return prevText ; } public String getTodayText ( ) { return todayText ; } public String getTodayTip ( ) { return todayTip ; } public void setCancelText ( String cancelText ) { this . cancelText = cancelText ; } public void setMaxText ( String maxText ) { this . maxText = maxText ; } public void setMinText ( String minText ) { this . minText = minText ; } public void setMonthYearText ( String monthYearText ) { this . monthYearText = monthYearText ; } public void setNextText ( String nextText ) { this . nextText = nextText ; } public void", "gt": "setOkText ( String okText )", "prediction": "( )\n", "label": 0}
{"id": 4319, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . jface . databinding . swt . WidgetValueProperty ; public abstract class WidgetIntValueProperty extends WidgetValueProperty { WidgetIntValueProperty ( ) { super ( ) ; } WidgetIntValueProperty ( int event ) { super ( event ) ; } WidgetIntValueProperty ( int [ ] events ) { super ( events ) ; } public Object getValueType ( ) { return Integer . TYPE ; } protected Object doGetValue ( Object source ) { return new Integer ( doGetIntValue ( source ) ) ; } protected void doSetValue ( Object source , Object value ) { doSetIntValue ( source , ( ( Integer ) value ) . intValue ( ) ) ; } abstract int doGetIntValue", "gt": "( Object source ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9053, "input": "<s> package com . dyned . woremotesiteconfig ; import java . util . regex . * ; import java . net . * ; import java . io . * ; import org . apache . log4j . Logger ; public class WebPageFromURL { private static Logger log = Logger . getLogger ( WebPageFromURL . class ) ; public String urlString ; public String content ; public String contentWithoutHTML ; public Long date ; public Long expirationDate ; public Long modificationDate ; public Integer responseCode ; public WebPageFromURL ( String theURLToGet , String method , String postData ) { super ( ) ; log . debug ( \"= = = = = = = = = = = = = = = = = = FINAL URL Call: \" + theURLToGet ) ; URL webPage = null ; HttpURLConnection urlConnection = null ; StringBuffer postDataContent = null ; InputStream pageContentStream = null ; BufferedReader pageReader = null ; StringBuffer pageContent = new StringBuffer ( ) ; if ( method == null ) method = \"GET\" ; if ( ( theURLToGet == null ) || ( theURLToGet == \"\" ) ) { log . error ( \" - theURLToGet is null.\" ) ; return ; } try { webPage = new URL ( theURLToGet ) ; urlConnection = ( HttpURLConnection ) webPage . openConnection ( ) ; urlConnection . setReadTimeout ( 15 * 1000 ) ; urlConnection . setDoOutput ( true ) ; urlConnection . setRequestMethod ( method ) ; if ( method . equalsIgnoreCase ( \"POST\" ) ) { postDataContent = new StringBuffer ( postData ) ; urlConnection . setRequestProperty ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) ; urlConnection . setRequestProperty ( \"Content-Length\" , \"\" + postDataContent . length ( ) ) ; DataOutputStream stream = new DataOutputStream ( urlConnection . getOutputStream ( ) ) ; stream . writeBytes ( postDataContent . toString ( ) ) ; stream . close ( ) ; } pageContentStream = urlConnection . getInputStream ( ) ; responseCode = new Integer ( urlConnection . getResponseCode ( ) ) ; pageReader = new BufferedReader ( new InputStreamReader ( pageContentStream ) ) ; String pageLine = pageReader . readLine ( ) ; while ( pageLine != null ) { pageContent . append ( pageLine ) ; pageContent . append ( \"\\n\" ) ; pageLine = pageReader . readLine ( ) ; } pageContentStream . close ( ) ; urlString = theURLToGet ; content = pageContent . toString ( ) ; contentWithoutHTML = cleanUpPunktuation ( removeHTMLTags ( pageContent . toString ( ) ) ) ; date = new Long ( urlConnection . getDate ( ) ) ; expirationDate = new Long ( urlConnection . getExpiration ( ) ) ; modificationDate = new Long ( urlConnection . getLastModified ( ) ) ; } catch ( FileNotFoundException ex ) { log . error ( \" - Page not found: \" + ex . getMessage ( ) ) ; log . error ( \"   URL: \" + theURLToGet ) ; content = \"OK\" ; return ; }", "gt": "catch ( MalformedURLException ex )", "prediction": "}\n", "label": 0}
{"id": 4324, "input": "<s> package com . cloudera . sqoop . mapreduce . db ; import java . sql . Connection ; import java . sql . SQLException ; import org . apache . hadoop . conf . Configuration ; import org . apache . sqoop . mapreduce . DBWritable ; public class OracleDataDrivenDBRecordReader < T extends DBWritable > extends org . apache . sqoop . mapreduce . db . OracleDataDrivenDBRecordReader < T > { public OracleDataDrivenDBRecordReader ( DBInputFormat . DBInputSplit split , Class < T > inputClass , Configuration conf , Connection conn , DBConfiguration dbConfig , String cond , String [ ] fields ,", "gt": "String table ) throws SQLException", "prediction": ") ;\n", "label": 1}
{"id": 750, "input": "<s> package com . sap . prd . mobile . ios . mios ; abstract class XCodeConstants { private XCodeConstants ( ) { throw new UnsupportedOperationException ( \"To prevent getting instances\" ) ; }", "gt": "final static String XCODE_PROJECT_EXTENTION = \".xcodeproj\" ;", "prediction": "}\n", "label": 0}
{"id": 4333, "input": "<s> package outputWriters ; public abstract class OutputInfoWriter extends OutputWriter { protected abstract void outputFileInfo ( ) ; protected abstract void outputGlobalAttributes ( ) ; protected", "gt": "abstract void outputDimensions ( ) ;", "prediction": "\n", "label": 1}
{"id": 5928, "input": "<s> package org . kares . jruby ; import java . io . IOException ; import java . io . InputStream ; import javax . servlet . ServletContext ; public abstract class ServletWorkerManager extends WorkerManager { private final ServletContext context ; public ServletWorkerManager ( ServletContext context ) { if ( context == null ) { throw new IllegalArgumentException ( \"null context\" ) ; } this . context = context ; setThreadPrefix ( context . getServletContextName ( ) ) ; } public ServletContext getServletContext ( ) { return context ; } @ Override public String getParameter ( String key ) { String val = context . getInitParameter ( key ) ; if ( val == null ) { val = super .", "gt": "getParameter ( key ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4336, "input": "<s> package org . apache . lucene . store . instantiated ; import org . apache . lucene . index . TermVectorOffsetInfo ; import java . io . Serializable ; import java . util . Comparator ; public class InstantiatedTermDocumentInformation implements Serializable { private static final long serialVersionUID = 1l ; public static final Comparator < InstantiatedTermDocumentInformation > termComparator = new Comparator < InstantiatedTermDocumentInformation > ( ) { public int compare ( InstantiatedTermDocumentInformation instantiatedTermDocumentInformation , InstantiatedTermDocumentInformation instantiatedTermDocumentInformation1 ) { return instantiatedTermDocumentInformation . getTerm ( ) . getTerm ( ) . compareTo ( instantiatedTermDocumentInformation1 . getTerm ( ) ) ; } } ; public static final Comparator < InstantiatedTermDocumentInformation > documentNumberComparator = new Comparator < InstantiatedTermDocumentInformation > ( ) { public int compare ( InstantiatedTermDocumentInformation instantiatedTermDocumentInformation , InstantiatedTermDocumentInformation instantiatedTermDocumentInformation1 ) { return instantiatedTermDocumentInformation . getDocument ( ) . getDocumentNumber ( ) . compareTo ( instantiatedTermDocumentInformation1 . getDocument ( ) . getDocumentNumber ( ) ) ; } } ; public static final Comparator doumentNumberIntegerComparator = new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { InstantiatedTermDocumentInformation di = ( InstantiatedTermDocumentInformation ) o1 ; Integer i = ( Integer ) o2 ; return di . getDocument ( ) . getDocumentNumber ( ) . compareTo ( i ) ; } } ; private byte [ ] [ ] payloads ; private int [ ] termPositions ; private InstantiatedTerm term ; private InstantiatedDocument document ; private TermVectorOffsetInfo [ ] termOffsets ; public InstantiatedTermDocumentInformation ( InstantiatedTerm term , InstantiatedDocument document , int [ ] termPositions , byte [ ] [ ] payloads ) { this . term = term ; this . document = document ; this . termPositions = termPositions ; this . payloads = payloads ; } public int [ ] getTermPositions ( ) { return termPositions ; } public byte [ ] [ ] getPayloads ( ) { return payloads ; } public InstantiatedDocument getDocument ( ) { return document ; } public InstantiatedTerm getTerm ( ) { return term ; } void setTermPositions (", "gt": "int [ ] termPositions )", "prediction": ")\n", "label": 1}
{"id": 5254, "input": "<s> public class T6569404a { static class Outer { public class Inner { } } static class Test < T extends Outer > { public Test ( T t ) { Outer . Inner inner = t . new Inner ( ) ; } } public static void main ( String [ ] args ) { new Test < Outer > ( new", "gt": "Outer ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4348, "input": "<s> package org . eclipse . ui . internal ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Date ; import java . util . Locale ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . Platform ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . about . ISystemSummarySection ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import com . ibm . icu . text . Collator ; import com . ibm . icu . text . DateFormat ; public final class ConfigurationInfo { public static String getBuildId ( ) { return System . getProperty ( \"eclipse.buildId\" , null ) ; } public static String getSystemSummary ( ) { StringWriter out = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( out ) ; writer . println ( NLS . bind ( WorkbenchMessages . get ( ) . SystemSummary_timeStamp , DateFormat . getDateTimeInstance ( DateFormat . FULL , DateFormat . FULL ) . format ( new Date ( ) ) ) ) ; ConfigurationInfo . appendExtensions ( writer ) ; writer . close ( ) ; return out . toString ( ) ; } private static void appendExtensions ( PrintWriter writer ) { IConfigurationElement [ ] configElements = getSortedExtensions ( Platform . getExtensionRegistry ( ) . getConfigurationElementsFor ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_SYSTEM_SUMMARY_SECTIONS ) ) ; for ( int i = 0 ; i < configElements . length ; ++ i ) { IConfigurationElement element = configElements [ i ] ; Object obj = null ; try { obj = WorkbenchPlugin . createExtension ( element , IWorkbenchConstants . TAG_CLASS ) ; } catch ( CoreException e ) { WorkbenchPlugin . log ( \"could not create class attribute for extension\" , e . getStatus ( ) ) ; } writer . println ( ) ; writer . println ( NLS . bind ( WorkbenchMessages . get ( ) . SystemSummary_sectionTitle , element . getAttribute ( \"sectionTitle\" ) ) ) ; if ( obj instanceof ISystemSummarySection ) { ISystemSummarySection logSection = ( ISystemSummarySection ) obj ; logSection . write ( writer ) ; } else { writer . println ( WorkbenchMessages . get ( ) . SystemSummary_sectionError ) ; } } } public static IConfigurationElement [ ] getSortedExtensions ( IConfigurationElement [ ] configElements ) { Arrays . sort ( configElements , new Comparator ( ) { Collator collator = Collator . getInstance ( Locale . getDefault ( ) ) ; public int compare ( Object a , Object b ) { IConfigurationElement element1 = ( IConfigurationElement ) a ; IConfigurationElement element2 = ( IConfigurationElement ) b ; String id1 = element1 . getAttribute ( \"id\" ) ; String id2 = element2 . getAttribute ( \"id\" ) ; if ( id1 != null && id2 != null && ! id1 . equals ( id2 ) ) { return collator . compare ( id1 , id2 ) ; } String title1 = element1 . getAttribute ( \"sectionTitle\" ) ; String title2 = element2 . getAttribute ( \"sectionTitle\" ) ; if ( title1 == null ) { title1 = \"\" ; } if ( title2 == null ) { title2 = \"\" ; } return collator .", "gt": "compare ( title1 , title2 ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1428, "input": "<s> class CountError { void m ( ) {", "gt": "throw new Exception ( ) ;", "prediction": "}\n", "label": 0}
{"id": 4358, "input": "<s> package org . eclipse . ui . themes ; import java . util . Hashtable ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . swt . graphics . RGB ; public class RGBBlendColorFactory implements IColorFactory , IExecutableExtension { private String color1 , color2 ; public RGB createColor ( ) { if ( color1 == null && color2 == null ) { return new RGB ( 0 , 0 , 0 ) ; } else if ( color1 != null && color2 == null ) { return ColorUtil . getColorValue ( color1 ) ; } else if ( color1 == null && color2 != null ) { return ColorUtil . getColorValue ( color2 ) ; } else { RGB rgb1 = ColorUtil . getColorValue ( color1 ) ; RGB rgb2 = ColorUtil . getColorValue ( color2 ) ; return ColorUtil . blend ( rgb1 , rgb2 ) ; } } public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) throws CoreException { if ( data instanceof Hashtable ) { Hashtable table", "gt": "= ( Hashtable ) data ;", "prediction": ";\n", "label": 1}
{"id": 4151, "input": "<s> package com . farpost . ldt ; import org . testng . annotations . BeforeMethod ; import org . testng . annotations . Test ; import java . lang . reflect . InvocationTargetException ; import static com . farpost . ldt . TestUtils . near ; import static org . easymock . EasyMock . * ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . equalTo ; public class TestRunnerTest { private TestRunner runner ; @ BeforeMethod public void setUp ( ) throws Exception { runner = new TestRunner ( ) ; } @ Test public void testRunnerCanCalculateTotalTime ( ) throws InterruptedException , InvocationTargetException , NoSuchMethodException , InstantiationException , IllegalAccessException { Task task = new PojoTask < SleepTask > ( new SleepTask ( 15 ) , \"execute\" ) ; TestResult result = runner . run ( task ) ; assertThat ( result . getConcurrencyLevel ( ) , equalTo ( 1 ) ) ; assertThat ( result . getTotalTime ( ) , near ( 15000L , 1000 ) ) ; } @ Test public void testRunnerCanRunTasksSeveralTimes ( ) throws InterruptedException , NoSuchMethodException { int samples = 5 ; long delay = 19 ; int concurrencyLevel = 3 ; runner . setThreadSamplesCount ( samples ) ; runner . setConcurrencyLevel ( concurrencyLevel ) ; Task task = new PojoTask < SleepTask > ( new SleepTask ( delay ) ) ; TestResult result = runner . run ( task ) ; assertThat ( result . getConcurrencyLevel ( ) , equalTo ( concurrencyLevel ) ) ; assertThat ( result . getSamplesCount ( ) , equalTo ( samples * concurrencyLevel ) ) ; assertThat ( result . getTotalTime ( ) , near ( samples * delay * 1000 , 10 * 1000 ) ) ; } @", "gt": "Test public void testRunnerCanMeasureThroughput ( ) throws InterruptedException , NoSuchMethodException", "prediction": "}\n", "label": 0}
{"id": 4360, "input": "<s> package br . org . archimedes . controller ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . model . Drawing ; public abstract class InputState { public abstract String receiveText ( String text ) ; public abstract InputState getNext ( ) ; public String gotSelection ( ) { return null ; } public abstract boolean nextShouldHandle ( ) ; public abstract InputState changedDrawing ( Drawing currentDrawing ) ; public abstract", "gt": "String cancel ( ) ;", "prediction": "\n", "label": 1}
{"id": 7235, "input": "<s> package ar . com . fdvs . dj . domain ; public interface DJCRosstabMeasurePrecalculatedTotalProvider { public Object getValueFor ( String [ ] colProp , Object colValue [ ] ,", "gt": "String rowProp [ ] , Object rowValue [ ] ) ;", "prediction": ")\n", "label": 0}
{"id": 4367, "input": "<s> package com . emf4sw . rdf ; import org . eclipse . emf . common . util . EList ; public interface RDFSeq extends RDFSContainer { EList", "gt": "< Node > getElements ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7694, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . util . ExpressionUtils ; import net . sf . jasperreports . charts . design . JRDesignAreaPlot ; import net . sf . jasperreports . engine . JRChartPlot ; import net . sf . jasperreports . engine . design . JRDesignExpression ; public class AreaPlot extends AbstractCategoryAxisPlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public void transform ( DynamicJasperDesign design , JRChartPlot plot , String name ) { super . transform ( design , plot , name ) ; JRDesignAreaPlot areaPlot = ( JRDesignAreaPlot ) plot ; StringExpression categoryAxisLabelExp = getCategoryAxisFormat ( ) . getLabelExpression ( ) ; if ( categoryAxisLabelExp != null ) { JRDesignExpression exp = ExpressionUtils . createAndRegisterExpression ( design , \"categoryAxisLabel_\" + name , categoryAxisLabelExp ) ; areaPlot . setCategoryAxisLabelExpression ( exp ) ; } if ( getCategoryAxisFormat ( ) . getTickLabelMask ( ) != null ) areaPlot . setCategoryAxisTickLabelMask ( getCategoryAxisFormat ( ) . getTickLabelMask ( ) ) ; if ( getCategoryAxisFormat ( ) . getLabelColor ( ) != null ) areaPlot . setCategoryAxisLabelColor ( getCategoryAxisFormat ( ) . getLabelColor ( ) ) ; if ( getCategoryAxisFormat ( ) . getLabelFont ( ) != null ) areaPlot . setCategoryAxisLabelFont ( getCategoryAxisFormat ( ) . getLabelFont ( ) . transform ( ) ) ; if ( getCategoryAxisFormat ( ) . getLineColor ( ) != null ) areaPlot . setCategoryAxisLineColor ( getCategoryAxisFormat ( ) . getLineColor ( ) ) ; if ( getCategoryAxisFormat ( ) . getTickLabelColor ( ) != null ) areaPlot . setCategoryAxisTickLabelColor ( getCategoryAxisFormat ( ) . getTickLabelColor ( ) ) ; if ( getCategoryAxisFormat ( ) . getTickLabelFont ( ) != null ) areaPlot . setCategoryAxisTickLabelFont ( getCategoryAxisFormat ( ) . getTickLabelFont ( ) . transform ( ) ) ; CustomExpression categoryAxisRangeMinValueExp = getCategoryAxisFormat ( ) . getRangeMinValueExpression ( ) ; if ( categoryAxisRangeMinValueExp != null ) { JRDesignExpression exp = ExpressionUtils . createAndRegisterExpression ( design , \"categoryAxisRangeMinValue_\" + name , categoryAxisRangeMinValueExp ) ; areaPlot .", "gt": "setDomainAxisMinValueExpression ( exp ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4391, "input": "<s> package br . org . archimedes . gui . rca ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.i18n.menu\" ; static { NLS . initializeMessages ( BUNDLE_NAME ,", "gt": "Messages . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7858, "input": "<s> package org . ofbiz . minilang . method . eventops ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class FieldToSession extends MethodOperation { private final FlexibleMapAccessor < Object > fieldFma ; private final FlexibleStringExpander attributeNameFse ; public FieldToSession ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" , \"session-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; String attributeName = element . getAttribute ( \"session-name\" ) ; if ( ! attributeName . isEmpty ( ) ) { this . attributeNameFse = FlexibleStringExpander . getInstance ( attributeName ) ; } else { this . attributeNameFse = FlexibleStringExpander . getInstance ( this . fieldFma . toString ( ) ) ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { if ( methodContext . getMethodType ( ) == MethodContext . EVENT ) { Object fieldVal = fieldFma . get ( methodContext . getEnvMap ( ) ) ; if ( fieldVal != null ) { String attributeName = attributeNameFse . expandString ( methodContext . getEnvMap ( ) ) ; if (", "gt": "! attributeName . isEmpty ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 4398, "input": "<s> package org . apache . lucene . util ; import java . nio . CharBuffer ; import java . nio . ByteBuffer ; public class IndexableBinaryStringTools { private static final CodingCase [ ] CODING_CASES = { new CodingCase ( 7 , 1 ) , new CodingCase ( 14 , 6 , 2 ) , new CodingCase ( 13 , 5 , 3 ) , new CodingCase ( 12 , 4 , 4 ) , new CodingCase ( 11 , 3 , 5 ) , new CodingCase ( 10 , 2 , 6 ) , new CodingCase ( 9 , 1 , 7 ) , new CodingCase ( 8 , 0 ) } ; private IndexableBinaryStringTools ( ) { } public static int getEncodedLength ( ByteBuffer original ) throws IllegalArgumentException { if ( original . hasArray ( ) ) { long length = ( long ) ( original . limit ( ) - original . arrayOffset ( ) ) ; return ( int ) ( ( length * 8L + 14L ) / 15L ) + 1 ; } else { throw new IllegalArgumentException ( \"original argument must have a backing array\" ) ; } } public static int getDecodedLength ( CharBuffer encoded ) throws IllegalArgumentException { if ( encoded . hasArray ( ) ) { int numChars = encoded . limit ( ) - encoded . arrayOffset ( ) - 1 ; if ( numChars <= 0 ) { return 0 ; } else { int numFullBytesInFinalChar = encoded . charAt ( encoded . limit ( ) - 1 ) ; int numEncodedChars = numChars - 1 ; return ( numEncodedChars * 15 + 7 ) / 8 + numFullBytesInFinalChar ; } } else { throw new IllegalArgumentException ( \"encoded argument must have a backing array\" ) ; } } public static void encode ( ByteBuffer input , CharBuffer output ) { if ( input . hasArray ( ) && output . hasArray ( ) ) { byte [ ] inputArray = input . array ( ) ; int inputOffset = input . arrayOffset ( ) ; int inputLength = input . limit ( ) - inputOffset ; char [ ] outputArray = output . array ( ) ; int outputOffset = output . arrayOffset ( ) ; int outputLength = getEncodedLength ( input ) ; output . limit ( outputOffset + outputLength ) ; output . position ( 0 ) ; if ( inputLength > 0 ) { int inputByteNum = inputOffset ; int caseNum = 0 ; int outputCharNum = outputOffset ; CodingCase codingCase ; for ( ; inputByteNum + CODING_CASES [ caseNum ] . numBytes <= inputLength ; ++ outputCharNum ) { codingCase = CODING_CASES [ caseNum ] ; if ( 2 == codingCase . numBytes ) { outputArray [ outputCharNum ] = ( char ) ( ( ( inputArray [ inputByteNum ] & 0xFF ) << codingCase . initialShift ) + ( ( ( inputArray [ inputByteNum + 1 ] & 0xFF ) > > > codingCase . finalShift ) & codingCase . finalMask ) & ( short ) 0x7FFF ) ; } else { outputArray [ outputCharNum ] = ( char ) ( ( ( inputArray [ inputByteNum ] & 0xFF ) << codingCase . initialShift ) + ( ( inputArray [ inputByteNum + 1 ] & 0xFF ) << codingCase . middleShift ) + ( ( ( inputArray [ inputByteNum + 2 ] & 0xFF ) > > > codingCase . finalShift ) & codingCase . finalMask ) & ( short ) 0x7FFF ) ; } inputByteNum += codingCase . advanceBytes ; if ( ++ caseNum == CODING_CASES . length ) { caseNum = 0 ; } } codingCase = CODING_CASES [ caseNum ] ; if ( inputByteNum + 1 < inputLength ) { outputArray [ outputCharNum ++ ] = ( char ) ( ( ( ( inputArray [ inputByteNum ] & 0xFF ) << codingCase . initialShift ) + ( ( inputArray [ inputByteNum + 1 ] & 0xFF ) << codingCase . middleShift ) ) & ( short ) 0x7FFF ) ; outputArray [ outputCharNum ++ ] = ( char ) 1 ; } else if ( inputByteNum < inputLength ) { outputArray [ outputCharNum ++ ] = ( char ) ( ( ( inputArray [ inputByteNum ] & 0xFF ) << codingCase . initialShift ) & ( short ) 0x7FFF ) ; outputArray [ outputCharNum ++ ] = caseNum == 0 ? ( char ) 1 : ( char ) 0 ; } else { outputArray [ outputCharNum ++ ] = ( char ) 1 ; } } } else { throw new IllegalArgumentException ( \"Arguments must have backing arrays\" ) ; } } public static void decode (", "gt": "CharBuffer input , ByteBuffer output )", "prediction": ")\n", "label": 1}
{"id": 3250, "input": "<s> package com . midtro . platform . modules . transition ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Composite ; import com . midtro . platform . AppGraphics ; import com . midtro . platform . Application ; public class FadeInTransition implements Transition { private final Color color ; private final float speed ; private float value = 1.0f ; public FadeInTransition ( Color color , float speed ) { this . color = color ; this . speed = speed / 100 ; } @ Override public void draw ( AppGraphics graphics , Application app ) { final Composite composite = graphics . getComposite ( ) ; graphics . setColor ( color ) ; graphics . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , value ) ) ; graphics . fillRect ( 0 , 0 , app . getSettings ( ) . getWidth ( ) , app . getSettings ( ) . getHeight ( ) ) ; graphics . setComposite ( composite ) ; } @ Override public boolean isComplete ( ) { return value == 0.0f ; } @ Override public", "gt": "void update ( float delta )", "prediction": "\n", "label": 0}
{"id": 4403, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"displayName\" , \"parentType\" , \"fields\" , \"contentTypeProperties\" , \"addToView\" } ) @ XmlRootElement ( name = \"CreateContentType\" ) public class CreateContentType { protected String listName ; protected String displayName ; protected String parentType ; protected CreateContentType . Fields fields ; protected CreateContentType . ContentTypeProperties contentTypeProperties ; protected String addToView ; public String getListName ( ) { return listName ; } public void setListName ( String value ) { this . listName = value ; } public String getDisplayName ( ) { return displayName ; } public void setDisplayName ( String value ) { this . displayName = value ; } public String getParentType ( ) { return parentType ; } public void setParentType ( String value ) { this . parentType = value ; } public CreateContentType . Fields getFields ( ) { return fields ; } public void setFields ( CreateContentType . Fields value ) { this . fields = value ; } public CreateContentType . ContentTypeProperties getContentTypeProperties ( ) { return contentTypeProperties ; } public void setContentTypeProperties (", "gt": "CreateContentType . ContentTypeProperties value )", "prediction": ")\n", "label": 1}
{"id": 6132, "input": "<s> package org . ofbiz . minilang . operation ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Element ; public class MakeInString { public static final String module = MakeInString . class . getName ( ) ; String fieldName ; List < MakeInStringOperation > operations = FastList . newInstance ( ) ; public MakeInString ( Element makeInStringElement ) { fieldName = makeInStringElement . getAttribute ( \"field\" ) ; List < ? extends Element > operationElements = UtilXml . childElementList ( makeInStringElement ) ; if ( UtilValidate . isNotEmpty ( operationElements ) ) { for ( Element curOperElem : operationElements ) { String nodeName = curOperElem . getNodeName ( ) ; if ( \"in-field\" . equals ( nodeName ) ) { operations . add ( new InFieldOper ( curOperElem ) ) ; } else if", "gt": "( \"property\" . equals ( nodeName ) )", "prediction": "( )\n", "label": 0}
{"id": 4410, "input": "<s> package org . restlet . engine . connector ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . channels . SocketChannel ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . Connector ; public abstract class ConnectionHelper < T extends Connector > extends BaseHelper < T > { private volatile ConnectionPool < T > connectionPool ; private final List < Connection < T > > connections ; public ConnectionHelper ( T connector , boolean clientSide ) { super ( connector , clientSide ) ; this . connections = new CopyOnWriteArrayList < Connection < T > > ( ) ; this . connectionPool = null ; } @ SuppressWarnings ( \"unchecked\" ) protected void checkin ( Connection < ? > connection ) { connection . clear ( ) ; if ( isPooledConnection ( ) ) { getConnectionPool ( ) . checkin ( ( Connection < T > ) connection ) ; } } protected Connection < T > checkout ( SocketChannel socketChannel , ConnectionController controller , InetSocketAddress socketAddress ) throws IOException { Connection < T > result = null ; if ( isPooledConnection ( ) ) { result = getConnectionPool ( ) . checkout ( ) ; result . reuse ( socketChannel , controller , socketAddress ) ; } else { result = createConnection ( socketChannel , controller , socketAddress ) ; } return result ; } protected abstract Connection < T > createConnection ( SocketChannel socketChannel , ConnectionController controller , InetSocketAddress socketAddress ) throws IOException ; public void createConnectionPool ( ) { if ( isPooledConnection ( ) ) { this . connectionPool = new ConnectionPool < T > ( this , getInitialConnections ( ) ) ; } } public abstract InboundWay createInboundWay ( Connection < T > connection , int bufferSize ) ; public abstract OutboundWay createOutboundWay ( Connection < T > connection , int bufferSize ) ; @ Override protected void doFinishStop ( ) { super . doFinishStop ( ) ; if ( isPooledConnection ( ) ) { this . connectionPool = null ; } } @ Override protected void doGracefulStop ( ) { super . doGracefulStop ( ) ; for ( Connection < T > connection : getConnections ( ) ) { connection . close ( true ) ; } } public ConnectionPool < T > getConnectionPool ( ) { return connectionPool ; } public List < Connection < T > > getConnections ( ) { return connections ; } public int getInitialConnections ( ) { return Integer . parseInt ( getHelpedParameters ( ) . getFirstValue ( \"initialConnections\" , \"100\" ) ) ; } public int getMaxConnectionsPerHost ( ) { return Integer . parseInt ( getHelpedParameters ( ) . getFirstValue ( \"maxConnectionsPerHost\" , \"-1\" ) ) ; } public int getMaxTotalConnections ( ) { return Integer . parseInt ( getHelpedParameters ( ) . getFirstValue ( \"maxTotalConnections\" , \"-1\" ) ) ; } public int getSocketReceiveBufferSize ( ) { return Integer . parseInt ( getHelpedParameters ( ) . getFirstValue ( \"socketReceiveBufferSize\" , \"8192\" ) ) ; } public boolean isPersistingConnections ( ) { return Boolean . parseBoolean ( getHelpedParameters ( ) . getFirstValue ( \"persistingConnections\" , \"true\" ) ) ; } public boolean isPipeliningConnections ( ) { return Boolean . parseBoolean ( getHelpedParameters ( ) . getFirstValue ( \"pipeliningConnections\" , \"false\" ) ) ; } public boolean isPooledConnection ( ) { return Boolean . parseBoolean ( getHelpedParameters ( ) . getFirstValue ( \"pooledConnections\" , \"true\" ) ) ; } public abstract boolean isProxying ( ) ; public boolean isSocketReuseAddress ( ) { return Boolean . parseBoolean ( getHelpedParameters ( ) . getFirstValue (", "gt": "\"socketReuseAddress\" , \"true\" ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2406, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . HideJournalEntry ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class HideJournalEntryImpl extends ReportAttributeImpl implements HideJournalEntry { protected static final String EXPRESSION_EDEFAULT = null ; protected String expression = EXPRESSION_EDEFAULT ; protected HideJournalEntryImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getHideJournalEntry ( ) ; } public String getExpression ( ) { return expression ; } public void setExpression ( String newExpression ) { String oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . HIDE_JOURNAL_ENTRY__EXPRESSION , oldExpression , expression ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . HIDE_JOURNAL_ENTRY__EXPRESSION : return getExpression ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . HIDE_JOURNAL_ENTRY__EXPRESSION : setExpression ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . HIDE_JOURNAL_ENTRY__EXPRESSION : setExpression ( EXPRESSION_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . HIDE_JOURNAL_ENTRY__EXPRESSION : return EXPRESSION_EDEFAULT == null ? expression != null : !", "gt": "EXPRESSION_EDEFAULT . equals ( expression ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4416, "input": "<s> package org . powerbot . game . api . methods . node ; import java . util . LinkedHashSet ; import java . util . Set ; import org . powerbot . game . api . methods . Calculations ; import org . powerbot . game . api . methods . Game ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . RegionOffset ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . node . SceneObject ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSAnimableNode ; import org . powerbot . game . client . RSGround ; import org . powerbot . game . client . RSGroundInfo ; import org . powerbot . game . client . RSInfo ; import org . powerbot . game . client . RSObject ; public class SceneEntities { public static final int TYPE_INTERACTIVE = 0x1 ; public static final int TYPE_FLOOR_DECORATION = 0x2 ; public static final int TYPE_BOUNDARY = 0x4 ; public static final int TYPE_WALL_DECORATION = 0x8 ; public static final int TYPE_UNKNOWN = 0x10 ; public static final Filter < SceneObject > ALL_FILTER = new Filter < SceneObject > ( ) { public boolean accept ( final SceneObject obj ) { return true ; } } ; public static SceneObject [ ] getLoaded ( ) { return getLoaded ( ALL_FILTER ) ; } public static SceneObject [ ] getLoaded ( final Tile tile ) { if ( tile . validate ( ) ) { final Set < SceneObject > locations = getLocalAt ( tile . getX ( ) - Game . getBaseX ( ) , tile . getY ( ) - Game . getBaseY ( ) , - 1 ) ; return locations . toArray ( new SceneObject [ locations . size ( ) ] ) ; } return new SceneObject [ 0 ] ; } public static SceneObject [ ] getLoaded ( final int ... ids ) { return getLoaded ( new Filter < SceneObject > ( ) { public", "gt": "boolean accept ( final SceneObject location )", "prediction": ")\n", "label": 1}
{"id": 4798, "input": "<s> import java . io . * ; import java . util . Arrays ; import javax . tools . * ; import com . sun . source . util . * ; public class T6357331 { public static void main ( String ... args ) { JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; PrintWriter out = new PrintWriter ( new StringWriter ( ) ) ; final JavacTask task = ( JavacTask ) ( tool . getTask ( out , null , null , null , null , null ) ) ; task . setTaskListener ( new TaskListener ( ) { public void started ( TaskEvent e ) {", "gt": "task . getElements ( ) ;", "prediction": "}\n", "label": 0}
{"id": 4432, "input": "<s> import java . util . Iterator ; import junit . framework . Assert ; import odatademo . Product ; import org . junit . Test ; import org . restlet . ext . odata . Query ; public class ProductTest { @ SuppressWarnings ( \"unused\" ) private int count ( Iterator < ? > i ) { int count = 0 ; for ( ; i . hasNext ( ) ; ) { i . next ( ) ; count ++ ; } return count ; } @ Test public void testSimpleGetProducts ( ) { OdataDemoService service = new OdataDemoService ( ) ; Query < Product > query = service . createProductQuery ( \"/Products\" ) ; int count = 0 ; for ( Product product : query ) { System . out . println ( \"- \" + product . getId ( ) + \", \" + product . getName ( ) ) ; count ++ ; } Assert . assertEquals ( 9 , count ) ; } @ Test public void testExpandGetProducts ( ) { OdataDemoService service = new OdataDemoService ( ) ; Query < Product > query = service . createProductQuery ( \"/Products\" ) . expand ( \"Category\" ) ; int count = 0 ; for ( Product product : query ) { System . out . println ( \"- \" + product . getId ( ) + \", \" + product . getName ( ) ) ; System . out . println ( \"    in \" + product . getCategory ( ) . getId ( ) + \", \" + product . getCategory ( ) . getName ( ) ) ; count ++ ; } Assert . assertEquals ( 9 , count ) ; } @ Test public void testSimpleGetProduct ( ) { OdataDemoService service = new OdataDemoService ( ) ; Query < Product > query = service . createProductQuery ( \"/Products(1)\" ) ; Iterator < Product > iterator = query . iterator ( ) ; Product product = iterator . next ( ) ; Assert . assertNotNull ( product ) ; Assert . assertEquals ( 1 , product . getId ( ) ) ; Assert . assertEquals ( \"Milk\" , product . getName ( ) ) ; System . out . println ( \"- \" + product . getId ( ) + \", \" + product . getName ( ) ) ; Assert . assertFalse ( iterator . hasNext ( ) ) ; } @ Test public void testFilterGetProducts ( ) { OdataDemoService service = new OdataDemoService ( ) ; Query < Product > query = service . createProductQuery ( \"/Products\" ) . filter ( \"Name eq 'Milk'\" ) ; Iterator < Product > iterator = query . iterator ( ) ; Product product = iterator . next ( ) ; Assert . assertEquals ( 1 , product . getId ( ) ) ; Assert . assertEquals ( \"Milk\" , product . getName ( ) ) ; Assert . assertFalse ( iterator . hasNext ( ) ) ; } @ Test public void testSkipTopGetProducts ( ) { OdataDemoService service = new OdataDemoService ( ) ; Query < Product > query = service . createProductQuery ( \"/Products\" ) . skip ( 8 ) . top ( 1 ) ; int count = 0 ; Product firstProduct = null ; Product lastProduct = null ; boolean begin = true ; for ( Product product : query ) { System . out . println ( \"- \" + product . getId ( ) + \", \" + product . getName ( ) ) ; if ( begin ) { firstProduct = product ; begin = false ; } lastProduct = product ; count ++ ; } Assert . assertEquals ( 1 , count ) ; Assert . assertEquals ( 8 , firstProduct . getId ( ) ) ; Assert . assertEquals ( \"LCD HDTV\" , firstProduct .", "gt": "getName ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4967, "input": "<s> public class T6215213 { static class Box < T > { } static class Box1 < T extends T6215213 > { } static class Pair < T , S > { } static class Pair1 < T extends T6215213 , S > { } static class Triple < T , S , U > { } static class Triple1 < T extends T6215213 , S , U extends T6215213 > { } static class Quad < T , S , U , V > { } static class Quad1 < T extends T6215213 , S , U extends T6215213 , V > { } < T > Box < T > testBox ( T t ) { return null ; } < T extends T6215213 > Box1 < T > testBox1 ( T t ) { return null ; } < T > Pair < T , T > testPair ( T t ) { return null ; } < T extends T6215213 > Pair1 < T , T > testPair1 ( T t ) { return null ; } < T > Triple < T , T , T > testTriple ( T t ) { return null ; } < T extends T6215213 > Triple1 < T , T , T > testTriple1 ( T t ) { return null ; } < T > Quad < T , T , T , T > testQuad ( T t ) { return null ; } < T extends T6215213 > Quad1 < T , T , T , T > testQuad1 ( T t ) { return null ; } void testAll ( ) { Box < ? > box = testBox ( null ) ; Box1 < ? > box1 = testBox1 ( null ) ; Pair < ? , ? > pair = testPair ( null ) ; Pair1 < ? , ? > pair1 = testPair1 ( null ) ; Triple < ? , ? , ? > triple = testTriple ( null ) ; Triple1 < ? , ? , ? > triple1 = testTriple1 ( null ) ; Quad < ? , ? , ? , ? > quad = testQuad ( null ) ; Quad1 < ? , ? , ?", "gt": ", ? > quad1 = testQuad1 ( null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4433, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . StringReader ; import java . text . ParseException ; import java . util . Date ; import junit . framework . TestCase ; import org . apache . lucene . benchmark . byTask . utils . Config ; import org . apache . lucene . document . DateTools ; public class TrecContentSourceTest extends TestCase { private static class StringableTrecSource extends TrecContentSource { private String docs = null ; public StringableTrecSource ( String docs , boolean forever ) { this . docs = docs ; this . forever = forever ; } void openNextFile ( ) throws NoMoreDataException , IOException { if ( reader != null ) { if ( ! forever ) { throw new NoMoreDataException ( ) ; } ++ iteration ; } reader = new BufferedReader ( new StringReader ( docs ) ) ; } public void setConfig ( Config config ) { htmlParser = new DemoHTMLParser ( ) ; } } private void assertDocData ( DocData dd , String expName , String expTitle , String expBody , Date expDate ) throws ParseException { assertNotNull ( dd ) ; assertEquals ( expName , dd . getName ( ) ) ; assertEquals ( expTitle , dd . getTitle ( ) ) ; assertTrue ( dd . getBody ( ) . indexOf ( expBody ) != - 1 ) ; Date date = dd . getDate ( ) != null ? DateTools . stringToDate ( dd . getDate ( ) ) : null ; assertEquals ( expDate , date ) ; } private void assertNoMoreDataException ( StringableTrecSource stdm ) throws Exception { boolean thrown = false ; try { stdm . getNextDocData ( null ) ; } catch ( NoMoreDataException e ) { thrown = true ; } assertTrue ( \"Expecting NoMoreDataException\" , thrown ) ; } public void testOneDocument ( ) throws Exception { String docs = \"<DOC>\\r\\n\" + \"<DOCNO>TEST-000</DOCNO>\\r\\n\" + \"<DOCHDR>\\r\\n\" + \"http://lucene.apache.org.trecdocmaker.test\\r\\n\" + \"HTTP/1.1 200 OK\\r\\n\" + \"Date: Sun, 11 Jan 2009 08:00:00 GMT\\r\\n\" + \"Server: Apache/1.3.27 (Unix)\\r\\n\" + \"Last-Modified: Sun, 11 Jan 2009 08:00:00 GMT\\r\\n\" + \"Content-Length: 614\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-Type: text/html\\r\\n\" + \"</DOCHDR>\\r\\n\" + \"<html>\\r\\n\" + \"\\r\\n\" + \"<head>\\r\\n\" + \"<title>\\r\\n\" + \"TEST-000 title\\r\\n\" + \"</title>\\r\\n\" + \"</head>\\r\\n\" + \"\\r\\n\" + \"<body>\\r\\n\" + \"TEST-000 text\\r\\n\" + \"\\r\\n\" + \"</body>\\r\\n\"", "gt": "+ \"\\r\\n\" + \"</DOC>\" ;", "prediction": ") ;\n", "label": 1}
{"id": 9066, "input": "<s> import java . lang . reflect . * ; public class StrictAbstract { static strictfp interface I { void f ( ) ; } static abstract strictfp class C { void f ( ) { } abstract void g ( ) ; } static Class [ ] ca = new Class [ 0 ] ; public static void main ( String [ ] args ) throws Exception { check ( I . class . getDeclaredMethod ( \"f\" , ca ) ) ; check ( C . class . getDeclaredMethod ( \"f\" , ca ) ) ; check ( C .", "gt": "class . getDeclaredMethod ( \"g\" , ca ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4438, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; public class L1FSInverseCosineLens extends FSInverseCosineLens { public L1FSInverseCosineLens ( ) { super ( ) ; } public L1FSInverseCosineLens ( float mm ) { super ( mm ) ; } public L1FSInverseCosineLens ( float mm , int outerRadius , int innerRadius ) { super ( mm , outerRadius , innerRadius ) ; } public L1FSInverseCosineLens ( float mm , int outerRadius , int innerRadius , int x , int y ) { super ( mm , outerRadius , innerRadius , x , y ) ; } public void gf ( float x , float y , float [ ] g ) { d = Math . abs ( x - sw - lx ) + Math . abs ( y - sh - ly ) ; if ( d <= LR2 ) g [ 0 ] = g [ 1 ] = MM ; else if ( d <= LR1 ) g [ 0 ] = g [ 1 ] = MM - c * ( float ) Math . acos ( Math . pow ( d * a + b - 1 , 2 ) ) ; else g [ 0 ] = g [ 1 ] = 1 ; } public void drawBoundary ( Graphics2D g2d ) { if ( r1Color != null ) { g2d . setColor ( r1Color ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 - LR1 , lx + w / 2 + LR1 , ly + h / 2 ) ; g2d . drawLine ( lx + w / 2 + LR1 , ly + h / 2 , lx + w / 2 , ly + h / 2 + LR1 ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 + LR1 , lx + w / 2 - LR1 , ly + h / 2 ) ; g2d . drawLine ( lx + w / 2 - LR1 , ly + h / 2 , lx + w / 2 , ly + h / 2 - LR1 ) ; } if ( r2Color != null ) { g2d . setColor ( r2Color ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 - LR2 , lx + w / 2 +", "gt": "LR2 , ly + h / 2 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9175, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class TjiFileTest extends XtextTest { public TjiFileTest ( ) { super ( \"TjiFileTest\" ) ; } @ Test public void testTjiFileNoProject ( ) { ignoreFormattingDifferences ( ) ; testFile ( \"TjiFileNoProject.tji\" ) ; } @ Test public void testTjiFileWithProject ( ) { ignoreFormattingDifferences ( ) ; assertConstraints ( testFileNoSerializer ( \"TjiFileWithProject.tji\" ) . nOfThemContain ( 1 , \"A *.tji file must not have a 'project' property.\" ) ) ; } @ Test public void testTjpFileNoProject ( ) { ignoreFormattingDifferences ( ) ; assertConstraints ( testFileNoSerializer ( \"TjpFileNoProject.tjp\" ) . nOfThemContain ( 1 , \"A *.tjp", "gt": "file must have a 'project' property.\" ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4444, "input": "<s> package org . nuxeo . ecm . platform . audit . service . management ; public interface AuditEventMetricMBean {", "gt": "Long getCount ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7619, "input": "<s> enum EnumNoFinalize { A , B , C ;", "gt": "public void finalize ( )", "prediction": "}\n", "label": 0}
{"id": 4456, "input": "<s> package litil . eval ; public class EvalException extends RuntimeException { public", "gt": "EvalException ( String s )", "prediction": "\n", "label": 1}
{"id": 1318, "input": "<s> package org . bombusim . networking ; import java . io . IOException ; import java . net . Socket ; import java . net . UnknownHostException ; import java . security . Principal ; import java . text . DateFormat ; import javax . net . ssl . HandshakeCompletedEvent ; import javax . net . ssl . HandshakeCompletedListener ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . net . ssl . SSLSocket ; import javax . net . ssl . SSLSocketFactory ; import javax . security . cert . X509Certificate ; import org . bombusim . lime . logger . LimeLog ; import android . net . SSLCertificateSocketFactory ; import com . jcraft . jzlib . DeflaterOutputStream ; import com . jcraft . jzlib . InflaterInputStream ; public class NetworkSocketDataStream extends NetworkDataStream { private boolean zlib = false ; private String certificateInfo ; protected Socket socket ; protected String host ; protected int port ; public NetworkSocketDataStream ( String server , int port ) throws UnknownHostException , IOException { this . host = server ; this . port = port ; LimeLog . i ( \"Socket\" , \"Connecting to \" + host + \":\" + port , null ) ; socket = new Socket ( server , port ) ; socket . setKeepAlive ( true ) ; istream = socket . getInputStream ( ) ; ostream = socket . getOutputStream ( ) ; } public void setCompression ( ) throws IOException { LimeLog . i ( \"Socket\" , \"Binding ZLIB\" , null ) ; istream = new InflaterInputStream ( istream ) ; DeflaterOutputStream dos ; dos = new DeflaterOutputStream ( ostream ) ; dos . setSyncFlush ( true ) ; ostream = dos ; zlib = true ; } public void setTLS ( ) throws IOException { LimeLog . i ( \"Socket\" , \"Switching to secure socket layer\" , null ) ; SSLSocketFactory sf = SSLCertificateSocketFactory . getInsecure ( 20000 , null ) ; final SSLSocket ssls = ( SSLSocket ) sf . createSocket ( socket , host , port , true ) ; ssls . addHandshakeCompletedListener ( new HandshakeCompletedListener ( ) { @ Override public void handshakeCompleted ( HandshakeCompletedEvent event ) { X509Certificate [ ] certs ; try { certs = ssls .", "gt": "getSession ( ) . getPeerCertificateChain ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4457, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IPerspectiveListener ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; public class ToggleEditorsVisibilityAction extends PerspectiveAction implements IPerspectiveListener { public void perspectiveActivated ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { if ( page . isEditorAreaVisible ( ) ) { setText ( WorkbenchMessages . get ( ) . ToggleEditor_hideEditors ) ; } else { setText ( WorkbenchMessages . get ( ) . ToggleEditor_showEditors ) ; } } public void perspectiveChanged ( IWorkbenchPage page , IPerspectiveDescriptor perspective , String changeId ) { if ( changeId == IWorkbenchPage . CHANGE_RESET || changeId == IWorkbenchPage . CHANGE_EDITOR_AREA_HIDE || changeId == IWorkbenchPage . CHANGE_EDITOR_AREA_SHOW ) { if ( page . isEditorAreaVisible ( ) ) { setText ( WorkbenchMessages . get ( ) . ToggleEditor_hideEditors ) ; } else { setText ( WorkbenchMessages . get ( ) . ToggleEditor_showEditors ) ; } } } public ToggleEditorsVisibilityAction ( IWorkbenchWindow window ) { super ( window ) ; setText ( WorkbenchMessages . get ( ) . ToggleEditor_hideEditors ) ; setActionDefinitionId ( \"org.eclipse.ui.window.hideShowEditors\" ) ; setToolTipText ( WorkbenchMessages . get ( ) . ToggleEditor_toolTip ) ; window . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IWorkbenchHelpContextIds . TOGGLE_EDITORS_VISIBILITY_ACTION ) ; window . addPerspectiveListener ( this ) ; } protected void run ( IWorkbenchPage page , IPerspectiveDescriptor persp ) { boolean visible = page . isEditorAreaVisible ( ) ; if ( visible ) { page . setEditorAreaVisible ( false ) ; setText ( WorkbenchMessages . get ( ) . ToggleEditor_showEditors ) ; } else { page . setEditorAreaVisible ( true ) ; setText ( WorkbenchMessages . get ( ) . ToggleEditor_hideEditors ) ; } } public void dispose ( ) { if ( getWindow ( ) != null ) { getWindow ( ) . removePerspectiveListener ( this ) ; } super", "gt": ". dispose ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1829, "input": "<s> package Liza ; import org . bukkit . event . Event ; public interface LizaListener {", "gt": "public void handleEvent ( Event e ) ;", "prediction": ";\n", "label": 0}
{"id": 4468, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . io . File ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task . standalone . commands . UnloadJarPlaceholder ; @ Deprecated public class UnloadJar extends UnloadJarPlaceholder { private static final Log log = LogFactory . getLog ( UnloadJar . class ) ; public UnloadJar ( ) { super ( ) ; } public UnloadJar ( File file ) { super ( file ) ; } @ Override protected Command doRun ( Task task , Map < String , String > prefs ) throws PackageException { log . warn ( \"UnloadJar command is deprecated and", "gt": "does nothing right now\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8778, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface TaskTimesheet extends TimesheetAttribute { Task getTask ( ) ; void setTask ( Task value ) ; EList < TaskTimesheetAttribute", "gt": "> getAttributes ( ) ;", "prediction": ";\n", "label": 0}
{"id": 4485, "input": "<s> package org . eclipse . jface . fieldassist ; import java . io . Serializable ; public interface IContentProposalProvider extends Serializable { IContentProposal [ ] getProposals ( String contents", "gt": ", int position ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7084, "input": "<s> package com . redhat . ceylon . compiler . java . test ; import org . junit . runner . RunWith ; import org . junit . runners . Suite . SuiteClasses ; import com . redhat . ceylon . ant . AntToolTests ; import com . redhat . ceylon . ceylondoc . test . CeylonDocToolTest ; import com . redhat . ceylon . compiler . java . codegen . NamingTest ; import com . redhat . ceylon . compiler . java . test . annotations . AnnotationsTest ; import com . redhat . ceylon . compiler . java . test . bc . BcTests ; import com . redhat . ceylon . compiler . java . test . cmr . CMRTest ; import com . redhat . ceylon . compiler . java . test . cmr . CMRTestHTTP ; import com . redhat . ceylon . compiler . java . test . expression . ExpressionTest ; import com . redhat . ceylon . compiler . java . test . expression . ExpressionTest2 ; import com . redhat . ceylon . compiler . java . test . expression . ExpressionTest3 ; import com . redhat . ceylon . compiler . java . test . interop . InteropTest ; import com . redhat . ceylon . compiler . java . test . issues . IssuesTest ; import com . redhat . ceylon . compiler . java . test . issues . PackageIssuesTest ; import com . redhat . ceylon . compiler . java . test . misc . MiscTest ; import com . redhat . ceylon . compiler . java . test . model . ModelLoaderTest ; import com . redhat . ceylon . compiler . java . test . model . TypeParserTest ; import com . redhat . ceylon . compiler . java . test . quoting . QuotingTest ; import com . redhat . ceylon . compiler . java . test . recovery . RecoveryTest ; import com . redhat . ceylon . compiler . java . test . statement . StatementTest ; import com . redhat . ceylon . compiler . java . test . structure . StructureTest ; import com . redhat . ceylon . compiler . java . test . structure . StructureTest2 ; import com . redhat . ceylon . compiler . java . test . structure . StructureTest3 ; import com . redhat . ceylon .", "gt": "tools . test . CompilerToolsTests ;", "prediction": ";\n", "label": 0}
{"id": 4494, "input": "<s> package br . org . archimedes . pan . tests ; import junit . framework . Assert ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . controller . commands . PanCommand ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; public class PanCommandTest extends Tester { private PanCommand pan ; private Drawing drawing ; @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; Point original = new Point ( 0 , 0 ) ; Point viewport = new Point ( 14 , 42 ) ; pan = new PanCommand ( original , viewport ) ; drawing = new Drawing ( \"Drawing\" ) ; } @ After public void tearDown ( ) throws Exception { pan = null ; drawing = null ; } @ Test public void testPanCommand ( ) { try { new PanCommand ( null , null ) ; Assert . fail ( \"Should throw a NullArgumentException.\" ) ; } catch ( NullArgumentException e ) { } catch ( IllegalActionException e ) { Assert . fail ( \"Should throw a NullArgumentException not an IllegalActionException.\" ) ; } try { new PanCommand ( new Point ( 10 , 10 ) , new Point ( 10 , 10 ) ) ; Assert . fail ( \"Should throw an IllegalActionException.\" ) ; } catch ( NullArgumentException e ) { Assert . fail ( \"Should throw an IllegalActionException not a NullArgumentException.\" ) ; } catch ( IllegalActionException e ) { } } @ Test public void testDoIt ( ) { try { pan . doIt ( null ) ; Assert . fail ( \"Should throw a NullArgumentException\" ) ; } catch ( IllegalActionException e ) { Assert . fail ( \"Should throw a NullArgumentException not IllegalActionException\" ) ; } catch ( NullArgumentException e ) { } double zoom = drawing . getZoom ( ) ; safeDoIt ( ) ; Assert . assertEquals ( \"The viewport position should have been updated.\" , new Point ( 14 , 42 ) , drawing . getViewportPosition ( ) ) ; Assert . assertEquals ( \"The zoom should be the same.\" , zoom , drawing . getZoom ( ) ) ; } private void safeDoIt ( ) { try { pan . doIt ( drawing ) ; } catch ( Exception e ) { Assert . fail ( \"Should not throw any exception.\" ) ; } } @ Test public void testUndoIt ( ) { try { pan . undoIt ( null ) ; Assert . fail ( \"Should throw a NullArgumentException\" ) ; } catch ( IllegalActionException e ) { Assert . fail ( \"Should throw a NullArgumentException not IllegalActionException\" ) ; } catch ( NullArgumentException e ) { } double zoom = drawing . getZoom ( ) ; safeDoIt ( ) ; try { pan . undoIt ( drawing ) ; } catch ( Exception e ) { Assert . fail", "gt": "( \"Should not throw any exception.\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9800, "input": "<s> import java . io . * ; class UnreachableCatch1 { void test ( ) { try { if ( true ) { throw new FileNotFoundException ( ) ; } else { throw new EOFException ( ) ; } } catch ( FileNotFoundException fnf ) { } catch ( EOFException eof ) { }", "gt": "catch ( IOException ex )", "prediction": "}\n", "label": 0}
{"id": 4531, "input": "<s> package org . fuzzydb . attrs . byteencoding ; import java . util . HashMap ; import java . util . Map ; import org . fuzzydb . attrs . bool . BooleanValue ; import org . fuzzydb . attrs . internal . AttrDefinitionMgr ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . dto . attributes . BooleanAttribute ; import org . fuzzydb . util . ByteArray ; public class BooleanCodec extends CompactAttrCodec { static final byte BOOLEAN_SIZE = ATTR_ID_SIZE + 1 ; private static final int BOOLEAN_FLAG_OFFSET = PAYLOAD_OFFSET ; private final Map < Integer , BooleanValue > map = new HashMap < Integer , BooleanValue > ( ) ; static BooleanCodec instance = null ; public static synchronized BooleanCodec getInstance ( ) { if ( instance == null ) { instance = new BooleanCodec ( ) ; } return instance ; } @ Override public void encodeToByteArray ( ByteArray bytes , int attrId , Object value ) { int i = findAttrInBuf ( bytes , attrId ) ; if ( i < 0 ) { i = bytes . getIndexForWrite ( BOOLEAN_SIZE ) ; } setAttrId ( bytes , i , attrId ) ; if ( value instanceof BooleanValue ) { bytes . putBoolean ( i + BOOLEAN_FLAG_OFFSET , ( ( BooleanValue ) value ) . isTrue ( ) ) ; } else if", "gt": "( value instanceof BooleanAttribute )", "prediction": "( )\n", "label": 1}
{"id": 9463, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . Booking ; import org . jjflyboy . tjpeditor . project . Interval4 ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class BookingImpl extends MinimalEObjectImpl . Container implements Booking { protected Interval4 interval ; protected static final int OVERTIME_EDEFAULT = 0 ; protected int overtime = OVERTIME_EDEFAULT ; protected static final int SLOPPY_EDEFAULT = 0 ; protected int sloppy = SLOPPY_EDEFAULT ; protected BookingImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getBooking ( ) ; } public Interval4 getInterval ( ) { return interval ; } public NotificationChain basicSetInterval ( Interval4 newInterval , NotificationChain msgs ) { Interval4 oldInterval = interval ; interval = newInterval ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . BOOKING__INTERVAL , oldInterval , newInterval ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setInterval ( Interval4 newInterval ) { if ( newInterval != interval ) { NotificationChain msgs = null ; if ( interval != null ) msgs = ( ( InternalEObject ) interval ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . BOOKING__INTERVAL , null , msgs ) ; if ( newInterval != null ) msgs = ( ( InternalEObject ) newInterval ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . BOOKING__INTERVAL , null , msgs ) ; msgs = basicSetInterval ( newInterval , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . BOOKING__INTERVAL , newInterval , newInterval ) ) ; } public int getOvertime ( ) { return overtime ; } public void setOvertime ( int newOvertime ) { int oldOvertime = overtime ; overtime = newOvertime ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . BOOKING__OVERTIME , oldOvertime , overtime ) ) ; } public int getSloppy ( ) { return sloppy ; } public void setSloppy ( int newSloppy ) { int oldSloppy = sloppy ; sloppy = newSloppy ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . BOOKING__SLOPPY , oldSloppy , sloppy ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . BOOKING__INTERVAL : return basicSetInterval ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . BOOKING__INTERVAL : return getInterval ( ) ; case ProjectPackage . BOOKING__OVERTIME : return getOvertime ( ) ; case ProjectPackage . BOOKING__SLOPPY : return getSloppy ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . BOOKING__INTERVAL : setInterval ( ( Interval4 ) newValue ) ; return ; case ProjectPackage . BOOKING__OVERTIME : setOvertime ( ( Integer ) newValue ) ; return ; case ProjectPackage . BOOKING__SLOPPY : setSloppy ( ( Integer ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . BOOKING__INTERVAL : setInterval ( ( Interval4 ) null ) ; return ; case ProjectPackage . BOOKING__OVERTIME : setOvertime ( OVERTIME_EDEFAULT ) ; return ; case ProjectPackage . BOOKING__SLOPPY : setSloppy ( SLOPPY_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . BOOKING__INTERVAL : return interval != null ; case ProjectPackage . BOOKING__OVERTIME : return overtime != OVERTIME_EDEFAULT ; case ProjectPackage . BOOKING__SLOPPY : return sloppy != SLOPPY_EDEFAULT ; } return super . eIsSet ( featureID ) ; } @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super . toString ( ) ) ;", "gt": "result . append ( \" (overtime: \" ) ;", "prediction": "}\n", "label": 0}
{"id": 4537, "input": "<s> package cs224n . util ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . List ; import java . util . ArrayList ; import java . io . Serializable ; public class PriorityQueue < E > implements Iterator < E > , Serializable , Cloneable { int size ; int capacity ; List < E > elements ; double [ ] priorities ; protected void grow ( int newCapacity ) { List < E > newElements = new ArrayList < E > ( newCapacity ) ; double [ ] newPriorities = new double [ newCapacity ] ; if ( size > 0 ) { newElements . addAll ( elements ) ; System . arraycopy ( priorities , 0 , newPriorities , 0 , priorities . length ) ; } elements = newElements ; priorities = newPriorities ; capacity = newCapacity ; } protected int parent ( int loc ) { return ( loc - 1 ) / 2 ; } protected int leftChild ( int loc ) { return 2 * loc + 1 ; } protected int rightChild ( int loc ) { return 2 * loc + 2 ; } protected void heapifyUp ( int loc ) { if ( loc == 0 ) return ; int parent = parent ( loc ) ; if ( priorities [ loc ] > priorities [ parent ] ) { swap ( loc , parent ) ; heapifyUp ( parent ) ; } } protected void heapifyDown ( int loc ) { int max = loc ; int leftChild = leftChild ( loc ) ; if ( leftChild < size ( ) ) { double priority = priorities [ loc ] ; double leftChildPriority = priorities [ leftChild ] ; if ( leftChildPriority > priority ) max = leftChild ; int rightChild = rightChild ( loc ) ; if ( rightChild < size ( ) ) { double rightChildPriority = priorities [ rightChild ( loc ) ] ; if ( rightChildPriority > priority && rightChildPriority > leftChildPriority ) max = rightChild ; } } if ( max == loc ) return ; swap ( loc , max ) ; heapifyDown ( max ) ; } protected void swap ( int loc1 , int loc2 ) { double tempPriority = priorities [ loc1 ] ; E tempElement = elements . get ( loc1 ) ; priorities [ loc1 ] = priorities [ loc2 ] ; elements . set ( loc1 , elements . get ( loc2 ) ) ; priorities [ loc2 ] = tempPriority ; elements . set ( loc2 , tempElement ) ; } protected void removeFirst ( ) { if ( size < 1 ) return ; swap ( 0 , size - 1 ) ; size -- ; elements . remove ( size ) ; heapifyDown ( 0 ) ; } public boolean hasNext ( ) { return ! isEmpty ( ) ; } public E next ( ) { E first = peek ( ) ; removeFirst ( ) ; return first ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public E peek ( ) { if ( size ( ) > 0 ) return elements . get ( 0 ) ; throw new NoSuchElementException ( ) ; } public double getPriority ( ) { if ( size ( ) > 0 ) return priorities [ 0 ] ; throw new NoSuchElementException ( ) ; } public int size ( ) { return size ; } public boolean isEmpty ( ) { return size == 0 ; } public boolean add ( E key , double priority ) { if ( size == capacity ) { grow", "gt": "( 2 * capacity + 1 ) ;", "prediction": "\n", "label": 1}
{"id": 7351, "input": "<s> package org . osgi . framework . resource ; import java . util . List ; public interface Wiring { List < Capability > getResourceCapabilities ( String namespace ) ; List < Requirement >", "gt": "getResourceRequirements ( String namespace ) ;", "prediction": ";\n", "label": 0}
{"id": 4563, "input": "<s> package br . org . archimedes . snap ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . model . Drawing ; import org . eclipse . core . commands . State ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . commands . ICommandService ; public class SnapCommand implements Command { public void doIt ( Drawing drawing ) throws IllegalActionException , NullArgumentException { ICommandService service = ( ICommandService ) PlatformUI . getWorkbench ( ) . getService ( ICommandService . class ) ; org . eclipse . core . commands . Command command = service . getCommand (", "gt": "Activator . SNAP_COMMAND_ID ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2470, "input": "<s> package org . hackreduce . models ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . hadoop . io . Text ; public class StockExchangeRecord { SimpleDateFormat sdf = new SimpleDateFormat ( \"yyyy-MM-dd\" ) ; String exchange ; String stockSymbol ; Date date ; double stockPriceOpen ; double stockPriceHigh ; double stockPriceLow ; double stockPriceClose ; int stockVolume ; double stockPriceAdjClose ; public StockExchangeRecord ( String inputString ) throws IllegalArgumentException { String [ ] attributes = inputString . split ( \",\" ) ; if ( attributes . length != 9 ) throw new IllegalArgumentException ( \"Input string given did not have 9 values in CSV format\" ) ; try { setExchange ( attributes [ 0 ] ) ; setStockSymbol ( attributes [ 1 ] ) ; setDate ( sdf . parse ( attributes [ 2 ] ) ) ; setStockPriceOpen ( Double . parseDouble ( attributes [ 3 ] ) ) ; setStockPriceHigh ( Double . parseDouble ( attributes [ 4 ] ) ) ; setStockPriceLow ( Double . parseDouble ( attributes [ 5 ] ) ) ; setStockPriceClose ( Double . parseDouble ( attributes [ 6 ] ) ) ; setStockVolume ( Integer . parseInt ( attributes [ 7 ] ) ) ; setStockPriceAdjClose ( Double . parseDouble ( attributes [ 8 ] ) ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( \"Input string contained an unknown value that couldn't be parsed\" , e ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( \"Input string contained an unknown number value that couldn't be parsed\" , e ) ; } } public StockExchangeRecord ( Text inputText ) throws IllegalArgumentException { this ( inputText . toString ( ) ) ; } public String getExchange ( ) { return exchange ; }", "gt": "public void setExchange ( String exchange )", "prediction": "}\n", "label": 0}
{"id": 4579, "input": "<s> package org . restlet . data ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . engine . util . SystemUtils ; import org . restlet . util . Series ; public final class ChallengeResponse extends ChallengeMessage { private volatile String clientNonce ; private volatile Reference digestRef ; private volatile String identifier ; private volatile String quality ; private volatile char [ ] secret ; private volatile String secretAlgorithm ; private volatile int serverNounceCount ; private volatile long timeIssued ; public ChallengeResponse ( ChallengeRequest challengeRequest , Response response , String identifier , char [ ] secret ) { this ( challengeRequest , response , identifier , secret , Digest . ALGORITHM_NONE ) ; } public ChallengeResponse ( ChallengeRequest challengeRequest , Response response , String identifier , char [ ] secret , String secretAlgorithm ) { this ( challengeRequest . getScheme ( ) , null , identifier , secret , secretAlgorithm , null , null , null , null , null , null , null , 0 , 0L ) ; org . restlet . engine . security . AuthenticatorUtils . update ( this , response . getRequest ( ) , response ) ; } public ChallengeResponse ( ChallengeRequest challengeRequest , Response response , String identifier , String secret ) { this ( challengeRequest , response , identifier , secret . toCharArray ( ) , Digest . ALGORITHM_NONE ) ; } public ChallengeResponse ( ChallengeScheme scheme ) { this ( scheme , null , ( char [ ] ) null ) ; } public ChallengeResponse ( ChallengeScheme scheme , Series < Parameter > parameters , String identifier , char [ ] secret , String secretAlgorithm , String realm , String quality , Reference digestRef , String digestAlgorithm , String opaque , String clientNonce , String serverNonce , int serverNounceCount , long timeIssued ) { super ( scheme , realm , parameters , digestAlgorithm , opaque , serverNonce ) ; this . clientNonce = clientNonce ; this . digestRef = digestRef ; this . identifier = identifier ; this . quality = quality ; this . secret = secret ; this . secretAlgorithm = secretAlgorithm ; this . serverNounceCount = serverNounceCount ; this . timeIssued = timeIssued ; } public ChallengeResponse ( ChallengeScheme scheme , String identifier , char [ ] secret ) { this ( scheme , identifier , secret , null ) ; } public ChallengeResponse ( ChallengeScheme scheme , String identifier , char [ ] secret , Series < Parameter > parameters ) { this ( scheme , parameters , identifier , secret , Digest . ALGORITHM_NONE , null , null , null , null , null , null , null , 0 , 0L ) ; } public ChallengeResponse ( ChallengeScheme scheme , String identifier , Series < Parameter > parameters ) { this ( scheme , identifier , null , parameters ) ; } public ChallengeResponse ( ChallengeScheme scheme , String identifier , String secret ) { this ( scheme , identifier , ( secret != null ) ? secret . toCharArray ( ) : null ) ; } @ Override public boolean equals ( Object obj ) { boolean result = ( obj == this ) ; if ( ! result ) {", "gt": "if ( obj instanceof ChallengeResponse )", "prediction": "}\n", "label": 1}
{"id": 1610, "input": "<s> package ar . com . fdvs . dj . core ; public class CoreException extends RuntimeException { public CoreException ( ) { super ( ) ; } public CoreException ( Throwable cause ) { super ( cause ) ; } private", "gt": "static final long serialVersionUID = - 5674432237257954632L ;", "prediction": "}\n", "label": 0}
{"id": 4582, "input": "<s> package org . restlet . example . book . restlet . ch09 . common ; import com . google . gwt . user . client . rpc . SerializationException ; import com . google . gwt . user . client . rpc . SerializationStreamReader ; import com . google . gwt . user . client . rpc . SerializationStreamWriter ; import com . google . gwt . user . client . rpc . impl . ReflectionHelper ; @ SuppressWarnings ( \"deprecation\" ) public class ContactsRepresentation_FieldSerializer implements com . google . gwt . user . client . rpc . impl . TypeHandler { private static native java . util . ArrayList getContacts ( org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation instance ) ; private static native void setContacts ( org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation instance , java . util . ArrayList value ) ; public static void deserialize ( SerializationStreamReader streamReader , org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation instance ) throws SerializationException { setContacts ( instance , ( java . util . ArrayList ) streamReader . readObject ( ) ) ; } public static org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation instantiate ( SerializationStreamReader streamReader ) throws SerializationException { return new org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation ( ) ; } public static void serialize ( SerializationStreamWriter streamWriter , org . restlet . example . book . restlet . ch09 . common . ContactsRepresentation instance ) throws SerializationException { streamWriter . writeObject ( getContacts ( instance ) ) ; } public Object create ( SerializationStreamReader reader ) throws SerializationException { return org . restlet . example . book . restlet . ch09 . common", "gt": ". ContactsRepresentation_FieldSerializer . instantiate ( reader ) ;", "prediction": ";\n", "label": 1}
{"id": 7929, "input": "<s> import java . io . * ; import java . nio . * ; import java . util . * ; import java . util . jar . * ; import javax . tools . * ; import javax . tools . StandardJavaFileManager . * ; public class T6400872 { static File testSrc = new File ( System . getProperty ( \"test.src\" , \".\" ) ) ; static File testClasses = new File ( System . getProperty ( \"test.classes\" , \".\" ) ) ; public static void main ( String ... args ) throws Exception { compile ( testClasses , null , new File ( testSrc , \"A.java\" ) , new File ( testSrc , \"B.java\" ) ) ; jar ( new File ( \"A.jar\" ) , iterable ( new File ( \".\" , \"B.jar\" ) ) , testClasses , new File ( \"A.class\" ) ) ; jar ( new File ( \"B.jar\" ) , iterable ( new File ( \".\" , \"A.jar\" ) ) , testClasses , new File ( \"B.class\" ) ) ; compile ( new File ( \".\" ) , iterable ( new File ( \"A.jar\" ) ) , new File ( testSrc , \"C.java\" ) ) ; } static void compile ( File classOutDir , Iterable < File > classPath , File ... files ) throws IOException { System . err . println ( \"compile...\" ) ; JavaCompiler compiler = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = compiler . getStandardFileManager ( null , null , null ) ; try { Iterable < ? extends JavaFileObject > fileObjects = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( files ) ) ; List < String > options = new ArrayList < String > ( ) ; if ( classOutDir != null ) { options . add ( \"-d\" ) ; options . add ( classOutDir . getPath ( ) ) ; } if ( classPath != null ) { options . add ( \"-classpath\" ) ; options . add ( join ( classPath , File . pathSeparator ) ) ; } options . add ( \"-verbose\" ) ; JavaCompiler . CompilationTask task = compiler . getTask ( null , fm , null , options , null , fileObjects ) ; if ( ! task . call ( ) ) throw new AssertionError ( \"compilation failed\" ) ; } finally { fm . close ( ) ; } } static void jar ( File jar , Iterable < File > classPath , File base , File ... files ) throws IOException { System . err . println ( \"jar...\" ) ; Manifest m = new Manifest ( ) ; if ( classPath != null ) { Attributes mainAttrs = m . getMainAttributes ( ) ; mainAttrs . put ( Attributes . Name . MANIFEST_VERSION , \"1.0\" ) ; mainAttrs . put ( Attributes . Name . CLASS_PATH , join ( classPath , \" \" ) ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( jar ) ) ; JarOutputStream j = new JarOutputStream ( out , m ) ; add ( j , base , files ) ; j . close ( ) ; } static void add ( JarOutputStream j , File base , File ... files ) throws IOException { if ( files == null ) return ; for ( File f : files ) add ( j , base , f ) ; } static void add ( JarOutputStream j , File base , File file ) throws IOException { File f = new File ( base , file . getPath ( ) ) ; if ( f . isDirectory ( ) ) { String [ ] children = f . list ( ) ; if ( children != null ) for ( String c : children ) add ( j , base , new File ( file , c ) ) ; } else { JarEntry e = new JarEntry ( file . getPath ( ) ) ; e . setSize ( f . length ( ) ) ; j . putNextEntry ( e ) ; j . write ( read ( f ) ) ; j . closeEntry ( ) ; } } static byte [ ] read ( File f ) throws IOException { byte [ ] buf = new byte [ ( int", "gt": ") f . length ( ) ] ;", "prediction": ") ;\n", "label": 0}
{"id": 4589, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage . transmogrify ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class NullClass implements IClass { public Iterator getReferences ( ) { return new ArrayList ( ) . iterator ( ) ; } public int getNumReferences ( ) { return 0 ; } public void addReference ( Reference ref ) { } public String getName ( ) { return \"null\" ; } public String getQualifiedName ( ) { return getName ( ) ; } public boolean isSourced ( ) { return false ; } public IClass getSuperclass ( ) { return null ; } public IClass [ ] getInterfaces ( ) { return new IClass [ 0 ] ; } public IClass [ ] getInnerClasses ( ) { return new IClass [ 0 ] ; } public List getSubclasses ( ) { return new ArrayList ( ) ; } public IClass getClassDefinition ( String name ) { return null ; } public", "gt": "IMethod getMethodDefinition ( String name , ISignature signature )", "prediction": "}\n", "label": 1}
{"id": 9574, "input": "<s> import java . util . List ; class T6369605b { static < T extends List < X > , X > List < T > m1 ( ) { return null ; } static < T extends List < U > , U extends List < X > , X > List < T > m2 ( ) { return null ; } static < T extends List < U > , U extends List < V > , V extends List < X > , X > List < T > m3 ( ) { return null ; } List", "gt": "< ? > l1 = m1 ( ) ;", "prediction": "}\n", "label": 0}
{"id": 4590, "input": "<s> package org . eclipse . jface . preference ; public final class JFacePreferences { public static final String ERROR_COLOR = \"ERROR_COLOR\" ; public static final String HYPERLINK_COLOR = \"HYPERLINK_COLOR\" ; public static final String ACTIVE_HYPERLINK_COLOR = \"ACTIVE_HYPERLINK_COLOR\" ; public static final String QUALIFIER_COLOR = \"QUALIFIER_COLOR\" ; public static final String DECORATIONS_COLOR = \"DECORATIONS_COLOR\" ; public static final String COUNTER_COLOR = \"COUNTER_COLOR\" ; public static final", "gt": "String CONTENT_ASSIST_BACKGROUND_COLOR = \"CONTENT_ASSIST_BACKGROUND_COLOR\" ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6024, "input": "<s> import java . io . IOException ; import java . io . InputStream ; import java . util . Hashtable ; class Main { static InputStream in = System . in ; static int max = 1 ; static Hashtable ht = new Hashtable ( ) ; public static void main ( String [ ] args ) throws Exception { ht . put ( \"0\" , new BigInteger ( \"0\" ) ) ; ht . put ( \"1\" , new BigInteger ( \"1\" ) ) ; while ( true ) { String str = readLine ( ) ; if ( str == null ) return ; int n = Integer . parseInt ( str . trim ( ) ) ; if ( n > max ) { while ( max != n ) { max ++ ; BigInteger n1 = ( BigInteger ) ht . get ( \"\" + ( max - 1 ) ) ; BigInteger n3 = new BigInteger ( \"0\" ) . add ( n1 ) ; n3 = n3 . add ( ( BigInteger ) ht . get ( \"\" + ( max - 2 ) ) ) ; ht . put ( \"\" + max , n3 ) ; } } BigInteger zzz = ( BigInteger ) ht . get ( \"\" + n ) ; System . out . println ( \"The Fibonacci number for \" + n + \" is \" + zzz . toString ( 10 ) ) ; } } static String readLine ( ) throws IOException { return readLine ( 500 ) ; } static String readLine ( int max ) throws IOException { int i = 0 , character = - 1 ; byte lin [ ] = new byte [ max ] ; while ( i < max ) { character = in . read ( ) ; if ( ( character < 0 ) || ( character == '\\n' ) ) break ; lin [ i ++ ] += character ; } if ( ( character < 0 ) && ( i == 0 ) ) { return ( null ) ; } return ( new String ( lin , 0 , i ) ) ; } } class BigInteger extends Number { int signum ; int [ ] mag ; private int firstNonzeroIntNum = - 2 ; private final static long LONG_MASK = 0xffffffffL ; public BigInteger ( byte [ ] val ) { if ( val . length == 0 ) throw new NumberFormatException ( \"Zero length BigInteger\" ) ; if ( val [ 0 ] < 0 ) { mag = makePositive ( val ) ; signum = - 1 ; } else { mag = stripLeadingZeroBytes ( val ) ; signum = ( mag . length == 0 ? 0 : 1 ) ; } } public BigInteger ( int signum , byte [ ] magnitude ) { this . mag = stripLeadingZeroBytes ( magnitude ) ; if ( signum < - 1 || signum > 1 ) throw ( new NumberFormatException ( \"Invalid signum value\" ) ) ; if ( this . mag . length == 0 ) { this . signum = 0 ; } else { if ( signum == 0 ) throw ( new NumberFormatException ( \"signum-magnitude mismatch\" ) ) ; this . signum = signum ; } } public BigInteger ( String val , int radix ) { int cursor = 0 , numDigits ; int len =", "gt": "val . length ( ) ;", "prediction": ";\n", "label": 0}
{"id": 4596, "input": "<s> package org . eclipse . ui . internal . presentations . defaultpresentation ; import org . eclipse . ui . internal . preferences . AbstractBooleanListener ; import org . eclipse . ui . internal . preferences . IDynamicPropertyMap ; public final class DefaultSimpleTabListener extends AbstractBooleanListener { private DefaultTabFolder folder ; public DefaultSimpleTabListener ( IDynamicPropertyMap map , String propertyId , DefaultTabFolder folder ) { super ( ) ; this . folder = folder ; attach ( map , propertyId , true ) ; } protected", "gt": "void handleValue ( boolean b )", "prediction": "}\n", "label": 1}
{"id": 4042, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import java . util . Iterator ; import javax . tools . JavaFileObject ; import com . redhat . ceylon . compiler . typechecker . context . PhasedUnit ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . Setter ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . Value ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . BaseMemberExpression ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCBlock ; import com . sun . tools . javac . tree . JCTree . JCCompilationUnit ; import com . sun . tools . javac . tree . JCTree . JCExpression ; import com . sun . tools . javac . tree . JCTree . JCImport ; import com . sun . tools . javac . tree . JCTree . JCStatement ; import com . sun . tools . javac . tree . JCTree . JCTypeParameter ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Options ; import com . sun . tools . javac . util . Position . LineMap ; public class CeylonTransformer extends AbstractTransformer { private Options options ; private LineMap map ; private JavaFileObject fileObject ; public boolean disableModelAnnotations = false ; CeylonVisitor visitor ; public static CeylonTransformer getInstance ( Context context ) { CeylonTransformer trans = context . get ( CeylonTransformer . class ) ; if ( trans == null ) { trans = new CeylonTransformer ( context ) ; context . put ( CeylonTransformer . class , trans ) ; } return trans ; } public CeylonTransformer ( Context context ) { super ( context ) ; setup ( context ) ; } private void setup ( Context context ) { options = Options . instance ( context ) ; options . put ( \"invokedynamic\" , \"invokedynamic\" ) ; } @ Override public void setMap ( LineMap map ) { this . map = map ; } @ Override protected LineMap getMap ( ) { return map ; } public void setFileObject ( JavaFileObject fileObject ) { this . fileObject = fileObject ; } public JavaFileObject getFileObject ( ) { return fileObject ; } public JCCompilationUnit makeJCCompilationUnitPlaceholder ( Tree . CompilationUnit t , JavaFileObject file , String pkgName , PhasedUnit phasedUnit ) { JCExpression pkg = pkgName != null ? getPackage ( pkgName ) : null ; at ( t ) ; JCCompilationUnit topLev = new CeylonCompilationUnit ( List . < JCTree . JCAnnotation > nil ( ) , pkg , List . < JCTree > nil ( ) , null , null , null , null , t , phasedUnit ) ; topLev . lineMap = getMap ( ) ; topLev . sourcefile = file ; topLev . isCeylonProgram = true ; return topLev ; } @ SuppressWarnings ( \"unchecked\" ) public ListBuffer < JCTree > transformAfterTypeChecking ( Tree . CompilationUnit t ) { disableModelAnnotations = false ; ToplevelAttributesDefinitionBuilder builder = new ToplevelAttributesDefinitionBuilder ( this ) ; CeylonVisitor visitor = new CeylonVisitor ( this , builder ) ; t . visitChildren ( visitor ) ; ListBuffer < JCTree > result = ListBuffer . lb ( ) ; result . appendList ( ( ListBuffer < JCTree > ) visitor . getResult ( ) ) ; result . appendList ( builder . build ( ) ) ; return result ; } Name makeName ( Iterable < String > components ) { Iterator < String > iterator = components . iterator ( ) ; String s = iterator . next ( ) ; assert ( ! iterator . hasNext ( ) ) ; return names ( ) . fromString ( s ) ; } String toFlatName ( Iterable < String > components ) { StringBuffer buf = new StringBuffer ( ) ; Iterator < String > iterator ; for ( iterator = components . iterator ( ) ; iterator . hasNext ( ) ; ) { buf . append ( iterator . next ( ) ) ; if ( iterator . hasNext ( ) ) buf . append ( '.' ) ; } return buf . toString ( ) ; } private JCExpression getPackage ( String fullname ) { return makeQuotedQualIdentFromString ( fullname ) ; } public JCImport transform ( Tree . ImportPath that ) { String [ ] names = new String [ that . getIdentifiers ( ) . size ( ) ] ; int i = 0 ; for ( Tree . Identifier component : that . getIdentifiers ( ) ) { names [ i ++ ] = component . getText ( ) ; } return at ( that ) . Import ( makeQuotedQualIdent ( null , names ) , false ) ; } public List < JCTree > transform ( Tree . AnyAttribute decl ) { return transformAttribute ( decl , null ) ; } public List < JCTree > transform ( Tree . AttributeSetterDefinition decl ) { return transformAttribute ( decl , null ) ; } public List < JCTree > transformAttribute ( Tree . TypedDeclaration decl , Tree . AttributeSetterDefinition setterDecl ) { at ( decl ) ; TypedDeclaration declarationModel = decl . getDeclarationModel ( ) ; final String attrName = decl . getIdentifier", "gt": "( ) . getText ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4628, "input": "<s> package br . org . archimedes . trims ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.trims.messages\" ; public static String notPerformed ; public static String SelectRefs ; public static String Trimmed ;", "gt": "public static String TrimSelectElements ;", "prediction": "}\n", "label": 1}
{"id": 2571, "input": "<s> package org . xbill . DNS ; public final class Credibility { private Credibility ( ) { } public static final int HINT = 0 ; public static final int ADDITIONAL = 1 ; public static final int GLUE = 2 ; public static final int NONAUTH_AUTHORITY = 3 ; public static final int NONAUTH_ANSWER = 3 ; public static final int AUTH_AUTHORITY = 4 ; public static", "gt": "final int AUTH_ANSWER = 4 ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4638, "input": "<s> package org . gatein . common . xml ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import java . io . IOException ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Properties ; import java . util . Set ; public class XMLTools { public static final String XML_LANG_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\" ; private static Properties DEFAULT_FORMAT = createFormat ( true , false , true , \"utf-8\" ) ; public static final String PARAM_YES = \"yes\" ; public static final String PARAM_NO = \"no\" ; public static final String ATTRIB_OMIT_XML_DECLARATION = \"omit-xml-declaration\" ; public static final String ATTRIB_CDATA_SECTION_ELEMENTS = \"cdata-section-elements\" ; public static final String ATTRIB_METHOD = \"method\" ; public static final String ATTRIB_INDENT = \"indent\" ; public static final String ATTRIB_HREF = \"href\" ; public static final String DIRECTIVE_IMPORT = \"xsl:import\" ; public static final String DIRECTIVE_INCLUDE = \"xsl:include\" ; public static final boolean DEFAULT_NAMESPACE_AWARE = true ; public static final boolean DEFAULT_VALIDATION = false ; private XMLTools ( ) { } public static DocumentBuilderFactory getDocumentBuilderFactory ( ) { return DocumentBuilderFactory . newInstance ( ) ; } private static Properties createFormat ( boolean omitXMLDeclaration , boolean standalone , boolean indented , String encoding ) { Properties format = new Properties ( ) ; format . setProperty ( OutputKeys . OMIT_XML_DECLARATION , omitXMLDeclaration ? \"yes\" : \"no\" ) ; format . setProperty ( OutputKeys . STANDALONE , standalone ? \"yes\" : \"no\" ) ; format . setProperty ( OutputKeys . INDENT , indented ? \"yes\" : \"no\" ) ; format . setProperty ( OutputKeys . ENCODING , encoding ) ; return format ; } public static String toString ( Document doc , boolean omitXMLDeclaration , boolean standalone , boolean indented , String encoding ) throws TransformerException { Properties format = createFormat ( omitXMLDeclaration , standalone , indented , encoding ) ; return toString ( doc , format ) ; } public static String toString ( Document doc ) throws TransformerException { return toString ( doc , DEFAULT_FORMAT ) ; } public static String toString ( Element element ) throws ParserConfigurationException , TransformerException { return toString ( element , DEFAULT_FORMAT ) ; } private static String toString ( Element element , Properties properties ) throws ParserConfigurationException , TransformerException { Document doc = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) . newDocument ( ) ; element = ( Element ) doc . importNode ( element , true ) ; doc . appendChild ( element ) ; return toString ( doc , properties ) ; } private static String toString ( Document doc , Properties format ) throws TransformerException { Transformer transformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; transformer . setOutputProperties ( format ) ; StringWriter writer = new StringWriter ( ) ; Source source = new DOMSource ( doc ) ; Result result = new StreamResult ( writer ) ; transformer . transform ( source , result ) ; return writer . toString ( ) ; } public static Document toDocument ( String text ) throws ParserConfigurationException , SAXException , IOException { DocumentBuilder builder = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; StringReader reader = new StringReader ( text ) ; InputSource source = new InputSource ( ) ; source . setCharacterStream ( reader ) ; return builder . parse ( source ) ; } public static Element toElement ( String text ) throws ParserConfigurationException , SAXException , IOException { Document doc = toDocument ( text ) ; return doc . getDocumentElement ( ) ; } public static Document toDocument ( Element element ) throws ParserConfigurationException , SAXException , IOException { if ( element == null ) { throw new IllegalArgumentException ( ) ; } Document doc = getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) . newDocument ( ) ; element = ( Element ) doc . importNode ( element , true ) ; doc . appendChild ( element ) ; return doc ; } public static String asString ( Element element ) throws IllegalArgumentException { return asString ( element , true ) ; } public static String asString ( Element element , boolean trim ) throws IllegalArgumentException { if ( element == null ) { throw new IllegalArgumentException ( \"No null element allowed\" ) ; } StringBuffer buffer = new StringBuffer ( ) ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . CDATA_SECTION_NODE : case Node . TEXT_NODE : buffer . append ( ( ( Text ) child ) .", "gt": "getData ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5282, "input": "<s> package com . farpost . maven . plugins ; import com . farpost . ldt . * ; import com . farpost . ldt . formatter . ResultFormatter ; import org . apache . maven . plugin . AbstractMojo ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . logging . Log ; import static com . farpost . ldt . TaskFactory . createTask ; public class TestMojo extends AbstractMojo { private String testName ; private int concurrencyLevel = 1 ; private int callCount = 0 ; private int time = 0 ; private int warmUpThreshold = 10 ; public void execute ( ) throws MojoExecutionException { TestRunner runner = new TestRunner ( ) ; runner . setConcurrencyLevel ( concurrencyLevel ) ; runner . setWarmUpThreshold ( warmUpThreshold ) ; if ( callCount > 0 ) { runner . setTestInterruptionStarategy ( new CallCountInterruptionStrategy ( callCount ) ) ; } else if ( time > 0 ) { runner . setTestInterruptionStarategy ( new TimeFrameInterruptionStrategy ( time ) ) ; } else { throw new RuntimeException ( \"Missing", "gt": "interruption strategy. Please set testTime or callCount parameter\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4642, "input": "<s> package org . spliffy . sync . triplets ; import com . ettrema . db . Table ; import com . ettrema . db . TableDefinitionSource ; import com . ettrema . db . types . FieldTypes ; import java . sql . * ; import java . util . * ; public class CrcDao { public static final CrcTable CRC = new CrcTable ( ) ; public static Map < String , CrcRecord > toMap ( List < CrcRecord > records ) { Map < String , CrcRecord > map = new HashMap < > ( ) ; for ( CrcRecord r : records ) { map . put ( r . name , r ) ; } return map ; } public void deleteCrc ( Connection c , String path , String name ) throws SQLException { String sql = \"DELETE FROM \" + CRC . tableName + \" WHERE \" + CRC . path . getName ( ) + \" = ?\" + \" AND \" + CRC . name . getName ( ) + \" = ?\" ; try ( PreparedStatement stmt = c . prepareStatement ( sql ) ) { CRC . path . set ( stmt , 1 , path ) ; CRC . name . set ( stmt , 2 , name ) ; stmt . execute ( ) ; } } public void insertCrc ( Connection c , String path , String name , long crc , long modDate ) throws SQLException { String sql = CRC . getInsert ( ) ; try ( PreparedStatement stmt = c . prepareStatement ( sql ) ) { CRC . crc . set ( stmt , 1 , crc ) ; CRC . path . set ( stmt , 2 , path ) ; CRC . name . set ( stmt , 3 , name ) ; CRC . date . set ( stmt , 4 , new Timestamp ( modDate ) ) ; stmt . execute ( ) ; } } public long getCrcRecordCount ( Connection c ) throws SQLException { final String q = CRC . getSelect ( ) ; long n = 0 ; try ( PreparedStatement stmt = c . prepareStatement ( q ) ) { try ( ResultSet rs = stmt . executeQuery ( ) ) { while ( rs . next ( ) ) { n ++ ; } } } return n ; } public List < CrcRecord > listCrcRecords ( Connection c , String path ) throws SQLException { final String q = CRC . getSelect ( ) + \" WHERE \" + CRC . path . getName ( ) + \" = ?\" ; List < CrcRecord > oldRecords = new ArrayList < > ( ) ; try ( PreparedStatement stmt = c . prepareStatement ( q ) ) { CRC . path . set ( stmt , 1 , path ) ; try ( ResultSet rs = stmt . executeQuery ( ) ) { while ( rs . next ( ) ) { long crc = CRC . crc . get ( rs ) ; String name = CRC . name . get ( rs ) ; Timestamp date = CRC . date . get ( rs ) ; CrcRecord r = new CrcRecord ( crc , name , date ) ; oldRecords", "gt": ". add ( r ) ;", "prediction": ";\n", "label": 1}
{"id": 6583, "input": "<s> package org . globaleaks . android . net ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import org . apache . http . HttpEntity ; import org . apache . http . HttpHost ; import org . apache . http . HttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . conn . params . ConnRoutePNames ; import org . apache . http . impl . client . DefaultHttpClient ; import org . globaleaks . android . MainActivity ; import org . globaleaks . android . TulipActivity ; import android . app . Activity ; import android . app . ProgressDialog ; import android . content . Intent ; import android . database . Cursor ; import android . net . Uri ; import android . os . AsyncTask ; import android . os . Bundle ; import android . provider . MediaStore ; import android . util . Log ; public class WebClient { private static final String LOG_TAG = \"WebClient\" ; private final DefaultHttpClient http ; private final String baseUrl ; private final Activity ctx ; public WebClient ( String baseUrl , MainActivity ctx ) { this . ctx = ctx ; http = new DefaultHttpClient ( ) ; if ( ctx . torProxy ( ) ) { HttpHost httpproxy = new HttpHost ( \"127.0.0.1\" , 8118 ) ; http . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , httpproxy ) ; } this . baseUrl = baseUrl ; } public void submit ( Intent data ) throws Exception { final Bundle bundle = data . getExtras ( ) ; final String imgUri = bundle . getString ( \"img\" ) ; final ProgressDialog dialog = new ProgressDialog ( ctx ) ; dialog . setProgressStyle ( ProgressDialog . STYLE_HORIZONTAL ) ; dialog . setTitle ( \"Submission\" ) ; dialog . setMessage ( \"Uploading material...\" ) ; dialog . show ( ) ; AsyncTask < Void , Long , Boolean > task = new AsyncTask < Void , Long , Boolean > ( ) { private String tulip ; @ Override protected void onProgressUpdate ( Long ... values ) { if ( values == null || values [ 0 ] == null ) return ; dialog . setProgress ( values [ 0 ] . intValue ( ) ) ; } @ Override protected Boolean doInBackground ( Void ... voids ) { publishProgress ( 0L ) ; final String formKey = parseFormKey ( ) ; publishProgress ( 10L ) ; if ( formKey == null ) { Log . e ( LOG_TAG , \"Error getting formKey\" ) ; return false ; } tulip = submitLeak ( formKey , bundle ) ; publishProgress ( 20L ) ; try { if ( imgUri == null ) { publishProgress ( 100L ) ; return true ; } final long imgSize = getImageSize ( imgUri , ctx ) ; InputStream input = ctx . getContentResolver ( ) . openInputStream ( Uri . parse ( imgUri ) ) ; HttpPost post = new HttpPost ( \"http://\" + baseUrl + \"/globaleaks/submission/upload?qqfile=image.png\" ) ; final long offset = 20L ; FilterStreamEntity entity = new FilterStreamEntity ( input , imgSize , new ProgressListener ( ) { @ Override public void transferred ( long num ) { Log . i ( LOG_TAG , \"Transferred \" + num + \" bytes\" ) ; long progress = num * 70 / imgSize ; publishProgress ( progress + offset ) ; } } ) ; post . setEntity ( entity ) ; HttpResponse resp = http . execute ( post ) ; publishProgress ( 100L ) ; HttpEntity he = resp . getEntity ( ) ; System . out . println ( convertStreamToString ( he . getContent ( ) ) ) ; } catch ( Exception e ) { Log . e", "gt": "( LOG_TAG , \"Error uploading file\" , e ) ;", "prediction": ";\n", "label": 0}
{"id": 4663, "input": "<s> package org . apache . lucene . queryParser . core . nodes ; import org . apache . lucene . queryParser . core . parser . EscapeQuerySyntax ; public class OpaqueQueryNode extends QueryNodeImpl { private static final long serialVersionUID = 0L ; private CharSequence schema = null ; private CharSequence value = null ; public OpaqueQueryNode ( CharSequence schema , CharSequence value ) { this . setLeaf ( true ) ; this . schema = schema ; this . value = value ; } public String toString ( ) { return \"<opaque schema='\" + this . schema + \"' value='\" + this . value + \"'/>\" ; } public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { return \"@\" + this . schema + \":'\" + this . value + \"'\" ; } public QueryNode cloneTree ( ) throws CloneNotSupportedException { OpaqueQueryNode clone = (", "gt": "OpaqueQueryNode ) super . cloneTree ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3817, "input": "<s> package dk . brics . automaton ; import java . io . IOException ; import java . io . InputStream ; import java . io . InvalidClassException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . OptionalDataException ; import java . io . OutputStream ; import java . io . Serializable ; import java . net . URL ; import java . util . Set ; public class RunAutomaton implements Serializable { static final long serialVersionUID = 20001 ; int size ; boolean [ ] accept ; int initial ; int [ ] transitions ; char [ ] points ; int [ ] classmap ; final void setAlphabet ( ) { classmap = new int [ Character . MAX_VALUE - Character . MIN_VALUE + 1 ] ; int i = 0 ; for ( int j = 0 ; j <= Character . MAX_VALUE - Character . MIN_VALUE ; j ++ ) { if ( i + 1 < points . length && j == points [ i + 1 ] ) i ++ ; classmap [ j ] = i ; } } @ Override public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( \"initial state: \" ) . append ( initial ) . append ( \"\\n\" ) ; for ( int i = 0 ; i < size ; i ++ ) { b . append ( \"state \" + i ) ; if ( accept [ i ] ) b . append ( \" [accept]:\\n\" ) ; else b . append ( \" [reject]:\\n\" ) ; for ( int j = 0 ; j < points . length ; j ++ ) { int k = transitions [ i * points . length + j ] ; if ( k != - 1 ) { char min = points [ j ] ; char max ; if ( j + 1 < points . length ) max = ( char ) ( points [ j + 1 ] - 1 ) ; else max = Character . MAX_VALUE ; b . append ( \" \" ) ; Transition . appendCharString ( min , b ) ; if ( min != max ) { b . append ( \"-\" ) ; Transition . appendCharString ( max , b ) ; } b . append ( \" -> \" ) . append ( k ) . append ( \"\\n\" ) ; } } } return b . toString ( ) ; } public int getSize ( ) { return size ; } public boolean isAccept ( int state ) { return accept [ state ] ; } public int getInitialState ( ) { return initial ; } public char [ ] getCharIntervals ( ) { return points . clone ( ) ; } int getCharClass ( char c ) { return SpecialOperations . findIndex ( c , points ) ; } @ SuppressWarnings ( \"unused\" ) private RunAutomaton ( ) { } public RunAutomaton ( Automaton a ) { this ( a , true ) ; } public static RunAutomaton load ( URL url ) throws IOException , OptionalDataException , ClassCastException , ClassNotFoundException , InvalidClassException { return load ( url . openStream ( ) ) ; } public static RunAutomaton load ( InputStream stream", "gt": ") throws IOException , OptionalDataException , ClassCastException , ClassNotFoundException , InvalidClassException", "prediction": ")\n", "label": 0}
{"id": 4673, "input": "<s> package org . eclipse . swt . accessibility ; import org . eclipse . swt . internal . SWTEventListener ; public interface AccessibleEditableTextListener extends SWTEventListener { public void copyText ( AccessibleEditableTextEvent e ) ; public void cutText ( AccessibleEditableTextEvent e ) ; public void pasteText ( AccessibleEditableTextEvent e ) ; public void replaceText ( AccessibleEditableTextEvent e ) ; public void setTextAttributes", "gt": "( AccessibleTextAttributeEvent e ) ;", "prediction": "( )\n", "label": 1}
{"id": 10089, "input": "<s> package org . gk . engine . client . build . form . field ; import java . util . Map ; import org . gk . engine . client . utils . IRegExpUtils ; import org . gk . ui . client . binding . gkFieldBinding ; import org . gk . ui . client . binding . gkNumberFieldBinding ; import org . gk . ui . client . com . panel . gkFormPanelIC ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . SliderEvent ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . Slider ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . PropertyEditor ; import com . extjs . gxt . ui . client . widget . form . SliderField ; public class SliderFieldBuilder extends FormFieldBuilder { public SliderFieldBuilder ( String fieldType ) { super ( fieldType ) ; } @ Override public Component create ( ) { Field field = createField ( ) ; initField ( field ) ; return field ; } @ Override public Component create ( gkFormPanelIC form ) { SliderField field = createField ( ) ; gkFieldBinding fb = new gkNumberFieldBinding ( field , getField ( ) . getName ( ) , ( Map ) form . getInfo ( ) ) ; form . addFieldBinding ( fb ) ; initField ( field ) ; return field ; } private SliderField createField ( ) { String inc = getField ( ) . getAttribute ( \"inc\" , \"\" ) ; String max = getField ( ) . getAttribute ( \"max\" , \"\" ) ; String min = getField ( ) . getAttribute ( \"min\" , \"\" ) ; String clickToChange = getField ( ) . getAttribute ( \"clickToChange\" , \"true\" ) ; final Slider slider = new Slider ( ) ; if ( inc . matches ( IRegExpUtils . INTEGER ) ) { slider . setIncrement ( Integer . parseInt ( inc ) ) ; } if ( max . matches ( IRegExpUtils . INTEGER ) ) { slider . setMaxValue ( Integer .", "gt": "parseInt ( max ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4680, "input": "<s> package org . eclipse . swt . internal . widgets . tabitemkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import java . io . IOException ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . swt . internal . widgets . ItemLCAUtil ; import org . eclipse . swt . widgets . * ; public class TabItemLCA extends AbstractWidgetLCA { private static final String TYPE = \"rwt.widgets.TabItem\" ; private static final String PROP_CONTROL = \"control\" ; @ Override public void preserveValues ( Widget widget ) { TabItem item = ( TabItem ) widget ; WidgetLCAUtil . preserveCustomVariant ( item ) ; WidgetLCAUtil . preserveToolTipText ( item , item . getToolTipText ( ) ) ; ItemLCAUtil . preserve ( item ) ; preserveProperty ( item , PROP_CONTROL , item . getControl ( ) ) ; } public void readData ( Widget widget ) { } @ Override public void renderInitialization ( Widget widget ) throws IOException { TabItem tabItem = ( TabItem ) widget ; TabFolder parent = tabItem . getParent ( ) ; IClientObject clientObject = ClientObjectFactory . getClientObject ( tabItem ) ; clientObject . create ( TYPE ) ; clientObject . set ( \"id\" , WidgetUtil . getId ( tabItem ) ) ; clientObject . set ( \"parent\" , WidgetUtil . getId ( parent ) ) ; clientObject . set ( \"index\" , parent . indexOf ( tabItem ) ) ; } @ Override public void renderChanges ( Widget widget ) throws IOException { TabItem tabItem = ( TabItem ) widget ; WidgetLCAUtil . renderCustomVariant ( tabItem ) ; WidgetLCAUtil . renderToolTip", "gt": "( tabItem , tabItem . getToolTipText ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8943, "input": "<s> package org . remast . swing . util ; import java . io . File ; import javax . swing . filechooser . FileFilter ; import org . remast . util . TextResourceBundle ; public abstract class FileFilters { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( FileFilters . class ) ; public static final class ICalFileFilter extends FileFilter { @ Override public boolean accept ( final File file ) { return file . isDirectory ( ) || file . getName ( ) . endsWith ( \".ics\" ) ; } @ Override public String getDescription ( ) { return textBundle . textFor ( \"FileFilters.ICalFile\" ) ; } } public static final class ExcelFileFilter extends FileFilter { @ Override public boolean accept ( final File file ) { return file . isDirectory ( ) || file . getName ( ) . endsWith ( \".xlsx\" ) ; } @ Override public String getDescription ( ) { return textBundle . textFor ( \"FileFilters.MicrosoftExcelFile\" ) ; } } public static final class CsvFileFilter extends FileFilter { @ Override public boolean accept ( final File file ) { return file . isDirectory ( ) || file . getName ( ) . endsWith ( \".csv\" ) ; } @ Override public String getDescription ( ) { return textBundle . textFor ( \"FileFilters.CommaSeparatedValuesFile\" ) ; } } public static final class DataFileFilter extends FileFilter { @ Override public boolean", "gt": "accept ( final File file )", "prediction": "( )\n", "label": 0}
{"id": 4684, "input": "<s> package org . modelgoon . core . editparts ; import org . eclipse . gef . commands . Command ; import org . eclipse . gef . editpolicies . DirectEditPolicy ; import org . eclipse . gef . requests . DirectEditRequest ; import org . modelgoon . core . NoteFigure ; public class NoteDirectEditPolicy extends DirectEditPolicy { @ Override protected Command getDirectEditCommand ( final DirectEditRequest request ) { String labelText = ( String ) request . getCellEditor ( ) . getValue ( ) ; NoteEditPart", "gt": "label = ( NoteEditPart ) getHost ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4065, "input": "<s> package Liza ; import org . bukkit . entity . EnderPearl ;", "gt": "public interface LizaEnderPearl extends EnderPearl", "prediction": "}\n", "label": 0}
{"id": 4693, "input": "<s> package org . eclipse . ui . internal ; public interface IWorkbenchThemeConstants { public static final String TAB_TEXT_FONT = \"org.eclipse.ui.workbench.TAB_TEXT_FONT\" ; public static final String VIEW_MESSAGE_TEXT_FONT = \"org.eclipse.ui.workbench.VIEW_MESSAGE_TEXT_FONT\" ; public static final String ACTIVE_TAB_TEXT_COLOR = \"org.eclipse.ui.workbench.ACTIVE_TAB_TEXT_COLOR\" ; public static final String ACTIVE_NOFOCUS_TAB_TEXT_COLOR = \"org.eclipse.ui.workbench.ACTIVE_NOFOCUS_TAB_TEXT_COLOR\" ; public static final String INACTIVE_TAB_TEXT_COLOR = \"org.eclipse.ui.workbench.INACTIVE_TAB_TEXT_COLOR\" ; public static final String ACTIVE_TAB_BG_START = \"org.eclipse.ui.workbench.ACTIVE_TAB_BG_START\" ; public static final String ACTIVE_TAB_BG_END = \"org.eclipse.ui.workbench.ACTIVE_TAB_BG_END\" ; public static final String ACTIVE_TAB_HIGHLIGHT = \"org.eclipse.ui.workbench.ACTIVE_TAB_HIGHLIGHT\" ; public static final String ACTIVE_TAB_HIGHLIGHT_START = \"org.eclipse.ui.workbench.ACTIVE_TAB_HIGHLIGHT_START\" ; public static final String ACTIVE_NOFOCUS_TAB_BG_START = \"org.eclipse.ui.workbench.ACTIVE_NOFOCUS_TAB_BG_START\" ; public static final String ACTIVE_NOFOCUS_TAB_BG_END = \"org.eclipse.ui.workbench.ACTIVE_NOFOCUS_TAB_BG_END\" ; public static final String INACTIVE_TAB_BG_START = \"org.eclipse.ui.workbench.INACTIVE_TAB_BG_START\" ; public static final String INACTIVE_TAB_BG_END = \"org.eclipse.ui.workbench.INACTIVE_TAB_BG_END\" ; public static final String ACTIVE_TAB_PERCENT = \"org.eclipse.ui.workbench.ACTIVE_TAB_PERCENT\" ; public", "gt": "static final String ACTIVE_NOFOCUS_TAB_PERCENT = \"org.eclipse.ui.workbench.ACTIVE_NOFOCUS_TAB_PERCENT\" ;", "prediction": "____________________________________________________________________________________________________\n", "label": 1}
{"id": 9406, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Pig ; public interface LizaPig extends Pig { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte >", "gt": "transparent , int maxDistance ) ;", "prediction": ")\n", "label": 0}
{"id": 4720, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . tests . harness . util . ActionUtil ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class IActionFilterTest extends UITestCase { protected IWorkbenchWindow fWindow ; protected IWorkbenchPage fPage ; protected String STATIC_MENU_VIEW_ID = \"org.eclipse.ui.tests.api.IActionFilterTest1\" ; protected String DYNAMIC_MENU_VIEW_ID = \"org.eclipse.ui.tests.api.IActionFilterTest2\" ; public IActionFilterTest ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; fWindow = openTestWindow ( ) ; fPage = fWindow . getActivePage ( ) ; } public void testStaticLifecycle ( ) throws Throwable { testLifecycle ( STATIC_MENU_VIEW_ID ) ; } public void testDynamicLifecycle ( ) throws Throwable { testLifecycle ( DYNAMIC_MENU_VIEW_ID ) ; } private void testLifecycle ( String viewId ) throws Throwable { ListView view = ( ListView ) fPage . showView ( viewId ) ; ListElement red = new ListElement ( \"red\" ) ; view . addElement ( red ) ; view . selectElement ( red ) ; ListElementActionFilter filter = ListElementActionFilter . getSingleton ( ) ; MenuManager menuMgr = view . getMenuManager ( ) ; ActionUtil . fireAboutToShow ( menuMgr ) ; assertTrue ( filter . getCalled ( ) ) ; } public void testDynamicMenuContribution ( ) throws Throwable { testMenu ( DYNAMIC_MENU_VIEW_ID ) ; } public void testStaticMenuContribution ( ) throws Throwable { testMenu ( STATIC_MENU_VIEW_ID ) ; } private void testMenu ( String viewId ) throws Throwable { ListElement red = new ListElement ( \"red\" ) ; ListElement blue = new ListElement ( \"blue\" ) ; ListElement green = new ListElement ( \"green\" ) ; ListElement redTrue = new ListElement ( \"red\" , true ) ; ListView view = ( ListView ) fPage . showView ( viewId ) ; MenuManager menuMgr = view . getMenuManager ( ) ; view . addElement ( red ) ; view . addElement ( blue ) ; view . addElement ( green ) ; view . addElement ( redTrue ) ; ListElementActionFilter filter = ListElementActionFilter . getSingleton ( ) ; view . selectElement ( red ) ; ActionUtil . fireAboutToShow ( menuMgr ) ; assertTrue ( filter . getCalled ( ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"blueAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"trueAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"falseAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redTrueAction_v1\" ) ) ; view . verifyActions ( this , menuMgr ) ; filter . clearCalled ( ) ; view . selectElement ( blue ) ; ActionUtil . fireAboutToShow ( menuMgr ) ; assertTrue ( filter . getCalled ( ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"blueAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"trueAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"falseAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redTrueAction_v1\" ) ) ; view . verifyActions ( this , menuMgr ) ; filter . clearCalled ( ) ; view . selectElement ( green ) ; ActionUtil . fireAboutToShow ( menuMgr ) ; assertTrue ( filter . getCalled ( ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"blueAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"trueAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"falseAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redTrueAction_v1\" ) ) ; view . verifyActions ( this , menuMgr ) ; filter . clearCalled ( ) ; view . selectElement ( redTrue ) ; ActionUtil . fireAboutToShow ( menuMgr ) ; assertTrue ( filter . getCalled ( ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"blueAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"trueAction_v1\" ) ) ; assertNull ( ActionUtil . getActionWithLabel ( menuMgr , \"falseAction_v1\" ) ) ; assertNotNull ( ActionUtil . getActionWithLabel ( menuMgr , \"redTrueAction_v1\" ) ) ; view . verifyActions ( this , menuMgr ) ; filter . clearCalled ( ) ; view . selectElement ( null ) ; ActionUtil", "gt": ". fireAboutToShow ( menuMgr ) ;", "prediction": ";\n", "label": 1}
{"id": 8440, "input": "<s> package com . toedter . gwt . demo . contacts . client . mvp ; import com . google . gwt . activity . shared . Activity ; import com . google . gwt . activity . shared . ActivityMapper ; import com . google . gwt . place . shared . Place ; import com . toedter . gwt . demo . contacts . client . IClientFactory ; import com . toedter . gwt . demo . contacts . client . activity . ContactListActivity ; import com . toedter . gwt . demo . contacts . client . place . ContactPlace ; public class WestActivityMapper implements ActivityMapper { private final IClientFactory clientFactory ; public WestActivityMapper ( IClientFactory clientFactory ) { super ( ) ; this . clientFactory = clientFactory ; } @ Override public Activity getActivity ( Place place ) { if ( place instanceof ContactPlace ) { return new ContactListActivity ( (", "gt": "ContactPlace ) place , clientFactory ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4724, "input": "<s> package org . restlet . test . ext . jaxrs . services . providers ; import javax", "gt": ". ws . rs . ext . Provider ;", "prediction": ";\n", "label": 1}
{"id": 7578, "input": "<s> package com . ui ; import android . os . Handler ; import android . os . Message ; public class UpdateDelayHandler extends Handler { GraphPlotter xyActivity ; int i = 0 ; public UpdateDelayHandler ( GraphPlotter xyActivity ) { super ( ) ; this . xyActivity = xyActivity ; }", "gt": "public void handleMessage ( Message msg )", "prediction": "}\n", "label": 0}
{"id": 4725, "input": "<s> package org . json ; public class HTTPTokener extends JSONTokener { public HTTPTokener ( String string ) { super ( string ) ; } public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == '\"' || c == '\\'' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c < ' ' ) { throw syntaxError ( \"Unterminated string.\" ) ; } if ( c == q ) {", "gt": "return sb . toString ( ) ;", "prediction": "\n", "label": 1}
{"id": 86, "input": "<s> public class AccessMethodsLHS { static void fail ( String msg ) throws Exception { throw new Exception ( \"FAIL: \" + msg ) ; } static int arg = 123456 ; private int i ; private double d ; private void m ( int x ) throws Exception { System . out . println ( \"called AccessMethodsLHS.m\" ) ; if ( x != 123456 ) AccessMethodsLHS . fail ( \"bad argument\" ) ; } public static class Bar { private int i ; private double d ; private String s ; private void m ( int x ) throws Exception { System . out . println ( \"called AccessMethodsLHS.Bar.m\" ) ; if ( x != 123456 ) AccessMethodsLHS . fail ( \"bad argument\" ) ; } static private int si ; static private double sd ; static private String ss ; static private void sm ( int x ) throws Exception { System . out . println ( \"called AccessMethodsLHS.Bar.sm\" ) ; if ( x != 123456 ) AccessMethodsLHS . fail ( \"bad argument\" ) ; } } public static class Baz { private int i ; private double d ; private String s ; private void m ( int x ) throws Exception { System . out . println ( \"called Baz.m\" ) ; if ( x != 123456 ) AccessMethodsLHS . fail ( \"bad argument\" ) ; } } public class Quux { void DoIt ( ) throws Exception { m ( arg ) ; i = 1 ; d = 1.0 ; i += 5 ; i -- ; } void DoMore ( AccessMethodsLHS f ) throws Exception { f . m ( arg ) ; } } public static class Quem { void DoIt ( ) { } } static int effects = 0 ; static Bar iBar ( Bar x ) { effects ++ ; return x ; } static Baz iBaz ( Baz x ) { effects ++ ; return x ; } static void checkEffects ( int i ) throws Exception { if ( effects != 1 ) { AccessMethodsLHS . fail ( \"incorrect side-effect behavior (\" + effects + \"): \" + i ) ; } effects = 0 ; } static public void main ( String args [ ] ) throws Exception { Bar b = new Bar ( ) ; Baz c = new Baz ( ) ; System . out . println ( \"testing assignment\" ) ; AccessMethodsLHS f = new AccessMethodsLHS ( ) ; Quux q1 = f . new Quux ( ) ; q1 . DoIt ( ) ; q1 . DoMore ( f ) ; Quem q2 = new Quem ( ) ; q2 . DoIt ( ) ; b . m ( arg ) ; b . i = 5 ; System . out . println ( b . i ) ; if ( b . i != 5 ) AccessMethodsLHS . fail ( \"simple assignment\" ) ; System . out . println ( b . i ) ; if ( ( b . i += 10 ) != 15 ) AccessMethodsLHS . fail ( \"add-assign result\" ) ; System . out . println ( b . i ) ; if ( b . i != 15 ) AccessMethodsLHS . fail ( \"add-assign effect\" ) ; System . out . println ( b . i ) ; b . s = \"foo\" ; if ( ! ( b . s += \"bar\" ) . equals ( \"foobar\" ) ) AccessMethodsLHS . fail ( \"concat-assign result\" ) ; System . out . println ( b . s ) ; if ( ! b . s . equals ( \"foobar\" ) ) AccessMethodsLHS . fail ( \"concat-assign effect\" ) ; System . out . println ( b . s ) ; b . s = \"foo\" ; b . s += \"bar\" ; if ( ! b . s . equals ( \"foobar\" ) ) AccessMethodsLHS . fail ( \"concat-assign effect (novalue)\" ) ; System . out . println ( b . s ) ; b . i = 0 ; b . i ++ ; if ( b . i != 1 ) AccessMethodsLHS . fail ( \"post-increment effect\" ) ; System . out . println ( b . i ) ; b . i = 5 ; if ( b . i ++ != 5 ) AccessMethodsLHS . fail ( \"post-increment result\" ) ; if ( b . i != 6 ) AccessMethodsLHS . fail ( \"post-increment effect (embedded)\" ) ; System . out . println ( b . i ) ; b . i = 1 ; -- b . i ; if ( b . i != 0 ) AccessMethodsLHS . fail ( \"pre-decrement effect\" ) ; b . i = 5 ; if ( -- b . i != 4 ) AccessMethodsLHS . fail ( \"pre-decrement result\" ) ; if ( b . i != 4 ) AccessMethodsLHS . fail ( \"pre-decrement effect (embedded)\" ) ; System . out . println ( b . i ) ; b . d = 5.0 ; System . out . println ( b . d ) ; if ( b . d != 5.0 ) AccessMethodsLHS . fail ( \"simple assignment\" ) ; System . out . println ( b . d ) ; if ( ( b . d += 10 ) != 15.0 ) AccessMethodsLHS . fail ( \"add-assign result\" ) ; System . out . println ( b . d ) ; if ( b . d != 15.0 ) AccessMethodsLHS . fail ( \"add-assign effect\" ) ; System . out . println ( b . d ) ; b", "gt": ". d = 0.0 ;", "prediction": ";\n", "label": 0}
{"id": 4741, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers . provider ; import java . io . IOException ; import java . io . InputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Type ; import java . util . List ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MultivaluedMap ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; public interface MessageBodyReader { public List < MediaType > getConsumedMimes ( ) ; public javax . ws . rs . ext . MessageBodyReader < ? > getJaxRsReader ( ) ; public boolean isReadable ( Class < ? > type , Type genericType , Annotation annotations [ ] , javax . ws . rs . core . MediaType mediaType ) ; public Object readFrom ( Class < ? > type , Type genericType , Annotation annotations [ ] , MediaType mediaType , CharacterSet characterSet , MultivaluedMap < String , String > httpHeaders , InputStream entityStream )", "gt": "throws IOException , WebApplicationException , InvocationTargetException ;", "prediction": ";\n", "label": 1}
{"id": 4166, "input": "<s> package org . parboiled . transform ; import org . parboiled . common . ImmutableList ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import java . io . IOException ; import java . util . List ; import static org . parboiled . transform . AsmTestUtils . assertTraceDumpEquality ; public class CachingGeneratorTest extends TransformationTest { private final List < RuleMethodProcessor > processors = ImmutableList . of ( new BodyWithSuperCallReplacer ( ) , new LabellingGenerator ( ) , new FlagMarkingGenerator ( ) , new CachingGenerator ( ) ) ; @ BeforeClass public void setup ( ) throws IOException { setup ( TestParser . class ) ; } @ SuppressWarnings ( { \"unchecked\" } ) @ Test public void test ( ) throws Exception { assertTraceDumpEquality ( processMethod ( \"RuleWithoutAction\" , processors ) , \"\" + \"    ALOAD 0\\n\" + \"    GETFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithoutAction : Lorg/parboiled/Rule;\\n\" + \"    DUP\\n\" + \"    IFNULL L0\\n\" + \"    ARETURN\\n\" + \"   L0\\n\" + \"    POP\\n\" + \"    NEW org/parboiled/matchers/ProxyMatcher\\n\" + \"    DUP\\n\" + \"    INVOKESPECIAL org/parboiled/matchers/ProxyMatcher.<init> ()V\\n\" + \"    DUP\\n\" + \"    ALOAD 0\\n\" + \"    SWAP\\n\" + \"    PUTFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithoutAction : Lorg/parboiled/Rule;\\n\" + \"    ALOAD 0\\n\" + \"    INVOKESPECIAL org/parboiled/transform/TestParser.RuleWithoutAction ()Lorg/parboiled/Rule;\\n\" + \"    DUP\\n\" + \"    IFNULL L1\\n\" + \"    LDC \\\"RuleWithoutAction\\\"\\n\" + \"    INVOKEINTERFACE org/parboiled/Rule.label (Ljava/lang/String;)Lorg/parboiled/Rule;\\n\" + \"   L1\\n\" + \"    DUP_X1\\n\" + \"    CHECKCAST org/parboiled/matchers/Matcher\\n\" + \"    INVOKEVIRTUAL org/parboiled/matchers/ProxyMatcher.arm (Lorg/parboiled/matchers/Matcher;)V\\n\" + \"    DUP\\n\" + \"    ALOAD 0\\n\" + \"    SWAP\\n\" + \"    PUTFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithoutAction : Lorg/parboiled/Rule;\\n\" + \"    ARETURN\\n\" ) ; assertTraceDumpEquality ( processMethod ( \"RuleWithNamedLabel\" , processors ) , \"\" + \"  @Lorg/parboiled/annotations/Label;(value=\\\"harry\\\")\\n\" + \"    ALOAD 0\\n\" + \"    GETFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithNamedLabel : Lorg/parboiled/Rule;\\n\" + \"    DUP\\n\" + \"    IFNULL L0\\n\" + \"    ARETURN\\n\" + \"   L0\\n\" + \"    POP\\n\" + \"    NEW org/parboiled/matchers/ProxyMatcher\\n\" + \"    DUP\\n\" + \"    INVOKESPECIAL org/parboiled/matchers/ProxyMatcher.<init> ()V\\n\" + \"    DUP\\n\" + \"    ALOAD 0\\n\" + \"    SWAP\\n\" + \"    PUTFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithNamedLabel : Lorg/parboiled/Rule;\\n\" + \"    ALOAD 0\\n\" + \"    INVOKESPECIAL org/parboiled/transform/TestParser.RuleWithNamedLabel ()Lorg/parboiled/Rule;\\n\" + \"    DUP\\n\" + \"    IFNULL L1\\n\" + \"    LDC \\\"harry\\\"\\n\" + \"    INVOKEINTERFACE org/parboiled/Rule.label (Ljava/lang/String;)Lorg/parboiled/Rule;\\n\" + \"   L1\\n\" + \"    DUP_X1\\n\" + \"    CHECKCAST org/parboiled/matchers/Matcher\\n\" + \"    INVOKEVIRTUAL org/parboiled/matchers/ProxyMatcher.arm (Lorg/parboiled/matchers/Matcher;)V\\n\" + \"    DUP\\n\" + \"    ALOAD 0\\n\" + \"    SWAP\\n\" + \"    PUTFIELD org/parboiled/transform/TestParser$$parboiled.cache$RuleWithNamedLabel :", "gt": "Lorg/parboiled/Rule;\\n\" + \"    ARETURN\\n\" ) ;", "prediction": ";\n", "label": 0}
{"id": 4743, "input": "<s> package de . uos . igf . db3d . dbms . util ; import java . util . Collection ; import de . uos . igf . db3d . dbms . api . DB3DException ; import de . uos . igf . db3d . dbms . geom . Equivalentable ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; public final class EquivalentableHashSet extends AbstractHashSet { private final ScalarOperator sop ; private byte equConst = - 1 ; private final int factor ; public EquivalentableHashSet ( ScalarOperator _sop , int equivalConstant ) { super ( ) ; this . sop = _sop ; this . equConst = ( byte ) equivalConstant ; this . factor = computeFactor ( this . sop ) ; } public EquivalentableHashSet ( int initialCapacity , ScalarOperator _sop , int equivalConstant ) { super ( initialCapacity ) ; this . sop = _sop ; this . equConst = ( byte ) equivalConstant ; this . factor = computeFactor ( this . sop ) ; } public EquivalentableHashSet ( int initialCapacity , float loadFactor , ScalarOperator _sop , int equivalConstant ) { super ( initialCapacity , loadFactor ) ; this . sop = _sop ; this . equConst = ( byte ) equivalConstant ; this . factor = computeFactor ( this . sop ) ; } public EquivalentableHashSet ( Collection c , ScalarOperator _sop , int equivalConstant ) { super ( ) ; this . sop = _sop ; this . equConst = ( byte ) equivalConstant ; this . factor = computeFactor ( this . sop ) ; addAll ( c ) ; } protected boolean equalityTest ( Object key , Object key2 ) { switch ( getEquivalentableConstant ( ) ) { case Equivalentable . GEOMETRY_EQUIVALENT : return ( ( Equivalentable ) key ) . isGeometryEquivalent ( ( Equivalentable ) key2 , this . sop ) ; case Equivalentable . STRICT_EQUAL : return ( ( Equivalentable ) key ) . isEqual ( ( Equivalentable ) key2 , this . sop ) ; default : return false ; } } protected int hashOfObject ( Object key ) { switch ( getEquivalentableConstant ( ) ) { case Equivalentable . GEOMETRY_EQUIVALENT : return ( ( Equivalentable ) key ) . isGeometryEquivalentHC ( this . factor ) ; case Equivalentable . STRICT_EQUAL : return ( ( Equivalentable", "gt": ") key ) . isEqualHC ( this . factor ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4307, "input": "<s> package org . ofbiz . base . lang ; public interface Factory < R , A > {", "gt": "public R getInstance ( A obj ) ;", "prediction": "return ;\n", "label": 0}
{"id": 4753, "input": "<s> package org . eclipse . ui . internal . presentations ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . presentations . IStackPresentationSite ;", "gt": "public class SystemMenuRestore extends SystemMenuStateChange", "prediction": "}\n", "label": 1}
{"id": 9471, "input": "<s> import java . util . Set ; import java . util . Collections ; import javax . lang . model . element . TypeElement ; import javax . annotation . processing . * ; import com . sun . tools . javac . processing . AnnotationProcessingError ; public class T6412656 extends ToolTester { int count = 0 ; void test ( String ... args ) { task = tool . getTask ( null , fm , null , null , Collections . singleton ( T6412656 . class . getName ( ) ) , null ) ; task . setProcessors ( Collections . singleton ( new MyProc ( this ) ) ) ; task . call ( ) ; if ( count == 0 ) throw new AssertionError ( \"Annotation processor not run\" ) ; System . out . println ( \"OK\" ) ; } public", "gt": "static void main ( String ... args )", "prediction": "}\n", "label": 0}
{"id": 4778, "input": "<s> package org . spliffy . server . db . utils ; import org . hibernate . Session ; import org . hibernate . SessionFactory ; import org . springframework . orm . hibernate3 . SessionFactoryUtils ; public class SessionManager { private static ThreadLocal < Session > tlSession = new ThreadLocal < > ( ) ; public static Session session ( ) { return tlSession . get ( ) ; } private final SessionFactory sessionFactory ; public SessionManager ( SessionFactory sessionFactory ) { this . sessionFactory = sessionFactory ; } public Session open ( ) { Session session = SessionFactoryUtils . getSession ( sessionFactory , true ) ; tlSession . set ( session ) ; return session ; } public void close ( ) { Session s = session ( ) ; if ( s != null ) {", "gt": "SessionFactoryUtils . closeSession ( s ) ;", "prediction": "}\n", "label": 1}
{"id": 1975, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect . model ; import java . util . List ; import com . redhat . ceylon . compiler . java . util . Util ; import com . redhat . ceylon . compiler . loader . AbstractModelLoader ; import com . redhat . ceylon . compiler . loader . impl . reflect . ReflectionModelLoader ; import com . redhat . ceylon . compiler . loader . model . LazyModuleManager ; import com . redhat . ceylon . compiler . typechecker . TypeChecker ; import com . redhat . ceylon . compiler . typechecker . context . Context ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . Modules ; public class ReflectionModuleManager extends LazyModuleManager { private AbstractModelLoader modelLoader ; public ReflectionModuleManager ( Context context ) { super ( context ) ; } @ Override public void initCoreModules ( ) { super . initCoreModules ( ) ; Modules modules = getContext ( ) . getModules ( ) ; Module languageModule = modules . getLanguageModule ( ) ; languageModule . setVersion ( TypeChecker . LANGUAGE_MODULE_VERSION ) ; } @ Override public AbstractModelLoader getModelLoader ( ) { if ( modelLoader == null ) { Modules modules = getContext ( ) . getModules ( ) ; modelLoader = createModelLoader ( modules ) ; } return modelLoader ; } protected AbstractModelLoader createModelLoader ( Modules modules ) { return new ReflectionModelLoader ( this , modules ) ; } @ Override protected Module createModule ( List < String > moduleName , String version ) { Module module ; if ( isModuleLoadedFromSource ( Util . getName ( moduleName ) ) ) module = new Module ( ) ; else module = new", "gt": "ReflectionModule ( this ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4795, "input": "<s> package org . eclipse . ui . internal ; public interface IChangeListener {", "gt": "void update ( boolean changed ) ;", "prediction": ";\n", "label": 1}
{"id": 9399, "input": "<s> package org . ofbiz . product . imagemanagement ; import java . io . IOException ; import java . util . List ; import javax . servlet . RequestDispatcher ; import javax . servlet . ServletConfig ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; @ SuppressWarnings ( \"serial\" ) public class ImageUrlServlet extends HttpServlet { public static final String module = ImageUrlServlet . class . getName ( ) ; public ImageUrlServlet ( ) { super ( ) ; } @ Override public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; } @ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { doGet ( request , response ) ; } @ Override public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { Delegator delegator = ( Delegator ) getServletContext ( ) . getAttribute ( \"delegator\" ) ; String pathInfo = request . getPathInfo ( ) ; List < String > pathElements = StringUtil . split ( pathInfo , \"/\" ) ; List < String > tagElements = FastList . newInstance ( ) ; for ( String pathElement : pathElements ) { tagElements . addAll ( StringUtil . split ( pathElement , \"-\" ) ) ; } String lastTagElement = tagElements . get ( tagElements . size ( ) - 1 ) ; String contentId = lastTagElement . substring ( 0 , lastTagElement . lastIndexOf ( \".\" ) ) ; String sizeTagElement = null ; if ( tagElements . size ( ) > 2 ) { sizeTagElement = tagElements . get ( tagElements . size ( ) - 2 ) ; } GenericValue content = null ; try { GenericValue contentResult = delegator . findOne ( \"Content\" , UtilMisc . toMap ( \"contentId\" , contentId ) , false ) ; if ( contentResult == null ) { content = delegator . findOne ( \"Content\" , UtilMisc . toMap ( \"contentId\" , sizeTagElement ) , false ) ; } else { content = delegator . findOne ( \"Content\" , UtilMisc . toMap ( \"contentId\" , contentId ) , false ) ; } } catch ( GenericEntityException e ) { Debug", "gt": ". logError ( e , module ) ;", "prediction": "\n", "label": 0}
{"id": 4799, "input": "<s> package com . emf4sw . rdf ; import org . eclipse . emf . ecore . EFactory ; public interface RDFFactory extends EFactory { RDFFactory eINSTANCE = com . emf4sw . rdf . impl . RDFFactoryImpl . init ( ) ; Namespace createNamespace ( ) ; DocumentGraph createDocumentGraph ( ) ; NamedGraph createNamedGraph ( ) ; Triple createTriple ( ) ; BlankNode createBlankNode ( ) ; TripleNode createTripleNode ( ) ; Resource createResource ( ) ; Property createProperty ( ) ; Datatype createDatatype ( ) ; Literal createLiteral ( ) ; RDFBag createRDFBag ( ) ; RDFAlt createRDFAlt ( ) ; RDFSeq createRDFSeq ( ) ; RDFList createRDFList ( ) ;", "gt": "RDFPackage getRDFPackage ( ) ;", "prediction": "}\n", "label": 1}
{"id": 671, "input": "<s> import java . util . Set ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; public class NoSupers extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement >", "gt": "tes , RoundEnvironment round )", "prediction": ")\n", "label": 0}
{"id": 4803, "input": "<s> package com . emf4sw . owl . resource ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . Resource . Factory ; public enum OWLFormats { OWL { @ Override public String value ( ) { return \"RDF/XML-ABBREV\" ; } @ Override public String extension ( ) { return \".owl\" ; } } , RDF { @ Override public String value ( ) { return \"RDF/XML-ABBREV\" ; } @ Override public String extension ( ) { return \".rdf\" ; } } , N3 { @ Override public String value ( ) { return \"N3\" ; } @ Override public String extension ( ) { return \".n3\" ; } } , TURTLE { @ Override public String value ( ) { return \"TTL\" ; } @ Override public String extension ( ) { return \".ttl\" ; } } , TRIPLES { @ Override public String value ( ) { return \"TRIPLES\" ; } @ Override public String extension ( ) { return \".nt\" ; } } , XMI { @ Override public String value ( ) { return \"XMI\" ; } @ Override public String extension ( ) { return \".xmi\" ; } } ; public", "gt": "abstract String value ( ) ;", "prediction": "}\n", "label": 1}
{"id": 1826, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import javax . tools . JavaCompiler . CompilationTask ; public class T6900149 { public static void main ( String [ ] args ) throws IOException { DiagnosticCollector < JavaFileObject > diag = new DiagnosticCollector < JavaFileObject > ( ) ; JavaCompiler compiler = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = compiler . getStandardFileManager ( null , null , null ) ; File emptyFile = File . createTempFile ( \"Empty\" , \".java\" ) ; File", "gt": "[ ] files = new File [ ]", "prediction": "}\n", "label": 0}
{"id": 4824, "input": "<s> package org . restlet . sandbox ; import java . security . GeneralSecurityException ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Cookie ; import org . restlet . data . CookieSetting ; import org . restlet . engine . util . Base64 ; import org . restlet . ext . crypto . internal . CryptoUtils ; import org . restlet . security . ChallengeAuthenticator ; import org . restlet . security . Verifier ; public abstract class CookieAuthenticator extends ChallengeAuthenticator { private volatile String cookieName ; private volatile String encryptAlgorithm ; private volatile byte [ ] encryptSecretKey ; public CookieAuthenticator ( Context context , boolean optional , ChallengeScheme challengeScheme , String realm , Verifier verifier ) { super ( context , optional , challengeScheme , realm , verifier ) ; this . cookieName = \"Credentials\" ; this . encryptAlgorithm = \"AES\" ; } public CookieAuthenticator ( Context context , boolean optional , ChallengeScheme challengeScheme , String realm ) { super ( context , optional , challengeScheme , realm ) ; } public CookieAuthenticator ( Context context , ChallengeScheme challengeScheme , String realm ) { super ( context , challengeScheme , realm ) ; } @ Override protected boolean authenticate ( Request request , Response response ) { Cookie credentialsCookie = request . getCookies ( ) . getFirst ( getCookieName ( ) ) ; if ( credentialsCookie != null ) { request . setChallengeResponse ( parseCredentials ( credentialsCookie . getValue ( ) ) ) ; } return super . authenticate ( request , response ) ; } @ Override protected int beforeHandle ( Request request , Response response ) { if ( isLoggingIn ( request , response ) ) { login ( request , response ) ; } else if ( isLoggingOut ( request , response ) ) { return logout ( request , response ) ; } return super . beforeHandle ( request , response ) ; } public String getCookieName ( ) { return cookieName ; } public String getEncryptAlgorithm ( ) { return encryptAlgorithm ; } public byte [ ] getEncryptSecretKey ( ) { return encryptSecretKey ; } public boolean isLoggingIn ( Request request , Response response ) { Cookie credentialsCookie = request . getCookies ( ) . getFirst ( getCookieName ( ) ) ; if ( credentialsCookie != null ) { return false ; } return true ; } public abstract boolean isLoggingOut ( Request request , Response response ) ; public abstract void login ( Request request , Response response ) ; protected int logout ( Request request , Response response ) { request . setChallengeResponse ( null ) ; CookieSetting credentialsCookie = getCredentialsCookie ( request , response ) ; credentialsCookie . setMaxAge ( 0 ) ; return STOP ; } protected String formatCredentials ( ChallengeResponse challenge ) throws GeneralSecurityException { StringBuffer sb = new StringBuffer ( ) ; StringBuffer isb = new StringBuffer ( ) ; String timeIssued = Long . toString ( System . currentTimeMillis ( ) ) ; int i = timeIssued . length ( ) ; sb . append ( timeIssued ) ; isb . append ( i ) ; String identifier = challenge . getIdentifier ( ) ; sb . append ( '/' ) ; sb . append ( identifier ) ; i += identifier . length ( ) + 1 ; isb . append ( ',' ) . append ( i ) ; sb . append ( '/' ) ; sb . append ( challenge . getSecret ( ) ) ; sb . append ( '/' ) ; sb . append ( isb ) ; return Base64 . encode ( CryptoUtils . encrypt ( getEncryptAlgorithm ( ) , getEncryptSecretKey ( ) , sb . toString ( ) ) , false ) ; } protected ChallengeResponse parseCredentials ( String cookieValue ) { byte [ ] encrypted = Base64 . decode ( cookieValue ) ; if ( encrypted == null ) { getLogger ( ) . warning ( \"Cannot decode cookie credentials : \" + cookieValue ) ; } try { String decrypted = CryptoUtils . decrypt ( getEncryptAlgorithm ( ) , getEncryptSecretKey ( ) , encrypted ) ; int lastSlash = decrypted . lastIndexOf ( '/' ) ; String [ ] indexes = decrypted . substring ( lastSlash + 1 ) . split ( \",\" ) ; int identifierIndex = Integer . parseInt ( indexes [ 0 ] ) ; int secretIndex = Integer . parseInt ( indexes [ 1 ] ) ; ChallengeResponse cr = new ChallengeResponse ( getScheme ( ) ) ; cr . setRawValue ( cookieValue ) ; cr . setTimeIssued ( Long . parseLong ( decrypted . substring ( 0 , identifierIndex ) ) ) ; cr . setIdentifier ( decrypted .", "gt": "substring ( identifierIndex + 1 , secretIndex ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4212, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class FieldWriterImpl extends AbstractMemberWriter implements FieldWriter , MemberSummaryWriter { public FieldWriterImpl ( SubWriterHolderWriter writer , ClassDoc classdoc ) { super ( writer , classdoc ) ; } public FieldWriterImpl ( SubWriterHolderWriter writer ) { super ( writer ) ; } public Content getMemberSummaryHeader ( ClassDoc classDoc , Content memberSummaryTree ) { memberSummaryTree . addContent ( HtmlConstants . START_OF_FIELD_SUMMARY ) ; Content memberTree = writer . getMemberTreeHeader ( ) ; writer . addSummaryHeader ( this , classDoc , memberTree ) ; return memberTree ; } public Content getFieldDetailsTreeHeader ( ClassDoc classDoc , Content memberDetailsTree ) { memberDetailsTree . addContent ( HtmlConstants . START_OF_FIELD_DETAILS ) ; Content fieldDetailsTree = writer . getMemberTreeHeader ( ) ; fieldDetailsTree . addContent ( writer . getMarkerAnchor ( \"field_detail\" ) ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . DETAILS_HEADING , writer . fieldDetailsLabel ) ; fieldDetailsTree . addContent ( heading ) ; return fieldDetailsTree ; } public Content getFieldDocTreeHeader ( FieldDoc field , Content fieldDetailsTree ) { fieldDetailsTree . addContent ( writer . getMarkerAnchor ( field . name ( ) ) ) ; Content fieldDocTree = writer . getMemberTreeHeader ( ) ; Content heading = new HtmlTree ( HtmlConstants . MEMBER_HEADING ) ; heading . addContent ( field . name ( ) ) ; fieldDocTree . addContent ( heading ) ; return fieldDocTree ; } public Content getSignature ( FieldDoc field ) { Content pre = new HtmlTree ( HtmlTag . PRE ) ; writer . addAnnotationInfo ( field , pre ) ; addModifiers ( field , pre ) ; Content fieldlink = new RawHtml ( writer . getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_MEMBER , field . type ( ) ) ) ) ; pre . addContent ( fieldlink ) ; pre . addContent ( \" \" ) ; if ( configuration ( ) . linksource ) { Content fieldName = new StringContent ( field . name ( ) ) ; writer . addSrcLink ( field , fieldName , pre ) ; } else { addName ( field . name ( ) , pre ) ; } return pre ; } public void addDeprecated ( FieldDoc field , Content fieldDocTree ) { addDeprecatedInfo ( field , fieldDocTree ) ; } public void addComments ( FieldDoc field , Content fieldDocTree ) { ClassDoc holder = field . containingClass ( ) ; if ( field . inlineTags ( ) . length > 0 ) { if ( holder . equals ( classdoc ) || ( ! ( holder . isPublic ( ) || Util . isLinkable ( holder , configuration ( ) ) ) ) ) { writer . addInlineComment ( field , fieldDocTree ) ; } else { Content link = new RawHtml ( writer . getDocLink ( LinkInfoImpl . CONTEXT_FIELD_DOC_COPY , holder , field , holder . isIncluded ( ) ? holder . typeName ( ) : holder . qualifiedTypeName ( ) , false ) ) ; Content codeLink = HtmlTree . CODE ( link ) ; Content strong = HtmlTree . STRONG ( holder . isClass ( ) ? writer . descfrmClassLabel : writer . descfrmInterfaceLabel ) ; strong . addContent ( writer . getSpace ( ) ) ; strong . addContent ( codeLink ) ; fieldDocTree . addContent ( HtmlTree . DIV ( HtmlStyle . block , strong ) ) ; writer . addInlineComment ( field , fieldDocTree ) ; } } } public void addTags ( FieldDoc field , Content fieldDocTree ) { writer . addTagsInfo ( field , fieldDocTree ) ; } public Content getFieldDetails ( Content fieldDetailsTree ) { return getMemberTree ( fieldDetailsTree ) ; } public Content getFieldDoc ( Content fieldDocTree , boolean isLastContent ) { return getMemberTree ( fieldDocTree , isLastContent ) ; } public void close ( ) throws IOException { writer . close ( ) ; } public int getMemberKind ( ) { return VisibleMemberMap . FIELDS ; } public void addSummaryLabel ( Content memberTree ) { Content label = HtmlTree . HEADING ( HtmlConstants . SUMMARY_HEADING , writer . getResource ( \"doclet.Field_Summary\" ) ) ; memberTree . addContent ( label ) ; } public String getTableSummary ( ) { return configuration ( ) . getText ( \"doclet.Member_Table_Summary\" , configuration ( ) . getText ( \"doclet.Field_Summary\" ) , configuration ( )", "gt": ". getText ( \"doclet.fields\" ) ) ;", "prediction": ";\n", "label": 0}
{"id": 4825, "input": "<s> package org . nuxeo . theme . editor . views ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . nuxeo . theme . formats . Format ; import org . nuxeo . theme . html . filters . layout . DefaultLayoutView ; import org . nuxeo . theme . rendering . RenderingInfo ; public class CellLayout extends DefaultLayoutView { static final Pattern contentPattern = Pattern . compile ( \"<.*?>(.*)</td>\" , Pattern . DOTALL ) ; @ Override public String render ( final RenderingInfo info ) { final String markup = info . getMarkup ( ) ; final Matcher contentMatcher = contentPattern . matcher ( markup ) ; if ( ! contentMatcher . find ( ) ) { return markup ; } final Format layout = info . getFormat ( ) ; final StringBuilder style = new StringBuilder ( ) ; String width = layout . getProperty ( \"width\" ) ; if ( width != null ) { style . append ( \"width:\" ) . append ( width ) . append ( ';' ) ; } else { width = \"\" ; } String textAlign = layout . getProperty ( \"text-align\" ) ; if ( textAlign != null ) { style . append ( \"text-align:\" ) . append ( textAlign ) . append ( ';' ) ; } final String cellId = info . getElement ( ) . getUid ( ) . toString ( ) ; final StringBuilder html = new StringBuilder ( ) ; html . append ( String . format ( \"<td class=\\\"nxthemesCellLayout nxthemesContainer\\\" style=\\\"%s\\\" id=\\\"e%s\\\">\" , style . toString ( ) , cellId ) ) ; html . append ( \"<form class=\\\"nxthemesSizer\\\" action=\\\"\\\" onsubmit=\\\"return false\\\">\" ) . append ( \"<b class=\\\"left\\\"></b><b class=\\\"right\\\"></b>\" ) . append ( \"<input class=\\\"nxthemesInput\\\" type=\\\"text\\\" size=\\\"5\\\"\" ) . append ( \" value=\\\"\" ) . append ( width ) . append ( \"\\\" name=\\\"width\\\" />\" ) . append ( \"<input type=\\\"hidden\\\" name=\\\"id\\\" value=\\\"\" ) . append ( layout . getUid ( ) . toString ( ) ) . append ( \"\\\" /></form>\" ) ; html . append ( contentMatcher . group ( 1 ) ) ; html . append ( \"</td>\" ) ;", "gt": "return html . toString ( ) ;", "prediction": "}\n", "label": 1}
{"id": 5217, "input": "<s> public class T6295056 { interface Foo { } interface Bar < X > { } Object m ( Foo f ) { return ( Bar <", "gt": "Object > ) f ;", "prediction": ") ;\n", "label": 0}
{"id": 4832, "input": "<s> package org . eclipse . xtext . xdoc . ui . wizards ; import java . lang . reflect . InvocationTargetException ; import org . apache . log4j . Logger ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . ui . INewWizard ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . actions . WorkspaceModifyOperation ; import org . eclipse . ui . dialogs . WizardNewProjectCreationPage ; import org . eclipse . xtext . xdoc . ui . utils . ProjectUtils ; public class NewWizard extends Wizard implements INewWizard { private static final String WIZARD_PAGE_DESCRIPTION = org . eclipse . xtext . xdoc . ui . wizards . Messages . XDOC_NEW_PROJECT_WIZARD_DESCRIPTION ; private WizardNewProjectCreationPage npp ; @ SuppressWarnings ( \"unused\" ) private IWorkbench workbench ; @ SuppressWarnings ( \"unused\" ) private IStructuredSelection selection ; private Logger logger = Logger . getLogger ( this . getClass ( ) ) ; private ProjectUtils utils = new ProjectUtils ( ) ; public NewWizard ( ) { } public void init ( IWorkbench workbench , IStructuredSelection selection ) { this . workbench = workbench ; this . selection = selection ; this . utils . setWorkspace ( ResourcesPlugin . getWorkspace ( ) ) ; } @ Override public boolean performFinish ( ) { utils . setName ( npp . getProjectName ( ) ) ; utils . setLocation ( null ) ; if ( ! npp . useDefaults ( ) ) { utils . setLocation ( npp . getLocationURI ( ) ) ; } IRunnableWithProgress op = new WorkspaceModifyOperation ( ) { @ Override protected void execute ( IProgressMonitor monitor ) throws CoreException , InvocationTargetException , InterruptedException { try { utils . createProject ( monitor ) ; } catch ( Exception e ) { throw new InvocationTargetException ( e ) ; } finally { monitor . done ( ) ; } } } ; try { getContainer (", "gt": ") . run ( true , false , op ) ;", "prediction": ")\n", "label": 1}
{"id": 505, "input": "<s> import java . io . * ; import java . util . * ; public class T6917288 { enum Kind { NONE , FALSE , TRUE , ALWAYS } ; public static void main ( String ... args ) throws Exception { new T6917288 ( ) . run ( ) ; } void run ( ) throws Exception { for ( Kind k : Kind . values ( ) ) { test ( k ) ; } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } void test ( Kind k ) throws Exception { System . err . println ( \"Test \" + ( ++ count ) + \": \" + k ) ; File testDir = new File ( \"test\" + count ) ; File srcDir = new File ( testDir , \"src\" ) ; srcDir . mkdirs ( ) ; File classesDir = new File ( testDir , \"classes\" ) ; classesDir . mkdirs ( ) ; List < String > opts = new ArrayList < String > ( ) ; opts . add ( \"-d\" ) ; opts . add ( classesDir . getPath ( ) ) ; File f = writeFile ( srcDir , k ) ; int rc = compile ( opts , f ) ; if ( rc != 0 ) { error ( \"compilation failed: rc=\" + rc ) ; return ; } check ( classesDir , \"Test.class\" , \"Test$Inner.class\" , \"Test$1.class\" ) ; } int compile ( List < String > opts , File ... files ) { List < String > args = new ArrayList < String > ( ) ; args . addAll ( opts ) ; for ( File f : files ) args . add ( f . getPath ( ) ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javac . Main . compile ( args . toArray ( new String [ args . size ( ) ] ) , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; if ( out . length ( ) > 0 ) System . err . println ( out ) ; return rc ; } void check ( File dir , String ... paths ) { Set < String > found = new TreeSet < String > ( Arrays . asList ( dir . list ( ) ) ) ; Set < String > expect = new TreeSet < String > ( Arrays . asList ( paths ) ) ; if ( found . equals ( expect ) ) return ; for ( String f : found ) { if ( ! expect . contains ( f ) ) error ( \"Unexpected file found: \" + f ) ; } for ( String e : expect ) { if ( ! found . contains ( e ) ) error ( \"Expected file not found: \" + e ) ; } } File writeFile ( File dir , Kind k ) throws Exception { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"public class Test {\\n\" ) ; sb . append ( \"    private Inner inner;\\n\" ) ; if ( k != Kind . NONE ) { sb . append ( \"    private void m() {\\n\" ) ; sb . append ( \"        \" ) ; switch ( k ) { case FALSE : case TRUE : sb . append ( \"if (\" + k . toString ( ) . toLowerCase ( )", "gt": "+ \") \" ) ;", "prediction": ";\n", "label": 0}
{"id": 4840, "input": "<s> package com . talis . hbase . rdf . layout . hybrid ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . iterator . AbstractIterator ; public class HBaseRdfSingleTableIterator extends AbstractIterator < Triple > { ResultScanner scanner = null ; HBaseRdfSingleRowIterator rowIterator = null ; Node subject = null , predicate = null , object = null ; String pred = null ; String columnFamily = null ; public HBaseRdfSingleTableIterator ( ResultScanner tableScanner , Node sm , Node pm , Node om , String pred , String columnFamily ) { this . scanner = tableScanner ; this . subject = sm ; this . predicate = pm ; this . object = om ; this . pred = pred ; this . columnFamily = columnFamily ; } @ Override public void close ( ) { scanner . close ( ) ; } @ Override public boolean hasNext ( ) { try { if ( rowIterator == null || ! rowIterator . hasNext ( ) ) { Result rr = scanner . next ( ) ; if ( rr == null ) { rowIterator = null ; close ( ) ; return false ; } rowIterator = new HBaseRdfSingleRowIterator ( rr , subject , predicate , object , pred , columnFamily ) ; rr = null ; } return rowIterator . hasNext ( ) ; } catch ( Exception e ) { throw new HBaseRdfException ( \"No next element found: \" , e ) ; } } @ Override public Triple _next ( ) { try { if ( rowIterator == null || ! rowIterator . hasNext ( ) ) { Result rr = scanner . next ( ) ; if ( rr == null ) { rowIterator = null ; close ( ) ; return null ; } rowIterator = new HBaseRdfSingleRowIterator ( rr , subject , predicate , object , pred , columnFamily ) ; rr = null ; } return", "gt": "( Triple ) rowIterator . next ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5763, "input": "<s> import java . util . List ; public class T6682380 < X > { public static void main ( String [ ] args ) { try { } finally { List < T6682380 < ? > > l = null ; T6682380 < ? > [ ] a = null ; for ( T6682380 < ? > e1 : l ) ; for ( T6682380 <", "gt": "? > e2 : a ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4855, "input": "<s> package org . eclipse . jface . viewers ; import java . util . EventObject ; public class LabelProviderChangedEvent extends EventObject { private static final long serialVersionUID = 3258410612479309878L ; private Object [ ] elements ; public LabelProviderChangedEvent ( IBaseLabelProvider source ) { super ( source ) ; } public LabelProviderChangedEvent ( IBaseLabelProvider source , Object [ ] elements ) { super ( source ) ; this . elements = elements ; } public LabelProviderChangedEvent ( IBaseLabelProvider source , Object element ) { super ( source ) ; this .", "gt": "elements = new Object [ 1 ] ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1132, "input": "<s> package org . ofbiz . content . report ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRField ; public class JRMapCollectionDataSource implements JRDataSource { private Collection data = null ; private Iterator iterator = null ; private Map currentMap = null ; public JRMapCollectionDataSource ( Collection mapCollection ) { this . data = mapCollection ; if ( data != null ) { this . iterator = data . iterator ( ) ; } } public boolean next ( ) throws JRException { boolean hasNext = false ; if ( this . iterator != null ) { hasNext = this . iterator . hasNext ( ) ; if ( hasNext ) { try { this . currentMap = ( Map ) this", "gt": ". iterator . next ( ) ;", "prediction": ";\n", "label": 0}
{"id": 4872, "input": "<s> package de . uos . igf . db3d . resources . i18n ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . logging . Level ; import java . util . logging . Logger ; import de . uos . igf . db3d . resources . DB3DProperties ; public final class DB3DLang { private DB3DLang ( ) { } public final static String qualClassName = DB3DLang . class . getCanonicalName ( ) . substring ( 0 , DB3DLang . class . getCanonicalName ( ) . length ( ) - DB3DLang . class . getSimpleName ( ) . length ( ) ) + \"Resources\" ; private static ResourceBundle currResourceBundle = ResourceBundle . getBundle ( qualClassName , new Locale ( \"en\" , \"US\" ) ) ; public static boolean setFromPropertyFile ( ) { try { DB3DLang . setLocale ( new Locale ( DB3DProperties . getProperty ( \"lang\" ) , DB3DProperties . getProperty ( \"country\" ) ) ) ; return true ; } catch ( Exception e ) { Logger . getLogger ( DB3DLang . class . getName ( ) ) . log ( Level . INFO , getString ( \"db3d.info.load_lang\" ) ) ; return false ; } } public static void setLocale ( Locale newLocale ) { String language = newLocale . getLanguage ( ) ; String country = newLocale . getCountry ( ) ; if ( newLocale != null && language != null && language . length ( ) != 0 && country != null && country . length ( ) != 0 ) currResourceBundle = ResourceBundle . getBundle (", "gt": "qualClassName , newLocale ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2295, "input": "<s> package org . remast . baralga . model . report ; import java . util . Collection ; import java . util . List ; import java . util . Observable ; import org . remast . baralga . model . ProjectActivity ; import org . remast . baralga . model . filter . Filter ; import ca . odell . glazedlists . BasicEventList ; import ca . odell . glazedlists . SortedList ; public class AccumulatedActivitiesReport extends Observable { private Collection < ProjectActivity > data ; private SortedList < AccumulatedProjectActivity > accumulatedActivitiesByDay ; protected Filter filter ; public AccumulatedActivitiesReport ( final Collection < ProjectActivity > data , Filter filter ) { this . data = data ; this . filter = filter ; this . accumulatedActivitiesByDay = new SortedList < AccumulatedProjectActivity > ( new BasicEventList < AccumulatedProjectActivity > ( ) ) ; accumulate ( ) ; } @ Override public String toString ( ) { final StringBuilder result = new StringBuilder ( ) ; for ( AccumulatedProjectActivity activity : accumulatedActivitiesByDay ) { result . append ( activity . toString ( ) + \":\" ) ; } return \"[\" + result . toString ( ) + \"]\" ; } public void acummulateActivity ( final ProjectActivity activity ) { AccumulatedProjectActivity newAccActivity = new AccumulatedProjectActivity ( activity . getProject ( ) , activity . getStart ( ) , activity . getDuration ( ) ) ; if ( this . accumulatedActivitiesByDay . contains ( newAccActivity ) ) { final AccumulatedProjectActivity accActivity = this . accumulatedActivitiesByDay . get ( accumulatedActivitiesByDay . indexOf ( newAccActivity ) ) ; accActivity . addTime ( newAccActivity . getTime ( ) ) ; } else { this . accumulatedActivitiesByDay . add ( newAccActivity ) ; } } protected void accumulate ( ) { this .", "gt": "accumulatedActivitiesByDay . clear ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 4898, "input": "<s> package cs224n . util ; import java . util . List ; import java . util . ArrayList ; public class Counters { public static < E > Counter < E > normalize ( Counter < E > counter ) { Counter < E > normalizedCounter = new Counter < E > ( ) ; double total = counter . totalCount ( ) ; for ( E key : counter . keySet ( ) ) { normalizedCounter . setCount ( key , counter . getCount ( key ) / total ) ; } return normalizedCounter ; } public static < K , V > CounterMap < K , V > conditionalNormalize ( CounterMap < K , V > counterMap ) { CounterMap < K , V > normalizedCounterMap = new CounterMap < K , V > ( ) ; for ( K key : counterMap . keySet ( ) ) { Counter < V > normalizedSubCounter = normalize ( counterMap . getCounter ( key ) ) ; for ( V value : normalizedSubCounter . keySet ( ) ) { double count = normalizedSubCounter . getCount ( value ) ; normalizedCounterMap . setCount ( key , value , count ) ; } } return normalizedCounterMap ; } public static < E > String toBiggestValuesFirstString ( Counter < E > c ) { return c . asPriorityQueue ( ) . toString ( ) ; } public static < E > String toBiggestValuesFirstString ( Counter < E > c , int k ) { PriorityQueue < E > pq = c . asPriorityQueue ( ) ; PriorityQueue < E > largestK = new PriorityQueue < E > ( ) ; while ( largestK . size ( ) < k && pq . hasNext ( ) ) { double", "gt": "firstScore = pq . getPriority ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9864, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class OrderByItem extends Atom { public enum Order { DEFAULT , ASCENDING , DESCENDING } public enum Nulls { DEFAULT , FIRST , LAST } private final Order order ; private final Nulls nulls ; private final ConstantValue value ; public OrderByItem ( Order order , Nulls nulls , ConstantValue value ) { this . order = order ; this . nulls = nulls ; this . value = value ; } public final Order getOrder ( ) { return order ; } public final Nulls getNulls ( ) { return nulls ; } public final ConstantValue getValue ( ) { return value ; } @ Override public boolean equals ( Object o ) { if ( o instanceof OrderByItem ) { OrderByItem other = ( OrderByItem ) o ; return order . equals ( other . order ) && nulls . equals ( other . nulls ) && value . equals ( other . value ) ; } else { return false ; } } public StringBuilder appendTo ( StringBuilder sb ) { value . appendTo ( sb ) ; switch ( order ) { case ASCENDING : sb . append ( \" ASC\" ) ; break ; case DESCENDING : sb . append ( \" DESC\" ) ; break ; } switch ( nulls ) { case FIRST : sb . append ( \" NULLS FIRST\" ) ; break ; case LAST : sb . append", "gt": "( \" NULLS LAST\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4903, "input": "<s> package org . eclipse . ui . internal . handlers ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public final class ActionCommandMappingService implements IActionCommandMappingService { private final Map mapping = new HashMap ( ) ; public final String getCommandId ( final String actionId ) { if ( actionId == null ) { throw new NullPointerException ( \"Cannot get the command identifier for a null action id\" ) ; } return ( String ) mapping . get ( actionId ) ; } public final void map ( final String actionId , final String commandId ) { if ( actionId == null ) { throw new NullPointerException ( \"The action id cannot be null\" ) ; } if ( commandId == null ) { throw new NullPointerException ( \"The command id cannot be null\" ) ; } mapping . put ( actionId , commandId ) ; } public final String getGeneratedCommandId ( String targetId , String actionId ) { return IWorkbenchRegistryConstants .", "gt": "AUTOGENERATED_PREFIX + targetId + '/' + actionId ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 2937, "input": "<s> package com . sun . source . tree ; public interface DoWhileLoopTree extends StatementTree {", "gt": "ExpressionTree getCondition ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 4911, "input": "<s> package org . apache . lucene . analysis . compound . hyphenation ; import java . io . Serializable ; public class ByteVector implements Serializable { private static final int DEFAULT_BLOCK_SIZE = 2048 ; private int blockSize ; private byte [ ] array ; private int n ; public ByteVector ( ) { this ( DEFAULT_BLOCK_SIZE ) ; } public ByteVector ( int capacity ) { if ( capacity > 0 ) { blockSize = capacity ; } else { blockSize = DEFAULT_BLOCK_SIZE ; } array = new byte [ blockSize ] ; n = 0 ; } public ByteVector ( byte [ ] a ) { blockSize = DEFAULT_BLOCK_SIZE ; array = a ; n = 0 ; } public ByteVector ( byte [ ] a , int capacity ) { if ( capacity > 0 ) { blockSize = capacity ; } else { blockSize = DEFAULT_BLOCK_SIZE ; } array = a ; n = 0 ; } public byte [ ] getArray ( ) { return array ; } public int length ( ) { return n ; } public int capacity ( ) { return array . length ; } public void put ( int index , byte val ) { array [ index ] = val ; } public byte get ( int index ) { return array [ index ] ; } public int alloc ( int size ) { int index = n ; int len = array . length ;", "gt": "if ( n + size >= len )", "prediction": "}\n", "label": 1}
{"id": 6931, "input": "<s> package org . remast . baralga . model . export ; import java . io . OutputStream ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . apache . commons . lang . StringEscapeUtils ; import org . joda . time . DateTime ; import org . joda . time . format . ISODateTimeFormat ; import org . remast . baralga . model . BaralgaDAO ; import org . remast . baralga . model . Project ; import org . remast . baralga . model . ProjectActivity ; import org . remast . baralga . model . filter . Filter ; import org . w3c . dom . Comment ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class XmlExporter implements Exporter { @ Override public void export ( Collection < ProjectActivity > data , Filter filter , OutputStream outputStream ) throws Exception { final Set < Project > projects = new HashSet < Project > ( ) ; for ( ProjectActivity activity : data ) { projects . add ( activity . getProject ( ) ) ; } final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; final DocumentBuilder documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; final Document document = documentBuilder . newDocument ( ) ; Element root = document . createElement ( \"baralga\" ) ; root . setAttribute ( \"version\" , String . valueOf ( BaralgaDAO . LATEST_DATABASE_VERSION ) ) ; document . appendChild ( root ) ; Comment comment = document . createComment ( \"Baralga data export created at \" + new DateTime ( ) + \".\" ) ; root . appendChild ( comment ) ; Element projectsElement = document . createElement ( \"projects\" ) ; root . appendChild ( projectsElement ) ; for ( Project project : projects ) { Element projectElement = document . createElement ( \"project\" ) ; projectElement . setAttribute ( \"id\" , String . valueOf ( project . getId ( ) ) ) ; Element titleElement = document . createElement ( \"title\" ) ; titleElement . appendChild ( document . createTextNode ( StringEscapeUtils . escapeXml ( project . getTitle ( ) ) ) ) ; projectElement . appendChild ( titleElement ) ; Element descriptionElement = document . createElement ( \"description\" ) ; descriptionElement . appendChild ( document . createTextNode ( StringEscapeUtils . escapeXml ( project . getDescription ( ) ) ) ) ; projectElement . appendChild ( descriptionElement ) ; projectsElement . appendChild ( projectElement ) ; } Element activitiesElement = document . createElement ( \"activities\" ) ; root . appendChild ( activitiesElement ) ; for ( ProjectActivity activity : data ) { final Element activityElement = document . createElement ( \"activity\" ) ; activityElement . setAttribute ( \"id\" , String . valueOf ( activity", "gt": ". getId ( ) ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 4917, "input": "<s> package com . cloudera . sqoop . manager ; import com . cloudera . sqoop . SqoopOptions ; public class PostgresqlManager extends org . apache . sqoop . manager . PostgresqlManager { public", "gt": "PostgresqlManager ( final SqoopOptions opts )", "prediction": ";\n", "label": 1}
{"id": 4129, "input": "<s> package org . jboss ; import org . jboss . soa . esb . actions . AbstractActionLifecycle ; import org . jboss . soa . esb . helpers . ConfigTree ; import org . jboss . soa . esb . message . Message ; import org . jboss . soa . esb . actions . ActionLifecycleException ; import org . jboss . soa . esb . ConfigurationException ; import org . apache . log4j . Logger ; public class IntroduceDelay extends AbstractActionLifecycle { private static final String DELAY_MILLIS = \"DELAY_MILLIS\" ; private Logger log = Logger . getLogger ( this . getClass ( ) ) ; private int delayMillis = 0 ; protected ConfigTree _config ; public IntroduceDelay ( ConfigTree config ) throws ConfigurationException { _config = config ; delayMillis = Integer . parseInt ( _config . getRequiredAttribute ( DELAY_MILLIS ) ) ; } public Message process ( Message message ) throws ActionLifecycleException { try { Thread . sleep ( delayMillis ) ; } catch ( Exception x ) { throw new ActionLifecycleException ( \"process() Exception =", "gt": "\" + x . getLocalizedMessage ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 4924, "input": "<s> package com . emf4sw . owl . resource . impl ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import com . emf4sw . owl . ClassExpression ; import com . emf4sw . owl . DataAllValuesFrom ; import com . emf4sw . owl . DataExactCardinality ; import com . emf4sw . owl . DataMaxCardinality ; import com . emf4sw . owl . DataMinCardinality ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . Individual ; import com . emf4sw . owl . OWLClass ; import com . emf4sw . owl . OWLDatatype ; import com . emf4sw . owl . OWLFactory ; import com . emf4sw . owl . ObjectAllValuesFrom ; import com . emf4sw . owl . ObjectComplementOf ; import com . emf4sw . owl . ObjectExactCardinality ; import com . emf4sw . owl . ObjectIntersectionOf ; import com . emf4sw . owl . ObjectMaxCardinality ; import com . emf4sw . owl . ObjectMinCardinality ; import com . emf4sw . owl . ObjectOneOf ; import com . emf4sw . owl . ObjectUnionOf ; import com . emf4sw . owl . jena . utils . OntModelSwitch ; import com . emf4sw . owl . resource . OWLFormats ; import com . emf4sw . owl . resource . OWLReader ; import com . emf4sw . owl . resource . OWLResource ; import com . emf4sw . rdf . vocabulary . XSD ; import com . hp . hpl . jena . ontology . AllValuesFromRestriction ; import com . hp . hpl . jena . ontology . CardinalityQRestriction ; import com . hp . hpl . jena . ontology . CardinalityRestriction ; import com . hp . hpl . jena . ontology . ComplementClass ; import com . hp . hpl . jena . ontology . DatatypeProperty ; import com . hp . hpl . jena . ontology . EnumeratedClass ; import com . hp . hpl . jena . ontology . IntersectionClass ; import com . hp . hpl . jena . ontology . MaxCardinalityQRestriction ; import com . hp . hpl . jena . ontology . MaxCardinalityRestriction ; import com . hp . hpl . jena . ontology . MinCardinalityQRestriction ; import com . hp . hpl . jena . ontology . MinCardinalityRestriction ; import com . hp . hpl . jena . ontology . ObjectProperty ; import com . hp . hpl . jena . ontology . OntClass ; import com . hp . hpl . jena . ontology . OntModel ; import com . hp . hpl . jena . ontology . OntModelSpec ; import com . hp . hpl . jena . ontology . OntProperty ; import com . hp . hpl . jena . ontology . OntResource ; import com . hp . hpl . jena . ontology . Ontology ; import com . hp . hpl . jena . ontology . UnionClass ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . hp . hpl . jena . rdf . model . RDFNode ; import com . hp . hpl . jena . rdf . model . RDFReader ; import com . hp . hpl . jena . rdf . model . ResIterator ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; public class OWLJenaReader implements OWLReader { @ Override public void read ( InputStream inputStream , OWLResource resource , OWLFormats format ) { final OntModel model = ModelFactory . createOntologyModel ( OntModelSpec . OWL_MEM ) ; final RDFReader aReader = model . getReader ( format . value ( ) ) ; try { aReader . read ( model , inputStream , \"\" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } doInject ( resource , model ) ; } protected OWLResource doInject ( final OWLResource resource , OntModel model ) { if ( resource == null ) { throw new IllegalArgumentException ( ) ; } for ( ExtendedIterator < Ontology > it = model . listOntologies ( ) ; it . hasNext ( ) ; ) { com . emf4sw . owl . Ontology ontology = doCreateAxioms ( model , it . next ( ) ) ; if ( ontology != null ) { resource . getContents ( ) . add ( ontology ) ; } } return resource ; } private com . emf4sw . owl . Ontology doCreateAxioms ( OntModel ontModel , Ontology ontology ) { final com . emf4sw . owl . Ontology onto = doOntology ( ontology ) ; final OntModelReaderSwitch swtch = new OntModelReaderSwitch ( ontModel , onto ) ; for ( ResIterator", "gt": "it = ontModel . listSubjects ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9693, "input": "<s> package com . matburt . mobileorg . test . OrgData ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . io . InputStreamReader ; import android . database . Cursor ; import android . test . ProviderTestCase2 ; import android . test . mock . MockContentResolver ; import com . matburt . mobileorg . OrgData . OrgContract . Files ; import com . matburt . mobileorg . OrgData . OrgContract . OrgData ; import com . matburt . mobileorg . OrgData . OrgDatabase ; import com . matburt . mobileorg . OrgData . OrgFile ; import com . matburt . mobileorg . OrgData . OrgFileParser ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProvider ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import com . matburt . mobileorg . test . util . OrgTestFiles . SimpleOrgFiles ; import com . matburt . mobileorg . test . util . OrgTestUtils ; import com . matburt . mobileorg . util . OrgFileNotFoundException ; import com . matburt . mobileorg . util . OrgNodeNotFoundException ; public class OrgFileTest extends ProviderTestCase2 < OrgProvider > { private MockContentResolver resolver ; public OrgFileTest ( ) { super ( OrgProvider . class , OrgProvider . class . getName ( ) ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; this . resolver = getMockContentResolver ( ) ; } @ Override protected void tearDown ( ) throws Exception { } public void testAddFileSimple ( ) throws OrgFileNotFoundException , OrgNodeNotFoundException { OrgFile orgFile = new OrgFile ( \"filename\" , \"name\" , \"checksum\" ) ; orgFile . addFile ( resolver ) ; OrgFile insertedFile = new OrgFile ( orgFile . id , resolver ) ; assertTrue ( orgFile . equals ( insertedFile ) ) ; assertEquals ( insertedFile . id , orgFile . id ) ; assertEquals ( insertedFile . nodeId , orgFile . nodeId ) ; OrgNode node = new OrgNode ( orgFile . nodeId , resolver ) ; assertEquals ( node . name , orgFile . name ) ; assertTrue ( orgFile . id >= 0 ) ; assertEquals ( node . fileId , orgFile . id ) ; } public void testDoesFileExist ( ) { OrgFile orgFile = new OrgFile ( \"filename\" , \"name\" , \"checksum\" ) ; orgFile . addFile ( resolver ) ; assertTrue ( orgFile . doesFileExist ( resolver ) ) ; } public void testRemoveFileSimple ( ) throws OrgFileNotFoundException { OrgFile orgFile = new OrgFile ( \"filename\" , \"name\" , \"checksum\" ) ; orgFile . addFile ( resolver ) ; OrgFile insertedFile = new OrgFile ( orgFile . id , resolver ) ; insertedFile . removeFile ( resolver ) ; Cursor filesCursor = resolver . query ( Files . buildIdUri ( orgFile . id ) , Files . DEFAULT_COLUMNS , null , null , null ) ; assertEquals ( 0 , filesCursor . getCount ( ) ) ; filesCursor . close ( ) ; Cursor dataCursor = resolver . query ( OrgData . buildIdUri ( insertedFile . nodeId ) , OrgData . DEFAULT_COLUMNS , null , null , null ) ; assertEquals ( 0 , dataCursor . getCount ( ) ) ; dataCursor . close ( ) ; } public void testRemoveFileWithNodes ( ) throws OrgFileNotFoundException { OrgNode node = OrgTestUtils . setupParentScenario ( resolver ) ; OrgFile orgFile = node . getOrgFile ( resolver ) ; orgFile . removeFile ( resolver ) ; Cursor filesCursor = resolver . query ( Files . buildIdUri ( orgFile . id ) , Files . DEFAULT_COLUMNS , null , null , null ) ; assertEquals ( 0 , filesCursor . getCount ( ) ) ; filesCursor . close ( ) ; Cursor dataCursor = resolver . query ( OrgData . CONTENT_URI , OrgData . DEFAULT_COLUMNS , OrgData . FILE_ID + \"=?\" , new String [ ] { Long . toString ( orgFile . id ) } , null ) ; assertEquals ( 0 , dataCursor . getCount ( ) ) ; dataCursor . close ( ) ; OrgTestUtils . cleanupParentScenario ( resolver ) ; } public void testFileToStringSimple ( ) throws OrgFileNotFoundException { final String filename = \"filename\" ; InputStream is = new ByteArrayInputStream ( SimpleOrgFiles . orgFile . getBytes ( ) ) ; BufferedReader breader = new BufferedReader ( new InputStreamReader ( is ) ) ; OrgFile orgFile = new OrgFile ( filename , \"file alias\" , \"\" ) ; OrgDatabase db = new OrgDatabaseStub ( getMockContext ( ) ) ; OrgFileParser parser = new OrgFileParser ( db , resolver ) ; parser . parse ( orgFile , breader ) ; db . close ( ) ; OrgFile file = new OrgFile ( filename , resolver ) ; String fileString = file . toString ( resolver ) ; assertEquals ( SimpleOrgFiles . orgFile . trim ( ) , fileString . trim ( ) ) ; } public void testCreateFile ( ) { final String fileAlias = \"test name\" ; OrgFile file = OrgProviderUtils . getOrCreateFile ( \"test file\" , fileAlias , resolver ) ; assertTrue ( file . id >= 0 ) ; assertTrue ( file . doesFileExist ( resolver ) ) ; try { OrgNode capturefileNode = file . getOrgNode ( resolver ) ; assertTrue ( capturefileNode . id >= 0 ) ; assertTrue ( capturefileNode . fileId >= 0 ) ; assertEquals ( file . id , capturefileNode . fileId ) ; assertEquals ( fileAlias , capturefileNode . name ) ; } catch ( IllegalArgumentException e ) { fail ( \"OrgNode not created\" ) ; } try { OrgFile file2 = new OrgFile ( file . id , resolver ) ; assertTrue ( file . equals ( file2 ) ) ; } catch ( OrgFileNotFoundException e ) { fail ( \"File node not created\" ) ; } } public void testCreateCaptureFile ( ) { OrgFile file = OrgProviderUtils . getOrCreateCaptureFile ( resolver ) ; assertTrue", "gt": "( file . id >= 0 ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4934, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import org .", "gt": "restlet . resource . Get ;", "prediction": "eclipse . eclipse . ;\n", "label": 1}
{"id": 4040, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface ReportPrefix extends IncludePropertiesAttribute {", "gt": "Report getReport ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 4982, "input": "<s> package org . jscsi . target ; import java . io . File ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . channels . ServerSocketChannel ; import java . nio . channels . SocketChannel ; import java . security . DigestException ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Vector ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicInteger ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . login . ISID ; import org . jscsi . parser . login . LoginRequestParser ; import org . jscsi . target . connection . Connection ; import org . jscsi . target . connection . Connection . TargetConnection ; import org . jscsi . target . connection . TargetSession ; import org . jscsi . target . scsi . inquiry . DeviceIdentificationVpdPage ; import org . jscsi . target . settings . SettingsException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public final class TargetServer implements Callable < Void > { private static final Logger LOGGER = LoggerFactory . getLogger ( TargetServer . class ) ; private ServerSocketChannel serverSocketChannel ; private Collection < TargetSession > sessions = new Vector < TargetSession > ( ) ; private Configuration config ; private DeviceIdentificationVpdPage deviceIdentificationVpdPage ; private HashMap < String , Target > targets = new HashMap < String , Target > ( ) ; private static final AtomicInteger nextTargetTransferTag = new AtomicInteger ( ) ; private Connection connection ; public TargetServer ( final Configuration conf ) { this . config = conf ; LOGGER . debug ( \"Starting jSCSI-target: \" ) ; LOGGER . debug ( \"   port:           \" + getConfig ( ) . getPort ( ) ) ; LOGGER . debug ( \"   loading targets.\" ) ; List < Target > targetInfo = getConfig ( ) . getTargets ( ) ; for ( Target curTargetInfo : targetInfo ) { targets . put ( curTargetInfo . getTargetName ( ) , curTargetInfo ) ; LOGGER . debug ( \"   target name:    \" + curTargetInfo . getTargetName ( ) + \" loaded.\" ) ; } this . deviceIdentificationVpdPage = new DeviceIdentificationVpdPage ( this ) ; } public static int getNextTargetTransferTag ( ) { int tag ; do { tag = nextTargetTransferTag . getAndIncrement ( ) ; } while ( tag == - 1 ) ; return tag ; } public static void main ( String [ ] args ) throws Exception { TargetServer target ; switch ( args . length ) { case 0 : target = new TargetServer ( Configuration . create ( ) ) ; break ; case 1 : target = new TargetServer ( Configuration . create ( Configuration . CONFIGURATION_SCHEMA_FILE , new File ( args [ 0 ] ) ) ) ; break ; case 2 : target = new TargetServer ( Configuration . create ( new File ( args [ 0 ] ) , new File ( args [ 1 ] ) ) ) ; break ; default : throw new IllegalArgumentException ( \"Only zero or one Parameter (Path to Configuration-File) allowed!\" ) ; } target . call ( ) ; } public Void call ( ) throws Exception { ExecutorService threadPool = Executors . newFixedThreadPool ( 4 ) ; try { serverSocketChannel =", "gt": "ServerSocketChannel . open ( ) ;", "prediction": ";\n", "label": 1}
{"id": 273, "input": "<s> package com . sun . tools . javac . code ; import java . util . Collections ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . code . Symbol . * ; import javax . lang . model . type . * ; import static com . sun . tools . javac . code . Flags . * ; import static com . sun . tools . javac . code . Kinds . * ; import static com . sun . tools . javac . code . BoundKind . * ; import static com . sun . tools . javac . code . TypeTags . * ; public class Type implements PrimitiveType { public static final JCNoType noType = new JCNoType ( NONE ) ; public static boolean moreInfo = false ; public int tag ; public TypeSymbol tsym ; public Object constValue ( ) { return null ; } public Type getModelType ( ) { return this ; } public static List < Type > getModelTypes ( List < Type > ts ) { ListBuffer < Type > lb = new ListBuffer < Type > ( ) ; for ( Type t : ts ) lb . append ( t . getModelType ( ) ) ; return lb . toList ( ) ; } public < R , S > R accept ( Type . Visitor < R , S > v , S s ) { return v . visitType ( this , s ) ; } public Type ( int tag , TypeSymbol tsym ) { this . tag = tag ; this . tsym = tsym ; } public static abstract class Mapping { private String name ; public Mapping ( String name ) { this . name = name ; } public abstract Type apply ( Type t ) ; public String toString ( ) { return name ; } } public Type map ( Mapping f ) { return this ; } public static List < Type > map ( List < Type > ts , Mapping f ) { if ( ts . nonEmpty ( ) ) { List < Type > tail1 = map ( ts . tail , f ) ; Type t = f . apply ( ts . head ) ; if ( tail1 != ts . tail || t != ts . head ) return tail1 . prepend ( t ) ; } return ts ; } public Type constType ( Object constValue ) { final Object value = constValue ; Assert", "gt": ". check ( tag <= BOOLEAN ) ;", "prediction": ";\n", "label": 0}
{"id": 4991, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . client . ClientSelector ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleFactory ; import org . eclipse . rap . rwt . internal . resources . JSLibraryConcatenator ; import org . eclipse . rap . rwt . internal . resources . ResourceDirectory ; import org . eclipse . rap . rwt . internal . resources . ResourceRegistry ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . service . StartupPage ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . IResourceManager ; public class ApplicationContextActivator_Test extends TestCase { private ApplicationContext applicationContext ; private LifeCycleFactory lifeCycleFactory ; private ThemeManager themeManager ; private JSLibraryConcatenator jsLibraryConcatenator ; private ServiceManager serviceManager ; private ClientSelector clientSelector ; @ Override protected void setUp ( ) { mockApplicationContext ( ) ; } public void testActivate ( ) { ApplicationContextActivator activator = new ApplicationContextActivator ( applicationContext ) ; activator . activate ( ) ; verify ( themeManager ) . activate ( ) ; verify ( lifeCycleFactory ) . activate ( ) ; verify ( jsLibraryConcatenator ) . activate ( ) ; verify ( jsLibraryConcatenator ) . startJSConcatenation ( ) ; verify ( clientSelector ) . activate ( ) ; } public void testDeactivate ( ) { ApplicationContextActivator activator = new ApplicationContextActivator ( applicationContext ) ; activator . deactivate ( ) ; verify ( jsLibraryConcatenator ) . deactivate ( ) ; verify ( lifeCycleFactory ) . deactivate ( ) ; verify ( serviceManager ) . clear ( ) ; verify ( themeManager ) . deactivate ( ) ; } private void mockApplicationContext ( ) { applicationContext = mock", "gt": "( ApplicationContext . class ) ;", "prediction": ";\n", "label": 1}
{"id": 8603, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . AlertLevel ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . StatusStatusSheet ; import org . jjflyboy . tjpeditor . project . StatusStatusSheetAttribute ; public class StatusStatusSheetImpl extends TaskStatusSheetAttributeImpl implements StatusStatusSheet { protected static final AlertLevel LEVEL_EDEFAULT = AlertLevel . RED ; protected AlertLevel level = LEVEL_EDEFAULT ; protected static final String TEXT_EDEFAULT = null ; protected String text = TEXT_EDEFAULT ; protected EList < StatusStatusSheetAttribute > attributes ; protected StatusStatusSheetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getStatusStatusSheet ( ) ; } public AlertLevel getLevel ( ) { return level ; } public void setLevel ( AlertLevel newLevel ) { AlertLevel oldLevel = level ; level = newLevel == null ? LEVEL_EDEFAULT : newLevel ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_STATUS_SHEET__LEVEL , oldLevel , level ) ) ; } public String getText ( ) { return text ; } public void setText ( String newText ) { String oldText = text ; text = newText ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_STATUS_SHEET__TEXT , oldText , text ) ) ; } public EList < StatusStatusSheetAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < StatusStatusSheetAttribute > ( StatusStatusSheetAttribute . class , this , ProjectPackage . STATUS_STATUS_SHEET__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd", "gt": ", int featureID , NotificationChain msgs )", "prediction": ")\n", "label": 0}
{"id": 5000, "input": "<s> package org . restlet . engine . local ; import org . restlet . Server ; import org . restlet . data . Protocol ; import org . restlet . engine . ServerHelper ; public class RiapServerHelper extends ServerHelper { public static RiapServerHelper instance = null ; public RiapServerHelper ( Server server ) { super ( server ) ; getProtocols ( ) . add ( Protocol . RIAP ) ; if ( server", "gt": "!= null && RiapServerHelper . instance == null )", "prediction": ") ;\n", "label": 1}
{"id": 7759, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface ResourceRoot extends ReportAttribute { Resource getResource ( ) ; void setResource", "gt": "( Resource value ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 5006, "input": "<s> package org . eclipse . rap . ui . interactiondesign ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IExtensionRegistry ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . internal . provisional . action . IToolBarManager2 ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . rap . ui . interactiondesign . internal . ConfigurableStackProxy ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . DefaultStackPresentationSite ; import org . eclipse . ui . internal . LayoutPart ; import org . eclipse . ui . internal . PartPane ; import org . eclipse . ui . internal . ViewPane ; import org . eclipse . ui . internal . presentations . PresentablePart ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . part . ViewPart ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . eclipse . ui . preferences . ScopedPreferenceStore ; import org . eclipse . ui . presentations . IPartMenu ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . presentations . IStackPresentationSite ; import org . eclipse . ui . presentations . StackPresentation ; public abstract class ConfigurableStack extends StackPresentation { private static final String CONFIG_ACTION_NAME = \"actionClass\" ; private static IStackPresentationSite siteDummy = new IStackPresentationSite ( ) { public void addSystemActions ( final IMenuManager menuManager ) { } public void close ( final IPresentablePart [ ] toClose ) { } public void dragStart ( final IPresentablePart beingDragged , final Point initialPosition , final boolean keyboard ) { } public void dragStart ( final Point initialPosition , final boolean keyboard ) { } public void flushLayout ( ) { } public IPresentablePart [ ] getPartList ( ) { return null ; } public String getProperty ( final String id ) { return null ; } public IPresentablePart getSelectedPart ( ) { return null ; } public int getState ( ) { return 0 ; } public boolean isCloseable ( final IPresentablePart toClose ) { return false ; } public boolean isPartMoveable ( final IPresentablePart toMove ) { return false ; } public boolean isStackMoveable ( ) { return false ; } public void selectPart ( final IPresentablePart toSelect ) { } public void setState ( final int newState ) { } public boolean supportsState ( final int state ) { return false ; } } ; public static final String STACK_PRESENTATION_EXT_ID = \"org.eclipse.rap.ui.stackPresentations\" ; public static final String getLayoutPartId ( final IStackPresentationSite site ) { String result = null ; if ( site != null && site instanceof DefaultStackPresentationSite ) { DefaultStackPresentationSite defaultSite", "gt": "= ( DefaultStackPresentationSite ) site ;", "prediction": ";\n", "label": 1}
{"id": 6145, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . Villager ; import Liza . LizaVillager ; public class LizaCraftVillager extends LizaCraftNPC implements LizaVillager { public LizaCraftVillager ( Villager villager ) { super ( villager ) ; } @ Override", "gt": "public Villager getBukkitHandle ( )", "prediction": "}\n", "label": 0}
{"id": 5007, "input": "<s> package org . jscsi . scsi . tasks . target ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . apache . log4j . Logger ; import org . jscsi . scsi . protocol . Command ; import org . jscsi . scsi . protocol . cdb . CDB ; import org . jscsi . scsi . protocol . cdb . ReportLuns ; import org . jscsi . scsi . protocol . sense . exceptions . IllegalRequestException ; import org . jscsi . scsi . protocol . sense . exceptions . InvalidCommandOperationCodeException ; import org . jscsi . scsi . tasks . Task ; import org . jscsi . scsi . tasks . TaskFactory ; import org . jscsi . scsi . transport . TargetTransportPort ; public class TargetTaskFactory implements TaskFactory { private static Logger _logger = Logger . getLogger ( TargetTaskFactory . class ) ; private static Map < Class < ? extends CDB > , Class < ? extends TargetTask > > tasks = new HashMap < Class < ? extends CDB > , Class < ? extends TargetTask > > ( ) ; private Set < Long > logicalUnits ; static { TargetTaskFactory . tasks . put ( ReportLuns . class , ReportLunsTask . class ) ; } public TargetTaskFactory (", "gt": "Set < Long > logicalUnits )", "prediction": ")\n", "label": 1}
{"id": 1685, "input": "<s> package com . cfm . ml ; import java . awt . Canvas ; import java . awt . Color ; import java . awt . Graphics ; import java . awt . event . KeyEvent ; import java . awt . event . KeyListener ; import java . awt . event . MouseEvent ; import java . awt . event . MouseListener ; import java . awt . event . MouseMotionListener ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; import javax . swing . JFrame ; @ SuppressWarnings ( \"serial\" ) public class MainCanvas extends Canvas implements MouseListener , MouseMotionListener , KeyListener { public static final Color [ ] COLORS = { Color . lightGray , Color . white } ; public static final int PLUS_VALUE = 0 , MINUS_VALUE = 1 ; public static final String [ ] CHAR_VALUE = { \"+\" , \"-\" } ; public List < TestPoint > points = new ArrayList < TestPoint > ( ) ; private int xMouse , yMouse ; private int k = 1 ; private TestPoint t = null ; private List < TestPoint > tests = new ArrayList < TestPoint > ( ) ; static class TestPoint { int x , y ; int value ; public TestPoint ( int x , int y , int value ) { super ( ) ; this . x = x ; this . y = y ; this . value = value ; } public TestPoint ( int x , int y ) { this . x = x ; this . y = y ; } public long sqDistanceTo ( long px , long py ) { return ( px - this . x ) * ( px - this . x ) + ( py - this . y ) * ( py - this . y ) ; } @ Override public String toString ( ) { return \"TestPoint [x=\" + x + \", y=\" + y + \", v=\" + CHAR_VALUE [ value ] + \"]\" ; } } public MainCanvas ( ) { this . addMouseListener ( this ) ; this . addKeyListener ( this ) ; this . addMouseMotionListener ( this ) ; } @ Override public void paint ( Graphics g ) { g . setColor ( Color . white ) ; g . fillRect ( 0 , 0", "gt": ", getWidth ( ) , getHeight ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5015, "input": "<s> package org . eclipse . ui . part ; public interface IShowInTargetList { public String [", "gt": "] getShowInTargetIds ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 3151, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJChart ; import ar . com . fdvs . dj . domain . DJChartOptions ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DJChartBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class ChartReportTest4 extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorder ( Border . PEN_2_POINT ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle .", "gt": "setTransparency ( Transparency . OPAQUE ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5022, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . parser ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . help . internal . entityresolver . LocalEntityResolver ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . internal . cheatsheets . Messages ; import org . eclipse . ui . internal . cheatsheets . composite . model . AbstractTask ; import org . eclipse . ui . internal . cheatsheets . composite . model . CompositeCheatSheetModel ; import org . eclipse . ui . internal . cheatsheets . composite . model . EditableTask ; import org . eclipse . ui . internal . cheatsheets . composite . model . TaskGroup ; import org . eclipse . ui . internal . cheatsheets . data . CheatSheetParserException ; import org . eclipse . ui . internal . cheatsheets . data . IParserTags ; import org . eclipse . ui . internal . cheatsheets . data . ParserStatusUtility ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class CompositeCheatSheetParser implements IStatusContainer { private DocumentBuilder documentBuilder ; private IStatus status ; private int nextTaskId = 0 ; public IStatus getStatus ( ) { return status ; } public DocumentBuilder getDocumentBuilder ( ) { if ( documentBuilder == null ) { try { documentBuilder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; documentBuilder . setEntityResolver ( new LocalEntityResolver ( ) ) ; } catch ( Exception e ) { addStatus ( IStatus . ERROR , Messages . get ( ) . ERROR_CREATING_DOCUMENT_BUILDER , e ) ; } } return documentBuilder ; } public void addStatus ( int severity , String message , Throwable exception ) { status = ParserStatusUtility . addStatus ( status , severity , message , exception ) ; } public CompositeCheatSheetModel parseGuide ( URL url ) { status = Status . OK_STATUS ; if ( url == null ) { String message = NLS . bind ( Messages . get ( ) . ERROR_OPENING_FILE , ( new Object [ ] { \"\" } ) ) ; addStatus ( IStatus . ERROR , message , null ) ; return null ; } InputStream is = null ; try { is = url . openStream ( ) ; if ( is == null ) { String message = NLS . bind ( Messages . get ( ) . ERROR_OPENING_FILE , ( new Object [ ] { url . getFile ( ) } ) ) ; addStatus ( IStatus . ERROR , message , null ) ; return null ; } } catch ( Exception e ) { String message = NLS . bind ( Messages . get ( ) . ERROR_OPENING_FILE , ( new Object [ ] { url . getFile ( ) } ) ) ; addStatus ( IStatus . ERROR , message , e ) ; return null ; } Document document ; String filename = url . getFile ( ) ; try { InputSource inputSource = new InputSource ( is ) ; document = getDocumentBuilder ( ) . parse ( inputSource ) ; } catch ( IOException e ) { String message = NLS . bind ( Messages . get ( ) . ERROR_OPENING_FILE_IN_PARSER , ( new Object [ ] { filename } ) ) ; addStatus ( IStatus . ERROR , message , e ) ; return null ; } catch ( SAXParseException spe ) { String message = NLS . bind ( Messages . get ( ) . ERROR_SAX_PARSING_WITH_LOCATION , ( new Object [ ] { filename , new Integer ( spe . getLineNumber ( ) ) , new Integer ( spe . getColumnNumber ( ) ) } ) ) ; addStatus ( IStatus . ERROR , message , spe ) ; return null ; } catch ( SAXException se ) { String message = NLS . bind ( Messages . get ( ) . ERROR_SAX_PARSING , ( new Object [ ] { filename } ) ) ; addStatus ( IStatus . ERROR , message , se ) ; return null ; } finally { try { is . close ( ) ; } catch ( Exception e ) { } } CompositeCheatSheetModel result = parseCompositeCheatSheet ( document , url ) ; return result ; } public CompositeCheatSheetModel parseCompositeCheatSheet ( Document document , URL url ) { status = Status . OK_STATUS ; try { if ( document != null ) { Node rootnode = document . getDocumentElement ( ) ; if ( ! rootnode . getNodeName ( ) . equals ( ICompositeCheatsheetTags . COMPOSITE_CHEATSHEET ) ) { String message = NLS . bind ( Messages . get ( ) . ERROR_PARSING_ROOT_NODE_TYPE , ( new Object [ ] { ICompositeCheatsheetTags . COMPOSITE_CHEATSHEET } ) ) ; throw new CheatSheetParserException ( message ) ; } String name = \"\" ; boolean nameFound = false ; String explorerId = ICompositeCheatsheetTags . TREE ; NamedNodeMap attributes = rootnode . getAttributes ( ) ; if ( attributes != null ) { for ( int x = 0 ; x < attributes . getLength ( ) ; x ++ ) { Node attribute = attributes . item ( x ) ; String attributeName = attribute . getNodeName ( ) ; if ( attributeName != null && attributeName . equals ( ICompositeCheatsheetTags . NAME ) ) { nameFound = true ; name = attribute . getNodeValue ( ) ; } if ( attributeName . equals ( ICompositeCheatsheetTags . EXPLORER ) ) { explorerId = attribute . getNodeValue ( ) ; } } } CompositeCheatSheetModel compositeCS = new CompositeCheatSheetModel ( name , name , explorerId ) ; parseCompositeCheatSheetChildren ( rootnode , compositeCS ) ; compositeCS . getDependencies ( ) . resolveDependencies ( this ) ; if ( compositeCS . getRootTask ( ) == null ) { addStatus ( IStatus . ERROR , Messages", "gt": ". get ( ) . ERROR_PARSING_NO_ROOT , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6410, "input": "<s> package api . forum . thread ; public class Answers { private String answer ; private Number percent ; private Number ratio ; public String getAnswer ( ) { try { return this . answer ; } catch ( Exception e ) { return null ; } } public Number getPercent ( ) { try { return this . percent ; } catch ( Exception e ) { return null ; } } public Number getRatio ( ) { try { return this . ratio ; } catch ( Exception e ) { return null ; } } @ Override public String toString ( ) { return \"Answers [getAnswer=\" + getAnswer ( ) + \", getPercent=\" + getPercent ( ) + \", getRatio=\" + getRatio", "gt": "( ) + \"]\" ;", "prediction": ") ;\n", "label": 0}
{"id": 5026, "input": "<s> package com . cloudera . sqoop . testutil ; import java . io . UnsupportedEncodingException ; import java . sql . Blob ; import java . sql . ResultSet ; import java . sql . SQLException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . io . BytesWritable ; import org . junit . Test ; public abstract class ManagerCompatTestCase extends ImportJobTestCase { private Log log ; public ManagerCompatTestCase ( ) { this . log = LogFactory . getLog ( ManagerCompatTestCase . class . getName ( ) ) ; } protected abstract Log getLogger ( ) ; protected abstract String getDbFriendlyName ( ) ; protected boolean skipped ; @ Override protected String getTablePrefix ( ) { return \"MGR_\" + getDbFriendlyName ( ) . toUpperCase ( ) + \"_\" ; } @ Override protected boolean useHsqldbTestServer ( ) { return false ; } @ Override public void setUp ( ) { log = getLogger ( ) ; skipped = false ; super . setUp ( ) ; } @ Override public void tearDown ( ) { try { dropTableIfExists ( getTableName ( ) ) ; } catch ( SQLException e ) { log . warn ( \"Error trying to drop table '\" + getTableName ( ) + \"' on tearDown: \" + e ) ; } super . tearDown ( ) ; } protected boolean supportsBoolean ( ) { return true ; } protected boolean supportsBigInt ( ) { return true ; } protected boolean supportsTinyInt ( ) { return true ; } protected boolean supportsLongVarChar ( ) { return true ; } protected boolean supportsVarBinary ( ) { return true ; } protected boolean supportsTime ( ) { return true ; } protected boolean supportsClob ( ) { return true ; } protected boolean supportsBlob ( ) { return true ; } protected String getNumericType ( ) { return \"NUMERIC(\" + getNumericScale ( ) + \", \" + getNumericDecPartDigits ( ) + \")\" ; } protected String getDecimalType ( ) { return \"DECIMAL(\" + getDecimalScale ( ) + \", \" + getDecimalDecPartDigits ( ) + \")\" ; } protected int getNumericScale ( ) { return 30 ; } protected int getNumericDecPartDigits ( ) { return 5 ; } protected int getDecimalScale ( ) { return 30 ; } protected int getDecimalDecPartDigits ( ) { return 5 ; } protected String getDoubleType ( ) { return \"DOUBLE\" ; } protected String getLongVarCharType ( ) { return \"LONGVARCHAR\" ; } protected String getTimestampType ( ) { return \"TIMESTAMP\" ; } protected String getClobType ( ) { return \"CLOB\" ; } protected String getBlobType ( ) { return \"BLOB\" ; } protected String getVarBinaryType ( ) { return \"VARBINARY(12)\" ; } protected String getTinyIntType ( ) { return \"TINYINT\" ; } protected String getTrueBoolNumericSqlInput ( ) { return \"1\" ; } protected String getFalseBoolNumericSqlInput ( ) { return \"0\" ; } protected String getTrueBoolLiteralSqlInput ( ) { return \"true\" ; } protected String getFalseBoolLiteralSqlInput ( ) { return \"false\" ; } protected String getTrueBoolSeqOutput ( ) { return \"true\" ; } protected String getFalseBoolSeqOutput ( ) { return \"false\" ; } protected String padString ( int width , String str ) { int extra = width - str . length ( ) ; for ( int i = 0 ; i < extra ; i ++ ) { str = str + \" \" ; } return str ; } protected String withDecimalZero ( String floatingPointStr ) { if ( floatingPointStr . indexOf ( \".\" ) == - 1 ) { return floatingPointStr + \".0\" ; } else { return floatingPointStr ; } } protected String getRealSeqOutput ( String realAsInserted ) { return withDecimalZero ( realAsInserted ) ; } protected String getFloatSeqOutput ( String floatAsInserted ) { return withDecimalZero ( floatAsInserted ) ; } protected String getDoubleSeqOutput ( String doubleAsInserted ) { return withDecimalZero ( doubleAsInserted ) ; } protected String getDateInsertStr ( String insertStr ) { return insertStr ; } protected String getTimeInsertStr ( String insertStr ) { return insertStr ; } protected String getTimestampInsertStr ( String insertStr ) { return insertStr ; } protected String getDateSeqOutput ( String dateAsInserted ) { return dateAsInserted ; } protected String getTimestampSeqOutput ( String tsAsInserted ) { if ( \"null\" . equals ( tsAsInserted ) ) { return tsAsInserted ; } int dotPos = tsAsInserted . indexOf ( \".\" ) ; if ( - 1 == dotPos ) { return tsAsInserted + \".0\" ; } else { return tsAsInserted ; } } protected String getNumericSeqOutput ( String numAsInserted ) { return numAsInserted ; } protected String getDecimalSeqOutput ( String numAsInserted ) { return numAsInserted ; } protected String getFixedCharSeqOut ( int fieldWidth , String asInserted ) { return asInserted ; } protected String getBlobInsertStr ( String blobData ) { return \"'\" + blobData + \"'\" ; } protected byte [ ] getBlobDbOutput ( String asInserted ) { try { return asInserted . getBytes ( \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { fail ( \"Could not get utf8 bytes\" ) ; return null ; } } protected String getBlobSeqOutput ( String asInserted ) { return new BytesWritable ( getBlobDbOutput ( asInserted ) ) . toString ( ) ; } protected String getVarBinarySeqOutput ( String asInserted ) { return new BytesWritable ( getBlobDbOutput ( asInserted ) ) . toString ( ) ; } protected String", "gt": "toLowerHexString ( String str )", "prediction": "( )\n", "label": 1}
{"id": 8756, "input": "<s> package org . parboiled . common ; public class ConsoleSink implements Sink < String > { public void receive ( String value ) { System .", "gt": "out . print ( value ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5030, "input": "<s> package net . claribole . zgrviewer ; import java . util . Vector ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . ClosedShape ; import fr . inria . zvtm . glyphs . VText ; import fr . inria . zvtm . svg . Metadata ; public class LNode extends LElem { LEdge [ ] edges ; short [ ] edgeDirections ; LNode ( String title , Vector < Glyph > gls ) { this . title = title ; this . glyphs = new Glyph [ gls . size ( ) ] ; this . URLs = new String [ gls . size ( ) ] ; this . tooltips = new String [ gls . size ( ) ] ; for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] = gls . elementAt ( i ) ; if ( this . glyphs [ i ] . getOwner ( ) != null ) { URLs [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURL ( ) ; tooltips [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURLTitle ( ) ; } } if ( this . glyphs . length > 0 ) { this . groupID = ( ( Metadata ) this . glyphs [ 0 ] . getOwner ( ) ) . getClosestAncestorGroupID ( ) ; } else { this . groupID = Messages . EMPTY_STRING ; } for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] . setOwner ( this ) ; } edges = new LEdge [ 0 ] ; edgeDirections = new short [ 0 ] ; } public String getURL ( Glyph g ) { for ( int i = 0 ; i < glyphs . length ; i ++ ) { if ( g == glyphs [ i ] ) { return URLs [ i ] ; } } return null ; } public String getTooltip ( Glyph g ) { for ( int i = 0 ; i < glyphs . length ; i ++ ) { if ( g == glyphs [ i ] ) { return tooltips [ i ] ; } } return null ; } void addArc ( LEdge e , short direction ) { LEdge [ ] nedges = new LEdge [ edges . length + 1 ] ; short [ ] nedgeDirections = new short [ edgeDirections . length + 1 ] ; System . arraycopy ( edges , 0 , nedges , 0 , edges . length ) ; System . arraycopy ( edgeDirections , 0 , nedgeDirections , 0 , edgeDirections . length ) ; nedges [ edges . length ] = e ; nedgeDirections [ edgeDirections . length ] = direction ; edges = nedges ; edgeDirections = nedgeDirections ; } void removeArc ( LEdge e ) { int index = - 1 ; for ( int i = 0 ; i < edges . length ; i ++ ) { if ( edges [ i ] == e ) { index = i ; break ; } } if ( index != - 1 ) { LEdge [ ] nedges = new LEdge [ edges . length - 1 ] ; short [ ] nedgeDirections = new short [ edgeDirections . length - 1 ] ; System . arraycopy ( edges , 0 , nedges , 0 , index ) ; System . arraycopy ( edges , index + 1 , nedges , index , edges . length - index - 1 ) ; System . arraycopy ( edgeDirections , 0 , nedgeDirections , 0 , index ) ; System . arraycopy ( edgeDirections , index + 1 , nedgeDirections , index , edgeDirections . length - index - 1 ) ; edges = nedges ; edgeDirections = nedgeDirections ; } } public LEdge [ ] getAllArcs ( ) { LEdge [ ] res = new LEdge [ edges . length ] ; System . arraycopy ( edges , 0 , res , 0 , edges . length ) ; return res ; } public LEdge [ ] getOtherArcs ( LEdge arc ) { int count = 0 ;", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 1}
{"id": 6076, "input": "<s> package org . gk . ui . client . themes ; import com . extjs . gxt . themes . client . access . image . AccessImages ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . util . Theme ; import com . google . gwt . core . client . GWT ; @ SuppressWarnings ( \"serial\" ) public class AccessTheme extends Theme { public static Theme ACCESS = new AccessTheme ( ) ; public AccessTheme ( ) {", "gt": "this ( \"Access Theme\" ) ;", "prediction": "}\n", "label": 0}
{"id": 5034, "input": "<s> package org . nuxeo . ecm . platform . task . core . helpers ; import java . util . ArrayList ; import java . util . List ; import org . nuxeo . ecm . core . api . NuxeoGroup ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; public final class TaskActorsHelper { private TaskActorsHelper ( ) { } public static List < String > getTaskActors ( NuxeoPrincipal principal ) { List < String > actors = new ArrayList < String > ( ) ; String name = principal . getName ( ) ; actors . add ( name ) ; if ( ! name . startsWith ( NuxeoPrincipal . PREFIX ) ) { actors . add ( NuxeoPrincipal . PREFIX + name ) ; } else { actors . add ( name . substring ( NuxeoPrincipal . PREFIX . length ( ) ) ) ; } for ( String group : principal . getAllGroups ( ) ) { actors . add ( group ) ; if ( ! group . startsWith (", "gt": "NuxeoGroup . PREFIX ) )", "prediction": ") ;\n", "label": 1}
{"id": 1215, "input": "<s> package com . sun . javadoc ; public interface WildcardType extends Type { Type [ ] extendsBounds ( ) ; Type", "gt": "[ ] superBounds ( ) ;", "prediction": "\n", "label": 0}
{"id": 5038, "input": "<s> package org . nuxeo . ecm . platform . task ; import java . io . Serializable ; import java . util . Date ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; public interface Task extends Serializable { String TASK_PROVIDER_KEY = \"taskProviderId\" ; DocumentModel getDocument ( ) ; String getId ( ) ; String getTargetDocumentId ( ) ; List < String > getActors ( ) throws ClientException ; String getInitiator ( ) throws ClientException ; String getName ( ) throws ClientException ; String getType ( ) throws ClientException ; String getProcessId ( ) throws ClientException ; String getDescription ( ) throws ClientException ; String getDirective ( ) throws ClientException ; List < TaskComment > getComments ( ) throws ClientException ; String getVariable ( String key ) throws ClientException ; Date getDueDate ( ) throws ClientException ; Date getCreated ( ) throws ClientException ; Boolean isCancelled ( ) throws ClientException ; Boolean isOpened ( ) throws ClientException ; Boolean hasEnded ( ) throws ClientException ; Boolean isAccepted ( ) throws ClientException ; Map < String , String > getVariables ( ) throws ClientException ; void setActors ( List < String > actors ) throws ClientException ; void setInitiator ( String initiator ) throws ClientException ; void setTargetDocumentId ( String targetDocumentId ) throws ClientException ; void setName ( String name ) throws ClientException ; void setType ( String type ) throws ClientException ; void setProcessId ( String processId ) throws ClientException ; void setDescription ( String description ) throws ClientException ; void setDirective ( String directive ) throws ClientException ; void setVariable ( String key , String value ) throws ClientException ; void setDueDate ( Date dueDate ) throws ClientException ; void setCreated ( Date", "gt": "created ) throws ClientException ;", "prediction": ") ;\n", "label": 1}
{"id": 6854, "input": "<s> import java . util . EnumSet ; import java . util . Set ; import javax . lang . model . SourceVersion ; import javax . tools . Tool ; import javax . tools . ToolProvider ; import static javax . lang . model . SourceVersion . * ; public class T6395981 { public static void main ( String ... args ) { Tool compiler = ToolProvider . getSystemJavaCompiler ( ) ; Set < SourceVersion > expected = EnumSet . noneOf ( SourceVersion . class ) ; for ( String arg : args ) expected . add ( SourceVersion . valueOf ( arg ) ) ; Set < SourceVersion", "gt": "> found = compiler . getSourceVersions ( ) ;", "prediction": ";\n", "label": 0}
{"id": 5065, "input": "<s> package org . mitre . jwt . signer . impl ; import static org . junit . Assert . assertEquals ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mitre . jwt . model . Jwt ; import org . mitre . jwt . model . JwtClaims ; import org . mitre . jwt . model . JwtHeader ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import com . google . gson . JsonIOException ; import com . google . gson . JsonObject ; import com . google . gson . JsonParser ; import com . google . gson . JsonSyntaxException ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { \"classpath:test-context.xml\" } ) public class Hmac384Test { URL claimsUrl = this . getClass ( ) . getResource ( \"/jwt/claims\" ) ; URL hs384Url = this . getClass ( ) . getResource ( \"/jwt/hs384\" ) ; Jwt jwt = null ; JwtClaims claims = null ; JwtHeader header = null ; @ Before public void setUp ( ) throws JsonIOException , JsonSyntaxException , IOException { JsonParser parser = new JsonParser ( ) ; JsonObject claimsObject = parser . parse ( new BufferedReader ( new InputStreamReader ( claimsUrl . openStream ( ) ) ) ) . getAsJsonObject ( ) ; JsonObject headerObject = parser . parse ( new BufferedReader ( new InputStreamReader ( hs384Url . openStream ( ) ) ) ) . getAsJsonObject ( ) ; claims = new JwtClaims ( claimsObject ) ; header = new JwtHeader ( headerObject ) ; jwt = new Jwt ( header , claims , null ) ; } @ After public void tearDown ( ) { } @ Test public void testHmacSigner384 ( ) throws Exception { setUp ( ) ; HmacSigner hmac = new HmacSigner ( header", "gt": ". getAlgorithm ( ) , \"secret\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3539, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . gmf . mappings . NodeReference ; public interface SimpleNodeReference extends EObject {", "gt": "NodeReference getNodeReference ( ) ;", "prediction": ";\n", "label": 0}
{"id": 5077, "input": "<s> package monbulk . MethodBuilder . client . model ; import java . util . Iterator ; import monbulk . shared . Architecture . IPresenter . FormPresenter ; import monbulk . shared . Architecture . iModel . iFormModel ; import monbulk . shared . Form . DictionaryFormField ; import monbulk . shared . Form . FormBuilder ; import monbulk . shared . Form . iFormField ; import monbulk . shared . Model . IPojo ; import monbulk . shared . Model . pojo . pojoStepDetails ; public abstract class baseModel implements iFormModel { protected IPojo dataObject ; protected FormBuilder formData ; protected FormPresenter Presenter ; public void convertPojoToForm ( IPojo dataObject ) { this . formData = dataObject . getFormStructure ( ) ; } public void savePojo ( ) { } public String getStringRpresentation ( String Format ) { return this . dataObject . writeOutput ( Format ) ; } @ Override public String ValidateForm ( ) { Iterator < iFormField > i = this . formData . getFormDetails ( ) . iterator ( ) ; String Validation = \"\" ; while ( i . hasNext ( ) ) { iFormField tmpItem = i . next ( ) ; if ( tmpItem . getFieldTypeName ( ) == \"String\" || tmpItem . getFieldTypeName ( ) == \"Description\" ) { if ( ! tmpItem . hasValue ( ) ) { Validation = Validation + \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } else { Validation = Validation + tmpItem . Validate ( tmpItem . GetFieldValue ( ) . toString ( ) ) ; } } else if ( tmpItem . getFieldTypeName ( ) == \"List\" || tmpItem . getFieldTypeName ( ) == \"Dictionary\" ) { if ( this . formData . getFormName ( ) . contains ( pojoStepDetails . FormName ) ) { iFormField tmpField = this . formData . getFieldItemForName ( pojoStepDetails . HasStudyField ) ; if ( tmpField != null ) { if ( tmpField . hasValue ( ) ) { if ( tmpField . GetFieldValue ( ) == \"true\" ) { Validation = Validation + ValidateDictionary ( tmpItem ) ; } } } } else { Validation = Validation + ValidateDictionary ( tmpItem ) ; } } } return Validation ; } private String ValidateDictionary ( iFormField tmpItem ) { if ( tmpItem != null ) { if ( ! tmpItem . hasValue ( ) ) { return \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } else if ( tmpItem . GetFieldValue ( ) . toString ( ) . contains ( \"null\" ) ) { return \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } else if ( ( tmpItem . GetFieldValue ( ) . toString ( ) . contains ( DictionaryFormField . defaultField ) ) ) { return \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } else if ( tmpItem . GetFieldValue ( ) . toString ( ) . length ( ) == 0 ) { return \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } else { return \"\" ; } } else { return \"<p>Please provide a value for the \" + tmpItem . GetFieldName ( ) + \" field</p>\" ; } } @ Override public String ValidateForm ( String FormName ) { return this . ValidateForm ( ) ; } @ Override public FormBuilder getFormData ( ) { return this . formData ; } public iFormField getFormItem ( String FieldName ) { if ( this . formData != null ) { iFormField thisField = this . formData", "gt": ". getFieldItemForName ( FieldName ) ;", "prediction": ";\n", "label": 1}
{"id": 5838, "input": "<s> package com . asakusafw . example . jdbc . operator ; import java . util . List ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . CategorySummary ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ErrorRecord ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ItemInfo ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . JoinedSalesInfo ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . SalesDetail ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . StoreInfo ; import com . asakusafw . runtime . value . Date ; import com . asakusafw . runtime . value . DateTime ; import com . asakusafw . runtime . value . DateUtil ; import com . asakusafw . vocabulary . model . Key ; import com . asakusafw . vocabulary . operator . MasterCheck ; import com . asakusafw . vocabulary . operator . MasterJoin ; import com . asakusafw . vocabulary . operator . MasterSelection ; import com . asakusafw . vocabulary . operator . Summarize ; import com .", "gt": "asakusafw . vocabulary . operator . Update ;", "prediction": "org . eclipse . eclipse . ;\n", "label": 0}
{"id": 5078, "input": "<s> package com . cloudera . sqoop ; import java . io . IOException ; import java . util . ArrayList ; import org . apache . commons . cli . ParseException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . IOUtils ; import org . apache . hadoop . io . SequenceFile ; import org . apache . hadoop . util . ReflectionUtils ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . orm . CompilationManager ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . HsqldbTestServer ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; import com . cloudera . sqoop . testutil . SeqFileReader ; import com . cloudera . sqoop . tool . ImportTool ; import com . cloudera . sqoop . util . ClassLoaderStack ; public class TestBoundaryQuery extends ImportJobTestCase { protected String [ ] getArgv ( boolean includeHadoopFlags , boolean tableImport , String boundaryQuery , String targetDir , String ... extraArgs ) { ArrayList < String > args = new ArrayList < String > ( ) ; if ( includeHadoopFlags ) { CommonArgs . addHadoopFlags ( args ) ; } if ( tableImport ) { args . add ( \"--table\" ) ; args . add ( HsqldbTestServer . getTableName ( ) ) ; } else { args . add ( \"--query\" ) ; args . add ( \"SELECT INTFIELD1, INTFIELD2 FROM \" + HsqldbTestServer . getTableName ( ) + \" WHERE $CONDITIONS\" ) ; } args . add ( \"--connect\" ) ; args . add ( HsqldbTestServer . getUrl ( ) ) ; if ( boundaryQuery != null ) { args . add ( \"--boundary-query\" ) ; args . add ( boundaryQuery ) ; } args . add ( \"--as-sequencefile\" ) ; args . add ( \"--target-dir\" ) ; args . add ( targetDir ) ; args . add ( \"--class-name\" ) ; args . add ( getTableName ( ) ) ; args . add ( \"--verbose\" ) ; for ( String extraArg : extraArgs ) { args . add ( extraArg ) ; } return args . toArray ( new String [ 0 ] ) ; } protected String getTableName ( ) { return HsqldbTestServer . getTableName ( ) ; } private int getFirstInt ( String str ) { String [ ] parts = str . split ( \",\" ) ; return Integer . parseInt ( parts [ 0 ] ) ; } public void runQueryTest ( String query , boolean tableImport , int numExpectedResults , int expectedSum , String targetDir , String ... extraArgs ) throws IOException { ClassLoader prevClassLoader = null ; SequenceFile . Reader reader = null ; String [ ] argv = getArgv ( true , tableImport , query , targetDir , extraArgs ) ; runImport ( argv ) ; try { SqoopOptions opts = new ImportTool ( ) . parseArguments ( getArgv ( false , tableImport , query , targetDir , extraArgs ) , null , null , true ) ; CompilationManager compileMgr = new CompilationManager ( opts ) ; String jarFileName = compileMgr . getJarFilename ( ) ; prevClassLoader = ClassLoaderStack . addJarFile ( jarFileName , getTableName ( ) ) ; reader = SeqFileReader . getSeqFileReader ( getDataFilePath ( ) . toString ( ) ) ; Configuration conf = new Configuration ( ) ; Object key = ReflectionUtils . newInstance ( reader . getKeyClass ( ) , conf ) ; Object val = ReflectionUtils . newInstance ( reader . getValueClass ( ) , conf ) ; if ( reader . next ( key ) == null ) { fail ( \"Empty SequenceFile during import\" ) ; } reader . getCurrentValue ( val ) ; int curSum = getFirstInt ( val . toString ( ) ) ; int totalResults = 1 ; while ( reader . next ( key ) != null ) { reader . getCurrentValue ( val ) ; curSum += getFirstInt ( val . toString ( ) ) ; totalResults ++ ; } assertEquals ( \"Total sum of first db column mismatch\" , expectedSum , curSum ) ; assertEquals ( \"Incorrect number", "gt": "of results for query\" , numExpectedResults , totalResults ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9667, "input": "<s> package org . ofbiz . webapp . ftl ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import freemarker . core . Environment ; import freemarker . ext . beans . BeanModel ; import freemarker . template . SimpleScalar ; import freemarker . template . TemplateMethodModelEx ; import freemarker . template . TemplateModelException ; import freemarker . template . TemplateNumberModel ; import freemarker . template . TemplateScalarModel ; public class SetRequestAttributeMethod implements TemplateMethodModelEx { public static final String module = SetRequestAttributeMethod . class . getName ( ) ; @ SuppressWarnings ( \"unchecked\" ) public Object exec ( List args ) throws TemplateModelException { if ( args == null || args . size ( ) != 2 ) throw new TemplateModelException ( \"Invalid number of arguements\" ) ; if ( ! ( args . get ( 0 ) instanceof TemplateScalarModel ) ) throw new TemplateModelException ( \"First argument not an instance of TemplateScalarModel\" ) ; if ( ! ( args . get ( 1 ) instanceof BeanModel ) && ! ( args . get ( 1 ) instanceof TemplateNumberModel ) && ! ( args . get ( 1 ) instanceof TemplateScalarModel ) ) throw new TemplateModelException ( \"Second argument not an instance of BeanModel", "gt": "nor TemplateNumberModel nor TemplateScalarModel\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5081, "input": "<s> package org . apache . lucene . messages ; public class MessagesTestBundle extends NLS { private static final String BUNDLE_NAME = MessagesTestBundle . class . getName ( ) ; private MessagesTestBundle ( ) { } static { NLS . initializeMessages ( BUNDLE_NAME , MessagesTestBundle . class ) ; } public static String Q0001E_INVALID_SYNTAX ;", "gt": "public static String Q0004E_INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION ;", "prediction": "}\n", "label": 1}
{"id": 6386, "input": "<s> package Liza ; import org . bukkit . entity . Fireball ;", "gt": "public interface LizaFireball extends Fireball", "prediction": "}\n", "label": 0}
{"id": 5119, "input": "<s> package monbulk . MetadataEditor ; import com . google . gwt . core . client . GWT ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . Widget ; import com . google . gwt . user . client . ui . ListBox ; import com . google . gwt . user . client . ui . Button ; import com . google . gwt . event . dom . client . ChangeEvent ; import com . google . gwt . event . dom . client . ClickEvent ; import monbulk . shared . Services . Element ; import monbulk . shared . widgets . Window . WindowSettings ; import monbulk . shared . widgets . Window . OkCancelWindow . * ; import monbulk . client . desktop . Desktop ; public class AttributesPanel extends ElementPanel implements OkCancelHandler , CommonElementPanel . ChangeTypeHandler , ValidateHandler { private static AttributesPanelUiBinder uiBinder = GWT . create ( AttributesPanelUiBinder . class ) ; interface AttributesPanelUiBinder extends UiBinder < Widget , AttributesPanel > { } @ UiField ListBox m_attributes ; @ UiField Button m_add ; @ UiField Button m_remove ; @ UiField Button m_edit ; private Element m_editAttribute ; private Element m_newAttribute ; private boolean m_addNewElement = false ; private boolean m_typeChanged = false ; private ElementEditor m_elementEditor ; public AttributesPanel ( ) throws Exception { initWidget ( uiBinder . createAndBindUi ( this ) ) ; m_elementEditor = new ElementEditor ( false ) ; m_elementEditor . setChangeTypeHandler ( this ) ; m_elementEditor . setValidateHandler ( this ) ; WindowSettings w = m_elementEditor . getWindowSettings ( ) ; w . windowId = \"ElementEditor-Attributes\" ; w . windowTitle = \"Attribute\" ; Desktop . get ( ) . registerWindow ( m_elementEditor ) ; } public void set ( Element element ) { super . set ( element ) ; m_attributes . clear ( ) ; int numAttributes = element . getNumAttributes ( ) ; for ( int i = 0 ; i < numAttributes ; i ++ ) { Element attribute = element . getAttribute ( i ) ; String name = attribute . getName ( ) ; if ( name . length ( ) > 0 ) { m_attributes . addItem ( name ) ; } } setButtonState ( false ) ; } public void update ( Element element ) { } public Element . ElementTypes getType ( ) { return Element . ElementTypes . Attribute ; } @ UiHandler ( \"m_attributes\" ) void onAttributeSelected ( ChangeEvent event ) { setButtonState ( true ) ; } private void showEditor ( Element element , boolean addNewElement ) { Desktop d = Desktop . get ( ) ; m_typeChanged = false ; m_editAttribute = element ; m_addNewElement = addNewElement ; m_elementEditor . setOkCancelHandler ( this ) ; m_elementEditor . setMetadataElement ( element ) ; d . show ( m_elementEditor , true ) ; } @ UiHandler ( \"m_edit\" ) void onEditClicked ( ClickEvent event ) { int index = m_attributes . getSelectedIndex ( ) ; int numAttributes = m_element . getNumAttributes ( ) ; if ( index >= 0 && index < numAttributes ) { Element element = m_element . getAttribute ( index ) ; showEditor ( element , false ) ; } } @ UiHandler ( \"m_remove\" ) void onRemoveClicked ( ClickEvent event ) { int index = m_attributes . getSelectedIndex ( ) ; int numAttributes = m_element . getNumAttributes ( ) ; if ( index >= 0 && index < numAttributes ) { m_element . removeAttribute ( index ) ; m_attributes . removeItem ( index ) ; index = index < numAttributes ? index : ( numAttributes - 1 ) ; if ( index >= 0 ) { m_attributes . setSelectedIndex ( index ) ; } else { setButtonState ( false ) ; } } } @ UiHandler ( \"m_add\" ) void onAddClicked ( ClickEvent event ) { try { Element element = Element . createElement ( Element . ElementTypes . String , \"attribute\" , \"An attribute\" , true ) ; showEditor ( element , true ) ; } catch ( Exception e ) { GWT . log ( e . toString ( ) ) ; } } private void setButtonState ( boolean enabled ) { m_edit . setEnabled ( enabled ) ; m_remove . setEnabled ( enabled ) ; } public void onOkCancelClicked ( OkCancelHandler . Event event ) { switch ( event ) { case Ok : { if ( m_addNewElement ) { String name =", "gt": "m_editAttribute . getName ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8405, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . tools . doclets . internal . toolkit . util . * ; public abstract class Content { public String toString ( ) { StringBuilder contentBuilder = new StringBuilder ( ) ; write ( contentBuilder ) ; return contentBuilder . toString ( ) ; } public abstract void addContent ( Content content ) ; public abstract void addContent ( String stringContent ) ; public abstract void write ( StringBuilder contentBuilder ) ; public abstract boolean isEmpty ( ) ; public boolean isValid ( ) { return ! isEmpty ( ) ; } protected static < T > T nullCheck ( T t ) { t . getClass ( ) ; return t ; } protected boolean endsWithNewLine ( StringBuilder contentBuilder ) { int contentLength = contentBuilder . length ( ) ; if ( contentLength == 0 ) { return true ; } int nlLength = DocletConstants . NL . length ( ) ; if ( contentLength < nlLength ) { return false ; } int contentIndex", "gt": "= contentLength - 1 ;", "prediction": ";\n", "label": 0}
{"id": 5141, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . graphics . Image ; public interface ILabelProvider extends IBaseLabelProvider { public Image getImage ( Object element ) ;", "gt": "public String getText ( Object element ) ;", "prediction": "}\n", "label": 1}
{"id": 7422, "input": "<s> package com . matburt . mobileorg . Views ; import android . app . Activity ; import android . content . Context ; import android . content . SharedPreferences ; import android . util . AttributeSet ; import android . util . Log ; import android . view . GestureDetector ; import android . view . GestureDetector . SimpleOnGestureListener ; import android . view . LayoutInflater ; import android . view . MotionEvent ; import android . view . View ; import android . view . inputmethod . InputMethodManager ; import android . widget . Button ; import android . widget . HorizontalScrollView ; import com . matburt . mobileorg . R ; public class PageFlipView extends HorizontalScrollView implements View . OnTouchListener { static String TAG = \"PageFlipView\" ; static final int SWIPE_MIN_DISTANCE = 5 ; static final int SWIPE_THRESHOLD_VELOCITY = 50 ; public static final int FIRST_PAGE = 0 , MIDDLE_PAGE = 1 , LAST_PAGE = 2 ; GestureDetector mGestureDetector ; WideLinearLayout container ; NextPageButtonListener nextPageButtonListener ; PreviousPageButtonListener previousPageButtonListener ; int maxScrollX ; int maxEnabledPage = - 1 ; int currentPage = 0 ; int screenWidth ; public PageFlipView ( Context context ) { super ( context ) ; } public PageFlipView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; nextPageButtonListener = new NextPageButtonListener ( ) ; previousPageButtonListener = new PreviousPageButtonListener ( ) ; mGestureDetector = new GestureDetector ( getContext ( ) , new PageSwipeDetector ( ) ) ; setOnTouchListener ( this ) ; } @ Override protected void onMeasure ( int w , int h ) { int width = MeasureSpec . getSize ( w ) ; container . setWidth ( width ) ; super . onMeasure ( w , h ) ; } @ Override public void onFinishInflate ( ) { container = ( WideLinearLayout ) findViewById ( R . id . wizard_container ) ; } private static void setButtonState ( Button b , boolean state , View . OnClickListener e ) { b . setOnClickListener ( e ) ; b . setEnabled ( state ) ; } public void enableNextButton ( Button b ) { b . setOnClickListener ( nextPageButtonListener ) ; b . setEnabled ( true ) ; } public void disableAllNextActions ( int page ) { if ( container != null ) for ( int i = page ; i < container . getChildCount ( ) ; i ++ ) { View pageContainer = ( View ) container . getChildAt ( i ) ; View nextButton = pageContainer . findViewById ( R . id . wizard_next_button ) ; if ( nextButton != null ) nextButton . setEnabled ( false ) ; } maxScrollX = page * getMeasuredWidth ( ) ; } public void setNavButtonStateOnPage ( int page , boolean state , int page_type ) { View pageContainer = ( View ) container . getChildAt ( page ) ; Button prevButton = ( Button ) pageContainer . findViewById ( R . id . wizard_previous_button ) ; Button nextButton = ( Button ) pageContainer . findViewById ( R . id . wizard_next_button ) ; switch ( page_type ) { case FIRST_PAGE : setButtonState ( nextButton , state , nextPageButtonListener ) ; break ; case MIDDLE_PAGE : setButtonState ( prevButton , state , previousPageButtonListener ) ; setButtonState ( nextButton , state , nextPageButtonListener ) ; break ; case LAST_PAGE : setButtonState ( prevButton , state , previousPageButtonListener ) ; break ; } } public void setDoneButtonOnClickListener ( View . OnClickListener e ) { Button done = ( Button ) container . findViewById ( R . id . wizard_done_button ) ; done . setOnClickListener ( e ) ; } public void enablePage ( int page ) { if ( page == - 1 ) { maxScrollX = 0 ; maxEnabledPage = - 1 ; return ; } int page_type = MIDDLE_PAGE ; if ( page == getNumberOfPages ( ) - 1 ) page_type = LAST_PAGE ; else if ( page == 0 ) page_type = 0 ; setNavButtonStateOnPage ( page , true , page_type ) ; maxScrollX = ( page + 1 ) * getMeasuredWidth ( ) ; maxEnabledPage = ( page > maxEnabledPage ) ? page : maxEnabledPage ; } public int getNumberOfPages ( ) { return container . getChildCount ( ) ; } public int getCurrentPage ( ) { return currentPage ; } public void setCurrentPage ( int i ) { currentPage = i ; } public void restoreLastPage ( ) { SharedPreferences prefs = ( ( Activity ) getContext ( ) ) . getPreferences ( 0 ) ; currentPage = prefs . getInt ( \"currentPage\" , 0 ) ; maxEnabledPage = prefs . getInt ( \"maxEnabledPage\" , - 1 ) ; post ( new Runnable ( ) { @ Override public void run ( ) { enablePage ( maxEnabledPage ) ; scrollTo ( currentPage * getMeasuredWidth (", "gt": ") , 0 ) ;", "prediction": ") )\n", "label": 0}
{"id": 5144, "input": "<s> package org . nuxeo . ecm . platform . annotations . repository . descriptor ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . annotations . repository . service . SecurityManager ; @ XObject ( \"securityManager\" ) public class SecurityManagerDescriptor { @ XNode ( \"@class\" ) private Class < ?", "gt": "extends SecurityManager > klass ;", "prediction": ";\n", "label": 1}
{"id": 6352, "input": "<s> package org . ofbiz . webapp . control ; import java . sql . Timestamp ; import java . util . Enumeration ; import java . util . Map ; import javax . servlet . http . HttpSession ; import javax . servlet . http . HttpSessionEvent ; import javax . servlet . http . HttpSessionListener ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . serialize . XmlSerializer ; import org . ofbiz . entity . transaction . TransactionUtil ; public class ControlEventListener implements HttpSessionListener { public static final String module = ControlEventListener . class . getName ( ) ; protected static long totalActiveSessions = 0 ; protected static long totalPassiveSessions = 0 ; public ControlEventListener ( ) { } public void sessionCreated ( HttpSessionEvent event ) { HttpSession session = event . getSession ( ) ; countCreateSession ( ) ; if ( System . getProperty ( \"org.ofbiz.log.session.stats\" ) != null ) { session . setAttribute ( \"org.ofbiz.log.session.stats\" , \"Y\" ) ; } Debug . logInfo ( \"Creating session: \" + session . getId ( ) , module ) ; } public void sessionDestroyed ( HttpSessionEvent event ) { HttpSession session = event . getSession ( ) ; boolean beganTransaction = false ; try { beganTransaction = TransactionUtil . begin ( ) ; GenericValue visit = ( GenericValue ) session . getAttribute ( \"visit\" ) ; if ( visit != null ) { Delegator delegator = visit . getDelegator ( ) ; visit = delegator . findOne ( \"Visit\" , UtilMisc . toMap ( \"visitId\" , visit . get ( \"visitId\" ) ) , false ) ; if ( visit != null ) { visit . set ( \"thruDate\" , new Timestamp ( session . getLastAccessedTime ( ) ) ) ; visit . store ( ) ; } } else { Debug . logWarning ( \"Could not find visit value object in session [\" + session . getId ( ) + \"] that is being destroyed\" , module ) ; } String userLoginSessionString = getUserLoginSession ( session ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; if ( userLogin != null && userLoginSessionString != null ) { GenericValue userLoginSession = null ; userLoginSession = userLogin . getRelatedOne ( \"UserLoginSession\" , false ) ; if ( userLoginSession == null ) { userLoginSession = userLogin . getDelegator ( ) . makeValue ( \"UserLoginSession\" , UtilMisc . toMap ( \"userLoginId\" , userLogin . getString ( \"userLoginId\" ) ) ) ; userLogin . getDelegator ( ) . create ( userLoginSession ) ; } userLoginSession . set ( \"savedDate\" , UtilDateTime . nowTimestamp ( ) ) ; userLoginSession . set ( \"sessionData\" , userLoginSessionString ) ; userLoginSession . store ( ) ; } countDestroySession ( ) ; Debug . logInfo ( \"Destroying session: \" + session . getId ( ) , module ) ; this . logStats ( session , visit ) ; }", "gt": "catch ( GenericEntityException e )", "prediction": "}\n", "label": 0}
{"id": 5155, "input": "<s> package org . nuxeo . ecm . automation . client . model ; import java . text . ParseException ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . TimeZone ; public class DateParser { public static Calendar parse ( String str ) throws ParseException { if ( str == null ) { return null ; } Calendar cal = new GregorianCalendar ( TimeZone . getTimeZone ( \"UTC\" ) ) ; cal . clear ( ) ; int len = str . length ( ) ; if ( len == 0 ) { return cal ; } int i = 0 ; i = readYear ( cal , str , i ) ; i = readCharOpt ( '-' , cal , str , i ) ; if ( i == - 1 ) { return cal ; } i = readMonth ( cal , str , i ) ; i = readCharOpt ( '-' , cal , str , i ) ; if ( i == - 1 ) { return cal ; } i = readDay ( cal , str , i ) ; i = readCharOpt ( 'T' , cal , str , i ) ; if ( i == - 1 ) { return cal ; } i = readHours ( cal , str , i ) ; i = readCharOpt ( ':' , cal , str , i ) ; if ( i == - 1 ) { return cal ; } i = readMinutes ( cal , str , i ) ; if ( isChar ( ':' , str , i ) ) { i = readSeconds ( cal , str , i + 1 ) ; if ( isChar ( '.' , str , i ) ) { i = readMilliseconds ( cal , str , i + 1 ) ; } } if ( i > - 1 ) { readTimeZone ( cal , str , i ) ; } return cal ; } public static Date parseW3CDateTime ( String str ) { if ( str == null ) { return null ; } try { return parse ( str ) . getTime ( ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( \"Failed to parse ISO 8601 date: \" + str , e ) ; } } public static String formatW3CDateTime ( Date date ) { if ( date == null ) { return null ; } Calendar cal = new GregorianCalendar ( TimeZone . getTimeZone ( \"UTC\" ) ) ; cal . setTime ( date ) ; StringBuilder buf = new StringBuilder ( 32 ) ; return buf . append ( cal . get ( Calendar . YEAR ) ) . append ( '-' ) . append ( pad ( cal . get ( Calendar . MONTH ) + 1 ) ) . append ( '-' ) . append ( pad ( cal . get ( Calendar . DATE ) ) ) . append ( 'T' ) . append ( pad ( cal . get ( Calendar . HOUR_OF_DAY ) ) ) . append ( ':' ) . append ( pad ( cal . get ( Calendar . MINUTE ) ) ) . append ( ':' ) . append ( pad ( cal . get ( Calendar . SECOND ) ) ) . append ( 'Z' ) . toString ( ) ; } public static String formatW3CDateTimeMs ( Date date ) { if ( date == null ) { return null ; } Calendar cal = new GregorianCalendar ( TimeZone . getTimeZone ( \"UTC\" ) ) ; cal . setTime ( date ) ; StringBuilder buf = new StringBuilder ( 32 ) ; return buf . append ( cal . get ( Calendar . YEAR ) ) . append ( '-' ) . append ( pad ( cal . get ( Calendar . MONTH ) + 1 ) ) . append ( '-' ) . append ( pad ( cal . get ( Calendar . DATE ) ) ) . append ( 'T' ) . append ( pad ( cal . get ( Calendar . HOUR_OF_DAY ) ) ) . append ( ':' ) . append ( pad ( cal . get ( Calendar . MINUTE ) ) ) . append ( ':' ) . append ( pad ( cal . get ( Calendar . SECOND ) ) ) . append ( '.' ) . append ( pad3 ( cal . get ( Calendar . MILLISECOND ) ) ) . append ( 'Z' ) . toString ( ) ; } private final static String pad ( int i ) { return i < 10 ? \"0\" . concat ( String . valueOf ( i ) ) : String . valueOf ( i ) ; } private final static String pad3 ( int i ) { if ( i < 10 ) { return \"00\" . concat ( String . valueOf ( i ) ) ; } else if ( i < 100 ) { return \"0\" . concat ( String . valueOf ( i ) ) ; } else { return String . valueOf ( i ) ; } } private final static int readYear ( Calendar cal , String str , int off ) throws ParseException { if ( str . length ( ) >= off + 4 ) { cal . set ( Calendar . YEAR , Integer . parseInt ( str . substring ( off , off + 4 ) ) ) ; return off + 4 ; } throw new ParseException ( \"Invalid year in date '\"", "gt": "+ str + \"'\" , off ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1070, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import org . eclipse . gmf . runtime . diagram . ui . parts . DiagramActionBarContributor ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . IWorkbenchPage ; public class SimplemapDiagramActionBarContributor extends DiagramActionBarContributor { protected Class getEditorClass ( ) { return SimplemapDiagramEditor . class ; }", "gt": "protected String getEditorId ( )", "prediction": "}\n", "label": 0}
{"id": 5160, "input": "<s> package org . nuxeo . ecm . automation . client . model ; import java . util . Date ; public class DateInput implements OperationInput { private static final long serialVersionUID = - 240778472381265434L ; public DateInput ( Date date ) { this . date = date ; } protected final Date date ; @ Override public boolean isBinary ( ) { return false ; } @ Override public String getInputType ( ) { return \"date\" ; }", "gt": "@ Override public String getInputRef ( )", "prediction": "}\n", "label": 1}
{"id": 7469, "input": "<s> package org . gk . engine . client . event ; public class EventValue { private Type type ; private String content ; private String value ; public enum Type { STRING , ID , EXPR } public Type getType ( ) { return type ; } public void setType ( Type type ) { this . type = type ; } public void setType ( String type ) { this . type = Type . valueOf ( type . toUpperCase ( ) ) ; } public String getContent ( ) { return content ; } public void setContent ( String content ) {", "gt": "this . content = content ;", "prediction": "\n", "label": 0}
{"id": 5177, "input": "<s> package fr . inria . zvtm . widgets ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Graphics ; import java . awt . Graphics2D ; import javax . swing . Icon ; import javax . swing . JLabel ; import fr . inria . zvtm . widgets . TranslucentWidget ; public class TranslucentJLabel extends JLabel implements TranslucentWidget { AlphaComposite bgAC = AB_08 ; AlphaComposite fgAC = AB_10 ; public TranslucentJLabel ( ) { super ( ) ; init ( ) ; } public TranslucentJLabel ( Icon image ) { super ( ) ; init ( ) ; } public TranslucentJLabel ( Icon image , int horizontalAlignment ) { super ( image , horizontalAlignment ) ; init ( ) ; } public TranslucentJLabel ( String text ) { super ( text ) ; init ( ) ; } public TranslucentJLabel ( String text , Icon icon , int horizontalAlignment ) { super ( text , icon , horizontalAlignment ) ; init ( ) ; } public TranslucentJLabel ( String text , int horizontalAlignment ) { super ( text , horizontalAlignment ) ; init ( ) ; } void init ( ) { setOpaque ( false ) ; initColors ( ) ; } void initColors ( ) { setForeground ( Color . WHITE ) ; setBackground ( Color . BLACK ) ; } public void setBackgroundTranslucence ( float alpha ) { this . bgAC = AlphaComposite . getInstance (", "gt": "AlphaComposite . SRC_OVER , alpha ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3365, "input": "<s> package org . ofbiz . base . util ; import java . io . Serializable ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . lang . ThreadSafe ; import com . ibm . icu . util . Calendar ; @ SourceMonitored @ ThreadSafe @ SuppressWarnings ( \"serial\" ) public class TimeDuration implements Serializable , Comparable < TimeDuration > { public static final TimeDuration ZeroTimeDuration = new NullDuration ( ) ; protected final int milliseconds ; protected final int seconds ; protected final int minutes ; protected final int hours ; protected final int days ; protected final int months ; protected final int years ; public TimeDuration ( int years , int months , int days , int hours , int minutes , int seconds , int milliseconds ) { this . milliseconds = milliseconds ; this . seconds = seconds ; this . minutes = minutes ; this . hours = hours ; this . days = days ; this . months = months ; this . years = years ; } public TimeDuration ( Calendar cal1 , Calendar cal2 ) { Calendar calStart ; Calendar calEnd ; int factor ; if ( cal1 . before ( cal2 ) ) { factor = 1 ; calStart = ( Calendar ) cal1 . clone ( ) ; calEnd = ( Calendar ) cal2 . clone ( ) ; } else { factor = - 1 ; calStart = ( Calendar ) cal2 . clone ( ) ; calEnd = ( Calendar ) cal1 . clone ( ) ; } long targetMillis = calEnd . getTimeInMillis ( ) ; long deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; if ( deltaMillis == 0 ) { this . years = this . months = this . days = this . hours = this . minutes = this . seconds = this . milliseconds = 0 ; return ; } long yearMillis = 86400000 * calStart . getLeastMaximum ( Calendar . DAY_OF_YEAR ) ; float units = deltaMillis / yearMillis ; this . years = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . YEAR ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; long monthMillis = 86400000 * ( calStart . getMaximum ( Calendar . DAY_OF_MONTH ) / 2 ) ; units = deltaMillis / monthMillis ; this . months = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . MONTH ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; units = deltaMillis / 86400000 ; this . days = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . DAY_OF_MONTH ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; units = deltaMillis / 3600000 ; this . hours = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . HOUR ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; units = deltaMillis / 60000 ; this . minutes = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . MINUTE ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; units = deltaMillis / 1000 ; this . seconds = factor * advanceCalendar ( calStart , calEnd , ( int ) units , Calendar . SECOND ) ; deltaMillis = computeDeltaMillis ( calStart . getTimeInMillis ( ) , targetMillis ) ; this . milliseconds = factor * ( int ) deltaMillis ; } private static long computeDeltaMillis ( long start , long end ) { if ( start < 0 ) { return end + ( - start ) ; } return end - start ; } private static int advanceCalendar ( Calendar start , Calendar end , int units , int type ) { if ( units >= 1 ) { Calendar tmp = ( Calendar ) start . clone ( ) ; int tmpUnits = units ; tmp . add ( type , tmpUnits ) ; while ( tmp . after ( end ) ) { tmp . add ( type , - 1 ) ; units -- ; } if ( units != 0 ) { start . add ( type , units ) ; } } return units ; } @ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } try { TimeDuration that = ( TimeDuration ) obj ; return this . years == that . years && this . months == that . months && this . days == that . days && this . hours == that . hours && this . minutes == that . minutes && this . seconds == that . seconds && this . milliseconds == that . milliseconds ; } catch ( Exception e ) { } return false ; } @ Override public String toString ( ) { return this . years + \":\" + this . months + \":\" + this . days + \":\" + this . hours + \":\" + this . minutes + \":\" + this . seconds + \":\" + this . milliseconds ; } @ Override public int compareTo ( TimeDuration arg0 ) { if ( this == arg0 ) { return 0 ; } int r = this . years - arg0 . years ; if ( r != 0 ) { return r ; } r = this . months - arg0 . months ; if ( r != 0 ) { return r ; } r = this . days - arg0 . days ; if ( r != 0 ) { return r ; } r = this . hours - arg0 . hours ; if ( r != 0 ) { return r ; } r = this . minutes", "gt": "- arg0 . minutes ;", "prediction": ";\n", "label": 0}
{"id": 5180, "input": "<s> package org . eclipse . ui . internal . registry ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . contexts . Context ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . dynamichelpers . ExtensionTracker ; import org . eclipse . core . runtime . dynamichelpers . IExtensionChangeHandler ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . internal . WorkbenchPlugin ; public class ActionSetRegistry implements IExtensionChangeHandler { private class ActionSetPartAssociation { public ActionSetPartAssociation ( String partId , String actionSetId ) { this . partId = partId ; this . actionSetId = actionSetId ; } String partId ; String actionSetId ; } private ArrayList children = new ArrayList ( ) ; private Map mapPartToActionSetIds = new HashMap ( ) ; private Map mapPartToActionSets = new HashMap ( ) ; private IContextService contextService ; private ActionSetRegistry ( ) { contextService = ( IContextService ) PlatformUI . getWorkbench ( ) . getService ( IContextService . class ) ; PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) . registerHandler ( this , ExtensionTracker . createExtensionPointFilter ( new IExtensionPoint [ ] { getActionSetExtensionPoint ( ) , getActionSetPartAssociationExtensionPoint ( ) } ) ) ; readFromRegistry ( ) ; } public static ActionSetRegistry getInstance ( ) { return SingletonUtil . getSessionInstance ( ActionSetRegistry . class ) ; } private IExtensionPoint getActionSetPartAssociationExtensionPoint ( ) { return Platform . getExtensionRegistry ( ) . getExtensionPoint ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_ACTION_SET_PART_ASSOCIATIONS ) ; } private IExtensionPoint getActionSetExtensionPoint ( ) { return Platform . getExtensionRegistry ( ) . getExtensionPoint ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_ACTION_SETS ) ; } private void addActionSet ( ActionSetDescriptor desc ) { children . add ( desc ) ; Context actionSetContext = contextService . getContext ( desc . getId ( ) ) ; if ( ! actionSetContext . isDefined ( ) ) { actionSetContext . define ( desc . getLabel ( ) , desc . getDescription", "gt": "( ) , \"org.eclipse.ui.contexts.actionSet\" ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 7795, "input": "<s> class T6521805a { static class Outer { T6521805a this$0 = null ; } public class Inner extends Outer { public void foo ( ) { this$0", "gt": "= new T6521805a ( ) ;", "prediction": "\n", "label": 0}
{"id": 5193, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec3 . sub2 ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this", "gt": ". accountRef = accountRef ;", "prediction": "\n", "label": 1}
{"id": 9918, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends", "gt": "Runnable , S extends String > void disjointness ( )", "prediction": ")\n", "label": 0}
{"id": 5215, "input": "<s> package monbulk . MethodBuilder . client . view ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map . Entry ; import com . google . gwt . core . client . GWT ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . event . dom . client . MouseOutEvent ; import com . google . gwt . event . dom . client . MouseOutHandler ; import com . google . gwt . event . dom . client . MouseOverEvent ; import com . google . gwt . event . dom . client . MouseOverHandler ; import com . google . gwt . event . shared . HandlerManager ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . FlexTable ; import com . google . gwt . user . client . ui . HasWidgets ; import com . google . gwt . user . client . ui . Hidden ; import com . google . gwt . user . client . ui . HorizontalPanel ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . PushButton ; import com . google . gwt . user . client . ui . ScrollPanel ; import com . google . gwt . user . client . ui . Widget ; import monbulk . MethodBuilder . client . event . MenuChangeEvent ; import monbulk . shared . Architecture . IPresenter ; import monbulk . shared . Architecture . ISearchController ; import monbulk . shared . Events . DragEvent ; import monbulk . shared . Model . IPojo ; import monbulk . shared . Model . pojo . pojoMethod ; import monbulk . shared . Model . pojo . pojoMethodComplete ; import monbulk . shared . Services . MethodService ; import monbulk . shared . Services . ServiceRegistry ; import monbulk . shared . util . MonbulkEnums ; import monbulk . shared . view . iMenuWidget ; public class MethodList extends Composite implements iMenuWidget , MethodService . MethodServiceHandler , ISearchController { private static MethodListUiBinder uiBinder = GWT . create ( MethodListUiBinder . class ) ; interface MethodListUiBinder extends UiBinder < Widget , MethodList > { } private final HandlerManager eventBus ; private String ActiveClassName ; private String PassiveClassName ; private HashMap < String , pojoMethod > methodList ; @ UiField FlexTable _MenuStack ; @ UiField ScrollPanel _pnlScroll ; @ UiField PushButton _Newbutton ; @ UiField PushButton _Refresh ; @ UiField HorizontalPanel _searchPanel ; private IPresenter _presenter ; public MethodList ( HandlerManager eBus ) { initWidget ( uiBinder . createAndBindUi ( this ) ) ; this . eventBus = eBus ; this . _pnlScroll . setAlwaysShowScrollBars ( true ) ; methodList = new HashMap < String , pojoMethod > ( ) ; try { MethodService service = ( MethodService ) ServiceRegistry . getService ( MonbulkEnums . ServiceNames . Methods ) ; service . getMethodList ( this ) ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( \"Couldn't find Method service\" ) ; } _Newbutton . setText ( \"Add New Method\" ) ; } public MethodList ( HandlerManager tmpEvent , String menuClassName , String activeClassName , String pClassName ) { initWidget ( uiBinder . createAndBindUi ( this ) ) ; this . eventBus = tmpEvent ; this . ActiveClassName = activeClassName ; this . PassiveClassName = pClassName ; try { MethodService service = ( MethodService ) ServiceRegistry . getService ( MonbulkEnums . ServiceNames . Methods ) ; service . getMethodList ( this ) ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( \"Couldn't find metadata service\" ) ; } } public void refreshList ( ) { try { MethodService service = ( MethodService ) ServiceRegistry . getService ( MonbulkEnums . ServiceNames . Methods ) ; this . _searchPanel . clear ( ) ; this . _MenuStack . clear ( ) ; this . _MenuStack . removeAllRows ( ) ; service . getMethodList ( this ) ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( \"Couldn't find Method service\" ) ; } } @ UiHandler ( \"_Newbutton\" ) void onClick ( ClickEvent e ) { eventBus . fireEvent ( new DragEvent ( \"NewMethod\" , \"NewMethod\" , 0 , null ) ) ; } @ UiHandler ( \"_Refresh\" ) void onClick1 ( ClickEvent e ) { eventBus . fireEvent ( new MenuChangeEvent ( \"Refresh\" , \"\" ) ) ; } public void setText ( String text ) { _Newbutton . setText ( text ) ; } public String getText ( ) { return _Newbutton . getText ( ) ; } @ Override public void Filter ( String Name ) { this . BuildList ( Name ) ; } @ Override public HasWidgets getBaseWidget ( ) { return this . _MenuStack ; } @ Override public final", "gt": "void setActiveMenu ( String activeItem )", "prediction": "\n", "label": 1}
{"id": 2186, "input": "<s> interface I { int f ( ) ; } class C { public static int f ( ) { return 7 ; } }", "gt": "class StaticOverride extends C implements I", "prediction": "}\n", "label": 0}
{"id": 5218, "input": "<s> package br . org . archimedes . io . pdf ; import java . io . IOException ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . gui . opengl . Color ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . io . pdf . rcp . ElementExporterEPLoader ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Layer ; import br . org . archimedes . model . LineStyle ; import br . org . archimedes . rcp . extensionpoints . ElementEPLoader ; import com . lowagie . text . Rectangle ; import com . lowagie . text . pdf . PdfContentByte ; public class PDFWriter { private PDFWriterHelper helper ; public PDFWriter ( PdfContentByte cb , Rectangle documentArea ) { this . helper = new PDFWriterHelper ( cb , documentArea ) ; } public void write ( Drawing drawing ) { this . helper . setViewport ( drawing . getViewportPosition ( ) ) ; this . helper . setZoom ( drawing . getZoom ( ) ) ; for ( Layer layer : drawing . getLayerMap ( ) . values ( ) ) { if ( layer . isVisible ( ) ) { write ( layer ) ; } } } public void write ( Layer layer ) { PdfContentByte cb = helper . getPdfContentByte ( ) ; cb . setLineWidth (", "gt": "( float ) layer . getThickness ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7498, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . io . FilenameUtils ; public class FrameworkStructureValidator { private final File fmwkDir ; private List < String > errorMsgs ; public FrameworkStructureValidator ( File fmwkDir ) { this . fmwkDir = fmwkDir ; } public List < String > validate ( ) { errorMsgs = new ArrayList < String > ( ) ; if ( ! fmwkDir . isDirectory ( ) ) { errorMsgs . add ( \"'\" + fmwkDir . getAbsolutePath ( ) + \"' is not a directory\" ) ; } else { validateSubdirExistence ( \"Versions\" , \"Versions/A\" , \"Versions/A/Headers\" , \"Versions/A/Resources\" ) ; String fmwkName = FilenameUtils . removeExtension ( fmwkDir . getName ( ) ) ; validateLib ( \"Versions/A/\" + fmwkName ) ; validateLink ( \"Headers\" , \"Versions/A/Headers\" ) ; validateLink ( \"Resources\" , \"Versions/A/Resources\" ) ; validateLink ( fmwkName , \"Versions/A/\" + fmwkName ) ; validateLink ( \"Versions/Current\" , \"Versions/A\" ) ; } return errorMsgs ; } private void validateSubdirExistence ( String ... subDirNames ) { for ( String subDirName : subDirNames ) { File dir = new File ( fmwkDir , subDirName ) ; if ( ! dir . isDirectory ( ) ) { errorMsgs . add ( \"Missing the required subdirectory '\" + subDirName + \"'\" ) ; } } }", "gt": "private void validateLib ( String relativeLibPath )", "prediction": "}\n", "label": 0}
{"id": 5276, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . sql . SQLException ; import java . util . List ; import junit . framework . TestCase ; import com . cloudera . sqoop . mapreduce . db . IntegerSplitter ; public class TestIntegerSplitter extends TestCase { private long [ ] toLongArray ( List < Long > in ) { long [ ] out = new long [ in . size ( ) ] ; for ( int i = 0 ; i < in . size ( ) ; i ++ ) { out [ i ] = in . get ( i ) . longValue ( ) ; } return out ; } public String formatLongArray ( long [ ] ar ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"[\" ) ; boolean first = true ; for ( long val : ar ) { if ( ! first ) { sb . append ( \", \" ) ; } sb . append ( Long . toString ( val ) ) ; first = false ; } sb . append ( \"]\" ) ; return sb . toString ( ) ; } public void assertLongArrayEquals ( long [ ] expected , long [ ] actual ) { for ( int i = 0 ; i < expected . length ; i ++ ) { try { assertEquals ( \"Failure at position \" + i + \"; got \" + actual [ i ] + \" instead of \" + expected [ i ] + \"; actual array is \" + formatLongArray ( actual ) , expected [ i ] , actual [ i ] ) ; } catch ( ArrayIndexOutOfBoundsException oob ) { fail ( \"Expected array with \" + expected . length + \" elements; got \" + actual . length + \". Actual array is \" + formatLongArray ( actual ) ) ; } } if ( actual . length > expected . length ) { fail ( \"Actual array has \" + actual . length + \" elements; expected \" + expected . length + \". Actual array is \" + formatLongArray ( actual ) ) ; } } public void testEvenSplits ( ) throws SQLException { List < Long > splits = new IntegerSplitter ( ) . split ( 10 , 0 , 100 ) ; long [ ] expected = { 0 , 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , } ; assertLongArrayEquals ( expected , toLongArray ( splits ) ) ; } public void testOddSplits ( ) throws SQLException { List < Long > splits = new IntegerSplitter ( ) . split ( 10 , 0 , 95 ) ; long [ ] expected = { 0 , 10 , 20 , 30 , 40 , 50 , 59 , 68 , 77 , 86 , 95 , } ; assertLongArrayEquals ( expected , toLongArray ( splits ) ) ; } public void testSingletonSplit ( ) throws SQLException { List < Long > splits = new IntegerSplitter ( ) . split ( 1 , 5 , 5 ) ; long [ ] expected = { 5 , 5 } ; assertLongArrayEquals ( expected , toLongArray ( splits ) ) ; } public void testSingletonSplit2 ( ) throws SQLException { List < Long > splits = new IntegerSplitter ( ) . split ( 5 , 5 , 5 ) ; long [ ] expected = { 5 , 5 } ; assertLongArrayEquals ( expected", "gt": ", toLongArray ( splits ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2662, "input": "<s> package api . forum . forumsections ; import java . util . List ; public class Categories { private Number categoryID ; private String categoryName ; private List < Forums > forums ; public Number getCategoryID ( ) { return this . categoryID ; } public String getCategoryName ( ) { return this . categoryName ; } public List < Forums > getForums ( ) { return this . forums ; }", "gt": "@ Override public String toString ( )", "prediction": "}\n", "label": 0}
{"id": 5291, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage . transmogrify ;", "gt": "public interface Typed extends IDefinition", "prediction": "}\n", "label": 1}
{"id": 1441, "input": "<s> package me . chester . minitruco . core ; public interface Estrategia { public abstract String getNomeEstrategia ( ) ; public abstract String getInfoEstrategia ( ) ; public abstract int joga ( SituacaoJogo s ) ; public abstract boolean aceitaTruco ( SituacaoJogo s ) ; public abstract boolean aceitaMao11 ( Carta [ ] cartasParceiro , SituacaoJogo s ) ; public abstract void inicioPartida ( ) ; public abstract void inicioMao ( ) ; public abstract void pediuAumentoAposta ( int posJogador , int valor ) ; public abstract void", "gt": "aceitouAumentoAposta ( int posJogador , int valor ) ;", "prediction": "( )\n", "label": 0}
{"id": 5296, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . usage ; import com . puppycrawl . tools . checkstyle . BaseCheckTestCase ; import com . puppycrawl . tools . checkstyle . DefaultConfiguration ; public class UnusedPrivateMethodCheckTest extends BaseCheckTestCase { public void testDefault ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedPrivateMethodCheck . class ) ; final String [ ] expected = { \"7:18: Unused private method 'methodUnused0'.\" , \"66:18: Unused private method 'writeObject'.\" , \"71:18: Unused private method 'readObject'.\" , \"76:20: Unused private method 'writeReplace'.\" , \"82:20: Unused private method 'readResolve'.\" , \"91:18: Unused private method 'writeObject'.\" , \"95:18: Unused private method 'writeObject'.\" , \"99:18: Unused private method 'writeObject'.\" , \"103:18: Unused private method 'readObject'.\" , \"107:18: Unused private method 'readObject'.\" , \"111:17: Unused private method 'writeReplace'.\" , \"116:20: Unused private method 'writeReplace'.\" , \"121:17: Unused private method 'readResolve'.\" , \"126:20: Unused private method 'readResolve'.\" , \"134:17: Unused private method 'writeObject'.\" , \"139:18: Unused private method 'readObject'.\" , \"143:20: Unused private method 'readResolve'.\" , \"151:17: Unused private method 'readObject'.\" , } ; verify ( checkConfig , getPath ( \"usage/InputUnusedMethod.java\" ) , expected ) ; } public void testAllowSerializationMethods ( ) throws Exception { final DefaultConfiguration checkConfig = createCheckConfig ( UnusedPrivateMethodCheck . class ) ; checkConfig . addAttribute ( \"allowSerializationMethods\" , \"true\" ) ; final String [ ] expected = { \"7:18: Unused private method 'methodUnused0'.\" , \"91:18: Unused private method 'writeObject'.\" , \"95:18: Unused private method 'writeObject'.\" , \"99:18: Unused private method 'writeObject'.\" , \"103:18: Unused private method 'readObject'.\" , \"107:18: Unused private method 'readObject'.\" , \"111:17: Unused private method 'writeReplace'.\" , \"116:20: Unused private method 'writeReplace'.\" , \"121:17: Unused private method 'readResolve'.\" , \"126:20: Unused private method 'readResolve'.\" , \"134:17: Unused private method 'writeObject'.\" , \"139:18: Unused private method 'readObject'.\" , \"143:20: Unused private method 'readResolve'.\" , \"151:17: Unused private method 'readObject'.\" , } ; verify ( checkConfig , getPath ( \"usage/InputUnusedMethod.java\" ) , expected ) ; } public", "gt": "void testInner ( ) throws Exception", "prediction": "void ( )\n", "label": 1}
{"id": 159, "input": "<s> package p3 ; class T3 extends p1 . T2 {", "gt": "public void f ( )", "prediction": ";\n", "label": 0}
{"id": 5298, "input": "<s> package org . eclipse . jface . fieldassist ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Text ; public class TextContentAdapter implements IControlContentAdapter , IControlContentAdapter2 { public String getControlContents ( Control control ) { return ( ( Text ) control ) . getText ( ) ; } public void setControlContents ( Control control , String text , int cursorPosition ) { ( ( Text ) control ) . setText ( text ) ; ( ( Text ) control ) . setSelection ( cursorPosition , cursorPosition ) ; } public void insertControlContents ( Control control , String text , int cursorPosition ) { Point selection = ( ( Text ) control ) . getSelection ( ) ; ( ( Text ) control ) . insert ( text ) ; if ( cursorPosition < text . length ( ) ) { ( ( Text ) control ) . setSelection ( selection . x + cursorPosition , selection . x + cursorPosition ) ; } } public int getCursorPosition ( Control control ) { return ( ( Text ) control ) . getCaretPosition ( ) ; } public Rectangle getInsertionBounds ( Control control ) { Text text = ( Text ) control ; float avgCharWidth = Graphics . getAvgCharWidth ( text . getFont ( ) ) ; int x = ( int ) ( text", "gt": ". getCaretPosition ( ) * avgCharWidth ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5303, "input": "<s> import java . io . IOException ; import java . util . * ; class Main { static Object mut = new Object ( ) ; static int pecaCount ; static Vector set = new Vector ( ) ; static Peca ignoravel ; static int maiorSoma ; static boolean encontrado ; static int somaAbsoluta ; static int somaAbsolutaCorrente ; static Peca menorPecaIgnoravel ; static int maximos [ ] = new int [ 1001 ] ; static Hashtable mapas [ ] = new Hashtable [ 1000 ] ; public static void main ( String args [ ] ) throws NumberFormatException , IOException { int temp ; while ( true ) { pecaCount = Integer . parseInt ( readLine ( 10 ) . trim ( ) ) ; if ( pecaCount == 0 ) { break ; } set . removeAllElements ( ) ; menorPecaIgnoravel = null ; maiorSoma = - 1 ; ignoravel = null ; for ( int i = 0 ; i != pecaCount ; i ++ ) { String [ ] linha = split ( readLine ( 30 ) ) ; Peca p = new Peca ( ) ; p . cima = Integer . parseInt ( linha [ 0 ] ) ; p . baixo = Integer . parseInt ( linha [ 1 ] ) ; if ( p . cima < p . baixo ) { temp = p . cima ; p . cima = p . baixo ; p . baixo = temp ; } p . abs = Math . abs ( p . cima - p . baixo ) ; set . addElement ( p ) ; } int somaMaxima = 0 ; somaAbsoluta = 0 ; for ( int i = pecaCount - 1 ; i != - 1 ; i -- ) { somaAbsoluta += getPeca ( i ) . cima + getPeca ( i ) . baixo ; somaMaxima += getPeca ( i ) . abs ; maximos [ i ] = somaMaxima ; getPeca ( i ) . level = i ; if ( mapas [ i ] == null ) { mapas [ i ] = new Hashtable ( ) ; } else { mapas [ i ] . clear ( ) ; } } encontrado = false ; if ( pecaCount == 1 ) { if ( getPeca ( 0 ) . abs != 0 ) { System . out . println ( \"impossible\" ) ; continue ; } else { System . out . println ( getPeca ( 0 ) . cima + \" discard none\" ) ; continue ; } } if ( pecaCount == 2 ) { if ( getPeca ( 0 ) . abs == 0 ) { printDiscard ( getPeca ( 0 ) . cima , getPeca ( 1 ) ) ; continue ; } if ( getPeca ( 1 ) . abs == 0 ) { printDiscard ( getPeca ( 1 ) . cima , getPeca ( 0 ) ) ; continue ; } System . out . println ( \"impossible\" ) ; continue ; } if ( somaAbsoluta % 2 == 0 ) { somaAbsolutaCorrente = somaAbsoluta / 2 ; tenta ( 0 , 0 , 0 ) ; if ( encontrado ) { continue ; } } menorPecaIgnoravel = null ; maiorSoma = - 1 ; for ( int i = 0 ; i != pecaCount ; i ++ ) { if ( getPeca ( i ) . abs == 0 ) { continue ; } for ( int i2 = 0 ; i2 != pecaCount ; i2 ++ ) { mapas [ i2 ] . clear ( ) ; } ignoravel = getPeca ( i ) ; if ( ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) % 2 == 0 ) { if ( encontrado ) { if ( menorPecaIgnoravel . cima + menorPecaIgnoravel . baixo < ignoravel . cima + ignoravel . baixo ) { continue ; } } somaAbsolutaCorrente = ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) / 2 ; tenta ( 0 , 0 , 0 ) ; } } if ( ! encontrado ) { System . out .", "gt": "println ( \"impossible\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5300, "input": "<s> package org . seage . metaheuristic . fireflies ; import org . seage . metaheuristic . tabusearch . TabuSearch ; public interface ObjectiveFunction extends java . io . Serializable { public void", "gt": "ObjectiveFunction ( Solution soln ) ;", "prediction": ";\n", "label": 1}
{"id": 3890, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class LocalVariableTypeTable_attribute extends Attribute { LocalVariableTypeTable_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; local_variable_table_length = cr . readUnsignedShort ( ) ; local_variable_table = new Entry [ local_variable_table_length ] ; for ( int i = 0 ; i < local_variable_table_length ; i ++ ) local_variable_table [ i ] = new Entry ( cr ) ; } public LocalVariableTypeTable_attribute ( ConstantPool constant_pool , Entry [ ] local_variable_table ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . LocalVariableTypeTable ) , local_variable_table ) ; } public LocalVariableTypeTable_attribute ( int name_index , Entry [ ] local_variable_table ) { super ( name_index , 2 + local_variable_table . length * Entry . length ( ) ) ; this . local_variable_table_length = local_variable_table . length ; this . local_variable_table = local_variable_table ; } public < R , D > R accept ( Visitor < R , D", "gt": "> visitor , D data )", "prediction": ") ;\n", "label": 0}
{"id": 5301, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse .", "gt": "emf . ecore . EObject ;", "prediction": ";\n", "label": 1}
{"id": 5308, "input": "<s> package com . gisgraphy . client . continent ; public interface ContinentRepository { Iterable < Continent > findAll ( ) ;", "gt": "Continent findByCode ( String code ) ;", "prediction": "}\n", "label": 0}
{"id": 5303, "input": "<s> package org . nuxeo . ecm . automation . client . model ; import java . util . Date ; public class PropertiesHelper { private PropertiesHelper ( ) { } public static boolean isBlob ( Object v ) { return v instanceof Blob ; } public static boolean isMap ( Object v ) { return v instanceof PropertyMap ; } public static boolean isList ( Object v ) { return v instanceof PropertyList ; } public static boolean isScalar ( Object v ) { return ! isBlob ( v ) && ! isList ( v ) && ! isMap ( v ) ; } public static String getString ( Object v , String defValue ) { if ( v == null ) { return defValue ; } if ( v . getClass ( ) == String . class ) { return v . toString ( ) ; } throw new IllegalArgumentException ( \"Property is not a scalar: \" + v ) ; } public static Boolean getBoolean ( Object v , Boolean defValue ) { if ( v == null ) { return defValue ; } if ( v . getClass ( ) == String . class ) { return Boolean . valueOf ( v . toString ( ) ) ; } throw new IllegalArgumentException ( \"Property is not a scalar: \" + v ) ; } public static Long getLong ( Object v , Long defValue ) { if ( v == null ) { return defValue ; } if ( v . getClass ( ) == String . class ) { return Long . valueOf ( v . toString ( ) ) ; } throw new IllegalArgumentException ( \"Property is not a scalar: \" + v ) ; } public static Double getDouble ( Object v , Double defValue ) { if ( v == null ) { return defValue ; } if ( v . getClass ( ) == String . class ) { return Double . valueOf ( v . toString ( ) ) ; } throw new IllegalArgumentException ( \"Property is not a scalar: \" + v ) ; } public static Date getDate ( Object v , Date defValue ) { if ( v == null ) { return defValue ; } if ( v . getClass ( ) == String . class ) { return DateUtils . parseDate ( v . toString ( ) ) ; } else { return ( Date ) v ; } } public static PropertyList getList ( Object v , PropertyList defValue ) { if ( v == null ) { return defValue ; }", "gt": "if ( v instanceof PropertyList )", "prediction": "}\n", "label": 1}
{"id": 3704, "input": "<s> package org . ofbiz . order . finaccount ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . Random ; import java . util . regex . Pattern ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; public class FinAccountHelper { public static final String module = FinAccountHelper . class . getName ( ) ; public static int decimals = UtilNumber . getBigDecimalScale ( \"finaccount.decimals\" ) ; public static int rounding = UtilNumber . getBigDecimalRoundingMode ( \"finaccount.rounding\" ) ; public static final BigDecimal ZERO = BigDecimal . ZERO . setScale ( decimals , rounding ) ; public static final String giftCertFinAccountTypeId = \"GIFTCERT_ACCOUNT\" ; public static final boolean defaultPinRequired = false ; static char [ ] char_pool = new char [ 10 + 26 ] ; static { int j = 0 ; for ( int i = \"0\" . charAt ( 0 ) ; i <= \"9\" . charAt ( 0 ) ; i ++ ) { char_pool [ j ++ ] = ( char ) i ; } for ( int i = \"A\" . charAt ( 0 ) ; i <= \"Z\" . charAt ( 0 ) ; i ++ ) { char_pool [ j ++ ] = ( char ) i ; } } public static BigDecimal addFirstEntryAmount ( BigDecimal initialValue , List < GenericValue > transactions , String fieldName , int decimals , int rounding ) throws GenericEntityException { if ( ( transactions != null ) && ( transactions . size ( ) == 1 ) ) { GenericValue firstEntry = transactions . get ( 0 ) ; if ( firstEntry . get ( fieldName ) != null ) { BigDecimal valueToAdd = firstEntry . getBigDecimal ( fieldName ) ; return initialValue . add ( valueToAdd ) . setScale ( decimals , rounding ) ; } else { return initialValue ; } } else { return initialValue ; } } public static String getNewFinAccountCode ( int codeLength , Delegator delegator ) throws GenericEntityException { Random r = new Random ( ) ; boolean foundUniqueNewCode = false ; StringBuilder newAccountCode = null ; long count = 0 ; while ( ! foundUniqueNewCode ) { newAccountCode = new StringBuilder ( codeLength ) ; for ( int i = 0 ; i < codeLength ; i ++ ) { newAccountCode . append ( char_pool [ r . nextInt ( char_pool . length ) ] ) ; } List < GenericValue > existingAccountsWithCode = delegator . findByAnd ( \"FinAccount\" , UtilMisc . toMap ( \"finAccountCode\" , newAccountCode . toString ( ) ) , null , false ) ; if ( existingAccountsWithCode . size ( ) == 0 ) { foundUniqueNewCode = true ; } count ++ ; if ( count > 999999 ) { throw new GenericEntityException ( \"Unable to locate unique FinAccountCode! Length [\" + codeLength + \"]\" ) ; } } return newAccountCode . toString ( ) ; } public static GenericValue getFinAccountFromCode ( String finAccountCode , Delegator delegator ) throws GenericEntityException { if ( finAccountCode == null ) { return null ; } Pattern filterRegex = Pattern . compile ( \"[^0-9A-Z]\" ) ; finAccountCode = finAccountCode . toUpperCase ( ) . replaceAll ( filterRegex . pattern ( ) , \"\" ) ; GenericValue encryptedFinAccount = delegator . makeValue ( \"FinAccount\" , UtilMisc . toMap ( \"finAccountCode\" , finAccountCode ) ) ; delegator . encryptFields ( encryptedFinAccount ) ; String encryptedFinAccountCode = encryptedFinAccount . getString ( \"finAccountCode\" ) ; List < GenericValue > accounts = delegator . findByAnd ( \"FinAccount\" , UtilMisc . toMap ( \"finAccountCode\" , encryptedFinAccountCode ) , null , false ) ; accounts = EntityUtil . filterByDate ( accounts ) ; if ( UtilValidate . isEmpty ( accounts ) ) { Debug . logWarning ( \"No fin account found for account code [\" + finAccountCode + \"]\" , module ) ; return null ; } else if ( accounts . size ( ) > 1 ) { Debug . logError ( \"Multiple fin accounts found\" , module ) ; return null ; } else { return accounts . get ( 0 ) ; } } public static BigDecimal getBalance ( String finAccountId , Timestamp asOfDateTime , Delegator delegator ) throws GenericEntityException { if ( asOfDateTime == null ) asOfDateTime = UtilDateTime . nowTimestamp ( ) ; BigDecimal incrementTotal = ZERO ; BigDecimal decrementTotal = ZERO ; EntityConditionList < EntityCondition > incrementConditions = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"finAccountId\" , EntityOperator . EQUALS , finAccountId ) , EntityCondition . makeCondition ( \"transactionDate\" , EntityOperator . LESS_THAN_EQUAL_TO , asOfDateTime ) , EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"finAccountTransTypeId\" , EntityOperator . EQUALS , \"DEPOSIT\" ) , EntityCondition . makeCondition ( \"finAccountTransTypeId\" , EntityOperator . EQUALS , \"ADJUSTMENT\" ) ) , EntityOperator . OR ) ) , EntityOperator . AND ) ; List < GenericValue > transSums = delegator . findList ( \"FinAccountTransSum\" , incrementConditions , UtilMisc . toSet (", "gt": "\"amount\" ) , null , null , false ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5304, "input": "<s> package org . spliffy . server . db ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import javax . persistence . CascadeType ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . Id ; import javax . persistence . OneToMany ; import org . hashsplit4j . api . Fanout ; @ Entity public class FanoutHash implements Serializable , Fanout { private long hash ; private long actualContentLength ; private List < FanoutEntry > fanoutEntrys ; @ Id public long getFanoutHash ( ) { return hash ; } public void setFanoutHash ( long hash ) { this . hash = hash ; } @ Column ( nullable = false ) @ Override", "gt": "public long getActualContentLength ( )", "prediction": "}\n", "label": 1}
{"id": 9611, "input": "<s> package com . sun . tools . javadoc ; import com . sun . javadoc . * ; import com . sun . tools . javac . main . CommandLine ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Options ; import java . io . IOException ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import static com . sun . tools . javac . code . Flags . * ; class Start { private final String defaultDocletClassName ; private final ClassLoader docletParentClassLoader ; private static final String javadocName = \"javadoc\" ; private static final String standardDocletClassName = \"com.sun.tools.doclets.standard.Standard\" ; private ListBuffer < String [ ] > options = new ListBuffer < String [ ] > ( ) ; private ModifierFilter showAccess = null ; private long defaultFilter = PUBLIC | PROTECTED ; private Messager messager ; String docLocale = \"\" ; boolean breakiterator = false ; boolean quiet = false ; String encoding = null ; private DocletInvoker docletInvoker ; private static final int F_VERBOSE = 1 << 0 ; private static final int F_WARNINGS = 1 << 2 ; private boolean rejectWarnings = false ; Start ( String programName , PrintWriter errWriter , PrintWriter warnWriter , PrintWriter noticeWriter , String defaultDocletClassName ) { this ( programName , errWriter , warnWriter , noticeWriter , defaultDocletClassName , null ) ; } Start ( String programName , PrintWriter errWriter , PrintWriter warnWriter , PrintWriter noticeWriter , String defaultDocletClassName , ClassLoader docletParentClassLoader ) { Context tempContext = new Context ( ) ; messager = new Messager ( tempContext , programName , errWriter , warnWriter , noticeWriter ) ; this . defaultDocletClassName = defaultDocletClassName ; this . docletParentClassLoader = docletParentClassLoader ; } Start ( String programName , String defaultDocletClassName ) { this ( programName , defaultDocletClassName , null ) ; } Start ( String programName , String defaultDocletClassName , ClassLoader docletParentClassLoader ) { Context tempContext = new Context ( ) ; messager = new Messager ( tempContext , programName ) ; this . defaultDocletClassName = defaultDocletClassName ; this . docletParentClassLoader = docletParentClassLoader ; } Start ( String", "gt": "programName , ClassLoader docletParentClassLoader )", "prediction": ") ;\n", "label": 0}
{"id": 5311, "input": "<s> package org . spliffy . server . db ; import java . io . Serializable ; import javax . persistence . * ; @ Entity public class ContactExtendedProperty implements Serializable { private Long id ; private Contact contact ; private String name ; private String propValue ; @ Id @ GeneratedValue public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } @ ManyToOne ( optional = false ) public Contact getContact ( ) { return contact ; } public void setContact ( Contact contact ) { this . contact = contact ; } @ Column ( nullable = false ) public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } @ Column ( nullable = false", "gt": ") public String getPropValue ( )", "prediction": ";\n", "label": 1}
{"id": 569, "input": "<s> package com . nesscomputing . hbase . spill ; import java . io . ByteArrayInputStream ; import java . util . List ; import java . util . UUID ; import org . apache . commons . io . Charsets ; import org . apache . hadoop . hbase . KeyValue ; import org . apache . hadoop . hbase . client . Put ; import org . junit . Assert ; import org . junit . Test ; public class TestBinaryConverter { @ Test public void testSimple ( ) { final Put put = new Put ( UUID . randomUUID ( ) . toString ( ) . getBytes ( Charsets . UTF_8 ) ) ; put . add ( \"family1\" . getBytes ( Charsets . UTF_8 ) , \"qualifier1\" . getBytes ( Charsets . UTF_8 ) , System . currentTimeMillis ( ) , \"data1\" . getBytes ( Charsets . UTF_8 ) ) ; put . add ( \"family2\" . getBytes ( Charsets . UTF_8 ) , \"qualifier2\" . getBytes ( Charsets . UTF_8 ) , System . currentTimeMillis ( ) , \"data2\" . getBytes ( Charsets . UTF_8 ) ) ; put . add ( \"family3\" . getBytes ( Charsets . UTF_8 ) , \"qualifier3\" . getBytes ( Charsets . UTF_8 ) , System . currentTimeMillis ( )", "gt": ", \"data3\" . getBytes ( Charsets . UTF_8 ) ) ;", "prediction": ";\n", "label": 0}
{"id": 5312, "input": "<s> package org . restlet . example . book . restlet . ch06 . sec2 . common ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; public interface AccountsResource { @ Get public String represent ( ) ; @ Post public String add", "gt": "( String account ) ;", "prediction": "( )\n", "label": 1}
{"id": 7678, "input": "<s> package com . mcbans . mcbans . commands ; import com . mcbans . mcbans . BanType ; import com . mcbans . mcbans . MCBansAPI ; import com . mcbans . mcbans . MCBansPlugin ; import com . mcbans . mcbans . api . FlagHandler ; import com . mcbans . mcbans . api . MCBansPluginManager ; import com . mcbans . mcbans . calls . Ban ; import java . util . ArrayList ; import java . util . regex . Pattern ; import org . bukkit . command . Command ; import org . bukkit . command . CommandExecutor ; import org . bukkit . command . CommandSender ; import org . bukkit . entity . Player ; public class BanCommand implements CommandExecutor { private final MCBansPlugin plugin ; private final MCBansPluginManager manager ; private final Pattern validUsername = Pattern . compile ( MCBansAPI . VALID_PLAYER_NAME_REGEX ) ; public BanCommand ( MCBansPlugin plugin ) { this . plugin = plugin ; this . manager = MCBansAPI . getInstance ( ) . getPluginManager ( ) ; } @ Override public boolean onCommand ( CommandSender sender , Command command , String label , String [ ] args ) { if ( ! sender . hasPermission ( \"mcbans.ban\" ) ) { sender . sendMessage ( plugin . lang . getFormat ( \"permissionDenied\" ) ) ; return true ; } String adminName = sender . getName ( ) ; String banReason = null ; String playerName = null ; String flagString = null ; String playerIP = \"\" ; String time = null ; String timeUnit = null ; BanType banType = BanType . LOCAL_BAN ; ArrayList < FlagHandler > customFlags = new ArrayList < FlagHandler > ( ) ; if ( args . length == 0 ) { return false ; } switch ( args . length ) { case 0 : return false ; case 1 : if ( args [ 0 ] . startsWith ( \"-\" ) ) { return false ; } else { playerName = args [ 0 ] ; banReason = plugin . config . getDefaultLocalBanReason ( ) ; } break ; default : if ( args [ 0 ] . startsWith ( \"-\" ) ) { flagString = args [ 0 ] . substring ( 1 ) ; char [ ] flagChars = flagString . toCharArray ( ) ; for ( char flag : flagChars ) { BanType f = BanType . getByChar ( flag ) ; if ( f == null ) { FlagHandler h = manager . getHandler ( flag ) ; if ( h == null ) { } else { customFlags . add ( h ) ; } } else { banType = f ; } } playerName = args [ 1 ] ; int reasonStart ; if ( banType == BanType . TEMP_BAN && args . length >= 4 ) { time = args [ 2 ] ; timeUnit = args [ 3 ] ; reasonStart = 4 ; } else { reasonStart = 2 ; } if ( args . length > reasonStart ) { StringBuilder sb = new StringBuilder ( args [ reasonStart ] ) ; for ( int i = reasonStart ; i < args . length ; i ++ ) { sb . append ( ' ' ) ; sb . append ( args [ i ] ) ; } banReason = sb . toString ( ) ; } } else { playerName = args [ 0 ] ; StringBuilder sb = new StringBuilder ( args [ 1 ] ) ; for ( int i = 2 ; i < args . length ; i ++ ) { sb . append ( ' ' ) ; sb . append ( args [ i ] ) ; } banReason = sb . toString ( ) ; } break ; } if ( ! plugin . checkPermission ( sender , banType . getPermission ( ) ) ) { plugin . log . debug ( \"Use of ban type flag without permission\" , false ) ; return true ; } if ( banType == BanType", "gt": ". GLOBAL_BAN && banReason == null )", "prediction": ")\n", "label": 0}
{"id": 5321, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers . provider ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Context ; import javax . ws . rs . ext . ExceptionMapper ; import javax . ws . rs . ext . Providers ; import org . restlet . ext . jaxrs . InstantiateException ; import org . restlet . ext . jaxrs . ObjectFactory ; import org . restlet . ext . jaxrs . internal . core . ThreadLocalizedContext ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertCookieParamException ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertHeaderParamException ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertMatrixParamException ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertPathParamException ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertQueryParamException ; import org . restlet . ext . jaxrs . internal . exceptions . ConvertRepresentationException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalBeanSetterTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalConstrParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalFieldTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . ImplementationException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingConstructorException ; import org . restlet . ext . jaxrs . internal . exceptions . NoMessageBodyReaderException ; import org . restlet . ext . jaxrs . internal . exceptions . ProviderNotInitializableException ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . ext . jaxrs . internal . wrappers . WrapperUtil ; import org . restlet . ext . jaxrs . internal . wrappers . params . ParameterList ; class PerRequestProviderWrapper extends AbstractProviderWrapper { private Object createInstance ( ) throws IllegalArgumentException , InvocationTargetException , InstantiateException , MissingAnnotationException , WebApplicationException , IllegalConstrParamTypeException , IllegalPathParamTypeException , MissingConstructorException { Util . checkClassConcrete ( jaxRsProviderClass , \"provider\" ) ; if ( objectFactory != null ) { Object jaxRsProvider ; jaxRsProvider = objectFactory . getInstance ( jaxRsProviderClass ) ; if ( jaxRsProvider != null ) { return jaxRsProvider ; } } final Constructor < ? > providerConstructor = WrapperUtil . findJaxRsConstructor (", "gt": "jaxRsProviderClass , \"provider\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4697, "input": "<s> package javax . lang . model . util ; import java . util . List ; import javax . lang . model . element . * ; import javax . lang . model . type . TypeMirror ; import static javax . lang . model . SourceVersion . * ; import javax", "gt": ". lang . model . SourceVersion ;", "prediction": ";\n", "label": 0}
{"id": 5322, "input": "<s> package com . corundumstudio . socketio ; public abstract class AckCallback < T > { protected final Class < T > resultClass ; protected final int timeout ; public AckCallback ( Class < T > resultClass ) { this ( resultClass , - 1 ) ; } public AckCallback ( Class < T > resultClass , int timeout ) { this . resultClass = resultClass ; this . timeout = timeout ; } public int getTimeout ( ) { return timeout ; } public abstract void", "gt": "onSuccess ( T result ) ;", "prediction": "( )\n", "label": 1}
{"id": 4232, "input": "<s> import java . util . List ; class T6985719b { abstract class A { abstract void f ( List < String > ls ) ; } interface B { void f ( List < Integer > ls ) ; } abstract class", "gt": "C extends A implements B", "prediction": "\n", "label": 0}
{"id": 5330, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . gwt . client . model ; public interface TilingInfoCallback {", "gt": "void tilingInfoUpdated ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9682, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface HideAccount extends ReportAttribute { String getExpression ( ) ;", "gt": "void setExpression ( String value ) ;", "prediction": "}\n", "label": 0}
{"id": 5372, "input": "<s> package org . zweizeichen . Motd ; import org . bukkit . entity . Player ; import org . bukkit . plugin . PluginDescriptionFile ; import org . bukkit . plugin . java . JavaPlugin ; import org . bukkit . configuration . file . YamlConfiguration ; import org . zweizeichen . Motd . modules . * ; public class Motd extends JavaPlugin { public String vtimeWorldName ; private final int CONFIG_VERSION = 3 ; public YamlConfiguration config ; public Config configFile ; public Permissions permissions = new Permissions ( this ) ; public Boolean permissionsEnabled = false ; public Markup markup = new Markup ( this ) ; @ Override public void onDisable ( ) { System . out . println ( \"Motd Disabled\" ) ; } @ Override public void onEnable ( ) { PluginDescriptionFile pdfFile = this . getDescription ( ) ; configFile = new Config ( this ) ; config = configFile . initConfig ( CONFIG_VERSION ) ; permissionsEnabled = config . getBoolean ( \"permissions_enabled\" ) ; if ( permissionsEnabled ) { System . out . println ( \"[motd] Permissions are enabled via SuperPerms.\" ) ; } else { System . out . println ( \"[motd] Permissions are not enabled. Commands will be handled by config.\" ) ; } getCommand ( \"ip\" ) . setExecutor ( new Util ( this ) ) ; getCommand ( \"who\" ) . setExecutor ( new Who ( this ) ) ; getCommand ( \"rules\" ) . setExecutor ( new Rules ( this ) ) ; getCommand ( \"motd\" ) .", "gt": "setExecutor ( new MessageOfTheDay ( this ) ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7738, "input": "<s> package org . ofbiz . party . content ; import org . ofbiz . content . content . ContentWrapper ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . base . util . * ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . entity . model . ModelUtil ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . service . LocalDispatcher ; import javax . servlet . http . HttpServletRequest ; import java . util . * ; import java . io . Writer ; import java . io . IOException ; import java . io . StringWriter ; import javolution . util . FastList ; import javolution . util . FastMap ; public class PartyContentWrapper implements ContentWrapper { public static final String module = PartyContentWrapper . class . getName ( ) ; public static final String CACHE_KEY_SEPARATOR = \"::\" ; private static final UtilCache < String , String > partyContentCache = UtilCache . createUtilCache ( \"party.content.rendered\" , true ) ; protected LocalDispatcher dispatcher ; protected GenericValue party ; protected Locale locale ; protected String mimeTypeId ; public PartyContentWrapper ( LocalDispatcher dispatcher , GenericValue party , Locale locale , String mimeTypeId ) { this . dispatcher = dispatcher ; this . party = party ; this . locale = locale ; this . mimeTypeId = mimeTypeId ; } public PartyContentWrapper ( GenericValue party , HttpServletRequest request ) { this . dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; this . party = party ; this . locale = UtilHttp . getLocale ( request ) ; this . mimeTypeId = \"text/html\" ; } public String get ( String contentTypeId , boolean useCache ) { return getPartyContentAsText ( party , contentTypeId , locale , mimeTypeId , party . getDelegator ( ) , dispatcher , useCache ) ; } public StringUtil . StringWrapper get ( String contentTypeId ) { return StringUtil . makeStringWrapper ( get ( contentTypeId , true ) ) ; } public String getId ( String contentTypeId ) { GenericValue partyContent = getFirstPartyContentByType ( null , party , contentTypeId , party . getDelegator ( ) ) ; if ( partyContent != null ) { return partyContent . getString ( \"contentId\" ) ; } else { return null ; } } public List < String > getList ( String contentTypeId ) { try { return getPartyContentTextList ( party , contentTypeId , locale , mimeTypeId , party . getDelegator ( ) , dispatcher ) ; } catch ( Exception e ) { Debug . logError ( e , module ) ; return null ; } } public String getContent ( String contentId , boolean useCache ) { return getPartyContentAsText ( party , contentId , null , locale , mimeTypeId , party . getDelegator ( ) , dispatcher , useCache ) ; } public String getContent ( String contentId ) { return getContent ( contentId , true ) ; } public static String getPartyContentAsText ( GenericValue party , String partyContentId , HttpServletRequest request ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; return getPartyContentAsText ( party , partyContentId , UtilHttp . getLocale ( request ) , \"text/html\" , party . getDelegator ( ) , dispatcher , true ) ; } public static String getPartyContentAsText ( GenericValue party , String partyContentId , Locale locale , LocalDispatcher dispatcher ) { return getPartyContentAsText ( party , partyContentId ,", "gt": "locale , null , null , dispatcher , true ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5389, "input": "<s> package org . restlet . service ; import java . util . List ; import org . restlet . Request ; import org . restlet . engine . application . Conneg ; import org . restlet . engine . application . FlexibleConneg ; import org . restlet . engine . application . StrictConneg ; import org . restlet . representation . Variant ; public class ConnegService extends Service { private volatile boolean strict ; public ConnegService ( ) { this ( true ) ; } public ConnegService ( boolean enabled ) { super ( enabled ) ; this . strict = false ; } public Variant getPreferredVariant ( List < ? extends Variant > variants , Request request , MetadataService metadataService ) { Conneg conneg = isStrict ( ) ? new StrictConneg ( request , metadataService", "gt": ") : new FlexibleConneg ( request , metadataService ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2599, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . swing . ColorUtils ; import javax . swing . * ; import javax . swing . plaf . ColorUIResource ; import javax . swing . plaf . InsetsUIResource ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . plaf . metal . MetalTheme ; import java . awt . Color ; import java . awt . Frame ; import java . awt . Insets ; import java . io . * ; import java . util . * ; import java . util . logging . * ; public class PgsLookAndFeel extends MetalLookAndFeel { private static MetalTheme currentTheme ; private static Logger logger = Logger . getLogger ( \"PgsLookAndFeel\" ) ; static { loadUserSettings ( ) ; } protected static void loadUserSettings ( ) { InputStream in = PgsLookAndFeel . class . getResourceAsStream ( \"/pgs.properties\" ) ; if ( in != null ) { try { logger . finest ( \"Found a pgs.properties! Going to setup from pgs.properties!\" ) ; Properties props = new Properties ( ) ; props . load ( in ) ; PlafOptions . useShadowBorder ( getPropertyBoolValue ( props , \"pgs.shadowBorder\" , \"false\" ) ) ; PlafOptions . useBoldFonts ( getPropertyBoolValue ( props , \"swing.boldMetal\" , \"false\" ) ) ; PlafOptions . useBoldMenuFonts ( getPropertyBoolValue ( props , \"pgs.boldMenuFonts\" , \"false\" ) ) ; PlafOptions . useExtraMargin ( getPropertyBoolValue ( props , \"pgs.extraMargin\" , \"true\" ) ) ; PlafOptions . useDisabledIcon ( getPropertyBoolValue ( props , \"pgs.useDisabledIcon\" , \"true\" ) ) ; PlafOptions . useToolBarIcon ( getPropertyBoolValue ( props , \"pgs.useToolBarIcon\" , \"true\" ) ) ; PlafOptions . setAntialiasingEnabled ( getPropertyBoolValue ( props , \"pgs.aaEnabled\" , \"false\" ) ) ; PlafOptions . setClearBorderEnabled ( getPropertyBoolValue ( props , \"pgs.clearBorderEnabled\" , \"false\" ) ) ; PlafOptions . setFixHtmlDisplayEnabled ( getPropertyBoolValue ( props , \"pgs.fixHtmlDisplayEnabled\" , \"true\" ) ) ; PlafOptions . setWheelTabbedPaneEnabled ( getPropertyBoolValue ( props , \"pgs.wheelTabEnabled\" , \"true\" ) ) ; PlafOptions . setTabbedPaneRightClickSelectionEnabled ( getPropertyBoolValue ( props , \"pgs.tabbedPaneRightClickSelectionEnabled\" , \"false\" ) ) ; PlafOptions . setTabReorderingEnabled ( getPropertyBoolValue ( props , \"pgs.tabReorderingEnabled\" , \"false\" ) ) ; PlafOptions . setPaintRolloverButtonBorder ( getPropertyBoolValue ( props , \"pgs.paintRolloverButtonBorder\" , \"true\" ) ) ; PlafOptions . setOfficeScrollBarEnabled ( getPropertyBoolValue ( props , \"pgs.officeScrollBarEnabled\" , \"false\" ) ) ; PlafOptions . setVistaStyle ( getPropertyBoolValue ( props , \"pgs.vistaStyle\" , \"false\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENUBAR , getPropertyStyleValue ( props , \"pgs.style.menuBar\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENU_ITEM , getPropertyStyleValue ( props , \"pgs.style.menuitem\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENUBARMENU , getPropertyStyleValue ( props , \"pgs.style.menuBarMenu\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . TOOLBAR , getPropertyStyleValue ( props , \"pgs.style.toolBar\" , \"gradient\" ) ) ; PlafOptions . setStyle ( PlafOptions . TOOLBARBUTTON , getPropertyStyleValue ( props , \"pgs.style.toolBarButton\" , \"gradient\" ) ) ; PlafOptions . setStyle ( PlafOptions . BUTTON , getPropertyStyleValue ( props , \"pgs.style.button\" , \"gradient\" ) ) ; PgsTheme theme = null ; String themeProperty = props . getProperty ( \"theme\" ) ; if ( themeProperty != null ) { theme = ThemeFactory . getTheme ( themeProperty ) ; } else { theme = ThemeFactory . createTheme ( props ) ; } if ( theme != null ) { setCurrentTheme ( theme ) ; } else { logger . warning ( \"Could not create theme from pgs.properties\" ) ; } logger . finest ( \"pgs.properties have been loaded.\" ) ; } catch ( IOException ex ) { logger . warning ( \"Unexpected exception happened while loading properties: \" + ex . toString ( ) ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { logger . warning ( \"Unexpected exception happened while closing the stream: \" + e . toString ( ) ) ; } } } } private static boolean getPropertyBoolValue ( Properties props , String key , String def ) { return \"true\" . equals ( props . getProperty ( key , def ) . trim ( ) . toLowerCase ( ) ) ; } private static int getPropertyStyleValue ( Properties props , String key , String def ) { return \"flat\" . equals ( props . getProperty ( key , def ) . trim ( ) . toLowerCase ( ) ) ? PlafOptions . FLAT_STYLE : PlafOptions . GRADIENT_STYLE ; } public PgsLookAndFeel ( ) { super ( ) ; UIManager . put ( \"swing.boldMetal\" , PlafOptions . useBoldFonts ( ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void initialize ( ) { super . initialize ( ) ; MetalLookAndFeel . setCurrentTheme ( getCurrentTheme ( ) ) ; } public void uninitialize ( ) { super . uninitialize ( ) ; } public static void setAsLookAndFeel ( ) { try { UIManager . setLookAndFeel ( \"com.pagosoft.plaf.PgsLookAndFeel\" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void updateAllUIs ( ) { Frame [ ] frames = Frame . getFrames ( ) ; for ( int i = 0 ; i < frames . length ; i ++ ) { if ( frames [ i ] instanceof JFrame ) { SwingUtilities . updateComponentTreeUI ( frames [ i ] ) ; } } } public static void setCurrentTheme ( MetalTheme theme ) { if ( theme == null ) { throw new IllegalArgumentException ( \"theme must not be null!\" ) ; } currentTheme = theme ; MetalLookAndFeel . setCurrentTheme ( theme ) ; } public static MetalTheme getCurrentTheme ( ) { if ( currentTheme == null ) { String theme = null ; try { theme = System . getProperty ( \"pgs.theme\" ) ; } catch ( Exception e ) { logger . warning ( \"Could not read system property 'pgs.theme'\" ) ; } if ( theme == null ) { currentTheme = ThemeFactory . getDefaultTheme ( ) ; } else { currentTheme = ThemeFactory . getTheme ( theme ) ; } } return currentTheme ; } public String getID ( ) { return \"com.pagosoft.plaf.PgsLookAndFeel\" ; } public String getName ( ) { return \"PgsLookAndFeel\" ; } public String getDescription ( ) { return \"Much like the original MetalLookAndFeel, but with gradients on menus, buttons, etc.\" ; } public boolean isNativeLookAndFeel ( ) { return false ; } public boolean isSupportedLookAndFeel ( ) { return true ; } protected void initClassDefaults ( UIDefaults table ) { super .", "gt": "initClassDefaults ( table ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5403, "input": "<s> package org . fuzzydb . attrs . enums ; import org . fuzzydb . attrs . AttributeMapFactory ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . enums . EnumExclusiveScorerExclusive ; import org . fuzzydb . attrs . enums . EnumExclusiveValue ; import org . fuzzydb . attrs . internal . ScoreConfiguration ; import org . fuzzydb . core . whirlwind . SearchSpec . SearchMode ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeMap ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; public class EnumExclusiveScorerExclusiveTest { protected int statusId = 1 ; protected int statusWantId = 2 ; private ScoreConfiguration scoreConfig = new ScoreConfiguration ( ) ; protected EnumExclusiveValue wantNullStatus = new EnumExclusiveValue ( statusWantId , ( short ) 0 , EnumExclusiveValue . WANT_NULL_VALUE ) ; protected EnumExclusiveValue statusIsOne = new EnumExclusiveValue ( statusId , ( short ) 0 , ( short ) 1 ) ; @ Before public void setUpConfig ( ) throws Exception { EnumExclusiveScorerExclusive scorer = new EnumExclusiveScorerExclusive ( statusWantId , statusId ) ; scorer . setScoreNull ( true ) ; scoreConfig . add ( scorer ) ; } @ Test public void testWantNull ( ) { IAttributeMap < IAttribute > search = AttributeMapFactory . newInstance ( IAttribute . class ) ; IAttributeMap < IAttribute > profile = AttributeMapFactory . newInstance ( IAttribute . class ) ; search . putAttr ( wantNullStatus ) ; Score score = scoreConfig . scoreAllItemToItem ( search , profile , SearchMode . Forwards ) ; assertTrue ( score .", "gt": "total ( ) == 1.0f ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4283, "input": "<s> package com . deliciousdroid . activity ; import java . util . ArrayList ; import com . deliciousdroid . Constants ; import com . deliciousdroid . R ; import com . deliciousdroid . authenticator . AuthenticatorActivity ; import com . deliciousdroid . platform . BookmarkManager ; import com . deliciousdroid . platform . BundleManager ; import com . deliciousdroid . platform . TagManager ; import com . deliciousdroid . providers . BookmarkContentProvider ; import android . accounts . Account ; import android . accounts . AccountManager ; import android . app . Activity ; import android . content . ContentResolver ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . os . Bundle ; import android . preference . PreferenceManager ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . widget . TextView ; import android . widget . Toast ; public class AppBaseActivity extends Activity { protected AccountManager mAccountManager ; protected Account mAccount ; protected Context mContext ; protected String username = null ; protected SharedPreferences settings ; protected long lastUpdate ; protected String bookmarkLimit ; protected String defaultAction ; private boolean first = true ; Bundle savedState ; @ Override public void onCreate ( Bundle savedInstanceState ) { savedState = savedInstanceState ; super . onCreate ( savedState ) ; mContext = this ; mAccountManager = AccountManager . get ( this ) ; loadSettings ( ) ; init ( ) ; } private void init ( ) { if ( mAccountManager . getAccountsByType ( Constants . ACCOUNT_TYPE ) . length < 1 ) { Intent i = new Intent ( this , AuthenticatorActivity . class ) ; startActivity ( i ) ; return ; } else if ( lastUpdate == 0 ) { Toast . makeText ( this , \"Syncing...\" , Toast . LENGTH_LONG ) . show ( ) ; if ( mAccount == null || username == null ) loadAccounts ( ) ; ContentResolver . requestSync ( mAccount , BookmarkContentProvider . AUTHORITY , Bundle . EMPTY ) ; } else { loadAccounts ( ) ; } } private void loadAccounts ( ) { if ( mAccountManager . getAccountsByType ( Constants . ACCOUNT_TYPE ) . length > 0 ) { mAccount = mAccountManager . getAccountsByType ( Constants . ACCOUNT_TYPE ) [ 0 ] ; } ArrayList < String", "gt": "> accounts = new ArrayList < String > ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 5414, "input": "<s> package org . seage . problem . tsp . grasp ; import java . io . FileInputStream ; import org . seage . problem . tsp . CityProvider ; import org . seage . problem . tsp . City ; import org . seage . metaheuristic . grasp . HillClimber ; import org . seage . problem . tsp . Visualizer ; public class TspHillClimberTest { private City [ ] _cities ; private Integer [ ] _tour ; private HillClimber _hc ; public static void main ( String [ ] args ) { try { new TspHillClimberTest ( ) . run ( args [ 0 ] , \"greedy\" , 500 , 500 ) ; } catch ( Exception ex ) { System . out . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } } public void run ( String path , String switcher , int restarts , int iteration ) throws Exception { _cities = CityProvider . readCities ( new FileInputStream ( path ) ) ; System . out . println ( \"Loading cities from path: \" + path ) ; System . out . println ( \"Number of cities: \" + _cities . length ) ; _hc = new HillClimber ( new TspObjectiveFunction ( _cities ) , new TspMoveManager ( ) , new TSPSolutionGenerator ( switcher , _cities ) , iteration ) ; _hc . startRestartedSearching ( restarts ) ; TspSolution bestSol = ( TspSolution ) _hc . getBestSolution ( ) ; _tour = bestSol", "gt": ". getTour ( ) ;", "prediction": ";\n", "label": 1}
{"id": 6631, "input": "<s> class Test { void foo ( float", "gt": "x , int x )", "prediction": ") ;\n", "label": 0}
{"id": 5418, "input": "<s> package org . apache . lucene . queryParser . surround . parser ; public interface CharStream { char readChar ( ) throws java . io . IOException ; int getEndColumn ( ) ; int getEndLine ( ) ; int getBeginColumn ( ) ; int getBeginLine ( ) ; void backup ( int amount ) ; char BeginToken ( ) throws java . io . IOException ; String GetImage ( ) ; char", "gt": "[ ] GetSuffix ( int len ) ;", "prediction": "}\n", "label": 1}
{"id": 954, "input": "<s> package com . sensor ; import android . os . Handler ; class SensorDelayThread extends Thread { private Boolean threadAlive = true ; public Handler mHandler ; public int delayTime = 1000 ; public SensorDelayThread ( SensorDelayHandler myHandler , int delayTime ) { this . mHandler = myHandler ; this . delayTime = delayTime ; } public void stopThread ( ) { synchronized ( this ) { threadAlive = false ; } } public void run ( ) { do { mHandler . sendEmptyMessage ( 0 ) ; try { Thread .", "gt": "sleep ( delayTime ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5419, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . explorer ; import org . eclipse . core . runtime . IPath ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . internal . cheatsheets . CheatSheetPlugin ; import org . eclipse . ui . internal . cheatsheets . Messages ; import org . eclipse . ui . internal . cheatsheets . composite . model . AbstractTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; public class StartAction extends Action { private AbstractTask task ; private static final String START_CCS_TASK_GIF = \"start_ccs_task.gif\" ; public StartAction ( ICompositeCheatSheetTask task ) { this . task = ( AbstractTask ) task ; this . setText ( Messages . get ( ) . COMPOSITE_MENU_START ) ; IPath path = CheatSheetPlugin . ICONS_PATH . append ( CheatSheetPlugin . T_ELCL ) . append ( START_CCS_TASK_GIF ) ; ImageDescriptor startImage = CheatSheetPlugin . createImageDescriptor ( CheatSheetPlugin . getPlugin ( ) .", "gt": "getBundle ( ) , path ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3241, "input": "<s> package net . minecraft . src ; public class ThxModelHelicopterAlt extends ThxModelHelicopterBase { public ModelRenderer body ; public ModelRenderer mainRotor ; public ModelRenderer tailRotor ; public ModelRenderer windshield ; public ThxModelHelicopterAlt ( ) { renderTexture = \"/thx/helicopter-alt.png\" ; body : { float length = 12f ; float height = 8f ; float width = 6f ; body = new ModelRenderer ( this , 0 , 12 ) ; body . addBox ( - length / 2f , - height / 2f , - width / 2f , ( int ) length , ( int ) height , ( int ) width ) ; body . setRotationPoint ( 0f , - 2f , 0f ) ; } mainRotor : { float length = 30f ; float height = 0f ; float width = 1f ; mainRotor = new ModelRenderer ( this , 0 , 0 ) ; mainRotor . addBox ( - length / 2f , - height / 2f , - width / 2f , ( int ) length , ( int ) height , ( int ) width ) ; mainRotor . setRotationPoint ( 2f , - 11.7f , 0f ) ; } tailRotor : { float length = 8f ; float height = 1f ; float width = 0f ; tailRotor = new ModelRenderer ( this , 0 , 2 ) ; tailRotor . addBox ( - length / 2f , - height / 2f , - width / 2f , ( int ) length , ( int ) height , ( int ) width ) ; tailRotor . setRotationPoint ( 16f , - 7f , .7f ) ; } windshield : { float length = 9f ; float height = 7f ; float width = 0f ; windshield = new ModelRenderer ( this , 0 , 4 ) ; windshield . addBox ( - length / 2f , - height / 2f , - width / 2f , ( int ) length , ( int ) height , ( int ) width ) ; windshield . setRotationPoint ( - 6.5f , - 5.5f , 0f ) ; windshield . rotateAngleY = PI * 1.5f ; } } public void render ( ) { super . render ( ) ; if (", "gt": "! visible ) return ;", "prediction": ")\n", "label": 0}
{"id": 5424, "input": "<s> package org . eclipse . rap . rwt . testfixture ; import java . util . * ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . swt . widgets . Widget ; import org . json . * ; public final class Message { private JSONObject message ; private JSONArray operations ; public Message ( String string ) { String json = string . trim ( ) ; try { message = new JSONObject ( json ) ; } catch ( JSONException e ) { throw new IllegalArgumentException ( \"Could not parse json: \" + json ) ; } try { operations = message . getJSONArray ( \"operations\" ) ; } catch ( JSONException e ) { throw new IllegalArgumentException ( \"Missing operations array: \" + json ) ; } } @ Override public String toString ( ) { try { return message . toString ( 2 ) ; } catch ( JSONException e ) { throw new RuntimeException ( \"Formatting failed\" ) ; } } public int getRequestCounter ( ) { try { return message . getJSONObject ( \"head\" ) . getInt ( \"requestCounter\" ) ; } catch ( JSONException e ) { throw new RuntimeException ( \"Getting requestCounter failed\" ) ; } } public String getError ( ) { try { return message . getJSONObject ( \"head\" ) . getString ( \"error\" ) ; } catch ( JSONException e ) { throw new RuntimeException ( \"Getting error failed\" ) ; } } public String getErrorMessage ( ) { try { return message . getJSONObject ( \"head\" ) . getString ( \"message\" ) ; } catch ( JSONException e ) { throw new RuntimeException ( \"Getting error message failed\" ) ; } } public int getOperationCount ( ) { return operations . length ( ) ; } public Operation getOperation ( int position ) { Operation result ; JSONArray operation = getOperationAsJson ( position ) ; String action = getOperationAction ( operation ) ; if ( action . equals ( \"create\" ) ) { result = new CreateOperation ( operation ) ; } else if ( action . equals ( \"call\" ) ) { result = new CallOperation ( operation ) ; } else if ( action . equals ( \"set\" ) ) { result = new SetOperation ( operation ) ; } else if ( action . equals ( \"listen\" ) ) { result = new ListenOperation ( operation ) ; } else if ( action . equals ( \"destroy\" ) ) { result = new DestroyOperation ( operation ) ; } else { throw new IllegalArgumentException ( \"Unknown operation action: \" + action ) ; } return result ; } public Object findSetProperty ( Widget widget , String property ) { String target = WidgetUtil . getId ( widget ) ; return findSetProperty ( target , property ) ; } public Object findSetProperty ( String target , String property ) { SetOperation operation = findSetOperation ( target , property ) ; if ( operation == null ) { throw new IllegalStateException ( \"operation not found\" ) ; } return operation . getProperty ( property ) ; } public SetOperation findSetOperation ( Widget widget , String property ) { String target = WidgetUtil . getId ( widget ) ; return findSetOperation ( target , property ) ; } public ListenOperation findListenOperation ( Widget widget , String property ) { String target = WidgetUtil . getId ( widget ) ; return findListenOperation ( target , property ) ; } public ListenOperation findListenOperation ( String target , String property ) { return ( ListenOperation ) findOperation ( ListenOperation . class , target , property ) ; } public Object findListenProperty ( Widget widget , String property ) { String target = WidgetUtil . getId ( widget ) ; return findListenProperty ( target , property ) ; } public Object findListenProperty ( String target , String property ) { ListenOperation operation = findListenOperation ( target , property ) ; if ( operation == null ) { throw new IllegalStateException ( \"operation not found\" ) ; } return operation . getProperty ( property ) ; } public CreateOperation findCreateOperation ( Widget widget ) { String target = WidgetUtil . getId ( widget ) ; return findCreateOperation ( target ) ; } public Object findCreateProperty ( Widget widget , String property ) { String target = WidgetUtil . getId ( widget ) ; return findCreateProperty ( target , property ) ; } public Object findCreateProperty ( String target , String property ) { CreateOperation operation = findCreateOperation ( target ) ; if ( operation == null || operation . getPropertyNames ( ) . indexOf ( property ) == - 1 ) { throw new IllegalStateException ( \"operation not found\" ) ; } return operation . getProperty ( property ) ; } public CreateOperation findCreateOperation ( String target ) { return ( CreateOperation ) findOperation ( CreateOperation . class , target ) ; } public DestroyOperation findDestroyOperation ( Widget widget ) { String target = WidgetUtil . getId ( widget ) ; return ( DestroyOperation ) findOperation ( DestroyOperation . class , target ) ; } public SetOperation findSetOperation ( String target , String property ) { return ( SetOperation ) findOperation ( SetOperation . class , target , property ) ; } public CallOperation findCallOperation ( Widget widget , String method ) { String target = WidgetUtil . getId ( widget ) ; return findCallOperation ( target , method ) ; } public CallOperation findCallOperation", "gt": "( String target , String method )", "prediction": "( )\n", "label": 1}
{"id": 483, "input": "<s> class ForwardReference_2 { static { System . out . println ( x ) ; } static", "gt": "int x = 1 ;", "prediction": "}\n", "label": 0}
{"id": 5427, "input": "<s> package org . nuxeo . ecm . platform . forms . layout . export ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import org . nuxeo . ecm . platform . forms . layout . io . JSONLayoutExporter ; @ Provider @ Produces ( { \"application/json\" , \"text/plain\" } ) public class WidgetTypeDefinitionsJsonWriter implements MessageBodyWriter < WidgetTypeDefinitions > { @ Override public long getSize ( WidgetTypeDefinitions arg0 , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 ) { return - 1 ; } @ Override public boolean isWriteable ( Class < ? > arg0 , Type arg1 , Annotation [ ] arg2 , MediaType arg3 ) { return WidgetTypeDefinitions . class . isAssignableFrom ( arg0 ) ; } @ Override public void writeTo ( WidgetTypeDefinitions arg0 , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 , MultivaluedMap < String , Object > arg5 , OutputStream arg6 ) throws IOException , WebApplicationException { JSONLayoutExporter . export", "gt": "( arg0 , arg6 ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2323, "input": "<s> import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import static javax . tools . Diagnostic . Kind . * ; @ SupportedOptions ( \"error\" ) public class TestProcUseImplicitWarning extends JavacTestingAbstractProcessor { int round = 0 ; @ Override public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { round ++ ; if ( round == 1 ) { boolean error = options . containsKey ( \"error\" ) ; if ( error ) messager", "gt": ". printMessage ( ERROR , \"error generated per option\" ) ;", "prediction": "\n", "label": 0}
{"id": 5437, "input": "<s> package org . fuzzydb . client . marker ; public interface HasNominee { public", "gt": "Object getNominee ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 2649, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . ProducedTypedReference ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCVariableDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; public class AttributeDefinitionBuilder { private boolean hasField = true ; private final String fieldName ; private final JCTree . JCExpression attrType ; private final JCTree . JCExpression attrTypeRaw ; private final String attrName ; private String javaClassName ; private long modifiers ; private final ListBuffer < JCTree . JCAnnotation > annotations = ListBuffer . lb ( ) ; private boolean readable = true ; private final MethodDefinitionBuilder getterBuilder ; private JCTree . JCExpression variableInit ; private boolean writable = true ; private final MethodDefinitionBuilder setterBuilder ; private AbstractTransformer owner ; private boolean toplevel = false ; private boolean noAnnotations = false ; private AttributeDefinitionBuilder ( AbstractTransformer owner , TypedDeclaration attrType , String javaClassName , String attrName , String fieldName , boolean toplevel ) { int typeFlags = 0 ; ProducedTypedReference typedRef = owner . getTypedReference ( attrType ) ; ProducedTypedReference nonWideningTypedRef = owner . nonWideningTypeDecl ( typedRef ) ; ProducedType nonWideningType = owner . nonWideningType ( typedRef , nonWideningTypedRef ) ; if ( ! CodegenUtil . isUnBoxed ( nonWideningTypedRef . getDeclaration ( ) ) ) { typeFlags |= AbstractTransformer . JT_NO_PRIMITIVES ; } this . attrType = owner . makeJavaType ( nonWideningType , typeFlags ) ; this . attrTypeRaw = owner . makeJavaType ( nonWideningType , AbstractTransformer . JT_RAW ) ; this . owner = owner ; this . javaClassName = javaClassName ; this . attrName = attrName ; this . fieldName = fieldName ; this . toplevel = toplevel ; getterBuilder = MethodDefinitionBuilder . method2 ( owner , Naming . getGetterName ( attrType ) ) . block ( generateDefaultGetterBlock ( ) ) . isOverride ( attrType . isActual ( ) ) . annotations ( owner . makeAtAnnotations ( attrType . getAnnotations ( ) ) ) . resultType ( this . attrType , attrType ) ; setterBuilder = MethodDefinitionBuilder . method2 ( owner , Naming . getSetterName ( attrType ) ) . block ( generateDefaultSetterBlock ( ) ) . isOverride ( attrType . isActual ( ) && ( ( TypedDeclaration ) attrType . getRefinedDeclaration ( ) ) . isVariable ( ) ) . parameter ( Flags . FINAL , attrName , attrType , nonWideningTypedRef . getDeclaration ( ) , nonWideningType , 0 ) ; } public static AttributeDefinitionBuilder wrapped ( AbstractTransformer owner , String javaClassName , String attrName , TypedDeclaration attrType , boolean toplevel ) { return new AttributeDefinitionBuilder ( owner , attrType , javaClassName , attrName , \"value\" , toplevel ) ; } public static AttributeDefinitionBuilder getter ( AbstractTransformer owner , String attrAndFieldName , TypedDeclaration attrType ) { return new AttributeDefinitionBuilder ( owner , attrType , null , attrAndFieldName , attrAndFieldName , false ) . skipField ( ) . immutable ( ) ; } public static AttributeDefinitionBuilder setter ( AbstractTransformer owner , String attrAndFieldName , TypedDeclaration attrType ) { return new AttributeDefinitionBuilder ( owner , attrType , null , attrAndFieldName , attrAndFieldName , false ) . skipField ( ) . skipGetter ( ) ; } public List < JCTree > build ( ) { ListBuffer < JCTree > defs = ListBuffer . lb ( ) ; appendDefinitionsTo ( defs ) ; if ( javaClassName != null ) { return ClassDefinitionBuilder . klass ( owner , javaClassName , null ) . modifiers ( Flags . FINAL | ( modifiers & ( Flags . PUBLIC | Flags . PRIVATE ) ) ) . constructorModifiers ( Flags . PRIVATE ) . annotations ( owner . makeAtAttribute ( ) ) . annotations ( annotations . toList ( ) ) . defs ( defs . toList ( ) ) . build ( ) ; } else { return defs . toList ( ) ; } } public void appendDefinitionsTo ( ListBuffer < JCTree > defs ) { if ( hasField ) {", "gt": "defs . append ( generateField ( ) ) ;", "prediction": "}\n", "label": 0}
{"id": 5441, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs ; import java . security . Principal ; import java . util . HashSet ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . Response ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationType ; import org . nuxeo . ecm . automation . server . jaxrs . batch . BatchResource ; import org . nuxeo . ecm . automation . server . jaxrs . debug . DebugResource ; import org . nuxeo . ecm . automation . server . jaxrs . doc . DocResource ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . model . PropertyException ; import org . nuxeo . ecm . webengine . jaxrs . session . SessionFactory ; import org . nuxeo . runtime . api . Framework ; @ Path ( \"automation\" ) public class AutomationResource { protected AutomationService service ; public AutomationResource ( ) throws Exception { service = Framework . getService ( AutomationService . class ) ; } @ Path ( \"doc\" ) public Object getDocPage ( ) { return new DocResource ( ) ; } @ Path ( \"debug\" ) public Object getDebugPage ( ) { return new DebugResource ( ) ; } @ SuppressWarnings ( \"unchecked\" ) @ GET @ Path ( \"files/{uid}\" ) public Object getFile ( @ Context HttpServletRequest request , @ PathParam ( \"uid\" ) String uid , @ QueryParam ( \"path\" ) String path ) { try { CoreSession session = SessionFactory . getSession ( request ) ; DocumentModel doc = session . getDocument ( new IdRef ( uid ) ) ; Object obj = null ; try { obj = doc . getPropertyValue ( path ) ; } catch ( PropertyException e ) { return ResponseHelper . notFound ( ) ; } if ( obj == null ) { return ResponseHelper . notFound ( ) ; } if ( obj instanceof List < ? > ) { List < ? > list = ( List < ? > ) obj ; if ( list . isEmpty ( ) ) { return ResponseHelper . notFound ( ) ; } if ( list . get ( 0 ) instanceof Blob ) { return ResponseHelper . blobs ( ( List < Blob > ) list ) ; } } else if ( obj instanceof Blob ) { return ResponseHelper . blob ( ( Blob ) obj ) ; } return ResponseHelper . notFound ( ) ; } catch ( Exception e ) { throw", "gt": "ExceptionHandler . newException ( e ) ;", "prediction": "\n", "label": 1}
{"id": 5690, "input": "<s> import java . util . List ; import java . util . ArrayList ; public class T6253161a { @ SuppressWarnings ( \"unchecked\" ) public void anonymousMethod ( ) { List list = new ArrayList < String > ( ) { static final long serialVersionUID = 1 ; List list = new ArrayList < Integer > ( ) ; public List < Integer > getMyList ( ) { final List floatList = new ArrayList < Float > ( ) { } ; for ( int i = 0 ; i < 10 ; i ++ ) list . add ( ( Float ) ( floatList . get (", "gt": "i ) ) * 11.232F * i ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 5453, "input": "<s> package org . nuxeo . webengine . blogs ; import static org . nuxeo . webengine . blogs . utils . BlogConstants . BLOGS_THEME_PAGE ; import static org . nuxeo . webengine . blogs . utils . BlogConstants . BLOG_DOC_TYPE ; import static org . nuxeo . webengine . blogs . utils . BlogConstants . BLOG_POST_DOC_TYPE ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . nuxeo . ecm . webengine . model . WebObject ; import org . nuxeo . webengine . sites . Sites ; @ Path ( \"/blogs\" ) @ WebObject", "gt": "( type = \"blogs\" , facets =", "prediction": ";\n", "label": 1}
{"id": 3876, "input": "<s> package com . dyned . woremotesiteconfig . eom ; import com . webobjects . eoaccess . * ; import com . webobjects . eocontrol . * ; import com . webobjects . foundation . * ; import java . math . * ; import java . util . * ; import org . apache . log4j . Logger ; @ SuppressWarnings ( \"all\" ) public abstract class _TimePoint extends EOGenericRecord { public static final String ENTITY_NAME = \"TimePoint\" ; public static final String HOUR_KEY = \"hour\" ; public static final String MIN_KEY = \"min\" ; public static final String NOTES_KEY = \"notes\" ; public static final String TITLE_KEY = \"title\" ; public static final String STORED_SITE_KEY = \"storedSite\" ; public static final String TIME_POINT_APPLICATIONS_KEY = \"timePointApplications\" ; private static Logger LOG = Logger . getLogger ( _TimePoint . class ) ; public TimePoint localInstanceIn ( EOEditingContext editingContext ) { TimePoint localInstance = ( TimePoint ) EOUtilities . localInstanceOfObject ( editingContext , this ) ; if ( localInstance == null ) { throw new IllegalStateException ( \"You attempted to localInstance \" + this + \", which has not yet committed.\" ) ; } return localInstance ; } public Integer hour ( ) { return ( Integer ) storedValueForKey ( \"hour\" ) ; } public void setHour ( Integer value ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"updating hour from \" + hour ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"hour\" ) ; } public Integer min ( ) { return ( Integer ) storedValueForKey ( \"min\" ) ; } public void setMin ( Integer value ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"updating min from \" + min ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"min\" ) ; } public String notes ( ) { return ( String ) storedValueForKey ( \"notes\" ) ; } public void setNotes ( String value ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"updating notes from \" + notes ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"notes\" ) ; } public String title ( ) { return ( String ) storedValueForKey ( \"title\" ) ; } public void setTitle ( String value ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"updating title from \" + title ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"title\" ) ; } public com . dyned . woremotesiteconfig . eom . StoredSite storedSite ( ) { return ( com . dyned . woremotesiteconfig . eom . StoredSite ) storedValueForKey ( \"storedSite\" ) ; } public void setStoredSiteRelationship ( com . dyned . woremotesiteconfig . eom . StoredSite value ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"updating storedSite from \" + storedSite ( ) + \" to \" + value ) ; } if ( value == null ) { com . dyned . woremotesiteconfig . eom . StoredSite oldValue = storedSite ( ) ; if ( oldValue != null ) { removeObjectFromBothSidesOfRelationshipWithKey ( oldValue , \"storedSite\" ) ; } } else { addObjectToBothSidesOfRelationshipWithKey ( value , \"storedSite\" ) ; } } public NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > timePointApplications ( ) { return ( NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > ) storedValueForKey ( \"timePointApplications\" ) ; } public NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > timePointApplications ( EOQualifier qualifier ) { return timePointApplications ( qualifier , null , false ) ; } public NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > timePointApplications ( EOQualifier qualifier , boolean fetch ) { return timePointApplications ( qualifier , null , fetch ) ; } public NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > timePointApplications ( EOQualifier qualifier , NSArray < EOSortOrdering > sortOrderings , boolean fetch ) { NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > results ; if ( fetch ) { EOQualifier fullQualifier ; EOQualifier inverseQualifier = new EOKeyValueQualifier ( com . dyned . woremotesiteconfig . eom . TimePointApplication . TIME_POINT_KEY , EOQualifier . QualifierOperatorEqual , this ) ; if ( qualifier == null ) { fullQualifier = inverseQualifier ; } else { NSMutableArray qualifiers = new NSMutableArray ( ) ; qualifiers . addObject ( qualifier ) ; qualifiers . addObject ( inverseQualifier ) ; fullQualifier = new EOAndQualifier ( qualifiers ) ; } results = com . dyned . woremotesiteconfig . eom . TimePointApplication . fetchTimePointApplications ( editingContext ( ) , fullQualifier , sortOrderings ) ; } else { results = timePointApplications ( ) ; if ( qualifier != null ) { results = ( NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > ) EOQualifier . filteredArrayWithQualifier ( results , qualifier ) ; } if ( sortOrderings != null ) { results = ( NSArray < com . dyned . woremotesiteconfig . eom . TimePointApplication > ) EOSortOrdering . sortedArrayUsingKeyOrderArray ( results , sortOrderings ) ; } } return results ; } public void addToTimePointApplicationsRelationship ( com . dyned . woremotesiteconfig . eom . TimePointApplication object ) { if ( _TimePoint . LOG . isDebugEnabled ( ) ) { _TimePoint . LOG . debug ( \"adding \" + object + \" to timePointApplications relationship\" ) ; } addObjectToBothSidesOfRelationshipWithKey ( object , \"timePointApplications\" ) ; } public void removeFromTimePointApplicationsRelationship ( com . dyned", "gt": ". woremotesiteconfig . eom . TimePointApplication object )", "prediction": ") ;\n", "label": 0}
{"id": 5465, "input": "<s> package org . restlet . ext . odata . internal . edm ; import java . util . ArrayList ; import java . util . List ; public class AssociationSet extends NamedObject { private Association association ; private List < AssociationSetEnd > ends ; public AssociationSet ( String name ) { super ( name ) ; } public Association getAssociation ( ) { return association ; } public List < AssociationSetEnd > getEnds ( ) { if ( ends == null ) { ends", "gt": "= new ArrayList < AssociationSetEnd > ( ) ;", "prediction": "\n", "label": 1}
{"id": 2576, "input": "<s> package one ; public abstract class Parent { abstract", "gt": "void method ( ) ;", "prediction": ";\n", "label": 0}
{"id": 5479, "input": "<s> package com . codeslap . persistence ; import android . content . * ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . net . Uri ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class BaseContentProvider extends ContentProvider { private static UriMatcher sUriMatcher ; private static final Map < Integer , String > TABLE_NAME_IDS = new HashMap < Integer , String > ( ) ; private DatabaseSpec mDatabaseSpec ; @ Override public boolean onCreate ( ) { mDatabaseSpec = PersistenceConfig . getDatabaseSpec ( getDatabaseSpecId ( ) ) ; sUriMatcher = new UriMatcher ( UriMatcher . NO_MATCH ) ; List < Class < ? > > objects = mDatabaseSpec . getSqliteClasses ( ) ; int id = 1 ; for ( Class < ? > theClass : objects ) { String tableName = SQLHelper . getTableName ( theClass ) ; TABLE_NAME_IDS . put ( id , tableName ) ; sUriMatcher . addURI ( getAuthority ( ) , tableName , id ) ; id ++ ; } return true ; } @ Override public Cursor query ( Uri uri , String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { int id = sUriMatcher . match ( uri ) ; if ( ! TABLE_NAME_IDS . containsKey ( id ) ) { throw new IllegalArgumentException ( \"Unknown URI \" + uri ) ; } String tableName = TABLE_NAME_IDS . get ( id ) ; Cursor cursor = getDatabase ( ) . query ( tableName , projection , selection , selectionArgs , null , null , sortOrder , null ) ; cursor . setNotificationUri ( getContext ( ) . getContentResolver ( ) , uri ) ; return cursor ; } @ Override public String getType ( Uri uri ) { int id = sUriMatcher . match ( uri ) ; String tableName = TABLE_NAME_IDS . get ( id ) ; return \"vnd.android.cursor.dir/vnd.\" + tableName . replace ( \"_\" , \".\" ) ; } @ Override public Uri insert ( Uri uri , ContentValues initialValues ) { int id = sUriMatcher . match ( uri ) ; if ( ! TABLE_NAME_IDS . containsKey ( id ) ) { throw new IllegalArgumentException ( \"Unknown URI \" + uri + \"; id \" + id + \"; \" + TABLE_NAME_IDS ) ; } if ( initialValues == null ) { initialValues = new ContentValues ( ) ; } String tableName = TABLE_NAME_IDS . get ( id ) ; long rowId = getDatabase ( ) . insert ( tableName , null , initialValues ) ; if ( rowId > 0 ) { Uri CONTENT_URI = Uri . parse ( String . format ( \"content://%s/%s\" , getAuthority ( ) , tableName ) ) ; Uri beanUri = ContentUris . withAppendedId ( CONTENT_URI , rowId ) ; getContext ( ) . getContentResolver ( ) . notifyChange ( beanUri , null ) ; return beanUri ; } throw new SQLException ( \"Failed to insert row into \" + uri ) ; } @ Override public int delete ( Uri uri , String where , String [ ] whereArgs ) { int id = sUriMatcher", "gt": ". match ( uri ) ;", "prediction": ";\n", "label": 1}
{"id": 3722, "input": "<s> package org . msl . simple . gmfmap . simplemapping . setting ; import org . eclipse . emf . common . util . BasicEList ; import org . eclipse . emf . ecore . EAttribute ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . BasicSettingDelegate . Stateless ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse . gmf . mappings . FeatureLabelMapping ; import org . eclipse . gmf . mappings . NodeMapping ; import org . eclipse . gmf . mappings . NodeReference ; import org . eclipse . gmf . tooldef . AbstractTool ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleNodeSettingDelegate extends Stateless { public SimpleNodeSettingDelegate ( EStructuralFeature arg0 ) { super ( arg0 ) ; } @ Override protected Object get ( InternalEObject owner , boolean resolve , boolean coreType ) { if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals . SIMPLE_NODE ) { switch ( eStructuralFeature . getEContainingClass ( ) . getEAllStructuralFeatures ( ) . indexOf ( eStructuralFeature ) ) { case SimplemappingsPackage . SIMPLE_NODE__DOMAIN_META_ELEMENT : return getDomainMetaElement ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__TOOL : return getTool ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__LABEL_ATTRIBUTES : return getLabelAttributes ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__DIAGRAM_NODE : return getDiagramNode ( ( SimpleNode ) owner ) ; case SimplemappingsPackage . SIMPLE_NODE__DIAGRAM_LABEL : return getDiagramLabel ( ( SimpleNode ) owner ) ; } } return null ; } private DiagramLabel getDiagramLabel ( SimpleNode owner ) { NodeReference nodeRef = owner . getNodeReference ( ) ; if ( nodeRef != null && nodeRef . getChild ( ) != null ) { NodeMapping nodeMapping = nodeRef . getChild ( ) ; if ( ! nodeMapping . getLabelMappings ( ) . isEmpty ( ) ) return nodeMapping . getLabelMappings ( ) . get ( 0 ) . getDiagramLabel ( ) ; } return null ; } private Node getDiagramNode ( SimpleNode owner ) { NodeReference nodeRef = owner . getNodeReference ( ) ; if ( nodeRef != null && nodeRef . getChild", "gt": "( ) != null )", "prediction": "( ) ;\n", "label": 0}
{"id": 5498, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import org . eclipse . emf . common . util . EList ; import org . eclipse . xtext . xdoc . xdoc . Section2 ; import org . eclipse . xtext . xdoc . xdoc . TextOrMarkup ; public class SectionRefImplCustom extends org . eclipse . xtext . xdoc . xdoc . impl . SectionRefImpl { @ Override public EList < TextOrMarkup > getContents ( ) { return getSection (", "gt": ") . getContents ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1549, "input": "<s> class ArrayAndVarags { void m ( int [ ] array ) { } void m", "gt": "( int ... args )", "prediction": ";\n", "label": 0}
{"id": 5508, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public class LookupList { private int lookupCount ; private int [ ] lookupOffsets ; private Lookup [ ] lookups ; public LookupList ( RandomAccessFile raf , int offset , LookupSubtableFactory factory ) throws IOException { raf . seek ( offset ) ; lookupCount = raf . readUnsignedShort ( ) ; lookupOffsets = new int [ lookupCount ] ; lookups = new Lookup [ lookupCount ] ; for ( int i = 0 ; i < lookupCount ; i ++ ) { lookupOffsets [", "gt": "i ] = raf . readUnsignedShort ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5326, "input": "<s> package org . jboss . arquillian . android . spi . event ; import org . jboss . arquillian . android . api . AndroidBridge ; public class AndroidBridgeInitialized { private AndroidBridge bridge ; public AndroidBridgeInitialized ( AndroidBridge bridge ) { this . bridge = bridge ; } public AndroidBridge getBridge ( ) { return bridge ; } public void", "gt": "setBridge ( AndroidBridge bridge )", "prediction": "( )\n", "label": 0}
{"id": 5510, "input": "<s> package org . modelgoon . classes . model ; import org . modelgoon . core . AbstractConnection ; public class Association extends AbstractConnection { ClassElement child ; ClassElement parent ; String name ; String multiplicity ; boolean containment ; public Association ( ) { } public void setName ( final String name ) { this . name = name ; propertyChanged ( ) ; } public String getName ( ) { return this . name ; } public void setMultiplicity ( final String multiplicity ) { this . multiplicity = multiplicity ; propertyChanged ( ) ; } public String getMultiplicity ( ) { return this . multiplicity ; } public void setContainment ( final boolean containment ) { this . containment = containment ; } public boolean isContainment ( ) { return this . containment ; } public void setChild ( final ClassElement child ) { this . child = child ; child . addOutgoingConnection ( this ) ; } public void setParent ( final ClassElement parent ) { this", "gt": ". parent = parent ;", "prediction": "\n", "label": 1}
{"id": 5241, "input": "<s> package org . dawb . workbench . plotting . tools . fitting ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import org . dawb . common . ui . plot . IPlottingSystem ; import org . dawb . common . ui . plot . trace . ILineTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . eclipse . draw2d . ColorConstants ; import uk . ac . diamond . scisoft . analysis . fitting . functions . IPeak ; import uk . ac . diamond . scisoft . analysis . optimize . IOptimizer ; public class FittedPeaks { private List < FittedPeak > fittedPeakList ; private IOptimizer optimizer ; private FittedPeak selectedPeak ; public FittedPeaks ( ) { this . fittedPeakList = new ArrayList < FittedPeak > ( 7 ) ; } public FittedPeaks clone ( ) { final FittedPeaks ret = new FittedPeaks ( ) ; if ( selectedPeak != null ) ret . selectedPeak = selectedPeak . clone ( ) ; for ( FittedPeak fp : fittedPeakList ) { ret . fittedPeakList . add ( fp . clone ( ) ) ; } ret . optimizer = optimizer ; return ret ; } public void dispose ( ) { selectedPeak = null ; if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . dispose ( ) ; } fittedPeakList . clear ( ) ; fittedPeakList = null ; } optimizer = null ; } public void activate ( ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . activate ( ) ; } } } public void deactivate ( ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . deactivate ( ) ; } } } public void setAreasVisible ( boolean isVis ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . setFWHMVisible ( isVis ) ; } } } public void setPeaksVisible ( boolean isVis ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . setCenterVisible ( isVis ) ; } } } public void setTracesVisible ( boolean isVis ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . setTraceVisible ( isVis ) ; } } } public void setAnnotationsVisible ( boolean isVis ) { if ( fittedPeakList != null ) { for ( FittedPeak fp : fittedPeakList ) { fp . setAnnotationVisible ( isVis ) ; } } } public void setSelectedPeak ( FittedPeak peak ) { this . selectedPeak = peak ; for ( FittedPeak fp : fittedPeakList ) { fp . getFwhm ( ) . setRegionColor ( ColorConstants . orange ) ; ( ( ILineTrace ) fp . getTrace ( ) ) . setTraceColor ( ColorConstants . black ) ; fp . getAnnotation ( ) . setAnnotationColor ( ColorConstants . black ) ; } peak . getFwhm ( ) . setRegionColor ( ColorConstants . red ) ; ( ( ILineTrace ) peak . getTrace ( ) ) . setTraceColor ( ColorConstants . darkGreen ) ; peak . getAnnotation ( ) . setAnnotationColor ( ColorConstants . darkGreen ) ; this . selectedPeak = peak ; } public void deleteSelectedPeak ( IPlottingSystem sys ) { if ( selectedPeak == null ) return ; selectedPeak . delete ( sys ) ; fittedPeakList . remove ( selectedPeak ) ; selectedPeak = null ; } public void removeSelections ( IPlottingSystem sys , boolean removeSaved ) { if ( fittedPeakList != null ) { Collection < FittedPeak > removed = new HashSet < FittedPeak > ( 3 ) ; for ( FittedPeak fp : fittedPeakList ) { if ( ! removeSaved && fp . isSaved ( ) ) continue ; fp . delete ( sys ) ; removed . add ( fp ) ; } fittedPeakList . removeAll ( removed ) ; } } public int size ( ) { return fittedPeakList . size ( ) ; } public String getAlgorithmType ( ) { return getOptimizer ( ) . getClass ( ) . getSimpleName ( ) ; } public boolean isEmpty ( ) { if ( fittedPeakList == null ) return true ; return fittedPeakList . isEmpty ( ) ; } public IOptimizer getOptimizer ( ) { return optimizer ; } public void setOptimizer ( IOptimizer optimizer ) { this . optimizer = optimizer ; } public List < FittedPeak > getPeakList ( ) { return fittedPeakList ; } public Collection < ITrace > getFittedPeakTraces ( ) { if ( fittedPeakList == null || fittedPeakList . isEmpty ( ) ) return Collections . EMPTY_SET ; final Collection < ITrace > traces = new HashSet < ITrace > ( 5 ) ; for ( FittedPeak fp : fittedPeakList ) { traces . add ( fp", "gt": ". getTrace ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5514, "input": "<s> package map ; import graphics . Sprite ; import java . awt . Graphics ; import java . io . FileInputStream ; import java . util . Scanner ; public class TileSet extends Sprite { public final static int TILE_DIMENSION = 32 ; public final static int ORIGINAL_DIMENSIONS = 16 ; public final static char PASSABLE = 'p' ; public final static char OVERLAY = 'o' ; public final static char IMPASSABLE = 'i' ; boolean [ ] [ ] [ ] passability ; public TileSet ( String s ) { super ( \"tilemaps/\" + s ) ; name = s . substring ( 0 , s . indexOf ( '.' ) ) ; xFrames = image . getWidth ( ) / ORIGINAL_DIMENSIONS ; yFrames = image . getHeight ( ) / ORIGINAL_DIMENSIONS ; passability = new boolean [ xFrames ] [ yFrames ] [ ] ; try { Scanner reader = new Scanner ( new FileInputStream ( \"data/tilemaps/\" + name + \".txt\" ) ) ; for ( int i = 0 ; i < yFrames ; i ++ ) { String line = reader . nextLine ( ) ; for ( int n = 0 ; n < xFrames ; n ++ ) { char c = line . charAt ( n ) ; if ( c == PASSABLE ) passability [ n ] [ i ] = new boolean [ ] { true , true , true , true , false } ; else if ( c == OVERLAY ) passability [ n ] [ i ] = new boolean [ ] { true , true , true , true , true } ; else passability [ n ] [ i ] = new boolean [ 5 ] ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; for ( int i = 0 ; i < xFrames ; i ++ ) for ( int n = 0 ; n < yFrames ; n ++ ) passability [ i ] [ n ] = new boolean [ ] { true , true , true , true , false } ; } } @ Override public double getWidth ( ) { return xFrames ; } @ Override public double getHeight ( ) { return yFrames ; } public boolean [ ] getPassability ( int x , int y ) { return passability [ x ] [ y ] ; } public boolean [ ] getPassability ( int i ) { return passability [ i % xFrames ] [ i / xFrames ] ; } public boolean [ ] [ ] [ ] getPassabilitySet ( ) { return passability ; } public void drawTile ( Graphics g , int x , int y , int tileX , int tileY ) { if ( g != null ) g . drawImage ( image , x , y , x + ORIGINAL_DIMENSIONS , y + ORIGINAL_DIMENSIONS , tileX * ORIGINAL_DIMENSIONS , tileY * ORIGINAL_DIMENSIONS , tileX * ORIGINAL_DIMENSIONS + ORIGINAL_DIMENSIONS , tileY * ORIGINAL_DIMENSIONS + ORIGINAL_DIMENSIONS , null ) ; } public void drawEditorTile ( Graphics g , int x , int y", "gt": ", int tileX , int tileY )", "prediction": ") ;\n", "label": 1}
{"id": 579, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class NCDRedTransferFunction extends AbstractTransferFunction { @ Override public double getPoint ( double value ) { if ( value >= 0.753 ) return 1 ; if ( value <= 0.188 ) return 0 ; if ( value <= 0.251 ) return 0.316 * ( value - 0.188 ) / ( 0.251 - 0.188 ) ; if ( value <= 0.306 ) return 0.316 ; if ( value <= 0.431 ) return 0.316 + ( 1 - 0.319 ) * ( value - 0.306 ) / ( 0.431 - 0.306 ) ; if ( value >= 0.682 ) return 0.639 + ( 1 - 0.639 ) * ( value - 0.682 ) / ( 0.753 - 0.682 ) ; if ( value >= 0.635 ) return 1 - ( 1 - 0.639 ) * ( value - 0.635 ) / (", "gt": "0.682 - 0.635 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5535, "input": "<s> package org . restlet . ext . sip ; import org . restlet . data . Status ; public final class SipStatus { private static final String BASE_SIP = \"http://tools.ietf.org/html/rfc3261#section-21\" ; public static final Status INFO_TRYING = new Status ( 100 , \"Trying\" , \"The request has been received and some unspecified action is being taken\" , BASE_SIP + \".1.1\" ) ; public static final Status INFO_RINGING = new Status ( 180 , \"Ringing\" , \"The UA receiving the INVITE is trying to alert the user\" , BASE_SIP + \".1.2\" ) ; public static final Status INFO_CALL_IS_BEING_FORWARDED = new Status ( 181 , \"Call Is Being Forwarded\" , \"The call is being forwarded to a different set of destinations\" , BASE_SIP + \".1.3\" ) ; public static final Status INFO_QUEUED = new Status ( 182 , \"Queued\" , \"The server has decided to queue the call rather than reject it\" , BASE_SIP + \".1.4\" ) ; public static final Status INFO_SESSION_PROGRESS = new Status ( 183 , \"Session Progress\" , \"Conveys information about the progress of the call that is not otherwise classified\" , BASE_SIP + \".1.5\" ) ; public static final Status SUCCESS_OK = new Status ( 200 , \"Success\" , \"The request has succeeded\" , BASE_SIP + \".2.1\" ) ; public static final Status REDIRECTION_MULTIPLE_CHOICES = new Status ( 300 , \"Multiple Choices\" , \"The address in the request resolved to several choices\" , BASE_SIP + \".3.1\" ) ; public static final Status REDIRECTION_MOVED_PERMANENTLY = new Status ( 301 , \"Moved Permanently\" , \"The user can no longer be found at the given address\" , BASE_SIP + \".3.2\" ) ; public static final Status REDIRECTION_MOVED_TEMPORARILY = new Status ( 302 , \"Moved Temporarily\" , \"Please retry the request at the new given address \" , BASE_SIP + \".3.3\" ) ; public static final Status REDIRECTION_USE_PROXY = new Status ( 305 , \"Use Proxy\" , \"The requested resource MUST be accessed through the proxy\" , BASE_SIP + \".3.4\" ) ; public static final Status REDIRECTION_ALTERNATIVE_SERVICE = new Status ( 380 , \"Alternative Service\" , \"The call was not successful, but alternative services are possible\" , BASE_SIP + \".3.5\" ) ; public static final Status CLIENT_ERROR_BAD_REQUEST = new Status ( 400 , \"Bad Request\" , \"The request could not be understood due to malformed syntax\" , BASE_SIP + \".4.1\" ) ; public static final Status CLIENT_ERROR_UNAUTHORIZED = new Status ( 401 , \"Unauthorized\" , \"The request requires user authentication\" , BASE_SIP + \".4.2\" ) ; public static final Status CLIENT_ERROR_PAYMENT_REQUIRED = new Status ( 402 , \"Payment Required\" , \"Reserved for future use\" , BASE_SIP + \".4.3\" ) ; public static final Status CLIENT_ERROR_FORBIDDEN = new Status ( 403 , \"Forbidden\" , \"The server understood the request, but is refusing to fulfill it\" , BASE_SIP + \".4.4\" ) ; public static final Status CLIENT_ERROR_NOT_FOUND = new Status ( 404 , \"Not Found\" , \"\" , BASE_SIP + \".4.5\" ) ; public static final Status CLIENT_ERROR_METHOD_NOT_ALLOWED = new Status ( 405 , \"Method Not Allowed\" , \"The method is understood, but not allowed for the given request URI\" , BASE_SIP + \".4.6\" ) ; public static final Status CLIENT_ERROR_NOT_ACCEPTABLE = new Status ( 406 , \"Not Acceptable\" , \"The resource is not", "gt": "capable of generating acceptable entities\" , BASE_SIP + \".4.7\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2151, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . LivingEntity ; public interface LizaLivingEntity extends LivingEntity { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent", "gt": ", int maxDistance ) ;", "prediction": ")\n", "label": 0}
{"id": 5538, "input": "<s> package com . abhyrama . smushit ; public class Utils { private static final String IMAGE_NAME_JUNK_CHARACTER = \".*?%2F\" ; private static final String IMAGE_URL_JUNK_CHARACTER = \".*?%2Fsmush%2F\" ; protected static String getExtension ( String fileName ) { String ext = fileName . substring ( fileName . lastIndexOf ( \".\" ) + 1 , fileName . length ( ) ) ; return ext . toLowerCase ( ) ; } protected static String getImageNameFromUrl ( String url ) { return url . substring ( url . lastIndexOf ( \"/\" ) + 1 , url . length ( ) ) ; }", "gt": "protected static String replaceJunkCharacterInImageNames ( String image )", "prediction": "}\n", "label": 1}
{"id": 5079, "input": "<s> package org . ofbiz . entity . util ; import java . io . IOException ; import java . io . InputStream ; import java . io . Serializable ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . URL ; import java . util . InvalidPropertiesFormatException ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Set ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . ResourceBundleMapWrapper ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; @ SuppressWarnings ( \"serial\" ) public class EntityUtilProperties implements Serializable { public final static String module = EntityUtilProperties . class . getName ( ) ; protected static String getSystemPropertyValue ( String resource , String name , Delegator delegator ) { if ( resource == null || resource . length ( ) <= 0 ) { return null ; } if ( name == null || name . length ( ) <= 0 ) return null ; resource = resource . replace ( \".properties\" , \"\" ) ; try { GenericValue systemProperty = delegator . findOne ( \"SystemProperty\" , UtilMisc . toMap ( \"systemResourceId\" , resource , \"systemPropertyId\" , name ) , false ) ; if ( UtilValidate . isNotEmpty ( systemProperty ) ) { String systemPropertyValue = systemProperty . getString ( \"systemPropertyValue\" ) ; if ( UtilValidate . isNotEmpty ( systemPropertyValue ) ) { return systemPropertyValue ; } } } catch ( Exception e ) { Debug . logWarning ( \"Could not get a sytem property for \" + name + \" : \" + e . getMessage ( ) , module ) ; } return null ; } public static boolean propertyValueEquals ( String resource , String name , String compareString ) { return UtilProperties . propertyValueEquals ( resource , name , compareString ) ; } public static boolean propertyValueEqualsIgnoreCase ( String resource , String name , String compareString , Delegator delegator ) { String value = getSystemPropertyValue ( resource , name , delegator ) ; if ( UtilValidate . isNotEmpty ( value ) ) { return value . trim ( ) . equalsIgnoreCase ( compareString ) ; } else { return UtilProperties . propertyValueEqualsIgnoreCase ( resource , name , compareString ) ; } } public static String getPropertyValue ( String resource , String name , String defaultValue , Delegator delegator ) { String value = getSystemPropertyValue ( resource , name , delegator ) ; if ( UtilValidate . isEmpty ( value ) ) { value = UtilProperties . getPropertyValue ( resource , name , defaultValue ) ; } return value ; } public static double getPropertyNumber ( String resource , String name , double defaultValue ) { return UtilProperties . getPropertyNumber ( resource , name , defaultValue ) ; } public static double getPropertyNumber ( String resource , String name ) { return UtilProperties . getPropertyNumber ( resource , name ) ; } public static Boolean getPropertyAsBoolean ( String resource , String name , boolean defaultValue ) { return UtilProperties . getPropertyAsBoolean ( resource , name , defaultValue ) ; } public static Integer getPropertyAsInteger ( String resource , String name , int defaultNumber ) { return UtilProperties . getPropertyAsInteger ( resource , name , defaultNumber ) ; } public static Long getPropertyAsLong ( String resource , String name , long defaultNumber ) { return UtilProperties . getPropertyAsLong ( resource , name , defaultNumber ) ; } public static Float getPropertyAsFloat ( String resource , String name , float defaultNumber ) { return UtilProperties . getPropertyAsFloat ( resource , name , defaultNumber ) ; } public static Double getPropertyAsDouble ( String resource , String name , double defaultNumber ) { return UtilProperties . getPropertyAsDouble ( resource , name , defaultNumber ) ; } public static BigInteger getPropertyAsBigInteger ( String resource , String name , BigInteger defaultNumber ) { return UtilProperties . getPropertyAsBigInteger ( resource , name , defaultNumber ) ; } public static BigDecimal getPropertyAsBigDecimal ( String resource , String name , BigDecimal defaultNumber ) { return UtilProperties . getPropertyAsBigDecimal ( resource , name , defaultNumber ) ; } public static String getPropertyValue ( String resource , String name , Delegator delegator ) { String value = getSystemPropertyValue ( resource , name , delegator ) ; if ( UtilValidate . isEmpty ( value ) ) { value = UtilProperties . getPropertyValue ( resource , name ) ; } return value ; } public static Properties getProperties ( String resource ) { return UtilProperties . getProperties ( resource ) ; } public static Properties getProperties ( URL url ) { return UtilProperties . getProperties ( url ) ; } public static boolean propertyValueEquals ( URL url , String name , String compareString ) { return UtilProperties . propertyValueEquals ( url , name , compareString ) ; } public static boolean propertyValueEqualsIgnoreCase ( URL url , String name , String compareString ) { return UtilProperties . propertyValueEqualsIgnoreCase ( url , name , compareString ) ; } public static String getPropertyValue ( URL url , String name , String defaultValue ) { return UtilProperties . getPropertyValue ( url , name , defaultValue ) ; } public static double getPropertyNumber ( URL url , String name , double defaultValue ) { return UtilProperties . getPropertyNumber ( url , name , defaultValue ) ; } public static double getPropertyNumber ( URL url , String name ) { return UtilProperties . getPropertyNumber ( url , name ) ; } public static String getPropertyValue ( URL url , String name ) { return UtilProperties . getPropertyValue ( url , name ) ; } public static String getSplitPropertyValue ( URL url , String name ) { return UtilProperties . getSplitPropertyValue ( url , name ) ; } public static void setPropertyValue ( String resource , String name , String value ) { UtilProperties . setPropertyValue", "gt": "( resource , name , value ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 5551, "input": "<s> package org . nuxeo . ecm . platform . picture . preview . adapter . factories ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . picture . api . adapters . PictureResourceAdapter ; import org . nuxeo . ecm . platform . preview . adapter . PreviewAdapterFactory ; import org . nuxeo . ecm . platform . preview . adapter . base . ConverterBasedHtmlPreviewAdapter ; import org . nuxeo . ecm . platform . preview . api . HtmlPreviewAdapter ; public class PicturePreviewAdapterFactory implements PreviewAdapterFactory { protected static final String ORIGINAL_JPEG_VIEW_NAME = \"OriginalJpeg\" ; protected static final String ORIGINAL_VIEW_NAME = \"Original\" ; @ Override public HtmlPreviewAdapter getAdapter ( DocumentModel doc ) { ConverterBasedHtmlPreviewAdapter adapter = new ConverterBasedHtmlPreviewAdapter ( ) ; adapter . setAdaptedDocument ( doc ) ; PictureResourceAdapter prAdapter = doc . getAdapter ( PictureResourceAdapter . class ) ; String xpath = prAdapter", "gt": ". getViewXPath ( ORIGINAL_JPEG_VIEW_NAME ) ;", "prediction": ";\n", "label": 1}
{"id": 4270, "input": "<s> package com . sun . source . tree ; import java . util . List ; import javax . tools . JavaFileObject ; import com . sun . source . tree . LineMap ; public interface CompilationUnitTree extends Tree { List < ? extends AnnotationTree > getPackageAnnotations ( ) ; ExpressionTree getPackageName ( ) ; List < ? extends ImportTree > getImports ( ) ; List < ? extends", "gt": "Tree > getTypeDecls ( ) ;", "prediction": "\n", "label": 0}
{"id": 5553, "input": "<s> package org . eclipse . core . tests . harness ; import java . io . * ; import junit . framework . TestCase ; import org . eclipse . core . runtime . * ; public class CoreTest extends TestCase { protected static int nextLocationCounter = 0 ; public static final String PI_HARNESS = \"org.eclipse.core.tests.harness\" ; public static void debug ( String message ) { String id = \"org.eclipse.core.tests.harness/debug\" ; String option = Platform . getDebugOption ( id ) ; if ( Boolean . TRUE . toString ( ) . equalsIgnoreCase ( option ) ) System . out . println ( message ) ; } public static void fail ( String message , Throwable e ) { if ( e instanceof CoreException ) { IStatus status = ( ( CoreException ) e ) . getStatus ( ) ; if ( status . getException ( ) == null ) e . printStackTrace ( ) ; write ( status , 0 ) ; } else e . printStackTrace ( ) ; fail ( message + \": \" + e ) ; } private static void indent ( OutputStream output , int indent ) { for ( int i = 0 ; i < indent ; i ++ ) try { output . write ( \"\\t\" . getBytes ( ) ) ; } catch ( IOException e ) { } } public static void log ( String pluginID , IStatus status ) { Platform . getLog ( Platform . getBundle ( pluginID ) ) . log ( status ) ; } public static void log ( String pluginID , Throwable e ) { log ( pluginID , new Status ( IStatus . ERROR , pluginID , IStatus . ERROR , \"Error\" , e ) ) ; } private static void write ( IStatus status , int indent ) { PrintStream output = System . out ; indent ( output , indent ) ; output . println ( \"Severity: \" + status . getSeverity ( ) ) ; indent ( output , indent ) ; output . println ( \"Plugin ID: \" + status . getPlugin ( ) ) ; indent ( output , indent ) ; output . println ( \"Code: \" + status . getCode ( ) ) ; indent ( output , indent ) ; output . println ( \"Message: \" + status . getMessage ( ) ) ; if ( status . getException ( ) != null ) { indent ( output , indent ) ; output . print ( \"Exception: \" ) ; status . getException ( ) . printStackTrace ( output ) ; } if ( status . isMultiStatus ( ) ) { IStatus [ ] children = status . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) write ( children [ i ] , indent + 1 ) ; } } public CoreTest ( ) { super ( ) ; } public CoreTest ( String name ) { super ( name ) ; } protected void assertClose ( InputStream stream ) { if ( stream == null ) return ; try { stream . close ( ) ; } catch ( IOException e ) { fail ( \"Failed", "gt": "close in assertClose\" , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4442, "input": "<s> import p . * ; class SubI implements Outer . I { SubI ( ) { } Outer . I getI ( ) { return this ; } } public class T { public static void main ( String argv [ ] ) { SubI sub = new SubI ( ) ; Outer . I inter = (", "gt": "Outer . I ) sub . getI ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5564, "input": "<s> package org . agoncal . book . javaee7 . chapter21 . ex08 ; import javax . xml . bind . annotation . * ; @ XmlRootElement @ XmlAccessorType ( XmlAccessType . FIELD ) public class CreditCard { @ XmlAttribute ( required = true ) private String number ; @ XmlElement ( name = \"expiry-date\" , defaultValue = \"01/10\" ) private String expiryDate ; private String type ; @ XmlElement ( name = \"control-number\" ) private Integer controlNumber ; public CreditCard ( ) { } public CreditCard ( String number , String expiryDate , Integer controlNumber , String type ) { this . number = number ; this . expiryDate = expiryDate ; this . controlNumber = controlNumber ; this . type = type ; } public String getNumber ( ) { return number ; } public void setNumber ( String number ) { this . number = number ; } public String getExpiryDate ( ) { return expiryDate ; } public void setExpiryDate ( String expiryDate ) { this . expiryDate = expiryDate ; } public Integer getControlNumber ( ) { return controlNumber ; } public void setControlNumber ( Integer controlNumber ) { this", "gt": ". controlNumber = controlNumber ;", "prediction": "\n", "label": 1}
{"id": 9818, "input": "<s> package com . nesscomputing . hbase . spill ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . util . List ; import javax . annotation . Nullable ; import com . google . common . base . Function ; import com . google . common . base . Preconditions ; import org . apache . hadoop . hbase . KeyValue ; import org . apache . hadoop . hbase . client . Put ; import com . nesscomputing . logging . Log ; import edu . umd . cs . findbugs . annotations . SuppressFBWarnings ; final class BinaryConverter { private static final Log LOG = Log . findLog ( ) ; public static final Function < Put , byte [ ] > PUT_WRITE_FUNCTION = new PutToBinary ( ) ; public static final Function < InputStream , Put > PUT_READ_FUNCTION = new StreamToPut ( ) ; private BinaryConverter ( ) { } static void writeInt ( final OutputStream stream , final int value ) throws IOException { final byte [ ] buffer = new byte [ 4 ] ; final ByteBuffer bb = ByteBuffer . wrap ( buffer ) ; bb . putInt ( value ) ; stream . write ( buffer ) ; } static void writeLong ( final OutputStream stream , final long value ) throws IOException { final byte [ ] buffer = new byte [ 8 ] ; final ByteBuffer bb = ByteBuffer . wrap ( buffer ) ; bb . putLong ( value ) ; stream . write ( buffer ) ; } static void writeByteArray ( final OutputStream stream , final byte [ ] bytes ) throws IOException { if ( bytes == null ) { writeInt ( stream , 0 ) ; } else { writeInt ( stream , bytes . length ) ; stream . write ( bytes ) ; } } static Long readLong ( final InputStream stream ) throws IOException { final byte [ ] buffer = readBuffer ( stream , 8 ) ; if ( buffer == null ) { return null ; } final ByteBuffer bb = ByteBuffer . wrap ( buffer ) ; return bb . getLong ( ) ; } static Integer readInt ( final InputStream stream ) throws IOException { final byte [ ] buffer = readBuffer ( stream , 4 ) ; if ( buffer == null ) { return null ; } final ByteBuffer bb = ByteBuffer . wrap ( buffer ) ; return bb . getInt ( ) ; } static byte [ ] readBytes ( final InputStream stream ) throws IOException { final Integer length = readInt ( stream ) ; if ( length == null ) { return null ; } return readBuffer ( stream , length ) ; } private static byte [ ] readBuffer ( final InputStream stream , int length ) throws IOException { final byte [ ] buffer = new byte [ length ] ; if ( stream . read ( buffer , 0 , buffer . length ) != buffer . length ) { return null ; } return buffer ; } static final class PutToBinary implements Function < Put , byte [ ] > { @ Override @ SuppressFBWarnings ( \"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE\" ) public byte [ ] apply ( Put input ) { Preconditions . checkNotNull ( input , \"input must not be null!\" ) ; try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; writeByteArray ( baos , input . getRow ( ) ) ; for ( List < KeyValue > entry : input . getFamilyMap ( ) . values ( ) ) { for ( KeyValue keyValue : entry ) { writeByteArray ( baos , keyValue . getBuffer ( ) ) ; } } final byte [ ] putBytes = baos . toByteArray ( ) ; baos = new ByteArrayOutputStream ( ) ; writeInt ( baos , 2 ) ; writeByteArray ( baos , putBytes ) ; return baos . toByteArray ( ) ; } catch ( IOException ioe ) { LOG . error ( ioe , \"While writing into byte array stream!\" ) ; return new byte [ 0 ] ; } } } static final class StreamToPut implements Function < InputStream , Put > { @ Override public Put apply ( @ Nullable InputStream stream ) { if ( stream == null || ! stream . markSupported ( ) ) { return null ; } try { final Integer version = readInt ( stream ) ; if ( version == null ) { return null ; } if ( version == 1 ) { final byte [ ] key = readBytes ( stream ) ; Preconditions . checkState ( key != null , \"Could not read key from input stream!\" ) ; final Put put = new Put ( key ) ; for ( ; ; ) { stream . mark ( 4 ) ; final Integer length = readInt ( stream ) ; if ( length == null || length == 1 ) { stream . reset ( ) ; return put ; } final byte [ ] kvBytes = readBuffer ( stream , length ) ; put . add ( new KeyValue ( kvBytes ) ) ; } } else if ( version == 2 ) { final byte [ ] putBytes = readBytes ( stream ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( putBytes ) ; final byte [ ] key = readBytes ( bais ) ; Preconditions . checkState ( key != null ,", "gt": "\"Could not read key from input stream!\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5565, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec5 . website ; import org . restlet . data . LocalReference ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . example . book . restlet . ch07 . sec5 . webapi . common . MailRepresentation ; import org . restlet . ext . freemarker . TemplateRepresentation ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; public class RootServerResource extends ServerResource { @ Override protected Representation get ( ) throws ResourceException { MailRepresentation mail = new MailRepresentation ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ;", "gt": "mail . setContent ( \"Doh!\" ) ;", "prediction": "}\n", "label": 1}
{"id": 1375, "input": "<s> package javax . lang . model . util ; import java . util . List ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; public interface Types { Element asElement ( TypeMirror t ) ; boolean isSameType ( TypeMirror t1 , TypeMirror t2 ) ; boolean isSubtype ( TypeMirror t1 , TypeMirror t2 ) ; boolean isAssignable ( TypeMirror t1 , TypeMirror t2 ) ; boolean contains ( TypeMirror t1 , TypeMirror t2 ) ; boolean isSubsignature ( ExecutableType m1 , ExecutableType m2 ) ; List < ? extends TypeMirror > directSupertypes ( TypeMirror t ) ; TypeMirror erasure ( TypeMirror t ) ; TypeElement boxedClass ( PrimitiveType p ) ; PrimitiveType unboxedType ( TypeMirror t ) ; TypeMirror capture ( TypeMirror t ) ; PrimitiveType getPrimitiveType ( TypeKind kind ) ; NullType getNullType ( ) ; NoType getNoType ( TypeKind kind ) ; ArrayType getArrayType", "gt": "( TypeMirror componentType ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 5583, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; public class QueryFetchCmd extends TransactionCommand { private static final long serialVersionUID = 1L ; private int qid ; private QueryFetchCmd ( ) { super ( - 1 , - 1 , - 1 ) ; } public QueryFetchCmd ( int storeId , int cid , int tid , int qid ) { super ( storeId , cid , tid ) ;", "gt": "this . qid = qid ;", "prediction": "}\n", "label": 1}
{"id": 6871, "input": "<s> package org . ofbiz . entity . condition ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import javolution . context . ObjectFactory ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . EntityCryptoException ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericModelException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . model . ModelFieldType ; @ SuppressWarnings ( \"serial\" ) public class EntityExpr extends EntityCondition { public static final String module = EntityExpr . class . getName ( ) ; protected static final ObjectFactory < EntityExpr > entityExprFactory = new ObjectFactory < EntityExpr > ( ) { @ Override protected EntityExpr create ( ) { return new EntityExpr ( ) ; } } ; private Object lhs = null ; private EntityOperator < Object , Object , ? > operator = null ; private Object rhs = null ; protected EntityExpr ( ) { } public < L , R , LL , RR > void init ( L lhs , EntityComparisonOperator < LL , RR > operator , R rhs ) { if ( lhs == null ) { throw new IllegalArgumentException ( \"The field name/value cannot be null\" ) ; } if ( operator == null ) { throw new IllegalArgumentException ( \"The operator argument cannot be null\" ) ; } if ( rhs == null || rhs == GenericEntity . NULL_FIELD ) { if ( ! EntityOperator . NOT_EQUAL . equals ( operator ) && ! EntityOperator . EQUALS . equals ( operator ) ) { throw new IllegalArgumentException ( \"Operator must be EQUALS or NOT_EQUAL when right/rhs argument is NULL \" ) ; } } if ( EntityOperator . BETWEEN . equals ( operator ) ) { if ( ! ( rhs instanceof Collection < ? > ) || ( ( ( Collection < ? > ) rhs ) . size ( ) != 2 ) ) { throw new IllegalArgumentException ( \"BETWEEN Operator requires a Collection with 2 elements for the right/rhs argument\" ) ; } } if ( lhs instanceof String ) { this . lhs = EntityFieldValue . makeFieldValue ( ( String ) lhs ) ; } else { this . lhs = lhs ; } this . operator = UtilGenerics . cast ( operator ) ; this . rhs = rhs ; } public void init ( EntityCondition lhs , EntityJoinOperator operator , EntityCondition rhs ) { if ( lhs == null ) { throw new IllegalArgumentException ( \"The left EntityCondition argument cannot be null\" ) ; } if ( rhs == null ) { throw new IllegalArgumentException ( \"The right EntityCondition argument cannot be null\" ) ; } if ( operator == null ) { throw new IllegalArgumentException ( \"The operator argument cannot be null\" ) ; } this . lhs = lhs ; this . operator = UtilGenerics . cast ( operator ) ; this . rhs = rhs ; } public void reset ( ) { this . lhs = null ; this . operator = null ; this . rhs = null ; } public Object getLhs ( ) { return lhs ; } public < L , R , T > EntityOperator < L , R , T > getOperator ( ) { return UtilGenerics . cast ( operator ) ; } public Object getRhs ( ) { return rhs ; } @ Override public boolean isEmpty ( ) { return operator . isEmpty ( lhs , rhs ) ; } @ Override public String makeWhereString ( ModelEntity modelEntity , List < EntityConditionParam > entityConditionParams , DatasourceInfo datasourceInfo ) { this . checkRhsType ( modelEntity , null ) ; StringBuilder sql = new StringBuilder ( ) ; operator . addSqlValue ( sql , modelEntity , entityConditionParams , true , lhs , rhs , datasourceInfo ) ; return sql . toString ( ) ; } @ Override public boolean mapMatches ( Delegator delegator , Map < String , ? extends Object > map ) { return operator . mapMatches ( delegator , map , lhs , rhs ) ; } @ Override public void checkCondition ( ModelEntity modelEntity ) throws GenericModelException { if ( lhs instanceof EntityCondition ) { ( ( EntityCondition ) lhs ) . checkCondition ( modelEntity ) ; ( ( EntityCondition ) rhs ) . checkCondition ( modelEntity ) ; } } @ Override protected void addValue ( StringBuilder buffer , ModelField field , Object value , List < EntityConditionParam > params ) { if ( rhs instanceof EntityFunction . UPPER ) { if ( value instanceof String ) { value = ( ( String ) value ) . toUpperCase ( ) ; } } super . addValue ( buffer , field , value , params ) ; } @ Override public EntityCondition freeze ( ) { return operator . freeze ( lhs , rhs ) ; } @ Override public void encryptConditionFields ( ModelEntity modelEntity , Delegator delegator ) { if ( this . lhs instanceof String ) { ModelField modelField = modelEntity . getField ( ( String ) this . lhs ) ; if ( modelField != null && modelField . getEncrypt ( ) ) { if ( ! ( rhs instanceof EntityConditionValue ) ) { try { this . rhs = delegator . encryptFieldValue ( modelEntity . getEntityName ( ) , this . rhs ) ; } catch ( EntityCryptoException e ) { Debug . logWarning ( e , \"Error encrypting field [\" + modelEntity . getEntityName ( ) + \".\" + modelField . getName ( ) + \"] with value: \" + this . rhs , module ) ; } } } } } @ Override public void visit ( EntityConditionVisitor visitor ) { visitor . acceptEntityOperator ( operator , lhs , rhs ) ; } @ Override public void accept ( EntityConditionVisitor visitor ) { visitor . acceptEntityExpr ( this ) ; } public void checkRhsType ( ModelEntity modelEntity , Delegator delegator ) { if ( this . rhs == null || this . rhs == GenericEntity . NULL_FIELD || modelEntity == null ) return ; Object value = this . rhs ; if ( this . rhs instanceof EntityFunction < ? > ) { value = UtilGenerics . < EntityFunction < ? > > cast ( this . rhs ) . getOriginalValue ( ) ; } if (", "gt": "value instanceof Collection < ? > )", "prediction": ")\n", "label": 0}
{"id": 5617, "input": "<s> package org . nuxeo . ecm . automation . client ; import java . util . Map ; import org . nuxeo . ecm . automation . client . model . OperationDocumentation ; import org . nuxeo . ecm . automation . client . model . OperationInput ; public interface OperationRequest { Session getSession ( ) ; String getUrl ( ) ; OperationDocumentation getOperation ( ) ; OperationRequest setInput ( OperationInput input ) ; OperationInput getInput ( ) ; OperationRequest set ( String key , Object value ) ;", "gt": "OperationRequest setContextProperty ( String key , Object value ) ;", "prediction": "}\n", "label": 1}
{"id": 5163, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class StackMapTable_attribute extends Attribute { static class InvalidStackMap extends AttributeException { private static final long serialVersionUID = - 5659038410855089780L ; InvalidStackMap ( String msg ) { super ( msg ) ; } } StackMapTable_attribute ( ClassReader cr , int name_index , int length ) throws IOException , InvalidStackMap { super ( name_index , length ) ; number_of_entries = cr . readUnsignedShort ( ) ; entries = new stack_map_frame [ number_of_entries ] ; for ( int i = 0 ; i < number_of_entries ; i ++ ) entries [ i ] = stack_map_frame . read ( cr ) ; } public StackMapTable_attribute ( ConstantPool constant_pool , stack_map_frame [ ] entries ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . StackMapTable ) , entries ) ; } public StackMapTable_attribute ( int name_index , stack_map_frame [ ] entries ) { super ( name_index , length ( entries ) ) ; this . number_of_entries = entries . length ; this . entries = entries ; } public < R , D > R accept ( Visitor < R , D > visitor , D data ) { return visitor . visitStackMapTable ( this , data ) ; } static int length ( stack_map_frame [ ] entries ) { int n = 2 ; for ( stack_map_frame entry : entries ) n += entry . length ( ) ; return n ; } public final int number_of_entries ; public final stack_map_frame entries [ ] ; public static abstract class stack_map_frame { static stack_map_frame read ( ClassReader cr ) throws IOException , InvalidStackMap { int frame_type = cr . readUnsignedByte ( ) ; if ( frame_type <= 63 ) return new same_frame ( frame_type ) ; else if ( frame_type <= 127 ) return new same_locals_1_stack_item_frame ( frame_type , cr ) ; else if ( frame_type <= 246 ) throw new Error ( \"unknown frame_type \" + frame_type ) ; else if ( frame_type == 247 ) return new same_locals_1_stack_item_frame_extended ( frame_type , cr ) ; else if ( frame_type <= 250 ) return new chop_frame ( frame_type , cr ) ; else if ( frame_type == 251 ) return new same_frame_extended ( frame_type , cr ) ; else if ( frame_type <= 254 ) return new append_frame ( frame_type , cr ) ; else return new full_frame ( frame_type , cr ) ; } protected stack_map_frame ( int frame_type ) { this . frame_type = frame_type ; } public int length ( ) { return 1 ; } public abstract int getOffsetDelta ( ) ; public abstract < R , D > R accept ( Visitor < R , D > visitor , D data ) ; public final int frame_type ; public static interface Visitor < R , P > { R visit_same_frame ( same_frame frame , P p ) ; R visit_same_locals_1_stack_item_frame ( same_locals_1_stack_item_frame frame , P p ) ; R visit_same_locals_1_stack_item_frame_extended ( same_locals_1_stack_item_frame_extended frame , P p ) ; R visit_chop_frame ( chop_frame frame , P p ) ; R visit_same_frame_extended ( same_frame_extended frame , P p ) ; R visit_append_frame ( append_frame frame , P p ) ; R visit_full_frame ( full_frame", "gt": "frame , P p ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5634, "input": "<s> package io . beancounter . usermanager ; import com . google . inject . Inject ; import com . google . inject . name . Named ; import io . beancounter . commons . helper . jedis . JedisPoolFactory ; import redis . clients . jedis . Jedis ; import redis . clients . jedis . JedisPool ; import redis . clients . jedis . exceptions . JedisConnectionException ; import java . util . UUID ; public class JedisUserTokenManager implements UserTokenManager { private JedisPool jedisPool ; private int database ; @ Inject public JedisUserTokenManager ( JedisPoolFactory jedisPoolFactory ) { jedisPool = jedisPoolFactory . build ( ) ; } @ Override public boolean checkTokenExists ( UUID token ) throws UserManagerException { if ( token == null ) { throw new UserManagerException ( \"User token cannot be null\" ) ; } Jedis jedis = null ; boolean isConnectionIssue = false ; try { jedis = jedisPool . getResource ( ) ; jedis . select ( database ) ; return jedis . exists ( token . toString ( ) ) ; } catch ( JedisConnectionException jce ) { isConnectionIssue = true ; throw new UserManagerException ( jce . getMessage ( ) , jce ) ; } catch ( Exception ex ) { throw new UserManagerException ( ex . getMessage ( ) , ex ) ; } finally { if ( jedis != null ) { if ( isConnectionIssue ) { jedisPool . returnBrokenResource ( jedis ) ; } else { jedisPool . returnResource ( jedis ) ; } } } } @ Override public UUID createUserToken ( String username ) throws UserManagerException { if ( username == null ) { throw new UserManagerException ( \"Username for user token cannot be null\" ) ; } Jedis jedis = null ; boolean isConnectionIssue = false ; try { jedis = jedisPool . getResource ( ) ; jedis . select ( database ) ; UUID userToken = UUID . randomUUID ( ) ; jedis . set ( userToken . toString ( ) , username ) ; return userToken ; } catch ( JedisConnectionException jce ) { isConnectionIssue = true ; throw new UserManagerException ( jce . getMessage ( ) , jce ) ; } catch ( Exception ex ) { throw new UserManagerException ( ex . getMessage ( ) , ex ) ; } finally { if ( jedis != null ) { if ( isConnectionIssue ) { jedisPool . returnBrokenResource ( jedis ) ; } else { jedisPool . returnResource ( jedis ) ; } } } } @ Override public boolean deleteUserToken ( UUID token ) throws UserManagerException { if ( token == null ) { throw new UserManagerException ( \"User token cannot be null\" ) ; } Jedis jedis = null ; boolean isConnectionIssue = false ; try { jedis", "gt": "= jedisPool . getResource ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7334, "input": "<s> public class T6207386 { static class F < T > { } static class C < X extends F < F < ? super X > > > { C ( X x ) { F < ? super", "gt": "X > f = x ;", "prediction": ";\n", "label": 0}
{"id": 5647, "input": "<s> package monbulk . MethodBuilder . shared ; public class EnumDefinitions { public enum SearchFilters { GREATER , LESS , EQUAL , NOTEQUAL", "gt": ", LIKE , BEFORE , AFTER , ONTHISDAY , CONTAINS }", "prediction": ") ;\n", "label": 1}
{"id": 1466, "input": "<s> class Pos06 { static class A extends Exception { } static class B extends Exception { } void m ( ) { try { if ( true ) { throw new A ( ) ; } else { throw new B ( ) ; } } catch ( A | B ex ) { System . out .", "gt": "println ( ex ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5661, "input": "<s> package io . beancounter . profiler . hdfs ; import io . beancounter . commons . model . UserProfile ; import java . util . UUID ; public interface ProfileWriter { public void init ( ) throws ProfileWriterException ; public void write ( UUID application , UserProfile profile ) throws ProfileWriterException ; public", "gt": "void close ( ) throws ProfileWriterException ;", "prediction": "\n", "label": 1}
{"id": 660, "input": "<s> package com . dyned . woremotesiteconfig . eom ; import com . webobjects . eoaccess . * ; import com . webobjects . eocontrol . * ; import com . webobjects . foundation . * ; import java . math . * ; import java . util . * ; import org . apache . log4j . Logger ; @ SuppressWarnings ( \"all\" ) public abstract class _StoredApp extends EOGenericRecord { public static final String ENTITY_NAME = \"StoredApp\" ; public static final String INSTANCE_INTERLEAVE_KEY = \"instanceInterleave\" ; public static final String JSON_STRING_KEY = \"jsonString\" ; public static final String NAME_KEY = \"name\" ; public static final String SCHEDULE_BEGIN_HOUR_KEY = \"scheduleBeginHour\" ; public static final String SCHEDULE_END_HOUR_KEY = \"scheduleEndHour\" ; public static final String SCHEDULE_HOURLY_INTERVAL_KEY = \"scheduleHourlyInterval\" ; public static final String SCHEDULE_TYPE_KEY = \"scheduleType\" ; public static final String SCHEDULE_WEEK_DAY_KEY = \"scheduleWeekDay\" ; public static final String STORED_INSTANCE_HOSTS_KEY = \"storedInstanceHosts\" ; public static final String STORED_SITE_KEY = \"storedSite\" ; public static final String TIME_POINT_APPLICATIONS_KEY = \"timePointApplications\" ; private static Logger LOG = Logger . getLogger ( _StoredApp . class ) ; public StoredApp localInstanceIn ( EOEditingContext editingContext ) { StoredApp localInstance = ( StoredApp ) EOUtilities . localInstanceOfObject ( editingContext , this ) ; if ( localInstance == null ) { throw new IllegalStateException ( \"You attempted to localInstance \" + this + \", which has not yet committed.\" ) ; } return localInstance ; } public Integer instanceInterleave ( ) { return ( Integer ) storedValueForKey ( \"instanceInterleave\" ) ; } public void setInstanceInterleave ( Integer value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating instanceInterleave from \" + instanceInterleave ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"instanceInterleave\" ) ; } public String jsonString ( ) { return ( String ) storedValueForKey ( \"jsonString\" ) ; } public void setJsonString ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating jsonString from \" + jsonString ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"jsonString\" ) ; } public String name ( ) { return ( String ) storedValueForKey ( \"name\" ) ; } public void setName ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating name from \" + name ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"name\" ) ; } public String scheduleBeginHour ( ) { return ( String ) storedValueForKey ( \"scheduleBeginHour\" ) ; } public void setScheduleBeginHour ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating scheduleBeginHour from \" + scheduleBeginHour ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"scheduleBeginHour\" ) ; } public String scheduleEndHour ( ) { return ( String ) storedValueForKey ( \"scheduleEndHour\" ) ; } public void setScheduleEndHour ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating scheduleEndHour from \" + scheduleEndHour ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"scheduleEndHour\" ) ; } public String scheduleHourlyInterval ( ) { return ( String ) storedValueForKey ( \"scheduleHourlyInterval\" ) ; } public void setScheduleHourlyInterval ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating scheduleHourlyInterval from \" + scheduleHourlyInterval ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"scheduleHourlyInterval\" ) ; } public String scheduleType ( ) { return ( String ) storedValueForKey ( \"scheduleType\" ) ; } public void setScheduleType ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating scheduleType from \" + scheduleType ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"scheduleType\" ) ; } public String scheduleWeekDay ( ) { return ( String ) storedValueForKey ( \"scheduleWeekDay\" ) ; } public void setScheduleWeekDay ( String value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating scheduleWeekDay from \" + scheduleWeekDay ( ) + \" to \" + value ) ; } takeStoredValueForKey ( value , \"scheduleWeekDay\" ) ; } public com . dyned . woremotesiteconfig . eom . StoredSite storedSite ( ) { return ( com . dyned . woremotesiteconfig . eom . StoredSite ) storedValueForKey ( \"storedSite\" ) ; } public void setStoredSiteRelationship ( com . dyned . woremotesiteconfig . eom . StoredSite value ) { if ( _StoredApp . LOG . isDebugEnabled ( ) ) { _StoredApp . LOG . debug ( \"updating storedSite from \" + storedSite ( ) + \" to \" + value ) ; } if ( value == null ) { com . dyned . woremotesiteconfig . eom . StoredSite oldValue = storedSite ( ) ; if ( oldValue != null ) { removeObjectFromBothSidesOfRelationshipWithKey ( oldValue , \"storedSite\" ) ; } } else { addObjectToBothSidesOfRelationshipWithKey ( value , \"storedSite\" ) ; } } public NSArray < com . dyned . woremotesiteconfig . eom . StoredInstanceHost > storedInstanceHosts ( ) { return ( NSArray < com . dyned . woremotesiteconfig", "gt": ". eom . StoredInstanceHost > ) storedValueForKey ( \"storedInstanceHosts\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5671, "input": "<s> package monbulk . MethodBuilder . client . model ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map . Entry ; import com . google . gwt . core . client . GWT ; import com . google . gwt . user . client . Window ; import monbulk . MethodBuilder . shared . iMBModel ; import monbulk . shared . Architecture . IPresenter . FormPresenter ; import monbulk . shared . Form . FormBuilder ; import monbulk . shared . Model . IPojo ; import monbulk . shared . Model . pojo . pojoMetaData ; import monbulk . shared . Model . pojo . pojoMethod ; import monbulk . shared . Model . pojo . pojoMethodComplete ; import monbulk . shared . Model . pojo . pojoStepDetails ; import monbulk . shared . Model . pojo . pojoStudy ; import monbulk . shared . Model . pojo . pojoSubjectProperties ; import monbulk . shared . Services . MethodService ; import monbulk . shared . Services . ServiceRegistry ; import monbulk . shared . util . MonbulkEnums . ServiceNames ; import monbulk . shared . view . IResult ; import monbulk . shared . view . ISearchFilter ; public class MethodCompleteModel extends baseModel implements iMBModel , MethodService . MethodServiceHandler { private pojoMethodComplete CompleteModel ; private FormPresenter Presenter ; private Boolean isLoaded ; private Boolean isInUse ; private int StepCount ; private String CurrentStep ; private String FirstStep ; public MethodCompleteModel ( ) { isLoaded = false ; this . CompleteModel = new pojoMethodComplete ( ) ; super . formData = this . CompleteModel . getFormStructure ( ) ; isLoaded = false ; CurrentStep = pojoStepDetails . FormName + \"0\" ; FirstStep = pojoStepDetails . FormName + \"0\" ; StepCount = 0 ; } public String getMethodName ( ) { return this . CompleteModel . getMethodDetails ( ) . getMethodName ( ) ; } public int getStepCount ( ) { return this . CompleteModel . getStepCount ( ) ; } public MethodCompleteModel ( String ID , FormPresenter presenter ) { isLoaded = true ; this . Presenter = presenter ; this . loadData ( ID ) ; FirstStep = pojoStepDetails . FormName + \"0\" ; } public void removeStep ( String StepFormName ) { this . CompleteModel . removeStep ( StepFormName ) ; this . CurrentStep = \"\" ; this . StepCount = this . CompleteModel . getStepCount ( ) ; } public void addStep ( ) { this . CompleteModel . addStep ( ) ; this . StepCount ++ ; } public pojoStepDetails getFirstStep ( ) { if ( this . CompleteModel . getStepCount ( ) > 0 ) { this . CurrentStep = FirstStep ; return this . CompleteModel . getSteps ( ) . get ( FirstStep ) ; } else { this . addStep ( ) ; this . CurrentStep = FirstStep ; return this . CompleteModel . getSteps ( ) . get ( FirstStep ) ; } } public pojoStepDetails getStep ( String StepFormName ) { if ( this . CompleteModel . getSteps ( ) . get ( StepFormName ) != null ) { this . CurrentStep = StepFormName ; return this . CompleteModel . getSteps ( ) . get ( StepFormName ) ; } else { return null ; } } public pojoStepDetails getNextStep ( String StepFormName ) { if ( this . CompleteModel . getSteps ( ) . get ( StepFormName ) != null ) { int index = this . CompleteModel . getSteps ( ) . get ( StepFormName ) . getFormIndex ( ) ; index ++ ; String newFormName = pojoStepDetails . FormName + index ; if ( this . CompleteModel . getSteps ( ) . get ( newFormName ) == null ) { this . addStep ( ) ; this . CurrentStep = newFormName ; return this . CompleteModel . getSteps ( ) . get ( newFormName ) ; } else { return this . CompleteModel . getSteps ( ) . get ( newFormName ) ; } } else { return null ; } } public void addStep ( pojoStepDetails stepIn ) { this . CompleteModel . addStep ( stepIn , stepIn . FormName ) ; this . StepCount ++ ; } public Boolean isLoaded ( ) { return this . isLoaded ; } @ Override public ArrayList < IResult > Search ( ArrayList < ISearchFilter > searchFilters ) { return null ; } @ Override public void saveData ( ) { } @ Override public void loadData ( String ID ) { if ( ID != \"\" ) { try { MethodService tmpSvc = MethodService . get ( ) ; if ( tmpSvc != null ) { tmpSvc . getMethod ( ID , this ) ; tmpSvc . checkUsage ( ID , this ) ; } else { throw new ServiceRegistry . ServiceNotFoundException ( ServiceNames . Methods ) ; } } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( \"Couldn't find Method service\" ) ; } } else { this . CompleteModel = new pojoMethodComplete ( ) ; } } @ Override public FormBuilder getFormData ( ) { return this . formData ; } public FormBuilder getFormData ( String FormName ) { try { if ( FormName == pojoMethod . FormName ) { return this . CompleteModel . getMethodDetails ( ) . getFormStructure ( ) ; } else if ( FormName == pojoSubjectProperties . FormName ) { return this . CompleteModel . getSubjectProperties ( ) . getFormStructure ( ) ; } else if ( FormName . contains ( pojoStepDetails . FormName ) ) { pojoStepDetails returnStep = this . CompleteModel . getSteps ( ) . get ( FormName ) ; if ( returnStep != null ) { return returnStep . getFormStructure ( ) ; } else { Window . alert ( \"We could not find that Step\" ) ; return new FormBuilder ( ) ; } } else { return this . formData ; } } catch ( Exception ex ) { GWT . log ( \"Error @ MethodCompleteModel.getFormData(String)\"", "gt": "+ ex . getMessage ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8932, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . Content ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class HtmlTree extends Content { private HtmlTag htmlTag ; private Map < HtmlAttr , String > attrs = Collections . < HtmlAttr , String > emptyMap ( ) ; private List < Content > content = Collections . < Content > emptyList ( ) ; public static final Content EMPTY = new StringContent ( \"\" ) ; public HtmlTree ( HtmlTag tag ) { htmlTag = nullCheck ( tag ) ; } public HtmlTree ( HtmlTag tag , Content ... contents ) { this ( tag ) ; for ( Content content : contents ) addContent ( content ) ; } public void addAttr ( HtmlAttr attrName , String attrValue ) { if ( attrs . isEmpty ( ) ) attrs = new LinkedHashMap < HtmlAttr , String > ( ) ; attrs . put ( nullCheck ( attrName ) , nullCheck ( attrValue ) ) ; } public void addStyle ( HtmlStyle style ) { addAttr ( HtmlAttr . CLASS , style . toString ( ) ) ; } public void addContent ( Content tagContent ) { if ( tagContent == HtmlTree . EMPTY || tagContent . isValid ( ) ) { if ( content . isEmpty ( ) ) content = new ArrayList < Content > ( ) ; content . add ( tagContent ) ; } } public void addContent ( String stringContent ) { if ( ! content . isEmpty ( ) ) { Content lastContent = content . get ( content . size ( ) - 1 ) ; if ( lastContent instanceof StringContent ) lastContent . addContent ( stringContent ) ; else addContent ( new StringContent ( stringContent ) ) ; } else addContent ( new StringContent ( stringContent ) ) ; } public static HtmlTree A ( String ref , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . A , nullCheck ( body ) ) ; htmltree . addAttr ( HtmlAttr . HREF , nullCheck ( ref ) ) ; return htmltree ; } public static HtmlTree A_NAME ( String name , Content body ) { HtmlTree htmltree = HtmlTree . A_NAME ( name ) ; htmltree . addContent ( nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree A_NAME ( String name ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . A ) ; htmltree . addAttr ( HtmlAttr . NAME , nullCheck ( name ) ) ; return htmltree ; } public static HtmlTree CAPTION ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . CAPTION , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree CODE ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . CODE , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DD ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DD , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DL ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DL , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DIV ( HtmlStyle styleClass , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DIV , nullCheck ( body ) ) ; if ( styleClass != null ) htmltree . addStyle ( styleClass ) ; return htmltree ; } public static HtmlTree DIV ( Content body ) { return DIV ( null , body ) ; } public static HtmlTree DT ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DT , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree EM ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . EM , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree FRAME ( String src , String name , String title , String scrolling ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . FRAME ) ; htmltree . addAttr ( HtmlAttr . SRC , nullCheck ( src ) ) ; htmltree . addAttr ( HtmlAttr . NAME , nullCheck ( name ) ) ; htmltree . addAttr ( HtmlAttr . TITLE , nullCheck ( title ) ) ; if ( scrolling != null ) htmltree . addAttr ( HtmlAttr . SCROLLING , scrolling ) ; return htmltree ; } public static HtmlTree FRAME ( String src , String name , String title ) { return FRAME ( src , name , title , null ) ; } public static HtmlTree FRAMESET ( String cols , String rows , String title , String onload ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . FRAMESET ) ; if ( cols != null ) htmltree . addAttr ( HtmlAttr . COLS , cols ) ; if ( rows != null ) htmltree . addAttr ( HtmlAttr . ROWS , rows ) ; htmltree . addAttr ( HtmlAttr . TITLE , nullCheck ( title ) ) ; htmltree . addAttr ( HtmlAttr . ONLOAD , nullCheck ( onload ) ) ; return htmltree ; } public static HtmlTree HEADING ( HtmlTag headingTag , boolean printTitle , HtmlStyle styleClass , Content body ) { HtmlTree htmltree = new HtmlTree ( headingTag , nullCheck ( body ) ) ; if ( printTitle ) htmltree . addAttr ( HtmlAttr . TITLE , Util . stripHtml ( body . toString ( ) ) ) ; if ( styleClass != null ) htmltree . addStyle ( styleClass ) ; return htmltree ; } public static HtmlTree HEADING ( HtmlTag headingTag , HtmlStyle styleClass , Content body ) { return HEADING ( headingTag , false , styleClass , body ) ; } public static HtmlTree HEADING ( HtmlTag headingTag , boolean printTitle , Content body ) { return HEADING ( headingTag , printTitle", "gt": ", null , body ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5685, "input": "<s> package org . restlet . test . engine ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import org . restlet . engine . util . DateUtils ; import org . restlet . test . RestletTestCase ; public class ImmutableDateTestCase extends RestletTestCase { public void test ( ) { Date now = new Date ( ) ; Calendar yesterdayCal = new GregorianCalendar ( ) ; yesterdayCal . add ( Calendar . DAY_OF_MONTH , - 1 ) ; Date yesterday = yesterdayCal . getTime ( ) ; assertTrue ( now . after ( yesterday ) ) ; assertTrue ( now . after ( DateUtils . unmodifiable ( yesterday ) ) ) ; assertTrue ( DateUtils . unmodifiable ( now ) . after ( yesterday ) ) ; assertTrue ( DateUtils . unmodifiable ( now ) . after ( DateUtils . unmodifiable ( yesterday ) ) ) ; assertTrue ( yesterday . before ( now ) ) ; assertTrue ( yesterday . before ( DateUtils .", "gt": "unmodifiable ( now ) ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 930, "input": "<s> package org . ofbiz . service . engine ; import static org . ofbiz . base . util . UtilGenerics . cast ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import javax . script . ScriptContext ; import javax . script . ScriptException ; import javolution . util . FastMap ; import org . ofbiz . base . util . Assert ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ScriptUtil ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; import org . ofbiz . service . ServiceUtil ; public final class ScriptEngine extends GenericAsyncEngine { public static final String module = ScriptEngine . class . getName ( ) ; private static final Set < String > protectedKeys = createProtectedKeys ( ) ; private static Set < String > createProtectedKeys ( ) { Set < String > newSet = new HashSet < String > ( ) ; newSet . add ( \"dctx\" ) ; newSet . add ( \"dispatcher\" ) ; newSet . add ( \"delegator\" ) ; return Collections . unmodifiableSet ( newSet ) ; } public ScriptEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } @ Override public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { Assert . notNull ( \"localName\" , localName , \"modelService.location\" , modelService . location , \"context\" , context ) ; Map < String , Object > params =", "gt": "FastMap . newInstance ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5711, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . ui . tests . harness . util . EmptyPerspective ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class IPageLayoutTest extends UITestCase { public IPageLayoutTest ( String testName ) { super ( testName ) ; } public void testGetDescriptor ( ) {", "gt": "EmptyPerspective . setLastPerspective ( null ) ;", "prediction": "\n", "label": 1}
{"id": 5973, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . Map ; import org . gk . engine . client . Engine ; import org . gk . engine . client . utils . ComponentUtils ; import org . gk . ui . client . com . IC ; import org . gk . ui . client . com . form . gkComboBox ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . form . gkTimeField ; import org . gk . ui . client . com . panel . gkHtmlContainer ; import org . gk . ui . client . com . toolbar . gkButton ; import org . gk . ui . client . com . tree . dir . gkTreeDirPanelIC ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import org . gk . ui . client . com . utils . DateTimeUtils ; import org . gk . ui . client . com . utils . TreeUtils ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . store . Record . RecordUpdate ; import com . extjs . gxt . ui . client . store . Store ; import com . extjs . gxt . ui . client . store . StoreEvent ; import com . extjs . gxt . ui . client . store . TreeStore ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . ComponentManager ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . WidgetComponent ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . extjs . gxt . ui . client . widget . form . DateField ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . Grid ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanel ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . ui . Frame ; public class ValueAttribute implements IAttribute { @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof IC ) { value = ( ( IC ) com ) . getInfo ( ) ; } else if ( com instanceof gkHtmlContainer ) { gkHtmlContainer hc = ( gkHtmlContainer ) com ; value = hc . getHtml ( ) ; } else if ( com instanceof Field ) { Field field = ( Field ) com ; if ( field instanceof DateField ) { value = DateTimeUtils . getValue ( ( DateField ) field ) ; } else if ( field instanceof gkTimeField ) { value = ( ( gkTimeField ) field ) . getTimeValue ( ) ; } else { value = field . getValue ( ) ; } } else if ( com instanceof gkButton ) { gkButton field = ( gkButton ) com ; value = field . getValue ( ) ; } else if ( com instanceof LayoutContainer ) { Object obj = ( ( LayoutContainer ) com ) . getItem ( 0 ) ; if ( obj instanceof WidgetComponent && ( ( WidgetComponent ) obj ) . getWidget ( ) instanceof Frame ) { Frame frame = ( Frame ) ( ( WidgetComponent ) obj ) . getWidget ( ) ; value = frame . getUrl ( ) ; } } else { Element ele = com . getElement ( ) ; value = ele . getInnerHTML ( ) ; Component g = ComponentManager . get ( ) . get ( ele . getAttribute ( \"gid\" ) ) ; if ( g instanceof Grid ) { String [ ] param = ele . getId ( ) . split ( \"_\" ) ; if ( param . length != 2 ) { return value ; } String columnName = ( ( Grid ) g ) . getColumnModel ( ) . getColumnById ( param [ 0 ] ) . getDataIndex ( ) ; int rowIdx = Integer . parseInt ( param [ 1 ] ) ; ModelData md = ( ModelData ) ( ( Grid ) g ) . getStore ( ) . getModels ( ) . get ( rowIdx ) ; value = md . get ( columnName ) ; } } return value ; } @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof IC ) { if ( com instanceof gkXMLTreePanelIC && value instanceof Map ) { TreeUtils . updateSelectNode ( ( gkXMLTreePanelIC ) com , ( Map ) value ) ; } else if ( com instanceof gkTreeDirPanelIC && value instanceof Map ) { Map map = ( Map ) value ; assert map . containsKey ( gkTreeDirPanelIC . ID ) : \"can't found nodeId:\" + map ; String id = map . get ( gkTreeDirPanelIC . ID ) . toString ( ) ; if ( map . containsKey ( gkTreeDirPanelIC . NAME ) ) { String name = map . get ( gkTreeDirPanelIC . NAME ) . toString ( ) ; TreePanel tree = ( TreePanel ) com ; TreeStore store = tree . getStore ( ) ; ModelData md = store . findModel ( id ) ; ModelData parent = store . getParent ( md ) ; int index = store . indexOf ( md ) ; gkMap newmd = ( gkMap ) gkMap . clone ( ( Map ) md ) ; String oldPath = md . get ( gkTreeDirPanelIC . PATH ) . toString ( ) ; String oldName = md . get ( gkTreeDirPanelIC . NAME ) . toString ( ) ; int last = oldPath . lastIndexOf ( oldName ) ; String lastPath = oldPath .", "gt": "substring ( last ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5725, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import java . io . IOException ; import java . util . BitSet ; public class CachingSpanFilter extends SpanFilter { protected SpanFilter filter ; private final CachingWrapperFilter . FilterCache cache ; public CachingSpanFilter ( SpanFilter filter ) { this ( filter , CachingWrapperFilter . DeletesMode . RECACHE ) ; } public CachingSpanFilter ( SpanFilter filter , CachingWrapperFilter . DeletesMode deletesMode ) { this . filter = filter ; if ( deletesMode == CachingWrapperFilter . DeletesMode . DYNAMIC ) { throw new IllegalArgumentException ( \"DeletesMode.DYNAMIC is not supported\" ) ; } this . cache = new CachingWrapperFilter . FilterCache ( deletesMode ) { protected Object mergeDeletes ( final IndexReader r , final Object value ) { throw new IllegalStateException ( \"DeletesMode.DYNAMIC is not supported\" ) ; } } ; } public BitSet bits ( IndexReader reader ) throws IOException { SpanFilterResult result = getCachedResult ( reader ) ; return result != null ? result . getBits ( ) : null ; } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { SpanFilterResult result = getCachedResult ( reader ) ; return result != null ? result . getDocIdSet ( ) : null ; } int hitCount , missCount ; private SpanFilterResult getCachedResult ( IndexReader reader ) throws IOException { final Object coreKey = reader . getFieldCacheKey ( ) ; final Object delCoreKey = reader . hasDeletions ( ) ? reader . getDeletesCacheKey ( ) : coreKey ; SpanFilterResult result = ( SpanFilterResult ) cache . get ( reader , coreKey , delCoreKey ) ; if ( result != null ) { hitCount ++ ; return result ; } missCount ++ ; result = filter . bitSpans ( reader ) ; cache . put ( coreKey , delCoreKey , result ) ; return result ; } public SpanFilterResult bitSpans ( IndexReader reader ) throws IOException { return getCachedResult ( reader ) ; } public String toString ( ) { return \"CachingSpanFilter(\" + filter + \")\" ; } public", "gt": "boolean equals ( Object o )", "prediction": "( )\n", "label": 1}
{"id": 1522, "input": "<s> package com . example . business . jobflow ; import com . example . business . modelgen . table . model . Stock ; public class StockToDb extends DefaultDbExporterDescription {", "gt": "@ Override public Class < ? > getModelType ( )", "prediction": "return ;\n", "label": 0}
{"id": 5727, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class Mail_BinderImpl_GenBundle_default_InlineClientBundleGenerator implements org . restlet . example . book . restlet . ch09 . client . Mail_BinderImpl_GenBundle { private static Mail_BinderImpl_GenBundle_default_InlineClientBundleGenerator _instance0 = new Mail_BinderImpl_GenBundle_default_InlineClientBundleGenerator ( ) ; private static java . util . HashMap < java . lang . String , com . google . gwt . resources . client . ResourcePrototype > resourceMap ; public ResourcePrototype [ ] getResources ( ) { return new ResourcePrototype [ ] { } ; } public ResourcePrototype getResource ( String name ) { if ( GWT", "gt": ". isScript ( ) )", "prediction": ")\n", "label": 1}
{"id": 7748, "input": "<s> class T6400189b < T > { static class A { < T > T m ( T6400189b < T > x ) { return null ; } } static class B < T > extends A { < T > T m ( T6400189b < T > x ) { return null ; } } void test ( B b ) { Integer i = b . m ( new", "gt": "T6400189b < Integer > ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5734, "input": "<s> package org . eclipse . ui . tests . api . workbenchpart ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Layout ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . menus . WorkbenchWindowControlContribution ; public class TextWidget extends WorkbenchWindowControlContribution { public TextWidget ( ) { } protected TextWidget ( String id ) { super ( id ) ; } protected Control createControl ( Composite parent ) { Composite textHolder = new Composite ( parent , SWT . NONE ) ; textHolder . setLayout ( new Layout ( ) { protected Point computeSize ( Composite composite , int wHint , int hHint , boolean flushCache ) { Text tw = ( Text ) composite . getChildren ( ) [ 0 ] ; Point twSize = tw . computeSize ( wHint , hHint , flushCache ) ; if ( twSize . x < 200 ) twSize . x = 200 ; return twSize ; } protected void layout ( Composite composite , boolean flushCache ) { Text tw = ( Text ) composite . getChildren ( ) [ 0 ] ; Point twSize = tw . computeSize ( SWT . DEFAULT , SWT . DEFAULT , flushCache ) ; Rectangle bb = composite . getBounds ( ) ; int yOffset = ( ( bb . height - twSize . y ) / 2 ) + 1 ; if ( yOffset < 0 ) yOffset = 0 ; tw . setBounds ( 0 , yOffset , bb . width , twSize . y ) ; } } ) ; Text tw = new Text ( textHolder , SWT . BORDER ) ; tw . setText", "gt": "( \"Test Text Eric was here...XXXXXX\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2567, "input": "<s> package com . sun . tools . javac . util ; public abstract class Name implements javax . lang . model . element . Name { public final Table table ; protected Name ( Table table ) { this . table = table ; } public boolean contentEquals ( CharSequence cs ) { return toString ( ) . equals ( cs . toString ( ) ) ; } public int length ( ) { return toString ( ) . length ( ) ; } public char charAt ( int index ) { return toString ( ) . charAt ( index ) ; } public CharSequence subSequence ( int start , int end ) { return toString ( ) . subSequence ( start , end ) ; } public Name append ( Name n ) { int len = getByteLength ( ) ; byte [ ] bs = new byte [ len + n . getByteLength ( ) ] ; getBytes ( bs , 0 ) ; n . getBytes ( bs , len ) ; return table . fromUtf ( bs , 0 , bs . length ) ; } public Name append ( char c , Name n ) { int len = getByteLength ( ) ; byte [ ] bs = new byte [ len + 1 + n . getByteLength ( ) ] ; getBytes ( bs , 0 ) ; bs [ len ] = ( byte ) c ; n . getBytes ( bs , len + 1 ) ; return table . fromUtf ( bs , 0 , bs . length ) ; } public int compareTo ( Name other ) { return other . getIndex ( ) - this . getIndex ( ) ; } public boolean isEmpty ( ) { return getByteLength ( ) == 0 ; } public int lastIndexOf ( byte b ) { byte [ ] bytes = getByteArray ( ) ; int offset = getByteOffset ( ) ; int i = getByteLength ( ) - 1 ; while ( i >= 0 && bytes [ offset + i ] != b ) i -- ; return i ; } public boolean startsWith ( Name prefix ) { byte [ ] thisBytes = this . getByteArray ( ) ; int thisOffset = this . getByteOffset ( ) ; int thisLength = this . getByteLength ( ) ; byte [ ] prefixBytes = prefix . getByteArray ( ) ; int prefixOffset = prefix . getByteOffset ( ) ; int prefixLength = prefix . getByteLength ( ) ; int i = 0 ; while ( i < prefixLength && i < thisLength && thisBytes [ thisOffset + i ] == prefixBytes [ prefixOffset + i ] ) i ++ ; return i == prefixLength ; } public Name subName ( int start , int end ) { if ( end < start ) end = start ; return table . fromUtf ( getByteArray ( ) , getByteOffset ( ) + start , end - start ) ; } public String toString ( ) { return Convert . utf2string ( getByteArray ( ) , getByteOffset ( ) , getByteLength ( ) ) ; } public byte [ ] toUtf ( ) { byte [ ] bs = new byte [ getByteLength ( ) ] ; getBytes ( bs , 0 ) ; return bs ; } public abstract int getIndex ( ) ; public abstract int getByteLength ( ) ; public abstract byte getByteAt ( int i ) ; public void getBytes ( byte cs [ ] , int start ) { System . arraycopy ( getByteArray ( ) , getByteOffset ( ) , cs , start , getByteLength ( ) ) ; } public abstract byte [ ] getByteArray ( ) ; public abstract int getByteOffset ( ) ; public static abstract class Table { public final Names names ; Table ( Names names ) { this . names = names ; } public abstract Name fromChars ( char [ ] cs , int start , int len ) ; public Name fromString ( String s ) { char [ ] cs = s . toCharArray ( ) ; return fromChars ( cs , 0 , cs . length ) ; } public Name fromUtf ( byte [ ] cs ) { return fromUtf ( cs , 0 , cs . length ) ; } public abstract Name fromUtf ( byte [ ] cs , int start , int len ) ; public abstract void dispose ( ) ; protected static int hashValue ( byte bytes [ ] , int offset , int length ) { int h = 0 ; int off = offset ;", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 0}
{"id": 5758, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . xmlparser . ParserException ; import org . apache . lucene . xmlparser . QueryBuilder ; import org . w3c . dom . Element ; public class MatchAllDocsQueryBuilder implements QueryBuilder { public Query getQuery (", "gt": "Element e ) throws ParserException", "prediction": ")\n", "label": 1}
{"id": 1152, "input": "<s> package org . gk . engine . client . event . attrib ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . TabItem ; public class NameAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof TabItem ) { ( ( TabItem ) com )", "gt": ". setText ( value + \"\" ) ;", "prediction": ";\n", "label": 0}
{"id": 5771, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; public class L1FSGaussianLens extends FSGaussianLens { public L1FSGaussianLens ( ) { super ( ) ; } public L1FSGaussianLens ( float mm ) { super ( mm ) ; } public L1FSGaussianLens ( float mm , int outerRadius , int innerRadius ) { super ( mm , outerRadius , innerRadius ) ; } public L1FSGaussianLens ( float mm , int outerRadius , int innerRadius , int x , int y ) { super ( mm , outerRadius , innerRadius , x , y ) ; } public void gf ( float x , float y , float [ ] g ) { d = Math . abs ( x - sw - lx ) + Math . abs ( y - sh - ly ) ; if ( d <= LR2 ) { g [ 0 ] = g [ 1 ] = MM ; } else if ( d <= LR1 ) { g [ 0 ] = g [ 1 ] = ( float ) ( c * Math . cos ( a * d + b ) + e ) ; } else { g [ 0 ] = g [ 1 ] = 1 ; } } public void drawBoundary ( Graphics2D g2d ) { if ( r1Color != null ) { g2d . setColor ( r1Color ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 - LR1 , lx + w / 2 + LR1 , ly + h / 2 ) ; g2d . drawLine ( lx + w / 2 + LR1 , ly + h / 2 , lx + w / 2 , ly + h / 2 + LR1 ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 + LR1 , lx + w / 2 - LR1 ,", "gt": "ly + h / 2 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1033, "input": "<s> class ExplicitParamsDoNotConformToBounds { void m ( int i1 ) { } void m ( int", "gt": "i1 , int i2 )", "prediction": ") ;\n", "label": 0}
{"id": 5794, "input": "<s> package org . eclipse . swt . internal . image ; import java . io . * ; import org . eclipse . swt . * ; import org . eclipse . swt . graphics . * ; @ SuppressWarnings ( \"all\" ) public class JPEGDecoder { static final int DCTSIZE = 8 ; static final int DCTSIZE2 = 64 ; static final int NUM_QUANT_TBLS = 4 ; static final int NUM_HUFF_TBLS = 4 ; static final int NUM_ARITH_TBLS = 16 ; static final int MAX_COMPS_IN_SCAN = 4 ; static final int MAX_COMPONENTS = 10 ; static final int MAX_SAMP_FACTOR = 4 ; static final int D_MAX_BLOCKS_IN_MCU = 10 ; static final int HUFF_LOOKAHEAD = 8 ; static final int MAX_Q_COMPS = 4 ; static final int IFAST_SCALE_BITS = 2 ; static final int MAXJSAMPLE = 255 ; static final int CENTERJSAMPLE = 128 ; static final int MIN_GET_BITS = 32 - 7 ; static final int INPUT_BUFFER_SIZE = 4096 ; static final int SCALEBITS = 16 ; static final int ONE_HALF = 1 << ( SCALEBITS - 1 ) ; static final int RGB_RED = 2 ; static final int RGB_GREEN = 1 ; static final int RGB_BLUE = 0 ; static final int RGB_PIXELSIZE = 3 ; static final int JBUF_PASS_THRU = 0 ; static final int JBUF_SAVE_SOURCE = 1 ; static final int JBUF_CRANK_DEST = 2 ; static final int JBUF_SAVE_AND_PASS = 3 ; static final int JPEG_MAX_DIMENSION = 65500 ; static final int BITS_IN_JSAMPLE = 8 ; static final int JDITHER_NONE = 0 ; static final int JDITHER_ORDERED = 1 ; static final int JDITHER_FS = 2 ; static final int JDCT_ISLOW = 0 ; static final int JDCT_IFAST = 1 ; static final int JDCT_FLOAT = 2 ; static final int JDCT_DEFAULT = JDCT_ISLOW ; static final int JCS_UNKNOWN = 0 ; static final int JCS_GRAYSCALE = 1 ; static final int JCS_RGB = 2 ; static final int JCS_YCbCr = 3 ; static final int JCS_CMYK = 4 ; static final int JCS_YCCK = 5 ; static final int SAVED_COEFS = 6 ; static final int Q01_POS = 1 ; static final int Q10_POS = 8 ; static final int Q20_POS = 16 ; static final int Q11_POS = 9 ; static final int Q02_POS = 2 ; static final int CTX_PREPARE_FOR_IMCU = 0 ; static final int CTX_PROCESS_IMCU = 1 ; static final int CTX_POSTPONED_ROW = 2 ; static final int APP0_DATA_LEN = 14 ; static final int APP14_DATA_LEN = 12 ; static final int APPN_DATA_LEN = 14 ; static final int M_SOF0 = 0xc0 ; static final int M_SOF1 = 0xc1 ; static final int M_SOF2 = 0xc2 ; static final int M_SOF3 = 0xc3 ; static final int M_SOF5 = 0xc5 ; static final int M_SOF6 = 0xc6 ; static final int M_SOF7 = 0xc7 ; static final int M_JPG = 0xc8 ; static final int M_SOF9 = 0xc9 ; static final int M_SOF10 = 0xca ; static final int M_SOF11 = 0xcb ; static final int M_SOF13 = 0xcd ; static final int M_SOF14 = 0xce ; static final int M_SOF15 = 0xcf ; static final int M_DHT = 0xc4 ; static final int M_DAC = 0xcc ; static final int M_RST0 = 0xd0 ; static final int M_RST1 = 0xd1 ; static final int M_RST2 = 0xd2 ; static final int M_RST3 = 0xd3 ; static final int M_RST4 = 0xd4 ; static final int M_RST5 = 0xd5 ; static final int M_RST6 = 0xd6 ; static final int M_RST7 = 0xd7 ; static final int M_SOI = 0xd8 ; static final int M_EOI = 0xd9 ; static final int M_SOS = 0xda ; static final int M_DQT = 0xdb ; static final int M_DNL = 0xdc ; static final int M_DRI = 0xdd ; static final int M_DHP = 0xde ; static final int M_EXP = 0xdf ; static final int M_APP0 = 0xe0 ; static final int M_APP1 = 0xe1 ; static final int M_APP2 = 0xe2 ; static final int M_APP3 = 0xe3 ; static final int M_APP4 = 0xe4 ; static final int M_APP5 = 0xe5 ; static final int M_APP6 = 0xe6 ; static final int M_APP7 = 0xe7 ; static final int M_APP8 = 0xe8 ; static final int M_APP9 = 0xe9 ; static final int M_APP10 = 0xea ; static final int M_APP11 = 0xeb ; static final int M_APP12 = 0xec ; static final int M_APP13 = 0xed ; static final int M_APP14 = 0xee ; static final int M_APP15 = 0xef ; static final int M_JPG0 = 0xf0 ; static final int M_JPG13 = 0xfd ; static final int M_COM = 0xfe ; static final int M_TEM = 0x01 ; static final int M_ERROR = 0x100 ; static final int CSTATE_START = 100 ; static final int CSTATE_SCANNING = 101 ; static final int CSTATE_RAW_OK = 102 ; static final int CSTATE_WRCOEFS = 103 ; static final int DSTATE_START = 200 ; static final int DSTATE_INHEADER = 201 ; static final int DSTATE_READY = 202 ; static final int DSTATE_PRELOAD = 203 ; static final int DSTATE_PRESCAN = 204 ; static final int DSTATE_SCANNING = 205 ; static final int DSTATE_RAW_OK = 206 ; static final int DSTATE_BUFIMAGE = 207 ; static final int DSTATE_BUFPOST = 208 ; static final int DSTATE_RDCOEFS = 209 ; static final int DSTATE_STOPPING = 210 ; static final int JPEG_REACHED_SOS = 1 ; static final int JPEG_REACHED_EOI = 2 ; static final int JPEG_ROW_COMPLETED = 3 ; static final int JPEG_SCAN_COMPLETED = 4 ; static final int JPEG_SUSPENDED = 0 ; static final int JPEG_HEADER_OK = 1 ; static final int JPEG_HEADER_TABLES_ONLY = 2 ; static final int DECOMPRESS_DATA = 0 ; static final int DECOMPRESS_SMOOTH_DATA = 1 ; static final int DECOMPRESS_ONEPASS = 2 ; static final int CONSUME_DATA = 0 ; static final int DUMMY_CONSUME_DATA = 1 ; static final int PROCESS_DATA_SIMPLE_MAIN = 0 ; static final int PROCESS_DATA_CONTEXT_MAIN = 1 ; static final int PROCESS_DATA_CRANK_POST = 2 ; static final int POST_PROCESS_1PASS = 0 ; static final int POST_PROCESS_DATA_UPSAMPLE = 1 ; static final int NULL_CONVERT = 0 ; static final int GRAYSCALE_CONVERT = 1 ; static final int YCC_RGB_CONVERT = 2 ; static final int GRAY_RGB_CONVERT = 3 ; static final int YCCK_CMYK_CONVERT = 4 ; static final int NOOP_UPSAMPLE = 0 ; static final int FULLSIZE_UPSAMPLE = 1 ; static final int H2V1_FANCY_UPSAMPLE = 2 ; static final int H2V1_UPSAMPLE = 3 ; static final int H2V2_FANCY_UPSAMPLE = 4 ; static final int H2V2_UPSAMPLE = 5 ; static", "gt": "final int INT_UPSAMPLE = 6 ;", "prediction": "____________________________________________________________________________________________________\n", "label": 1}
{"id": 7259, "input": "<s> package com . vexsoftware . votifier . model . listeners ; import java . util . logging . Logger ; import com . vexsoftware . votifier . model . Vote ; import com . vexsoftware . votifier . model . VoteListener ; public class BasicVoteListener implements VoteListener { private Logger log = Logger . getLogger ( \"BasicVoteListener\" ) ;", "gt": "public void voteMade ( Vote vote )", "prediction": "}\n", "label": 0}
{"id": 5796, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"listProperties\" , \"newFields\" , \"updateFields\" , \"deleteFields\" , \"listVersion\" } ) @ XmlRootElement ( name = \"UpdateList\" ) public class UpdateList { protected String listName ; protected UpdateList . ListProperties listProperties ; protected UpdateList . NewFields newFields ; protected UpdateList . UpdateFields updateFields ; protected UpdateList . DeleteFields deleteFields ; protected String listVersion ; public String getListName ( ) { return listName ; } public void setListName ( String value ) { this . listName = value ; } public UpdateList . ListProperties getListProperties ( ) { return listProperties ; } public void setListProperties ( UpdateList . ListProperties value ) { this . listProperties = value ; } public UpdateList . NewFields getNewFields ( ) { return newFields ; } public void setNewFields ( UpdateList . NewFields value ) { this . newFields = value ; } public UpdateList . UpdateFields getUpdateFields ( ) { return updateFields ; } public void setUpdateFields ( UpdateList . UpdateFields value ) { this . updateFields = value ; } public UpdateList . DeleteFields getDeleteFields ( ) { return deleteFields ; } public void setDeleteFields ( UpdateList . DeleteFields value ) { this . deleteFields = value ; } public String getListVersion ( ) { return listVersion ; } public void setListVersion ( String value ) { this . listVersion = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class DeleteFields { @ XmlMixed @ XmlAnyElement ( lax = true ) protected List < Object > content ; public List < Object > getContent ( ) { if ( content == null ) { content = new ArrayList < Object > ( ) ; } return this . content ; } } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class ListProperties { @ XmlMixed @ XmlAnyElement ( lax = true ) protected List < Object > content ; public List < Object > getContent ( ) { if ( content == null ) { content = new ArrayList < Object > ( ) ; } return this . content ; } } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class NewFields { @ XmlMixed @ XmlAnyElement ( lax", "gt": "= true ) protected List < Object > content ;", "prediction": ") ;\n", "label": 1}
{"id": 8624, "input": "<s> package org . parboiled . examples . java ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . parserunners . ReportingParseRunner ; import org . parboiled . support . ParsingResult ; import org . testng . annotations . Test ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; import static org . testng . Assert . assertEquals ; public class ReportingParseRunnerTest { @ Test public void testJavaError1 ( ) { String sourceWithErrors = \"package org.parboiled.examples;\\n\" + \"public class JavaTestSource {\\n\" + \"    @SuppressWarnings({\\\"UnnecessaryLocalVariable\\\", \\\"UnusedDeclaration\\\"})\\n\" + \"    public String method(int param) {\\n\" + \"        String name = toString(;\\n\" + \"        return name;\\n\" + \"    }\\n\" + \"}\" ; JavaParser parser = Parboiled . createParser ( JavaParser . class ) ; Rule rule = parser . CompilationUnit ( ) ; ParsingResult result = new ReportingParseRunner ( rule ) . run ( sourceWithErrors ) ; assertEquals ( result . parseErrors . size ( ) , 1 ) ; assertEquals ( printParseErrors ( result ) , \"\" + \"Invalid input ';', expected Spacing, Expression or ')' (line 5, pos 32):\\n\" + \"        String name = toString(;\\n\" + \"                               ^\\n\" ) ; } @ Test public void testJavaError2 ( ) { String sourceWithErrors = \"package org.parboiled.examples;\\n\" + \"public class JavaTestSource {\\n\" + \"    @SuppressWarnings({\\\"UnnecessaryLocalVariable\\\", \\\"UnusedDeclaration\\\"})\\n\" + \"    public String method(int param) {\\n\" + \"        String name  toString();\\n\" + \"        return name;\\n\" + \"    }\\n\" + \"}\" ; JavaParser", "gt": "parser = Parboiled . createParser ( JavaParser . class ) ;", "prediction": ";\n", "label": 0}
{"id": 5803, "input": "<s> package org . agoncal . book . javaee7 . chapter22 . ex04 ; import javax . ws . rs . DELETE ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import java . util . List ; @ Path ( \"/04/items\" ) public class ItemRestService04 { @ GET public List < Item04 > getListOfItems ( ) { System . out . println ( \"getListOfItems\" ) ; return null ; } @ GET @ Path ( \"{itemid}\" ) public Item04 getItem ( @ PathParam ( \"itemid\" ) String itemid ) { System . out . println ( \"getItem : \" + itemid ) ; return null ; } @ DELETE @ Path ( \"{itemid}\" ) public void deleteItem ( @ PathParam ( \"itemid\" ) String itemid ) { System . out . println (", "gt": "\"deleteItem : \" + itemid ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4742, "input": "<s> class InheritedPrivateImpl { interface I { public void foo ( ) ; } static class C1 { private void foo ( ) { } } static abstract", "gt": "class C2 extends C1 implements I", "prediction": "( )\n", "label": 0}
{"id": 5805, "input": "<s> package com . talis . hbase . rdf . layout . simple ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . iterator . AbstractIterator ; public class HBaseRdfAllRowsWithFilterIterator extends AbstractIterator < Node > { ResultScanner scanner = null ; HBaseRdfSingleRowIterator rowIterator = null ; Node subject = null , predicate = null , object = null ; String columnFamily = null ; public HBaseRdfAllRowsWithFilterIterator ( ResultScanner tableScanner , Node sm , Node pm , Node om , String columnFamily ) { this . scanner = tableScanner ; this . subject = sm ; this . predicate = pm ; this . object = om ; this . columnFamily = columnFamily ; } @ Override public void close ( ) { scanner . close ( ) ; } @ Override public boolean hasNext ( ) { try { if ( rowIterator == null || ! rowIterator . hasNext ( ) ) { Result rr = scanner . next ( ) ; if ( rr == null ) { rowIterator = null ; close ( ) ; return false ; } rowIterator = new HBaseRdfSingleRowIterator ( rr , subject , predicate , object , columnFamily ) ; rr = null ; } return rowIterator . hasNext ( ) ; } catch ( Exception e ) { throw new HBaseRdfException ( \"No next element found: \" , e ) ; } } @ Override public Node _next ( ) { try { if ( rowIterator == null || ! rowIterator . hasNext ( ) ) { Result rr", "gt": "= scanner . next ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5953, "input": "<s> package org . bombusim . lime . fragments ; import java . util . ArrayList ; import java . util . Collections ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import org . bombusim . lime . activity . About ; import org . bombusim . lime . activity . AccountSettingsActivity ; import org . bombusim . lime . activity . ActiveChats ; import org . bombusim . lime . activity . ChatActivity ; import org . bombusim . lime . activity . EditContactActivity ; import org . bombusim . lime . activity . LoggerActivity ; import org . bombusim . lime . activity . PresenceActivity ; import org . bombusim . lime . activity . RosterActivity ; import org . bombusim . lime . activity . VCardActivity ; import org . bombusim . lime . activity . preferences . LimePrefs ; import org . bombusim . lime . activity . preferences . LimePrefsHC ; import org . bombusim . lime . data . Contact ; import org . bombusim . lime . data . Roster ; import org . bombusim . lime . data . RosterGroup ; import org . bombusim . lime . data . SelfContact ; import org . bombusim . lime . service . XmppService ; import org . bombusim . lime . service . XmppServiceBinding ; import org . bombusim . lime . widgets . AccountViewFactory ; import org . bombusim . lime . widgets . ContactViewFactory ; import org . bombusim . lime . widgets . GroupViewFactory ; import org . bombusim . xmpp . XmppAccount ; import org . bombusim . xmpp . handlers . IqRoster ; import org . bombusim . xmpp . stanza . XmppPresence ; import com . actionbarsherlock . app . SherlockListFragment ; import android . app . AlertDialog ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . content . IntentFilter ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . drawable . BitmapDrawable ; import android . graphics . drawable . Drawable ; import android . os . AsyncTask ; import android . os . Bundle ; import android . support . v4 . app . ListFragment ; import android . util . Log ; import android . view . ContextMenu ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup ; import android . view . ContextMenu . ContextMenuInfo ; import android . widget . BaseAdapter ; import android . widget . ListAdapter ; import android . widget . ListView ; import android . widget . Toast ; import android . widget . AdapterView . AdapterContextMenuInfo ; public class RosterFragment extends SherlockListFragment { XmppServiceBinding sb ; private Bitmap [ ] statusIcons ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; statusIcons = new Bitmap [ ] { BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_offline ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_online ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_chat ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_away ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_xa ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_dnd ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_ask ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_unknown ) , BitmapFactory . decodeResource ( getResources ( ) , R . drawable . status_invisible ) } ; ListAdapter adapter = new RosterAdapter ( getActivity ( ) , statusIcons ) ; setListAdapter ( adapter ) ; sb = new XmppServiceBinding ( getActivity ( ) ) ; Lime . getInstance ( ) . saveBinding ( sb ) ; } @ Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; registerForContextMenu ( getListView ( ) ) ; } protected void showSslStatus ( String certificateChain ) { if ( certificateChain == null ) return ; AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . sslInfo ) . setIcon ( R . drawable . ssl_yes ) . setMessage ( certificateChain ) . setPositiveButton ( R . string . close , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int id ) { dialog . cancel ( ) ; } } ) ; AlertDialog alert = builder . create ( ) ; alert . setOwnerActivity ( getActivity ( ) ) ; alert . show ( ) ; } @ Override public void onListItemClick ( ListView l , View v , int position , long id ) { Object item = getListAdapter ( ) . getItem ( position ) ; if ( item instanceof RosterGroup ) { ( ( RosterGroup ) item ) . toggleCollapsed ( ) ; refreshVisualContent ( ) ; return ; } if", "gt": "( item instanceof XmppAccount )", "prediction": "( )\n", "label": 0}
{"id": 5807, "input": "<s> package fr . inria . zvtm . animation ; public interface EndAction { void", "gt": "execute ( Object subject , Animation . Dimension dimension ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9176, "input": "<s> package org . ofbiz . common . authentication . example ; import org . ofbiz . common . authentication . api . AuthenticatorException ; import org . ofbiz . common . authentication . api . Authenticator ; import org . ofbiz . base . util . Debug ; public class TestPassAuthenticator extends TestFailAuthenticator implements Authenticator { private static final String module = TestPassAuthenticator . class . getName ( ) ; @ Override public boolean authenticate ( String username , String password , boolean isServiceAuth ) throws AuthenticatorException { Debug . logInfo ( this . getClass ( ) . getName ( ) + \" Authenticator authenticate()", "gt": "-- returning false\" , module ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5813, "input": "<s> package org . eclipse . rap . demo . presentation ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . jface . action . * ; import org . eclipse . jface . dialogs . PopupDialog ; import org . eclipse . jface . window . ApplicationWindow ; import org . eclipse . rap . demo . DemoActionBarAdvisor ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . layout . * ; import org . eclipse . swt . widgets . * ; import org . eclipse . ui . * ; import org . eclipse . ui . application . * ; public class DemoPresentationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { private static final int BANNER_HEIGTH = 88 ; private static final Color COLOR_BANNER_BG = Graphics . getColor ( 27 , 87 , 144 ) ; private static final Color COLOR_BANNER_FG = Graphics . getColor ( 255 , 255 , 255 ) ; private static final Color COLOR_SHELL_BG = Graphics . getColor ( 255 , 255 , 255 ) ; public DemoPresentationWorkbenchWindowAdvisor ( IWorkbenchWindowConfigurer configurer ) { super ( configurer ) ; } @ Override public ActionBarAdvisor createActionBarAdvisor ( IActionBarConfigurer configurer ) { return new DemoActionBarAdvisor ( configurer ) ; } @ Override public void preWindowOpen ( ) { IWorkbenchWindowConfigurer configurer = getWindowConfigurer ( ) ; configurer . setShowCoolBar ( true ) ; configurer . setShowStatusLine ( false ) ; configurer . setTitle ( \"Presentation Prototype\" ) ; configurer . setShellStyle ( SWT . NONE ) ; Rectangle bounds = Display . getDefault ( ) . getBounds ( ) ; configurer . setInitialSize ( new Point ( bounds . width , bounds . height ) ) ; } @ Override public void postWindowOpen ( ) { final IWorkbenchWindow window = getWindowConfigurer ( ) . getWindow ( ) ; Shell shell = window . getShell ( ) ; shell . setMaximized ( true ) ; } @ Override public void createWindowContents ( Shell shell ) { shell . setBackground ( COLOR_SHELL_BG ) ; shell . setLayout ( new FormLayout ( ) ) ; createBanner ( shell ) ; createPageComposite ( shell ) ; } private void createBanner ( Shell shell ) { Composite banner = new Composite ( shell , SWT . NONE ) ; banner . setBackgroundMode ( SWT . INHERIT_DEFAULT ) ; banner . setData ( RWT . CUSTOM_VARIANT , \"banner\" ) ; FormData fdBanner = new FormData ( ) ; banner . setLayoutData ( fdBanner ) ; fdBanner . top = new FormAttachment ( 0 , 0 ) ; fdBanner . left = new FormAttachment ( 0 , 50 ) ; fdBanner . height = BANNER_HEIGTH ; fdBanner . right = new FormAttachment ( 100 , - 50 ) ; banner . setLayout ( new FormLayout ( ) ) ; banner . setBackgroundImage ( Images . IMG_BANNER_BG ) ; Label label = new Label ( banner , SWT . NONE ) ; label . setText ( \"RAP Demo\" ) ; label . setForeground ( COLOR_BANNER_FG ) ; label . setFont ( Graphics . getFont ( \"Verdana\" , 38 , SWT . BOLD ) ) ; label . pack ( ) ; FormData fdLabel = new FormData ( ) ; label . setLayoutData ( fdLabel ) ; fdLabel . top = new FormAttachment ( 0 , 5 ) ; fdLabel . left = new FormAttachment ( 0 , 10 ) ; Label roundedCornerLeft = new Label ( banner , SWT . NONE ) ; roundedCornerLeft . setImage ( Images . IMG_BANNER_ROUNDED_LEFT ) ; roundedCornerLeft . pack ( ) ; FormData fdRoundedCornerLeft = new FormData ( ) ; roundedCornerLeft . setLayoutData ( fdRoundedCornerLeft ) ; fdRoundedCornerLeft . top = new FormAttachment ( 100 , - 5 ) ; fdRoundedCornerLeft . left = new FormAttachment ( 0 , 0 ) ; roundedCornerLeft . moveAbove ( banner ) ; Label roundedCornerRight = new Label ( banner , SWT . NONE ) ; roundedCornerRight . setImage ( Images . IMG_BANNER_ROUNDED_RIGHT ) ; roundedCornerRight . pack ( ) ; FormData fdRoundedCornerRight = new FormData ( ) ; roundedCornerRight . setLayoutData ( fdRoundedCornerRight ) ; fdRoundedCornerRight . top = new FormAttachment ( 100 , - 5 ) ; fdRoundedCornerRight . left = new FormAttachment ( 100", "gt": ", - 5 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9722, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface WeeklyMax extends LimitsAttribute", "prediction": "}\n", "label": 0}
{"id": 5832, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . internal . SerializableCompatibility ; final class ProbeResultStore implements SerializableCompatibility { private final Map < FontData , ProbeResult > probeResults ; static ProbeResultStore getInstance ( ) { return SingletonUtil . getSessionInstance ( ProbeResultStore . class ) ; } ProbeResultStore ( ) { probeResults = new HashMap < FontData , ProbeResult > ( ) ; } ProbeResult createProbeResult ( Probe probe , Point size ) { ProbeResult result = new ProbeResult ( probe , size ) ; probeResults . put ( probe . getFontData ( ) , result ) ; return result ; } ProbeResult getProbeResult ( FontData fontData ) { return probeResults", "gt": ". get ( fontData ) ;", "prediction": ";\n", "label": 1}
{"id": 176, "input": "<s> package play . modules . neo4j ; import java . util . LinkedHashMap ; import java . util . Map ; import org . neo4j . kernel . EmbeddedGraphDatabase ; public class Neo4jConfig { public static final String DEFAULT_CONFIG_NAME = \"neo4j\" ; private String storeDir ; private final String name ; private volatile EmbeddedGraphDatabase graphDb ; private static Object lock = new Object [ 0 ] ; public final Map < String , String > params = new LinkedHashMap < String , String > ( 0 ) ; public Neo4jConfig ( String name ) { this . name = name ; } public void initialize ( ) { synchronized ( lock ) { if ( graphDb != null ) { return ; } if ( params . size ( ) > 0 ) { graphDb = new EmbeddedGraphDatabase ( getStoreDir ( ) , params ) ; } else { graphDb = new EmbeddedGraphDatabase (", "gt": "getStoreDir ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5839, "input": "<s> package org . restlet . ext . odata . internal . edm ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; public class EntityType extends ODataType { private List < NavigationProperty > associations ; private boolean blob ; private Property blobValueEditRefProperty ; private Property blobValueRefProperty ; private List < Property > keys ; public EntityType ( String name ) { super ( name ) ; } public List < NavigationProperty > getAssociations ( ) { if ( associations == null ) { associations = new ArrayList < NavigationProperty > ( ) ; } return associations ; } @ Override public EntityType getBaseType ( ) { return ( EntityType ) super . getBaseType ( ) ; } public Property getBlobValueEditRefProperty ( ) { return blobValueEditRefProperty ; } public Property getBlobValueRefProperty ( ) { return blobValueRefProperty ; } public Set < String > getImportedJavaClasses ( ) { Set < String > result = super . getImportedJavaClasses ( ) ; for ( NavigationProperty property : getAssociations ( ) ) { if ( property . getToRole ( ) . isToMany ( ) ) { result . add ( \"java.util.List\" ) ; break ; } } return result ; } @ Override public Set < ODataType > getImportedTypes ( ) { Set < ODataType > result = super . getImportedTypes ( ) ; for ( NavigationProperty property : getAssociations ( ) ) { result . add ( property . getToRole ( ) . getType ( ) ) ; } return result ; } public List < Property > getKeys ( ) { return keys ; } public boolean isBlob ( ) { return blob ; } public void setAssociations ( List < NavigationProperty > associations ) { this . associations = associations ; } public void setBlob ( boolean blob ) { this . blob = blob ; } public void", "gt": "setBlobValueEditRefProperty ( Property blobValueEditRefProperty )", "prediction": "( ) ;\n", "label": 1}
{"id": 5223, "input": "<s> class J { < T extends Error , U extends Error > void foo ( ) { try { int i = 12 ; }", "gt": "catch ( T ex )", "prediction": "}\n", "label": 0}
{"id": 5847, "input": "<s> package br . org . archimedes . runalltests ; import org . junit . runner . RunWith ; import org . junit . runners . Suite ; import br . org . archimedes . controller . ActiveStateTest ; import br . org . archimedes . intersectors . ArcArcIntersectorTest ; import br . org . archimedes . io . svg . elements . ArcExporterTest ; import br . org . archimedes . extenders . ArcExtenderTest ; import br . org . archimedes . arc . ArcFactoryTest ; import br . org . archimedes . intersectors . ArcInfiniteLineIntersectorTest ; import br . org . archimedes . intersectors . ArcLineIntersectorTest ; import br . org . archimedes . arc . ArcTest ; import br . org . archimedes . trimmers . ArcTrimTest ; import br . org . archimedes . polyline . area . AreaPerimeterFactoryTest ; import br . org . archimedes . io . svg . elements . CircleExporterTest ; import br . org . archimedes . circle . CircleFactoryTest ; import br . org . archimedes . intersectors . CircleLineIntersectorTest ; import br . org . archimedes . intersectors . CirclePolylineIntersectorTest ; import br . org . archimedes . circle . CircleTest ; import br . org . archimedes . trimmers . CircleTrimTest ; import br . org . archimedes . parser . CommandParserTest ; import br . org . archimedes . copypaste . CopyPasteFactoryTest ; import br . org . archimedes . copytoclipboard . CopyToClipboardFactoryTest ; import br . org . archimedes . fillet . DefaultFilleterTest ; import br . org . archimedes . io . svg . elements . DimensionExporterTest ; import br . org . archimedes . dimension . test . DimensionFactoryTest ; import br . org . archimedes . io . xml . parsers . DimensionParserTest ; import br . org . archimedes . dimension . test . DimensionTest ; import br . org . archimedes . distance . DistanceFactoryTest ; import br . org . archimedes . parser . DistanceParserTest ; import br . org . archimedes . parser . DoubleDecoratorParserTest ; import br . org . archimedes . model . DrawingIntersectionTest ; import br . org . archimedes . model . DrawingTest ; import br . org . archimedes . text . edittext . tests . EditTextCommandTest ; import br . org . archimedes . text . edittext . tests . EditTextFactoryTest ; import br . org . archimedes . erase . EraseFactoryTest ; import br . org . archimedes . polyline . explode . ExplodeFactoryTest ; import br . org . archimedes . extend . ExtendCommandTest ; import br . org .", "gt": "archimedes . extend . ExtendManagerTest ;", "prediction": "eclipse . eclipse . ;\n", "label": 1}
{"id": 8742, "input": "<s> package ar . com . fdvs . dj . domain ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . util . PropertiesMap ; public class ColumnProperty extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private String property ; private String valueClassName ; private PropertiesMap fieldProperties = new PropertiesMap ( ) ; public ColumnProperty ( String property , String valueClass ) { this . setProperty ( property ) ; this . setValueClassName ( valueClass ) ; } public ColumnProperty ( String property , Class clazz ) { this . setProperty ( property ) ; this . setValueClassName ( clazz . getName ( ) ) ; } public ColumnProperty ( ) { super ( ) ; } public String getProperty ( ) { return property ; } public void setProperty ( String property ) { this . property = property ; } public String getValueClassName ( ) { return valueClassName ; } public void setValueClassName ( String valueClass ) {", "gt": "this . valueClassName = valueClass ;", "prediction": "\n", "label": 0}
{"id": 5856, "input": "<s> package org . nuxeo . ecm . platform . localconfiguration . search ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . when ; import org . junit . Test ; import org . nuxeo . ecm . webapp . localconfiguration . search . SearchLocalConfiguration ; public class TestSearchConfigurationAction { SearchConfigurationActions searchConfigurationActions = new SearchConfigurationActions ( ) ; @ Test public void testConditionToReturnAChosenAdvancedSearch ( ) { SearchLocalConfiguration configuration = null ; assertFalse ( \"The condition should be False when the SearchLocalConfiguration is null\" , searchConfigurationActions . isLocalConfigurationExistsAndSearchViewAvailable ( configuration ) ) ; configuration = mock ( SearchLocalConfiguration . class ) ; when ( configuration . getAdvancedSearchView ( ) ) . thenReturn ( null ) ; assertFalse ( \"The condition should be False when the SearchLocalConfiguration is not null and an AdvancedSearchView is null\"", "gt": ", searchConfigurationActions . isLocalConfigurationExistsAndSearchViewAvailable ( configuration ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3920, "input": "<s> package pkg ; import java . lang . annotation . * ; @", "gt": "Documented public @ interface AnnotationType", "prediction": ";\n", "label": 0}
{"id": 5857, "input": "<s> package org . seage . metaheuristic . tabusearch ; import java . util . * ; public class SolutionComparator implements Comparator < Object > { private boolean _maximizing ; public SolutionComparator ( boolean maximizing ) { _maximizing = maximizing ; } public int compare ( Object o1 , Object o2 ) { Solution s1 = ( Solution ) o1 ; Solution s2 = ( Solution ) o2 ; for ( int i = 0 ; i < s1 . getObjectiveValue ( ) . length ; i ++ ) { int result = compare ( s1 . getObjectiveValue ( ) [ i ] , s2 . getObjectiveValue ( ) [ i ] ) ; if ( result == 0 ) continue ; else return result ; } return 0 ; } private int compare ( double d1 , double d2 ) { int max = - 1 ; if ( _maximizing == false", "gt": ") max = 1 ;", "prediction": ")\n", "label": 1}
{"id": 6302, "input": "<s> import java . util . * ; public class T6365166 { static < A > void add ( List < ? super A > l , List < A > la ) {", "gt": "l . addAll ( la ) ;", "prediction": "\n", "label": 0}
{"id": 5858, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; public class StaleReaderException extends IOException { public StaleReaderException ( String message ) {", "gt": "super ( message ) ;", "prediction": "\n", "label": 1}
{"id": 6018, "input": "<s> package org . parboiled . annotations ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ;", "gt": "@ Retention ( RetentionPolicy . RUNTIME ) @ Target (", "prediction": ";\n", "label": 0}
{"id": 5875, "input": "<s> package br . org . archimedes . polyline ; import static org . junit . Assert . assertNotNull ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . helper . FactoryTester ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Vector ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class PolyLineFactoryTest extends FactoryTester { private CommandFactory factory ; private Drawing drawing ; @ Before public void setUp ( ) { factory = new PolylineFactory ( ) ; drawing = new Drawing ( \"Drawing\" ) ; br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( drawing ) ; } @ After public void tearDown ( ) { br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( null ) ; } @ Test public void testCreatePolyLine ( ) { Point point1 = new Point ( 2 , 3 ) ; Point point2 = new Point ( 3 , 7 ) ; Vector vector1 = new Vector ( point1 , point2 ) ; Vector vector2 = new Vector ( point2 , new Point ( 5 , 5 ) ) ; assertBegin ( factory , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , null ) ; assertInvalidNext ( factory , vector1 ) ; assertSafeNext ( factory , point1 , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , null ) ; assertInvalidNext ( factory , point1 ) ; assertSafeNext ( factory , vector1 , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , point1 ) ; assertSafeNext ( factory , null , true ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertSafeNext ( factory , vector1 , false ) ; assertSafeNext ( factory , vector2 , false ) ; assertSafeNext ( factory , null , true ) ; } @ Test public void testCreateClosedPolyLineWithC ( ) { Point point1 = new Point ( 2 , 3 ) ; Point point2 = new Point ( 3 , 7 ) ; Vector vector1 = new Vector ( point1 , point2 ) ; Vector vector2 = new Vector ( point2 , new Point ( 5 , 5 ) ) ; assertBegin ( factory , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , null ) ; assertInvalidNext ( factory , vector1 ) ; assertInvalidNext ( factory , \"c\" ) ; assertSafeNext ( factory , point1 , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , null ) ; assertInvalidNext ( factory , point1 ) ; assertInvalidNext ( factory , \"c\" ) ; assertSafeNext ( factory , vector1 , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , point1 ) ; assertInvalidNext ( factory , \"c\" ) ; assertSafeNext ( factory , vector1 , false ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , point1 ) ; assertSafeNext ( factory , \"c\" , true ) ; assertInvalidNext ( factory , new Object ( ) ) ; assertInvalidNext ( factory , null ) ; assertInvalidNext ( factory , point1 ) ; assertInvalidNext ( factory , vector1 ) ; assertInvalidNext ( factory , \"c\" ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertSafeNext ( factory , vector1 , false ) ; assertSafeNext ( factory , vector2 , false ) ; assertSafeNext ( factory , \"c\" , true ) ; } @ Test public void testCancelPolyLineCreation ( ) { Point point1 = new Point ( 2 , 3 ) ; Point point2 = new Point ( 3 , 7 ) ; Vector vector1 = new Vector ( point1 , point2 ) ; Vector vector2 = new Vector ( point2 , new Point ( 5 , 5 ) ) ; assertBegin ( factory , false ) ; assertCancel ( factory , false ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertCancel ( factory , false ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertSafeNext ( factory , vector1 , false ) ; assertCancel ( factory , true ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertSafeNext ( factory , vector1 , false ) ; assertSafeNext ( factory , vector2 , false ) ; assertCancel ( factory , true ) ; } @ Test public void testUndo ( ) { Point point1 = new Point ( 2 , 3 ) ; Point point2 = new Point ( 3 , 7 ) ; Vector vector1 = new Vector ( point1 , point2 ) ; Vector vector2 = new Vector ( point2 , new Point ( 5 , 5 ) ) ; assertBegin ( factory , false ) ; assertInvalidNext ( factory , \"u\" ) ; assertCancel ( factory , false ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , point1 , false ) ; assertSafeNext ( factory , \"u\" , false ) ;", "gt": "assertInvalidNext ( factory , vector1 ) ;", "prediction": "}\n", "label": 1}
{"id": 9980, "input": "<s> interface B { int f ( ) ; } abstract class", "gt": "C extends a . A implements B", "prediction": ";\n", "label": 0}
{"id": 5880, "input": "<s> package tk . blackwolf12333 . grieflog . data . block ; import org . bukkit . Bukkit ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import tk . blackwolf12333 . grieflog . PlayerSession ; import tk . blackwolf12333 . grieflog . utils . Events ; public class BlockPlaceData extends BaseBlockData { public BlockPlaceData ( Block block , String playerName , Integer gamemode ) { putBlock ( block ) ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . PLACE ; } public BlockPlaceData ( Integer blockX , Integer blockY , Integer blockZ , String blockType , byte blockData , String world , String playerName , Integer gamemode ) { this . blockX = blockX ; this . blockY = blockY ; this . blockZ = blockZ ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; this . event = Events . PLACE ; } public BlockPlaceData ( String time , Integer blockX , Integer blockY , Integer blockZ , String blockType , byte blockData , String world , String playerName , Integer gamemode ) { this . time = time ; this . blockX = blockX ; this . blockY = blockY ; this . blockZ = blockZ ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; this . event = Events . PLACE ; } @ Override public void rollback ( ) { World w = Bukkit . getWorld ( worldName ) ; Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; w . getBlockAt ( loc ) . setType ( Material . AIR ) ; } @ Override public String getMinimal ( ) { return time + \" \" + playerName + \" placed \" + blockType . toLowerCase ( ) + \".\" ; } @ Override public boolean isInWorldEditSelectionOf ( PlayerSession player ) { Location loc = new Location ( Bukkit . getWorld ( worldName ) ,", "gt": "blockX , blockY , blockZ ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2392, "input": "<s> package org . ofbiz . service . engine ; import java . util . Map ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; public class InterfaceEngine implements GenericEngine { public InterfaceEngine ( ServiceDispatcher dispatcher ) { } public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { throw new GenericServiceException ( \"Interface services cannot be invoked; try invoking an implementing service.\" ) ; } public void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { throw new GenericServiceException ( \"Interface services cannot be invoked; try invoking an implementing service.\" ) ; } public void runAsync ( String localName , ModelService modelService , Map < String , Object > context , GenericRequester requester , boolean persist ) throws GenericServiceException { throw new GenericServiceException ( \"Interface services cannot be invoked; try invoking an implementing service.\" ) ; } public void runAsync ( String localName , ModelService modelService , Map < String , Object", "gt": "> context , boolean persist ) throws GenericServiceException", "prediction": ") ;\n", "label": 0}
{"id": 5892, "input": "<s> package com . talis . hbase . rdf . iterator ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class IteratorOfIterators < T > implements Iterator < T > { private Iterator < T > currentIter = null ; private List < Iterator < T > > arr ; private Iterator < Iterator < T > > arrIter ; public IteratorOfIterators ( ) { arr = new ArrayList < Iterator < T > > ( ) ; } public void add ( Iterator < T > e ) { arr . add ( e ) ; } public void closeArr ( ) { arrIter = arr . iterator ( ) ; } @ Override public boolean hasNext ( ) { if ( currentIter != null &&", "gt": "currentIter . hasNext ( ) ) return true ;", "prediction": ")\n", "label": 1}
{"id": 5171, "input": "<s> package org . msl . simple . gmfmap . model . triggers ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { public static final String PLUGIN_ID = \"org.msl.simple.gmfmap.model.triggers\" ; private static Activator plugin ; public Activator ( ) { } public void start (", "gt": "BundleContext context ) throws Exception", "prediction": ")\n", "label": 0}
{"id": 5893, "input": "<s> package observers ; import javax . jcr . observation . Event ; import javax . jcr . observation . EventIterator ; import javax . jcr . observation . EventListener ; import play . Logger ; import play . modules . cream . annotations . JcrOnEvent ; @ JcrOnEvent ( eventTypes = Event . NODE_ADDED | Event . NODE_REMOVED | Event . PROPERTY_CHANGED , absPath = \"/\" , isDeep =", "gt": "true ) public class LoggingObserver implements EventListener", "prediction": ";\n", "label": 1}
{"id": 6585, "input": "<s> import com . sun . source . tree . * ; import com . sun . source . util . Trees ; import com . sun . tools . javac . api . * ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . tree . JCTree . * ; import java . net . URI ; import java . util . Arrays ; import javax . tools . * ; public class T6972327 { public static void main ( String [ ] args ) throws Exception { final String bootPath = System . getProperty ( \"sun.boot.class.path\" ) ; final JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; assert tool != null ; String code = \"\\n@interface Test {}\" ; JavacTaskImpl ct = ( JavacTaskImpl ) tool . getTask ( null , null , null , Arrays . asList ( \"-bootclasspath\" , bootPath , \"-Xjcov\" ) , null , Arrays . asList ( new MyFileObject ( code ) ) ) ; CompilationUnitTree cut = ct . parse ( ) . iterator ( ) . next ( ) ; ClassTree clazz = ( ClassTree ) cut . getTypeDecls ( )", "gt": ". get ( 0 ) ;", "prediction": ";\n", "label": 0}
{"id": 5898, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class ModeSense10 extends ModeSense6 { public static final int OPERATION_CODE = 0x5A ; private boolean LLBAA ; public ModeSense10 ( ) { super ( OPERATION_CODE ) ; } public ModeSense10 ( boolean dbd , boolean llbaa , int pageControl , int pageCode , int subPageCode , boolean linked , boolean normalACA , long allocationLength ) { super ( dbd , pageControl , pageCode , subPageCode , linked , normalACA , allocationLength ) ; this . LLBAA = llbaa ; } public ModeSense10 ( boolean dbd , boolean llbaa , int pageControl , int pageCode , int subPageCode , long allocationLength ) { this ( dbd , llbaa , pageControl , pageCode , subPageCode , false , false , allocationLength ) ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int tmp ; int operationCode = in . readUnsignedByte ( ) ; tmp = in . readUnsignedByte ( ) ; this . setDBD ( ( tmp & 0x08 ) != 0 ) ; tmp >>>= 4 ; this . LLBAA = ( tmp & 0x01 ) != 0 ; tmp = in . readUnsignedByte ( ) ; this . setPageCode ( tmp & 0x3F ) ; this . setPC ( tmp > > > 6 ) ; this . setSubPageCode ( in . readUnsignedByte ( ) ) ; in . readShort ( ) ; in . readByte ( ) ; setAllocationLength ( in . readUnsignedShort ( ) ) ; super . setControl ( in . readUnsignedByte ( ) ) ; if ( operationCode != OPERATION_CODE ) { throw new IOException ( \"Invalid operation code: \" + Integer . toHexString ( operationCode ) ) ; } } public byte [ ] encode ( ) { ByteArrayOutputStream cdb = new ByteArrayOutputStream ( this . size ( ) ) ; DataOutputStream out = new DataOutputStream ( cdb ) ; try { out . writeByte ( OPERATION_CODE ) ; out . writeByte ( ( ( this . LLBAA ? 0x10 : 0x00 ) | ( this . isDBD ( ) ? 0x08 :", "gt": "0x00 ) ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2961, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import java . io . * ; import com . sun . javadoc . * ; public interface FieldWriter { public Content getFieldDetailsTreeHeader ( ClassDoc classDoc , Content memberDetailsTree ) ; public Content getFieldDocTreeHeader ( FieldDoc field , Content fieldDetailsTree ) ; public Content getSignature ( FieldDoc field ) ; public void addDeprecated ( FieldDoc field , Content fieldDocTree ) ; public void addComments ( FieldDoc field , Content fieldDocTree ) ; public void addTags (", "gt": "FieldDoc field , Content fieldDocTree ) ;", "prediction": ")\n", "label": 0}
{"id": 5906, "input": "<s> package org . eclipse . ui . internal . registry ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; public interface IActionSetDescriptor { public IActionSet createActionSet ( ) throws CoreException ; public String getDescription ( ) ; public String getId ( ) ; public String getLabel ( ) ; public boolean isInitiallyVisible ( ) ; public", "gt": "void setInitiallyVisible ( boolean visible ) ;", "prediction": "\n", "label": 1}
{"id": 6161, "input": "<s> public class GetClass { public static void main ( String [ ] args ) { Class < ? extends Class < GetClass > > x = GetClass .", "gt": "class . getClass ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5913, "input": "<s> package org . eclipse . ui . tests . concurrency ; import java . lang . reflect . InvocationTargetException ; import junit . framework . TestCase ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . operation . IThreadListener ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . PlatformUI ; public class ModalContextCrashTest extends TestCase { public void testCrash ( ) throws Exception { IRunnableWithProgress operation = new CrashingRunnable ( ) ; try { PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . run ( true , false , operation ) ; fail ( \"Should have an invocation target exception\" ) ; } catch ( InvocationTargetException e ) { } } private static final class CrashingRunnable implements IRunnableWithProgress , IThreadListener { public void run ( IProgressMonitor monitor ) throws InvocationTargetException , InterruptedException { } public void threadChange ( Thread thread ) { if ( Display . findDisplay ( thread ) != null", "gt": ") throw new RuntimeException ( \"Simulated exception during threadChange\" ) ;", "prediction": ")\n", "label": 1}
{"id": 2768, "input": "<s> class Neg04 { static class A extends Exception { } static class B extends Exception { } void test ( ) throws B { try { if ( true ) { throw new A ( ) ; } else if ( false ) { throw", "gt": "new B ( ) ;", "prediction": ";\n", "label": 0}
{"id": 5915, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . AssertionFailedException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . MessageDialogWithToggle ; import org . eclipse . jface . operation . IRunnableContext ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . viewers . ArrayContentProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . window . IShellProvider ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . ISaveablePart ; import org . eclipse . ui . ISaveablePart2 ; import org . eclipse . ui . ISaveablesLifecycleListener ; import org . eclipse . ui . ISaveablesSource ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . Saveable ; import org . eclipse . ui . SaveablesLifecycleEvent ; import org . eclipse . ui . dialogs . ListSelectionDialog ; import org . eclipse . ui . internal . dialogs . EventLoopProgressMonitor ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . model . WorkbenchPartLabelProvider ; public class SaveablesList implements ISaveablesLifecycleListener { private ListenerList listeners = new ListenerList ( ) ; private Map modelMap = new HashMap ( ) ; private Map modelRefCounts = new HashMap ( ) ; private Set nonPartSources = new HashSet ( ) ; public Saveable [ ] getOpenModels ( ) { Set allDistinctModels = new HashSet ( ) ; Iterator saveables = modelMap . values ( ) . iterator ( ) ; while ( saveables . hasNext ( ) ) allDistinctModels . addAll ( ( Set ) saveables . next ( ) ) ; return ( Saveable [ ] ) allDistinctModels . toArray ( new Saveable [ allDistinctModels . size ( ) ] ) ; } private boolean addModel ( Object source , Saveable model ) { if ( model == null ) { logWarning ( \"Ignored attempt to add invalid saveable\" , source , model ) ; return false ; } boolean result = false ; Set modelsForSource = ( Set ) modelMap . get ( source ) ; if ( modelsForSource == null ) { modelsForSource = new HashSet ( ) ; modelMap . put ( source , modelsForSource ) ; } if ( modelsForSource . add ( model ) ) { result = incrementRefCount ( modelRefCounts , model ) ; } else { logWarning ( \"Ignored attempt to add saveable that was already registered\" , source , model ) ; } return result ; } private boolean incrementRefCount ( Map referenceMap , Object key ) { boolean result = false ; Integer refCount = ( Integer ) referenceMap . get ( key ) ; if ( refCount == null ) { result = true ; refCount = new Integer ( 0 ) ; } referenceMap . put ( key , new Integer ( refCount . intValue ( ) + 1 ) ) ; return result ; } private boolean decrementRefCount ( Map referenceMap , Object key ) { boolean result = false ; Integer refCount = ( Integer ) referenceMap . get ( key ) ; Assert . isTrue ( refCount != null ) ; if ( refCount . intValue ( ) == 1 ) { referenceMap . remove ( key ) ; result = true ; } else { referenceMap . put ( key , new Integer ( refCount . intValue ( ) - 1 ) ) ; } return result ; } private boolean removeModel ( Object source , Saveable model ) { boolean result = false ; Set modelsForSource = ( Set ) modelMap . get ( source ) ; if ( modelsForSource == null ) { logWarning ( \"Ignored attempt to remove a saveable when no saveables were known\" , source , model ) ; } else { if ( modelsForSource . remove ( model ) ) { result = decrementRefCount ( modelRefCounts , model ) ; if ( modelsForSource . isEmpty ( ) ) { modelMap . remove ( source ) ; } } else { logWarning ( \"Ignored attempt to remove a saveable that was not registered\" , source , model ) ; } } return result ; } private void logWarning ( String message , Object source , Saveable model ) { AssertionFailedException assertionFailedException = new AssertionFailedException ( \"unknown saveable: \" + model + \" from part: \" + source ) ; assertionFailedException . fillInStackTrace ( ) ; WorkbenchPlugin . log ( StatusUtil . newStatus ( IStatus . WARNING , message , assertionFailedException ) ) ; } public void handleLifecycleEvent ( SaveablesLifecycleEvent event ) { if ( ! ( event . getSource ( ) instanceof IWorkbenchPart ) ) { updateNonPartSource ( ( ISaveablesSource ) event . getSource ( ) ) ; return ; } Saveable", "gt": "[ ] modelArray = event . getSaveables ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7296, "input": "<s> package org . ofbiz . content . survey ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; import org . ofbiz . webapp . event . EventHandlerException ; public class SurveyEvents { public static final String module = SurveyEvents . class . getName ( ) ; public static String createSurveyResponseAndRestoreParameters ( HttpServletRequest request , HttpServletResponse response ) { ConfigXMLReader . Event createSurveyResponseEvent = new ConfigXMLReader . Event ( \"service\" , null , \"createSurveyResponse\" , true ) ; RequestHandler rh = ( RequestHandler ) request . getAttribute ( \"_REQUEST_HANDLER_\" ) ;", "gt": "ConfigXMLReader . ControllerConfig controllerConfig = rh . getControllerConfig ( ) ;", "prediction": "}\n", "label": 0}
{"id": 5919, "input": "<s> package org . eclipse . ui . actions ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . ui . IActionBars ; public abstract class ActionGroup { private ActionContext context ; public ActionContext getContext ( ) { return context ; } public void setContext ( ActionContext context ) { this", "gt": ". context = context ;", "prediction": "\n", "label": 1}
{"id": 4480, "input": "<s> package api . torrents . artist ; public class Requests { private Number bounty ; private Number categoryId ; private Number requestId ; private String timeAdded ; private String title ; private Number votes ; private Number year ; public Number getBounty ( ) { return this . bounty ; } public Number getCategoryId ( ) { return this . categoryId ; } public Number getRequestId ( ) { return this . requestId ; } public String getTimeAdded ( ) { return this . timeAdded ; } public String getTitle ( ) { return this . title ; } public Number getVotes ( ) { return this . votes ; }", "gt": "public Number getYear ( )", "prediction": "}\n", "label": 0}
{"id": 5926, "input": "<s> package org . restlet . ext . openid ; import java . io . IOException ; import org . restlet . Context ; import org . restlet . data . CookieSetting ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . ext . xml . DomRepresentation ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class OpenIdFormForwarder { public static Representation handleFormRedirect ( Representation input , ClientResource resource ) throws IOException { Representation output = input ; if ( resource != null ) { for ( CookieSetting cs : resource . getCookieSettings ( ) ) { resource . getCookies ( ) . add ( cs . getName ( ) , cs . getValue ( ) ) ; } } if ( MediaType . TEXT_HTML . equals ( input . getMediaType ( ) ) && input . getSize ( ) != 0 ) { DomRepresentation htmlRep = new DomRepresentation ( input ) ; Node form = htmlRep . getNode ( \"//form\" ) ; if ( form != null ) { Node body = htmlRep . getNode ( \"//body\" ) ; NamedNodeMap nnm = body . getAttributes ( ) ; Node onload = nnm . getNamedItem ( \"onload\" ) ; String val = onload . getNodeValue ( ) ; if ( val . endsWith ( \".submit();\" ) ) { NamedNodeMap nnm2 = form . getAttributes ( ) ; String name = nnm2 . getNamedItem ( \"name\" ) . getNodeValue ( ) ; String action = nnm2 . getNamedItem ( \"action\" ) . getNodeValue ( ) ; String method = nnm2 . getNamedItem ( \"method\" ) . getNodeValue ( ) ; Context . getCurrentLogger ( ) . fine ( \"name = \" + name + \" action = \" + action + \" method = \" + method ) ; if ( name != null && name . length ( ) > 0 && action != null && action . length ( ) > 0 && method != null && method . length ( ) > 0 && \"post\" . equalsIgnoreCase ( method ) ) { Form f = new Form ( ) ; NodeList nl = form . getChildNodes ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl .", "gt": "item ( i ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 4923, "input": "<s> package com . matburt . mobileorg . Settings . Synchronizers ; import android . content . SharedPreferences ; import android . content . SharedPreferences . OnSharedPreferenceChangeListener ; import android . os . Bundle ; import android . preference . Preference ; import android . preference . PreferenceActivity ; import android . preference . PreferenceManager ; import com . matburt . mobileorg . R ; public class SDCardSettingsActivity extends PreferenceActivity implements OnSharedPreferenceChangeListener { public static final String KEY_INDEX_FILE_PATH = \"indexFilePath\" ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . sdsync_preferences ) ; setPreferenceSummary ( PreferenceManager . getDefaultSharedPreferences ( this ) , KEY_INDEX_FILE_PATH ) ; } @ Override public void onPause ( ) { getPreferenceScreen ( ) . getSharedPreferences ( ) . unregisterOnSharedPreferenceChangeListener ( this ) ; super . onPause ( ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; getPreferenceScreen ( ) . getSharedPreferences ( ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { setPreferenceSummary ( sharedPreferences , key ) ; } protected void setPreferenceSummary ( SharedPreferences sharedPreferences , String key ) { Preference pref = findPreference ( key ) ;", "gt": "if ( pref != null )", "prediction": "}\n", "label": 0}
{"id": 5936, "input": "<s> package org . nuxeo . ecm . platform . relations . services ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . GraphDescription ; import org . nuxeo . ecm . platform . relations . api . GraphFactory ; import org . nuxeo . ecm . platform . relations . api . Node ; import org . nuxeo . ecm . platform . relations . api . QueryResult ; import org . nuxeo . ecm . platform . relations . api . RelationManager ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . ResourceAdapter ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . descriptors . GraphTypeDescriptor ; import org . nuxeo . ecm . platform . relations . descriptors . ResourceAdapterDescriptor ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . model . ComponentContext ; import org . nuxeo . runtime . model . ComponentInstance ; import org . nuxeo . runtime . model . ComponentName ; import org . nuxeo . runtime . model . DefaultComponent ; import org . nuxeo . runtime . transaction . TransactionHelper ; public class RelationService extends DefaultComponent implements RelationManager { public static final ComponentName NAME = new ComponentName ( \"org.nuxeo.ecm.platform.relations.services.RelationService\" ) ; private static final long serialVersionUID = - 4778456059717447736L ; private static final Log log = LogFactory . getLog ( RelationService . class ) ; protected final Map < String , Class", "gt": "< ? > > graphTypes ;", "prediction": ";\n", "label": 1}
{"id": 6541, "input": "<s> import static p . E1 . A ; import", "gt": "static p . E2 . A ;", "prediction": "( ) ;\n", "label": 0}
{"id": 5962, "input": "<s> package com . emf4sw . rdf . util ; import org . eclipse . emf . common . notify . Adapter ; import org . eclipse . emf . common . notify . Notifier ; import org . eclipse . emf . common . notify . impl . AdapterFactoryImpl ; import org . eclipse . emf . ecore . EObject ; import com . emf4sw . rdf . BlankNode ; import com . emf4sw . rdf . Datatype ; import com . emf4sw . rdf . DocumentGraph ; import com . emf4sw . rdf . Literal ; import com . emf4sw . rdf . NamedGraph ; import com . emf4sw . rdf . Namespace ; import com . emf4sw . rdf . Node ; import com . emf4sw . rdf . Property ; import com . emf4sw . rdf . RDFAlt ; import com . emf4sw . rdf . RDFBag ; import com . emf4sw . rdf . RDFGraph ; import com . emf4sw . rdf . RDFList ; import com . emf4sw . rdf . RDFPackage ; import com . emf4sw . rdf . RDFSContainer ; import com . emf4sw . rdf . RDFSeq ; import com . emf4sw . rdf . Resource ; import com . emf4sw . rdf . SubjectNode ; import com . emf4sw . rdf . Triple ; import com . emf4sw . rdf . TripleNode ; import com . emf4sw . rdf . URIElement ; public class RDFAdapterFactory extends AdapterFactoryImpl { protected static RDFPackage modelPackage ; public RDFAdapterFactory ( ) { if ( modelPackage == null ) { modelPackage = RDFPackage . eINSTANCE ; } } @ Override public boolean isFactoryForType ( Object object ) { if ( object == modelPackage ) { return true ; } if ( object instanceof EObject ) { return ( ( EObject ) object ) . eClass ( ) . getEPackage ( ) == modelPackage ; } return false ; } protected RDFSwitch < Adapter > modelSwitch = new RDFSwitch < Adapter > ( ) { @ Override public Adapter caseURIElement ( URIElement object ) { return createURIElementAdapter ( ) ; } @ Override public Adapter caseNamespace ( Namespace object ) { return createNamespaceAdapter ( ) ; } @ Override public Adapter caseRDFGraph ( RDFGraph object ) { return createRDFGraphAdapter ( ) ; } @ Override public Adapter caseDocumentGraph ( DocumentGraph object ) { return createDocumentGraphAdapter ( ) ; } @ Override public Adapter caseTriple ( Triple object ) { return createTripleAdapter ( ) ; } @ Override public Adapter caseNode ( Node object ) { return createNodeAdapter ( ) ; } @ Override public Adapter caseSubjectNode ( SubjectNode object ) { return createSubjectNodeAdapter ( ) ; } @ Override public Adapter caseNamedGraph ( NamedGraph object ) { return createNamedGraphAdapter ( ) ; } @ Override public Adapter caseBlankNode ( BlankNode object ) { return createBlankNodeAdapter ( ) ; } @ Override public Adapter caseTripleNode ( TripleNode object ) { return createTripleNodeAdapter ( ) ; }", "gt": "@ Override public Adapter caseResource ( Resource object )", "prediction": "}\n", "label": 1}
{"id": 9248, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Face { char d [ ] [ ] = new char [ 3 ] [ 3 ] ; public void read ( String [ ] s , int c , int l ) { this . d [ l ] [ 0 ] = s [ c + 0 ] . charAt ( 0 ) ; this . d [ l ] [ 1 ] = s [ c + 1 ] . charAt ( 1 ) ; this . d [ l ] [ 2 ] = s [ c + 2 ] . charAt ( 2 ) ; } public boolean ok ( ) { for ( int i = 0 ; i != 3 ; i ++ ) for ( int j = 0 ; j != 3 ; j ++ ) if ( this . d [ i ] [ j ] != this . d [ 0 ] [ 0 ] ) return false ; return true ; } public void rotaciona ( int i ) { if ( i == 1 ) { rotDireita ( ) ; } else if ( i == - 1 ) { rotEsquerda ( ) ; } } private void rotEsquerda ( ) { } private void rotDireita ( ) { } } class Main { static int maxLg = 200 ; static int n , m , l ; static Face [ ] faces = new Face [ 7 ] ; public static void main ( String args [ ] ) throws Exception { String t [ ] ; for ( int i = 0 ; i != 7 ; i ++ ) { faces [ i ] = new Face ( ) ; } faces [ 1 ] . f ( faces [ 5 ] , faces [ 4 ] , faces [ 2 ] , faces [ 6 ] ) ; faces [ 2 ] . f ( faces [ 5 ] , faces [ 1 ] , faces [ 3 ] , faces [ 6 ] ) ; int tz = Integer . parseInt ( readLine ( ) . trim ( ) ) ; ooo : while ( tz -- != 0 ) { faces [ 5 ] . read ( split ( readLine ( ) ) , 0 , 0 ) ; faces [ 5 ] . read ( split ( readLine ( ) ) , 0 , 1 ) ; faces [ 5 ] . read ( split ( readLine ( ) ) , 0 , 2 ) ; String [ ] s1 = split ( readLine ( ) ) ; String [ ] s2 = split ( readLine ( ) ) ; String [ ] s3 = split ( readLine ( ) ) ; for ( int i = 1 ; i != 5 ; i ++ ) { faces [ i ] . read ( s1 , i * 3 , 0 ) ; faces [ i ] . read ( s2 , i * 3 , 1 ) ; faces [ i ] . read ( s3 , i * 3 , 2 ) ; } faces [ 6 ] . read ( split ( readLine ( ) ) , 0 , 0 ) ; faces [ 6 ] . read ( split ( readLine ( ) ) , 0 , 1 ) ; faces [ 6 ] . read ( split ( readLine ( ) ) , 0 , 2 ) ; t = split ( readLine ( ) ) ; for ( int i = 0 ; i != t . length ; i ++ ) { int z = Integer . parseInt ( t [ i ] ) ; if ( z == 0 ) break ; faces [ Math . abs ( z ) ] . rotaciona ( z > 0 ? 1 : - 1 ) ; } for ( int i = 1 ; i != 7 ; i ++ ) { if ( ! faces [ i ] . ok ( ) ) { System .", "gt": "out . println ( \"No, you are wrong!\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 5964, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; public class TestSpansAdvanced extends LuceneTestCase { protected Directory mDirectory ; ; protected IndexSearcher searcher ; private final static String FIELD_ID = \"ID\" ; protected final static String FIELD_TEXT = \"TEXT\" ; protected void setUp ( ) throws Exception { super . setUp ( ) ; super . setUp ( ) ; mDirectory = new RAMDirectory ( ) ; final IndexWriter writer = new IndexWriter ( mDirectory , new StandardAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; addDocument ( writer , \"1\" , \"I think it should work.\" ) ; addDocument ( writer , \"2\" , \"I think it should work.\" ) ; addDocument ( writer , \"3\" , \"I think it should work.\" ) ; addDocument ( writer , \"4\" , \"I think it should work.\" ) ; writer . close ( ) ; searcher = new IndexSearcher ( mDirectory ) ; } protected void tearDown ( ) throws Exception { super . tearDown ( ) ; searcher . close ( ) ; mDirectory . close ( ) ; mDirectory = null ; } protected void addDocument ( final IndexWriter writer , final String id , final String text ) throws IOException { final Document document = new Document ( ) ; document . add ( new Field ( FIELD_ID , id , Field . Store . YES , Field . Index . NOT_ANALYZED ) ) ; document . add ( new Field ( FIELD_TEXT , text , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( document ) ; } public void testBooleanQueryWithSpanQueries ( ) throws IOException { doTestBooleanQueryWithSpanQueries ( searcher , 0.3884282f ) ; } protected void doTestBooleanQueryWithSpanQueries ( IndexSearcher s , final float expectedScore ) throws IOException { final Query spanQuery = new SpanTermQuery ( new Term ( FIELD_TEXT , \"work\" ) ) ; final BooleanQuery query = new BooleanQuery ( ) ; query . add ( spanQuery , BooleanClause . Occur . MUST ) ; query . add ( spanQuery , BooleanClause . Occur . MUST ) ; final String [ ] expectedIds = new String [ ] { \"1\" , \"2\" , \"3\" , \"4\" } ; final float [ ] expectedScores = new float [ ] { expectedScore , expectedScore , expectedScore , expectedScore } ; assertHits ( s , query , \"two span queries\" , expectedIds , expectedScores ) ; } protected static void assertHits ( Searcher s , Query query , final String description , final String [ ] expectedIds , final float [ ] expectedScores ) throws IOException { QueryUtils . check ( query , s ) ; final float tolerance = 1e-5f ; TopDocs topdocs = s . search ( query , null , 10000 ) ; assertEquals ( expectedIds . length , topdocs . totalHits ) ; for ( int i = 0 ; i < topdocs . totalHits ; i ++ ) { int id = topdocs . scoreDocs [ i ] . doc ; float score = topdocs . scoreDocs [", "gt": "i ] . score ;", "prediction": ";\n", "label": 1}
{"id": 7085, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . ToolTip ; public class ToolTipImpl extends ColumnAttributeImpl implements ToolTip { protected LogicalExpression expression ; protected static final String TIP_EDEFAULT = null ; protected String tip = TIP_EDEFAULT ; protected ToolTipImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getToolTip ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . TOOL_TIP__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . TOOL_TIP__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . TOOL_TIP__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TOOL_TIP__EXPRESSION , newExpression , newExpression ) ) ; } public String getTip ( ) { return tip ; } public void setTip ( String newTip ) { String oldTip = tip ; tip = newTip ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET ,", "gt": "ProjectPackage . TOOL_TIP__TIP , oldTip , tip ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 5983, "input": "<s> package org . nuxeo . ecm . admin ; import static org . jboss . seam . ScopeType . CONVERSATION ; import java . io . Serializable ; import java . util . List ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . contexts . Contexts ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . actions . Action ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . platform . ui . web . api . TabActionsSelection ; import org . nuxeo . ecm . platform . ui . web . api . WebActions ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"adminViews\" ) @ Scope ( CONVERSATION ) public class AdminViewManager implements Serializable { private static final long serialVersionUID = 1L ; protected String externalPackageDownloadRequest ; public static final String ADMIN_ACTION_CATEGORY = \"NUXEO_ADMIN\" ; public static final String VIEW_ADMIN = \"view_admin\" ; @ In ( create = true , required = false ) protected WebActions webActions ; @ In ( create = true , required = false ) protected transient NavigationContext navigationContext ; protected DocumentModel lastVisitedDocument ; public String goHome ( ) { webActions . resetCurrentTabs ( ADMIN_ACTION_CATEGORY ) ; Contexts . getEventContext ( ) . remove ( \"currentView\" ) ; Contexts . getEventContext ( ) . remove ( \"currentAdminSubView\" ) ; return VIEW_ADMIN ; } public String enter ( ) { lastVisitedDocument = navigationContext . getCurrentDocument ( ) ; return VIEW_ADMIN ; } public String exit ( ) throws ClientException { if ( lastVisitedDocument != null ) { return navigationContext . navigateToDocument ( lastVisitedDocument ) ; } else { return navigationContext . goHome ( ) ; } } @ Factory ( value = \"currentAdminView\" , scope = ScopeType . EVENT ) public Action getCurrentView ( ) { return webActions . getCurrentTabAction ( ADMIN_ACTION_CATEGORY ) ; } public void setCurrentView ( Action currentView ) { webActions . setCurrentTabAction ( ADMIN_ACTION_CATEGORY , currentView ) ; } public String getCurrentViewId ( ) { return", "gt": "getCurrentView ( ) . getId ( ) ;", "prediction": "\n", "label": 1}
{"id": 5853, "input": "<s> package pkg1 ; import java . io . Serializable ; @ Deprecated public abstract class C5 implements Serializable { private String name ; private int publicKey ; protected C5 ( ) { }", "gt": "public void printInfo ( )", "prediction": "}\n", "label": 0}
{"id": 6004, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . internal . util . Util ; import org . eclipse . ui . presentations . IPresentablePart ; public final class PartInfo { public String name ; public String title ; public String contentDescription ; public String toolTip ; public Image image ; public boolean dirty ; public PartInfo ( ) { name = Util . ZERO_LENGTH_STRING ; title = Util . ZERO_LENGTH_STRING ; contentDescription = Util . ZERO_LENGTH_STRING ; toolTip = Util . ZERO_LENGTH_STRING ; image = null ; } public PartInfo ( IPresentablePart part ) { set ( part ) ; } public void set ( IPresentablePart part ) {", "gt": "name = part . getName ( ) ;", "prediction": "\n", "label": 1}
{"id": 6402, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect . mirror ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . redhat . ceylon . compiler . loader . mirror . FieldMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeMirror ; public class ReflectionField implements FieldMirror { private Field field ; private ReflectionType type ; public ReflectionField ( Field field ) { this . field = field ; } @ Override public AnnotationMirror getAnnotation ( String type ) { return ReflectionUtils . getAnnotation ( field , type ) ; } @ Override public String getName ( ) { return field . getName ( ) ; } @ Override public boolean isStatic ( ) { return Modifier . isStatic ( field . getModifiers ( ) ) ; } @ Override public boolean isPublic ( ) { return Modifier . isPublic ( field .", "gt": "getModifiers ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6005, "input": "<s> package com . design ; public class Rib extends Part { public int topNotchPos = 1 ; public int bottomNotchPos = 1 ; public Rib ( double width , double height ) { super ( width , height ) ; } public void addNotches ( double notchWidth , double notchHeight , double ribNotchOffset , double topCirclePos , double bottomCirclePos ) { Notch notch1 = new Notch ( notchWidth , notchHeight ) ; Notch notch2 = new Notch ( notchWidth , notchHeight ) ; this . setNotch ( notch1 , topCirclePos , ribNotchOffset , true ) ; this . setNotch ( notch2 , height - bottomCirclePos , ribNotchOffset , false ) ; } private void setNotch ( Notch notch , double pos , double ribNotchOffset , boolean top ) { int topEdgeNum = 1 ; int bottomEdgeNum = 1 ; for ( int i = 1 ; i < edges . size ( ) / 2 - 1 ; i ++ ) { if ( edges . get ( i ) . start . getY ( ) <= pos && edges . get ( i + 1 ) . start . getY ( ) >= pos ) { topEdgeNum = i ; } if ( edges . get ( i ) . end . getY ( ) <= pos && edges . get ( i + 1 ) . end .", "gt": "getY ( ) >= pos )", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8571, "input": "<s> package ar . com . fdvs . dj . core ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import net . sf . jasperreports . engine . fill . JRFillParameter ; public class ParameterMapWrapper implements Map { private Map map ; public ParameterMapWrapper ( Map map ) { this . map = map ; } public ParameterMapWrapper ( ) { this . map = Collections . EMPTY_MAP ; } public void clear ( ) { map . clear ( ) ; } public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; } public boolean containsValue ( Object value ) { throw new DJException ( \"Method not implemented\" ) ; } public Set entrySet ( ) { return map . entrySet ( ) ; } public boolean equals ( Object o ) { return map . equals ( o ) ; } public Object get ( Object key ) { Object value = map . get ( key ) ; if ( value == null ) return null ; return ( ( JRFillParameter ) value ) . getValue ( ) ; } public int hashCode ( ) { return map . hashCode ( ) ; } public boolean isEmpty ( ) { return map . isEmpty ( ) ; } public Set keySet ( ) {", "gt": "return map . keySet ( ) ;", "prediction": "\n", "label": 0}
{"id": 6008, "input": "<s> import org . apache . camel . builder . RouteBuilder ; import org . junit . Test ; import play . modules . camel . CamelPlugin ; import play . test . UnitTest ; public class FileRouteTest extends UnitTest { @ Test public void testFile ( ) { RouteBuilder routes = new RouteBuilder ( ) { @ Override public void", "gt": "configure ( ) throws Exception", "prediction": "( )\n", "label": 1}
{"id": 2250, "input": "<s> package good . covar ; interface A { A f ( ) ; } interface B { B f ( ) ; } class C { public D f ( ) { return null ; } } class D", "gt": "extends C implements A , B", "prediction": "\n", "label": 0}
{"id": 6012, "input": "<s> package com . google . code . microlog4android . format . command ; import android . util . Log ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . format . command . util . StringUtil ; public class CategoryFormatCommand implements FormatCommandInterface { private static final String TAG = \"Microlog.CategoryFormatCommand\" ; public static final int FULL_CLASS_NAME_SPECIFIER = - 1 ; public static final int DEFAULT_PRECISION_SPECIFIER = 1 ; private int precisionSpecifier = DEFAULT_PRECISION_SPECIFIER ; public String execute ( String clientID , String name , long time , Level level , Object message , Throwable throwable ) { String convertedData = \"\" ; if ( name != null ) { if ( precisionSpecifier == FULL_CLASS_NAME_SPECIFIER ) { convertedData = name ; } else { convertedData = StringUtil . extractPartialClassName ( name , precisionSpecifier ) ; } } return convertedData ; } public void init ( String initString ) { try { precisionSpecifier = Integer . parseInt ( initString ) ; System . out . println ( \"Precision specifier for %c is \" + precisionSpecifier ) ; } catch ( NumberFormatException e ) { Log . e ( TAG , \"Failed to parse the specifier for the %c pattern \" + e ) ; } }", "gt": "public int getPrecisionSpecifier ( )", "prediction": "}\n", "label": 1}
{"id": 4164, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposeableAdapterFactory ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ItemProviderAdapter ; import org . eclipse . emf . edit . provider . ViewerNotification ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleNodeItemProvider extends ItemProviderAdapter implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleNodeItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; addNodeFigurePropertyDescriptor ( object ) ; addLabelFigurePropertyDescriptor ( object ) ; addContainmentFeaturePropertyDescriptor ( object ) ; addToolPropertyDescriptor ( object ) ; addLabelAttributesPropertyDescriptor ( object ) ; addDiagramNodePropertyDescriptor ( object ) ; addDiagramLabelPropertyDescriptor ( object ) ; addDomainMetaElementPropertyDescriptor ( object ) ; } return itemPropertyDescriptors ; } protected void addNodeFigurePropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleMappingElementWithFigure_nodeFigure_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleMappingElementWithFigure_nodeFigure_feature\" , \"_UI_SimpleMappingElementWithFigure_type\" ) , SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__NODE_FIGURE , false , false , true , null , null , null ) ) ; } protected void addLabelFigurePropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleMappingElementWithFigure_labelFigure_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleMappingElementWithFigure_labelFigure_feature\" , \"_UI_SimpleMappingElementWithFigure_type\" ) , SimplemappingsPackage . Literals . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE__LABEL_FIGURE , false , false , true , null , null , null ) ) ; } protected void addDomainMetaElementPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNode_domainMetaElement_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNode_domainMetaElement_feature\" , \"_UI_SimpleNode_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE__DOMAIN_META_ELEMENT , true , false , true , null , null , null ) ) ; } protected void addContainmentFeaturePropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNodeReference_containmentFeature_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNodeReference_containmentFeature_feature\" , \"_UI_SimpleNodeReference_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__CONTAINMENT_FEATURE , true , false , true , null , null , null ) ) ; } protected void addToolPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNode_tool_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNode_tool_feature\" , \"_UI_SimpleNode_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE__TOOL , false , false , true , null , null , null ) ) ; } protected void addLabelAttributesPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNode_labelAttributes_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNode_labelAttributes_feature\" , \"_UI_SimpleNode_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE__LABEL_ATTRIBUTES , true , false , true , null , null , null ) ) ; } protected void addDiagramNodePropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNode_diagramNode_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNode_diagramNode_feature\" , \"_UI_SimpleNode_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE__DIAGRAM_NODE , false , false , true , null , null , null ) ) ; } protected void addDiagramLabelPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleNode_diagramLabel_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleNode_diagramLabel_feature\" , \"_UI_SimpleNode_type\" ) , SimplemappingsPackage . Literals . SIMPLE_NODE__DIAGRAM_LABEL , false , false , true , null , null , null ) ) ; } @ Override public Object getImage ( Object object ) { return overlayImage ( object , getResourceLocator ( ) . getImage ( \"full/obj16/SimpleNode\" ) ) ; } @ Override public String getText ( Object object ) { String label = ( ( SimpleNode ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( \"_UI_SimpleNode_type\" ) : label ; } @ Override public void notifyChanged ( Notification notification ) { updateChildren ( notification ) ; switch ( notification . getFeatureID ( SimpleNode . class ) ) { case SimplemappingsPackage . SIMPLE_NODE__NAME : fireNotifyChanged ( new ViewerNotification ( notification , notification . getNotifier ( ) , false , true ) ) ; return ; } super . notifyChanged ( notification ) ; } @ Override protected void collectNewChildDescriptors ( Collection < Object > newChildDescriptors , Object object ) { super . collectNewChildDescriptors ( newChildDescriptors , object ) ; } @", "gt": "Override public ResourceLocator getResourceLocator ( )", "prediction": "}\n", "label": 0}
{"id": 6029, "input": "<s> package org . eclipse . swt . internal . widgets . buttonkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . graphics . ImageFactory ; import org . eclipse . swt . internal . widgets . IShellAdapter ; import org . eclipse . swt . internal . widgets . Props ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Shell ;", "gt": "import org . eclipse . swt . widgets . Widget ;", "prediction": ";\n", "label": 1}
{"id": 5237, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Task ; import org . jjflyboy . tjpeditor . project . TaskAttribute ; public class TaskImpl extends PropertyImpl implements Task { protected static final String ID_EDEFAULT = null ; protected String id = ID_EDEFAULT ; protected static final String NAME_EDEFAULT = null ; protected String name = NAME_EDEFAULT ; protected EList < TaskAttribute > attributes ; protected TaskImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getTask ( ) ; } public String getId ( ) { return id ; } public void setId ( String newId ) { String oldId = id ; id = newId ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TASK__ID , oldId , id ) ) ; } public String getName ( ) { return name ; } public void setName ( String newName ) { String oldName = name ; name = newName ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TASK__NAME , oldName , name ) ) ; } public EList < TaskAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < TaskAttribute > ( TaskAttribute . class , this , ProjectPackage . TASK__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . TASK__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . TASK__ID : return getId ( ) ; case ProjectPackage . TASK__NAME : return getName ( ) ; case ProjectPackage . TASK__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . TASK__ID : setId ( ( String ) newValue ) ; return ; case ProjectPackage . TASK__NAME : setName ( ( String ) newValue ) ; return ; case ProjectPackage . TASK__ATTRIBUTES : getAttributes ( ) . clear ( ) ; getAttributes ( ) . addAll ( ( Collection < ? extends TaskAttribute > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . TASK__ID : setId ( ID_EDEFAULT ) ; return ; case ProjectPackage . TASK__NAME : setName ( NAME_EDEFAULT ) ; return ; case ProjectPackage . TASK__ATTRIBUTES : getAttributes ( ) . clear ( ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . TASK__ID : return ID_EDEFAULT == null ? id != null : ! ID_EDEFAULT . equals ( id ) ; case ProjectPackage . TASK__NAME : return NAME_EDEFAULT == null ? name != null : ! NAME_EDEFAULT . equals ( name ) ; case ProjectPackage . TASK__ATTRIBUTES : return attributes != null && ! attributes . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; } @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer", "gt": "( super . toString ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 6069, "input": "<s> package org . apache . lucene . analysis . de ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . standard . StandardTokenizer ; public class TestGermanStemFilter extends BaseTokenStreamTestCase { public void testStemming ( ) throws Exception { File dataDir = new File ( System . getProperty ( \"dataDir\" , \"./bin\" ) ) ; File testFile = new File ( dataDir , \"org/apache/lucene/analysis/de/data.txt\" ) ; FileInputStream fis = new FileInputStream ( testFile ) ; InputStreamReader isr = new InputStreamReader ( fis , \"iso-8859-1\" ) ; BufferedReader breader = new BufferedReader ( isr ) ; while ( true ) { String line = breader . readLine ( ) ; if ( line == null ) break ; line = line . trim ( ) ; if ( line . startsWith ( \"#\" ) || line . equals ( \"\" ) ) continue ; String [ ] parts = line . split ( \";\" ) ; check ( parts [ 0 ] , parts [ 1 ] ) ; } breader . close ( ) ; isr . close ( ) ; fis . close ( ) ; } public void testReusableTokenStream ( ) throws Exception { Analyzer a = new GermanAnalyzer ( ) ; checkReuse ( a , \"Tisch\" , \"tisch\" ) ; checkReuse ( a , \"Tische\" , \"tisch\" ) ; checkReuse ( a , \"Tischen\" , \"tisch\" ) ; } private class GermanSubclassAnalyzer extends GermanAnalyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new WhitespaceTokenizer ( reader ) ; } } public void testLUCENE1678BWComp ( ) throws Exception { checkReuse ( new", "gt": "GermanSubclassAnalyzer ( ) , \"Tischen\" , \"Tischen\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8876, "input": "<s> import java . io . * ; import java . util . * ; public class TestCRLineSeparator extends JavadocTester { private static final String BUG_ID = \"4979486\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , \".\" , \"pkg\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"MyClass.html\" , \"Line 1\\n Line 2\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; public static void main ( String [ ] args ) throws Exception { initFiles ( new File ( SRC_DIR ) , new File ( \".\" ) , \"pkg\" ) ; TestCRLineSeparator tester = new TestCRLineSeparator ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return getClass ( ) . getName ( ) ; } static void initFiles ( File fromDir , File toDir , String f ) throws IOException { File from_f = new File ( fromDir , f ) ; File to_f = new File", "gt": "( toDir , f ) ;", "prediction": ";\n", "label": 0}
{"id": 6099, "input": "<s> package io . beancounter . publisher . facebook ; import com . restfb . types . FacebookType ; import io . beancounter . commons . model . activity . * ; import io . beancounter . commons . model . activity . rai . TVEvent ; import io . beancounter . publisher . facebook . adapters . Publisher ; import io . beancounter . publisher . facebook . adapters . TVEventPublisher ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Properties ; public class FacebookPublisher implements Processor { private static final Logger LOGGER = LoggerFactory . getLogger ( FacebookPublisher . class ) ; @ Override public void process ( Exchange exchange ) throws FacebookPublisherException { ResolvedActivity resolvedActivity = exchange . getIn ( ) . getBody ( ResolvedActivity . class ) ; Activity activity = resolvedActivity . getActivity ( ) ; String token ; try { token = resolvedActivity . getUser ( ) . getServices ( ) . get ( \"facebook\" ) . getSession ( ) ; } catch ( NullPointerException e ) { final String errMessage = \"Facebook service not authorized. Do you have the token?\" ; LOGGER . warn ( errMessage ) ; throw new FacebookPublisherException ( errMessage , e ) ; } Publisher publisher = getPublisher ( activity . getObject ( ) ) ; FacebookType response = publisher . publishActivity ( token , activity . getVerb ( ) , activity . getObject ( ) ) ; LOGGER . debug ( \"published message ID: \" + response . getId ( ) ) ; } Publisher getPublisher ( io . beancounter . commons . model . activity . Object object ) throws FacebookPublisherException { Class clazz = ( Class ) getProperties ( ) . get ( object . getClass ( ) . getCanonicalName ( ) ) ; Publisher publisher ; try { publisher =", "gt": "( Publisher ) clazz . newInstance ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5889, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Snowball ; public interface LizaSnowball extends Snowball { List < LizaEntity > getNearbyLizaEntities ( double x", "gt": ", double y , double z ) ;", "prediction": ")\n", "label": 0}
{"id": 6110, "input": "<s> package org . eclipse . rap . rwt . internal . widgets ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . rap . rwt . testfixture . Message . Operation ; import org . eclipse . swt . widgets . Display ; public class JavaScriptExecutorImpl_Test extends TestCase { private static final String EXECUTE_1 = \"execute_1\" ; private static final String EXECUTE_2 = \"execute_2\" ; private JavaScriptExecutorImpl executor ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; new Display ( ) ; executor = new JavaScriptExecutorImpl ( ) ; Fixture . fakeNewRequest ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testExecuteJSOnce ( ) { executor . execute ( EXECUTE_1 ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Message message = Fixture . getProtocolMessage ( ) ; assertTrue ( indexOfCallOperation ( message , \"execute\" , EXECUTE_1 ) != - 1 ) ; } public void testExecuteJSTwice ( ) { executor . execute ( EXECUTE_1 ) ; executor . execute ( EXECUTE_2 ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Message message = Fixture . getProtocolMessage ( ) ; assertTrue ( indexOfCallOperation ( message , \"execute\" , EXECUTE_1 + EXECUTE_2 ) != - 1 ) ; } public void testExecuteJSIsClearedAfterRender ( ) { executor . execute ( EXECUTE_1 ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Fixture . fakeNewRequest ( ) ; executor . execute ( EXECUTE_2 ) ; Fixture . executeLifeCycleFromServerThread ( ) ; String script = getMessageScript ( ) ; assertFalse ( script . contains ( EXECUTE_1 ) ) ;", "gt": "assertTrue ( script . contains ( EXECUTE_2 ) ) ;", "prediction": "}\n", "label": 1}
{"id": 9459, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . craftbukkit . entity . CraftPig ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaLivingEntity ; import Liza . LizaPig ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftPig implements LizaPig { private CraftPig pig ; public LizaCraftPig ( CraftPig pig ) { this . pig = pig ; } @ Override public boolean canBreed ( ) { return this . pig . canBreed ( ) ; } @ Override public int getAge ( ) { return this . pig . getAge ( ) ; } @ Override public boolean getAgeLock ( ) { return this . pig . getAgeLock ( ) ; } @ Override public boolean isAdult ( ) { return this . pig . isAdult ( ) ; } @ Override public void setAdult ( ) { this . pig . setAdult ( ) ; } @ Override public void setAge ( int age ) { this . pig . setAge ( age ) ; } @ Override public void setAgeLock ( boolean lock ) { this . pig . setAgeLock ( lock ) ; } @ Override public void setBaby ( ) { this . pig . setBaby ( ) ; } @ Override public void setBreed ( boolean breed ) { this . pig . setBreed ( breed ) ; } @ Override public LizaLivingEntity getTarget ( ) { return new LizaCraftLivingEntity ( this . pig . getTarget ( ) ) ; } @ Override public void setTarget ( LivingEntity target ) { this . pig . setTarget ( target ) ; } @ Override public void damage ( int amount ) { this . pig . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . pig . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . pig . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . pig . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . pig . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . pig . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . pig . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . pig . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . pig . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . pig . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . pig . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . pig . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . pig . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . pig . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . pig . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > transparent , int maxDistance ) { return new LizaCraftBlock ( this . pig . getTargetBlock ( transparent , maxDistance ) ) ; } @ Override public LizaVehicle getVehicle ( ) { return new LizaCraftVehicle ( this . pig . getVehicle ( ) ) ; } @ Override public boolean isInsideVehicle ( ) { return this . pig . isInsideVehicle ( ) ; } @ Override public boolean leaveVehicle ( ) { return this . pig . leaveVehicle ( ) ; } @ Override public void setHealth ( int health ) { this . pig . setHealth ( health ) ; } @ Override public void setLastDamage ( int damage ) { this . pig . setLastDamage ( damage ) ; } @ Override public void setMaximumAir ( int ticks ) { this . pig . setMaximumAir ( ticks ) ; } @ Override public void setMaximumNoDamageTicks ( int ticks ) { this . pig . setMaximumNoDamageTicks ( ticks ) ; } @", "gt": "Override public void setNoDamageTicks ( int ticks )", "prediction": "}\n", "label": 0}
{"id": 6128, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . resources . client . CssResource ;", "gt": "public interface MailDetail_BinderImpl_GenCss_style extends CssResource", "prediction": ";\n", "label": 1}
{"id": 7587, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class ParameterValue extends Value { private final String name ; public ParameterValue ( String name ) { this . name = name ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public String getName ( ) { return name ; } @ Override public boolean equals ( Object o ) { if ( o instanceof ParameterValue ) { ParameterValue other = ( ParameterValue ) o ; return name . equals ( other . name ) ; } else { return false ; } } public StringBuilder appendTo ( StringBuilder sb ) { sb . append", "gt": "( '?' ) . append ( name ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6134, "input": "<s> package org . eclipse . jface . operation ; public interface IThreadListener { public void threadChange", "gt": "( Thread thread ) ;", "prediction": "( )\n", "label": 1}
{"id": 534, "input": "<s> class A { class B { enum C { X", "gt": ", Y , Z }", "prediction": ";\n", "label": 0}
{"id": 6140, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . digest ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . data . ChallengeRequest ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Parameter ; import org . restlet . data . Protocol ; import org . restlet . data . Status ; import org . restlet . resource . ClientResource ; import org . restlet . resource . ResourceException ; import org . restlet . util . Series ; public class MailClient { public static void main ( String [ ] args ) throws Exception { Client client = new Client ( new Context ( ) , Protocol . HTTPS ) ; Series < Parameter > parameters = client . getContext ( ) . getParameters ( ) ; parameters . add ( \"truststorePath\" , \"src/org/restlet/example/book/restlet/ch05/clientTrust.jks\" ) ; parameters . add ( \"truststorePassword\" , \"password\" ) ; parameters . add ( \"truststoreType\" , \"JKS\" ) ; ClientResource clientResource = new ClientResource ( \"https://localhost:8183/accounts/chunkylover53/mails/123\" ) ; clientResource . setNext ( client ) ; MailResource mailClient = clientResource . wrap ( MailResource . class ) ; try { mailClient . retrieve ( ) ; } catch ( ResourceException re ) { if ( Status . CLIENT_ERROR_UNAUTHORIZED . equals ( re . getStatus ( ) ) ) {", "gt": "ChallengeRequest digestChallenge = null ;", "prediction": "}\n", "label": 1}
{"id": 4662, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse .", "gt": "emf . ecore . EObject ;", "prediction": ";\n", "label": 0}
{"id": 6142, "input": "<s> package org . eclipse . ui . dialogs ; import org . eclipse . jface . wizard . IWizardPage ; import org . eclipse . ui . IWorkingSet ; public interface IWorkingSetPage extends IWizardPage { public", "gt": "void finish ( ) ;", "prediction": "\n", "label": 1}
{"id": 10056, "input": "<s> package com . gisgraphy . client . administrativedivision ; import static com . gisgraphy . client . administrativedivision . AdministrativeCountryInformationObjectMother . antarcticaAdministrativeCountryInformation ; import static com . gisgraphy . client . administrativedivision . AdministrativeCountryInformationObjectMother . franceAdministrativeCountryInformation ; import static com . gisgraphy . client . administrativedivision . AdministrativeCountryInformationObjectMother . unitedStatesAdministrativeCountryInformation ; import static com . gisgraphy . client . administrativedivision . AdministrativeCountryInformationObjectMother . usOutlyingIslandsAdministrativeCountryInformation ; import static com . gisgraphy . client . administrativedivision . FipsCountryCodeObjectMother . antarcticaFipsCountryCode ; import static com . gisgraphy . client . administrativedivision . FipsCountryCodeObjectMother . franceFipsCountryCode ; import static com . gisgraphy . client . administrativedivision . FipsCountryCodeObjectMother . unitedStatesFipsCountryCode ; import static com . gisgraphy . client . administrativedivision . GeographicCountryInformationObjectMother . antarcticaGeographicCountryInformation ; import static com . gisgraphy . client . administrativedivision . GeographicCountryInformationObjectMother . franceGeographicCountryInformation ; import static com . gisgraphy . client . administrativedivision . GeographicCountryInformationObjectMother . unitedStatesGeographicCountryInformation ; import static com . gisgraphy . client . administrativedivision . GeographicCountryInformationObjectMother . usOutlyingIslandsGeographicCountryInformation ; import static com . gisgraphy . client . administrativedivision . IsoCountryCodeObjectMother . antarcticaCountryCode ; import static com . gisgraphy . client . administrativedivision . IsoCountryCodeObjectMother . franceCountryCode ; import static com . gisgraphy . client . administrativedivision . IsoCountryCodeObjectMother . unitedStatesCountryCode ; import static com . gisgraphy . client . administrativedivision . IsoCountryCodeObjectMother . usOutlyingIslandsCountryCode ; import static com . gisgraphy . client . continent . ContinentObjectMother . antarcticaContinent ; import static com . gisgraphy . client . continent . ContinentObjectMother . europe ; import static com . gisgraphy . client . continent . ContinentObjectMother . northAmericaContinent ; import static com . gisgraphy . client . continent . ContinentObjectMother . oceania ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . antarcticaGisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . franceGisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . unitedStatesGisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . usOutlyingIslandsGisFeature ; import com . gisgraphy . client . administrativedivision . Country ; import com . gisgraphy . client . continent . ContinentObjectMother ; import com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother ; import com . gisgraphy . client . gisfeature . GisFeatureObjectMother ; import com . ibm . icu . util . Currency ; public class CountryObjectMother { public", "gt": "static Country unitedStatesCountry ( )", "prediction": ";\n", "label": 0}
{"id": 6147, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; final class JPEGScanHeader extends JPEGVariableSizeSegment { public int [ ] [ ] componentParameters ; public JPEGScanHeader ( byte [ ] reference ) { super ( reference ) ; } public JPEGScanHeader ( LEDataInputStream byteStream ) { super ( byteStream ) ; initializeComponentParameters ( ) ; } public int getApproxBitPositionHigh ( ) { return reference [ ( 2 * getNumberOfImageComponents ( ) ) + 7 ] > > 4 ; } public int getApproxBitPositionLow ( ) { return reference [ ( 2 * getNumberOfImageComponents ( ) ) + 7 ] & 0xF ; } public int getEndOfSpectralSelection ( ) { return reference [ ( 2 * getNumberOfImageComponents ( ) ) + 6 ] ; } public int getNumberOfImageComponents ( ) { return reference [ 4 ] ; } public int getStartOfSpectralSelection ( ) { return reference [ ( 2 * getNumberOfImageComponents ( ) ) + 5 ] ; } void initializeComponentParameters ( ) { int compCount = getNumberOfImageComponents ( ) ; componentParameters = new int [ 0 ] [ ] ; for ( int i = 0 ; i < compCount ; i ++ ) { int ofs = 5 + i * 2 ; int cid = reference [ ofs ] & 0xFF ; int dc = ( reference [ ofs + 1 ] & 0xFF ) > > 4 ; int ac = reference [ ofs + 1 ] & 0xF ; if ( componentParameters . length <= cid ) { int [ ] [ ] newParams = new int [ cid + 1 ] [ ] ; System . arraycopy ( componentParameters , 0 , newParams , 0 , componentParameters . length ) ; componentParameters = newParams ; } componentParameters [ cid ] = new int [ ] { dc , ac } ; } } public void initializeContents ( ) { int compCount = getNumberOfImageComponents ( ) ; int [ ] [ ] compSpecParams = componentParameters ; if ( compCount == 0 || compCount != compSpecParams . length ) { SWT . error ( SWT . ERROR_INVALID_IMAGE ) ; } for ( int i = 0 ; i < compCount ; i ++ ) { int ofs = i * 2 + 5 ; int [ ] compParams = compSpecParams [ i ] ; reference [ ofs ] = ( byte ) ( i + 1 ) ; reference [ ofs + 1 ] = ( byte ) ( compParams [ 0 ] * 16 + compParams [ 1 ] ) ; } } public void setEndOfSpectralSelection ( int anInteger ) { reference [ ( 2 * getNumberOfImageComponents ( ) ) + 6 ] = ( byte ) anInteger ; } public void setNumberOfImageComponents ( int anInteger ) { reference [ 4 ] = ( byte ) ( anInteger & 0xFF ) ; } public void setStartOfSpectralSelection ( int anInteger ) { reference [ ( 2 * getNumberOfImageComponents ( ) ) + 5 ] = ( byte ) anInteger ; } public int signature ( ) { return JPEGFileFormat . SOS ; } public boolean verifyProgressiveScan ( ) { int start = getStartOfSpectralSelection ( ) ; int end = getEndOfSpectralSelection ( ) ; int low = getApproxBitPositionLow ( ) ; int high = getApproxBitPositionHigh ( ) ; int count = getNumberOfImageComponents ( ) ; if ( ( start == 0 && end == 00 ) || ( start", "gt": "<= end && end <= 63 ) )", "prediction": ")\n", "label": 1}
{"id": 4088, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalDateLiteral ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class LogicalDateLiteralImpl extends LogicalExpressionImpl implements LogicalDateLiteral { protected static final String VALUE_EDEFAULT = null ; protected String value = VALUE_EDEFAULT ; protected LogicalDateLiteralImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getLogicalDateLiteral ( ) ; } public String getValue ( ) { return value ; } public void setValue ( String newValue ) { String oldValue = value ; value = newValue ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . LOGICAL_DATE_LITERAL__VALUE , oldValue , value ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . LOGICAL_DATE_LITERAL__VALUE : return getValue ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . LOGICAL_DATE_LITERAL__VALUE : setValue ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . LOGICAL_DATE_LITERAL__VALUE : setValue ( VALUE_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . LOGICAL_DATE_LITERAL__VALUE : return VALUE_EDEFAULT == null ? value != null :", "gt": "! VALUE_EDEFAULT . equals ( value ) ;", "prediction": ";\n", "label": 0}
{"id": 6149, "input": "<s> package org . restlet . data ; import org . restlet . engine . util . SystemUtils ; public class AuthenticationInfo { private volatile String nextServerNonce ; private volatile int nonceCount ; private volatile String clientNonce ; private volatile String quality ; private volatile String responseDigest ; public AuthenticationInfo ( String nextNonce , int nonceCount , String cnonce , String quality , String responseDigest ) { this . nextServerNonce = nextNonce ; this . nonceCount = nonceCount ; this . clientNonce = cnonce ; this . quality = quality ; this . responseDigest = responseDigest ; } @ Override public final boolean equals ( final Object obj ) { boolean result = ( obj == this ) ; if ( ! result ) { if ( obj instanceof AuthenticationInfo ) { final AuthenticationInfo that = ( AuthenticationInfo ) obj ; if ( getNextServerNonce ( ) != null ) { result = getNextServerNonce ( ) . equals ( that . getNextServerNonce ( ) ) ; } else { result = ( that . getNextServerNonce ( ) == null ) ; } if ( result ) { result = ( getNonceCount ( ) == that . getNonceCount ( ) ) ; } if ( result ) { if ( getClientNonce ( ) != null ) { result = getClientNonce ( ) . equals ( that . getClientNonce ( ) ) ; } else { result = ( that . getClientNonce ( ) == null ) ; } } if ( result ) { if ( getQuality ( ) != null ) { result = getQuality ( ) . equals ( that . getQuality ( ) ) ; } else { result = ( that . getQuality ( ) == null ) ; } } if ( result ) { if ( getResponseDigest ( ) != null ) { result = getResponseDigest ( ) . equals ( that . getResponseDigest ( ) ) ; } else { result = ( that . getResponseDigest ( ) == null ) ; } } } } return result ; } public String getClientNonce ( ) { return this . clientNonce ; } public String getNextServerNonce ( ) { return this . nextServerNonce ; } public int getNonceCount ( ) { return this . nonceCount ; } public String getQuality ( ) { return this . quality ; } public String getResponseDigest ( ) { return this . responseDigest ; } @ Override public int hashCode ( ) { return SystemUtils . hashCode ( getNextServerNonce ( ) , getNonceCount ( ) , getClientNonce ( )", "gt": ", getQuality ( ) , getResponseDigest ( ) ) ;", "prediction": ";\n", "label": 1}
{"id": 4436, "input": "<s> package Liza ; import org . bukkit . entity . Ghast ;", "gt": "public interface LizaGhast extends Ghast", "prediction": "}\n", "label": 0}
{"id": 6162, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . store . NoLockFactory ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; public class TestCrash extends LuceneTestCase { private IndexWriter initIndex ( ) throws IOException { return initIndex ( new MockRAMDirectory ( ) ) ; } private IndexWriter initIndex ( MockRAMDirectory dir ) throws IOException { dir . setLockFactory ( NoLockFactory . getNoLockFactory ( ) ) ; IndexWriter writer = new IndexWriter ( dir , new WhitespaceAnalyzer ( ) ) ; writer . setMaxBufferedDocs ( 10 ) ; ( ( ConcurrentMergeScheduler ) writer . getMergeScheduler ( ) ) . setSuppressExceptions ( ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"content\" , \"aaa\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; doc . add ( new Field ( \"id\" , \"0\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; for ( int i = 0 ; i < 157 ; i ++ ) writer . addDocument ( doc ) ; return writer ; } private void crash ( final IndexWriter writer ) throws IOException { final MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; ConcurrentMergeScheduler cms = ( ConcurrentMergeScheduler ) writer . getMergeScheduler ( ) ; dir . crash ( ) ; cms . sync ( ) ; dir . clearCrash ( ) ; } public void testCrashWhileIndexing ( ) throws IOException { IndexWriter writer = initIndex ( ) ; MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; crash ( writer ) ; IndexReader reader = IndexReader . open ( dir ) ; assertTrue ( reader . numDocs ( ) < 157 ) ; } public void testWriterAfterCrash ( ) throws IOException { IndexWriter writer = initIndex ( ) ; MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; dir . setPreventDoubleWrite ( false ) ; crash ( writer ) ; writer = initIndex ( dir ) ; writer . close ( ) ; IndexReader reader = IndexReader . open ( dir ) ; assertTrue ( reader . numDocs ( ) < 314 ) ; } public void testCrashAfterReopen ( ) throws IOException { IndexWriter writer = initIndex ( ) ; MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; writer . close ( ) ; writer = initIndex ( dir ) ; assertEquals ( 314 , writer . docCount ( ) ) ; crash ( writer ) ; IndexReader reader = IndexReader . open ( dir ) ; assertTrue ( reader . numDocs ( ) >= 157 ) ; } public void testCrashAfterClose ( ) throws IOException { IndexWriter writer = initIndex ( ) ; MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; writer . close ( ) ; dir . crash ( ) ; IndexReader reader = IndexReader . open ( dir ) ; assertEquals ( 157 , reader . numDocs ( ) ) ; } public void testCrashAfterCloseNoWait ( ) throws IOException { IndexWriter writer = initIndex ( ) ; MockRAMDirectory dir = ( MockRAMDirectory ) writer . getDirectory ( ) ; writer . close ( false ) ; dir . crash ( ) ; IndexReader reader = IndexReader", "gt": ". open ( dir ) ;", "prediction": ";\n", "label": 1}
{"id": 751, "input": "<s> package org . jboss . arquillian . android . configuration ; public class AndroidExtensionConfiguration { private boolean skip ; private boolean force ; private String serialId ; private String avdName ; private String emulatorOptions ; private String sdSize = \"128M\" ; private long emulatorBootupTimeoutInSeconds = 120L ; private long emulatorShutdownTimeoutInSeconds = 60L ; private String home = System . getenv ( \"ANDROID_HOME\" ) ; private String apiLevel = \"10\" ; public String getHome ( ) { return home ; } public void setHome ( String home ) { this . home = home ; } public String getAvdName ( ) { return avdName ; } public void setAvdName ( String avdName ) { this . avdName = avdName ; } public String getSerialId ( ) { return serialId ; } public void setSerialId ( String serialId ) { this . serialId = serialId ; } public String getEmulatorOptions ( ) { return emulatorOptions ; } public void setEmulatorOptions ( String emulatorOptions ) { this . emulatorOptions = emulatorOptions ; } public boolean isSkip ( ) { return skip ; } public void setSkip ( boolean skip ) { this . skip = skip ; } public boolean isForce ( ) { return force ; } public void setForce ( boolean force ) { this . force = force ; } public long getEmulatorBootupTimeoutInSeconds ( ) { return emulatorBootupTimeoutInSeconds ; } public void setEmulatorBootupTimeoutInSeconds ( long emulatorBootupTimeoutInSeconds ) { this . emulatorBootupTimeoutInSeconds = emulatorBootupTimeoutInSeconds ; } public String getApiLevel ( ) { return apiLevel ; } public void setApiLevel ( String apiLevel ) { this . apiLevel = apiLevel ; } public String getSdSize ( ) { return sdSize ; }", "gt": "public void setSdSize ( String sdSize )", "prediction": "}\n", "label": 0}
{"id": 6169, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . safehtml . shared . SafeHtmlUtils ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiBinderUtil ; import com . google . gwt . user . client . ui . Widget ; public class Tasks_BinderImpl implements UiBinder < com . google . gwt . user . client . ui . Widget , org . restlet . example . book . restlet . ch09 . client . Tasks > , org . restlet . example . book . restlet . ch09 . client . Tasks . Binder { interface Template extends SafeHtmlTemplates { @ Template ( \"Get groceries\" ) SafeHtml html1 ( ) ; @ Template ( \"Walk the dog\" ) SafeHtml html2 ( ) ; @ Template ( \"Start Web 2.0 company\" ) SafeHtml html3 ( ) ; @ Template ( \"Write cool app in GWT\" ) SafeHtml html4 ( ) ; @ Template ( \"Get funding\" ) SafeHtml html5 ( ) ; @ Template ( \"Take a vacation\" ) SafeHtml html6 ( ) ; } Template template = GWT . create ( Template . class ) ; public com . google . gwt . user . client . ui . Widget createAndBindUi ( final org . restlet . example . book . restlet . ch09 . client . Tasks owner ) { org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenBundle clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay = ( org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenBundle ) GWT . create ( org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenBundle . class ) ; org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenCss_style style = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay . style ( ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox2 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox3 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox4 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox5 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox6 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . CheckBox f_CheckBox7 = ( com . google . gwt . user . client . ui . CheckBox ) GWT . create ( com . google . gwt . user . client . ui . CheckBox . class ) ; com . google . gwt . user . client . ui . FlowPanel f_FlowPanel1 = ( com . google . gwt . user . client . ui . FlowPanel ) GWT . create ( com . google . gwt . user . client . ui . FlowPanel . class ) ; f_CheckBox2 . setHTML ( template . html1 ( ) . asString ( ) ) ; f_CheckBox2 . setStyleName ( \"\" + style . item ( ) + \"\" ) ; f_FlowPanel1 . add ( f_CheckBox2 ) ; f_CheckBox3 . setHTML ( template . html2 ( ) . asString ( ) ) ; f_CheckBox3 . setStyleName ( \"\" + style . item ( ) + \"\" ) ; f_FlowPanel1 . add ( f_CheckBox3 ) ; f_CheckBox4 . setHTML ( template . html3 ( ) . asString ( ) ) ; f_CheckBox4 . setStyleName ( \"\" + style . item ( ) + \"\" ) ; f_FlowPanel1 . add ( f_CheckBox4 ) ; f_CheckBox5 . setHTML ( template . html4", "gt": "( ) . asString ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9820, "input": "<s> package com . redhat . ceylon . tools . help ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . StringWriter ; import junit . framework . Assert ; import org . junit . Ignore ; import org . junit . Test ; import org . tautua . markdownpapers . ast . Document ; import org . tautua . markdownpapers . parser . Parser ; import com . redhat . ceylon . common . tool . WordWrap ; public class PlaintextTest { public void renderAndCompare ( String mdFile , String txtFile ) throws Exception { StringWriter sw = new StringWriter ( ) ; try ( InputStreamReader stream = new InputStreamReader ( PlaintextTest . class . getResourceAsStream ( mdFile ) ) ) { Parser parser = new Parser ( stream ) ; Document document = parser . parse ( ) ; PlaintextMarkdownVisitor emitter = new PlaintextMarkdownVisitor ( new WordWrap ( sw ) ) ; document . accept ( emitter ) ; } StringBuilder sb = new StringBuilder ( ) ; try ( BufferedReader r = new BufferedReader ( new InputStreamReader ( PlaintextTest . class . getResourceAsStream ( txtFile ) ) ) ) { String line = r . readLine ( ) ;", "gt": "while ( line != null )", "prediction": "}\n", "label": 0}
{"id": 6213, "input": "<s> package monbulk . shared . view ; import java . util . List ; import monbulk . shared . Architecture . IPresenter ; import com . google . gwt . user . client . ui . HasWidgets ; import com . google . gwt . user . client", "gt": ". ui . Widget ;", "prediction": ";\n", "label": 1}
{"id": 8212, "input": "<s> package org . ofbiz . webapp . taglib ; import java . io . IOException ; import javax . servlet . jsp . JspException ; import javax . servlet . jsp . JspWriter ; import javax . servlet . jsp . tagext . TagSupport ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilJ2eeCompat ; @ SuppressWarnings ( \"serial\" ) public class PrintTag extends TagSupport { public static final String module = PrintTag . class . getName ( ) ; private String attribute = null ; private String defaultStr = \"\" ; public String getAttribute ( ) { return attribute ; } public void setAttribute ( String attribute ) { this . attribute = attribute ; } public String getDefault ( ) { return defaultStr ; } public void setDefault ( String defaultStr ) { this . defaultStr = defaultStr ; } @ Override public int doStartTag ( ) throws JspException { if", "gt": "( attribute == null ) return SKIP_BODY ;", "prediction": "( )\n", "label": 0}
{"id": 6214, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . store . IndexOutput ; import org . apache . lucene . store . ChecksumIndexOutput ; import org . apache . lucene . store . ChecksumIndexInput ; import org . apache . lucene . store . NoSuchDirectoryException ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Vector ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Map ; public final class SegmentInfos extends Vector { public static final int FORMAT = - 1 ; public static final int FORMAT_LOCKLESS = - 2 ; public static final int FORMAT_SINGLE_NORM_FILE = - 3 ; public static final int FORMAT_SHARED_DOC_STORE = - 4 ; public static final int FORMAT_CHECKSUM = - 5 ; public static final int FORMAT_DEL_COUNT = - 6 ; public static final int FORMAT_HAS_PROX = - 7 ; public static final int FORMAT_USER_DATA = - 8 ; public static final int FORMAT_DIAGNOSTICS = - 9 ; static final int CURRENT_FORMAT = FORMAT_DIAGNOSTICS ; public int counter = 0 ; private long version = System . currentTimeMillis ( ) ; private long generation = 0 ; private long lastGeneration = 0 ; private Map userData = Collections . EMPTY_MAP ; private static PrintStream infoStream ; public final SegmentInfo info ( int i ) { return ( SegmentInfo ) get ( i ) ; } public static long getCurrentSegmentGeneration ( String [ ] files ) { if ( files == null ) { return - 1 ; } long max = - 1 ; for ( int i = 0 ; i < files . length ; i ++ ) { String file = files [ i ] ; if ( file . startsWith ( IndexFileNames . SEGMENTS ) && ! file . equals ( IndexFileNames . SEGMENTS_GEN ) ) { long gen = generationFromSegmentsFileName ( file ) ; if ( gen > max ) { max = gen ; } } } return max ; } public static long getCurrentSegmentGeneration ( Directory directory ) throws IOException { try { return getCurrentSegmentGeneration", "gt": "( directory . listAll ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1039, "input": "<s> package com . sun . tools . javac . comp ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . jvm . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . code . Type . * ; import static com . sun . tools . javac . code . TypeTags . * ; import static com . sun . tools . javac . jvm . ByteCodes . * ; strictfp class ConstFold { protected static final Context . Key < ConstFold > constFoldKey = new Context . Key < ConstFold > ( ) ; private Symtab syms ; public static ConstFold instance ( Context context ) { ConstFold instance = context . get ( constFoldKey ) ; if ( instance == null ) instance = new ConstFold ( context ) ; return instance ; } private ConstFold ( Context context ) { context . put ( constFoldKey , this ) ; syms = Symtab . instance ( context ) ; } static Integer minusOne = - 1 ; static Integer zero = 0 ; static Integer one = 1 ; private static Integer b2i ( boolean b ) { return b ? one : zero ; } private static int intValue ( Object x ) { return ( ( Number ) x ) . intValue ( ) ; } private static long longValue ( Object x ) { return ( ( Number ) x ) . longValue ( ) ; } private static float floatValue ( Object x ) { return ( ( Number ) x ) . floatValue ( ) ; } private static double doubleValue ( Object x ) { return ( ( Number ) x ) . doubleValue ( ) ; } Type fold ( int opcode , List < Type > argtypes ) { int argCount = argtypes . length ( ) ; if ( argCount == 1 ) return fold1 ( opcode , argtypes . head ) ; else if ( argCount == 2 ) return fold2 ( opcode , argtypes . head , argtypes . tail . head ) ; else throw new AssertionError ( ) ; } Type fold1 ( int opcode , Type operand ) { try { Object od = operand . constValue ( ) ; switch ( opcode ) { case nop : return operand ; case ineg : return syms . intType . constType ( - intValue ( od ) ) ; case ixor : return syms . intType . constType ( ~ intValue ( od ) ) ; case bool_not : return syms . booleanType . constType ( b2i ( intValue ( od ) == 0 ) ) ; case ifeq : return syms . booleanType . constType ( b2i ( intValue ( od ) == 0 ) ) ; case ifne : return syms . booleanType . constType ( b2i ( intValue ( od ) != 0 ) ) ; case iflt : return syms . booleanType . constType ( b2i ( intValue ( od ) < 0 ) ) ; case ifgt : return syms . booleanType . constType ( b2i ( intValue ( od ) > 0 ) ) ; case ifle : return syms . booleanType . constType ( b2i ( intValue ( od ) <= 0 ) ) ; case ifge : return syms . booleanType . constType ( b2i ( intValue ( od ) >= 0 ) ) ; case lneg : return syms . longType . constType ( new Long ( - longValue ( od ) ) ) ; case lxor : return syms . longType . constType ( new Long ( ~ longValue ( od ) ) ) ; case fneg : return syms . floatType . constType ( new Float ( - floatValue ( od ) ) ) ; case dneg : return syms . doubleType . constType ( new Double ( - doubleValue ( od ) ) ) ; default : return null ; } } catch ( ArithmeticException e ) { return null ; } } Type fold2", "gt": "( int opcode , Type left , Type right )", "prediction": ";\n", "label": 0}
{"id": 6224, "input": "<s> package org . eclipse . ui . internal . activities . ws ; import java . util . * ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . viewers . * ; import org . eclipse . jface . window . Window ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . * ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . * ; import com . ibm . icu . text . MessageFormat ; public class EnablementDialog extends Dialog { private final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( EnablementDialog . class . getName ( ) , RWT . getLocale ( ) ) ; private Button dontAskButton ; private Set activitiesToEnable = new HashSet ( 7 ) ; private Collection activityIds ; private boolean dontAsk ; private Button detailsButton ; boolean showDetails = false ; private Composite detailsComposite ; private Label detailsLabel ; private String selectedActivity ; private Text detailsText ; private Properties strings ; public EnablementDialog ( Shell parentShell , Collection activityIds , Properties strings ) { super ( parentShell ) ; this . activityIds = activityIds ; this . strings = strings ; } protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; Font dialogFont = parent . getFont ( ) ; composite . setFont ( dialogFont ) ; Label text = new Label ( composite , SWT . NONE ) ; text . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; text . setFont ( dialogFont ) ; IActivityManager manager = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) . getActivityManager ( ) ; if ( activityIds . size ( ) == 1 ) { String activityId = ( String ) activityIds . iterator ( ) . next ( ) ; activitiesToEnable . add ( activityId ) ; selectedActivity = activityId ; IActivity activity = manager . getActivity ( activityId ) ; String activityText ; try { activityText = activity . getName ( ) ; } catch ( NotDefinedException e ) { activityText = activity . getId ( ) ; } text . setText ( MessageFormat . format ( RESOURCE_BUNDLE . getString ( \"requiresSingle\" ) , new Object [ ] { activityText } ) ) ; text = new Label ( composite , SWT . NONE ) ; text . setText ( strings . getProperty ( WorkbenchTriggerPointAdvisor . PROCEED_SINGLE , RESOURCE_BUNDLE . getString ( WorkbenchTriggerPointAdvisor", "gt": ". PROCEED_SINGLE ) ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8610, "input": "<s> package org . ofbiz . product . product ; import java . io . IOException ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . category . CategoryWorker ; import org . ofbiz . product . feature . ParametricSearch ; import org . ofbiz . product . product . ProductSearch . CategoryConstraint ; import org . ofbiz . product . product . ProductSearch . FeatureConstraint ; import org . ofbiz . product . product . ProductSearch . KeywordConstraint ; import org . ofbiz . product . product . ProductSearch . ProductSearchConstraint ; import org . ofbiz . product . product . ProductSearch . ProductSearchContext ; import org . ofbiz . product . product . ProductSearch . ResultSortOrder ; import org . ofbiz . product . product . ProductSearch . SortKeywordRelevancy ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . stats . VisitHandler ; public class ProductSearchSession { public static final String module = ProductSearchSession . class . getName ( ) ; @ SuppressWarnings ( \"serial\" ) public static class ProductSearchOptions implements java . io . Serializable { protected List < ProductSearchConstraint > constraintList = null ; protected String topProductCategoryId = null ; protected ResultSortOrder resultSortOrder = null ; protected Integer viewIndex = null ; protected Integer viewSize = null ; protected boolean changed = false ; protected String paging = \"Y\" ; protected Integer previousViewSize = null ; public ProductSearchOptions ( ) { } public ProductSearchOptions ( ProductSearchOptions productSearchOptions ) { this . constraintList = FastList . newInstance ( ) ; if ( UtilValidate . isNotEmpty ( productSearchOptions . constraintList ) ) { this . constraintList . addAll ( productSearchOptions . constraintList ) ; } this . topProductCategoryId = productSearchOptions . topProductCategoryId ; this . resultSortOrder = productSearchOptions . resultSortOrder ; this . viewIndex = productSearchOptions . viewIndex ; this . viewSize = productSearchOptions . viewSize ; this . changed = productSearchOptions . changed ; this . paging = productSearchOptions . paging ; this . previousViewSize = productSearchOptions . previousViewSize ; } public List < ProductSearchConstraint > getConstraintList ( ) { return this . constraintList ; } public static List < ProductSearchConstraint > getConstraintList ( HttpSession session ) { return getProductSearchOptions ( session ) . constraintList ; } public static void", "gt": "addConstraint ( ProductSearchConstraint productSearchConstraint , HttpSession session )", "prediction": "( )\n", "label": 0}
{"id": 6226, "input": "<s> package com . cloudera . sqoop . mapreduce ; import java . sql . SQLException ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import com . cloudera . sqoop . lib . SqoopRecord ; public abstract class AsyncSqlRecordWriter < K extends SqoopRecord , V > extends org . apache . sqoop . mapreduce . AsyncSqlRecordWriter", "gt": "< K , V >", "prediction": ";\n", "label": 1}
{"id": 7603, "input": "<s> package org . osgi . framework . resource ; import org . osgi . framework . Constants ; import org . osgi . framework . Version ; import org . osgi . framework . wiring . BundleRevision ; import org . osgi . framework . wiring . BundleWiring ; public final class ResourceConstants { private ResourceConstants ( ) { } public static final String IDENTITY_NAMESPACE = \"osgi.identity\" ; public static final String IDENTITY_VERSION_ATTRIBUTE = Constants . VERSION_ATTRIBUTE ; public static final String IDENTITY_TYPE_ATTRIBUTE = \"type\" ; public static final String IDENTITY_TYPE_BUNDLE = \"osgi.bundle\" ; public static final String IDENTITY_TYPE_FRAGMENT = \"osgi.fragment\" ; public static final String IDENTITY_TYPE_UNKNOWN = \"unknown\" ; public static final String IDENTITY_SINGLETON_DIRECTIVE = Constants . SINGLETON_DIRECTIVE ; public static final String WIRING_PACKAGE_NAMESPACE = \"osgi.wiring.package\" ; public static final String WIRING_BUNDLE_NAMESPACE = \"osgi.wiring.bundle\" ; public static final String WIRING_HOST_NAMESPACE = \"osgi.wiring.host\" ; public final static String REQUIREMENT_FILTER_DIRECTIVE = Constants . FILTER_DIRECTIVE ; public final static String REQUIREMENT_RESOLUTION_DIRECTIVE = Constants . RESOLUTION_DIRECTIVE ; public final static String REQUIREMENT_RESOLUTION_MANDATORY = Constants . RESOLUTION_MANDATORY ; public final static String REQUIREMENT_RESOLUTION_OPTIONAL = Constants . RESOLUTION_OPTIONAL ; public final static String REQUIREMENT_EFFECTIVE_DIRECTIVE = Constants . EFFECTIVE_DIRECTIVE ; public final", "gt": "static String EFFECTIVE_RESOLVE = Constants . EFFECTIVE_RESOLVE ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6241, "input": "<s> package io . beancounter . commons . cogito . model ; public class Entity { private String name ; private String syncon ; private boolean isSyncon ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getSyncon ( ) { return syncon ; } public synchronized void setSyncon ( String syncon ) { if ( syncon . compareTo ( \"SYNCON\" ) == 0 ) { isSyncon = true ; } else if ( isSyncon ) { this . syncon = syncon ; isSyncon = false ; } } @ Override public String toString ( ) { return \"Entity{\" + \"name='\" + name + '\\'' +", "gt": "\", syncon='\" + syncon + '\\'' + '}' ;", "prediction": ") ;\n", "label": 1}
{"id": 942, "input": "<s> package com . mapr . storm ; import backtype . storm . task . OutputCollector ; import backtype . storm . task . TopologyContext ; import backtype . storm . topology . IRichBolt ; import backtype . storm . topology . OutputFieldsDeclarer ; import backtype . storm . tuple . Fields ; import backtype . storm . tuple . Tuple ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import java . util . Arrays ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Queue ; public class TimeLimitedJoin implements IRichBolt { private final long expirationTime ; private final int maxTuplesToRetain ; private final Fields joinKey ; private OutputCollector collector ; private final Queue < TimedTuple > queue = new LinkedList < TimedTuple > ( ) ; private final Map < Key , TimedTuple > pendingByKey = Maps . newHashMap ( ) ; public TimeLimitedJoin ( long expirationTime , int maxTuplesToRetain , Fields joinKey ) { this . expirationTime = expirationTime ; this . maxTuplesToRetain = maxTuplesToRetain ; this . joinKey = joinKey ; } @ Override public void prepare ( Map config , TopologyContext context , OutputCollector collector ) { this . collector = collector ; } @ Override public synchronized void execute ( Tuple input ) { long cutoff = now ( ) - expirationTime ; while ( queue . size ( ) > 0 && ( queue . size ( ) > maxTuplesToRetain || queue . peek ( ) . time < cutoff ) ) { TimedTuple expiringTuple = queue . poll ( ) ; if ( expiringTuple . tuple != null ) { collector . ack ( expiringTuple . tuple ) ; Key key = extractJoinKey ( input ) ; if ( pendingByKey . get ( key ) . time < cutoff ) { pendingByKey . remove ( key ) ; } } } final Key key = extractJoinKey ( input ) ; TimedTuple match = pendingByKey . get ( key ) ; if ( match != null ) { if ( match . tuple != null ) { pendingByKey . remove ( key ) ; collector . emit ( Arrays . asList ( input , match . tuple ) , ImmutableList . of ( Lists . newArrayList ( key ) , match . tuple , input ) ) ; collector . ack ( input ) ; collector . ack ( match . tuple ) ; match . tuple = null ; } } else { final TimedTuple t = new TimedTuple ( now ( ) , input ) ; queue . add ( t ) ; pendingByKey . put ( key , t ) ; } } private Key extractJoinKey ( Tuple input ) { List < Object > keys = Lists . newArrayList ( ) ; for ( String key : joinKey ) { keys . add ( input . getValueByField ( key ) ) ; } return new Key ( keys ) ; } private long now ( ) { return System . nanoTime ( ) / 1000000 ; } @ Override public void cleanup ( ) { } @ Override public void declareOutputFields ( OutputFieldsDeclarer declarer ) { declarer . declare ( new Fields ( \"old\" , \"new\" ) ) ; } private static class Key implements Iterable < Object > { final List < Object > values ; private Key ( List < Object > values ) { this . values = values ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Key ) ) { return false ; } Key other = ( Key ) o ; if ( values == other . values ) { return true ; } else if ( values == null || other . values == null ) { return values == other . values ; } else { if ( values . size ( ) != other . values . size ( ) ) { return false ; } Iterator i = other . values . iterator ( ) ; for ( Object value : values ) { if ( ! i . hasNext ( ) || ! value . equals ( i . next ( ) ) ) { return false ; } } return true ; } } @ Override public int hashCode ( ) { int hash = 0 ; for ( Object value : values ) { hash = hash ^ value . hashCode ( ) ; } return hash ; } @ Override public Iterator < Object > iterator ( ) { return values . iterator ( ) ; } } private static class TimedTuple implements Comparable < TimedTuple > { private final long time ; public Tuple tuple ; public", "gt": "TimedTuple ( long time , Tuple tuple )", "prediction": "( )\n", "label": 0}
{"id": 6242, "input": "<s> package org . apache . lucene . store . db ; import java . io . IOException ; import org . apache . lucene . store . IndexInput ; public class DbIndexInput extends IndexInput { protected long position = 0L , length = 0L ; protected DbDirectory directory ; protected Block block ; protected File file ; protected DbIndexInput ( DbDirectory directory , String name ) throws IOException { super ( ) ; this . directory = directory ; this . file = new File ( name ) ; if ( ! file . exists ( directory ) ) throw new IOException ( \"File does not exist: \" + name ) ; length = file . getLength ( ) ; block = new Block ( file ) ; block . get ( directory ) ; } public Object clone ( ) { try { DbIndexInput clone = ( DbIndexInput ) super . clone ( ) ; clone . block = new Block ( file ) ; clone . block . seek ( position ) ; clone . block . get ( directory ) ; return clone ; } catch ( IOException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } public void close ( ) throws IOException { } public long length ( ) { return length ; } public byte readByte ( ) throws IOException { if ( position + 1 > length ) throw new IOException ( \"Reading past end of file\" ) ; int blockPos = ( int ) ( position ++ & DbIndexOutput . BLOCK_MASK ) ; byte b = block . getData ( ) [ blockPos ] ; if ( blockPos + 1 == DbIndexOutput . BLOCK_LEN ) { block . seek ( position ) ; block . get ( directory ) ; } return b ; } public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { if ( position + len > length ) throw new IOException ( \"Reading past end of file\" ) ; else { int blockPos = ( int ) ( position & DbIndexOutput . BLOCK_MASK ) ; while ( blockPos + len >= DbIndexOutput . BLOCK_LEN ) { int blockLen = DbIndexOutput . BLOCK_LEN - blockPos ; System . arraycopy ( block . getData ( ) , blockPos , b , offset , blockLen ) ; len -= blockLen ; offset += blockLen ; position += blockLen ; block . seek ( position ) ; block . get ( directory ) ; blockPos = 0 ; } if ( len > 0 ) { System . arraycopy ( block . getData ( ) , blockPos , b , offset , len ) ; position += len ; } } } public void", "gt": "seek ( long pos ) throws IOException", "prediction": "( )\n", "label": 1}
{"id": 2020, "input": "<s> package ar . com . fdvs . dj . test . crosstab ; import java . awt . Color ; import java . util . Date ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . CrosstabBuilder ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . test . BaseDjReportTest ; import ar . com . fdvs . dj . test . TestRepositoryProducts ; import ar . com . fdvs . dj . util . SortUtils ; public class CrosstabReportTest4 extends BaseDjReportTest { private Style totalHeaderStyle ; private Style colAndRowHeaderStyle ; private Style mainHeaderStyle ; private Style totalStyle ; private Style measureStyle ; private Style titleStyle ; public DynamicReport buildReport ( ) throws Exception { initStyles ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setPrintColumnNames ( false ) . setUseFullPageWidth ( true ) . setWhenNoData ( \"No data for this report\" , null ) . setDefaultStyles ( titleStyle , null , null , null ) ; DJCrosstab djcross = new CrosstabBuilder ( ) . setHeight ( 200 ) . setWidth ( 500 ) . setHeaderStyle ( mainHeaderStyle ) . setDatasource ( \"sr\" , DJConstants . DATA_SOURCE_ORIGIN_PARAMETER , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) . setUseFullWidth ( true ) . setColorScheme ( DJConstants . COLOR_SCHEMA_LIGHT_GREEN ) . setAutomaticTitle ( true ) . setCellBorder ( Border . THIN ) . addRow ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , false ) . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , false ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , true ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , true ) . addMeasure ( \"id\" , Long . class . getName ( ) , DJCalculation . SUM , \"Id\" , measureStyle ) . addMeasure ( \"amount\" , Float . class . getName ( ) , DJCalculation . SUM , \"Amount\" , measureStyle ) . setRowStyles ( colAndRowHeaderStyle , totalStyle , totalHeaderStyle ) . setColumnStyles ( colAndRowHeaderStyle , totalStyle , totalHeaderStyle ) . setCellDimension ( 34 , 60 ) . setColumnHeaderHeight ( 30 ) . setRowHeaderWidth ( 80 ) . build ( ) ; drb . addHeaderCrosstab ( djcross ) ; DynamicReport dr = drb . build ( ) ; params . put ( \"sr\" , SortUtils . sortCollection ( TestRepositoryProducts . getDummyCollection ( ) , djcross ) ) ; return dr ; } private void initStyles ( ) { titleStyle = new StyleBuilder ( false ) . setFont ( Font . ARIAL_BIG_BOLD ) . setHorizontalAlign ( HorizontalAlign . LEFT ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setTransparency ( Transparency . OPAQUE ) . setBorderBottom ( Border . PEN_2_POINT ) . build ( ) ; totalHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . setTextColor ( Color . BLUE ) . build ( ) ; colAndRowHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . LEFT ) . setVerticalAlign ( VerticalAlign . TOP ) . setFont ( Font . ARIAL_MEDIUM_BOLD ) . build ( ) ; mainHeaderStyle = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . setVerticalAlign ( VerticalAlign . MIDDLE ) . setFont ( Font . ARIAL_BIG_BOLD ) . setTextColor ( Color . BLACK )", "gt": ". build ( ) ;", "prediction": ";\n", "label": 0}
{"id": 6252, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . wizard . IWizard ; import org . eclipse . jface . wizard . IWizardPage ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . dialogs . IWorkingSetPage ; public class DynamicWorkingSetPage implements IWorkingSetPage { public void finish ( ) { } public IWorkingSet getSelection ( ) { return null ; } public void setSelection ( IWorkingSet workingSet ) { } public boolean canFlipToNextPage ( ) { return false ; } public String getName ( ) { return null ; } public IWizardPage getNextPage ( ) { return null ; } public IWizardPage getPreviousPage ( ) { return null ; } public IWizard getWizard ( ) { return null ; } public boolean isPageComplete ( ) { return false ; } public void setPreviousPage ( IWizardPage page ) { } public void setWizard ( IWizard newWizard ) { } public void createControl ( Composite parent ) { } public void dispose ( ) { } public Control getControl ( ) { return null ; } public String getDescription ( ) { return null ; }", "gt": "public String getErrorMessage ( )", "prediction": "}\n", "label": 1}
{"id": 4152, "input": "<s> package org . gk . engine . client . build . toolbar ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class ToolBarBuilder extends Builder { public ToolBarBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode ( List", "gt": "< UIGen > nodeList , Node node )", "prediction": ")\n", "label": 0}
{"id": 6303, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core .", "gt": "api . impl . DocumentModelListImpl ;", "prediction": ";\n", "label": 1}
{"id": 8673, "input": "<s> import java . util . List ; class T6985719h { abstract class A < X > { abstract void f ( List < X > ls ) ; } abstract class B extends A < String > { abstract", "gt": "void f ( List < Integer > ls ) ;", "prediction": "\n", "label": 0}
{"id": 6305, "input": "<s> package it . rainet . portal . cms . client . integration . lightstreamer ; import java . io . Serializable ; public class LightstreamerDTO implements Serializable { private static final long serialVersionUID = 1L ; public static final String TYPE_OPENBOXES = \"OB\" ; public static final String TYPE_BEANCOUNTER = \"BC\" ; public enum Command { START , STOP } ; private String owner ; private String body ; private String type ; public LightstreamerDTO ( String owner , String body , String type ) { this . owner = owner ; this . body = body ; this . type = type ; } public String getOwner ( ) { return owner ; } public String getBody ( ) { return body ; } public String getType ( ) { return type ; } @ Override public String toString ( ) { return \"owner = \" + owner + \"type = \" + type + \", body = \" + ( body . length ( ) > 100 ? body . substring ( 0", "gt": ", 97 ) + \"...\" : body ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2925, "input": "<s> package com . redhat . ceylon . itest ; import org . junit . runner . RunWith ; import org . junit . runners . Suite ; import org . junit . runners . Suite . SuiteClasses ; @ RunWith ( Suite . class ) @ SuiteClasses ( { CeylonCompileScriptTest . class , CeylonDocScriptTest . class , CeylonRunScriptTest . class , CeyloncAntTest .", "gt": "class , CeylondAntTest . class , CeylonAntTest . class , }", "prediction": ") ;\n", "label": 0}
{"id": 6309, "input": "<s> package org . eclipse . ui . application ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . WorkbenchException ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . internal . WorkbenchWindowConfigurer ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . intro . IIntroManager ; public class WorkbenchWindowAdvisor { private IWorkbenchWindowConfigurer windowConfigurer ; public WorkbenchWindowAdvisor ( IWorkbenchWindowConfigurer configurer ) { Assert . isNotNull ( configurer ) ; this . windowConfigurer = configurer ; } protected IWorkbenchWindowConfigurer getWindowConfigurer ( ) { return windowConfigurer ; } public void preWindowOpen ( ) { } public ActionBarAdvisor createActionBarAdvisor ( IActionBarConfigurer configurer ) { return new ActionBarAdvisor ( configurer ) ; } public void postWindowRestore ( ) throws WorkbenchException { } public void openIntro ( ) { IWorkbenchConfigurer wbConfig = getWindowConfigurer ( ) . getWorkbenchConfigurer ( ) ; final String key = \"introOpened\" ; Boolean introOpened = ( Boolean ) wbConfig . getData ( key ) ; if ( introOpened != null && introOpened . booleanValue ( ) ) { return ; } wbConfig . setData ( key , Boolean . TRUE ) ; boolean showIntro = PrefUtil . getAPIPreferenceStore ( ) . getBoolean ( IWorkbenchPreferenceConstants . SHOW_INTRO ) ; IIntroManager introManager = wbConfig . getWorkbench ( ) . getIntroManager ( ) ; boolean hasIntro = introManager . hasIntro ( ) ; boolean isNewIntroContentAvailable = introManager . isNewContentAvailable ( ) ; if ( hasIntro && ( showIntro || isNewIntroContentAvailable ) ) { PrefUtil . getAPIPreferenceStore ( ) . setValue ( IWorkbenchPreferenceConstants . SHOW_INTRO , false ) ; PrefUtil . saveAPIPrefs ( ) ; introManager . showIntro ( getWindowConfigurer ( ) . getWindow ( ) , false ) ; } } public void postWindowCreate ( ) { } public void postWindowOpen ( ) { } public boolean preWindowShellClose ( ) { return true ; } public void postWindowClose ( ) { } public void createWindowContents ( Shell shell ) { ( ( WorkbenchWindowConfigurer ) getWindowConfigurer ( ) ) . createDefaultContents ( shell ) ; } public Control createEmptyWindowContents ( Composite parent ) { return null ; } public boolean isDurableFolder ( String perspectiveId , String folderId ) { return false ; } public void dispose ( ) { } public IStatus saveState ( IMemento memento ) { return Status . OK_STATUS ; } public IStatus", "gt": "restoreState ( IMemento memento )", "prediction": ";\n", "label": 1}
{"id": 7143, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import java . awt . Color ; import java . util . List ; import org . jfree . chart . plot . PlotOrientation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . dataset . CategoryDataset ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . chart . plot . BarPlot ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; public class DJBarChartBuilder extends AbstractChartBuilder { public DJBarChartBuilder setOperation ( byte operation ) { this . chart . setOperation ( operation ) ; return this ; } public DJBarChartBuilder setLink ( DJHyperLink link ) { this . chart . setLink ( link ) ; return this ; } public DJBarChartBuilder setBackColor ( Color backColor ) { this . chart . getOptions ( ) . setBackColor ( backColor ) ; return this ; } public DJBarChartBuilder setHeight ( int height ) { this . chart . getOptions ( ) . setHeight ( height ) ; return this ; } public DJBarChartBuilder setWidth ( int width ) { this . chart . getOptions ( ) . setWidth ( width ) ; return this ; } public DJBarChartBuilder setCentered ( boolean centered ) { this . chart . getOptions ( ) . setCentered ( centered ) ; return this ; } public DJBarChartBuilder setPosition ( byte position ) { this . chart . getOptions ( ) . setPosition ( position ) ; return this ; } public DJBarChartBuilder setY ( int y ) { this . chart . getOptions ( ) . setY ( y ) ; return this ; } public DJBarChartBuilder setX ( int x ) { this . chart . getOptions ( ) . setX ( x ) ; return this ; } public DJBarChartBuilder setShowLegend ( boolean showLegend ) { this . chart . getOptions ( ) . setShowLegend ( new Boolean ( showLegend ) ) ; return this ; } public DJBarChartBuilder setTitleColor ( Color titleColor ) { this . chart . getOptions ( ) . setTitleColor ( titleColor ) ; return this ; } public DJBarChartBuilder setSubtitleColor ( Color subtitleColor ) { this . chart . getOptions ( ) . setSubtitleColor ( subtitleColor ) ; return this ; } public DJBarChartBuilder setLegendColor ( Color legendColor ) { this . chart . getOptions ( ) . setLegendColor ( legendColor ) ; return this ; } public DJBarChartBuilder setLegendBackgroundColor ( Color legendBackgroundColor ) { this . chart . getOptions ( ) . setLegendBackgroundColor ( legendBackgroundColor ) ; return this ; } public DJBarChartBuilder setTheme ( String theme ) { this . chart . getOptions ( ) . setTheme ( theme ) ; return this ; } public DJBarChartBuilder setTitleFont ( Font titleFont ) { this . chart . getOptions ( ) . setTitleFont ( titleFont ) ; return this ; } public DJBarChartBuilder setSubtitleFont ( Font subtitleFont ) { this . chart . getOptions ( ) . setSubtitleFont ( subtitleFont ) ; return this ; } public DJBarChartBuilder setLegendFont ( Font legendFont ) { this . chart . getOptions ( ) . setLegendFont ( legendFont ) ; return this ; } public DJBarChartBuilder setLegendPosition ( byte legendPosition ) { this . chart . getOptions ( ) . setLegendPosition ( legendPosition ) ; return this ; } public DJBarChartBuilder setTitlePosition ( byte titlePosition ) { this . chart . getOptions ( ) . setTitlePosition ( titlePosition ) ; return this ; } public DJBarChartBuilder setTitle ( String title ) { this . chart . getOptions ( ) . setTitleExpression ( new LiteralExpression ( title ) ) ; return this ; } public DJBarChartBuilder setTitle ( StringExpression titleExpression ) { this . chart . getOptions ( ) . setTitleExpression ( titleExpression ) ; return this ; } public DJBarChartBuilder setSubtitle ( String subtitle ) { this . chart . getOptions ( ) . setSubtitleExpression ( new", "gt": "LiteralExpression ( subtitle ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6326, "input": "<s> package org . eclipse . xtext . xdoc . generator ; import com . google . common . base . Objects ; import com . google . inject . Inject ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . URLDecoder ; import java . nio . ByteBuffer ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . nio . channels . WritableByteChannel ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . resource . URIConverter ; import org . eclipse . xtend2 . lib . StringConcatenation ; import org . eclipse . xtext . common . types . JvmAnnotationType ; import org . eclipse . xtext . common . types . JvmDeclaredType ; import org . eclipse . xtext . generator . IFileSystemAccess ; import org . eclipse . xtext . generator . IFileSystemAccessExtension2 ; import org . eclipse . xtext . xbase . lib . Exceptions ; import org . eclipse . xtext . xbase . lib . IterableExtensions ; import org . eclipse . xtext . xdoc . generator . AbstractSectionExtension ; import org . eclipse . xtext . xdoc . generator . EclipseHelpUriUtil ; import org . eclipse . xtext . xdoc . generator . Outlets ; import org . eclipse . xtext . xdoc . generator . PlainText ; import org . eclipse . xtext . xdoc . generator . TocGenerator ; import org . eclipse . xtext . xdoc . generator . util . EclipseNamingExtensions ; import org . eclipse . xtext . xdoc . generator . util . GitExtensions ; import org . eclipse . xtext . xdoc . generator . util . JavaDocExtension ; import org . eclipse . xtext . xdoc . generator . util . Utils ; import org . eclipse . xtext . xdoc . xdoc . AbstractSection ; import org . eclipse . xtext . xdoc . xdoc . Anchor ; import org . eclipse . xtext . xdoc . xdoc . Chapter ; import org . eclipse . xtext . xdoc . xdoc . Code ; import org . eclipse . xtext . xdoc . xdoc . CodeBlock ; import org . eclipse . xtext . xdoc . xdoc . CodeRef ; import org . eclipse . xtext . xdoc . xdoc . Document ; import org . eclipse . xtext . xdoc . xdoc . Emphasize ; import org . eclipse . xtext . xdoc . xdoc . Identifiable ; import org . eclipse . xtext . xdoc . xdoc . ImageRef ; import org . eclipse . xtext . xdoc . xdoc . Item ; import org . eclipse . xtext . xdoc . xdoc . LangDef ; import org . eclipse . xtext . xdoc . xdoc . Link ; import org . eclipse . xtext . xdoc . xdoc . MarkupInCode ; import org . eclipse . xtext . xdoc . xdoc . OrderedList ; import org . eclipse . xtext . xdoc . xdoc . Part ; import org . eclipse . xtext . xdoc . xdoc . Ref ; import org . eclipse . xtext . xdoc . xdoc . Section ; import org . eclipse . xtext . xdoc . xdoc . Section2 ; import org . eclipse . xtext . xdoc", "gt": ". xdoc . Section3 ;", "prediction": ";\n", "label": 1}
{"id": 2058, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ViewerNotification ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleSubNodeItemProvider extends SimpleNodeItemProvider implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleSubNodeItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; } return itemPropertyDescriptors ; } @ Override public Object getImage ( Object object ) { return overlayImage ( object , getResourceLocator ( ) . getImage ( \"full/obj16/SimpleSubNode\" ) ) ; } @ Override public String getText ( Object object ) { String label = ( ( SimpleSubNode ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( \"_UI_SimpleSubNode_type\" ) : label ; } @ Override public void notifyChanged ( Notification notification ) { updateChildren ( notification ) ; switch ( notification . getFeatureID ( SimpleSubNode . class ) ) { case SimplemappingsPackage . SIMPLE_SUB_NODE__CHILDREN : fireNotifyChanged ( new ViewerNotification ( notification , notification . getNotifier ( ) , false , true ) ) ; return ; }", "gt": "super . notifyChanged ( notification ) ;", "prediction": "}\n", "label": 0}
{"id": 6346, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . io . IOException ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . Query ; public class FastVectorHighlighter { public static final boolean DEFAULT_PHRASE_HIGHLIGHT = true ; public static final boolean DEFAULT_FIELD_MATCH = true ; private final boolean phraseHighlight ; private final boolean fieldMatch ; private final FragListBuilder fragListBuilder ; private final FragmentsBuilder fragmentsBuilder ; public FastVectorHighlighter ( ) { this ( DEFAULT_PHRASE_HIGHLIGHT , DEFAULT_FIELD_MATCH ) ; } public FastVectorHighlighter ( boolean phraseHighlight , boolean fieldMatch ) { this ( phraseHighlight , fieldMatch , new SimpleFragListBuilder ( ) , new ScoreOrderFragmentsBuilder ( ) ) ; } public FastVectorHighlighter ( boolean phraseHighlight , boolean fieldMatch , FragListBuilder fragListBuilder , FragmentsBuilder fragmentsBuilder ) { this . phraseHighlight = phraseHighlight ; this . fieldMatch = fieldMatch ; this . fragListBuilder = fragListBuilder ; this . fragmentsBuilder = fragmentsBuilder ; } public FieldQuery getFieldQuery ( Query query ) { return new FieldQuery ( query , phraseHighlight , fieldMatch ) ; } public final String getBestFragment ( final FieldQuery fieldQuery , IndexReader reader , int docId , String fieldName , int fragCharSize ) throws IOException { FieldFragList fieldFragList = getFieldFragList ( fieldQuery , reader , docId ,", "gt": "fieldName , fragCharSize ) ;", "prediction": ") ;\n", "label": 1}
{"id": 399, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf", "gt": ". ecore . EObject ;", "prediction": ";\n", "label": 0}
{"id": 6355, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . util . regex . Pattern ; import javax . servlet . http . Cookie ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . SettingStoreManager ; import org . eclipse . rap . rwt . service . ISettingStore ; import org . eclipse . rap . rwt . service . ISettingStoreFactory ; import org . eclipse . rap . rwt . testfixture . * ; public class SettingStoreManager_Test extends TestCase { private static class TestSettingStoreFactory implements ISettingStoreFactory { public ISettingStore createSettingStore ( String storeId ) { return null ; } } public void testGetStoreTwoRequests ( ) { ISettingStore store = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertNotNull ( store ) ; Fixture . fakeNewRequest ( ) ; ISettingStore sameStore = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertSame ( store , sameStore ) ; } public void testGetStoreTwoSessions ( ) { ISettingStore store = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertNotNull ( store ) ; fakeNewSession ( ) ; ISettingStore newStore = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertNotSame ( store , newStore ) ; } public void testGetStoreAfterLoad ( ) throws Exception { ISettingStore store = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertNotNull ( store ) ; String randomId = String . valueOf ( System . currentTimeMillis ( ) ) ; RWTFactory . getSettingStoreManager ( ) . getStore ( ) . loadById ( randomId ) ; assertSame ( store , RWTFactory . getSettingStoreManager ( ) . getStore ( ) ) ; } public void testLoadById ( ) throws Exception { String id = String . valueOf ( System . currentTimeMillis ( ) ) ; ISettingStore store = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; store . loadById ( id ) ; assertNull ( store . getAttribute ( \"key\" ) ) ; store . setAttribute ( \"key\" , \"value\" ) ; fakeNewSession ( ) ; ISettingStore newStore = RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; assertNull ( newStore . getAttribute ( \"key\" ) ) ; newStore . loadById ( id ) ; assertEquals ( \"value\" , newStore . getAttribute ( \"key\" ) ) ; } public void testGetStoreSetsCookie ( ) { RWTFactory . getSettingStoreManager ( ) . getStore ( ) ; TestResponse response = ( TestResponse ) ContextProvider . getResponse ( ) ; Cookie cookie = response . getCookie ( \"settingStore\" ) ; assertTrue ( cookie . getMaxAge ( ) > 0 ) ; assertTrue ( Pattern . matches ( \"[0-9]*_[0-9]*\" , cookie . getValue ( ) ) ) ; } public void testGetStoreReadsCookie ( ) { String storeId = \"123_456\" ;", "gt": "Cookie cookie = new Cookie ( \"settingStore\" , storeId ) ;", "prediction": "}\n", "label": 1}
{"id": 2021, "input": "<s> package dk . brics . automaton ; import java . io . IOException ; public interface AutomatonProvider { public", "gt": "Automaton getAutomaton ( String name ) throws IOException ;", "prediction": ";\n", "label": 0}
{"id": 6368, "input": "<s> package io . beancounter . commons . camel . tests ; import org . apache . camel . builder . RouteBuilder ; public class KestrelRoute extends RouteBuilder { private String host ; private String message ; public void configure ( ) { from ( \"timer://foo?repeatCount=1\" ) . setBody ( constant ( message ) ) . to ( \"log:TestHelper?level=DEBUG&showAll=true&multiline=true\" ) . to ( \"kestrel://\" + host ) ; }", "gt": "public void setHost ( String host )", "prediction": "}\n", "label": 1}
{"id": 7290, "input": "<s> public class TwrNullTests { public static void main ( String ... args ) { testNormalCompletion ( ) ; testNoSuppression ( ) ; } private static void testNormalCompletion ( ) { try ( AutoCloseable resource = null ) { return ; } catch ( Exception e ) { throw new AssertionError ( \"Should not be reached\" , e ) ; } } private static void testNoSuppression ( ) { try ( AutoCloseable resource = null ) { throw new java . io . IOException ( ) ; } catch ( java . io . IOException ioe ) { Throwable [ ] suppressed = ioe . getSuppressed ( ) ; if ( suppressed . length != 0 ) { throw new AssertionError ( \"Non-empty suppressed exceptions\" , ioe ) ; } } catch ( Exception e ) { throw new", "gt": "AssertionError ( \"Should not be reached\" , e ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6371, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . common . xmap . annotation . XNodeMap ; import org . nuxeo . common . xmap . annotation . XObject ; @ XObject ( value = \"configuration\" ) public class ImagingConfigurationDescriptor implements Serializable { private static", "gt": "final long serialVersionUID = 1L ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9107, "input": "<s> package org . ofbiz . base . util . collections ; import java . util . Map ; public abstract class GenericMapEntrySet < K , V , M extends GenericMap < K , V > > extends GenericMapSet < K , V , M , Map . Entry < K , V > > { public GenericMapEntrySet ( M source ) { super ( source ) ; } public boolean contains ( Object item ) { if ( item == null ) return false ; if ( ! ( item instanceof Map . Entry < ? , ? > ) ) return false ; Map . Entry < ? , ? > other = ( Map . Entry < ? , ? > ) item ; return contains ( other . getKey ( ) , other . getValue ( ) ) ; } protected abstract boolean contains ( Object key", "gt": ", Object value ) ;", "prediction": ")\n", "label": 0}
{"id": 6389, "input": "<s> package org . nuxeo . ecm . platform . forum . workflow ; public final class ForumConstants { @ Deprecated public static final String FORUM_MODERATORS_LIST = \"moderatorsList\" ; public static final String PENDING_STATE = \"moderation_pending\" ; public static final String PUBLISHED_STATE = \"moderation_published\" ; public static final String TRANSITION_TO_PUBLISHED_STATE = \"moderation_publish\" ; public static final String TRANSITION_TO_REJECTED_STATE = \"moderation_reject\" ; public static final String PROCESS_INSTANCE_NAME = \"forum_moderation\" ; public static final String COMMENT_ID = \"commentId\" ; public", "gt": "static final String THREAD_REF = \"threadRef\" ;", "prediction": "void ( ) ;\n", "label": 1}
{"id": 4177, "input": "<s> package org . bombusim . lime . logger ; import android . graphics . Color ; public class LoggerEvent { public String title ; public String message ; public int eventType ; public long timestamp ; public boolean expanded = false ; public LoggerEvent ( int eventType , String title , String message ) { this . eventType = eventType ; this . title = title ; this . message = message ; timestamp = System . currentTimeMillis ( ) ; } public LoggerEvent ( int eventType , String title ) { this ( eventType , title , null ) ; } public final static int XML = 0 ; public final static int XMLIN = 0 ; public final static int XMLOUT = 1 ; public final static int DEBUG = 10 ; public final static int INFO = 20 ; public final static int WARNING = 30 ; public final static int ERROR = 90 ; private final static int XMLIN_COLOR = Color . GREEN ; private final static int XMLOUT_COLOR = Color . CYAN ; private final static int DEBUG_COLOR = Color . LTGRAY ; private", "gt": "final static int INFO_COLOR = Color . WHITE ;", "prediction": ";\n", "label": 0}
{"id": 6408, "input": "<s> package org . mitre . oauth2 . service ; import java . util . Collection ; import org . mitre . oauth2 . model . ClientDetailsEntity ; import org . springframework . security . oauth2 . common . exceptions . OAuth2Exception ; import org . springframework . security . oauth2 . provider . ClientDetailsService ; public interface ClientDetailsEntityService extends ClientDetailsService { public ClientDetailsEntity saveNewClient ( ClientDetailsEntity client ) ; public ClientDetailsEntity getClientById ( Long id ) ; public ClientDetailsEntity loadClientByClientId ( String clientId ) throws OAuth2Exception ; public void deleteClient ( ClientDetailsEntity client ) ;", "gt": "public ClientDetailsEntity updateClient ( ClientDetailsEntity oldClient , ClientDetailsEntity newClient ) ;", "prediction": "}\n", "label": 1}
{"id": 5328, "input": "<s> package dk . brics . automaton ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashMap ; import java . util . IdentityHashMap ; final public class StringUnionOperations { public final static Comparator < CharSequence > LEXICOGRAPHIC_ORDER = new Comparator < CharSequence > ( ) { public int compare ( CharSequence s1 , CharSequence s2 ) { final int lens1 = s1 . length ( ) ; final int lens2 = s2 . length ( ) ; final int max = Math . min ( lens1 , lens2 ) ; for ( int i = 0 ; i < max ; i ++ ) { final char c1 = s1 . charAt ( i ) ; final char c2 = s2 . charAt ( i ) ; if ( c1 != c2 ) return c1 - c2 ; } return lens1 - lens2 ; } } ; final static class State { private final static char [ ] NO_LABELS = new char [ 0 ] ; private final static State [ ] NO_STATES = new State [ 0 ] ; char [ ] labels = NO_LABELS ; State [ ] states = NO_STATES ; boolean is_final ; public State getState ( char label ) { final int index = Arrays . binarySearch ( labels , label ) ; return index >= 0 ? states [ index ] : null ; } public char [ ] getTransitionLabels ( ) { return this . labels ; } public State [ ] getStates ( ) { return this . states ; } @ Override public boolean equals ( Object obj ) { final State other = ( State ) obj ; return is_final == other . is_final && Arrays . equals ( this . labels , other . labels ) && referenceEquals ( this . states , other . states ) ; } public boolean hasChildren ( ) { return labels . length > 0 ; } public boolean isFinal ( ) { return is_final ; } @ Override public int hashCode ( ) { int hash = is_final ? 1 : 0 ; hash ^= hash * 31 + this . labels . length ; for ( char c : this . labels ) hash ^= hash * 31 + c ; for ( State s : this . states ) { hash ^= System . identityHashCode ( s ) ; } return hash ; } State", "gt": "newState ( char label )", "prediction": "( ) ;\n", "label": 0}
{"id": 6416, "input": "<s> package org . fuzzydb . io . packet . layer1 ; import org . fuzzydb . io . core . MessageSource ; import org . fuzzydb .", "gt": "io . packet . CommsStack ;", "prediction": ";\n", "label": 1}
{"id": 1133, "input": "<s> import java . util . * ; class T6762569b { < T > void m ( T t , List < ? super List < T > > list ) { } void test ( List < ? super List < ?", "gt": "extends Number > > list )", "prediction": ")\n", "label": 0}
{"id": 6419, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . widgets . Button ; public class ButtonTextProperty extends WidgetStringValueProperty { String doGetStringValue ( Object source ) { return ( ( Button ) source ) . getText ( ) ; } void doSetStringValue ( Object source , String value ) { ( ( Button ) source ) . setText (", "gt": "value == null ? \"\" : value ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5963, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . lang . annotation . * ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . * ; import sun . reflect . annotation . * ; import com . sun . mirror . type . TypeMirror ; import com . sun . mirror . type . MirroredTypeException ; import com . sun . mirror . type . MirroredTypesException ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Pair ; @ SuppressWarnings ( \"deprecation\" ) class AnnotationProxyMaker { private final AptEnv env ; private final Attribute . Compound attrs ; private final Class < ? extends Annotation > annoType ; private AnnotationProxyMaker ( AptEnv env , Attribute . Compound attrs , Class < ? extends Annotation > annoType ) { this . env = env ; this . attrs = attrs ; this . annoType = annoType ; } public static < A extends Annotation > A generateAnnotation ( AptEnv env , Attribute . Compound attrs , Class < A > annoType ) { AnnotationProxyMaker apm = new AnnotationProxyMaker ( env , attrs , annoType ) ; return annoType . cast ( apm . generateAnnotation ( ) ) ; } private Annotation generateAnnotation ( ) { return AnnotationParser . annotationForMap ( annoType , getAllReflectedValues ( ) ) ; } private Map < String , Object > getAllReflectedValues ( ) { Map < String , Object > res = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < MethodSymbol , Attribute > entry : getAllValues ( ) . entrySet ( ) ) { MethodSymbol meth = entry . getKey ( ) ; Object value = generateValue ( meth , entry . getValue ( ) ) ; if ( value != null ) { res . put ( meth . name . toString ( ) , value ) ; } else { } } return res ; } private", "gt": "Map < MethodSymbol , Attribute > getAllValues ( )", "prediction": "}\n", "label": 0}
{"id": 6425, "input": "<s> package org . seage . metaheuristic . fireflies ; public interface Move {", "gt": "public void operateOn ( Solution soln ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 7997, "input": "<s> package test . annotation ; import java . lang . annotation . * ; @ Retention ( RetentionPolicy . RUNTIME ) public @ interface TestAnnotation {", "gt": "int test ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 6448, "input": "<s> package org . nuxeo . ecm . platform . tag ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . security . auth . login . LoginContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . common . utils . StringUtils ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . core . api . IterableQueryResult ; import org . nuxeo . ecm . core . api . UnrestrictedSessionRunner ; import org . nuxeo . ecm . core . api . repository . RepositoryManager ; import org . nuxeo . ecm . core . query . sql . NXQL ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . model . DefaultComponent ; public class TagServiceImpl extends DefaultComponent implements TagService { private static final Log log = LogFactory . getLog ( TagServiceImpl . class ) ; public static final String NXTAG = TagQueryMaker . NXTAG ; private Boolean enabled ; public boolean isEnabled ( ) { if ( enabled == null ) { enabled = Boolean . FALSE ; LoginContext lc = null ; try { lc = Framework . login ( ) ; RepositoryManager rm = Framework . getService ( RepositoryManager . class ) ; if ( rm . getDefaultRepository ( ) . supportsTags ( ) ) { log . debug ( \"Activating TagService\" ) ; enabled = Boolean . TRUE ; } else { log . warn ( \"Default repository does not support Tag feature: \" + \"Tag service won't be available.\" ) ; } } catch ( Exception e ) { log . error ( \"Unable to test repository for Tag feature.\" , e ) ; } finally { if ( lc != null ) { try { lc . logout ( ) ; } catch ( Exception e ) { log . error ( e , e ) ; } } } } return enabled . booleanValue ( ) ; } protected static String getUsername ( CoreSession session ) throws ClientException { if ( session == null ) { throw new ClientException ( \"No session available\" ) ; } return session . getPrincipal ( ) . getName ( ) . replace ( \"'\" , \"\" ) ; } protected static String cleanLabel ( String label , boolean allowPercent ) throws ClientException { if ( label == null ) { throw new ClientException ( \"Invalid empty tag\" ) ; } label = label . toLowerCase ( ) ; label = label . replace ( \" \" , \"\" ) ; label = label . replace ( \"\\\\\" , \"\" ) ; label = label . replace ( \"'\" , \"\" ) ; if ( ! allowPercent ) { label = label . replace ( \"%\" , \"\" ) ; } if ( label . length ( ) == 0 ) { throw new ClientException ( \"Invalid empty tag\" ) ; } return label ; } public void tag ( CoreSession session , String docId , String label , String username ) throws ClientException { UnrestrictedAddTagging r = new UnrestrictedAddTagging ( session , docId , label , username ) ; r . runUnrestricted ( ) ; } protected static class UnrestrictedAddTagging extends UnrestrictedSessionRunner { private final String docId ; private final String label ; private final String username ; protected UnrestrictedAddTagging ( CoreSession session , String docId , String label , String username ) throws ClientException { super ( session ) ; this . docId = docId ; this . label = cleanLabel ( label , false ) ; this . username = username == null ? null : username . replace ( \"'\" , \"\" ) ; } @ Override public void run ( ) throws ClientException { String tagId = null ; String query = String . format ( \"SELECT ecm:uuid FROM Tag WHERE tag:label = '%s' AND ecm:isProxy = 0\" , label ) ; IterableQueryResult res = session . queryAndFetch", "gt": "( query , NXQL . NXQL ) ;", "prediction": ";\n", "label": 1}
{"id": 5995, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; class ModulesClassLoader extends ClassLoader { static class CachedTOCJar { File jar ; Set < String > contents = new HashSet < String > ( ) ; Set < String > packages = new HashSet < String > ( ) ; CachedTOCJar ( File jar ) { this . jar = jar ; try { ZipFile zf = new ZipFile ( jar ) ; try { Enumeration < ? extends ZipEntry > entries = zf . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; if ( ! entry . isDirectory ( ) ) { packages . add ( getPackageName ( entry . getName ( ) ) ) ; contents . add ( entry . getName ( ) ) ; } } } finally { zf . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } private String getPackageName ( String name ) { int lastSlash = name . lastIndexOf ( '/' ) ; if ( lastSlash == - 1 ) return \"\" ; return name . substring ( 0 , lastSlash ) ; } boolean containsFile ( String path ) { return contents . contains ( path ) ; } boolean containsPackage ( String path ) { return packages . contains ( path ) ; } byte [ ] getContents ( String path ) { try { ZipFile zf = new ZipFile ( jar ) ; try { ZipEntry entry = zf . getEntry ( path ) ; if ( entry != null ) return loadFile ( zf . getInputStream ( entry ) , ( int ) entry . getSize ( ) ) ; } finally { zf . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } throw new RuntimeException ( \"Missing entry: \" + path + \" in jar file: \" + jar . getPath ( ) ) ; } private byte [ ] loadFile ( InputStream inputStream , int size ) throws IOException { byte [ ] buf = new byte [ size ] ; try { int read ; int offset = 0 ; while ( offset != size && ( read = inputStream . read ( buf , offset , size - offset ) ) >= 0 ) { offset += read ; } return buf ; } finally { inputStream . close ( ) ; } } } private List < CachedTOCJar > jars = new LinkedList < CachedTOCJar > ( ) ; @ Override protected Class < ? > findClass ( String name ) throws ClassNotFoundException { String path = name . replace ( '.' , '/' ) . concat ( \".class\" ) ; for ( CachedTOCJar jar : jars ) { if ( jar . containsFile ( path ) ) { byte", "gt": "[ ] contents = jar . getContents ( path ) ;", "prediction": ";\n", "label": 0}
{"id": 6462, "input": "<s> package org . springframework . tenancy . datasource ; import java . io . PrintWriter ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . Statement ; import javax . sql . DataSource ; public abstract class AbstractDatabaseSwitchingDataSource implements DataSource { public static enum Language { HSQL ( \"SET SCHEMA \" , \"'\" ) , MYSQL ( \"USE \" , \"`\" ) , ORACLE ( \"ALTER SESSION SET CURRENT_SCHEMA=\" , \"\\\"\" ) ; private final String switchCommand ; private final String quoteChar ; private Language ( String switchCommand , String quoteChar ) { this . switchCommand = switchCommand ; this . quoteChar = quoteChar ; } public String switchDatabase ( String dbName ) { String query = switchCommand + quoteChar + dbName + quoteChar ; if ( this . name ( ) . equals ( ORACLE . name ( ) ) ) { return query ; } else { return query + \";\" ; } } } ; protected DataSource wrappedDataSource ; protected Language language = Language . MYSQL ; public void setLanguage ( Language l ) { this . language = l ; } @ Override public PrintWriter getLogWriter ( ) throws SQLException { return wrappedDataSource . getLogWriter ( ) ; } @ Override public int getLoginTimeout ( ) throws SQLException { return wrappedDataSource . getLoginTimeout ( ) ; } @ Override public void setLogWriter ( PrintWriter arg0 ) throws SQLException { wrappedDataSource . setLogWriter ( arg0 ) ; } @ Override public void setLoginTimeout ( int arg0 ) throws SQLException { wrappedDataSource . setLoginTimeout ( arg0 ) ; } @ Override public boolean isWrapperFor ( Class < ? > iface ) throws SQLException { return wrappedDataSource . isWrapperFor ( iface ) ; } @ Override public < T > T unwrap ( Class < T > iface ) throws SQLException { return wrappedDataSource . unwrap ( iface ) ; } @ Override public Connection getConnection ( ) throws SQLException { Connection con = wrappedDataSource . getConnection ( ) ; return switchDatabase ( con ) ; }", "gt": "protected Connection switchDatabase ( Connection con ) throws SQLException", "prediction": "}\n", "label": 1}
{"id": 1899, "input": "<s> package org . ofbiz . party . communication ; import org . ofbiz . base . util . GeneralException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . nio . ByteBuffer ; import java . sql . Timestamp ; import java . util . Enumeration ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . mail . Address ; import javax . mail . BodyPart ; import javax . mail . MessagingException ; import javax . mail . internet . InternetAddress ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . common . email . NotificationServices ; import org . ofbiz . content . data . DataResourceWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . mail . MimeMessageWrapper ; public class CommunicationEventServices { public static final String module = CommunicationEventServices . class . getName ( ) ; public static final String resource = \"PartyErrorUiLabels\" ; public static Map < String , Object > sendCommEventAsEmail ( DispatchContext ctx , Map < String , ? extends Object > context ) { Delegator delegator = ctx . getDelegator ( ) ; LocalDispatcher dispatcher = ctx . getDispatcher ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; String communicationEventId = ( String ) context . get ( \"communicationEventId\" ) ; Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; List < Object > errorMessages = FastList . newInstance ( ) ; try { GenericValue communicationEvent = delegator . findOne ( \"CommunicationEvent\" , UtilMisc . toMap ( \"communicationEventId\" , communicationEventId ) , false ) ; if ( communicationEvent == null ) { String errMsg = UtilProperties . getMessage ( resource , \"commeventservices.communication_event_not_found_failure\" , locale ) ; return ServiceUtil . returnError ( errMsg + \" \" + communicationEventId ) ; } String communicationEventType = communicationEvent . getString ( \"communicationEventTypeId\" ) ; if ( communicationEventType == null || ! ( \"EMAIL_COMMUNICATION\" . equals ( communicationEventType ) || \"AUTO_EMAIL_COMM\" . equals ( communicationEventType ) ) ) { String errMsg = UtilProperties . getMessage ( resource , \"commeventservices.communication_event_must_be_email_for_email\" , locale ) ; return ServiceUtil . returnError ( errMsg + \" \" + communicationEventId ) ; } if ( ( communicationEvent . getRelatedOne ( \"FromContactMech\" , false ) == null ) || ( ! ( communicationEvent . getRelatedOne ( \"FromContactMech\" , false ) . getString ( \"contactMechTypeId\" ) . equals ( \"EMAIL_ADDRESS\" ) ) || ( communicationEvent . getRelatedOne ( \"FromContactMech\" , false ) . getString ( \"infoString\" ) == null ) ) ) { String errMsg = UtilProperties . getMessage ( resource , \"commeventservices.communication_event_from_contact_mech_must_be_email\" , locale ) ; return ServiceUtil . returnError ( errMsg + \" \" + communicationEventId ) ; } if ( UtilValidate . isEmpty ( communicationEvent . getString ( \"subject\" ) ) ) { communicationEvent . put", "gt": "( \"subject\" , \" \" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6469, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import org . eclipse . rap . rwt . internal . theme . QxIdentifier ; import junit . framework . TestCase ; public class QxIdentifier_Test extends TestCase { public void testCreate ( ) { QxIdentifier identifier = new QxIdentifier ( \"line-through\" ) ; assertEquals ( \"line-through\" , identifier . value ) ; } public void testDefaultString ( ) { QxIdentifier identifier = new QxIdentifier ( \"line-through\" ) ; assertEquals ( \"line-through\" , identifier . toDefaultString ( ) ) ; } public void testEquals ( ) { QxIdentifier identifier1", "gt": "= new QxIdentifier ( \"line-through\" ) ;", "prediction": ";\n", "label": 1}
{"id": 6204, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . Header ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class HeaderImpl extends ReportAttributeImpl implements Header { protected HeaderImpl ( ) { super ( ) ; } @ Override", "gt": "protected EClass eStaticClass ( )", "prediction": "}\n", "label": 0}
{"id": 6474, "input": "<s> package org . agoncal . book . javaee7 . chapter19 ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; import javax . xml . bind . annotation . XmlElement ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class OrderLine { @ XmlAttribute private String item ; @ XmlElement ( name = \"unit_price\" ) private Double unitPrice ; @ XmlAttribute private Integer quantity ; public OrderLine ( ) { } public OrderLine ( String item , Double unitPrice , Integer quantity ) { this . item = item ; this . unitPrice = unitPrice ; this . quantity = quantity ; } public String getItem ( ) { return item ; } public void setItem ( String item ) { this . item = item ; } public Double getUnitPrice ( ) { return unitPrice ; } public void setUnitPrice ( Double unitPrice ) { this . unitPrice = unitPrice ; } public Integer getQuantity ( ) { return quantity ; } public void", "gt": "setQuantity ( Integer quantity )", "prediction": "( )\n", "label": 1}
{"id": 9251, "input": "<s> package com . sun . tools . javap ; import java . io . PrintWriter ; import java . nio . charset . Charset ; import javax . tools . DiagnosticListener ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . util . Context ; public class JavapFileManager extends JavacFileManager { private JavapFileManager ( Context context , Charset charset ) { super ( context , true , charset ) ; setIgnoreSymbolFile ( true ) ; } public static JavapFileManager create ( final DiagnosticListener < ? super JavaFileObject > dl , PrintWriter log ) { Context javac_context = new Context ( ) ; if ( dl != null ) javac_context . put ( DiagnosticListener . class , dl ) ; javac_context . put ( com . sun . tools . javac . util . Log . outKey , log ) ; return new JavapFileManager (", "gt": "javac_context , null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6496, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor . text ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . jface . text . rules . IRule ; import org . eclipse . jface . text . rules . PatternRule ; import org . eclipse . jface . text . rules . RuleBasedScanner ; import org . eclipse . jface . text . rules . Token ; import org . eclipse . jface . text . rules . WhitespaceRule ; import org . eclipse . jface . text . rules . WordPatternRule ; import org . eclipse . jface . text . rules . WordRule ; import com . googlecode . veloeclipse . vaulttec . ui . IColorConstants ; import com . googlecode . veloeclipse . vaulttec . ui . VelocityColorProvider ; import com . googlecode . veloeclipse . vaulttec . ui . editor . VelocityEditorEnvironment ; import com . googlecode . veloeclipse . vaulttec . ui . model . Directive ; public class VelocityCodeScanner extends RuleBasedScanner { public VelocityCodeScanner ( VelocityColorProvider manager ) { List rules = new ArrayList ( ) ; rules . add ( new WhitespaceRule ( new WhitespaceDetector ( ) ) ) ; Token token = ( Token ) manager . getToken ( IColorConstants . DIRECTIVE ) ; WordRule wordRule = new WordRule ( new DirectiveDetector ( ) , token ) ; token = ( Token ) manager . getToken ( IColorConstants . DIRECTIVE ) ; String [ ] directives = Directive . DIRECTIVES ; for ( int i = directives . length - 1 ; i >= 0 ; i -- ) { wordRule . addWord ( directives [ i ] , token ) ; } Iterator userDirectives = VelocityEditorEnvironment . getParser ( ) . getUserDirectives ( ) . iterator ( ) ; while ( userDirectives . hasNext ( ) ) { wordRule . addWord ( ( String ) userDirectives . next ( ) , token ) ; } rules . add ( wordRule ) ; token = ( Token ) manager . getToken ( IColorConstants . REFERENCE ) ; rules . add ( new PatternRule ( \"$!{\" , \"}\" , token , ( char ) 0 , true ) ) ; rules . add ( new PatternRule ( \"${\" , \"}\" , token , ( char ) 0 , true ) ) ; token = ( Token ) manager . getToken ( IColorConstants . REFERENCE ) ; rules . add ( new WordPatternRule ( new IdentifierDetector ( ) ,", "gt": "\"$!\" , null , token ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4941, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . resource . impl . ResourceSetImpl ; import org . eclipse . gmf . internal . bridge . wizards . pages . simple . DomainModelSelectionPage ; import org . eclipse . gmf . internal . common . ui . ResourceLocationProvider ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . ui . INewWizard ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . actions . WorkspaceModifyOperation ; public class SimpleMapEditorCreationWizard extends Wizard implements INewWizard { private IWorkbench workbench ; protected IStructuredSelection selection ; protected SimplemapCreationWizardPage diagramModelFilePage ; protected DomainModelSelectionPage domainModelSelectionPage ; protected Resource diagram ; private boolean openNewlyCreatedDiagramEditor = true ; public IWorkbench getWorkbench ( ) { return workbench ; } public IStructuredSelection getSelection ( ) { return selection ; } public final Resource getDiagram ( ) { return diagram ; } public final boolean isOpenNewlyCreatedDiagramEditor ( ) { return openNewlyCreatedDiagramEditor ; } public void setOpenNewlyCreatedDiagramEditor ( boolean openNewlyCreatedDiagramEditor ) { this . openNewlyCreatedDiagramEditor = openNewlyCreatedDiagramEditor ; } public void init ( IWorkbench workbench , IStructuredSelection selection ) { this . workbench = workbench ; this . selection = selection ; setWindowTitle ( Messages . SimplemapCreationWizardTitle ) ; setDefaultPageImageDescriptor ( SimplemapDiagramEditorPlugin . getBundledImageDescriptor ( \"icons/wizban/NewSimplemappingsWizard.gif\" ) ) ; setNeedsProgressMonitor ( true ) ; } public void addPages ( ) { ResourceLocationProvider rloc = new ResourceLocationProvider ( selection ) ; ResourceSet resourceSet = new ResourceSetImpl ( ) ; diagramModelFilePage = new SimplemapCreationWizardPage ( \"DiagramModelFile\" , getSelection ( ) , \"simplemappings\" ) ; diagramModelFilePage . setTitle ( Messages . SimplemapCreationWizard_DiagramModelFilePageTitle ) ; diagramModelFilePage . setDescription ( Messages . SimplemapCreationWizard_DiagramModelFilePageDescription ) ; addPage ( diagramModelFilePage ) ; domainModelSelectionPage = new DomainModelSelectionPage ( \"DomainModelSelectionPage\" , rloc , resourceSet ) ; domainModelSelectionPage . setTitle ( org . eclipse . gmf . internal . bridge . wizards . Messages . SimpleModelWizardDomainModelSelectionPageTitle ) ; domainModelSelectionPage . setDescription ( org . eclipse . gmf . internal . bridge . wizards . Messages . SimpleModelWizardDomainModelSelectionPageDesc ) ; domainModelSelectionPage . setModelRequired ( true ) ; addPage ( domainModelSelectionPage ) ; } public boolean performFinish ( ) { IRunnableWithProgress op =", "gt": "new WorkspaceModifyOperation ( null )", "prediction": ";\n", "label": 0}
{"id": 6499, "input": "<s> package audio ; import java . io . File ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . Clip ; import javax . sound . sampled . DataLine ; import javax . sound . sampled . Line ; public class SoundEffect { String name ; Line line ; Clip clip ; AudioInputStream ais ; boolean loop ; public SoundEffect ( String s ) { name = s ; try { File f = new File ( \"data/audio/fx/nature.wav\" ) ; ais = AudioSystem . getAudioInputStream ( f ) ; AudioFormat af = ais . getFormat ( ) ; clip = ( Clip ) AudioSystem . getLine ( new DataLine . Info ( Clip . class , ais . getFormat ( ) ) ) ; clip . open ( ais ) ; } catch ( Exception e ) { System . out . println ( ) ; e . printStackTrace ( ) ; } } public", "gt": "void setLoop ( boolean loop )", "prediction": "}\n", "label": 1}
{"id": 8089, "input": "<s> package org . bombusim . lime . data ; import java . util . ArrayList ; import java . util . Collections ; public class RosterGroup implements Comparable < RosterGroup > { public String rJid ; public String groupName ; public ArrayList < Contact > contacts ; public boolean collapsed ; public int onlineCount ; public RosterGroup ( String name , String rJid ) { this . groupName = name ; this . rJid = rJid ; contacts = new ArrayList < Contact > ( ) ; } @ Override public int compareTo ( RosterGroup another ) { return groupName", "gt": ". compareToIgnoreCase ( another . groupName ) ;", "prediction": ";\n", "label": 0}
{"id": 6504, "input": "<s> package org . eclipse . jface . internal . provisional . action ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . action . ToolBarContributionItem ; public class ToolBarContributionItem2 extends ToolBarContributionItem implements IToolBarContributionItem { public ToolBarContributionItem2 ( ) { super ( ) ; } public ToolBarContributionItem2 ( IToolBarManager toolBarManager ) { super ( toolBarManager ) ; } public ToolBarContributionItem2 (", "gt": "IToolBarManager toolBarManager , String id )", "prediction": ")\n", "label": 1}
{"id": 9256, "input": "<s> import java . io . DataInputStream ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import com . sun . tools . classfile . AccessFlags ; import com . sun . tools . classfile . ClassFile ; import com . sun . tools . classfile . ConstantPoolException ; import com . sun . tools . classfile . Method ; import java . io . BufferedReader ; import java . io . FileInputStream ; import java . io . InputStreamReader ; import java . util . LinkedHashSet ; public class CompareTest { String [ ] [ ] testCases = { { } , { \"-jni\" } , } ; public static void main ( String ... args ) throws Exception { new CompareTest ( ) . run ( args ) ; } public void run ( String ... args ) throws Exception { old_javah_cmd = new File ( args [ 0 ] ) ; rt_jar = new File ( args [ 1 ] ) ; Set < String > testClasses ; if ( args . length > 2 ) { testClasses = new LinkedHashSet < String > ( Arrays . asList ( Arrays . copyOfRange ( args , 2 , args . length ) ) ) ; } else testClasses = getNativeClasses ( new JarFile ( rt_jar ) ) ; for ( String [ ] options : testCases ) { for ( String name : testClasses ) { test ( Arrays . asList ( options ) , rt_jar , name ) ; } } if ( errors == 0 ) System . out . println ( count + \" tests passed\" ) ; else throw new Exception ( errors + \"/\" + count + \" tests failed\" ) ; } public void test ( List < String > options , File bootclasspath , String className ) throws IOException , InterruptedException { System . err . println ( \"test: \" + options + \" \" + className ) ; count ++ ; testOptions = options ; testClassName = className ; File oldOutDir = initDir ( file ( new File ( \"old\" ) , className ) ) ; int old_rc = old_javah ( options , oldOutDir , bootclasspath , className ) ; File newOutDir = initDir ( file ( new File ( \"new\" ) , className ) ) ; int new_rc = new_javah ( options , newOutDir , bootclasspath , className ) ; if ( old_rc != new_rc ) error ( \"return codes differ; old: \" + old_rc + \", new: \" + new_rc ) ; compare ( oldOutDir , newOutDir ) ; } int old_javah ( List < String > options , File outDir , File bootclasspath , String className ) throws IOException , InterruptedException { List < String > cmd = new ArrayList < String > ( ) ; cmd . add ( old_javah_cmd . getPath ( ) ) ; cmd . addAll ( options ) ; cmd . add ( \"-d\" ) ; cmd . add ( outDir . getPath ( ) ) ; cmd . add ( \"-bootclasspath\" ) ; cmd . add ( bootclasspath . getPath ( ) ) ; cmd . add ( className ) ; System . err . println ( \"old_javah: \" + cmd ) ; ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . redirectErrorStream ( true ) ; Process p = pb . start ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; StringBuilder sb = new StringBuilder ( ) ; while ( ( line = in . readLine ( ) ) != null ) { sb . append ( line ) ; sb . append ( \"\\n\" ) ; } System . err . println ( \"old javah out: \" + sb . toString ( ) ) ; return p . waitFor ( ) ; } int new_javah ( List < String > options , File outDir , File bootclasspath , String className ) { List < String > args = new ArrayList < String > ( ) ; args . addAll ( options ) ; args . add ( \"-d\" ) ; args . add ( outDir . getPath ( ) ) ; args . add ( \"-bootclasspath\" ) ; args . add ( bootclasspath . getPath ( ) ) ; args . add ( className ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; int rc = com . sun . tools . javah . Main . run ( args . toArray ( new String [ args . size ( ) ] ) , pw ) ; pw . close ( ) ; System . err . println ( \"new javah out: \" + sw . toString ( ) ) ; return rc ; } Set < String > getNativeClasses ( JarFile jar ) throws IOException , ConstantPoolException { System . err . println ( \"getNativeClasses: \" + jar . getName ( ) ) ; Set < String > results = new TreeSet < String > ( ) ; Enumeration < JarEntry > e = jar . entries ( ) ; while ( e . hasMoreElements ( ) ) { JarEntry je = e . nextElement ( ) ; if ( isNativeClass ( jar , je ) ) { String name = je . getName ( ) ; results . add ( name . substring ( 0 , name . length ( ) - 6 ) . replace ( \"/\" , \".\" ) ) ; } } return results ; } boolean isNativeClass ( JarFile jar , JarEntry entry ) throws IOException , ConstantPoolException { String name = entry . getName ( ) ; if ( name . startsWith ( \"META-INF\" ) || ! name . endsWith ( \".class\" ) ) return false ; InputStream in = jar . getInputStream ( entry ) ; ClassFile cf = ClassFile . read ( in ) ; for ( int i = 0 ; i < cf . methods . length ; i ++ ) { Method m = cf . methods [ i ] ; if ( m . access_flags . is ( AccessFlags . ACC_NATIVE ) ) { return true ; } } return false ; } void compare ( File", "gt": "f1 , File f2 ) throws IOException", "prediction": ")\n", "label": 0}
{"id": 6511, "input": "<s> package org . jscsi . initiator . devices ; import static org . junit . Assert . assertEquals ; import java . util . Random ; import org . junit . After ; import org . junit . Before ; import org . junit . Ignore ; import org . junit . Test ; @ Ignore ( \"Lack of testembed, removing\" ) public class WriteBufferDeviceTest { private static final String TARGET_NAME = \"testing-xen2-disk1\" ; private static WriteBufferDevice device ; private final byte [ ] testDataBlock8kb ; private final byte [ ] testDataBlock128kb ; Random randomGenerator ; public WriteBufferDeviceTest ( ) { randomGenerator = new Random ( System . currentTimeMillis ( ) ) ; testDataBlock8kb = new byte [ 8 * 1024 ] ; randomGenerator . nextBytes ( testDataBlock8kb ) ; testDataBlock128kb = new byte [ 128 * 1024 ] ; randomGenerator . nextBytes ( testDataBlock128kb ) ; } @ Before public final void setUp ( ) throws Exception { device = new WriteBufferDevice ( new JSCSIDevice ( TARGET_NAME ) ) ; device . open ( ) ; } @ After public final void tearDown ( ) throws Exception { device . close ( ) ; } @ Test public final void testReadWriteBeginning8kb ( ) throws Exception { int writeBlockCount = 50 ; int blockFactor = testDataBlock8kb . length / device . getBlockSize ( ) ; long address = 0 ; for ( int i = 0 ; i < writeBlockCount ; i ++ ) { device . write ( address + i * blockFactor , testDataBlock8kb ) ; } device . flush ( ) ; for ( int j = 0 ; j < writeBlockCount ; j ++ ) { byte [ ] result = new byte [ testDataBlock8kb . length ] ; device . read ( address + j * blockFactor , result ) ; for ( int i = 0 ; i < testDataBlock8kb . length ; i ++ ) { assertEquals ( result [ i ] , testDataBlock8kb [ i ] ) ; } } } @ Test public final void testReadWriteBeginning128kb ( ) throws Exception { int writeBlockCount = 50 ; int blockFactor = testDataBlock128kb . length / device . getBlockSize ( ) ; long address = 0 ; for ( int i = 0 ; i < writeBlockCount ; i ++ ) { device . write ( address + i *", "gt": "blockFactor , testDataBlock128kb ) ;", "prediction": ") ;\n", "label": 1}
{"id": 335, "input": "<s> public class ProtectedAccess_3 { ProtectedAccess_3 ( ) { new Object ( ) { public void finalize ( ) throws Throwable { ProtectedAccess_3 . this . finalize ( ) ; } } ; } public", "gt": "static void main ( String [ ] argv )", "prediction": "void ( )\n", "label": 0}
{"id": 6512, "input": "<s> package org . seage . problem . tsp ; import org . seage . aal . algorithm . IPhenotypeEvaluator ; import org . seage . aal . data . ProblemInstanceInfo ; public class TspPhenotypeEvaluator implements IPhenotypeEvaluator { private static final long serialVersionUID = - 3361951575532763882L ; @ Override public double [ ] evaluate ( Object [ ] phenotypeSubject , ProblemInstanceInfo instance ) throws Exception { double tourLength = 0 ; City [ ] cities = ( ( TspProblemInstance ) instance ) . getCities ( ) ; int numCities = cities . length ; for ( int i = 0 ; i < numCities ; i ++ ) { int k = i + 1 ; if ( i == numCities - 1 ) k = 0 ; int ix1 = ( Integer ) phenotypeSubject [ i ] ; int ix2 = ( Integer ) phenotypeSubject [ k ] ; double x1 = cities [ ix1 ] . X ; double y1 = cities [ ix1 ] . Y ; double x2 = cities [ ix2 ] . X ; double y2 = cities [ ix2 ] . Y ; tourLength += Math . sqrt ( Math . pow ( x1 - x2 , 2 ) + Math . pow ( y1 - y2 , 2 ) ) ; } return new double [ ] { tourLength } ; } @ Override public int compare ( double [ ] o1 , double [ ] o2 ) { if ( o1 == null ) return - 1 ; if ( o2 == null ) return 1 ; int length = o1 . length <= o2 . length ? o1 . length", "gt": ": o2 . length ;", "prediction": ";\n", "label": 1}
{"id": 4970, "input": "<s> package com . sun . mirror . util ; import com . sun . mirror . declaration . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface Declarations { boolean hides ( MemberDeclaration", "gt": "sub , MemberDeclaration sup ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6515, "input": "<s> package org . eclipse . core . tests . harness ; import java . io . PrintWriter ; import java . util . * ; import junit . framework . * ; public class PerformanceTestResult extends TestResult { protected PrintWriter output ; protected ArrayList timerList = new ArrayList ( ) ; protected HashMap timers = new HashMap ( ) ; public PerformanceTestResult ( ) { this ( new PrintWriter ( System . out ) ) ; } public PerformanceTestResult ( PrintWriter outputStream ) { this . output = outputStream ; } public synchronized void endTest ( Test test ) { print ( ) ; } public synchronized void print ( ) { stopTimers ( ) ; printHeader ( output ) ; printErrors ( output ) ; printFailures ( output ) ; printTimings ( output ) ; } protected void printErrors ( PrintWriter out ) { int count = errorCount ( ) ; if ( count != 0 ) { if ( count == 1 ) out . println ( \"There was \" + count + \" error:\" ) ; else out . println ( \"There were \" + count + \" errors:\" ) ; int i = 1 ; for ( Enumeration e = errors ( ) ; e . hasMoreElements ( ) ; i ++ ) { TestFailure failure = ( TestFailure ) e . nextElement ( ) ; out . println ( i + \") \" + failure . failedTest ( ) ) ; failure . thrownException ( ) . printStackTrace ( out ) ; } } } protected void printFailures ( PrintWriter out ) { int count = failureCount ( ) ; if ( count != 0 ) { if ( count == 1 ) out . println ( \"There was \" + count + \" failure:\" ) ; else out . println ( \"There were \" + count + \" failures:\" ) ; int i = 1 ; for ( Enumeration e = failures ( ) ; e . hasMoreElements ( ) ; i ++ ) { TestFailure failure = ( TestFailure ) e . nextElement ( ) ; out . println ( i + \") \" + failure . failedTest ( ) ) ; failure . thrownException ( ) . printStackTrace ( out ) ; } } } protected void printHeader ( PrintWriter out ) { if ( wasSuccessful ( ) ) { out . println ( ) ; out . print ( \"OK\" ) ; out . println ( \" (\" + runCount ( ) + \" tests)\" ) ; } else { out . println ( ) ; out . println ( \"!!!FAILURES!!!\" ) ; out . println ( \"Test Results:\" ) ; out . println ( \"Run: \" + runCount ( ) + \" Failures: \" + failureCount ( ) + \" Errors: \" + errorCount ( ) ) ; } } protected void printTimings ( PrintWriter out ) { for ( Iterator it = timerList . iterator ( ) ; it . hasNext ( ) ; ) { PerformanceTimer timer = ( PerformanceTimer ) it . next ( ) ; out . println ( \"Timing \" + timer . getName ( ) + \" : \" + timer . getElapsedTime ( ) + \" ms \" ) ; } } public synchronized void startTest ( Test test ) { super . startTest ( test ) ; System . out . print ( \".\" ) ; } public synchronized void startTimer ( String timerName ) { PerformanceTimer timer = ( PerformanceTimer ) timers . get ( timerName ) ; if ( timer == null ) { timer = new PerformanceTimer ( timerName ) ; timers . put ( timerName , timer ) ; timerList . add ( timer ) ; } timer . startTiming ( ) ; } public synchronized void stopTimer ( String timerName ) { PerformanceTimer timer = ( PerformanceTimer ) timers . get ( timerName ) ; if ( timer == null ) { throw new Error ( timerName + \" is not a valid timer name \" ) ; }", "gt": "timer . stopTiming ( ) ;", "prediction": "}\n", "label": 1}
{"id": 5663, "input": "<s> package com . matburt . mobileorg . Synchronizers ; import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . security . SecureRandom ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; import java . util . regex . Pattern ; import javax . net . ssl . HostnameVerifier ; import javax . net . ssl . HttpsURLConnection ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLHandshakeException ; import javax . net . ssl . SSLSession ; import javax . net . ssl . X509TrustManager ; import android . content . Context ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . content . res . Resources ; import android . preference . PreferenceManager ; import android . util . Base64 ; import android . util . Log ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Gui . CertificateConflictActivity ; import com . matburt . mobileorg . util . FileUtils ; public class WebDAVSynchronizer implements SynchronizerInterface { class IntelligentX509TrustManager implements X509TrustManager { Context c ; public IntelligentX509TrustManager ( Context c ) { super ( ) ; this . c = c ; } public boolean validateCertificate ( int hash , String description ) { SharedPreferences appSettings = PreferenceManager . getDefaultSharedPreferences ( this . c ) ; Editor edit = appSettings . edit ( ) ; int existingHash = appSettings . getInt ( \"webCertHash\" , 0 ) ; if ( existingHash == 0 ) { Log . i ( \"MobileOrg\" , \"Storing new certificate\" ) ; edit . putInt ( \"webCertHash\" , hash ) ; edit . putString ( \"webCertDescr\" , description ) ; edit . commit ( ) ; return true ; } else if ( existingHash != hash ) { Log . i ( \"MobileOrg\" , \"Conflicting Certificate Hash\" ) ; edit . putInt ( \"webConflictHash\" , hash ) ; edit . putString ( \"webConflictHashDesc\" , description ) ; edit . commit ( ) ; return true ; } Log . i ( \"MobileOrg\" , \"Certificates match\" ) ; return true ; } public void checkClientTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { } public void checkServerTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException { for ( int i = 0 ; i < chain . length ; i ++ ) { String descr = chain [ i ] . toString ( ) ; int hash = chain [ i ] . hashCode ( ) ; Log . i ( \"MobileOrg\" , \"Validating certificate hash\" ) ; if ( ! this", "gt": ". validateCertificate ( hash , descr ) )", "prediction": ") ;\n", "label": 0}
{"id": 6550, "input": "<s> package org . gatein . common . i18n ; import org . gatein . common . text . CharBuffer ; import org . gatein . common . util . ConversionException ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . io . IOException ; public class BundleName { public BundleName ( String baseName ) { this ( baseName , \"\" , \"\" , \"\" ) ; } public BundleName ( String baseName , String language ) { this ( baseName , language , \"\" , \"\" ) ; } public BundleName ( String baseName , String language , String country ) { this ( baseName , language , country , \"\" ) ; } public BundleName ( String baseName , String language , String country , String variant ) { if ( baseName == null ) { throw new IllegalArgumentException ( ) ; } if ( language == null ) { throw new IllegalArgumentException ( ) ; } if ( country == null ) { throw new IllegalArgumentException ( ) ; } if ( variant == null ) { throw new IllegalArgumentException ( ) ; } this . baseName = baseName ; this . locale = new Locale ( language , country , variant ) ; } private final String baseName ; private final Locale locale ; public String getBaseName ( ) { return baseName ; } public Locale getLocale ( ) { return locale ; } public String getLanguage ( ) { return locale . getLanguage ( ) ; } public String getCountry ( ) { return locale . getCountry ( ) ; } public String getVariant ( ) { return locale . getVariant ( ) ; } public String toString ( ) { if ( locale . getLanguage ( ) . length ( ) == 0 && locale . getCountry ( ) . length ( ) == 0 ) { return baseName ; } else { CharBuffer buffer = new CharBuffer ( baseName . length ( ) + 15 ) ; buffer . append ( baseName ) ; buffer . append ( '_' ) ; try { LocaleFormat . DEFAULT . write ( locale , buffer ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } catch ( ConversionException e ) { throw new AssertionError ( e ) ; } return buffer . asString ( ) ; } } public static class Iterator implements java . util . Iterator < BundleName > { private BundleName name ; private int status ; public Iterator ( String baseName , Locale locale ) { String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; status = 8 + ( language . length ( ) > 0 ? 4 : 0 ) + ( country . length ( ) > 0 ? 2 : 0 ) + ( variant . length ( ) > 0 ? 1 : 0 ) ; switch ( status & 0x7 ) { case 0 : name = new BundleName ( baseName ) ; break ; case 1 : name = new BundleName ( baseName , \"\" , \"\" , variant ) ; break ; case 2 : name = new BundleName ( baseName , \"\" , variant , \"\" ) ; break ; case 3 : name = new BundleName ( baseName , \"\" , country , variant ) ; break ; case 4 : name = new BundleName ( baseName , language , \"\" , \"\" ) ; break ; case 5 : name = new BundleName ( baseName , language , \"\" , variant ) ; break ; case 6 : name = new BundleName ( baseName , language , country , \"\" ) ; break ; case 7 : name = new BundleName ( baseName , language , country , variant ) ; break ; default : throw new AssertionError ( \"Should not be here\" ) ; } } public boolean hasNext ( ) { return status != 0 ; } public BundleName next ( ) { if ( status >= 8 ) { status -= 8 ; } else { switch ( status ) { case 0 : throw new NoSuchElementException ( ) ; case 1 : name = new BundleName ( name . getBaseName ( ) ) ; status = 0 ; break ; case 2 : name = new BundleName ( name . getBaseName ( ) ) ; status = 0 ; break ; case 3 : name = new BundleName ( name . getBaseName ( ) , \"\" , name . getCountry ( ) ) ; status = 2 ; break ; case 4 : name = new BundleName ( name . getBaseName ( ) ) ; status = 0 ; break ; case 5 : name = new BundleName ( name . getBaseName ( ) , name . getLanguage ( ) ) ; status = 4 ; break ; case 6 : name = new BundleName ( name . getBaseName ( ) , name . getLanguage ( ) ) ; status = 4 ; break ; case 7 : name = new BundleName ( name . getBaseName ( ) , name . getLanguage ( ) , name . getCountry ( ) ) ; status = 6 ; break ; default : throw new AssertionError ( \"Should not be here\" ) ; } } return name ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } public static class Parser { public BundleName parse ( String s , int from , int to ) { if ( s == null ) { throw new IllegalArgumentException ( ) ; } if ( from < 0 ) { throw new IllegalArgumentException ( ) ; } if ( to <", "gt": "s . length ( ) )", "prediction": ")\n", "label": 1}
{"id": 7076, "input": "<s> public class Aggregate { static { System . out . println ( \"xxyzzy\" ) ; } private Aggregate ( ) { } private static double hypot ( double Berkeley , double SantaCruz ) { return 0.0 ; } public int hashcode ( ) { return 42 ; } public boolean equals ( Aggregate a ) { return this == a ; }", "gt": "public static void main ( String [ ] argv )", "prediction": "}\n", "label": 0}
{"id": 6552, "input": "<s> package org . eclipse . swt . internal . widgets . listkit ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . controlkit . ControlThemeAdapter ; import org", "gt": ". eclipse . swt . widgets . Control ;", "prediction": ";\n", "label": 1}
{"id": 4876, "input": "<s> package api . better ; import java . util . List ; public class Response { private List < Artist > artist ; private String downloadUrl ; private Number groupId ; private String groupName ; private Number groupYear ; private Number torrentId ; public List < Artist > getArtist ( ) { return this . artist ; } public String getDownloadUrl ( ) { return this . downloadUrl ; } public Number getGroupId ( ) { return this . groupId ; } public String getGroupName ( ) { return this . groupName ; } public Number getGroupYear ( ) { return this . groupYear ; } public Number getTorrentId ( ) { return this . torrentId ; }", "gt": "@ Override public String toString ( )", "prediction": "}\n", "label": 0}
{"id": 6557, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType .", "gt": "FIELD ) @ XmlType ( name = \"\" , propOrder =", "prediction": ") ;\n", "label": 1}
{"id": 1738, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . util . * ; public class Master { private Name origin ; private File file ; private Record last = null ; private long defaultTTL ; private Master included = null ; private Tokenizer st ; private int currentType ; private int currentDClass ; private long currentTTL ; private boolean needSOATTL ; private Generator generator ; private List generators ; private boolean noExpandGenerate ; Master ( File file , Name origin , long initialTTL ) throws IOException { if ( origin != null && ! origin . isAbsolute ( ) ) { throw new RelativeNameException ( origin ) ; } this . file = file ; st = new Tokenizer ( file ) ; this . origin = origin ; defaultTTL = initialTTL ; } public Master ( String filename , Name origin , long ttl ) throws IOException { this ( new File ( filename ) , origin , ttl ) ; } public Master ( String filename , Name origin ) throws IOException { this ( new File ( filename ) , origin , - 1 ) ; } public Master ( String filename ) throws IOException { this ( new File ( filename ) , null , - 1 ) ; } public Master ( InputStream in , Name origin , long ttl ) { if ( origin != null && ! origin . isAbsolute ( ) ) { throw new RelativeNameException ( origin ) ; } st = new Tokenizer ( in ) ; this . origin = origin ; defaultTTL = ttl ; } public Master ( InputStream in , Name origin ) { this ( in , origin , - 1 ) ; } public Master ( InputStream in ) { this ( in , null , - 1 ) ; } private Name parseName ( String s , Name origin ) throws TextParseException { try { return Name . fromString ( s , origin ) ; } catch ( TextParseException e ) { throw st . exception ( e . getMessage ( ) ) ; } } private void parseTTLClassAndType ( ) throws IOException { String s ; boolean seen_class = false ; seen_class = false ; s = st . getString ( ) ; if ( ( currentDClass = DClass . value ( s ) ) >= 0 ) { s = st . getString ( ) ; seen_class = true ; } currentTTL = - 1 ; try { currentTTL = TTL . parseTTL ( s ) ; s = st . getString ( ) ; } catch ( NumberFormatException e ) { if ( defaultTTL >= 0 ) currentTTL = defaultTTL ; else if ( last != null ) currentTTL = last . getTTL ( ) ; } if ( ! seen_class ) { if ( ( currentDClass = DClass . value ( s ) ) >= 0 ) { s = st . getString ( ) ; } else { currentDClass = DClass . IN ; } } if ( ( currentType = Type . value ( s ) ) < 0 ) throw st . exception ( \"Invalid type '\" + s + \"'\" ) ; if ( currentTTL < 0 ) { if ( currentType != Type . SOA ) throw st . exception ( \"missing TTL\" ) ; needSOATTL = true ; currentTTL = 0 ; } } private long parseUInt32 ( String s ) { if ( ! Character . isDigit ( s . charAt", "gt": "( 0 ) ) ) return - 1 ;", "prediction": ") ;\n", "label": 0}
{"id": 6559, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public class KeyEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public char character ; public int keyCode ; public int stateMask ; public boolean doit ; public KeyEvent ( Event event ) { super ( event ) ; character = event . character ; keyCode = event . keyCode ; stateMask = event . stateMask ; doit = event . doit ; } @ Override public String toString ( ) { String", "gt": "string = super . toString ( ) ;", "prediction": "\n", "label": 1}
{"id": 5074, "input": "<s> public class TestNavagation extends JavadocTester { private static final String BUG_ID = \"4131628-4664607\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"A.html\" , \"<li>Prev Class</li>\" } , { BUG_ID + FS + \"pkg\" + FS + \"A.html\" , \"<a href=\\\"../pkg/C.html\\\" title=\\\"class in pkg\\\"><span class=\\\"strong\\\">Next Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<a href=\\\"../pkg/A.html\\\" title=\\\"annotation in pkg\\\"><span class=\\\"strong\\\">Prev Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<a href=\\\"../pkg/E.html\\\" title=\\\"enum in pkg\\\"><span class=\\\"strong\\\">Next Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"E.html\" , \"<a href=\\\"../pkg/C.html\\\" title=\\\"class in pkg\\\"><span class=\\\"strong\\\">Prev Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"E.html\" , \"<a href=\\\"../pkg/I.html\\\" title=\\\"interface in pkg\\\"><span class=\\\"strong\\\">Next Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"I.html\" , \"<a href=\\\"../pkg/E.html\\\" title=\\\"enum in pkg\\\"><span class=\\\"strong\\\">Prev Class</span></a>\" } , { BUG_ID + FS + \"pkg\" + FS + \"I.html\" , \"<li>Next Class</li>\" } , { BUG_ID + FS + \"pkg\" + FS + \"I.html\" , \"<a href=\\\"#skip-navbar_top\\\" title=\\\"Skip navigation links\\\"></a><a name=\\\"navbar_top_firstrow\\\">\" + NL + \"<!--   -->\" + NL + \"</a>\" } } ; private static final", "gt": "String [ ] [ ] NEGATED_TEST = NO_TEST ;", "prediction": "____________________________________________________________________________________________________\n", "label": 0}
{"id": 6560, "input": "<s> package org . eclipse . ui . tests . menus ; import java . util . Map ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . commands . IElementUpdater ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . handlers . HandlerUtil ; import org . eclipse . ui . menus . UIElement ; public class HelloUpdateHandler extends AbstractHandler implements IElementUpdater { private String myLabelState = null ; public Object execute ( ExecutionEvent event ) throws ExecutionException { IWorkbenchWindow window", "gt": "= HandlerUtil . getActiveWorkbenchWindowChecked ( event ) ;", "prediction": ";\n", "label": 1}
{"id": 5123, "input": "<s> package org . ofbiz . pos . jpos . factory ; import java . util . HashMap ; import java . util . Map ; import jpos . JposConst ; import jpos . JposException ; import jpos . config . JposEntry ; import jpos . loader . JposServiceInstance ; import jpos . loader . JposServiceInstanceFactory ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . pos . jpos . service . BaseService ; public class OfbizJposServiceFactory extends Object implements JposServiceInstanceFactory { public static final String module = OfbizJposServiceFactory . class . getName ( ) ; private static Map < String , Object > serviceMap = new HashMap < String , Object > ( ) ; public JposServiceInstance createInstance ( String logicalName , JposEntry entry ) throws JposException { if ( ! entry . hasPropertyWithName ( JposEntry . SERVICE_CLASS_PROP_NAME ) ) { throw new JposException ( JposConst . JPOS_E_NOSERVICE , \"serviceClass property not found!\" ) ; } String className = ( String ) entry . getPropertyValue ( JposEntry . SERVICE_CLASS_PROP_NAME ) ; BaseService service = ( BaseService ) serviceMap . get ( className ) ; if ( service != null ) { service . setEntry ( entry ) ; } else { try { Object obj = ObjectType . getInstance ( className ) ; if ( obj == null ) { throw new JposException", "gt": "( JposConst . JPOS_E_NOEXIST , \"unable to locate serviceClass\" ) ;", "prediction": ";\n", "label": 0}
{"id": 6590, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . util . Iterator ; import java . util . List ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . stats . Report ; import org . apache . lucene . benchmark . byTask . stats . TaskStats ; public class RepSelectByPrefTask extends RepSumByPrefTask { public RepSelectByPrefTask ( PerfRunData runData ) { super ( runData ) ; } public int doLogic ( ) throws Exception { Report rp = reportSelectByPrefix ( getRunData ( ) . getPoints ( ) . taskStats ( ) ) ; System . out . println ( ) ; System . out . println ( \"------------> Report Select By Prefix (\" + prefix + \") (\" + rp . getSize ( ) + \" about \" + rp . getReported ( ) + \" out of \" + rp . getOutOf ( ) + \")\" ) ; System . out . println ( rp . getText ( ) ) ; System . out . println ( ) ; return 0 ; } protected Report reportSelectByPrefix ( List taskStats ) { String longestOp = longestOp ( taskStats . iterator ( ) ) ; boolean first = true ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( tableTitle ( longestOp ) ) ; sb . append ( newline ) ; int reported = 0 ; for ( Iterator it = taskStats . iterator ( ) ; it . hasNext ( ) ; ) { TaskStats stat = ( TaskStats ) it . next ( ) ; if ( stat . getElapsed ( ) >= 0 && stat . getTask ( ) . getName ( ) . startsWith ( prefix ) ) { reported ++ ; if ( ! first ) { sb . append ( newline ) ; } first = false ; String line = taskReportLine ( longestOp , stat ) ; if ( taskStats . size ( ) > 2 && reported % 2 == 0 ) { line = line . replaceAll ( \"   \" , \" - \" ) ; } sb . append ( line ) ; } } String reptxt = ( reported == 0 ? \"No Matching Entries Were Found!\" :", "gt": "sb . toString ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8199, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import javax . xml . bind . JAXBException ; import org . apache . commons . io . FileUtils ; import org . apache . commons . io . IOUtils ; import org . apache . maven . artifact . Artifact ; import org . apache . maven . execution . MavenSession ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; import org . apache . maven . project . MavenProjectHelper ; import org . sonatype . aether . RepositorySystem ; import org . sonatype . aether . RepositorySystemSession ; import org . sonatype . aether . repository . RemoteRepository ; import org . xml . sax . SAXException ; import com . sap . prd . mobile . ios . mios . CodeSignManager . ExecResult ; import com . sap . prd . mobile . ios . mios . CodeSignManager . ExecutionResultVerificationException ; import com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 . Dependency ; public class XCodeVersionInfoMojo extends AbstractXCodeMojo { protected MavenSession mavenSession ; protected RepositorySystem repoSystem ; protected RepositorySystemSession repoSession ; protected List < RemoteRepository > projectRepos ; private MavenProjectHelper projectHelper ; private String syncInfo ; private boolean failOnMissingSyncInfo ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { final File syncInfoFile = new File ( mavenSession . getExecutionRootDirectory ( ) , syncInfo ) ; if ( ! syncInfoFile . exists ( ) ) { if ( failOnMissingSyncInfo ) { throw new MojoExecutionException ( \"Sync info file '\" + syncInfoFile . getAbsolutePath ( ) + \"' not found. Please configure your SCM plugin accordingly.\" ) ; } getLog ( ) . info ( \"The optional sync info file '\" + syncInfoFile . getAbsolutePath ( ) + \"' not found. Cannot attach versions.xml to build results.\" ) ; return ; } getLog ( ) . info ( \"Sync info file found: '\" + syncInfoFile . getAbsolutePath ( ) + \"'. Creating versions.xml file.\" ) ; final File versionsFile = new File ( project . getBuild ( ) . getDirectory ( ) , \"versions.xml\" ) ; FileOutputStream os = null ; try { os = new FileOutputStream ( versionsFile ) ; new VersionInfoManager ( ) . createVersionInfoFile ( project . getGroupId ( ) , project . getArtifactId ( ) , project . getVersion ( ) , syncInfoFile , getDependencies ( ) , os ) ; } catch ( JAXBException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } finally { IOUtils . closeQuietly ( os ) ; } if ( getPackagingType ( ) == PackagingType . APP ) { try { copyVersionsXmlAndSign ( ) ; } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( ExecutionResultVerificationException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } } projectHelper . attachArtifact ( project , \"xml\" , \"versions\" , versionsFile ) ; getLog ( ) . info ( \"versions.xml '\" + versionsFile + \" attached as additional artifact.\" ) ; } private void copyVersionsXmlAndSign ( ) throws IOException , ExecutionResultVerificationException { for ( final String configuration : getConfigurations ( ) ) { for ( final String sdk : getSDKs ( ) ) { if ( sdk . startsWith ( \"iphoneos\" ) ) { File versionsXmlInBuild = new File ( project . getBuild ( ) . getDirectory ( ) , \"versions.xml\" ) ; File rootDir = XCodeBuildLayout . getAppFolder ( getXCodeCompileDirectory ( ) , configuration , sdk ) ; String productName = EffectiveBuildSettings . getProductName ( this . project , configuration , sdk ) ; File appFolder = new File ( rootDir , productName + \".app\" ) ; File versionsXmlInApp = new File ( appFolder , \"versions.xml\" ) ; CodeSignManager . verify ( appFolder ) ; final ExecResult originalCodesignEntitlementsInfo = CodeSignManager", "gt": ". getCodesignEntitlementsInformation ( appFolder ) ;", "prediction": ";\n", "label": 0}
{"id": 6593, "input": "<s> package org . restlet . engine . log ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . logging . Formatter ; import java . util . logging . LogRecord ; public class SimplestFormatter extends Formatter { public synchronized String format ( LogRecord record ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( formatMessage ( record ) ) ; sb . append ( '\\n' ) ; if ( record . getThrown ( ) != null ) { try { sb", "gt": ". append ( System . getProperty ( \"line.separator\" ) ) ;", "prediction": ";\n", "label": 1}
{"id": 4486, "input": "<s> enum TestEnum { BAR , QUX , BAZ { private final TestEnum a = BAR ;", "gt": "private final TestEnum b = QUX ;", "prediction": "}\n", "label": 0}
{"id": 6595, "input": "<s> package org . whiskcraft . ScheduledAnnouncer ; import org . bukkit . ChatColor ; public class ChatColorHelper { public static String replaceColorCodes ( String message ) { for ( ChatColor color : ChatColor . values ( ) ) { message = message . replaceAll ( String . format ( \"&%c\" , color . getChar ( ) ) , color .", "gt": "toString ( ) ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 3479, "input": "<s> package org . apache . felix . resolver . impl ; import java . util . List ; import org . osgi . framework . resource . Capability ; import org . osgi . framework . resource . Requirement ; import org . osgi . framework . resource . Resource ; import org . osgi . framework . resource . Wire ; import org . osgi . framework . resource . Wiring ; class WireImpl implements Wire { private final Resource m_requirer ; private final Requirement m_req ; private final Resource m_provider ; private final Capability m_cap ; public WireImpl ( Resource requirer , Requirement req , Resource provider , Capability cap ) { m_requirer = requirer ; m_req = req ; m_provider = provider ; m_cap = cap ; } public Resource getRequirer ( ) { return m_requirer ; } public Requirement getRequirement ( ) { return m_req ; } public Resource getProvider ( ) { return m_provider ; } public Capability getCapability ( ) { return m_cap ; } @ Override public String toString ( ) { return m_req + \"", "gt": "-> \" + \"[\" + m_provider + \"]\" ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6598, "input": "<s> package knowevo . articlerank ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . BufferedWriter ; import java . io . FileWriter ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . Map ; import java . util . Iterator ; public class Ranker { public static Graph buildSeeAlsoGraph ( String path ) { Graph g = null ; try { BufferedReader br = new BufferedReader ( new FileReader ( path ) ) ; ArrayList < Article > al = new ArrayList < Article > ( ) ; Article [ ] arts ; String line = br . readLine ( ) ; while ( line != null ) { al . add ( getSeealsoArticle ( line ) ) ; line = br . readLine ( ) ; } arts = new Article [ al . size ( ) ] ; for ( int i = 0 ; i < arts . length ; i ++ ) arts [ i ] = al . get ( i ) ; g = new Graph ( arts ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return g ; } private static Article getSeealsoArticle ( String line ) { Article art ; String [ ] parts = line . split ( \" \" ) ; int id = Integer . parseInt ( parts [ 0 ] . split ( \":\" ) [ 0 ] ) ; int [ ] edges = new int [ parts . length - 1 ] ; for ( int i = 0 ; i < edges . length && parts [ i + 1 ] . length ( ) != 0 ; i ++ ) edges [ i ] = Integer . parseInt ( parts [ i + 1 ] ) ; art = new Article ( id , edges ) ; return art ; } private static Map < Integer , Double >", "gt": "getTFDFMap ( String line , boolean weighted , double cutoff )", "prediction": ";\n", "label": 1}
{"id": 7089, "input": "<s> package org . ofbiz . catalina . container ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . List ; import org . apache . catalina . Container ; import org . apache . catalina . Loader ; import org . apache . catalina . Session ; import org . apache . catalina . Store ; import org . apache . catalina . session . StandardSession ; import org . apache . catalina . session . StoreBase ; import org . apache . catalina . util . CustomObjectInputStream ; import org . ofbiz . base . util . Debug ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class OfbizStore extends StoreBase implements Store { public static final String module = OfbizStore . class . getName ( ) ; public static final String entityName = \"CatalinaSession\" ; protected static String storeName = \"OfbizStore\" ; protected Delegator delegator = null ; public OfbizStore ( Delegator delegator ) { this . delegator = delegator ; } @ Override public String getStoreName ( ) { return storeName ; } public int getSize ( ) throws IOException { long count = 0 ; try { count = delegator . findCountByCondition ( entityName , null , null , null ) ; } catch ( GenericEntityException e ) { throw new IOException ( e . getMessage ( ) ) ; } return ( int ) count ; } public String [ ] keys ( ) throws IOException { List < GenericValue > sessions = null ; try { sessions = delegator . findList ( entityName , null , null , null , null , false ) ; } catch ( GenericEntityException e ) { throw new IOException ( e . getMessage ( ) ) ; } if ( sessions == null ) { return new String [ 0 ] ; } else { String [ ] ids = new String [ sessions . size ( ) ] ; int loc = 0 ; for ( GenericValue value : sessions ) { ids [ loc ++ ] = value . getString ( \"sessionId\" ) ; } return ids ; } } public", "gt": "Session load ( String id ) throws ClassNotFoundException , IOException", "prediction": "void ( )\n", "label": 0}
{"id": 6603, "input": "<s> package edu . washington . cs . cse490h . lib ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Random ; import edu . washington . cs . cse490h . lib . Node . NodeCrashException ; import edu . washington . cs . cse490h . lib . Packet . CorruptPacketException ; public class Emulator extends Manager { private Node node ; private NodeServer server ; private int address ; private final long timeStep ; private final String routerName ; private final int routerPort ; private boolean failed ; private boolean IOFinished ; public Emulator ( Class < ? extends Node > nodeImpl , int nodeAddr , String routerName , int routerPort , Long seed , long timeStep , String replayOutputFilename , String replayInputFilename ) throws IOException , IllegalArgumentException { super ( nodeImpl , seed , replayOutputFilename , replayInputFilename ) ; setParser ( new EmulationCommandsParser ( ) ) ; System . out . print ( \"Starting emulation \" ) ; if ( Replay . isReplaying ( ) ) { System . out . print ( \"in replay mode \" ) ; } System . out . println ( \"with seed: \" + this . seed ) ; Utility . randNumGen = new Random ( this . seed ) ; this . routerName = routerName ; this . routerPort = routerPort ; if ( Replay . isReplaying ( ) ) { try { Packet addrPkt = Replay . getPacket ( ) ; if ( Replay . isAddrPacket ( addrPkt ) ) { address = addrPkt . getDest ( ) ; } else { throw new Replay . ReplayException ( \"Address packet expected! Instead, we got: \" + addrPkt . toString ( ) ) ; } } catch ( CorruptPacketException e ) { throw new Replay . ReplayException ( \"Address packet expected, but packet was corrupted\" ) ; } IOFinished = false ; } else { address = nodeAddr ; IOFinished = true ; } if ( Replay . replayOut != null ) { try { Packet addrPkt = Replay . getAddrPacket ( address ) ; Replay . replayOut . write ( addrPkt . pack ( ) ) ; } catch ( IOException e ) { throw new Replay . ReplayException ( e . getMessage ( ) ) ; } } vtimes = new HashMap < Integer , VectorTime > ( ) ; failed = false ; this . timeStep = timeStep ; setTime ( 0 ) ; } public Emulator ( Class < ? extends Node > nodeImpl , int nodeAddr , String routerName , int routerPort , FailureLvl failureGen , Long seed , long timeStep , String replayOutputFilename , String replayInputFilename ) throws UnknownHostException , IOException , IllegalArgumentException { this ( nodeImpl , nodeAddr , routerName , routerPort , seed , timeStep , replayOutputFilename , replayInputFilename ) ; cmdInputType = InputType . USER ; userControl = failureGen ; } public Emulator ( Class < ? extends Node > nodeImpl , int nodeAddr , String routerName , int routerPort , FailureLvl failureGen , Long seed , long timeStep , String replayOutputFilename , String replayInputFilename , String commandFile ) throws UnknownHostException , IOException , IllegalArgumentException { this ( nodeImpl , nodeAddr , routerName , routerPort , seed , timeStep , replayOutputFilename , replayInputFilename ) ; cmdInputType = InputType . FILE ; userControl = failureGen ; EmulationCommandsParser commandFileParser = new EmulationCommandsParser ( ) ; sortedEvents = commandFileParser . parseFile ( commandFile ) ; } private void doTimestep ( ArrayList < Event > currentRoundEvents ) { checkInTransit ( currentRoundEvents ) ; checkTimeouts ( currentRoundEvents ) ; checkCrash ( currentRoundEvents ) ; executeEvents ( currentRoundEvents ) ; } @ Override protected void start ( ) { synPartialOrderLogger . start ( MessageLayer . synopticPartialOrderLogFilename ) ; startNode ( ) ; if ( cmdInputType == InputType . FILE ) { while ( node != null || failed ) { if ( IOFinished && node != null ) { System . err . println ( \"Network I/O thread failed, killing the node...\" ) ; failNode ( ) ; } System . out . println ( \"\\nTime: \" + now ( ) ) ; if ( node == null ) { checkRecover ( ) ; } else { ArrayList < Event > currentRoundEvents = new ArrayList < Event > ( ) ; boolean advance = false ; do { if ( sortedEvents . isEmpty ( ) ) { advance = true ; } else { Event ev = sortedEvents . remove ( 0 ) ; if ( ev . t == Event . EventType . TIME ) { advance = true ; } else { currentRoundEvents . add ( ev ) ; } } } while ( ! advance ) ; doTimestep ( currentRoundEvents ) ; } setTime ( now ( ) + 1 ) ; if ( node != null ) { logEventWithNodeField ( node , \"TIMESTEP time:\" + now ( ) ) ; } try { Thread . sleep ( timeStep ) ; } catch ( InterruptedException e ) { } } } else if ( cmdInputType == InputType . USER ) { while ( node != null || failed ) { if ( IOFinished && node != null ) { System . err . println ( \"Network I/O thread failed, killing the node...\" ) ; failNode ( ) ; } System . out . println ( \"\\nTime: \" + now ( ) ) ; if ( node == null ) { checkRecover ( ) ; if ( userControl . compareTo ( FailureLvl . CRASH ) < 0 ) { try { Thread . sleep ( timeStep ) ; } catch ( InterruptedException e ) { } } } else { ArrayList < Event > currentRoundEvents = new ArrayList < Event > ( ) ; Event ev ; boolean advance = false ; System . out . println ( \"Please input a sequence of commands terminated by a blank line or the TIME command:\" ) ; do { ev = null ; try {", "gt": "String input = Replay . getLine ( ) ;", "prediction": "}\n", "label": 1}
{"id": 3754, "input": "<s> package net . minecraft . src ; public class ThxEntityHelperServer extends ThxEntityHelper { public ThxEntityHelperServer ( ThxEntity entity ) { this . entity = entity ; } void applyUpdatePacket ( Packet230ModLoader packet ) { if ( true ) return ; if ( packet == null ) return ; if ( entity . riddenByEntity == null ) { System . out . println ( \"update received even though no pilot\" ) ; } else if ( entity . riddenByEntity . isDead ) { log ( \"pilot entity is dead\" ) ; entity", "gt": ". pilotExit ( ) ;", "prediction": "}\n", "label": 0}
{"id": 6613, "input": "<s> package org . eclipse . ui . internal ; import java . util . Map ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . ISourceProvider ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . commands . IElementUpdater ; import org . eclipse . ui . handlers . HandlerUtil ; import org . eclipse . ui . internal . services . WorkbenchSourceProvider ; import org . eclipse . ui . internal . util . Util ; import org . eclipse . ui . menus . UIElement ; import org . eclipse . ui . part . IShowInTarget ; import org . eclipse . ui . part . ShowInContext ; import org . eclipse . ui . services . ISourceProviderService ; import org . eclipse . ui . views . IViewDescriptor ; import org . eclipse . ui . views . IViewRegistry ; public class ShowInHandler extends AbstractHandler implements IElementUpdater { public Object execute ( ExecutionEvent event ) throws ExecutionException { String targetId = event . getParameter ( IWorkbenchCommandConstants . NAVIGATE_SHOW_IN_PARM_TARGET ) ; if ( targetId == null ) { throw new ExecutionException ( \"No targetId specified\" ) ; } final IWorkbenchWindow activeWorkbenchWindow = HandlerUtil . getActiveWorkbenchWindowChecked ( event ) ; ISourceProviderService sps = ( ISourceProviderService ) activeWorkbenchWindow . getService ( ISourceProviderService . class ) ; if ( sps != null ) { ISourceProvider sp = sps . getSourceProvider ( ISources . SHOW_IN_SELECTION ) ; if ( sp instanceof WorkbenchSourceProvider ) { ( ( WorkbenchSourceProvider ) sp ) . checkActivePart ( true ) ; } } ShowInContext context = getContext ( HandlerUtil . getShowInSelection ( event ) , HandlerUtil . getShowInInput ( event ) ) ; if ( context == null ) { return null ; } IWorkbenchPage page = activeWorkbenchWindow . getActivePage ( ) ; try { IViewPart view = page . showView ( targetId ) ; IShowInTarget target = getShowInTarget ( view ) ; if ( ! ( target != null && target . show ( context ) ) ) { page . getWorkbenchWindow ( ) . getShell ( ) . getDisplay ( ) . beep ( ) ; } ( ( WorkbenchPage ) page ) . performedShowIn ( targetId ) ; } catch ( PartInitException e ) { throw new ExecutionException ( \"Failed to show in\" , e ) ; } return null ; } private ShowInContext getContext ( ISelection showInSelection , Object input ) { if ( input == null && showInSelection == null ) { return null ; } return new ShowInContext ( input , showInSelection ) ; } private IShowInTarget getShowInTarget ( IWorkbenchPart targetPart ) { return ( IShowInTarget )", "gt": "Util . getAdapter ( targetPart , IShowInTarget . class ) ;", "prediction": ";\n", "label": 1}
{"id": 7805, "input": "<s> package org . parboiled . trees ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . common . Formatter ; import org . parboiled . common . Predicate ; import org . parboiled . common . Predicates ; import java . util . Collection ; import java . util . HashSet ; public final class GraphUtils { private GraphUtils ( ) { } public static boolean hasChildren ( GraphNode < ? > node ) { return node != null && ! node . getChildren ( ) . isEmpty ( ) ; } public static < T extends GraphNode < T > > T getFirstChild ( T node ) { return hasChildren ( node ) ? node . getChildren ( ) . get ( 0 ) : null ; } public static < T extends GraphNode < T > > T getLastChild ( T node ) { return hasChildren ( node ) ? node . getChildren ( ) . get ( node . getChildren ( ) . size ( ) - 1 ) : null ; } public static < T extends GraphNode < T > > int countAllDistinct ( T node ) { if ( node == null ) return 0 ; return collectAllNodes ( node , new HashSet < T > ( ) ) . size ( ) ; } public static < T extends GraphNode < T > , C extends Collection < T > > C collectAllNodes ( T node , C collection ) { checkArgNotNull ( collection , \"collection\" ) ; if ( node != null && ! collection . contains ( node ) ) { collection . add ( node ) ; for ( T child : node . getChildren ( ) ) { collectAllNodes ( child , collection ) ; } } return collection ; } public static < T extends GraphNode < T > > String printTree", "gt": "( T node , Formatter < T > formatter )", "prediction": "( )\n", "label": 0}
{"id": 6620, "input": "<s> package br . org . archimedes . io . pdf . elements ; import java . io . IOException ; import br . org . archimedes . Geometrics ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . io . pdf . PDFWriterHelper ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import com . lowagie . text . pdf . PdfContentByte ; public class ArcExporter implements ElementExporter < Arc > { public void exportElement ( Arc arc , Object outputObject ) throws IOException { PDFWriterHelper helper = ( PDFWriterHelper ) outputObject ; PdfContentByte cb = helper . getPdfContentByte ( ) ; Point center = arc . getCenter ( ) ; Point initial = arc . getInitialPoint ( ) ; Point ending = arc . getEndingPoint ( ) ; float start = 0 ; float extent = 0 ; try { start = ( float ) Geometrics . calculateAngle ( center , initial ) ; extent = ( float ) Geometrics . calculateAngle ( center , ending ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } start *= ( 180 / Math . PI ) ; extent *= ( 180 / Math . PI ) ; extent -= start ; if ( extent < 0 ) { extent += 360 ; } center = helper . modelToDocument ( center ) ; double radius = helper .", "gt": "getZoom ( ) * arc . getRadius ( ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6052, "input": "<s> class Comparator < T > { } class Arrays { public static < U , T extends U > void sort ( T [ ] a , Comparator < U > c ) { throw new Error ( ) ; } } class JSR14Bug { public static void main ( String [ ] args ) { Object [ ] oa = null ; Arrays .", "gt": "sort ( oa , new Comparator ( )", "prediction": "get ( ) ;\n", "label": 0}
{"id": 6634, "input": "<s> package fr . inria . zvtm . widgets ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . Graphics ; import java . awt . event . MouseEvent ; import java . awt . event . MouseAdapter ; import javax . swing . JRadioButton ; import javax . swing . Action ; import javax . swing . Icon ; public class TranslucentRadioButton extends JRadioButton implements TranslucentWidget { AlphaComposite bgAC = AB_08 ; AlphaComposite bgACro = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , .8f ) ; AlphaComposite fgAC = AB_10 ; Color bgColro = Color . GRAY ; Color fgColsel = Color . LIGHT_GRAY ; Color fgCol = Color . WHITE ; Color bgCol = Color . BLACK ; boolean cursorInside = false ; boolean buttonPressed = false ; public TranslucentRadioButton ( ) { super ( ) ; } public TranslucentRadioButton ( Action a ) { super ( a ) ; init ( ) ; } public TranslucentRadioButton ( Icon icon ) { super ( icon ) ; init ( ) ; } public TranslucentRadioButton ( Icon icon , boolean selected ) { super ( icon , selected ) ; init ( ) ; } public TranslucentRadioButton ( String text ) { super ( text ) ; init ( ) ; } public TranslucentRadioButton ( String text , boolean selected ) { super ( text , selected ) ; init ( ) ; } public TranslucentRadioButton ( String text , Icon icon ) { super ( text , icon ) ; init ( ) ; } public TranslucentRadioButton ( String text , Icon icon , boolean selected ) { super ( text , icon , selected ) ; init ( ) ; } void init ( ) { setOpaque ( false ) ; setContentAreaFilled ( false ) ; setBorderPainted ( false ) ; initColors ( ) ; initListeners ( ) ; } void initColors ( ) { setForeground ( fgCol ) ; setBackground ( bgCol ) ; } void initListeners ( ) { addMouseListener ( new MouseAdapter ( ) { public void mouseEntered ( MouseEvent e ) { cursorInside = true ; setBackground ( bgColro ) ; repaint ( ) ; } public void mouseExited ( MouseEvent e ) { cursorInside = false ; setBackground ( bgCol ) ; repaint ( ) ; } public void mousePressed ( MouseEvent e ) { buttonPressed = true ; setForeground ( fgColsel ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { buttonPressed = false ; setForeground ( fgCol ) ; repaint ( ) ; } } ) ; } public void setBackgroundTranslucence ( float alpha ) { this . bgAC = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , alpha ) ; } public void setForegroundTranslucence ( float alpha ) { this . fgAC = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , alpha ) ; } public void setRolloverBackgroundTranslucence ( float alpha ) { this . bgAC = AlphaComposite . getInstance", "gt": "( AlphaComposite . SRC_OVER , alpha ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2259, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . util . * ; public class Zone implements Serializable { private static final long serialVersionUID = - 9220510891189510942L ; public static final int PRIMARY = 1 ; public static final int SECONDARY = 2 ; private Map data ; private Name origin ; private Object originNode ; private int dclass = DClass . IN ; private RRset NS ; private SOARecord SOA ; private boolean hasWild ; class ZoneIterator implements Iterator { private Iterator zentries ; private RRset [ ] current ; private int count ; private boolean wantLastSOA ; ZoneIterator ( boolean axfr ) { synchronized ( Zone . this ) { zentries = data . entrySet ( ) . iterator ( ) ; } wantLastSOA = axfr ; RRset [ ] sets = allRRsets ( originNode ) ; current = new RRset [ sets . length ] ; for ( int i = 0 , j = 2 ; i < sets . length ; i ++ ) { int type = sets [ i ] . getType ( ) ; if ( type == Type . SOA ) current [ 0 ] = sets [ i ] ; else if ( type == Type . NS ) current [ 1 ] = sets [ i ] ; else current [ j ++ ] = sets [ i ] ; } } public boolean hasNext ( ) { return ( current != null || wantLastSOA ) ; } public Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( current == null ) { wantLastSOA = false ; return oneRRset ( originNode , Type . SOA ) ; } Object set = current [ count ++ ] ; if ( count == current . length ) { current = null ; while ( zentries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) zentries . next ( ) ; if ( entry . getKey ( ) . equals ( origin ) ) continue ; RRset [ ] sets = allRRsets ( entry . getValue ( ) ) ; if ( sets . length == 0 ) continue ; current = sets ; count = 0 ; break ; } } return set ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private void validate ( ) throws IOException { originNode = exactName ( origin ) ; if ( originNode == null ) throw new IOException ( origin + \": no data specified\" ) ; RRset rrset = oneRRset ( originNode , Type . SOA ) ; if ( rrset == null || rrset . size ( ) != 1 ) throw new IOException ( origin + \": exactly 1 SOA must be specified\" ) ; Iterator it = rrset . rrs ( ) ; SOA = ( SOARecord ) it . next ( ) ; NS = oneRRset ( originNode , Type . NS ) ; if ( NS == null ) throw new IOException ( origin + \": no NS set specified\" ) ; } private final void maybeAddRecord ( Record record ) throws IOException { int rtype = record . getType ( ) ; Name name = record . getName ( ) ; if ( rtype == Type", "gt": ". SOA && ! name . equals ( origin ) )", "prediction": ") ;\n", "label": 0}
{"id": 6653, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . INullSelectionListener ; import org . eclipse . ui . ISelectionListener ; import org . eclipse . ui . IWorkbenchPart ; public abstract class AbstractPartSelectionTracker { private ListenerList fListeners = new ListenerList ( ) ; private ListenerList postListeners = new ListenerList ( ) ; private String fPartId ; public AbstractPartSelectionTracker ( String partId ) { setPartId ( partId ) ; } public void addSelectionListener ( ISelectionListener listener ) { fListeners . add ( listener ) ; } public void addPostSelectionListener ( ISelectionListener listener ) { postListeners . add ( listener ) ; } public abstract ISelection getSelection ( ) ; public void removeSelectionListener ( ISelectionListener listener ) { fListeners . remove ( listener ) ; } public void removePostSelectionListener ( ISelectionListener listener ) { postListeners . remove ( listener ) ; } public void dispose ( ) { synchronized ( fListeners ) { Object [ ] listeners = fListeners . getListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { fListeners . remove ( listeners [ i ] ) ; postListeners . remove (", "gt": "listeners [ i ] ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8787, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Main { static int maxLg = 200 ; public static void main ( String args [ ] ) throws Exception { String s = \"\" ; long [ ] k = new long [ 2 ] ; while ( true ) { s = readLine ( ) ; if ( s == null ) { break ; } k = splitLongLine ( s . trim ( ) ) ; if ( k [ 0 ] == 1 && k [ 1 ] == 1 ) return ; tenta ( k [ 0 ] , k [ 1 ] , 0 , 1 , 1 , 0 ) ; System . out . println ( ) ; } } private static void tenta ( long l , long r , long a , long b , long c , long d ) { if ( l == a + c && r == b + d ) return ; if ( l * ( b + d ) < r * ( a + c ) ) { System . out . print ( \"L\" ) ; tenta ( l , r , a , b , c + a , d + b ) ; } else { System . out . print ( \"R\" ) ; tenta ( l , r , a + c , b + d , c , d ) ; } } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; }", "gt": "lin [ lg ++ ] += car ;", "prediction": "}\n", "label": 0}
{"id": 6662, "input": "<s> package org . spliffy . server . web . calc ; import org . spliffy . server . web . SpliffyResource ; interface Accumulator { void accumulate ( SpliffyResource r", "gt": ", Object o ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5962, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import ar . com . fdvs . dj . domain . chart . DJChart ; public class DJStackedBar3DChartBuilder extends DJBar3DChartBuilder {", "gt": "protected byte getChartType ( )", "prediction": "return ;\n", "label": 0}
{"id": 6666, "input": "<s> package org . apache . lucene . search . payloads ; import java . io . IOException ; import java . io . Reader ; import java . util . Collection ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . LowerCaseTokenizer ; import org . apache . lucene . analysis . Token ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . PayloadAttribute ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Payload ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . DefaultSimilarity ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . QueryUtils ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . Searcher ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . search . spans . SpanQuery ; import org . apache . lucene . search . spans . SpanNearQuery ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . English ; import org . apache . lucene . util . LuceneTestCase ; public class TestPayloadNearQuery extends LuceneTestCase { private IndexSearcher searcher ; private BoostingSimilarity similarity = new BoostingSimilarity ( ) ; private byte [ ] payload2 = new byte [ ] { 2 } ; private byte [ ] payload4 = new byte [ ] { 4 } ; public TestPayloadNearQuery ( String s ) { super ( s ) ; } private class PayloadAnalyzer extends Analyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { TokenStream result = new LowerCaseTokenizer ( reader ) ; result = new PayloadFilter ( result , fieldName ) ; return result ; } } private class PayloadFilter extends TokenFilter { String fieldName ; int numSeen = 0 ; protected PayloadAttribute payAtt ; public PayloadFilter ( TokenStream input , String fieldName ) { super ( input ) ; this . fieldName = fieldName ; payAtt = ( PayloadAttribute ) addAttribute ( PayloadAttribute . class ) ; } public boolean incrementToken ( ) throws IOException { boolean result = false ; if ( input . incrementToken ( ) == true ) { if ( numSeen % 2 == 0 ) { payAtt . setPayload ( new Payload ( payload2 ) ) ; } else { payAtt . setPayload ( new Payload ( payload4 ) ) ; } numSeen ++ ; result = true ; } return result ; } } private PayloadNearQuery newPhraseQuery ( String fieldName , String phrase , boolean inOrder ) { int n ; String [ ] words = phrase . split ( \"[\\\\s]+\" ) ; SpanQuery clauses [ ] = new SpanQuery [ words . length ] ; for ( int i = 0 ; i < clauses . length ; i ++ ) { clauses [ i ] = new PayloadTermQuery ( new Term ( fieldName , words [ i ] ) , new AveragePayloadFunction ( ) ) ; } return new PayloadNearQuery ( clauses , 0 , inOrder ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; RAMDirectory directory = new RAMDirectory ( ) ;", "gt": "PayloadAnalyzer analyzer = new PayloadAnalyzer ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8635, "input": "<s> package org . jjflyboy . tjpeditor . validation ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . xtext . xbase . validation . XbaseJavaValidator ; import org . eclipse . xtext . validation . ComposedChecks ; @ ComposedChecks ( validators = { org . eclipse . xtext . validation . ImportUriValidator . class , org . eclipse . xtext . validation . NamesAreUniqueValidator . class } ) public class AbstractProjectJavaValidator extends XbaseJavaValidator { @ Override protected List < EPackage > getEPackages ( ) { List < EPackage > result = new ArrayList < EPackage > ( ) ; result . add ( org . jjflyboy . tjpeditor . project . ProjectPackage . eINSTANCE ) ; result . add ( EPackage . Registry . INSTANCE . getEPackage ( \"http://www.eclipse.org/xtext/xbase/Xbase\" ) ) ; result . add ( EPackage . Registry . INSTANCE . getEPackage ( \"http://www.eclipse.org/xtext/common/JavaVMTypes\" ) ) ; result . add ( EPackage .", "gt": "Registry . INSTANCE . getEPackage ( \"http://www.eclipse.org/xtext/xbase/Xtype\" ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 6672, "input": "<s> package org . nlogo . extensions . sound ; public class StopMusic implements org . nlogo . api . Command { public String getAgentClassString ( ) { return \"OTP\" ; } public org . nlogo . api . Syntax getSyntax ( ) { return org . nlogo . api . Syntax . commandSyntax ( ) ; } public boolean getSwitchesBoolean ( ) { return false ; } public org . nlogo . api . Command newInstance ( String name ) { return new StopMusic ( ) ; } public void perform ( org . nlogo . api . Argument args [ ] , org . nlogo . api . Context context ) throws org . nlogo . api", "gt": ". ExtensionException , org . nlogo . api . LogoException", "prediction": ";\n", "label": 1}
{"id": 7977, "input": "<s> package org . ofbiz . minilang ; @ SuppressWarnings ( \"serial\" ) public class MiniLangRuntimeException extends MiniLangException { private final MiniLangElement element ; public MiniLangRuntimeException ( String str , MiniLangElement element ) { super ( str ) ; this . element = element ; } public MiniLangRuntimeException ( Throwable nested , MiniLangElement element ) { super ( nested ) ; this . element = element ; } @ Override public String getMessage ( ) { StringBuilder sb = new StringBuilder ( super . getMessage ( ) ) ; if ( this . element != null ) { SimpleMethod method = this . element . getSimpleMethod ( ) ; sb . append ( \" Method = \" ) . append ( method . getMethodName ( ) ) . append ( \", File = \" ) . append ( method . getFromLocation ( ) ) ; sb . append ( \", Element = <\" ) . append ( this . element . getTagName ( ) ) . append ( \">\" ) ; sb . append ( \", Line \" ) . append ( this . element", "gt": ". getLineNumber ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6676, "input": "<s> package org . springframework . tenancy . provider ; import org . springframework . tenancy . core . Tenant ; public class DefaultTenantProvider implements TenantProvider { @ Override public Tenant findTenant ( Object identity ) {", "gt": "DefaultTenant result = new DefaultTenant ( ) ;", "prediction": "\n", "label": 1}
{"id": 5344, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . util . EObjectResolvingEList ; import org . jjflyboy . tjpeditor . project . Alternative ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Resource ; public class AlternativeImpl extends AllocateResourceAttributeImpl implements Alternative { protected EList < Resource > resources ; protected AlternativeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getAlternative ( ) ; } public EList < Resource > getResources ( ) { if ( resources == null ) { resources = new EObjectResolvingEList < Resource > ( Resource . class , this , ProjectPackage . ALTERNATIVE__RESOURCES ) ; } return resources ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . ALTERNATIVE__RESOURCES : return getResources ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . ALTERNATIVE__RESOURCES : getResources ( ) . clear ( ) ; getResources ( ) . addAll ( ( Collection", "gt": "< ? extends Resource > ) newValue ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6679, "input": "<s> package knowevo . myvizster . controls ; import java . awt . event . MouseEvent ; import java . util . TimerTask ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . activity . Activity ; import edu . berkeley . guir . prefuse . event . ControlAdapter ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Entity ; public class HighlightHoldControl extends ControlAdapter { public static final int MOUSE_OVER_MODE = 0 ; public static final int CLICK_MODE = 1 ; public static final int CLICK_AND_HOLD_MODE = 2 ; private Vizster vizster ; private long delay = 1000 ; private int mouseButton = MouseEvent . BUTTON1 ; private int mouseMask = MouseEvent . BUTTON1_DOWN_MASK ; private int mode ; private TimerTask task ; private FocusSet focusSet ; private Entity curFocus ; private Object focusSetKey ; private Activity activity ; public HighlightHoldControl ( Activity act , Object focusSetKey , Vizster vizster , int mode ) { if ( mode < MOUSE_OVER_MODE || mode > CLICK_AND_HOLD_MODE ) throw new IllegalArgumentException ( \"Unrecognized mode.\" ) ; this . vizster = vizster ; this . mode = mode ; this . activity = act ; this . focusSetKey = focusSetKey ; } public void itemEntered ( VisualItem vi , MouseEvent e ) { if ( mode != MOUSE_OVER_MODE ) return ; final VisualItem item = vi ; task = new TimerTask ( ) { public void run ( ) { setFocus ( item ) ; setMagnify ( true ) ; } } ; VizsterLib . getTimer ( ) . schedule ( task , delay ) ; } public void itemExited ( VisualItem vi , MouseEvent e ) { if ( mode != MOUSE_OVER_MODE ) return ; task . cancel ( ) ; setMagnify ( false ) ; clearFocus ( ) ; } public void itemDragged ( VisualItem vi , MouseEvent e ) { if ( ( e . getModifiersEx ( ) & mouseMask ) == 0 ) return ; if ( mode == CLICK_MODE ) return ; task . cancel ( ) ; } public void itemPressed ( VisualItem vi , MouseEvent e ) { if ( e . getButton ( ) != mouseButton ) return ; if ( mode != CLICK_AND_HOLD_MODE ) return ; final VisualItem item = vi ; task = new TimerTask ( ) { public void run ( ) { setFocus ( item ) ; setMagnify ( true ) ; } } ; VizsterLib . getTimer ( ) . schedule ( task , delay ) ; } public void itemReleased ( VisualItem vi , MouseEvent e ) { if ( e . getButton ( ) != mouseButton ) return ; if ( mode != CLICK_AND_HOLD_MODE ) return ; task . cancel ( ) ; } public void itemClicked ( VisualItem vi , MouseEvent e ) { if ( e . getButton ( ) != mouseButton ) return ; if ( mode != CLICK_MODE ) return ; setMagnify ( true ) ; setFocus ( vi ) ; } public void mouseReleased ( MouseEvent e ) { if ( e", "gt": ". getButton ( ) != mouseButton ) return ;", "prediction": ")\n", "label": 1}
{"id": 7715, "input": "<s> package com . redhat . ceylon . compiler . loader ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . Scope ; public interface ModelLoader { enum DeclarationType { TYPE , VALUE ; } public Declaration getDeclaration ( String typeName , DeclarationType declarationType ) ; public ProducedType getType ( String pkg", "gt": ", String name , Scope scope ) ;", "prediction": ")\n", "label": 0}
{"id": 6682, "input": "<s> package org . eclipse . jface . databinding . swt ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . value . IObservableValue ; import org . eclipse . core . databinding . property . INativePropertyListener ; import org . eclipse . core . databinding . property . ISimplePropertyListener ; import org . eclipse . core . databinding . property . value . SimpleValueProperty ; import org . eclipse . jface . internal . databinding . swt . SWTObservableValueDecorator ; import org . eclipse . jface . internal . databinding . swt . WidgetListener ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Widget ; public abstract class WidgetValueProperty extends SimpleValueProperty implements IWidgetValueProperty { private int [ ] changeEvents ; private int [ ] staleEvents ; protected WidgetValueProperty ( ) { this ( null , null ) ; } protected WidgetValueProperty ( int changeEvent ) { this ( new int [ ] { changeEvent } , null ) ; } protected WidgetValueProperty ( int [ ] changeEvents ) { this ( changeEvents , null ) ; } public WidgetValueProperty ( int [ ] changeEvents , int [ ] staleEvents ) { this . changeEvents = changeEvents ; this . staleEvents = staleEvents ; } public INativePropertyListener adaptListener ( ISimplePropertyListener listener ) { if ( changeEvents == null && staleEvents == null ) return null ; return new WidgetListener ( this , listener , changeEvents , staleEvents ) ; } public IObservableValue observe ( Object source ) { if ( source instanceof Widget ) { return observe ( ( Widget ) source ) ; } return super . observe ( source ) ; } public IObservableValue observe ( Realm realm , Object source ) { return wrapObservable ( super . observe ( realm , source ) ,", "gt": "( Widget ) source ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4766, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . tools . * ; public class T6341866 { static final String testSrc = System . getProperty ( \"test.src\" , \".\" ) ; static final String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; static final File a_java = new File ( testSrc , \"A.java\" ) ; static final File a_class = new File ( \"A.class\" ) ; static final File b_java = new File ( testSrc , \"B.java\" ) ; static final File b_class = new File ( \"B.class\" ) ; static final File processorServices = services ( Processor . class ) ; enum ImplicitType { NONE ( null ) , OPT_UNSET ( null ) , OPT_NONE ( \"-implicit:none\" ) , OPT_CLASS ( \"-implicit:class\" ) ; ImplicitType ( String opt ) { this . opt = opt ; } final String opt ; } ; enum AnnoType { NONE , SERVICE , SPECIFY } ; public static void main ( String ... args ) throws Exception { boolean ok = true ; for ( ImplicitType implicitType : EnumSet . allOf ( ImplicitType . class ) ) { for ( AnnoType annoType : EnumSet . allOf ( AnnoType . class ) ) { ok &= test ( implicitType , annoType ) ; } } if ( ! ok ) throw new AssertionError ( \"test failed\" ) ; } static boolean test ( ImplicitType implicitType , AnnoType annoType ) throws IOException { System . err . println ( \"test  implicit=\" + implicitType + \"  anno=\" + annoType ) ; a_class . delete ( ) ; b_class . delete ( ) ; processorServices . delete ( ) ; List < String > opts = new ArrayList < String > ( ) ; opts . addAll ( Arrays . asList ( \"-d\" , \".\" , \"-sourcepath\" , testSrc , \"-classpath\" , testClasses , \"-source\" , \"1.6\" , \"-Xlint:-options\" ) ) ; if ( implicitType . opt != null ) opts . add ( implicitType . opt ) ; switch ( annoType ) { case SERVICE : createProcessorServices ( Anno . class . getName ( ) ) ; break ; case SPECIFY : opts . addAll ( Arrays . asList ( \"-processor\" , Anno . class . getName ( ) ) ) ; break ; } JavaCompiler javac = ToolProvider . getSystemJavaCompiler ( ) ; MyDiagListener dl = new MyDiagListener ( ) ; StandardJavaFileManager fm = javac . getStandardFileManager ( dl , null , null ) ; File file = ( implicitType != ImplicitType . NONE ) ? a_java : b_java ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjects ( file ) ; boolean ok = javac . getTask ( null , fm , dl , opts , null , files ) . call ( ) ; if ( ! ok ) { error ( \"compilation failed\" ) ; return false ; } if ( implicitType != ImplicitType . NONE ) { boolean expectClass = ( implicitType != ImplicitType . OPT_NONE ) ; if ( b_class . exists ( ) != expectClass ) { if ( b_class . exists ( ) ) error ( \"B implicitly compiled unexpectedly\" ) ; else error ( \"B not impliictly compiled\" ) ; return false ; } } String expectKey = null ; if ( implicitType == ImplicitType . OPT_UNSET ) { switch ( annoType ) { case SERVICE : expectKey = \"compiler.warn.proc.use.proc.or.implicit\" ; break ; case SPECIFY : expectKey = \"compiler.warn.proc.use.implicit\" ; break ; } } if ( expectKey == null ) { if ( dl . diagCodes . size ( ) != 0 ) { error ( \"no diagnostics expected\" ) ; return false ; } } else { if ( ! ( dl . diagCodes . size ( ) == 1 && dl . diagCodes . get ( 0 ) . equals ( expectKey ) ) ) { error ( \"unexpected diagnostics generated\" ) ; return false ; } } return true ; } static void createProcessorServices ( String name ) throws IOException { processorServices . getParentFile ( ) . mkdirs ( ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( processorServices ) ) ; out . write ( name ) ; out . newLine ( ) ; out . close ( ) ; } static class MyDiagListener implements DiagnosticListener < JavaFileObject > { public void report ( Diagnostic d ) { diagCodes", "gt": ". add ( d . getCode ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 6686, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec4 . common ; public class MailRepresentation { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public", "gt": "void setContent ( String content )", "prediction": "}\n", "label": 1}
{"id": 6577, "input": "<s> package org . ofbiz . entity . finder ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class PrimaryKeyFinder extends Finder { public static final String module = PrimaryKeyFinder . class . getName ( ) ; protected FlexibleMapAccessor < Object > valueNameAcsr ; protected FlexibleStringExpander autoFieldMapExdr ; protected Map < FlexibleMapAccessor < Object > , Object > fieldMap ; protected List < FlexibleStringExpander > selectFieldExpanderList ; public PrimaryKeyFinder ( Element entityOneElement ) { super ( entityOneElement ) ; if ( UtilValidate . isNotEmpty ( entityOneElement . getAttribute ( \"value-field\" ) ) ) { this . valueNameAcsr = FlexibleMapAccessor . getInstance ( entityOneElement . getAttribute ( \"value-field\" ) ) ; } else { this . valueNameAcsr = FlexibleMapAccessor . getInstance ( entityOneElement . getAttribute ( \"value-name\" ) ) ; } this . autoFieldMapExdr = FlexibleStringExpander . getInstance ( entityOneElement . getAttribute ( \"auto-field-map\" ) ) ; this . fieldMap = EntityFinderUtil . makeFieldMap ( entityOneElement ) ; selectFieldExpanderList = EntityFinderUtil . makeSelectFieldExpanderList ( entityOneElement ) ; } @ Override public void runFind ( Map < String , Object > context , Delegator delegator ) throws GeneralException { String entityName = this . entityNameExdr . expandString ( context ) ; String useCacheString = this . useCacheStrExdr . expandString ( context ) ; boolean useCacheBool = \"true\" . equals ( useCacheString ) ; String autoFieldMapString = this . autoFieldMapExdr . expandString ( context ) ; boolean autoFieldMapBool = ! \"false\" . equals ( autoFieldMapString ) ; ModelEntity modelEntity = delegator . getModelEntity ( entityName ) ; if ( modelEntity == null ) { throw new IllegalArgumentException ( \"No entity definition found for entity name [\" + entityName + \"]\" ) ; } GenericValue valueOut = runFind ( modelEntity , context , delegator , useCacheBool , autoFieldMapBool , this . fieldMap , this . selectFieldExpanderList ) ; if ( ! valueNameAcsr . isEmpty ( ) ) { this . valueNameAcsr . put ( context , valueOut ) ; } else { if ( valueOut != null ) { context", "gt": ". putAll ( valueOut ) ;", "prediction": "\n", "label": 0}
{"id": 6693, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . common . util . EList ; public interface DatatypeRestriction extends DataRange { DataRange getDatatype ( ) ;", "gt": "void setDatatype ( DataRange value ) ;", "prediction": "}\n", "label": 1}
{"id": 5056, "input": "<s> package org . xbill . DNS ; public class MFRecord extends SingleNameBase { private static final long serialVersionUID = - 6670449036843028169L ; MFRecord ( ) { } Record getObject ( ) { return new MFRecord ( ) ; } public MFRecord ( Name name , int dclass , long ttl , Name mailAgent ) { super ( name , Type . MF , dclass , ttl , mailAgent , \"mail agent\" ) ; } public Name getMailAgent ( ) { return getSingleName ( ) ; }", "gt": "public Name getAdditionalName ( )", "prediction": "}\n", "label": 0}
{"id": 6695, "input": "<s> package io . beancounter . listener ; import org . apache . camel . CamelContext ; import org . apache . camel . VetoCamelContextStartException ; import org . apache . camel . support . LifecycleStrategySupport ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import io . beancounter . commons . helper . jedis . JedisPoolFactory ; public class ResourceCleanupStrategy extends LifecycleStrategySupport { private static final Logger LOGGER = LoggerFactory . getLogger ( ResourceCleanupStrategy . class ) ; JedisPoolFactory factory ; public ResourceCleanupStrategy ( JedisPoolFactory factory ) { this . factory = factory ; } @ Override public void onContextStart ( CamelContext context ) throws VetoCamelContextStartException { LOGGER . info ( \"Starting Camel handler\" ) ; } @ Override public void onContextStop ( CamelContext context ) { LOGGER", "gt": ". info ( \"Stopping Camel handler\" ) ;", "prediction": "\n", "label": 1}
{"id": 5639, "input": "<s> package api . torrents . torrents ; public class RemixedBy { private Number id ; private String name ; public Number getId ( ) { return this . id ; } public String getName ( ) { return this . name ; } @ Override public String toString ( ) { return \"RemixedBy [getId=\" + getId ( ) + \",", "gt": "getName=\" + getName ( ) + \"]\" ;", "prediction": ";\n", "label": 0}
{"id": 6715, "input": "<s> package org . apache . lucene . search . regex ; public interface RegexCapabilities { void compile ( String pattern ) ; boolean match ( String string ) ;", "gt": "String prefix ( ) ;", "prediction": "}\n", "label": 1}
{"id": 3743, "input": "<s> package org . jjflyboy . tjpeditor . project ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . Enumerator ; public enum CriterionDirection implements Enumerator { UP ( 0 , \"UP\" , \"up\" ) , DOWN ( 1 , \"DOWN\" , \"down\" ) ; public static final int UP_VALUE = 0 ; public static final int DOWN_VALUE = 1 ; private static final CriterionDirection [ ] VALUES_ARRAY = new CriterionDirection [ ] { UP , DOWN , } ; public static final List < CriterionDirection > VALUES = Collections . unmodifiableList ( Arrays . asList ( VALUES_ARRAY ) ) ; public static CriterionDirection get ( String literal ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { CriterionDirection result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( literal ) ) { return result ; } } return null ; } public static CriterionDirection getByName ( String name ) { for ( int i = 0 ; i", "gt": "< VALUES_ARRAY . length ;", "prediction": ";\n", "label": 0}
{"id": 6733, "input": "<s> package org . nuxeo . ecm . automation . client . adapters ; import org . nuxeo . ecm . automation . client . AdapterFactory ; import org . nuxeo . ecm . automation . client . Session ; public class DocumentServiceFactory implements AdapterFactory < DocumentService > { public Class < ? > getAcceptType ( ) { return Session . class ; }", "gt": "public Class < DocumentService > getAdapterType ( )", "prediction": "}\n", "label": 1}
{"id": 319, "input": "<s> package ar . com . fdvs . dj . domain . builders ; import java . util . Iterator ; import java . util . List ; import net . sf . jasperreports . charts . design . JRDesignCategoryDataset ; import net . sf . jasperreports . charts . design . JRDesignCategorySeries ; import net . sf . jasperreports . charts . design . JRDesignPieDataset ; import net . sf . jasperreports . engine . JRExpression ; import net . sf . jasperreports . engine . design . JRDesignChartDataset ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import ar . com . fdvs . dj . core . DJException ; import ar . com . fdvs . dj . domain . DJChart ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; public class DataSetFactory { public static JRDesignChartDataset getDataset ( DJChart djchart , JRDesignGroup group , JRDesignGroup parentGroup , List vars ) { JRDesignChartDataset dataSet = null ; byte chartType = djchart . getType ( ) ; if ( chartType == DJChart . PIE_CHART ) { dataSet = createPieDataset ( group , parentGroup , vars , djchart ) ; } else if ( chartType == DJChart . BAR_CHART ) { dataSet = createBarDataset ( group , parentGroup , vars , djchart ) ; } if ( dataSet == null ) { throw new DJException ( \"Error creating dataset for chart, no valid dataset type.\" ) ; } return dataSet ; } protected static JRDesignChartDataset createLineDataset ( JRDesignGroup group , JRDesignGroup parentGroup , List vars , DJChart djchart ) { JRDesignCategoryDataset data = new JRDesignCategoryDataset ( null ) ; JRDesignCategorySeries serie = new JRDesignCategorySeries ( ) ; JRDesignVariable var = ( JRDesignVariable ) vars . get ( 0 ) ; JRDesignVariable var1 = ( JRDesignVariable ) vars . get ( 0 ) ; if ( vars . size ( ) > 1 ) var1 = ( JRDesignVariable ) vars . get ( 1 ) ; JRDesignExpression varExp = getExpressionFromVariable ( var ) ; JRExpression varExp1 = var1 . getExpression ( ) ; serie . setValueExpression ( varExp ) ; JRExpression exp2 = group . getExpression ( ) ; JRDesignExpression exp3 = new JRDesignExpression ( ) ; int index = vars . indexOf ( var ) ; AbstractColumn col = ( AbstractColumn ) djchart . getColumns ( ) . get ( index ) ; exp3 . setText ( \"\\\"\" + col . getTitle ( ) + \"\\\"\" ) ; exp3 . setValueClass ( String . class ) ; serie . setCategoryExpression ( exp2 ) ; serie . setLabelExpression ( exp2 ) ; serie . setSeriesExpression ( varExp1 ) ; data . addCategorySeries ( serie ) ; setResetStyle ( data , group , parentGroup ) ; return data ; } protected static JRDesignChartDataset createBarDataset ( JRDesignGroup group , JRDesignGroup parentGroup , List vars , DJChart djchart ) { JRDesignCategoryDataset data = new JRDesignCategoryDataset ( null ) ; for ( Iterator iterator = vars . iterator ( ) ; iterator . hasNext ( ) ; ) { JRDesignCategorySeries serie = new JRDesignCategorySeries ( ) ; JRDesignVariable var = ( JRDesignVariable ) iterator . next ( ) ; JRDesignExpression varExp = getExpressionFromVariable ( var ) ; serie . setValueExpression ( varExp ) ; JRExpression", "gt": "exp2 = group . getExpression ( ) ;", "prediction": ";\n", "label": 0}
{"id": 6735, "input": "<s> package org . apache . lucene . analysis . br ; import java . io . File ; import java . io . IOException ; import java . io . Reader ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . LowerCaseFilter ; import org . apache . lucene . analysis . StopFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . WordlistLoader ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . analysis . standard . StandardFilter ; import org . apache . lucene . analysis . standard . StandardTokenizer ; import org . apache . lucene . util . Version ; public final class BrazilianAnalyzer extends Analyzer { public final static String [ ] BRAZILIAN_STOP_WORDS = { \"a\" , \"ainda\" , \"alem\" , \"ambas\" , \"ambos\" , \"antes\" , \"ao\" , \"aonde\" , \"aos\" , \"apos\" , \"aquele\" , \"aqueles\" , \"as\" , \"assim\" , \"com\" , \"como\" , \"contra\" , \"contudo\" , \"cuja\" , \"cujas\" , \"cujo\" , \"cujos\" , \"da\" , \"das\" , \"de\" , \"dela\" , \"dele\" , \"deles\" , \"demais\" , \"depois\" , \"desde\" , \"desta\" , \"deste\" , \"dispoe\" , \"dispoem\" , \"diversa\" , \"diversas\" , \"diversos\" , \"do\" , \"dos\" , \"durante\" , \"e\" , \"ela\" , \"elas\" , \"ele\" , \"eles\" , \"em\" , \"entao\" , \"entre\" , \"essa\" , \"essas\" , \"esse\" , \"esses\" , \"esta\" , \"estas\" , \"este\" , \"estes\" , \"ha\" , \"isso\" , \"isto\" , \"logo\" , \"mais\" , \"mas\" , \"mediante\" , \"menos\" , \"mesma\" , \"mesmas\" , \"mesmo\" , \"mesmos\" , \"na\" , \"nas\" , \"nao\" , \"nas\" , \"nem\" , \"nesse\" , \"neste\" , \"nos\" , \"o\" , \"os\" , \"ou\" , \"outra\" , \"outras\" , \"outro\" , \"outros\" , \"pelas\" , \"pelas\" , \"pelo\" , \"pelos\" , \"perante\" , \"pois\" , \"por\" , \"porque\" , \"portanto\" , \"proprio\" , \"propios\" , \"quais\" , \"qual\" , \"qualquer\" , \"quando\" , \"quanto\" , \"que\" , \"quem\" , \"quer\" , \"se\" , \"seja\" , \"sem\" , \"sendo\" , \"seu\" , \"seus\" , \"sob\" , \"sobre\" , \"sua\" , \"suas\" , \"tal\" , \"tambem\" , \"teu\" , \"teus\" , \"toda\" , \"todas\" , \"todo\" , \"todos\" , \"tua\" , \"tuas\" , \"tudo\" , \"um\" , \"uma\" , \"umas\" , \"uns\" } ; private Set stoptable = new HashSet ( ) ; private Set excltable = new HashSet ( ) ; private final Version matchVersion ; public BrazilianAnalyzer ( ) { this ( Version . LUCENE_23 ) ; } public BrazilianAnalyzer ( Version matchVersion ) { stoptable = StopFilter . makeStopSet ( BRAZILIAN_STOP_WORDS ) ; this . matchVersion = matchVersion ; } public BrazilianAnalyzer ( String [ ] stopwords ) { this ( Version . LUCENE_23 , stopwords ) ; } public BrazilianAnalyzer ( Version matchVersion , String [ ] stopwords ) { stoptable = StopFilter . makeStopSet ( stopwords ) ; this . matchVersion = matchVersion ; } public BrazilianAnalyzer ( Map stopwords ) { this ( Version . LUCENE_23 , stopwords ) ; } public BrazilianAnalyzer ( Version matchVersion , Map stopwords ) { stoptable = new HashSet ( stopwords . keySet ( ) ) ; this . matchVersion = matchVersion ; } public BrazilianAnalyzer ( File stopwords ) throws IOException { this ( Version . LUCENE_23 , stopwords ) ; } public BrazilianAnalyzer ( Version matchVersion , File stopwords ) throws IOException { stoptable = WordlistLoader . getWordSet ( stopwords ) ; this . matchVersion = matchVersion ; } public void setStemExclusionTable ( String [ ] exclusionlist ) { excltable = StopFilter . makeStopSet ( exclusionlist ) ; setPreviousTokenStream ( null ) ; } public void setStemExclusionTable ( Map exclusionlist ) { excltable = new HashSet ( exclusionlist . keySet ( ) ) ; setPreviousTokenStream ( null ) ; } public void setStemExclusionTable ( File exclusionlist ) throws IOException { excltable = WordlistLoader . getWordSet ( exclusionlist ) ; setPreviousTokenStream ( null ) ; } public final TokenStream tokenStream ( String fieldName , Reader reader ) { TokenStream result = new StandardTokenizer ( matchVersion , reader ) ; result = new LowerCaseFilter ( result ) ; result = new StandardFilter ( result ) ; result = new StopFilter ( StopFilter . getEnablePositionIncrementsVersionDefault ( matchVersion ) , result , stoptable ) ; result = new BrazilianStemFilter ( result , excltable ) ; return result ; } private class SavedStreams { Tokenizer source ; TokenStream result ; } ; public TokenStream reusableTokenStream ( String fieldName , Reader reader ) throws IOException { SavedStreams streams = ( SavedStreams ) getPreviousTokenStream ( ) ; if ( streams == null ) { streams", "gt": "= new SavedStreams ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4324, "input": "<s> package pkg1 ; import java . util . * ; public class Foo { public void method ( Vector", "gt": "< Object > o )", "prediction": ")\n", "label": 0}
{"id": 6736, "input": "<s> package br . org . archimedes . gui . opengl ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.i18n.exceptions\" ; public static String OpenGLWrapper_InvalidFont ; static { NLS", "gt": ". initializeMessages ( BUNDLE_NAME , Messages . class ) ;", "prediction": ";\n", "label": 1}
{"id": 112, "input": "<s> package org . dawb . workbench . ui . editors ; import java . util . Collection ; import org . dawb . common . ui . editors . EditorExtensionFactory ; import org . dawb . common . ui . plot . tool . IToolPageSystem ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . common . ui . views . HeaderTablePage ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IReusableEditor ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . part . MultiPageEditorPart ; import org . eclipse . ui . part . Page ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ImageEditor extends MultiPageEditorPart implements IReusableEditor { public static final String ID = \"org.dawb.workbench.editors.ImageEditor\" ; private static final Logger logger = LoggerFactory . getLogger ( ImageEditor . class ) ; private PlotImageEditor plotImageEditor ; @ Override public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { super . init ( site , input ) ; setPartName ( input . getName ( ) ) ; } public void setInput ( IEditorInput input ) { super . setInput ( input ) ; for ( int ied = 0 ; ied < getPageCount ( ) ; ++ ied ) { if ( getEditor ( ied ) instanceof IReusableEditor ) { ( ( IReusableEditor ) getEditor ( ied ) ) . setInput ( input ) ; } } try { setPartName ( input . getName ( ) ) ; } catch ( Exception ignored ) { } } @ Override protected void createPages ( ) { try { int index = 0 ; try { Collection < IEditorPart > extensions = EditorExtensionFactory . getEditors ( this ) ; if ( extensions != null && extensions . size ( ) > 0 ) { for ( IEditorPart iEditorPart : extensions ) { addPage ( index , iEditorPart , getEditorInput ( ) ) ; setPageText ( index , iEditorPart . getTitle ( ) ) ; index ++ ; } } } catch ( Exception e ) { logger . error ( \"Cannot read editor extensions!\" , e ) ; } this . plotImageEditor = new PlotImageEditor ( ) ; addPage ( index , plotImageEditor , getEditorInput ( ) ) ; setPageText ( index , \"Image\" ) ; index ++ ; if ( System . getProperty ( \"org.dawb.editor.ascii.hide.diamond.image.editor\" ) == null ) { final uk . ac . diamond . scisoft . analysis . rcp . editors . ImageEditor im = new uk . ac . diamond . scisoft . analysis . rcp . editors . ImageEditor ( ) ; addPage ( index , im , getEditorInput ( ) ) ; setPageText ( index , \"Info\" ) ; } final int infoIndex = index ; getSite ( ) . getShell ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { @ Override public void run ( ) { if ( EclipseUtils . getPage ( ) . findView ( \"uk.ac.diamond.scisoft.analysis.rcp.views.DatasetInspectorView\" ) != null && getPageCount ( ) >= 2 ) { setActivePage ( infoIndex ) ; } } } ) ; } catch ( PartInitException e ) { logger . error ( \"Cannot initiate \" + getClass ( ) . getName ( ) + \"!\" , e ) ; } } @ Override public void doSave ( IProgressMonitor monitor ) { if ( getActiveEditor ( ) . isDirty ( ) ) { getActiveEditor ( ) . doSave ( monitor ) ; } } @ Override public void doSaveAs ( ) { if ( getActiveEditor ( ) . isDirty ( ) ) { getActiveEditor ( ) . doSaveAs ( ) ; } } @ Override public boolean isSaveAsAllowed ( ) { return false ; } public Object getAdapter ( final Class clazz ) { if ( clazz == Page . class ) { return new HeaderTablePage ( EclipseUtils . getFilePath ( getEditorInput", "gt": "( ) ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6738, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . index . DocumentsWriter . IndexingChain ; import org . apache . lucene . search . Similarity ; import org . apache . lucene . search . Query ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . store . Lock ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . BufferedIndexInput ; import org . apache . lucene . util . Constants ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . util . List ; import java . util . Collection ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Set ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . Iterator ; import java . util . Map ; public class IndexWriter { public static long WRITE_LOCK_TIMEOUT = 1000 ; private long writeLockTimeout = WRITE_LOCK_TIMEOUT ; public static final String WRITE_LOCK_NAME = \"write.lock\" ; public final static int DEFAULT_MERGE_FACTOR = LogMergePolicy . DEFAULT_MERGE_FACTOR ; public final static int DISABLE_AUTO_FLUSH = - 1 ; public final static int DEFAULT_MAX_BUFFERED_DOCS = DISABLE_AUTO_FLUSH ; public final static double DEFAULT_RAM_BUFFER_SIZE_MB = 16.0 ; public final static int DEFAULT_MAX_BUFFERED_DELETE_TERMS = DISABLE_AUTO_FLUSH ; public final static int DEFAULT_MAX_MERGE_DOCS = LogDocMergePolicy . DEFAULT_MAX_MERGE_DOCS ; public final static int DEFAULT_MAX_FIELD_LENGTH = 10000 ; public final static int DEFAULT_TERM_INDEX_INTERVAL = 128 ; public final static int MAX_TERM_LENGTH = DocumentsWriter . MAX_TERM_LENGTH ; public final static double DEFAULT_MAX_SYNC_PAUSE_SECONDS ; static { if ( Constants . WINDOWS ) DEFAULT_MAX_SYNC_PAUSE_SECONDS = 10.0 ; else DEFAULT_MAX_SYNC_PAUSE_SECONDS = 0.0 ; } private final static int MERGE_READ_BUFFER_SIZE = 4096 ; private static Object MESSAGE_ID_LOCK = new Object ( ) ; private static int MESSAGE_ID = 0 ; private int messageID = - 1 ; volatile private boolean hitOOM ; private Directory directory ; private Analyzer analyzer ; private Similarity similarity = Similarity . getDefault ( ) ; private volatile long changeCount ; private long lastCommitChangeCount ; private SegmentInfos rollbackSegmentInfos ; private HashMap rollbackSegments ; volatile SegmentInfos pendingCommit ; volatile long pendingCommitChangeCount ; private SegmentInfos localRollbackSegmentInfos ; private boolean localAutoCommit ; private int localFlushedDocCount ; private boolean autoCommit = true ; private SegmentInfos segmentInfos = new SegmentInfos ( ) ; private DocumentsWriter docWriter ; private IndexFileDeleter deleter ; private Set segmentsToOptimize = new HashSet ( ) ; private Lock writeLock ; private int termIndexInterval = DEFAULT_TERM_INDEX_INTERVAL ; private boolean closeDir ; private boolean closed ; private boolean closing ; private HashSet mergingSegments = new HashSet ( ) ; private MergePolicy mergePolicy = new LogByteSizeMergePolicy ( this ) ; private MergeScheduler mergeScheduler = new ConcurrentMergeScheduler ( ) ; private LinkedList pendingMerges = new LinkedList ( ) ; private Set runningMerges = new HashSet ( ) ; private List mergeExceptions = new ArrayList ( ) ; private long mergeGen ; private boolean stopMerges ; private int flushCount ; private int flushDeletesCount ; private double maxSyncPauseSeconds = DEFAULT_MAX_SYNC_PAUSE_SECONDS ; private int readCount ; private Thread writeThread ; final ReaderPool readerPool = new ReaderPool ( ) ; private int upgradeCount ; private int readerTermsIndexDivisor = IndexReader . DEFAULT_TERMS_INDEX_DIVISOR ; private volatile boolean poolReaders ; public IndexReader getReader ( ) throws IOException { return getReader ( readerTermsIndexDivisor ) ; } public IndexReader getReader ( int termInfosIndexDivisor ) throws IOException { ensureOpen ( ) ; if ( infoStream != null ) { message ( \"flush at getReader\" ) ; } poolReaders = true ; flush (", "gt": "true , true , false ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1128, "input": "<s> package org . ofbiz . entity . cache ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; public class EntityCache extends AbstractCache < GenericPK , GenericValue > { public static final String module = EntityCache . class . getName ( ) ; public EntityCache ( String delegatorName ) { super ( delegatorName , \"entity\" ) ; } public GenericValue get ( GenericPK pk ) { UtilCache < GenericPK , GenericValue > entityCache = getCache ( pk . getEntityName ( ) ) ; if ( entityCache == null ) return null ; return entityCache . get ( pk ) ; } public GenericValue put ( GenericValue entity ) { if ( entity == null ) return null ; return put ( entity . getPrimaryKey ( ) , entity ) ; } public GenericValue put ( GenericPK pk , GenericValue entity ) { if ( pk . getModelEntity ( ) . getNeverCache ( ) ) { Debug . logWarning ( \"Tried to put a value of the \" + pk . getEntityName ( ) + \" entity in the BY PRIMARY KEY cache but this entity has never-cache set to true, not caching.\" , module ) ; return null ; } if ( entity == null ) { entity = GenericValue . NULL_VALUE ; } else { entity . setImmutable ( ) ; } UtilCache < GenericPK , GenericValue > entityCache = getOrCreateCache ( pk . getEntityName ( ) ) ; return entityCache . put ( pk , entity ) ; } public void remove ( String entityName , EntityCondition condition ) { UtilCache < GenericPK", "gt": ", GenericValue > entityCache = getCache ( entityName ) ;", "prediction": ";\n", "label": 0}
{"id": 6740, "input": "<s> package net . claribole . zgrviewer . dot ; public class SubRecord extends Record { public Rectangle rect ; private void init ( Record directParentRecord ) { this . rootRecord = directParentRecord . rootRecord ; Graph . addNode ( this . root , this . rootRecord ) ; Graph . addNode ( this . root , directParentRecord ) ; directParentRecord", "gt": ". addSubRecord ( this ) ;", "prediction": ";\n", "label": 1}
{"id": 5724, "input": "<s> package org . xbill . DNS ; import java . util . * ; public class SPFRecord extends TXTBase { private static final long serialVersionUID = - 2100754352801658722L ; SPFRecord ( ) { } Record getObject ( ) { return new SPFRecord ( ) ; } public SPFRecord ( Name name , int dclass ,", "gt": "long ttl , List strings )", "prediction": ") ;\n", "label": 0}
{"id": 6742, "input": "<s> package br . org . archimedes . text . edittext ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Layer ; import br . org . archimedes . text . Text ; import org . eclipse . ui . PlatformUI ; public class EditTextCommand implements UndoableCommand { private Text text ; private String oldContent ; private String newContent ; public EditTextCommand ( Text text ) throws NullArgumentException { this . text = text ; oldContent = text . getText ( ) ; } public void undoIt ( Drawing drawing ) throws IllegalActionException , NullArgumentException { changeText ( drawing , oldContent ) ; } public void changeText ( Drawing drawing , String content ) throws IllegalActionException , NullArgumentException { if ( drawing == null ) { throw new NullArgumentException ( ) ; } Layer layer = text", "gt": ". getLayer ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3909, "input": "<s> package org . remast . baralga . gui . model . report ; import org . remast . baralga . gui . events . BaralgaEvent ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . model . ProjectActivity ; import ca . odell . glazedlists . BasicEventList ; import ca . odell . glazedlists . SortedList ; import com . google . common . eventbus . EventBus ; import com . google . common . eventbus . Subscribe ; public class HoursByProjectReport { private PresentationModel model ; private EventBus eventBus = new EventBus ( ) ; private SortedList < HoursByProject > hoursByProjectList ; public HoursByProjectReport ( final PresentationModel model ) { this . model = model ; this . model . getEventBus ( ) . register ( this ) ; this . hoursByProjectList = new SortedList < HoursByProject > ( new BasicEventList < HoursByProject > ( ) ) ; calculateHours ( ) ; } public EventBus getEventBus ( ) { return eventBus ; } public void calculateHours ( ) { this . hoursByProjectList . clear ( ) ; for ( ProjectActivity activity : this . model . getActivitiesList ( ) ) { this . addHours ( activity ) ; } } public void addHours ( final ProjectActivity activity ) { final HoursByProject newHoursByProject = new HoursByProject ( activity . getProject ( ) , activity . getDuration ( ) ) ; if ( this . hoursByProjectList . contains ( newHoursByProject ) ) { HoursByProject HoursByProject = this . hoursByProjectList . get ( hoursByProjectList . indexOf ( newHoursByProject ) ) ; HoursByProject . addHours ( newHoursByProject . getHours ( ) ) ; } else { this . hoursByProjectList . add ( newHoursByProject ) ; } } public SortedList < HoursByProject > getHoursByProject ( ) { return hoursByProjectList ; } @ SuppressWarnings ( \"unchecked\" ) @ Subscribe public void update ( final Object eventObject ) { if ( eventObject == null || !", "gt": "( eventObject instanceof BaralgaEvent ) )", "prediction": ")\n", "label": 0}
{"id": 6749, "input": "<s> package com . androidmapballoons . library ; import java . util . List ; import android . graphics . drawable . Drawable ; import android . view . MotionEvent ; import android . view . View ; import android . view . View . OnTouchListener ; import android . view . ViewGroup . LayoutParams ; import com . example . tourapp . R ; import com . example . tourapp . R . id ; import com . google . android . maps . GeoPoint ; import com . google . android . maps . ItemizedOverlay ; import com . google . android . maps . MapController ; import com . google . android . maps . MapView ; import com . google . android . maps . Overlay ; import com . google . android . maps . OverlayItem ; public abstract class BalloonItemizedOverlay < Item extends OverlayItem > extends ItemizedOverlay < Item > { private MapView mapView ; private BalloonOverlayView < Item > balloonView ; private View clickRegion ; private int viewOffset ; final MapController mc ; private Item currentFocussedItem ; private int currentFocussedIndex ; public BalloonItemizedOverlay ( Drawable defaultMarker , MapView mapView ) { super ( defaultMarker ) ; this . mapView = mapView ; viewOffset = 0 ; mc = mapView . getController ( ) ; } public void setBalloonBottomOffset ( int pixels ) { viewOffset = pixels ; } public int getBalloonBottomOffset ( ) { return viewOffset ; } protected boolean onBalloonTap ( int index , Item item ) { return false ; } @ Override protected final boolean onTap ( int index ) { currentFocussedIndex = index ; currentFocussedItem = createItem ( index ) ; boolean isRecycled ; if ( balloonView == null ) { balloonView = createBalloonOverlayView ( ) ; clickRegion = ( View ) balloonView . findViewById ( R . id . balloon_inner_layout ) ; clickRegion . setOnTouchListener ( createBalloonTouchListener ( ) ) ; isRecycled = false ; } else { isRecycled = true ; } balloonView . setVisibility ( View . GONE ) ; List < Overlay > mapOverlays = mapView . getOverlays ( ) ; if ( mapOverlays . size ( ) > 1 ) { hideOtherBalloons ( mapOverlays ) ; } balloonView . setData ( currentFocussedItem ) ; GeoPoint point = currentFocussedItem . getPoint ( ) ; MapView . LayoutParams params = new MapView . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT , point , MapView . LayoutParams . BOTTOM_CENTER ) ; params . mode = MapView . LayoutParams . MODE_MAP ; balloonView . setVisibility ( View . VISIBLE ) ; if ( isRecycled ) { balloonView . setLayoutParams ( params ) ; } else { mapView . addView ( balloonView , params ) ; } mc . animateTo ( point ) ; return true ; } protected BalloonOverlayView < Item > createBalloonOverlayView ( ) { return new BalloonOverlayView < Item > ( getMapView ( ) . getContext ( ) , getBalloonBottomOffset ( ) ) ; } protected MapView getMapView ( ) { return mapView ; } protected void hideBalloon ( ) { if ( balloonView != null ) { balloonView . setVisibility ( View . GONE ) ; } } private void hideOtherBalloons ( List < Overlay > overlays ) { for ( Overlay overlay : overlays ) { if ( overlay instanceof BalloonItemizedOverlay < ? > && overlay != this ) { ( ( BalloonItemizedOverlay < ? > ) overlay ) . hideBalloon ( ) ; } } } private OnTouchListener createBalloonTouchListener ( ) { return new OnTouchListener ( ) { public boolean onTouch ( View v , MotionEvent event ) { View l = ( ( View ) v . getParent ( ) ) . findViewById ( R . id . balloon_main_layout ) ; Drawable d = l . getBackground ( ) ; if ( event . getAction ( ) == MotionEvent . ACTION_DOWN ) { int [ ] states = { android . R . attr . state_pressed } ; if ( d . setState ( states ) ) { d . invalidateSelf ( ) ; } return true ; } else if ( event .", "gt": "getAction ( ) == MotionEvent . ACTION_UP )", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7723, "input": "<s> package com . vexsoftware . votifier . model ; import java . io . File ; import java . net . * ; import java . util . * ; import java . util . logging . * ; import com . vexsoftware . votifier . Votifier ; public class ListenerLoader { private static final Logger LOG = Logger . getLogger ( \"Votifier\" ) ; public static List < VoteListener > load ( String directory ) { List < VoteListener > listeners = new ArrayList < VoteListener > ( ) ; File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { LOG . log ( Level . WARNING , \"No listeners loaded! Cannot find listener directory '\" + dir + \"' \" ) ; return listeners ; } ClassLoader loader ; try { loader = new URLClassLoader ( new URL [ ] { dir . toURI ( ) . toURL ( ) } , VoteListener . class . getClassLoader ( ) ) ; } catch ( MalformedURLException ex ) { LOG . log ( Level . SEVERE , \"Error while configuring listener class loader\" , ex ) ; return listeners ; } for ( File file : dir . listFiles ( ) ) { if ( ! file . getName ( ) . endsWith ( \".class\" ) ) { continue ; } String name = file . getName ( ) . substring ( 0 , file . getName ( ) . lastIndexOf ( \".\" ) ) ; try { Class < ? > clazz = loader . loadClass ( name ) ; Object object = clazz . newInstance ( ) ; if ( ! ( object instanceof VoteListener ) ) { LOG . info ( \"Not a vote listener: \" + clazz . getSimpleName ( ) ) ; continue ; } VoteListener listener", "gt": "= ( VoteListener ) object ;", "prediction": ";\n", "label": 0}
{"id": 6755, "input": "<s> package episode_3 ; import org . lwjgl . LWJGLException ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import static org . lwjgl . opengl . GL11 . * ; public class SimpleOGLRenderer { public static void main ( String [ ] args ) { try { Display . setDisplayMode ( new DisplayMode ( 640 , 480 ) ) ; Display . setTitle ( \"Episode 2 - Display\" ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; Display . destroy ( ) ; System . exit ( 1 ) ; } glMatrixMode ( GL_PROJECTION ) ; glOrtho ( 0 , 640 , 480 , 0 , 1 , - 1 ) ; glMatrixMode ( GL_MODELVIEW ) ; while ( ! Display . isCloseRequested ( ) ) { glClear ( GL_COLOR_BUFFER_BIT ) ; glBegin ( GL_QUADS ) ; glColor3f ( 1.0f , 0.0f , 0.0f ) ; glVertex2i ( 0 , 0 ) ; glColor3b ( ( byte ) 0 , ( byte ) 127 , ( byte ) 0 ) ; glVertex2d", "gt": "( 640.0 , 0.0 ) ;", "prediction": ";\n", "label": 1}
{"id": 6866, "input": "<s> class Base { class Nested { } } class", "gt": "EnclClassRequired extends Base . Nested", "prediction": ";\n", "label": 0}
{"id": 6763, "input": "<s> package org . restlet . service ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . CharacterSet ; import org . restlet . data . Encoding ; import org . restlet . data . Language ; import org . restlet . data . MediaType ; import org . restlet . data . Metadata ; import org . restlet . engine . application . MetadataExtension ; public class MetadataService extends Service { private volatile CharacterSet defaultCharacterSet ; private volatile Encoding defaultEncoding ; private volatile Language defaultLanguage ; private volatile MediaType defaultMediaType ; private final List < MetadataExtension > mappings ; public MetadataService ( ) { this . defaultCharacterSet = CharacterSet . DEFAULT ; this . defaultEncoding = Encoding . IDENTITY ; this . defaultLanguage = Language . DEFAULT ; this . defaultMediaType = MediaType . APPLICATION_OCTET_STREAM ; this . mappings = new CopyOnWriteArrayList < MetadataExtension > ( ) ; addCommonExtensions ( ) ; } public void addCommonExtensions ( ) { List < MetadataExtension > dm = new ArrayList < MetadataExtension > ( ) ; ext ( dm , \"en\" , Language . ENGLISH ) ; ext ( dm , \"es\" , Language . SPANISH ) ; ext ( dm , \"fr\" , Language . FRENCH ) ; ext ( dm , \"ascii\" , CharacterSet . US_ASCII ) ; ext ( dm , \"ai\" , MediaType . APPLICATION_POSTSCRIPT ) ; ext ( dm , \"atom\" , MediaType . APPLICATION_ATOM ) ; ext ( dm , \"atomcat\" , MediaType . APPLICATION_ATOMPUB_CATEGORY ) ; ext ( dm , \"atomsvc\" , MediaType . APPLICATION_ATOMPUB_SERVICE ) ; ext ( dm , \"au\" , MediaType . AUDIO_BASIC ) ; ext ( dm , \"bin\" , MediaType . APPLICATION_OCTET_STREAM ) ; ext ( dm , \"bmp\" , MediaType . IMAGE_BMP ) ; ext ( dm , \"class\" , MediaType . APPLICATION_JAVA ) ; ext ( dm , \"css\" , MediaType . TEXT_CSS ) ; ext ( dm , \"csv\" , MediaType . TEXT_CSV ) ; ext ( dm , \"dat\" , MediaType . TEXT_DAT ) ; ext ( dm , \"dib\" , MediaType . IMAGE_BMP ) ; ext ( dm , \"doc\" , MediaType . APPLICATION_WORD ) ; ext ( dm , \"docm\" , MediaType . APPLICATION_MSOFFICE_DOCM ) ; ext ( dm , \"docx\" , MediaType . APPLICATION_MSOFFICE_DOCX ) ; ext ( dm , \"dotm\" , MediaType . APPLICATION_MSOFFICE_DOTM ) ; ext ( dm , \"dotx\" , MediaType . APPLICATION_MSOFFICE_DOTX ) ; ext ( dm , \"dtd\" , MediaType . APPLICATION_XML_DTD ) ; ext ( dm , \"ecore\" , MediaType . APPLICATION_ECORE ) ; ext ( dm , \"eps\" , MediaType . APPLICATION_POSTSCRIPT ) ; ext ( dm , \"exe\" , MediaType . APPLICATION_OCTET_STREAM ) ; ext ( dm , \"fmt\" , Encoding . FREEMARKER ) ; ext ( dm , \"form\" , MediaType . APPLICATION_WWW_FORM ) ; ext ( dm , \"ftl\" , Encoding . FREEMARKER , true ) ; ext ( dm , \"gif\" , MediaType . IMAGE_GIF ) ; ext ( dm , \"gwt\" , MediaType . APPLICATION_JAVA_OBJECT_GWT ) ; ext ( dm , \"hqx\" , MediaType . APPLICATION_MAC_BINHEX40 ) ; ext ( dm , \"ico\" , MediaType . IMAGE_ICON ) ; ext ( dm , \"jad\" , MediaType . TEXT_J2ME_APP_DESCRIPTOR ) ; ext ( dm , \"jar\" , MediaType . APPLICATION_JAVA_ARCHIVE ) ; ext ( dm , \"java\" , MediaType . TEXT_PLAIN ) ; ext ( dm , \"jnlp\" , MediaType . APPLICATION_JNLP ) ; ext ( dm , \"jpe\" , MediaType . IMAGE_JPEG ) ; ext ( dm , \"jpeg\" , MediaType . IMAGE_JPEG ) ; ext ( dm , \"jpg\" , MediaType . IMAGE_JPEG ) ; ext ( dm , \"js\" , MediaType . APPLICATION_JAVASCRIPT ) ; ext ( dm , \"jsf\" , MediaType . TEXT_PLAIN ) ; ext ( dm , \"kar\" , MediaType . AUDIO_MIDI ) ; ext ( dm , \"latex\" , MediaType . APPLICATION_LATEX ) ; ext ( dm , \"latin1\" , CharacterSet . ISO_8859_1 ) ; ext ( dm , \"mac\" , CharacterSet . MACINTOSH ) ; ext ( dm , \"man\" , MediaType . APPLICATION_TROFF_MAN ) ; ext ( dm , \"mathml\" ,", "gt": "MediaType . APPLICATION_MATHML ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8684, "input": "<s> package com . toedter . gwt . demo . contacts . client . ui ; import com . google . gwt . core . client . GWT ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . user . client . ui . PushButton ; import com . google . gwt . user . client . ui . Widget ; public class ToolBarView extends Composite implements IToolBarView { private static final Binder binder = GWT . create ( Binder . class ) ; @ UiField PushButton saveButton ; @ UiField PushButton addContactButton ; @ UiField PushButton deleteContactButton ; private Presenter presenter ; interface Binder extends UiBinder < Widget , ToolBarView > { } public ToolBarView ( ) { initWidget ( binder . createAndBindUi ( this ) ) ; saveButton . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { presenter . saveContact ( ) ; } } ) ; addContactButton . addClickHandler ( new ClickHandler ( ) { @ Override", "gt": "public void onClick ( ClickEvent event )", "prediction": "}\n", "label": 0}
{"id": 6780, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; final class DocInverterPerThread extends DocFieldConsumerPerThread { final DocInverter docInverter ; final InvertedDocConsumerPerThread consumer ; final InvertedDocEndConsumerPerThread endConsumer ; final SingleTokenTokenStream singleTokenTokenStream = new SingleTokenTokenStream ( ) ; static class SingleTokenTokenStream extends TokenStream { TermAttribute termAttribute ; OffsetAttribute offsetAttribute ; SingleTokenTokenStream ( ) { termAttribute = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; offsetAttribute = ( OffsetAttribute ) addAttribute ( OffsetAttribute . class ) ; } public void reinit ( String stringValue , int startOffset , int endOffset ) { termAttribute . setTermBuffer ( stringValue ) ; offsetAttribute . setOffset ( startOffset , endOffset ) ; } public boolean incrementToken ( ) { throw new UnsupportedOperationException ( ) ; } } final DocumentsWriter . DocState docState ; final FieldInvertState fieldState = new FieldInvertState ( ) ; final ReusableStringReader stringReader = new ReusableStringReader ( ) ; public DocInverterPerThread ( DocFieldProcessorPerThread docFieldProcessorPerThread , DocInverter docInverter ) { this . docInverter = docInverter ; docState = docFieldProcessorPerThread . docState ; consumer = docInverter . consumer . addThread ( this ) ; endConsumer =", "gt": "docInverter . endConsumer . addThread ( this ) ;", "prediction": ";\n", "label": 1}
{"id": 1170, "input": "<s> package ar . com . fdvs . dj . domain ; import java . util . Map ; import ar . com . fdvs . dj . domain . entities . conditionalStyle . StatusLightCondition ; public interface DJValueFormatter { public Object evaluate ( Object value , Map fields , Map variables , Map parameters ) ; public", "gt": "String getClassName ( ) ;", "prediction": "\n", "label": 0}
{"id": 6795, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . io . IOException ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . theme . css . ConditionalValue ; import org . eclipse . rap . rwt . internal . theme . css . CssFileReader ; import org . eclipse . rap . rwt . internal . theme . css . StyleSheet ; import org . eclipse . rap . rwt . resources . ResourceLoader ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . swt . widgets . Widget ; public final class ThemeUtil { private static final String DEFAULT_THEME_NAME = \"RAP Default Theme\" ; private static final String DEFAULT_THEME_CSS = \"resource/theme/default.css\" ; private static final String CURR_THEME_ATTR = \"org.eclipse.rap.theme.current\" ; public static String [ ] getAvailableThemeIds ( ) { return RWTFactory . getThemeManager ( ) . getRegisteredThemeIds ( ) ; } public static String getCurrentThemeId ( ) { ISessionStore sessionStore = ContextProvider . getSessionStore ( ) ; String result = ( String ) sessionStore . getAttribute ( CURR_THEME_ATTR ) ; if ( result == null ) { result = RWT . DEFAULT_THEME_ID ; } return result ; } public static void setCurrentThemeId ( String themeId ) { if ( ! RWTFactory . getThemeManager ( ) . hasTheme ( themeId ) ) { throw new IllegalArgumentException ( \"Illegal theme id: \" + themeId ) ; } ContextProvider . getSessionStore ( ) . setAttribute ( CURR_THEME_ATTR , themeId ) ; } public static Theme getCurrentTheme ( ) { return RWTFactory . getThemeManager ( ) . getTheme ( getCurrentThemeId ( ) ) ; } public static Theme getDefaultTheme ( ) { ThemeManager themeManager = RWTFactory . getThemeManager ( ) ; return themeManager . getTheme ( RWT . DEFAULT_THEME_ID ) ; } private static Theme getFallbackTheme ( ) { ThemeManager themeManager = RWTFactory . getThemeManager ( ) ; return themeManager . getTheme ( ThemeManager . FALLBACK_THEME_ID ) ; } public static void initializeDefaultTheme ( ThemeManager themeManager ) { if ( ! themeManager . hasTheme ( RWT . DEFAULT_THEME_ID ) ) { StyleSheet defaultStyleSheet = readDefaultThemeStyleSheet ( ) ; Theme defaultTheme = new Theme ( RWT . DEFAULT_THEME_ID , DEFAULT_THEME_NAME , defaultStyleSheet ) ; themeManager . registerTheme ( defaultTheme ) ; } } private static StyleSheet readDefaultThemeStyleSheet ( ) { StyleSheet result ; try { ResourceLoader resLoader = ThemeManager . STANDARD_RESOURCE_LOADER ; result = CssFileReader . readStyleSheet ( DEFAULT_THEME_CSS , resLoader ) ; } catch ( IOException e ) { String msg = \"Failed to load default theme: \" + DEFAULT_THEME_CSS ; throw new ThemeManagerException ( msg , e ) ; } return result ; } public static QxType getCssValue ( String cssElement , String cssProperty , SimpleSelector selector ) { return getCssValue ( cssElement , cssProperty , selector , null ) ; } public static QxType getCssValue ( String cssElement , String cssProperty , ValueSelector selector , Widget widget ) { Theme theme = getCurrentTheme ( ) ; ThemeCssValuesMap valuesMap = theme . getValuesMap ( ) ; ConditionalValue [ ] values = valuesMap . getValues ( cssElement , cssProperty ) ; QxType result = selector . select ( values , widget ) ; if ( result == null ) { theme = getFallbackTheme ( ) ; valuesMap = theme . getValuesMap ( ) ; values", "gt": "= valuesMap . getValues ( cssElement , cssProperty ) ;", "prediction": ";\n", "label": 1}
{"id": 4081, "input": "<s> package org . ofbiz . minilang . method . callops ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMapProcessor ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . minilang . operation . MapProcessor ; import org . w3c . dom . Element ; public final class CallSimpleMapProcessor extends MethodOperation { private final FlexibleMapAccessor < List < Object > > errorListFma ; private final MapProcessor inlineMapProcessor ; private final FlexibleMapAccessor < Map < String , Object > > inMapFma ; private final FlexibleMapAccessor < Map < String , Object > > outMapFma ; private final String processorName ; private final String xmlResource ; public CallSimpleMapProcessor ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"processor-name\" , \"xml-resource\" , \"in-map-name\" , \"out-map-name\" , \"error-list-name\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"processor-name\" , \"xml-resource\" , \"error-list-name\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"in-map-name\" , \"out-map-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"in-map-name\" , \"out-map-name\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"simple-map-processor\" ) ; } processorName = element . getAttribute ( \"processor-name\" ) ; xmlResource = element . getAttribute ( \"xml-resource\" ) ; errorListFma = FlexibleMapAccessor . getInstance ( MiniLangValidate . checkAttribute ( element . getAttribute ( \"error-list-name\" ) , \"error_list\" ) ) ; inMapFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"in-map-name\" ) ) ; outMapFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"out-map-name\" ) ) ; Element simpleMapProcessorElement = UtilXml . firstChildElement ( element , \"simple-map-processor\" ) ; if ( simpleMapProcessorElement != null ) { inlineMapProcessor = new MapProcessor ( simpleMapProcessorElement ) ; } else { inlineMapProcessor = null ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { List < Object > messages = errorListFma . get ( methodContext . getEnvMap ( ) ) ; if ( messages == null ) { messages = FastList . newInstance ( ) ; errorListFma . put ( methodContext . getEnvMap ( ) , messages ) ; } Map < String , Object > inMap = inMapFma . get ( methodContext . getEnvMap ( ) ) ; if ( inMap == null ) { inMap = FastMap . newInstance ( ) ; } Map < String , Object > outMap = outMapFma . get ( methodContext . getEnvMap ( ) ) ; if ( outMap == null ) { outMap = FastMap . newInstance ( ) ; outMapFma .", "gt": "put ( methodContext . getEnvMap ( ) , outMap ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 6800, "input": "<s> package org . apache . lucene . queryParser . core . nodes ; public class MatchNoDocsQueryNode extends DeletedQueryNode { private static final long serialVersionUID = 8081805751679581497L ; public MatchNoDocsQueryNode ( ) { }", "gt": "public String toString ( )", "prediction": "}\n", "label": 1}
{"id": 2497, "input": "<s> package InnerInterface2 ; class Builder < Community > { class Produces < B extends AbstractBuilder > { } interface AbstractBuilder { } } class MyBuilder extends Builder < String > { Produces < HTMLConsumer > p0 ; Produces", "gt": "< MyABuilder > p1 ;", "prediction": "\n", "label": 0}
{"id": 6832, "input": "<s> package org . fuzzydb . server ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . MalformedURLException ; import java . net . URL ; import org . fuzzydb . client . Client ; import org . fuzzydb . client . ClientFactory ; import org . fuzzydb . client . Store ; import org . fuzzydb . client . StoreMgr ; import org . fuzzydb . client . WWMDBProtocolHander ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . io . core . Authority ; import org . fuzzydb . server . internal . server . Database ; import org . fuzzydb . server . internal . server . DatabaseFactory ; import org . slf4j . Logger ; import org . springframework . context . Lifecycle ; import org . springframework . util . Assert ; import org . springframework . util . StringUtils ; public class EmbeddedClientFactory implements ClientFactory , Lifecycle { static private final Logger log = LogFactory . getLogger ( EmbeddedClientFactory . class ) ; private static EmbeddedClientFactory instance ; private boolean isPersistent = false ; private Database database ; private Lifecycle httpServer ; private final ReceiverMessageSource databaseMessageSource ; public static synchronized EmbeddedClientFactory getInstance ( ) { if ( instance == null ) { instance = new EmbeddedClientFactory ( ) ; } return instance ; } private EmbeddedClientFactory ( ) { databaseMessageSource = new ReceiverMessageSource ( ) ; } private synchronized void startDatabase ( ) { if ( database != null ) { return ; } database = DatabaseFactory . createDatabase ( databaseMessageSource , isPersistent ( ) ) ; try { database . startServer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( \"Failure starting database:\" + e . getMessage ( ) , e ) ; } httpServer = startHttpServiceIfAvailable ( ) ; } private Lifecycle startHttpServiceIfAvailable ( ) { Class < ? > cl ; Lifecycle httpServer = null ; try { cl = Class . forName ( \"com.wwm.atom.impl.HttpServerFactory\" ) ; } catch ( ClassNotFoundException e ) { return null ; } try { Method m = cl . getMethod ( \"getInstance\" ) ; httpServer = ( Lifecycle ) m . invoke ( null ) ; if ( httpServer == null ) { return null ; } httpServer . start ( ) ; return httpServer ; } catch ( InvocationTargetException e ) { log .", "gt": "warn ( \"Can't start HttpServer\" , e ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 3828, "input": "<s> package jns . element ; import jns . trace . Event ; import jns . trace . EventParameter ; import jns . util . EventGenerator ; public class QueueDropTail extends Queue { private jns . util . Queue m_packets ; public QueueDropTail ( int maxlength ) { super ( maxlength ) ; m_packets = new jns . util . Queue ( ) ; } public void enqueue ( IPPacket packet ) { if ( m_maxlength != 0 ) { if ( packet . length > m_maxlength ) { } while ( m_curlength + packet . length > m_maxlength ) { drop ( ) ; } } if ( m_maxlength == 0 || m_curlength + packet . length < m_maxlength ) { m_packets . pushFront ( packet ) ; m_curlength += packet . length ; } Event event = EventGenerator . makePacketEvent ( \"EnqueueEvent\" , packet ) ; event . addParameter ( new EventParameter ( \"Queue Length\" , new Integer ( m_curlength ) ) ) ; sendEvent ( event ) ; } private void drop ( ) { IPPacket packet = ( IPPacket ) m_packets . peekBack ( ) ; m_packets . popBack ( ) ; m_curlength -= packet . length ; Event event = EventGenerator . makePacketEvent ( \"QueueDropEvent\" , packet ) ; event . addParameter ( new EventParameter ( \"Queue Length\" , new Integer ( m_curlength ) ) ) ; sendEvent ( event ) ; } public IPPacket dequeue ( ) { if ( m_packets . size ( ) != 0 ) { IPPacket packet = ( IPPacket ) m_packets . peekBack ( ) ; m_packets . popBack ( ) ; m_curlength -= packet . length ; Event event = EventGenerator . makePacketEvent ( \"DequeueEvent\" , packet ) ; event . addParameter ( new EventParameter ( \"Queue Length\"", "gt": ", new Integer ( m_curlength ) ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6835, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . login ; import org . nuxeo . ecm . platform . gwt . client . http . HttpResponse ; import com . google . gwt . user . client . ui . Widget ; import com . smartgwt . client . types . Alignment ; import com . smartgwt . client . widgets . Window ; import com . smartgwt . client . widgets . form . DynamicForm ; import com . smartgwt . client . widgets . form . fields . HeaderItem ; import com . smartgwt . client . widgets . form . fields . PasswordItem ; import com . smartgwt . client . widgets . form . fields . StaticTextItem ; import com . smartgwt . client . widgets . form . fields . SubmitItem ; import com . smartgwt . client . widgets . form . fields . TextItem ; import com . smartgwt . client . widgets . form . fields . events . ClickEvent ; import com . smartgwt . client . widgets . form . fields . events . ClickHandler ; import com . smartgwt . client . widgets . form . validator . CustomValidator ; import com . smartgwt . client . widgets . form . validator . Validator ; public class LoginDialog extends Window { protected boolean isRunning = false ; protected TextItem userName ; protected PasswordItem password ; protected String header ; protected DynamicForm form ; protected boolean isError = false ; public LoginDialog ( ) { this ( \"Authentication Required!\" ) ; } public LoginDialog ( String header ) { super ( ) ; this . header = header ; setAnimateMinimize ( true ) ; setWidth ( 300 ) ; setHeight ( 250 ) ; setTitle ( \"Login\" ) ; setShowMinimizeButton ( false ) ; setIsModal ( true ) ; setAutoCenter ( true ) ; addItem ( createContent ( ) ) ; } @ Override public void show ( ) { if ( isRunning ) { return ; } isRunning = true ; super . show ( ) ; System . out . println ( getZIndex ( ) ) ; } public boolean isRunning ( ) { return isRunning ; } protected Widget createContent ( ) { form = new DynamicForm ( ) ; form . setAutoFocus ( true ) ; form . setNumCols ( 2 ) ; HeaderItem hItem = new HeaderItem ( \"header\" ) ; hItem . setValue ( \"<h3>\" + header + \"</h3>\" ) ; hItem . setAlign ( Alignment . CENTER ) ; userName = new TextItem ( \"username\" ) ; userName . setTitle ( \"Username\" ) ; userName . setSelectOnFocus ( true ) ; userName . setWrapTitle ( false ) ; password = new PasswordItem ( \"password\" ) ; password . setTitle ( \"Password\" ) ; password . setWrapTitle ( false ) ; SubmitItem submit", "gt": "= new SubmitItem ( \"submit\" ) ;", "prediction": ";\n", "label": 1}
{"id": 10069, "input": "<s> import javax . annotation . processing . * ; import static javax . lang . model . SourceVersion . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; import java . util . * ; import java . io . * ; @ SupportedAnnotationTypes ( \"*\" ) @ SupportedSourceVersion ( RELEASE_6 ) public class PhantomUpdate extends AbstractProcessor { boolean firstRound = true ; public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( firstRound ) { verifyOptions ( ) ; printGoodbyeWorld ( ) ; firstRound = false ; } return true ; } private void verifyOptions ( ) { Map < String , String > actualOptions = processingEnv . getOptions ( ) ; Map < String , String > expectedOptions = new LinkedHashMap < String , String > ( ) ; expectedOptions . put ( \"foo\" , null ) ; expectedOptions . put ( \"bar\" , \"baz\" ) ; if ( ! actualOptions . equals ( expectedOptions ) ) { System . err . println ( \"Expected options \" + expectedOptions + \"\\n but got \" + actualOptions ) ; throw new RuntimeException ( \"Options mismatch\" ) ; } } private void printGoodbyeWorld ( ) { try { PrintWriter pw = new PrintWriter ( processingEnv . getFiler ( ) . createSourceFile ( \"GoodbyeWorld\" ) . openWriter ( ) ) ; pw . println ( \"public class GoodbyeWorld {\" ) ; pw . println ( \"  // PhantomUpdate Goodbye world\" ) ; pw . println ( \"  public", "gt": "static void main(String argv[]) {\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6851, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . core . service ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . userworkspace . api . UserWorkspaceService ; @ XObject ( \"userWorkspace\" ) public class UserWorkspaceDescriptor {", "gt": "@ XNode ( \"@targetDomainName\" ) private String targetDomainName = \"default-domain\" ;", "prediction": "( )\n", "label": 1}
{"id": 2371, "input": "<s> class HelloPathWorld { public static void main ( String ... args ) { System . out . println", "gt": "( \"Hello World!\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 6866, "input": "<s> package br . org . archimedes . scale ; import static org . junit . Assert . assertNotNull ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . helper . FactoryTester ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . stub . StubElement ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import java . util . HashSet ; public class ScaleFactoryTest extends FactoryTester { private CommandFactory factory ; private HashSet < Element > selection ; private Point reference ; private double proportion ; @ Before public void setUp ( ) throws Exception { Drawing drawing = new Drawing ( \"Teste\" ) ; Element element1 = new StubElement ( ) ; Element element2 = new StubElement ( ) ; putSafeElementOnDrawing ( element1 , drawing ) ; putSafeElementOnDrawing ( element2 , drawing ) ; selection = new HashSet < Element > ( ) ; selection . add ( element1 ) ; selection . add ( element2 ) ; factory = new ScaleFactory ( ) ; reference = new Point ( 50 , 50 ) ; proportion = 1.6 ; br . org . archimedes . Utils . getController ( ) . deselectAll ( ) ; br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( drawing ) ; } @ After public void tearDown ( ) { factory = null ; selection = null ; reference = null ; proportion = 1.0 ; br . org . archimedes . Utils . getController ( ) . deselectAll ( ) ; br . org . archimedes . Utils . getController ( ) . setActiveDrawing ( null ) ; } @ Test public void testProportion ( ) { assertBegin ( factory , false ) ; sendsInvalids ( factory ) ; assertInvalidNext ( factory , reference ) ; assertInvalidNext ( factory , proportion ) ; assertSafeNext ( factory , selection , false ) ; sendsInvalids ( factory ) ; assertInvalidNext ( factory , selection ) ; assertInvalidNext ( factory , proportion ) ; assertSafeNext ( factory , reference , false ) ; sendsInvalids ( factory ) ; assertInvalidNext ( factory , selection ) ; assertSafeNext ( factory , proportion , true ) ; sendsInvalids ( factory ) ; assertInvalidNext ( factory , selection ) ; assertInvalidNext ( factory , reference ) ; assertInvalidNext ( factory , proportion ) ; assertBegin ( factory , false ) ; assertSafeNext ( factory , selection , false ) ; assertSafeNext ( factory , reference , false ) ; assertSafeNext ( factory , proportion , true ) ; } @ Test public void testTwoPoints ( ) { Point numeratorPoint = new Point ( 50 , 20 ) ; Double denominator = 60.0 ; assertBegin ( factory , false ) ; assertSafeNext ( factory , selection , false ) ; assertSafeNext ( factory ,", "gt": "reference , false ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6248, "input": "<s> package com . sun . tools . apt . main ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import java . util . MissingResourceException ; import java . util . StringTokenizer ; import java . util . Map ; import java . util . HashMap ; import java . util . Collections ; import java . net . URLClassLoader ; import java . net . URL ; import java . net . MalformedURLException ; import javax . tools . JavaFileManager ; import javax . tools . StandardLocation ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . code . Source ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . jvm . Target ; import com . sun . tools . javac . util . * ; import com . sun . tools . apt . comp . AnnotationProcessingError ; import com . sun . tools . apt . comp . UsageMessageNeededException ; import com . sun . tools . apt . util . Bark ; import com . sun . mirror . apt . AnnotationProcessorFactory ; import static com . sun . tools . javac . file . Paths . pathToURLs ; @ SuppressWarnings ( \"deprecation\" ) public class Main { static String [ ] forcedOpts = { \"-XDsave-parameter-names\" } ; String ownName ; PrintWriter out ; AnnotationProcessorFactory providedFactory = null ; Map < String , String > origOptions = new HashMap < String , String > ( ) ; ClassLoader aptCL = null ; static final int EXIT_OK = 0 , EXIT_ERROR = 1 , EXIT_CMDERR = 2 , EXIT_SYSERR = 3 , EXIT_ABNORMAL = 4 ; private class Option { boolean aptOnly = false ; String name ; String argsNameKey ; String descrKey ; boolean hasSuffix ; Option ( String name , String argsNameKey , String descrKey ) { this . name = name ; this . argsNameKey = argsNameKey ; this . descrKey = descrKey ; char lastChar = name . charAt ( name . length ( ) - 1 ) ; hasSuffix = lastChar == ':' || lastChar == '=' ; } Option ( String name , String descrKey ) { this ( name , null , descrKey ) ; } public String toString ( ) { return name ; } boolean hasArg ( ) { return argsNameKey != null && ! hasSuffix ; } boolean matches ( String arg ) { return hasSuffix ? arg . startsWith ( name ) : arg . equals ( name ) ; } void help ( ) { } String helpSynopsis ( ) { return name + ( argsNameKey == null ? \"\" : ( ( hasSuffix ? \"\" : \" \" ) + getLocalizedString ( argsNameKey ) ) ) ; } void xhelp ( ) { } boolean process ( String option , String arg ) { options . put ( option , arg ) ; return false ; } boolean process ( String option ) { if ( hasSuffix ) return process ( name , option . substring ( name . length ( ) ) ) ; else return process ( option , option ) ; } } ; private class SharedOption extends Option { SharedOption ( String name , String argsNameKey , String descrKey ) { super ( name , argsNameKey , descrKey ) ; } SharedOption ( String name , String descrKey ) { super ( name , descrKey ) ; } void help ( ) { String s = \"  \" + helpSynopsis ( ) ; out . print ( s ) ; for ( int j = s . length ( ) ; j < 29 ; j ++ ) out . print ( \" \" ) ; Bark . printLines ( out , getLocalizedString ( descrKey ) ) ; } } private class AptOption extends Option { AptOption ( String name , String argsNameKey , String descrKey ) { super ( name , argsNameKey , descrKey ) ; aptOnly = true ; } AptOption ( String name , String descrKey ) { super ( name , descrKey ) ; aptOnly = true ; } void help ( ) { String s = \"  \" + helpSynopsis ( ) ; out . print ( s ) ; for ( int j = s . length ( ) ; j < 29 ; j ++ ) out . print ( \" \" ) ; Bark . printLines ( out , getLocalizedString ( descrKey ) ) ; } } private class XOption extends Option { XOption ( String name , String argsNameKey , String descrKey ) { super ( name , argsNameKey , descrKey ) ; } XOption ( String name , String descrKey ) { this ( name , null , descrKey ) ; } void help ( ) { } void xhelp ( ) { } } ; private class AptXOption extends Option { AptXOption ( String name , String argsNameKey , String descrKey ) { super ( name , argsNameKey , descrKey ) ; aptOnly = true ; } AptXOption ( String name , String descrKey ) { this ( name , null , descrKey ) ; } void xhelp ( ) { String s = \"  \" + helpSynopsis ( ) ; out . print ( s ) ; for ( int j = s . length ( ) ; j < 29 ; j ++ ) out . print ( \" \" ) ; Log . printLines ( out , getLocalizedString ( descrKey ) ) ; } } ; private class HiddenOption extends Option { HiddenOption ( String name ) { super ( name , null , null ) ; } HiddenOption ( String name , String argsNameKey ) { super ( name , argsNameKey , null ) ; } void help ( ) { } void xhelp ( ) { } } ; private class AptHiddenOption extends HiddenOption { AptHiddenOption ( String name ) { super ( name ) ; aptOnly = true ; } AptHiddenOption ( String name , String argsNameKey ) { super ( name , argsNameKey ) ; aptOnly = true ; } } private Option [ ] recognizedOptions = { new Option ( \"-g\" , \"opt.g\" ) , new Option ( \"-g:none\" , \"opt.g.none\" ) { boolean process ( String option ) { options . put ( \"-g:\" , \"none\" ) ; return false ; } } , new Option ( \"-g:{lines,vars,source}\" , \"opt.g.lines.vars.source\" ) { boolean matches ( String s ) { return s . startsWith ( \"-g:\" ) ; } boolean process ( String option ) { String suboptions = option .", "gt": "substring ( 3 ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 6870, "input": "<s> package org . jscsi . target . settings ; import java . util . regex . Matcher ; public final class NumericalValueRange extends NumericalValue { private final int min ; private final int max ; public static final NumericalValueRange create ( final int min , final int max ) { if ( min > max ) return null ; return new NumericalValueRange ( min , max ) ; } public static final NumericalValueRange parseNumericalValueRange ( final String value ) { final Matcher rangeMatcher = NUMERICAL_RANGE_PATTERN . matcher ( value ) ; if ( ! rangeMatcher . matches ( ) ) { return null ; } int min , max ; String [ ] numbers = value . split ( \"~\" ) ; final SingleNumericalValue minVal = SingleNumericalValue . parseSingleNumericValue ( numbers [ 0 ] ) ; final SingleNumericalValue maxVal = SingleNumericalValue . parseSingleNumericValue ( numbers [ 1 ] ) ; if ( minVal == null || maxVal == null ) return null ; min = minVal . getValue ( ) ; max = maxVal . getValue ( ) ; return create ( min , max ) ; } private NumericalValueRange ( final int min , final int max ) { if ( min <= max ) { this . min = min ; this . max = max ; } else { this . min = max ; this . max = min ; } } public final int getMin ( ) { return min ; } public final int getMax ( ) { return max ; } @ Override public final String toString ( ) { return \"[\" + min + \",\" + max + \"]\" ; } @ Override public boolean contains ( final Object value ) { if ( value instanceof NumericalValue ) return contains ( ( NumericalValue ) value ) ; if ( value instanceof Integer ) return contains ( ( int ) ( ( Integer ) value ) ) ; return false ; } public boolean contains ( final NumericalValue value ) { if ( value instanceof SingleNumericalValue ) return contains ( ( SingleNumericalValue ) value ) ; if ( value instanceof NumericalValueRange ) return contains ( ( NumericalValueRange ) value ) ; return false ; } public boolean contains ( final NumericalValueRange range ) { if ( range == null ) return false ; if ( min <= range . getMin ( ) && range . getMax ( ) <= max ) return true ; return false ; } public boolean contains ( final SingleNumericalValue value ) { if ( value == null ) return false ; return contains ( value . getValue ( ) ) ; }", "gt": "@ Override public boolean contains ( final int value )", "prediction": "}\n", "label": 1}
{"id": 9629, "input": "<s> package com . mobeelizer . mobile . android . api ; import java . util . List ; import java . util . Map ; public interface MobeelizerCriteriaBuilder < T > { List < T > list ( ) ; List < Map < String , Object > > listAsMaps ( ) ; long count ( ) ; T uniqueResult ( ) ; Map < String , Object > uniqueResultAsMap ( ) ; MobeelizerCriteriaBuilder < T > setMaxResults ( final int maxResults ) ; MobeelizerCriteriaBuilder <", "gt": "T > setFirstResult ( final int firstResult ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6874, "input": "<s> package org . fuzzydb . client ; import java . util . Collection ; import java . util . Map ; import org . fuzzydb . core . exceptions . ArchException ; import org . fuzzydb . core . query . ResultSet ; import org . fuzzydb . core . query . RetrieveSpec ; import org . fuzzydb . core . query . RetrieveSpecResult ; import org . fuzzydb . expressions . LogicExpr ; public interface Queryable extends Searchable { Object retrieve ( Ref ref ) ; Map < Ref , Object > retrieve ( Collection < Ref > refs ) ; RetrieveSpecResult retrieve ( RetrieveSpec spec ) ; < E > E retrieve ( Class < E > clazz", "gt": ", String keyfield , Object keyval ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9371, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect . mirror ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import com . redhat . ceylon . compiler . java . metadata . Name ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeMirror ; import com . redhat . ceylon . compiler . loader . mirror . VariableMirror ; public class ReflectionVariable implements VariableMirror { private Type type ; private Annotation [ ] annotations ; private ReflectionType varType ; public ReflectionVariable ( Type type , Annotation [ ] annotations ) { this . type = type ; this . annotations = annotations ; } @ Override public AnnotationMirror getAnnotation ( String type ) { return ReflectionUtils . getAnnotation ( annotations , type ) ; } @ Override public TypeMirror getType ( ) {", "gt": "if ( varType != null ) return varType ;", "prediction": "\n", "label": 0}
{"id": 6886, "input": "<s> package org . jscsi . scsi . test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . util . Arrays ; import java . util . List ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; public class BitFieldValueTest { @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { } @ AfterClass public static void tearDownAfterClass ( ) throws Exception { } @ Before public void setUp ( ) throws Exception { } @ After public void tearDown ( ) throws Exception { } @ Test public void testParseValueList ( ) throws Exception { List < List < Boolean > > values = BitFieldValue . parseValueList ( \"0x0A;0b001;0b010\" , 5 , 0 ) ; assertEquals ( \"returned list improper length\" , 3 , values . size ( ) ) ; Object [ ] val = null ; val = ( Object [ ] ) values . get ( 0 ) . toArray ( ) ; assertTrue ( \"element parsed incorrectly\" , Arrays . equals ( val , new Object [ ] { false , true , false , true , false } ) ) ; val = ( Object [ ] ) values . get ( 1 ) . toArray ( ) ; assertTrue ( \"element parsed incorrectly\" , Arrays . equals ( val , new Object [ ] { false , false , false , false , true } ) ) ; val = ( Object [ ] ) values . get ( 2 ) . toArray ( ) ; assertTrue ( \"element parsed incorrectly\" , Arrays . equals ( val , new Object [ ] { false , false , false , true , false } ) ) ; } @ Test public void testParseFieldLength ( ) throws Exception { assertEquals ( \"invalid field length parsed\" , 8 , BitFieldValue . parseFieldLength ( \"bits\" , \"bits(8)\" , 0 ) ) ; assertEquals ( \"invalid field length parsed\" , 16 , BitFieldValue . parseFieldLength ( \"bits\" , \"bits(16)\" , 0 ) ) ; assertEquals ( \"invalid field length parsed\" , 100 , BitFieldValue . parseFieldLength ( \"bits\" , \"bits(100)\" , 0 ) ) ; assertEquals ( \"invalid field length parsed\" , 10234 , BitFieldValue . parseFieldLength ( \"bits\" , \"bits(10234)\" , 0 ) ) ; assertEquals ( \"invalid field length parsed\" , 58 , BitFieldValue . parseFieldLength ( \"bits\" , \"bits(58)\" , 0 ) ) ; } @ Test public void testParseBinaryValue ( ) throws Exception { Object [ ] val = null ; val = ( Object [ ] ) BitFieldValue . parseBinaryValue ( \"0110101\" , 7 , 0 ) . toArray ( ) ; assertTrue ( \"parse failure\" , Arrays . equals ( val , new Object [ ] { false , true , true , false , true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseBinaryValue ( \"0110101\" , 5 , 0 ) . toArray ( ) ; assertTrue ( \"parse failure\" , Arrays . equals ( val , new Object [ ] { true , false , true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseBinaryValue ( \"0110101\" , 9 , 0 ) . toArray ( ) ; assertTrue ( \"parse failure\" , Arrays . equals ( val , new Object [ ] { false , false , false , true , true , false , true , false , true } ) ) ; } @ Test public void testParseHexValue_FillAndTruncate ( ) throws Exception { Object [ ] val = null ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 0 , 0 ) . toArray ( ) ; assertTrue ( \"truncate failure\" , Arrays . equals ( val , new Object [ ] { } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 1 , 0 ) . toArray ( ) ; assertTrue ( \"truncate failure\" , Arrays . equals ( val , new Object [ ] { true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 2 , 0 ) . toArray ( ) ; assertTrue ( \"truncate failure\" , Arrays . equals ( val , new Object [ ] { false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 3 , 0 ) . toArray ( ) ; assertTrue ( \"truncate failure\" , Arrays . equals ( val , new Object [ ] { true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 4 , 0 ) . toArray ( ) ; assertTrue ( \"truncate failure\" , Arrays . equals ( val , new Object [ ] { false , true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 5 , 0 ) . toArray ( ) ; assertTrue ( \"fill failure\" , Arrays . equals ( val , new Object [ ] { false , false , true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 6 , 0 ) . toArray ( ) ; assertTrue ( \"fill failure\" , Arrays . equals ( val , new Object [ ] { false , false , false , true , false , true } ) ) ; val = ( Object [ ] ) BitFieldValue . parseHexValue ( \"5\" , 7 ,", "gt": "0 ) . toArray ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9365, "input": "<s> package com . sun . tools . javac . util ; import java . util . HashSet ; import java . util . Set ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . code . Lint . LintCategory ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; public class MandatoryWarningHandler { private enum DeferredDiagnosticKind { IN_FILE ( \".filename\" ) , ADDITIONAL_IN_FILE ( \".filename.additional\" ) , IN_FILES ( \".plural\" ) , ADDITIONAL_IN_FILES ( \".plural.additional\" ) ; DeferredDiagnosticKind ( String v ) { value = v ; } String getKey ( String prefix ) { return prefix + value ; } private String value ; } public MandatoryWarningHandler ( Log log , boolean verbose , boolean enforceMandatory , String prefix , LintCategory lc ) { this . log = log ; this . verbose = verbose ; this . prefix = prefix ; this . enforceMandatory = enforceMandatory ; this . lintCategory = lc ; } public void report ( DiagnosticPosition pos , String msg , Object ... args ) { JavaFileObject currentSource = log . currentSourceFile ( ) ; if ( verbose ) { if ( sourcesWithReportedWarnings == null ) sourcesWithReportedWarnings = new HashSet < JavaFileObject > ( ) ; if ( log . nwarnings < log . MaxWarnings ) { logMandatoryWarning ( pos , msg , args ) ; sourcesWithReportedWarnings . add ( currentSource ) ; } else if ( deferredDiagnosticKind == null ) { if ( sourcesWithReportedWarnings . contains ( currentSource ) ) { deferredDiagnosticKind = DeferredDiagnosticKind . ADDITIONAL_IN_FILE ; } else { deferredDiagnosticKind = DeferredDiagnosticKind . IN_FILE ; } deferredDiagnosticSource = currentSource ; deferredDiagnosticArg = currentSource ; } else if ( ( deferredDiagnosticKind == DeferredDiagnosticKind . IN_FILE || deferredDiagnosticKind == DeferredDiagnosticKind . ADDITIONAL_IN_FILE ) && ! equal ( deferredDiagnosticSource , currentSource ) ) { deferredDiagnosticKind = DeferredDiagnosticKind . ADDITIONAL_IN_FILES ; deferredDiagnosticArg = null ; } } else { if ( deferredDiagnosticKind == null ) { deferredDiagnosticKind = DeferredDiagnosticKind . IN_FILE ; deferredDiagnosticSource = currentSource ; deferredDiagnosticArg = currentSource ; } else if ( deferredDiagnosticKind == DeferredDiagnosticKind . IN_FILE && ! equal ( deferredDiagnosticSource , currentSource ) ) { deferredDiagnosticKind = DeferredDiagnosticKind . IN_FILES ; deferredDiagnosticArg = null ; } } } public void reportDeferredDiagnostic ( ) { if ( deferredDiagnosticKind != null ) { if ( deferredDiagnosticArg == null ) logMandatoryNote ( deferredDiagnosticSource , deferredDiagnosticKind . getKey ( prefix ) ) ; else logMandatoryNote ( deferredDiagnosticSource , deferredDiagnosticKind . getKey ( prefix ) , deferredDiagnosticArg ) ; if ( ! verbose ) logMandatoryNote ( deferredDiagnosticSource , prefix + \".recompile\" ) ; } } private static boolean equal ( Object o1 , Object o2 ) { return ( ( o1 == null || o2 == null ) ? ( o1 == o2 ) : o1 . equals ( o2 ) ) ; } private Log log ; private boolean verbose ; private String prefix ; private Set < JavaFileObject > sourcesWithReportedWarnings ; private DeferredDiagnosticKind deferredDiagnosticKind ; private JavaFileObject deferredDiagnosticSource ; private Object deferredDiagnosticArg ; private final boolean enforceMandatory ; private final LintCategory lintCategory ; private void logMandatoryWarning ( DiagnosticPosition pos , String msg , Object ... args ) { if ( enforceMandatory ) log . mandatoryWarning ( lintCategory , pos , msg , args ) ; else log . warning ( lintCategory", "gt": ", pos , msg , args ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6888, "input": "<s> package org . restlet . ext . freemarker . internal ; import org . restlet . util . Resolver ; import freemarker . template . TemplateHashModel ; import freemarker . template . TemplateModel ; import freemarker . template . TemplateModelException ; public class ResolverHashModel implements TemplateHashModel { private final Resolver < ? extends Object > resolver ; public ResolverHashModel ( Resolver < ? extends Object > resolver ) { super ( ) ; this . resolver = resolver ; } public TemplateModel get ( String key ) throws TemplateModelException { Object value = this . resolver", "gt": ". resolve ( key ) ;", "prediction": ";\n", "label": 1}
{"id": 6115, "input": "<s> package com . farpost . ldt ; import java . util . Arrays ; import static java . lang . Math . pow ; import static java . lang . Math . sqrt ; import static java . util . Arrays . sort ; public class Utils { public static double calculateStdDev ( long [ ] [ ] numbers ) { long sum = 0 ; long mean = 0 ; int count = 0 ; for ( long [ ] row : numbers ) { count += row . length ; for ( long number : row ) { sum += number ; mean += pow ( number , 2 ) ; } } double avarage = sum / count ; return sqrt ( mean / count - pow ( avarage , 2 ) ) ; } public static long percentile ( long [ ] vector , double fraction ) { if ( fraction <= 0 || fraction >= 1 ) { throw new IllegalArgumentException ( \"Percentile should be greater than 0 and less than 1\" ) ; } if ( vector . length <= 0 ) { throw new IllegalArgumentException ( \"Empty vector given\" ) ; } sort ( vector ) ; int index = ( int ) ( vector . length * fraction - 1 ) ;", "gt": "return vector [ index ] ;", "prediction": "}\n", "label": 0}
{"id": 6890, "input": "<s> package org . gatein . common . util ; import junit . framework . TestCase ; import org . gatein . common . util . MapBuilder ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . TreeMap ; @ SuppressWarnings ( \"unchecked\" ) public class MapBuilderTestCase extends TestCase { public void testHashMap1 ( ) { assertEquals ( new HashMap ( ) , MapBuilder . hashMap ( ) . get ( ) ) ; } public void testHashMap2 ( ) { HashMap < String , String > expected = new HashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; assertEquals ( expected , MapBuilder . hashMap ( \"a\" , \"b\" ) . get ( ) ) ; } public void testHashMap3 ( ) { HashMap < String , String > expected = new HashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . hashMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . get ( ) ) ; } public void testHashMap4 ( ) { HashMap < String , String > expected = new HashMap < String , String > ( ) ; expected . put ( \"a\" , \"d\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . hashMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . put ( \"a\" , \"d\" ) . get ( ) ) ; } public void testLinkedHashMap1 ( ) { assertEquals ( new LinkedHashMap ( ) , MapBuilder . linkedHashMap ( ) . get ( ) ) ; } public void testLinkedHashMap2 ( ) { LinkedHashMap < String , String > expected = new LinkedHashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; assertEquals ( expected , MapBuilder . linkedHashMap ( \"a\" , \"b\" ) . get ( ) ) ; } public void testLinkedHashMap3 ( ) { LinkedHashMap < String , String > expected = new LinkedHashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . linkedHashMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . get ( ) ) ; } public void testLinkedHashMap4 ( ) { LinkedHashMap < String , String > expected = new LinkedHashMap < String , String > ( ) ; expected . put ( \"a\" , \"d\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . linkedHashMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . put ( \"a\" , \"d\" ) . get ( ) ) ; } public void testTreeMap1 ( ) { assertEquals ( new TreeMap ( ) , MapBuilder . treeMap ( ) . get ( ) ) ; } public void testTreeMap2 ( ) { TreeMap < String , String > expected = new TreeMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; assertEquals ( expected , MapBuilder . treeMap ( \"a\" , \"b\" ) . get ( ) ) ; } public void testTreeMap3 ( ) { TreeMap < String , String > expected = new TreeMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . treeMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . get ( ) ) ; } public void testTreeMap4 ( ) { TreeMap < String , String > expected = new TreeMap < String , String > ( ) ; expected . put ( \"a\" , \"d\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . treeMap ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) . put ( \"a\" , \"d\" ) . get ( ) ) ; } public void testMap1 ( ) { assertEquals ( new HashMap ( ) , MapBuilder . create ( new HashMap < String , String > ( ) ) . get ( ) ) ; } public void testMap2 ( ) { Map < String , String > expected = new HashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; assertEquals ( expected , MapBuilder . create ( new HashMap < String , String > ( ) ) . put ( \"a\" , \"b\" ) . get ( ) ) ; } public void testMap3 ( ) { Map < String , String > expected = new HashMap < String , String > ( ) ; expected . put ( \"a\" , \"b\" ) ; expected . put ( \"c\" , \"d\" ) ; assertEquals ( expected , MapBuilder . create ( new HashMap < String , String > ( ) ) . put ( \"a\" , \"b\" ) . put ( \"c\" , \"d\" ) .", "gt": "get ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9185, "input": "<s> package ar . com . fdvs . dj . util ; import net . sf . jasperreports . engine . JRHyperlink ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignImage ; import net . sf . jasperreports . engine . design . JRDesignTextField ; import net . sf . jasperreports . engine . design . JasperDesign ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; public class HyperLinkUtil { static final Log log = LogFactory . getLog ( HyperLinkUtil . class ) ; public static void applyHyperLinkToElement ( DynamicJasperDesign design , DJHyperLink djlink , JRDesignImage image , String name ) { StringExpression hce = djlink . getExpression ( ) ; String text = ExpressionUtils . createCustomExpressionInvocationText ( name ) ; LayoutUtils . registerCustomExpressionParameter ( design , name , hce ) ; JRDesignExpression hlpe = new JRDesignExpression ( ) ; hlpe . setValueClassName ( hce . getClassName ( ) ) ; hlpe . setText ( text ) ; image . setHyperlinkReferenceExpression ( hlpe ) ; image . setHyperlinkType ( JRHyperlink . HYPERLINK_TYPE_REFERENCE ) ; if ( djlink . getTooltip ( ) != null ) { StringExpression sExp = djlink . getTooltip ( ) ; String tooltipParameterName = \"hyperlink_tooltip_\" + name ; String tooltipText = ExpressionUtils . createCustomExpressionInvocationText ( tooltipParameterName ) ; LayoutUtils . registerCustomExpressionParameter ( design , tooltipParameterName , sExp ) ; JRDesignExpression tooltipExp = new JRDesignExpression ( ) ; tooltipExp . setValueClassName ( sExp . getClassName ( ) ) ; tooltipExp . setText ( tooltipText ) ; image . setHyperlinkTooltipExpression ( tooltipExp ) ; } } public static void applyHyperLinkToElement ( DynamicJasperDesign design , DJHyperLink djlink , JRDesignTextField textField , String name ) { StringExpression", "gt": "hce = djlink . getExpression ( ) ;", "prediction": ";\n", "label": 0}
{"id": 6895, "input": "<s> package org . eclipse . core . tests . harness ; import junit . framework . Assert ; public class TestBarrier { public static final int STATUS_BLOCKED = 6 ; public static final int STATUS_DONE = 5 ; public static final int STATUS_RUNNING = 3 ; public static final int STATUS_START = 1 ; public static final int STATUS_WAIT_FOR_DONE = 4 ; public static final int STATUS_WAIT_FOR_RUN = 2 ; public static final int STATUS_WAIT_FOR_START = 0 ; private final int myIndex ; private final int [ ] myStatus ; private static void doWaitForStatus ( int [ ] statuses , int index , int status , int timeout ) { int i = 0 ; while ( statuses [ index ] != status ) { try { Thread . yield ( ) ; Thread . sleep ( 100 ) ; Thread . yield ( ) ; } catch ( InterruptedException e ) { } Assert . assertTrue ( \"Timeout waiting for status to change from \" + getStatus ( statuses [ index ] ) + \" to \" + getStatus ( status ) , i ++ < timeout ) ; } } private static String getStatus ( int status ) { switch ( status ) { case STATUS_WAIT_FOR_START : return \"WAIT_FOR_START\" ; case STATUS_START : return \"START\" ; case STATUS_WAIT_FOR_RUN : return \"WAIT_FOR_RUN\" ; case STATUS_RUNNING : return \"RUNNING\" ; case STATUS_WAIT_FOR_DONE : return \"WAIT_FOR_DONE\" ; case STATUS_DONE : return \"DONE\" ; case STATUS_BLOCKED : return \"BLOCKED\" ; default : return \"UNKNOWN_STATUS\" ; } } public static void waitForStatus ( int [ ] location , int status ) { doWaitForStatus ( location , 0 , status , 100 ) ; } public static void waitForStatus ( int [ ] location , int index , int status ) {", "gt": "doWaitForStatus ( location , index , status , 100 ) ;", "prediction": "}\n", "label": 1}
{"id": 1983, "input": "<s> package com . midtro . platform . modules . assets ; public class IndexEntry { private final long CRC ; private final String type ; private final String name ; private final String fileName ; public IndexEntry ( long CRC , String type , String name , String fileName ) { this . CRC = CRC ; this . type = type ;", "gt": "this . name = name ;", "prediction": "}\n", "label": 0}
{"id": 6898, "input": "<s> package com . cloudera . sqoop . mapreduce . db ; import org . apache . hadoop . conf . Configuration ; public class DBConfiguration extends org . apache . sqoop . mapreduce . db . DBConfiguration { public static final String DRIVER_CLASS_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . DRIVER_CLASS_PROPERTY ; public static final String URL_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . URL_PROPERTY ; public static final String USERNAME_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . USERNAME_PROPERTY ; public static final String PASSWORD_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . PASSWORD_PROPERTY ; public static final String FETCH_SIZE = org . apache . sqoop . mapreduce . db . DBConfiguration . FETCH_SIZE ; public static final String INPUT_TABLE_NAME_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_TABLE_NAME_PROPERTY ; public static final String INPUT_FIELD_NAMES_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_FIELD_NAMES_PROPERTY ; public static final String INPUT_CONDITIONS_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_CONDITIONS_PROPERTY ; public static final String INPUT_ORDER_BY_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_ORDER_BY_PROPERTY ; public static final String INPUT_QUERY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_QUERY ; public static final String INPUT_COUNT_QUERY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_COUNT_QUERY ; public static final String INPUT_BOUNDING_QUERY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_BOUNDING_QUERY ; public static final String INPUT_CLASS_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . INPUT_CLASS_PROPERTY ; public static final String OUTPUT_TABLE_NAME_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . OUTPUT_TABLE_NAME_PROPERTY ; public static final String OUTPUT_FIELD_NAMES_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . OUTPUT_FIELD_NAMES_PROPERTY ; public static final String OUTPUT_FIELD_COUNT_PROPERTY = org . apache . sqoop . mapreduce . db . DBConfiguration . OUTPUT_FIELD_COUNT_PROPERTY ; public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd , Integer fetchSize ) { org . apache . sqoop . mapreduce . db . DBConfiguration . configureDB ( conf , driverClass , dbUrl , userName , passwd , fetchSize ) ; } public static void configureDB ( Configuration job , String driverClass , String dbUrl , Integer fetchSize ) { org . apache . sqoop . mapreduce . db . DBConfiguration . configureDB ( job , driverClass , dbUrl , fetchSize ) ; } public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd ) { org . apache . sqoop . mapreduce . db . DBConfiguration . configureDB ( conf , driverClass , dbUrl , userName , passwd ) ; } public static void configureDB ( Configuration job , String driverClass , String dbUrl ) { org . apache . sqoop . mapreduce . db . DBConfiguration . configureDB ( job , driverClass , dbUrl ) ; } public", "gt": "DBConfiguration ( Configuration job )", "prediction": "void ( )\n", "label": 1}
{"id": 2689, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . util . * ; public class Cache { private interface Element { public boolean expired ( ) ; public int compareCredibility ( int cred ) ; public int getType ( ) ; } private static int limitExpire ( long ttl , long maxttl ) { if ( maxttl >= 0 && maxttl < ttl ) ttl = maxttl ; long expire = ( System . currentTimeMillis ( ) / 1000 ) + ttl ; if ( expire < 0 || expire > Integer . MAX_VALUE ) return Integer . MAX_VALUE ; return ( int ) expire ; } private static class CacheRRset extends RRset implements Element { private static final long serialVersionUID = 5971755205903597024L ; int credibility ; int expire ; public CacheRRset ( Record rec , int cred , long maxttl ) { super ( ) ; this . credibility = cred ; this . expire = limitExpire ( rec . getTTL ( ) , maxttl ) ; addRR ( rec ) ; } public CacheRRset ( RRset rrset , int cred , long maxttl ) { super ( rrset ) ; this . credibility = cred ; this . expire = limitExpire ( rrset . getTTL ( ) , maxttl ) ; } public final boolean expired ( ) { int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; return ( now >= expire ) ; } public final int compareCredibility ( int cred ) { return credibility - cred ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( super . toString ( ) ) ; sb . append ( \" cl = \" ) ; sb . append ( credibility ) ; return sb . toString ( ) ; } } private static class NegativeElement implements Element { int type ; Name name ; int credibility ; int expire ; public NegativeElement ( Name name , int type , SOARecord soa , int cred , long maxttl ) { this . name = name ; this . type = type ; long cttl = 0 ; if ( soa != null ) cttl = soa . getMinimum ( ) ; this . credibility = cred ; this . expire = limitExpire ( cttl , maxttl ) ; } public int getType ( ) { return type ; } public final boolean expired ( ) { int now = ( int ) ( System . currentTimeMillis ( ) / 1000 ) ; return ( now >= expire ) ; } public final int compareCredibility ( int cred ) { return credibility - cred ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( type == 0 ) sb . append ( \"NXDOMAIN \" + name ) ; else sb . append ( \"NXRRSET \" + name + \" \" + Type . string ( type ) ) ; sb . append ( \" cl = \" ) ; sb . append ( credibility ) ; return sb . toString ( ) ; } } private static class CacheMap extends LinkedHashMap { private int maxsize = - 1 ; CacheMap ( int maxsize ) { super ( 16 , ( float ) 0.75 , true ) ; this . maxsize = maxsize ; } int getMaxSize ( ) { return maxsize ; } void setMaxSize ( int maxsize ) { this . maxsize = maxsize ; } protected boolean removeEldestEntry ( Map . Entry eldest ) { return maxsize >= 0 && size ( ) > maxsize ; } } private CacheMap data ; private int maxncache = - 1 ; private int maxcache = - 1 ; private int dclass ; private static final int defaultMaxEntries = 50000 ; public Cache ( int dclass ) { this . dclass = dclass ; data = new CacheMap ( defaultMaxEntries ) ; } public Cache ( ) { this ( DClass . IN ) ; } public Cache ( String file ) throws IOException { data = new CacheMap ( defaultMaxEntries ) ; Master m = new Master ( file ) ; Record record ; while ( ( record = m . nextRecord ( ) ) != null ) addRecord ( record , Credibility . HINT , m ) ; } private synchronized Object exactName ( Name name ) { return data . get ( name ) ; } private", "gt": "synchronized void removeName ( Name name )", "prediction": "( ) ;\n", "label": 0}
{"id": 6901, "input": "<s> package br . org . archimedes . parser ; import br . org . archimedes . Utils ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NoActiveDrawingException ; import br . org . archimedes . interfaces . Parser ; import br . org . archimedes . model . Selection ; public class SelectionOrDoubleParser implements Parser { private Selection selection ; private Double value ; private boolean done ; public SelectionOrDoubleParser ( ) { done = false ; selection = null ; value = null ; br . org . archimedes . Utils . getController ( ) . deselectAll ( ) ; } public String next ( String message ) throws InvalidParameterException { if ( Utils . isDouble ( message ) ) { value = Math . abs ( ( Double ) Utils . getDouble ( message ) ) ; done = true ; } else { try { selection = br . org . archimedes . Utils . getController ( ) . getCurrentSelection ( ) ; } catch ( NoActiveDrawingException e ) { e . printStackTrace ( ) ; } if ( selection . isEmpty ( ) ) { selection = null ; throw", "gt": "new InvalidParameterException ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3691, "input": "<s> package com . extjs . gxt . ui . client . widget ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . Style . SelectionMode ; import com . extjs . gxt . ui . client . aria . FocusFrame ; import com . extjs . gxt . ui . client . core . CompositeElement ; import com . extjs . gxt . ui . client . core . DomQuery ; import com . extjs . gxt . ui . client . core . XDOM ; import com . extjs . gxt . ui . client . core . XTemplate ; import com . extjs . gxt . ui . client . data . BaseModel ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . data . ModelProcessor ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . ListViewEvent ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . store . StoreEvent ; import com . extjs . gxt . ui . client . store . StoreListener ; import com . extjs . gxt . ui . client . util . Util ; import com . extjs . gxt . ui . client . widget . tips . QuickTip ; import com . google . gwt . dom . client . Node ; import com . google . gwt . dom . client . NodeList ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; public class ListView < M extends ModelData > extends BoxComponent { protected int rowSelectorDepth = 5 ; protected ListStore < M > store ; private CompositeElement all ; private String displayProperty = \"text\" ; private boolean enableQuickTip = true ; private String itemSelector = \".x-view-item\" ; private String loadingText ; private ModelProcessor < M > modelProcessor ; private Element overElement ; private String overStyle = \"x-view-item-over\" ; private QuickTip quickTip ; private boolean selectOnHover ; private String selectStyle = \"x-view-item-sel\" ; private ListViewSelectionModel < M > sm ; private StoreListener < M > storeListener ; private XTemplate template ; public ListView ( ) { initComponent ( ) ; setSelectionModel ( new ListViewSelectionModel < M > ( ) ) ; all = new CompositeElement ( ) ; baseStyle = \"x-view\" ; disableTextSelection ( true ) ; } public ListView ( ListStore < M > store ) { this ( ) ; setStore ( store ) ; } public ListView ( ListStore < M > store , XTemplate template ) { this ( store ) ; this . template = template ; } public Element findElement ( Element element ) { return fly ( element ) . findParentElement ( itemSelector , rowSelectorDepth ) ; } public int findElementIndex ( Element element ) { Element elem = findElement ( element ) ; if ( elem != null ) { return indexOf ( elem ) ; } return - 1 ; } public String getDisplayProperty ( ) { return displayProperty ; } public Element getElement ( int index ) { return all . getElement ( index ) ; } public List < Element > getElements ( ) { return all . getElements ( ) ; } public int getItemCount ( ) { return store == null ? 0 : store . getCount ( ) ; } public String getItemSelector ( ) { return itemSelector ; } public String getLoadingText ( ) { return loadingText ; } public ModelProcessor < M > getModelProcessor ( ) { return modelProcessor ; } public String getOverStyle ( ) { return overStyle ; } public QuickTip getQuickTip ( ) { return quickTip ; } public ListViewSelectionModel < M > getSelectionModel ( ) { return sm ; } public boolean getSelectOnOver ( ) { return selectOnHover ; } public String getSelectStyle ( ) { return selectStyle ; } public ListStore < M > getStore ( ) { return store ; } public XTemplate getTemplate ( ) { return template ; } public int indexOf ( Element element ) { if ( element . getPropertyString ( \"viewIndex\" ) != null ) { return element . getPropertyInt ( \"viewIndex\" ) ; } return all . indexOf ( element ) ; } public boolean isEnableQuickTips ( ) { return enableQuickTip ; } public void moveSelectedDown ( ) { List < M > sel = getSelectionModel ( ) . getSelectedItems ( ) ; Collections . sort ( sel , new Comparator < M > ( ) { @ Override public", "gt": "int compare ( M o1 , M o2 )", "prediction": "( )\n", "label": 0}
{"id": 6906, "input": "<s> package org . eclipse . rap . rwt . internal . theme . css ; import org . w3c . css . sac . * ; public class NullDescendantSelector implements DescendantSelector , SelectorExt { public Selector getAncestorSelector ( ) { return null ; } public SimpleSelector getSimpleSelector ( ) { return null ; } public short getSelectorType ( ) { return SAC_DESCENDANT_SELECTOR ; }", "gt": "public String getElementName ( )", "prediction": "}\n", "label": 1}
{"id": 5117, "input": "<s> package LizaCraft . Block ; import java . util . Collection ; import org . bukkit . Chunk ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Biome ; import org . bukkit . block . Block ; import org . bukkit . block . BlockFace ; import org . bukkit . block . BlockState ; import org . bukkit . block . PistonMoveReaction ; import org . bukkit . inventory . ItemStack ; import Liza . LizaBlock ; public class LizaCraftBlock implements LizaBlock { private Block block ; public LizaCraftBlock ( Block block ) { this . block = block ; } public boolean assertBlockType ( Material type ) { return this . getType ( ) . equals ( type ) ; } @ Override public Biome getBiome ( ) { return this . block . getBiome ( ) ; } @ Override public int getBlockPower ( ) { return this . block . getBlockPower ( ) ; } @ Override public int getBlockPower ( BlockFace arg0 ) { return this . block . getBlockPower ( arg0 ) ; } @ Override public Chunk getChunk ( ) { return this . block . getChunk ( ) ; } @ Override public byte getData ( ) { return this . block . getData ( ) ; } @ Override @ Deprecated public Block getFace ( BlockFace arg0 ) { return new LizaCraftBlock ( this . block . getFace ( arg0 ) ) ; } @ Override public BlockFace getFace ( Block arg0 ) { return this . block . getFace ( arg0 ) ; } @ Override public Block getFace ( BlockFace arg0 , int arg1 ) { return this . block . getFace ( arg0 , arg1 ) ; } @ Override public double getHumidity ( ) { return this . block . getHumidity ( ) ; } @ Override public byte getLightLevel ( ) { return this . block . getLightLevel ( ) ; } @ Override public Location getLocation ( ) { return this . block . getLocation ( ) ; } @ Override public PistonMoveReaction getPistonMoveReaction ( ) { return this . block . getPistonMoveReaction ( ) ; } @ Override public Block getRelative ( BlockFace arg0 ) { return this . block . getRelative ( arg0 ) ; } @ Override public Block getRelative ( BlockFace arg0 , int arg1 ) { return this . block . getRelative ( arg0 , arg1 ) ; } @ Override public Block getRelative ( int arg0 , int arg1 , int arg2 ) { return this . block . getRelative ( arg0 , arg1 , arg2 ) ; } @ Override public BlockState getState ( ) { return this . block . getState ( ) ; } @ Override public double getTemperature ( ) { return this . block . getTemperature ( ) ; } @ Override public Material getType ( ) { return this . block . getType ( ) ; } @ Override public int getTypeId ( ) { return this . block . getTypeId ( ) ; } @ Override public World getWorld ( ) { return this . block . getWorld ( ) ; } @ Override public int getX ( ) { return this . block . getX ( ) ; } @ Override public int getY ( ) { return this . block . getY ( ) ; } @ Override public int getZ ( ) { return this . block . getZ ( ) ; } @ Override public boolean isBlockFaceIndirectlyPowered ( BlockFace arg0 ) { return this . block . isBlockFaceIndirectlyPowered ( arg0 ) ; } @ Override public boolean isBlockFacePowered ( BlockFace arg0 ) { return this . block . isBlockFacePowered ( arg0 ) ; } @", "gt": "Override public boolean isBlockIndirectlyPowered ( )", "prediction": "}\n", "label": 0}
{"id": 6911, "input": "<s> package org . eclipse . xtext . xdoc . images . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . impl . EFactoryImpl ; import org . eclipse . emf . ecore . plugin . EcorePlugin ; import org . eclipse . xtext . xdoc . images . * ; public class ImagesFactoryImpl extends EFactoryImpl implements ImagesFactory { public static ImagesFactory init ( ) { try { ImagesFactory theImagesFactory = ( ImagesFactory ) EPackage . Registry . INSTANCE . getEFactory ( \"http://eclipse.org/Xtext/xdoc/imageProxy\" ) ; if ( theImagesFactory != null ) { return theImagesFactory ; } } catch ( Exception exception ) { EcorePlugin . INSTANCE . log ( exception ) ; } return new ImagesFactoryImpl ( ) ; } public ImagesFactoryImpl ( ) { super ( ) ; } @ Override public EObject create ( EClass eClass ) { switch ( eClass . getClassifierID ( ) ) { case ImagesPackage . IMAGE_PROXY : return createImageProxy ( ) ; default : throw new IllegalArgumentException ( \"The class '\" + eClass . getName ( ) + \"' is not a valid classifier\" ) ; } } public ImageProxy createImageProxy ( ) { ImageProxyImpl imageProxy = new ImageProxyImpl ( ) ; return imageProxy ; }", "gt": "public ImagesPackage getImagesPackage ( )", "prediction": "}\n", "label": 1}
{"id": 5797, "input": "<s> package org . dawb . workbench . plotting . system . dialog ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . workbench . plotting . system . swtxy . RegionArea ; import org . dawb . workbench . plotting . system . swtxy . XYRegionGraph ; import org . dawb . workbench . plotting . system . swtxy . selection . AbstractSelectionRegion ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; public class RemoveRegionDialog extends Dialog { private XYRegionGraph xyGraph ; private Combo regionCombo ; private AbstractSelectionRegion removedRegion ; public RemoveRegionDialog ( Shell parentShell , XYRegionGraph xyGraph ) { super ( parentShell ) ; this . xyGraph = xyGraph ; setShellStyle ( getShellStyle ( ) | SWT . RESIZE ) ; } @ Override protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( \"Remove Region\" ) ; } @ Override protected Control createDialogArea ( Composite parent ) { final Composite parent_composite = ( Composite ) super . createDialogArea ( parent ) ; final Composite composite = new Composite ( parent_composite , SWT . NONE ) ; composite . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; composite . setLayout ( new GridLayout ( 1 , false ) ) ; final Label removeLabel = new Label ( composite , SWT . None ) ; removeLabel . setLayoutData ( new", "gt": "GridData ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6914, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . automation . core . scripting . Scripting ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . core . api . PathRef ; public class StringToDocRef implements TypeAdapter { public DocumentRef getAdaptedValue ( OperationContext ctx , Object objectToAdapt ) throws TypeAdaptException { try { String value = ( String ) objectToAdapt ; if ( value . startsWith ( \".\" ) ) { Object obj = Scripting . newExpression ( \"Document.resolvePathAsRef(\\\"\" +", "gt": "value + \"\\\")\" ) . eval ( ctx ) ;", "prediction": ") ;\n", "label": 1}
{"id": 993, "input": "<s> import java . util . Set ; import java . util . HashSet ; import java . util . Arrays ; import javax . annotation . processing . * ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import static javax . tools . Diagnostic . Kind . * ; @ SupportedAnnotationTypes ( \"*\" ) @ SupportedOptions ( \"SourceVersion\" ) public class TestSourceVersionWarnings extends AbstractProcessor { @ Override public SourceVersion getSupportedSourceVersion ( ) { String sourceVersion = processingEnv . getOptions ( ) . get ( \"SourceVersion\" ) ; if ( sourceVersion == null ) { processingEnv . getMessager ( ) . printMessage ( WARNING , \"No SourceVersion option given\" ) ; return SourceVersion . RELEASE_6 ; } else { return SourceVersion . valueOf ( sourceVersion ) ; } } public boolean process ( Set < ?", "gt": "extends TypeElement > annotations , RoundEnvironment roundEnvironment )", "prediction": ")\n", "label": 0}
{"id": 6928, "input": "<s> package org . eclipse . ui . tests . contexts ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . contexts . EnabledSubmission ; import org . eclipse . ui . contexts . IContext ; import org . eclipse . ui . contexts . IWorkbenchContextSupport ; import org . eclipse . ui . tests . harness . util . UITestCase ; public final class Bug74990Test extends UITestCase { public Bug74990Test ( final String name ) { super ( name ) ; } public final void testPartIdSubmission ( ) throws PartInitException { final String testContextId = \"org.eclipse.ui.tests.contexts.Bug74990\" ; final IWorkbenchContextSupport contextSupport = fWorkbench . getContextSupport ( ) ; final IContext testContext = contextSupport . getContextManager ( ) . getContext ( testContextId ) ; final EnabledSubmission testSubmission = new EnabledSubmission ( \"org.eclipse.ui.tests.api.MockViewPart\" , null , null , testContextId ) ; contextSupport . addEnabledSubmission ( testSubmission ) ; try { assertTrue ( \"The MockViewPart context should not be enabled\" , ! testContext . isEnabled ( ) ) ; final IWorkbenchPage page = openTestWindow ( ) . getActivePage ( ) ;", "gt": "final IViewPart openedView = page . showView ( \"org.eclipse.ui.tests.api.MockViewPart\" ) ;", "prediction": "}\n", "label": 1}
{"id": 7856, "input": "<s> class T6730476a { @ SuppressWarnings ( \"unchecked\" ) < T > void f ( int i , T ... x ) { } void g ( ) {", "gt": "f ( 1 ) ;", "prediction": "}\n", "label": 0}
{"id": 6929, "input": "<s> package org . mitre . openid . connect . config ; public class ConfigurationPropertiesBean { private String issuer ; private String defaultJwtSigner ; public ConfigurationPropertiesBean ( ) { } public String getDefaultJwtSigner ( ) { return defaultJwtSigner ; } public void setDefaultJwtSigner ( String signer ) { defaultJwtSigner = signer ; }", "gt": "public String getIssuer ( )", "prediction": "}\n", "label": 1}
{"id": 7225, "input": "<s> package com . redhat . ceylon . tools . help ; import java . io . IOException ; import org . tautua . markdownpapers . HtmlEmitter ; import org . tautua . markdownpapers . ast . Node ; class Html { private final Appendable out ; private IOException error ; public Html ( Appendable out ) { this . out = out ; } private Html append ( String s ) { if ( error == null ) { try { out . append ( s ) ; } catch ( IOException e ) { error = e ; } } return this ; } private Html append ( char s ) { if ( error == null ) { try { out . append ( s ) ; } catch ( IOException e ) { error = e ; } } return this ; } public Html open ( String ... tags ) { for ( String tag : tags ) { open ( tag ) ; } return this ; } public Html open ( String tag ) { append ( '<' ) . append ( tag ) . append ( '>' ) ; return this ; } public Html close ( String ... tags ) { for ( String tag : tags ) { close ( tag ) ; } return this ; } public Html close ( String tag ) { append ( \"</\" ) . append ( tag", "gt": ") . append ( '>' ) ;", "prediction": ") ;\n", "label": 0}
{"id": 6937, "input": "<s> package org . apache . sqoop . lib ; import java . util . Map ; public interface FieldMappable {", "gt": "Map < String , Object > getFieldMap ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9005, "input": "<s> import java . lang . reflect . Constructor ; import java . lang . annotation . Documented ; class T6400189a { Constructor c = null ; Documented", "gt": "d = c . getAnnotation ( Documented . class ) ;", "prediction": ";\n", "label": 0}
{"id": 6953, "input": "<s> package org . eclipse . ui . tests . harness . util ; import java . util . Random ; public class ArrayUtil { private static Random randomBox = new Random ( ) ; public static Object pickRandom ( Object [ ] array ) { int num = randomBox . nextInt ( array . length ) ; return array [ num ] ; } public static boolean checkNotNull ( Object [ ] array ) { if ( array == null ) return false ; else { for ( int i = 0 ; i < array . length ; i ++ ) if ( array [ i ] == null ) return false ; return true ; } } public static boolean contains ( Object [ ] array , Object element ) { if ( array ==", "gt": "null || element == null ) return false ;", "prediction": ")\n", "label": 1}
{"id": 4311, "input": "<s> class Unchecked < T > { void f ( Unchecked u ) {", "gt": "Unchecked < String > us = u ;", "prediction": "}\n", "label": 0}
{"id": 6955, "input": "<s> package org . restlet . ext . osgi ; import java . util . Dictionary ; import org . osgi . service . http . HttpContext ; import org . restlet . Application ; import org . restlet . Context ; public interface IApplicationProvider { String COMPONENT_ATTRIBUTE = \"org.restlet.ext.servlet.ServerServlet.component.org.eclipselabs.restlet.servlet.ApplicationServlet\" ; String SERVLET_CONFIG_ATTRIBUTE = \"javax.servlet.ServletConfig\" ; String SERVLET_CONTEXT_ATTRIBUTE = \"org.restlet.ext.servlet.ServletContext\" ; Application createApplication ( Context context ) ; String getAlias ( ) ; HttpContext getContext ( ) ; Dictionary <", "gt": "String , Object > getInitParms ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 8273, "input": "<s> package com . matburt . mobileorg . OrgData ; import android . app . Application ; import com . matburt . mobileorg . Services . SyncService ; public class MobileOrgApplication extends Application { @ Override public void onCreate ( ) { SyncService", "gt": ". startAlarm ( getApplicationContext ( ) ) ;", "prediction": "\n", "label": 0}
{"id": 6957, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers ; import org . restlet . ext . jaxrs . internal . util . PathRegExp ; public interface ResourceMethodOrLocator extends RrcOrRml { public String getName ( ) ;", "gt": "public PathRegExp getPathRegExp ( ) ;", "prediction": "}\n", "label": 1}
{"id": 10017, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . taglets . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class HtmlSerialFieldWriter extends FieldWriterImpl implements SerializedFormWriter . SerialFieldWriter { ProgramElementDoc [ ] members = null ; private boolean printedOverallAnchor = false ; public HtmlSerialFieldWriter ( SubWriterHolderWriter writer , ClassDoc classdoc ) { super ( writer , classdoc ) ; } public List < FieldDoc > members ( ClassDoc cd ) { return Arrays . asList ( cd . serializableFields ( ) ) ; } protected void printTypeLinkNoDimension ( Type type ) { ClassDoc cd = type . asClassDoc ( ) ; if ( type . isPrimitive ( ) || cd . isPackagePrivate ( ) ) { print ( type . typeName ( ) ) ; } else { writer . printLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_SERIAL_MEMBER , type ) ) ; } } public Content getSerializableFieldsHeader ( ) { HtmlTree ul = new HtmlTree ( HtmlTag . UL ) ; ul . addStyle ( HtmlStyle . blockList ) ; return ul ; } public Content getFieldsContentHeader ( boolean isLastContent ) { HtmlTree li = new HtmlTree ( HtmlTag . LI ) ; if ( isLastContent ) li . addStyle ( HtmlStyle . blockListLast ) ; else li . addStyle ( HtmlStyle . blockList ) ; return li ; } public Content getSerializableFields ( String heading , Content serializableFieldsTree ) { HtmlTree li = new HtmlTree ( HtmlTag . LI ) ; li . addStyle ( HtmlStyle . blockList ) ; if ( serializableFieldsTree . isValid ( ) ) { if ( ! printedOverallAnchor ) { li . addContent ( writer . getMarkerAnchor ( \"serializedForm\" ) ) ; printedOverallAnchor = true ; } Content headingContent = new StringContent ( heading ) ; Content serialHeading = HtmlTree . HEADING ( HtmlConstants . SERIALIZED_MEMBER_HEADING , headingContent ) ; li . addContent ( serialHeading ) ; li . addContent ( serializableFieldsTree ) ; } return li ; } public void addMemberHeader ( ClassDoc fieldType , String fieldTypeStr , String fieldDimensions , String fieldName , Content contentTree ) { Content nameContent = new RawHtml ( fieldName ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . MEMBER_HEADING , nameContent ) ; contentTree . addContent ( heading ) ; Content pre = new HtmlTree ( HtmlTag . PRE ) ; if ( fieldType == null ) { pre . addContent ( fieldTypeStr ) ; } else { Content fieldContent = new RawHtml ( writer . getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_SERIAL_MEMBER , fieldType ) ) ) ; pre . addContent ( fieldContent ) ; } pre . addContent ( fieldDimensions + \" \" ) ; pre . addContent ( fieldName ) ; contentTree . addContent ( pre ) ; } public void addMemberDeprecatedInfo ( FieldDoc field , Content contentTree ) { addDeprecatedInfo ( field , contentTree ) ; } public void addMemberDescription ( FieldDoc field , Content contentTree ) { if ( field", "gt": ". inlineTags ( ) . length > 0 )", "prediction": ") ;\n", "label": 0}
{"id": 6987, "input": "<s> package org . seage . experimenter . reporting . rapidminer ; import java . io . File ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . seage . thread . TaskRunner ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; import com . rapidminer . Process ; import com . rapidminer . RapidMiner ; import com . rapidminer . example . Attribute ; import com . rapidminer . example . table . AttributeFactory ; import com . rapidminer . example . table . DataRow ; import com . rapidminer . example . table . DoubleArrayDataRow ; import com . rapidminer . example . table . ListDataRowReader ; import com . rapidminer . example . table . MemoryExampleTable ; import com . rapidminer . operator . IOContainer ; import com . rapidminer . operator . Operator ; import com . rapidminer . operator . OperatorCreationException ; import com . rapidminer . operator . OperatorException ; import com . rapidminer . operator . io . RepositoryStorer ; import com . rapidminer . repository . Repository ; import com . rapidminer . repository . RepositoryException ; import com . rapidminer . repository . RepositoryManager ; import com . rapidminer . repository . local . LocalRepository ; import com . rapidminer . tools . Ontology ; import com . rapidminer . tools . OperatorService ; public class ExperimentLogImporter { private static Logger _logger = Logger . getLogger ( ExperimentLogImporter . class . getName ( ) ) ; private String _logPath ; private String _repoName ; private final String RAPIDMINER_LOCAL_REPOSITORY_NAME = \"seage\" ; private final String RAPIDMINER_LOCAL_REPOSITORY_DIR_PATH = \"repository\" ; private Hashtable < RMDataTableInfo , List < DataRow > > _rmDataTables ; private Hashtable < String , Hashtable < String , XPath > > _xPaths ; public ExperimentLogImporter ( String logPath , String repoName ) throws RepositoryException { _logPath = logPath ; _repoName = repoName ; _rmDataTables = new Hashtable < RMDataTableInfo , List < DataRow > > ( ) ; RMDataTableInfo expValues = new RMDataTableInfo ( \"ExperimentValues\" ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"ExperimentID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"ProblemID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"AlgorithmID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"InstanceID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"ConfigID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"RunID\" , Ontology . NOMINAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"InitSolutionValue\" , Ontology . REAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"BestSolutionValue\" , Ontology . REAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"NrOfNewSolutions\" , Ontology . REAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"NrOfIterations\" , Ontology . REAL ) ) ; expValues . Attributes . add ( new RMAttributeInfo ( \"LastIterNumberNewSol\" , Ontology . REAL ) ) ; _rmDataTables . put ( expValues , new ArrayList < DataRow > ( ) ) ; _xPaths = new Hashtable < String , Hashtable < String , XPath > > ( ) ; Hashtable < String , XPath > v01 = new Hashtable < String , XPath > ( ) ; v01 . put ( \"ExperimentID\" , new XPath ( \"/ExperimentTask/Config/@runID\" ) ) ; v01 . put ( \"ProblemID\" , new XPath ( \"/ExperimentTask/Config/Problem/@id\" ) ) ; v01 . put ( \"AlgorithmID\" , new XPath ( \"/ExperimentTask/Config/Algorithm/@id\" ) ) ; v01 . put ( \"InstanceID\" , new XPath ( \"/ExperimentTask/Config/Problem/Instance/@name\" ) ) ; v01 . put ( \"ConfigID\" , new XPath ( \"/ExperimentTask/Config/@configID\" ) ) ; v01 . put ( \"RunID\" , new XPath ( \"/ExperimentTask/AlgorithmReport/@created\" ) ) ; v01 . put ( \"InitSolutionValue\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@initObjVal\" ) ) ; v01 . put ( \"BestSolutionValue\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@bestObjVal\" ) ) ; v01 . put ( \"NrOfNewSolutions\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@numberOfNewSolutions\" ) ) ; v01 . put ( \"LastIterNumberNewSol\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@lastIterNumberNewSol\" ) ) ; v01 . put ( \"NrOfIterations\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@numberOfIter\" ) ) ; Hashtable < String , XPath > v02 = new Hashtable < String , XPath > ( ) ; v02 . put ( \"ExperimentID\" , new XPath ( \"/ExperimentTask/@experimentID\" ) ) ; v02 . put ( \"ProblemID\" , new XPath ( \"/ExperimentTask/Config/Problem/@id\" ) ) ; v02 . put ( \"AlgorithmID\" , new XPath ( \"/ExperimentTask/Config/Algorithm/@id\" ) ) ; v02 . put ( \"InstanceID\" , new XPath ( \"/ExperimentTask/Config/Problem/Instance/@name\" ) ) ; v02 . put ( \"ConfigID\" , new XPath ( \"/ExperimentTask/Config/@configID\" ) ) ; v02 . put ( \"RunID\" , new XPath ( \"/ExperimentTask/@runID\" ) ) ; v02 . put ( \"InitSolutionValue\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@initObjVal\" ) ) ; v02 . put ( \"BestSolutionValue\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@bestObjVal\" ) ) ; v02 . put ( \"NrOfNewSolutions\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@numberOfNewSolutions\" ) ) ; v02 . put ( \"LastIterNumberNewSol\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@lastIterNumberNewSol\" ) ) ; v02 . put ( \"NrOfIterations\" , new XPath ( \"/ExperimentTask/AlgorithmReport/Statistics/@numberOfIter\" ) ) ; Hashtable < String , XPath > v03 = new Hashtable < String , XPath > ( ) ; v03 . put ( \"ExperimentID\" , new XPath ( \"/ExperimentTask/@experimentID\" ) ) ; v03 . put ( \"ProblemID\" , new XPath ( \"/ExperimentTask/Config/Problem/@id\" ) ) ; v03 . put ( \"AlgorithmID\" , new XPath ( \"/ExperimentTask/Config/Algorithm/@id\" ) ) ; v03 . put ( \"InstanceID\" , new XPath ( \"/ExperimentTask/Config/Problem/Instance/@name\" ) ) ; v03 . put ( \"ConfigID\" , new XPath", "gt": "( \"/ExperimentTask/Config/@configID\" ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7393, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import static org . parboiled . common . StringUtils . escape ; import org . parboiled . MatcherContext ; import org . parboiled . matchervisitors . MatcherVisitor ; public class CharRangeMatcher extends AbstractMatcher { public final char cLow ; public final char cHigh ; public CharRangeMatcher ( char cLow , char cHigh ) { super ( escape ( cLow ) + \"..\" + escape ( cHigh ) ) ; checkArgument ( cLow < cHigh ) ; this . cLow = cLow ; this . cHigh = cHigh ; } public boolean match ( MatcherContext context ) { char c = context . getCurrentChar ( ) ; if ( c < cLow || c > cHigh ) return false ; context . advanceIndex ( 1 ) ; context . createNode ( ) ; return true ; } public <", "gt": "R > R accept ( MatcherVisitor < R > visitor )", "prediction": "( )\n", "label": 0}
{"id": 6993, "input": "<s> package com . corundumstudio . socketio ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicInteger ; import junit . framework . Assert ; import mockit . Mocked ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . UpstreamMessageEvent ; import org . junit . Before ; import org . junit . Test ; import com . corundumstudio . socketio . ack . AckManager ; import com . corundumstudio . socketio . handler . PacketHandler ; import com . corundumstudio . socketio . messages . PacketsMessage ; import com . corundumstudio . socketio . namespace . Namespace ; import com . corundumstudio . socketio . namespace . NamespacesHub ; import com . corundumstudio . socketio . parser . Decoder ; import com . corundumstudio . socketio . parser . Encoder ; import com . corundumstudio . socketio . parser . JacksonJsonSupport ; import com . corundumstudio . socketio . parser . JsonSupport ; import com . corundumstudio . socketio . parser . Packet ; import com . corundumstudio . socketio . parser . PacketType ; import com . corundumstudio . socketio . transport . BaseClient ; public class PacketHandlerTest { private JsonSupport map = new JacksonJsonSupport ( new Configuration ( ) ) ; private Decoder decoder = new Decoder ( map , new AckManager ( null ) ) ; private Encoder encoder = new Encoder ( map ) ; private NamespacesHub namespacesHub = new NamespacesHub ( map ) ; @ Mocked private Channel channel ; @ Mocked private BaseClient client ; private final AtomicInteger invocations = new AtomicInteger ( ) ; @ Before public void before ( ) { if ( namespacesHub . get ( Namespace . DEFAULT_NAME ) == null ) { namespacesHub . create ( Namespace . DEFAULT_NAME ) ; } invocations . set ( 0 ) ; } private PacketListener createTestListener ( final List < Packet > packets ) { PacketListener listener = new PacketListener ( null , null , null ) { @ Override public void onPacket ( Packet packet , SocketIOClient client , AckRequest ackRequest ) { int index = invocations . incrementAndGet ( ) ; Packet currentPacket = packets . get ( index - 1 ) ; Assert . assertEquals ( currentPacket . getType ( ) , packet . getType ( ) ) ; Assert . assertEquals ( currentPacket . getData ( ) , packet . getData ( ) ) ; } } ; return listener ; } @ Test public void testOnePacket ( ) throws Exception { List < Packet > packets = new ArrayList < Packet > ( ) ; Packet packet = new Packet ( PacketType . JSON ) ; packet . setData ( Collections . singletonMap ( \"test1\" , \"test2\" ) ) ; packets . add ( packet ) ; PacketListener listener = createTestListener ( packets ) ; PacketHandler handler = new PacketHandler ( listener , decoder , namespacesHub ) ; testHandler ( handler , new ConcurrentLinkedQueue < Packet > ( packets ) ) ; } @ Test public void testUTF8MultiplePackets ( ) throws Exception { List < Packet > packets = new ArrayList < Packet > ( ) ; Packet packet3 = new Packet ( PacketType . CONNECT ) ; packets . add ( packet3 ) ; Packet packet = new Packet ( PacketType . JSON ) ; packet . setData ( Collections . singletonMap ( \"test1\" , \"\u0414\u0430\u043d\u043d\u044b\u0435\" ) ) ; packets . add ( packet ) ; Packet packet1 = new Packet ( PacketType . JSON ) ; packet1 . setData ( Collections . singletonMap ( \"\u041f\u0440\u0438\ufffd\u0432\u0435\u0442\" , \"wq\ufffdeq\" ) ) ; packets . add ( packet1 ) ; PacketListener listener = createTestListener ( packets ) ; PacketHandler handler = new PacketHandler ( listener , decoder , namespacesHub ) ; testHandler ( handler , new ConcurrentLinkedQueue < Packet > ( packets ) ) ; } @ Test public void testMultiplePackets ( ) throws Exception { List < Packet > packets = new ArrayList < Packet > ( ) ; Packet packet3 = new Packet ( PacketType . CONNECT ) ; packets . add ( packet3 ) ; Packet packet = new Packet ( PacketType . JSON ) ; packet . setData ( Collections . singletonMap ( \"test1\" , \"test2\" ) ) ; packets . add ( packet ) ; Packet packet1 = new Packet ( PacketType . JSON ) ; packet1 . setData ( Collections . singletonMap ( \"fsdfdf\" , \"wqeq\" ) ) ; packets . add ( packet1 ) ; PacketListener listener = createTestListener ( packets ) ; PacketHandler handler = new PacketHandler ( listener , decoder , namespacesHub ) ; testHandler ( handler , new ConcurrentLinkedQueue < Packet > ( packets ) ) ; } private void testHandler ( PacketHandler handler , Queue < Packet > packets ) throws Exception { int size = packets . size ( ) ; ChannelBuffer buffer = encoder . encodePackets ( packets ) ; handler . messageReceived ( null , new UpstreamMessageEvent ( channel , new PacketsMessage ( client , buffer ) , null ) ) ; Assert . assertEquals ( size , invocations . get ( ) ) ; } public void testDecodePerf ( ) throws Exception { PacketListener listener = new PacketListener ( null , null , null ) { @ Override public void onPacket ( Packet packet , SocketIOClient client , AckRequest ackRequest ) { } } ; PacketHandler handler = new PacketHandler ( listener , decoder , namespacesHub ) ; long start = System", "gt": ". currentTimeMillis ( ) ;", "prediction": ";\n", "label": 1}
{"id": 501, "input": "<s> class test_ff { public final String fnl_str =", "gt": "\"String found at runtime\" ;", "prediction": ";\n", "label": 0}
{"id": 6994, "input": "<s> package net . immortal_forces . silence . plugin . whitelist ; import org . bukkit . event . player . PlayerListener ; import org . bukkit . event . player . PlayerLoginEvent ; public class WLPlayerListener extends PlayerListener { private final Whitelist m_Plugin ; public WLPlayerListener ( Whitelist instance ) { m_Plugin = instance ; } @ Override public void onPlayerLogin ( PlayerLoginEvent event ) { if ( m_Plugin . isWhitelistActive ( ) ) { if ( m_Plugin . needReloadWhitelist ( ) ) { System . out . println ( \"Whitelist: Executing scheduled whitelist reload.\" ) ; m_Plugin . reloadSettings ( ) ; m_Plugin . resetNeedReloadWhitelist ( ) ; } String playerName = event . getPlayer ( ) . getName ( ) ; System . out . print ( \"Whitelist: Player \" + playerName + \" is trying to join...\" ) ; if", "gt": "( m_Plugin . isOnWhitelist ( playerName ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 5252, "input": "<s> package com . sun . tools . apt . mirror . type ; import java . util . Collection ; import java . util . ArrayList ; import com . sun . mirror . type . * ; import com . sun . mirror . type . PrimitiveType . Kind ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . util . Context ; import static com . sun . tools . javac . code . TypeTags . * ; @ SuppressWarnings ( \"deprecation\" ) public class TypeMaker { private final AptEnv env ; private final VoidType voidType ; private PrimitiveType [ ] primTypes = new PrimitiveType [ VOID ] ; private static final Context . Key < TypeMaker > typeMakerKey = new Context . Key < TypeMaker > ( ) ; public static TypeMaker instance ( Context context ) { TypeMaker instance = context . get ( typeMakerKey ) ; if ( instance == null ) { instance = new TypeMaker ( context ) ; } return instance ; } private TypeMaker ( Context context ) { context . put ( typeMakerKey , this ) ; env = AptEnv . instance ( context ) ; voidType = new VoidTypeImpl ( env ) ; primTypes [ BOOLEAN ] = new PrimitiveTypeImpl ( env , Kind . BOOLEAN ) ; primTypes [ BYTE ] = new PrimitiveTypeImpl ( env , Kind . BYTE ) ; primTypes [ SHORT ] = new PrimitiveTypeImpl ( env , Kind . SHORT ) ; primTypes [ INT ] = new PrimitiveTypeImpl ( env , Kind . INT ) ; primTypes [ LONG ] = new PrimitiveTypeImpl ( env , Kind . LONG ) ; primTypes [ CHAR ] = new PrimitiveTypeImpl ( env , Kind . CHAR ) ; primTypes [ FLOAT ] = new PrimitiveTypeImpl ( env , Kind . FLOAT ) ; primTypes [ DOUBLE ] = new PrimitiveTypeImpl ( env , Kind . DOUBLE ) ; } public TypeMirror getType ( Type t ) { if ( t . isPrimitive ( ) ) { return primTypes [ t . tag ] ; } switch ( t . tag ) { case ERROR : case CLASS : return getDeclaredType ( ( Type . ClassType ) t ) ; case WILDCARD : return new WildcardTypeImpl ( env , ( Type . WildcardType ) t ) ; case TYPEVAR : return new TypeVariableImpl ( env , ( Type . TypeVar ) t ) ; case ARRAY : return new ArrayTypeImpl ( env , ( Type . ArrayType ) t ) ; case VOID : return voidType ; default : throw new AssertionError ( ) ; } } public DeclaredType getDeclaredType ( Type . ClassType t ) { return hasFlag ( t . tsym , Flags . ANNOTATION ) ? new AnnotationTypeImpl ( env , t ) : hasFlag ( t . tsym , Flags . INTERFACE ) ? new InterfaceTypeImpl ( env , t ) : hasFlag ( t . tsym , Flags . ENUM ) ? new EnumTypeImpl ( env , t ) :", "gt": "new ClassTypeImpl ( env , t ) ;", "prediction": ";\n", "label": 0}
{"id": 7020, "input": "<s> package org . eclipse . rap . rwt . lifecycle ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . lifecycle . TestEntryPoint ; import org . eclipse . rap . rwt . lifecycle . DefaultEntryPointFactory ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class DefaultEntryPointFactory_Test extends TestCase { public void testConstructorWithNullParam ( ) { try { new DefaultEntryPointFactory ( ( Class < ? extends IEntryPoint > ) null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testConstructorFailsWithAbstractClass ( ) { try { new DefaultEntryPointFactory ( AbstractClass . class ) ; fail ( ) ; } catch ( IllegalArgumentException exception ) { String message = exception . getMessage ( ) ; assertTrue ( message . startsWith ( \"Abstract class or interface given as entrypoint\" ) ) ; } } public void testConstructorFailsWithInterface ( ) { try { new DefaultEntryPointFactory ( Interface . class ) ; fail ( ) ; } catch ( IllegalArgumentException exception ) { String message = exception . getMessage ( ) ; assertTrue ( message . startsWith ( \"Abstract class or interface given as entrypoint\" ) ) ; } } public void testConstructorFailsWithNonStaticInnerClass ( ) { try { new DefaultEntryPointFactory ( NonStaticInnerClass . class ) ; fail ( ) ; } catch ( IllegalArgumentException exception ) { String message = exception . getMessage ( ) ; assertTrue ( message . startsWith ( \"Non-static inner class given as entrypoint\" ) ) ; } } public void testCreate ( ) { DefaultEntryPointFactory factory = new DefaultEntryPointFactory ( TestEntryPoint . class ) ; IEntryPoint entryPoint = factory . create ( ) ; assertTrue ( entryPoint instanceof TestEntryPoint ) ; } public void testCreateWithInnerClass ( ) { DefaultEntryPointFactory factory = new DefaultEntryPointFactory ( EntryPoint . class ) ; IEntryPoint entryPoint = factory . create ( ) ; assertTrue ( entryPoint instanceof EntryPoint ) ; } public void testCreateWithPrivateConstructor ( ) { DefaultEntryPointFactory factory = new DefaultEntryPointFactory ( EntryPointWithPrivateConstructor . class ) ; IEntryPoint entryPoint = factory . create ( ) ; assertTrue ( entryPoint instanceof EntryPointWithPrivateConstructor ) ; } public void testCreateWithFailingConstructor ( ) { DefaultEntryPointFactory factory = new DefaultEntryPointFactory ( EntryPointWithFailingConstructor . class ) ; try { factory . create ( ) ; fail ( ) ; } catch ( Exception exception ) { assertTrue ( exception . getMessage ( ) . startsWith ( \"Could not create entrypoint instance\" ) ) ; } } private static class EntryPoint implements IEntryPoint { public int createUI ( ) { return 0 ; } } private static class EntryPointWithPrivateConstructor implements IEntryPoint { private EntryPointWithPrivateConstructor ( ) { } public int createUI ( ) { return 0 ; } } private static class EntryPointWithFailingConstructor implements IEntryPoint { @ SuppressWarnings ( \"unused\" ) public EntryPointWithFailingConstructor ( ) { throw new IllegalArgumentException ( ) ; } public int createUI ( ) { return 0 ; } } private class NonStaticInnerClass implements IEntryPoint { public int createUI ( ) { return 0 ; } } private", "gt": "static abstract class AbstractClass implements IEntryPoint", "prediction": "}\n", "label": 1}
{"id": 8412, "input": "<s> import java . lang . reflect . Method ; import static java . lang . reflect . Modifier . * ; public class T6520152 { public static void main ( String [ ] args ) throws Exception { Class clazz = Class . forName ( \"T$1\" ) ; if ( ( clazz . getModifiers ( ) & FINAL ) != 0 ) { throw new RuntimeException ( \"Failed: \" + clazz . getName ( ) + \"", "gt": "shouldn't be marked final.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7034, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . safehtml . shared . SafeHtmlUtils ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiBinderUtil ; import com . google . gwt . user . client . ui . Widget ; public class Contacts_ContactPopup_BinderImpl implements UiBinder < com . google . gwt . user . client . ui . Widget , org . restlet . example . book . restlet . ch09 . client . Contacts . ContactPopup > , org . restlet . example . book . restlet . ch09 . client . Contacts . ContactPopup . Binder { interface Template extends SafeHtmlTemplates { @ Template ( \"<div class='{0}'></div> <div class='{1}'> <div id='{2}'></div> <div class='{3}' id='{4}'></div> </div>\" ) SafeHtml html1 ( String arg0 , String arg1 , String arg2 , String arg3 , String arg4 ) ; } Template template = GWT . create ( Template . class ) ; public com . google . gwt . user . client . ui . Widget createAndBindUi ( final org . restlet . example . book . restlet . ch09 . client . Contacts . ContactPopup owner ) { org . restlet . example . book . restlet . ch09 . client . Contacts_ContactPopup_BinderImpl_GenBundle clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay = ( org . restlet . example . book . restlet . ch09 . client . Contacts_ContactPopup_BinderImpl_GenBundle ) GWT . create ( org . restlet . example . book . restlet . ch09 . client . Contacts_ContactPopup_BinderImpl_GenBundle . class ) ; com . google . gwt . resources . client . ImageResource photo = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay", "gt": ". photo ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7631, "input": "<s> package com . asakusafw . example . summarization . flowpart ; import org . junit . Before ; import org . junit . Test ; import com . asakusafw . example . summarization . common . BatchContextParameters ; import com . asakusafw . example . summarization . modelgen . dmdl . model . AllValues ; import com . asakusafw . example . summarization . modelgen . dmdl . model . ErrorReceipt ; import com . asakusafw . example . summarization . modelgen . dmdl . model . Item ; import com . asakusafw . example . summarization . modelgen . dmdl . model . Receipt ; import com . asakusafw . example . summarization . modelgen . dmdl . model . Shop ; import com . asakusafw . testdriver . FlowPartTester ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . Out ; public class CleansingFlowPartTest { static final String INPUT_PATH = \"/com/asakusafw/example/summarization/input/\" ; static final String PATH = \"/com/asakusafw/example/summarization/flowpart/cleansing/\" ; FlowPartTester tester ; @ Before public void setup ( ) { tester = new FlowPartTester ( getClass ( ) ) ; tester . setBatchArg ( BatchContextParameters . FROM_ISSUE_DATE , \"20120101\" ) ; tester . setBatchArg ( BatchContextParameters . TO_ISSUE_DATE , \"20120131\" ) ; } @ Test public void testExcludeReceipt ( ) { run ( PATH + \"exclude_receipt.xls\" ) ; } @ Test public void testInvalidReceipt ( ) { run ( PATH + \"invalid_receipt.xls\" ) ; } @ Test public void testInvalidMaster ( ) { run ( PATH + \"invalid_master.xls\" ) ; }", "gt": "@ Test public void testCleansing ( )", "prediction": "}\n", "label": 0}
{"id": 7047, "input": "<s> package org . restlet . engine . adapter ; import java . util . logging . Logger ; import org . restlet . Context ; public class Adapter { private volatile Context context ; public Adapter ( Context context ) { this . context = context ; } public Context getContext ( ) { return this . context ; } public Logger getLogger ( ) { Logger result = ( getContext ( ) != null ) ? getContext (", "gt": ") . getLogger ( ) : null ;", "prediction": ") ;\n", "label": 1}
{"id": 2540, "input": "<s> package com . gisgraphy . client . commons ; import javax . measure . quantity . Length ; import javax . measure . unit . Unit ; public interface DistanceCalculator < T > { double distance", "gt": "( T o , Unit < Length > unit ) ;", "prediction": ";\n", "label": 0}
{"id": 7056, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . io . File ; import java . util . Map ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task . update . Rollback ; import org . nuxeo . connect . update . task . update . RollbackOptions ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . reload . ReloadService ; public class RollbackAndUndeploy extends Rollback { public RollbackAndUndeploy ( ) { super ( ) ; } public RollbackAndUndeploy ( RollbackOptions opt ) { super ( opt ) ; } @ Override protected Command doRun ( Task task , Map < String , String > prefs ) throws PackageException { Command res = null ; try { res = super . doRun ( task , prefs ) ; ReloadService srv = Framework . getLocalService ( ReloadService . class ) ; srv . runDeploymentPreprocessor ( ) ; } catch ( Exception e ) { task . setRestartRequired ( true ) ; throw new PackageException ( \"Failed to undeploy", "gt": "bundle\" , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7409, "input": "<s> class T6407257a extends T6407257a { } public class T6407257 extends T6407257a { public static", "gt": "void main ( String ... args )", "prediction": "( )\n", "label": 0}
{"id": 7067, "input": "<s> package org . tinyradius . util ; import java . io . UnsupportedEncodingException ; public class RadiusUtil { public static byte [ ] getUtf8Bytes ( String str ) { try { return str . getBytes ( \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { return str . getBytes ( ) ; } } public static String getStringFromUtf8 ( byte [ ] utf8 ) { try { return new String ( utf8 , \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { return new String ( utf8 ) ; } } public static String getHexString ( byte [ ] data ) { StringBuffer hex = new StringBuffer ( \"0x\" ) ; if ( data != null ) for ( int i = 0 ; i", "gt": "< data . length ;", "prediction": ") ;\n", "label": 1}
{"id": 6756, "input": "<s> interface Base { int m ( ) ; } interface ClashesWith extends Base {", "gt": "String m ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 7110, "input": "<s> package org . eclipse . jface . tests . preferences ; import junit . framework . TestCase ; import org . eclipse . jface . preference . PreferenceStore ; import org . eclipse . jface . preference . StringFieldEditor ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class StringFieldEditorTest extends TestCase { private Shell shell ; private StringFieldEditor stringFieldEditor ; protected void setUp ( ) throws Exception { super . setUp ( ) ; shell = new Shell ( ) ; stringFieldEditor = new StringFieldEditor ( \"name\" , \"label\" , shell ) ; } public void testSetLabelText ( ) { stringFieldEditor . setLabelText ( \"label text\" ) ; assertEquals ( \"label text\" , stringFieldEditor . getLabelText ( ) ) ; stringFieldEditor . setLabelText ( \"label text\" ) ; assertEquals ( \"label text\" , stringFieldEditor . getLabelText ( ) ) ; } public void testLoad ( ) { PreferenceStore myPreferenceStore = new PreferenceStore ( ) ; stringFieldEditor . setPreferenceName ( \"name\" ) ; stringFieldEditor . setPreferenceStore ( myPreferenceStore ) ; myPreferenceStore . setDefault ( \"name\" , \"foo\" ) ; stringFieldEditor . load ( ) ; assertEquals ( stringFieldEditor . getStringValue ( ) , \"foo\" ) ; myPreferenceStore . setDefault ( \"name\" , \"foo\" ) ; myPreferenceStore . setValue ( \"name\" , \"bar\" ) ; stringFieldEditor . load ( ) ; assertEquals ( stringFieldEditor . getStringValue ( ) , \"bar\" ) ; } public void testLoadDefault ( ) { PreferenceStore myPreferenceStore = new PreferenceStore ( ) ; stringFieldEditor . setPreferenceName ( \"name\" ) ; stringFieldEditor . setPreferenceStore ( myPreferenceStore ) ; myPreferenceStore . setDefault ( \"name\" , \"foo\" ) ; myPreferenceStore . setValue ( \"name\" , \"bar\" ) ; stringFieldEditor . loadDefault ( ) ; assertEquals ( stringFieldEditor . getStringValue ( ) , \"foo\" ) ; } public void testSetValueInWidget ( ) { PreferenceStore myPreferenceStore = new PreferenceStore ( ) ; stringFieldEditor . setPreferenceName ( \"name\" ) ; stringFieldEditor . setPreferenceStore ( myPreferenceStore ) ; myPreferenceStore . setValue ( \"name\" , \"foo\" ) ; stringFieldEditor . load ( ) ; assertEquals", "gt": "( stringFieldEditor . getStringValue ( ) , \"foo\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9597, "input": "<s> package org . ofbiz . product . product ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . security . Security ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . website . WebSiteWorker ; public class ProductEvents { public static final String module = ProductEvents . class . getName ( ) ; public static final String resource = \"ProductErrorUiLabels\" ; public static String updateAllKeywords ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; Security security = ( Security ) request . getAttribute ( \"security\" ) ; Timestamp nowTimestamp = UtilDateTime . nowTimestamp ( ) ; String updateMode = \"CREATE\" ; String errMsg = null ; String doAll = request . getParameter ( \"doAll\" ) ; if ( ! security . hasEntityPermission ( \"CATALOG\" , \"_\" + updateMode , request . getSession ( ) ) ) { Map < String , String > messageMap = UtilMisc . toMap ( \"updateMode\" , updateMode ) ; errMsg = UtilProperties . getMessage ( resource , \"productevents.not_sufficient_permissions\" , messageMap , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } EntityCondition condition = null ; if ( ! \"Y\" . equals ( doAll ) ) { List < EntityCondition > condList = FastList . newInstance ( ) ; condList . add ( EntityCondition . makeCondition ( EntityCondition . makeCondition ( \"autoCreateKeywords\" , EntityOperator . EQUALS , null ) , EntityOperator . OR , EntityCondition . makeCondition ( \"autoCreateKeywords\" , EntityOperator . NOT_EQUAL , \"N\" ) ) ) ; if ( \"true\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.ignore.variants\" ) ) ) { condList . add ( EntityCondition . makeCondition ( EntityCondition . makeCondition ( \"isVariant\" , EntityOperator . EQUALS , null ) , EntityOperator . OR , EntityCondition . makeCondition ( \"isVariant\" , EntityOperator . NOT_EQUAL , \"Y\" ) ) ) ; } if ( \"true\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.ignore.discontinued.sales\" ) ) ) { condList . add ( EntityCondition . makeCondition ( EntityCondition . makeCondition ( \"salesDiscontinuationDate\" , EntityOperator . EQUALS , null ) , EntityOperator . OR , EntityCondition . makeCondition ( \"salesDiscontinuationDate\" , EntityOperator . GREATER_THAN_EQUAL_TO , nowTimestamp ) ) ) ; } condition = EntityCondition . makeCondition ( condList , EntityOperator . AND ) ; } else { condition = EntityCondition . makeCondition ( EntityCondition . makeCondition ( \"autoCreateKeywords\" , EntityOperator . EQUALS , null ) , EntityOperator . OR , EntityCondition . makeCondition ( \"autoCreateKeywords\" , EntityOperator . NOT_EQUAL , \"N\" ) ) ; } EntityListIterator entityListIterator = null ; int numProds = 0 ; int errProds = 0 ; boolean beganTx = false ; try { beganTx = TransactionUtil . begin ( 7200 ) ; try { if ( Debug . infoOn ( ) ) { long count = delegator . findCountByCondition ( \"Product\" , condition , null , null ) ; Debug . logInfo ( \"========== Found \" + count + \" products to index ==========\" , module ) ; } entityListIterator = delegator . find ( \"Product\" , condition , null , null , null , null ) ; } catch ( GenericEntityException gee ) { Debug . logWarning ( gee , gee . getMessage ( ) , module ) ; Map < String , String > messageMap = UtilMisc . toMap ( \"gee\" , gee . toString ( ) ) ; errMsg = UtilProperties . getMessage ( resource , \"productevents.error_getting_product_list\" , messageMap , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; throw gee ; } GenericValue product ; while ( ( product = entityListIterator . next ( ) ) != null ) { try { KeywordIndex . indexKeywords ( product , \"Y\" . equals ( doAll ) ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( \"[ProductEvents.updateAllKeywords] Could not create product-keyword (write error); message: \" + e . getMessage ( ) , module ) ; errProds ++ ; } numProds ++ ; if ( numProds % 500 == 0 ) { Debug . logInfo ( \"Keywords indexed for \" + numProds + \" so far\" , module ) ; } } } catch ( GenericEntityException e ) { try { TransactionUtil . rollback ( beganTx , e . getMessage ( ) , e ) ; } catch ( Exception e1 ) { Debug . logError ( e1 , module ) ; } return \"error\" ; } catch ( Throwable t ) { Debug . logError ( t , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , t . getMessage ( ) ) ; try { TransactionUtil . rollback ( beganTx , t . getMessage ( ) , t ) ; } catch ( Exception e2 ) { Debug . logError ( e2 , module ) ; } return \"error\" ; } finally { if ( entityListIterator != null ) { try { entityListIterator . close ( ) ; } catch ( GenericEntityException gee ) { Debug . logError ( gee , \"Error closing EntityListIterator when indexing product", "gt": "keywords.\" , module ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7112, "input": "<s> package org . eclipse . ui . dialogs ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . WorkbenchMessages ; public class CheckedTreeSelectionDialog extends SelectionStatusDialog { private CheckboxTreeViewer fViewer ; private ILabelProvider fLabelProvider ; private ITreeContentProvider fContentProvider ; private ISelectionStatusValidator fValidator = null ; private ViewerComparator fComparator ; private String fEmptyListMessage = WorkbenchMessages . get ( ) . CheckedTreeSelectionDialog_nothing_available ; private IStatus fCurrStatus = new Status ( IStatus . OK , PlatformUI . PLUGIN_ID , 0 , \"\" , null ) ; private List fFilters ; private Object fInput ; private boolean fIsEmpty ; private int fWidth = 60 ; private int fHeight = 18 ; private boolean fContainerMode ; private Object [ ] fExpandedElements ; public CheckedTreeSelectionDialog ( Shell parent , ILabelProvider labelProvider , ITreeContentProvider contentProvider ) { super ( parent ) ; fLabelProvider = labelProvider ; fContentProvider = contentProvider ; setResult ( new ArrayList ( 0 ) ) ; setStatusLineAboveButtons ( true ) ; fContainerMode = false ; fExpandedElements = null ; } public void setContainerMode ( boolean containerMode ) { fContainerMode = containerMode ; } public void setInitialSelection ( Object selection ) { setInitialSelections ( new Object [ ] { selection } ) ; } public void setEmptyListMessage ( String message ) { fEmptyListMessage = message ; } public void setSorter ( ViewerSorter sorter ) { fComparator = sorter ; } public void setComparator ( ViewerComparator comparator ) { fComparator = comparator ; } public void addFilter ( ViewerFilter filter ) { if ( fFilters == null ) { fFilters = new ArrayList ( 4 ) ; } fFilters . add ( filter ) ; } public void setValidator ( ISelectionStatusValidator validator ) { fValidator = validator ; } public void setInput ( Object input ) { fInput = input ; } public void setExpandedElements ( Object [ ] elements ) { fExpandedElements = elements ; } public void setSize ( int width , int height ) { fWidth = width ; fHeight = height ; } protected void updateOKStatus ( ) { if ( ! fIsEmpty ) { if ( fValidator != null ) { fCurrStatus = fValidator . validate ( fViewer . getCheckedElements ( ) ) ; updateStatus ( fCurrStatus ) ; } else if ( ! fCurrStatus . isOK ( ) ) { fCurrStatus = new Status ( IStatus . OK , PlatformUI . PLUGIN_ID , IStatus . OK , \"\" , null ) ; } } else { fCurrStatus = new Status ( IStatus . ERROR , PlatformUI . PLUGIN_ID , IStatus . OK , fEmptyListMessage , null ) ; } updateStatus ( fCurrStatus ) ; } public int open ( ) { fIsEmpty = evaluateIfTreeEmpty ( fInput ) ; super . open ( ) ; return getReturnCode ( ) ; } private void access$superCreate ( ) { super . create ( ) ; } protected void cancelPressed ( ) { setResult ( null ) ; super . cancelPressed ( ) ; } protected void computeResult ( ) { setResult ( Arrays . asList ( fViewer . getCheckedElements ( ) ) ) ; } public void create ( ) { BusyIndicator . showWhile ( null , new Runnable ( ) { public void run ( ) { access$superCreate ( ) ; fViewer . setCheckedElements ( getInitialElementSelections ( ) . toArray ( ) ) ; if ( fExpandedElements != null ) { fViewer . setExpandedElements ( fExpandedElements ) ; } updateOKStatus ( ) ; } } ) ; } protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; Label messageLabel = createMessageArea ( composite ) ; CheckboxTreeViewer treeViewer = createTreeViewer ( composite ) ; Control buttonComposite = createSelectionButtons ( composite ) ; GridData data = new GridData ( GridData . FILL_BOTH ) ; data", "gt": ". widthHint = convertWidthInCharsToPixels ( fWidth ) ;", "prediction": ";\n", "label": 1}
{"id": 7918, "input": "<s> package org . ofbiz . entity . util ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) @ Deprecated public class ByteWrapper implements Serializable { protected byte [ ] bytes ; protected ByteWrapper ( ) { } public ByteWrapper ( byte [ ] bytes ) { this . bytes = bytes ; } public byte [ ] getBytes ( ) { return bytes ; } public", "gt": "byte getByte ( int pos )", "prediction": "void ( )\n", "label": 0}
{"id": 7119, "input": "<s> package com . emf4sw . owl . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import com . emf4sw . owl . AnnotatedElement ; import com . emf4sw . owl . Annotation ; import com . emf4sw . owl . AnnotationProperty ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . OWLProperty ; import com . emf4sw . rdf . impl . ResourceImpl ; public abstract class OWLPropertyImpl extends ResourceImpl implements OWLProperty { protected EList < Annotation > annotations ; protected OWLPropertyImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . OWL_PROPERTY ; } public EList < Annotation > getAnnotations ( ) { if ( annotations == null ) { annotations = new EObjectContainmentEList < Annotation > ( Annotation . class , this , OWLPackage . OWL_PROPERTY__ANNOTATIONS ) ; } return annotations ; } public void addAnnotation ( AnnotationProperty property , Object value ) { throw new UnsupportedOperationException ( ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case OWLPackage . OWL_PROPERTY__ANNOTATIONS : return ( ( InternalEList < ? > ) getAnnotations ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . OWL_PROPERTY__ANNOTATIONS : return getAnnotations ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case OWLPackage . OWL_PROPERTY__ANNOTATIONS : getAnnotations ( ) . clear ( ) ; getAnnotations ( ) . addAll ( ( Collection < ? extends Annotation > ) newValue ) ; return ; } super . eSet", "gt": "( featureID , newValue ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3603, "input": "<s> package javax . tools ; public interface OptionChecker {", "gt": "int isSupportedOption ( String option ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7121, "input": "<s> package org . fuzzydb . attrs . simple ; public interface IFloat { public", "gt": "float getValue ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 9922, "input": "<s> package com . redhat . ceylon . compiler . loader ; import com . sun . tools .", "gt": "javac . util . Context ;", "prediction": ";\n", "label": 0}
{"id": 7122, "input": "<s> package org . apache . lucene . search ; import java . text . Collator ; public class ConstantScoreRangeQuery extends TermRangeQuery { public ConstantScoreRangeQuery ( String fieldName , String lowerVal , String upperVal , boolean includeLower , boolean includeUpper ) { super ( fieldName , lowerVal , upperVal , includeLower , includeUpper ) ; rewriteMethod = CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ; } public ConstantScoreRangeQuery ( String fieldName , String lowerVal , String upperVal , boolean includeLower , boolean includeUpper , Collator collator ) { super ( fieldName , lowerVal , upperVal , includeLower , includeUpper , collator ) ; rewriteMethod = CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ; } public String getLowerVal ( ) { return getLowerTerm ( ) ; } public String getUpperVal ( ) { return getUpperTerm ( ) ; } public void setRewriteMethod ( RewriteMethod method ) { throw new UnsupportedOperationException ( \"Use", "gt": "TermRangeQuery instead to change the rewrite method.\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1592, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; public class CompilerBoxingVisitor extends BoxingVisitor { private AbstractTransformer transformer ; public CompilerBoxingVisitor ( AbstractTransformer transformer ) { this . transformer = transformer ; }", "gt": "@ Override protected boolean isBooleanTrue ( Declaration decl )", "prediction": "}\n", "label": 0}
{"id": 7126, "input": "<s> package org . puredata . android . test ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; import org . puredata . android . service . PdPreferences ; import org . puredata . android . service . PdService ; import org . puredata . core . PdBase ; import org . puredata . core . PdReceiver ; import org . puredata . core . utils . IoUtils ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . ComponentName ; import android . content . Intent ; import android . content . ServiceConnection ; import android . content . SharedPreferences ; import android . content . res . Resources ; import android . os . IBinder ; import android . preference . PreferenceManager ; import android . text . method . ScrollingMovementMethod ; import android . util . Log ; import android . view . KeyEvent ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . Button ; import android . widget . CheckBox ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . TextView . OnEditorActionListener ; import android . widget . Toast ; public class PdTest extends Activity implements OnClickListener , OnEditorActionListener , SharedPreferences . OnSharedPreferenceChangeListener { private static final String TAG = \"Pd Test\" ; private CheckBox left , right , mic ; private EditText msg ; private Button prefs ; private TextView logs ; private PdService pdService = null ; private Toast toast = null ; private void toast ( final String msg ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( toast == null ) { toast = Toast . makeText ( getApplicationContext ( ) , \"\" , Toast . LENGTH_SHORT ) ; } toast . setText ( TAG + \": \" + msg ) ; toast . show ( ) ; } } ) ; } private void post ( final String s ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { logs . append ( s + ( ( s . endsWith ( \"\\n\" ) ) ? \"\" : \"\\n\" ) ) ; } } ) ; } private PdReceiver receiver = new PdReceiver ( ) { private void pdPost ( String msg ) { toast ( \"Pure Data says, \\\"\" + msg + \"\\\"\" ) ; } @ Override public void print ( String s ) { post ( s ) ; } @ Override public void receiveBang ( String source ) { pdPost ( \"bang\" ) ; } @ Override public void receiveFloat ( String source , float x ) { pdPost ( \"float: \" + x ) ; } @ Override public void receiveList ( String source , Object ... args ) { pdPost ( \"list: \" + Arrays . toString ( args ) ) ; } @ Override public void receiveMessage ( String source , String symbol , Object ... args ) { pdPost ( \"message: \" + Arrays . toString ( args ) ) ; } @ Override public void receiveSymbol ( String source , String symbol ) { pdPost ( \"symbol: \" + symbol ) ; } } ; private final ServiceConnection pdConnection", "gt": "= new ServiceConnection ( )", "prediction": ";\n", "label": 1}
{"id": 5421, "input": "<s> package com . sun . source . tree ; import javax . lang . model . type . TypeKind ;", "gt": "public interface PrimitiveTypeTree extends Tree", "prediction": ";\n", "label": 0}
{"id": 7134, "input": "<s> package org . eclipse . swt . internal ; import java . io . * ; import java . text . MessageFormat ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . zip . InflaterInputStream ; import java . util . zip . DeflaterOutputStream ; import org . eclipse . swt . SWT ; public final class Compatibility { public static double PI = Math . PI ; static double toRadians = PI / 180 ; public static int cos ( int angle , int length ) { return ( int ) ( Math . cos ( angle * toRadians ) * length ) ; } public static int sin ( int angle , int length ) { return ( int ) ( Math . sin ( angle * toRadians ) * length ) ; } public static int ceil ( int p , int q ) { return ( int ) Math . ceil ( ( float ) p / q ) ; } public static int floor ( int p , int q ) { return ( int ) Math . floor ( ( double ) p / q ) ; } public static int round ( int p , int q ) { return Math . round ( ( float ) p / q ) ; } public static int pow2 ( int n ) { if ( n >= 1 && n <= 30 ) return 2 << ( n - 1 ) ; else if ( n != 0 ) { SWT . error ( SWT . ERROR_INVALID_RANGE ) ; } return 1 ; } public static OutputStream newDeflaterOutputStream ( OutputStream stream ) throws IOException { return new DeflaterOutputStream ( stream ) ; } public static InputStream newFileInputStream ( String filename ) throws IOException { return new FileInputStream ( filename ) ; } public static OutputStream newFileOutputStream ( String filename ) throws IOException { return new FileOutputStream ( filename ) ; } public static InputStream newInflaterInputStream ( InputStream stream ) throws IOException { return new BufferedInputStream ( new InflaterInputStream ( stream ) ) ; } public static boolean isLetter ( char c ) { return Character . isLetter ( c ) ; } public static boolean isLetterOrDigit ( char c ) { return Character . isLetterOrDigit ( c ) ; } public static boolean isSpaceChar ( char c ) { return Character . isSpaceChar ( c ) ; } public static boolean isWhitespace ( char c ) { return Character . isWhitespace ( c ) ; } public static void exec ( String prog ) throws java . io . IOException { Runtime . getRuntime ( ) . exec ( prog ) ; } public static void exec ( String [ ] progArray ) throws java . io . IOException { Runtime", "gt": ". getRuntime ( ) . exec ( progArray ) ;", "prediction": ";\n", "label": 1}
{"id": 1986, "input": "<s> package me . moocar . logbackgelf ; import ch . qos . logback . core . AppenderBase ; import java . io . * ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . security . MessageDigest ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class GelfAppender < E > extends AppenderBase < E > { private String facility = \"GELF\" ; private String graylog2ServerHost = \"localhost\" ; private int graylog2ServerPort = 12201 ; private boolean useLoggerName = false ; private boolean useThreadName = false ; private String graylog2ServerVersion = \"0.9.5\" ; private int chunkThreshold = 1000 ; private String messagePattern = \"%m%rEx\" ; private Map < String , String > additionalFields = new HashMap < String , String > ( ) ; private int shortMessageLength = 255 ; private static final int maxChunks = 127 ; private int messageIdLength = 32 ; private boolean padSeq = true ; private final byte [ ] chunkedGelfId = new byte [ ] { 0x1e , 0x0f } ; private AppenderExecutor < E > appenderExecutor ; @ Override protected void append ( E logEvent ) { try { appenderExecutor . append ( logEvent ) ; } catch ( RuntimeException e ) { System . out . println ( getStringStackTrace ( e ) ) ; this . addError ( \"Error occurred: \" , e ) ; throw e ; } } private String getStringStackTrace ( Exception e ) { Writer result = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( result ) ; e . printStackTrace ( printWriter ) ; return result . toString ( ) ; } @ Override public void start ( ) { super . start ( ) ; initExecutor ( ) ; } private void initExecutor ( ) { try { InetAddress address = getInetAddress ( ) ; Transport transport = new Transport ( graylog2ServerPort , address ) ; if ( graylog2ServerVersion . equals ( \"0.9.6\" ) ) { messageIdLength = 8 ; padSeq = false ; } String hostname = getLocalHostName ( ) ; PayloadChunker payloadChunker = new PayloadChunker ( chunkThreshold , maxChunks , new MessageIdProvider ( messageIdLength , MessageDigest . getInstance ( \"MD5\" ) , hostname ) , new ChunkFactory ( chunkedGelfId , padSeq ) ) ; GelfConverter converter = new GelfConverter ( facility , useLoggerName , useThreadName , additionalFields , shortMessageLength , hostname , messagePattern ) ; appenderExecutor = new AppenderExecutor < E > ( transport , payloadChunker , converter , new Zipper ( ) , chunkThreshold ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Error initialising appender appenderExecutor\" , e ) ; } } private String getLocalHostName ( ) throws SocketException , UnknownHostException { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { NetworkInterface networkInterface = NetworkInterface . getNetworkInterfaces ( ) . nextElement ( ) ; if ( networkInterface == null ) throw e ; InetAddress ipAddress = networkInterface . getInetAddresses ( ) . nextElement ( ) ; if ( ipAddress == null ) throw e ; return ipAddress . getHostAddress ( ) ; } } private InetAddress getInetAddress ( ) { try { return InetAddress . getByName ( graylog2ServerHost ) ; } catch ( UnknownHostException e ) { throw new IllegalStateException ( \"Unknown host: \" + e . getMessage ( ) + \". Make sure you have specified the 'graylog2ServerHost' property correctly in your logback.xml'\" ) ; } } public String getFacility ( ) { return facility ; } public void setFacility ( String facility ) { this . facility = facility ; } public String getGraylog2ServerHost ( ) { return graylog2ServerHost ; } public void setGraylog2ServerHost ( String graylog2ServerHost ) { this . graylog2ServerHost = graylog2ServerHost ; } public int getGraylog2ServerPort ( ) { return graylog2ServerPort ; } public void setGraylog2ServerPort ( int graylog2ServerPort ) { this . graylog2ServerPort = graylog2ServerPort ; } public boolean isUseLoggerName ( ) { return useLoggerName ; } public void setUseLoggerName ( boolean useLoggerName ) { this . useLoggerName = useLoggerName ; } public boolean isUseThreadName ( ) { return useThreadName ; } public", "gt": "void setUseThreadName ( boolean useThreadName )", "prediction": "( )\n", "label": 0}
{"id": 7139, "input": "<s> package de . uos . igf . db3d . dbms . api ; import java . util . Locale ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class Db3dSimpleResourceBundle { private static ResourceBundle resourceBundle ; static { Locale loc = new Locale ( System . getProperty ( \"user.language\" ) ) ; try { resourceBundle = ResourceBundle . getBundle ( \"Resources\" , loc ) ; } catch ( MissingResourceException mre ) { loc = new Locale ( \"en\" ) ; resourceBundle = ResourceBundle . getBundle ( \"Resources\" , loc ) ; } } public static String getString ( String key ) { return resourceBundle", "gt": ". getString ( key ) ;", "prediction": ";\n", "label": 1}
{"id": 5088, "input": "<s> class BarNeg2a < T > { BarNeg2a . Inner . InnerMost object = new BarNeg2a . Inner < ? > . InnerMost ( ) ; static", "gt": "class Inner < S >", "prediction": "}\n", "label": 0}
{"id": 7167, "input": "<s> package org . nuxeo . ecm . automation . core . operations . execution ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . BlobList ; import org . nuxeo . ecm . core . api . Blob ; @ Operation ( id = RunFileChain . ID , category = Constants . CAT_SUBCHAIN_EXECUTION , label = \"Run File Chain\" , description = \"Run an operation chain which is returning a file in the current context. The input for the chain to run is a file or a list of files. Return the output of the chain as a file or a list of files.\" ) public class RunFileChain { public static final String ID = \"Context.RunFileOperation\" ; @ Context protected OperationContext ctx ; @ Context protected AutomationService service ; @ Param ( name = \"id\" ) protected String chainId ; @ Param ( name = \"isolate\" , required = false , values = \"false\" ) protected boolean isolate = false ; @ OperationMethod public Blob run ( Blob blob ) throws Exception { Map < String , Object > vars = isolate ? new HashMap < String , Object > ( ctx . getVars ( ) ) : ctx . getVars ( ) ; OperationContext subctx = new OperationContext ( ctx . getCoreSession ( ) , vars ) ; subctx . setInput ( blob ) ; return ( Blob ) service .", "gt": "run ( subctx , chainId ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 623, "input": "<s> package com . dyned . woremotesiteconfig . javamonitor ; import net . sf . json . JSONObject ; import org . apache . log4j . Logger ; public class SiteApplication { private static Logger log = Logger . getLogger ( SiteApplication . class ) ; public static final String TYPE = \"type\" ; public static final String ADAPTOR = \"adaptor\" ; public static final String ADAPTORTHREADS = \"adaptorThreads\" ; public static final String ADAPTORTHREADSMAX = \"adaptorThreadsMax\" ; public static final String ADAPTORTHREADSMIN = \"adaptorThreadsMin\" ; public static final String ADDITIONALARGS = \"additionalArgs\" ; public static final String AUTOOPENINBROWSER = \"autoOpenInBrowser\" ; public static final String AUTORECOVER = \"autoRecover\" ; public static final String CACHINGENABLED = \"cachingEnabled\" ; public static final String CNCTTIMEOUT = \"cnctTimeout\" ; public static final String DEBUGGINGENABLED = \"debuggingEnabled\" ; public static final String DORMANT = \"dormant\" ; public static final String LIFEBEATINTERVAL = \"lifebeatInterval\" ; public static final String LISTENQUEUESIZE = \"listenQueueSize\" ; public static final String MACOUTPUTPATH = \"macOutputPath\" ; public static final String MACPATH = \"macPath\" ; public static final String MINIMUMACTIVESESSIONSCOUNT = \"minimumActiveSessionsCount\" ; public static final String NAME = \"name\" ; public static final String NOTIFICATIONEMAILADDR = \"notificationEmailAddr\" ; public static final String NOTIFICATIONEMAILENABLED = \"notificationEmailEnabled\" ; public static final String OLDNAME = \"oldname\" ; public static final String PHASEDSTARTUP = \"phasedStartup\" ; public static final String POOLSIZE = \"poolsize\" ; public static final String PROJECTSEARCHPATH = \"projectSearchPath\" ; public static final String RECVBUFSIZE = \"recvBufSize\" ; public static final String RECVTIMEOUT = \"recvTimeout\" ; public static final String REDIR = \"redir\" ; public static final String RETRIES = \"retries\" ; public static final String SCHEDULER = \"scheduler\" ; public static final String SENDBUFSIZE = \"sendBufSize\" ; public static final String SENDTIMEOUT = \"sendTimeout\" ; public static final String SESSIONTIMEOUT = \"sessionTimeOut\" ; public static final String STARTINGPORT = \"startingPort\" ; public static final String STATISTICSPASSWORD = \"statisticsPassword\" ; public static final String TIMEFORSTARTUP = \"timeForStartup\" ; public static final String UNIXOUTPUTPATH = \"unixOutputPath\" ; public static final String UNIXPATH = \"unixPath\" ; public static final String URLVERSION = \"urlVersion\" ; public static final String WINOUTPUTPATH = \"winOutputPath\" ; public static final String WINPATH = \"winPath\" ; private String type ; private String adaptor ; private String adaptorThreads ; private String adaptorThreadsMax ; private String adaptorThreadsMin ; private String additionalArgs ; private String autoOpenInBrowser ; private String autoRecover ; private String cachingEnabled ; private String cnctTimeout ; private String debuggingEnabled ; private String dormant ; private String lifebeatInterval ; private String listenQueueSize ; private String macOutputPath ; private String macPath ; private String minimumActiveSessionsCount ; private String name ; private String notificationEmailAddr ; private String notificationEmailEnabled ; private String oldname ; private String phasedStartup ; private String poolsize ; private String projectSearchPath ; private String recvBufSize ; private String recvTimeout ; private String redir ; private String retries ; private String scheduler ; private String sendBufSize ; private String sendTimeout ; private String sessionTimeOut ; private String startingPort ; private String statisticsPassword ; private String timeForStartup ; private String unixOutputPath ; private String unixPath ; private String urlVersion ; private String winOutputPath ; private String winPath ; private Site parentSite ; public SiteApplication ( JSONObject jsonObject ) { super ( ) ; log . debug ( \"Parsing: \" + jsonObject . toString ( ) ) ; if ( jsonObject != null ) { type = jsonObject . getString ( TYPE ) ; adaptor = jsonObject . getString ( ADAPTOR ) ; adaptorThreads = jsonObject . getString ( ADAPTORTHREADS ) ; adaptorThreadsMax = jsonObject . getString ( ADAPTORTHREADSMAX ) ; adaptorThreadsMin = jsonObject . getString ( ADAPTORTHREADSMIN ) ; additionalArgs = jsonObject . getString ( ADDITIONALARGS ) ; autoOpenInBrowser = jsonObject . getString ( AUTOOPENINBROWSER ) ; autoRecover = jsonObject . getString ( AUTORECOVER ) ; cachingEnabled = jsonObject . getString ( CACHINGENABLED ) ; cnctTimeout = jsonObject . getString ( CNCTTIMEOUT ) ; debuggingEnabled = jsonObject . getString ( DEBUGGINGENABLED ) ; dormant = jsonObject . getString ( DORMANT ) ; lifebeatInterval = jsonObject . getString ( LIFEBEATINTERVAL ) ; listenQueueSize = jsonObject . getString ( LISTENQUEUESIZE ) ; macOutputPath = jsonObject . getString ( MACOUTPUTPATH ) ; macPath = jsonObject . getString ( MACPATH ) ; minimumActiveSessionsCount = jsonObject . getString ( MINIMUMACTIVESESSIONSCOUNT ) ; name = jsonObject . getString ( NAME ) ; notificationEmailAddr = jsonObject . getString ( NOTIFICATIONEMAILADDR ) ; notificationEmailEnabled = jsonObject . getString ( NOTIFICATIONEMAILENABLED ) ; oldname = jsonObject . getString ( OLDNAME ) ; phasedStartup = jsonObject . getString ( PHASEDSTARTUP ) ; poolsize = jsonObject . getString ( POOLSIZE ) ; projectSearchPath = jsonObject . getString ( PROJECTSEARCHPATH ) ; recvBufSize = jsonObject . getString ( RECVBUFSIZE ) ; recvTimeout = jsonObject . getString ( RECVTIMEOUT ) ; redir = jsonObject . getString ( REDIR ) ; retries = jsonObject . getString ( RETRIES ) ; scheduler = jsonObject . getString ( SCHEDULER ) ; sendBufSize = jsonObject . getString ( SENDBUFSIZE ) ; sendTimeout = jsonObject . getString ( SENDTIMEOUT ) ; sessionTimeOut = jsonObject . getString ( SESSIONTIMEOUT ) ; startingPort = jsonObject . getString ( STARTINGPORT ) ; statisticsPassword = jsonObject . getString ( STATISTICSPASSWORD ) ; timeForStartup = jsonObject . getString ( TIMEFORSTARTUP ) ; unixOutputPath = jsonObject . getString ( UNIXOUTPUTPATH ) ; unixPath = jsonObject . getString ( UNIXPATH ) ; urlVersion = jsonObject . getString ( URLVERSION ) ; winOutputPath = jsonObject . getString ( WINOUTPUTPATH ) ; winPath = jsonObject . getString ( WINPATH ) ; log . debug ( \"   type: \" + type ) ; log . debug ( \"   adaptor: \" + adaptor ) ; log . debug ( \"   adaptorThreads: \" + adaptorThreads ) ; log . debug ( \"   adaptorThreadsMax: \" + adaptorThreadsMax ) ; log . debug ( \"   adaptorThreadsMin: \" + adaptorThreadsMin ) ; log . debug", "gt": "( \"   additionalArgs: \" + additionalArgs ) ;", "prediction": ";\n", "label": 0}
{"id": 7177, "input": "<s> package br . org . archimedes . interfaces ; import java . util . Collection ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; public interface ExtendManager { public Element extend ( Element element , Collection <", "gt": "Element > references , Point click ) throws NullArgumentException ;", "prediction": ") ;\n", "label": 1}
{"id": 3371, "input": "<s> class VarMightAlreadyBeAssigned { void m ( boolean b ) { final int i ; if ( b", "gt": ") i = 3 ;", "prediction": ")\n", "label": 0}
{"id": 7181, "input": "<s> package org . eclipse . rap . examples . pages ; import java . util . Arrays ; import org . eclipse . rap . examples . ExampleUtil ; import org . eclipse . rap . examples . IExamplePage ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . ByteArrayTransfer ; import org . eclipse . swt . dnd . DND ; import org . eclipse . swt . dnd . DragSource ; import org . eclipse . swt . dnd . DragSourceAdapter ; import org . eclipse . swt . dnd . DragSourceEvent ; import org . eclipse . swt . dnd . DropTarget ; import org . eclipse . swt . dnd . DropTargetAdapter ; import org . eclipse . swt . dnd . DropTargetEvent ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . dnd . TransferData ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . RowLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . List ; public class ListExample implements IExamplePage { private static final int LIST_STYLE = SWT . BORDER | SWT . MULTI | SWT . V_SCROLL ; private static final String IMG_ADD = \"resources/forward_nav.gif\" ; private static final String IMG_REMOVE = \"resources/backward_nav.gif\" ; private static final String [ ] ELEMENTS = new String [ ] { \"Dansk\" , \"Deutsch\" , \"English\" , \"Espa\u00f1ol\" , \"Fran\u00e7ais\" , \"Nederlands\" , \"\u0420\u0443\u0441\u0441\u043a\u0438\u0439\" , \"Suomi\" , \"Svenska\" , } ; public void createControl ( Composite parent ) { parent . setLayout ( ExampleUtil . createMainLayout ( 1 ) ) ; Composite composite = new Composite ( parent , SWT . NONE ) ; composite . setLayout ( ExampleUtil . createGridLayout ( 3 , false , true , true ) ) ; composite . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; final List leftList = new List ( composite , LIST_STYLE ) ; leftList . setLayoutData ( ExampleUtil . createFillData ( ) ) ; addDragSupport ( leftList ) ; addDropSupport ( leftList ) ; Composite buttons = new Composite ( composite , SWT . NONE ) ; RowLayout layout = new RowLayout ( SWT . VERTICAL ) ; layout . fill = true ; buttons . setLayout ( layout ) ; final Button addButton = createButton ( buttons , \"Add\" , IMG_ADD ) ; final Button removeButton = createButton ( buttons , \"Remove\" , IMG_REMOVE ) ; final List rightList = new List ( composite , LIST_STYLE ) ; rightList . setLayoutData ( ExampleUtil . createFillData ( ) ) ; addDragSupport ( rightList ) ; addDropSupport ( rightList ) ; leftList . setItems ( ELEMENTS ) ; addButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { moveSelectedItems ( leftList , rightList ) ; } } ) ; removeButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { moveSelectedItems ( rightList , leftList ) ; } } ) ; } private static void addDragSupport ( final List list ) { DragSource dragSource = new DragSource ( list , DND . DROP_MOVE ) ; dragSource . setTransfer ( new Transfer [ ] { new StringArrayTransfer ( ) } ) ; dragSource . addDragListener ( new DragSourceAdapter ( ) { @ Override public void dragSetData ( final DragSourceEvent event ) { event . data = list . getSelection ( ) ; } @ Override public void dragFinished ( final DragSourceEvent event ) { if ( event . detail == DND . DROP_MOVE ) { String [ ] items = list . getSelection ( ) ; for ( int i = 0 ; i < items . length ; i ++ ) { list . remove ( items [ i ] ) ; } } } } ) ; } private static void addDropSupport ( final List list ) { DropTarget dropTarget = new DropTarget ( list , DND . DROP_MOVE ) ; dropTarget . setTransfer ( new Transfer [ ] { new StringArrayTransfer ( ) } ) ; dropTarget . addDropListener ( new DropTargetAdapter ( ) { @ Override public void drop ( final DropTargetEvent event ) { String [ ] items = ( String [ ] ) event . data ; for ( int i = 0 ; i < items . length ; i ++ ) {", "gt": "list . add ( items [ i ] ) ;", "prediction": "}\n", "label": 1}
{"id": 2552, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Monster ; public interface LizaMonster extends Monster { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza (", "gt": "HashSet < Byte > transparent , int maxDistance ) ;", "prediction": ")\n", "label": 0}
{"id": 7182, "input": "<s> package org . eclipse . rap . rwt . internal . engine ; import java . io . IOException ; import javax . servlet . * ; import javax . servlet . http . HttpSession ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . engine . RWTClusterSupport ; import org . eclipse . rap . rwt . internal . service . SessionStoreImpl ; import org . eclipse . rap . rwt . testfixture . * ; public class RWTClusterSupport_Test extends TestCase { private static class TestFilterChain implements FilterChain { boolean doFilterWasCalled ; public void doFilter ( ServletRequest request , ServletResponse response ) throws IOException , ServletException { doFilterWasCalled = true ; } } private RWTClusterSupport rwtClusterSupport ; private TestFilterChain chain ; private TestRequest request ; private TestResponse response ; public void testWithNonExistingSession ( ) throws Exception { request . setSession ( null ) ; rwtClusterSupport . doFilter ( request , response , chain ) ; assertTrue ( chain . doFilterWasCalled ) ; } public void testSessionStoreGetsAttached ( ) throws Exception { HttpSession session = new TestSession ( ) ; request . setSession ( session ) ; session . setAttribute ( SessionStoreImpl . ATTR_SESSION_STORE , new SessionStoreImpl ( session ) ) ; rwtClusterSupport . doFilter ( request , response , chain ) ; SessionStoreImpl sessionStore = SessionStoreImpl . getInstanceFromSession ( session ) ; assertTrue ( chain . doFilterWasCalled ) ; assertSame ( session , sessionStore . getHttpSession ( ) ) ; } public void testSessionIsMarkedAsChanged ( ) throws Exception { final StringBuilder log = new StringBuilder ( ) ; HttpSession session = new TestSession ( ) { public void setAttribute ( String name , Object value ) { super . setAttribute ( name , value ) ; if ( log . length ( ) > 0 ) { log . append ( \", \" ) ; } log . append ( name ) ; } } ; request . setSession ( session ) ; session . setAttribute ( \"foo\" , \"bar\" ) ; SessionStoreImpl . attachInstanceToSession ( session , new SessionStoreImpl ( session ) ) ; log . setLength ( 0 ) ; rwtClusterSupport . doFilter ( request , response , chain ) ; assertEquals ( SessionStoreImpl . ATTR_SESSION_STORE , log . toString ( ) ) ; } protected void setUp ( ) throws Exception { request =", "gt": "new TestRequest ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8102, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import org . eclipse . core . resources . IFile ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . common . util . WrappedException ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . resource . impl . ResourceSetImpl ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . runtime . emf . core . GMFEditingDomainFactory ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IWorkbenchPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleMappingEditPart ; public class SimplemapInitDiagramFileAction implements IObjectActionDelegate { private IWorkbenchPart targetPart ; private URI domainModelURI ; public void setActivePart ( IAction action , IWorkbenchPart targetPart ) { this . targetPart = targetPart ; } public void selectionChanged ( IAction action , ISelection selection ) { domainModelURI = null ; action . setEnabled ( false ) ; if ( selection instanceof IStructuredSelection == false || selection . isEmpty ( ) ) { return ; } IFile file = ( IFile ) ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; domainModelURI = URI . createPlatformResourceURI ( file . getFullPath ( ) . toString ( ) , true ) ; action . setEnabled ( true ) ; } private Shell getShell ( ) { return targetPart . getSite ( ) . getShell ( ) ; } public void run ( IAction action ) { TransactionalEditingDomain editingDomain = GMFEditingDomainFactory . INSTANCE . createEditingDomain ( ) ; ResourceSet resourceSet = new ResourceSetImpl ( ) ; EObject diagramRoot = null ; try { Resource resource = resourceSet . getResource ( domainModelURI , true ) ; diagramRoot = ( EObject ) resource . getContents ( ) . get ( 0 ) ; } catch ( WrappedException ex ) { SimplemapDiagramEditorPlugin . getInstance ( ) . logError ( \"Unable to load resource: \" + domainModelURI , ex ) ; } if ( diagramRoot == null ) { MessageDialog . openError ( getShell ( ) ,", "gt": "Messages . InitDiagramFile_ResourceErrorDialogTitle , Messages . InitDiagramFile_ResourceErrorDialogMessage ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7185, "input": "<s> package org . seage . experimenter . reporting . rapidminer ; import com . rapidminer . example . Attribute ; import com . rapidminer . example . Attributes ; import com . rapidminer . example . Example ; import com . rapidminer . example . ExampleSet ; import com . rapidminer . example . set . SortedExampleReader ; import com . rapidminer . example . set . SortedExampleSet ; import com . rapidminer . example . table . * ; import com . rapidminer . operator . IOObjectCollection ; import com . rapidminer . tools . Ontology ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . seage . data . DataNode ; public class ExampleSetConverter { private static final String ROOT_NODE = \"ExampleSet\" ; private static final String COLLECTION_NODE = \"Collection\" ; private static final String ATTRIBUTES_NODE = \"Attributes\" ; private static final String EXAMPLES_NODE = \"Examples\" ; private static final String ATTRIBUTE_NODE = \"Attribute\" ; private static final String EXAMPLE_NODE = \"Example\" ; private static final String RESULT_NODE = \"Result\" ; private static final String NAME_ATTRIBUTE = \"name\" ; private static final String VALUE_ATTRIBUTE = \"value\" ; private static final String ISNOMINAL_ATTRIBUTE = \"isnominal\" ; private static final String NOT_A_NUMBER = \"NaN\" ; public static DataNode convertToDataNodeFromCollection ( IOObjectCollection < ExampleSet > collection ) throws Exception { DataNode collectionNode = new DataNode ( COLLECTION_NODE ) ; boolean once = true ; for ( ExampleSet exampleSet : collection . getObjects ( ) ) { collectionNode . putDataNode ( ExampleSetConverter . convertToDataNodeWithoutAttributes ( exampleSet ) ) ; if ( once ) { collectionNode . putDataNode ( ExampleSetConverter . getAttributesNodeFromExampleSet ( exampleSet ) ) ; once = false ; } } return collectionNode ; } private static DataNode getAttributesNodeFromExampleSet ( ExampleSet exampleSet ) throws Exception { DataNode attributesNode = new DataNode ( ATTRIBUTES_NODE ) ; Attributes attributes = exampleSet . getAttributes ( ) ; Iterator < Attribute > attributeIterator = attributes . allAttributes ( ) ; while ( attributeIterator . hasNext ( ) ) { Attribute attribute = attributeIterator . next ( ) ; DataNode attributeNode = new DataNode ( ATTRIBUTE_NODE ) ; attributeNode . putValue ( NAME_ATTRIBUTE , attribute . getName ( ) ) ; attributeNode . putValue ( ISNOMINAL_ATTRIBUTE , attribute . isNominal ( ) ) ; attributesNode . putDataNode ( attributeNode ) ; } return attributesNode ; } private static DataNode convertToDataNodeWithoutAttributes ( ExampleSet exampleSet ) throws Exception { DataNode exampleSetNode = new DataNode ( ROOT_NODE ) ; DataNode examplesNode = new DataNode ( EXAMPLES_NODE ) ; ExampleTable exampleTable = exampleSet . getExampleTable ( ) ; Iterator < ? > dataRowReader ; if ( exampleSet instanceof SortedExampleSet ) dataRowReader = new SortedExampleReader ( exampleSet ) ; else dataRowReader = exampleTable . getDataRowReader ( ) ; Attributes attributes = exampleSet . getAttributes ( ) ; while ( dataRowReader . hasNext ( ) ) { DataRow dr ; if ( exampleSet instanceof SortedExampleSet ) dr = ( ( Example ) dataRowReader . next ( ) ) . getDataRow ( ) ; else dr = ( DataRow ) dataRowReader . next ( ) ; DataNode exampleNode = new DataNode ( EXAMPLE_NODE ) ; Iterator < Attribute > attributeIterator = attributes . allAttributes ( ) ; while ( attributeIterator . hasNext ( ) ) { Attribute attribute = attributeIterator . next ( ) ; DataNode resultNode = new DataNode ( RESULT_NODE ) ; if ( String . valueOf ( dr . get ( attribute ) ) . equals ( NOT_A_NUMBER ) ) continue ; if ( attribute . isNominal ( ) ) resultNode . putValue ( VALUE_ATTRIBUTE , attribute . getMapping ( ) . mapIndex ( ( int ) dr . get ( attribute ) ) ) ; else resultNode . putValue ( VALUE_ATTRIBUTE , dr . get ( attribute ) ) ; exampleNode . putDataNode ( resultNode ) ; } examplesNode . putDataNode ( exampleNode ) ; } exampleSetNode . putDataNode ( examplesNode ) ; return exampleSetNode ; } public static DataNode convertToDataNode ( ExampleSet exampleSet ) throws Exception { DataNode exampleSetNode = new DataNode ( ROOT_NODE ) ; DataNode attributesNode = new DataNode ( ATTRIBUTES_NODE ) ; DataNode examplesNode = new DataNode ( EXAMPLES_NODE ) ; Attributes attributes = exampleSet . getAttributes ( ) ; Iterator < Attribute > attributeIterator = attributes . allAttributes ( ) ; while ( attributeIterator . hasNext ( ) ) { Attribute attribute = attributeIterator . next ( ) ; DataNode attributeNode = new DataNode ( ATTRIBUTE_NODE ) ; attributeNode . putValue ( NAME_ATTRIBUTE , attribute . getName ( ) ) ; attributeNode . putValue ( ISNOMINAL_ATTRIBUTE , attribute . isNominal ( ) ) ; attributesNode . putDataNode ( attributeNode ) ; } ExampleTable exampleTable = exampleSet . getExampleTable ( ) ; Iterator < ? > dataRowReader ; if ( exampleSet instanceof SortedExampleSet ) dataRowReader = new SortedExampleReader ( exampleSet ) ; else dataRowReader = exampleTable . getDataRowReader ( ) ; while ( dataRowReader . hasNext ( ) ) { DataRow dr ; if ( exampleSet instanceof SortedExampleSet ) dr = ( ( Example ) dataRowReader . next ( ) ) . getDataRow ( ) ; else dr = ( DataRow ) dataRowReader . next ( ) ; DataNode exampleNode = new DataNode ( EXAMPLE_NODE ) ; attributeIterator = attributes . allAttributes ( ) ; while ( attributeIterator . hasNext ( ) ) { Attribute attribute = attributeIterator . next ( ) ; DataNode resultNode = new DataNode ( RESULT_NODE ) ; if ( String . valueOf ( dr . get ( attribute ) ) . equals ( NOT_A_NUMBER ) ) continue ; if ( attribute . isNominal ( ) ) resultNode . putValue ( VALUE_ATTRIBUTE , attribute . getMapping ( ) . mapIndex ( ( int ) dr . get ( attribute ) ) ) ; else resultNode . putValue ( VALUE_ATTRIBUTE , dr . get ( attribute ) ) ; exampleNode . putDataNode ( resultNode ) ; } examplesNode . putDataNode ( exampleNode ) ; } exampleSetNode . putDataNode ( attributesNode ) ; exampleSetNode . putDataNode ( examplesNode ) ; return exampleSetNode ; } public static ExampleSet convertToExampleSet ( DataNode dataNode ) throws Exception { DataNode attributesNode = dataNode . getDataNode ( ATTRIBUTES_NODE ) ; List < Attribute > attributes = new ArrayList < Attribute > ( ) ; for ( DataNode attribute : attributesNode . getDataNodes ( ) ) { Attribute concreteAttribute ; if ( attribute . getValueBool ( ISNOMINAL_ATTRIBUTE ) ) concreteAttribute = AttributeFactory . createAttribute ( attribute . getValueStr ( NAME_ATTRIBUTE ) , Ontology . NOMINAL ) ; else concreteAttribute = AttributeFactory . createAttribute ( attribute . getValueStr ( NAME_ATTRIBUTE ) , Ontology . REAL ) ; attributes . add ( concreteAttribute ) ; } DataNode", "gt": "examplesNode = dataNode . getDataNode ( EXAMPLES_NODE ) ;", "prediction": ";\n", "label": 1}
{"id": 8750, "input": "<s> package org . parboiled . errors ; public class ParserRuntimeException extends RuntimeException { public ParserRuntimeException ( ) { } public ParserRuntimeException ( String message ) { super ( message ) ; } public ParserRuntimeException ( String message , Throwable cause ) { super ( message , cause ) ; } public ParserRuntimeException ( String message , Object ... messageArgs ) { super", "gt": "( String . format ( message , messageArgs ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7188, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . ui . IActionFilter ; public class ListElement implements IAdaptable { private String name ; private boolean flag ; public ListElement ( String name ) { this ( name , false ) ; } public ListElement ( String name , boolean flag ) { this . name = name ; this . flag = flag ; } public String toString ( ) { return name", "gt": "+ ':' + flag ;", "prediction": ";\n", "label": 1}
{"id": 5836, "input": "<s> import java . io . * ; import java . net . URI ; import java . util . * ; import javax . tools . * ; import javax . tools . JavaCompiler . CompilationTask ; public class Test { public static void main ( String ... args ) throws Exception { new Test ( ) . run ( ) ; } void run ( ) throws Exception { Locale prev = Locale . getDefault ( ) ; Locale . setDefault ( Locale . ENGLISH ) ; try { test ( Arrays . < String > asList ( ) , \"myfo://test:1: error: cannot find symbol\" ) ; test ( Arrays . asList ( \"-XDdiagsFormat=OLD\" ) , \"myfo://test:1: cannot find symbol\" ) ; test ( Arrays . asList ( \"-XDoldDiags\" ) , \"myfo://test:1: cannot find symbol\" ) ; } finally { Locale . setDefault ( prev ) ; } } void test ( List < String > options , String expect ) throws Exception { System . err . println ( \"test: \" + options ) ; JavaCompiler javac = ToolProvider . getSystemJavaCompiler ( ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; JavaFileObject f = new MyFileObject ( \"myfo://test\" , \"class Bad { Missing x; }\" ) ; List < ? extends JavaFileObject > files = Arrays . asList ( f ) ; CompilationTask task = javac . getTask ( pw , null , null , options , null , files ) ; boolean ok = task . call ( ) ; pw . close ( ) ; String out = sw . toString ( ) ; if ( ! out . isEmpty ( ) ) System . err . println ( out ) ; if ( ok ) throw new Exception ( \"Compilation succeeded unexpectedly\" ) ; if ( ! out . contains ( expect ) ) throw new Exception", "gt": "( \"expected text not found: \" + expect ) ;", "prediction": ";\n", "label": 0}
{"id": 7218, "input": "<s> package org . eclipse . swt . internal . widgets . menukit ; import java . io . IOException ; import org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil ; import org . eclipse . swt . widgets . * ; final class DropDownMenuLCA extends MenuDelegateLCA { void preserveValues ( Menu menu ) { MenuLCAUtil . preserveValues ( menu ) ; } void readData ( Menu menu ) { MenuLCAUtil . readMenuEvent ( menu ) ; WidgetLCAUtil . processHelp ( menu ) ; } void renderInitialization ( Menu menu ) throws IOException { MenuLCAUtil . renderInitialization ( menu ) ; } void renderChanges ( Menu menu ) throws IOException { MenuLCAUtil", "gt": ". renderChanges ( menu ) ;", "prediction": ";\n", "label": 1}
{"id": 9830, "input": "<s> package org . ofbiz . geronimo ; import java . sql . Connection ; import java . sql . SQLException ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import javax . transaction . xa . XAException ; import org . apache . geronimo . transaction . log . UnrecoverableLog ; import org . apache . geronimo . transaction . manager . GeronimoTransactionManager ; import org . apache . geronimo . transaction . manager . TransactionLog ; import org . apache . geronimo . transaction . manager . XidFactoryImpl ; import org . ofbiz . base . util . Debug ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . ConnectionFactory ; import org . ofbiz . entity . transaction . TransactionFactoryInterface ; public class GeronimoTransactionFactory implements TransactionFactoryInterface { public static final String module = GeronimoTransactionFactory . class . getName ( ) ; private static int defaultTransactionTimeoutSeconds = 60 ; private static TransactionLog transactionLog ; private static GeronimoTransactionManager geronimoTransactionManager ; static { try { transactionLog = new UnrecoverableLog ( ) ; geronimoTransactionManager = new GeronimoTransactionManager ( defaultTransactionTimeoutSeconds , new XidFactoryImpl ( ) , transactionLog ) ; } catch ( XAException e ) { Debug . logError ( e , \"Error initializing Geronimo transaction manager: \" + e . toString ( ) , module ) ; } } public TransactionManager getTransactionManager ( ) { return geronimoTransactionManager ; } public UserTransaction getUserTransaction ( ) { return geronimoTransactionManager ; } public String getTxMgrName ( ) { return \"geronimo\" ; } public Connection getConnection ( GenericHelperInfo helperInfo ) throws SQLException , GenericEntityException { DatasourceInfo datasourceInfo = EntityConfigUtil", "gt": ". getDatasourceInfo ( helperInfo . getHelperBaseName ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 7222, "input": "<s> package org . powerbot . game . api . wrappers . interactive ; import java . awt . Color ; import java . awt . Graphics ; import java . awt . Point ; import java . awt . Polygon ; import org . powerbot . game . api . methods . Calculations ; import org . powerbot . game . api . methods . Game ; import org . powerbot . game . api . methods . input . Mouse ; import org . powerbot . game . api . methods . interactive . NPCs ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . methods . node . Menu ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . util . node . LinkedList ; import org . powerbot . game . api . util . node . Nodes ; import org . powerbot . game . api . wrappers . Entity ; import org . powerbot . game . api . wrappers . Identifiable ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . RegionOffset ; import org . powerbot . game . api . wrappers . Rotatable ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . graphics . CapturedModel ; import org . powerbot . game . api . wrappers . graphics . model . CharacterModel ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . CombatStatus ; import org . powerbot . game . client . CombatStatusData ; import org . powerbot . game . client . HashTable ; import org . powerbot . game . client . Model ; import org . powerbot . game . client . RSAnimator ; import org . powerbot . game . client . RSCharacter ; import org . powerbot . game . client . RSInteractable ; import org . powerbot . game . client . RSInteractableData ; import org . powerbot . game . client . RSMessageData ; import org . powerbot . game . client . RSNPC ; import org . powerbot . game . client . RSNPCNode ; import org . powerbot . game . client . RSPlayer ; import org . powerbot . game . client . Sequence ; public abstract class Character implements Entity , Locatable , Rotatable , Identifiable { private final Client client ; private final Multipliers multipliers ; public Character ( ) { this . client = Context . client ( ) ; this . multipliers = Context . multipliers ( ) ; } public abstract int getLevel ( ) ; public abstract String getName ( ) ; public RegionOffset getRegionOffset ( ) { final RSInteractable location = get ( ) ; final RSInteractableData data = ( RSInteractableData ) location . getData ( ) ; return new RegionOffset ( ( int ) data . getLocation ( ) . getX ( ) > > 9 , ( int ) data . getLocation ( ) . getY ( ) > > 9 , getPlane ( ) ) ; } public Tile getLocation ( ) { final RegionOffset regionTile = getRegionOffset ( ) ; return new Tile ( Game . getBaseX ( ) + regionTile . getX ( ) , Game . getBaseY ( ) + regionTile . getY ( ) , regionTile . getPlane ( ) ) ; } public int getPlane ( ) { return get ( ) . getPlane ( ) ; } public Character getInteracting ( ) { final int index = get ( ) . getInteracting ( ) * multipliers . CHARACTER_INTERACTING ; if ( index == - 1 ) { return null ; } if ( index < 0x8000 ) { final Object npcNode = Nodes . lookup ( ( HashTable ) client . getRSNPCNC ( ) , index ) ; if ( npcNode == null ) { return null ; } return new NPC ( ( RSNPC ) ( ( RSNPCNode ) npcNode ) . getRSNPC ( ) ) ; } else { return new Player ( ( RSPlayer ) client . getRSPlayerArray ( ) [ index - 0x8000 ] ) ; } } public int getAnimation ( ) { final RSAnimator animation = ( RSAnimator ) get ( ) . getAnimation ( ) ; if ( animation != null ) { final Sequence sequence = ( Sequence ) animation . getSequence ( ) ; if ( sequence != null ) { return sequence . getID ( ) * multipliers . SEQUENCE_ID ; } } return - 1 ; } public int getPassiveAnimation ( ) { try { final RSAnimator animation = ( RSAnimator ) get ( ) . getPassiveAnimation ( ) ; if ( animation != null ) { final Sequence sequence = ( Sequence ) animation . getSequence ( ) ; if ( sequence != null ) { return sequence . getID ( ) * multipliers . SEQUENCE_ID ; } } } catch ( final AbstractMethodError ignored ) { } catch ( final ClassCastException ignored ) { } return - 1 ; } public int getHeight ( ) { return get ( ) . getHeight ( ) * multipliers . CHARACTER_HEIGHT ; } public int getRotation ( ) { return get ( ) . getOrientation ( ) * multipliers . CHARACTER_ORIENTATION ; } public int getOrientation ( ) { return ( 630 - getRotation ( ) * 45 / 0x800 ) % 360 ; } private CombatStatusData getCombatInfoData ( ) { final RSCharacter accessor = get ( ) ; if ( accessor == null ) { return null ; } final int global_loopCycle = client . getLoopCycle ( ) * multipliers . GLOBAL_LOOPCYCLE ; final Object combatStatusList = accessor . getCombatStatusList ( ) ; if ( combatStatusList == null ) { return null ; } final LinkedList < Object > linkedCombatStatus = new LinkedList < Object > ( ( org . powerbot . game . client . LinkedList ) combatStatusList ) ; for ( Object combatStatus = linkedCombatStatus . getHead ( ) ; combatStatus != null ; combatStatus = linkedCombatStatus . getNext ( ) ) { final Object dataList = ( ( CombatStatus", "gt": ") combatStatus ) . getData ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3557, "input": "<s> import java . util . List ; class T6763518 { @ SuppressWarnings ( \"rawtypes\" ) List l1 ; void m (", "gt": "@ SuppressWarnings ( \"rawtypes\" ) List l2 )", "prediction": ") ;\n", "label": 0}
{"id": 7223, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . invoker ; import org . apache . http . HttpEntity ; import org . apache . http . HttpResponse ; import org . apache . http . client . ClientProtocolException ; import org . apache . http . client . HttpClient ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . entity . StringEntity ; import org . apache . http . impl . client . DefaultHttpClient ; import org . nuxeo . common . utils . Base64 ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . interfaces . RemotePublisherMarshaler ; import org . nuxeo . ecm . platform . publisher . remoting . server . PublicationInvokationHandler ; import org . nuxeo . ecm . platform . publisher . remoting . server . TestInvokationHandler ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . List ; public class DefaultRemotePublicationInvoker implements RemotePublicationInvoker { protected String baseURL ; protected String userName ; protected String password ; protected RemotePublisherMarshaler marshaler ; protected PublicationInvokationHandler testPublicationHandler ; protected boolean useTestMode = false ; public void init ( String baseURL , String userName , String password , RemotePublisherMarshaler marshaler ) { this . baseURL = baseURL ; this . userName = userName ; this . password = password ; this . marshaler = marshaler ; if ( baseURL . startsWith ( \"test\" ) ) { useTestMode = true ; testPublicationHandler = new TestInvokationHandler ( marshaler ) ; } else { useTestMode = false ; } } public Object invoke ( String methodName , List < Object > params ) throws ClientException { String marshaledData = marshaler . marshallParameters ( params ) ; String result = doInvoke ( methodName , marshaledData ) ; if ( result == null ) return null ; return marshaler . unMarshallResult ( result ) ; } protected String doInvoke ( String methodName , String marshaledData ) throws ClientException { if ( useTestMode ) { return testPublicationHandler . invoke ( methodName , marshaledData ) ; } else { if ( baseURL . startsWith ( \"http\" ) ) { try { return doHttpCall ( methodName , marshaledData ) ; } catch ( Exception e ) { throw new ClientException ( \"Error in http communication\" , e ) ; } } throw new ClientException ( \"Unhandled protocol for url \" + baseURL ) ; } } protected String doHttpCall ( String methodName , String marshaledData ) throws ClientException , ClientProtocolException , IOException { HttpClient httpClient = new DefaultHttpClient ( ) ; String BAHeaderContent = userName + \":\" + password ; BAHeaderContent = Base64 . encodeBytes ( BAHeaderContent . getBytes ( ) ) ; String BAHeader = \"basic \" + BAHeaderContent ; String targetUrl = baseURL + methodName ; HttpPost httpPost = new HttpPost ( targetUrl ) ; HttpEntity entity = new StringEntity ( marshaledData , \"UTF-8\" ) ; httpPost . setEntity ( entity ) ; httpPost . setHeader (", "gt": "\"content-type\" , \"nuxeo/remotepub\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8408, "input": "<s> package org . dawb . workbench . plotting . printing ; import java . awt . image . BufferedImage ; import java . awt . image . ColorModel ; import java . awt . image . DirectColorModel ; import java . awt . image . IndexColorModel ; import java . awt . image . RenderedImage ; import java . awt . image . WritableRaster ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import javax . imageio . ImageIO ; import javax . print . Doc ; import javax . print . DocFlavor ; import javax . print . DocPrintJob ; import javax . print . PrintException ; import javax . print . SimpleDoc ; import javax . print . StreamPrintService ; import javax . print . StreamPrintServiceFactory ; import javax . print . event . PrintJobAdapter ; import javax . print . event . PrintJobEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . Clipboard ; import org . eclipse . swt . dnd . FileTransfer ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . ImageLoader ; import org . eclipse . swt . graphics . PaletteData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PlatformUI ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class PlotExportPrintUtil { public static final String [ ] FILE_TYPES = new String [ ] { \"PNG/JPEG File\" , \"Postscript File\" , \"SVG File\" } ; private static final Logger logger = LoggerFactory . getLogger ( PlotExportPrintUtil . class ) ; private static final String tempDirectory = System . getProperty ( \"java.io.tmpdir\" ) ; private static void savePostScript ( File imageFile , Image image ) throws FileNotFoundException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; RenderedImage awtImage = convertToAWT ( image . getImageData ( ) ) ; try { ImageIO . write ( awtImage , \"png\" , os ) ; } catch ( IOException e ) { logger . error ( \"Could not write to OutputStream\" , e ) ; } try { ByteArrayInputStream inputStream = new ByteArrayInputStream ( os . toByteArray ( ) ) ; InputStream is = new BufferedInputStream ( inputStream ) ; OutputStream fos = new BufferedOutputStream ( new FileOutputStream ( imageFile . getAbsolutePath ( ) ) ) ; DocFlavor flavor = DocFlavor . INPUT_STREAM . GIF ; StreamPrintServiceFactory [ ] factories = StreamPrintServiceFactory . lookupStreamPrintServiceFactories ( flavor , DocFlavor . BYTE_ARRAY . POSTSCRIPT . getMimeType ( ) ) ; if ( factories . length > 0 ) { StreamPrintService service = factories [ 0 ] . getPrintService ( fos ) ; DocPrintJob job = service . createPrintJob ( ) ; Doc doc = new SimpleDoc ( is , flavor , null ) ; PrintJobWatcher pjDone = new PrintJobWatcher ( job ) ; job . print ( doc , null ) ; pjDone . waitUntilDone ( ) ; } is . close ( ) ; fos . close ( ) ; } catch ( PrintException e ) { logger . error ( \"Could not print to PostScript\" , e ) ; } catch ( IOException e ) { logger . error ( \"IO error\" , e ) ; } } private static void saveSVG ( File imageFile , Image image ) throws FileNotFoundException { } private static BufferedImage convertToAWT ( ImageData data ) { ColorModel colorModel = null ; PaletteData palette = data . palette ; if ( palette . isDirect ) { colorModel = new DirectColorModel ( data . depth , palette . redMask , palette . greenMask , palette . blueMask ) ; BufferedImage bufferedImage = new BufferedImage ( colorModel , colorModel . createCompatibleWritableRaster ( data . width , data . height ) , false , null ) ; WritableRaster raster = bufferedImage . getRaster ( ) ; int [", "gt": "] pixelArray = new int [ 3 ] ;", "prediction": ";\n", "label": 0}
{"id": 7235, "input": "<s> package com . codeslap . persistence . pref ; import android . content . Context ; import android . preference . EditTextPreference ; import android . widget . TextView ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; class SmartEditTextPreference extends EditTextPreference { private final Class < ? > mType ; private final String mDefVal ; public SmartEditTextPreference ( Context context , Class < ? > type , String defVal ) { super ( context ) ; mType = type ; mDefVal = defVal ; setOnPreferenceClickListener ( new ProxyOnPreferenceClickListener ( this ) ) ; setOnPreferenceChangeListener ( new TypeChangeListener ( type ) ) ; } @ Override public void setOnPreferenceClickListener ( OnPreferenceClickListener onPreferenceClickListener ) { if ( onPreferenceClickListener instanceof ProxyOnPreferenceClickListener ) { super . setOnPreferenceClickListener ( onPreferenceClickListener ) ; } else { ProxyOnPreferenceClickListener listener = ( ProxyOnPreferenceClickListener ) getOnPreferenceClickListener ( ) ; listener . setClickListener ( onPreferenceClickListener ) ; } } @ Override public void setOnPreferenceChangeListener ( OnPreferenceChangeListener onPreferenceChangeListener ) { if ( onPreferenceChangeListener instanceof TypeChangeListener ) { super . setOnPreferenceChangeListener ( onPreferenceChangeListener ) ; } else { TypeChangeListener listener = ( TypeChangeListener ) getOnPreferenceChangeListener ( ) ; listener . setOnPreferenceChangeListener ( onPreferenceChangeListener ) ; } } @ Override public String getPersistedString ( String defaultReturnValue ) { String value = null ; if ( mType == int . class ) { value = String . valueOf ( getPersistedInt ( Integer . parseInt ( mDefVal ) ) ) ; } else if ( mType == float . class ) { Double val = Double . parseDouble ( mDefVal ) ; value = String . valueOf ( getPersistedFloat ( val . floatValue ( ) ) ) ; } else if ( mType == boolean . class ) { value = String . valueOf ( getPersistedBoolean ( Boolean . parseBoolean ( mDefVal ) ) ) ; } else if ( mType == long . class ) { value = String . valueOf ( getPersistedLong ( Long . parseLong ( mDefVal ) ) ) ; } else if ( mType == String . class ) { value = super . getPersistedString ( mDefVal ) ; } return value ; } @ Override protected boolean persistString ( String value ) { if ( mType == int . class ) { return persistInt ( Integer . parseInt ( value ) ) ; } else if ( mType == float . class ) { return persistFloat ( Float . parseFloat ( value ) ) ; } else if ( mType == boolean . class ) { return persistBoolean ( Boolean . parseBoolean ( value ) ) ; } else", "gt": "if ( mType == long . class )", "prediction": "\n", "label": 1}
{"id": 9433, "input": "<s> package pkg1 ; public class Base {", "gt": "protected void baseMethod ( )", "prediction": "}\n", "label": 0}
{"id": 7238, "input": "<s> package org . apache . lucene . analysis . cn . smart ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; public class AnalyzerProfile { public static String ANALYSIS_DATA_DIR = \"\" ; static { init ( ) ; } private static void init ( ) { String dirName = \"analysis-data\" ; String propName = \"analysis.properties\" ; ANALYSIS_DATA_DIR = System . getProperty ( \"analysis.data.dir\" , \"\" ) ; if ( ANALYSIS_DATA_DIR . length ( ) != 0 ) return ; File [ ] cadidateFiles = new File [ ] { new File ( \"./\" + dirName ) , new File ( \"./lib/\" + dirName ) , new File ( \"./\" + propName ) , new File ( \"./lib/\" + propName ) } ; for ( int i = 0 ; i < cadidateFiles . length ; i ++ ) { File file = cadidateFiles [ i ] ; if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { ANALYSIS_DATA_DIR = file . getAbsolutePath ( ) ; } else if ( file . isFile ( ) && getAnalysisDataDir ( file ) . length ( ) != 0 ) { ANALYSIS_DATA_DIR = getAnalysisDataDir ( file ) ; } break ; } } if ( ANALYSIS_DATA_DIR . length ( ) == 0 ) { System . err . println ( \"WARNING: Can not find lexical dictionary directory!\" ) ; System . err . println ( \"WARNING: This will cause unpredictable exceptions in your application!\" ) ; System . err . println ( \"WARNING: Please refer to the manual", "gt": "to download the dictionaries.\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5010, "input": "<s> package com . deliciousdroid . action ; import android . accounts . Account ; import android . content . Context ; import com . deliciousdroid . providers . BookmarkContent . Bookmark ; public class BookmarkTaskArgs { private Bookmark bookmark ; private Bookmark oldBookmark ; private Account account ; private Context context ; private Boolean update ; public Bookmark getBookmark ( ) { return bookmark ; } public Bookmark getOldBookmark ( ) { return oldBookmark ; } public Account getAccount ( ) { return account ; } public Context getContext ( ) { return context ; } public Boolean getUpdate ( ) { return update ; } public BookmarkTaskArgs ( Bookmark b , Account a , Context c ) { bookmark = b ; account = a ; context = c ; } public BookmarkTaskArgs ( Bookmark b , Bookmark ob , Account", "gt": "a , Context c , Boolean u )", "prediction": ")\n", "label": 0}
{"id": 7248, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . restlet . test . ext . jaxrs . services . tests . DeterminingMediaTypeTest ; @ Path ( \"/providertest\" ) public class DeterminingMediaTypeTestService { @ GET @ Path ( \"htmlPlainGif\" ) @ Produces ( { \"text/html\" , \"text/plain\" , \"image/gif\" } ) public byte [ ] getHtmlPlainGif ( ) { return \"gkjlgk\" . getBytes ( ) ; } @ GET @ Path ( \"textStar\" ) @ Produces", "gt": "( \"text/*\" ) public String getTextStar ( )", "prediction": ";\n", "label": 1}
{"id": 8562, "input": "<s> interface Attribute < T > { } interface AttributeSet2 { < T > Attribute < ? > get ( Class < T > category ) ; } class AttributeSet2Impl implements AttributeSet2 { public Attribute get ( Class category ) { return null ; } } interface AttributeSet3 { Attribute < ? > get ( Class < ? > category ) ; } class AttributeSet3Impl implements AttributeSet3 { public Attribute get ( Class category ) { return null ; } } interface AttributeSet4 { Attribute < ? > get ( Number category ) ; } class AttributeSet4Impl implements AttributeSet4 { public Attribute get ( Number category ) { return null ; } } interface AttributeSet5 { Attribute < ? > get ( Attribute < Number > category ) ; } class AttributeSet5Impl implements AttributeSet5 { public Attribute get ( Attribute category ) { return null ; } } interface I1 < T > { void f ( Attribute < T > l ) ; } class C1 implements I1 < String > { public void f ( Attribute l ) { } void test ( ) { Attribute < Number > n = null ; f ( n ) ; } } interface A2 { void f ( Attribute < String > a ) ; } class B2 { public void f ( Attribute a ) { } } class C2 extends B2 implements A2 { void", "gt": "test ( Attribute < Number > a )", "prediction": "( )\n", "label": 0}
{"id": 7257, "input": "<s> package org . jscsi . scsi . protocol . sense . exceptions ; import org . jscsi . scsi . protocol . sense . KCQ ; import org . jscsi . scsi . protocol . sense . additional . FieldPointer ; public class LogicalUnitNotSupportedException extends IllegalRequestException { private static final long serialVersionUID = 2168812902720645413L ; public LogicalUnitNotSupportedException ( ) { super ( KCQ . LOGICAL_UNIT_NOT_SUPPORTED , true ) ; } @ Override", "gt": "protected FieldPointer getFieldPointer ( )", "prediction": "}\n", "label": 1}
{"id": 4388, "input": "<s> package com . matburt . mobileorg . Synchronizers ; import java . io . BufferedReader ; import java . io . IOException ; import java . security . cert . CertificateException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import javax . net . ssl . SSLHandshakeException ; import android . content . ContentResolver ; import android . content . Context ; import android . content . Intent ; import android . text . TextUtils ; import android . util . Log ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Gui . FileDecryptionActivity ; import com . matburt . mobileorg . Gui . SynchronizerNotification ; import com . matburt . mobileorg . OrgData . OrgContract . Edits ; import com . matburt . mobileorg . OrgData . OrgContract . Files ; import com . matburt . mobileorg . OrgData . OrgEdit ; import com . matburt . mobileorg . OrgData . OrgFile ; import com . matburt . mobileorg . OrgData . OrgFileParser ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import com . matburt . mobileorg . util . FileUtils ; import com . matburt . mobileorg . util . OrgFileNotFoundException ; import com . matburt . mobileorg . util . OrgUtils ; public class Synchronizer { public static final String SYNC_UPDATE = \"com.matburt.mobileorg.Synchronizer.action.SYNC_UPDATE\" ; public static final String SYNC_DONE = \"sync_done\" ; public static final String SYNC_START = \"sync_start\" ; public static final String SYNC_PROGRESS_UPDATE = \"progress_update\" ; public static final String SYNC_SHOW_TOAST = \"showToast\" ; public static final String CAPTURE_FILE = \"mobileorg.org\" ; public static final String INDEX_FILE = \"index.org\" ; private Context context ; private ContentResolver resolver ; private SynchronizerInterface syncher ; private SynchronizerNotification notify ; public Synchronizer ( Context context , SynchronizerInterface syncher , SynchronizerNotification notify ) { this . context = context ; this . resolver = context . getContentResolver ( ) ; this . syncher = syncher ; this . notify = notify ; } public boolean isEnabled ( ) { return true ; } public void runSynchronizer ( OrgFileParser parser ) { if ( ! syncher . isConfigured ( ) ) { notify . errorNotification ( \"Sync not configured\" ) ; return ; } try { announceStartSync ( ) ; pull ( parser ) ; pushCaptures ( ) ; announceSyncDone ( ) ; } catch ( Exception e ) { showErrorNotification ( e ) ; OrgUtils . announceSyncDone ( context ) ; } } public void pushCaptures ( ) throws IOException , CertificateException , SSLHandshakeException { final String filename = CAPTURE_FILE ; notify . updateNotification ( \"Uploading captures\" ) ; String localContents = \"\" ; try { OrgFile file = new OrgFile ( filename , resolver ) ; localContents += file . toString ( resolver ) ; } catch ( OrgFileNotFoundException e ) { } localContents += OrgEdit . editsToString ( resolver ) ; if ( localContents . equals ( \"\" ) ) return ; String remoteContent = FileUtils . read ( syncher . getRemoteFile ( filename ) ) ; if ( remoteContent . indexOf ( \"{\\\"error\\\":\" ) == - 1 ) localContents = remoteContent + \"\\n\" + localContents ; syncher . putRemoteFile ( filename , localContents ) ; try { new OrgFile ( filename , resolver ) . removeFile ( resolver ) ; } catch ( OrgFileNotFoundException e ) { } resolver . delete ( Edits .", "gt": "CONTENT_URI , null , null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7265, "input": "<s> package com . cloudera . sqoop . testutil ; import java . util . List ; public final class CommonArgs { private CommonArgs ( ) { } public static final String LOCAL_FS = \"file:///\" ; public static final String FS_DEFAULT_NAME = \"fs.defaultfs.name\" ; public static final String FS_DEFAULTFS = \"fs.defaultFS\" ; public static String getJobtrackerAddress ( ) { return System . getProperty ( \"mapreduce.jobtracker.address\" , \"local\" ) ; } public static String getDefaultFS ( ) { return System . getProperty ( FS_DEFAULT_NAME , LOCAL_FS ) ; } public static void addHadoopFlags ( List < String > args ) { args . add ( \"-D\" ) ; args . add ( \"mapreduce.jobtracker.address=local\" ) ; args . add ( \"-D\" ) ; args .", "gt": "add ( \"mapreduce.job.maps=1\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6340, "input": "<s> package pkg1 ; public @ interface Value {", "gt": "String value ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7283, "input": "<s> package org . mitre . openid . connect . token ; import java . util . Date ; import java . util . Map ; import java . util . Set ; import org . mitre . openid . connect . model . ApprovedSite ; import org . mitre . openid . connect . model . WhitelistedSite ; import org . mitre . openid . connect . service . ApprovedSiteService ; import org . mitre . openid . connect . service . WhitelistedSiteService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . core . Authentication ; import org . springframework . security . oauth2 . common . exceptions . InvalidScopeException ; import org . springframework . security . oauth2 . provider . AuthorizationRequest ; import org . springframework . security . oauth2 . provider . ClientDetails ; import org . springframework . security . oauth2 . provider . ClientDetailsService ; import org . springframework . security . oauth2 . provider . approval . UserApprovalHandler ; import com . google . common . base . Splitter ; import com . google . common . collect . Sets ; public class TofuUserApprovalHandler implements UserApprovalHandler { @ Autowired ApprovedSiteService approvedSiteService ; @ Autowired WhitelistedSiteService whitelistedSiteService ; @ Autowired ClientDetailsService clientDetailsService ; @ Override public boolean isApproved ( AuthorizationRequest authorizationRequest , Authentication userAuthentication ) { String userId = userAuthentication . getName ( ) ; String clientId = authorizationRequest . getClientId ( ) ; ClientDetails client = clientDetailsService . loadClientByClientId ( clientId ) ; String scopes = authorizationRequest . getAuthorizationParameters ( ) . get ( \"scope\" ) ; Set < String > authRequestScopes = Sets . newHashSet ( Splitter . on ( \" \" ) . split ( scopes ) ) ; ApprovedSite ap = approvedSiteService . getByClientIdAndUserId ( clientId , userId ) ; if ( ap != null ) { if ( scopesMatch ( authRequestScopes , ap . getAllowedScopes ( ) ) ) { ap . setAccessDate ( new Date ( ) ) ; approvedSiteService . save ( ap ) ; return true ; } } WhitelistedSite ws = whitelistedSiteService", "gt": ". getByClientId ( clientId ) ;", "prediction": ";\n", "label": 1}
{"id": 587, "input": "<s> package com . sun . tools . apt . mirror . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . TypeVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; @ SuppressWarnings ( \"deprecation\" ) public class WildcardTypeImpl extends TypeMirrorImpl implements WildcardType { protected Type . WildcardType type ; WildcardTypeImpl ( AptEnv env , Type . WildcardType type ) { super ( env , type ) ; this . type = type ; } public String toString ( ) { return toString ( env , type ) ; } public Collection < ReferenceType > getUpperBounds ( ) { return type . isSuperBound ( ) ? Collections . < ReferenceType > emptyList ( ) : typeToCollection", "gt": "( type . type ) ;", "prediction": ";\n", "label": 0}
{"id": 7285, "input": "<s> package cs224n . util ; public class UnorderedPair < F , S > { F first ; S second ; public F getFirst ( ) { return first ; } public S getSecond ( ) { return second ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof UnorderedPair ) ) return false ; final UnorderedPair pair = ( UnorderedPair ) o ; return ( ( ( first == null ? pair . first == null : first . equals ( pair . first ) ) && ( second == null ? pair . second == null : second . equals ( pair . second ) ) ) || ( ( first == null ? pair . second == null : first . equals ( pair . second ) ) && ( second == null ? pair . first == null : second . equals ( pair . first ) ) ) ) ; } public int hashCode ( ) { int firstHashCode = ( first == null ? 0 : first . hashCode ( ) ) ; int secondHashCode = ( second == null ? 0 : second . hashCode ( ) ) ; if ( firstHashCode != secondHashCode ) { return ( ( ( firstHashCode & secondHashCode ) << 16 ) ^ ( ( firstHashCode | secondHashCode ) ) ) ; } else { return firstHashCode ; } } public String toString ( ) { String firstString = getFirst ( ) . toString ( ) ; String secondString = getSecond ( ) . toString ( ) ; if ( firstString . compareTo ( secondString ) > 0 ) { String tempString = firstString ; firstString = secondString ; secondString = tempString ; } return \"(\" + firstString +", "gt": "\", \" + secondString + \")\" ;", "prediction": ";\n", "label": 1}
{"id": 9929, "input": "<s> package org . remast . baralga . gui . model . report ; import java . util . Date ; import org . apache . commons . lang . builder . CompareToBuilder ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . joda . time . DateTime ; public class HoursByMonth implements Comparable < HoursByMonth > { private DateTime month ; private double hours ; public HoursByMonth ( final DateTime month , final double hours ) { this . month = month ; this . hours = hours ; } public Date getMonth ( ) { return month . toDate ( ) ; } public double getHours ( ) { return hours ; } @ Override public boolean equals ( final Object that ) { if ( this == that ) { return true ; } if ( ! ( that instanceof HoursByMonth ) ) { return false ; } final HoursByMonth accAct = ( HoursByMonth ) that ; final EqualsBuilder eqBuilder = new EqualsBuilder ( ) ; eqBuilder . append ( this . month . getYear ( ) , accAct . month .", "gt": "getYear ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7308, "input": "<s> package io . beancounter . publisher . twitter . adapters ; import io . beancounter . commons . model . activity . Verb ; import io . beancounter . commons . model . activity . rai . Comment ; import io . beancounter . publisher . twitter . TwitterPublisherException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import twitter4j . Status ; import twitter4j . Twitter ; import twitter4j . TwitterException ; public class CommentPublisher implements Publisher < Comment > { private static final Logger LOG = LoggerFactory . getLogger ( CommentPublisher . class ) ; @ Override public Status publish ( Twitter twitter , Verb verb , Comment comment ) throws TwitterPublisherException { Status status ; String message = getMessage ( comment ) ; try { status = twitter . updateStatus ( message ) ; } catch ( TwitterException e ) { final String errMessage = \"Error while", "gt": "updating the status to [\" + message + \"]\" ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9246, "input": "<s> package org . hackreduce . mappers . ngram ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import org . apache . hadoop . io . WritableComparable ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . lib . input . TextInputFormat ; import org . hackreduce . mappers . ModelMapper ; import org . hackreduce . models . ngram . TwoGram ; public abstract class TwoGramMapper < K extends WritableComparable < ? > , V extends Writable > extends ModelMapper < TwoGram , LongWritable , Text", "gt": ", K , V >", "prediction": ") ;\n", "label": 0}
{"id": 7311, "input": "<s> package com . inepex . classtemplater . plugin . logic ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . eclipse . jdt . core . Flags ; import org . eclipse . jdt . core . ICompilationUnit ; import org . eclipse . jdt . core . IField ; public class Attribute { String name ; String type ; String visibility ; boolean isPrivate = false ; boolean isPublic = false ; boolean isProtected = false ; boolean isStatic = false ; boolean isAbstract = false ; boolean isFinal = false ; boolean isList = false ; boolean isGeneric = false ; boolean isEnum = false ; boolean isMap = false ; Set < Importable > typesInGenerics = new HashSet < Importable > ( ) ; List < Importable > typesInGenericsList = new ArrayList < Importable > ( ) ; List < String > firstLevelGenericTypes = new ArrayList < String > ( ) ; Map < String , Annotation > annotations = new HashMap < String , Annotation > ( ) ; private String workspaceRelativePath ; private String packageName ; public Attribute ( String name , String type , String visibility , boolean isStatic , boolean isAbstract , boolean isFinal , boolean isList , boolean isGeneric , boolean isEnum ) { super ( ) ; this . name = name ; this . type = type ; setVisibility ( visibility ) ; this . isStatic = isStatic ; this . isAbstract = isAbstract ; this . isFinal = isFinal ; this . isList = isList ; this . isGeneric = isGeneric ; this . isEnum = isEnum ; } public Attribute ( IField field ) throws Exception { String sign = field . getTypeSignature ( ) ; processSignature ( sign ) ; String visibility = \"\" ; if ( Flags . isPublic ( field . getFlags ( ) ) ) visibility = \"public\" ; else if ( Flags . isPrivate ( field . getFlags ( ) ) ) visibility = \"private\" ; else if ( Flags . isProtected ( field . getFlags ( ) ) ) visibility = \"protected\" ; else visibility = \"public\" ; name = field . getElementName ( ) ; this . visibility = visibility ; setVisibility ( visibility ) ; isStatic = Flags . isStatic ( field . getFlags ( ) ) ; isAbstract = Flags . isAbstract ( field . getFlags ( ) ) ; isFinal =", "gt": "Flags . isFinal ( field . getFlags ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 7503, "input": "<s> package mp3player ; import java . io . IOException ; import java . net . URL ; import java . util . Properties ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . BooleanControl ; import javax . sound . sampled . Control ; import javax . sound . sampled . DataLine ; import javax . sound . sampled . FloatControl ; import javax . sound . sampled . LineEvent ; import javax . sound . sampled . LineListener ; import javax . sound . sampled . SourceDataLine ; import config . AppConfig ; import javazoom . jl . decoder . Decoder ; import javazoom . jl . decoder . JavaLayerException ; import javazoom . jl . player . AudioDevice ; import javazoom . jl . player . advanced . PlaybackListener ; import main . Application ; import servercontact . Server ; public class MP3Player implements Runnable { Thread t = null ; static Object lock = new Object ( ) ; static boolean stop = false ; static boolean paused = false ; SourceDataLine line = null ; AudioFormat decodedFormat = null ; AudioInputStream din = null ; FloatControl volControl = null ; BooleanControl muteControl = null ; public Properties songProperties = new Properties ( ) ; private PlaybackListener listener ; private AudioDevice audio ; public static boolean songCompleted ; public MP3Player ( Properties properties ) { URL url = null ; try { songProperties = properties ; String songID = songProperties . getProperty ( \"id\" ) ; url = Server . getStreamURL ( songID ) ; AudioInputStream in = AudioSystem . getAudioInputStream ( url ) ; AudioFormat baseFormat = in . getFormat ( ) ; decodedFormat = new AudioFormat ( AudioFormat . Encoding . PCM_SIGNED , baseFormat . getSampleRate ( ) , 16 , baseFormat . getChannels ( ) , baseFormat . getChannels ( ) * 2 , baseFormat . getSampleRate ( ) , false ) ; din = AudioSystem . getAudioInputStream ( decodedFormat , in ) ; DataLine . Info info = new DataLine . Info ( SourceDataLine . class , decodedFormat ) ; line = ( SourceDataLine ) AudioSystem . getLine ( info ) ; } catch ( Exception ex ) { System . out . println ( \"MP3Player: URL = \" + url ) ; ex . printStackTrace ( ) ; } } public long getPosition ( ) { if ( line != null ) { return line . getMicrosecondPosition ( ) ; } else { return 0 ; } } public void play ( ) { if ( t == null ) { t = new Thread ( this ) ; line . addLineListener ( createLineListener ( ) ) ; t . start ( ) ; } } public void stop ( ) { if ( isPlaying ( ) || isPaused ( ) ) { stop = true ; } } public void pause ( ) { paused = true ; } public void unpause ( ) { synchronized ( lock ) { paused = false ; lock . notifyAll ( ) ; } } public void mute ( ) { try { muteControl . setValue ( true ) ; } catch ( Exception ignore ) { } } public void unmute ( ) { try { muteControl . setValue ( false ) ; } catch ( Exception ignore ) { } } public void setVolume ( float gain ) { if ( volControl != null ) { volControl . setValue ( gain ) ; } } public boolean isPlaying ( ) { if ( line != null && ( line . isRunning ( ) && ! isPaused ( ) ) ) { return true ; } else { return false ; } } public boolean isPaused ( ) { return paused ; } @ Override public void run ( ) { try { if ( line != null ) { line . open ( decodedFormat ) ; byte [ ] data = new byte [ 4096 ] ; line . start ( ) ; Control control [ ] = line . getControls ( ) ; volControl = ( ( FloatControl ) control [ 0 ] ) ; volControl . setValue ( AppConfig . getVolume ( ) ) ; muteControl = ( ( BooleanControl ) control [ 1 ] ) ; int nBytesRead ; synchronized ( lock ) { while ( ( nBytesRead = din . read ( data , 0 , data . length ) ) != - 1 && ! stop ) { while (", "gt": "paused && ! stop )", "prediction": ") ;\n", "label": 0}
{"id": 7313, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . internal . * ; public interface GestureListener extends SWTEventListener { public void", "gt": "gesture ( GestureEvent e ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3466, "input": "<s> package org . jboss . arquillian . android . api ; public interface AndroidDeviceOutputReciever { void processNewLines (", "gt": "String [ ] lines ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7328, "input": "<s> package org . eclipse . ui ; public interface IPlaceholderFolderLayout { public void addPlaceholder ( String viewId ) ; public String getProperty ( String id ) ; public void setProperty ( String", "gt": "id , String value ) ;", "prediction": ")\n", "label": 1}
{"id": 7466, "input": "<s> package evalexpr ; import java . io . ByteArrayOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . StringReader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . CharBuffer ; import java . util . HashMap ; import java . util . Map ; import javax . tools . * ; import javax . tools . JavaFileObject . Kind ; public final class MemoryFileManager extends ForwardingJavaFileManager { private Map < String , byte [ ] > classes ; public static JavaFileObject makeSource ( String name , String code ) { return new JavaSourceFromString ( name , code ) ; } public MemoryFileManager ( JavaFileManager fileManager ) { super ( fileManager ) ; classes = new HashMap < String , byte [ ] > ( ) ; } @ Override public ClassLoader getClassLoader ( Location location ) { return new ByteArrayClassLoader ( classes ) ; } @ Override public JavaFileObject getJavaFileForOutput ( Location location , String name , Kind kind , FileObject originatingSource ) throws UnsupportedOperationException { if ( originatingSource instanceof JavaSourceFromString ) { return new JavaClassInArray ( name ) ; } else { throw new UnsupportedOperationException ( ) ; } } protected static URI uriFromString ( String uri ) { try { return new URI ( uri ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e ) ; } } private class JavaClassInArray extends SimpleJavaFileObject { private String name ; JavaClassInArray ( String name ) { super ( uriFromString ( \"mfm:///\" + name . replace ( '.' , '/' ) + Kind . CLASS . extension ) , Kind . CLASS ) ; this . name = name ; }", "gt": "public OutputStream openOutputStream ( )", "prediction": "}\n", "label": 0}
{"id": 7351, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . automation . core . util . Properties ; public class StringToProperties implements TypeAdapter { public Object getAdaptedValue ( OperationContext ctx , Object objectToAdapt ) throws TypeAdaptException { String content = ( String ) objectToAdapt ; try { return new Properties ( content ) ; } catch ( Exception e ) { throw", "gt": "new TypeAdaptException ( e ) ;", "prediction": ";\n", "label": 1}
{"id": 8541, "input": "<s> package org . davidsingleton . nnrccar ; public class FeatureFrame { byte [ ] features ; float [ ] accelerometerFeatures ; boolean left ; boolean right ; boolean forward ; boolean reverse ; int leftStateLenMs ; int rightStateLenMs ; int forwardStateLenMs ; int reverseStateLenMs ; public int getLeftStateLenMs ( ) { return leftStateLenMs ; } public int getRightStateLenMs ( ) { return rightStateLenMs ; } public int getForwardStateLenMs ( ) { return forwardStateLenMs ; } public int getReverseStateLenMs ( ) { return reverseStateLenMs ; } public FeatureFrame ( byte [ ] features , boolean left , boolean right , boolean forward , boolean reverse , int leftTime , int rightTime , int forwardTime , int reverseTime , float [ ] accelerometerFeatures ) { super ( ) ; this . features = features ; this . left = left ; this . right = right ; this . forward = forward ; this . reverse = reverse ; this . leftStateLenMs = leftTime ; this . rightStateLenMs = rightTime ; this . forwardStateLenMs = forwardTime ; this . reverseStateLenMs = reverseTime ; this . accelerometerFeatures = accelerometerFeatures ; } public byte [ ] getFeatures ( ) { return features ; } public boolean isLeft ( ) { return left ; } public boolean isRight ( ) { return right ; } public boolean isForward ( ) { return forward ; } public boolean isReverse ( ) { return reverse ; }", "gt": "public float getAccelerometerFeature ( int i )", "prediction": "}\n", "label": 0}
{"id": 7375, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . explorer ; import java . net . URL ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . Path ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . internal . cheatsheets . CheatSheetPlugin ; import org . eclipse . ui . internal . cheatsheets . composite . model . TaskStateUtilities ; import org . eclipse . ui . internal . cheatsheets . composite . parser . ICompositeCheatsheetTags ; import org . eclipse . ui . internal . cheatsheets . composite . views . TaskEditorManager ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ITaskGroup ; import org . osgi . framework . Bundle ; public class TreeLabelProvider extends LabelProvider { private static int BLOCKED = - 1 ; private Image defaultImage = null ; private class ImageSet { Map images = new HashMap ( ) ; public void put ( int index , Image image ) { images . put ( Integer . toString ( index ) , image ) ; } public Image getImage ( int index ) { return ( Image ) images . get ( Integer . toString ( index ) ) ; } void dispose ( ) { } } private Map imageMap = null ; public TreeLabelProvider ( ) { imageMap = new HashMap ( ) ; } public String getText ( Object obj ) { String result ; if ( obj instanceof ICompositeCheatSheetTask ) { result = ( ( ICompositeCheatSheetTask ) obj ) . getName ( ) ; } else { result = obj . toString ( ) ; } if ( result == null ) { result = \"\" ; } return result ; } public Image getImage ( Object obj ) { if ( obj instanceof ICompositeCheatSheetTask ) { ICompositeCheatSheetTask task = ( ICompositeCheatSheetTask ) obj ; return lookupImage ( task . getKind ( ) , task . getState ( ) , TaskStateUtilities . isBlocked ( task ) ) ; } return super . getImage ( obj ) ; } public Image lookupImage ( String kind , int state , boolean isBlocked ) { ImageSet images = ( ImageSet ) imageMap . get ( kind ) ; if ( images == null ) { images = createImages ( kind ) ; imageMap . put ( kind , images ) ; } if ( isBlocked ) { return images . getImage ( BLOCKED ) ; } return images . getImage ( state ) ; } private ImageSet createImages ( String kind ) { ImageSet images = new ImageSet ( ) ; ImageDescriptor desc ; desc = getPredefinedImageDescriptor ( kind , true ) ; if ( desc == null ) { desc = TaskEditorManager . getInstance ( ) . getImageDescriptor ( kind ) ; } if ( desc != null ) { Image baseImage = desc . createImage ( ) ; images . put ( ICompositeCheatSheetTask . NOT_STARTED , baseImage ) ; createImageWithOverlay ( ICompositeCheatSheetTask . IN_PROGRESS , \"$nl$/icons/ovr16/task_in_progress.gif\" , images , desc ) ; createImageWithOverlay ( ICompositeCheatSheetTask . SKIPPED , \"$nl$/icons/ovr16/task_skipped.gif\" , images , desc ) ; createDisabledImage ( kind , BLOCKED , images , baseImage ) ; createImageWithOverlay ( ICompositeCheatSheetTask . COMPLETED , \"$nl$/icons/ovr16/task_complete.gif\" , images , desc ) ; } return images ; } private ImageDescriptor getPredefinedImageDescriptor ( String kind , boolean isEnabled ) { String filename ; if ( ICompositeCheatsheetTags . CHEATSHEET_TASK_KIND . equals ( kind ) ) { filename = \"cheatsheet_task.gif\" ; } else if ( ITaskGroup . SET . equals ( kind ) ) { filename = \"task_set.gif\" ; } else if ( ITaskGroup . CHOICE . equals ( kind ) ) { filename = \"task_choice.gif\" ; } else if ( ITaskGroup . SEQUENCE . equals ( kind ) ) { filename = \"task_sequence.gif\" ; } else { return null ; } String iconPath = \"$nl$/icons/\" ; if ( isEnabled ) { iconPath += CheatSheetPlugin . T_OBJ ; } else { iconPath += CheatSheetPlugin . T_DLCL ; } iconPath += filename ; return createImageDescriptor ( iconPath ) ; } private void createImageWithOverlay ( int state , String imagePath , ImageSet images , ImageDescriptor baseDescriptor ) { ImageDescriptor descriptor = createImageDescriptor ( imagePath ) ; images . put ( state , descriptor . createImage ( ) ) ; } private void createDisabledImage ( String kind , int state , ImageSet images , Image baseImage ) { ImageDescriptor desc = getPredefinedImageDescriptor ( kind , false ) ; Image disabledImage ; if ( desc != null ) { disabledImage = desc . createImage ( ) ; } else { disabledImage = createGrayedImage ( baseImage ) ; } images . put ( state , disabledImage ) ; } private Image createGrayedImage ( Image image ) { return image ; } private ImageDescriptor createImageDescriptor ( String relativePath ) { Bundle bundle = CheatSheetPlugin . getPlugin ( ) . getBundle ( ) ; URL url = FileLocator . find ( bundle ,", "gt": "new Path ( relativePath ) , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4628, "input": "<s> package org . msl . simple . gmfmap . model . triggers . parent ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . gmfgraph . BasicFont ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . GMFGraphFactory ; import org . eclipse . gmf . gmfgraph . Label ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse . gmf . mappings . ChildReference ; import org . eclipse . gmf . mappings . CompartmentMapping ; import org . eclipse . gmf . mappings . GMFMapFactory ; import org . eclipse . gmf . mappings . NodeMapping ; import org . eclipse . gmf . tooldef . CreationTool ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; public class NewSubNodeTrigger extends NewTopNodeTrigger { public NewSubNodeTrigger ( TransactionalEditingDomain domain , SimpleParentNode parent , SimpleSubNode newSubNode ) { super ( domain , parent , newSubNode ) ; } @ Override public void executeTrigger ( ) { Node newNode = GMFGraphFactory . eINSTANCE . createNode ( ) ; DiagramLabel newLabel = GMFGraphFactory . eINSTANCE . createDiagramLabel ( ) ; Label parentLabel = getLabelFigure ( parent ) ; BasicFont parentFont = parentLabel != null ? ( BasicFont ) parentLabel . getFont ( ) : null ; updateCanvas ( newNode , newLabel , parentFont ) ; CreationTool newCreationTool = createNewTool ( ) ; if ( parent instanceof SimpleCompartment ) { SimpleNode parentNode = ( SimpleNode ) ( ( SimpleCompartment ) parent ) . getParent ( ) ; updateMapping ( parentNode , newNode , newLabel , newCreationTool , ( ( SimpleCompartment ) parent ) . getCompartmentMapping ( ) ) ; } else updateMapping ( ( SimpleNode ) parent , newNode , newLabel , newCreationTool ) ; } protected void updateCanvas ( Node newNode , DiagramLabel newLabel , BasicFont parentFont ) { canvasFactory . createDefaultRoundedRectangleWithLabel ( newNode , newLabel , false , parentFont ) ; } private void updateMapping ( SimpleNode parentNode , Node newNode , DiagramLabel newLabel , CreationTool newCreationTool ) { updateMapping ( parentNode , newNode , newLabel , newCreationTool , null ) ; } private void updateMapping ( SimpleNode parentNode , Node newNode , DiagramLabel newLabel , CreationTool newCreationTool , CompartmentMapping compartment ) { NodeMapping newNodeMapping = createNewNodeMapping ( newNode , newLabel , newCreationTool ) ; ChildReference newChildReference = GMFMapFactory", "gt": ". eINSTANCE . createChildReference ( ) ;", "prediction": ";\n", "label": 0}
{"id": 7379, "input": "<s> package org . mitre . openid . connect . web ; import java . beans . PropertyEditorSupport ; import java . util . Set ; import org . mitre . jwt . signer . JwsAlgorithm ; import org . mitre . oauth2 . exception . ClientNotFoundException ; import org . mitre . oauth2 . model . ClientDetailsEntity ; import org . mitre . oauth2 . model . ClientDetailsEntity . AppType ; import org . mitre . oauth2 . model . ClientDetailsEntity . AuthType ; import org . mitre . oauth2 . model . ClientDetailsEntity . UserIdType ; import org . mitre . oauth2 . service . ClientDetailsEntityService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . oauth2 . common . exceptions . UnauthorizedClientException ; import org . springframework . stereotype . Controller ; import org . springframework . ui . ModelMap ; import org . springframework . web . bind . WebDataBinder ; import org . springframework . web . bind . annotation . InitBinder ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; import com . google . common . base . Joiner ; import com . google . common . base . Objects ; import com . google . common . base . Splitter ; import com . google . common . base . Strings ; import com . google . common . collect . Sets ; @ Controller @ RequestMapping ( value = \"register\" ) public class ClientDynamicRegistrationEndpoint { @ Autowired private ClientDetailsEntityService clientService ; @ InitBinder public void utilityDataInitBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( AppType . class , new PropertyEditorSupport ( ) { @ Override public void setAsText ( String text ) throws IllegalArgumentException { if ( Strings . isNullOrEmpty ( text ) ) { setValue ( null ) ; } else { setValue ( AppType . getByValue ( text ) ) ; } } @ Override public String getAsText ( ) { AppType at = ( AppType ) getValue ( ) ; return at == null ? null : at . getValue ( ) ; } } ) ; binder . registerCustomEditor ( AuthType . class , new PropertyEditorSupport ( ) { @ Override public void setAsText ( String text ) throws IllegalArgumentException { if (", "gt": "Strings . isNullOrEmpty ( text ) )", "prediction": ")\n", "label": 1}
{"id": 8570, "input": "<s> import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import javax . swing . JFrame ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; public class LineGraph extends JPanel implements ClickerConsumerInterface { private String currentQuestion ; private JFrame parentFrame ; private int width ; private int height ; private ConsumerFrame parent ; private Map < String , Map < String , String > > currentValueMap ; private float value1 ; private float value2 ; private Color weirdGray ; private float equationValue1 ; private float equationValue2 ; private int promptCount ; public LineGraph ( ) { equationValue1 = - 2.0f ; equationValue2 = 4.0f ; promptCount = 0 ; value1 = 0f ; value2 = 0f ; currentQuestion = \"\" ; width = 400 ; height = 400 ; parentFrame = new JFrame ( ) ; parentFrame . setSize ( width + 80 , height + 80 ) ; this . setMinimumSize ( new Dimension ( width , height ) ) ; parentFrame . add ( \"Center\" , this ) ; weirdGray = new Color ( 0x6E6E6E ) ; initializeGraph ( ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; drawGridLines ( g ) ; drawGridLabels ( g ) ; g . setColor ( Color . BLUE ) ; g . drawLine ( 200 , 0 , 200 , 400 ) ; g . drawLine ( 0 , 200 , 400 , 200 ) ; float lastx = 0 ; float lasty = 0 ; float scalar = 10 ; float lastEQy = 0 ; for ( int z = - 200 ; z <= 200 ; z ++ ) { g . setColor ( Color . RED ) ; float x = z / scalar ; float y = ( x ) * ( value1 * scalar ) + ( value2 * scalar ) ; float xDraw = z + 200 ; float eqY = ( x ) * ( equationValue1 * scalar ) + ( equationValue2 * scalar ) ; if ( z == - 200 ) { lastx = xDraw ; lasty = dy ( y ) ; lastEQy = dy ( eqY ) ; } g . drawLine ( ( int ) lastx , ( int ) lastEQy , ( int ) xDraw , ( int ) dy ( eqY ) ) ; g . setColor ( Color . BLACK ) ; g . drawLine ( ( int ) lastx , ( int ) lasty , ( int ) xDraw , ( int ) dy ( y ) ) ; lastx = xDraw ; lasty = dy ( y ) ; lastEQy = dy ( eqY ) ; } g . drawString ( ( value1 ) + \" + \" + ( value2 ) + \"x\" , 250 , 375 ) ; System . out . println ( \"-200 : \" + ( int ) ( - 20 * equationValue1 ) + \" 200 :\" + ( int ) ( 20 * equationValue2 ) ) ; if ( ( value1 ) == equationValue1 && ( value2 ) == equationValue2 && promptCount == 0 ) { promptCount ++ ; JOptionPane . showMessageDialog ( this , \"Matched the equation!\" ) ; } } private void drawGridLabels ( Graphics g ) { g . setColor ( weirdGray ) ; g . drawString ( \"0\" , 202 , 205 ) ; g . drawString ( \"2\" , 202 , 185 ) ; g . drawString ( \"4\" , 202 , 165 ) ; g . drawString ( \"6\" , 202 , 145 ) ; g . drawString ( \"8\" , 202 , 125 ) ; g . drawString ( \"10\" , 202 , 105 ) ; g . drawString ( \"-2\" , 202 , 225 ) ; g . drawString ( \"-4\" , 202 , 245 ) ; g . drawString ( \"-6\" , 202 , 265 ) ; g . drawString ( \"-8\" , 202 , 285 ) ; g . drawString ( \"-10\" , 202 , 305 ) ; g . drawString ( \"2\" , 217 , 214 ) ; g . drawString ( \"4\" , 237 , 214 ) ; g . drawString ( \"6\" , 257 , 214 ) ; g . drawString ( \"8\" , 277 , 214 ) ; g . drawString ( \"10\" , 292 , 214 ) ; g . drawString ( \"-2\" , 177 , 214 ) ; g . drawString (", "gt": "\"-4\" , 157 , 214 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7387, "input": "<s> package org . fuzzydb . attrs . enums ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . internal . IConstraintMap ; import org . fuzzydb . attrs . internal . TwoAttrScorer ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; import org . fuzzydb . core . whirlwind . internal . IAttributeMap ; import org . fuzzydb . util . BitSet64 ; public class OptionsScorer extends TwoAttrScorer { private static final long serialVersionUID = 1L ; @ SuppressWarnings ( \"unused\" ) private OptionsScorer ( ) { this ( 1 , 1 ) ; } public OptionsScorer ( int attrId , int otherAttrId ) { super ( attrId , otherAttrId ) ; } @ Override public void scoreSearchToNode ( Score score , Score . Direction d , IConstraintMap c , IAttributeMap < ? extends IAttribute > scoreAttrs ) { IAttribute attr = scoreAttrs . findAttr ( scorerAttrId ) ; if ( attr == null ) { return ; } EnumMultipleValue bAttr = ( EnumMultipleValue ) attr ; IAttributeConstraint na = c . findAttr ( otherAttrId ) ; if ( bAttr . isWantNull ( ) ) { float scoreVal = na == null || na . isIncludesNotSpecified ( ) ? maxScore : minScore ; score . add ( this , scoreVal , d ) ; return ; } if ( na == null ) { score . addNull ( this , d ) ; return ; } float result = 0.0f ; if ( na . isIncludesNotSpecified ( ) ) { if ( isScoreNull ( ) ) { result = getScoreOnNull ( ) ; } } result = Math . max ( result , calcScoreSearchToNode ( bAttr , ( EnumMultipleConstraint ) na ) ) ; score . add ( this , result , d ) ; } @ Override public void scoreNodeToSearch ( Score score , Score . Direction d , IAttributeMap < IAttributeConstraint > c , IAttributeMap < IAttribute > searchAttrs ) { IAttributeConstraint bNa = c . findAttr ( scorerAttrId ) ; if ( bNa == null ) { return ; } EnumMultipleValue otherAttr = ( EnumMultipleValue ) searchAttrs . findAttr ( otherAttrId ) ; if ( bNa . isIncludesNotSpecified ( ) ) { score . add ( this , maxScore , d ) ; return ; } if ( otherAttr == null ) { score . addNull ( this , d ) ; return ; } float result = calcScoreNodeToSearch ( ( EnumMultipleConstraint ) bNa , otherAttr ) ; score . add ( this , result , d ) ; } @ Override public void scoreItemToItem ( Score score , Score . Direction d , IAttributeMap < IAttribute > c , IAttributeMap < IAttribute > scoreAttrs ) { IAttribute attr = scoreAttrs . findAttr ( scorerAttrId ) ; if ( attr == null ) { return ; } EnumMultipleValue searchAttr = ( EnumMultipleValue ) attr ; EnumMultipleValue otherAttr = ( EnumMultipleValue ) c . findAttr ( otherAttrId ) ; if ( searchAttr . isWantNull ( ) ) { float scoreVal = ( otherAttr == null ) ? maxScore : minScore ; score . add ( this , scoreVal , d ) ; return ; } if ( otherAttr == null ) { score . addNull ( this , d ) ; return ; } float result = calcScoreItemToItem ( searchAttr , otherAttr ) ; score . add ( this , result , d ) ; } private float getMultiEnumScore ( int numMatches , int matchesForTopScore ) { if ( matchesForTopScore == numMatches ) { return 1f ; } if ( numMatches == 0 ) return minScore ; if ( numMatches >= matchesForTopScore ) return maxScore ; float interval = ( maxScore - minScore ) / matchesForTopScore ; float result = minScore + numMatches * interval ; return result ; } private float calcScoreItemToItem ( EnumMultipleValue thisAttr , EnumMultipleValue otherAttr ) { BitSet64 thisBits = thisAttr . getBitSet ( ) ; BitSet64 otherBits = otherAttr . getBitSet ( ) ; return calcScoreUsingNumMatchingBits ( thisBits , otherBits ) ; } private float calcScoreUsingNumMatchingBits ( BitSet64 thisBits , BitSet64 otherBits ) { BitSet64 matches = ( BitSet64 ) thisBits . clone ( ) ; matches . and ( otherBits ) ; int matchCount", "gt": "= matches . cardinality ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3153, "input": "<s> package com . sun", "gt": ". mirror . apt ;", "prediction": ";\n", "label": 0}
{"id": 7401, "input": "<s> package org . eclipse . jface . viewers ; public class TreeColumnViewerLabelProvider extends TableColumnViewerLabelProvider { private ITreePathLabelProvider treePathProvider = new ITreePathLabelProvider ( ) { public void updateLabel ( ViewerLabel label , TreePath elementPath ) { } public void dispose ( ) { } public void addListener ( ILabelProviderListener listener ) { } public void removeListener ( ILabelProviderListener listener ) { } public boolean isLabelProperty ( Object element , String property ) { return false ; } } ; public TreeColumnViewerLabelProvider ( IBaseLabelProvider labelProvider ) { super ( labelProvider ) ; } public void updateLabel ( ViewerLabel label , TreePath elementPath ) { treePathProvider . updateLabel ( label , elementPath ) ; } public void setProviders ( Object provider ) { super . setProviders ( provider ) ; if ( provider instanceof", "gt": "ITreePathLabelProvider ) treePathProvider = ( ITreePathLabelProvider ) provider ;", "prediction": ")\n", "label": 1}
{"id": 1176, "input": "<s> package pkg1 ; import java . io . IOException ; import java . io . Serializable ; public class C1 implements Serializable { @ Deprecated public boolean undecorated = false ; private String title ; public static enum ModalExclusionType { NO_EXCLUDE , APPLICATION_EXCLUDE } ; public C1 ( String", "gt": "title , boolean test )", "prediction": ")\n", "label": 0}
{"id": 7408, "input": "<s> package monbulk . MetadataEditor ; import com . google . gwt . core . client . GWT ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . user . client . ui . Widget ; import com . google . gwt . user . client . ui . LayoutPanel ; import com . google . gwt . user . client . ui . HTMLPanel ; import com . google . gwt . user . client . ui . TextBox ; import com . google . gwt . user . client . ui . ListBox ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . CheckBox ; import com . google . gwt . event . dom . client . ChangeEvent ; import com . google . gwt . event . dom . client . KeyUpHandler ; import com . google . gwt . dom . client . Style ; import monbulk . shared . Services . * ; public class CommonElementPanel extends ElementPanel { public interface ChangeTypeHandler { public void onChangeType ( Element element , String newType ) ; } private static ElementPanelUiBinder uiBinder = GWT . create ( ElementPanelUiBinder . class ) ; @ UiField TextBox m_name ; @ UiField ListBox m_type ; @ UiField TextBox m_description ; @ UiField TextBox m_minOccurs ; @ UiField TextBox m_maxOccurs ; @ UiField Label m_maxOccursLabel ; @ UiField Label m_minOccursLabel ; @ UiField LayoutPanel m_layout ; @ UiField HTMLPanel m_maxOccursPanel ; @ UiField Label m_typeLabel ; @ UiField HTMLPanel m_typePanel ; CheckBox m_required = new CheckBox ( \"Required\" ) ; ChangeTypeHandler m_changeTypeHandler = null ; interface ElementPanelUiBinder extends UiBinder < Widget , CommonElementPanel > { } public CommonElementPanel ( ) { Widget w = uiBinder . createAndBindUi ( this ) ; initWidget ( w ) ; } public void setNameFocus ( ) { m_name . setFocus ( true ) ; m_name . selectAll ( ) ; } public void setMinOccursFocus ( ) { m_minOccurs . setFocus ( true ) ; m_minOccurs . selectAll ( ) ; } public void addNameKeyUpHandler ( KeyUpHandler handler ) { m_name . addKeyUpHandler ( handler ) ; } public String getName ( ) { return m_name . getText ( ) ; } public void setChangeTypeHandler ( ChangeTypeHandler handler ) { m_changeTypeHandler = handler ; } public void update ( Element element ) { element . setSetting ( \"name\" , m_name . getText ( ) ) ; element . setDescription ( m_description . getText ( ) ) ; if ( element . getIsAttribute ( ) ) { element . setSetting ( \"min-occurs\" , m_required . getValue ( ) ? \"1\" : \"0\" ) ; } else { String minOccurs = m_minOccurs . getValue ( ) ; element . setSetting ( \"min-occurs\" , minOccurs ) ; String maxOccurs = m_maxOccurs . getValue ( ) ; element . setSetting ( \"max-occurs\" , maxOccurs ) ; } } public void set ( Element element ) { super . set ( element ) ; boolean isAttribute = element . getIsAttribute ( ) ; m_type . clear ( ) ; for ( Element . ElementTypes e : Element . ElementTypes . values ( ) ) { if ( e . isVisible ( ) && ( ! isAttribute || e . isUseInAttributes ( ) ) ) { m_type . addItem ( e . toString ( ) ) ; } } m_name . setText ( element . getName ( ) ) ; m_description . setText ( element . getDescription ( ) ) ; String type = element . getType ( ) . toString ( ) ; for ( int i = 0 ; i < m_type . getItemCount ( ) ; i ++ ) { if ( m_type . getItemText ( i )", "gt": ". equals ( type ) )", "prediction": ") ;\n", "label": 1}
{"id": 1274, "input": "<s> import java . util . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import static com . sun . mirror . type . PrimitiveType . Kind . * ; public class TypeCreation extends Tester { public static void main ( String [ ] args ) { ( new TypeCreation ( ) ) . run ( ) ; } class A { } class O < T > { class I < S > { } } private Types types ; private TypeDeclaration A ; private TypeDeclaration O ; private TypeDeclaration I ; private DeclaredType AType ; protected void init ( ) { types = env . getTypeUtils ( ) ; A = env . getTypeDeclaration ( \"TypeCreation.A\" ) ; O = env . getTypeDeclaration ( \"TypeCreation.O\" ) ; I = env . getTypeDeclaration ( \"TypeCreation.O.I\" ) ; AType = types . getDeclaredType ( A ) ; } @ Test ( result = \"boolean\" ) PrimitiveType getPrimitiveType ( ) { return types . getPrimitiveType ( BOOLEAN ) ; } @ Test ( result = \"void\" ) VoidType getVoidType ( ) { return types . getVoidType ( ) ; } @ Test ( result = \"boolean[]\" ) ArrayType getArrayType1 ( ) { return types . getArrayType ( types . getPrimitiveType ( BOOLEAN ) ) ; } @ Test ( result = \"TypeCreation.A[]\" ) ArrayType getArrayType2 ( ) { return types . getArrayType ( AType ) ; } @ Test ( result = \"? extends TypeCreation.A\" ) WildcardType getWildcardType ( ) { Collection < ReferenceType > uppers = new ArrayList < ReferenceType > ( ) ; Collection < ReferenceType > downers = new ArrayList < ReferenceType > ( ) ; uppers . add ( AType ) ; return types . getWildcardType ( uppers , downers ) ; } @ Test ( result = \"TypeCreation.O<java.lang.String>\" ) DeclaredType getDeclaredType1 ( ) { TypeDeclaration stringDecl = env . getTypeDeclaration ( \"java.lang.String\" ) ; DeclaredType stringType = types", "gt": ". getDeclaredType ( stringDecl ) ;", "prediction": ";\n", "label": 0}
{"id": 7436, "input": "<s> package org . fuzzydb . attrs . converters ; import java . util . UUID ; import org . springframework . core . convert . converter . Converter ; public class StringToUuidConverter implements Converter < String , UUID > { @ Override", "gt": "public UUID convert ( String uuid )", "prediction": ";\n", "label": 1}
{"id": 277, "input": "<s> package mage . tracker . domain ; import java . io . Serializable ; import javax . persistence . * ; @ NamedQueries ( { @ NamedQuery ( name = \"CardEdition.findByNameAndExpansion\" , query = \"select c from CardEdition c where c.card.name = :cardName and c.expansion.name = :expansionName\" ) , @ NamedQuery ( name = \"CardEdition.findByNameAndExpansionCode\" , query = \"select c from CardEdition c where c.card.name = :cardName and c.expansion.code = :expansionCode\" ) , @ NamedQuery ( name = \"CardEdition.findByCardId\" , query = \"select c from CardEdition c where c.card.id = :cardId\" ) , @ NamedQuery ( name = \"CardEdition.findByCardNumberAndExpansionId\" , query = \"select c from CardEdition c where c.cardNumber = :cardNumber and c.expansion.id = :expansionId\" ) } ) @ Entity public class CardEdition implements Serializable { public static final String FIND_BY_NAME_AND_EXPANSION = \"CardEdition.findByNameAndExpansion\" ; public static final String FIND_BY_NAME_AND_EXPANSION_CODE = \"CardEdition.findByNameAndExpansionCode\" ; public static final String FIND_BY_CARD_NUMBER_AND_EXPANSION_ID = \"CardEdition.findByCardNumberAndExpansionId\" ; public static final String FIND_BY_CARD_ID = \"CardEdition.findByCardId\" ; @ Id @ GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; @ ManyToOne private Card card ; @ ManyToOne ( fetch = FetchType . EAGER ) private Expansion expansion ; @ Column ( length = 64 ) private String gathererId ; @ Column ( length = 64 ) private String cardNumber ; @ Column ( length = 64 ) private String mtgoImageId ; @ Enumerated ( EnumType . ORDINAL ) @ Column ( nullable = false ) private CardRarity rarity ; public Card getCard ( ) { return card ; } public void setCard ( Card card ) { this . card = card ; } public String getCardNumber ( ) { return cardNumber ; } public void setCardNumber ( String cardNumber ) { this . cardNumber = cardNumber ; } public Expansion getExpansion ( ) { return expansion ; } public void", "gt": "setExpansion ( Expansion expansion )", "prediction": "( )\n", "label": 0}
{"id": 7437, "input": "<s> package com . cloudera . sqoop . lib ; import java . io . * ; import com . cloudera . sqoop . testutil . BaseSqoopTestCase ; import com . cloudera . sqoop . testutil . CommonArgs ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . cloudera . sqoop . io . LobFile ; public class TestBlobRef extends TestCase { public void testEmptyStr ( ) { BlobRef r = BlobRef . parse ( \"\" ) ; assertFalse ( r . isExternal ( ) ) ; } public void testInline ( ) throws IOException { BlobRef r = BlobRef . parse ( \"foo\" ) ; assertFalse ( r . isExternal ( ) ) ; } public void testEmptyFile ( ) { BlobRef r = BlobRef . parse ( \"externalLob()\" ) ; assertFalse ( r . isExternal ( ) ) ; r = BlobRef . parse ( \"externalLob(lf,,0,0)\" ) ; assertTrue ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(lf,,0,0)\" , r . toString ( ) ) ; } public void testInlineNearMatch ( ) { BlobRef r = BlobRef . parse ( \"externalLob(foo)bar\" ) ; assertFalse ( r . isExternal ( ) ) ; r = BlobRef . parse ( \"externalLob(foo)\" ) ; assertFalse ( r . isExternal ( ) ) ; r = BlobRef . parse ( \"externalLob(lf,foo)\" ) ; assertFalse ( r . isExternal ( ) ) ; r = BlobRef . parse ( \"externalLob(lf,foo,1,2)x\" ) ; assertFalse ( r . isExternal ( ) ) ; } public void testExternal ( ) throws IOException { final byte [ ] DATA = { 1 , 2 , 3 , 4 , 5 } ; final String FILENAME = \"blobdata\" ; doExternalTest ( DATA , FILENAME ) ; } public void testExternalSubdir ( ) throws IOException { final byte [ ] DATA = { 1 , 2 , 3 , 4 , 5 } ; final String FILENAME = \"_lob/blobdata\" ; try { doExternalTest ( DATA , FILENAME ) ; } finally { Configuration conf = new Configuration ( ) ; FileSystem fs = FileSystem . getLocal ( conf ) ; String tmpDir = System . getProperty ( \"test.build.data\" , \"/tmp/\" ) ; Path lobDir = new Path ( new Path ( tmpDir ) , \"_lob\" ) ; fs . delete ( lobDir , false ) ; } } private void doExternalTest ( final byte [ ] data , final String filename ) throws IOException { Configuration conf = new Configuration ( ) ; if ( ! BaseSqoopTestCase . isOnPhysicalCluster ( ) ) { conf . set ( CommonArgs . FS_DEFAULT_NAME , CommonArgs . LOCAL_FS ) ; } FileSystem fs = FileSystem . get ( conf ) ; String tmpDir = System . getProperty ( \"test.build.data\" , \"/tmp/\" ) ; Path tmpPath = new Path ( tmpDir ) ; Path blobFile = new Path ( tmpPath , filename ) ; Path blobParent = blobFile . getParent ( ) ; if ( ! fs . exists ( blobParent ) ) { fs . mkdirs ( blobParent ) ; } LobFile . Writer lw = LobFile . create ( blobFile , conf , false ) ; try { long off = lw . tell ( ) ; long len = data . length ; OutputStream os = lw . writeBlobRecord ( len ) ; os . write ( data , 0 , data . length ) ; os . close ( ) ; lw . close ( ) ; String refString = \"externalLob(lf,\" + filename + \",\" + off + \",\" + len + \")\" ; BlobRef blob = BlobRef . parse ( refString ) ; assertTrue ( blob . isExternal ( ) ) ; assertEquals ( refString , blob . toString ( ) ) ; InputStream is = blob . getDataStream ( conf , tmpPath ) ; assertNotNull ( is ) ; byte [ ] buf = new", "gt": "byte [ 4096 ] ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9431, "input": "<s> package com . quirijngrootbluemink . iptools ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import android . app . Activity ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . IntentFilter ; import android . graphics . Color ; import android . graphics . Paint ; import android . net . wifi . ScanResult ; import android . net . wifi . WifiManager ; import android . os . Bundle ; import android . os . Handler ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . ListView ; import com . androidplot . Plot ; import com . androidplot . series . XYSeries ; import com . androidplot . ui . AnchorPosition ; import com . androidplot . ui . SizeLayoutType ; import com . androidplot . xy . BoundaryMode ; import com . androidplot . xy . LineAndPointFormatter ; import com . androidplot . xy . LineAndPointRenderer ; import com . androidplot . xy . SimpleXYSeries ; import com . androidplot . xy . XLayoutStyle ; import com . androidplot . xy . XYPlot ; import com . androidplot . xy . XYStepMode ; import com . androidplot . xy . YLayoutStyle ; import com . markupartist . android . widget . ActionBar ; public class WifiChannelChart extends Activity { private XYPlot channelChart ; private List < ScanResult > scanResults ; private List < XYSeries > currentSeries ; BroadcastReceiver receiver ; ListView wifiNetworksList ; WifiManager wifi ; Handler handlr ; Runnable mUpdateScanTask ; private void setActionBar ( ) { ActionBar actionBar = ( ActionBar ) findViewById ( R . id . actionBar ) ; actionBar . setTitle ( getString ( R . string . app_name ) ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setOnTitleClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { goUp ( ) ; } } ) ; } private void goUp ( ) { this . finish ( ) ; } private double calculateY ( double x , double strength , double channel ) { double v = 100 - strength ; double vertical = 100 - v ; double stretch = ( 0.25 ) * v ; double formula = - ( Math . pow ( ( x - channel ) , 2 ) ) ; return ( ( stretch ) * ( formula ) - ( vertical ) ) ; } private List < List < Double > > getCoordinates ( double channel , double strength ) { List < List < Double > > coords = new ArrayList < List < Double > > ( ) ; List < Double > x2 = new ArrayList < Double > ( ) ; double chan = channel ; double step = 0.1 ; double startpoint = chan - 2 ; double endpoint = chan + 2.1 ; double counter = startpoint ; while ( counter <= endpoint ) { x2 . add ( counter ) ; counter += step ; } counter = startpoint ; List < Double > y2 = new ArrayList < Double > ( ) ; while ( counter <= ( endpoint ) ) { double v = calculateY ( counter , Math . abs ( strength ) , chan ) ; y2 . add ( v ) ; counter += step ; } coords . add ( x2 ) ; coords . add ( y2 ) ; return coords ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . wifi_channel_graph ) ; setActionBar ( ) ; currentSeries", "gt": "= new ArrayList < XYSeries > ( ) ;", "prediction": ";\n", "label": 0}
{"id": 7443, "input": "<s> package org . restlet . ext . ssl ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . channels . SocketChannel ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLEngine ; import org . restlet . Request ; import org . restlet . Server ; import org . restlet . data . Protocol ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . connector . ConnectionController ; import org . restlet . engine . connector . HttpServerHelper ; import org . restlet . engine . connector . InboundWay ; import org . restlet . engine . connector . OutboundWay ; import org . restlet . ext . ssl . internal . HttpsInboundRequest ; import org . restlet . ext . ssl . internal . HttpsServerInboundWay ; import org . restlet . ext . ssl . internal . HttpsServerOutboundWay ; import org . restlet . ext . ssl . internal . SslConnection ; import org . restlet . ext . ssl . internal . SslUtils ; public class HttpsServerHelper extends HttpServerHelper { private volatile SSLContext sslContext ; public HttpsServerHelper ( Server server ) { super ( server , Protocol . HTTPS ) ; } @ Override protected Connection < Server > createConnection ( SocketChannel socketChannel , ConnectionController controller , InetSocketAddress socketAddress ) throws IOException { SSLEngine engine ;", "gt": "if ( socketAddress != null )", "prediction": "}\n", "label": 1}
{"id": 7420, "input": "<s> package com . redhat . ceylon . compiler . java . tools ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import java . util . zip . ZipEntry ; import javax . tools . JavaFileObject ; import javax . tools . StandardLocation ; import com . redhat . ceylon . cmr . api . ArtifactContext ; import com . redhat . ceylon . cmr . api . Logger ; import com . redhat . ceylon . cmr . api . RepositoryManager ; import com . redhat . ceylon . cmr . api . SourceArchiveCreator ; import com . redhat . ceylon . cmr . ceylon . CeylonUtils ; import com . redhat . ceylon . cmr . util . JarUtils ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . sun . tools . javac . main . OptionName ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Options ; public class JarOutputRepositoryManager { private Map < Module , ProgressiveJar > openJars = new HashMap < Module , ProgressiveJar > ( ) ; private Log log ; private Options options ; private CeyloncFileManager ceyloncFileManager ; JarOutputRepositoryManager ( Log log , Options options , CeyloncFileManager ceyloncFileManager ) { this . log = log ; this . options = options ; this . ceyloncFileManager = ceyloncFileManager ; } public JavaFileObject getFileObject ( RepositoryManager repositoryManager , Module module , String fileName , File sourceFile ) throws IOException { ProgressiveJar progressiveJar = getProgressiveJar ( repositoryManager , module ) ; return progressiveJar . getJavaFileObject ( fileName , sourceFile ) ; } private ProgressiveJar getProgressiveJar ( RepositoryManager repositoryManager , Module module ) throws IOException { ProgressiveJar jarFile = openJars . get ( module ) ; if ( jarFile == null ) { jarFile = new ProgressiveJar ( repositoryManager , module , log , options , ceyloncFileManager ) ; openJars . put ( module , jarFile ) ; } return jarFile ; } public void flush ( ) throws IOException { try { for ( ProgressiveJar jarFile : openJars . values ( ) ) { jarFile . close ( ) ; } } finally { openJars . clear ( ) ; } } static class ProgressiveJar { private static final String MAPPING_FILE = \"META-INF/mapping.txt\" ; private File originalJarFile ; private File outputJarFile ; private JarOutputStream jarOutputStream ; final private Set < String > modifiedSourceFiles = new HashSet < String > ( ) ; final private Properties writtenClassesMapping = new Properties ( ) ; private Logger cmrLog ; private Options options ; private RepositoryManager repoManager ; private ArtifactContext carContext ; private SourceArchiveCreator creator ; public ProgressiveJar ( RepositoryManager repoManager , Module module , Log log , Options options , CeyloncFileManager ceyloncFileManager ) throws IOException { this . options = options ; this . repoManager = repoManager ; this . carContext = new ArtifactContext ( module . getNameAsString ( ) , module . getVersion ( ) , ArtifactContext . CAR ) ; this . cmrLog = new JavacLogger ( options , Log . instance ( ceyloncFileManager . getContext ( ) ) ) ; this . creator = CeylonUtils . makeSourceArchiveCreator ( repoManager , ceyloncFileManager . getLocation ( StandardLocation . SOURCE_PATH ) , module . getNameAsString ( ) , module . getVersion ( ) , options . get ( OptionName . VERBOSE ) != null , cmrLog ) ; setupJarOutput ( ) ; } private void setupJarOutput ( ) throws IOException { File targetJarFile = repoManager . getArtifact ( carContext ) ; outputJarFile = File . createTempFile ( \"car\" , \".tmp\" ) ; originalJarFile = targetJarFile ; jarOutputStream = new JarOutputStream ( new FileOutputStream ( outputJarFile ) ) ; } private Properties getPreviousMapping ( ) throws IOException { if ( originalJarFile != null ) { JarFile jarFile = null ; jarFile = new JarFile ( originalJarFile ) ; try { JarEntry entry = jarFile . getJarEntry ( MAPPING_FILE ) ; if ( entry != null ) { InputStream inputStream = jarFile . getInputStream ( entry ) ; try { Properties previousMapping = new Properties ( ) ; previousMapping .", "gt": "load ( inputStream ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7471, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . io . File ; import java . io . IOException ; import java . util . Map ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . PackageUpdateComponent ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task . standalone . commands . UninstallPlaceholder ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; @ Deprecated public class Uninstall extends UninstallPlaceholder { public Uninstall ( ) { super ( ) ; } public Uninstall ( File file ) { super ( file ) ; } @ Override protected Command doRun ( Task task , Map < String , String > prefs ) throws PackageException { BundleContext ctx = PackageUpdateComponent . getContext ( ) . getBundle ( ) . getBundleContext ( ) ; JarFile jar = null ; try { jar = new JarFile ( file ) ; Manifest mf = jar . getManifest ( ) ; String name = mf . getMainAttributes ( ) . getValue ( \"Bundle-SymbolicName\" ) ; if ( name != null ) {", "gt": "for ( Bundle bundle : ctx . getBundles ( ) )", "prediction": "}\n", "label": 1}
{"id": 3899, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . datumswaehler ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . SwingConstants ; class DatumAuswaehlWerkzeugUI { private JPanel _hauptPanel ; private JButton _weiterButton ; private JButton _zurueckButton ; private JLabel _datumLabel ; public DatumAuswaehlWerkzeugUI ( String startDatumString ) { _hauptPanel = erstellePanel ( startDatumString ) ; } private JPanel erstellePanel ( String startDatumString ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridBagLayout ( ) ) ; _datumLabel = new JLabel ( startDatumString , SwingConstants . CENTER ) ; panel . add ( _datumLabel , new GridBagConstraints ( 0 , 0 , 2 , 1 , 1.0 , 0.0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 2 , 0 , 2 , 0 ) , 0 , 0 ) ) ; Icon zurueckIcon =", "gt": "new ImageIcon ( \"images/go-previous.png\" ) ;", "prediction": ";\n", "label": 0}
{"id": 7488, "input": "<s> package org . mitre . openid . connect . config ; public class OIDCServerConfiguration { private String authorizationEndpointUrl ; private String tokenEndpointUrl ; private String clientSecret ; private String clientId ; private String issuer ; private String x509EncryptUrl ; private String x509SigningUrl ; private String jwkEncryptUrl ; private String jwkSigningUrl ; private String userInfoUrl ; public String getAuthorizationEndpointUrl ( ) { return authorizationEndpointUrl ; } public String getClientId ( ) { return clientId ; } public String getIssuer ( ) { return issuer ; } public String getClientSecret ( ) { return clientSecret ; } public String getTokenEndpointUrl ( ) { return tokenEndpointUrl ; } public void setAuthorizationEndpointUrl ( String authorizationEndpointURI ) { this . authorizationEndpointUrl = authorizationEndpointURI ; } public void setClientId ( String clientId ) { this . clientId = clientId ; } public void setIssuer ( String issuer ) { this . issuer = issuer ; } public void setClientSecret ( String clientSecret ) { this . clientSecret = clientSecret ; } public void setTokenEndpointUrl ( String tokenEndpointURI ) { this . tokenEndpointUrl = tokenEndpointURI ; } public String getX509EncryptUrl ( ) { return x509EncryptUrl ; } public String getX509SigningUrl ( ) { return x509SigningUrl ; } public String getJwkEncryptUrl ( ) { return jwkEncryptUrl ; } public String getJwkSigningUrl ( ) { return jwkSigningUrl ; } public void setX509EncryptUrl ( String x509EncryptUrl ) { this . x509EncryptUrl = x509EncryptUrl ; } public void setX509SigningUrl ( String x509SigningUrl ) { this", "gt": ". x509SigningUrl = x509SigningUrl ;", "prediction": ";\n", "label": 1}
{"id": 9893, "input": "<s> import java . util . StringTokenizer ; import java . io . IOException ; import java . util . Vector ; class Main { static int maxLg = 200 ; public static void sort ( Vector v ) { int n = v . size ( ) ; Vector v2 = new Vector ( ) ; char us [ ] = new char [ n ] ; int j , t , i ; P p1 , p2 ; for ( i = 0 ; i < n ; i ++ ) { p1 = null ; t = - 1 ; for ( j = 0 ; j < n ; j ++ ) { if ( us [ j ] == 1 ) continue ; p2 = ( P ) v . elementAt ( j ) ; if ( p1 == null || p1 . compareTo ( p2 ) > 0 ) { t = j ; p1 = p2 ; } } us [ t ] = 1 ; v2 . addElement ( p1 ) ; } v . removeAllElements ( ) ; for ( i = 0 ; i != n ; i ++ ) { v . addElement ( v2 . elementAt ( i ) ) ; } } public static void main ( String args [ ] ) throws Exception { } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \",\" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ;", "gt": "int lg = 0 , car = - 1 ;", "prediction": "}\n", "label": 0}
{"id": 7489, "input": "<s> package org . nuxeo . ecm . automation . server . test ; import static org . junit . Assert . * ; import java . io . FileInputStream ; import java . lang . management . ManagementFactory ; import java . lang . management . MemoryMXBean ; import java . lang . management . MemoryUsage ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . client . Session ; import org . nuxeo . ecm . automation . server . test . UploadFileSupport . MockInputStream ; import org . nuxeo . ecm . automation . test . RestFeature ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import org . nuxeo . runtime . test . runner . Jetty ; import com . google . inject . Inject ; @ RunWith ( FeaturesRunner . class ) @ Features ( RestFeature . class ) @ Jetty ( port = 18080 ) public class UploadBigFileTest { @ Inject Session session ; @ Test public void withMaxMemory ( ) throws Exception { MemoryMXBean mbean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage usage = mbean . getHeapMemoryUsage ( ) ; MockInputStream source = UploadFileSupport . newMockInput ( usage . getMax ( ) , false ) ; FileInputStream result = new UploadFileSupport", "gt": "( session ) . testUploadFile ( source ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4279, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface LogicalDateLiteral extends LogicalExpression {", "gt": "String getValue ( ) ;", "prediction": "return ;\n", "label": 0}
{"id": 7501, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . text . MessageFormat ; import java . util . * ; import java . util . Map . Entry ; import javax . servlet . http . * ; import org . eclipse . rap . rwt . internal . lifecycle . FakeContextUtil ; import org . eclipse . rap . rwt . internal . lifecycle . ISessionShutdownAdapter ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . internal . util . SerializableLock ; import org . eclipse . rap . rwt . service . * ; import org . eclipse . swt . internal . SerializableCompatibility ; public final class SessionStoreImpl implements ISessionStore , HttpSessionBindingListener , SerializableCompatibility { public static final String ATTR_SESSION_STORE = SessionStoreImpl . class . getName ( ) ; public static SessionStoreImpl getInstanceFromSession ( HttpSession httpSession ) { return ( SessionStoreImpl ) httpSession . getAttribute ( ATTR_SESSION_STORE ) ; } public static void attachInstanceToSession ( HttpSession httpSession , ISessionStore sessionStore ) { httpSession . setAttribute ( ATTR_SESSION_STORE , sessionStore ) ; } private final SerializableLock requestLock ; private final SerializableLock lock ; private final Map < String , Object > attributes ; private final Set < SessionStoreListener > sessionStoreListeners ; private final String id ; private transient HttpSession httpSession ; private boolean bound ; private boolean aboutUnbound ; private transient ISessionShutdownAdapter shutdownAdapter ; public SessionStoreImpl ( HttpSession httpSession ) { ParamCheck . notNull ( httpSession , \"httpSession\" ) ; requestLock = new SerializableLock ( ) ; lock = new SerializableLock ( ) ; attributes = new HashMap < String , Object > ( ) ; sessionStoreListeners = new HashSet < SessionStoreListener > ( ) ; id = httpSession . getId ( ) ; bound = true ; this . httpSession = httpSession ; } public void setShutdownAdapter ( ISessionShutdownAdapter adapter ) { shutdownAdapter = adapter ; if ( shutdownAdapter != null ) { shutdownAdapter . setSessionStore ( this ) ; shutdownAdapter . setShutdownCallback ( new Runnable ( ) { public void run ( ) { doValueUnbound ( ) ; } } ) ; } } public ISessionShutdownAdapter getShutdownAdapter ( ) { return shutdownAdapter ; } public Object getAttribute ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; Object result = null ; synchronized ( lock ) { result = attributes . get ( name ) ; } return result ; } public boolean setAttribute ( String name , Object value ) { ParamCheck . notNull ( name , \"name\" ) ; boolean result = false ; synchronized ( lock ) { if ( bound ) { result = true ; removeAttributeInternal ( name ) ; attributes . put ( name , value ) ; fireValueBound ( name , value ) ; } } return result ; } public boolean removeAttribute ( String name ) { ParamCheck . notNull ( name , \"name\" ) ; boolean result = false ; synchronized ( lock ) { if ( bound ) { result = true ; removeAttributeInternal ( name ) ; } } return result ; } public Enumeration < String > getAttributeNames ( ) { return createAttributeNameEnumeration ( ) ; } public String getId ( ) { return id ; } public HttpSession getHttpSession ( ) { synchronized ( lock ) { return httpSession ; } } public void attachHttpSession ( HttpSession httpSession ) { ParamCheck . notNull ( httpSession , \"httpSession\" ) ; synchronized ( lock ) { this . httpSession = httpSession ; } } public boolean isBound ( ) { synchronized ( lock ) { return bound ; } } public boolean addSessionStoreListener ( SessionStoreListener listener ) { ParamCheck . notNull ( listener , \"listener\" ) ; boolean result = false ; synchronized ( lock ) { if ( bound && ! aboutUnbound ) { result = true ; sessionStoreListeners . add ( listener ) ; } } return result ; } public boolean removeSessionStoreListener ( SessionStoreListener listener ) { ParamCheck . notNull ( listener , \"listener\" ) ; boolean result = false ; synchronized ( lock ) { if ( bound && ! aboutUnbound ) { result = true ; sessionStoreListeners . remove ( listener ) ; } } return result ; } public void valueBound ( HttpSessionBindingEvent event ) { synchronized ( lock ) { bound = true ; aboutUnbound = false ; } } public void valueUnbound ( HttpSessionBindingEvent event ) { if ( shutdownAdapter != null ) { shutdownAdapter . interceptShutdown ( ) ; } else { boolean fakeContext = false ; if ( ! ContextProvider . hasContext ( ) ) { fakeContext = true ; ServiceContext context = FakeContextUtil . createFakeContext ( this ) ; ContextProvider . setContext ( context ) ; } try { doValueUnbound ( ) ; } finally { if ( fakeContext ) { ContextProvider . releaseContextHolder ( ) ; } } } } Object getRequestLock ( ) { return requestLock ; } private void removeAttributeInternal ( String name ) { Object removed = attributes . remove ( name ) ; fireValueUnbound ( name , removed ) ; } private void doValueUnbound ( ) { Map < String , Object > attributesCopy ; synchronized ( lock ) { aboutUnbound = true ; attributesCopy = new HashMap < String , Object > ( attributes ) ; } fireBeforeDestroy ( ) ; Iterator iterator = attributesCopy . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Entry entry = ( Entry ) iterator . next ( ) ; fireValueUnbound ( ( String ) entry . getKey ( ) , entry . getValue ( ) ) ; } synchronized ( lock ) { attributes . clear ( ) ; sessionStoreListeners . clear ( ) ; bound = false ; aboutUnbound = false ; } } private void fireBeforeDestroy ( ) { SessionStoreListener [ ] listeners ; synchronized ( lock ) { int size = sessionStoreListeners . size ( ) ; listeners = sessionStoreListeners . toArray ( new SessionStoreListener [ size ] ) ; } SessionStoreEvent event = new SessionStoreEvent ( this ) ; for (", "gt": "int i = 0 ;", "prediction": ") ;\n", "label": 1}
{"id": 4038, "input": "<s> package org . ofbiz . base . util ; import java . math . BigDecimal ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public class UtilFormatOut { public static final String module = UtilFormatOut . class . getName ( ) ; public static String safeToString ( Object obj ) { if ( obj != null ) { return obj . toString ( ) ; } else { return \"\" ; } } static DecimalFormat priceDecimalFormat = new DecimalFormat ( UtilProperties . getPropertyValue ( \"general.properties\" , \"currency.decimal.format\" , \"#,##0.00\" ) ) ; public static String formatPrice ( Double price ) { if ( price == null ) return \"\" ; return formatPrice ( price . doubleValue ( ) ) ; } public static String formatPrice ( BigDecimal price ) { if ( price == null ) return \"\" ; return priceDecimalFormat . format ( price ) ; } public static String formatPrice ( double price ) { return priceDecimalFormat . format ( price ) ; } public static Double formatPriceNumber ( double price ) { try { return Double . valueOf ( priceDecimalFormat . parse ( formatPrice ( price ) ) . doubleValue ( ) ) ; } catch ( ParseException e ) { Debug . logError ( e , module ) ; return Double . valueOf ( price ) ; } } public static String formatCurrency ( double price , String isoCode , Locale locale , int maximumFractionDigits ) { com . ibm . icu . text . NumberFormat nf = com . ibm . icu . text . NumberFormat . getCurrencyInstance ( locale ) ; if ( isoCode != null && isoCode . length ( ) > 1 ) { nf . setCurrency ( com . ibm . icu . util . Currency . getInstance ( isoCode ) ) ; } else { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"No isoCode specified to format currency value:\" + price , module ) ; } if ( maximumFractionDigits >= 0 ) { nf . setMaximumFractionDigits ( maximumFractionDigits ) ; } return nf . format ( price ) ; } public static String formatCurrency ( BigDecimal price , String isoCode , Locale locale , int maximumFractionDigits ) { return formatCurrency ( price . doubleValue ( ) , isoCode , locale , maximumFractionDigits ) ; } public static String formatDecimalNumber ( double number , String pattern , Locale locale ) { com . ibm . icu . text . NumberFormat nf = com . ibm . icu . text . NumberFormat . getNumberInstance ( locale ) ; String nbParsing = \"\" ; ( ( com . ibm . icu . text . DecimalFormat ) nf ) . applyPattern ( pattern ) ; ( ( com . ibm . icu . text . DecimalFormat ) nf ) . toPattern ( ) ; nbParsing = nf . format ( number ) ; return nbParsing ; } public static String formatCurrency ( BigDecimal price , String isoCode , Locale locale ) { return formatCurrency ( price , isoCode , locale , - 1 ) ; } public static String formatSpelledOutAmount ( Double amount , Locale locale ) { return formatSpelledOutAmount ( amount . doubleValue ( ) , locale ) ; } public static String formatSpelledOutAmount ( double amount , Locale locale ) { com . ibm . icu . text . NumberFormat nf = new com . ibm . icu . text . RuleBasedNumberFormat ( locale , com . ibm . icu . text . RuleBasedNumberFormat . SPELLOUT ) ; return nf . format ( amount ) ; } public static String formatAmount ( double amount , Locale locale ) { com . ibm . icu . text . NumberFormat nf = com . ibm . icu . text . NumberFormat . getInstance ( locale ) ; nf . setMinimumFractionDigits ( 2 ) ; nf . setMaximumFractionDigits ( 2 ) ;", "gt": "return nf . format ( amount ) ;", "prediction": "}\n", "label": 0}
{"id": 7513, "input": "<s> package org . eclipse . ui . internal . dialogs ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . wizard . IWizardNode ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Table ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . model . AdaptableList ; import org . eclipse . ui . model . WorkbenchLabelProvider ; import org . eclipse . ui . model . WorkbenchViewerComparator ; public abstract class WorkbenchWizardListSelectionPage extends WorkbenchWizardSelectionPage implements ISelectionChangedListener , IDoubleClickListener { private static final String DIALOG_SETTING_SECTION_NAME = \"WizardListSelectionPage.\" ; private final static int SIZING_LISTS_HEIGHT = 200 ; private static final String STORE_SELECTED_WIZARD_ID = DIALOG_SETTING_SECTION_NAME + \"STORE_SELECTED_WIZARD_ID\" ; private TableViewer viewer ; private String message ; protected WorkbenchWizardListSelectionPage ( IWorkbench aWorkbench , IStructuredSelection currentSelection , AdaptableList wizardElements , String message , String triggerPointId ) { super ( \"singleWizardSelectionPage\" , aWorkbench , currentSelection , wizardElements , triggerPointId ) ; setDescription ( WorkbenchMessages . get ( ) . WizardList_description ) ; this . message = message ; } public void createControl ( Composite parent ) { Font font = parent . getFont ( ) ; Composite outerContainer = new Composite ( parent , SWT . NONE ) ; outerContainer . setLayout ( new GridLayout ( ) ) ; outerContainer . setLayoutData ( new GridData ( GridData . VERTICAL_ALIGN_FILL | GridData . HORIZONTAL_ALIGN_FILL ) ) ; outerContainer . setFont ( font ) ; Label messageLabel = new Label ( outerContainer , SWT . NONE ) ; messageLabel . setText ( message ) ; messageLabel . setFont ( font ) ; createViewer ( outerContainer ) ; layoutTopControl ( viewer . getControl ( ) ) ; restoreWidgetValues ( ) ; setControl ( outerContainer ) ; } private void createViewer ( Composite parent ) { Table table = new Table ( parent , SWT . BORDER ) ; table . setFont ( parent . getFont ( ) ) ; viewer = new TableViewer ( table ) ; viewer . setContentProvider ( new WizardContentProvider ( ) ) ; viewer . setLabelProvider ( new WorkbenchLabelProvider ( ) ) ; viewer . setComparator ( new WorkbenchViewerComparator ( ) ) ; viewer . addSelectionChangedListener ( this ) ; viewer . addDoubleClickListener ( this ) ; viewer . setInput ( wizardElements ) ; } protected abstract IWizardNode createWizardNode ( WorkbenchWizardElement element ) ; public void doubleClick ( DoubleClickEvent event ) { selectionChanged ( new SelectionChangedEvent ( event . getViewer ( ) , event . getViewer ( ) . getSelection ( ) ) ) ; getContainer ( ) . showPage ( getNextPage ( ) ) ; } private void layoutTopControl ( Control control ) { GridData data = new GridData ( GridData . FILL_BOTH ) ; int availableRows = DialogUtil . availableRows ( control . getParent ( ) ) ; if ( availableRows > 50 ) { data . heightHint = SIZING_LISTS_HEIGHT ; } else { data . heightHint = availableRows * 3 ; } control . setLayoutData ( data ) ; } private void restoreWidgetValues ( ) { IDialogSettings settings = getDialogSettings ( ) ; if ( settings == null ) { return ; } String wizardId = settings . get ( STORE_SELECTED_WIZARD_ID ) ; WorkbenchWizardElement wizard = findWizard ( wizardId ) ; if ( wizard == null ) { return ; } StructuredSelection selection =", "gt": "new StructuredSelection ( wizard ) ;", "prediction": ";\n", "label": 1}
{"id": 5479, "input": "<s> package com . gisgraphy . client . gisfeature ; import org . joda . time . DateTime ; import org . junit . Assert ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . franceGisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureObjectMother . rambouilletAdm4GisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureType . geonamesFeatureClass ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import org . junit . Test ; import com . gisgraphy . client . gisfeature . GeonamesGisFeature ; import com . gisgraphy . client . gisfeature . GisFeatureGeography ; import com . gisgraphy . client . gisfeature . GisFeatureNames ; public class GeonamesGisFeatureTest { @ Test public void shouldCreateFranceGisFeature ( ) { GeonamesGisFeature france = GisFeatureObjectMother . franceGisFeature ( ) ; assertEquals ( france . getGeonamesFeatureClass ( ) , \"A\" ) ; assertEquals ( france . getGeonamesFeatureCode ( ) , \"PCLI\" ) ; assertEquals ( france . getGeonamesId ( ) . longValue ( ) , 3017382L ) ; assertEquals ( france . getNames ( ) . getName ( ) , \"France\" ) ; assertNotNull ( france . getGeography ( ) ) ; assertEquals ( france . getGeography ( ) . getLocation ( ) . getCoordinate ( ) . x , 2.0 , 0.0001 ) ; assertEquals ( france . getGeography ( ) . getLocation ( ) . getCoordinate ( ) . y , 46.0 , 0.0001 ) ; assertNotNull ( france . getLastModificationDate ( ) ) ; } @ Test public void shouldCreateGisFeature ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithModificationDate ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . lastModificationDate ( new DateTime ( ) ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithNullParentEntity ( ) { GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) . lastModificationDate ( new DateTime ( ) ) . parentAdministrativeEntity ( null ) . build ( ) ; } @ Test public void shouldCreateGisFeatureWithNullModificationDate ( ) { final GeonamesGisFeature gisFeature = GeonamesGisFeature . gisFeature ( ) . geonamesId ( 1L ) . names ( GisFeatureNames . gisFeatureName ( \"France\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PLCI\" ) ) . geography ( GisFeatureGeography . gisFeatureGeography ( 2.0 , 46.0 ) ) .", "gt": "lastModificationDate ( null ) . build ( ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7523, "input": "<s> package org . restlet . test . resource ; import java . io . IOException ; import org . restlet . data . MediaType ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Finder ; import org . restlet . resource . ResourceException ; import org . restlet . test . RestletTestCase ; public class AnnotatedResource7TestCase extends RestletTestCase { private ClientResource clientResource ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Finder finder = new Finder ( ) ; finder . setTargetClass ( MyResource7 . class ) ; this . clientResource = new ClientResource ( \"http://local\" ) ; this . clientResource . setNext ( finder ) ; } @ Override protected void tearDown ( ) throws Exception { clientResource = null ; super . tearDown ( ) ; } public void testPost ( ) throws IOException , ResourceException { Representation input = new StringRepresentation ( \"[\\\"root\\\"]\" , MediaType . APPLICATION_JSON ) ; Representation result = clientResource . post ( input ) ; assertNotNull ( result ) ; assertEquals ( \"[\\\"root\\\"]1\" , result . getText ( ) ) ; assertEquals ( MediaType . APPLICATION_XML , result . getMediaType ( ) ) ; input = new StringRepresentation ( \"<root/>\" , MediaType . APPLICATION_XML ) ; result = clientResource . post ( input ) ; assertNotNull ( result ) ; assertEquals ( \"<root/>2\" , result . getText ( ) ) ; assertEquals ( MediaType . APPLICATION_XML ,", "gt": "result . getMediaType ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6925, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . util . EDataTypeEList ; import org . jjflyboy . tjpeditor . project . Formats ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . ReportFormat ; public class FormatsImpl extends ReportAttributeImpl implements Formats { protected EList < ReportFormat > formats ; protected FormatsImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getFormats ( ) ; } public EList < ReportFormat > getFormats ( ) { if ( formats == null ) { formats = new EDataTypeEList < ReportFormat > ( ReportFormat . class , this , ProjectPackage . FORMATS__FORMATS ) ; } return formats ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . FORMATS__FORMATS : return getFormats ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . FORMATS__FORMATS : getFormats ( ) . clear ( ) ; getFormats ( ) . addAll ( ( Collection < ? extends ReportFormat > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . FORMATS__FORMATS : getFormats ( ) . clear ( ) ; return ; }", "gt": "super . eUnset ( featureID ) ;", "prediction": "}\n", "label": 0}
{"id": 7525, "input": "<s> package org . eclipse . ui . tests . session ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . views . properties . PropertySheet ; public class NonRestorablePropertySheetTest extends TestCase { public static TestSuite suite ( ) { return new TestSuite ( NonRestorablePropertySheetTest . class ) ; } public NonRestorablePropertySheetTest ( String testName ) { super ( testName ) ; } public void test01ActivateView ( ) throws PartInitException { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchPage page = workbench . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; IViewPart part = page . showView ( IPageLayout . ID_PROP_SHEET ) ; assertNotNull ( part ) ; assertTrue ( part instanceof PropertySheet ) ; for ( int j = 0 ; j < 3 ; j ++ ) { try { page . showView ( IPageLayout . ID_PROP_SHEET , \"#\" + j , IWorkbenchPage . VIEW_ACTIVATE ) ; } catch ( PartInitException e ) { fail ( e . getMessage ( ) ) ; } } assertTrue ( countPropertySheetViews ( page ) == 4 ) ; } public void test02SecondOpening ( ) throws PartInitException { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchPage page = workbench . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; assertTrue ( countPropertySheetViews ( page ) == 1 ) ; } private int countPropertySheetViews ( final IWorkbenchPage page ) { int count = 0 ; IViewReference [ ] views = page . getViewReferences ( ) ; for ( int i = 0 ; i < views . length ; i ++ ) { IViewReference ref = views [ i ] ; if ( ref . getId ( )", "gt": ". equals ( IPageLayout . ID_PROP_SHEET ) )", "prediction": ";\n", "label": 1}
{"id": 6388, "input": "<s> package org . bombusim . xmpp ; import java . io . IOException ; import org . bombusim . xmpp . exception . XmppAuthException ; import org . bombusim . xmpp . exception . XmppException ; public class AuthFallback extends XmppObjectListener { @ Override public int blockArrived ( XmppObject data , XmppStream stream ) throws IOException , XmppException { throw new XmppAuthException ( \"No known authentication methods found\" ) ; } @ Override", "gt": "public int priority ( )", "prediction": "}\n", "label": 0}
{"id": 7539, "input": "<s> package risk ; import java . io . FileWriter ; import java . io . IOException ; public class DataWriter { FileWriter territoriesWriter ; FileWriter influenceWriter ; FileWriter wealthWriter ; public String territoriesFile = \"./outputFiles/outputTerritories.csv\" ; public String influenceFile = \"./outputFiles/outputInfluence.csv\" ; public String wealthFile = \"./outputFiles/outputWealth.csv\" ; public DataWriter ( String [ ] names ) { setTitles ( names ) ; } public void setTitles ( String [ ] names ) { try { territoriesWriter = new FileWriter ( territoriesFile ) ; influenceWriter = new FileWriter ( influenceFile ) ; wealthWriter = new FileWriter ( wealthFile ) ; for ( int i = 0 ; i < names . length ; i ++ ) { territoriesWriter . append ( names [ i ] ) ; territoriesWriter . append ( ',' ) ; influenceWriter . append ( names [ i ] ) ; influenceWriter . append ( ',' ) ; wealthWriter . append ( names [ i ] ) ; wealthWriter . append ( ',' ) ; } territoriesWriter . append ( '\\n' ) ; territoriesWriter . flush ( ) ; influenceWriter . append ( '\\n' ) ; influenceWriter . flush ( ) ; wealthWriter . append ( '\\n' ) ; wealthWriter . flush ( ) ; } catch ( IOException e ) { } } public void writeTerritories ( double [ ] records ) { try { for ( int i = 0 ; i < records . length ; i ++ ) { String record = Double . toString ( records [ i ] ) ; territoriesWriter . append ( record ) ; territoriesWriter . append ( ',' ) ; } territoriesWriter . append ( '\\n' ) ; territoriesWriter . flush ( ) ; } catch ( IOException e ) { } } public void writeInfluence ( double [ ] records ) { try { for ( int i = 0 ;", "gt": "i < records . length ;", "prediction": "}\n", "label": 1}
{"id": 10001, "input": "<s> package next . interfaces . controller . widgets ; import next . i . mobile . SelectionChangedEvent ; import next . i . mobile . SelectionChangedHandler ; import next . i . view . widgets . XFlexTable ; import next . i . view . widgets . XLabel ; import next . i . view . widgets . XRadioButton ; import next . i . view . widgets . XRadioButtonGroup ; import next . i . view . widgets . XLabel . XLabelType ; import next . interfaces . controller . GitXController ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; public class RadioButtonController extends GitXController { public RadioButtonController ( ) { setTitle ( \"Radio Button\" ) ; } @ Override public IsWidget getViewContent ( ) { XFlexTable panel = new XFlexTable ( ) ; panel . setCellSpacing ( 20 ) ; XRadioButton radio0 = new XRadioButton ( \"Red\" , \"Red\" ) ; XRadioButton radio1 = new XRadioButton ( \"Green\" , \"Green\" ) ; XRadioButton radio2 = new XRadioButton ( \"Blue\" , \"Blue\" ) ; final XRadioButtonGroup group1 = new XRadioButtonGroup ( true ) ; group1 . add ( radio0 , radio1 , radio2 ) ; XRadioButton radioA = new XRadioButton ( \"Red\" , \"Red\" ) ; XRadioButton radioB = new XRadioButton ( \"Green\" , \"Green\" ) ; XRadioButton radioC = new XRadioButton ( \"Blue\" , \"Blue\" ) ; final XRadioButtonGroup group2 = new XRadioButtonGroup ( false ) ; group2 . add ( radioA , radioB , radioC ) ; final XLabel label1 = new XLabel ( \"Favorite color\" , XLabelType . Header ) ; final XLabel label2 = new XLabel ( \"Favorite color\" , XLabelType . Header ) ; radio0 . setValue ( true ) ; radioA . setValue ( true ) ; group1 . addSelectionChangedHandler ( new SelectionChangedHandler ( ) { public void onSelectionChanged ( SelectionChangedEvent e ) { label1 . setText ( \"Favorite color: \" + group1 . getCheckedWidget ( ) . getName ( ) ) ; } } ) ; group2 . addSelectionChangedHandler ( new SelectionChangedHandler ( ) { public", "gt": "void onSelectionChanged ( SelectionChangedEvent e )", "prediction": "( )\n", "label": 0}
{"id": 7541, "input": "<s> package org . eclipse . ui . wizards ; import org . eclipse . core . runtime . IPath ; public interface IWizardCategory { IWizardCategory findCategory ( IPath path ) ; IWizardDescriptor findWizard ( String id ) ; IWizardCategory [ ] getCategories ( ) ; String getId ( ) ; String getLabel ( ) ; IWizardCategory getParent ( ) ;", "gt": "IPath getPath ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7570, "input": "<s> package com . sun . mirror . declaration ; import com . sun . mirror . type . TypeMirror ; @ Deprecated @ SuppressWarnings (", "gt": "\"deprecation\" ) public interface FieldDeclaration extends MemberDeclaration", "prediction": ") ;\n", "label": 0}
{"id": 7542, "input": "<s> package org . powerbot . game . api . methods ; import java . awt . Point ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . input . Mouse ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Timer ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . ViewportEntity ; import org . powerbot . game . api . wrappers . map . LocalPath ; import org . powerbot . game . api . wrappers . map . TilePath ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSGroundData ; import org . powerbot . game . client . RSInfo ; public class Walking { private static final int WIDGET = 750 ; private static final int WIDGET_RUN = 2 ; private static final int WIDGET_RUN_ENERGY = 6 ; public static Tile getDestination ( ) { final Client client = Context . client ( ) ; final Multipliers multipliers = Context . multipliers ( ) ; final int lx = ( client . getDestX ( ) * multipliers . GLOBAL_DESTX ) / 4 ; final int ly = ( client . getDestY ( ) * multipliers . GLOBAL_DESTY ) / 4 ; if ( lx == - 1 || ly == - 1 ) { return new Tile ( - 1 , - 1 , - 1 ) ; } return new Tile ( Game . getBaseX ( ) + lx , Game . getBaseY ( ) + ly , Game . getPlane ( ) ) ; } public static Tile getCollisionOffset ( final int plane ) { final Multipliers multipliers = Context . multipliers ( ) ; final RSInfo info = ( RSInfo ) Context . client ( ) . getRSGroundInfo ( ) ; final RSGroundData data = ( ( RSGroundData [ ] ) info . getGroundData ( ) ) [ plane ] ; return new Tile ( data . getX ( ) * multipliers . GROUNDDATA_X , data . getY ( ) * multipliers . GROUNDDATA_Y , plane ) ; } public static int [ ] [ ] getCollisionFlags ( final int plane ) { final RSInfo info = ( RSInfo ) Context . client ( ) . getRSGroundInfo ( ) ; final RSGroundData data = ( ( RSGroundData [ ] ) info . getGroundData ( ) ) [ plane ] ; return ( int [ ] [ ] ) data . getBlocks ( ) ; } public static void setRun ( final boolean enabled ) { if ( isRunEnabled ( ) != enabled && Widgets . get ( WIDGET , WIDGET_RUN ) . click ( true ) ) { final Timer t = new Timer ( 1800 ) ; while ( t . isRunning ( ) && isRunEnabled ( ) != enabled ) { Task . sleep ( 5 ) ; } } }", "gt": "public static boolean isRunEnabled ( )", "prediction": "}\n", "label": 1}
{"id": 4759, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . plaf . metal . * ; import java . awt . * ; import java . util . HashMap ; public class PlafOptions { private static boolean vistaStyle ; private PlafOptions ( ) { } public static void setAsLookAndFeel ( ) { try { Class . forName ( \"com.jidesoft.utils.Lm\" ) ; enableJideFastGradient ( ) ; } catch ( ClassNotFoundException e ) { } PgsLookAndFeel . setAsLookAndFeel ( ) ; } public static void setCurrentTheme ( MetalTheme t ) { PgsLookAndFeel . setCurrentTheme ( t ) ; } public static void updateAllUIs ( ) { PgsLookAndFeel . updateAllUIs ( ) ; } private static Dimension defIconSize = new Dimension ( 10 , 10 ) ; public static void setDefaultMenuItemIconSize ( Dimension dim ) { defIconSize = dim ; } public static Dimension getDefaultMenuItemIconSize ( ) { return defIconSize ; } private static boolean useExtraMargin = true ; public static boolean useExtraMargin ( ) { return useExtraMargin ; } public static void useExtraMargin ( boolean use ) { useExtraMargin = use ; } private static boolean useBoldFonts = false ; private static boolean useBoldMenuFonts = false ; public static boolean useBoldFonts ( ) { return useBoldFonts ; } public static void useBoldFonts ( boolean use ) { useBoldFonts = use ; UIManager . put ( \"swing.boldMetal\" , Boolean . valueOf ( use ) ) ; } public static boolean useBoldMenuFonts ( ) { return useBoldMenuFonts ; } public static void useBoldMenuFonts ( boolean use ) { useBoldMenuFonts = use ; } private static boolean useShadowBorder = false ; public static void useShadowBorder ( boolean use ) { useShadowBorder = use ; } public static boolean isShadowBorderUsed ( ) { return useShadowBorder ; } private static boolean useToolBarIcon = true ; public static void useToolBarIcon ( boolean use ) { useToolBarIcon = use ; } public static boolean isToolBarIconUsed ( ) { return useToolBarIcon ; } private static boolean useDisabledIcon = true ; public static void useDisabledIcon ( boolean use ) { useDisabledIcon = use ; } public static boolean isDisabledIconUsed ( ) { return useDisabledIcon ; } private static boolean aaText = false ; public static void setAntialiasingEnabled ( boolean use ) { aaText = use ; } public static boolean isAntialiasingEnabled ( ) { return aaText ; } private static boolean isClearBorderEnabled = false ; public static void setClearBorderEnabled ( boolean enabled ) { PgsUtils . regenerateBorderStroke ( ) ; isClearBorderEnabled = enabled ; } public static boolean isClearBorderEnabled ( ) { return isClearBorderEnabled ; } private static boolean fixHtmlDisplay = false ; public static boolean isHtmlDisplayFixEnabled ( ) { return fixHtmlDisplay ; } public static void setFixHtmlDisplayEnabled ( boolean aFixHtmlDisplayEnabled ) { fixHtmlDisplay = aFixHtmlDisplayEnabled ; } private static boolean wheelTabbedPaneEnabled = false ; public static boolean isWheelTabbedPaneEnabled ( ) { return wheelTabbedPaneEnabled ; } public static void setWheelTabbedPaneEnabled ( boolean enabled ) { wheelTabbedPaneEnabled = enabled ; } private static boolean tabbedPaneRightClickSelectionEnabled = false ; public static boolean isTabbedPaneRightClickSelectionEnabled ( ) { return tabbedPaneRightClickSelectionEnabled ; } public static void setTabbedPaneRightClickSelectionEnabled ( boolean enabled ) { tabbedPaneRightClickSelectionEnabled = enabled ; } private", "gt": "static boolean tabReorderingEnabled = false ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7551, "input": "<s> package org . apache . lucene . analysis . cn . smart ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . analysis . cn . smart . hhmm . HHMMSegmenter ; import org . apache . lucene . analysis . cn . smart . hhmm . SegToken ; import org . apache . lucene . analysis . cn . smart . hhmm . SegTokenFilter ; class WordSegmenter { private HHMMSegmenter hhmmSegmenter = new HHMMSegmenter ( ) ; private SegTokenFilter tokenFilter = new SegTokenFilter ( ) ; public List segmentSentence ( String sentence , int startOffset ) { List segTokenList = hhmmSegmenter . process ( sentence ) ; List result = new ArrayList ( ) ; for ( int i = 1 ; i < segTokenList . size ( ) - 1 ; i ++ ) { result . add ( convertSegToken ( ( SegToken ) segTokenList . get ( i ) , sentence , startOffset ) ) ; } return result ; } public SegToken convertSegToken (", "gt": "SegToken st , String sentence , int sentenceStartOffset )", "prediction": ")\n", "label": 1}
{"id": 4278, "input": "<s> import java . util . * ; import java . io . * ; import java . text . * ; class Main { void start ( ) throws Exception { System . out . println ( readLine ( 110 ) ) ; int teamsCount = Integer . parseInt ( readLine ( 5 ) ) ; ArrayList teams = new ArrayList ( teamsCount + 1 ) ; Hashtable teamsTable = new Hashtable ( ) ; while ( teamsCount -- != 0 ) { Team t = new Team ( ) ; t . name = readLine ( 100 ) ; teams . add ( t ) ; teamsTable . put ( t . name , t ) ; } int gamesCount = Integer . parseInt ( readLine ( 5 ) ) ; while ( gamesCount -- != 0 ) { String line = readLine ( 100 ) ; int arroba = line . indexOf ( '@' ) ; Team t1 = ( Team ) teamsTable . get ( line . substring ( 0 , line . indexOf ( '#' ) ) ) ; int goals1 = Integer . parseInt ( line . substring ( line . indexOf ( '#' ) + 1 , arroba ) ) ; t1 . goals += goals1 ; line = line . substring ( arroba ) ; Team t2 = ( Team ) teamsTable . get ( line . substring ( line . indexOf ( '#' ) + 1 ) ) ; int goals2 = Integer . parseInt ( line . substring ( 1 , line . indexOf ( '#' ) ) ) ; t2 . goals += goals2 ; t1 . against += goals2 ; t2 . against += goals1 ; t1 . games ++ ; t2 . games ++ ; if ( goals1 > goals2 ) { t1 . won ++ ; t2 . lost ++ ; t1 . points += 3 ; } else if ( goals1 < goals2 ) { t2 . won ++ ; t1 . lost ++ ; t2 . points += 3 ; } else { t1 . draw ++ ; t2 . draw ++ ; t1 . points += 1 ; t2 . points += 1 ; } } TreeSet h = new TreeSet ( new CompareTeams ( ) ) ; h . addAll ( teams ) ; int i = 1 ; for ( Iterator it = h . iterator ( ) ; it . hasNext ( ) ; i ++ ) { Team t = ( Team ) it . next ( ) ; System . out . println ( i + \") \" + t . name + \" \" + t . points + \"p, \" + t . games + \"g (\" + t . won + \"-\" + t . draw + \"-\" + t . lost + \"), \" + ( t . goals - t . against ) + \"gd (\" + t . goals + \"-\" + t . against + \")\" ) ; } } public static void main ( String args [ ] ) throws Exception { try { int caseCount = Integer . parseInt ( readLine ( 5 ) ) ; int i = 0 ; while ( caseCount -- != 0 ) { if ( i ++ != 0 ) System . out . println ( ) ; new Main ( ) . start ( ) ; } } catch ( Exception ex ) { while ( true ) { } } } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( int maxLg ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; } lin [ lg ++ ] += car ; } if ( ( car < 0 ) && ( lg == 0 ) ) { return ( null ) ; } return ( new String ( lin , 0 , lg ) ) ; } } class Team { String name ; int won = 0 ; int lost = 0 ; int draw = 0 ; int games = 0 ; int goals = 0 ; int against = 0 ; int points = 0 ; } class CompareTeams implements Comparator { public int compare ( Object o1 , Object o2 ) { Team t1 = ( Team ) o1 ; Team t2 = ( Team ) o2 ; if ( t1 . points != t2 . points ) { return t1 . points < t2 . points ? 1 : - 1 ; } if ( t1 . won != t2 . won ) { return t1 . won <", "gt": "t2 . won ? 1 : - 1 ;", "prediction": ";\n", "label": 0}
{"id": 7558, "input": "<s> package org . apache . sqoop ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Constructor ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . util . ReflectionUtils ; import org . apache . hadoop . util . StringUtils ; import com . cloudera . sqoop . manager . ConnManager ; import com . cloudera . sqoop . manager . DefaultManagerFactory ; import com . cloudera . sqoop . manager . ManagerFactory ; import com . cloudera . sqoop . metastore . JobData ; import com . cloudera . sqoop . util . ClassLoaderStack ; import org . apache . sqoop . manager . GenericJdbcManager ; public class ConnFactory { public static final Log LOG = LogFactory . getLog ( ConnFactory . class . getName ( ) ) ; public ConnFactory ( Configuration conf ) { factories = new LinkedList < ManagerFactory > ( ) ; instantiateFactories ( conf ) ; } public static final String FACTORY_CLASS_NAMES_KEY = \"sqoop.connection.factories\" ; public static final String DEFAULT_FACTORY_CLASS_NAMES = DefaultManagerFactory . class . getName ( ) ; private List < ManagerFactory > factories ; private void instantiateFactories ( Configuration conf ) { loadManagersFromConfDir ( conf ) ; String [ ] classNameArray = conf . getStrings ( FACTORY_CLASS_NAMES_KEY , DEFAULT_FACTORY_CLASS_NAMES ) ; for ( String className : classNameArray ) { try { className = className . trim ( ) ; ManagerFactory factory = ReflectionUtils . newInstance ( ( Class < ? extends ManagerFactory > ) conf . getClassByName ( className ) , conf ) ; LOG . debug ( \"Loaded manager factory: \" + className ) ; factories . add ( factory ) ; } catch ( ClassNotFoundException cnfe ) { LOG . error ( \"Could not load ManagerFactory \" + className + \" (not found)\" ) ; } } } public ConnManager getManager ( JobData data ) throws IOException { com . cloudera . sqoop . SqoopOptions options = data . getSqoopOptions ( ) ; String manualDriver = options . getDriverClassName ( ) ; String managerClassName = options . getConnManagerClassName ( ) ; if ( manualDriver != null && managerClassName == null ) { LOG . warn ( \"Parameter --driver is set to an explicit driver however\" + \" appropriate connection manager is not being set (via\" + \" --connection-manager). Sqoop is going to fall back to \" + GenericJdbcManager . class . getCanonicalName ( ) + \". Please specify\" + \" explicitly which connection manager should be used next time.\" ) ; return new GenericJdbcManager ( manualDriver , options ) ; } if ( managerClassName != null ) { ConnManager connManager = null ; try { Class < ConnManager > cls = ( Class < ConnManager > ) Class . forName ( managerClassName ) ; if ( manualDriver == null ) { Constructor < ConnManager > constructor = cls . getDeclaredConstructor ( com . cloudera . sqoop . SqoopOptions . class ) ; connManager = constructor . newInstance ( options ) ; } else { Constructor < ConnManager > constructor = cls . getDeclaredConstructor ( String . class , com . cloudera . sqoop . SqoopOptions . class ) ; connManager = constructor . newInstance ( manualDriver , options ) ; } } catch ( ClassNotFoundException e ) { LOG . error ( \"Sqoop could not found specified connection manager class \" + managerClassName + \". Please check that you've specified the \" + \"class correctly.\" ) ; throw new IOException ( e ) ; } catch ( NoSuchMethodException e ) { LOG . error ( \"Sqoop wasn't able to create connnection manager properly. \" + \"Some of the connectors supports explicit --driver and some \" + \"do not. Please try to either specify", "gt": "--driver or leave it out.\" ) ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 401, "input": "<s> import java . io . * ; import java . net . URI ; import javax . tools . * ; public class T6501502 { public static void main ( String ... args ) throws Exception { new T6501502 ( ) . run ( ) ; } void run ( ) throws Exception { JavaCompiler c = ToolProvider . getSystemJavaCompiler ( ) ; fm = c . getStandardFileManager ( null , null , null ) ; System . err . println ( System . getProperties ( ) ) ; File tmpDir = new File ( System . getProperty ( \"java.io.tmpdir\" ) ) ; File testSrcDir = new File ( System . getProperty ( \"test.src\" ) ) ; File testClassesDir = new File ( System . getProperty ( \"test.classes\" ) ) ; test ( new File ( \"abc.tmp\" ) ) ; test ( new File ( tmpDir , \"bad.file\" ) ) ; test ( new File ( testSrcDir , \"T6501501.java\" ) ) ; test ( new File ( testClassesDir , \"T6501501.class\" ) ) ; test ( new File ( \"a b\" ) ) ; } void test ( File f ) throws Exception { System . err . println ( \"test \" + f ) ; FileObject fo = fm . getJavaFileObjects ( f ) . iterator ( ) . next ( ) ; URI uri = fo . toUri ( ) ; System . err .", "gt": "println ( \"FileObject uri: \" + uri ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7587, "input": "<s> package org . agoncal . book . javaee7 . chapter19 . ex03 ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import java . io . File ; import java . io . StringWriter ; import java . nio . file . Paths ; public class XsltTransforming { public static void main ( String [ ] args ) { String order = new XsltTransforming ( ) . transformOrder ( ) ; System . out . println ( order ) ; } public String transformOrder ( ) {", "gt": "StringWriter writer = new StringWriter ( ) ;", "prediction": "\n", "label": 1}
{"id": 4922, "input": "<s> package org . parboiled . parserunners ; import org . parboiled . BaseParser ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class SimpleErrorRecoveryTest extends TestNgParboiledTest < Object > { @ BuildParseTree public static class Parser extends BaseParser < Object > { Rule Clause ( ) { return Sequence ( Subject ( ) , Verb ( ) , Object ( ) , EOI ) ; } Rule Subject ( ) { return Sequence ( Name ( ) , ZeroOrMore ( FirstOf ( \" and \" , \" or \" ) , Name ( ) ) ) ; } Rule Name ( ) { return FirstOf ( \"Alice\" , \"Bob\" , \"Charlie\" , \"Doreen\" , \"Emilio\" , \"Ferdinand\" ) ; } Rule Verb ( ) { return FirstOf ( \" has \" , \" have \" , \" digs \" , \" dig \" , \" loves \" , \" love \" , \" hates \" ) ; } Rule Object ( ) { return FirstOf ( \"cats\" , \"dogs\" , \"animals\" , \"cars\" , \"building\" ) ; } } @ Test public void testRecovery ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; testWithRecovery ( parser . Clause ( ) , \"AaA\" ) . hasErrors ( \"\" + \"Invalid input 'a...', expected 'l' (line 1, pos 2):\\n\" + \"AaA\\n\" + \" ^^\\n\" + \"---\\n\" + \"Invalid input 'EOI', expected \\\" and \\\", \\\" or \\\" or Verb (line 1, pos 4):\\n\" + \"AaA\\n\" + \"   ^\\n\" ) ; testWithRecovery ( parser . Clause ( ) , \"Alice has anximals\" ) . hasErrors ( \"\" + \"Invalid input 'x', expected 'i' (line 1, pos 13):\\n\" + \"Alice has anximals\\n\" + \"            ^\\n\" ) . hasParseTree ( \"\" + \"[Clause]E 'Alice has animals'\\n\" + \"  [Subject] 'Alice'\\n\" + \"    [Name] 'Alice'\\n\" + \"      [\\\"Alice\\\"] 'Alice'\\n\" + \"    [ZeroOrMore]\\n\" + \"  [Verb] ' has '\\n\" + \"    [\\\" has \\\"] ' has '\\n\" + \"  [Object]E 'animals'\\n\" + \"    [\\\"animals\\\"]E 'animals'\\n\" + \"  [EOI]\\n\" ) ; testWithRecovery ( parser . Clause ( ) . suppressSubnodes ( ) , \"Alice has anximals\" ) . hasErrors ( \"\" + \"Invalid input 'x', expected 'i' (line 1, pos 13):\\n\" + \"Alice has anximals\\n\" + \"            ^\\n\" ) . hasParseTree ( \"[Clause]E 'Alice has animals'\\n\" ) ; testWithRecovery ( parser . Clause ( ) , \"Alice has anmals\" ) . hasErrors ( \"\" + \"Invalid input 'm', expected 'i' (line 1, pos 13):\\n\" + \"Alice has anmals\\n\" + \"            ^\\n\" ) . hasParseTree ( \"\" + \"[Clause]E 'Alice has animals'\\n\" + \"  [Subject] 'Alice'\\n\" + \"    [Name] 'Alice'\\n\" + \"      [\\\"Alice\\\"] 'Alice'\\n\" + \"    [ZeroOrMore]\\n\" + \"  [Verb] ' has '\\n\" + \"    [\\\" has \\\"] ' has '\\n\" + \"  [Object]E 'animals'\\n\" + \"  ", "gt": " [\\\"animals\\\"]E 'animals'\\n\" + \"  [EOI]\\n\" ) ;", "prediction": "\" ;\n", "label": 0}
{"id": 7595, "input": "<s> package io . beancounter . queues ; public interface Queues { public void push ( String json ) throws QueuesException ; public void push ( String json , String queueName ) throws QueuesException ; public", "gt": "void shutDown ( ) throws QueuesException ;", "prediction": "\n", "label": 1}
{"id": 8360, "input": "<s> package com . redhat . ceylon . compiler . java . test . issues ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import org . junit . Test ; import com . redhat . ceylon . compiler . java . test . CompilerTest ; public class PackageIssuesTest extends CompilerTest { private String testDir ; @ Override protected String getSourcePath ( ) { return super . getPackagePath ( ) + testDir + File . separator ; } @ Override protected String getPackagePath ( ) { return super . getPackagePath ( ) + testDir + File . separator ; } @ Override", "gt": "protected String transformDestDir ( String name )", "prediction": "}\n", "label": 0}
{"id": 7606, "input": "<s> package org . eclipse . ui . tests . session ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart3 ; import org . eclipse . ui . PlatformUI ; public class ArbitraryPropertiesViewTest extends TestCase { private static final String USER_PROP = \"org.eclipse.ui.tests.users\" ; private static final String PROBLEM_VIEW_ID = \"org.eclipse.ui.views.ProblemView\" ; private static final String VIEW_WITH_STATE_ID = \"org.eclipse.ui.tests.session.ViewWithState\" ; public static TestSuite suite ( ) { return new TestSuite ( ArbitraryPropertiesViewTest . class ) ; } public ArbitraryPropertiesViewTest ( String testName ) { super ( testName ) ; } public void test01ActivateView ( ) throws Throwable { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchPage page = workbench . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; IViewPart v = page . showView ( VIEW_WITH_STATE_ID ) ; page . showView ( PROBLEM_VIEW_ID ) ; IWorkbenchPart3 wp = ( IWorkbenchPart3 ) v ; wp . setPartProperty ( USER_PROP , \"pwebster\" ) ; } public void test02SecondOpening ( ) throws Throwable { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchPage page = workbench . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; IViewReference [ ] views = page . getViewReferences ( ) ; for ( int i = 0 ; i < views . length ; i ++ ) { IViewReference ref = views [ i ] ; if ( ref . getId ( ) . equals ( VIEW_WITH_STATE_ID ) ) { assertNull ( \"The view should not be instantiated\" , ref . getPart ( false ) ) ; assertEquals ( \"pwebster\" , ref . getPartProperty ( USER_PROP ) ) ; } } } static class PropListener implements IPropertyChangeListener { public int count = 0 ; public void propertyChange ( PropertyChangeEvent event ) { count ++ ; } } ; public void test03PartInstantiation ( ) throws Throwable { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchPage page = workbench . getActiveWorkbenchWindow (", "gt": ") . getActivePage ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5456, "input": "<s> package org . hackreduce . examples . flights ; import java . io . IOException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . util . ToolRunner ; import org . hackreduce . mappers . FlightMapper ; import org . hackreduce . mappers . ModelMapper ; import org . hackreduce . models . FlightRecord ; public class RecordCounter extends org . hackreduce . examples . RecordCounter { public enum Count { TOTAL_RECORDS } public static class RecordCounterMapper extends FlightMapper < Text , LongWritable > { public static final Text TOTAL_COUNT = new Text ( \"total\" ) ; public static final LongWritable ONE_COUNT = new LongWritable ( 1 ) ; @ Override protected void map ( FlightRecord record , Context context ) throws IOException , InterruptedException { context . getCounter ( Count . TOTAL_RECORDS ) . increment ( 1 ) ; context .", "gt": "write ( TOTAL_COUNT , ONE_COUNT ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7617, "input": "<s> package com . rabbitmq . messagepatterns . unicast ; public interface Messaging extends Sender , Receiver { public void addSenderSetupListener ( ChannelSetupListener channelSetup ) ; public void removeSenderSetupListener ( ChannelSetupListener channelSetup ) ; public void addReceiverSetupListener", "gt": "( ChannelSetupListener channelSetup ) ;", "prediction": "( )\n", "label": 1}
{"id": 1140, "input": "<s> package Liza ; import org . bukkit . entity . ComplexEntityPart ;", "gt": "public interface LizaComplexEntityPart extends ComplexEntityPart", "prediction": "}\n", "label": 0}
{"id": 7620, "input": "<s> package org . eclipse . swt . accessibility ; import org . eclipse . swt . internal . SWTEventListener ; public interface AccessibleHyperlinkListener extends SWTEventListener { public void getAnchor", "gt": "( AccessibleHyperlinkEvent e ) ;", "prediction": "( )\n", "label": 1}
{"id": 8297, "input": "<s> package org . papaours . yama . model ; import javax . xml . bind . annotation . XmlElement ; public class YamaNumericalQuestionUnit { private int multiplier ; private String unitName ; public YamaNumericalQuestionUnit ( ) { } public YamaNumericalQuestionUnit ( final int theMultiplier , final String theUnitName ) { this . multiplier = theMultiplier ; this . unitName = theUnitName ; } @ XmlElement ( name = \"multiplier\" ) public int getMultiplier ( ) { return multiplier ; } public void setMultiplier ( final int theMultiplier ) { this . multiplier = theMultiplier ; } @", "gt": "XmlElement ( name = \"unit_name\" ) public String getUnitName ( )", "prediction": "}\n", "label": 0}
{"id": 7638, "input": "<s> package org . jscsi . parser . reject ; import static org . testng . AssertJUnit . assertEquals ; import static org . testng . AssertJUnit . assertTrue ; import org . testng . annotations . Test ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . security . DigestException ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnitTest ; import org . jscsi . parser . reject . RejectParser . ReasonCode ; import org . jscsi . utils . WiresharkMessageParser ; public class RejectParserTest extends ProtocolDataUnitTest { private static final String TEST_CASE_1 = \"3f 80 04 00 00 00 00 30 00 00 00 00 00 00 00 00 \" + \"ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 00 \" + \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \" + \"c3 00 02 02 00 00 00 95 00 00 00 00 ab cd 00 00 \" + \"a8 97 69 81 00 00 00 00 00 00 01 5d 00 00 00 00 \" + \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\" ; @ Test public void testDeserialize1 ( ) throws IOException , InternetSCSIException , DigestException { super . setUp ( TEST_CASE_1 ) ; super . testDeserialize ( false , true , OperationCode . REJECT , 0x00000000 , 0x00000030 , 0xFFFFFFFF ) ; assertTrue ( recognizedParser instanceof RejectParser ) ; RejectParser parser = ( RejectParser ) recognizedParser ; assertEquals ( ReasonCode . PROTOCOL_ERROR , parser . getReasonCode ( ) ) ; assertEquals ( 0x00000000 , parser . getStatusSequenceNumber ( ) ) ; assertEquals ( 0x00000000 , parser . getExpectedCommandSequenceNumber ( ) ) ; assertEquals ( 0x00000000 , parser . getMaximumCommandSequenceNumber ( ) ) ; assertEquals ( 0x00000000 , parser . getDataSequenceNumber ( ) ) ; } @ Test public void testSerialize1 ( ) throws InternetSCSIException , IOException , DigestException { super . setUp ( TEST_CASE_1 ) ; ByteBuffer expectedResult = WiresharkMessageParser . parseToByteBuffer ( TEST_CASE_1 ) ; assertTrue ( expectedResult . equals", "gt": "( protocolDataUnit . serialize ( ) ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6093, "input": "<s> import java . io . File ; import java . util . Arrays ; import javax . tools . * ; import javax . tools . JavaFileManager . Location ; import static javax . tools . StandardLocation . CLASS_OUTPUT ; public class T6397104 { JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; void test ( StandardJavaFileManager fm , Location location , File siblingFile , String relName , String expectedPath ) throws Exception { JavaFileObject sibling = siblingFile == null ? null : fm . getJavaFileObjectsFromFiles ( Arrays . asList ( siblingFile ) ) . iterator ( ) . next ( ) ; FileObject fileObject = fm . getFileForOutput ( location , \"java.lang\" , relName , sibling ) ; if ( ! fileObject . toUri ( ) . getPath ( ) . equals ( expectedPath ) ) throw new AssertionError ( \"Expected \" + expectedPath + \", got \" + fileObject . toUri ( ) . getPath ( ) ) ; System . out . format ( \"OK: (%s, %s) => %s%n\" , siblingFile , relName , fileObject . toUri ( ) ) ; } void test ( boolean hasLocation , File siblingFile , String relName , String expectedPath ) throws Exception { StandardJavaFileManager fm ; if ( hasLocation ) { for ( Location location : StandardLocation", "gt": ". values ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 7647, "input": "<s> package com . petpet . sc . listeners ; import android . view . View ; import android . view . ViewGroup . OnHierarchyChangeListener ; import android . widget . Button ; import com . petpet . sc . widget . SegmentedControl ; public class SCHierarchyChangeListener implements OnHierarchyChangeListener { private SegmentedControl sc ; private SCTouchListener stateListener ; public SCHierarchyChangeListener ( final SegmentedControl sc ) { this . sc = sc ; this . stateListener = new SCTouchListener ( this . sc ) ; } @ Override public void onChildViewAdded ( View parent , View child ) { this . register ( parent , child , true ) ; } @ Override public void onChildViewRemoved ( View parent , View child ) { this . register ( parent , child , false ) ; } private void register ( View parent , View child , boolean register ) { if ( parent . getId ( ) == this . sc . getId ( ) && child instanceof Button ) { final Button btn = ( Button ) child ; if ( register ) btn . setOnTouchListener ( stateListener ) ; else btn . setOnTouchListener ( null ) ; addBtnState ( ) ; trimText ( btn ) ; this . sc . stateChanged ( null ) ; } } private void trimText ( Button btn ) { String label = btn . getText ( ) . toString ( ) ; int maxLength = this . sc . getMaxLength ( ) ; if ( label . length ( ) > maxLength ) { label = label . substring ( 0 , maxLength - 3 ) ; label += \"...\" ; btn . setText ( label ) ; } } private void addBtnState ( ) { int count = this . sc . getChildCount ( ) ; if", "gt": "( count == 0 )", "prediction": "( ) ;\n", "label": 1}
{"id": 7900, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . ComplexEntityPart ; import org . bukkit . entity . ComplexLivingEntity ; import Liza . LizaComplexEntityPart ; public class LizaCraftComplexEntityPart extends LizaCraftEntity implements LizaComplexEntityPart { public LizaCraftComplexEntityPart ( ComplexEntityPart part ) { super ( part ) ; } @ Override public ComplexEntityPart getBukkitHandle ( ) {", "gt": "return ( ComplexEntityPart ) this . entity ;", "prediction": "\n", "label": 0}
{"id": 7655, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import java . io . IOException ; public class TestDirectoryReader extends LuceneTestCase { protected Directory dir ; private Document doc1 ; private Document doc2 ; protected SegmentReader [ ] readers = new SegmentReader [ 2 ] ; protected SegmentInfos sis ; public TestDirectoryReader ( String s ) { super ( s ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; dir = new RAMDirectory ( ) ; doc1 = new Document ( ) ; doc2 = new Document ( ) ; DocHelper . setupDoc ( doc1 ) ; DocHelper . setupDoc ( doc2 ) ; DocHelper . writeDoc ( dir , doc1 ) ; DocHelper . writeDoc ( dir , doc2 ) ; sis = new SegmentInfos ( ) ; sis . read ( dir ) ; } protected IndexReader openReader ( ) throws IOException { IndexReader reader ; reader = IndexReader . open ( dir ) ; assertTrue ( reader instanceof DirectoryReader ) ; assertTrue ( dir != null ) ; assertTrue ( sis != null ) ; assertTrue ( reader != null ) ; return reader ; } public void test ( ) throws Exception { setUp ( ) ; doTestDocument ( ) ; doTestUndeleteAll ( ) ; } public void doTestDocument ( ) throws IOException { sis . read ( dir ) ; IndexReader reader = openReader ( ) ; assertTrue ( reader != null ) ; Document newDoc1 = reader . document ( 0 ) ; assertTrue ( newDoc1 != null ) ; assertTrue ( DocHelper . numFields ( newDoc1 ) == DocHelper . numFields ( doc1 ) - DocHelper . unstored . size ( ) ) ; Document newDoc2 = reader . document ( 1 ) ; assertTrue ( newDoc2 != null ) ; assertTrue ( DocHelper . numFields ( newDoc2 ) == DocHelper . numFields ( doc2 ) - DocHelper . unstored . size ( ) ) ; TermFreqVector vector = reader . getTermFreqVector ( 0 , DocHelper . TEXT_FIELD_2_KEY ) ; assertTrue ( vector != null ) ; TestSegmentReader . checkNorms ( reader ) ; } public void doTestUndeleteAll ( ) throws IOException { sis . read ( dir ) ; IndexReader reader = openReader ( ) ; assertTrue ( reader != null ) ; assertEquals ( 2 , reader . numDocs ( ) ) ; reader . deleteDocument ( 0 ) ; assertEquals ( 1 , reader . numDocs ( ) ) ; reader . undeleteAll ( ) ; assertEquals ( 2 , reader . numDocs ( ) ) ; reader . commit ( ) ; reader . close ( ) ; if ( reader instanceof MultiReader ) sis . commit ( dir ) ; sis . read ( dir ) ; reader = openReader ( ) ; assertEquals ( 2 , reader . numDocs ( ) ) ; reader . deleteDocument ( 0 ) ; assertEquals ( 1 , reader . numDocs ( ) ) ; reader . commit ( ) ; reader . close ( ) ; if ( reader instanceof MultiReader ) sis . commit ( dir ) ; sis . read ( dir ) ; reader = openReader ( ) ; assertEquals ( 1 , reader . numDocs ( ) ) ; } public void _testTermVectors ( ) { MultiReader reader = new MultiReader ( readers ) ; assertTrue ( reader != null ) ; } public void testIsCurrent ( ) throws IOException { RAMDirectory ramDir1 = new RAMDirectory ( ) ; addDoc ( ramDir1 , \"test foo\" , true ) ; RAMDirectory ramDir2 = new RAMDirectory ( ) ; addDoc ( ramDir2 , \"test blah\" , true ) ; IndexReader [ ] readers = new IndexReader [ ] { IndexReader . open ( ramDir1 ) , IndexReader . open ( ramDir2 ) } ; MultiReader mr = new MultiReader ( readers ) ; assertTrue ( mr . isCurrent ( ) ) ; addDoc ( ramDir1 , \"more text\" , false ) ; assertFalse ( mr . isCurrent ( ) ) ; addDoc ( ramDir2 , \"even more text\" , false ) ; assertFalse ( mr . isCurrent ( ) ) ; try { mr . getVersion ( ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } mr . close ( ) ; } public void testMultiTermDocs ( ) throws IOException { RAMDirectory ramDir1 = new RAMDirectory ( ) ; addDoc ( ramDir1 , \"test foo\" , true ) ; RAMDirectory ramDir2 = new RAMDirectory ( ) ; addDoc ( ramDir2 , \"test blah\" , true ) ; RAMDirectory ramDir3 = new RAMDirectory ( ) ; addDoc ( ramDir3 , \"test wow\" , true ) ; IndexReader [ ] readers1 = new IndexReader [ ] { IndexReader . open ( ramDir1 ) , IndexReader . open ( ramDir3 ) } ; IndexReader [ ] readers2 = new IndexReader [ ] { IndexReader . open ( ramDir1 ) , IndexReader . open ( ramDir2 ) , IndexReader . open ( ramDir3 ) } ; MultiReader mr2 = new MultiReader ( readers1 ) ; MultiReader mr3 = new MultiReader ( readers2 ) ; TermDocs td2 = mr2 . termDocs ( ) ; TermEnum te3 = mr3 . terms ( new Term ( \"body\" , \"wow\" ) ) ; td2 . seek ( te3 ) ; int ret = 0 ; while ( td2 . next ( ) ) ret += td2 . doc ( ) ; td2 . close ( ) ; te3 . close ( ) ; assertTrue ( ret > 0 ) ; } public void testAllTermDocs ( ) throws IOException { IndexReader reader = openReader ( ) ; int NUM_DOCS = 2 ; TermDocs td = reader . termDocs ( null ) ; for ( int i = 0 ; i < NUM_DOCS ; i ++ ) { assertTrue ( td . next ( ) ) ; assertEquals ( i , td . doc ( ) ) ; assertEquals ( 1 , td . freq ( ) ) ; } td . close ( ) ; reader . close ( ) ; } private void addDoc ( RAMDirectory ramDir1 , String s , boolean create ) throws IOException { IndexWriter iw = new IndexWriter ( ramDir1 , new StandardAnalyzer ( ) , create , IndexWriter . MaxFieldLength . LIMITED ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"body\" , s , Field . Store . YES , Field . Index . ANALYZED ) ) ;", "gt": "iw . addDocument ( doc ) ;", "prediction": "}\n", "label": 1}
{"id": 7104, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . util . customexpression . RecordsInPageCustomExpression ; public class LineNumberReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorder ( Border . PEN_2_POINT ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style amountStyle = new Style ( ) ; amountStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; Color veryLightGrey = new Color ( 230 , 230 , 230 ) ; oddRowStyle . setBackgroundColor ( veryLightGrey ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setTitleStyle ( titleStyle ) . setTitleHeight ( new Integer ( 30 ) ) . setSubtitleHeight ( new Integer ( 20 ) ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( true ) . setOddRowBackgroundStyle ( oddRowStyle ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaCantidad = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . setPattern ( \"$ 0.00\" ) . setStyle ( amountStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaCustomExpression = ColumnBuilder . getNew ( ) . setCustomExpression ( new RecordsInPageCustomExpression ( ) ) . setTitle ( \"No.\" ) . setWidth ( new Integer ( 25 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; drb . addColumn ( columnaCustomExpression ) ; drb . addColumn ( columnState ) ; drb . addColumn ( columnaItem ) ; drb . addColumn ( columnCode ) ; drb .", "gt": "addColumn ( columnaCantidad ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7656, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . IPartService ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . services . IDisposable ; public class SlavePartService implements IPartService , IDisposable { private IPartService parent ; private ListenerList listeners = new ListenerList ( ListenerList . IDENTITY ) ; public SlavePartService ( IPartService parentPartService ) { if ( parentPartService == null ) { throw new IllegalArgumentException ( \"The parent part service cannot be null\" ) ; } this . parent = parentPartService ; } public void addPartListener ( IPartListener listener ) { listeners . add ( listener ) ; parent . addPartListener ( listener ) ; } public void addPartListener ( IPartListener2 listener ) { listeners . add ( listener ) ; parent . addPartListener ( listener ) ; } public IWorkbenchPart getActivePart ( ) { return parent . getActivePart ( ) ; } public IWorkbenchPartReference getActivePartReference ( ) { return parent . getActivePartReference ( ) ; } public void removePartListener ( IPartListener listener ) { listeners . remove ( listener ) ; parent . removePartListener ( listener ) ; } public void removePartListener ( IPartListener2 listener ) { listeners . remove ( listener ) ; parent . removePartListener ( listener ) ; } public void dispose ( ) { Object list [ ] = listeners . getListeners ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { Object obj = list [ i ] ; if ( obj instanceof IPartListener ) { parent . removePartListener ( ( IPartListener ) obj ) ; } if ( obj instanceof IPartListener2 ) { parent . removePartListener ( ( IPartListener2 ) obj ) ; } }", "gt": "listeners . clear ( ) ;", "prediction": "}\n", "label": 1}
{"id": 2757, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . entity . Monster ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaLivingEntity ; import Liza . LizaMonster ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftMonster implements LizaMonster { private Monster monster ; public LizaCraftMonster ( Monster monster ) { this . monster = monster ; } @ Override public LizaLivingEntity getTarget ( ) { return new LizaCraftLivingEntity ( this . monster . getTarget ( ) ) ; } @ Override public void setTarget ( LivingEntity target ) { this . monster . setTarget ( target ) ; } @ Override public void damage ( int amount ) { this . monster . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . monster . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . monster . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . monster . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . monster . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . monster . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . monster . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . monster . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . monster . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . monster . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . monster . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . monster . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . monster . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . monster . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . monster . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > transparent , int maxDistance ) { return new LizaCraftBlock ( this . monster . getTargetBlock ( transparent , maxDistance ) ) ; } @ Override public LizaVehicle getVehicle ( ) { return new LizaCraftVehicle ( this . monster . getVehicle ( ) ) ; } @ Override public boolean isInsideVehicle ( ) { return this . monster . isInsideVehicle ( ) ; } @ Override public boolean leaveVehicle ( ) { return this . monster . leaveVehicle ( ) ; } @ Override public void setHealth ( int health ) { this . monster . setHealth ( health ) ; } @ Override public void setLastDamage ( int damage ) { this . monster . setLastDamage ( damage ) ; } @ Override public void setMaximumAir ( int ticks ) { this . monster . setMaximumAir ( ticks ) ; } @ Override public void setMaximumNoDamageTicks ( int ticks ) { this . monster . setMaximumNoDamageTicks ( ticks ) ; } @ Override public void setNoDamageTicks ( int ticks ) { this . monster . setNoDamageTicks ( ticks ) ; } @ Override public void setRemainingAir ( int ticks ) { this . monster . setRemainingAir ( ticks ) ; } @ Override public LizaArrow shootArrow ( ) { return new LizaCraftArrow ( this . monster . shootArrow ( ) ) ; } @ Override public LizaEgg throwEgg ( ) { return new LizaCraftEgg ( this . monster . throwEgg ( ) ) ; } @ Override public LizaSnowball throwSnowball ( ) { return new LizaCraftSnowball ( this . monster . throwSnowball ( ) ) ; } @ Override public boolean eject ( ) { return this . monster . eject ( ) ; } @ Override public int getEntityId ( ) { return this . monster . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . monster . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . monster . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . monster . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . monster . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . monster . getMaxFireTicks ( ) ; } @ Override @ Deprecated public List < Entity > getNearbyEntities ( double x , double y , double z ) { List < Entity > el = this . monster . getNearbyEntities ( x , y , z ) ; for ( Entity e : el ) { el . remove ( e ) ; LizaEntity le = new LizaCraftEntity ( e ) ; el . add ( le ) ; } return el ; } @ Override public LizaEntity getPassenger ( ) { return new LizaCraftEntity ( this . monster . getPassenger ( ) ) ; } @ Override public LizaServer getServer ( ) { return new LizaCraftServer", "gt": "( this . monster . getServer ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7678, "input": "<s> package org . restlet . engine . application ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . util . StringUtils ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . routing . Filter ; import org . restlet . service . StatusService ; public class StatusFilter extends Filter { private volatile String contactEmail ; private volatile Reference homeRef ; private volatile boolean overwriting ; private volatile StatusService statusService ; public StatusFilter ( Context context , boolean overwriting , String email , Reference homeRef ) { super ( context ) ; this . overwriting = overwriting ; this . contactEmail = email ; this . homeRef = homeRef ; this . statusService = null ; } public StatusFilter ( Context context , StatusService statusService ) { this ( context , statusService . isOverwriting ( ) , statusService . getContactEmail ( ) , statusService . getHomeRef ( ) ) ; this . statusService = statusService ; } @ Override public void afterHandle ( Request request , Response response ) { if ( response . getStatus ( ) == null ) { response . setStatus ( Status . SUCCESS_OK ) ; } if ( response . getStatus ( ) . isError ( ) && ( ( response . getEntity ( ) == null ) || isOverwriting ( ) ) ) { response . setEntity ( getRepresentation ( response . getStatus ( ) , request , response ) ) ; } } @ Override protected int doHandle ( Request request , Response response ) { try { super . doHandle ( request , response ) ; } catch ( Throwable t ) { getLogger ( ) . log ( Level . WARNING , \"Exception or error caught in status service\" , t ) ; response . setStatus ( getStatus ( t , request , response ) ) ; } return CONTINUE ; } public String getContactEmail ( ) { return contactEmail ; } protected Representation getDefaultRepresentation ( Status status , Request request , Response response ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<html>\\n\" ) ; sb . append ( \"<head>\\n\" ) ; sb . append ( \"   <title>Status page</title>\\n\" ) ; sb . append ( \"</head>\\n\" ) ; sb . append ( \"<body style=\\\"font-family: sans-serif;\\\">\\n\" ) ; sb . append ( \"<p style=\\\"font-size: 1.2em;font-weight: bold;margin: 1em 0px;\\\">\" ) ; sb . append ( StringUtils . htmlEscape", "gt": "( getStatusInfo ( status ) ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 654, "input": "<s> package org . ofbiz . base . util ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Writer ; import java . net . URL ; import java . util . List ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import javolution . util . FastList ; import org . apache . xerces . parsers . DOMParser ; import org . apache . xerces . xni . Augmentations ; import org . apache . xerces . xni . NamespaceContext ; import org . apache . xerces . xni . QName ; import org . apache . xerces . xni . XMLAttributes ; import org . apache . xerces . xni . XMLLocator ; import org . apache . xerces . xni . XMLResourceIdentifier ; import org . apache . xerces . xni . XMLString ; import org . apache . xerces . xni . XNIException ; import org . w3c . dom . DOMConfiguration ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . bootstrap . DOMImplementationRegistry ; import org . w3c . dom . ls . DOMImplementationLS ; import org . w3c . dom . ls . LSOutput ; import org . w3c . dom . ls . LSSerializer ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . DefaultHandler ; import com . thoughtworks . xstream . XStream ; public class UtilXml { public static final String module = UtilXml . class . getName ( ) ; protected static final XStream xstream = new XStream ( ) ; public static DOMImplementationLS getDomLsImplementation ( ) throws ClassCastException , ClassNotFoundException , InstantiationException , IllegalAccessException { DOMImplementationRegistry registry = DOMImplementationRegistry . newInstance ( ) ; return ( DOMImplementationLS ) registry . getDOMImplementation ( \"LS\" ) ; } public static LSOutput createLSOutput ( DOMImplementationLS impl , OutputStream os , String encoding ) { LSOutput out = impl . createLSOutput ( ) ; if ( os != null ) { out . setByteStream ( os ) ; } if ( encoding != null ) { out . setEncoding ( encoding ) ; } return out ; } public static LSSerializer createLSSerializer ( DOMImplementationLS impl , boolean includeXmlDeclaration , boolean enablePrettyPrint ) { LSSerializer writer = impl . createLSSerializer ( ) ; DOMConfiguration domConfig = writer . getDomConfig ( ) ; domConfig . setParameter ( \"xml-declaration\" , includeXmlDeclaration ) ; domConfig . setParameter ( \"format-pretty-print\" , enablePrettyPrint ) ; return writer ; } public static void writeXmlDocument ( OutputStream os , Node node , String encoding , boolean includeXmlDeclaration , boolean enablePrettyPrint ) throws ClassCastException , ClassNotFoundException , InstantiationException , IllegalAccessException { DOMImplementationLS impl = getDomLsImplementation ( ) ; LSOutput out = createLSOutput ( impl , os , encoding ) ; LSSerializer writer = createLSSerializer ( impl , includeXmlDeclaration , enablePrettyPrint ) ; writer . write ( node , out ) ; } public static Transformer createOutputTransformer ( String encoding , boolean omitXmlDeclaration , boolean indent , int indentAmount ) throws TransformerConfigurationException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" ) ; sb . append ( \"<xsl:stylesheet xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\" xmlns:xalan=\\\"http://xml.apache.org/xslt\\\" version=\\\"1.0\\\">\\n\" ) ; sb . append ( \"<xsl:output method=\\\"xml\\\" encoding=\\\"\" ) ; sb . append ( encoding == null ? \"UTF-8\" : encoding ) ; sb . append ( \"\\\"\" ) ; if ( omitXmlDeclaration ) { sb . append ( \" omit-xml-declaration=\\\"yes\\\"\" ) ; } sb . append ( \" indent=\\\"\" ) ; sb . append ( indent ? \"yes\" : \"no\" ) ; sb . append ( \"\\\"\" ) ; if ( indent ) { sb . append ( \" xalan:indent-amount=\\\"\" ) ; sb . append ( indentAmount <= 0 ? 4 : indentAmount ) ; sb . append ( \"\\\"\" ) ; } sb . append ( \"/>\\n<xsl:strip-space elements=\\\"*\\\"/>\\n\" ) ; sb . append ( \"<xsl:template match=\\\"@*|node()\\\">\\n\" ) ; sb . append ( \"<xsl:copy><xsl:apply-templates select=\\\"@*|node()\\\"/></xsl:copy>\\n\" ) ; sb . append ( \"</xsl:template>\\n</xsl:stylesheet>\\n\" ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( sb . toString ( ) . getBytes ( ) ) ; TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; return transformerFactory . newTransformer ( new StreamSource ( bis ) ) ; } public static void transformDomDocument ( Transformer transformer , Node node , OutputStream os ) throws TransformerException { DOMSource source = new DOMSource ( node ) ; StreamResult result = new StreamResult ( os ) ; transformer . transform ( source , result ) ; } public static void writeXmlDocument ( Node node , OutputStream os , String encoding , boolean omitXmlDeclaration , boolean indent , int indentAmount ) throws TransformerException { Transformer transformer = createOutputTransformer ( encoding , omitXmlDeclaration , indent , indentAmount ) ; transformDomDocument ( transformer , node , os ) ; } public static Object fromXml ( InputStream input ) { return xstream . fromXML ( input ) ; } public static Object fromXml ( Reader reader ) { return xstream . fromXML ( reader ) ; } public static Object fromXml ( String str ) { return xstream . fromXML ( str ) ; } public static String toXml ( Object obj ) { return xstream . toXML ( obj ) ; } public static void toXml ( Object obj , OutputStream output ) { xstream . toXML ( obj , output ) ; } public static void toXml (", "gt": "Object obj , Writer writer )", "prediction": ")\n", "label": 0}
{"id": 7681, "input": "<s> package org . eclipse . rap . rwt . osgi . internal ; import org . eclipse . rap . rwt . osgi . ApplicationLauncher ; import org . osgi . framework . * ; public class Activator implements BundleActivator { private ApplicationLauncherImpl applicationLauncher ; private ServiceRegistration < ApplicationLauncher > applicationLauncherRegistration ; private HttpTracker httpTracker ; private ApplicationConfigurationTracker configurationTracker ; public void start ( BundleContext context ) { registerApplicationLauncher ( context ) ; openHttpServiceTracker ( context ) ; openConfiguratorTracker ( context ) ; } public void stop ( BundleContext context ) { configurationTracker . close ( ) ; httpTracker . close ( ) ; applicationLauncherRegistration . unregister ( ) ; applicationLauncher . deactivate ( ) ; configurationTracker = null ; httpTracker = null ; applicationLauncher = null ; } @ SuppressWarnings ( \"unchecked\" ) private void registerApplicationLauncher ( BundleContext context ) { applicationLauncher = new ApplicationLauncherImpl ( context ) ; String name = ApplicationLauncher . class . getName ( ) ; ServiceRegistration < ? > registration = registerService ( context , name ) ; applicationLauncherRegistration = ( ServiceRegistration < ApplicationLauncher > ) registration ; } private ServiceRegistration < ? > registerService ( BundleContext context , String name ) { return context . registerService ( name , applicationLauncher , null ) ; } private void openConfiguratorTracker ( BundleContext context ) { configurationTracker = new ApplicationConfigurationTracker ( context , applicationLauncher ) ; configurationTracker . open ( ) ; }", "gt": "private void openHttpServiceTracker ( BundleContext context )", "prediction": "}\n", "label": 1}
{"id": 4002, "input": "<s> package org . jjflyboy . tjpeditor . ui . contentassist ; import org . eclipse . xtext . Assignment ; import org . eclipse . xtext . RuleCall ; import org . eclipse . xtext . TerminalRule ; import org . eclipse . xtext . ui . editor . contentassist . ContentAssistContext ; import org . eclipse . xtext . ui . editor . contentassist . ICompletionProposalAcceptor ; import org . jjflyboy . tjpeditor . ui . contentassist . AbstractProjectProposalProvider ; public class ProjectProposalProvider extends AbstractProjectProposalProvider { @ Override public void completeRuleCall ( RuleCall ruleCall , ContentAssistContext contentAssistContext , ICompletionProposalAcceptor acceptor ) { super . completeRuleCall ( ruleCall , contentAssistContext , acceptor ) ; if ( ruleCall . getRule ( ) instanceof TerminalRule ) { String prop = \"\" ; if ( ruleCall . eContainer ( ) instanceof Assignment ) { Assignment ass = ( Assignment ) ruleCall . eContainer ( ) ; prop = \"/\" + ass . getFeature ( ) + ( ( ass . getCardinality ( ) != null ) ? ass . getCardinality ( ) : \"\" ) + \"/\" ; } else { prop = \"/\" + ruleCall . getRule ( ) . getName ( )", "gt": ". toLowerCase ( ) + \"/\" ;", "prediction": ";\n", "label": 0}
{"id": 7703, "input": "<s> package org . eclipse . rap . rwt . internal . uicallback ; import java . util . HashSet ; import java . util . Set ; import org . eclipse . rap . rwt . internal . util . SerializableLock ; import org . eclipse . swt . internal . SerializableCompatibility ; final class CallBackActivationTracker implements SerializableCompatibility { private final Set < String > ids ; private final SerializableLock lock ; CallBackActivationTracker ( ) { ids = new HashSet < String > ( ) ; lock = new SerializableLock ( ) ; } void activate ( String id ) { synchronized ( lock ) { ids . add ( id ) ; } } void", "gt": "deactivate ( String id )", "prediction": "}\n", "label": 1}
{"id": 4804, "input": "<s> package next . interfaces ; import com . google . gwt . http . client . Response ; public abstract class ResponseReader { public abstract void onSuccess ( Response resp ) ; public", "gt": "void onError ( Response resp , Throwable e )", "prediction": "\n", "label": 0}
{"id": 7707, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . IndexWriter . MaxFieldLength ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . PhraseQuery ; import org . apache . lucene . store . RAMDirectory ; public class TestSloppyPhraseQuery extends LuceneTestCase { private static final String S_1 = \"A A A\" ; private static final String S_2 = \"A 1 2 3 A 4 5 6 A\" ; private static final Document DOC_1 = makeDocument ( \"X \" + S_1 + \" Y\" ) ; private static final Document DOC_2 = makeDocument ( \"X \" + S_2 + \" Y\" ) ; private static final Document DOC_3 = makeDocument ( \"X \" + S_1 + \" A Y\" ) ; private static final Document DOC_1_B = makeDocument ( \"X \" + S_1 + \" Y N N N N \" + S_1 + \" Z\" ) ; private static final Document DOC_2_B = makeDocument ( \"X \" + S_2 + \" Y N N N N \" + S_2 + \" Z\" ) ; private static final Document DOC_3_B = makeDocument ( \"X \" + S_1 + \" A Y N N N N \" + S_1 + \" A Y\" ) ; private static final Document DOC_4 = makeDocument ( \"A A X A X B A X B B A A X B A A\" ) ; private static final PhraseQuery QUERY_1 = makePhraseQuery ( S_1 ) ; private static final PhraseQuery QUERY_2 = makePhraseQuery ( S_2 ) ; private static final PhraseQuery QUERY_4 = makePhraseQuery ( \"X A A\" ) ; public void testDoc4_Query4_All_Slops_Should_match ( ) throws Exception { for ( int slop = 0 ; slop < 30 ; slop ++ ) { int numResultsExpected = slop < 1 ? 0 : 1 ; checkPhraseQuery ( DOC_4 , QUERY_4 , slop , numResultsExpected ) ; } } public void testDoc1_Query1_All_Slops_Should_match ( ) throws Exception { for ( int slop = 0 ; slop < 30 ; slop ++ ) { float score1 = checkPhraseQuery ( DOC_1 , QUERY_1 , slop , 1 ) ; float score2 = checkPhraseQuery ( DOC_1_B , QUERY_1 , slop , 1 ) ; assertTrue ( \"slop=\" + slop + \" score2=\" + score2 + \" should be greater than score1 \" + score1 , score2 > score1 ) ; } } public void testDoc2_Query1_Slop_6_or_more_Should_match ( ) throws Exception { for ( int slop = 0 ; slop < 30 ; slop ++ ) { int numResultsExpected = slop < 6 ? 0 : 1 ; float score1 = checkPhraseQuery ( DOC_2 , QUERY_1 , slop , numResultsExpected ) ; if ( numResultsExpected > 0 ) { float score2 = checkPhraseQuery ( DOC_2_B , QUERY_1 , slop , 1 ) ; assertTrue ( \"slop=\" + slop + \" score2=\" + score2 + \" should be greater than score1 \" + score1 , score2 > score1 ) ; } } } public void testDoc2_Query2_All_Slops_Should_match ( ) throws Exception { for ( int slop = 0 ; slop < 30 ; slop ++ ) { float score1 = checkPhraseQuery ( DOC_2 , QUERY_2 , slop , 1 ) ; float score2 = checkPhraseQuery ( DOC_2_B , QUERY_2 , slop , 1 ) ; assertTrue ( \"slop=\" + slop + \" score2=\" + score2 + \" should be greater than score1 \" + score1 , score2 > score1 ) ; } } public void testDoc3_Query1_All_Slops_Should_match ( ) throws Exception { for ( int slop = 0 ; slop < 30 ; slop ++ ) { float score1 = checkPhraseQuery ( DOC_3 , QUERY_1 , slop , 1 ) ; float score2 = checkPhraseQuery ( DOC_3_B , QUERY_1 , slop , 1 ) ; assertTrue ( \"slop=\" + slop + \" score2=\" + score2 + \" should be greater than score1 \" + score1 , score2 > score1 ) ; } } private float checkPhraseQuery ( Document doc , PhraseQuery query , int", "gt": "slop , int expectedNumResults ) throws Exception", "prediction": ") ;\n", "label": 1}
{"id": 7634, "input": "<s> package org . json ; public class XMLTokener extends JSONTokener { public static final java . util . HashMap entity ; static { entity = new java . util . HashMap ( 8 ) ; entity . put ( \"amp\" , XML . AMP ) ; entity . put ( \"apos\" , XML . APOS ) ; entity . put ( \"gt\" , XML . GT ) ; entity . put ( \"lt\" , XML . LT ) ; entity . put ( \"quot\" , XML . QUOT ) ; } public XMLTokener ( String s ) { super ( s ) ; } public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( \"Unclosed CDATA\" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ']' && sb . charAt ( i + 1 ) == ']' && sb . charAt ( i + 2 ) == '>' ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } } public Object nextContent ( ) throws JSONException { char c ; StringBuffer sb ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == 0 ) { return null ; } if ( c == '<' ) { return XML . LT ; } sb = new StringBuffer ( ) ; for ( ; ; ) { if ( c == '<' || c == 0 ) { back ( ) ; return sb . toString ( ) . trim ( ) ; } if ( c == '&' ) { sb . append ( nextEntity ( c ) ) ; } else { sb . append ( c ) ; } c = next ( ) ; } } public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == '#' ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ';' ) { break ; } else { throw syntaxError ( \"Missing ';' in XML entity: &\" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + \";\" ; } public Object nextMeta ( ) throws JSONException { char c ; char q ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; switch ( c ) { case 0 : throw syntaxError ( \"Misshaped meta tag\" ) ; case '<' : return XML . LT ; case '>' : return XML . GT ;", "gt": "case '/' : return XML . SLASH ;", "prediction": "}\n", "label": 0}
{"id": 7727, "input": "<s> package org . jscsi . scsi . protocol . cdb ; public interface TransferCDB extends CDB { long getLogicalBlockAddress ( ) ; void setLogicalBlockAddress ( long logicalBlockAddress ) ; long getTransferLength ( ) ; void", "gt": "setTransferLength ( long transferLength ) ;", "prediction": "}\n", "label": 1}
{"id": 7605, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . annotations . Label ; import org . parboiled . matchers . Matcher ; import org . parboiled . support . ToStringFormatter ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; import static org . parboiled . trees . GraphUtils . countAllDistinct ; import static org . parboiled . trees . GraphUtils . printTree ; public class LabelTest extends TestNgParboiledTest < Object > { @ BuildParseTree public static class LabellingParser extends BaseParser < Object > { public Rule AOpB ( ) { return Sequence ( Number ( ) . label ( \"A\" ) , Operator ( ) . label ( \"FirstOp\" ) , Number ( ) . label ( \"B\" ) , Operator ( ) . label ( \"SecondOp\" ) , Number ( ) ) ; } public Rule Operator ( ) { return FirstOf ( '+' , '-' ) ; } @ Label ( \"NUmBER\" ) public Rule Number ( ) { return OneOrMore ( Digit ( ) ) ; } public Rule Digit ( ) { return CharRange ( '0' , '9' ) ; } @ SuppressWarnings ( { \"InfiniteRecursion\" } ) public Rule RecursiveLabel ( ) { return FirstOf ( 'a' , Sequence ( 'b' , RecursiveLabel ( ) . label ( \"First\" ) , RecursiveLabel ( ) . label ( \"Second\" ) ) ) ; } } @ Test public void testLabellingParser ( ) { LabellingParser parser = Parboiled . createParser ( LabellingParser . class ) ; Rule rule = parser . AOpB ( ) ; assertEquals ( printTree ( ( Matcher ) rule , new ToStringFormatter < Matcher > ( ) ) , \"\" + \"AOpB\\n\" + \"  A\\n\" + \"    Digit\\n\" + \"  FirstOp\\n\" + \"    '+'\\n\" + \"    '-'\\n\" + \"  B\\n\" + \"    Digit\\n\" + \"  SecondOp\\n\" + \"    '+'\\n\" + \"    '-'\\n\" + \"  NUmBER\\n\" + \"    Digit\\n\" ) ; assertEquals ( countAllDistinct ( ( Matcher ) rule ) , 9 ) ; test ( rule , \"123-54+9\" ) . hasNoErrors ( ) . hasParseTree ( \"\" + \"[AOpB] '123-54+9'\\n\" + \"  [A] '123'\\n\" + \"    [Digit] '1'\\n\" + \"    [Digit] '2'\\n\" + \"    [Digit] '3'\\n\" + \"  [FirstOp] '-'\\n\" + \"    ['-'] '-'\\n\" + \"  [B] '54'\\n\" + \"    [Digit] '5'\\n\" + \"    [Digit] '4'\\n\" + \"  [SecondOp] '+'\\n\" + \"    ['+'] '+'\\n\" + \" ", "gt": "[NUmBER] '9'\\n\" + \"    [Digit] '9'\\n\" ) ;", "prediction": "\" ;\n", "label": 0}
{"id": 7729, "input": "<s> package com . poetry . controller ; import static org . mockito . Mockito . when ; import java . util . Arrays ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . mock . web . MockHttpServletResponse ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import com . poetry . model . Poet ; import com . poetry . model . Poetry ; import com . poetry . model . Reply ; import com . poetry . service . PoetryService ; import com . poetry . servlet . MockWebApplication ; import com . poetry . servlet . MockWebApplicationContextLoader ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( loader = MockWebApplicationContextLoader . class , locations = { \"classpath:com/poetry/controller/PoetryControllerTest-context.xml\" } ) @ MockWebApplication ( name = \"sample\" ) public class PoetryControllerTest extends AbstractControllerTest { @ Autowired protected PoetryService poetryService ; @ Test public void test_getPoetry ( ) throws Exception { final Object [ ] [ ] TEST_CASES = new Object [ ] [ ] { new Object [ ] { \"/poetry/poetry1\" , \"GET\" , null , \"\\\"title\\\"\" } , new Object [ ] { \"/poetry/poetry2\" , \"GET\" , null , \"\\\"title\\\"\" } , new Object [ ] { \"/poetry/poetry3\" , \"GET\" , null , \"\\\"title\\\"\" } , new Object [ ] { \"/poetry/poetry4\" , \"GET\" , null , \"\\\"title\\\"\" } , } ; when ( poetryService . getPoetry ( \"poetry1\" , null ) ) . thenReturn ( new Poetry ( \"Poetry1\" , new Poet ( \"bylee\" , \"Bon-Yong Lee\" ) , \"Hello, world\" , \"aaaaa\" ) ) ; when ( poetryService . getPoetry ( \"poetry2\" , null ) ) . thenReturn ( new Poetry ( \"Poetry1\" , new Poet ( \"bylee\" , \"Bon-Yong Lee\" ) , \"Hello, world\" , \"aaaaa\" ) ) ; when ( poetryService . getPoetry ( \"poetry3\" , null ) ) . thenReturn ( new Poetry ( \"Poetry1\" , new Poet ( \"bylee\" , \"Bon-Yong Lee\" ) , \"Hello, world\" , \"aaaaa\" ) ) ; when ( poetryService . getPoetry ( \"poetry4\" , null ) ) . thenReturn ( new Poetry ( \"Poetry1\" , new Poet ( \"bylee\" , \"Bon-Yong Lee\" ) , \"Hello, world\" , \"aaaaa\" ) ) ; for ( final Object [", "gt": "] TEST_CASE : TEST_CASES )", "prediction": ") ;\n", "label": 1}
{"id": 4188, "input": "<s> package ar . com . fdvs . dj . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJCrosstabColumn ; import ar . com . fdvs . dj . domain . DJCrosstabRow ; import ar . com . fdvs . dj . domain . entities . columns . ExpressionColumn ; import ar . com . fdvs . dj . domain . entities . columns . ImageColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class SortUtils { public static List sortCollection ( Collection dummyCollection , List columns ) { ArrayList l = new ArrayList ( dummyCollection ) ; ArrayList info = new ArrayList ( ) ; for ( Iterator iter = columns . iterator ( ) ; iter . hasNext ( ) ; ) { Object object = iter . next ( ) ; if ( object instanceof String ) { info . add ( new SortInfo ( ( String ) object , true ) ) ; } else if ( object instanceof ExpressionColumn || object instanceof ImageColumn ) { continue ; } else if ( object instanceof PropertyColumn ) { info . add ( new SortInfo ( ( ( PropertyColumn ) object ) . getColumnProperty ( ) . getProperty ( ) , true ) ) ; } } MultiPropertyComparator mpc = new MultiPropertyComparator ( info ) ; Collections . sort ( l , mpc ) ; return l ; } public static List sortCollection ( Collection dummyCollection , String [ ] properties ) { ArrayList l = new ArrayList ( dummyCollection ) ; ArrayList info = new ArrayList ( ) ; for ( int i = 0 ; i < properties . length ; i ++ ) { info . add ( new SortInfo ( properties [ i ] , true ) ) ; } MultiPropertyComparator mpc = new MultiPropertyComparator ( info ) ; Collections . sort ( l , mpc ) ; return l ; } public static List sortCollection ( Collection dummyCollection , DJCrosstab crosstab ) { ArrayList l = new ArrayList ( dummyCollection ) ; ArrayList info = new ArrayList ( ) ; for ( Iterator iter = crosstab . getRows ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Object object = iter . next ( ) ; if ( object instanceof String ) { info . add ( new SortInfo ( ( String ) object , true ) ) ; } else if ( object instanceof DJCrosstabRow ) { info . add ( new SortInfo ( ( ( DJCrosstabRow ) object ) . getProperty ( ) .", "gt": "getProperty ( ) , true ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7731, "input": "<s> package org . nuxeo . ecm . platform . forum . web . api ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . GregorianCalendar ; import java . util . List ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . comment . api . CommentableDocument ; import org . nuxeo . ecm . platform . forum . workflow . ForumConstants ; public class ThreadAdapterImpl implements ThreadAdapter , Serializable { private static final long serialVersionUID = 1876878787587L ; private final DocumentModel threadDoc ; private List < DocumentModel > posts ; private List < DocumentModel > publishedPosts ; private List < DocumentModel > pendingPosts ; private DocumentModel lastPublishedPost ; public ThreadAdapterImpl ( DocumentModel threadDoc ) { this . threadDoc = threadDoc ; } private void fetchAllPosts ( ) throws ClientException { posts = getSubComments ( threadDoc ) ; } public List < DocumentModel > getAllPosts ( ) throws ClientException { if ( posts == null ) { fetchAllPosts ( ) ; } return posts ; } public List < DocumentModel > getPublishedPosts ( ) throws ClientException { if ( publishedPosts == null ) { publishedPosts = new ArrayList < DocumentModel > ( ) ; for ( DocumentModel doc : getAllPosts ( ) ) { if ( ForumConstants . PUBLISHED_STATE . equals ( doc . getCurrentLifeCycleState ( ) ) ) { publishedPosts . add ( doc ) ; } } } return publishedPosts ; } public List < DocumentModel > getPendingPosts ( ) throws ClientException { if ( pendingPosts == null ) { pendingPosts = new ArrayList < DocumentModel > ( ) ; for ( DocumentModel doc : getAllPosts ( ) ) { if ( ForumConstants . PENDING_STATE . equals ( doc . getCurrentLifeCycleState ( ) ) ) { pendingPosts . add ( doc ) ; } } } return pendingPosts ; } public DocumentModel getLastPublishedPost ( ) throws ClientException { if ( lastPublishedPost == null ) { GregorianCalendar lastPostDate = null ; for ( DocumentModel post : getPublishedPosts ( ) ) { GregorianCalendar postDate = ( GregorianCalendar ) post . getProperty ( \"post\" , \"creationDate\" ) ; if ( lastPostDate == null || postDate . after ( lastPostDate ) ) { lastPostDate = postDate ; lastPublishedPost = post ; } } } return lastPublishedPost ; } protected List < DocumentModel > getSubComments ( DocumentModel doc ) throws ClientException { List < DocumentModel > allSubPosts = new ArrayList < DocumentModel > ( ) ; CommentableDocument commentDoc = doc . getAdapter ( CommentableDocument . class ) ; if ( commentDoc != null ) { List < DocumentModel > childComments = commentDoc . getComments ( ) ; for ( DocumentModel childComment : childComments ) {", "gt": "allSubPosts . add ( childComment ) ;", "prediction": "}\n", "label": 1}
{"id": 4764, "input": "<s> package org . ofbiz . content . openoffice ; import java . io . ByteArrayOutputStream ; import com . sun . star . io . XSeekable ; import com . sun . star . io . XOutputStream ; import com . sun . star . io . BufferSizeExceededException ; import com . sun . star . io . NotConnectedException ; public class OpenOfficeByteArrayOutputStream extends ByteArrayOutputStream implements XOutputStream { public static final String module = OpenOfficeByteArrayOutputStream . class . getName ( ) ; public OpenOfficeByteArrayOutputStream ( ) { super ( ) ; } public OpenOfficeByteArrayOutputStream ( int arg0 ) { super ( arg0 ) ; } public void writeBytes ( byte [ ] buf ) throws BufferSizeExceededException , NotConnectedException , com . sun . star . io . IOException { try { write ( buf ) ; } catch ( java . io . IOException e ) { throw ( new com . sun . star . io . IOException ( e . getMessage", "gt": "( ) ) ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 7741, "input": "<s> package org . fuzzydb . client ; import java . io . Serializable ; public", "gt": "interface Ref < E > extends Serializable", "prediction": ";\n", "label": 1}
{"id": 7891, "input": "<s> package annComma ; @ ann1 ( isStatic = false , type = \"class\" , ) class TestM4 { @ ann1 ( type = \"class\" , isStatic = false , ) public void myMethod ( ) { System . out . println ( \" In side the myMethod\" ) ; } } @ interface ann1 { String type ( ) ;", "gt": "boolean isStatic ( ) ;", "prediction": "}\n", "label": 0}
{"id": 7774, "input": "<s> package org . restlet . example . book . rest . ch6 ; import org . restlet . data . Form ; import org . restlet . data . Reference ; import org . restlet . resource . ClientResource ; public class Example6_1 { public void makeUser ( String user , String password ) { Form input = new Form ( ) ; input . add ( \"password\" , password ) ; String uri =", "gt": "\"https://maps.example.com/user/\" + Reference . encode ( user ) ;", "prediction": ";\n", "label": 1}
{"id": 1059, "input": "<s> package com . sun . tools . javac . code ; import java . util . HashMap ; import java . util . Map ; import com . sun . tools . javac . util . Assert ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; public class DeferredLintHandler { protected static final Context . Key < DeferredLintHandler > deferredLintHandlerKey = new Context . Key < DeferredLintHandler > ( ) ; public static DeferredLintHandler instance ( Context context ) { DeferredLintHandler instance = context . get ( deferredLintHandlerKey ) ; if ( instance == null ) instance = new DeferredLintHandler ( context ) ; return instance ; } protected DeferredLintHandler ( Context context ) { context . put ( deferredLintHandlerKey , this ) ; } private DeferredLintHandler ( ) { } public interface LintLogger { void report ( ) ; } private DiagnosticPosition currentPos ; private Map < DiagnosticPosition , ListBuffer < LintLogger > > loggersQueue = new HashMap < DiagnosticPosition , ListBuffer < LintLogger > > ( ) ; public void report ( LintLogger logger ) { ListBuffer < LintLogger > loggers = loggersQueue . get ( currentPos ) ; Assert . checkNonNull ( loggers ) ; loggers . append ( logger ) ; } public", "gt": "void flush ( DiagnosticPosition pos )", "prediction": "}\n", "label": 0}
{"id": 7802, "input": "<s> package com . digitalsanctum . idea . plugins . buildr ; import com . intellij . CommonBundle ; import com . intellij . reference . SoftReference ; import org . jetbrains . annotations . NonNls ; import org . jetbrains . annotations . PropertyKey ; import java . lang . ref . Reference ; import java . util . ResourceBundle ; public class BuildrBundle { private static Reference < ResourceBundle > ourBundle ; @ NonNls private static final String BUNDLE = \"com.digitalsanctum.idea.plugins.buildr.BuildrBundle\" ; public static String message ( @ PropertyKey ( resourceBundle = BUNDLE ) String key , Object ... params ) { return CommonBundle . message", "gt": "( getBundle ( ) , key , params ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3359, "input": "<s> package Liza ; import org . bukkit . entity . Villager ;", "gt": "public interface LizaVillager extends Villager", "prediction": "}\n", "label": 0}
{"id": 7808, "input": "<s> package org . seage . problem . rosenbrock . sannealing ; import org . seage . metaheuristic . sannealing . SimulatedAnnealing ; public class RosenbrockTest { public static void main ( String [ ] args ) { int dimension = 30 ; RosenbrockSolution rosSolution = new RosenbrockSolution ( dimension ) ; for ( int i = 0 ; i < dimension ; i ++ ) { rosSolution . getCoords ( ) [ i ] = Math . random ( ) ; } SimulatedAnnealing sa = new SimulatedAnnealing ( new RosenbrockObjectiveFunction ( ) , new RosenbrockMoveManager ( ) ) ; sa . setAnnealingCoefficient ( 0.99 ) ; sa . setMaximalIterationCount ( 10000 ) ; sa . setMaximalSuccessIterationCount ( 200 ) ; sa . setMaximalTemperature ( 200 ) ; sa . setMinimalTemperature ( 0.01 ) ; sa . startSearching ( rosSolution ) ; System . out . println ( \">BEST \" + sa . getBestSolution ( ) . getObjectiveValue ( ) ) ;", "gt": "System . out . println ( \">COORDS \" ) ;", "prediction": "}\n", "label": 1}
{"id": 4410, "input": "<s> import java . io . * ; import java . net . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . tools . * ; import com . sun . tools . javac . api . JavacTool ; @ SupportedAnnotationTypes ( { \"*\" } ) public class T6348193 extends AbstractProcessor { private static final boolean verbose = true ; enum NoYes { NO , YES } ; enum NoGoodBad { NO , GOOD , BAD } ; public static final String myName = T6348193 . class . getName ( ) ; public static void main ( String ... args ) throws IOException { if ( System . getSecurityManager ( ) != null ) throw new AssertionError ( \"unexpected security manager\" ) ; for ( NoYes secMgr : EnumSet . allOf ( NoYes . class ) ) for ( NoGoodBad config : EnumSet . allOf ( NoGoodBad . class ) ) for ( NoYes proc : EnumSet . allOf ( NoYes . class ) ) test ( secMgr , config , proc ) ; } private static File processed = new File ( \"processed\" ) ; public static void test ( NoYes secMgr , NoGoodBad config , NoYes proc ) throws IOException { if ( verbose ) System . err . println ( \"secMgr:\" + secMgr + \" config:\" + config + \" proc:\" + proc ) ; if ( secMgr == NoYes . YES && System . getSecurityManager ( ) == null ) System . setSecurityManager ( new NoLoaderSecurityManager ( ) ) ; installConfigFile ( config ) ; processed . delete ( ) ; List < String > args = new ArrayList < String > ( ) ; if ( proc == NoYes . YES ) { args . add ( \"-processor\" ) ; args . add ( myName ) ; } args . add ( \"-processorpath\" ) ; args . add ( System . getProperty ( \"java.class.path\" ) ) ; args . add ( \"-d\" ) ; args . add ( \".\" ) ; JavacTool t = JavacTool . create ( ) ; MyDiagListener dl = new MyDiagListener ( ) ; PrintWriter out = new PrintWriter ( System . err , true ) ; StandardJavaFileManager fm = t . getStandardFileManager ( dl , null , null ) ; File file = new File ( System . getProperty ( \"test.src\" ) , myName + \".java\" ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays", "gt": ". asList ( file ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7820, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import org . apache . lucene . search . vectorhighlight . FieldQuery . QueryPhraseMap ; import org . apache . lucene . search . vectorhighlight . FieldTermStack . TermInfo ; public class FieldPhraseList { LinkedList < WeightedPhraseInfo > phraseList = new LinkedList < WeightedPhraseInfo > ( ) ; public FieldPhraseList ( FieldTermStack fieldTermStack , FieldQuery fieldQuery ) { final String field = fieldTermStack . getFieldName ( ) ; LinkedList < TermInfo > phraseCandidate = new LinkedList < TermInfo > ( ) ; QueryPhraseMap currMap = null ; QueryPhraseMap nextMap = null ; while ( ! fieldTermStack . isEmpty ( ) ) { phraseCandidate . clear ( ) ; TermInfo ti = fieldTermStack . pop ( ) ; currMap = fieldQuery . getFieldTermMap ( field , ti . getText ( ) ) ; if ( currMap == null ) continue ; phraseCandidate . add ( ti ) ; while ( true ) { ti = fieldTermStack . pop ( ) ; nextMap = null ; if ( ti != null ) nextMap = currMap . getTermMap ( ti . getText ( ) ) ; if ( ti == null || nextMap == null ) { if ( ti != null ) fieldTermStack . push ( ti ) ; if ( currMap . isValidTermOrPhrase ( phraseCandidate ) ) { addIfNoOverlap ( new WeightedPhraseInfo ( phraseCandidate , currMap . getBoost ( ) , currMap . getTermOrPhraseNumber ( ) ) ) ; } else { while ( phraseCandidate . size ( ) > 1 ) { fieldTermStack . push ( phraseCandidate . removeLast ( ) ) ; currMap = fieldQuery . searchPhrase ( field , phraseCandidate ) ; if ( currMap != null ) { addIfNoOverlap ( new WeightedPhraseInfo ( phraseCandidate , currMap . getBoost ( ) , currMap . getTermOrPhraseNumber ( ) ) ) ; break ; } } } break ; } else { phraseCandidate . add ( ti ) ; currMap = nextMap ; } } } } void addIfNoOverlap ( WeightedPhraseInfo wpi ) { for ( WeightedPhraseInfo existWpi : phraseList ) { if ( existWpi . isOffsetOverlap ( wpi ) ) return ; } phraseList . add ( wpi ) ; } public static class WeightedPhraseInfo { String text ; List < Toffs > termsOffsets ; float boost ; int seqnum ; public WeightedPhraseInfo ( LinkedList < TermInfo > terms , float boost ) { this ( terms , boost , 0 ) ; } public WeightedPhraseInfo ( LinkedList < TermInfo > terms , float boost , int number ) { this . boost = boost ; this . seqnum = number ; termsOffsets = new ArrayList < Toffs > ( terms . size ( ) ) ; TermInfo ti = terms . get ( 0 ) ; termsOffsets . add ( new Toffs ( ti . getStartOffset ( ) , ti . getEndOffset ( ) ) ) ; if ( terms . size ( ) == 1 ) { text = ti . getText ( ) ; return ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( ti . getText ( ) ) ; int pos = ti . getPosition ( ) ; for ( int i = 1 ; i < terms . size ( ) ; i ++ ) { ti = terms . get ( i ) ; sb . append ( ti . getText ( ) ) ; if (", "gt": "ti . getPosition ( ) - pos == 1 )", "prediction": ") ;\n", "label": 1}
{"id": 6148, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Prolog ; public class PrologImpl extends ReportAttributeImpl implements Prolog { protected PrologImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return", "gt": "ProjectPackage . eINSTANCE . getProlog ( ) ;", "prediction": "\n", "label": 0}
{"id": 7835, "input": "<s> package org . json ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; public class JSONTokener { private int index ; private Reader reader ; private char lastChar ; private boolean useLastChar ; public JSONTokener ( Reader reader ) { this . reader = reader . markSupported ( ) ? reader : new BufferedReader ( reader ) ; this . useLastChar = false ; this . index = 0 ; } public JSONTokener ( String s ) { this ( new StringReader ( s ) ) ; } public void back ( ) throws JSONException { if ( useLastChar || index <= 0 ) { throw new JSONException ( \"Stepping back two steps is not supported\" ) ; } index -= 1 ; useLastChar = true ; } public static int dehexchar ( char c ) { if ( c >= '0' && c <= '9' ) { return c - '0' ; } if ( c >= 'A' && c <= 'F' ) { return c - ( 'A' - 10 ) ; } if ( c >= 'a' && c <= 'f' ) { return c - ( 'a' - 10 ) ; } return - 1 ; } public boolean more ( ) throws JSONException { char nextChar = next ( ) ; if ( nextChar == 0 ) { return false ; } back ( ) ; return true ; } public char next ( ) throws JSONException { if ( this . useLastChar ) { this . useLastChar = false ; if ( this . lastChar != 0 ) { this . index += 1 ; } return this . lastChar ; } int c ; try { c = this . reader . read ( ) ; } catch ( IOException exc ) { throw new JSONException ( exc ) ; } if ( c <= 0 ) { this . lastChar = 0 ; return 0 ; } this . index += 1 ; this . lastChar = ( char ) c ; return this . lastChar ; } public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( \"Expected '\" + c + \"' and instead saw '\" + n + \"'\" ) ; } return n ; } public String next ( int n ) throws JSONException { if ( n == 0 ) { return \"\" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( \"Substring bounds error\" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; } public char nextClean ( ) throws JSONException { for ( ; ; ) { char c = next ( ) ; if ( c == 0 || c > ' ' ) { return c ; } } } public String nextString ( char quote ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case 0 : case '\\n' : case '\\r' : throw syntaxError ( \"Unterminated string\" ) ; case '\\\\' : c = next ( ) ; switch ( c ) { case 'b' : sb . append ( '\\b' ) ; break ; case 't' : sb . append ( '\\t' ) ; break ; case 'n' : sb . append ( '\\n' ) ; break ; case 'f' : sb . append ( '\\f' ) ; break ; case 'r' : sb . append ( '\\r' ) ; break ; case 'u' : sb . append ( ( char ) Integer . parseInt ( next ( 4 ) , 16 ) ) ; break ; case '\"' : case '\\'' : case '\\\\' : case '/' : sb . append ( c ) ; break ; default : throw syntaxError ( \"Illegal escape.\" ) ; } break ; default : if ( c == quote ) { return sb . toString ( ) ; } sb . append ( c ) ; } } } public String nextTo ( char d ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '\\n' || c == '\\r' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '\\n' || c == '\\r' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } public Object nextValue ( ) throws JSONException { char c = nextClean ( ) ; String s ; switch ( c ) { case '\"' : case '\\'' : return nextString ( c ) ; case '{' : back ( ) ; return new JSONObject ( this ) ; case '[' : case '(' : back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >= ' ' && \",:]}/\\\\\\\"[{;=#\" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = next ( ) ; } back ( ) ; s = sb", "gt": ". toString ( ) . trim ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3195, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NULLRecord extends Record { private static final long serialVersionUID = - 5796493183235216538L ; private byte [ ] data ; NULLRecord ( ) { } Record getObject ( ) { return new NULLRecord ( ) ; } public NULLRecord ( Name name , int dclass , long ttl , byte [ ] data ) { super ( name , Type . NULL , dclass , ttl ) ; if ( data . length > 0xFFFF ) { throw new IllegalArgumentException ( \"data must be <65536 bytes\" ) ; } this . data = data ; } void rrFromWire ( DNSInput in ) throws IOException { data = in . readByteArray ( ) ; } void rdataFromString ( Tokenizer st ,", "gt": "Name origin ) throws IOException", "prediction": ") ;\n", "label": 0}
{"id": 7842, "input": "<s> package litil . cg . ast ; import litil . ast . Type ; import java . util . List ; public class BcNode { public static final class DeclField extends BcNode { public final String name ; public final Type type ; public DeclField ( String name , Type type ) { this . name = name ; this . type = type ; } } public static final class InitField extends BcNode { public final String name ; public final Type type ; public final List < BcNode > bc ; public InitField ( String name , Type type ,", "gt": "List < BcNode > bc )", "prediction": ")\n", "label": 1}
{"id": 4616, "input": "<s> package org . ofbiz . webapp . event ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public interface EventHandler { public void init ( ServletContext context ) throws EventHandlerException ; public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse", "gt": "response ) throws EventHandlerException ;", "prediction": ") ;\n", "label": 0}
{"id": 7850, "input": "<s> package com . emf4sw . rdf ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . util . FeatureMap ; public interface RDFGraph extends URIElement { FeatureMap getNodes ( ) ; EList < Resource > getResources ( ) ; EList < Property > getProperties ( ) ; EList < BlankNode > getBlankNodes ( ) ; EList < Datatype > getDatatypes ( ) ; EList < Literal > getLiterals ( ) ; EList < Triple > getTriples ( ) ; boolean isEquivalentTo ( RDFGraph graph ) ; void add ( RDFGraph graph ) ; RDFGraph union ( RDFGraph graph ) ; RDFGraph diff ( RDFGraph graph ) ; Triple addTriple ( Node subject , Property property , Node object ) ; EList < SubjectNode > listSubjectsWithProperty ( Property property ) ; EList < SubjectNode > listSubjectsWithPropertyValue ( Property property , Node object ) ; EList < Triple > listAllTriples ( ) ; EList < Resource > listAllResources ( ) ; EList < Property > listAllProperties ( ) ; EList < SubjectNode > listSubjects ( ) ; Resource getResource ( String uri ) ; Property getProperty ( String uri ) ;", "gt": "Datatype getDatatype ( String uri ) ;", "prediction": "}\n", "label": 1}
{"id": 9676, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import org . eclipse . emf . ecore . EAnnotation ; import org . eclipse . gef . commands . Command ; import org . eclipse . gmf . runtime . common . core . command . ICompositeCommand ; import org . eclipse . gmf . runtime . diagram . core . commands . DeleteCommand ; import org . eclipse . gmf . runtime . emf . commands . core . command . CompositeTransactionalCommand ; import org . eclipse . gmf . runtime . emf . type . core . commands . DestroyElementCommand ; import org . eclipse . gmf . runtime . emf . type . core . requests . CreateElementRequest ; import org . eclipse . gmf . runtime . emf . type . core . requests . DestroyElementRequest ; import org . eclipse . gmf . runtime . notation . Node ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleChildReferenceCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleCompartmentCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleLabelNodeCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . commands . SimpleSubNodeCreateCommand ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleChildReferenceEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLabelNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry ; import org . msl . simple . gmfmap . simplemappings . diagram . providers . SimplemapElementTypes ; public class SimpleTopNodeItemSemanticEditPolicy extends SimplemapBaseItemSemanticEditPolicy { public SimpleTopNodeItemSemanticEditPolicy ( ) { super ( SimplemapElementTypes . SimpleTopNode_1001 ) ; } protected Command getCreateCommand ( CreateElementRequest req ) { if ( SimplemapElementTypes . SimpleLabelNode_2001 == req . getElementType ( ) ) { return getGEFWrapper ( new SimpleLabelNodeCreateCommand ( req ) ) ; } if ( SimplemapElementTypes .", "gt": "SimpleCompartment_2002 == req . getElementType ( ) )", "prediction": "get ( ) ;\n", "label": 0}
{"id": 7862, "input": "<s> package com . primitive2d ; import processing . core . PApplet ; import com . datatype . Point ; import com . datatype . DCHalfEdge ; public class Line extends DCHalfEdge implements Drawable { public float strokeWeight = 1 ; public Line ( Point start , Point end ) { super ( start , end ) ; } public Line ( double startX , double startY , double endX , double endY ) { super ( new Point ( startX , startY ) , new Point ( endX , endY ) ) ; } public Line ( Point origin , double radius , double theta ) { super ( origin . copy ( ) , radius , theta ) ; } public void draw ( PApplet parent , float strokeWeight ) { parent . strokeWeight ( strokeWeight ) ; parent . line ( ( float ) start . getX ( ) , ( float ) start . getY ( ) , ( float ) end . getX ( ) , ( float ) end . getY ( ) ) ; } public void print ( PApplet parent , float strokeWeight ) { } public void moveTo ( double x , double y ) { this . start . moveTo ( x , y", "gt": ", this . start ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2898, "input": "<s> package org . ofbiz . webapp . view ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import jimm . datavision . Report ; import jimm . datavision . UserCancellationException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . webapp . control . ContextFilter ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . jdbc . ConnectionFactory ; public class DataVisionViewHandler extends AbstractViewHandler { public static final String module = DataVisionViewHandler . class . getName ( ) ; protected ServletContext context ; public void init ( ServletContext context ) throws ViewHandlerException { this . context = context ; } public void render ( String name , String page , String info , String contentType , String encoding , HttpServletRequest request , HttpServletResponse response ) throws ViewHandlerException { if ( request == null ) { throw new ViewHandlerException ( \"The HttpServletRequest object was null, how did that happen?\" ) ; } if ( UtilValidate . isEmpty ( page ) ) { throw new ViewHandlerException ( \"View page was null or empty, but must be specified\" ) ; } if ( UtilValidate . isEmpty ( info ) ) { throw new ViewHandlerException ( \"View fnfo string was null or empty, but must be used to specify an Entity that is mapped to the Entity Engine datasource that the report will use.\" ) ; } request . setAttribute ( ContextFilter . FORWARDED_FROM_SERVLET , Boolean . TRUE ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; if ( delegator == null ) { throw new ViewHandlerException ( \"The delegator object was null, how did that happen?\" ) ; } try { String datasourceName = delegator . getEntityHelperName ( info ) ; Report report = new Report ( ) ; report . setDatabaseConnection ( ConnectionFactory . getConnection ( datasourceName ) ) ; Debug . logInfo ( \"before reading file\" , module ) ; report . read ( new File ( context . getRealPath ( page ) ) ) ; Debug . logInfo ( \"before set layout engine\" , module ) ; report . setLayoutEngine ( new jimm . datavision . layout . HTMLLE ( response . getWriter ( ) ) ) ; Debug . logInfo ( \"before run report\" , module ) ; report . runReport ( ) ; Debug . logInfo ( \"after run report, end\" , module ) ; } catch ( UserCancellationException e ) { throw new ViewHandlerException ( \"User cancelled report\" , e ) ; } catch ( FileNotFoundException e ) { throw new ViewHandlerException ( \"Report file not found [\" + page + \"]\" , e ) ; } catch ( IOException ie ) { throw new ViewHandlerException ( \"IO Error", "gt": "in region\" , ie ) ;", "prediction": ") ;\n", "label": 0}
{"id": 7871, "input": "<s> package io . beancounter . jmspublisher . process ; import io . beancounter . commons . model . notifies . Notify ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import it . rainet . portal . cms . client . integration . lightstreamer . LightstreamerDTO ; import io . beancounter . commons . model . activity . Object ; import io . beancounter . commons . model . activity . ResolvedActivity ; import io . beancounter . commons . model . activity . rai . Comment ; public class ActivityToJmsConverter { public static final String TYPE = \"BC\" ; private static final Logger LOG = LoggerFactory . getLogger ( ActivityToJmsConverter . class ) ; public LightstreamerDTO wrapResolvedActivityInExternalObject ( ResolvedActivity resolvedActivity , String json ) { LOG . debug ( \"Converting activity: {}\" , json ) ; Object object = resolvedActivity . getActivity ( ) . getObject ( ) ; if ( object instanceof Comment ) { Comment", "gt": "comment = ( Comment ) object ;", "prediction": ";\n", "label": 1}
{"id": 8584, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . engine . client . utils . IRegExpUtils ; import org . gk . ui . client . com . grid . column . gkSpinnerColumnConfig ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . SpinnerField ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; import com . google . gwt . i18n . client . NumberFormat ; public class GSpinnerFieldBuilder extends GridFieldBuilder { public GSpinnerFieldBuilder ( String spin ) { super ( spin ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; ColumnConfig cc = new gkSpinnerColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ; } @ Override public Field createField ( ) { int maxDecimalLength = 0 ; String numType = x . getAttribute ( \"numType\" , \"\" ) ; String inc = x . getAttribute ( \"inc\" , \"\" ) ; String maxValue = x . getAttribute ( \"maxValue\" , \"\" ) ; String minValue = x . getAttribute ( \"minValue\" , \"\" ) ; String value = x . getValue ( ) ; String format = x . getFormat ( ) ; SpinnerField sf = new SpinnerField ( ) { @ Override public void focus ( ) { if ( rendered ) { getFocusEl ( ) . focus ( ) ; onFocus ( new FieldEvent ( this ) ) ; } if ( ! hasFocus ) { fireEvent ( Events . Focus ) ; } } @ Override public void setFieldLabel ( String fieldLabel ) { super . setFieldLabel ( fieldLabel ) ; setHeader ( fieldLabel ) ; } @ Override protected void blur ( ) { if ( rendered ) { getFocusEl ( ) . blur ( ) ; } if ( hasFocus ) { fireEvent ( Events . Blur ) ; hasFocus = false ; } } } ; if ( ! numType . equals ( \"\" ) ) { sf . getPropertyEditor ( ) . setType ( getNumberType ( numType ) ) ; } if ( inc . matches ( IRegExpUtils . FLOAT ) ) { sf . setIncrement ( Double . parseDouble ( inc ) ) ; maxDecimalLength = getMaxDecLength ( inc , maxDecimalLength ) ; } if ( maxValue . matches ( IRegExpUtils . FLOAT ) ) { sf . setMaxValue ( Double . parseDouble ( maxValue ) ) ; maxDecimalLength = getMaxDecLength ( maxValue , maxDecimalLength ) ; }", "gt": "if ( minValue . matches ( IRegExpUtils . FLOAT ) )", "prediction": "}\n", "label": 0}
{"id": 7878, "input": "<s> package org . restlet . ext . sip . internal ; import org . restlet . data . Parameter ; import org . restlet . engine . header . HeaderWriter ; import org . restlet . ext . sip . Subscription ; public class SubscriptionWriter extends HeaderWriter < Subscription > { public static String write ( Subscription subscription ) { return new SubscriptionWriter ( ) . append ( subscription ) . toString ( ) ; } @ Override public HeaderWriter < Subscription > append ( Subscription value ) { append ( value . getValue ( ) ) ; if ( value . getReason ( ) != null ) { appendParameterSeparator ( ) ; appendExtension ( \"reason\" , value . getReason ( ) ) ; } if ( value . getExpires", "gt": "( ) > 0 )", "prediction": "( ) ) ;\n", "label": 1}
{"id": 8887, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . ReflectiveItemProviderAdapterFactory ; import org . eclipse . emf . edit . provider . resource . ResourceItemProviderAdapterFactory ; import org . eclipse . emf . edit . ui . provider . ExtendedImageRegistry ; import org . eclipse . gmf . gmfgraph . provider . GMFGraphItemProviderAdapterFactory ; import org . eclipse . gmf . mappings . provider . GMFMapItemProviderAdapterFactory ; import org . eclipse . gmf . runtime . diagram . core . preferences . PreferencesHint ; import org . eclipse . gmf . tooldef . provider . GMFToolItemProviderAdapterFactory ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . msl . simple . gmfmap . simplemappings . diagram . providers . ElementInitializers ; import org . msl . simple . gmfmap . simplemappings . provider . SimplemappingsItemProviderAdapterFactory ; import org . osgi . framework . BundleContext ; public class SimplemapDiagramEditorPlugin extends AbstractUIPlugin { public static final String ID = \"org.msl.simple.gmfmap.diagram\" ; public static final PreferencesHint DIAGRAM_PREFERENCES_HINT = new PreferencesHint ( ID ) ; private static SimplemapDiagramEditorPlugin instance ; private ComposedAdapterFactory adapterFactory ; private SimplemapDocumentProvider documentProvider ; private ElementInitializers initializers ; public SimplemapDiagramEditorPlugin ( ) { } public void start ( BundleContext context ) throws Exception { super . start ( context ) ; instance = this ; PreferencesHint . registerPreferenceStore ( DIAGRAM_PREFERENCES_HINT , getPreferenceStore ( ) ) ; adapterFactory = createAdapterFactory ( ) ; } public void stop ( BundleContext context ) throws Exception { adapterFactory . dispose ( ) ; adapterFactory = null ; initializers = null ; instance = null ; super . stop ( context ) ; } public static SimplemapDiagramEditorPlugin getInstance ( ) { return instance ; } protected ComposedAdapterFactory createAdapterFactory ( ) { ArrayList < AdapterFactory > factories = new ArrayList < AdapterFactory > ( ) ; fillItemProviderFactories ( factories ) ; ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory ( ComposedAdapterFactory . Descriptor . Registry . INSTANCE ) ; for ( AdapterFactory factory : factories ) composedAdapterFactory . addAdapterFactory ( factory ) ; return composedAdapterFactory ; } protected void fillItemProviderFactories ( List < AdapterFactory > factories ) { factories . add ( new SimplemappingsItemProviderAdapterFactory ( ) ) ; factories . add ( new GMFGraphItemProviderAdapterFactory ( ) ) ; factories . add ( new GMFMapItemProviderAdapterFactory ( ) ) ; factories . add ( new GMFToolItemProviderAdapterFactory ( ) ) ; factories . add ( new ResourceItemProviderAdapterFactory ( ) ) ; factories . add ( new ReflectiveItemProviderAdapterFactory ( ) ) ; } public AdapterFactory getItemProvidersAdapterFactory ( ) { return adapterFactory ; } public String getItemLabel ( Object item ) { IItemLabelProvider labelProvider = ( IItemLabelProvider ) adapterFactory . adapt ( item , IItemLabelProvider . class ) ; if ( labelProvider != null ) { return labelProvider . getText ( item ) ; } return null ; } public ImageDescriptor getItemImageDescriptor ( Object item ) { IItemLabelProvider labelProvider = ( IItemLabelProvider ) adapterFactory . adapt ( item , IItemLabelProvider . class ) ; if ( labelProvider != null ) { return ExtendedImageRegistry . getInstance ( ) . getImageDescriptor ( labelProvider . getImage ( item ) ) ; } return null ; } public Image getImage ( Object item ) { IItemLabelProvider labelProvider = ( IItemLabelProvider ) adapterFactory . adapt ( item , IItemLabelProvider . class ) ; if ( labelProvider != null ) { return ExtendedImageRegistry . getInstance ( ) . getImage ( labelProvider . getImage ( item ) ) ; } return null ; } public static ImageDescriptor getBundledImageDescriptor ( String path ) { return AbstractUIPlugin . imageDescriptorFromPlugin ( ID , path ) ; } public static ImageDescriptor findImageDescriptor ( String path ) { final IPath p = new Path ( path ) ; if ( p . isAbsolute ( ) && p . segmentCount ( ) > 1 ) { return AbstractUIPlugin . imageDescriptorFromPlugin ( p . segment ( 0 ) , p . removeFirstSegments ( 1 ) . makeAbsolute ( ) . toString ( ) ) ; } else { return getBundledImageDescriptor ( p . makeAbsolute ( ) . toString ( ) ) ; } } public Image getBundledImage ( String path ) { Image image = getImageRegistry ( ) . get ( path ) ; if ( image == null ) { getImageRegistry ( ) . put ( path , getBundledImageDescriptor ( path ) ) ; image = getImageRegistry ( ) . get ( path ) ; } return image ; } public static String getString ( String key ) { return Platform . getResourceString ( getInstance ( ) . getBundle ( ) , \"%\" + key ) ; } public SimplemapDocumentProvider getDocumentProvider ( ) { if ( documentProvider == null ) { documentProvider = new SimplemapDocumentProvider ( ) ; } return documentProvider ; } public ElementInitializers getElementInitializers ( ) { return initializers ; } public void", "gt": "setElementInitializers ( ElementInitializers i )", "prediction": "( )\n", "label": 0}
{"id": 7880, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; import java . awt . image . BufferedImage ; import java . awt . image . DataBuffer ; import java . awt . image . WritableRaster ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . ViewPanel ; import fr . inria . zvtm . engine . VirtualSpaceManager ; public abstract class Lens { public static float MM_FLOOR = 0.001f ; protected ViewPanel owningView ; public int w ; public int h ; public int sw ; public int sh ; public int mbw ; float hmbw ; public int mbh ; float hmbh ; public int lx = 0 ; public int ly = 0 ; boolean initialized = false ; public int lensWidth = 0 ; public int lensHeight = 0 ; public BufferedImage mbi ; public Graphics2D magnifiedGraphics ; int imageType = BufferedImage . TYPE_INT_ARGB_PRE ; int transferType = DataBuffer . TYPE_INT ; int [ ] oPixelsI , mPixelsI , tPixelsI ; short [ ] oPixelsS , mPixelsS , tPixelsS ; byte [ ] oPixelsB , mPixelsB , tPixelsB ; float [ ] gain = new float [ 2 ] ; int [ ] lurd = new int [ 4 ] ; public volatile float MM = 2.0f ; protected float mSwitchThreshold = 1.0f ; public abstract void setLensBuffer ( ViewPanel p ) ; public abstract void gf ( float x , float y , float [ ] g ) ; public void setMaximumMagnification ( float mm ) { setMaximumMagnification ( mm , true ) ; } public void setMaximumMagnification ( float mm , boolean forceRaster ) { this . MM = mm ; updateMagBufferWorkingDimensions ( ) ; if ( forceRaster ) { setMagRasterDimensions ( mbw , mbh ) ; } owningView . parent . repaint ( ) ; } public float getMaximumMagnification ( ) { return this . MM ; } public float getActualMaximumMagnification ( ) { return this . MM ; } public void setBufferThreshold ( float t ) { this . mSwitchThreshold = t ; owningView . parent . repaint ( ) ; } public float getBufferThreshold ( ) { return this . mSwitchThreshold ; } void initBuffers ( int mainBufferSize , int magBufferSize ) { switch ( transferType ) { case DataBuffer . TYPE_INT : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_USHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_BYTE : { oPixelsB = new byte [ mainBufferSize ] ; mPixelsB = new byte [ magBufferSize ] ; tPixelsB = new byte [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_SHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } default : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } } } public boolean isInitialized ( ) { return initialized ; } public void transform ( BufferedImage sbi ) { try { switch ( transferType ) { case DataBuffer . TYPE_INT : { transformI ( sbi . getRaster ( ) , mbi . getRaster ( ) ) ; break ; } case DataBuffer . TYPE_USHORT : { transformS ( sbi . getRaster ( ) , mbi . getRaster ( ) ) ; break ; } case DataBuffer . TYPE_BYTE : { transformB ( sbi . getRaster ( ) , mbi . getRaster ( ) ) ; break ; } case DataBuffer . TYPE_SHORT : { transformS ( sbi . getRaster ( ) , mbi . getRaster ( ) ) ; break ; } default : { transformI ( sbi . getRaster ( ) , mbi . getRaster ( ) ) ; break ; } } } catch ( Exception ex ) { if ( VirtualSpaceManager . debugModeON ( ) ) { System . err . println ( \"Lens error probably due to an unsupported screen color depth.\" ) ; ex . printStackTrace ( ) ; } } } abstract void transformI ( WritableRaster iwr , WritableRaster ewr ) ; abstract void transformS ( WritableRaster iwr , WritableRaster ewr ) ; abstract void transformB ( WritableRaster iwr , WritableRaster ewr ) ; public abstract void setAbsolutePosition ( int ax , int ay ) ; public abstract int getRadius ( ) ; void updateMagBufferWorkingDimensions ( ) { hmbw = getRadius ( ) * MM ; hmbh = getRadius ( ) * MM ; mbw = Math . round ( 2 * hmbw ) ; mbh = Math . round ( 2 * hmbh ) ; } public void setMagRasterDimensions ( int size ) { setMagRasterDimensions ( size , size ) ; } public void setMagRasterDimensions ( int w , int h ) { switch ( transferType ) { case DataBuffer . TYPE_INT : { mPixelsI = new int [ w * h ] ; break ; } case DataBuffer . TYPE_USHORT : { mPixelsS = new short [ w * h ] ; break ; } case DataBuffer . TYPE_BYTE : { mPixelsB = new byte [ w * h ] ; break ; } case DataBuffer . TYPE_SHORT : {", "gt": "mPixelsS = new short [ w * h ] ;", "prediction": ";\n", "label": 1}
{"id": 1116, "input": "<s> import java . util . * ; class UncheckedFilename2 { List", "gt": "< String > list = new ArrayList ( ) ;", "prediction": ";\n", "label": 0}
{"id": 7882, "input": "<s> package com . yahoo . ycsb ; public class WorkloadException extends Exception { private static final long serialVersionUID = 8844396756042772132L ; public WorkloadException ( String message ) { super ( message ) ; } public WorkloadException ( ) { super ( ) ; } public", "gt": "WorkloadException ( String message , Throwable cause )", "prediction": "}\n", "label": 1}
{"id": 7592, "input": "<s> package org . parboiled . buffers ; import org . parboiled . common . IntArrayStack ; import org . parboiled . support . Chars ; import org . parboiled . support . IndexRange ; import org . parboiled . support . Position ; import java . util . Arrays ; import static org . parboiled . common . Preconditions . checkArgNotNull ; import static org . parboiled . common . Preconditions . checkArgument ; public class DefaultInputBuffer implements InputBuffer { private final int length ; private final char [ ] buffer ; private int [ ] newlines ; public DefaultInputBuffer ( char [ ] buffer ) { checkArgNotNull ( buffer , \"buffer\" ) ; this . buffer = buffer ; this . length = buffer . length ; } public char charAt ( int index ) { return 0 <= index && index < length ? buffer [ index ] : Chars . EOI ; } public boolean test ( int index , char [ ] characters ) { int len = characters . length ; if ( index < 0 || index > length - len ) { return false ; } for ( int i = 0 ; i < len ; i ++ ) { if ( buffer [ index + i ] != characters [ i ] ) return false ; } return true ; } public String extract ( int start , int end ) { if ( start < 0 ) start = 0 ; if ( end >= length ) end = length ; if ( end <= start ) return \"\" ; return new String ( buffer , start , end - start ) ; } public String extract ( IndexRange range ) { return new String ( buffer , range . start , Math . min ( range . end , length ) - range . start ) ; } public Position getPosition ( int index ) { buildNewlines ( ) ; int line = getLine0 ( newlines , index ) ; int column = index - ( line > 0 ? newlines [ line - 1 ] : - 1 ) ; return new Position ( line + 1 , column ) ; } public int getOriginalIndex ( int index ) { return index ; } private static int getLine0 ( int [ ] newlines , int index ) { int j = Arrays . binarySearch ( newlines , index ) ; return j >= 0 ? j : - ( j + 1 ) ; } public String extractLine ( int lineNumber ) { buildNewlines ( ) ; checkArgument ( 0 < lineNumber && lineNumber <= newlines . length + 1 ) ; int start = lineNumber > 1 ? newlines [ lineNumber", "gt": "- 2 ] + 1 : 0 ;", "prediction": ";\n", "label": 0}
{"id": 7887, "input": "<s> package org . nuxeo . ecm . automation . core . mail ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . activation . DataSource ; import org . nuxeo . ecm . core . api . Blob ; public class BlobDataSource implements DataSource { protected final Blob blob ; public BlobDataSource ( Blob blob ) { this . blob = blob ; } public String getContentType ( ) { return blob . getMimeType ( ) ; } public InputStream getInputStream ( ) throws IOException { return blob . getStream ( ) ; } public String getName ( ) {", "gt": "return blob . getFilename ( ) ;", "prediction": "\n", "label": 1}
{"id": 9796, "input": "<s> package org . ofbiz . webapp . taglib ; import java . util . Map ; import javax . servlet . jsp . JspTagException ; import javax . servlet . jsp . tagext . TagSupport ; import javolution . util . FastMap ; @ SuppressWarnings ( \"serial\" ) public abstract class AbstractParameterTag extends TagSupport { private Map < String , Object > inParameters = null ; private Map < String , String > outParameters = null ; public void addInParameter ( String name , Object value ) { if ( this . inParameters == null ) this . inParameters = FastMap . newInstance ( ) ; inParameters . put ( name , value ) ; } public Map < String , Object > getInParameters ( ) { if ( this . inParameters == null ) return FastMap . newInstance ( ) ; else return this . inParameters ; } public void addOutParameter ( Object name , Object alias ) { if ( this . outParameters == null ) this . outParameters = FastMap . newInstance ( ) ; outParameters . put ( ( String ) name , ( String ) alias ) ; } public Map < String , String > getOutParameters ( ) { if ( this . outParameters == null ) return FastMap . newInstance ( ) ; else return this . outParameters ; } @ Override", "gt": "public int doStartTag ( ) throws JspTagException", "prediction": ";\n", "label": 0}
{"id": 7901, "input": "<s> package org . eclipse . swt . accessibility ; public abstract class AccessibleControlAdapter implements AccessibleControlListener { public void getChildAtPoint ( AccessibleControlEvent e ) { } public void getLocation ( AccessibleControlEvent e ) { } public void getChild ( AccessibleControlEvent e ) { } public void getChildCount ( AccessibleControlEvent e ) { } public void getDefaultAction ( AccessibleControlEvent e ) { } public void", "gt": "getFocus ( AccessibleControlEvent e )", "prediction": "( )\n", "label": 1}
{"id": 5597, "input": "<s> package com . nesscomputing . hbase ; import org . skife . config . Config ; import org . skife . config . Default ; public abstract class HBaseConfig { @ Config ( \"ness.hbase.zookeeper.quorum\" ) public abstract String getHBaseZookeeperQuorum ( ) ; @ Config ( \"ness.hbase.zookeeper.path\" ) @ Default ( \"/hbase\" )", "gt": "public String getHBaseZookeeperPath ( )", "prediction": ";\n", "label": 0}
{"id": 7918, "input": "<s> package org . eclipse . ui . tests . compare ; import java . util . Iterator ; import junit . framework . TestCase ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . help . WorkbenchHelp ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . tests . dialogs . PreferenceDialogWrapper ; import org . eclipse . ui . tests . harness . util . DialogCheck ; public class UIComparePreferencesAuto extends TestCase { public UIComparePreferencesAuto ( String name ) { super ( name ) ; } protected Shell getShell ( ) { return DialogCheck . getShell ( ) ; } private PreferenceDialog getPreferenceDialog ( String id ) {", "gt": "PreferenceDialogWrapper dialog = null ;", "prediction": "\n", "label": 1}
{"id": 7248, "input": "<s> package com . redhat . ceylon . compiler . java . test . interop ; abstract class Class < T > { public abstract T classMethod ( T t ) ; } interface Interface < T > { public T interfaceMethod ( T t ) ; } public class JavaVariance extends Class < Class < ? > > implements Interface < Interface < ? > > { @ Override public Interface < ? > interfaceMethod ( Interface < ? > t ) { return null ; } @ Override public Class < ? > classMethod ( Class < ? > t ) { return null ; } public < T extends Class < ? > > T method ( T t ) { return t ; }", "gt": "public final Class < ? > roField = null ;", "prediction": "}\n", "label": 0}
{"id": 7943, "input": "<s> package org . agoncal . book . javaee7 . chapter19 ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAttribute ; @ XmlAccessorType ( XmlAccessType . FIELD ) public class Customer { @ XmlAttribute ( name = \"first_name\" ) private String firstName ; @ XmlAttribute ( name = \"last_name\" ) private String lastName ; private String email ; private String phoneNumber ; public Customer ( ) { } public Customer ( String firstName , String lastName , String email , String phoneNumber ) { this . firstName = firstName ; this . lastName = lastName ; this . email = email ; this", "gt": ". phoneNumber = phoneNumber ;", "prediction": ";\n", "label": 1}
{"id": 6788, "input": "<s> package org . ofbiz . minilang . method ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . SimpleMethod ; import org . w3c . dom . Element ; public final class FieldObject < T > extends MethodObject < T > { private final FlexibleMapAccessor < Object > fieldFma ; private final String type ; public FieldObject ( Element element , SimpleMethod simpleMethod ) { super ( element , simpleMethod ) ; this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; String typeAttribute = element . getAttribute ( \"type\" ) ; if ( typeAttribute . isEmpty ( ) ) { this . type = \"java.lang.String\" ; } else { this . type = typeAttribute ; } } @ SuppressWarnings ( \"unchecked\" ) @ Override public T getObject ( MethodContext methodContext ) { return ( T ) this . fieldFma . get ( methodContext . getEnvMap ( ) ) ; } @ Override public Class < T > getTypeClass ( MethodContext methodContext ) throws ClassNotFoundException { return UtilGenerics . cast ( ObjectType . loadClass ( this . type , methodContext . getLoader ( ) ) ) ; } @ Override public String getTypeName ( ) {", "gt": "return this . type ;", "prediction": "\n", "label": 0}
{"id": 7951, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Mockito . mock ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionListener ; public class ToolItem_Test extends TestCase { private Display display ; private Shell shell ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testText ( ) { ToolBar toolbar = new ToolBar ( shell , SWT . NONE ) ; ToolItem item = new ToolItem ( toolbar , SWT . NONE ) ; ToolItem separator = new ToolItem ( toolbar , SWT . SEPARATOR ) ; String text0 = \"text0\" ; String text1 = \"text1\" ; item . setText ( text0 ) ; assertEquals ( text0 , item . getText ( ) ) ; item . setText ( text1 ) ; assertEquals ( text1 , item . getText ( ) ) ; assertEquals ( \"\" , separator . getText ( ) ) ; separator . setText ( text1 ) ; assertEquals ( \"\" , separator . getText ( ) ) ; } public void testImage ( ) { ToolBar toolbar = new ToolBar ( shell , SWT . NONE ) ; ToolItem item = new ToolItem ( toolbar , SWT . NONE ) ; item . setImage ( null ) ; assertEquals ( null , item . getImage ( ) ) ; } public void testEnabled ( ) { ToolBar toolbar = new ToolBar ( shell , SWT . NONE ) ; ToolItem item = new ToolItem ( toolbar , SWT . NONE ) ; ToolItem separator = new ToolItem ( toolbar , SWT . SEPARATOR ) ; separator . setControl ( new Text ( toolbar , SWT . NONE ) ) ; assertEquals ( true , item . getEnabled ( ) ) ; toolbar . setEnabled ( false ) ; item . setEnabled ( true ) ; assertEquals ( true , item . getEnabled ( ) ) ; assertEquals ( false , item . isEnabled ( ) ) ; toolbar . setEnabled ( false ) ; item . setEnabled ( false ) ; assertEquals ( false , item . getEnabled ( ) ) ; assertEquals ( false , item . isEnabled ( ) ) ; separator . setEnabled ( false ) ; assertEquals ( true , separator . getControl ( ) . getEnabled ( ) ) ; } public void testSeparatorWithControl ( ) { ToolBar toolbar = new ToolBar ( shell , SWT . NONE ) ; ToolItem item = new ToolItem ( toolbar , SWT . NONE ) ; ToolItem separator = new ToolItem ( toolbar , SWT . SEPARATOR ) ; separator . setControl ( new Text ( toolbar , SWT . NONE ) ) ; item . setControl ( new Text ( toolbar , SWT . NONE ) ) ; assertEquals ( null , item . getControl ( ) ) ; Control control = new Text ( toolbar , SWT . NONE ) ; separator . setControl ( control ) ; assertSame ( control , separator . getControl ( ) ) ; separator . setControl ( null ) ; assertEquals ( null , separator . getControl ( ) ) ; Control currentControl = new Text ( toolbar , SWT . NONE ) ; separator . setControl ( currentControl ) ; Control diposedControl = new Text ( toolbar , SWT . NONE ) ; diposedControl . dispose ( ) ; try { separator . setControl ( diposedControl ) ; fail ( \"Must not allow to set", "gt": "diposed control in setControl\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6159, "input": "<s> package com . farpost . ldt ; import org . testng . annotations . Test ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . equalTo ; public class TimeFrameInterruptionStrategyTest { @ Test ( expectedExceptions = { IllegalArgumentException . class } ) public void shoulfGenerateExceptionOnNegativeTime ( ) { new TimeFrameInterruptionStrategy ( - 1 ) ; } @ Test ( expectedExceptions = { IllegalArgumentException . class } ) public void shoulfGenerateExceptionOnZeroTime ( ) { new TimeFrameInterruptionStrategy ( 0 ) ; } @ Test public void shouldInterruptWhenExecutionTimeSumReachesGivenValue ( ) { TestInterruptionStrategy strategy = new TimeFrameInterruptionStrategy ( 6000 ) ; assertThat ( strategy . shouldContinue ( 3000000 ) , equalTo ( true ) ) ; assertThat ( strategy . shouldContinue ( 2000000 ) , equalTo ( true ) ) ; assertThat ( strategy . shouldContinue ( 2000000 ) , equalTo ( false ) ) ; } @ Test public void shouldInterruptTestEvenIfItIsCompleteVeryQuickly ( ) { TestInterruptionStrategy strategy = new TimeFrameInterruptionStrategy ( 1 ) ; assertThat ( strategy . shouldContinue ( 486 ) , equalTo ( true ) ) ; assertThat ( strategy . shouldContinue ( 535 ) , equalTo", "gt": "( false ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 7956, "input": "<s> package org . seage . reasoning . algparams . dummy ; import org . seage . aal . reporter . AlgorithmReport ; import org . seage . reasoning . algparams . Policy ; import org . seage . reasoning . algparams . Policy . Attribute ; import org . seage . reasoning . algparams . Reasoner ; import org . seage . aal . reporter . AlgorithmReportEvaluator ; public class DummyReasoner extends Reasoner { public DummyReasoner", "gt": "( Attribute [ ] atts , AlgorithmReportEvaluator re )", "prediction": ";\n", "label": 1}
{"id": 9963, "input": "<s> package com . sun . tools . doclets . internal . toolkit . taglets ; import com . sun . javadoc . * ; public interface Taglet { public abstract boolean inField ( ) ; public abstract boolean inConstructor ( ) ; public abstract boolean inMethod ( ) ; public abstract boolean inOverview ( ) ; public abstract boolean inPackage ( ) ; public abstract boolean inType ( ) ; public abstract boolean isInlineTag ( ) ; public abstract String getName ( ) ; public abstract TagletOutput getTagletOutput ( Tag tag , TagletWriter writer ) throws IllegalArgumentException ; public abstract TagletOutput getTagletOutput ( Doc holder , TagletWriter", "gt": "writer ) throws IllegalArgumentException ;", "prediction": ") ;\n", "label": 0}
{"id": 7959, "input": "<s> package org . restlet . example . tutorial ; import org . restlet . resource . ClientResource ; public class Part02a_RetrieveContent { public static void main ( String [ ] args ) throws Exception { new ClientResource ( \"http://www.restlet.org\" ) . get ( ) . write", "gt": "( System . out ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4663, "input": "<s> class DiamondNonGeneric { String s = new String <", "gt": "> ( \"foo\" ) ;", "prediction": ";\n", "label": 0}
{"id": 7973, "input": "<s> package org . restlet . ext . jaxrs . internal . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . SortedMap ; import java . util . TreeMap ; import org . restlet . data . Language ; import org . restlet . data . MediaType ; import org . restlet . data . Metadata ; import org . restlet . data . Preference ; public class SortedMetadata < T extends Metadata > implements Iterable < T > { @ SuppressWarnings ( \"hiding\" ) private class IteratorIterator < T extends Metadata > implements Iterator < T > { private final Iterator < Iterable < T > > iterIter ; private Iterator < T > iter ; IteratorIterator ( Iterator < Iterable < T > > iterIter ) { this . iterIter = iterIter ; } public boolean hasNext ( ) { if ( ( this . iter != null ) && this . iter . hasNext ( ) ) { return true ; } while ( this . iterIter . hasNext ( ) ) { final Iterable < T > iterable = this . iterIter . next ( ) ; if ( iterable != null ) { this . iter = iterable . iterator ( ) ; if ( this . iter . hasNext ( ) ) { return true ; } } } return false ; } public T next ( ) { if ( this . hasNext ( ) ) { return this . iter . next ( ) ; } throw new NoSuchElementException ( ) ; } public void remove ( ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( ) ; } } public static SortedMetadata < MediaType > get ( MediaType respMediaType ) { return new SortedMetadata < MediaType > ( Collections . singleton ( new Preference < MediaType > ( respMediaType ) ) ) ; } public static SortedMetadata < MediaType > getEmptyMediaTypes ( ) { return new SortedMetadata < MediaType > ( new ArrayList < Collection < MediaType > > ( ) ) ; } public static SortedMetadata < Language > getForLanguages ( Collection < Preference < Language > > preferences ) { return new SortedMetadata < Language > ( preferences ) ; } public static SortedMetadata < MediaType > getForMediaTypes ( Collection < Preference < MediaType > > preferences ) { if ( preferences . isEmpty ( ) ) { return new SortedMetadata < MediaType > ( Collections . singletonList ( ( Collection < MediaType > ) Collections . singletonList ( MediaType . ALL ) ) ) ; } return new SortedMetadata < MediaType > ( preferences ) ; } public static SortedMetadata < MediaType > getMediaTypeAll ( ) { return new SortedMetadata < MediaType > ( Collections . singletonList ( Util . createColl ( MediaType . ALL ) ) ) ; } public static SortedMetadata < MediaType > singleton ( MediaType mediaType ) { return new SortedMetadata < MediaType > ( Collections . singletonList ( Util . createColl ( mediaType ) ) ) ; } private final List < Collection < T > > metadatas ; @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) private SortedMetadata ( Collection < Preference < T > > preferences ) { SortedMap < Float , Collection < T > > map = new TreeMap < Float , Collection < T", "gt": "> > ( Collections . reverseOrder ( ) ) ;", "prediction": ";\n", "label": 1}
{"id": 9080, "input": "<s> import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import com . sun . tools . classfile . AccessFlags ; import com . sun . tools . classfile . ClassFile ; import com . sun . tools . classfile . ConstantPoolException ; import com . sun . tools . classfile . Method ; import java . util . Comparator ; import java . util . Set ; import java . util . TreeSet ; public class FindNativeFiles { public static void main ( String [ ] args ) throws IOException , ConstantPoolException { new FindNativeFiles ( ) . run ( args ) ; } public void run ( String [ ] args ) throws IOException , ConstantPoolException { JarFile jar = new JarFile ( args [ 0 ] ) ; Set < JarEntry > entries = getNativeClasses ( jar ) ; for ( JarEntry e : entries ) { String name = e . getName ( ) ; String className = name . substring ( 0 , name . length ( ) - 6 ) . replace ( \"/\" , \".\" ) ; System . out . println ( className ) ; } } Set < JarEntry > getNativeClasses ( JarFile jar ) throws IOException , ConstantPoolException { Set < JarEntry > results = new TreeSet < JarEntry > ( new Comparator < JarEntry > ( ) { public int compare ( JarEntry o1 , JarEntry o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ; Enumeration < JarEntry > e = jar . entries ( ) ; while ( e . hasMoreElements ( ) ) { JarEntry je = e . nextElement ( ) ; if ( isNativeClass ( jar , je ) ) results . add ( je ) ; } return results ; } boolean isNativeClass ( JarFile jar , JarEntry entry ) throws IOException , ConstantPoolException { String name = entry . getName ( ) ; if ( name . startsWith ( \"META-INF\" ) || ! name . endsWith ( \".class\" ) ) return false ; InputStream in = jar . getInputStream ( entry ) ; ClassFile cf = ClassFile . read ( in ) ; in . close ( ) ; for ( int i = 0 ; i < cf . methods . length ; i ++ ) { Method m = cf . methods [ i ] ; if ( m . access_flags .", "gt": "is ( AccessFlags . ACC_NATIVE ) )", "prediction": ") ;\n", "label": 0}
{"id": 7989, "input": "<s> package org . eclipse . jface . util ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . swt . dnd . DND ; import org . eclipse . swt . dnd . DropTargetEvent ; import org . eclipse . swt . dnd . DropTargetListener ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . dnd . TransferData ; public class DelegatingDropAdapter implements DropTargetListener { private List listeners = new ArrayList ( ) ; private TransferDropTargetListener currentListener ; private int originalDropType ; public void addDropTargetListener ( TransferDropTargetListener listener ) { listeners . add ( listener ) ; } public void dragEnter ( DropTargetEvent event ) { originalDropType = event . detail ; updateCurrentListener ( event ) ; } public void dragLeave ( final DropTargetEvent event ) { setCurrentListener ( null , event ) ; } public void dragOperationChanged ( final DropTargetEvent event ) { originalDropType = event . detail ; TransferDropTargetListener oldListener = getCurrentListener ( ) ; updateCurrentListener ( event ) ; final TransferDropTargetListener newListener = getCurrentListener ( ) ; if ( newListener != null && newListener == oldListener ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { newListener . dragOperationChanged ( event ) ; } } ) ; } } public void dragOver ( final DropTargetEvent event ) { TransferDropTargetListener oldListener = getCurrentListener ( ) ; updateCurrentListener ( event ) ; final TransferDropTargetListener newListener = getCurrentListener ( ) ; if ( newListener != null && newListener == oldListener ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { newListener . dragOver ( event ) ; } } ) ; } } public void drop ( final DropTargetEvent event ) { updateCurrentListener ( event ) ; if ( getCurrentListener ( ) != null ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { getCurrentListener ( ) . drop ( event ) ; } } ) ; } setCurrentListener ( null , event ) ; } public void dropAccept ( final DropTargetEvent event ) { if ( getCurrentListener ( ) != null ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { getCurrentListener", "gt": "( ) . dropAccept ( event ) ;", "prediction": "( )\n", "label": 1}
{"id": 9001, "input": "<s> package com . shopzilla . api . client . model ; import com . shopzilla . api . client . model . response . AttributeSearchResponse ; import com . shopzilla . services . catalog . AttributeResponse ; import com . shopzilla . services . catalog . AttributeType ; import com . shopzilla . services . catalog . AttributeValueType ; import org . apache . commons . lang . ObjectUtils ; import org . apache . commons . lang . StringUtils ; import org . junit . Test ; import java . math . BigDecimal ; import java . util . List ; import static org . junit . Assert . assertTrue ; public class AttributeModelAdapterTest { @ Test public void testWithNullInput ( ) throws Exception { assertTrue ( responsesAreEqual ( new AttributeSearchResponse ( ) , AttributeModelAdapter . fromCatalogAPI ( null ) ) ) ; } @ Test public void testFromCatalogAPIWithNullAttributes ( ) throws Exception { AttributeResponse attributeResponse = generateAttributeResponse ( ) ; attributeResponse . setAttributes ( null ) ; AttributeSearchResponse attributeSearchResponse = AttributeModelAdapter . fromCatalogAPI ( attributeResponse ) ; assertTrue ( responsesAreEqual ( new AttributeSearchResponse ( ) , attributeSearchResponse ) ) ; } @ Test public void testFromCatalogAPI ( ) throws Exception { AttributeResponse attributeResponse = generateAttributeResponse ( ) ; AttributeSearchResponse attributeSearchResponse = AttributeModelAdapter . fromCatalogAPI ( attributeResponse ) ; assertTrue ( responsesAreEqual ( generateExpectedAttributeSearchResponse ( ) , attributeSearchResponse ) ) ; } private boolean responsesAreEqual ( AttributeSearchResponse response , AttributeSearchResponse otherResponse ) { if ( response == null && otherResponse == null ) { return true ; } if ( response == null || otherResponse == null ) { return false ; } if ( ! ObjectUtils . equals ( response . getIncludedResults ( ) , otherResponse . getIncludedResults ( ) ) ) { return false ; } if ( ! ObjectUtils . equals ( response . getMetaInfo ( ) , otherResponse . getMetaInfo ( ) ) ) { return false ; } if ( ! ObjectUtils . equals ( response . getTotalResults ( ) , otherResponse . getTotalResults ( ) ) ) { return false ; } if ( ! areAttributesEquals ( response . getAttributes ( ) , otherResponse . getAttributes ( ) ) ) { return false ; } return true ; } private boolean areAttributesEquals ( AttributeSearchResponse . Attributes attributes , AttributeSearchResponse . Attributes otherAttributes ) { if ( attributes == null && otherAttributes == null ) { return true ; } if ( attributes == null || otherAttributes == null ) { return false ; } if ( attributes . getAttribute ( ) == null && otherAttributes . getAttribute ( ) == null ) { return true ; } if ( attributes . getAttribute ( ) == null || otherAttributes . getAttribute ( ) == null ) { return false ; } if ( attributes . getAttribute ( ) . size ( ) != otherAttributes . getAttribute ( ) . size ( ) ) { return false ; } for ( int i = 0 ; i < attributes . getAttribute ( ) . size ( ) ; i ++ ) { if ( ! areAttributeTypeEqual ( attributes . getAttribute ( ) . get ( i ) , otherAttributes . getAttribute ( ) . get ( i ) ) ) { return false ; } } return true ; } private boolean areAttributeTypeEqual ( AttributeType attributeType , AttributeType otherAttributeType ) { if ( attributeType == null && otherAttributeType == null ) { return true ; } if ( attributeType == null || otherAttributeType == null ) { return false ; } if ( ! StringUtils . equals ( attributeType . getId ( ) , otherAttributeType . getId ( ) ) ) { return false ; } if ( ! StringUtils . equals ( attributeType . getName ( ) , otherAttributeType . getName ( ) ) ) { return false ; } if ( attributeType . getAttributeValues ( ) == null && otherAttributeType . getAttributeValues ( ) == null ) { return true ; } if ( attributeType . getAttributeValues ( ) == null || otherAttributeType . getAttributeValues ( ) == null ) { return false ; } List < AttributeValueType > attributeValueTypes = attributeType", "gt": ". getAttributeValues ( ) . getAttributeValue ( ) ;", "prediction": ";\n", "label": 0}
{"id": 7990, "input": "<s> package org . jscsi . scsi . tasks ; import java . nio . ByteBuffer ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . log4j . Logger ; import org . jscsi . core . scsi . Status ; import org . jscsi . scsi . protocol . Command ; import org . jscsi . scsi . protocol . cdb . CDB ; import org . jscsi . scsi . protocol . cdb . ParameterCDB ; import org . jscsi . scsi . protocol . cdb . TransferCDB ; import org . jscsi . scsi . protocol . inquiry . InquiryDataRegistry ; import org . jscsi . scsi . protocol . mode . ModePageRegistry ; import org . jscsi . scsi . protocol . sense . exceptions . SenseException ; import org . jscsi . scsi . protocol . sense . exceptions . SynchronousDataTransferErrorException ; import org . jscsi . scsi . transport . TargetTransportPort ; public abstract class AbstractTask implements Task { private static Logger _logger = Logger . getLogger ( AbstractTask . class ) ; private TargetTransportPort targetTransportPort ; private Command command ; private ModePageRegistry modePageRegistry ; private InquiryDataRegistry inquiryDataRegistry ; private String name = \"DefaultTaskName\" ; private Thread thread = null ; private final AtomicBoolean abort = new AtomicBoolean ( false ) ; protected abstract void execute ( ) throws InterruptedException , SenseException ; protected AbstractTask ( ) { } protected AbstractTask ( String name ) { this . name = name ; } protected AbstractTask ( String name , TargetTransportPort targetPort , Command command , ModePageRegistry modePageRegistry , InquiryDataRegistry inquiryDataRegistry ) { this . name = name ; this . targetTransportPort = targetPort ; this . command = command ; this . modePageRegistry = modePageRegistry ; this . inquiryDataRegistry = inquiryDataRegistry ; } protected final Task load ( TargetTransportPort targetPort , Command command , ModePageRegistry modePageRegistry , InquiryDataRegistry inquiryDataRegistry ) { this . command = command ; this . targetTransportPort = targetPort ; this . modePageRegistry = modePageRegistry ; this . inquiryDataRegistry = inquiryDataRegistry ; return this ; } public final boolean abort ( ) { if ( abort . compareAndSet ( false , true ) ) { this . thread . interrupt ( ) ; this . targetTransportPort . terminateDataTransfer ( this . command . getNexus ( ) , this . command . getCommandReferenceNumber ( ) ) ; return true ; } else { return false ; } } public final void run ( ) { this . thread = Thread . currentThread ( ) ; try { this . execute ( ) ; } catch ( SenseException e ) { _logger . debug ( \"sense exception caught handling command: \" + command ) ; this . targetTransportPort . writeResponse ( this . command . getNexus ( ) , this . command . getCommandReferenceNumber ( ) , Status . CHECK_CONDITION , ByteBuffer . wrap ( e . encode ( ) ) ) ; } catch ( InterruptedException e ) { _logger . info ( \"Task \" + name + \" was aborted.\" ) ; } catch ( Exception e ) { _logger . error ( \"Task \" + name + \" encountered an exception while executing\" , e ) ; } } protected final boolean readData ( ByteBuffer output ) throws InterruptedException , SynchronousDataTransferErrorException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; return this . targetTransportPort . readData ( this . command . getNexus ( ) , this . command . getCommandReferenceNumber ( ) , output ) ; } protected final boolean writeData ( ByteBuffer input ) throws InterruptedException , SynchronousDataTransferErrorException { if ( Thread . interrupted ( ) ) { _logger . debug ( \"calling writeData on the TransportPort was interrupted during Task execution\" ) ; throw new InterruptedException ( ) ; } return this . targetTransportPort . writeData ( this . command . getNexus ( ) , this . command . getCommandReferenceNumber ( ) , input ) ; } protected final boolean writeData ( byte [ ] input ) throws InterruptedException , SynchronousDataTransferErrorException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; CDB cdb = this . command . getCommandDescriptorBlock ( ) ; long transferLength = 0 ; if ( cdb instanceof TransferCDB ) { transferLength = ( ( TransferCDB ) cdb ) . getTransferLength ( ) ; } else if ( cdb instanceof ParameterCDB ) { transferLength = ( ( ParameterCDB ) cdb ) . getAllocationLength ( ) ; } ByteBuffer data = ByteBuffer . allocate ( ( int ) Math . min ( transferLength , input . length ) ) ; data . put ( input , 0 , ( int ) Math . min ( transferLength , input . length ) ) ; data . rewind ( ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; return this . targetTransportPort . writeData ( this . command . getNexus ( ) , this . command . getCommandReferenceNumber ( ) , data ) ; } protected final void", "gt": "writeResponse ( Status status , ByteBuffer senseData )", "prediction": "( ) ;\n", "label": 1}
{"id": 4198, "input": "<s> package org . msl . simple . gmfmap . diagram . properties ; import org . eclipse . gmf . mappings . LinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; public class FigureConnectionPropertiesSection extends AbstractSimplemapPropertySection { @ Override protected Object transformSelection ( Object selected ) { Object transformSelection = super . transformSelection ( selected ) ; LinkMapping linkMapping = null ; if ( transformSelection instanceof SimpleLinkMapping ) { linkMapping = ( ( SimpleLinkMapping", "gt": ") transformSelection ) . getLinkMapping ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8006, "input": "<s> package org . fuzzydb . dto . dimensions ; import java . io . Serializable ; public interface IRange3D extends Serializable { public boolean contains ( IPoint3D point ) ; public IPoint3D getMax ( ) ;", "gt": "public IPoint3D getMin ( ) ;", "prediction": "}\n", "label": 1}
{"id": 9486, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . ComplexEntityPart ; import org . bukkit . entity . ComplexLivingEntity ; import org . bukkit . entity . Entity ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaComplexEntityPart ; import Liza . LizaComplexLivingEntity ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftComplexLivingEntity implements LizaComplexLivingEntity { private ComplexLivingEntity cle ; public LizaCraftComplexLivingEntity ( ComplexLivingEntity cle ) { this . cle = cle ; } @ Override @ Deprecated public Set < ComplexEntityPart > getParts ( ) { Set < ComplexEntityPart > parts = this . cle . getParts ( ) ; for ( ComplexEntityPart part : parts ) { part = new LizaCraftComplexEntityPart ( part ) ; } return parts ; } @ Override public void damage ( int amount ) { this . cle . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . cle . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . cle . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . cle . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . cle . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . cle . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . cle . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . cle . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . cle . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . cle . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . cle . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . cle . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . cle . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . cle . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . cle . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > transparent , int maxDistance ) { return new LizaCraftBlock ( this . cle . getTargetBlock ( transparent , maxDistance ) ) ; } @ Override public LizaVehicle getVehicle ( ) { return new LizaCraftVehicle ( this . cle . getVehicle ( ) ) ; } @ Override public boolean isInsideVehicle ( ) { return this . cle . isInsideVehicle ( ) ; } @ Override public boolean leaveVehicle ( ) { return this . cle . leaveVehicle ( ) ; } @ Override public void setHealth ( int health ) { this . cle . setHealth ( health ) ; } @ Override public void setLastDamage ( int damage ) { this . cle . setLastDamage ( damage ) ; } @ Override public void setMaximumAir ( int ticks ) { this . cle . setMaximumAir ( ticks ) ; } @ Override public void setMaximumNoDamageTicks ( int ticks ) { this . cle . setMaximumNoDamageTicks ( ticks ) ; } @ Override public void setNoDamageTicks ( int ticks ) { this . cle . setNoDamageTicks ( ticks ) ; } @ Override public void setRemainingAir ( int ticks ) { this . cle . setRemainingAir ( ticks ) ; } @ Override public LizaArrow shootArrow ( ) { return new LizaCraftArrow ( this . cle . shootArrow ( ) ) ; } @ Override public LizaEgg throwEgg ( ) { return new LizaCraftEgg ( this . cle . throwEgg ( ) ) ; } @ Override public LizaSnowball throwSnowball ( ) { return new LizaCraftSnowball ( this . cle . throwSnowball ( ) ) ; } @ Override public boolean eject ( ) { return this . cle . eject ( ) ; } @ Override public int getEntityId ( ) { return this . cle . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . cle . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . cle . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . cle . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . cle . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . cle . getMaxFireTicks ( ) ; } @ Override @ Deprecated public List < Entity > getNearbyEntities ( double x , double y , double z ) { List < Entity > el = this . cle . getNearbyEntities ( x , y , z ) ; for ( Entity e : el ) { el . remove ( e ) ; LizaEntity le = new LizaCraftEntity ( e ) ; el . add ( le ) ; } return el ; } @ Override public LizaEntity getPassenger ( ) { return new", "gt": "LizaCraftEntity ( this . cle . getPassenger ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8040, "input": "<s> package org . eclipse . ui . tests . harness . util ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import junit . framework . AssertionFailedError ; public class Mocks { public static interface EqualityComparator { public boolean equals ( Object o1 , Object o2 ) ; } private static EqualityComparator defaultEqualityComparator = new EqualityComparator ( ) { public boolean equals ( Object o1 , Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; } } ; private static EqualityComparator indifferentEqualityComparator = new EqualityComparator ( ) { public boolean equals ( Object o1 , Object o2 ) { return true ; } } ; private static interface Mock { public MockInvocationHandler getMockInvocationHandler ( ) ; } private static Method getMockInvocationHandlerMethod ; private static Method equalsMethod ; static { try { getMockInvocationHandlerMethod = Mock . class . getMethod ( \"getMockInvocationHandler\" , new Class [ 0 ] ) ; equalsMethod = Object . class . getMethod ( \"equals\" , new Class [ ] { Object . class } ) ; } catch ( Exception e ) { } } private static final class MockInvocationHandler implements InvocationHandler { private class MethodCall { private final Method method ; private final Object [ ] args ; private Object returnValue = null ; public MethodCall ( Method method , Object [ ] args ) { this . method = method ; this . args = args ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof MethodCall ) ) { return false ; } MethodCall other = ( MethodCall ) obj ; if ( other . method != method || ( other . args == null && args != null ) || ( other . args != null && args == null ) || ( args != null && other . args . length != args . length ) ) { return false ; } if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( ! equalityComparator . equals ( args [ i ] , other . args [ i ] ) ) { return false ; } } } return true ; } public void setReturnValue ( Object object ) { returnValue = object ; } public Object getReturnValue ( ) { return returnValue ; } public String toString ( ) { return method . toString ( ) ; } } List previousCallHistory = null ; List currentCallHistory = new ArrayList ( ) ; private final boolean ordered ; private final EqualityComparator equalityComparator ; public MockInvocationHandler ( boolean ordered , EqualityComparator equalityComparator ) { this . ordered = ordered ; this . equalityComparator = equalityComparator ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( getMockInvocationHandlerMethod . equals ( method ) ) { return this ; } if ( equalsMethod . equals ( method ) ) { return new Boolean ( proxy == args [ 0 ] ) ; } MethodCall methodCall = new MethodCall ( method , args ) ; if ( previousCallHistory != null ) { int indexOfMethodCall = previousCallHistory . indexOf ( methodCall ) ; if ( indexOfMethodCall != - 1 ) { methodCall . setReturnValue ( ( ( MethodCall ) previousCallHistory . get ( indexOfMethodCall ) ) . getReturnValue ( ) ) ; } else { throw new AssertionFailedError ( \"unexpected method call: \" + method . getName ( ) ) ; } if ( ordered ) { if ( previousCallHistory . size ( ) <= currentCallHistory . size ( ) ) { throw new AssertionFailedError ( \"extra method call: \" + method . getName ( ) ) ; } MethodCall previousCall = ( MethodCall ) previousCallHistory . get ( currentCallHistory . size ( ) ) ; if ( ! methodCall . equals ( previousCall ) ) { throw new AssertionFailedError ( \"different method call (expected:\" + previousCall . method . getName ( ) + \", actual:\" + method . getName ( ) + \")\" ) ; } } } currentCallHistory . add ( methodCall ) ; Class returnType = method . getReturnType ( ) ; if ( returnType . isPrimitive ( ) && void . class != returnType ) { Object result = null ; Object returnValue = methodCall . getReturnValue ( ) ; if ( returnType == boolean . class ) { result = ( returnValue != null ) ? ( Boolean ) returnValue : Boolean . FALSE ; } else if (", "gt": "returnType == byte . class )", "prediction": ") ;\n", "label": 1}
{"id": 2559, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; import redstone . xmlrpc . XmlRpcArray ; public class TestRun { public String summary ; public String case_run_status ; public XmlRpcArray env_value ; public String product_version ; public String manager ; public String default_tester ; public XmlRpcArray tag ; public Integer manager_id ; public String stop_date ; public Integer plan_text_version ; public String build ; public String errata_id ; public Integer plan_id ; public String plan ; public Integer run_id ; public String estimated_time ; public Integer default_tester_id ; public Integer build_id ; public Integer environment_id ; public String notes ; public String start_date ; public XmlRpcArray cc ; public static class add_cases extends TcmsArrayCommand { @ RequiredField public Integer [ ] case_ids ; @ RequiredField public Integer [ ] run_ids ; } public static class add_tag extends TcmsArrayCommand { @ RequiredField public Integer [ ] run_ids ; @ RequiredField public String [ ] tags ; } public static class filter extends TcmsHashCommand { public Integer build ; public Integer plan ; public Integer product ; public Integer manager ; public String summary ; } public static class create extends TcmsHashCommand { @ RequiredField public Integer plan ; @ RequiredField public Integer build ; @ RequiredField public Integer manager ; @ RequiredField public String summary ; @ RequiredField public Integer product ; @ RequiredField public Integer product_version ; public Integer default_tester ; public Integer plan_text_version ; public Object estimated_time ; public String notes ; public Integer status ; public String caseVar ; public String tag ; } public static class env_value extends TcmsArrayCommand { @ RequiredField public String action ; @ RequiredField public Integer runid ; @ RequiredField public Integer env_value_id ; } public static class get extends TcmsArrayCommand { @ RequiredField public Integer run_id ; } public static class get_bugs extends TestRun . get { } public static class get_env_values extends TestRun . get { } public static class get_tags extends TestRun . get { } public static class get_test_case_runs extends TcmsArrayCommand { @ RequiredField public Integer run_id ; public Boolean is_current ; } public static class get_test_cases extends TestRun . get { } public static class get_test_plan extends TestRun . get { } public static class link_env_value extends TcmsArrayCommand { @ RequiredField public Integer run_id ; @ RequiredField public Integer env_value_id ; } public static class remove_tag extends TcmsArrayCommand { @", "gt": "RequiredField public Integer run_id ;", "prediction": "( )\n", "label": 0}
{"id": 8043, "input": "<s> package org . eclipse . ui . internal . presentations ; import java . util . ArrayList ; import java . util . Iterator ; import org . eclipse . jface . util . Util ; import org . eclipse . jface . viewers . ColumnLabelProvider ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . ContentViewer ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Table ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . internal . presentations . defaultpresentation . DefaultTabItem ; import org . eclipse . ui . internal . presentations . util . AbstractTabItem ; import org . eclipse . ui . internal . presentations . util . PresentablePartFolder ; import org . eclipse . ui . internal . tweaklets . TabBehaviour ; import org . eclipse . ui . internal . tweaklets . Tweaklets ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . presentations . IStackPresentationSite ; public class BasicPartList extends AbstractTableInformationControl { private PresentablePartFolder folder ; private IStackPresentationSite site ; private class BasicStackListContentProvider implements IStructuredContentProvider { public BasicStackListContentProvider ( ) { } public void dispose ( ) { } public Object [ ] getElements ( Object inputElement ) { if ( folder == null ) { return new IPresentablePart [ 0 ] ; } return folder . getPartList ( ) ; } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { folder = ( PresentablePartFolder ) newInput ; } } private class BasicStackListLabelProvider extends ColumnLabelProvider { private Font visibleEditorsFont ; private Font invisibleEditorsFont ; private Color visibleEditorsColor ; public BasicStackListLabelProvider ( ) { } public String getText ( Object element ) { IPresentablePart presentablePart = ( IPresentablePart ) element ; if ( presentablePart . isDirty ( ) ) { return DefaultTabItem . DIRTY_PREFIX + presentablePart . getName ( ) ; } return presentablePart . getName ( ) ; } public Image getImage ( Object element ) { IPresentablePart presentablePart = ( IPresentablePart ) element ; return presentablePart . getTitleImage ( ) ; } public Font getFont ( Object element ) { IPresentablePart presentablePart = ( IPresentablePart ) element ; AbstractTabItem item = folder . getTab ( presentablePart ) ; Control control = folder . getTabFolder ( ) . getControl ( ) ; if ( item != null && item . isShowing ( ) ) { return getVisibleEditorsFont ( control . getDisplay ( ) , control . getFont ( ) ) ; } return getInvisibleEditorsFont ( control . getDisplay ( ) , control . getFont ( ) ) ; } private Color getVisibleEditorsColor ( Display display , RGB originalForeground , RGB originalBackground ) { if ( visibleEditorsColor == null ) { visibleEditorsColor = ( ( TabBehaviour ) Tweaklets . get ( TabBehaviour . KEY ) ) . createVisibleEditorsColor ( display , originalForeground , originalBackground ) ; } return visibleEditorsColor ; } private Font getVisibleEditorsFont ( Display display , Font font ) { if ( visibleEditorsFont == null ) { visibleEditorsFont = ( ( TabBehaviour ) Tweaklets . get ( TabBehaviour . KEY ) ) . createVisibleEditorsFont ( display , font ) ; } return visibleEditorsFont ; } private Font getInvisibleEditorsFont ( Display display , Font font ) { if ( invisibleEditorsFont == null ) { invisibleEditorsFont = ( ( TabBehaviour ) Tweaklets . get ( TabBehaviour . KEY ) ) . createInvisibleEditorsFont ( display , font ) ; } return invisibleEditorsFont ; } public void dispose ( ) { super . dispose ( ) ; if ( visibleEditorsColor != null ) { visibleEditorsColor . dispose ( ) ; } if ( visibleEditorsFont != null ) { visibleEditorsFont . dispose ( ) ; } if ( invisibleEditorsFont != null ) { invisibleEditorsFont . dispose ( ) ; } } public Color getForeground ( Object element ) { IPresentablePart presentablePart = ( IPresentablePart ) element ; AbstractTabItem item = folder . getTab ( presentablePart ) ; Control control = folder . getTabFolder ( ) . getControl ( ) ; if ( item != null && item . isShowing ( ) ) { return getVisibleEditorsColor ( control . getDisplay ( ) , control . getForeground ( ) . getRGB ( ) , control . getBackground ( ) . getRGB ( ) ) ; } return null ; } public String getToolTipText ( Object element ) { if ( element instanceof PresentablePart ) { PresentablePart part = ( PresentablePart ) element ; IWorkbenchPartReference reference = part . getPane ( ) . getPartReference ( ) ; return reference . getTitleToolTip ( ) ; } return null ; } public boolean useNativeToolTip ( Object object ) { return true ; } } private class BasicStackListViewerComparator extends ViewerComparator { public BasicStackListViewerComparator ( ) { } public int compare ( Viewer viewer , Object e1 , Object e2 ) { int cat1 = category ( e1 ) ; int cat2 = category ( e2 ) ; if ( cat1 != cat2 ) { return cat1 - cat2 ; } String name1 ; String name2 ; if ( viewer == null || ! ( viewer instanceof ContentViewer ) ) { name1 = e1 . toString ( ) ; name2 = e2", "gt": ". toString ( ) ;", "prediction": ";\n", "label": 1}
{"id": 1670, "input": "<s> package com . l7 . mitra . client . ui ; import java . awt . LayoutManager ; import javax . swing . JPanel ; public class OAuthStepPanel extends JPanel { protected String stepLabel = \"\" ; public OAuthStepPanel ( ) { } public OAuthStepPanel ( LayoutManager arg0 ) { super ( arg0 ) ; } public OAuthStepPanel ( boolean arg0 ) { super ( arg0 ) ; } public OAuthStepPanel ( LayoutManager arg0 , boolean arg1 ) { super", "gt": "( arg0 , arg1 ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8051, "input": "<s> package org . fuzzydb . util . context ; import java . util . Map ; import java . util . TreeMap ; public class SimpleApplicationContext implements ApplicationContext { static private SimpleApplicationContext instance = new SimpleApplicationContext ( ) ; static public SimpleApplicationContext getInstance ( ) { return instance ; } private Map < String , Object > objects ; public SimpleApplicationContext ( ) { objects = new TreeMap < String ,", "gt": "Object > ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4720, "input": "<s> package net . minecraft . src ; import org . lwjgl . opengl . GL11 ; public abstract class ThxModel extends ModelBase { final float RAD_PER_DEG = 00 .01745329f ; final float PI = 03 .14159265f ; boolean visible = true ; boolean paused ; float deltaTime ; long prevTime ; long entityPrevTime ; float rotationYaw ; float rotationYawSpeed ; float rotationPitch ; float rotationPitchSpeed ; float rotationRoll ; float rotationRollSpeed ; String renderTexture ; RenderManager renderManager ; int updateCount ; public void update ( ) { updateCount ++ ; long time = System . nanoTime ( ) ; deltaTime = ( ( float ) ( time - prevTime ) ) / 1000000000f ; if ( deltaTime > .03f ) deltaTime = .03f ; if ( paused ) { } else if ( entityPrevTime > prevTime ) { float adjustedDeltaTime = ( ( float )", "gt": "( time - entityPrevTime ) ) / 1000000000f ;", "prediction": ";\n", "label": 0}
{"id": 8053, "input": "<s> package org . jscsi . target . scsi . modeSense ; import org . jscsi . target . scsi . ISerializable ; public abstract class ModeParameterHeader implements ISerializable { protected final int modeDataLength ; protected final byte mediumType = ( byte ) 0x00 ; protected final byte deviceSpecificParameter", "gt": "= ( byte ) 0x00 ;", "prediction": ";\n", "label": 1}
{"id": 6630, "input": "<s> package org . ofbiz . entity . condition ; import java . util . List ; public interface EntityConditionVisitor { < T > void visit ( T obj ) ; < T > void accept ( T obj ) ; void acceptObject ( Object obj ) ; void acceptEntityCondition ( EntityCondition condition ) ; < T extends EntityCondition > void acceptEntityJoinOperator ( EntityJoinOperator op , List < T > conditions ) ; < L , R , T > void acceptEntityOperator ( EntityOperator < L , R , T > op , L lhs , R rhs ) ; < L , R > void acceptEntityComparisonOperator ( EntityComparisonOperator < L , R > op , L lhs , R rhs ) ; void acceptEntityConditionValue ( EntityConditionValue value ) ; void acceptEntityFieldValue ( EntityFieldValue value ) ; void acceptEntityExpr ( EntityExpr expr ) ; < T extends EntityCondition > void acceptEntityConditionList ( EntityConditionList < T > list ) ; void acceptEntityFieldMap ( EntityFieldMap fieldMap ) ; void acceptEntityConditionFunction ( EntityConditionFunction func , EntityCondition nested ) ; < T extends Comparable < ? > > void acceptEntityFunction ( EntityFunction", "gt": "< T > func ) ;", "prediction": ")\n", "label": 0}
{"id": 8067, "input": "<s> package com . orange . place . tasks . async ; import android . content . Context ; import android . util . Log ; import com . github . droidfu . concurrent . BetterAsyncTask ; import com . orange . place . Activity_Main_Places ; import com . orange . place . Activity_PlacePosts ; import com . orange . place . constant . ErrorCode ; import com . orange . place . constants . Constants ; public class AsyncGetFollowedPlacesTask extends BetterAsyncTask < Void , Void , Integer > { public AsyncGetFollowedPlacesTask ( Context context ) { super ( context ) ; } @ Override protected void handleError ( Context context , Exception error ) { Log . e ( Constants . LOG_TAG , \"Error happened in \" + getClass ( ) . getName ( ) , error ) ; } @ Override protected void after ( Context context , Integer taskResult ) { if ( taskResult == ErrorCode . ERROR_SUCCESS ) { if ( context instanceof Activity_Main_Places ) { ( ( Activity_Main_Places", "gt": ") context ) . updateFollowedPlacesView ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9410, "input": "<s> import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SupportedAnnotationTypes ( \"*\" ) public class AnnoProc extends AbstractProcessor { public boolean process ( Set < ? extends TypeElement > elems , RoundEnvironment renv ) { if ( renv . processingOver ( ) ) { Messager m", "gt": "= processingEnv . getMessager ( ) ;", "prediction": ";\n", "label": 0}
{"id": 8071, "input": "<s> package org . spliffy . server . apps . website ; import com . bradmcevoy . http . * ; import com . bradmcevoy . http . Request . Method ; import com . bradmcevoy . http . exceptions . BadRequestException ; import com . bradmcevoy . http . exceptions . NotAuthorizedException ; import com . bradmcevoy . http . exceptions . NotFoundException ; import com . ettrema . http . acl . Principal ; import java . io . IOException ; import java . io . OutputStream ; import java . util . * ; import org . spliffy . server . apps . ApplicationManager ; import org . spliffy . server . db . * ; import org . spliffy . server . db . utils . SessionManager ; import org . spliffy . server . web . AbstractResource ; import org . spliffy . server . web . PrincipalResource ; import org . spliffy . server . web . RepositoryFolder ; import org . spliffy . server . web . RootFolder ; import org . spliffy . server . web . SecurityUtils ; import org . spliffy . server . web . Services ; import org . spliffy . server . web . SpliffyCollectionResource ; import org . spliffy . server . web . UserResource ; import org . spliffy . server . web . Utils ; public class WebsiteRootFolder extends AbstractResource implements RootFolder , SpliffyCollectionResource , GetableResource , PropFindableResource { private Map < String , PrincipalResource > children = new HashMap < > ( ) ; private final ApplicationManager applicationManager ; private final Website website ; public WebsiteRootFolder ( Services services , ApplicationManager applicationManager , Website website ) { super ( services ) ; this . website = website ; this . applicationManager = applicationManager ; } @ Override public String getName ( ) { return \"\" ; } @ Override public boolean authorise ( Request request , Request . Method method , Auth auth ) { System . out . println ( \"authorise\" ) ; if ( method . equals ( Method . PROPFIND ) ) { return getCurrentUser ( ) != null ; } return true ; } @ Override public Date getModifiedDate ( ) { return null ; } @ Override public Resource child ( String childName ) throws NotAuthorizedException , BadRequestException { Resource r = applicationManager . getPage ( this , childName ) ; if ( r != null ) { return r ; } r = Utils . childOf ( getChildren ( ) , childName ) ; if ( r != null ) { return r ; } r = findEntity ( childName ) ; return r ; } @ Override public PrincipalResource findEntity ( String name ) { PrincipalResource r = children . get ( name ) ; if ( r != null ) { return r ; } Profile u = services . getSecurityManager ( ) . getUserDao ( ) . getProfile ( name , getOrganisation ( ) , SessionManager . session ( ) ) ; if ( u == null ) { return null ; } else { UserResource ur = new UserResource ( this , u , applicationManager ) ; children . put (", "gt": "name , ur ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7878, "input": "<s> package firstSentence2 ; public class B extends A {", "gt": "public void m ( )", "prediction": "if ( )\n", "label": 0}
{"id": 8080, "input": "<s> package org . eclipse . ui . internal . layout ; import java . util . List ; import org . eclipse . swt . SWT ; public interface ITrimManager { public static final int TOP = SWT . TOP ; public static final int BOTTOM = SWT . BOTTOM ; public static final int LEFT = SWT . LEFT ; public static final int RIGHT = SWT . RIGHT ; public static final int NONTRIM = SWT . DEFAULT ; public void addTrim ( int areaId , IWindowTrim trim ) ; public void addTrim ( int areaId , IWindowTrim trim , IWindowTrim beforeMe ) ; public void removeTrim ( IWindowTrim toRemove ) ; public IWindowTrim getTrim ( String id ) ; public int [ ] getAreaIds ( ) ; public List getAreaTrim ( int areaId ) ; public void updateAreaTrim ( int", "gt": "id , List trim , boolean removeExtra ) ;", "prediction": ")\n", "label": 1}
{"id": 5681, "input": "<s> package org . bombusim . xmpp ; import java . io . IOException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . ArrayList ; import java . util . Collections ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import org . bombusim . util . strconv ; import org . bombusim . xmpp . exception . XmppException ; import org . bombusim . xmpp . stanza . Iq ; import android . util . Log ; public class EntityCaps extends XmppObjectListener { private static final String DISCO_INFO = \"http://jabber.org/protocol/disco#info\" ; private static final String XMLNS_CAPS = \"http://jabber.org/protocol/caps\" ; private static final String BOMBUS_NS = \"http://bombus-im.org/android\" ; private static final String BOMBUS_CATEGORY = \"client\" ; private static final String BOMBUS_TYPE = \"mobile\" ; private ArrayList < String > features ; private String ver ; public XmppObject getresenceCaps ( ) { String ver = calculateVer ( ) ; if ( ver == null ) return null ; XmppObject c = new XmppObject ( \"c\" , null , null ) . setNameSpace ( XMLNS_CAPS ) . setAttribute ( \"hash\" , \"sha-1\" ) . setAttribute ( \"ver\" , ver ) . setAttribute ( \"node\" , BOMBUS_NS ) ; return c ; } private String calculateVer ( ) { if ( ver != null ) return ver ; Collections . sort ( features ) ; StringBuilder sb = new StringBuilder ( BOMBUS_CATEGORY ) . append ( '/' ) . append ( BOMBUS_TYPE ) . append ( \"//\" ) . append ( getVersionName ( ) ) . append ( '<' ) ; for ( String feature : features ) { sb . append ( feature ) . append ( '<' ) ; } MessageDigest sha1 ; try { sha1 = MessageDigest . getInstance ( \"SHA-1\" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return null ; } String caps = sb . toString ( ) ; Log . d ( \"CAPS\" , caps ) ; sha1 . update ( caps . getBytes ( ) ) ; ver = strconv . byteArrayToHexString ( sha1 . digest ( ) ) ; return ver ; } private String getVersionName ( ) { return Lime . getInstance ( ) . getString ( R . string . app_name ) + ' ' + Lime . getInstance ( ) . getVersion ( ) ; } public void updateFeatures ( ArrayList < String > features ) { this . features = features ; ver = null ; } @ Override public int blockArrived ( XmppObject data , XmppStream stream ) throws IOException , XmppException { try { Iq disco = ( Iq ) data ; if ( ! disco . getTypeAttribute ( ) . equals ( \"get\" ) ) return BLOCK_REJECTED ; XmppObject query = disco . findNamespace ( \"query\" , DISCO_INFO ) ; String node = query . getAttribute ( \"node\" ) ; Iq result = new Iq ( disco . getAttribute ( \"from\" ) , Iq . TYPE_RESULT , disco . getAttribute ( \"id\" ) ) ; XmppObject qr = result . addChildNs ( \"query\" , DISCO_INFO ) ; if ( node != null ) { if ( ! node . equals ( BOMBUS_NS + '#' + calculateVer ( ) ) ) return BLOCK_REJECTED ; }", "gt": "qr . setAttribute ( \"node\" , node ) ;", "prediction": "}\n", "label": 0}
{"id": 8081, "input": "<s> package org . eclipse . ui . tests . manual ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IMenuListener ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . resource . LocalResourceManager ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . ui . ISaveablesLifecycleListener ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . Saveable ; import org . eclipse . ui . SaveablesLifecycleEvent ; import org . eclipse . ui . internal . SaveablesList ; import org . eclipse . ui . part . ViewPart ; public class SaveablesView extends ViewPart { private TableViewer viewer ; private Action printSourcesAction ; private ISaveablesLifecycleListener saveablesLifecycleListener = new ISaveablesLifecycleListener ( ) { public void handleLifecycleEvent ( SaveablesLifecycleEvent event ) { if ( event . getEventType ( ) == SaveablesLifecycleEvent . DIRTY_CHANGED ) { Saveable [ ] saveables = event . getSaveables ( ) ; viewer . update ( saveables , null ) ; } else { viewer . refresh ( ) ; } } } ; private LocalResourceManager resourceManager ; class ViewContentProvider implements IStructuredContentProvider { public void inputChanged ( Viewer v , Object oldInput , Object newInput ) { } public void dispose ( ) { } public Object [ ] getElements ( Object parent ) { return ( ( SaveablesList ) getSite ( ) . getService ( ISaveablesLifecycleListener . class ) ) . getOpenModels ( ) ; } } class ViewLabelProvider extends LabelProvider implements ITableLabelProvider { public String getColumnText ( Object obj , int index ) { Saveable saveable = ( Saveable ) obj ; return ( saveable . isDirty ( ) ? \"* \" : \"\" ) + saveable . getName ( ) ; } public", "gt": "Image getColumnImage ( Object obj , int index )", "prediction": "}\n", "label": 1}
{"id": 5638, "input": "<s> package org . parboiled ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class BugIn0100Test extends TestNgParboiledTest < Integer > { public interface A { public String get ( ) ; } public interface B extends A { } public static class Parser extends BaseParser < B > { Rule ID ( ) { return Sequence ( 'a' , match ( ) . equals ( peek", "gt": "( ) . get ( ) ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8104, "input": "<s> package com . codeslap . persistence ; public interface PreferencesAdapter { String DEFAULT_PREFS = \"default.prefs\" ; public < T > void store ( T bean ) ; public < T > T", "gt": "retrieve ( Class < T > theClass ) ;", "prediction": "\n", "label": 1}
{"id": 1817, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . StatusSheetReport ; import org . jjflyboy . tjpeditor . project . StatusSheetReportAttribute ; public class StatusSheetReportImpl extends PropertyImpl implements StatusSheetReport { protected static final String FILENAME_EDEFAULT = null ; protected String filename = FILENAME_EDEFAULT ; protected EList < StatusSheetReportAttribute > attributes ; protected StatusSheetReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getStatusSheetReport ( ) ; } public String getFilename ( ) { return filename ; } public void setFilename ( String newFilename ) { String oldFilename = filename ; filename = newFilename ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_SHEET_REPORT__FILENAME , oldFilename , filename ) ) ; } public EList < StatusSheetReportAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < StatusSheetReportAttribute > ( StatusSheetReportAttribute . class , this , ProjectPackage . STATUS_SHEET_REPORT__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . STATUS_SHEET_REPORT__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . STATUS_SHEET_REPORT__FILENAME : return getFilename ( ) ; case ProjectPackage . STATUS_SHEET_REPORT__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . STATUS_SHEET_REPORT__FILENAME : setFilename ( ( String ) newValue ) ; return ; case ProjectPackage . STATUS_SHEET_REPORT__ATTRIBUTES : getAttributes ( ) . clear ( ) ; getAttributes ( ) . addAll ( ( Collection < ? extends StatusSheetReportAttribute > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . STATUS_SHEET_REPORT__FILENAME : setFilename ( FILENAME_EDEFAULT ) ; return ; case ProjectPackage . STATUS_SHEET_REPORT__ATTRIBUTES : getAttributes ( ) . clear ( ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . STATUS_SHEET_REPORT__FILENAME : return FILENAME_EDEFAULT == null ? filename != null : ! FILENAME_EDEFAULT", "gt": ". equals ( filename ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8110, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . core . whirlwind . SearchSpec ; public class WWSearchCmd extends TransactionCommand { private static final long serialVersionUID = 1L ; private String namespace ; private final SearchSpec search ; private int queryId ; private boolean wantNominee ; private int fetchSize ; private WWSearchCmd ( ) { super ( 0 , 0 , 0 ) ; this . search = null ; } public WWSearchCmd ( int storeId , int cid , int tid , String namespace , int queryId , boolean wantNominee , int fetchSize , SearchSpec search ) { super ( storeId , cid , tid ) ;", "gt": "this . namespace = namespace ;", "prediction": "}\n", "label": 1}
{"id": 1589, "input": "<s> package com . example . business . operator ; import java . util . Iterator ; import java . util . List ; import com . asakusafw . runtime . core . Result ; import com . asakusafw . vocabulary . model . Key ; import com . asakusafw . vocabulary . operator . Branch ; import com . asakusafw . vocabulary . operator . CoGroup ; import com . example . business . modelgen . table . model . Shipment ; import com . example . business . modelgen . table . model . Stock ; public abstract class StockOp { @ Branch public ShipmentStatus checkShipment ( Shipment shipment ) { if ( shipment . getShippedDateOption ( ) . isNull ( ) ) { return ShipmentStatus . NOT_SHIPPED ; } if ( shipment . getCostOption ( ) . isNull ( ) ) { return ShipmentStatus . COST_UNKNOWN ; } return ShipmentStatus . COMPLETED ; } public enum ShipmentStatus { NOT_SHIPPED , COST_UNKNOWN , COMPLETED , } @ CoGroup public void cutoff ( @ Key ( group = \"ITEM_CODE\" , order = \"PURCHASED_DATE ASC\" ) List < Stock > stocks , @ Key ( group = \"ITEM_CODE\" , order = \"SHIPPED_DATE ASC\" ) List < Shipment > shipments , Result < Stock", "gt": "> newStocks , Result < Shipment > newShipments )", "prediction": ") ;\n", "label": 0}
{"id": 8112, "input": "<s> package org . nuxeo . ecm . platform . tag . sql ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import org . hibernate . dialect . Dialect ; public class Table implements Serializable { private static final long serialVersionUID = 1L ; private final String name ; private final List < Column > columns ; public Table ( String name ) { columns = new ArrayList < Column > ( ) ; this . name = name ; } public String getName ( ) { return name ; } public String getQuotedName ( Dialect dialect ) { return dialect . openQuote ( ) + name + dialect . closeQuote ( ) ; } public List < Column > getColumns ( ) { return columns ; } public void addColumn ( Column column ) { columns . add ( column ) ; } public String getCreateSql ( Dialect dialect ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( \"create table\" ) ; buf . append ( ' ' ) ; buf . append ( name ) ; buf . append ( \" (\" ) ; boolean first = true ; for ( Column column : columns ) { if ( first ) { first = false ; } else { buf . append ( \", \" ) ; } buf . append ( column . getName ( ) ) ; buf . append ( ' ' ) ; buf . append ( column .", "gt": "getSqlTypeString ( dialect ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9718, "input": "<s> package org . ofbiz . entity . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class EntityTypeUtil { public static final String module = EntityTypeUtil . class . getName ( ) ; public static boolean isType ( Collection < GenericValue > thisCollection , String typeRelation , GenericValue targetType ) { for ( GenericValue value : thisCollection ) { try { GenericValue related = value . getRelatedOne ( typeRelation , false ) ; if ( isType ( related , targetType ) ) { return true ; } } catch ( GenericEntityException e ) { continue ; } } return false ; } private static GenericValue getParentType ( GenericValue typeValue ) { try { return typeValue . getRelatedOne ( \"Parent\" + typeValue . getEntityName ( ) , true ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e , module ) ; return null ; } } public static List < GenericValue > getDescendantTypes ( GenericValue typeValue ) { List < GenericValue > descendantTypes = new ArrayList < GenericValue > ( ) ; List < GenericValue > childrenTypes = null ; try { childrenTypes = typeValue . getRelated ( \"Child\" + typeValue . getEntityName ( ) , null , null , true ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( e , module ) ; return null ; } if ( childrenTypes == null ) return null ; descendantTypes . addAll ( childrenTypes ) ; for ( GenericValue childType : childrenTypes ) { List < GenericValue > childTypeDescendants = getDescendantTypes ( childType ) ; if ( childTypeDescendants != null ) { descendantTypes . addAll ( childTypeDescendants ) ; } } return descendantTypes ; } public static", "gt": "boolean isType ( GenericValue thisType , GenericValue targetType )", "prediction": "( )\n", "label": 0}
{"id": 8157, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . internal . intro . IntroMessages ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . intro . IIntroPart ; import org . eclipse . ui . intro . IIntroSite ; import org . eclipse . ui . part . ViewPart ; public final class ViewIntroAdapterPart extends ViewPart { private IIntroPart introPart ; private IIntroSite introSite ; private boolean handleZoomEvents = true ; private void addPaneListener ( ) { IWorkbenchPartSite site = getSite ( ) ; if ( site instanceof PartSite ) { final WorkbenchPartReference ref = ( ( WorkbenchPartReference ) ( ( PartSite ) site ) . getPartReference ( ) ) ; ref . addInternalPropertyListener ( new IPropertyListener ( ) { public void propertyChanged ( Object source , int propId ) { if ( handleZoomEvents ) { if ( propId == WorkbenchPartReference . INTERNAL_PROPERTY_ZOOMED ) { setStandby ( ! ref . getPane ( ) . isZoomed ( ) ) ; } } } } ) ; } } public void setStandby ( final boolean standby ) { final Control control = ( ( PartSite ) getSite ( ) ) . getPane ( ) . getControl ( ) ; BusyIndicator . showWhile ( control . getDisplay ( ) , new Runnable ( ) { public void run ( ) { try { control . setRedraw ( false ) ; introPart . standbyStateChanged ( standby ) ; } finally { control . setRedraw ( true ) ; } setBarVisibility ( standby ) ; } } ) ; } public void setHandleZoomEvents ( boolean handle ) { handleZoomEvents = handle ; } public void createPartControl ( Composite parent ) { addPaneListener ( ) ; introPart . createPartControl ( parent ) ; } public void dispose ( ) { setBarVisibility ( true ) ; super . dispose ( ) ; getSite ( ) . getWorkbenchWindow ( ) . getWorkbench ( ) . getIntroManager ( ) . closeIntro ( introPart ) ; introPart . dispose ( ) ; } public Object getAdapter ( Class adapter ) { return introPart . getAdapter ( adapter ) ; } public Image getTitleImage ( ) { return introPart . getTitleImage ( ) ; } public String getTitle ( ) { return introPart == null ? super . getTitle ( ) : introPart . getTitle ( ) ; } public void init ( IViewSite site , IMemento memento ) throws PartInitException { super . init ( site ) ; Workbench workbench = ( Workbench ) site . getWorkbenchWindow ( ) . getWorkbench ( ) ; try { introPart = workbench . getWorkbenchIntroManager ( ) . createNewIntroPart ( ) ; setPartName", "gt": "( introPart . getTitle ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3256, "input": "<s> public class TestModifier extends JavadocTester { private static final String BUG_ID = \"4210388\" ; private static final String [ ] [ ] TEST = NO_TEST ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-sourcepath\" , SRC_DIR , \"-docletpath\" , SRC_DIR , \"-doclet\" , \"ModifierAbstract\" , SRC_DIR + FS + \"Interface.java\" , SRC_DIR + FS + \"Test.java\" } ; public static void main ( String [ ] args ) { TestModifier tester =", "gt": "new TestModifier ( ) ;", "prediction": ";\n", "label": 0}
{"id": 8166, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . util . Properties ; import org . apache . lucene . benchmark . BenchmarkTestCase ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . utils . Config ; public class PerfTaskTest extends BenchmarkTestCase { private static final class MyPerfTask extends PerfTask { public MyPerfTask ( PerfRunData runData ) { super ( runData ) ; } public int doLogic ( ) throws Exception { return 0 ; } public int getLogStep ( ) { return logStep ; } } private PerfRunData createPerfRunData ( boolean setLogStep , int logStepVal , boolean setTaskLogStep , int taskLogStepVal ) throws Exception { Properties props = new Properties ( ) ; if ( setLogStep ) { props . setProperty ( \"log.step\" , Integer . toString ( logStepVal ) ) ; } if ( setTaskLogStep ) { props . setProperty ( \"log.step.MyPerf\" , Integer . toString ( taskLogStepVal ) ) ; } props . setProperty ( \"directory\" , \"RAMDirectory\" ) ; Config config = new", "gt": "Config ( props ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6281, "input": "<s> package jns . agent ; import jns . util . IPAddr ; public interface CO_Agent extends Agent { public void connect ( IPAddr source , IPAddr destination , int destination_port ) ; public void disconnect ( ) ; public void listen ( IPAddr local_ip ) ; public void send (", "gt": "int length , Object data , int unique_id ) ;", "prediction": ")\n", "label": 0}
{"id": 8170, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . eclipse . xtext . xdoc . xdoc . MarkUp ; import org", "gt": ". eclipse . xtext . xdoc . xdoc . XdocPackage ;", "prediction": ";\n", "label": 1}
{"id": 2179, "input": "<s> import java . util . * ; public class T5061359a { public static class Test", "gt": "< T extends Base & Intf >", "prediction": "\n", "label": 0}
{"id": 8174, "input": "<s> package org . projectvoodoo . simunlock ; import android . app . Application ; import android . content . Context ; public class App extends Application { static Context context ; static final String VALID_BUILD_MODEL [ ] = { \"GT-I9300.*\" } ; @ Override public void onCreate ( ) {", "gt": "super . onCreate ( ) ;", "prediction": "\n", "label": 1}
{"id": 8513, "input": "<s> package firstSentence2 ; public class C extends B {", "gt": "public void m ( )", "prediction": "( )\n", "label": 0}
{"id": 8205, "input": "<s> package org . eclipse . ui . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . viewers . AbstractTreeViewer ; import org . eclipse . ui . IWorkbenchCommandConstants ; public class CollapseAllHandler extends AbstractHandler { public static final String COMMAND_ID = IWorkbenchCommandConstants . NAVIGATE_COLLAPSE_ALL ; private AbstractTreeViewer treeViewer ; public CollapseAllHandler ( AbstractTreeViewer viewer ) { Assert . isNotNull ( viewer ) ; treeViewer = viewer ; } public Object execute ( ExecutionEvent event ) { treeViewer", "gt": ". collapseAll ( ) ;", "prediction": ";\n", "label": 1}
{"id": 221, "input": "<s> import java . util . * ; import java . io . * ; import java . text . * ; class Main { static int maxLg = 15 ; public static void main ( String args [ ] ) throws Exception { try { String line ; BigNum bigNum [ ] = new BigNum [ 6000 ] ; bigNum [ 0 ] = BigNum . ZERO ; bigNum [ 1 ] = BigNum . ONE ; for ( int i = 2 ; i != 5011 ; i ++ ) { bigNum [ i ] = bigNum [ i - 1 ] . add ( bigNum [ i - 2 ] ) ; } while ( ( line = readLine ( ) ) != null ) { int i = Integer . parseInt ( line ) ; System . out . println ( \"The Fibonacci number for \" + i + \" is \" + bigNum [ i ] ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; } lin [ lg ++ ] += car ; } if ( ( car < 0 ) && ( lg == 0 ) ) { return ( null ) ; } return ( new String ( lin , 0 , lg ) ) ; } } class BigNum { static final int MAX = 200 ; static final long QUOTE = 1000000000 ; static BigNum ONE = new BigNum ( 1 ) ; static BigNum ZERO = new BigNum ( 0 ) ; int max = 0 ; long [ ] mag ; BigNum ( int i ) { mag = new long [ MAX ] ; for ( int z = 0 ; z != MAX ; z ++ ) { mag [ z ] = 0 ; } while ( i != 0 ) { mag [ max ++ ] = i % QUOTE ; i /= QUOTE ; } } BigNum ( BigNum b ) { this . max = b . max ; mag = new long [ MAX ] ; for ( int z = 0 ; z != MAX ; z ++ ) { mag [ z ] = b . mag [ z ] ; } }", "gt": "BigNum add ( BigNum b )", "prediction": "}\n", "label": 0}
{"id": 8212, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . jface . viewers . ILabelDecorator ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . swt . graphics . Image ; public class DynamicLabelDecorator implements ILabelDecorator { public DynamicLabelDecorator ( ) { super ( ) ; } public Image decorateImage ( Image image , Object element ) { return null ; } public String decorateText ( String text , Object element ) { return text + \" F1 \" ; } public void addListener ( ILabelProviderListener listener ) { } public void dispose ( ) { } public boolean isLabelProperty", "gt": "( Object element , String property )", "prediction": "( )\n", "label": 1}
{"id": 10078, "input": "<s> package org . ofbiz . base . start ; import java . io . PrintStream ; import java . io . PrintWriter ; @ SuppressWarnings ( \"serial\" ) public class StartupException extends Exception { Throwable nested = null ; public StartupException ( ) { super ( ) ; } public StartupException ( String msg ) { super ( msg ) ; } public StartupException ( String msg , Throwable nested ) { super ( msg ) ; this . nested = nested ; } public StartupException ( Throwable nested ) { super ( ) ; this . nested = nested ; } @ Override public String getMessage ( ) { if ( nested != null ) { return super . getMessage ( ) + \" (\" + nested . getMessage ( ) + \")\" ; } else { return super . getMessage ( ) ; } } public String getNonNestedMessage ( ) { return super . getMessage ( ) ; } public Throwable getNested ( ) { if ( nested == null ) { return this ; } return nested ; } @ Override", "gt": "public void printStackTrace ( )", "prediction": "}\n", "label": 0}
{"id": 8213, "input": "<s> package org . restlet . ext . openid ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . Cookie ; import org . restlet . data . CookieSetting ; import org . restlet . data . Status ; import org . restlet . security . Authenticator ; import org . restlet . security . User ; import org . restlet . security . Verifier ; public class RedirectAuthenticator extends Authenticator { public final static String DEFAULT_IDENTIFIER_COOKIE = \"session_id\" ; public final static String DEFAULT_ORIGINAL_REF_COOKIE = \"original_ref\" ; public final static String ORIGINAL_REF_ATTRIBUTE = \"origRef\" ; public static void clearIdentifierCookie ( String cookieId , Request req , Response res ) { Cookie cookie = req . getCookies ( ) . getFirst ( cookieId ) ; CookieSetting identifierCookie = res . getCookieSettings ( ) . getFirst ( cookieId ) ; if ( identifierCookie == null && cookie != null ) { identifierCookie = new CookieSetting ( cookieId , null ) ; res . getCookieSettings ( ) . add ( identifierCookie ) ; } if ( identifierCookie != null ) identifierCookie . setMaxAge ( 0 ) ; } public static void clearIdentiiferCookie ( Request req , Response res ) { clearIdentifierCookie ( DEFAULT_IDENTIFIER_COOKIE , req , res ) ; } private Restlet forbiddenResource ; private final String identifierCookie ; private final String origRefCookie ; private final Verifier verifier ; public RedirectAuthenticator ( Context context , Verifier verifier , Restlet forbiddenResource ) { super ( context ) ; this . forbiddenResource = forbiddenResource ; this . verifier = verifier ; this . origRefCookie = DEFAULT_ORIGINAL_REF_COOKIE ; this . identifierCookie = DEFAULT_IDENTIFIER_COOKIE ; } public RedirectAuthenticator ( Context context , Verifier verifier , String identifierCookie , String origRefCookie , Restlet forbiddenResource ) { super ( context ) ; this . forbiddenResource = forbiddenResource ; this . verifier = verifier ; this . identifierCookie = identifierCookie != null ? identifierCookie : DEFAULT_IDENTIFIER_COOKIE ; this . origRefCookie = origRefCookie != null ? origRefCookie : DEFAULT_ORIGINAL_REF_COOKIE ; } @ Override protected boolean authenticate ( Request request , Response response ) { User u = request . getClientInfo ( ) . getUser ( ) ; String identifier = request . getCookies ( ) . getFirstValue ( identifierCookie ) ; String origRef ; if ( identifier != null ) { u = new User ( identifier ) ; request . getClientInfo ( ) . setUser ( u ) ; handleUser ( u , true ) ; return true ; } if ( request . getCookies ( ) . getFirstValue ( origRefCookie ) == null ) { origRef = request . getResourceRef ( ) . toString ( ) ; response . getCookieSettings ( ) . add ( origRefCookie , request . getResourceRef ( ) . toString ( ) ) ; } else { origRef = request . getCookies ( ) . getFirstValue ( origRefCookie ) ; } int verified = verifier . verify ( request , response ) ; getLogger ( ) . fine ( \"VERIFIED: \" + verified ) ; if ( verified == Verifier . RESULT_VALID ) { response . getCookieSettings ( ) . removeAll ( identifierCookie ) ; response . getCookieSettings ( ) . add ( identifierCookie , request . getClientInfo ( ) . getUser ( ) . getIdentifier ( ) ) ; handleUser ( request . getClientInfo ( ) . getUser ( ) , false ) ; request . getCookies ( ) . removeAll ( origRefCookie ) ; response . getCookieSettings ( ) . removeAll ( origRefCookie ) ; if ( origRef != null ) { response . redirectPermanent ( origRef ) ; } return true ; } response . getCookieSettings ( ) . removeAll ( identifierCookie ) ; if ( verified == Verifier . RESULT_UNKNOWN || verified == Verifier . RESULT_INVALID ) { origRef = response . getCookieSettings ( ) . getFirstValue ( origRefCookie ) ; if ( origRef == null ) origRef = request . getCookies ( ) . getFirstValue ( origRefCookie ) ; forbid ( origRef , request , response ) ; } return false ; } public void forbid ( String origRef , Request request , Response response ) { if ( forbiddenResource == null ) response . setStatus ( Status . CLIENT_ERROR_FORBIDDEN ) ; else { getLogger ( ) . fine ( \"sending to error resource\" ) ; forbiddenResource . handle ( request , response ) ; } } protected void handleUser ( User user , boolean cached ) { getLogger ( ) . info ( \"Handle User: \" + user . getIdentifier ( ) + \" \" + user . getEmail ( ) ) ; ; } @ Override protected int unauthenticated ( Request request , Response response ) { int ret = super .", "gt": "unauthenticated ( request , response ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 2582, "input": "<s> package javax . lang . model . element ; import java . lang . annotation . Annotation ; import java . lang . annotation . AnnotationTypeMismatchException ; import java . lang . annotation . IncompleteAnnotationException ; import java . util . List ; import java . util . Set ; import javax . lang . model . element . Modifier ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; public interface Element { TypeMirror asType ( ) ; ElementKind getKind ( ) ; List < ? extends AnnotationMirror > getAnnotationMirrors ( ) ; < A extends Annotation >", "gt": "A getAnnotation ( Class < A > annotationType ) ;", "prediction": ";\n", "label": 0}
{"id": 8216, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . tests . harness . util . CallHistory ; import org . eclipse . ui . tests . harness . util . UITestCase ; public abstract class IWorkbenchPartTest extends UITestCase { protected IWorkbenchWindow fWindow ; protected IWorkbenchPage fPage ; public IWorkbenchPartTest ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; fWindow = openTestWindow ( ) ; fPage = fWindow . getActivePage ( ) ; } public void testOpenAndClose ( ) throws Throwable { MockPart part = openPart ( fPage ) ; assertTrue ( part .", "gt": "isSiteInitialized ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 256, "input": "<s> package org . ofbiz . widget . form ; import java . io . IOException ; import java . net . URL ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . model . ModelReader ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . LocalDispatcher ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class FormFactory { public static final String module = FormFactory . class . getName ( ) ; private static final UtilCache < String , ModelForm > formLocationCache = UtilCache . createUtilCache ( \"widget.form.locationResource\" , 0 , 0 , false ) ; private static final UtilCache < String , ModelForm > formWebappCache = UtilCache . createUtilCache ( \"widget.form.webappResource\" , 0 , 0 , false ) ; public static Map < String , ModelForm > getFormsFromLocation ( String resourceName , ModelReader entityModelReader , DispatchContext dispatchContext ) throws IOException , SAXException , ParserConfigurationException { URL formFileUrl = FlexibleLocation . resolveLocation ( resourceName ) ; Document formFileDoc = UtilXml . readXmlDocument ( formFileUrl , true , true ) ; return readFormDocument ( formFileDoc , entityModelReader , dispatchContext , resourceName ) ; } public static ModelForm getFormFromLocation ( String resourceName , String formName , ModelReader entityModelReader , DispatchContext dispatchContext ) throws IOException , SAXException , ParserConfigurationException { String cacheKey = resourceName + \"#\" + formName ; ModelForm modelForm = formLocationCache . get ( cacheKey ) ; if ( modelForm == null ) { URL formFileUrl = FlexibleLocation . resolveLocation ( resourceName ) ; Document formFileDoc = UtilXml . readXmlDocument ( formFileUrl , true , true ) ; if ( formFileDoc == null ) { throw new IllegalArgumentException ( \"Could not find resource [\" + resourceName + \"]\" ) ; } modelForm = createModelForm ( formFileDoc , entityModelReader , dispatchContext , resourceName , formName ) ; modelForm = formLocationCache . putIfAbsentAndGet ( cacheKey , modelForm ) ; } if ( modelForm == null ) { throw new IllegalArgumentException ( \"Could not find form with name [\" + formName + \"] in class resource [\" + resourceName + \"]\" ) ; } return modelForm ; } public static ModelForm getFormFromWebappContext ( String resourceName , String formName , HttpServletRequest request ) throws IOException , SAXException , ParserConfigurationException { String webappName = UtilHttp . getApplicationName ( request ) ; String cacheKey = webappName + \"::\" + resourceName + \"::\" + formName ; ModelForm modelForm = formWebappCache . get ( cacheKey ) ; if ( modelForm == null ) { ServletContext servletContext = ( ServletContext ) request . getAttribute ( \"servletContext\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; URL formFileUrl = servletContext . getResource ( resourceName ) ; Document formFileDoc = UtilXml . readXmlDocument ( formFileUrl , true , true ) ; Element formElement = UtilXml . firstChildElement ( formFileDoc . getDocumentElement ( ) , \"form\" , \"name\" , formName ) ; modelForm = new ModelForm ( formElement , delegator . getModelReader ( ) , dispatcher . getDispatchContext ( ) ) ; modelForm . setFormLocation ( resourceName ) ; modelForm = formWebappCache . putIfAbsentAndGet ( cacheKey , modelForm ) ; } if ( modelForm == null ) { throw new IllegalArgumentException ( \"Could not find form with name [\" + formName + \"] in webapp resource [\" + resourceName + \"] in the webapp [\" + webappName + \"]\" ) ; } return modelForm ; } public static Map < String , ModelForm > readFormDocument ( Document formFileDoc , ModelReader entityModelReader , DispatchContext dispatchContext , String formLocation ) { Map < String , ModelForm > modelFormMap = new HashMap < String , ModelForm > ( ) ; if ( formFileDoc != null ) { Element rootElement = formFileDoc . getDocumentElement ( ) ; List < ? extends Element > formElements = UtilXml . childElementList ( rootElement , \"form\" ) ; for ( Element formElement : formElements ) { String formName = formElement . getAttribute ( \"name\" ) ; String cacheKey = formLocation + \"#\" + formName ; ModelForm modelForm = formLocationCache . get ( cacheKey ) ; if ( modelForm == null ) { modelForm = createModelForm ( formElement , entityModelReader , dispatchContext , formLocation , formName ) ; modelForm = formLocationCache . putIfAbsentAndGet ( cacheKey , modelForm ) ; } modelFormMap . put ( formName , modelForm ) ; } } return modelFormMap ; } public static ModelForm createModelForm ( Document formFileDoc , ModelReader entityModelReader", "gt": ", DispatchContext dispatchContext , String formLocation , String formName )", "prediction": ")\n", "label": 0}
{"id": 8219, "input": "<s> package org . jscsi . parser . reject ; import java . util . HashMap ; import java . util . Map ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . Constants ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . TargetMessageParser ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . utils . Utils ; public final class RejectParser extends TargetMessageParser { public static enum ReasonCode { RESERVED ( ( byte ) 0x01 ) , DATA_DIGEST_ERROR ( ( byte ) 0x02 ) , SNACK_REJECT ( ( byte ) 0x03 ) , PROTOCOL_ERROR ( ( byte ) 0x04 ) , COMMAND_NOT_SUPPORTED ( ( byte ) 0x05 ) , IMMEDIATE_COMMAND_REJECT ( ( byte ) 0x06 ) , TASK_IN_PROGRESS ( ( byte ) 0x07 ) , INVALID_DATA_ACK ( ( byte ) 0x08 ) , INVALID_PDU_FIELD ( ( byte ) 0x09 ) , LONG_OPERATION_REJECT ( ( byte ) 0x0A ) , NEGOTIATION_RESET ( ( byte ) 0x0B ) , WAITING_FOR_LOGOUT ( ( byte ) 0x0C ) ; private final byte value ; private static Map < Byte , ReasonCode > mapping ; static { ReasonCode . mapping = new HashMap < Byte , ReasonCode > ( ) ; for ( ReasonCode s : values ( ) ) { ReasonCode . mapping . put ( s . value , s ) ; } } private ReasonCode ( final byte newValue ) { value = newValue ; } public final byte value ( ) { return value ; } public static final ReasonCode valueOf ( final byte value ) { return ReasonCode . mapping . get ( value ) ; } } private ReasonCode reasonCode ; private int dataSequenceNumber ; public RejectParser ( final ProtocolDataUnit initProtocolDataUnit ) { super ( initProtocolDataUnit ) ; } public final int getDataSequenceNumber ( ) { return dataSequenceNumber ; } public final ReasonCode getReasonCode ( ) { return reasonCode ; } @ Override public final String toString ( ) { final StringBuilder sb = new StringBuilder ( Constants . LOG_INITIAL_SIZE ) ; Utils . printField ( sb , \"Reason\" , reasonCode . value , 1 ) ; sb . append ( super . toString ( ) ) ; Utils . printField ( sb , \"Data SN\" , dataSequenceNumber , 1 ) ; return sb . toString ( ) ; } @ Override public final DataSegmentFormat getDataSegmentFormat ( ) { return DataSegmentFormat . BINARY ; } @ Override public final void clear ( ) { super . clear ( ) ; reasonCode = null ; dataSequenceNumber = 0x00000000 ; } @ Override protected final void deserializeBytes1to3 (", "gt": "final int line ) throws InternetSCSIException", "prediction": ")\n", "label": 1}
{"id": 7804, "input": "<s> package org . ofbiz . base . config ; import java . io . InputStream ; import java . net . URL ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . Debug ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public final class MainResourceHandler implements ResourceHandler { public static final String module = MainResourceHandler . class . getName ( ) ; protected final String xmlFilename ; protected final String loaderName ; protected final String location ; public MainResourceHandler ( String xmlFilename , Element element ) { this . xmlFilename = xmlFilename ; this . loaderName = element . getAttribute ( \"loader\" ) ; this . location = element . getAttribute ( \"location\" ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Created \" + this . toString ( ) , module ) ; } public MainResourceHandler ( String xmlFilename , String loaderName , String location ) { this . xmlFilename = xmlFilename ; this . loaderName = loaderName ; this . location = location ; } public String getLoaderName ( ) { return this . loaderName ; } public String getLocation ( ) { return this . location ; } public Document getDocument ( ) throws GenericConfigException { try { return UtilXml . readXmlDocument ( this . getStream ( ) , this . xmlFilename , true ) ; } catch ( org . xml . sax . SAXException e ) { throw new GenericConfigException ( \"Error reading \" + this . toString ( ) , e ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { throw new GenericConfigException ( \"Error reading \" + this . toString ( ) , e ) ; } catch ( java . io . IOException e ) { throw new GenericConfigException ( \"Error reading \" + this . toString ( ) , e ) ; } } public InputStream getStream ( ) throws GenericConfigException { return ResourceLoader . loadResource ( this . xmlFilename , this . location , this . loaderName ) ; } public URL getURL ( ) throws GenericConfigException { return ResourceLoader . getURL ( this . xmlFilename , this . location , this . loaderName ) ; } public boolean isFileResource ( ) throws GenericConfigException { ResourceLoader loader = ResourceLoader . getLoader ( this . xmlFilename , this . loaderName ) ; if ( loader instanceof FileLoader ) { return true ; } else { return false ; } } public String getFullLocation ( ) throws GenericConfigException { ResourceLoader loader = ResourceLoader . getLoader", "gt": "( this . xmlFilename , this . loaderName ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8221, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . queryParser . ParseException ; import org . apache . lucene . search . Query ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; public class FileBasedQueryMaker extends AbstractQueryMaker implements QueryMaker { protected Query [ ] prepareQueries ( ) throws Exception { Analyzer anlzr = ( Analyzer ) Class . forName ( config . get ( \"analyzer\" , \"org.apache.lucene.analysis.standard.StandardAnalyzer\" ) ) . newInstance ( ) ; String defaultField = config . get ( \"file.query.maker.default.field\" , DocMaker . BODY_FIELD ) ; QueryParser qp = new QueryParser ( defaultField , anlzr ) ; List qq = new ArrayList ( ) ; String fileName = config . get ( \"file.query.maker.file\" , null ) ; if ( fileName != null ) { File file = new File ( fileName ) ; Reader reader = null ; if ( file . exists ( ) ) { reader = new FileReader ( file ) ; } else { InputStream asStream = FileBasedQueryMaker . class . getClassLoader ( ) . getResourceAsStream ( fileName ) ; if ( asStream != null ) { reader = new InputStreamReader ( asStream ) ; } } if ( reader != null ) { try { BufferedReader buffered = new BufferedReader ( reader ) ; String line = null ; int lineNum = 0 ; while ( ( line = buffered . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( ! line . equals ( \"\" ) && ! line", "gt": ". startsWith ( \"#\" ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 5707, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Currency ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class CurrencyImpl extends ProjectAttributeImpl implements Currency { protected static final String CURRENCY_EDEFAULT = null ; protected String currency = CURRENCY_EDEFAULT ; protected CurrencyImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getCurrency ( ) ; } public String getCurrency ( ) { return currency ; } public void setCurrency ( String newCurrency ) { String oldCurrency = currency ; currency = newCurrency ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . CURRENCY__CURRENCY , oldCurrency , currency ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . CURRENCY__CURRENCY : return getCurrency ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . CURRENCY__CURRENCY : setCurrency ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . CURRENCY__CURRENCY : setCurrency ( CURRENCY_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }", "gt": "@ Override public boolean eIsSet ( int featureID )", "prediction": "}\n", "label": 0}
{"id": 8238, "input": "<s> package org . apache . lucene . store ; import java . io . IOException ; import java . io . FileNotFoundException ; import java . io . File ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Set ; public class RAMDirectory extends Directory implements Serializable { private static final long serialVersionUID = 1l ; HashMap fileMap = new HashMap ( ) ; long sizeInBytes ; public RAMDirectory ( ) { setLockFactory ( new SingleInstanceLockFactory ( ) ) ; } public RAMDirectory ( Directory dir ) throws IOException { this ( dir , false ) ; } private RAMDirectory ( Directory dir , boolean closeDir ) throws IOException { this ( ) ; Directory . copy ( dir , this , closeDir ) ; } public RAMDirectory ( File dir ) throws IOException { this ( FSDirectory . getDirectory ( dir ) , true ) ; } public RAMDirectory ( String dir ) throws IOException { this ( FSDirectory . getDirectory ( dir ) , true ) ; } public synchronized final String [ ] list ( ) { return listAll ( ) ; } public synchronized final String [ ] listAll ( ) { ensureOpen ( ) ; Set fileNames = fileMap . keySet ( ) ; String [ ] result = new String [ fileNames . size ( ) ] ; int i = 0 ; Iterator it = fileNames . iterator ( ) ; while ( it . hasNext ( ) ) result [ i ++ ] = ( String ) it . next ( ) ; return result ; } public final boolean fileExists ( String name ) { ensureOpen ( ) ; RAMFile file ; synchronized ( this ) { file = ( RAMFile ) fileMap . get ( name ) ; } return file != null ; } public final long fileModified ( String name ) throws IOException { ensureOpen ( ) ; RAMFile file ; synchronized ( this ) { file = ( RAMFile ) fileMap . get ( name ) ; } if ( file == null ) throw new FileNotFoundException ( name ) ; return file . getLastModified ( ) ; } public void touchFile ( String name ) throws IOException { ensureOpen ( ) ; RAMFile file ; synchronized ( this ) { file = ( RAMFile ) fileMap . get ( name ) ; } if ( file == null ) throw new FileNotFoundException ( name ) ; long ts2 , ts1 = System . currentTimeMillis ( ) ; do { try { Thread . sleep ( 0 , 1 ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( ie ) ; } ts2 = System . currentTimeMillis ( ) ; } while ( ts1 == ts2 ) ; file . setLastModified ( ts2 ) ; } public final long fileLength ( String name ) throws IOException { ensureOpen ( ) ; RAMFile file ; synchronized ( this ) { file =", "gt": "( RAMFile ) fileMap . get ( name ) ;", "prediction": ";\n", "label": 1}
{"id": 2189, "input": "<s> package org . meqantt ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . UnknownHostException ; import java . util . concurrent . Semaphore ; import org . meqantt . message . ConnAckMessage ; import org . meqantt . message . ConnectMessage ; import org . meqantt . message . DisconnectMessage ; import org . meqantt . message . Message ; import org . meqantt . message . MessageInputStream ; import org . meqantt . message . MessageOutputStream ; import org . meqantt . message . PublishMessage ; import org . meqantt . message . QoS ; import org . meqantt . message . SubscribeMessage ; public class SocketClient { private MessageInputStream in ; private Socket socket ; private MessageOutputStream out ; private MqttReader reader ; private Semaphore connectionAckLock ; private final String id ; public SocketClient ( String id ) { this . id = id ; } public void connect ( String host , int port ) throws UnknownHostException , IOException , InterruptedException { socket = new Socket ( host , port ) ; InputStream is = socket . getInputStream ( ) ; in = new MessageInputStream ( is ) ; OutputStream os = socket . getOutputStream ( ) ; out = new MessageOutputStream ( os ) ; reader = new MqttReader ( ) ; reader . start ( ) ; ConnectMessage msg = new ConnectMessage ( id , false , 60 ) ; connectionAckLock = new Semaphore ( 0 ) ; out . writeMessage ( msg ) ; connectionAckLock . acquire ( ) ; } public void publish ( String topic , String message ) throws IOException { PublishMessage msg = new PublishMessage ( topic , message ) ; out . writeMessage ( msg ) ; } public void subscribe ( String topic ) throws IOException { SubscribeMessage msg = new SubscribeMessage ( topic , QoS . AT_MOST_ONCE ) ; out . writeMessage ( msg ) ; } public void disconnect ( ) throws IOException { DisconnectMessage msg = new DisconnectMessage ( ) ; out . writeMessage ( msg ) ; socket . close ( ) ; } private void handleMessage ( Message msg ) { if ( msg == null ) { return ; } switch ( msg . getType ( ) ) { case", "gt": "CONNACK : handleMessage ( ( ConnAckMessage ) msg ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8253, "input": "<s> package tk . blackwolf12333 . grieflog ; import java . util . ArrayList ; import java . util . HashMap ; import org . bukkit . Bukkit ; import org . bukkit . ChatColor ; import org . bukkit . Location ; import org . bukkit . Server ; import org . bukkit . World ; import org . bukkit . command . ConsoleCommandSender ; import org . bukkit . conversations . Conversable ; import org . bukkit . conversations . Conversation ; import org . bukkit . conversations . ConversationAbandonedEvent ; import org . bukkit . entity . Player ; import com . sk89q . worldedit . bukkit . WorldEditPlugin ; import com . sk89q . worldedit . bukkit . selections . Selection ; import tk . blackwolf12333 . grieflog . callback . RollbackCallback ; import tk . blackwolf12333 . grieflog . callback . WorldEditFilterCallback ; import tk . blackwolf12333 . grieflog . data . BaseData ; import tk . blackwolf12333 . grieflog . utils . ResultPage ; import tk . blackwolf12333 . grieflog . utils . config . ConfigHandler ; public class PlayerSession implements Conversable { World world ; Player player ; GriefLog plugin ; ConsoleCommandSender sender ; Boolean worldedit ; HashMap < Integer , ResultPage > pages ; Conversation conversation ; public Integer rollbackTaskID ; public Thread worldeditFilter ; public Thread searchTask ; public Thread rollbackThread ; boolean isDoingRollback = false ; boolean isSearching = false ; boolean isUsingTool = false ; public boolean we = false ; public HashMap < Location , String > playersIgnitedTNT = new HashMap < Location , String > ( ) ; public ArrayList < BaseData > result = new ArrayList < BaseData > ( ) ; public PlayerSession ( GriefLog plugin , Player player ) { this . player = player ; this . plugin = plugin ; } public PlayerSession ( GriefLog plugin , ConsoleCommandSender sender ) { this . sender = sender ; this . plugin = plugin ; } public void rollback ( boolean we , ArrayList < String > args ) { String [ ] arg = new String [ args . size ( ) ] ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { arg [ i ] = args . get ( i ) ; } if ( we ) { new SearchTask ( this , new WorldEditFilterCallback ( this ) , arg ) ; } else { new SearchTask ( this , new RollbackCallback ( this ) , arg ) ; } } public void print ( String msg ) { if ( player == null ) { sender . sendMessage ( msg ) ; } else { player . sendMessage ( msg ) ; } } public void print ( String [ ] msg ) { if ( msg != null ) { for ( int i = 0 ; i < msg . length ; i ++ ) { if ( msg [ i ] != null ) { if ( player == null ) { sender . sendMessage ( msg [ i ] ) ; } else { player . sendMessage ( msg [ i ] ) ; } } } } } public void print ( BaseData [ ] msg ) { if ( msg != null ) { for ( int i = 0 ; i < msg . length ; i ++ ) { if ( msg [ i ] != null ) { if ( player == null ) { sender . sendMessage ( msg [ i ] . toString ( ) ) ; } else { player . sendMessage ( msg [ i ] . toString ( ) ) ; } } } } } public void printMinimal ( BaseData [ ] msg ) { if ( msg != null ) { for ( int i = 0 ; i < msg . length ; i ++ ) { if ( msg [ i ] != null ) { if ( player == null ) { sender . sendMessage ( msg [ i ] . getMinimal ( ) ) ; } else { player . sendMessage ( msg [ i ] . getMinimal ( ) ) ; } } } } } public void print ( ArrayList < String > msg ) { if ( msg != null ) { for ( int i = 0 ; i < msg . size ( ) ; i ++ ) { if ( msg . get ( i ) != null ) { if ( player == null ) { sender . sendMessage ( msg . get ( i ) ) ; } else { player . sendMessage ( msg . get ( i ) ) ; } } } } } public boolean cancelRollback ( ) { if ( this . rollbackTaskID == null ) { this . print ( ChatColor . YELLOW + \"[GriefLog] You don't have any rollback's going on right now.\" ) ; return true ; } Bukkit . getScheduler ( ) . cancelTask ( this . getRollbackTaskID ( ) ) ; this . rollbackTaskID = null ; this . setDoingRollback ( false ) ; this . print ( ChatColor . YELLOW + \"[GriefLog] Rollback cancelled.\" ) ; return true ; } public boolean teleport ( Location to ) { return player . teleport ( to ) ; } public GriefLog getGriefLog ( ) { return plugin ; } public World getWorld ( ) { return player . getWorld ( ) ; } public Server getServer ( ) { return player . getServer ( ) ; } public Player getPlayer ( ) { return player ; } public", "gt": "ArrayList < BaseData > getSearchResult ( )", "prediction": "}\n", "label": 1}
{"id": 142, "input": "<s> package jns . trace ; public class EventParameter { public String name ; public Object value ; public EventParameter ( ) { name = new String ( ) ; value = null ; } public EventParameter ( String name , Object value ) { this", "gt": ". name = name ;", "prediction": ";\n", "label": 0}
{"id": 8270, "input": "<s> package org . nuxeo . ecm . platform . gwt . client ; import org . nuxeo . ecm . platform . gwt . client . ui . ExtensionPoints ; import org . nuxeo . ecm . platform . gwt . client . ui . admin . AdministrationView ; import org . nuxeo . ecm . platform . gwt . client . ui . clipboard . ClipboardView ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . DocumentEditor ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . DocumentMetadataPage ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . DocumentViewPage ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . FolderViewPage ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . HtmlView ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . SmartEditorManager ; import org . nuxeo . ecm . platform . gwt . client . ui . editor . UrlView ; import org . nuxeo . ecm . platform . gwt . client . ui . impl . Footer ; import org . nuxeo . ecm . platform . gwt . client . ui . impl . Header ; import org . nuxeo . ecm . platform . gwt . client . ui . impl . SmartApplication ; import org . nuxeo . ecm . platform . gwt . client . ui . impl . ViewStack ; import org . nuxeo . ecm . platform . gwt . client . ui . navigator . NavigatorView ; import org . nuxeo . ecm . platform . gwt . client . ui . search . SearchEditor ; @ Bundle ( DefaultBundle . class ) public interface SmartBundle extends ApplicationBundle { @ Extension ( targets", "gt": "= Framework . APPLICATION_XP ) @ ExtensionPoint (", "prediction": ")\n", "label": 1}
{"id": 5757, "input": "<s> package com . redhat . ceylon . compiler . java . loader . mirror ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . sun . tools . javac . code . Attribute ; import com . sun . tools . javac . code . Attribute . Compound ; import com . sun . tools . javac . code . Symbol . MethodSymbol ; import com . sun . tools . javac . util . Pair ; public class JavacAnnotation implements AnnotationMirror { private Compound annotation ; private Map < String , Object > attributes ; public JavacAnnotation ( Compound annotation ) { this . annotation = annotation ; attributes = new HashMap < String , Object > ( ) ; } @ Override public Object getValue ( String fieldName ) { Object result = attributes . get ( fieldName ) ; if ( result == null ) { Attribute attr = member ( fieldName ) ; result = attributeToRefl ( attr ) ; attributes . put ( fieldName , result ) ; } return result ; } private Object attributeToRefl ( Attribute attr ) { if ( attr == null ) return null ; if ( attr instanceof Attribute . Constant ) return attr . getValue ( ) ; if ( attr", "gt": "instanceof Attribute . Array )", "prediction": ") ;\n", "label": 0}
{"id": 8294, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermDocs ; import org . apache . lucene . index . TermEnum ; import org . apache . lucene . util . OpenBitSet ; import java . io . IOException ; import java . util . BitSet ; public class MultiTermQueryWrapperFilter extends Filter { protected final MultiTermQuery query ; protected MultiTermQueryWrapperFilter ( MultiTermQuery query ) { this . query = query ; } public String toString ( ) { return query . toString ( ) ; } public final boolean equals ( final Object o ) { if ( o == this ) return true ; if ( o == null ) return false ; if ( this . getClass ( ) . equals ( o . getClass ( ) ) ) { return this . query . equals ( ( ( MultiTermQueryWrapperFilter ) o ) . query ) ; } return false ; } public final int hashCode ( ) { return query . hashCode ( ) ; } public int getTotalNumberOfTerms ( ) { return query . getTotalNumberOfTerms ( ) ; } public void clearTotalNumberOfTerms ( ) { query . clearTotalNumberOfTerms ( ) ; } abstract class TermGenerator { public void generate ( IndexReader reader , TermEnum enumerator ) throws IOException { final int [ ] docs = new int [ 32 ] ; final int [ ] freqs = new int [ 32 ] ; TermDocs termDocs = reader . termDocs ( ) ; try { int termCount = 0 ; do { Term term = enumerator . term ( ) ; if ( term == null ) break ; termCount ++ ; termDocs . seek ( term ) ; while ( true ) { final int count = termDocs . read ( docs , freqs ) ; if ( count != 0 ) { for ( int i = 0 ; i < count ; i ++ ) { handleDoc ( docs [ i ] ) ; } } else { break ; } } } while ( enumerator . next ( ) ) ; query . incTotalNumberOfTerms ( termCount ) ; } finally { termDocs . close ( ) ; } } abstract public void handleDoc ( int doc ) ; } public BitSet bits ( IndexReader reader ) throws IOException { final TermEnum enumerator = query . getEnum ( reader ) ; try { final BitSet bitSet = new BitSet ( reader . maxDoc ( ) ) ; new TermGenerator ( ) { public void handleDoc ( int doc ) { bitSet .", "gt": "set ( doc ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8567, "input": "<s> package org . ofbiz . accounting . thirdparty . authorizedotnet ; import java . util . Map ; import javolution . util . FastMap ; public class CPRespPositions extends AuthorizeResponse . RespPositions { private static Map < String , Integer > positions = FastMap . newInstance ( ) ; static { positions . put ( AuthorizeResponse . RESPONSE_CODE , 2 ) ; positions . put ( AuthorizeResponse . REASON_CODE , 3 ) ; positions . put ( AuthorizeResponse . REASON_TEXT , 4 ) ; positions . put ( AuthorizeResponse . AUTHORIZATION_CODE , 5 ) ; positions . put ( AuthorizeResponse . AVS_RESULT_CODE , 6 ) ; positions . put ( AuthorizeResponse . CVV_RESULT_CODE , 7 ) ; positions . put ( AuthorizeResponse . TRANSACTION_ID , 8 ) ; positions .", "gt": "put ( AuthorizeResponse . AMOUNT , 25 ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 8301, "input": "<s> package br . org . archimedes . io . svg . rcp ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.io.svg.messages\" ; public static String SVGWizardExporter_ErrorBoxTitle ; public static String SVGExporter_NoExporter ; public static String SVGWizardExporter_ErrorBoxMessage ; public static String SVGWizardExporter_ExporterName ; public static String SVGFilePickerPage_WindowTitle ; public static String SVGFilePickerPage_WindowMessage ; public static String SVGFilePickerPage_Extension ; public static String SVGFilePickerPage_ExtensionName ; public static String SVGFilePickerPage_ChooseWindowMessage ;", "gt": "public static String SVGFilePickerPage_BrowseButtonText ;", "prediction": "}\n", "label": 1}
{"id": 9398, "input": "<s> package pkg ; public class Wildcards { public void methodWithWildCardParam ( TypeParameters < ? super String > a , TypeParameters <", "gt": "? extends StringBuffer > b , TypeParameters c )", "prediction": ") ;\n", "label": 0}
{"id": 8319, "input": "<s> package org . restlet . ext . sip . internal ; import java . io . IOException ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Response ; import org . restlet . Server ; import org . restlet . data . CacheDirective ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ClientInfo ; import org . restlet . data . Conditions ; import org . restlet . data . Cookie ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . data . Range ; import org . restlet . data . RecipientInfo ; import org . restlet . data . Reference ; import org . restlet . data . Tag ; import org . restlet . data . Warning ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . connector . InboundRequest ; import org . restlet . engine . header . CacheDirectiveReader ; import org . restlet . engine . header . CookieReader ; import org . restlet . engine . header . ExpectationReader ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . HeaderReader ; import org . restlet . engine . header . PreferenceReader ; import org . restlet . engine . header . RangeReader ; import org . restlet . engine . header . RecipientInfoReader ; import org . restlet . engine . header . WarningReader ; import org . restlet . engine . security . AuthenticatorUtils ; import org . restlet . engine . util . DateUtils ; import org . restlet . ext . sip . Address ; import org . restlet . ext . sip . ContactInfo ; import org . restlet . ext . sip . Event ; import org . restlet . ext . sip . EventType ; import org . restlet . ext . sip . OptionTag ; import org . restlet . ext . sip . Priority ; import org . restlet . ext . sip . SipRecipientInfo ; import org . restlet . ext . sip . SipRequest ; import org . restlet . ext . sip . Subscription ; import org . restlet . util . Series ; public class SipInboundRequest extends SipRequest implements InboundRequest { private volatile boolean cacheDirectivesAdded ; private volatile boolean clientAdded ; private volatile boolean conditionAdded ; private final Connection < Server > connection ; private final Context context ; private volatile boolean cookiesAdded ; private volatile String protocol ; private volatile boolean proxySecurityAdded ; private volatile boolean rangesAdded ; private volatile boolean recipientsInfoAdded ; private volatile boolean referrerAdded ; private volatile String resourceUri ; private volatile boolean securityAdded ; private final Principal userPrincipal ; private volatile boolean warningsAdded ; private volatile boolean alertInfoAdded ; private volatile boolean allowedEventTypesAdded ; private volatile boolean callerInfoAdded ; private volatile boolean contactAdded ; private volatile boolean eventAdded ; private volatile boolean inReplyToAdded ; private volatile boolean priorityAdded ; private volatile boolean proxyRequiresAdded ; private volatile boolean sipRecipientsInfoAdded ; private volatile boolean recordedRoutesAdded ; private volatile boolean referToAdded ; private volatile boolean replyToAdded ; private volatile boolean requiresAdded ; private volatile boolean routesAdded ; private volatile boolean sipIfMatchAdded ; private volatile boolean subscriptionAdded ; private volatile boolean supportedAdded ; public SipInboundRequest ( Context context , Connection < Server > connection , String methodName , String resourceUri , String protocol ) { super ( ) ; this . context = context ; this . cacheDirectivesAdded = false ; this . clientAdded = false ;", "gt": "this . conditionAdded = false ;", "prediction": "}\n", "label": 1}
{"id": 9616, "input": "<s> package com . gisgraphy . client . gisfeature ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . californiaAdm1 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . ileDeFranceAdm1 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . losAngelesAdm2 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . parisAdm2 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . parisAdm3 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . parisAdm4 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . rambouilletAdm3 ; import static com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother . yvelinesAdm2 ; import static com . gisgraphy . client . administrativedivision . CountryObjectMother . france ; import static com . gisgraphy . client . administrativedivision . CountryObjectMother . unitedStatesCountry ; import static com . gisgraphy . client . gisfeature . GeonamesGisFeature . gisFeature ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . antarcticaCountryGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . californiaAdm1GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . franceCountryGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . ileDeFranceAdm1GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . losAngelesAdm2GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . losAngelesPplGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . marinaDelReyPplGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . parisAdm2GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . parisAdm3GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . parisPplcGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . rambouilletAdm3GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . rambouilletAdm4GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . rambouilletPPlGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . unitedStatesCountryGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . usOutlyingIslandsCountryGisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureGeographyObjectMother . yvelinesAdm2GisFeatureGeography ; import static com . gisgraphy . client . gisfeature . GisFeatureNames . gisFeatureName ; import static com . gisgraphy . client . gisfeature . GisFeatureType . geonamesFeatureClass ; import com . gisgraphy . client . administrativedivision . AdministrativeDivisionObjectMother ; public class GisFeatureObjectMother { public static GeonamesGisFeature unitedStatesGisFeature ( ) { return gisFeature ( ) . geonamesId ( 6252001L ) . names ( gisFeatureName ( \"United States\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"PCLI\" ) ) . geography ( unitedStatesCountryGisFeatureGeography ( ) ) . build ( ) ; } public static GeonamesGisFeature californiaAdm1GisFeature ( ) { return gisFeature ( ) . geonamesId ( 5332921L ) . names ( gisFeatureName ( \"California\" ) ) . type ( geonamesFeatureClass ( \"A\" ) . geonamesFeatureCode ( \"ADM1\" ) ) . geography ( californiaAdm1GisFeatureGeography ( ) ) . parentAdministrativeEntity ( unitedStatesCountry ( ) ) . build ( ) ; } public static GeonamesGisFeature losAngelesPplGisFeature ( ) { return gisFeature ( ) . geonamesId ( 5368361L ) . names ( gisFeatureName ( \"Los Angeles\" ) ) . type ( geonamesFeatureClass ( \"P\" ) . geonamesFeatureCode ( \"PPL\" ) ) . geography ( losAngelesPplGisFeatureGeography ( ) ) . parentAdministrativeEntity ( losAngelesAdm2 ( ) ) . build ( ) ; } public static GeonamesGisFeature marinaDelReyPplGisFeature ( ) { return gisFeature ( ) . geonamesId ( 5370542L ) . names ( gisFeatureName ( \"Marina Del Rey\" ) ) . type ( geonamesFeatureClass ( \"P\" ) . geonamesFeatureCode ( \"PPL\" ) ) . geography ( marinaDelReyPplGisFeatureGeography ( ) ) . parentAdministrativeEntity ( losAngelesAdm2 ( )", "gt": ") . build ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8321, "input": "<s> package org . nuxeo . ecm . platform . publisher . web ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . annotations . In ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . security . SecurityConstants ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . webapp . helpers . ResourcesAccessor ; public abstract class AbstractPublishActions { private static final Log log = LogFactory . getLog ( AbstractPublishActions . class ) ; @ In ( create = true ) protected transient NavigationContext navigationContext ; @ In ( create = true , required = false ) protected transient CoreSession documentManager ; @ In ( create = true ) protected transient ResourcesAccessor resourcesAccessor ; public String getFormattedPath ( DocumentModel documentModel ) throws ClientException { List < String > pathFragments = new ArrayList < String > ( ) ; getPathFragments ( documentModel , pathFragments ) ; return formatPathFragments ( pathFragments ) ; } protected static String formatPathFragments ( List < String > pathFragments ) { String fullPath = \"\" ; for ( String aFragment : pathFragments ) { if ( ! \"\" . equals ( fullPath ) ) { fullPath = \">\" + fullPath ; } fullPath = aFragment + fullPath ; } return fullPath ; } protected void getPathFragments ( DocumentModel documentModel , List < String > pathFragments ) throws ClientException { String pathElementName = documentModel . getTitle ( ) ; String translatedPathElement = resourcesAccessor . getMessages ( ) . get ( pathElementName ) ; pathFragments . add ( translatedPathElement ) ; if ( \"Domain\" . equals", "gt": "( documentModel . getType ( ) ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 6010, "input": "<s> package p1 ; public class T4720356a { void m ( ) { } } class T4720356c extends p2 . T4720356b {", "gt": "public int m ( )", "prediction": "( ) ;\n", "label": 0}
{"id": 8332, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs . io . writers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyWriter ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; @ Produces ( { \"application/json+nxentity\" , \"application/json\" } ) public class JsonPrimitiveWriter implements MessageBodyWriter < Object > { @ Override public long getSize ( Object arg0 , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 ) { return - 1 ; } @ Override public boolean isWriteable ( Class < ? > typeClass , Type arg1 , Annotation [ ] arg2 , MediaType arg3 ) { if ( typeClass == String . class ) { return true ; } if ( typeClass == Boolean . class ) { return true ; } if ( Number . class . isAssignableFrom ( typeClass ) ) { return true ; } return false ; } @ Override public void writeTo ( Object value , Class < ? > arg1 , Type arg2 , Annotation [ ] arg3 , MediaType arg4 , MultivaluedMap < String , Object", "gt": "> arg5 , OutputStream out ) throws IOException , WebApplicationException", "prediction": ") ;\n", "label": 1}
{"id": 8375, "input": "<s> package org . ofbiz . content . webapp . ftl ; import java . io . IOException ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import freemarker . core . Environment ; import freemarker . template . TemplateTransformModel ; public class RenderSubContentAsText implements TemplateTransformModel { public static final String module = RenderSubContentAsText . class . getName ( ) ; public static final String [ ] upSaveKeyNames = { \"globalNodeTrail\" } ; public static final String [ ] saveKeyNames = { \"contentId\" , \"subContentId\" , \"subDataResourceTypeId\" , \"mimeTypeId\" , \"whenMap\" , \"locale\" , \"wrapTemplateId\" , \"encloseWrapText\" , \"nullThruDatesOnly\" , \"globalNodeTrail\" } ; @ SuppressWarnings ( \"unchecked\" ) public Writer getWriter ( final Writer out , Map args ) { final Environment env = Environment . getCurrentEnvironment ( ) ; final LocalDispatcher dispatcher = FreeMarkerWorker . getWrappedObject ( \"dispatcher\" , env ) ; final Delegator delegator = FreeMarkerWorker . getWrappedObject ( \"delegator\" , env ) ; final HttpServletRequest request = FreeMarkerWorker . getWrappedObject ( \"request\" , env ) ; final Map < String , Object > templateRoot = FreeMarkerWorker . createEnvironmentMap ( env ) ; if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"in RenderSubContent, contentId(0):\" + templateRoot . get ( \"contentId\" ) , module ) ; } FreeMarkerWorker . getSiteParameters ( request , templateRoot ) ; final Map < String , Object > savedValuesUp = FastMap . newInstance ( ) ; FreeMarkerWorker . saveContextValues ( templateRoot , upSaveKeyNames , savedValuesUp ) ; FreeMarkerWorker . overrideWithArgs ( templateRoot , args ) ; if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"in RenderSubContent, contentId(2):\" + templateRoot . get ( \"contentId\" ) , module ) ; } final String thisContentId = ( String ) templateRoot . get ( \"contentId\" ) ; final String thisMapKey = ( String ) templateRoot . get ( \"mapKey\" ) ; final String xmlEscape = ( String ) templateRoot . get ( \"xmlEscape\" ) ; if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"in Render(0), thisSubContentId .\" + thisContentId , module ) ; } final boolean directAssocMode = UtilValidate . isNotEmpty ( thisContentId ) ? true : false ; if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"in Render(0), directAssocMode .\" + directAssocMode , module ) ; } final Map < String , Object > savedValues = FastMap . newInstance ( ) ; return new Writer ( out ) { @ Override public void write ( char cbuf [ ] , int off , int len ) { } @ Override public void flush ( ) throws IOException { out . flush ( ) ; } @ Override public void close ( ) throws IOException { List < Map < String , ? extends Object > > globalNodeTrail = UtilGenerics . checkList ( templateRoot . get ( \"globalNodeTrail\" ) ) ; if ( Debug . infoOn ( ) ) { Debug . logInfo ( \"Render close, globalNodeTrail(2a):\" + ContentWorker . nodeTrailToCsv ( globalNodeTrail ) , \"\" ) ; } renderSubContent ( ) ; } public void renderSubContent ( ) throws IOException { String mimeTypeId = ( String ) templateRoot . get ( \"mimeTypeId\" ) ; Object localeObject = templateRoot . get ( \"locale\" ) ; Locale locale = null ; if ( localeObject == null ) { locale = UtilHttp . getLocale ( request ) ; } else { locale = UtilMisc . ensureLocale ( localeObject ) ; } String editRequestName", "gt": "= ( String ) templateRoot . get ( \"editRequestName\" ) ;", "prediction": "( )\n", "label": 0}
{"id": 8339, "input": "<s> package org . nuxeo . ecm . platform . relations . core . listener ; import java . util . ArrayList ; import java . util . List ; import org . junit . Before ; import org . junit . After ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . storage . sql . SQLRepositoryTestCase ; import org . nuxeo . ecm . platform . comment . api . CommentableDocument ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . RelationManager ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . api . impl . LiteralImpl ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . ecm . platform . relations . api . impl . StatementImpl ; import org . nuxeo . ecm . platform . relations . api . util . RelationConstants ; import org . nuxeo . runtime . api . Framework ; public class PublishRelationsListenerTestCase extends SQLRepositoryTestCase { protected static final Resource conformsTo = new ResourceImpl ( \"http://purl.org/dc/terms/ConformsTo\" ) ; protected static final String COMMENTS_GRAPH_NAME = \"documentComments\" ; protected static final String DOCUMENT_NAMESPACE_NOSLASH = \"http://www.nuxeo.org/document/uid\" ; protected DocumentModel doc1 ; protected DocumentModel doc2 ; protected DocumentModel workspace ; protected DocumentModel section ; protected RelationManager relationManager ; @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.relations.api\" ) ; deployBundle ( \"org.nuxeo.ecm.relations\" ) ; deployBundle ( \"org.nuxeo.ecm.relations.jena\" ) ; deployBundle ( \"org.nuxeo.ecm.relations.core.listener\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.comment.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.comment\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.relations.core.listener.tests\" ) ; openSession ( ) ; relationManager = Framework . getService ( RelationManager . class ) ; workspace = session . createDocumentModel ( \"Folder\" ) ; workspace . setProperty ( \"dublincore\" , \"title\" , \"Workspace\" ) ; workspace . setPathInfo ( \"/\" , \"workspace\" ) ; workspace = session . createDocument ( workspace ) ; section = session . createDocumentModel ( \"Folder\" ) ; section . setProperty", "gt": "( \"dublincore\" , \"title\" , \"Section\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4261, "input": "<s> package javax . tools ; public interface DiagnosticListener < S > { void report ( Diagnostic < ? extends", "gt": "S > diagnostic ) ;", "prediction": ")\n", "label": 0}
{"id": 8346, "input": "<s> package org . apache . lucene . queryParser . core . config ; public interface FieldConfigListener { void buildFieldConfig", "gt": "( FieldConfig fieldConfig ) ;", "prediction": ";\n", "label": 1}
{"id": 2806, "input": "<s> public class Null2DArray { public static void main ( final String [ ] args ) { try { float [ ] [ ] channels = null ; channels [ 0 ] =", "gt": "new float [ 10 ] ;", "prediction": ";\n", "label": 0}
{"id": 8347, "input": "<s> package fr . inria . zvtm . lens ; public interface TemporalLens { public void setAbsolutePosition ( int ax , int ay , long absTime ) ; public void updateTimeBasedParams ( ) ; public void updateTimeBasedParams ( int cx", "gt": ", int cy ) ;", "prediction": ")\n", "label": 1}
{"id": 6406, "input": "<s> package dbprocess ; import static org . junit . Assert . * ; import java . sql . SQLException ; import java . util . ArrayList ; import org . apache . log4j . Logger ; import model . Book ; import model . Cart ; import model . PaymentInfo ; import model . User ; import org . junit . Test ; import exceptions . CartException ; import exceptions . NoUsernameOrPasswordException ; import exceptions . NullUserException ; import exceptions . UserAlreadyExistsException ; public class DatabaseProcessJUnit { private DatabaseProcess db = DatabaseProcess . getInstance ( ) ; Logger log = Logger . getLogger ( DatabaseProcessJUnit . class ) ; @ Test public void testCreateUser ( ) throws SQLException { log . debug ( \"testCreateUser Entered.\" ) ; try { boolean res ; res = db . createUser ( \"Test\" , \"1234@google.se\" , \"1234\" ) ; assertTrue ( res ) ; assertTrue ( db . checkUser ( \"Test\" , \"1234\" ) ) ; log . debug ( \"testCreateUser Passed.\" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; log . debug ( \"Stupid exception1.\" ) ; } catch ( NoUsernameOrPasswordException e2 ) { assertTrue ( e2 . getMessage ( ) . equals ( \"Please supply both a username and password.\" ) ) ; log . debug ( \"Stupid exception2.\" ) ; } catch ( NullUserException e3 ) { assertTrue ( e3 . getMessage ( ) . equals ( \"Null User passed.\" ) ) ; log . debug ( \"Stupid exception3.\" ) ; } catch ( UserAlreadyExistsException e4 ) { assertTrue ( e4 . getMessage ( ) . equals ( \"A user with that name already exists.\" ) ) ; log . debug ( \"Stupid exception4.\" ) ; } catch ( Exception e5 ) { e5 . printStackTrace ( ) ; log . debug ( \"Stupid exception5.\" ) ; } } @ Test public void testGetUserInfo ( ) throws SQLException { log . debug ( \"testGetUserInfo Entered.\" ) ; try { User res = db . getUserInfo ( \"Test\" ) ; assertEquals ( \"User Retrival\" , \"Test\" , res . getUserName ( ) ) ; log . debug ( \"testGetUserInfo Passed.\" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Test public void testGetUserPassWord ( ) { try { log . debug ( \"testGetUserPassWord entered.\" ) ; String password = db . getUserPassWord ( \"Test\" ) ; assertTrue ( password . equals ( \"1234\" ) ) ; log . debug ( \"testGetUserPassWord Passed.\" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } @ Test public void testGetAdminStatus ( ) throws SQLException { log . debug ( \"testGetAdminStatus Entered.\" ) ; User u = new User ( \"Test\" , false , \"1234@google.se\" , new ArrayList < Book > ( ) , new PaymentInfo ( ) , new Cart ( ) ) ; try { boolean res = db . getAdminStatus ( \"Test\" ) ; assertEquals ( \"isAdmin Status\" , u . isAdmin , res ) ; log . debug ( \"testGetAdminStatus Passed.\" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } @ Test public void testAddBookToCatalogue ( ) { log . debug ( \"testAddBookToCatalogue Entered.\" ) ; Book b = new Book ( \"THISISAUNIQUESTRING\" , \"THISISAUNIQUESTRING\" , 1.10 , \"THISISAUNIQUESTRING\" , 2309580 , \"THISISAUNIQUESTRING\" , \"THISISAUNIQUESTRING\" ) ; try { db . addBookToCatalogue ( b ) ; log . debug ( \"testAddBookToCatalogue Passed.\" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } @ Test public void testAddBookToUser ( ) { log . debug ( \"testAddBookToUser Entered.\" ) ; Book b = new Book ( \"THISISAUNIQUESTRING\" , \"THISISAUNIQUESTRING\" , 1.10 , \"THISISAUNIQUESTRING\" , 2309580 , \"THISISAUNIQUESTRING\" , \"THISISAUNIQUESTRING\" ) ; try { db . addBookToUser ( b . getBookISBN ( ) , \"Test\" ) ; log . debug ( \"testAddBookToUser Passed.\" ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } @ Test public void testShoppingCart ( ) throws SQLException , CartException { log . debug ( \"testShoppingCart Entered.\" ) ; User res = db . getUserInfo ( \"Test\" ) ; res . cart = new Cart ( ) ; res . cart . add ( db . getBookByIsbn ( 2309580 ) ) ; db . saveShoppingCart ( res . cart , res . getUserName ( ) , \"2012-02-27\" ) ; Cart c = db . getUserCart ( \"Test\" ) ; assertTrue ( c . get ( 0 ) . getBookISBN ( ) == 2309580 ) ; db . removeShoppingCart ( \"Test\" ) ; c = db . getUserCart ( \"Test\" ) ; assertTrue ( c == null ) ; log . debug ( \"testShoppingCart Passed.\" ) ; } @ Test public void testUserHasBook ( ) { try { log . debug ( \"testUserHasBook Entered.\" ) ; boolean res = db . userHasBook ( \"Test\" , 2309580 ) ; assertTrue ( res ) ; log", "gt": ". debug ( \"testUserHasBook Passed.\" ) ;", "prediction": "}\n", "label": 0}
{"id": 8349, "input": "<s> package org . nuxeo . ecm . platform . relations . io . test ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . InputStream ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . After ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . core . io . DocumentTranslationMap ; import org . nuxeo . ecm . core . io . impl . DocumentTranslationMapImpl ; import org . nuxeo . ecm . platform . io . api . IOManager ; import org . nuxeo . ecm . platform . io . api . IOResourceAdapter ; import org . nuxeo . ecm . platform . io . api . IOResources ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . Node ; import org . nuxeo . ecm . platform . relations . api . QNameResource ; import org . nuxeo . ecm . platform . relations . api . RelationManager ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . api . impl . QNameResourceImpl ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . ecm . platform . relations . api . impl . StatementImpl ; import org . nuxeo . ecm . platform . relations . io . IORelationResources ; import org . nuxeo . ecm . platform . relations . jena . JenaGraph ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . test . NXRuntimeTestCase ; public class TestIORelationAdapter extends NXRuntimeTestCase { private static final String repoName = \"demo\" ; private static final String graphName = \"myrelations\" ; private static final String documentNamespace = \"http://www.ecm.org/uid/\" ; private static final String predicateNamespace = \"http://purl.org/dc/terms/\" ; private static final QNameResource isBasedOn = new QNameResourceImpl ( predicateNamespace , \"IsBasedOn\" ) ; private static final QNameResource references = new QNameResourceImpl ( predicateNamespace , \"References\" ) ; private static final String doc1Ref = \"DOC200600013_02.01\" ; private static final String doc1RefCopy = \"DOC200600013_02.01_copy\" ; private static final QNameResource doc1Resource = new QNameResourceImpl ( documentNamespace , \"demo/DOC200600013_02.01\" ) ; private static final QNameResource doc2Resource = new QNameResourceImpl ( documentNamespace , \"demo/DOC200600015_01.00\" ) ; private static final QNameResource doc1ResourceCopy = new QNameResourceImpl ( documentNamespace , \"demo/DOC200600013_02.01_copy\" ) ; private static final Resource simpleResource = new ResourceImpl ( \"http://www.wikipedia.com/Enterprise_Content_Management\" ) ; private IOManager ioService ; private RelationManager rService ; private JenaGraph graph ; @ Override @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.core.schema\" ) ; deployBundle ( \"org.nuxeo.ecm.core.event\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"RepositoryManager.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"RepositoryService.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"FakeRepository.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"SecurityService.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"io-test-framework.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"io-relations-test-contrib.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.relations.io.tests\" , \"jena-test-bundle.xml\" ) ; ioService = Framework . getService ( IOManager . class ) ; assertNotNull ( ioService ) ; assertNotNull ( ioService ) ; rService = Framework . getService ( RelationManager . class ) ; Graph graph = rService . getGraphByName ( graphName ) ; assertNotNull ( graph ) ; assertEquals ( JenaGraph . class , graph . getClass ( ) ) ; this . graph = ( JenaGraph ) graph ; } @ Override @ After public void tearDown ( ) throws Exception { if ( graph != null ) { graph . clear ( ) ; } graph = null ; super . tearDown ( ) ; } private static InputStream getTestFile ( String filePath ) { return Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( filePath ) ; } private static JenaGraph getMemoryGraph ( ) { JenaGraph graph = new JenaGraph ( ) ; Map < String , String > namespaces = new HashMap < String , String > ( ) ; namespaces . put ( \"rdf\" , \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" ) ; namespaces . put ( \"dcterms\" , \"http://purl.org/dc/terms/\" ) ; namespaces . put ( \"uid\" , \"http://www.ecm.org/uid/\" ) ; namespaces . put ( \"metadata\" , \"http://www.ecm.org/metadata/\" ) ; graph . setNamespaces ( namespaces ) ; return graph ; } private static void feedGraph ( String filePath , Graph graph ) { assertSame ( 0L , graph . size ( ) ) ; graph . read ( getTestFile ( filePath ) , null , null ) ; assertNotSame ( 0L , graph . size ( ) ) ; } private static void compareGraph ( String filePath , Graph graph ) { Graph newGraph = getMemoryGraph ( ) ; feedGraph ( filePath , newGraph ) ; List < Statement > expected = newGraph . getStatements ( ) ; Collections . sort ( expected ) ; List < Statement > actual = graph . getStatements ( ) ; Collections . sort ( actual ) ; for ( int i = 0 ; i < expected . size ( ) ; i ++ ) { assertEquals ( expected . get ( i ) ,", "gt": "actual . get ( i ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3267, "input": "<s> package org . xbill . DNS ; import java . util . * ; public class SIGRecord extends SIGBase { private static final long serialVersionUID = 4963556060953589058L ; SIGRecord ( ) { } Record getObject ( ) { return new SIGRecord ( ) ; } public SIGRecord ( Name name , int dclass , long ttl , int covered , int alg , long origttl , Date expire , Date timeSigned , int footprint , Name signer , byte [ ] signature ) { super ( name , Type . SIG , dclass , ttl , covered , alg , origttl , expire , timeSigned", "gt": ", footprint , signer , signature ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8394, "input": "<s> package org . eclipse . ui . internal ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . SubContributionItem ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . util . Geometry ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IPerspectiveFactory ; import org . eclipse . ui . IPlaceholderFolderLayout ; import org . eclipse . ui . IViewLayout ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . WorkbenchException ; import org . eclipse . ui . XMLMemento ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . internal . StartupThreading . StartupRunnable ; import org . eclipse . ui . internal . intro . IIntroConstants ; import org . eclipse . ui . internal . layout . ITrimManager ; import org . eclipse . ui . internal . layout . IWindowTrim ; import org . eclipse . ui . internal . layout . TrimLayout ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . internal . registry . ActionSetRegistry ; import org . eclipse . ui . internal . registry . IActionSetDescriptor ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . internal . registry . PerspectiveDescriptor ; import org . eclipse . ui . internal . registry . PerspectiveExtensionReader ; import org . eclipse . ui . internal . registry . PerspectiveRegistry ; import org . eclipse . ui . internal . registry . StickyViewDescriptor ; import org . eclipse . ui . internal . util . PrefUtil ; import org . eclipse . ui . presentations . AbstractPresentationFactory ; import org . eclipse . ui . presentations . IStackPresentationSite ; import org . eclipse . ui . statushandlers . StatusManager ; import org . eclipse . ui . views . IStickyViewDescriptor ; import org . eclipse . ui . views . IViewDescriptor ; import org . eclipse . ui . views . IViewRegistry ; public class Perspective { protected PerspectiveDescriptor descriptor ; protected WorkbenchPage page ; protected LayoutPart editorArea ; protected PartPlaceholder editorHolder ; protected boolean editorHidden = false ; protected boolean editorAreaRestoreOnUnzoom = false ; protected int editorAreaState = IStackPresentationSite . STATE_RESTORED ; private ViewFactory viewFactory ; protected ArrayList alwaysOnActionSets ; protected ArrayList alwaysOffActionSets ; protected ArrayList newWizardShortcuts ; protected ArrayList showViewShortcuts ; protected ArrayList perspectiveShortcuts ; protected Collection hideMenuIDs ; protected Collection hideToolBarIDs ; protected FastViewManager fastViewManager = null ; private Map mapIDtoViewLayoutRec ; protected boolean fixed ; protected ArrayList showInPartIds ; protected HashMap showInTimes = new HashMap ( ) ; private IViewReference activeFastView ; protected IMemento memento ; protected PerspectiveHelper presentation ; final static private String VERSION_STRING = \"0.016\" ; private FastViewPane fastViewPane = new FastViewPane ( ) ; private static final int FASTVIEW_HIDE_STEPS = 5 ; private IWorkbenchPartReference oldPartRef = null ; protected boolean shouldHideEditorsOnActivate = false ; protected PageLayout layout ; public Perspective ( PerspectiveDescriptor desc , WorkbenchPage page ) throws WorkbenchException { this ( page ) ; descriptor = desc ; if ( desc != null ) { createPresentation ( desc ) ; } } protected Perspective ( WorkbenchPage page ) throws WorkbenchException { this . page = page ; this . editorArea = page .", "gt": "getEditorPresentation ( ) . getLayoutPart ( ) ;", "prediction": ";\n", "label": 1}
{"id": 6311, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . Export ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ExportTest extends XtextTest {", "gt": "@ Test public void testAllExports ( )", "prediction": "( )\n", "label": 0}
{"id": 8412, "input": "<s> package org . seage . problem . rosenbrock . fireflies ; import org . seage . metaheuristic . fireflies . FireflyOperator ; import org . seage . metaheuristic . fireflies . FireflySearch ; import org . seage . metaheuristic . fireflies . Solution ; import org . seage . metaheuristic . particles . Particle ; import org . seage . metaheuristic . particles . ParticleSwarm ; public class RosenbrockTest { public static void main ( String [ ] args ) throws Exception { boolean _withDecreasingRandomness = false ; boolean _withHillClimbingBestSolution = false ; boolean _bestSolutionNoMove = false ; double _initialIntensity = 1 ; double _initialRandomness = 5 ; double _finalRandomness = 2 ; double _absorption = 0.3 ; double _timeStep = 1.7 ; int populationSize = 100 ; boolean _maximizing = false ; int iterationsToGo = 1000 ; double [ ] minBound = { - 10 , - 10 } ; double [ ] maxBound = { 10 , 10 } ; FireflyOperator fo = new ContinuousFireflyOperator ( _initialIntensity , _initialRandomness , _finalRandomness , _absorption , _timeStep , _withDecreasingRandomness , 2 , minBound , maxBound ) ; RosenbrockObjectiveFunction rof = new RosenbrockObjectiveFunction ( ) ; FireflySearch fs = new FireflySearch ( fo , rof ) ; fs . setWithDecreasingRandomness ( _withDecreasingRandomness ) ; fs . setWithHillClimbingBestSolution ( _withHillClimbingBestSolution ) ; fs . setInitialIntensity ( _initialIntensity ) ; fs . setInitialRandomness ( _initialRandomness ) ; fs . setFinalRandomness ( _finalRandomness ) ; fs . setBestSolutionNoMove ( _bestSolutionNoMove ) ; fs . setAbsorption ( _absorption ) ; fs . setTimeStep ( _timeStep ) ; fs . setPopulationCount ( populationSize ) ; fs . setMaximizing ( _maximizing ) ; fs . setIterationsToGo ( iterationsToGo ) ; Solution [ ] solutions = generateInitialSolutions ( 10 , fo ) ; fs . startSolving ( solutions ) ; } private static Solution [ ] generateInitialSolutions ( int count , FireflyOperator fo ) throws Exception { Solution [ ] result = new", "gt": "Solution [ count ] ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8632, "input": "<s> interface If < T > { final If <", "gt": "T > C0 = null ;", "prediction": ") ;\n", "label": 0}
{"id": 8443, "input": "<s> package org . eclipse . swt . internal . widgets ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import org . eclipse . swt . widgets . Item ; public class ItemLCAUtil { private static final String PROP_TEXT = \"text\" ; private static final String PROP_IMAGE = \"image\" ; private ItemLCAUtil ( ) { } public static void preserve ( Item item ) { preserveProperty ( item , PROP_TEXT , item . getText ( ) ) ; preserveProperty ( item , PROP_IMAGE , item . getImage ( ) ) ; } public static void", "gt": "renderChanges ( Item item )", "prediction": "( )\n", "label": 1}
{"id": 5570, "input": "<s> public class ManyExitsInTry { static public int func ( int i ) { try { if ( i == 0 ) return 0 ; if ( i == 1 ) return 1 ; if ( i == 2 ) return 2 ; if ( i == 3 ) return 3 ; if ( i == 4 ) return 4 ; if ( i == 5 ) return 5 ; if ( i == 6 ) return 6 ; if ( i == 7 ) return 7 ; if ( i == 8 ) return 8 ; if ( i == 9 ) return 9 ; if ( i == 10 ) return 10 ; if ( i == 11 ) return 11 ; if ( i == 12 ) return 12 ; if ( i == 13 ) return 13 ; if ( i == 14 ) return 14 ; if ( i == 15 ) return 15 ; if ( i == 16 ) return 16 ; if ( i == 17 ) return 17 ; if ( i == 18 ) return 18 ; if ( i == 19 ) return 19 ; if ( i == 20 ) return 20 ; if ( i == 21 ) return 21 ; if ( i == 22 ) return 22 ; if ( i == 23 ) return 23 ; if ( i == 24 ) return 24 ; if ( i == 25 ) return 25 ; if ( i == 26 ) return 26 ; if ( i == 27 ) return 27 ; if ( i == 28 ) return 28 ; if ( i == 29 ) return 29 ; if ( i == 30 ) return 30 ; if ( i == 31 ) return 31 ; if ( i == 32 ) return 32 ; if ( i == 33 ) return 33 ; if ( i == 34 ) return 34 ; if ( i == 35 ) return 35 ; if ( i == 36 ) return 36 ; if ( i == 37 ) return 37 ; if ( i == 38 ) return 38 ; if ( i == 39 ) return 39 ; if ( i == 40 ) return 40 ; if ( i == 41 ) return 41 ; if ( i == 42 ) return 42 ; if ( i == 43 ) return 43 ; if ( i == 44 ) return 44 ; if ( i == 45 ) return 45 ; if ( i == 46 ) return 46 ; if ( i == 47 ) return 47 ; if ( i == 48 ) return 48 ; if ( i == 49 ) return 49 ; if ( i == 50 ) return 50 ; if ( i == 51 ) return 51 ; if ( i == 52 ) return 52 ; if ( i == 53 ) return 53 ; if ( i == 54 ) return 54 ; if ( i == 55 ) return 55 ; if ( i == 56 ) return 56 ; if ( i == 57 ) return 57 ; if ( i == 58 ) return 58 ; if ( i == 59 ) return 59 ; if ( i == 60 ) return 60 ; if ( i == 61 ) return 61 ; if ( i == 62 ) return 62 ; if ( i == 63 ) return 63 ; if ( i == 64 ) return 64 ; if ( i == 65 ) return 65 ; if ( i == 66 ) return 66 ; if ( i == 67 ) return 67 ; if ( i == 68 ) return 68 ; if ( i == 69 ) return 69 ; if ( i == 70 ) return 70 ; if ( i == 71 ) return 71 ; if ( i == 72 ) return 72 ; if ( i == 73 ) return 73 ; if ( i == 74 ) return 74 ; if ( i == 75 ) return 75 ; if ( i == 76 ) return 76 ; if ( i == 77 ) return 77 ; if ( i == 78 ) return 78 ; if ( i == 79 ) return 79 ; if ( i == 80 ) return 80 ; if ( i == 81 ) return 81 ; if ( i == 82 ) return 82 ; if ( i == 83 ) return 83 ; if ( i == 84 ) return 84 ; if ( i == 85 ) return 85 ; if ( i == 86 ) return 86 ; if ( i == 87 ) return 87 ; if ( i == 88 ) return 88 ; if ( i == 89 ) return 89 ; if ( i == 90 ) return 90 ; if ( i == 91 ) return 91 ; if ( i == 92 ) return 92 ; if ( i == 93 ) return 93 ; if ( i == 94 ) return 94 ; if ( i == 95 ) return 95 ; if ( i == 96 ) return 96 ; if ( i == 97 ) return 97 ; if ( i == 98 ) return 98 ; if ( i == 99 ) return 99 ; if ( i == 100 ) return 100 ; if ( i == 101 ) return 101 ; if ( i == 102 ) return 102 ; if ( i == 103 ) return 103 ; if ( i == 104 ) return 104 ; if ( i == 105 ) return 105 ; if ( i == 106 ) return 106 ; if ( i == 107 ) return 107 ; if ( i == 108 ) return 108 ; if ( i == 109 ) return 109 ; if ( i == 110 ) return 110 ; if ( i == 111 ) return 111 ; if ( i == 112 ) return 112 ; if ( i == 113 ) return 113 ; if ( i == 114 ) return 114 ; if ( i == 115 ) return 115 ; if ( i == 116 ) return 116 ; if ( i == 117 ) return 117 ; if ( i == 118 ) return 118 ; if ( i == 119 ) return 119 ; if ( i == 120 ) return 120 ; if ( i == 121 ) return 121 ; if", "gt": "( i == 122 ) return 122 ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8500, "input": "<s> package org . restlet . ext . oauth ; import java . io . IOException ; import java . util . StringTokenizer ; import org . restlet . Context ; import org . restlet . Response ; import org . restlet . data . ChallengeRequest ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Form ; import org . restlet . data . Parameter ; import org . restlet . engine . header . ChallengeWriter ; import org . restlet . engine . header . Header ; import org . restlet . engine . security . AuthenticatorHelper ; import org . restlet . util . Series ; public class HttpOAuthHelper extends AuthenticatorHelper { public static String getAuthPage ( Context c ) { return c . getParameters ( ) . getFirstValue ( \"authPage\" , \"/auth_page\" ) ; } public static String getAuthPageTemplate ( Context c ) { return c . getParameters ( ) . getFirstValue ( \"authPageTemplate\" ) ; } public static boolean getAuthSkipApproved ( Context c ) { c . getLogger ( ) . fine ( \"Trying to get auth page template\" ) ; String skip = c . getParameters ( ) . getFirstValue ( \"authSkipApproved\" ) ; if ( skip == null ) return false ; return Boolean . parseBoolean ( skip ) ; } public static void setAuthPage ( String authPage , Context c ) { c . getParameters ( ) . set ( \"authPage\" , authPage ) ; } public static void setAuthPageTemplate ( String authPageTemplate , Context c ) { c . getParameters ( ) . set ( \"authPageTemplate\" , authPageTemplate ) ; } public static void setAuthSkipApproved ( boolean skip , Context c ) { c . getParameters ( ) . set ( \"authSkipApproved\" , Boolean . toString ( skip ) ) ; } public HttpOAuthHelper ( ) { super ( ChallengeScheme . HTTP_OAUTH , true , true ) ; } @ Override public void formatRequest ( ChallengeWriter cw , ChallengeRequest challenge , Response response , Series < Header > httpHeaders ) throws IOException { cw . append ( \"realm='\" ) ; cw . append ( challenge . getRealm ( ) ) ; cw . append ( \"'\" ) ; for ( Parameter p : challenge . getParameters ( ) ) { cw . append ( \", \" ) ; cw . append ( p . getName ( ) ) ; cw . append ( \"='\" ) ; cw . append ( p . getValue ( ) ) ; cw . append ( \"'\" ) ; } } @ Override public void parseRequest ( ChallengeRequest challenge , Response response , Series < Header > httpHeaders ) { String raw = challenge . getRawValue ( ) ; if ( raw != null && raw . length ( ) > 0 ) { StringTokenizer st = new", "gt": "StringTokenizer ( raw , \",\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 5670, "input": "<s> interface Attribute < T > { } interface AttributeSet1 { < T > Attribute < T > get ( Class < T > category ) ; } class AttributeSet1Impl implements AttributeSet1 { public", "gt": "Attribute get ( Class category )", "prediction": "\n", "label": 0}
{"id": 8532, "input": "<s> package com . corundumstudio . socketio ; import com . corundumstudio . socketio . parser . Packet ; public interface ClientOperations { void sendMessage ( String message ) ; void sendJsonObject ( Object object ) ; void send ( Packet packet ) ; void disconnect ( ) ; void sendEvent ( String", "gt": "name , Object data ) ;", "prediction": ")\n", "label": 1}
{"id": 846, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface WeeklyMin extends LimitsAttribute", "prediction": "}\n", "label": 0}
{"id": 8541, "input": "<s> package br . org . archimedes . controller ; import br . org . archimedes . Constant ; import br . org . archimedes . Utils ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NoActiveDrawingException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; import br . org . archimedes . parser . CommandParser ; public class IdleState extends InputState { private static final String IDLE = \"br.org.archimedes.idle\" ; private CommandFactory previousFactory ; private InputState nextState ; private boolean nextShould ; private Drawing currentDrawing ; private DisabledState disabledState ; public IdleState ( DisabledState previousState ) { previousFactory = null ; disabledState = previousState ; } public String receiveText ( String text ) { String returnValue = null ; CommandFactory factory = null ; nextState = this ; nextShould = false ; if ( text == null || text . trim ( ) . equals ( \"\" ) ) { factory = previousFactory ; } else { CommandParser parser = br . org . archimedes . Utils . getInputController ( ) . getCommandParser ( ) ; factory = parser . getCommand ( text ) ; } if ( factory != null ) { returnValue = setCurrentFactory ( factory ) ; } else if ( Utils . isPoint ( text ) ) { Point point = Utils . getPointCoordinates ( text ) ; try { if ( ! br . org . archimedes . Utils . getController ( ) . movePoint ( point ) ) { nextState = new SelectionState ( this ) ; nextShould = true ; } } catch ( NoActiveDrawingException e ) { e . printStackTrace ( ) ; } } else { returnValue = Messages . Invalid + Constant . NEW_LINE + Messages . Waiting ; } return returnValue ; } public InputState getNext ( ) { return nextState ; } protected String setCurrentFactory ( CommandFactory factory ) { String returnValue = factory . getName ( ) . toUpperCase ( ) + \": \" + factory . begin ( ) ; CommandParser parser = br . org . archimedes . Utils . getInputController ( ) . getCommandParser ( ) ; if ( parser . getCommand ( factory . getName ( ) ) != null ) { previousFactory = factory ; } if ( factory . isDone ( ) ) { try { br . org . archimedes . Utils . getController ( ) . execute ( factory . getCommands ( ) ) ; } catch ( IllegalActionException e ) { returnValue = factory . getName ( ) . toUpperCase ( ) + \": \" + e . getMessage ( ) + Constant . NEW_LINE + Messages . Waiting ; } catch ( NoActiveDrawingException e ) { nextState = disabledState ; returnValue = Messages . NoDrawing ; } } else { nextState = new ActiveState ( this , factory , currentDrawing ) ; } nextShould = false ; return returnValue ; } public boolean nextShouldHandle ( ) { return nextShould ; }", "gt": "public InputState changedDrawing ( Drawing currentDrawing )", "prediction": "}\n", "label": 1}
{"id": 1264, "input": "<s> package com . sun . source . tree ; public interface UnaryTree extends ExpressionTree {", "gt": "ExpressionTree getExpression ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 8554, "input": "<s> package fr . inria . zvtm . tests ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . event . RepaintListener ; import fr . inria . zvtm . event . ViewAdapter ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . ViewPanel ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . MultilineText ; import fr . inria . zvtm . glyphs . VRectangle ; import fr . inria . zvtm . glyphs . VText ; import java . awt . Color ; import java . awt . Font ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . event . MouseWheelEvent ; import java . awt . geom . Point2D ; import java . util . Vector ; public class MultilineTextTest { private VirtualSpaceManager vsm = VirtualSpaceManager . INSTANCE ; private Camera cam ; MultilineTextTest ( ) { final VirtualSpace vs = vsm . addVirtualSpace ( \"testSpace\" ) ; cam = vs . addCamera ( ) ; cam . setZoomFloor ( - 90 ) ; Vector < Camera > cameras = new Vector < Camera > ( ) ; cameras . add ( cam ) ; final View view = vsm . addFrameView ( cameras , \"MultilineText test\" , View . STD_VIEW , 800 , 600 , false , true , true , null ) ; view . setListener ( new MultilineTestEventHandler ( ) ) ; view . getCursor ( ) . setColor ( Color . GREEN ) ; final MultilineText adt = new MultilineText ( \"Forty-two is six multiplied by nine.\" ) ; adt . setColor ( Color . RED ) ; adt . setWidthConstraint ( 42 ) ; vs . addGlyph ( adt ) ; final MultilineText adt2 = new MultilineText ( \"We apologize for the inconvenience\" ) ; adt2 . setColor ( Color . BLUE ) ; adt2 . setFont ( new Font ( \"Monospaced\" , Font . PLAIN , 6 ) ) ; adt2 . move ( 50 , 0 ) ; vs . addGlyph ( adt2 ) ; view . repaint ( new RepaintListener ( ) { public void viewRepainted ( View v ) { view . getGlobalView ( cam , 500 ) ; Point2D . Double adtB = adt . getBounds ( cam . getIndex ( ) ) ; VRectangle adtBounds = new VRectangle ( adt . vx , adt . vy , 0 , adtB . getX ( ) , adtB . getY ( ) , new Color ( 0 , 0 , 0 , 0 ) ) ; adtBounds . setBorderColor ( Color . RED ) ; adtBounds . move ( adtBounds . getWidth ( ) / 2 , - adtBounds . getHeight ( ) / 2 ) ; vs . addGlyph ( adtBounds ) ; Point2D . Double adt2B = adt2 . getBounds ( cam . getIndex ( ) ) ; VRectangle adt2Bounds = new VRectangle ( adt2 . vx , adt2 . vy , 0 , adt2B . getX ( ) , adt2B . getY ( ) , new Color ( 0 , 0 , 0 , 0 ) ) ; adt2Bounds . setBorderColor ( Color . BLUE ) ; adt2Bounds . move ( adt2Bounds . getWidth ( ) / 2 , - adt2Bounds . getHeight ( ) / 2 ) ; vs . addGlyph ( adt2Bounds ) ; view . removeRepaintListener ( ) ; } } ) ; } public static void main ( String [ ] args ) { new MultilineTextTest ( ) ; } class MultilineTestEventHandler extends ViewAdapter { float ZOOM_SPEED_COEF = 1.0f / 50.0f ; double PAN_SPEED_COEF = 50.0 ; int lastJPX , lastJPY ; MultilineTestEventHandler ( ) { } public void press1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { lastJPX = jpx ; lastJPY = jpy ; v . setDrawDrag ( true ) ; System . out . println ( v . getVCursor ( ) . getPicker ( ) . lastGlyphEntered ( ) ) ; } public void release1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { v . cams [ 0 ] . setXspeed ( 0 ) ; v . cams [ 0 ] . setYspeed ( 0 ) ; v . setDrawDrag ( false ) ; } public void mouseDragged ( ViewPanel v , int mod , int buttonNumber , int jpx , int jpy , MouseEvent e ) { if ( buttonNumber == 1 ) { Camera c = cam ; double a = ( c . focal + Math . abs ( c . altitude ) ) / c . focal ; v . cams [ 0 ] . setXspeed ( ( c . altitude > 0 ) ? ( long ) ( ( jpx - lastJPX ) * ( a / PAN_SPEED_COEF ) ) : ( long ) ( ( jpx - lastJPX ) / ( a * PAN_SPEED_COEF ) ) ) ; v . cams [ 0 ] . setYspeed ( ( c . altitude > 0 ) ? ( long ) ( ( lastJPY - jpy ) * ( a / PAN_SPEED_COEF ) ) : ( long ) ( ( lastJPY - jpy ) / ( a * PAN_SPEED_COEF ) ) ) ; } } public void mouseWheelMoved ( ViewPanel v , short wheelDirection , int jpx , int jpy , MouseWheelEvent e ) { Camera c = cam ; double a = ( c . focal + Math . abs ( c . altitude ) )", "gt": "/ c . focal ;", "prediction": ";\n", "label": 1}
{"id": 804, "input": "<s> package com . sun . tools . javac . util ; public class FatalError extends Error { private static final long serialVersionUID = 0 ; public FatalError ( JCDiagnostic d ) { super ( d . toString ( ) ) ; } public", "gt": "FatalError ( JCDiagnostic d , Throwable t )", "prediction": "}\n", "label": 0}
{"id": 8574, "input": "<s> package org . nuxeo . ecm . platform . mail . action ; import javax . mail . Folder ; import javax . mail . Message ; import javax . mail . MessagingException ; public class Visitor { private final MessageActionPipe pipe ; public Visitor ( MessageActionPipe pipe ) { this . pipe = pipe ; } public void visit ( Folder folder ) throws Exception { visit ( folder , null ) ; } public void visit ( Folder folder , ExecutionContext initialContext ) throws Exception { for ( Message message : folder . getMessages ( ) ) { ExecutionContext context = new ExecutionContext ( message , initialContext ) ; for ( MessageAction action : pipe ) { action . reset ( context ) ; boolean result = action . execute ( context ) ; if ( ! result ) { break ; } } } Folder [ ] folders = { } ; try { folders = folder . list ( ) ; } catch ( MessagingException e ) { } for ( Folder f : folders ) { visit ( f , initialContext ) ; } } public void visit", "gt": "( Message [ ] messages , ExecutionContext initialContext ) throws Exception", "prediction": "( )\n", "label": 1}
{"id": 1520, "input": "<s> package com . mobeelizer . mobile . android . search ; import static org . junit . Assert . assertSame ; import static org . mockito . Mockito . mock ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . powermock . api . mockito . PowerMockito ; import org . powermock . core . classloader . annotations . PrepareForTest ; import org . powermock . modules . junit4 . PowerMockRunner ; import com . mobeelizer . mobile . android . api . MobeelizerOrder ; import com . mobeelizer . mobile . android . api . MobeelizerOrders ; @ RunWith ( PowerMockRunner . class ) @ PrepareForTest ( MobeelizerOrders . class ) public class MobeelizerOrdersTest { @ Test public void shouldCreateAscOrder ( ) throws Exception { MobeelizerOrderImpl expectedOrder = mock ( MobeelizerOrderImpl . class ) ; PowerMockito . whenNew ( MobeelizerOrderImpl . class ) . withArguments ( \"field\" , true ) . thenReturn ( expectedOrder ) ; MobeelizerOrder order =", "gt": "MobeelizerOrders . asc ( \"field\" ) ;", "prediction": ";\n", "label": 0}
{"id": 8577, "input": "<s> package org . mitre . openid . connect . web ; import java . security . Principal ; import java . util . Collection ; import org . mitre . openid . connect . model . WhitelistedSite ; import org . mitre . openid . connect . service . WhitelistedSiteService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . http . HttpStatus ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . stereotype . Controller ; import org . springframework . ui . ModelMap ; import org . springframework . web . bind . annotation . PathVariable ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import com . google . gson . Gson ; import com . google . gson . JsonObject ; import com . google . gson . JsonParser ; @ Controller @ RequestMapping ( \"/api/whitelist\" ) @ PreAuthorize ( \"hasRole('ROLE_ADMIN')\" ) public class WhitelistAPI { @ Autowired private WhitelistedSiteService whitelistService ; private Gson gson = new Gson ( ) ; private JsonParser parser = new JsonParser ( ) ; @ RequestMapping ( method = RequestMethod . GET , headers = \"Accept=application/json\" ) public String getAllWhitelistedSites ( ModelMap m ) { Collection < WhitelistedSite > all = whitelistService . getAll ( ) ; m . put ( \"entity\" , all ) ; return \"jsonEntityView\" ; } @ RequestMapping ( method = RequestMethod . POST , headers = \"Accept=application/json\" ) public String addNewWhitelistedSite ( @ RequestBody String jsonString , ModelMap m , Principal p ) { JsonObject json = parser . parse ( jsonString ) . getAsJsonObject ( ) ; WhitelistedSite whitelist = gson . fromJson ( json , WhitelistedSite . class ) ; whitelist . setCreatorUserId ( p . getName ( ) ) ; WhitelistedSite newWhitelist = whitelistService . saveNew ( whitelist ) ; m . put ( \"entity\" , newWhitelist ) ; return \"jsonEntityView\" ; } @ RequestMapping ( value = \"/{id}\" , method = RequestMethod . PUT , headers = \"Accept=application/json\" ) public String updateWhitelistedSite ( @ PathVariable ( \"id\" ) Long id , @ RequestBody String jsonString , ModelMap m , Principal p ) { JsonObject json = parser . parse ( jsonString ) . getAsJsonObject ( ) ; WhitelistedSite whitelist = gson . fromJson ( json , WhitelistedSite . class ) ; WhitelistedSite oldWhitelist = whitelistService . getById ( id ) ; if ( oldWhitelist == null ) { m . put ( \"code\" , HttpStatus . NOT_FOUND ) ; return \"httpCodeView\" ; } else { WhitelistedSite newWhitelist = whitelistService . update ( oldWhitelist , whitelist ) ; m . put ( \"entity\" , newWhitelist ) ; return \"jsonEntityView\" ; } } @ RequestMapping ( value = \"/{id}\" , method = RequestMethod . DELETE , headers = \"Accept=application/json\" ) public String deleteWhitelistedSite ( @ PathVariable ( \"id\" ) Long id , ModelMap m ) { WhitelistedSite whitelist = whitelistService . getById ( id ) ; if ( whitelist == null ) { m . put ( \"code\" , HttpStatus . NOT_FOUND ) ; } else { whitelistService . remove ( whitelist ) ; } return \"httpCodeView\" ; } @ RequestMapping ( value = \"/{id}\" , method = RequestMethod . GET , headers = \"Accept=application/json\" ) public String getWhitelistedSite ( @ PathVariable ( \"id\" ) Long id , ModelMap m ) { WhitelistedSite whitelist = whitelistService . getById ( id ) ; if ( whitelist == null ) { m . put ( \"code\" , HttpStatus . NOT_FOUND ) ; return \"httpCodeView\" ; } else {", "gt": "m . put ( \"entity\" , whitelist ) ;", "prediction": "}\n", "label": 1}
{"id": 2274, "input": "<s> import javax . lang . model . UnknownEntityException ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; public class TestExceptions { public static void main ( String ... args ) { RuntimeException [ ] exceptions = { new UnknownElementException ( ( Element ) null , ( Object ) null ) , new UnknownAnnotationValueException ( ( AnnotationValue ) null , ( Object ) null ) , new UnknownTypeException ( ( TypeMirror ) null , ( Object ) null ) } ;", "gt": "for ( RuntimeException exception : exceptions )", "prediction": "}\n", "label": 0}
{"id": 8582, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . basic ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public void setContent ( String content ) { this . content = content ; } public void setStatus ( String status ) { this . status = status ; } public", "gt": "void setSubject ( String subject )", "prediction": "( ) ;\n", "label": 1}
{"id": 188, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; } public static boolean start ( RootDoc root ) { try {", "gt": "for ( ClassDoc cd : root . classes ( ) )", "prediction": "}\n", "label": 0}
{"id": 8583, "input": "<s> package org . nuxeo . ecm . platform . preview . adapter ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo .", "gt": "ecm . platform . preview . api . HtmlPreviewAdapter ;", "prediction": ";\n", "label": 1}
{"id": 5985, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . CaveSpider ; public interface LizaCaveSpider extends CaveSpider { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities ( double x , double", "gt": "y , double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8613, "input": "<s> package episode_9 ; public interface MoveableEntity extends Entity { public double getDX ( ) ; public double getDY ( ) ; public void", "gt": "setDX ( double dx ) ;", "prediction": "( )\n", "label": 1}
{"id": 156, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class RuntimeInvisibleAnnotations_attribute extends RuntimeAnnotations_attribute { RuntimeInvisibleAnnotations_attribute ( ClassReader cr , int name_index , int length ) throws IOException , AttributeException { super ( cr , name_index , length ) ; } public RuntimeInvisibleAnnotations_attribute ( ConstantPool cp , Annotation [ ] annotations ) throws ConstantPoolException { this ( cp . getUTF8Index ( Attribute . RuntimeInvisibleAnnotations ) , annotations ) ; } public RuntimeInvisibleAnnotations_attribute ( int name_index , Annotation [ ] annotations ) { super", "gt": "( name_index , annotations ) ;", "prediction": ";\n", "label": 0}
{"id": 8634, "input": "<s> package org . apache . lucene . index ; import java . io . File ; import java . io . IOException ; import java . io . Reader ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Random ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . tokenattributes . PayloadAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . UnicodeUtil ; import org . apache . lucene . util . _TestUtil ; public class TestPayloads extends LuceneTestCase { public void testPayload ( ) throws Exception { rnd = newRandom ( ) ; byte [ ] testData = \"This is a test!\" . getBytes ( ) ; Payload payload = new Payload ( testData ) ; assertEquals ( \"Wrong payload length.\" , testData . length , payload . length ( ) ) ; byte [ ] target = new byte [ testData . length - 1 ] ; try { payload . copyTo ( target , 0 ) ; fail ( \"Expected exception not thrown\" ) ; } catch ( Exception expected ) { } target = new byte [ testData . length + 3 ] ; payload . copyTo ( target , 3 ) ; for ( int i = 0 ; i < testData . length ; i ++ ) { assertEquals ( testData [ i ] , target [ i + 3 ] ) ; } target = payload . toByteArray ( ) ; assertByteArrayEquals ( testData , target ) ; for ( int i = 0 ; i < testData . length ; i ++ ) { assertEquals ( payload . byteAt ( i ) , testData [ i ] ) ; } try { payload . byteAt ( testData . length + 1 ) ; fail ( \"Expected exception not thrown\" ) ; } catch ( Exception expected ) { } Payload clone = ( Payload ) payload . clone ( ) ; assertEquals ( payload . length ( ) , clone . length ( ) ) ; for ( int i = 0 ; i < payload . length ( ) ; i ++ ) { assertEquals ( payload . byteAt ( i ) , clone . byteAt ( i ) ) ; } } public void testPayloadFieldBit ( ) throws Exception { rnd = newRandom ( ) ; Directory ram = new RAMDirectory ( ) ; PayloadAnalyzer analyzer = new PayloadAnalyzer ( ) ; IndexWriter writer = new IndexWriter ( ram , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; Document d = new Document ( ) ; d . add ( new Field ( \"f1\" , \"This field has no payloads\" , Field . Store . NO , Field . Index . ANALYZED ) ) ; d . add ( new Field ( \"f2\" , \"This field has payloads in all docs\" , Field . Store . NO , Field . Index . ANALYZED ) ) ; d . add ( new Field ( \"f2\" , \"This field has payloads in all docs\" , Field . Store . NO , Field . Index . ANALYZED ) ) ; d . add ( new Field ( \"f3\" , \"This field has payloads in some docs\" , Field . Store . NO , Field . Index . ANALYZED ) ) ; analyzer . setPayloadData ( \"f2\" , 1 , \"somedata\" . getBytes ( ) , 0 , 1 ) ; writer . addDocument ( d ) ; writer . close ( ) ; SegmentReader reader = SegmentReader . getOnlySegmentReader ( ram ) ; FieldInfos fi = reader . fieldInfos ( ) ; assertFalse ( \"Payload field bit should not be set.\" , fi . fieldInfo ( \"f1\" ) . storePayloads ) ; assertTrue ( \"Payload field bit should be set.\" , fi .", "gt": "fieldInfo ( \"f2\" ) . storePayloads ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6434, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . gmf . gmfgraph . Compartment ; import org . eclipse . gmf . gmfgraph . Label ; import org . eclipse . gmf . mappings . CompartmentMapping ; public interface SimpleCompartment extends SimpleParentNode , SimpleChildNode , SimpleMappingElementWithFigure { CompartmentMapping getCompartmentMapping ( ) ; void setCompartmentMapping ( CompartmentMapping value ) ; String getName ( ) ; void setName ( String value ) ; Compartment getCompartment ( ) ; boolean isSetCompartment ( ) ; Label getCompartmentLabel ( ) ;", "gt": "boolean isSetCompartmentLabel ( ) ;", "prediction": "}\n", "label": 0}
{"id": 8635, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . resource . ImageDescriptor ; public interface IWorkingSet extends IPersistableElement , IAdaptable { public IAdaptable [ ] getElements ( ) ; public String getId ( ) ; public ImageDescriptor getImage ( ) ; public ImageDescriptor getImageDescriptor ( ) ; public String getName ( ) ; public void setElements ( IAdaptable [ ] elements ) ; public", "gt": "void setId ( String id ) ;", "prediction": "\n", "label": 1}
{"id": 769, "input": "<s> import java . util . * ; class UncheckedCall { void m ( ) { List l = new ArrayList", "gt": "< String > ( ) ;", "prediction": ";\n", "label": 0}
{"id": 8639, "input": "<s> package org . tinyradius . proxy ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . net . DatagramPacket ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . tinyradius . attribute . RadiusAttribute ; import org . tinyradius . packet . RadiusPacket ; import org . tinyradius . util . RadiusEndpoint ; import org . tinyradius . util . RadiusException ; import org . tinyradius . util . RadiusServer ; public abstract class RadiusProxy extends RadiusServer { public void start ( boolean listenAuth , boolean listenAcct , boolean listenProxy ) { super . start ( listenAuth , listenAcct ) ; if ( listenProxy ) { new Thread ( ) { public void run ( ) { setName ( \"Radius Proxy Listener\" ) ; try { logger . info ( \"starting RadiusProxyListener on port \" + getProxyPort ( ) ) ; listen ( getProxySocket ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } . start ( ) ; } } public void stop ( ) { logger . info ( \"stopping Radius proxy\" ) ; if ( proxySocket != null ) proxySocket . close ( ) ; super . stop ( ) ; } public abstract RadiusEndpoint getProxyServer ( RadiusPacket packet , RadiusEndpoint client ) ; public int getProxyPort ( ) { return proxyPort ; } public void setProxyPort ( int proxyPort ) { this . proxyPort = proxyPort ; this . proxySocket = null ; } public void setSocketTimeout ( int socketTimeout ) throws SocketException { super . setSocketTimeout ( socketTimeout ) ; if ( proxySocket != null ) proxySocket . setSoTimeout ( socketTimeout ) ; } protected DatagramSocket getProxySocket ( ) throws SocketException { if ( proxySocket == null ) { if ( getListenAddress ( ) == null ) proxySocket = new DatagramSocket ( getProxyPort ( ) ) ; else proxySocket = new DatagramSocket ( getProxyPort ( ) , getListenAddress ( ) ) ; proxySocket . setSoTimeout ( getSocketTimeout ( ) ) ; } return proxySocket ; } protected RadiusPacket handlePacket ( InetSocketAddress localAddress , InetSocketAddress remoteAddress , RadiusPacket request , String sharedSecret ) throws RadiusException , IOException { if ( localAddress . getPort ( ) == getProxyPort ( ) ) { proxyPacketReceived ( request , remoteAddress ) ; return null ; } RadiusEndpoint radiusClient = new RadiusEndpoint ( remoteAddress , sharedSecret ) ; RadiusEndpoint radiusServer = getProxyServer ( request , radiusClient ) ; if ( radiusServer != null ) { RadiusProxyConnection proxyConnection = new RadiusProxyConnection ( radiusServer , radiusClient , request , localAddress . getPort ( ) ) ; logger . info ( \"proxy packet to \" + proxyConnection ) ; proxyPacket ( request , proxyConnection ) ; return null ; } return super . handlePacket ( localAddress , remoteAddress , request , sharedSecret ) ; } protected void proxyPacketReceived ( RadiusPacket packet , InetSocketAddress remote ) throws IOException , RadiusException { List proxyStates = packet . getAttributes ( 33 ) ; if ( proxyStates == null || proxyStates . size ( ) == 0 ) throw new RadiusException ( \"proxy packet without Proxy-State attribute\" ) ; RadiusAttribute proxyState = ( RadiusAttribute ) proxyStates . get ( proxyStates . size ( ) - 1 ) ; String state = new String ( proxyState . getAttributeData ( ) ) ; RadiusProxyConnection proxyConnection = ( RadiusProxyConnection ) proxyConnections . remove ( state ) ; if ( proxyConnection == null ) { logger . warn ( \"received packet on proxy port without saved proxy connection - duplicate?\" ) ; return ; } RadiusEndpoint client = proxyConnection . getRadiusClient ( ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( \"received proxy packet: \" + packet ) ; logger . info ( \"forward packet to \" + client . getEndpointAddress ( ) . toString ( ) + \" with secret \" + client . getSharedSecret ( ) ) ; } packet . removeLastAttribute ( 33 ) ; RadiusPacket answer = new RadiusPacket ( packet . getPacketType ( ) , packet . getPacketIdentifier ( ) , packet . getAttributes ( ) ) ; DatagramPacket datagram = makeDatagramPacket ( answer , client . getSharedSecret ( ) , client . getEndpointAddress ( ) . getAddress ( ) , client . getEndpointAddress ( ) . getPort ( ) , proxyConnection . getPacket ( ) ) ; DatagramSocket socket ; if ( proxyConnection . getPort ( ) == getAuthPort ( ) ) socket = getAuthSocket ( ) ; else socket = getAcctSocket ( ) ; socket . send ( datagram ) ; } protected void proxyPacket ( RadiusPacket packet , RadiusProxyConnection proxyConnection ) throws IOException { synchronized ( RadiusProxy . class ) { proxyIndex ++ ; String proxyIndexStr = Integer . toString ( proxyIndex ) ; packet . addAttribute ( new RadiusAttribute ( 33 , proxyIndexStr . getBytes ( ) ) ) ; proxyConnections . put ( proxyIndexStr , proxyConnection ) ; } InetAddress serverAddress = proxyConnection . getRadiusServer ( ) . getEndpointAddress ( ) . getAddress ( ) ; int serverPort = proxyConnection . getRadiusServer ( ) . getEndpointAddress ( ) . getPort ( ) ; String serverSecret = proxyConnection . getRadiusServer ( ) . getSharedSecret ( ) ; byte [ ] auth =", "gt": "packet . getAuthenticator ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2894, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; public class OptionalMatcher extends CustomDefaultLabelMatcher < OptionalMatcher > { public final Matcher subMatcher ; public OptionalMatcher ( Rule subRule ) { super ( checkArgNotNull ( subRule , \"subRule\" ) , \"Optional\" ) ; this . subMatcher = getChildren ( ) . get ( 0 ) ; } public boolean match ( MatcherContext context ) { subMatcher . getSubContext ( context ) . runMatcher ( ) ; context . createNode ( ) ; return true ; } public < R > R accept", "gt": "( MatcherVisitor < R > visitor )", "prediction": "( )\n", "label": 0}
{"id": 8643, "input": "<s> package org . restlet . ext . rdf . internal . ntriples ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . restlet . data . Reference ; import org . restlet . engine . io . IoUtils ; import org . restlet . ext . rdf . GraphHandler ; import org . restlet . ext . rdf . Link ; import org . restlet . ext . rdf . Literal ; import org . restlet . ext . rdf . internal . RdfReader ; import org . restlet . representation . Representation ; public class RdfNTriplesReader extends RdfReader { private BufferedReader br ; private final char [ ] buffer ; private final int BUFFER_SIZE = 4096 ; public final int EOF = 0 ; private int scoutIndex ; private int startTokenIndex ; public RdfNTriplesReader ( Representation rdfRepresentation , GraphHandler graphHandler ) throws IOException { super ( rdfRepresentation , graphHandler ) ; this . buffer = new char [ ( BUFFER_SIZE + 1 ) * 2 ] ; this . buffer [ BUFFER_SIZE ] = this . buffer [ 2 * BUFFER_SIZE + 1 ] = EOF ; this . scoutIndex = 2 * BUFFER_SIZE ; this . startTokenIndex = 0 ; this . br = new BufferedReader ( getRdfRepresentation ( ) . getReader ( ) , IoUtils . BUFFER_SIZE ) ; } protected void consumeStatement ( ) throws IOException { int c = getChar ( ) ; while ( ! isEndOfFile ( c ) && c != '.' ) { c = step ( ) ; } if ( getChar ( ) == '.' ) { step ( ) ; } discard ( ) ; } protected void consumeWhiteSpaces ( ) throws IOException { while ( isWhiteSpace ( getChar ( ) ) ) { step ( ) ; } discard ( ) ; } protected void discard ( ) { startTokenIndex = scoutIndex ; } protected char getChar ( ) { return buffer [ scoutIndex ] ; } protected String getCurrentToken ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( startTokenIndex <= scoutIndex ) { if ( scoutIndex <= BUFFER_SIZE ) { for ( int i = startTokenIndex ; i < scoutIndex ; i ++ ) { builder . append ( buffer [ i ] ) ; } } else { for ( int i = startTokenIndex ; i < BUFFER_SIZE ; i ++ ) { builder . append ( buffer [ i ] ) ; } for ( int i = BUFFER_SIZE + 1 ; i < scoutIndex ; i ++ ) { builder . append ( buffer [ i ] ) ; } } } else { if ( startTokenIndex <= BUFFER_SIZE ) { for ( int i = startTokenIndex ; i < BUFFER_SIZE ; i ++ ) { builder . append ( buffer [ i ] ) ; } for ( int i = BUFFER_SIZE + 1 ; i < ( 2 * BUFFER_SIZE + 1 ) ; i ++ ) { builder . append ( buffer [ i ] ) ; } for ( int i = 0 ; i < scoutIndex ; i ++ ) { builder . append ( buffer [ i ] ) ; } } else { for ( int i = startTokenIndex ; i < ( 2 * BUFFER_SIZE + 1 ) ; i ++ ) { builder . append ( buffer [ i ] ) ; } for ( int i = 0 ; i < scoutIndex ; i ++ ) { builder . append ( buffer [ i ] ) ; } } } startTokenIndex = scoutIndex ; return builder . toString ( ) ; } public String getParsingMessage ( ) { return getParsingMessage ( buffer , startTokenIndex , scoutIndex ) ; } protected String getParsingMessage ( char [ ] buffer , int startTokenIndex , int scoutIndex ) { StringBuilder sb = new StringBuilder ( \"Parsing data [\" ) ; sb . append ( startTokenIndex ) ; sb . append ( \",\" ) ; sb . append ( scoutIndex ) ; sb . append ( \"] near \" ) ; if ( startTokenIndex < 25 ) { sb . append ( buffer , buffer . length - 30 , 28 ) ; sb . append ( buffer , 0 , 25 ) ; } else if ( startTokenIndex > ( buffer . length - 25 ) ) { sb . append ( buffer , buffer .", "gt": "length - 30 , 28 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9967, "input": "<s> package ar . com . fdvs . dj . domain . entities . columns ; import ar . com . fdvs . dj . core . CoreException ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . Entity ; public class PercentageColumn extends AbstractColumn { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private PropertyColumn percentageColumn ; public String getTextForExpression ( ) { throw new CoreException ( \"invalid operation on PercentageColumn\" ) ; } public String getTextForExpression ( DJGroup group ) { return \"new Double((\" + getPercentageColumn ( ) . getTextForExpression ( ) + \").doubleValue() / $V{\" + getGroupVariableName ( group ) + \"}.doubleValue())\" ; } public String getTextForExpression ( DJGroup group , DJGroup childGroup , String type ) { return \"new Double( $V{\" + getGroupVariableName ( childGroup ) + \"}.doubleValue() / $V{\" + getGroupVariableName ( type , group . getColumnToGroupBy ( ) . getColumnProperty ( ) . getProperty ( ) ) + \"}.doubleValue())\" ; } public String getValueClassNameForExpression ( ) { return Number . class . getName ( ) ; } public String getGroupVariableName ( String type , String columnToGroupByProperty ) { return \"variable-\" + type + \"_\" + columnToGroupByProperty + \"_\" + getPercentageColumn ( ) . getColumnProperty ( ) . getProperty ( ) + \"_percentage\" ; } public String getVariableClassName ( DJCalculation op ) { if ( op == DJCalculation . COUNT || op == DJCalculation . DISTINCT_COUNT ) return Long . class . getName ( ) ; else return Number . class . getName ( ) ; } public String getInitialExpression ( DJCalculation op ) { return \"new java.lang.Long(\\\"0\\\")\" ; } public String getGroupVariableName ( DJGroup group ) { String columnToGroupByProperty = null ; columnToGroupByProperty = group . getColumnToGroupBy ( ) . getColumnProperty ( ) . getProperty ( ) ; return \"variable-\" + columnToGroupByProperty + \"_\" + getPercentageColumn ( ) . getColumnProperty ( ) . getProperty ( ) + \"_percentage\" ; } public void setPercentageColumn ( PropertyColumn percentageColumn ) { this", "gt": ". percentageColumn = percentageColumn ;", "prediction": ";\n", "label": 0}
{"id": 8687, "input": "<s> package br . org . archimedes . rcp ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . Collections ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . Path ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . Bundle ; public abstract class AbstractFileLocatorActivator extends AbstractUIPlugin { public static InputStream locateFile ( String path , Bundle bundle ) throws IOException { File file = resolveFile ( path , bundle ) ; if ( file != null ) { return new FileInputStream ( file ) ; } return null ; } public static File resolveFile ( String path ,", "gt": "Bundle bundle ) throws IOException", "prediction": ")\n", "label": 1}
{"id": 2239, "input": "<s> package org . gk . engine . client . event ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import jfreecode . gwt . event . client . bus . obj . InfoList ; import jfreecode . gwt . event . client . bus . obj . InfoMap ; import jfreecode . gwt . event . client . bus . obj . InfoString ; import com . google . gwt . core . client . JavaScriptObject ; public class HttpHandler extends BeanHandler { @ Override protected void publishRemote ( String eventId , Map info , final JavaScriptObject jso ) { String remoteUrl = eventId ; EventObject eo = new EventObject ( eventId , info ) ; bus . publishRemote ( remoteUrl , eo , new EventProcess ( ) { @ Override public void execute ( String eventId , EventObject eo ) {", "gt": "if ( eo . getInfo ( ) instanceof InfoMap )", "prediction": "\n", "label": 0}
{"id": 8709, "input": "<s> package org . restlet . example . tutorial ; import static org . restlet . example . tutorial . Constants . ROOT_URI ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Restlet ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Protocol ; import org . restlet . resource . Directory ; import org . restlet . security . ChallengeAuthenticator ; import org . restlet . security . MapVerifier ; public class Part09a_GuardAccess extends Application { public static void main ( String [ ] args ) throws Exception { Component component = new Component ( ) ; component . getServers ( ) . add ( Protocol . HTTP , 8111 ) ; component . getClients ( ) . add ( Protocol . FILE ) ; Application application", "gt": "= new Part09a_GuardAccess ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7774, "input": "<s> package org . jboss . arquillian . android . configuration ; import java . io . File ; class Validate { public static void stateNotNull ( Object object , String message ) throws IllegalStateException { if ( object == null ) { throw new IllegalStateException ( message ) ; } } public static void notNull ( final Object obj , final String message ) throws IllegalArgumentException { if ( obj == null ) { throw new IllegalArgumentException ( message ) ; } } public static void notNullOrEmpty ( final String string , final String message ) throws IllegalArgumentException { if ( string == null || string . length ( ) == 0 ) { throw new IllegalArgumentException ( message ) ; } } public static void isReadable ( final String path , String message ) throws IllegalArgumentException { notNullOrEmpty ( path , message ) ; File file = new File ( path ) ; isReadable ( file , message ) ; } public static void isReadable ( final File file , String message ) throws IllegalArgumentException { if ( file == null ) {", "gt": "throw new IllegalArgumentException ( message ) ;", "prediction": "\n", "label": 0}
{"id": 8711, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . parser ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . internal . cheatsheets . Messages ; import org . eclipse . ui . internal . cheatsheets . composite . model . AbstractTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ITaskGroup ; import org . w3c . dom . Node ; public class TaskGroupParseStrategy implements ITaskParseStrategy { public TaskGroupParseStrategy ( ) { } public void init ( ) { } public boolean parseElementNode ( Node childNode , Node parentNode , AbstractTask parentTask , IStatusContainer status ) { return false ; } public void parsingComplete ( AbstractTask parentTask , IStatusContainer status ) { String kind = parentTask . getKind ( ) ; if ( ITaskGroup . SEQUENCE . equals ( kind ) ) { ICompositeCheatSheetTask [ ] children = parentTask . getSubtasks ( ) ; AbstractTask previous = null ; AbstractTask next = null ; for ( int i = 0 ; i < children . length ; i ++ ) { previous = next ; next = ( AbstractTask ) children [ i ] ; if ( previous != null ) { next . addRequiredTask ( previous ) ; } } checkForChildren ( parentTask , status ) ; } else if ( ITaskGroup . SET . equals ( kind ) ) { checkForChildren ( parentTask , status ) ; } else if ( ITaskGroup . CHOICE . equals ( kind ) ) { checkForChildren ( parentTask , status ) ; } else { String message = NLS . bind ( Messages . get ( ) . ERROR_PARSING_TASK_INVALID_KIND , ( new Object [ ] { parentTask . getKind ( ) , ICompositeCheatsheetTags . TASK_GROUP", "gt": ", parentTask . getName ( ) }", "prediction": ") ;\n", "label": 1}
{"id": 7266, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; public abstract class AbstractBuilder { protected Configuration configuration ; protected static Set < String > containingPackagesSeen ; protected static final boolean DEBUG = false ; public AbstractBuilder ( Configuration configuration ) { this . configuration = configuration ; } public abstract String getName ( ) ; public abstract void build ( ) throws IOException ; protected void build ( XMLNode node , Content contentTree ) { String component = node . name ; try { invokeMethod ( \"build\" + component , new Class < ? > [ ] { XMLNode . class , Content . class } , new Object [ ] { node , contentTree } ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; configuration . root . printError ( \"Unknown element: \" + component ) ; throw new DocletAbortException ( ) ; } catch ( InvocationTargetException e ) { e . getCause ( ) . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; configuration . root . printError ( \"Exception \" + e . getClass ( ) . getName ( ) + \" thrown while processing element: \" + component ) ; throw new DocletAbortException ( ) ; } } protected void buildChildren ( XMLNode node , Content contentTree ) { for ( XMLNode child : node .", "gt": "children ) build ( child , contentTree ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 8719, "input": "<s> package org . fuzzydb . postcode ; import java . io . File ; import java . io . UnsupportedEncodingException ; import java . util . Random ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . core . Settings ; import org . fuzzydb . util . FileUtils ; import org . fuzzydb . util . MTRandom ; import org . slf4j . Logger ; public class RandomPostcodeGenerator { private static Logger log = LogFactory . getLogger ( RandomPostcodeGenerator . class ) ; private Random random ; byte [ ] fullData ; byte [ ] shortData ; public RandomPostcodeGenerator ( ) { random = new MTRandom ( ) ; load ( ) ; } public RandomPostcodeGenerator ( Random r ) { assert ( r != null ) ; random = r ; load ( ) ; } public String nextFullPostcode ( ) { if ( fullData == null || fullData . length < 7 ) { throw new RuntimeException ( \"Random Postcodes data did not load\" ) ; } int numCodes = fullData . length / 7 ; int index = 7 * random . nextInt ( numCodes ) ; String result ; try { result = new String ( fullData , index , 7 , \"UTF8\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( \"Internal error: \" , e ) ; throw new RuntimeException ( e ) ; } return result . trim ( ) ; } public String nextShortPostcode ( ) { if ( shortData == null || shortData . length < 4 ) { throw new RuntimeException ( \"Random Postcodes short data did not load\" ) ; } int numCodes = shortData . length / 4 ; int index = 4 * random . nextInt ( numCodes ) ; String result ; try { result = new String ( shortData , index , 4 , \"UTF8\" ) ; } catch ( UnsupportedEncodingException e ) { System . out . println ( \"Internal error: \" + e ) ; throw new RuntimeException ( e ) ; } return result . trim ( ) ; } private void load ( ) { JibbleConvertor j = JibbleConvertor . getInstance ( ) ; shortData = j . getPrefixData ( ) ; try { String root = Settings . getInstance ( ) . getPostcodeRoot ( ) ; String fileName =", "gt": "root + File . separatorChar + RandomPostcodeImporter . randomCodesFile ;", "prediction": ";\n", "label": 1}
{"id": 4823, "input": "<s> package org . ofbiz . manufacturing . jobshopmgt ; import java . util . List ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . LocalDispatcher ; public class ProductionRunHelper { public static final String module = ProductionRunHelper . class . getName ( ) ; public static final String resource = \"ManufacturingUiLabels\" ; public static Map < String , Object > getProductionRun ( Delegator delegator , String productionRunId ) { Map < String , Object > result = FastMap . newInstance ( ) ; try { if ( productionRunId != null ) { GenericValue productionRun = delegator . findOne ( \"WorkEffort\" , UtilMisc . toMap ( \"workEffortId\" , productionRunId ) , false ) ; if ( productionRun != null ) { List < GenericValue > productionRunProducts = productionRun . getRelated ( \"WorkEffortGoodStandard\" , UtilMisc . toMap ( \"workEffortGoodStdTypeId\" , \"PRUN_PROD_DELIV\" ) , null , false ) ; GenericValue productionRunProduct = EntityUtil . getFirst ( productionRunProducts ) ; GenericValue productProduced = productionRunProduct . getRelatedOne ( \"Product\" , true ) ; List < GenericValue > productionRunComponents = productionRun . getRelated ( \"WorkEffortGoodStandard\" , UtilMisc . toMap ( \"workEffortGoodStdTypeId\" , \"PRUNT_PROD_NEEDED\" ) , null , false ) ; List < GenericValue > productionRunRoutingTasks = productionRun . getRelated ( \"FromWorkEffortAssoc\" , UtilMisc . toMap ( \"workEffortTypeId\" , \"PROD_ORDER_TASK\" ) , null , false ) ; result . put ( \"productionRunProduct\" , productionRunProduct ) ; result . put ( \"productProduced\" , productProduced ) ; result . put ( \"productionRunComponents\" , productionRunComponents ) ; result . put ( \"productionRunRoutingTasks\" , productionRunRoutingTasks ) ; } } } catch ( GenericEntityException e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; } return result ; } public static boolean hasTask ( Delegator delegator , String taskName , String workEffortId ) throws GenericEntityException { List < GenericValue > tasks = delegator . findByAnd ( \"WorkEffort\" , UtilMisc . toMap ( \"workEffortParentId\" , workEffortId , \"workEffortTypeId\" , \"PROD_ORDER_TASK\" , \"workEffortName\" , taskName ) , null , false ) ; return ( UtilValidate . isNotEmpty ( tasks ) ) ; } public static void getLinkedProductionRuns ( Delegator delegator , LocalDispatcher dispatcher , String productionRunId , List < ProductionRun > productionRuns ) throws GenericEntityException { productionRuns . add ( new ProductionRun (", "gt": "productionRunId , delegator , dispatcher ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8722, "input": "<s> package org . nuxeo . ecm . platform . userpreferences ; import org . nuxeo . ecm . core . api", "gt": ". localconfiguration . LocalConfiguration ;", "prediction": ";\n", "label": 1}
{"id": 6799, "input": "<s> package capture1 ; import java . util . List ; class C { public static < T > void copy1 ( List < ? super T > dest , List < ? extends T > src ) { copy1 ( dest , src ) ; copy2 ( dest , src ) ; copy3 ( dest , src ) ; } public static < T > void copy2 ( List < T > dest , List < ? extends T > src ) { copy1 ( dest , src ) ; copy2 ( dest , src ) ; copy3 ( dest , src ) ; } public static < T > void copy3 ( List < ? super T > dest , List < T > src ) { copy1 ( dest , src ) ; copy2 ( dest , src ) ; copy3 (", "gt": "dest , src ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8735, "input": "<s> package episode_18 ; import org . lwjgl . LWJGLException ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import static org . lwjgl . opengl . GL11 . * ; public class ImmediateDemo { public static void main ( String [ ] args ) { try { Display . setDisplayMode ( new DisplayMode ( 640 , 480 ) ) ; Display . setTitle ( \"Immediate Mode Demo\" ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; Display . destroy ( ) ; System . exit ( 1 ) ; } glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; glOrtho ( 1 , - 1 , 1 , - 1 , 1 , - 1 ) ; glMatrixMode ( GL_MODELVIEW ) ; glLoadIdentity ( ) ; while ( ! Display . isCloseRequested ( ) ) { glClear ( GL_COLOR_BUFFER_BIT ) ; glBegin ( GL_TRIANGLES ) ; glColor3f ( 1 , 0 , 0 ) ; glVertex2f ( - 0.5f , - 0.5f ) ; glColor3f ( 0 , 1 , 0 ) ; glVertex2f ( 0.5f , - 0.5f ) ; glColor3f ( 0 , 0 , 1 ) ; glVertex2f (", "gt": "0.5f , 0.5f ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3649, "input": "<s> package org . ofbiz . order . quote ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class QuoteServices { public static final String module = QuoteServices . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static final String resourceProduct = \"ProductUiLabels\" ; public static Map < String , Object > sendQuoteReportMail ( DispatchContext dctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; String emailType = ( String ) context . get ( \"emailType\" ) ; String quoteId = ( String ) context . get ( \"quoteId\" ) ; String sendTo = ( String ) context . get ( \"sendTo\" ) ; String sendCc = ( String ) context . get ( \"sendCc\" ) ; String note = ( String ) context . get ( \"note\" ) ; Map < String , Object > sendMap = FastMap . newInstance ( ) ; GenericValue quote = null ; try { quote = delegator . findOne ( \"Quote\" , UtilMisc . toMap ( \"quoteId\" , quoteId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Problem getting Quote\" , module ) ; } if ( quote == null ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"OrderOrderQuoteCannotBeFound\" , UtilMisc . toMap ( \"quoteId\" , quoteId ) , locale ) ) ; } GenericValue productStoreEmail = null ; try { productStoreEmail = delegator . findOne ( \"ProductStoreEmailSetting\" , UtilMisc . toMap ( \"productStoreId\" , quote . get ( \"productStoreId\" ) , \"emailType\" , emailType ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Problem getting the ProductStoreEmailSetting for productStoreId=\" + quote . get ( \"productStoreId\" ) + \" and emailType=\" + emailType , module ) ; } if ( productStoreEmail == null ) { return ServiceUtil . returnFailure ( UtilProperties . getMessage ( resourceProduct , \"ProductProductStoreEmailSettingsNotValid\" , UtilMisc . toMap ( \"productStoreId\" , quote . get ( \"productStoreId\" ) , \"emailType\" , emailType ) , locale ) ) ; } String bodyScreenLocation = productStoreEmail . getString ( \"bodyScreenLocation\" ) ; if ( UtilValidate . isEmpty ( bodyScreenLocation ) ) { return ServiceUtil . returnFailure ( UtilProperties . getMessage ( resourceProduct , \"ProductProductStoreEmailSettingsNotValidBodyScreenLocation\" , UtilMisc . toMap ( \"productStoreId\" , quote . get ( \"productStoreId\" ) , \"emailType\" , emailType ) , locale ) ) ; } sendMap . put ( \"bodyScreenUri\" , bodyScreenLocation ) ; String xslfoAttachScreenLocation = productStoreEmail . getString ( \"xslfoAttachScreenLocation\" ) ; sendMap . put ( \"xslfoAttachScreenLocation\" , xslfoAttachScreenLocation ) ; if ( ( sendTo == null ) || ! UtilValidate . isEmail ( sendTo ) ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resourceProduct , \"ProductProductStoreEmailSettingsNoSendToFound\" , locale ) ) ; } Map < String , Object > bodyParameters = UtilMisc . < String , Object > toMap ( \"quoteId\" , quoteId , \"userLogin\" , userLogin , \"locale\" , locale ) ; bodyParameters . put ( \"note\" , note ) ; bodyParameters . put ( \"partyId\" , quote . getString ( \"partyId\" ) ) ; sendMap . put ( \"bodyParameters\" , bodyParameters ) ; sendMap . put ( \"userLogin\" , userLogin ) ; String subjectString = productStoreEmail . getString ( \"subject\" ) ; sendMap . put ( \"subject\" , subjectString ) ; sendMap . put ( \"contentType\" , productStoreEmail . get ( \"contentType\" ) ) ; sendMap . put ( \"sendFrom\" , productStoreEmail . get ( \"fromAddress\" ) ) ; sendMap . put ( \"sendCc\" , productStoreEmail . get ( \"ccAddress\" ) ) ; sendMap . put ( \"sendBcc\" , productStoreEmail . get ( \"bccAddress\" ) ) ; sendMap . put", "gt": "( \"sendTo\" , sendTo ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 8736, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . webapp . documentsLists . DocumentsListsManager ; @ Operation ( id = ClearSelectedDocuments . ID , category = Constants . CAT_UI , requires = Constants . SEAM_CONTEXT , label = \"Clear Selected Documents\" , description = \"Clear the selected documents list.\"", "gt": ", since = \"5.6\" ) public class ClearSelectedDocuments", "prediction": ") ;\n", "label": 1}
{"id": 680, "input": "<s> package org . ofbiz . base . component ; import org . ofbiz . base . config . GenericConfigException ; @ SuppressWarnings ( \"serial\" ) public class ComponentException extends GenericConfigException { public ComponentException ( ) { super ( ) ; } public ComponentException ( String str ) { super ( str ) ; }", "gt": "public ComponentException ( Throwable nested )", "prediction": "}\n", "label": 0}
{"id": 8748, "input": "<s> package com . google . code . microlog4android ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import android . util . Log ; import com . google . code . microlog4android . appender . Appender ; import com . google . code . microlog4android . factory . DefaultAppenderFactory ; import com . google . code . microlog4android . repository . CommonLoggerRepository ; public final class Logger { private static final String TAG = \"Microlog.Logger\" ; public static final Level DEFAULT_LOG_LEVEL = Level . DEBUG ; public static final String DEFAULT_CLIENT_ID = \"Microlog\" ; private CommonLoggerRepository commonLoggerRepository = null ; private String clientID = DEFAULT_CLIENT_ID ; private String name ; private Level level ; private static final StopWatch stopWatch = new StopWatch ( ) ; private final static List < Appender > appenderList = new ArrayList < Appender > ( 4 ) ; private static boolean firstLogEvent = true ; public Logger ( String name ) { this . name = name ; } public Logger ( String name , CommonLoggerRepository commonLoggerRepository ) { this . name = name ; this . commonLoggerRepository = commonLoggerRepository ; } public synchronized void setCommonRepository ( final CommonLoggerRepository commonLoggerRepository ) { this . commonLoggerRepository = commonLoggerRepository ; } public Level getLevel ( ) { return level ; } public void setLevel ( Level level ) throws IllegalArgumentException { if ( level == null ) { throw new IllegalArgumentException ( \"The level must not be null.\" ) ; } this . level = level ; } public Level getEffectiveLevel ( ) { Level effectiveLevel = level ; if ( effectiveLevel == null && ! name . equals ( \"\" ) ) { if ( commonLoggerRepository == null ) { throw new IllegalStateException ( \"CommonLoggerRepository has not been set\" ) ; } else { effectiveLevel = commonLoggerRepository . getEffectiveLevel ( name ) ; } } return effectiveLevel ; } public String getClientID ( ) { return clientID ; } public void setClientID ( String clientID ) { this . clientID = clientID ; } public String getName ( ) { return name ; } public void addAppender ( Appender appender ) throws IllegalArgumentException { if ( appender == null ) { throw new IllegalArgumentException ( \"Appender not allowed to be null\" ) ; } if ( ! appenderList . contains ( appender ) ) { appenderList . add ( appender ) ; } } public void removeAppender ( Appender appender ) throws IllegalArgumentException { if ( appender == null ) { throw new IllegalArgumentException ( \"The appender must not be null.\" ) ; } if ( appender . isLogOpen ( ) ) { try { appender . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to close appender. \" + e ) ; } } appenderList . remove ( appender ) ; } public void removeAllAppenders ( ) { for ( Appender appender : appenderList ) { if ( appender . isLogOpen ( ) ) { try { appender . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to close appender. \" + e ) ; } } } appenderList . clear ( ) ; } public int getNumberOfAppenders ( ) { return appenderList . size ( ) ; } public Appender getAppender ( int index ) { return appenderList . get ( index ) ; } public void log ( Level level , Object message ) throws IllegalArgumentException { log ( level , message , null ) ; } public void log ( Level level , Object message , Throwable t ) throws IllegalArgumentException { if ( level == null ) { throw new IllegalArgumentException ( \"The level must not be null.\" ) ; } if ( getEffectiveLevel ( ) . toInt ( ) <= level . toInt ( ) && level . toInt ( ) > Level . OFF_INT ) { if ( firstLogEvent == true ) { addDefaultAppender ( ) ; try { open ( ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to open the log. \" + e ) ; } stopWatch . start ( ) ; firstLogEvent = false ; } for ( Appender appender : appenderList ) { appender . doLog ( clientID , name , stopWatch . getCurrentTime ( ) , level , message , t ) ; } } } private void addDefaultAppender ( ) { if ( appenderList . size ( ) == 0 ) { Log . w ( TAG , \"Warning! No appender is set, using LogCatAppender with PatternFormatter\" ) ; Appender appender = DefaultAppenderFactory . createDefaultAppender ( ) ; addAppender ( appender ) ; } } public boolean isTraceEnabled ( ) { Level effectiveLevel = getEffectiveLevel ( ) ; return effectiveLevel . toInt ( ) <= Level . TRACE_INT ; } public void trace ( Object message ) { log ( Level . TRACE , message , null ) ; } public void trace ( Object message , Throwable t ) { log ( Level . TRACE , message , t ) ; } public boolean isDebugEnabled ( ) { Level effectiveLevel = getEffectiveLevel ( ) ; return effectiveLevel . toInt ( ) <= Level . DEBUG_INT ; } public void debug ( Object message ) { log ( Level . DEBUG , message , null ) ; } public void debug ( Object message , Throwable t ) { log ( Level . DEBUG", "gt": ", message , t ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9427, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; import org . apache . http . client . HttpClient ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . InputStreamSource ; public class GisgraphyQueryCommand { private static final Logger logger = LoggerFactory . getLogger ( GisgraphyQueryCommand . class ) ; private final HttpClient httpClient ; private final UrlGenerator urlGenerator ; private final GisgraphyQuery searchQuery ; public GisgraphyQueryCommand ( HttpClient httpClient , UrlGenerator urlGenerator , GisgraphyQuery searchQuery ) { super ( ) ; this . httpClient = httpClient ; this . urlGenerator = urlGenerator ;", "gt": "this . searchQuery = searchQuery ;", "prediction": "}\n", "label": 0}
{"id": 8776, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . ToolBar ; import org . eclipse . swt . widgets . ToolItem ; public class TrimUtil { public static final int TRIM_DEFAULT_HEIGHT ; static { Shell s = new Shell ( Display . getCurrent ( ) , SWT . NONE ) ; s . setLayout ( new GridLayout ( ) ) ; ToolBar t = new ToolBar ( s , SWT . NONE ) ; t . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; ToolItem ti = new ToolItem ( t , SWT . PUSH ) ; ti . setImage ( JFaceResources . getImageRegistry ( ) . get (", "gt": "Dialog . DLG_IMG_MESSAGE_INFO ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 615, "input": "<s> package com . midtro . platform ; import com . midtro . platform . math . Vector2 ; public class Input { private final boolean [ ] keyState = new boolean [ 256 ] ; private final Vector2 mouse = new Vector2 ( ) ; public boolean isKeyUp ( final int key ) { return ! keyState [ key ] ; } public boolean isKeyDown ( final int key ) { return keyState [ key ] ; } private boolean withinRange ( final int i ) { return i >= 0 && i < keyState . length ; } public void updateKey ( final boolean state , final int keyCode ) { if ( withinRange ( keyCode ) ) { keyState [", "gt": "keyCode ] = state ;", "prediction": ";\n", "label": 0}
{"id": 8783, "input": "<s> package io . beancounter . listener . facebook . core . converter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import io . beancounter . commons . model . activity . * ; import io . beancounter . listener . facebook . core . converter . custom . Converter ; import io . beancounter . listener . facebook . core . converter . custom . ConverterException ; import io . beancounter . listener . facebook . core . converter . custom . UnconvertableException ; import java . lang . Object ; import java . util . HashMap ; import java . util . Map ; public class FacebookActivityConverter { private static final Logger LOGGER = LoggerFactory . getLogger ( FacebookActivityConverter . class ) ; private Map < Key , Converter > converters = new HashMap < Key , Converter > ( ) ; public void registerConverter ( Class < ? > clazz , Verb verb , Converter converter ) throws FacebookActivityConverterException { Key key = new Key ( clazz , verb ) ; if ( converters . containsKey ( key ) ) { converters . remove ( key ) ; converters . put ( key , converter ) ; } else { converters . put ( key , converter ) ; } } public Result convert ( Object obj , Verb verb , String userId ) throws FacebookActivityConverterException { Key key = new Key ( obj . getClass ( ) , verb ) ; LOGGER . debug ( \"got key {}\" , key ) ; Converter converter = converters . get ( key ) ; if ( converter == null ) { final String errMsg = \"object with type [\" + obj . getClass ( ) + \"] and verb [\" + verb + \"] is not supported\" ; LOGGER . error ( errMsg ) ; throw new FacebookActivityConverterException ( errMsg ) ; } io . beancounter . commons . model . activity . Object innerObj ; try { innerObj = converter . convert ( obj , true ) ; } catch ( UnconvertableException e ) { final String errMsg = \"object with type [\" + obj . getClass ( ) + \"] cannot be converted\" ; LOGGER . warn ( errMsg , e ) ; throw new UnconvertableFacebookActivityException ( errMsg , e ) ; } catch ( ConverterException e ) { final String errMsg = \"error while converting object with type [\" + obj . getClass ( ) + \"]\" ; LOGGER", "gt": ". error ( errMsg ) ;", "prediction": ";\n", "label": 1}
{"id": 531, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; } public static boolean start ( RootDoc root ) { try { for ( PackageDoc p : root . specifiedPackages ( ) ) { for ( AnnotationTypeDoc a : p . annotationTypes ( ) ) { for ( AnnotationTypeElementDoc e : a . elements ( ) ) { tester . printAnnotationTypeElement ( e ) ; } tester . println ( ) ; } for ( ClassDoc e : p . enums ( ) ) { for ( FieldDoc ec : e . enumConstants ( ) ) { tester . printField ( ec ) ; } tester . println ( ) ; } for ( ClassDoc cd : p . ordinaryClasses ( ) ) { for ( FieldDoc f : cd . fields ( ) ) { tester . printField ( f ) ; } tester . println ( ) ;", "gt": "for ( MethodDoc m : cd . methods ( ) )", "prediction": "}\n", "label": 0}
{"id": 8785, "input": "<s> package io . beancounter . activities ; public class WildcardSearchException extends Exception {", "gt": "public WildcardSearchException ( String message )", "prediction": "\n", "label": 1}
{"id": 5215, "input": "<s> class EnumCantBeInstantiated { enum E { A , B , C } E e =", "gt": "new E ( \"a\" ) ;", "prediction": ";\n", "label": 0}
{"id": 8795, "input": "<s> package cs224u . ingredients ; import org . xml . sax . * ; import org . xml . sax . helpers . * ; import java . io . * ; import java . util . * ; public class RecipeHandler extends DefaultHandler { private ArrayList < Recipe > recipes = new ArrayList < Recipe > ( ) ; private Recipe curRecipe = new Recipe ( ) ; private CharArrayWriter contents = new CharArrayWriter ( ) ; private IngredientLineParser ilp = new IngredientLineParser ( ) ; public void startElement ( String namespaceURI , String localName , String qName , Attributes attr ) throws SAXException { contents . reset ( ) ; if ( localName . equals ( \"page\" ) ) { curRecipe = new Recipe ( ) ; } } public void endElement ( String namespaceURI , String localName , String qName ) throws SAXException { if ( localName . equals ( \"page\" ) ) { curRecipe . setPlaintext ( contents . toString ( ) ) ; if ( curRecipe . isRecipe ( ) ) { curRecipe . structure ( ilp ) ; recipes . add ( curRecipe ) ; } } else if ( localName . equals ( \"title\" ) ) { curRecipe . setTitle ( contents . toString ( ) ) ; } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { contents . write ( ch , start , length ) ; } public ArrayList < Recipe > getRecipes ( ) { return recipes ; } public static void main ( String [ ] argv ) { System . out . println ( \"RecipeHandler SAX Events:\" ) ; try { XMLReader xr = XMLReaderFactory . createXMLReader ( ) ; RecipeHandler handler = new RecipeHandler ( ) ; xr . setContentHandler ( handler ) ; xr . parse ( new InputSource ( new FileReader ( \"WikibooksCookbookComplete-20120207011907.xml\" ) ) ) ; ArrayList < Recipe > recipes = handler . getRecipes ( ) ; System . out . println ( \"\" + recipes . size ( ) + \" total recipes\" ) ; for ( int i = 0 ; i < 30 ; i ++ ) { System . out . println ( recipes . get ( i ) . getStructuredIngredients ( ) . toString ( ) ) ; } }", "gt": "catch ( Exception e )", "prediction": "}\n", "label": 1}
{"id": 2484, "input": "<s> package org . gk . ui . client . com . grid . column ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . Radio ; import com . extjs . gxt . ui . client . widget . form . RadioGroup ; import com . extjs . gxt . ui . client . widget . grid . Grid ; public abstract class gkRadioColumnConfig extends gkCellColumnConfig { public gkRadioColumnConfig ( gkColumnInfo field ) { super ( field ) ; } @ Override protected Field createField ( ) { return new Radio ( ) { @ Override public void setFieldLabel ( String fieldLabel ) { super . setFieldLabel ( fieldLabel ) ; setHeader ( fieldLabel ) ; } } ; } @ Override protected Field createColumnCell ( final ModelData model , final String property , ListStore < ModelData > store , int rowIndex , int colIndex , Grid < ModelData > grid ) { final Radio radio = ( Radio ) createField ( ) ; onField ( radio ) ; if ( model . get ( property ) != null ) { String keyValue = model . get ( property ) ; if ( radio . getData ( radio . getBoxLabel ( ) ) . equals ( keyValue ) ) { radio . setValue ( true ) ; } else { radio . setValue ( false ) ; } } else {", "gt": "if ( radio . getValue ( ) )", "prediction": "}\n", "label": 0}
{"id": 8811, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import java . util . List ; import org . restlet . resource . Get ; import", "gt": "org . restlet . resource . Post ;", "prediction": ";\n", "label": 1}
{"id": 8966, "input": "<s> package pkg1 ; public class B { @ A ( \"f\" ) public int f ; @ A ( \"m1\"", "gt": ") public void m1 ( int i )", "prediction": ") ;\n", "label": 0}
{"id": 8816, "input": "<s> package org . apache . lucene . benchmark ; public class Constants { public static final int DEFAULT_RUN_COUNT = 5 ; public static final int DEFAULT_SCALE_UP = 5 ; public static final int DEFAULT_LOG_STEP = 1000 ; public static Boolean [", "gt": "] BOOLEANS = new Boolean [ ]", "prediction": ";\n", "label": 1}
{"id": 4943, "input": "<s> package com . asakusafw . example . jdbc . jobflow ; import com . asakusafw . example . jdbc . modelgen . dmdl . jdbc . AbstractSalesDetailJdbcImporterDescription ; public class SalesDetailFromJdbc extends AbstractSalesDetailJdbcImporterDescription {", "gt": "@ Override public String getProfileName ( )", "prediction": "( ) ;\n", "label": 0}
{"id": 8853, "input": "<s> package org . restlet . example . book . rest . ch3 ; import java . util . ArrayList ; import java . util . List ; import org . restlet . Response ; import org . restlet . ext . xml . DomRepresentation ; import org . w3c . dom . Node ; public class S3App extends S3Authorized { public static void main ( String ... args ) { for ( S3Bucket bucket : new S3App ( ) . getBuckets ( ) ) { System . out . println ( bucket . getName ( ) + \" : \" + bucket . getUri ( ) ) ; } } public List < S3Bucket > getBuckets ( ) { List < S3Bucket > result", "gt": "= new ArrayList < S3Bucket > ( ) ;", "prediction": ";\n", "label": 1}
{"id": 87, "input": "<s> package jns . util ; import java . util . Enumeration ; public class PriorityQueue { PriorityQueueItem m_first , m_last ; int m_size ; public PriorityQueue ( ) { m_first = m_last = null ; m_size = 0 ; } public void push ( Object object , double priority ) { PriorityQueueItem item = new PriorityQueueItem ( object , priority ) ; if ( m_first == null ) { m_first = m_last = item ; } else { PriorityQueueItem run = m_first ; while ( run != null && run . priority > priority ) run = run . next ; if ( run == null ) { item . prev = m_last ; m_last . next = item ; m_last = item ; } else { item . prev = run . prev ; item . next = run ; if ( run . prev == null ) { m_first = item ; run . prev = item ; } else { run . prev . next = item ; run . prev = item ; } } } m_size ++ ; } public Object peek ( ) { if ( m_last == null ) return null ; return m_last . object ; } public void pop ( ) { if ( m_last != null ) { m_size -- ; if ( m_last . prev == null ) { m_first = m_last = null ; } else { m_last = m_last . prev ; m_last . next = null ; } } } public int size ( ) { return m_size ; } public Enumeration elements ( ) { return new PriorityQueueEnumeration ( this ) ; } } class PriorityQueueItem { public PriorityQueueItem next , prev ; public Object object ; public double priority ; public PriorityQueueItem ( Object object , double priority ) { this . object = object ; this . priority = priority ; this . next = null ; this . prev = null ; } } class PriorityQueueEnumeration implements Enumeration { private PriorityQueueItem current ; public PriorityQueueEnumeration ( PriorityQueue q ) { current = q . m_last ; } public boolean hasMoreElements ( ) { return ( current != null ) ; } public Object nextElement ( ) { if", "gt": "( current != null )", "prediction": "( )\n", "label": 0}
{"id": 8879, "input": "<s> package org . apache . lucene . search . spans ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . * ; import org . apache . lucene . search . Explanation . IDFExplanation ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; public class SpanWeight extends Weight { protected Similarity similarity ; protected float value ; protected float idf ; protected float queryNorm ; protected float queryWeight ; protected Set terms ; protected SpanQuery query ; private IDFExplanation idfExp ; public SpanWeight ( SpanQuery query , Searcher searcher ) throws IOException { this . similarity = query . getSimilarity ( searcher ) ; this . query = query ; terms = new HashSet ( ) ; query . extractTerms ( terms ) ; idfExp = similarity . idfExplain ( terms , searcher ) ; idf = idfExp . getIdf ( ) ; } public Query getQuery ( ) { return query ; } public float getValue ( ) { return value ; } public float sumOfSquaredWeights ( ) throws IOException { queryWeight = idf * query . getBoost ( ) ; return queryWeight * queryWeight ; } public void normalize ( float queryNorm ) { this . queryNorm = queryNorm ; queryWeight *= queryNorm ; value = queryWeight * idf ; } public Scorer scorer ( IndexReader reader , boolean scoreDocsInOrder , boolean topScorer ) throws IOException { return new SpanScorer ( query . getSpans ( reader ) , this , similarity , reader . norms ( query . getField ( ) ) ) ; } public Explanation explain ( IndexReader reader , int doc ) throws IOException { ComplexExplanation result = new ComplexExplanation ( ) ; result . setDescription ( \"weight(\" + getQuery ( ) + \" in \" + doc + \"), product of:\" ) ; String field = ( ( SpanQuery ) getQuery ( ) ) . getField ( ) ; Explanation idfExpl = new Explanation ( idf , \"idf(\" + field + \": \" + idfExp . explain ( ) + \")\" ) ; Explanation queryExpl = new Explanation ( ) ; queryExpl . setDescription ( \"queryWeight(\" + getQuery ( ) + \"), product of:\" ) ; Explanation boostExpl = new Explanation ( getQuery ( ) . getBoost ( ) , \"boost\" ) ; if ( getQuery ( ) . getBoost ( ) != 1.0f ) queryExpl . addDetail ( boostExpl ) ; queryExpl . addDetail ( idfExpl ) ; Explanation queryNormExpl = new Explanation ( queryNorm , \"queryNorm\" ) ; queryExpl . addDetail ( queryNormExpl ) ; queryExpl . setValue ( boostExpl . getValue ( ) * idfExpl . getValue ( ) * queryNormExpl . getValue ( ) ) ; result . addDetail ( queryExpl ) ; ComplexExplanation fieldExpl = new ComplexExplanation ( ) ; fieldExpl . setDescription ( \"fieldWeight(\" + field + \":\" + query . toString ( field ) + \" in \" + doc + \"), product of:\" ) ; Explanation tfExpl = scorer ( reader , true , false ) . explain ( doc ) ; fieldExpl . addDetail ( tfExpl ) ; fieldExpl . addDetail ( idfExpl ) ; Explanation fieldNormExpl = new Explanation ( ) ; byte [ ] fieldNorms = reader . norms ( field ) ; float fieldNorm = fieldNorms != null ? Similarity . decodeNorm ( fieldNorms [ doc ] ) : 1.0f ; fieldNormExpl . setValue ( fieldNorm ) ; fieldNormExpl . setDescription ( \"fieldNorm(field=\" + field + \", doc=\" + doc + \")\" ) ; fieldExpl . addDetail ( fieldNormExpl ) ; fieldExpl . setMatch ( Boolean . valueOf ( tfExpl . isMatch ( ) ) ) ; fieldExpl . setValue ( tfExpl . getValue ( ) * idfExpl . getValue", "gt": "( ) * fieldNormExpl . getValue ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3815, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . IOException ; import java . io . PrintWriter ; import java . net . URL ; import com . sap . prd . mobile . ios . ota . lib . OtaBuildHtmlGenerator ; import com . sap . prd . mobile . ios . ota . lib . OtaBuildHtmlGenerator . Parameters ; class OTAManager { private final URL miosOtaServiceUrl ; private final String title ; private final String bundleIdentifier ; private final String bundleVersion ; private final String ipaClassifier ; private final String otaClassifier ; public OTAManager ( URL miosOtaServiceUrl , String title , String bundleIdentifier , String bundleVersion , String ipaClassifier , String otaClassifier ) { super ( ) ; this . miosOtaServiceUrl = miosOtaServiceUrl ; this . title = title ; this . bundleIdentifier = bundleIdentifier ; this . bundleVersion = bundleVersion ;", "gt": "this . ipaClassifier = ipaClassifier ;", "prediction": "}\n", "label": 0}
{"id": 8882, "input": "<s> package org . restlet . util ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . service . Service ; public final class ServiceList extends WrapperList < Service > { private volatile Context context ; public ServiceList ( Context context ) { super ( new CopyOnWriteArrayList < Service > ( ) ) ; this . context = context ; } @ Override public void add ( int index , Service service ) { service . setContext ( getContext ( ) ) ; super . add ( index , service ) ; } @ Override public boolean add ( Service service ) { service . setContext ( getContext ( ) ) ; return super . add ( service ) ; } @ Override public boolean addAll ( Collection < ? extends Service > services ) { if ( services != null ) { for ( Service service : services ) { service . setContext ( getContext ( ) ) ; } } return super . addAll ( services ) ; } @ Override public boolean addAll ( int index , Collection < ? extends Service > services ) { if ( services != null ) { for ( Service service : services ) { service . setContext ( getContext ( ) ) ; } } return super . addAll ( index , services ) ; } @ SuppressWarnings ( \"unchecked\" ) public < T extends Service > T get ( Class < T > clazz ) { for ( Service service : this ) { if ( clazz . isAssignableFrom ( service . getClass ( ) ) ) { return ( T ) service ; } } return null ; } public Context getContext ( ) { return this . context ; } public synchronized void set ( List < Service > services ) { clear ( ) ; if ( services != null ) { addAll ( services ) ; } } public synchronized void set ( Service newService ) { List < Service > services = new CopyOnWriteArrayList < Service > ( ) ; Service service ; boolean replaced = false ; for ( int i = 0 ; ( i < size ( ) ) ; i ++ ) { service = get ( i ) ; if ( service != null ) { if ( service . getClass ( ) . isAssignableFrom ( newService . getClass ( ) ) ) { try { service . stop ( ) ; } catch ( Exception e ) { Context . getCurrentLogger ( ) . log ( Level . WARNING , \"Unable to stop service replaced\" , e ) ; } services . add ( newService ) ; replaced = true ; } else { services .", "gt": "add ( service ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 6198, "input": "<s> import test . core . TestCore ; public class T6365854 { public static void main ( String ... args ) { TestCore tc = new TestCore ( ) ; System . out . println ( tc .", "gt": "toString ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8889, "input": "<s> package org . fuzzydb . client ; import org . springframework . util . Assert ; public class TransactionTemplate { private final Store store ; public TransactionTemplate ( Store store ) { this . store = store ; } public < T > T execute ( TransactionCallback < T > callback ) { Assert . state ( store . currentTransaction ( ) == null , \"Transaction already", "gt": "in progress. Cannot nest transactions in same thread.\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 943, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . ArrayList ; import java . util . List ; import com . mobeelizer . mobile . android . api . MobeelizerConjunction ; import com . mobeelizer . mobile . android . api . MobeelizerCriterion ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerConjunctionRestritionImpl implements MobeelizerInternalCriterion , MobeelizerConjunction { private final List < MobeelizerCriterion > criterions = new ArrayList < MobeelizerCriterion > ( ) ; @ Override public MobeelizerConjunction add ( final MobeelizerCriterion criterion ) { criterions .", "gt": "add ( criterion ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 8891, "input": "<s> package org . modelgoon . packages . editor ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IEditorActionBarContributor ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; public class PackagesViewContributor implements IEditorActionBarContributor { public void init ( final", "gt": "IActionBars bars , final IWorkbenchPage page )", "prediction": ")\n", "label": 1}
{"id": 3107, "input": "<s> package ar . com . fdvs . dj . output ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . engine . JRExporter ; import net . sf . jasperreports . engine . export . JRHtmlExporterParameter ; import net . sf . jasperreports . engine . export . JRXlsExporterParameter ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . core . layout . ListLayoutManager ; public class FormatInfoRegistry { public static final String EXPORTER_CLASS_XLS = \"net.sf.jasperreports.engine.export.JRXlsExporter\" ; public static final String EXPORTER_CLASS_CSV = \"net.sf.jasperreports.engine.export.JRCsvExporter\" ; public static final String EXPORTER_CLASS_HTML = \"net.sf.jasperreports.engine.export.JRHtmlExporter\" ; public static final String EXPORTER_CLASS_PDF = \"net.sf.jasperreports.engine.export.JRPdfExporter\" ; public static final String EXPORTER_CLASS_XML = \"net.sf.jasperreports.engine.export.JRXmlExporter\" ; private static final Map FORMAT_INFO = new HashMap ( ) ; static { FORMAT_INFO . put ( DJConstants . FORMAT_CSV , new FormatInfo ( \"text/plain\" , EXPORTER_CLASS_CSV , ClassicLayoutManager . class . getName ( ) ) ) ; FORMAT_INFO . put ( DJConstants . FORMAT_HTML , new FormatInfo ( \"text/html\" , EXPORTER_CLASS_HTML , ClassicLayoutManager . class . getName ( ) ) ) ; FORMAT_INFO . put ( DJConstants . FORMAT_PDF , new FormatInfo ( \"application/pdf\" , EXPORTER_CLASS_PDF , ClassicLayoutManager . class . getName ( ) ) ) ; FORMAT_INFO . put ( DJConstants . FORMAT_XLS , new FormatInfo ( \"application/vnd.ms-excel\" , EXPORTER_CLASS_XLS , ListLayoutManager . class . getName ( ) ) ) ; FORMAT_INFO . put ( DJConstants . FORMAT_XML , new FormatInfo ( \"text/xml\" , EXPORTER_CLASS_XML , ClassicLayoutManager . class . getName ( ) ) ) ; } private static final FormatInfoRegistry INSTANCE = new FormatInfoRegistry ( ) ; public String getContentType ( final String _format ) { checkFormat ( _format ) ; return ( ( FormatInfo ) FORMAT_INFO . get ( _format ) ) . getContentType ( ) ; } public JRExporter getExporter ( final String _format ) { checkFormat ( _format ) ; final JRExporter exporter = ( ( FormatInfo ) FORMAT_INFO . get ( _format ) ) . getExporterInstance ( ) ; exporter . setParameter ( JRHtmlExporterParameter . IS_USING_IMAGES_TO_ALIGN , Boolean . FALSE ) ; exporter . setParameter ( JRXlsExporterParameter . IS_WHITE_PAGE_BACKGROUND , Boolean . FALSE ) ; exporter . setParameter ( JRXlsExporterParameter . IS_REMOVE_EMPTY_SPACE_BETWEEN_ROWS , Boolean . TRUE ) ; exporter . setParameter ( JRXlsExporterParameter . IS_WHITE_PAGE_BACKGROUND , Boolean . FALSE ) ; exporter . setParameter ( JRXlsExporterParameter . IS_REMOVE_EMPTY_SPACE_BETWEEN_ROWS , Boolean . TRUE ) ; return exporter ; } public LayoutManager getLayoutManager ( final String _format ) { checkFormat ( _format ) ; return ( ( FormatInfo ) FORMAT_INFO . get ( _format ) ) . getLayoutManagerInstance ( ) ; } private static void checkFormat", "gt": "( final String _format )", "prediction": ";\n", "label": 0}
{"id": 8894, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . controllers ; import java . util . ArrayList ; import android . app . Activity ; import android . app . Fragment ; import android . app . FragmentManager ; import android . app . FragmentTransaction ; import android . content . res . Resources ; import android . graphics . Color ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import android . view . View ; import android . view . View . MeasureSpec ; import android . view . View . OnClickListener ; import android . view . ViewGroup ; import android . view . ViewGroup . LayoutParams ; import android . view . inputmethod . InputMethodManager ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . TextView ; import com . xtremelabs . androidtohackui . R ; import com . xtremelabs . androidtohackui . bubbles . fragments . IBubbleFragment ; import com . xtremelabs . androidtohackui . bubbles . models . BubbleTitleBarElements ; import com . xtremelabs . androidtohackui . bubbles . ui . AnchorInfo ; import com . xtremelabs . androidtohackui . bubbles . ui . BubbleLayout ; abstract public class AbstractBubbleController { public static final int BUBBLE_DEFAULT_WIDTH = 380 ; public static final int BUBBLE_DEFAULT_HEIGHT = 600 ; private long mLastBubbleAppearance = Long . MIN_VALUE ; private static final String FRAGMENT_TRANSACTION_NAME = \"FRAGMENT_TRANSACTION_NAME\" ; private BubbleLayout mBubbleLayout ; protected Activity mActivity ; private Button mBackButton ; private boolean mOpen = false ; private ArrayList < OnCloseListener > mOnCloseListeners ; abstract public void onBubbleAttachedToWindow ( ) ; public AbstractBubbleController ( final Activity activity ) { if ( ! ( activity instanceof IBubbleContainer ) ) { throw new RuntimeException ( \"Activity must implement IBubbleContainer\" ) ; } mActivity = activity ; mBackButton = new Button ( activity ) ; mBackButton . setText ( \"Back\" ) ; mBackButton . setTextColor ( Color . BLACK ) ; mBackButton . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onBackPressed ( activity . getFragmentManager ( ) ) ; } } ) ; mOnCloseListeners = new ArrayList < OnCloseListener > ( ) ; } public void showBubble ( View anchor ) { AnchorInfo anchorInfo = AnchorInfo . createAnchorInfo ( anchor ) ; if ( isSmashingAnchor ( ) ) return ; ( ( IBubbleContainer ) mActivity ) . initBubble ( this ) ; if ( mBubbleLayout != null ) { closeBubble ( ) ; } BubbleLayout layout = createBubbleLayout ( anchorInfo ) ; layout . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { AbstractBubbleController . this . closeBubble ( ) ; } } ) ; layout . setAnchor ( anchorInfo ) ; determineMeasureSpecs ( layout ) ; attachLayoutToScreen ( layout ) ; } public void closeBubble ( ) { if ( mBubbleLayout != null ) { cleanupDependencies ( ) ; removeLayoutFromScreen ( ) ; resetState ( ) ; } } protected void pushFragment ( Fragment fragment ) { int bubbleId = mBubbleLayout . getContainer ( ) . getId ( ) ; addBackButton ( fragment ) ; FragmentManager fragmentManager = mActivity . getFragmentManager ( ) ; if ( fragmentManager . findFragmentById ( bubbleId ) == null ) { fragmentManager . beginTransaction ( ) . add ( bubbleId , fragment ) . addToBackStack ( FRAGMENT_TRANSACTION_NAME ) . commit ( ) ; } else { FragmentTransaction ft = fragmentManager . beginTransaction ( ) ; ft . replace ( bubbleId , fragment ) ; ft . addToBackStack ( FRAGMENT_TRANSACTION_NAME ) . commit ( ) ; } fragmentManager . executePendingTransactions ( ) ; configureTitleBar ( ) ; } protected boolean popFragment ( ) { FragmentManager fragmentManager = mActivity . getFragmentManager ( ) ; if ( fragmentManager . getBackStackEntryCount ( ) <= 0 ) return false ; hideKeyboard ( ) ; fragmentManager . popBackStackImmediate ( ) ; if ( fragmentManager . getBackStackEntryCount ( ) <= 0 ) { closeBubble ( ) ; } else { configureTitleBar ( ) ; } return true ; } private void addBackButton ( Fragment fragment ) { FragmentManager fragmentManager = mActivity . getFragmentManager ( ) ; if ( fragment instanceof IBubbleFragment && fragmentManager . getBackStackEntryCount ( ) > 0 ) { ( ( IBubbleFragment ) fragment ) . getBubbleActionBarElements ( ) . setLeftButton ( mBackButton ) ; } } private void resetState ( ) { mBubbleLayout = null ; mActivity = null ; mOpen = false ; } private void removeLayoutFromScreen ( ) { ViewGroup frame = (", "gt": "ViewGroup ) mActivity . findViewById ( getContainerId ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7954, "input": "<s> package javax . tools ; import java . io . * ; import java . net . URI ; import java . nio . CharBuffer ; import javax . lang . model . element . Modifier ; import javax . lang . model . element . NestingKind ; import javax . tools . JavaFileObject . Kind ; public class SimpleJavaFileObject implements JavaFileObject { protected final URI uri ; protected final Kind kind ; protected SimpleJavaFileObject ( URI uri , Kind kind ) { uri . getClass ( ) ; kind . getClass ( ) ; if ( uri . getPath ( ) == null ) throw new IllegalArgumentException ( \"URI must have a path: \" + uri ) ; this . uri = uri ; this . kind = kind ; } public URI toUri ( ) { return uri ; } public String getName ( ) { return toUri ( ) . getPath ( ) ; } public InputStream openInputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public OutputStream openOutputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Reader openReader ( boolean ignoreEncodingErrors ) throws IOException { CharSequence charContent = getCharContent ( ignoreEncodingErrors ) ; if ( charContent == null ) throw new UnsupportedOperationException ( ) ; if ( charContent instanceof CharBuffer ) { CharBuffer buffer = ( CharBuffer ) charContent ; if ( buffer . hasArray ( ) ) return new CharArrayReader ( buffer . array ( ) ) ; } return new StringReader ( charContent . toString ( ) ) ; } public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Writer openWriter ( ) throws IOException { return new OutputStreamWriter ( openOutputStream ( ) ) ; } public long getLastModified ( ) { return 0L ; } public boolean delete ( ) { return false ; } public Kind getKind ( ) { return kind ; } public boolean isNameCompatible ( String simpleName , Kind kind ) { String baseName", "gt": "= simpleName + kind . extension ;", "prediction": ";\n", "label": 0}
{"id": 8899, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . compatible . controllers ; import java . util . ArrayList ; import android . content . res . Resources ; import android . support . v4 . app . Fragment ; import android . support . v4 . app . FragmentActivity ; import android . support . v4 . app . FragmentManager ; import android . support . v4 . app . FragmentManager . BackStackEntry ; import android . support . v4 . app . FragmentTransaction ; import android . util . DisplayMetrics ; import android . util . TypedValue ; import android . view . View ; import android . view . View . MeasureSpec ; import android . view . View . OnClickListener ; import android . view . ViewGroup ; import android . view . ViewGroup . LayoutParams ; import android . view . inputmethod . InputMethodManager ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . TextView ; import com . xtremelabs . androidtohackui . R ; import com . xtremelabs . androidtohackui . bubbles . fragments . IBubbleFragment ; import com . xtremelabs . androidtohackui . bubbles . models . BubbleTitleBarElements ; import com . xtremelabs . androidtohackui . bubbles . ui . AnchorInfo ; import com . xtremelabs . androidtohackui . bubbles . ui . BubbleLayout ; abstract public class AbstractBubbleController { public static final int BUBBLE_DEFAULT_WIDTH = 380 ; public static final int BUBBLE_DEFAULT_HEIGHT = 600 ; private long mLastBubbleAppearance = Long . MIN_VALUE ; public static final String TRANS_ID = \"8305612947\" ; private BubbleLayout mBubbleLayout ; protected FragmentActivity mActivity ; private Button mBackButton ; private boolean mOpen = false ; private ArrayList < OnCloseListener > mOnCloseListeners ; abstract public void onBubbleAttachedToWindow ( ) ; public AbstractBubbleController ( final FragmentActivity activity ) { if ( ! ( activity instanceof IBubbleContainer ) ) { throw new RuntimeException ( \"Can only create bubbles in activities that implement IBubbleContainer\" ) ; } mActivity = activity ; mBackButton = new Button ( activity ) ; mBackButton . setText ( \"Back\" ) ; mBackButton . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onBackPressed ( activity . getSupportFragmentManager ( ) ) ; } } ) ; mOnCloseListeners = new ArrayList < OnCloseListener > ( ) ; } public void showBubble ( View anchor ) { showBubble ( AnchorInfo . createAnchorInfo ( anchor ) , MeasureSpec . makeMeasureSpec ( getDIPValue ( BUBBLE_DEFAULT_WIDTH ) , MeasureSpec . AT_MOST ) , MeasureSpec . makeMeasureSpec ( getDIPValue ( BUBBLE_DEFAULT_HEIGHT ) , MeasureSpec . AT_MOST ) ) ; } public void showBubble ( final AnchorInfo anchorInfo , int preferredBubbleWidthMeasureSpec , int preferredBubbleHeightMeasureSpec ) { ( ( IBubbleContainer ) mActivity ) . initBubble ( this ) ; long now = System . currentTimeMillis ( ) ; if ( now - mLastBubbleAppearance < 500 && mLastBubbleAppearance != Long . MIN_VALUE ) return ; mLastBubbleAppearance = now ; if ( mBubbleLayout != null ) { closeBubble ( ) ; } BubbleLayout layout = new BubbleLayout ( mActivity ) { @ Override protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { AnchorInfo newInfo = anchorInfo ; AnchorInfo oldInfo = getAnchor ( ) ; if ( oldInfo != null && ! oldInfo . equals ( newInfo ) ) { setAnchor ( newInfo ) ; } super . onLayout ( changed , left , top , right , bottom ) ; } @ Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; onBubbleAttachedToWindow ( ) ; } } ; layout . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { AbstractBubbleController . this . closeBubble ( ) ; } } ) ; layout . setAnchor ( anchorInfo ) ; if ( preferredBubbleHeightMeasureSpec != 0 ) { layout . setPreferredBubbleHeightMeasureSpec ( preferredBubbleHeightMeasureSpec ) ; } if ( preferredBubbleWidthMeasureSpec != 0 ) { layout . setPreferredBubbleWidthMeasureSpec ( preferredBubbleWidthMeasureSpec ) ; } if ( preferredBubbleHeightMeasureSpec == 0 || preferredBubbleWidthMeasureSpec == 0 ) { layout . setLayoutParams ( new LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ) ; } ViewGroup frame = ( ViewGroup ) mActivity . findViewById ( getContainerId ( ) ) ; mBubbleLayout = layout ; frame . addView ( mBubbleLayout , new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . MATCH_PARENT ) ) ; mOpen = true ; } protected int getContainerId ( ) { return ( ( IBubbleContainer ) mActivity ) . getBubbleContainerId ( ) ; } public void closeBubble ( ) { if ( mBubbleLayout != null ) { hideKeyboard ( ) ; for ( OnCloseListener onCloseListener : mOnCloseListeners ) { onCloseListener . onClose ( this , mBubbleLayout , mActivity . getSupportFragmentManager ( ) ) ; } while ( mActivity . getSupportFragmentManager ( ) . popBackStackImmediate ( ) ) { } ViewGroup frame = ( ViewGroup ) mActivity . findViewById ( getContainerId ( ) ) ; if ( frame != null ) frame . removeView ( mBubbleLayout ) ; mBubbleLayout = null ; mActivity = null ; mOpen = false ; } } public void addOnCloseListener ( OnCloseListener listener ) { if ( ! mOnCloseListeners . contains ( listener ) ) { mOnCloseListeners . add ( listener ) ; } } public void removeOnCloseListener ( OnCloseListener listener ) { mOnCloseListeners . remove ( listener ) ; } public void clearOnCloseListeners ( ) { mOnCloseListeners . clear ( ) ; } public boolean isOpen ( ) { return mOpen ; } private void hideKeyboard ( ) { InputMethodManager imm = ( InputMethodManager ) mActivity . getSystemService ( FragmentActivity . INPUT_METHOD_SERVICE ) ; View view = mActivity . getCurrentFocus ( ) ; if ( view == null ) return ; imm . hideSoftInputFromWindow ( view . getWindowToken ( ) , 0 ) ; } protected Fragment getVisibleFragment ( ) { if ( mActivity == null ) return null ; int bodyId = mBubbleLayout . getContainer ( ) . getId ( ) ; FragmentManager fragmentManager = mActivity . getSupportFragmentManager ( ) ; return fragmentManager . findFragmentById ( bodyId ) ; } protected void pushFragment ( Fragment fragment , String title ) { int bodyId = mBubbleLayout . getContainer ( ) . getId ( ) ; FragmentManager fragmentManager = mActivity . getSupportFragmentManager ( ) ; if ( fragmentManager . findFragmentById ( bodyId ) == null ) fragmentManager . beginTransaction ( ) . add ( bodyId , fragment ) . setBreadCrumbShortTitle ( title ) . addToBackStack ( TRANS_ID ) . commit ( ) ; else { FragmentTransaction ft = fragmentManager . beginTransaction ( ) ; ft . replace ( bodyId , fragment ) . addToBackStack ( TRANS_ID", "gt": ") . setBreadCrumbShortTitle ( title ) . commit ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6718, "input": "<s> package next . interfaces . controller . widgets ; import next . i . view . widgets . XFlexTable ; import next . i . view . widgets . XSlider ; import next . interfaces . controller . GitXController ; import com . google . gwt . event . logical . shared . ValueChangeEvent ; import com . google . gwt . event . logical . shared . ValueChangeHandler ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . user . client . ui . Label ; public class SliderController extends GitXController { public SliderController ( ) { setTitle ( \"Slider\" ) ; } @ Override public IsWidget getViewContent ( ) { XFlexTable panel = new XFlexTable ( ) ; panel . setCellSpacing ( 40 ) ; HTML label = new HTML ( \"&nbsp;\" ) ; XSlider slider1 = new XSlider ( 75 ) ; XSlider slider2 = new XSlider ( 100 ) ; XSlider slider3 = new XSlider ( 35 ) ; addHandlers ( label , slider1", "gt": ", slider2 , slider3 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 8907, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class ReferenceCounter { private Map mapIdToRec = new HashMap ( 11 ) ; public class RefRec { public RefRec ( Object id , Object value ) { this . id = id ; this . value = value ; addRef ( ) ; } public Object getId ( ) { return id ; } public Object getValue ( ) { return value ; } public int addRef ( ) { ++ refCount ; return refCount ; } public int removeRef ( ) { -- refCount ; return refCount ; } public int getRef ( ) { return refCount ; } public boolean isNotReferenced ( ) { return ( refCount <= 0 ) ; } public Object id ; public Object value ; private int refCount ; } public ReferenceCounter ( ) { super ( ) ; } public int addRef ( Object id ) { RefRec rec = ( RefRec ) mapIdToRec . get ( id ) ; if ( rec == null ) { return 0 ; } return rec . addRef ( ) ; } public Object get ( Object id ) { RefRec rec = ( RefRec ) mapIdToRec . get ( id ) ; if ( rec == null ) { return null ; } return rec . getValue ( ) ; } public Set keySet ( ) { return mapIdToRec . keySet ( ) ; } public void put ( Object id , Object value ) { RefRec rec = new RefRec ( id , value ) ; mapIdToRec . put ( id , rec ) ; } public int getRef ( Object id ) { RefRec rec = ( RefRec ) mapIdToRec . get ( id ) ; if ( rec == null ) { return 0 ; } return rec . refCount ; } public int removeRef ( Object id ) { RefRec rec = ( RefRec ) mapIdToRec . get ( id ) ;", "gt": "if ( rec == null )", "prediction": "}\n", "label": 1}
{"id": 7249, "input": "<s> package ar . com . fdvs . dj . domain . entities ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . domain . BooleanExpression ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJBaseElement ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJGroupLabel ; import ar . com . fdvs . dj . domain . DJValueFormatter ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . util . ExpressionUtils ; public class DJGroupVariable extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private static final Log log = LogFactory . getLog ( DJGroupVariable . class ) ; private AbstractColumn columnToApplyOperation ; private DJCalculation operation ; private Style style ; private DJValueFormatter valueFormatter ; private BooleanExpression printWhenExpression ; private CustomExpression valueExpression ; private DJGroupLabel label ; private DJGroup group ; public DJGroupVariable ( AbstractColumn columnToApplyOperation , DJCalculation operation ) { this . columnToApplyOperation = columnToApplyOperation ; this . operation = operation ; } public DJGroupVariable ( AbstractColumn columnToApplyOperation , DJCalculation operation , Style style ) { this . columnToApplyOperation = columnToApplyOperation ; this . operation = operation ; this . style = style ; } public DJGroupVariable ( AbstractColumn columnToApplyOperation , DJCalculation operation , Style style , DJValueFormatter formatter ) { this . columnToApplyOperation = columnToApplyOperation ; this . operation = operation ; this . style = style ; this . valueFormatter = formatter ; } public DJGroupVariable ( AbstractColumn columnToApplyOperation , CustomExpression valueExpression ) { this . columnToApplyOperation = columnToApplyOperation ; this . valueExpression = valueExpression ; } public DJGroupVariable ( AbstractColumn columnToApplyOperation , CustomExpression valueExpression , Style style ) { this . columnToApplyOperation = columnToApplyOperation ; this . valueExpression = valueExpression ; this . style = style ; } public String getTextForValueFormatterExpression ( String variableName ) { String fieldsMap = ExpressionUtils . getTextForFieldsFromScriptlet ( ) ; String parametersMap = ExpressionUtils . getTextForParametersFromScriptlet ( ) ; String variablesMap = ExpressionUtils . getTextForVariablesFromScriptlet ( ) ; String stringExpression = \"(((\" + DJValueFormatter . class . getName ( ) + \")$P{\" + variableName + \"_vf}).evaluate( \" + \"$V{\" + variableName + \"}, \" + fieldsMap + \", \" + variablesMap + \", \" + parametersMap + \" ))\" ; log . debug ( \"Expression for DJValueFormatter = \" + stringExpression ) ; return stringExpression ; } public Style getStyle ( ) { return style ; } public void setStyle ( Style style ) { this . style = style ; } public AbstractColumn getColumnToApplyOperation ( ) { return columnToApplyOperation ; } public void setColumnToApplyOperation ( AbstractColumn columnToApplyOperation ) { this . columnToApplyOperation = columnToApplyOperation ; } public DJCalculation getOperation ( ) { return operation ; } public void setOperation ( DJCalculation operation ) { this . operation = operation ; } public DJValueFormatter getValueFormatter ( ) { return valueFormatter ; } public void setValueFormatter ( DJValueFormatter valueFormatter ) { this . valueFormatter = valueFormatter ; } public DJGroupLabel getLabel ( ) { return label ; } public void setLabel ( DJGroupLabel label ) { this . label = label ; } public static Log getLog ( ) { return log ; } public DJGroupVariable ( AbstractColumn columnToApplyOperation , DJCalculation operation , Style style , DJValueFormatter", "gt": "valueFormatter , DJGroupLabel label )", "prediction": ") ;\n", "label": 0}
{"id": 8912, "input": "<s> package fr . inria . zvtm . widgets ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . Graphics ; import java . awt . event . MouseEvent ; import java . awt . event . MouseAdapter ; import javax . swing . JButton ; import javax . swing . Action ; import javax . swing . Icon ; public class TranslucentButton extends JButton implements TranslucentWidget { AlphaComposite bgAC = AB_08 ; AlphaComposite bgACro = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , .8f ) ; AlphaComposite fgAC = AB_10 ; Color bgColro = Color . GRAY ; Color fgColsel = Color . LIGHT_GRAY ; Color fgCol = Color . WHITE ; Color bgCol = Color . BLACK ; boolean cursorInside = false ; boolean buttonPressed = false ; public TranslucentButton ( ) { super ( ) ; init ( ) ; } public TranslucentButton ( Action a ) { super ( a ) ; init ( ) ; } public TranslucentButton ( Icon icon ) { super ( icon ) ; init ( ) ; } public TranslucentButton ( String text ) { super ( text ) ; init ( ) ; } public TranslucentButton ( String text , Icon icon ) { super ( text , icon ) ; init ( ) ; } void init ( ) { setOpaque ( false ) ; setContentAreaFilled ( false ) ; setBorderPainted ( false ) ; initColors ( ) ; initListeners ( ) ; } void initColors ( ) { setForeground ( fgCol ) ; setBackground ( bgCol ) ; } void initListeners ( ) { addMouseListener ( new MouseAdapter ( ) { public void mouseEntered ( MouseEvent e ) { cursorInside = true ; setBackground ( bgColro ) ; repaint ( ) ; } public void mouseExited ( MouseEvent e ) { cursorInside = false ; setBackground ( bgCol ) ; repaint ( ) ; } public void mousePressed ( MouseEvent e ) { buttonPressed = true ; setForeground ( fgColsel ) ; repaint ( ) ; } public void mouseReleased ( MouseEvent e ) { buttonPressed = false ; setForeground ( fgCol ) ; repaint ( ) ; } } ) ; } public void setBackgroundTranslucence ( float alpha ) { this . bgAC = AlphaComposite . getInstance", "gt": "( AlphaComposite . SRC_OVER , alpha ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1498, "input": "<s> import com . sun . source . util . JavacTask ; import java . net . URI ; import java . util . Arrays ; import javax . tools . Diagnostic ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . StandardJavaFileManager ; import javax . tools . ToolProvider ; public class GenericConstructorAndDiamondTest { enum BoundKind { NO_BOUND ( \"\" ) , STRING_BOUND ( \"extends String\" ) , INTEGER_BOUND ( \"extends Integer\" ) ; String boundStr ; private BoundKind ( String boundStr ) { this . boundStr = boundStr ; } boolean matches ( TypeArgumentKind tak ) { switch ( tak ) { case NONE : return true ; case STRING : return this != INTEGER_BOUND ; case INTEGER : return this != STRING_BOUND ; default : return false ; } } } enum ConstructorKind { NON_GENERIC ( \"Foo(Object o) {}\" ) , GENERIC_NO_BOUND ( \"<T> Foo(T t) {}\" ) , GENERIC_STRING_BOUND ( \"<T extends String> Foo(T t) {}\" ) , GENERIC_INTEGER_BOUND ( \"<T extends Integer> Foo(T t) {}\" ) ; String constrStr ; private ConstructorKind ( String constrStr ) { this . constrStr = constrStr ; } boolean matches ( ArgumentKind ak ) { switch ( ak ) { case STRING : return this != GENERIC_INTEGER_BOUND ; case INTEGER : return this != GENERIC_STRING_BOUND ; default : return false ; } } } enum TypeArgArity { ONE ( 1 ) , TWO ( 2 ) , THREE ( 3 ) ; int n ; private TypeArgArity ( int n ) { this . n = n ; } } enum TypeArgumentKind { NONE ( \"\" ) , STRING ( \"String\" ) , INTEGER ( \"Integer\" ) ; String typeargStr ; private TypeArgumentKind ( String typeargStr ) { this . typeargStr = typeargStr ; } String getArgs ( TypeArgArity arity ) { if ( this == NONE ) return \"\" ; else { StringBuilder buf = new StringBuilder ( ) ; String sep = \"\" ; for ( int i = 0 ; i < arity . n ; i ++ ) { buf . append ( sep ) ; buf . append ( typeargStr ) ; sep = \",\" ; } return \"<\" + buf . toString ( ) + \">\" ; } } boolean matches ( ArgumentKind ak ) { switch ( ak ) { case STRING : return this != INTEGER ; case INTEGER : return this != STRING ; default : return false ; } } boolean matches ( TypeArgumentKind other ) { switch ( other ) { case STRING : return this != INTEGER ; case INTEGER", "gt": ": return this != STRING ;", "prediction": ") ;\n", "label": 0}
{"id": 8935, "input": "<s> package org . fuzzydb . util ; public class DynamicRef < T > { volatile private T object ; public T getObject ( ) { return object ; } public synchronized void", "gt": "setObject ( T object )", "prediction": "( )\n", "label": 1}
{"id": 298, "input": "<s> package com . matburt . mobileorg . Services ; import android . app . Dialog ; import android . app . TimePickerDialog ; import android . os . Bundle ; import android . support . v4 . app . DialogFragment ; import android . support . v4 . app . FragmentActivity ; import android . support . v4 . app . FragmentTransaction ; import android . view . View ; import android . view . Window ; import android . widget . Button ; import android . widget . TextView ; import android . widget . TimePicker ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . util . OrgNodeNotFoundException ; public class TimeclockDialog extends FragmentActivity { private OrgNode node ; private int hour = 0 ; private int minute = 0 ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_LEFT_ICON ) ; setContentView ( R . layout . timeclock_dialog ) ; getWindow ( ) . setFeatureDrawableResource ( Window . FEATURE_LEFT_ICON , android . R . drawable . ic_dialog_alert ) ; Button button = ( Button ) findViewById ( R . id . timeclock_cancel ) ; button . setOnClickListener ( cancelListener ) ; button = ( Button ) findViewById ( R . id . timeclock_edit ) ; button . setOnClickListener ( editListener ) ; button = ( Button ) findViewById ( R . id . timeclock_save ) ; button . setOnClickListener ( saveListener ) ; } @ Override protected void onStart ( ) { super . onStart ( ) ; String elapsedTime = TimeclockService . getInstance ( ) . getElapsedTimeString ( ) ; parseElapsedTime ( elapsedTime ) ; setTitle ( \"MobileOrg Timeclock\" ) ; TextView textView = ( TextView ) findViewById ( R . id . timeclock_text ) ; long node_id = TimeclockService . getInstance ( ) . getNodeID ( ) ; try { this . node = new OrgNode ( node_id , getContentResolver ( ) ) ; } catch ( OrgNodeNotFoundException e ) { } textView . setText ( node . name + \"@\" + elapsedTime ) ; } private void parseElapsedTime ( String elapsedTime ) { String [ ] split = elapsedTime . trim ( ) . split ( \":\" ) ; try { this . hour = Integer . parseInt ( split [ 0 ] ) ; this . minute = Integer . parseInt ( split [ 1 ] ) ; } catch ( NumberFormatException e ) { } } private void saveClock ( int hour , int minute ) { long startTime = TimeclockService . getInstance ( ) . getStartTime ( ) ; long endTime = TimeclockService . getInstance ( ) . getEndTime ( ) ; String elapsedTime = TimeclockService . getInstance ( ) . getElapsedTimeString ( ) ; node . addLogbook ( startTime , endTime , elapsedTime , getContentResolver ( ) ) ; } private void endTimeclock ( ) { TimeclockService . getInstance ( ) . cancelNotification ( ) ; finish ( ) ; } private View . OnClickListener cancelListener =", "gt": "new View . OnClickListener ( )", "prediction": "( ) ;\n", "label": 0}
{"id": 8944, "input": "<s> package org . eclipse . jface . resource ; import java . util . ArrayList ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . eclipse . core . runtime . Assert ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . graphics . Rectangle ; public class StringConverter { private static final String REGULAR = \"regular\" ; private static final String BOLD = \"bold\" ; private static final String ITALIC = \"italic\" ; private static final String BOLD_ITALIC = \"bold italic\" ; private static final char SEPARATOR = '-' ; private static final String FONT_SEPARATOR = \";\" ; private StringConverter ( ) { } public static String [ ] asArray ( String value ) throws DataFormatException { ArrayList list = new ArrayList ( ) ; StringTokenizer stok = new StringTokenizer ( value ) ; while ( stok . hasMoreTokens ( ) ) { list . add ( stok . nextToken ( ) ) ; } String result [ ] = new String [ list . size ( ) ] ; list . toArray ( result ) ; return result ; } public static String [ ] asArray ( String value , String [ ] dflt ) { try { return asArray ( value ) ; } catch ( DataFormatException e ) { return dflt ; } } public static boolean asBoolean ( String value ) throws DataFormatException { String v = value . toLowerCase ( ) ; if ( v . equals ( \"t\" ) || v . equals ( \"true\" ) ) { return true ; } if ( value . equals ( \"f\" ) || v . equals ( \"false\" ) ) { return false ; } throw new DataFormatException ( \"Value \" + value + \"doesn't represent a boolean\" ) ; } public static boolean asBoolean ( String value , boolean dflt ) { try { return asBoolean ( value ) ; } catch ( DataFormatException e ) { return dflt ; } } public static double asDouble ( String value ) throws DataFormatException { try { return ( Double . valueOf ( value ) ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { throw new DataFormatException ( e . getMessage ( ) ) ; } } public static double asDouble ( String value , double dflt ) { try { return asDouble ( value ) ; } catch ( DataFormatException e ) { return dflt ; } } public static float asFloat ( String value ) throws DataFormatException { try { return ( Float . valueOf ( value ) ) . floatValue ( ) ; } catch ( NumberFormatException e ) { throw new DataFormatException ( e . getMessage ( ) ) ; } } public static float asFloat ( String value , float dflt ) { try { return asFloat ( value ) ; } catch ( DataFormatException e ) { return dflt ; } } public static FontData asFontData ( String value ) throws DataFormatException { if ( value == null ) { throw new DataFormatException ( \"Null doesn't represent a valid font data\" ) ; } String name = null ; int height = 0 ; int style = 0 ; try { int length = value . length ( ) ; int heightIndex = value . lastIndexOf ( SEPARATOR ) ; if ( heightIndex == - 1 ) { throw new DataFormatException ( \"No correct font data format \\\"\" + value + \"\\\"\" ) ; } height = StringConverter . asInt ( value . substring ( heightIndex + 1 , length ) ) ; int faceIndex = value . lastIndexOf ( SEPARATOR , heightIndex - 1 ) ; if ( faceIndex == - 1 ) { throw new DataFormatException ( \"No correct font data format \\\"\" + value + \"\\\"\" ) ; } String s = value . substring ( faceIndex + 1 , heightIndex ) ; if ( BOLD_ITALIC . equals ( s ) ) { style = SWT . BOLD | SWT . ITALIC ; } else if ( BOLD . equals ( s ) ) { style = SWT . BOLD ; } else if ( ITALIC . equals ( s ) ) { style = SWT . ITALIC ; } else if ( REGULAR . equals ( s ) ) { style = SWT . NORMAL ; } else { throw new DataFormatException ( \"Unknown face name \\\"\" + s + \"\\\"\" ) ; } name = value . substring ( 0 , faceIndex ) ; } catch ( NoSuchElementException e ) { throw new DataFormatException ( e . getMessage ( ) ) ; } return new FontData ( name , height , style ) ; } private static String [ ] getArrayFromList ( String prop , String separator ) { if ( prop == null || prop . trim ( ) . equals ( \"\" ) ) { return", "gt": "new String [ 0 ] ;", "prediction": ";\n", "label": 1}
{"id": 1649, "input": "<s> class AnonInnerException_2 { boolean done = true ; void foo ( ) throws Exception { AnonInnerExceptionAux y = new AnonInnerExceptionAux ( ) { { if ( done ) throw new java", "gt": ". io . IOException ( ) ;", "prediction": ";\n", "label": 0}
{"id": 8946, "input": "<s> package org . fuzzydb . util ; import junit . framework . Assert ; import org . fuzzydb . util . ScreenNameValidator ; import org . junit . Test ; public class TestScreenNameValidator { ScreenNameValidator validator = new ScreenNameValidator ( ) ; @ Test public void testSimpleNames ( ) { Assert . assertTrue ( validator . checkName ( \"Mary\" ) . equals ( \"Mary\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Jane\" ) . equals ( \"Jane\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Liz\" ) . equals ( \"Liz\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Sharon\" ) . equals ( \"Sharon\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Victor\" ) . equals ( \"Victor\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Adrian\" ) . equals ( \"Adrian\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Mohammed\" ) . equals ( \"Mohammed\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Joe\" ) . equals ( \"Joe\" ) ) ; } @ Test public void testSimpleNamesCaseCorrection ( ) { Assert . assertTrue ( validator . checkName ( \"mary\" ) . equals ( \"Mary\" ) ) ; Assert . assertTrue ( validator . checkName ( \"JANE\" ) . equals ( \"Jane\" ) ) ; Assert . assertTrue ( validator . checkName ( \"lIZ\" ) . equals ( \"Liz\" ) ) ; Assert . assertTrue ( validator . checkName ( \"ShArOn\" ) . equals ( \"Sharon\" ) ) ; Assert . assertTrue ( validator . checkName ( \"vICTOR\" ) . equals ( \"Victor\" ) ) ; Assert . assertTrue ( validator . checkName ( \"adrian\" ) . equals ( \"Adrian\" ) ) ; Assert . assertTrue ( validator . checkName ( \"mOhAmMeD\" ) . equals ( \"Mohammed\" ) ) ; Assert . assertTrue ( validator . checkName ( \"JOE\" ) . equals ( \"Joe\" ) ) ; } @ Test public void testSimpleNamesSexed ( ) { Assert . assertTrue ( validator . checkName ( \"Mary\" , false ) . equals ( \"Mary\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Jane\" , false ) . equals ( \"Jane\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Liz\" , false ) . equals ( \"Liz\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Sharon\" , false ) . equals ( \"Sharon\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Victor\" , true ) . equals ( \"Victor\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Adrian\" , true ) . equals ( \"Adrian\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Mohammed\" , true ) . equals ( \"Mohammed\" ) ) ; Assert . assertTrue ( validator . checkName ( \"Joe\" , true ) . equals ( \"Joe\" ) ) ; } @ Test public void testSimpleNamesCaseCorrectionSexed ( ) { Assert . assertTrue ( validator . checkName ( \"mary\" , false ) . equals ( \"Mary\" ) ) ; Assert . assertTrue ( validator . checkName ( \"JANE\" , false ) . equals ( \"Jane\" ) ) ; Assert . assertTrue ( validator . checkName ( \"lIZ\" , false ) . equals ( \"Liz\" ) ) ; Assert . assertTrue ( validator . checkName ( \"ShArOn\" , false ) . equals ( \"Sharon\" ) ) ; Assert . assertTrue ( validator . checkName ( \"vICTOR\" , true ) . equals ( \"Victor\" ) ) ; Assert . assertTrue ( validator . checkName ( \"adrian\" , true ) . equals ( \"Adrian\" ) ) ; Assert . assertTrue ( validator . checkName ( \"mOhAmMeD\" , true ) . equals ( \"Mohammed\" ) ) ; Assert . assertTrue ( validator . checkName ( \"JOE\" , true ) . equals ( \"Joe\" ) ) ; } @ Test public void testBogusNames ( ) { Assert . assertNull ( validator . checkName ( \"Bazza\" ) ) ; Assert . assertNull ( validator . checkName ( \"BadNurse\" ) ) ; Assert . assertNull ( validator . checkName ( \"randyrod\" ) ) ; Assert . assertNull ( validator . checkName ( \"asdfghjk\" ) ) ; } @ Test public void testBogusNamesSexed ( ) { Assert . assertNull ( validator . checkName ( \"Bazza\" , true ) ) ; Assert . assertNull ( validator . checkName ( \"BadNurse\" , false ) ) ; Assert . assertNull ( validator . checkName ( \"randyrod\" , true ) ) ; Assert . assertNull ( validator . checkName ( \"asdfghjk\" , false ) ) ; } @ Test public void testCrossedSex ( ) { Assert . assertNull ( validator . checkName ( \"Mary\" , true ) ) ; Assert . assertNull ( validator . checkName ( \"Victor\" , false ) ) ; Assert . assertNull ( validator . checkName ( \"WENDY\"", "gt": ", true ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1774, "input": "<s> package com . example . tutorial . jobflow ; import com . example . tutorial . modelgen . table . model . OrderDetail ; public class OrderDetailToDb extends DefaultDbExporterDescription {", "gt": "@ Override public Class < ? > getModelType ( )", "prediction": "( )\n", "label": 0}
{"id": 9008, "input": "<s> package monbulk . shared . Form ; import monbulk . shared . Form . iFormField . iFormFieldValidation ; public class IntegerValidation implements iFormFieldValidation { private String InvalidReason ; private String FieldName ; public IntegerValidation ( String fName ) { FieldName = fName ; } @ Override public boolean isValueValid ( String value ) { try { Integer . parseInt ( value ) ; return true ; } catch ( NumberFormatException ex ) { InvalidReason", "gt": "= this . FieldName + \": Not a valid number\" ;", "prediction": ";\n", "label": 1}
{"id": 1832, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . util ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . Shape ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . PrecisionPoint ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . swt . graphics . Color ; public class Sector extends Shape { private boolean drawSymmetry = false ; private Rectangle box ; private PrecisionPoint centre ; private double [ ] radius ; private double [ ] angle ; private double [ ] symAngle ; public Sector ( ) { this ( 0 , 0 , 100 , 200 , 0 , 360 ) ; } public Sector ( double cx , double cy , double inner , double outer , double start , double end ) { centre = new PrecisionPoint ( cx , cy ) ; radius = new double [ ] { inner , outer } ; angle = new double [ ] { start , end } ; calcBox ( ) ; } @ Override public void setLocation ( Point p ) { centre . setPreciseX ( p . preciseX ( ) - radius [ 1 ] ) ; centre . setPreciseY ( p . preciseY ( ) - radius [ 1 ] ) ; calcBox ( ) ; } public void setCentre ( double cx , double cy ) { centre . setPreciseX ( cx ) ; centre . setPreciseY ( cy ) ; calcBox ( ) ; } public void setRadii ( double inner , double outer ) { radius [ 0 ] = inner ; radius [ 1 ] = outer ; calcBox ( ) ; } public void setAnglesDegrees ( double start , double end ) { angle [ 0 ] = start ; angle [ 1 ] = end ; calcBox ( ) ; } public void setSymmetryAnglesDegrees ( double start , double end ) { if ( symAngle == null ) symAngle = new double [ 2 ] ; symAngle [ 0 ] = start ; symAngle [ 1 ] = end ; calcBox ( ) ; } public PrecisionPoint getCentre ( ) { return centre ; } public double [ ] getRadii ( ) { return radius ; } public double [ ] getAnglesDegrees ( ) { return angle ; } private void calcBox ( ) { int l = ( int ) ( 2 * radius [ 1 ] + 1 ) ; box = new Rectangle ( ( int ) ( centre . preciseX ( ) - radius [ 1 ] ) , ( int ) ( centre . preciseY ( ) - radius [ 1 ] ) , l , l ) ; setBounds ( box ) ; } @ Override public boolean containsPoint ( int x , int y ) { if ( ! super . containsPoint ( x , y ) ) return false ; double px = x - centre . preciseX ( ) ; double py = centre . preciseY ( ) - y ; double r = Math . hypot ( px , py ) ; if ( r < radius [ 0 ] || r > radius [ 1 ] ) return false ; double a = Math . toDegrees ( Math . atan2 ( py , px ) ) ; if ( angle [ 0 ] > 0 ) { if ( a < 0 ) a += 360 ; } else { if ( a < angle [ 0 ] ) a += 360 ; } return a >= angle [ 0 ] && a <= angle [ 1 ] ; } @ Override protected void fillShape ( Graphics graphics ) { fillSector ( graphics , radius , angle ) ; if ( isDrawSymmetry ( ) && symAngle != null )", "gt": "fillSector ( graphics , radius , symAngle ) ;", "prediction": "\n", "label": 0}
{"id": 9020, "input": "<s> package org . nuxeo . webengine . blogs . adapters ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import org . nuxeo . ecm . webengine . WebException ; import org . nuxeo . ecm . webengine . model . WebAdapter ; import org . nuxeo . webengine . sites . PerspectiveAdapter ; @ WebAdapter ( name = \"perspective\" , type = \"BlogPerspectiveAdapter\" , targetType = \"Document\" ) @", "gt": "Produces ( \"text/html; charset=UTF-8\" ) public class BlogPerspectiveAdapter extends PerspectiveAdapter", "prediction": ";\n", "label": 1}
{"id": 6687, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . List ; import org . gk . ui . client . com . form . gkComboBox ; import org . gk . ui . client . com . grid . gkGridIC ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . google . gwt . core . client . Scheduler ; import com . google . gwt . core . client . Scheduler . ScheduledCommand ; public class ListAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof gkComboBox ) { final gkComboBox cb = ( gkComboBox ) com ; if ( value instanceof List ) { cb . getStore ( ) . removeAll ( ) ; cb . getStore ( ) . add ( ( List ) value ) ; cb . getPropertyEditor ( ) . setList ( ( List ) value ) ; if ( cb . isTriggerExpand ( ) ) { Scheduler . get ( ) . scheduleDeferred ( new ScheduledCommand ( ) { @ Override public void execute ( ) { if ( ! cb . isExpanded ( ) ) { cb . expand ( ) ; } } } ) ; } } } else if ( com instanceof gkGridIC ) { ( ( gkGridIC ) com ) . setInfo ( value ) ; } } @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof ComboBox ) { ComboBox cb = ( ComboBox ) com ; value", "gt": "= cb . getStore ( ) . getModels ( ) ;", "prediction": ";\n", "label": 0}
{"id": 9025, "input": "<s> package io . beancounter . usermanager . services . auth ; import io . beancounter . commons . model . auth . AuthHandler ; import io . beancounter . commons . model . Service ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class AbstractServiceAuthorizationManager implements ServiceAuthorizationManager { protected Map < Service , AuthHandler > handlers = new HashMap < Service , AuthHandler > ( ) ; public void addHandler ( Service service , AuthHandler handler ) throws ServiceAuthorizationManagerException { handlers . put ( service , handler ) ; } public AuthHandler getHandler ( String service ) throws ServiceAuthorizationManagerException { for ( Service s : handlers . keySet ( ) ) { if ( s . getName ( ) . equals ( service ) ) { return handlers . get ( s ) ; } } throw new ServiceAuthorizationManagerException ( \"service '\" + service + \"' not found\" ) ; } public List < Service > getServices ( ) throws ServiceAuthorizationManagerException { return new ArrayList < Service > ( handlers . keySet ( ) ) ; } public", "gt": "Service getService ( String serviceName ) throws ServiceAuthorizationManagerException", "prediction": "}\n", "label": 1}
{"id": 6847, "input": "<s> package com . toedter . gwt . demo . contacts . client . ui ; import java . util . List ; import com . google . gwt . cell . client . AbstractCell ; import com . google . gwt . safehtml . shared . SafeHtmlBuilder ; import com . google . gwt . user . cellview . client . CellList ; import com . google . gwt . user . cellview . client . HasKeyboardSelectionPolicy . KeyboardSelectionPolicy ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . view . client . SelectionChangeEvent ; import com . google . gwt . view . client . SingleSelectionModel ; import com . toedter . gwt . demo . contacts . shared . Contact ; class ContactCell extends AbstractCell < Contact > { @ Override public void render ( Context context , Contact value , SafeHtmlBuilder sb ) { if ( value != null ) { sb . appendEscaped ( value . getFirstName ( ) + \" \" + value . getLastName ( ) ) ; } } } public class ContactListView3 extends Composite implements IContactListView { private final CellList < Contact > cellList ; private Presenter presenter ; public ContactListView3 ( ) { ContactCell contactCell = new ContactCell ( ) ; cellList", "gt": "= new CellList < Contact > ( contactCell ) ;", "prediction": ";\n", "label": 0}
{"id": 9056, "input": "<s> package org . eclipse . ui . internal . presentations ; import java . util . ArrayList ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . TabFolder ; import org . eclipse . swt . widgets . TabItem ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . presentations . IStackPresentationSite ; import org . eclipse . ui . presentations . StackDropResult ; import org . eclipse . ui . presentations . StackPresentation ; public class NativeStackPresentation extends StackPresentation { private TabFolder tabFolder ; private IPresentablePart current ; private MenuManager systemMenuManager = new MenuManager ( ) ; private static int tabPos = PlatformUI . getPreferenceStore ( ) . getInt ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION ) ; private final static String TAB_DATA = NativeStackPresentation . class . getName ( ) + \".partId\" ; private MouseListener mouseListener = new MouseAdapter ( ) { public void mouseDown ( MouseEvent e ) { if ( current != null ) { current . setFocus ( ) ; } } } ; private Listener menuListener = new Listener ( ) { public void handleEvent ( Event event ) { Point pos = new Point ( event . x , event . y ) ; IPresentablePart part = null ; showPaneMenu ( part , pos ) ; } } ; private Listener selectionListener = new Listener ( ) { public void handleEvent ( Event e ) { IPresentablePart item = getPartForTab ( ( TabItem ) e . item ) ; if ( item != null ) { getSite ( ) . selectPart ( item ) ; } } } ; private Listener resizeListener = new Listener ( ) { public void handleEvent ( Event e ) { setControlSize ( ) ; } } ; private IPropertyListener childPropertyChangeListener = new IPropertyListener ( ) { public void propertyChanged ( Object source , int property ) { if ( isDisposed ( ) ) { return ; } if ( source instanceof IPresentablePart ) { IPresentablePart part = ( IPresentablePart ) source ; childPropertyChanged ( part , property ) ; } } } ; private DisposeListener tabDisposeListener = new DisposeListener ( ) { public void widgetDisposed ( DisposeEvent e ) { if ( e . widget instanceof TabItem ) { TabItem item = ( TabItem ) e . widget ; IPresentablePart part = getPartForTab ( item ) ; part . removePropertyListener ( childPropertyChangeListener ) ; } } } ; public NativeStackPresentation ( Composite parent , IStackPresentationSite stackSite ) { super ( stackSite ) ; tabFolder = new TabFolder ( parent , tabPos ) ; tabFolder . addListener ( SWT . Selection , selectionListener ) ; tabFolder . addListener ( SWT . Resize , resizeListener ) ; tabFolder . addMouseListener ( mouseListener ) ; tabFolder . addListener ( SWT . MenuDetect , menuListener ) ; } private final int indexOf ( IPresentablePart part ) { if ( part == null ) { return tabFolder . getItemCount ( ) ; } TabItem [ ] items = tabFolder . getItems ( ) ; for ( int idx = 0 ; idx < items . length ; idx ++ ) { IPresentablePart tabPart = getPartForTab ( items [ idx ] ) ; if ( part == tabPart ) { return idx ; } } return items . length ; } protected final TabItem getTab ( IPresentablePart part ) { TabItem [ ] items = tabFolder . getItems ( ) ; int idx = indexOf ( part ) ; if ( idx < items . length ) { return items [ idx ] ; } return null ; } protected void childPropertyChanged ( IPresentablePart part , int property ) { TabItem tab = getTab ( part ) ; initTab ( tab , part ) ; } protected final IPresentablePart getPartForTab ( TabItem item ) { IPresentablePart part = ( IPresentablePart ) item . getData ( TAB_DATA ) ; return part ; } protected TabFolder getTabFolder ( ) { return tabFolder ; } public boolean isDisposed ( ) { return tabFolder == null || tabFolder . isDisposed ( ) ; } private void setControlSize ( ) { if ( current == null || tabFolder == null ) { return ; } current . setBounds ( calculatePageBounds ( tabFolder ) ) ; } public static Rectangle calculatePageBounds ( TabFolder folder ) { if ( folder == null ) { return new Rectangle ( 0 , 0", "gt": ", 0 , 0 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 203, "input": "<s> class X { void m ( ) { } void m2 ( ) { System . err", "gt": ". println ( m ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 9070, "input": "<s> package org . eclipse . swt . dnd ; import org . eclipse . swt . * ; import org . eclipse . swt . widgets . * ; public class DragSourceEffect extends DragSourceAdapter { Control control = null ; public DragSourceEffect ( Control control ) { if ( control ==", "gt": "null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ;", "prediction": ")\n", "label": 1}
{"id": 2483, "input": "<s> package ar . com . fdvs . dj . core . registration ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRField ; import net . sf . jasperreports . engine . design . JRDesignField ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignParameter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . domain . ColumnProperty ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . entities . DJGroupVariableDef ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . ExpressionColumn ; import ar . com . fdvs . dj . domain . entities . columns . PercentageColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . util . ExpressionUtils ; import ar . com . fdvs . dj . util . LayoutUtils ; public class ColumnRegistrationManager extends AbstractEntityRegistrationManager { private static final String FIELD_ALREADY_REGISTERED = \"The field has already been registered\" ; private static final Log log = LogFactory . getLog ( ColumnRegistrationManager . class ) ; private int colCounter = 0 ; private static final String COLUMN_NAME_PREFIX = \"COLUMN_\" ; public ColumnRegistrationManager ( DynamicJasperDesign jd , DynamicReport dr , LayoutManager layoutManager ) { super ( jd , dr , layoutManager ) ; } protected void registerEntity ( Entity entity ) { AbstractColumn column = ( AbstractColumn ) entity ; if ( column . getName ( ) == null ) { column . setName ( COLUMN_NAME_PREFIX + colCounter ++ ) ; } if ( column . getConditionalStyles ( ) != null && ! column . getConditionalStyles ( ) . isEmpty ( ) ) { ConditionalStylesRegistrationManager conditionalStylesRm = new ConditionalStylesRegistrationManager ( getDjd ( ) , getDynamicReport ( ) , column . getName ( ) , getLayoutManager ( ) ) ; conditionalStylesRm . registerEntities ( column . getConditionalStyles ( ) ) ; } if ( column . getTextFormatter ( ) != null ) { JRDesignParameter parameter = new JRDesignParameter ( ) ; parameter . setName ( ExpressionUtils . createParameterName ( \"formatter_for_\" + column . getName ( ) , column . getTextFormatter ( ) ) ) ; parameter . setValueClassName ( Object . class . getName ( ) ) ; log . debug ( \"registering text formatter: \" + parameter", "gt": ". getName ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9079, "input": "<s> package org . eclipse . ui . internal . misc ; import java . util . Vector ; public class StringMatcher { protected String fPattern ; protected int fLength ; protected boolean fIgnoreWildCards ; protected boolean fIgnoreCase ; protected boolean fHasLeadingStar ; protected boolean fHasTrailingStar ; protected String fSegments [ ] ; protected int fBound = 0 ; protected static final char fSingleWildCard = '\u0000' ; public static class Position { int start ; int end ; public Position ( int start , int end ) { this . start = start ; this . end = end ; } public int getStart ( ) { return start ; } public int getEnd ( ) { return end ; } } public StringMatcher ( String pattern , boolean ignoreCase , boolean ignoreWildCards ) { if ( pattern == null ) { throw new IllegalArgumentException ( ) ; } fIgnoreCase = ignoreCase ; fIgnoreWildCards = ignoreWildCards ; fPattern = pattern ; fLength = pattern . length ( ) ; if ( fIgnoreWildCards ) { parseNoWildCards ( ) ; } else { parseWildCards ( ) ; } } public StringMatcher . Position find ( String text , int start , int end ) { if ( text == null ) { throw new IllegalArgumentException ( ) ; } int tlen = text . length ( ) ; if ( start < 0 ) { start = 0 ; } if ( end > tlen ) { end = tlen ; } if ( end < 0 || start >= end ) { return null ; } if ( fLength == 0 ) { return new Position ( start , start ) ; } if ( fIgnoreWildCards ) { int x = posIn ( text , start , end ) ; if ( x < 0 ) { return null ; } return new Position ( x , x + fLength ) ; } int segCount = fSegments . length ; if ( segCount == 0 ) { return new Position ( start , end ) ; } int curPos = start ; int matchStart = - 1 ; int i ; for ( i = 0 ; i < segCount && curPos < end ; ++ i ) { String current = fSegments [ i ] ; int nextMatch = regExpPosIn ( text , curPos , end , current ) ; if ( nextMatch < 0 ) { return null ; } if ( i == 0 ) { matchStart = nextMatch ; } curPos = nextMatch + current . length ( ) ; } if ( i < segCount ) { return null ; } return new Position ( matchStart , curPos ) ; } public boolean match ( String text ) { if ( text == null ) { return false ; } return match ( text , 0 , text . length ( ) ) ; } public boolean match ( String text , int start , int end ) { if ( null == text ) { throw new IllegalArgumentException ( ) ; } if ( start > end ) { return false ; } if ( fIgnoreWildCards ) { return ( end - start == fLength ) && fPattern . regionMatches ( fIgnoreCase , 0 , text , start , fLength ) ; } int segCount = fSegments . length ; if ( segCount == 0 && ( fHasLeadingStar || fHasTrailingStar ) ) { return true ; } if ( start == end ) { return fLength == 0 ; } if ( fLength == 0 ) { return start == end ; } int tlen = text . length ( ) ; if ( start < 0 ) { start = 0 ; } if ( end > tlen ) { end = tlen ; } int tCurPos = start ; int bound = end - fBound ; if ( bound < 0 ) { return false ; } int i = 0 ; String current = fSegments [ i ] ; int segLength = current . length ( ) ; if ( ! fHasLeadingStar ) { if ( ! regExpRegionMatches ( text , start , current , 0 , segLength ) ) { return false ; } else { ++ i ; tCurPos = tCurPos + segLength ; } } if ( ( fSegments . length == 1 ) && ( ! fHasLeadingStar ) && ( ! fHasTrailingStar ) ) { return tCurPos == end ; } while ( i < segCount ) { current = fSegments [ i ] ; int currentMatch ; int k = current . indexOf ( fSingleWildCard ) ; if ( k < 0 ) { currentMatch = textPosIn ( text , tCurPos , end , current ) ; if ( currentMatch < 0 ) { return false ; } } else { currentMatch = regExpPosIn ( text , tCurPos , end , current ) ; if ( currentMatch < 0 ) { return false ; } } tCurPos = currentMatch + current . length ( ) ; i ++ ; } if ( ! fHasTrailingStar && tCurPos != end ) { int clen = current . length ( ) ; return regExpRegionMatches ( text , end - clen , current , 0 , clen ) ; } return i == segCount ; } private void parseNoWildCards ( ) { fSegments = new String [ 1 ] ; fSegments [ 0 ] = fPattern ; fBound = fLength ; } private void parseWildCards ( ) { if ( fPattern . startsWith ( \"*\" ) ) { fHasLeadingStar = true ; } if ( fPattern . endsWith ( \"*\" ) ) { if ( fLength > 1 && fPattern . charAt ( fLength - 2 ) != '\\\\' ) { fHasTrailingStar = true ; } } Vector temp = new Vector ( ) ; int pos = 0 ; StringBuffer buf = new StringBuffer ( ) ; while ( pos < fLength ) { char c = fPattern . charAt ( pos ++ ) ; switch ( c ) { case '\\\\' : if ( pos >= fLength ) { buf . append ( c ) ; } else { char next = fPattern . charAt ( pos ++ ) ; if ( next == '*' || next == '?' || next == '\\\\' ) { buf . append ( next ) ; } else { buf . append ( c ) ; buf . append ( next ) ; } } break ; case '*' : if ( buf . length ( ) > 0 ) { temp . addElement ( buf . toString ( ) ) ; fBound", "gt": "+= buf . length ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4651, "input": "<s> package gui ; import javax . swing . JPanel ; import java . awt . GridLayout ; import javax . swing . JLabel ; import java . awt . Font ; import java . util . ArrayList ; import javax . swing . SwingConstants ; import model . Book ; import controllers . Controller ; public class CheckoutVerifyCartContentsPanel extends JPanel { private static final long serialVersionUID = 1995910743393899639L ; public CheckoutVerifyCartContentsPanel ( ) { setLayout ( new GridLayout ( 0 , 3 ) ) ; JLabel lblNewLabel = new JLabel ( \"Title\" ) ; lblNewLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel . setFont ( new Font ( \"Times New Roman\" , Font . BOLD , 14 ) ) ; add ( lblNewLabel ) ; JLabel lblNewLabel_1 = new JLabel ( \"Author\" ) ; lblNewLabel_1 . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel_1 . setFont ( new Font ( \"Times New Roman\" , Font . PLAIN , 14 ) ) ; add ( lblNewLabel_1 ) ; JLabel lblNewLabel_2 = new JLabel ( \"Price ($)\" ) ; lblNewLabel_2 . setHorizontalAlignment ( SwingConstants . CENTER ) ; lblNewLabel_2 . setFont ( new Font ( \"Times New Roman\" , Font . PLAIN , 14 ) ) ; add ( lblNewLabel_2 ) ; ArrayList < Book", "gt": "> books = null ;", "prediction": ";\n", "label": 0}
{"id": 9083, "input": "<s> package org . powerbot . game . api . wrappers . map ; import java . util . Arrays ; import java . util . EnumSet ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . Calculations ; import org . powerbot . game . api . methods . Walking ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . wrappers . Tile ; public class TilePath extends Path { protected Tile [ ] tiles ; protected Tile [ ] orig ; private boolean end ; public TilePath ( final Tile [ ] tiles ) { orig = tiles ; this . tiles = Arrays . copyOf ( tiles , tiles . length ) ; } @ Override public boolean traverse ( final EnumSet < TraversalOption > options ) { final Tile next = getNext ( ) ; if ( next == null ) { return false ; } if ( next . equals ( getEnd ( ) ) ) { if ( Calculations . distanceTo ( next ) <= 1 || end && ( ! Players . getLocal ( ) . isMoving ( ) || Calculations . distanceTo ( next ) < 3 ) ) { return false ; } end = true ; } else { end = false ; } if ( options != null && options . contains ( TraversalOption . HANDLE_RUN ) && ! Walking . isRunEnabled ( ) && Walking . getEnergy ( ) > 50 ) { Walking . setRun ( true ) ; Task . sleep ( 300 ) ; } if ( options != null && options . contains ( TraversalOption . SPACE_ACTIONS ) ) { final Tile dest = Walking . getDestination ( ) ; if ( dest . getX ( ) != - 1 && Players . getLocal ( ) . isMoving ( ) && Calculations . distanceTo ( dest ) > 5 && Calculations . distance ( next , dest ) < 7 ) { return true ; } } return Walking . walk ( next ) ; } @ Override public boolean validate ( ) { return tiles . length > 0 && getNext ( ) != null && Calculations . distanceTo ( getEnd ( ) ) > Math . sqrt ( 2 ) ; } @ Override public Tile getNext ( ) { final Tile dest = Walking . getDestination ( ) ; for ( int i = tiles . length - 1 ; i >= 0 ; -- i ) { if ( tiles [ i ] . isOnMap ( ) && ( tiles [ i ] . canReach ( ) || ( i != 0 && ( dest . getX ( ) != - 1 ? Calculations . distance ( dest , tiles [ i - 1 ] ) < 3 : Calculations . distanceTo ( tiles [ i - 1 ] ) < 7 ) ) ) ) { return tiles [ i ] ; } } return null ; } @ Override public Tile getStart ( ) { return tiles [ 0 ] ; } @ Override public Tile getEnd ( ) { return tiles", "gt": "[ tiles . length - 1 ] ;", "prediction": ";\n", "label": 1}
{"id": 630, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . PurgeReport ; import org . jjflyboy . tjpeditor . project . PurgeReportAttribute ; public class PurgeReportImpl extends ReportAttributeImpl implements PurgeReport { protected static final PurgeReportAttribute LIST_ATTRIBUTE_EDEFAULT = PurgeReportAttribute . COLUMNS ; protected PurgeReportAttribute listAttribute = LIST_ATTRIBUTE_EDEFAULT ; protected PurgeReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getPurgeReport ( ) ; } public PurgeReportAttribute getListAttribute ( ) { return listAttribute ; } public void setListAttribute ( PurgeReportAttribute newListAttribute ) { PurgeReportAttribute oldListAttribute = listAttribute ; listAttribute = newListAttribute == null ? LIST_ATTRIBUTE_EDEFAULT : newListAttribute ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE , oldListAttribute , listAttribute ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE : return getListAttribute ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . PURGE_REPORT__LIST_ATTRIBUTE : setListAttribute ( ( PurgeReportAttribute ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; }", "gt": "@ Override public void eUnset ( int featureID )", "prediction": "}\n", "label": 0}
{"id": 9090, "input": "<s> package org . nuxeo . ecm . platform . publisher . synchonize . server ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentLocation ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . publisher . api . PublicationNode ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocument ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocumentFactory ; import java . util . List ; import java . util . Map ; public abstract class AbstractSynchonizablePublicationTree implements ServerSynchronizablePublicationTree { public String exportPublishedDocumentByPath ( String path ) { return null ; } public List < PublicationNode > listModifiedNodes ( long timeDelta ) { return null ; } public List < PublishedDocument > listModifiedPublishedDocuments ( long timeDelta ) { return null ; } public String getConfigName ( ) { return null ; } public List < PublishedDocument > getExistingPublishedDocument ( DocumentLocation docLoc ) throws ClientException { return null ; } public PublicationNode getNodeByPath ( String path ) throws ClientException { return null ; } public List < PublishedDocument > getPublishedDocumentInNode ( PublicationNode node ) throws ClientException { return null ; } public String getSessionId ( ) { return null ; } public String getTitle ( ) { return null ; } public String getTreeType ( ) { return null ; } public void initTree ( String sid , CoreSession coreSession , Map < String , String > parameters , PublishedDocumentFactory factory , String configName ) throws ClientException { } public PublishedDocument publish ( DocumentModel doc , PublicationNode targetNode ) throws ClientException { return null ; } public PublishedDocument publish ( DocumentModel doc , PublicationNode targetNode , Map < String", "gt": ", String > params ) throws ClientException", "prediction": ") ;\n", "label": 1}
{"id": 9229, "input": "<s> package net . minecraft . src ; import java . util . List ; import java . util . Random ; public abstract class ThxEntityProjectile extends ThxEntity { boolean enteredWater ; boolean launched ; public ThxEntityProjectile ( World world ) { super ( world ) ; helper = createHelper ( ) ; setSize ( .5f , .5f ) ; } public ThxEntityProjectile ( Entity owner , double x , double y , double z , double dx , double dy , double dz , float yaw , float pitch ) { this ( owner . worldObj ) ; this . owner = owner ; setPositionAndRotation ( x , y , z , yaw , pitch ) ; float acceleration = getAcceleration ( ) ; updateRotation ( ) ; updateVectors ( ) ; motionX = fwd . x * acceleration + dx ; motionY = fwd . y * acceleration + dy ; motionZ = fwd . z * acceleration + dz ; isImmuneToFire ( ) ; } public void onUpdate ( ) { super . onUpdate ( ) ; if ( owner == null ) { setDead ( ) ; return ; } if ( ticksExisted > 300 ) { detonate ( ) ; return ; } if ( ! launched ) { launched = true ; onLaunch ( ) ; } createParticles ( ) ; Vec3D posStart = Vec3D . createVector ( posX , posY , posZ ) ; Vec3D posEnd = Vec3D . createVector ( posX + motionX , posY + motionY , posZ + motionZ ) ; MovingObjectPosition movingobjectposition = worldObj . rayTraceBlocks ( posStart , posEnd ) ; if ( movingobjectposition != null ) { posEnd = Vec3D . createVector ( movingobjectposition . hitVec . xCoord , movingobjectposition . hitVec . yCoord , movingobjectposition . hitVec . zCoord ) ; } setPosition ( posEnd . xCoord , posEnd . yCoord , posEnd . zCoord ) ; if ( ! enteredWater && isInWater ( ) ) { enteredWater = true ; motionX *= .7f ; motionY *= .7f ; motionZ *= .7f ; worldObj . playSoundAtEntity ( this , \"random.splash\" , 1f , 1f ) ; for ( int l = 0 ; l < 4 ; l ++ ) { float f3 = 0.25F ; worldObj . spawnParticle ( \"bubble\" , posX - motionX * ( double ) f3 , posY - motionY * ( double ) f3 , posZ - motionZ * ( double ) f3 , motionX , motionY , motionZ ) ; } } Entity entity = null ; double closest = 1.0 ; List list = worldObj . getEntitiesWithinAABBExcludingEntity ( this , boundingBox . expand ( 1.0D , 1.0D , 1.0D ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Entity nextEntity = ( Entity ) list . get ( i ) ; if ( nextEntity == null ) continue ; if ( ! nextEntity . canBeCollidedWith ( ) ) continue ; if ( nextEntity . equals ( owner ) ) continue ; if ( owner == null ) log ( this + \" owner is null\" ) ; if ( owner . equals ( nextEntity . riddenByEntity ) || owner . equals ( nextEntity ) ) { log ( \"skipping self\" ) ; continue ; } float f4 = 0.3F ; AxisAlignedBB axisalignedbb = nextEntity . boundingBox . expand ( f4 , f4 , f4 ) ; MovingObjectPosition movingobjectposition1 = axisalignedbb . calculateIntercept ( posStart , posEnd ) ; if ( movingobjectposition1 == null ) continue ; double distanceToEntity = posStart . distanceTo ( movingobjectposition1 . hitVec ) ; if ( distanceToEntity < closest ) { entity = nextEntity ; closest = distanceToEntity ; } } if ( entity != null ) { movingobjectposition = new MovingObjectPosition ( entity ) ; if ( owner == null || owner . equals ( entity . riddenByEntity ) || owner . equals ( entity ) ) { log ( owner + \" ignoring hit from own rocket\" ) ; } else { strikeEntity ( entity ) ; detonate ( ) ; return ; } } if ( movingobjectposition != null ) { int i = MathHelper . floor_double ( posX ) ; int j = MathHelper . floor_double ( posY - 0.2 - ( double ) yOffset ) ; int k = MathHelper . floor_double ( posZ ) ; int blockId = worldObj . getBlockId ( i , j , k ) ; if ( blockId > 0 ) { for ( int k1 = 0 ; k1 < 4 ; k1 ++ ) { worldObj . spawnParticle ( ( new StringBuilder ( ) ) . append ( \"tilecrack_\" ) . append ( blockId ) . toString ( ) , posX + ( ( double ) rand . nextFloat ( ) - 0.5 ) * ( double ) width , boundingBox . minY + 0.1 , posZ + ( ( double ) rand . nextFloat ( ) - 0.5 ) * ( double ) width , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) ) ; } } else { for ( int k1 = 0 ; k1 < 4 ; k1 ++ ) { worldObj . spawnParticle ( \"snowballpoof\" , posX + ( ( double ) rand . nextFloat ( ) - 0.5 ) , boundingBox . minY + 0.1 , posZ + ( ( double ) rand . nextFloat ( ) - 0.5 ) , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) , 1.0 + ( ( double ) rand . nextFloat ( ) - 0.5 ) ) ; } } detonate ( ) ; return ; } } void doSplashDamage ( double splashSize , int damage ) { List list = worldObj . getEntitiesWithinAABBExcludingEntity ( this , boundingBox . expand ( splashSize , splashSize , splashSize ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Entity entity = ( Entity ) list . get ( i ) ; if ( ! entity . canBeCollidedWith ( ) ) continue ; entity . attackEntityFrom ( new EntityDamageSource (", "gt": "\"projectile splash damage\" , owner ) , damage ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9099, "input": "<s> package org . eclipse . ui . internal . handlers ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . IHandler ; import org . eclipse . core . commands . IHandler2 ; import org . eclipse . core . commands . IHandlerListener ; import org . eclipse . core . commands . IObjectWithState ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . State ; import org . eclipse . core . expressions . EvaluationResult ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . InvalidRegistryObjectException ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . widgets . Event ; import org . eclipse . ui . IActionDelegate ; import org . eclipse . ui . IActionDelegate2 ; import org . eclipse . ui . IActionDelegateWithEvent ; import org . eclipse . ui . IEditorActionDelegate ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . INullSelectionListener ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . ISelectionListener ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . IWorkbenchWindowActionDelegate ; import org . eclipse . ui . internal . WorkbenchPlugin ; public final class ActionDelegateHandlerProxy implements ISelectionListener , ISelectionChangedListener , INullSelectionListener , IHandler2 , IObjectWithState , IPartListener2 { private CommandLegacyActionWrapper action ; private String actionId ; private ParameterizedCommand command ; private ISelection currentSelection ; private IActionDelegate delegate ; private IEditorActionDelegate editorDelegate = null ; private IViewActionDelegate viewDelegate = null ; private IObjectActionDelegate objectDelegate = null ; private IWorkbenchWindowActionDelegate windowDelegate = null ; private IWorkbenchPart currentPart = null ; private String delegateAttributeName ; private IConfigurationElement element ; private final Expression enabledWhenExpression ; private transient ListenerList listenerList = null ; private final String style ; private final String viewId ; private final IWorkbenchWindow window ; public ActionDelegateHandlerProxy ( final IConfigurationElement element , final String delegateAttributeName , final String actionId , final ParameterizedCommand command , final IWorkbenchWindow window , final String style , final Expression enabledWhenExpression , final String viewId ) { if ( element == null ) { throw new NullPointerException ( \"The configuration element backing a handler proxy cannot be null\" ) ; } if ( delegateAttributeName == null ) { throw new NullPointerException ( \"The attribute containing the action delegate must be known\" ) ; } if ( window == null ) { throw new NullPointerException ( \"The workbench window for a delegate must not be null\" ) ; } this . element = element ; this . enabledWhenExpression = enabledWhenExpression ; this . delegateAttributeName = delegateAttributeName ; this . window = window ; this . command = command ; this . actionId = actionId ; this . style = style ; this . viewId = viewId ; } public final void addHandlerListener ( final IHandlerListener handlerListener ) { if ( listenerList == null ) { listenerList = new ListenerList ( ListenerList . IDENTITY ) ; } listenerList . add ( handlerListener ) ; } public void addState ( String id , State state ) { } public final void dispose ( ) { disposeDelegate ( ) ; } private void disposeDelegate ( ) { final IActionDelegate actDel = getDelegate ( ) ; if ( actDel instanceof IWorkbenchWindowActionDelegate ) { final IWorkbenchWindowActionDelegate workbenchWindowDelegate = ( IWorkbenchWindowActionDelegate ) actDel ; workbenchWindowDelegate . dispose ( ) ; } else if ( actDel instanceof IActionDelegate2 ) { final IActionDelegate2 delegate2 = ( IActionDelegate2 ) actDel ; delegate2 . dispose ( ) ; } delegate = null ; editorDelegate = null ; objectDelegate = null ; viewDelegate = null ; windowDelegate = null ; currentSelection = null ; } public final Object execute ( final ExecutionEvent event ) { final IAction action = getAction ( ) ; if ( loadDelegate ( ) && ( action != null ) ) { final Object trigger = event . getTrigger ( ) ; final Object applicationContext = event . getApplicationContext ( ) ; if ( applicationContext instanceof IEvaluationContext ) {", "gt": "final IEvaluationContext context = ( IEvaluationContext ) applicationContext ;", "prediction": "\n", "label": 1}
{"id": 4125, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; class Main2102d { public static void main ( String [ ] args ) throws IOException { int cases = Integer . parseInt ( readLine ( 255 ) ) ; for ( int i = 0 ; i != cases ; i ++ ) { String [ ] line = breakLine ( readLine ( 255 ) ) ; int garrafas = Integer . parseInt ( line [ 0 ] ) ; int deUm = Integer . parseInt ( line [ 1 ] ) ; int deCinco = Integer . parseInt ( line [ 2 ] ) ; int deDez = Integer . parseInt ( line [ 3 ] ) ; int moves = 0 ; System . out . println ( \"--------------\" + garrafas ) ; while ( garrafas > 0 ) { System . out . println ( deDez + \",\" + deCinco + \",\" + deUm ) ; if ( deDez > 0 ) { deDez -- ; deUm += 2 ; moves ++ ; System . out . println ( \"a\" ) ; } else if ( deCinco == 1 ) { deCinco -- ; deUm -= 3 ; moves += 4 ; System . out . println ( \"b\" ) ; } else if ( deCinco >= 1 ) { if ( deCinco == garrafas * 2 ) { deCinco -= 2 * garrafas ; deUm += 3 * garrafas ; moves += 2 * garrafas ; garrafas = 1 ; System . out . println ( \"n\" ) ; } else if ( deCinco >= 3 && deUm < 6 ) { deCinco -= 2 ; deUm += 2 ; moves += 2 ; System . out . println ( \"k\" ) ; } else { if ( garrafas == 1 ) { deCinco -= 2 ; deUm += 3 ; moves += 2 ; System . out . println ( \"c\" ) ; } else if ( deUm >= 6 ) { deCinco -= 2 ; deUm -= 6 ; moves += 8 ; garrafas -- ; System . out . println ( \"d\" ) ; } else { deCinco -= 1 ; deUm -= 3 ; moves += 4 ; System . out . println ( \"e\" ) ; } } } else { deUm -= 8 ; moves += 8 ; System . out . println ( \"8x1\" ) ; } garrafas -- ; } System . out . println ( moves ) ; } } static String [ ] breakLine ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; }", "gt": "static String readLine ( int maxLg ) throws IOException", "prediction": "}\n", "label": 0}
{"id": 9100, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . io . PrintStream ; import java . text . NumberFormat ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map . Entry ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . Similarity ; import org . apache . lucene . search . Weight ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMFile ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . Constants ; final class DocumentsWriter { IndexWriter writer ; Directory directory ; String segment ; private String docStoreSegment ; private int docStoreOffset ; private int nextDocID ; private int numDocsInRAM ; int numDocsInStore ; private final static int MAX_THREAD_STATE = 5 ; private DocumentsWriterThreadState [ ] threadStates = new DocumentsWriterThreadState [ 0 ] ; private final HashMap threadBindings = new HashMap ( ) ; private int pauseThreads ; boolean flushPending ; boolean bufferIsFull ; private boolean aborting ; private DocFieldProcessor docFieldProcessor ; PrintStream infoStream ; int maxFieldLength = IndexWriter . DEFAULT_MAX_FIELD_LENGTH ; Similarity similarity ; List newFiles ; static class DocState { DocumentsWriter docWriter ; Analyzer analyzer ; int maxFieldLength ; PrintStream infoStream ; Similarity similarity ; int docID ; Document doc ; String maxTermPrefix ; boolean allowMinus1Position ; public boolean testPoint ( String name ) { return docWriter . writer . testPoint ( name ) ; } public void clear ( ) { doc = null ; analyzer = null ; } } abstract static class DocWriter { DocWriter next ; int docID ; abstract void finish ( ) throws IOException ; abstract void abort ( ) ; abstract long sizeInBytes ( ) ; void setNext ( DocWriter next ) { this . next = next ; } } PerDocBuffer newPerDocBuffer ( ) { return new PerDocBuffer ( ) ; } class PerDocBuffer extends RAMFile { protected byte [ ] newBuffer ( int size ) { assert size == PER_DOC_BLOCK_SIZE ; return perDocAllocator . getByteBlock ( false ) ; } synchronized void recycle ( ) { if ( buffers . size ( ) > 0 ) { setLength ( 0 ) ; perDocAllocator . recycleByteBlocks ( buffers ) ; buffers . clear ( ) ; sizeInBytes = 0 ; assert numBuffers ( ) == 0 ; } } } abstract static class IndexingChain { abstract DocConsumer getChain ( DocumentsWriter documentsWriter ) ; } static final IndexingChain DefaultIndexingChain = new IndexingChain ( ) { DocConsumer getChain ( DocumentsWriter documentsWriter ) { final TermsHashConsumer termVectorsWriter = new TermVectorsTermsWriter ( documentsWriter ) ; final TermsHashConsumer freqProxWriter = new FreqProxTermsWriter ( ) ; final InvertedDocConsumer termsHash = new TermsHash ( documentsWriter , true , freqProxWriter , new TermsHash ( documentsWriter , false , termVectorsWriter , null ) ) ; final NormsWriter normsWriter = new NormsWriter ( ) ; final DocInverter docInverter = new DocInverter ( termsHash , normsWriter ) ; return new DocFieldProcessor ( documentsWriter , docInverter ) ; } } ; final DocConsumer consumer ; private BufferedDeletes deletesInRAM = new BufferedDeletes ( false ) ; private BufferedDeletes deletesFlushed = new BufferedDeletes ( true ) ; private int maxBufferedDeleteTerms = IndexWriter . DEFAULT_MAX_BUFFERED_DELETE_TERMS ; private long ramBufferSize = ( long ) ( IndexWriter . DEFAULT_RAM_BUFFER_SIZE_MB * 1024 * 1024 ) ; private long waitQueuePauseBytes = ( long ) ( ramBufferSize * 0.1 ) ; private long waitQueueResumeBytes = ( long ) ( ramBufferSize * 0.05 ) ; private long freeTrigger = ( long ) ( IndexWriter . DEFAULT_RAM_BUFFER_SIZE_MB * 1024 * 1024 * 1.05 ) ; private long freeLevel = ( long ) ( IndexWriter . DEFAULT_RAM_BUFFER_SIZE_MB * 1024 * 1024 * 0.95 ) ; private int maxBufferedDocs = IndexWriter . DEFAULT_MAX_BUFFERED_DOCS ; private int flushedDocCount ; synchronized void updateFlushedDocCount ( int n ) { flushedDocCount += n ; } synchronized int getFlushedDocCount ( ) { return flushedDocCount ; } synchronized void setFlushedDocCount ( int n ) { flushedDocCount = n ; } private boolean closed ; DocumentsWriter ( Directory directory , IndexWriter writer , IndexingChain indexingChain ) throws IOException { this . directory = directory ; this . writer = writer ; this . similarity = writer . getSimilarity ( ) ; flushedDocCount = writer . maxDoc ( ) ; consumer = indexingChain . getChain ( this ) ; if ( consumer instanceof DocFieldProcessor ) { docFieldProcessor = ( DocFieldProcessor ) consumer ; } } boolean hasProx ( ) { return ( docFieldProcessor != null ) ? docFieldProcessor . fieldInfos . hasProx ( ) : true ; } synchronized void setInfoStream ( PrintStream infoStream ) { this . infoStream = infoStream ; for ( int i = 0 ; i < threadStates . length ; i ++ ) threadStates [ i ] . docState . infoStream = infoStream ; } synchronized void setMaxFieldLength ( int maxFieldLength ) { this . maxFieldLength = maxFieldLength ; for ( int i = 0 ; i < threadStates . length ; i ++ ) threadStates [ i ] . docState . maxFieldLength = maxFieldLength ; } synchronized void setSimilarity ( Similarity similarity ) { this . similarity = similarity ; for ( int i = 0 ; i < threadStates . length ; i ++ ) threadStates [ i ] . docState . similarity = similarity ; } synchronized void setAllowMinus1Position ( ) { for ( int i = 0 ; i < threadStates . length ; i ++ ) threadStates [ i ] . docState . allowMinus1Position = true ; } synchronized void setRAMBufferSizeMB ( double mb ) { if ( mb == IndexWriter . DISABLE_AUTO_FLUSH ) { ramBufferSize = IndexWriter . DISABLE_AUTO_FLUSH ; waitQueuePauseBytes = 4 * 1024 * 1024 ; waitQueueResumeBytes = 2 * 1024 * 1024 ; } else { ramBufferSize = ( long ) ( mb * 1024 * 1024 ) ;", "gt": "waitQueuePauseBytes = ( long ) ( ramBufferSize * 0.1 ) ;", "prediction": "}\n", "label": 1}
{"id": 5423, "input": "<s> package org . bombusim . lime . data ; import org . bombusim . xmpp . XmppAccount ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; public class AccountDbAdapter { protected final static String DATABASE_TABLE = \"accounts\" ; protected final static String DATABASE_NAME = \"accounts.db\" ; protected final static int DATABASE_VERSION = 3 ; public final static String KEY_ID = \"_id\" ; public final static String KEY_JID = \"jid\" ; public final static String KEY_PASSWORD = \"password\" ; public final static String KEY_PWDSAVED = \"pwdsaved\" ; public final static String KEY_RESOURCE = \"resource\" ; public final static String KEY_HOSTPORT = \"hostport\" ; public final static String KEY_XMPPHOST = \"xmpphost\" ; public final static String KEY_XMPPPORT = \"xmppport\" ; public final static String KEY_SECURITY = \"security\" ; public final static String KEY_PLAINPWD = \"pwdplain\" ; public final static String KEY_ZLIB = \"zlib\" ; public final static String KEY_PRIORITY = \"priority\" ; public final static String KEY_AUTOLOGIN = \"autologin\" ; public final static String KEY_ACTIVE = \"active\" ; private AccountDbHelper dbHelper ; private SQLiteDatabase db ; public AccountDbAdapter ( Context context ) { dbHelper = new AccountDbHelper ( context ) ; } public void open ( ) { try { db = dbHelper . getWritableDatabase ( ) ; } catch ( SQLException ex ) { db = dbHelper . getReadableDatabase ( ) ; } } public void close ( ) { db . close ( ) ; } public long putAccount ( XmppAccount account , long position ) { ContentValues v = new ContentValues ( ) ; v . put ( KEY_JID , account . userJid ) ; v . put ( KEY_PASSWORD , account . password ) ; v . put ( KEY_PWDSAVED , 1 ) ; v . put ( KEY_RESOURCE , account . resource ) ; v . put ( KEY_PRIORITY , account . priority ) ; v . put ( KEY_HOSTPORT , account . specificHostPort ? 1 : 0 ) ; v . put ( KEY_XMPPHOST , account . xmppHost ) ; v . put ( KEY_XMPPPORT , account . xmppPort ) ; v . put ( KEY_SECURITY , account . secureConnection ) ; v . put ( KEY_PLAINPWD , account . enablePlainAuth ) ; v . put ( KEY_ZLIB , account . trafficCompression ) ; v . put ( KEY_AUTOLOGIN , account . autoLogin ? 1 : 0 ) ; v . put ( KEY_ACTIVE , account . active ? 1 : 0 ) ; if ( position < 0 ) { return db . insert ( DATABASE_TABLE , null , v ) ; } else { return db . update ( DATABASE_TABLE , v , KEY_ID + \"=\" + position , null ) ; } } public long removeAccount ( long position ) { return db . delete ( DATABASE_TABLE , KEY_ID + \"=\" + position , null ) ; } public long [ ] getAccountIndexes ( ) { Cursor ind = db . query ( DATABASE_TABLE , new String [ ] { KEY_ID } , null , null , null , null , null ) ; int count = ind . getCount ( ) ; if ( count == 0 || !", "gt": "ind . moveToFirst ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 9102, "input": "<s> package knowevo . myvizster . action ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . EdgeItem ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . NodeItem ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . action . AbstractAction ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Edge ; import edu . berkeley . guir . prefuse . graph . Node ; public class HighlightAction extends AbstractAction { private ArrayList queue = new ArrayList ( ) ; private ArrayList queue2 = new ArrayList ( ) ; private HashSet visited = new HashSet ( ) ; private int hops = 2 ; private boolean showEdges ; private boolean skipFoci ; public HighlightAction ( ) { this ( 2 ) ; } public HighlightAction ( int hops ) { this ( 2 , true , true ) ; } public HighlightAction ( int hops , boolean showEdges , boolean skipFoci ) { this . hops = hops ; this . showEdges = showEdges ; this . skipFoci = skipFoci ; } public void run ( ItemRegistry registry , double frac ) { Node nn = null ; NodeItem n = null ; FocusManager fman = registry . getFocusManager ( ) ; FocusSet highlight = fman . getFocusSet ( Vizster . HIGHLIGHT_KEY ) ; FocusSet mouseover = fman . getFocusSet ( Vizster . MOUSE_KEY ) ; FocusSet search = fman . getFocusSet ( Vizster . SEARCH_KEY ) ; FocusSet fs ; synchronized ( highlight ) { synchronized ( mouseover ) { fs = ( highlight . size ( ) > 0 ? highlight : mouseover ) ; if ( fs . size ( ) > 0 ) { nn = ( Node ) fs . iterator ( ) . next ( ) ; n = registry . getNodeItem ( nn ) ; } } } boolean restore = search == null ; int defaultValue = ( restore || search . size ( ) == 0 ? 0 : - 1 ) ; Iterator iter = registry . getNodeItems ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; item . setHighlighted ( false ) ; VizsterLib . setHighlightValue ( item , defaultValue ) ; } iter = registry . getEdgeItems ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; item . setHighlighted ( false ) ; VizsterLib . setHighlightValue ( item , defaultValue ) ; } iter = registry . getAggregateItems ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; item . setHighlighted ( restore ) ; } if ( restore ) { return ; } else if ( n == null ) { iter = search . iterator ( ) ; while ( iter . hasNext ( ) ) { Node node = ( Node ) iter . next ( ) ; NodeItem nitem = registry . getNodeItem ( node ) ; VizsterLib . setHighlightValue ( nitem , 0 ) ; VisualItem aitem = registry . getAggregateItem ( node ) ; if ( aitem != null ) { aitem . setHighlighted ( true ) ; registry . touch", "gt": "( aitem . getItemClass ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6287, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . AccountReport ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class", "gt": "AccountReportImpl extends PropertyImpl implements AccountReport", "prediction": ";\n", "label": 0}
{"id": 9104, "input": "<s> package org . eclipse . jface . preference ; import java . io . Serializable ; import org . eclipse . jface . util . IPropertyChangeListener ; public interface IPreferenceStore extends Serializable { public static final boolean BOOLEAN_DEFAULT_DEFAULT = false ; public static final double DOUBLE_DEFAULT_DEFAULT = 0.0 ; public static final float FLOAT_DEFAULT_DEFAULT = 0.0f ; public static final int INT_DEFAULT_DEFAULT = 0 ; public static final long LONG_DEFAULT_DEFAULT = 0L ; public static final String STRING_DEFAULT_DEFAULT = \"\" ; public static final String TRUE = \"true\" ; public static final String FALSE = \"false\" ; public void addPropertyChangeListener ( IPropertyChangeListener listener ) ; public boolean contains ( String name ) ; public void firePropertyChangeEvent ( String name , Object oldValue , Object newValue ) ; public boolean getBoolean ( String name ) ; public boolean getDefaultBoolean ( String name ) ; public double getDefaultDouble ( String name ) ; public float getDefaultFloat ( String name ) ; public int getDefaultInt ( String name ) ; public long getDefaultLong ( String name ) ; public String getDefaultString ( String name ) ; public double getDouble ( String name ) ; public float getFloat ( String name ) ; public int getInt ( String name ) ; public long getLong ( String name ) ; public String getString ( String name ) ; public boolean isDefault ( String name ) ; public boolean needsSaving ( ) ; public void putValue ( String name , String value ) ; public void", "gt": "removePropertyChangeListener ( IPropertyChangeListener listener ) ;", "prediction": "( )\n", "label": 1}
{"id": 9668, "input": "<s> package org . dawb . workbench . ui . editors . preference ; import java . text . DecimalFormat ; import org . dawb . common . ui . plot . PlottingFactory ; import org . dawb . common . ui . widgets . LabelFieldEditor ; import org . dawb . workbench . ui . Activator ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . preference . BooleanFieldEditor ; import org . eclipse . jface . preference . ComboFieldEditor ; import org . eclipse . jface . preference . FieldEditorPreferencePage ; import org . eclipse . jface . preference . IntegerFieldEditor ; import org . eclipse . jface . preference . StringFieldEditor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; public class EditorPreferencePage extends FieldEditorPreferencePage implements IWorkbenchPreferencePage { public static final String ID = \"org.edna.workbench.editors.preferencePage\" ; private StringFieldEditor formatFieldEditor ; public EditorPreferencePage ( ) { super ( GRID ) ; setPreferenceStore ( Activator . getDefault ( ) . getPreferenceStore ( ) ) ; setDescription ( \"Preferences for viewing data sets available in nexus and ascii data.\" ) ; } @ Override protected void createFieldEditors ( ) { final String [ ] [ ] namesAndValues = PlottingFactory . getPlottingPreferenceChoices ( ) ; ComboFieldEditor plotChoice = new ComboFieldEditor ( EditorConstants . PLOTTING_SYSTEM_CHOICE , \"Plotting Technology*\" , namesAndValues , getFieldEditorParent ( ) ) ; addField ( plotChoice ) ; new LabelFieldEditor ( \"(* Please close and reopen the part after changing plotting preference.)\\n\\n\" , getFieldEditorParent ( ) ) ; IConfigurationElement [ ] config = Platform . getExtensionRegistry ( ) . getConfigurationElementsFor ( \"uk.ac.diamond.scisoft.analysis.data.set.filter\" ) ; if ( config != null && config . length > 0 ) { final Label sep = new Label ( getFieldEditorParent ( ) , SWT . NONE ) ; sep . setLayoutData ( new GridData ( SWT . FILL , SWT . NONE , true , false , 1 , 5 ) ) ; BooleanFieldEditor showAll = new BooleanFieldEditor ( EditorConstants . IGNORE_DATASET_FILTERS , \"Show all possible data sets\" , getFieldEditorParent ( ) ) ; addField ( showAll ) ; final StringBuilder buf = new StringBuilder ( \"Current data set filters:\\n\" ) ; for ( IConfigurationElement e : config ) { buf . append ( \"\\t-    \" ) ; final String pattern = e . getAttribute ( \"regularExpression\" ) ; buf . append ( pattern ) ; buf . append ( \"\\n\" ) ; } buf . append ( \"\\nData set filters reduce the content available to plot and\\ncompare for simplicity but can be turned off.\\nAll data is shown in the nexus tree, filters are not applied.\" ) ; final Label label = new Label ( getFieldEditorParent ( ) , SWT . WRAP ) ; label . setText ( buf . toString ( ) ) ; label . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , false ) ) ; } BooleanFieldEditor showXY = new BooleanFieldEditor ( EditorConstants . SHOW_XY_COLUMN , \"Show XY column.\" , getFieldEditorParent ( ) ) ; addField ( showXY ) ; BooleanFieldEditor showSize = new BooleanFieldEditor ( EditorConstants . SHOW_DATA_SIZE , \"Show size column.\" , getFieldEditorParent ( ) ) ; addField ( showSize ) ; BooleanFieldEditor showDims = new BooleanFieldEditor ( EditorConstants . SHOW_DIMS , \"Show dimensions column.\" , getFieldEditorParent ( ) ) ; addField ( showDims ) ; BooleanFieldEditor showShape = new BooleanFieldEditor ( EditorConstants . SHOW_SHAPE , \"Show shape column.\" , getFieldEditorParent ( ) ) ; addField ( showShape ) ; BooleanFieldEditor showVarName = new BooleanFieldEditor ( EditorConstants . SHOW_VARNAME , \"Show expression variable name.\" , getFieldEditorParent ( ) ) ; addField ( showVarName ) ; new LabelFieldEditor ( \"\\nEditors with a 'Data' tab, show the data of the current plot.\\nThis option sets the number format for the table and the csv file,", "gt": "if the data is exported.\" , getFieldEditorParent ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9106, "input": "<s> package com . corundumstudio . socketio . handler ; import java . util . Collections ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . ChannelHandler . Sharable ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . ExceptionEvent ; import org . jboss . netty . channel . MessageEvent ; import org . jboss . netty . channel . SimpleChannelUpstreamHandler ; import org . jboss . netty . util . CharsetUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . corundumstudio . socketio . AckRequest ; import com . corundumstudio . socketio . PacketListener ; import com . corundumstudio . socketio . SocketIOClient ; import com . corundumstudio . socketio . messages . PacketsMessage ; import com . corundumstudio . socketio . namespace . Namespace ; import com . corundumstudio . socketio . namespace . NamespacesHub ; import com . corundumstudio . socketio . parser . Decoder ; import com . corundumstudio . socketio . parser . Packet ; @ Sharable public class PacketHandler extends SimpleChannelUpstreamHandler { private final Logger log = LoggerFactory . getLogger ( getClass ( ) ) ; private final PacketListener packetListener ; private final Decoder decoder ; private final NamespacesHub namespacesHub ; public PacketHandler ( PacketListener packetListener , Decoder decoder , NamespacesHub namespacesHub ) { super ( ) ; this . packetListener = packetListener ; this . decoder = decoder ; this . namespacesHub = namespacesHub ; } @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { Object msg = e . getMessage ( ) ; if ( msg instanceof PacketsMessage ) { PacketsMessage message = ( PacketsMessage ) msg ; ChannelBuffer content = message . getContent ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( \"In message: {} sessionId: {}\" , new Object [ ] { content . toString ( CharsetUtil . UTF_8 ) , message . getClient ( ) . getSessionId ( ) } ) ; } while ( content . readable ( ) ) { Packet packet = decoder . decodePackets ( content , message . getClient ( ) . getSessionId ( ) ) ; Namespace ns = namespacesHub . get ( packet . getEndpoint ( ) ) ; SocketIOClient client = message . getClient ( ) . getChildClient ( ns ) ; AckRequest ackSender = new AckRequest ( packet , client ) ; packetListener . onPacket ( packet , client , ackSender ) ; ackSender . sendAckData ( Collections . emptyList ( ) ) ; } } else { ctx . sendUpstream ( e ) ; } } @ Override public void exceptionCaught", "gt": "( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception", "prediction": "( )\n", "label": 1}
{"id": 7536, "input": "<s> package org . ofbiz . product . config ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Enumeration ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . config . ProductConfigWrapper . ConfigItem ; import org . ofbiz . product . config . ProductConfigWrapper . ConfigOption ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . base . util . cache . UtilCache ; public class ProductConfigWorker { public static final String module = ProductConfigWorker . class . getName ( ) ; public static final String resource = \"ProductUiLabels\" ; public static final String SEPARATOR = \"::\" ; private static final UtilCache < String , ProductConfigWrapper > productConfigCache = UtilCache . createUtilCache ( \"product.config\" , true ) ; public static ProductConfigWrapper getProductConfigWrapper ( String productId , String currencyUomId , HttpServletRequest request ) { ProductConfigWrapper configWrapper = null ; String catalogId = CatalogWorker . getCurrentCatalogId ( request ) ; String webSiteId = CatalogWorker . getWebSiteId ( request ) ; String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; GenericValue autoUserLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"autoUserLogin\" ) ; try { String cacheKey = productId + SEPARATOR + productStoreId + SEPARATOR + catalogId + SEPARATOR + webSiteId + SEPARATOR + currencyUomId ; configWrapper = productConfigCache . get ( cacheKey ) ; if ( configWrapper == null ) { configWrapper = new ProductConfigWrapper ( ( Delegator ) request . getAttribute ( \"delegator\" ) , ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) , productId , productStoreId , catalogId , webSiteId , currencyUomId , UtilHttp . getLocale ( request ) , autoUserLogin ) ; configWrapper = productConfigCache . putIfAbsentAndGet ( cacheKey , new ProductConfigWrapper ( configWrapper ) ) ; } else { configWrapper = new ProductConfigWrapper ( configWrapper ) ; } } catch ( ProductConfigWrapperException we ) { configWrapper = null ; } catch ( Exception e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; } return configWrapper ; } public static void fillProductConfigWrapper ( ProductConfigWrapper configWrapper , HttpServletRequest request ) { int numOfQuestions = configWrapper . getQuestions ( ) . size ( ) ; for ( int k = 0 ; k < numOfQuestions ; k ++ ) { String [ ] opts = request . getParameterValues ( Integer . toString ( k ) ) ; if ( opts == null ) { ProductConfigWrapper . ConfigItem question = configWrapper . getQuestions ( ) . get ( k ) ; if ( question . isStandard ( ) ) { int i = 0 ; while ( i <= ( question . getOptions ( ) . size ( ) - 1 ) ) { String comments = request . getParameter ( \"comments_\" + k + \"_\" + i ) ; if ( UtilValidate . isNotEmpty ( comments ) ) { try { configWrapper . setSelected ( k , i , comments ) ; } catch ( Exception e ) { Debug . logWarning ( e . getMessage ( ) , module ) ; } } i ++ ; } } continue ; } for ( String opt : opts ) { int cnt = - 1 ; try { cnt = Integer . parseInt ( opt ) ; String comments = null ; ProductConfigWrapper . ConfigItem question = configWrapper . getQuestions ( ) . get ( k ) ; if ( question . isSingleChoice ( ) ) { comments = request . getParameter ( \"comments_\" + k + \"_\" + \"0\" ) ; } else { comments = request . getParameter ( \"comments_\" + k + \"_\" + cnt ) ; } configWrapper . setSelected ( k , cnt , comments ) ; ProductConfigWrapper . ConfigOption option = configWrapper . getItemOtion ( k , cnt ) ; if ( UtilValidate . isNotEmpty ( option ) && ( option . hasVirtualComponent ( ) ) ) { List < GenericValue > components = option . getComponents ( ) ; int variantIndex = 0 ; for ( int i = 0 ; i < components . size ( ) ; i ++ ) { GenericValue component = components . get ( i ) ; if ( option . isVirtualComponent ( component ) ) { String productParamName = \"add_product_id\" + k + \"_\" + cnt + \"_\" + variantIndex ; String selectedProductId = request . getParameter ( productParamName ) ; if ( UtilValidate . isEmpty ( selectedProductId ) ) { Debug . logWarning ( \"ERROR: Request param [\" + productParamName + \"] not found!\" , module ) ; } else { if ( ProductWorker . isVirtual ( ( Delegator ) request . getAttribute ( \"delegator\" ) , selectedProductId ) ) { if ( \"VV_FEATURETREE\" . equals ( ProductWorker . getProductVirtualVariantMethod ( ( Delegator ) request . getAttribute ( \"delegator\" ) , selectedProductId ) ) ) { List < String > selectedFeatures = FastList . newInstance ( ) ; Enumeration < String > paramNames = UtilGenerics . cast ( request . getParameterNames ( ) ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = paramNames . nextElement ( ) ; if ( paramName . startsWith ( \"FT\" + k + \"_\" + cnt + \"_\" + variantIndex ) ) { selectedFeatures . add ( request . getParameterValues ( paramName ) [ 0 ] ) ; } } if ( UtilValidate . isEmpty ( selectedFeatures ) ) { Debug . logWarning ( \"ERROR: No features selected for productId", "gt": "[\" + selectedProductId + \"]\" , module ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9107, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . preferences . AbstractPreferenceInitializer ; import org . eclipse . core . runtime . preferences . DefaultScope ; import org . eclipse . core . runtime . preferences . IEclipsePreferences ; import org . eclipse . core . runtime . preferences . IScopeContext ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . swt . SWT ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; public class UIPreferenceInitializer extends AbstractPreferenceInitializer { public void initializeDefaultPreferences ( ) { IScopeContext context = new DefaultScope ( ) ; IEclipsePreferences node = context . getNode ( UIPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) ) ; node . put ( IWorkbenchPreferenceConstants . OPEN_NEW_PERSPECTIVE , IWorkbenchPreferenceConstants . OPEN_PERSPECTIVE_REPLACE ) ; node . putBoolean ( IWorkbenchPreferenceConstants . LINK_NAVIGATOR_TO_EDITOR , false ) ; node . put ( IWorkbenchPreferenceConstants . PRESENTATION_FACTORY_ID , IWorkbenchConstants . DEFAULT_PRESENTATION_ID ) ; node . put ( IWorkbenchPreferenceConstants . DOCK_PERSPECTIVE_BAR , IWorkbenchPreferenceConstants . TOP_RIGHT ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_TEXT_ON_PERSPECTIVE_BAR , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_OTHER_IN_PERSPECTIVE_MENU , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_OPEN_ON_PERSPECTIVE_BAR , true ) ; node . put ( IWorkbenchPreferenceConstants . INITIAL_FAST_VIEW_BAR_LOCATION , IWorkbenchPreferenceConstants . BOTTOM ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_INTRO , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_SYSTEM_JOBS , false ) ; node . putInt ( IWorkbenchPreferenceConstants . EDITOR_MINIMUM_CHARACTERS , - 1 ) ; node . putInt ( IWorkbenchPreferenceConstants . VIEW_MINIMUM_CHARACTERS , 1 ) ; node . putBoolean ( IWorkbenchPreferenceConstants . CLOSE_EDITORS_ON_EXIT , false ) ; node . putBoolean ( IWorkbenchPreferenceConstants . USE_WINDOW_WORKING_SET_BY_DEFAULT , false ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_FILTERED_TEXTS , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . PROMPT_WHEN_SAVEABLE_STILL_OPEN , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . ENABLE_NEW_MIN_MAX , false ) ; node . putBoolean ( IWorkbenchPreferenceConstants . DISABLE_NEW_FAST_VIEW , true ) ; node . putBoolean ( IWorkbenchPreferenceConstants . ENABLE_32_STICKY_CLOSE_BEHAVIOR , false ) ; node . putInt ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION , SWT . TOP ) ; node . putInt ( IWorkbenchPreferenceConstants . EDITOR_TAB_POSITION , SWT . TOP ) ; node . putBoolean ( IWorkbenchPreferenceConstants . SHOW_MULTIPLE_EDITOR_TABS , true ) ; migrateInternalPreferences ( ) ; } private void migrateInternalPreferences ( ) { IPreferenceStore internalStore = WorkbenchPlugin . getDefault ( ) . getPreferenceStore ( ) ; IPreferenceStore apiStore = PlatformUI . getPreferenceStore ( ) ; if ( internalStore . contains ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION ) ) { apiStore . setValue ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION , internalStore . getInt ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION ) ) ; internalStore . setToDefault ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION ) ; } if ( internalStore . contains (", "gt": "IWorkbenchPreferenceConstants . EDITOR_TAB_POSITION ) )", "prediction": ") ;\n", "label": 1}
{"id": 9544, "input": "<s> package uk . ac . cam . cl . dtg . android . time . data . handlers ; import java . util . List ; import uk . ac . cam . cl . dtg . android . time . buses . BusStop ; public class StopsSAXHandler extends AbstractStopsSAXHandler < List < BusStop > > { @ Override public List <", "gt": "BusStop > getData ( )", "prediction": "\n", "label": 0}
{"id": 9114, "input": "<s> package scenes . MenuScene . System ; import scenes . GameSystem ; import engine . Input ; public class WeaponState extends EquipmentState { public WeaponState ( GameSystem c ) { super ( c ) ; } @ Override public void handleKeyInput ( int key ) { if ( mode != 0 ) { if ( key == Input . KEY_A ) { if ( player . getWeapon ( ) == player . getWeapons ( ) [ row + col ] ) player . setWeapon ( null ) ; else if ( player . getWeapons ( ) [ row + col ] != null ) player . setWeapon ( player . getWeapons ( ) [ row + col ] ) ; } }", "gt": "super . handleKeyInput ( key ) ;", "prediction": "}\n", "label": 1}
{"id": 3647, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . ShortTimeFormat ; public class ShortTimeFormatImpl extends ProjectAttributeImpl implements ShortTimeFormat { protected static final String SHORT_TIME_FORMAT_EDEFAULT = null ; protected String shortTimeFormat = SHORT_TIME_FORMAT_EDEFAULT ; protected ShortTimeFormatImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getShortTimeFormat ( ) ; } public String getShortTimeFormat ( ) { return shortTimeFormat ; } public void setShortTimeFormat ( String newShortTimeFormat ) { String oldShortTimeFormat = shortTimeFormat ; shortTimeFormat = newShortTimeFormat ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SHORT_TIME_FORMAT__SHORT_TIME_FORMAT , oldShortTimeFormat , shortTimeFormat ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SHORT_TIME_FORMAT__SHORT_TIME_FORMAT : return getShortTimeFormat ( ) ; } return super . eGet (", "gt": "featureID , resolve , coreType ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9121, "input": "<s> package net . claribole . zgrviewer . dot ; import java . util . Vector ; class Record extends CommonNode { Record rootRecord ; Rectangle [ ] rects ; protected SubRecord [ ] subRecords ; public Record ( Object root , String id ) throws Exception { super ( root , id ) ; if ( ! ( this instanceof SubRecord ) ) { this . label = id ; this . rootRecord = this ; } this . getGenericAttributes ( ) ; } private void getAttributes ( Record record ) { if ( this . rects != null && record . rects != null ) if ( this . rects . equals ( record . rects ) ) this . rects = record . rects ; if ( this . isRounded ( ) != record . isRounded ( ) ) this . setRounded ( record . isRounded ( ) ) ; if ( this . fixedsize != record . fixedsize ) this . fixedsize = record . fixedsize ; if ( ! this . group . equals ( record . group ) ) this . group = record . group ; if ( this . height != record . height ) this . height = record . height ; if ( this . layer != null && record . layer != null ) if ( ! this . layer . equals ( record . layer ) ) this . layer = record . layer ; if ( ! this . margin . equals ( record . margin ) ) this . margin = record . margin ; if ( this . pin != record . pin ) this . pin = record . pin ; if ( this . pos != null && record . pos != null ) if ( ! this . pos . equals ( record . pos ) ) this . pos = record . pos ; if ( this . rotate != record . rotate ) this . rotate = record . rotate ; if ( this . showboxes != record . showboxes ) this . showboxes = record . showboxes ; if ( ! this . tooltip . equals ( record . tooltip ) ) this . tooltip = record . tooltip ; if ( this . vertices != null && record . vertices != null ) if ( ! this . vertices . equals ( record . vertices ) ) this . vertices = record . vertices ; if ( this . width != record . width ) this . width = record . width ; if ( this . z != record . z ) this . z = record . z ; if ( this . color == null ) this . color = record . color ; else if ( ! this . color . equals ( record . color ) ) this . color = record . color ; if ( this . fillcolor == null ) this . fillcolor = record . fillcolor ; else if ( ! this . fillcolor . equals ( record . fillcolor ) ) this . fillcolor = record . fillcolor ; if ( this . fontcolor == null ) this . fontcolor = record . fontcolor ; else if ( ! this . fontcolor . equals ( record . fontcolor ) ) this . fontcolor = record . fontcolor ; if ( ! this . fontname . equals ( record . fontname ) ) this . fontname = record . fontname ; if ( this . fontsize != record . fontsize ) this . fontsize = record . fontsize ; if ( this . label != null && record . label != null ) if ( ! this . label . equals ( record . label ) && ! record . label . equals ( \"node\" ) ) this . label = record . label ; if ( this . nojustify != record . nojustify ) this . nojustify = record . nojustify ; if ( this . peripheries != record . peripheries ) this . peripheries = record . peripheries ; if ( ! this . style . equals ( record . style ) ) this . style = record . style ; if ( this . target != null && record . target != null ) if ( ! this . target . equals ( record . target ) ) this . target = record . target ; if ( this . URL != null && record . URL != null ) if ( ! this . URL . equals ( record . URL ) ) this . URL = record . URL ; } private void getGenericAttributes ( ) { Object rootGraph = this . root ; Vector roots = new Vector ( ) ; while ( rootGraph instanceof SubGraph ) { roots . add ( rootGraph ) ; rootGraph = ( ( SubGraph ) rootGraph ) . root ; } if ( ( ( Graph ) rootGraph ) . genericRecord != null ) getAttributes ( ( ( Graph ) rootGraph ) . genericRecord ) ; for ( int i = roots . size ( ) - 1 ; i == 0 ; i -- ) { Record generic = ( ( SubGraph ) roots . get ( i ) ) . genericRecord ; if ( generic != null ) getAttributes ( generic ) ; } } public void addSubRecord ( SubRecord subRecord ) {", "gt": "if ( this . subRecords == null )", "prediction": "\n", "label": 1}
{"id": 1941, "input": "<s> package org . gk . ui . client . com . grid ; import java . util . List ; import org . gk . ui . client . com . form . gkMap ; import com . extjs . gxt . ui . client . data . BaseListLoadResult ; import com . extjs . gxt . ui . client . data . BaseListLoader ; import com . extjs . gxt . ui . client . data . RpcProxy ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . layout . FitLayout ; import com . google . gwt . user . client . rpc . AsyncCallback ; public abstract class gkListGridIC extends gkGridIC { public gkListGridIC ( ) { init ( ) ; } protected void init ( ) { setLayout ( new FitLayout ( ) ) ; loader = createDataLoader ( ) ; store = new ListStore ( loader ) ; grid = createGrid ( store , createColumnModel ( ) ) ; grid . setAutoWidth ( true ) ; add ( grid ) ; addListener ( ) ; } @ Override public void setListItem ( List < gkMap > list ) { models = list ; setLimitRecords ( ) ; getGrid ( ) . getStore ( ) . removeAll ( ) ; getGrid ( ) . getStore ( )", "gt": ". add ( models ) ;", "prediction": ";\n", "label": 0}
{"id": 9122, "input": "<s> package org . nuxeo . ecm . admin . monitoring ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . contexts . Contexts ; import org . nuxeo . ecm . core . management . events . EventMonitoring ; @ Name ( \"eventMonitoringAction\" ) @ Scope ( ScopeType . EVENT ) public class EventMonitoringActionBean implements Serializable { private static final long serialVersionUID = 1L ; protected EventMonitoring monitor ; protected EventMonitoring getEventMonitoring ( ) { if ( monitor == null ) { monitor = new EventMonitoring ( ) ; } return monitor ; } public int getActiveThreads ( ) { return getEventMonitoring ( ) . getActiveThreadsCount ( ) ; } public int getQueuedEvents ( ) { return getEventMonitoring ( ) . getEventsInQueueCount ( ) ; } @ Factory ( value = \"eventSyncStats\" , scope = ScopeType . EVENT ) public List < List < String > > getSyncStats ( ) { String stats = getEventMonitoring ( ) . getSyncHandlersExecTime ( ) ; return formatStats ( stats ) ; } @ Factory ( value = \"eventAsyncStats\" , scope = ScopeType . EVENT ) public List < List < String > > getAsyncStats ( ) { String stats = getEventMonitoring ( ) . getAsyncHandlersExecTime ( ) ; return formatStats ( stats ) ; } protected List < List < String > > formatStats ( String stats ) { List < List < String > > result = new ArrayList < List < String > > ( ) ; if ( stats == null || stats . length ( ) == 0 ) { return result ; } String [ ] lines = stats . split ( \"\\n\" ) ; for ( String line : lines ) { line = line . trim ( ) ; if ( line . length ( ) == 0 ) { continue ; } String [ ] parts = line . split ( \" - \" ) ; List < String > lin = Arrays . asList ( parts ) ; result . add ( lin ) ; } return result ; } public void refresh ( ) { cleanSeamEventCache ( ) ; } public String getEventStatistics ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"Active", "gt": "Threads : \" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6400, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . helpers ;", "gt": "public class SimpleMappingEditHelper extends SimplemapBaseEditHelper", "prediction": "}\n", "label": 0}
{"id": 9129, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . common . util . EList ; public interface ClassProperty extends OWLProperty { Boolean getIsFunctional ( ) ; void setIsFunctional ( Boolean value ) ; EList", "gt": "< ClassExpression > getDomain ( ) ;", "prediction": "\n", "label": 1}
{"id": 3106, "input": "<s> package Liza ; import org . bukkit . entity . Tameable ;", "gt": "public interface LizaTameable extends Tameable", "prediction": "}\n", "label": 0}
{"id": 9152, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; public class TestNot extends LuceneTestCase { public TestNot ( String name ) { super ( name ) ; } public void testNot ( ) throws Exception { RAMDirectory store = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( store , new SimpleAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; Document d1 = new Document ( ) ; d1 . add ( new Field ( \"field\" , \"a b\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( d1 ) ; writer . optimize ( ) ; writer . close ( ) ; Searcher searcher", "gt": "= new IndexSearcher ( store ) ;", "prediction": ";\n", "label": 1}
{"id": 3111, "input": "<s> import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; class MainOk { public static void main ( String [ ] args ) throws IOException { Hashtable jaPassouPor = new Hashtable ( ) ; while ( true ) { String [ ] line = breakLine ( readLine ( 255 ) ) ; int rows = Integer . parseInt ( line [ 0 ] ) ; int cols = Integer . parseInt ( line [ 1 ] ) ; int x = Integer . parseInt ( line [ 2 ] ) - 1 ; int y = 0 ; if ( rows == 0 && cols == 0 && x == - 1 ) { break ; } String lines [ ] = new String [ 10 ] ; for ( int i = 0 ; i != rows ; i ++ ) { lines [ i ] = readLine ( 255 ) ; } int steps = 0 ; jaPassouPor . clear ( ) ; while ( true ) { String key = y + \",\" + x ; if ( jaPassouPor . containsKey ( key ) ) { System . out . println ( jaPassouPor . get ( key ) + \" step(s) before a loop of \" + ( steps - ( ( Integer ) jaPassouPor . get ( key ) ) . intValue ( ) ) + \" step(s)\" ) ; break ; } jaPassouPor . put ( key , new Integer ( steps ) ) ; if ( lines [ y ] . charAt ( x ) == 'N' ) { y -- ; } else if ( lines [ y ] . charAt ( x ) == 'S' ) { y ++ ; } else if ( lines [ y ]", "gt": ". charAt ( x ) == 'E' )", "prediction": ")\n", "label": 0}
{"id": 9156, "input": "<s> package org . eclipse . jface . layout ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Layout ; import org . eclipse . swt . widgets . Scrollable ; class LayoutGenerator { private static final Point defaultSize = new Point ( 150 , 150 ) ; private static final int wrapSize = 350 ; private static final GridDataFactory nonWrappingLabelData = GridDataFactory . fillDefaults ( ) . align ( SWT . BEGINNING , SWT . CENTER ) . grab ( false , false ) ; private static boolean hasStyle ( Control c , int style ) { return ( c . getStyle ( ) & style ) != 0 ; } public static void generateLayout ( Composite toGenerate ) { Control [ ] children = toGenerate . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { Control control = children [ i ] ; if ( control . getLayoutData ( ) != null ) { continue ; } applyLayoutDataTo ( control ) ; } } private static void applyLayoutDataTo ( Control control ) { defaultsFor ( control ) . applyTo ( control ) ; } public static GridDataFactory defaultsFor ( Control control ) { if ( control instanceof Button ) { Button button = ( Button ) control ; if ( hasStyle ( button , SWT . CHECK ) ) { return nonWrappingLabelData . copy ( ) ; } return GridDataFactory . fillDefaults ( ) . align ( SWT . FILL , SWT . CENTER ) . hint ( Geometry . max ( button . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) , LayoutConstants . getMinButtonSize ( ) ) ) ; } if ( control instanceof Scrollable ) { Scrollable scrollable = ( Scrollable ) control ; if ( scrollable instanceof Composite ) { Composite composite = ( Composite ) control ; Layout theLayout = composite . getLayout ( ) ; if ( theLayout instanceof GridLayout ) { boolean growsHorizontally = false ; boolean growsVertically = false ; Control [ ] children = composite . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { Control child = children [ i ] ; GridData data = ( GridData ) child . getLayoutData ( ) ; if ( data != null ) { if ( data . grabExcessHorizontalSpace ) { growsHorizontally = true ; } if ( data . grabExcessVerticalSpace ) { growsVertically = true ; } } } return GridDataFactory . fillDefaults ( ) . grab ( growsHorizontally , growsVertically ) ; } } } boolean wrapping = hasStyle ( control , SWT . WRAP ) ; boolean hScroll = hasStyle ( control , SWT . H_SCROLL ) ; boolean vScroll = hasStyle ( control , SWT . V_SCROLL ) ; boolean containsText = hasMethod ( control , \"setText\" , new Class [ ] { String . class } ) ; boolean userEditable = ! hasStyle ( control , SWT . READ_ONLY ) && containsText && hasMethod ( control , \"addModifyListener\" , new Class [ ] { ModifyListener . class } ) ; if ( userEditable ) { if ( hasStyle ( control", "gt": ", SWT . MULTI ) )", "prediction": ")\n", "label": 1}
{"id": 3750, "input": "<s> package com . deliciousdroid . syncadapter ; import android . app . Service ; import android . content . Intent ; import android . os . IBinder ; public class ContactSyncService extends Service { private static final Object sSyncAdapterLock = new Object ( ) ; private static ContactSyncAdapter sSyncAdapter = null ; @ Override public void onCreate ( ) { synchronized ( sSyncAdapterLock ) { if ( sSyncAdapter == null ) { sSyncAdapter = new ContactSyncAdapter ( getApplicationContext ( ) , true ) ; } } }", "gt": "@ Override public IBinder onBind ( Intent intent )", "prediction": "}\n", "label": 0}
{"id": 9163, "input": "<s> package org . eclipse . ui . tests . decorators ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . decorators . DecoratorDefinition ; import org . eclipse . ui . internal . decorators . DecoratorManager ; import org . eclipse . ui . tests . navigator . AbstractNavigatorTest ; public abstract class DecoratorEnablementTestCase extends AbstractNavigatorTest implements ILabelProviderListener { protected DecoratorDefinition definition ; protected boolean updated = false ; public DecoratorEnablementTestCase ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; createTestFile ( ) ; showNav ( ) ; WorkbenchPlugin . getDefault ( ) . getDecoratorManager ( ) . addListener ( this ) ; DecoratorDefinition [ ] definitions = WorkbenchPlugin . getDefault ( ) . getDecoratorManager ( ) . getAllDecoratorDefinitions ( ) ; for ( int i = 0 ; i < definitions . length ; i ++ ) { if ( definitions [ i ] . getId ( ) . equals ( \"org.eclipse.ui.tests.decorators.lightweightdecorator\" ) ) definition = definitions [ i ] ; } } protected DecoratorManager getDecoratorManager ( ) { return WorkbenchPlugin . getDefault ( ) . getDecoratorManager ( ) ; } protected void doTearDown ( ) throws Exception { super . doTearDown ( ) ; getDecoratorManager ( ) . removeListener ( this ) ; } public void testEnableDecorator ( ) { getDecoratorManager ( ) . clearCaches ( ) ; definition . setEnabled ( true ) ; getDecoratorManager ( ) . updateForEnablementChange ( ) ; } public void testDisableDecorator ( ) { getDecoratorManager ( ) . clearCaches ( ) ; definition . setEnabled ( false ) ; getDecoratorManager ( )", "gt": ". updateForEnablementChange ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8764, "input": "<s> package org . ofbiz . datafile ; import java . util . ArrayList ; import java . util . List ; public class ModelDataFile { public static final String SEP_FIXED_LENGTH = \"fixed-length\" ; public static final String SEP_FIXED_RECORD = \"fixed-record\" ; public static final String SEP_DELIMITED = \"delimited\" ; public String name = \"\" ; public String typeCode = \"\" ; public String sender = \"\" ; public String receiver = \"\" ; public int recordLength = - 1 ; public char delimiter = '|' ; public String textDelimiter = null ; public String separatorStyle = \"\" ; public String description = \"\" ; public List < ModelRecord > records = new ArrayList < ModelRecord > ( ) ; public ModelRecord getModelRecord ( String recordName ) { for ( ModelRecord curRecord : records ) { if ( curRecord . name . equals ( recordName ) ) { return curRecord ; } } return null ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getTypeCode ( ) { return typeCode ; } public void setTypeCode ( String typeCode ) { this . typeCode = typeCode ; } public String getSender ( ) { return sender ; } public void setSender ( String sender ) { this . sender = sender ; } public String getReceiver ( ) { return receiver ; }", "gt": "public void setReceiver ( String receiver )", "prediction": "}\n", "label": 0}
{"id": 9165, "input": "<s> package com . northconcepts . eventbus . example ; import java . util . ArrayList ; import java . util . List ; import com . northconcepts . eventbus . EventBus ; public class GarbageCollectionExample { public static void main ( String [ ] args ) throws Throwable { GarbageCollectionExample eventSource = new GarbageCollectionExample ( ) ; Location store = new Location ( ) ; EventBus eventBus = new EventBus ( ) ; eventBus . addListener ( WalkListener . class , null , new WalkListener ( ) { public void walkTo ( Location location ) { System . out . println ( \"walking...\" ) ; } } ) ; WalkListener publisher = eventBus . getPublisher ( eventSource , WalkListener . class ) ; publisher . walkTo ( store ) ; System . gc ( ) ; publisher . walkTo ( store ) ; List < byte [ ] > bytes = new", "gt": "ArrayList < byte [ ] > ( 10000 ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4887, "input": "<s> import java . io . IOException ; import java . util . Comparator ; import java . util . Arrays ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; } public static boolean start ( RootDoc root ) { try { ClassDoc [ ] cds = root . classes ( ) ; Arrays . sort ( cds ) ; for ( ClassDoc cd : cds ) { ParameterizedType arrayList = cd . superclassType ( ) . asParameterizedType ( ) ; tester . println ( arrayList ) ; tester . println ( ) ; tester . println ( arrayList . superclassType ( ) ) ; Type [ ] interfaces = arrayList . interfaceTypes ( ) ; Arrays . sort ( interfaces , new", "gt": "Comparator < Type > ( )", "prediction": ") ;\n", "label": 0}
{"id": 9168, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . util . HashMap ; import java . util . Map ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . index . IndexWriter ; public class CommitIndexTask extends PerfTask { String commitUserData = null ; public CommitIndexTask ( PerfRunData runData ) { super ( runData ) ; } public boolean supportsParams ( ) { return true ; } public void setParams ( String params ) { commitUserData = params ; } public int doLogic ( ) throws Exception {", "gt": "IndexWriter iw = getRunData ( ) . getIndexWriter ( ) ;", "prediction": "\n", "label": 1}
{"id": 2912, "input": "<s> package mage . tracker . domain ; import java . io . Serializable ; import java . util . Date ; import javax . persistence . * ; @ NamedQueries ( { @ NamedQuery ( name = \"Comment.findByCardId\" , query = \"select c from Comment c where c.card.id = :cardId order by c.postTime\" ) } ) @ Entity public class Comment implements Serializable { public static final String FIND_BY_CARD_ID = \"Comment.findByCardId\" ; @ Id @ GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; @ Column ( length = 1024 , nullable = false ) private String text ; @ Column ( nullable = false ) @ Temporal ( TemporalType . TIMESTAMP ) private Date postTime ; @ ManyToOne @ JoinColumn ( nullable = false ) private Card card ; @ OneToOne private Account account ; public Card getCard ( ) { return card ; } public void setCard ( Card card ) { this . card = card ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Date getPostTime ( ) { return postTime ; } public void setPostTime ( Date postTime ) { this . postTime = postTime ; } public String getText ( ) { return text ; }", "gt": "public void setText ( String text )", "prediction": "}\n", "label": 0}
{"id": 9181, "input": "<s> package org . eclipse . jface . fieldassist ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Iterator ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . swt . graphics . Image ; public class FieldDecorationRegistry implements Serializable { public static final String DEC_CONTENT_PROPOSAL = \"DEC_CONTENT_PROPOSAL\" ; public static final String DEC_REQUIRED = \"DEC_REQUIRED\" ; public static final String DEC_ERROR = \"DEC_ERROR\" ; public static final String DEC_WARNING = \"DEC_WARNING\" ; public static final String DEC_INFORMATION = \"DEC_INFORMATION\" ; public static final String DEC_ERROR_QUICKFIX = \"DEC_ERRORQUICKFIX\" ; private static final String IMG_DEC_FIELD_CONTENT_PROPOSAL = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_CONTENT_PROPOSAL\" ; private static final String IMG_DEC_FIELD_REQUIRED = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_REQUIRED\" ; private static final String IMG_DEC_FIELD_ERROR = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_ERROR\" ; private static final String IMG_DEC_FIELD_ERROR_QUICKFIX = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_ERROR_QUICKFIX\" ; private static final String IMG_DEC_FIELD_WARNING = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_WARNING\" ; private static final String IMG_DEC_FIELD_INFO = \"org.eclipse.jface.fieldassist.IMG_DEC_FIELD_INFO\" ; static { ImageRegistry imageRegistry = JFaceResources . getImageRegistry ( ) ; imageRegistry . put ( IMG_DEC_FIELD_CONTENT_PROPOSAL , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/contassist_ovr.gif\" ) ) ; imageRegistry . put ( IMG_DEC_FIELD_ERROR , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/error_ovr.gif\" ) ) ; imageRegistry . put ( IMG_DEC_FIELD_WARNING , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/warn_ovr.gif\" ) ) ; imageRegistry . put ( IMG_DEC_FIELD_REQUIRED , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/required_field_cue.gif\" ) ) ; imageRegistry . put ( IMG_DEC_FIELD_ERROR_QUICKFIX , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/errorqf_ovr.gif\" ) ) ; imageRegistry . put ( IMG_DEC_FIELD_INFO , ImageDescriptor . createFromFile ( FieldDecorationRegistry . class , \"images/info_ovr.gif\" ) ) ; getDefault ( ) . registerFieldDecoration ( DEC_CONTENT_PROPOSAL , JFaceResources . getString ( \"FieldDecorationRegistry.contentAssistMessage\" ) , IMG_DEC_FIELD_CONTENT_PROPOSAL , imageRegistry ) ; getDefault ( ) . registerFieldDecoration ( DEC_ERROR , JFaceResources . getString ( \"FieldDecorationRegistry.errorMessage\" ) , IMG_DEC_FIELD_ERROR , imageRegistry ) ; getDefault ( ) . registerFieldDecoration ( DEC_ERROR_QUICKFIX , JFaceResources . getString ( \"FieldDecorationRegistry.errorQuickFixMessage\" ) , IMG_DEC_FIELD_ERROR_QUICKFIX , imageRegistry ) ; getDefault ( ) . registerFieldDecoration ( DEC_WARNING , null , IMG_DEC_FIELD_WARNING , imageRegistry ) ; getDefault ( ) . registerFieldDecoration ( DEC_INFORMATION , null , IMG_DEC_FIELD_INFO , imageRegistry ) ; getDefault ( ) . registerFieldDecoration ( DEC_REQUIRED , JFaceResources . getString ( \"FieldDecorationRegistry.requiredFieldMessage\" ) , IMG_DEC_FIELD_REQUIRED , imageRegistry ) ; } class Entry { private String description ; private String imageId ; private ImageRegistry imageRegistry ; private Image image ; private FieldDecoration decoration ; Entry ( String description , String imageId , ImageRegistry registry ) { this . description = description ; this . imageId = imageId ; this . imageRegistry = registry ; } Entry ( String description , Image image ) { this . description = description ; this . image = image ; } FieldDecoration getDecoration ( ) { if ( decoration == null ) { if ( image == null ) { if ( imageRegistry == null ) { imageRegistry = JFaceResources . getImageRegistry ( ) ; } image = imageRegistry . get ( imageId ) ; } decoration = new FieldDecoration ( image , description ) ; } description = null ; imageId = null ; imageRegistry = null ; image = null ; return decoration ; } } private static FieldDecorationRegistry defaultInstance ; private int maxDecorationWidth = 0 ; private int maxDecorationHeight = 0 ;", "gt": "private HashMap decorations = new HashMap ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6531, "input": "<s> package pkg2 ; import pkg1 . * ; public class SubClass extends BaseClass { public void publicMethod ( ) { } public void packagePrivateMethod ( ) { }", "gt": "public void privateMethod ( )", "prediction": "}\n", "label": 0}
{"id": 9201, "input": "<s> import java . io . * ; import java . util . * ; class Board { private final int [ ] [ ] ROW ; private final int [ ] [ ] COL ; private Field [ ] field ; private AreaMap area = null ; private CArray charSet ; private int size ; public Board ( String puzzleString ) { if ( puzzleString . length ( ) != 81 ) { System . err . println ( \"Could not parse puzzle string\" ) ; System . exit ( - 1 ) ; } size = 9 ; field = new Field [ 81 ] ; area = new AreaMap ( \"map/9.map\" , size ) ; char [ ] cCharSet = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' } ; charSet = new CArray ( cCharSet ) ; for ( int i = 0 ; i < 81 ; i ++ ) { char c = puzzleString . charAt ( i ) ; if ( charSet . has ( c ) ) field [ i ] = new Field ( charSet , c ) ; else field [ i ] = new Field ( charSet ) ; } ROW = new int [ size ] [ size ] ; COL = new int [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { ROW [ i ] [ j ] = size * i + j ; COL [ i ] [ j ] = size * j + i ; } } } public Board ( String puzzleFileName , String mapFileName ) { File puzzleFile = new File ( puzzleFileName ) ; try { Scanner s = new Scanner ( puzzleFile ) ; String charSetString = \"\" ; if ( s . hasNext ( ) ) { charSetString = s . next ( ) ; } else { System . err . println ( \"Error parsing puzzleFileName file \\'\" + puzzleFileName + \"\\'.\" ) ; System . err . println ( \"Could not find character set\" ) ; System . exit ( - 1 ) ; } charSet = new CArray ( charSetString . split ( \",\" ) ) ; size = charSet . length ( ) ; field = new Field [ size * size ] ; for ( int i = 0 ; i < size * size ; i ++ ) { if ( s . hasNext ( ) ) { char c = s . next ( ) . charAt ( 0 ) ; if ( charSet . has ( c ) ) { field [ i ] = new Field ( charSet , c ) ; } else { field [ i ] = new Field ( charSet ) ; } } else { System . err . println ( \"Error parsing puzzleFileName file \\'\" + puzzleFileName + \"\\'.\" ) ; System . err . println ( \"Not enough fields\" ) ; System . exit ( - 1 ) ; } } } catch ( FileNotFoundException e ) { System . err . println ( \"Could not find sudoku file \\'\" + puzzleFileName + \"\\'\" ) ; System . exit ( - 1 ) ; } if ( mapFileName . equals ( \"\" ) ) { mapFileName = \"map/\" + size + \".map\" ; System . out . println ( \"Using default map file \\'\" + mapFileName + \"\\'\" ) ; } else { System . out . println ( \"Using custom map file \\'\" + mapFileName + \"\\'\" ) ; } area = new AreaMap ( mapFileName , size ) ; ROW = new int [ size ] [ size ] ; COL = new int [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { ROW [ i ] [ j ] = size * i + j ; COL [ i ] [ j ]", "gt": "= size * j + i ;", "prediction": ";\n", "label": 1}
{"id": 2119, "input": "<s> package pkg ; public class P { public void method ( ) throws T5", "gt": ", T6 , T7 , T8", "prediction": "\n", "label": 0}
{"id": 9206, "input": "<s> package org . eclipse . ui . internal . layout ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Layout ; public class CellLayout extends Layout { private Row defaultRowSettings = new Row ( false ) ; private Row defaultColSettings = new Row ( true ) ; int horizontalSpacing = 5 ; int verticalSpacing = 5 ; public int marginWidth = 5 ; public int marginHeight = 5 ; private int numCols ; private List cols ; private List rows = new ArrayList ( 16 ) ; private GridInfo gridInfo = new GridInfo ( ) ; private int [ ] cachedRowMin = null ; private int [ ] cachedColMin = null ; public static int cacheMisses ; public static int cacheHits ; private LayoutCache cache = new LayoutCache ( ) ; public CellLayout ( int numCols ) { super ( ) ; this . numCols = numCols ; cols = new ArrayList ( numCols == 0 ? 3 : numCols ) ; } public CellLayout setSpacing ( int horizontalSpacing , int verticalSpacing ) { this . horizontalSpacing = horizontalSpacing ; this . verticalSpacing = verticalSpacing ; return this ; } public CellLayout setSpacing ( Point newSpacing ) { horizontalSpacing = newSpacing . x ; verticalSpacing = newSpacing . y ; return this ; } public Point getSpacing ( ) { return new Point ( horizontalSpacing , verticalSpacing ) ; } public CellLayout setMargins ( int marginWidth , int marginHeight ) { this . marginWidth = marginWidth ; this . marginHeight = marginHeight ; return this ; } public CellLayout setMargins ( Point newMargins ) { marginWidth = newMargins . x ; marginHeight = newMargins . y ; return this ; } public Point getMargins ( ) { return new Point ( marginWidth , marginHeight ) ; } public CellLayout setDefaultColumn ( Row info ) { defaultColSettings = info ; return this ; } public CellLayout setColumn ( int colNum , Row info ) { while ( cols . size ( ) <= colNum ) { cols . add ( null ) ; } cols . set ( colNum , info ) ; return this ; } public CellLayout setDefaultRow ( Row info ) { defaultRowSettings = info ; return this ; } public CellLayout setRow ( int rowNum , Row info ) { while ( rows . size ( ) <= rowNum ) { rows . add ( null ) ; } rows . set ( rowNum , info ) ; return this ; } private Row getRow ( int rowNum , boolean isHorizontal ) { if ( isHorizontal ) { if ( rowNum >= rows . size ( ) ) { return defaultRowSettings ; } Row result = ( Row ) rows . get ( rowNum ) ; if ( result == null ) { result = defaultRowSettings ; } return result ; } else { if ( rowNum >= cols . size ( ) ) { return defaultColSettings ; } Row result = ( Row ) cols . get ( rowNum ) ; if ( result == null ) { result = defaultColSettings ; } return result ; } } private void initGrid ( Control [ ] children ) { cache . setControls ( children ) ; gridInfo . initGrid ( children , this ) ; cachedRowMin = null ; cachedColMin = null ; } protected Point computeSize ( Composite composite , int wHint , int hHint , boolean flushCache ) { Control [ ] children = composite . getChildren ( ) ; initGrid ( children ) ; if ( flushCache ) { cache . flush ( ) ; } Point emptySpace = totalEmptySpace ( ) ; int [ ] heightConstraints = computeConstraints ( true ) ; int width ; if ( wHint == SWT . DEFAULT ) { width = preferredSize ( heightConstraints , false ) ; } else { width = wHint - emptySpace . x ; } int height = hHint ; if ( hHint == SWT . DEFAULT ) { height = preferredSize ( computeSizes ( heightConstraints , width , false ) , true ) ; } else { height = hHint - emptySpace . y ; } Point preferredSize = new Point ( width + emptySpace . x , height + emptySpace . y ) ; Point minimumSize = CellLayoutUtil . computeMinimumSize ( composite ) ; boolean wider = ( preferredSize . x >= minimumSize . x ) ; boolean taller = ( preferredSize . y >= minimumSize . y ) ; if ( wider ) { if ( taller ) { return preferredSize ; } else { return computeSize ( composite , wHint , minimumSize . y , false ) ; } } else { if ( taller ) { return computeSize ( composite , minimumSize . x , hHint , false ) ; } else { return minimumSize ; } } } int [ ] computeSizes ( int [ ] constraints , int availableSpace , boolean computingRows ) { int [ ] result = computeMinSizes ( constraints , computingRows ) ; int totalFixed = sumOfSizes ( result ) ; int denominator = getResizeDenominator ( computingRows ) ; int numRows = gridInfo . getNumRows ( computingRows ) ; if ( totalFixed < availableSpace ) { int remaining = availableSpace - totalFixed ;", "gt": "for ( int idx = 0 ;", "prediction": "}\n", "label": 1}
{"id": 329, "input": "<s> package org . ofbiz . base . util ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Stack ; import javolution . util . FastMap ; public class UtilGenerics { public static final String module = UtilMisc . class . getName ( ) ; @ SuppressWarnings ( \"unchecked\" ) public static < V > V cast ( Object object ) { return ( V ) object ; } private static < C extends Collection < ? > > C checkCollectionCast ( Object object , Class < C > clz ) { return clz . cast ( object ) ; } public static < C extends Collection < ? > > void checkCollectionContainment ( Object object , Class < C > clz , Class < ? > type ) { if ( object != null ) { if ( ! ( clz . isInstance ( object ) ) ) throw new ClassCastException ( \"Not a \" + clz . getName ( ) ) ; int i = 0 ; for ( Object value : ( Collection < ? > ) object ) { if ( value != null && ! type . isInstance ( value ) ) { throw new IllegalArgumentException ( \"Value(\" + i + \"), with value(\" + value + \") is not a \" + type . getName ( ) ) ; } i ++ ; } } } @ SuppressWarnings ( \"unchecked\" ) public static < T > Collection < T > checkCollection ( Object object ) { return ( Collection < T > ) checkCollectionCast ( object , Collection . class ) ; } public static < T > Collection < T > checkCollection ( Object object , Class < T > type ) { checkCollectionContainment ( object , Collection . class , type ) ; return checkCollection ( object ) ; } @ SuppressWarnings ( \"unchecked\" ) public static < T > List < T > checkList ( Object object ) { return ( List < T > ) checkCollectionCast ( object , List . class ) ; } public static < T > List < T > checkList ( Object object , Class < T > type ) { checkCollectionContainment ( object , List . class , type ) ; return checkList ( object ) ; } @ SuppressWarnings ( \"unchecked\" ) public static < K , V > Map < K , V > checkMap ( Object object ) { if ( object != null && ! ( object instanceof Map ) ) throw new ClassCastException ( \"Not a map\" ) ; return ( Map <", "gt": "K , V > ) object ;", "prediction": ") ;\n", "label": 0}
{"id": 9235, "input": "<s> package br . org . archimedes . exceptions ; public class InvalidArgumentException extends Exception {", "gt": "private static final long serialVersionUID = - 7256441278054393719L ;", "prediction": "\n", "label": 1}
{"id": 6318, "input": "<s> package com . atlassian . crowd . integration . authentication ; @ SuppressWarnings ( \"serial\" ) public class PrincipalAuthenticationContext implements java . io . Serializable { private java . lang . String application ; private com . atlassian . crowd . integration . authentication . PasswordCredential credential ; private java . lang . String name ; private com . atlassian . crowd . integration . authentication . ValidationFactor [ ] validationFactors ; public PrincipalAuthenticationContext ( ) { } public PrincipalAuthenticationContext ( java . lang . String application , com . atlassian . crowd . integration . authentication . PasswordCredential credential , java . lang . String name , com . atlassian . crowd . integration . authentication . ValidationFactor [ ] validationFactors ) { this . application = application ; this . credential = credential ; this . name = name ; this . validationFactors = validationFactors ; } public java . lang . String getApplication ( ) { return application ; } public void setApplication ( java . lang . String application ) { this . application = application ; } public com . atlassian . crowd . integration . authentication . PasswordCredential getCredential ( ) { return credential ; } public void setCredential ( com . atlassian . crowd . integration . authentication . PasswordCredential credential ) { this . credential = credential ; } public java . lang . String getName ( ) { return name ; } public void setName ( java . lang . String name ) { this . name = name ; } public com . atlassian . crowd . integration . authentication . ValidationFactor [ ] getValidationFactors ( ) { return validationFactors ; } public void setValidationFactors ( com . atlassian . crowd . integration . authentication . ValidationFactor [ ] validationFactors ) { this . validationFactors = validationFactors ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof PrincipalAuthenticationContext ) ) return false ; PrincipalAuthenticationContext other = ( PrincipalAuthenticationContext ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . application == null && other . getApplication ( ) == null ) || ( this . application != null && this . application . equals ( other . getApplication ( ) ) ) ) && ( ( this . credential == null && other . getCredential ( ) == null ) || ( this . credential != null && this . credential . equals ( other . getCredential ( ) ) ) ) && ( ( this . name == null && other . getName ( ) == null ) || ( this . name != null && this . name . equals ( other . getName ( ) ) ) ) && ( ( this . validationFactors == null && other . getValidationFactors ( ) == null ) || ( this . validationFactors != null && java . util . Arrays . equals ( this . validationFactors , other . getValidationFactors ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getApplication ( ) != null ) { _hashCode += getApplication ( ) . hashCode ( ) ; } if ( getCredential ( ) != null ) { _hashCode += getCredential ( ) . hashCode ( ) ; } if ( getName ( ) != null ) { _hashCode += getName ( ) . hashCode ( ) ; } if ( getValidationFactors ( ) != null ) { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( getValidationFactors ( ) ) ; i ++ ) { java . lang . Object obj = java . lang . reflect . Array . get ( getValidationFactors ( ) , i ) ; if ( obj != null && ! obj . getClass ( ) . isArray ( ) ) { _hashCode += obj . hashCode ( ) ; } } } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( PrincipalAuthenticationContext . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://authentication.integration.crowd.atlassian.com\" , \"PrincipalAuthenticationContext\" ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"application\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://authentication.integration.crowd.atlassian.com\" , \"application\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://www.w3.org/2001/XMLSchema\" , \"string\" ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( true ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"credential\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://authentication.integration.crowd.atlassian.com\" , \"credential\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://authentication.integration.crowd.atlassian.com\" , \"PasswordCredential\" ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( true ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"name\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://authentication.integration.crowd.atlassian.com\" , \"name\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://www.w3.org/2001/XMLSchema\" , \"string\" ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( true ) ; typeDesc", "gt": ". addFieldDesc ( elemField ) ;", "prediction": ";\n", "label": 0}
{"id": 9238, "input": "<s> package org . nuxeo . ecm . platform . picture . core . libraryselector ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; @ XObject ( \"LibrarySelector\" ) public class LibrarySelectorServiceDescriptor { @ XNode ( \"ImageUtils\" ) public ImageUtilsDescriptor imageUtils ; @ XNode ( \"MimeUtils\" ) public MimeUtilsDescriptor mimeUtils ; @ XNode (", "gt": "\"MetadataUtils\" ) public MetadataUtilsDescriptor metadataUtils ;", "prediction": ") ;\n", "label": 1}
{"id": 7647, "input": "<s> package Liza ; import org . bukkit . entity . CaveSpider ;", "gt": "public interface LizaCaveSpider extends CaveSpider", "prediction": "}\n", "label": 0}
{"id": 9272, "input": "<s> package org . restlet . test . ext . jaxb ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . restlet . test . RestletTestCase ; import org . restlet . Application ; import org . restlet . Client ; import org . restlet . Component ; import org . restlet . Context ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; import org . restlet . data . Preference ; import org . restlet . data . Protocol ; import org . restlet . ext . jaxb . JaxbRepresentation ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . resource . Put ; import org . restlet . resource . ServerResource ; import org . restlet . routing . Router ; public class JaxbIntegrationConverterTestCase extends RestletTestCase { private static final String IN_STRING = \"foo\" ; private static final String HELLO_OUT_STRING = \"Hello World \" + IN_STRING ; private Component component ; private String uri ; public void setUp ( ) throws Exception { super . setUp ( ) ; this . component = new Component ( ) ; final Server server = this . component . getServers ( ) . add ( Protocol . HTTP , 0 ) ; final Application application = createApplication ( this . component ) ; this . component . getDefaultHost ( ) . attach ( application ) ; this . component . start ( ) ; uri = \"http://localhost:\" + server . getEphemeralPort ( ) + \"/test\" ; } public void tearDown ( ) throws Exception { if ( component != null ) { component . stop ( ) ; } this . component = null ; super . tearDown ( ) ; } protected Application createApplication ( Component component ) { final Application application = new Application ( ) { @ Override public Restlet createInboundRoot ( ) { final Router router = new Router ( getContext ( ) ) ; router . attach ( \"/test\" , SampleResource . class ) ; return router ; } } ; return application ; } public void testIntegration ( ) throws Exception { Client client = new Client ( new Context ( ) , Arrays . asList ( Protocol . HTTP ) ) ; Request request = new Request ( Method . POST , uri ) ; request . setEntity ( new JaxbRepresentation < Sample > ( new Sample ( IN_STRING ) ) ) ; Response response = client . handle ( request ) ; JaxbRepresentation < Sample > resultRepresentation = new JaxbRepresentation < Sample > ( response . getEntity ( ) , Sample . class ) ; Sample", "gt": "sample = resultRepresentation . getObject ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7771, "input": "<s> package org . gk . engine . client . event . attrib ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . form . CheckBox ; public class CheckedAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof CheckBox ) {", "gt": "CheckBox cb = ( CheckBox ) com ;", "prediction": "}\n", "label": 0}
{"id": 9275, "input": "<s> package org . eclipse . jface . databinding . wizard ; import org . eclipse . core . databinding . DataBindingContext ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . jface . databinding . dialog . DialogPageSupport ; import org . eclipse . jface . wizard . WizardPage ; public class WizardPageSupport extends DialogPageSupport { private WizardPageSupport ( WizardPage wizardPage , DataBindingContext dbc ) { super ( wizardPage , dbc ) ; } public static WizardPageSupport create ( WizardPage wizardPage , DataBindingContext dbc ) { return new WizardPageSupport ( wizardPage , dbc ) ; } protected void handleStatusChanged ( ) { super . handleStatusChanged ( ) ; boolean pageComplete = true ; if ( currentStatusStale ) { pageComplete = false ; } else if ( currentStatus != null ) { pageComplete = ! currentStatus . matches ( IStatus", "gt": ". ERROR | IStatus . CANCEL ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1622, "input": "<s> import java . io . PrintStream ; interface clss41701i { void run ( ) ; } class clss41701a < A extends clss41701i ,", "gt": "B extends clss41701i , C extends A & B >", "prediction": ". get ( ) ;\n", "label": 0}
{"id": 9300, "input": "<s> package org . nuxeo . ecm . platform . publisher . descriptors ; import java . io . Serializable ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XObject ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinder ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinderFactory ; @ XObject ( \"rootSectionFinderFactory\" ) public class RootSectionFinderFactoryDescriptor implements Serializable { private static final long serialVersionUID = 1L ; @ XNode ( \"@class\" ) private Class < ? extends RootSectionFinderFactory > factory ; public Class < ?", "gt": "extends RootSectionFinderFactory > getFactory ( )", "prediction": "( )\n", "label": 1}
{"id": 2159, "input": "<s> package org . jjflyboy . tjpeditor . scoping ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . xtext . EcoreUtil2 ; import org . eclipse . xtext . resource . IEObjectDescription ; import org . eclipse . xtext . resource . IResourceDescription ; import org . eclipse . xtext . resource . IResourceDescriptions ; import org . eclipse . xtext . scoping . IScope ; import org . eclipse . xtext . scoping . impl . ImportUriGlobalScopeProvider ; import org . eclipse . xtext . scoping . impl . ImportUriResolver ; import org . eclipse . xtext . util . IResourceScopeCache ; import org . eclipse . xtext . util . Pair ; import org . eclipse . xtext . util . Tuples ; import org . jjflyboy . tjpeditor . project . Global ; import org . jjflyboy . tjpeditor . project . IncludeProperties ; import org . jjflyboy . tjpeditor . project . Property ; import com . google . common . base . Predicate ; import com . google . common . collect . Lists ; import com . google . inject . Inject ; import com . google . inject . Provider ; public class ProjectImportUriGlobalScopeProvider extends ImportUriGlobalScopeProvider implements IProjectGlobalScopeProvider { @ Inject private ImportUriResolver importResolver ; @ Inject private IResourceScopeCache cache ; public IScope getScope ( Resource resource , final EReference reference , EObject originalContext ) { return getScope ( resource , reference , null , originalContext ) ; } public IScope getScope ( Resource resource , final EReference reference , Predicate < IEObjectDescription > filter , EObject originalContext ) { return getScope ( resource , isIgnoreCase ( reference ) , reference . getEReferenceType ( ) , filter , originalContext ) ; } protected IScope getScope ( Resource resource , boolean ignoreCase , EClass type , Predicate < IEObjectDescription > filter , EObject originalContext ) { final LinkedHashSet < URI > uniqueImportURIs = getImportedUris ( resource , originalContext ) ; IResourceDescriptions descriptions = getResourceDescriptions ( resource , uniqueImportURIs ) ; List < URI > urisAsList = Lists . newArrayList ( uniqueImportURIs ) ; IScope scope = IScope . NULLSCOPE ; for ( URI uri : urisAsList ) { scope = createLazyResourceScope ( scope , uri , descriptions , type ,", "gt": "filter , ignoreCase ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9309, "input": "<s> package org . apache . lucene . analysis ; import java . io . IOException ; import java . util . IdentityHashMap ; import org . apache . lucene . analysis . tokenattributes . FlagsAttribute ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . PayloadAttribute ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . analysis . tokenattributes . TypeAttribute ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Payload ; import org . apache . lucene . util . Attribute ; import org . apache . lucene . util . AttributeImpl ; import org . apache . lucene . util . AttributeSource ; public abstract class TokenStream extends AttributeSource { private static final AttributeFactory DEFAULT_TOKEN_WRAPPER_ATTRIBUTE_FACTORY = new TokenWrapperAttributeFactory ( AttributeFactory . DEFAULT_ATTRIBUTE_FACTORY ) ; private final TokenWrapper tokenWrapper ; private static boolean onlyUseNewAPI = false ; private final MethodSupport supportedMethods = getSupportedMethods ( this . getClass ( ) ) ; private static final class MethodSupport { final boolean hasIncrementToken , hasReusableNext , hasNext ; MethodSupport ( Class clazz ) { hasIncrementToken = isMethodOverridden ( clazz , \"incrementToken\" , METHOD_NO_PARAMS ) ; hasReusableNext = isMethodOverridden ( clazz , \"next\" , METHOD_TOKEN_PARAM ) ; hasNext = isMethodOverridden ( clazz , \"next\" , METHOD_NO_PARAMS ) ; } private static boolean isMethodOverridden ( Class clazz , String name , Class [ ] params ) { try { return clazz . getMethod ( name , params ) . getDeclaringClass ( ) != TokenStream . class ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } } private static final Class [ ] METHOD_NO_PARAMS = new Class [ 0 ] ; private static final Class [ ] METHOD_TOKEN_PARAM = new Class [ ] { Token . class } ; } private static final IdentityHashMap knownMethodSupport = new IdentityHashMap ( ) ; private static MethodSupport getSupportedMethods ( Class clazz ) { MethodSupport supportedMethods ; synchronized ( knownMethodSupport ) { supportedMethods = ( MethodSupport ) knownMethodSupport . get ( clazz ) ; if ( supportedMethods == null ) { knownMethodSupport . put ( clazz , supportedMethods = new MethodSupport ( clazz ) ) ; } } return supportedMethods ; } private static final class TokenWrapperAttributeFactory extends AttributeFactory { private final AttributeFactory delegate ; private TokenWrapperAttributeFactory ( AttributeFactory delegate ) { this . delegate = delegate ; } public AttributeImpl createAttributeInstance ( Class attClass ) { return attClass . isAssignableFrom ( TokenWrapper . class ) ? new TokenWrapper", "gt": "( ) : delegate . createAttributeInstance ( attClass ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8967, "input": "<s> public class DefAssignBoolean_5 { public static void main ( String [ ] args ) { boolean b3 , b4 ; boolean r = false ; boolean t = true ; if ( ( t && ( b3 = r ) ) != ( t && ( b3 = t )", "gt": ") ) r = b3 ;", "prediction": ";\n", "label": 0}
{"id": 9311, "input": "<s> package org . apache . lucene . store . instantiated ; import org . apache . lucene . index . TermFreqVector ; import java . io . Serializable ; import java . util . Arrays ; import java . util . List ; public class InstantiatedTermFreqVector implements TermFreqVector , Serializable { private static final long serialVersionUID = 1l ; private final List < InstantiatedTermDocumentInformation > termDocumentInformations ; private final String field ; private final String terms [ ] ; private final int termFrequencies [ ] ; public InstantiatedTermFreqVector ( InstantiatedDocument document , String field ) { this . field = field ; termDocumentInformations = document . getVectorSpace ( ) . get ( field ) ; terms = new String [ termDocumentInformations . size ( ) ] ; termFrequencies = new int [ termDocumentInformations . size ( ) ] ; for ( int i = 0 ; i < termDocumentInformations . size ( ) ; i ++ ) { InstantiatedTermDocumentInformation termDocumentInformation = termDocumentInformations . get ( i ) ; terms [ i ] = termDocumentInformation . getTerm ( ) . text ( ) ; termFrequencies [ i ] = termDocumentInformation . getTermPositions ( ) . length ; } } public String getField ( ) { return field ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( '{' ) ; sb . append ( field ) . append ( \": \" ) ; if ( terms != null ) { for ( int i = 0 ; i < terms . length ; i ++ ) { if ( i > 0 ) sb . append ( \", \" ) ; sb . append ( terms [ i ] ) . append ( '/' ) . append ( termFrequencies [ i ] ) ; } } sb . append ( '}' ) ; return sb . toString ( ) ; } public int size ( ) { return terms == null ? 0 : terms . length ; } public String [ ] getTerms ( ) { return terms ; } public int [ ] getTermFrequencies ( ) { return termFrequencies ; } public int indexOf ( String termText ) { if ( terms == null ) return - 1 ; int res = Arrays . binarySearch ( terms , termText ) ; return res >= 0 ? res : - 1 ; } public int [ ] indexesOf ( String [ ] termNumbers , int start , int len ) { int res [ ] = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { res [ i ] = indexOf (", "gt": "termNumbers [ start + i ] ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2888, "input": "<s> package api . top ; import java . util . List ; import api . son . MySon ; import api . soup . MySoup ; public class Top { private List < Response > response ; private String status ; public static Top initTopTorrents ( int limit ) { if ( validLimit ( limit ) ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=top10&type=torrents&limit=\" + limit + \"&auth=\" + authkey ; Top top = ( Top ) MySon . toObject ( url , Top . class ) ; return top ; } else { System . err . println ( \"Limit \" + limit + \"is not invalid\" ) ; } return null ; } public static Top initTopTags ( int limit ) { if ( validLimit ( limit ) ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=top10&type=tags&limit=\" + limit + \"&auth=\" + authkey ; Top top = ( Top ) MySon . toObject ( url , Top . class ) ; return top ; } else { System . err . println ( \"Limit \" + limit + \"is not invalid\" ) ; } return null ; } public static Top initTopUsers ( int limit ) { if ( validLimit ( limit ) ) { String", "gt": "authkey = MySoup . getAuthKey ( ) ;", "prediction": "\n", "label": 0}
{"id": 9315, "input": "<s> package Model ; import java . util . ArrayList ; import java . util . List ; public class Tour { private int sTourId ; private String sName ; private String sDescription ; private String sDifficulty ; private List < Waypoint > pWaypoints = new ArrayList < Waypoint > ( ) ; public Tour ( ) { } public Tour ( int idtour , String name , String description , String difficulty ) { this . sTourId = idtour ; this . sName = name ; this . sDescription = description ; this . sDifficulty = difficulty ; } public int getTourId ( ) { return sTourId ; } public void setTourId ( int idtour ) { this . sTourId = idtour ; } public String getTourName ( ) { return sName ; } public void setTourName ( String name ) { this . sName = name ; } public String getTourDescription ( ) { return sDescription ; } public void setTourDescription ( String description ) { this . sDescription = description ; } public String getTourDifficulty ( ) { return sDifficulty ; } public void setTourDifficulty ( String difficulty ) { this . sDifficulty = difficulty ; } public List < Waypoint > getTourWaypoints ( ) { return pWaypoints ; } public void setTourWaypoints ( List < Waypoint > waypoints ) { this . pWaypoints = waypoints ; } public void addWaypoint ( Waypoint waypoint ) { pWaypoints . add ( waypoint ) ; } public Waypoint getWaypointByPosition ( int nPos ) { return pWaypoints . get ( nPos ) ; } public int getWaypointCount ( ) { return pWaypoints . size ( ) ; }", "gt": "@ Override public boolean equals ( Object obj )", "prediction": "}\n", "label": 1}
{"id": 2461, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public", "gt": "interface Scenarios extends ReportAttribute , ExportAttribute", "prediction": ";\n", "label": 0}
{"id": 9320, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; public interface IDateTimeAdapter { int WEEKDAY_TEXTFIELD = 0 ; int DAY_TEXTFIELD = 1 ; int MONTH_TEXTFIELD = 2 ; int YEAR_TEXTFIELD = 3 ; int WEEKDAY_MONTH_SEPARATOR = 4 ; int MONTH_DAY_SEPARATOR = 5 ; int DAY_YEAR_SEPARATOR = 6 ; int SPINNER = 7 ; int HOURS_TEXTFIELD = 8 ; int MINUTES_TEXTFIELD = 9 ; int SECONDS_TEXTFIELD = 10 ; int HOURS_MINUTES_SEPARATOR = 11 ; int MINUTES_SECONDS_SEPARATOR = 12 ; int DROP_DOWN_BUTTON = 13 ; Rectangle getBounds ( int widget ) ; Point getCellSize ( ) ; String", "gt": "[ ] getMonthNames ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6856, "input": "<s> public class DeclarationStatementInline { { class Foo { Foo ( ) { System . out . println ( \"Hello\" ) ; } } new Foo ( ) ; } DeclarationStatementInline ( ) { System . out . println ( \"Constructor one\" ) ; } DeclarationStatementInline ( int i ) { System . out . println", "gt": "( \"Constructor two\" ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 9326, "input": "<s> package org . jscsi . scsi . protocol ; import java . io . IOException ; import java . nio . ByteBuffer ; public interface Encodable { byte [ ]", "gt": "encode ( ) throws IOException ;", "prediction": ";\n", "label": 1}
{"id": 5053, "input": "<s> class Test extends Test { { for (", "gt": "Integer x : null )", "prediction": ") ;\n", "label": 0}
{"id": 9329, "input": "<s> package org . gatein . common . util ; import junit . framework . TestCase ; import org . gatein . common . util . MapAdapters ; import java . util . Map ; import java . util . HashMap ; public class MapAdaptersTestCase extends TestCase { Map < String , String [ ] > adapted ; Map < String , String > adapter ; protected void setUp ( ) throws Exception { adapted = new HashMap < String , String [ ] > ( ) ; adapter = MapAdapters . adapt ( adapted ) ; } public void testGet ( ) { adapted . put ( \"daa\" , null ) ; adapted . put ( \"foo\" , new String [ ] { } ) ; adapted . put ( \"bar\" , new String [ ] { \"bar_1\" } ) ; adapted . put ( \"juu\" , new String [ ] { \"juu_1\" , \"juu_2\" } ) ; try { adapter . get ( \"foo\" ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } try { adapter . get ( \"daa\" ) ; fail ( ) ; } catch ( IllegalStateException ignore ) { } assertEquals ( \"bar_1\" , adapter . get ( \"bar\" ) ) ; assertEquals ( \"juu_1\" , adapter . get ( \"juu\" ) ) ; } public void testPut1 ( ) { try { adapter . put ( \"foo\" , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } public void testPut2 ( ) { adapted . put ( \"foo\"", "gt": ", new String [ ]", "prediction": ") ;\n", "label": 1}
{"id": 8752, "input": "<s> public class Test < T > { < T extends Test < ? super Number > > T m1 ( T t ) { return m2 ( t ) ; } < T extends Test <", "gt": "? super Number > > T m2 ( T t )", "prediction": "\n", "label": 0}
{"id": 9331, "input": "<s> package org . eclipse . ui . internal . dialogs ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui .", "gt": "internal . preferences . WorkbenchPreferenceExpressionNode ;", "prediction": ";\n", "label": 1}
{"id": 6942, "input": "<s> enum Color { red , green , blue } @ interface An {", "gt": "void a ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 9344, "input": "<s> package org . restlet . ext . sip ; import java . util . HashMap ; import java . util . Map ; public class OptionTag { private static volatile Map < String , OptionTag > _optionTags = null ; public static final OptionTag ANSWER_MODE = register ( \"answermode\" ) ; public static final OptionTag EARLY_SESSION = register ( \"early-session\" ) ; public static final OptionTag EVENT_LIST = register ( \"eventlist\" ) ; public static final OptionTag FROM_CHANGE = register ( \"from-change\" ) ; public static final OptionTag GRUU = register ( \"gruu\" ) ; public static final OptionTag HIST_INFO = register ( \"histinfo\" ) ; public static final OptionTag ICE = register ( \"ice\" ) ; public static final OptionTag JOIN = register ( \"join\" ) ; public static final OptionTag MULTIPLE_REFER = register ( \"multiple-refer\" ) ; public static final OptionTag NO_REFER_SUB = register ( \"norefersub\" ) ; public static final OptionTag OUTBOUND = register ( \"outbound\" ) ; public static final OptionTag PATH = register ( \"path\" ) ; public static final OptionTag PRECONDITION = register ( \"precondition\" ) ; public static final OptionTag PREF = register ( \"pref\" ) ; public static final OptionTag PRIVACY = register ( \"privacy\" ) ; public static final OptionTag RECIPIENT_LIST_INVITE = register ( \"recipient-list-invite\" ) ; public static final OptionTag RECIPIENT_LIST_MESSAGE = register ( \"recipient-list-message\" ) ; public static final OptionTag RECIPIENT_LIST_SUBSCRIBE = register ( \"recipient-list-subscribe\" ) ; public static final OptionTag REPLACES = register ( \"replaces\" ) ; public static final OptionTag RESOURCE_PRIORITY = register ( \"resource-priority\" ) ; public static final OptionTag SDP_ANAT = register ( \"sdp-anat\" ) ; public static final OptionTag SEC_AGREE = register ( \"sec-agree\" ) ; public static final OptionTag T_DIALOG = register ( \"tdialog\" ) ; public static final OptionTag TAG_100REL = register ( \"100rel\" ) ; public static final OptionTag TIMER = register ( \"timer\" ) ; private static Map < String , OptionTag > getOptionTags ( ) { if ( _optionTags == null ) { _optionTags = new HashMap < String , OptionTag > ( ) ; } return _optionTags ; } public static synchronized OptionTag register ( String name ) { if ( ! getOptionTags ( ) . containsKey ( name ) ) { final OptionTag tag = new OptionTag ( name ) ; getOptionTags ( ) . put ( name , tag ) ; } return getOptionTags ( ) . get ( name ) ; } public static OptionTag valueOf ( String name ) { OptionTag result = null ; if ( ( name != null ) && ! name . equals ( \"\" ) ) { result = getOptionTags ( ) . get ( name ) ; if ( result == null ) { result =", "gt": "new OptionTag ( name ) ;", "prediction": ";\n", "label": 1}
{"id": 197, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Task extends Property , TaskAttribute { String getId ( ) ;", "gt": "void setId ( String value ) ;", "prediction": "}\n", "label": 0}
{"id": 9346, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . jface . fieldassist . ControlDecoration ; import org . eclipse . jface . fieldassist . FieldDecorationRegistry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Text ; public class ControlDecorationTab extends ExampleTab { private final class LoggingSelectionListener implements SelectionListener { public void widgetSelected ( SelectionEvent event ) { log ( \"widgetSelected: \" + event . toString ( ) ) ; } public void widgetDefaultSelected ( SelectionEvent event ) { log ( \"widgetDefaultSelected: \" + event . toString ( ) ) ; } } private static final String PROP_SELECTION_LISTENER = \"selectionListener\" ; private boolean showOnlyOnFocus ; private boolean showHover = true ; private String description = \"Description\" ; private final ControlDecoration [ ] decorations = new ControlDecoration [ 2 ] ; private final SelectionListener listener ; public ControlDecorationTab ( ) { super ( \"ControlDecoration\" ) ; listener = new LoggingSelectionListener ( ) ; } @ Override protected void createStyleControls ( Composite parent ) { createStyleButton ( \"TOP\" , SWT . TOP ) ; createStyleButton ( \"BOTTOM\" , SWT . BOTTOM ) ; createStyleButton ( \"LEFT\" , SWT . LEFT ) ; createStyleButton ( \"RIGHT\" , SWT . RIGHT ) ; createChangeDescriptionButton ( parent ) ; createShowOnlyOnFocus ( parent ) ; createShowHover ( parent ) ; createPropertyCheckbox ( \"Add Selection Listener\" , PROP_SELECTION_LISTENER ) ; } @ Override protected void createExampleControls ( Composite parent ) { GridLayout groupLayout = new GridLayout ( 2 , false ) ; groupLayout . horizontalSpacing = 10 ; groupLayout . marginRight = 10 ; parent . setLayout ( groupLayout ) ; decorations [ 0 ] = createStaticExample ( parent ) ; decorations [ 1 ] = createDynamicExample ( parent ) ; configureDecorations ( ) ; } private ControlDecoration createStaticExample ( Composite parent ) { Label label = new Label ( parent , SWT . NONE ) ; label . setText ( \"Static decoration: \" ) ; Text text = new Text ( parent , SWT . SINGLE | SWT . BORDER ) ; GridData", "gt": "data = new GridData ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3013, "input": "<s> package org . ofbiz . webapp . event ; import java . io . IOException ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; import com . sun . syndication . feed . WireFeed ; import com . sun . syndication . io . FeedException ; import com . sun . syndication . io . WireFeedOutput ; public class RomeEventHandler implements EventHandler { public static final String module = RomeEventHandler . class . getName ( ) ; public static final String mime = \"application/xml; charset=UTF-8\" ; public static final String defaultFeedType = \"rss_2.0\" ; protected RequestHandler handler ; protected ServletContext context ; protected EventHandler service ; protected WireFeedOutput out ; public void init ( ServletContext context ) throws EventHandlerException { this . context = context ; this . handler = ( RequestHandler ) context . getAttribute ( \"_REQUEST_HANDLER_\" ) ; if ( this . handler == null ) { throw new EventHandlerException ( \"No request handler found in servlet context!\" ) ; } this . service = new ServiceEventHandler ( ) ; this . service . init ( context ) ; this . out = new WireFeedOutput ( ) ; } public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse response ) throws EventHandlerException { String entryLinkReq = request . getParameter ( \"entryLinkReq\" ) ; String mainLinkReq = request . getParameter ( \"mainLinkReq\" ) ; String entryLink = handler . makeLink ( request , response , entryLinkReq , true , false , false ) ; String mainLink = handler . makeLink ( request , response , mainLinkReq , true , false , false ) ; request . setAttribute ( \"entryLink\" , entryLink ) ; request . setAttribute ( \"mainLink\" , mainLink ) ; String feedType = request . getParameter ( \"feedType\" ) ; if ( feedType == null ) { request", "gt": ". setAttribute ( \"feedType\" , defaultFeedType ) ;", "prediction": ";\n", "label": 0}
{"id": 9355, "input": "<s> package org . nuxeo . ecm . automation . client . model ; public class PathRef extends DocRef { private static final long serialVersionUID = 1L ; public PathRef ( String path ) { super ( path ) ; } public String value ( ) { return ref ; } public PathRef getParent ( ) { if ( ref . length ( ) == 0 || ref . equals ( \"/\" ) ) { return null ; } String path = ref ; if ( path . endsWith ( \"/\" ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } int p = path . lastIndexOf ( '/' ) ; if ( p == - 1 ) { return new PathRef ( \"/\" ) ; } else { return new PathRef ( path . substring ( 0 , p ) ) ; } } public", "gt": "PathRef getChild ( String childPath )", "prediction": "}\n", "label": 1}
{"id": 1091, "input": "<s> package org . parboiled . common ; public class StringBuilderSink implements Sink < String > { public final StringBuilder builder = new StringBuilder ( ) ; public void receive ( String value ) { builder . append ( value ) ; } @ Override public String toString ( ) {", "gt": "return builder . toString ( ) ;", "prediction": "\n", "label": 0}
{"id": 9379, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class Tasks_BinderImpl_GenBundle_default_StaticClientBundleGenerator implements org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenBundle { private static Tasks_BinderImpl_GenBundle_default_StaticClientBundleGenerator _instance0 = new Tasks_BinderImpl_GenBundle_default_StaticClientBundleGenerator ( ) ; private void styleInitializer ( ) { style = new org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenCss_style ( ) { private boolean injected ; public boolean ensureInjected ( ) { if ( ! injected ) { injected = true ; com . google . gwt . dom . client . StyleInjector . inject ( getText ( ) ) ; return true ; } return false ; } public String getName ( ) { return \"style\" ; } public String getText ( ) { return ( \".GL0P3EKCOJ{padding:\" + ( \"0.5em\" ) + \";line-height:\" + ( \"150%\" ) + \";}.GL0P3EKCNJ{display:\" + ( \"block\" ) + \";}\" ) ; } public java . lang . String item ( ) { return \"GL0P3EKCNJ\" ; } public java . lang . String tasks ( ) { return \"GL0P3EKCOJ\" ; } } ; } private static class styleInitializer { static { _instance0 . styleInitializer ( ) ; } static org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenCss_style get ( ) { return style ; } } public org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenCss_style style ( ) { return styleInitializer . get ( ) ; } private static java . util . HashMap < java . lang . String , com . google . gwt . resources . client . ResourcePrototype > resourceMap ; private static org . restlet . example . book . restlet . ch09 . client . Tasks_BinderImpl_GenCss_style style ; public ResourcePrototype [ ] getResources ( ) { return new ResourcePrototype [ ] { style ( ) , } ; } public ResourcePrototype getResource ( String name ) { if (", "gt": "GWT . isScript ( ) )", "prediction": ")\n", "label": 1}
{"id": 2874, "input": "<s> package com . redhat . ceylon . ceylondoc ; import static com . redhat . ceylon . ceylondoc . Util . getDoc ; import static com . redhat . ceylon . ceylondoc . Util . getModifiers ; import java . io . IOException ; import java . io . Writer ; import java . util . Iterator ; import java . util . List ; import com . redhat . ceylon . compiler . typechecker . model . Annotation ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . Functional ; import com . redhat . ceylon . compiler . typechecker . model . FunctionalParameter ; import com . redhat . ceylon . compiler . typechecker . model . Method ; import com . redhat . ceylon . compiler . typechecker . model . MethodOrValue ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . ParameterList ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . TypeParameter ; public abstract class ClassOrPackageDoc extends CeylonDoc { public ClassOrPackageDoc ( Module module , CeylonDocTool tool , Writer writer ) { super ( module , tool , writer ) ; } protected void writeSee ( Declaration decl ) throws IOException { Annotation see = Util . getAnnotation ( decl , \"see\" ) ; if ( see == null ) return ; boolean first = true ; open ( \"div class='see'\" ) ; write ( \"See also: \" ) ; for ( String target : see . getPositionalArguments ( ) ) { if ( ! first ) { write ( \", \" ) ; } else { first = false ; } linkRenderer ( ) . to ( target ) . useScope ( decl ) . write ( ) ; } close ( \"div\" ) ; } protected void doc ( MethodOrValue d ) throws IOException { open ( \"tr class='TableRowColor'\" ) ; open ( \"td id='\" + d . getName ( ) + \"'\" , \"code\" ) ; writeIcon ( d ) ; around ( \"span class='modifiers'\" , getModifiers ( d ) ) ; write ( \" \" ) ; linkRenderer ( ) . to ( d . getType ( ) ) . write ( ) ; close ( \"code\" , \"td\" ) ; open ( \"td\" ) ; writeLinkSource ( d ) ; writeTagged ( d ) ; open ( \"code\" ) ; write ( d . getName ( ) ) ; if ( d instanceof Method ) { Method m = ( Method ) d ; writeTypeParameters ( m ) ; writeParameterList ( m ) ; } close ( \"code\" ) ; writeDescription ( d ) ; close ( \"td\" ) ; close ( \"tr\" ) ; } protected void writeDescription ( Declaration d ) throws IOException { open ( \"div class='description'\" ) ; writeDeprecated ( d ) ; around ( \"div class='doc'\" , getDoc ( d , linkRenderer ( ) ) ) ; if ( d instanceof MethodOrValue ) { writeParameters ( d ) ; writeThrows ( d ) ; writeSee ( d ) ; writeBy ( d ) ; } close ( \"div\" ) ; } private void writeLinkSource ( MethodOrValue m ) throws IOException { if ( ! tool . isIncludeSourceCode ( ) ) { return ; } String srcUrl ; if ( m . isToplevel ( ) ) { srcUrl = linkRenderer ( ) . getSrcUrl ( m ) ; } else { srcUrl = linkRenderer ( ) . getSrcUrl ( m . getContainer ( ) ) ; } int [ ] lines = tool . getDeclarationSrcLocation ( m ) ; if ( lines != null ) { open ( \"a class='link-source-code member' href='\" + srcUrl + \"#\" + lines [ 0 ] + \",\" + lines [ 1 ] + \"'\" ) ; write ( \"<i class='icon-source-code'></i>\" ) ; write ( \"Source Code\" ) ; close ( \"a\" ) ; } } private void writeTypeParameters ( Method m ) throws IOException { List < TypeParameter > typeParameters = m . getTypeParameters ( ) ; if ( ! typeParameters . isEmpty ( ) ) { write ( \"&lt;\" ) ; boolean first = true ; for ( TypeParameter type : typeParameters ) { if ( first ) first = false ; else write ( \", \" ) ; write ( type . getName ( ) ) ; } write ( \"&gt;\" ) ; } } protected void writeParameterList ( Functional f ) throws IOException { for ( ParameterList lists : f . getParameterLists ( ) ) { write ( \"(\" ) ; boolean first = true ; for ( Parameter param : lists . getParameters ( ) ) { if ( ! first ) { write ( \", \" ) ; } else { first = false ; } if ( param instanceof FunctionalParameter ) { writeFunctionalParameter ( (", "gt": "FunctionalParameter ) param ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9382, "input": "<s> package org . apache . lucene . ant ; import org . apache . lucene . document . Document ; import java . io . File ; public interface DocumentHandler { Document getDocument (", "gt": "File file ) throws DocumentHandlerException ;", "prediction": ") ;\n", "label": 1}
{"id": 5816, "input": "<s> package org . jboss . arquillian . android . example ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . android . api . AndroidDeviceOutputReciever ; import org . jboss . arquillian . android . api . AndroidExecutionException ; import org . jboss . arquillian . junit . Arquillian ; import org . jboss . arquillian . test . api . ArquillianResource ; import org . junit . Assert ; import org . junit . Test ; import org . junit . runner . RunWith ; @ RunWith ( Arquillian . class ) public class AndroidApkInstallationTestCase { private final String INSTALLED_PACKAGES_CMD = \"pm list packages\" ; private final String CALCULATOR_APP = \"com.calculator\" ; @ ArquillianResource AndroidDevice device ; @ Test public void installAndUninstallApk ( ) throws AndroidExecutionException { device . installPackage ( new File ( \"src/test/apk/calculator.apk\" ) , true ) ; List < String > installedApps = getInstalledPackages ( device ) ; Assert . assertTrue ( \"Calculator app was installed\" , installedApps . contains ( CALCULATOR_APP ) ) ; device . uninstallPackage ( CALCULATOR_APP ) ; installedApps = getInstalledPackages ( device ) ; Assert . assertFalse ( \"Calculator app was uninstalled\" , installedApps . contains ( CALCULATOR_APP ) ) ; } public List < String > getInstalledPackages ( AndroidDevice device ) throws AndroidExecutionException { final List < String > output = new ArrayList < String > ( ) ; device . executeShellCommand ( INSTALLED_PACKAGES_CMD , new AndroidDeviceOutputReciever ( ) { @ Override public void", "gt": "processNewLines ( String [ ] lines )", "prediction": "( )\n", "label": 0}
{"id": 9384, "input": "<s> package org . restlet . test ; import java . io . File ; import java . io . FileWriter ; import org . restlet . Application ; import org . restlet . Client ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . LocalReference ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . engine . io . BioUtils ; import org . restlet . resource . Directory ; public class TemplateFilterTestCase extends RestletTestCase { private static class MyFreemakerApplication extends Application { File testDirectory ; Directory directory ; public MyFreemakerApplication ( File testDirectory ) { setTestDirectory ( testDirectory ) ; } @ Override public Restlet createInboundRoot ( ) { this . directory = new Directory ( getContext ( ) , LocalReference . createFileReference ( getTestDirectory ( ) ) ) ; this . directory . setNegotiatingContent ( true ) ; return new org . restlet . ext . freemarker . TemplateFilter ( getContext ( ) , this . directory ) ; } public File getTestDirectory ( ) { return this . testDirectory ; } public void setTestDirectory ( File testDirectory ) { this . testDirectory = testDirectory ; } } private static class MyVelocityApplication extends Application { File testDirectory ; Directory directory ; public MyVelocityApplication ( File testDirectory ) { setTestDirectory ( testDirectory ) ; } @ Override public Restlet createInboundRoot ( ) { this . directory = new Directory ( getContext ( ) , LocalReference . createFileReference ( getTestDirectory ( ) ) ) ; this . directory . setNegotiatingContent ( true ) ; return new org . restlet . ext . velocity . TemplateFilter ( getContext ( ) , this . directory ) ; } public File getTestDirectory ( ) { return this . testDirectory ; } public void setTestDirectory ( File testDirectory ) { this . testDirectory = testDirectory ; } } File testDir ; public void testTemplateFilter ( ) { try { this . testDir = new File ( System . getProperty ( \"java.io.tmpdir\" ) , \"TemplateFilterTestCase\" ) ; BioUtils . delete ( this . testDir , true ) ; this . testDir . mkdir ( ) ; File testFileFm1 = new File ( this . testDir , \"testFm1.txt.fmt\" ) ; FileWriter fw = new FileWriter ( testFileFm1 ) ; fw . write ( \"Method=${m}/Authority=${ra}\" ) ; fw . close ( ) ; File testFileFm2 = new File ( this . testDir , \"testFm2.txt\" ) ; fw = new FileWriter ( testFileFm2 ) ; fw . write ( \"Method=${m}/Authority=${ra}\" ) ; fw . close ( ) ; File testFileVl1 = new File ( this . testDir , \"testVl1.txt.vm\" ) ; fw = new FileWriter ( testFileVl1 ) ; fw . write ( \"Method=${m}/Path=${rp}\" ) ; fw . close ( ) ; File testFileVl2 = new File ( this . testDir , \"testVl2.txt\" ) ; fw = new FileWriter ( testFileVl2 ) ; fw . write ( \"Method=${m}/Path=${rp}\" ) ; fw . close ( ) ; Component component = new Component ( ) ; component . getServers ( ) . add ( Protocol . HTTP , TEST_PORT ) ; component . getClients ( ) . add ( Protocol . FILE ) ; MyFreemakerApplication freemarkerApplication = new MyFreemakerApplication ( this . testDir ) ; MyVelocityApplication velocityApplication = new MyVelocityApplication ( this . testDir ) ; component . getDefaultHost ( ) . attach ( \"/freemarker\" , freemarkerApplication ) ; component . getDefaultHost ( ) . attach ( \"/velocity\" , velocityApplication ) ; component . start ( ) ; freemarkerApplication . getTunnelService ( ) . setExtensionsTunnel ( true ) ; velocityApplication . getTunnelService ( ) . setExtensionsTunnel ( true ) ; Client client = new Client ( Protocol . HTTP ) ; Response response = client . handle ( new Request ( Method . GET , \"http://localhost:\" + TEST_PORT + \"/freemarker/\" + testFileFm1 . getName ( ) ) ) ; if ( response . isEntityAvailable ( ) ) { assertEquals ( \"Method=GET/Authority=localhost:\" + TEST_PORT , response . getEntity ( ) . getText ( ) ) ; } response = client . handle ( new Request ( Method . GET , \"http://localhost:\" + TEST_PORT + \"/freemarker/\" + testFileFm2 . getName ( ) ) ) ; assertTrue ( response . getStatus ( ) . isSuccess ( ) ) ; if ( response . isEntityAvailable ( ) ) { assertEquals ( \"Method=${m}/Authority=${ra}\" , response . getEntity ( ) . getText ( ) ) ; } response = client . handle ( new Request ( Method . GET , \"http://localhost:\" + TEST_PORT + \"/velocity/\" + testFileVl1 . getName ( ) ) ) ; if ( response . isEntityAvailable ( ) ) { assertEquals ( \"Method=GET/Path=/velocity/testVl1\" , response . getEntity ( ) . getText ( ) ) ; } response = client . handle ( new Request ( Method . GET , \"http://localhost:\" + TEST_PORT + \"/velocity/\" +", "gt": "testFileVl2 . getName ( ) ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7773, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Zombie ; public interface LizaZombie extends Zombie { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities ( double", "gt": "x , double y , double z ) ;", "prediction": ")\n", "label": 0}
{"id": 9404, "input": "<s> package org . eclipse . ui . tests . dynamicplugins ; import java . lang . ref . ReferenceQueue ; import java . lang . ref . WeakReference ; import junit . framework . TestCase ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . dynamichelpers . ExtensionTracker ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . ui . tests . leaks . LeakTests ; public class DynamicSupportTests extends TestCase { private IExtensionTracker tracker ; private IExtension e1 , e2 ; private Object o1 , o2 ; public DynamicSupportTests ( String name ) { super ( name ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; tracker = new ExtensionTracker ( ) ; IExtension [ ] elements = Platform . getExtensionRegistry ( ) . getExtensionPoint ( \"org.eclipse.ui.views\" ) . getExtensions ( ) ; assertNotNull ( elements ) ; assertFalse ( elements . length < 2 ) ; e1 = elements [ 0 ] ; e2 = elements [ 1 ] ; o1 = new Object ( ) ; o2 = new WeakReference ( o1 ) ; } protected void tearDown ( ) throws Exception { super . tearDown ( ) ; ( ( ExtensionTracker ) tracker ) . close ( ) ; } public void testConfigurationElementTracker1 ( ) { tracker . registerObject ( e1 , o1 , IExtensionTracker . REF_WEAK ) ; Object [ ] results = tracker . getObjects ( e1 ) ; assertNotNull ( results ) ; assertEquals ( 1 , results . length ) ; assertEquals ( o1 , results [ 0 ] ) ; } public void testConfigurationElementTracker2 ( ) throws Exception { tracker . registerObject ( e1 , o1 , IExtensionTracker . REF_WEAK ) ; ReferenceQueue queue = new ReferenceQueue ( ) ; WeakReference ref = new WeakReference ( o1 , queue ) ; o1 = null ; LeakTests . checkRef ( queue , ref ) ; Object [ ] results = tracker . getObjects ( e1 ) ; assertNotNull ( results ) ; assertEquals ( 0 , results . length ) ; } public void testConfigurationElementTracker3 ( ) { tracker . registerObject ( e2 , o2 ,", "gt": "IExtensionTracker . REF_WEAK ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9708, "input": "<s> package com . mobeelizer . mobile . android . types ; import static com . mobeelizer . java . model . MobeelizerReflectionUtil . setValue ; import java . util . Map ; import android . content . ContentValues ; import android . database . Cursor ; import com . mobeelizer . java . api . MobeelizerErrorsBuilder ; import com . mobeelizer . java . definition . MobeelizerFieldType ; import com . mobeelizer . java . model . MobeelizerFieldAccessor ; public class IntegerFieldTypeHelper extends FieldTypeHelper { public IntegerFieldTypeHelper ( ) { super ( MobeelizerFieldType . INTEGER ) ; } @ Override protected void setNotNullValueFromEntityToDatabase ( final ContentValues values , final Object value , final MobeelizerFieldAccessor field , final Map < String , String > options , final MobeelizerErrorsBuilder errors ) { Long longValue = ( Long ) getType ( ) . convertFromEntityValueToDatabaseValue ( field , value , options , errors ) ; if ( ! errors . hasNoErrors ( ) ) { return ; } values . put ( field . getName ( ) , longValue ) ; } @ Override protected void setNullValueFromEntityToDatabase ( final ContentValues values , final MobeelizerFieldAccessor field , final Map < String , String > options , final MobeelizerErrorsBuilder errors ) { values . put ( field . getName ( ) , ( Long ) null ) ; } @ Override protected < T > void setNotNullValueFromDatabaseToEntity ( final Cursor cursor , final int columnIndex , final T entity , final MobeelizerFieldAccessor field , final Map < String , String > options ) { setValue ( field , entity , getType ( ) . convertFromDatabaseValueToEntityValue ( field , cursor . getLong ( columnIndex ) ) ) ; } @ Override protected String [ ] getTypeDefinition ( final MobeelizerFieldAccessor field , final boolean required , final Object defaultValue , final Map < String , String > options ) { int length = Integer . toString ( getMaxValue ( options ) ) . length ( ) ; return new String [ ] { getSingleDefinition ( field . getName ( ) , \"INTEGER(\" + length + \")\" , required , defaultValue == null ? null : Long . toString ( ( Long ) defaultValue ) , false ) } ; } @ Override protected void setNotNullValueFromDatabaseToMap ( final Cursor cursor , final int columnIndex , final Map < String , String > values , final MobeelizerFieldAccessor field , final Map < String , String > options ) { values . put ( field . getName ( ) , Long . toString ( cursor . getLong ( columnIndex ) ) ) ; } @ Override protected void setNullValueFromDatabaseToMap ( final Cursor cursor , final int columnIndex , final Map < String , String > values , final MobeelizerFieldAccessor field , final Map < String , String > options ) { values . put ( field", "gt": ". getName ( ) , null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9409, "input": "<s> package org . apache . lucene . analysis . sinks ; import java . io . IOException ; import java . io . StringReader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . TeeSinkTokenFilter ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . TeeSinkTokenFilter . SinkTokenStream ; public class TokenRangeSinkTokenizerTest extends BaseTokenStreamTestCase { public TokenRangeSinkTokenizerTest ( String s ) { super ( s ) ; } public void test ( ) throws IOException { TokenRangeSinkFilter sinkFilter = new TokenRangeSinkFilter ( 2 , 4 ) ; String test = \"The quick red fox jumped over the lazy brown dogs\" ; TeeSinkTokenFilter tee = new TeeSinkTokenFilter ( new WhitespaceTokenizer ( new StringReader ( test ) ) ) ; SinkTokenStream rangeToks = tee . newSinkTokenStream ( sinkFilter ) ; int count = 0 ; tee . reset ( ) ; while ( tee . incrementToken ( ) ) { count ++ ; } int sinkCount = 0 ; rangeToks . reset ( ) ; while ( rangeToks . incrementToken ( ) ) { sinkCount ++ ; } assertTrue ( count + \" does not equal:", "gt": "\" + 10 , count == 10 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6632, "input": "<s> public class TestSuperClassInSerialForm extends JavadocTester { private static final String BUG_ID = \"4671694\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"serialized-form.html\" , \"<a href=\\\"pkg/SubClass.html\\\" title=\\\"class in pkg\\\">pkg.SubClass</a> extends <a href=\\\"pkg/SuperClass.html\\\" title=\\\"class in pkg\\\">SuperClass</a>\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\"", "gt": ", SRC_DIR , \"pkg\" }", "prediction": ") ;\n", "label": 0}
{"id": 9412, "input": "<s> package highscore ; import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import javax . swing . JOptionPane ; import gui . MainPanel ; public class HighScore { private MainPanel panel ; private ArrayList < Score > highscore ; private String filename ; private String defaultName ; private ObjectOutputStream outputStream = null ; private ObjectInputStream inputStream = null ; public HighScore ( MainPanel panel , String filename ) { this . panel = panel ; this . filename = filename ; highscore = new ArrayList < Score > ( ) ; defaultName = new String ( \"xyzzy\" ) ; } public ArrayList < Score > getHighScore ( ) { return highscore ; } public void addScore ( String name , int pts ) { loadScoreFile ( ) ; highscore . add ( new Score ( name , pts ) ) ; updateScoreFile ( ) ; } public ArrayList < Score > getScores ( ) { loadScoreFile ( ) ; sort ( ) ; return highscore ; } @ SuppressWarnings ( \"unchecked\" ) public void loadScoreFile ( ) { try { inputStream = new ObjectInputStream ( new FileInputStream ( filename ) ) ; highscore = ( ArrayList < Score > ) inputStream . readObject ( ) ; } catch ( FileNotFoundException e ) { this . updateScoreFile ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"IO Error\" , JOptionPane . ERROR_MESSAGE ) ; } catch ( ClassNotFoundException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"ClassNotFound Error\" , JOptionPane . ERROR_MESSAGE ) ; } finally { try { if ( outputStream != null ) { outputStream . flush ( ) ; outputStream . close ( ) ; } } catch ( IOException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"IO Error\" , JOptionPane . ERROR_MESSAGE ) ; } } } public void updateScoreFile ( ) { try { outputStream = new ObjectOutputStream ( new FileOutputStream ( filename ) ) ; outputStream . writeObject ( highscore ) ; } catch ( FileNotFoundException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"File Not Found\" , JOptionPane . ERROR_MESSAGE ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"IO Error\" , JOptionPane . ERROR_MESSAGE ) ; } finally { try { if ( outputStream != null ) { outputStream . flush ( ) ; outputStream . close ( ) ; } } catch ( IOException e ) { JOptionPane . showMessageDialog ( panel , e . getMessage ( ) , \"IO Error\" , JOptionPane . ERROR_MESSAGE ) ; } } } public String getHighscoreString ( ) { String highscoreString = \"\" ; int max = 10 ; ArrayList < Score > highscore ; highscore = getScores ( ) ; int i = 0 ; int x = highscore . size ( ) ; if ( x > max ) { x = max ; } while ( i < x ) { highscoreString += ( i + 1 ) + \"\\t\" + highscore . get ( i ) . getName ( ) + \"\\t\" + highscore . get ( i ) . getScore ( ) + \"\\n\" ; i ++ ; } return highscoreString ; } public void gameOver ( int myScore ) { if ( madeTheListCheck ( myScore ) ) { enterName ( myScore ) ; } } private void sort ( ) { Collections . sort ( highscore ) ; } private boolean madeTheListCheck ( int myScore ) { boolean madeIt = false ; if ( highscore . isEmpty ( ) ) { madeIt = true ; } for ( Score s : highscore ) { if ( myScore > s . getScore ( ) ) { madeIt = true ; break ; } } return madeIt ; } private void enterName ( int myScore ) { String name = JOptionPane . showInputDialog ( panel , \"Enter you", "gt": "name\" , defaultName ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7429, "input": "<s> package next . interfaces . controller . animation ; import next . i . controller . XController ; import next . i . view . XBarItem . Type ; import next . i . view . widgets . XFlexTable ; import next . interfaces . controller . DemoUtils ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . user . client . ui . Image ; import com . google . gwt . user . client . ui . IsWidget ; public class VerticalController extends XController { public VerticalController ( ) { setTitle ( \"Vertical Scroll\" ) ; getNavigationBar ( ) . setLeftTitle ( \"Back\" , Type . BACK_BUTTON ) ; getNavigationBar ( ) . getLeftButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { getNavigationController ( ) . popController ( true ) ; } } ) ;", "gt": "getNavigationBar ( ) . setRightTitle ( \"Source\" ) ;", "prediction": "}\n", "label": 0}
{"id": 9413, "input": "<s> package org . eclipse . rap . rwt . internal . protocol ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap . rwt . internal . protocol . ClientMessage . CallOperation ; import org . eclipse . rap . rwt . internal . protocol . ClientMessage . NotifyOperation ; import org . eclipse . rap . rwt . internal . protocol . ClientMessage . SetOperation ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer . IInstanceCreator ; import org . eclipse . rap . rwt . service . IServiceStore ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . graphics . FontUtil ; import org . eclipse . swt . internal . graphics . ImageFactory ; public final class ProtocolUtil { private static final Pattern FONT_NAME_FILTER_PATTERN = Pattern . compile ( \"\\\"|\\\\\\\\\" ) ; private static final String CLIENT_MESSAGE = ProtocolUtil . class . getName ( ) + \"#clientMessage\" ; private final static SharedInstanceBuffer < String , String [ ] > parsedFonts = new SharedInstanceBuffer < String , String [ ] > ( ) ; private ProtocolUtil ( ) { } public static ClientMessage getClientMessage ( ) { IServiceStore serviceStore = ContextProvider . getServiceStore ( ) ; ClientMessage clientMessage = ( ClientMessage ) serviceStore . getAttribute ( CLIENT_MESSAGE ) ; if ( clientMessage == null ) { HttpServletRequest request = ContextProvider . getRequest ( ) ; StringBuilder json = new StringBuilder ( ) ; try { InputStreamReader inputStreamReader = new InputStreamReader ( request . getInputStream ( ) ) ; BufferedReader reader = new BufferedReader ( inputStreamReader ) ; String line = reader . readLine ( ) ; while ( line != null ) { json . append ( line + \"\\n\" ) ; line = reader . readLine ( ) ; } reader . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( \"Unable to read the json message\" ) ; } clientMessage = new ClientMessage ( json . toString ( ) ) ; serviceStore . setAttribute ( CLIENT_MESSAGE , clientMessage ) ; } return clientMessage ; } public static void setClientMessage ( ClientMessage clientMessage ) { IServiceStore serviceStore = ContextProvider . getServiceStore ( ) ; serviceStore . setAttribute ( CLIENT_MESSAGE , clientMessage ) ; } public static boolean isClientMessageProcessed ( ) { IServiceStore serviceStore = ContextProvider . getServiceStore ( ) ; return serviceStore . getAttribute ( CLIENT_MESSAGE ) != null ; } public static String readHeadPropertyValue ( String property ) { ClientMessage message = getClientMessage ( ) ; Object result = message . getHeadProperty ( property ) ; return result == null ? null : result . toString ( ) ; } public static Object readPropertyValue ( String target , String property ) { Object result = null ; ClientMessage message = getClientMessage ( ) ; SetOperation operation = message . getLastSetOperationFor ( target , property ) ; if ( operation != null ) { result = operation . getProperty ( property ) ; } return result ; } public static String readPropertyValueAsString ( String target , String property ) { return readPropertyValueAs ( target , property , String . class ) ; } public static Point readPropertyValueAsPoint ( String target , String property ) { return readPropertyValueAs ( target , property , Point . class ) ; } public static Rectangle readPropertyValueAsRectangle ( String target , String property ) { return readPropertyValueAs ( target , property , Rectangle . class ) ; } public static int [ ] readPropertyValueAsIntArray ( String target , String property ) { return readPropertyValueAs ( target , property , int [ ] . class ) ; } public static boolean [ ] readPropertyValueAsBooleanArray ( String target , String property ) { return readPropertyValueAs ( target , property , boolean [ ] . class ) ; } public static String [ ] readPropertyValueAsStringArray ( String target , String property ) { return readPropertyValueAs ( target , property , String [ ] . class ) ; } @ SuppressWarnings ( \"unchecked\" ) private static < T > T readPropertyValueAs ( String target , String property , Class < T > clazz ) { T result = null ; ClientMessage message = getClientMessage ( ) ; SetOperation operation = message . getLastSetOperationFor ( target , property ) ; if ( operation != null ) { Object value = operation . getProperty ( property ) ; if ( value != null ) { if ( String . class . equals ( clazz ) ) { result = ( T ) value . toString ( ) ; } else if ( Point . class . equals ( clazz ) ) { result = ( T ) toPoint ( value ) ; } else if ( Rectangle . class . equals ( clazz ) ) { result = ( T ) toRectangle ( value ) ; } else if ( int [ ] . class . equals ( clazz ) ) { result = ( T ) toIntArray ( value ) ; } else if ( boolean [ ] . class . equals ( clazz ) ) { result = ( T ) toBooleanArray ( value ) ; } else if ( String [ ] . class . equals ( clazz ) ) { result = ( T ) toStringArray ( value ) ; } else { throw new IllegalStateException ( \"Could not convert property to \" + clazz . getName ( ) ) ; } } } return result ; } public static String readEventPropertyValueAsString ( String target , String eventName , String property ) { String result = null ; ClientMessage message = getClientMessage ( ) ; NotifyOperation operation =", "gt": "message . getLastNotifyOperationFor ( target , eventName ) ;", "prediction": ";\n", "label": 1}
{"id": 2679, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Definitions ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class DefinitionsImpl extends ExportAttributeImpl implements Definitions { protected static final boolean ALL_EDEFAULT = false ; protected boolean all = ALL_EDEFAULT ; protected static final boolean NONE_EDEFAULT = false ; protected boolean none = NONE_EDEFAULT ; protected DefinitionsImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getDefinitions ( ) ; } public boolean isAll ( ) { return all ; } public void setAll ( boolean newAll ) { boolean oldAll = all ; all = newAll ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . DEFINITIONS__ALL , oldAll , all ) ) ; } public boolean isNone ( ) { return none ; } public void setNone ( boolean newNone ) { boolean oldNone = none ; none = newNone ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . DEFINITIONS__NONE , oldNone , none ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . DEFINITIONS__ALL : return isAll ( ) ; case ProjectPackage . DEFINITIONS__NONE : return isNone ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @", "gt": "Override public void eSet ( int featureID , Object newValue )", "prediction": "}\n", "label": 0}
{"id": 9423, "input": "<s> package com . orange . place . helper ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . json . JSONArray ; import org . json . JSONObject ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . database . sqlite . SQLiteQueryBuilder ; import android . util . Log ; import com . orange . place . constant . DBConstants ; import com . orange . place . constant . ErrorCode ; import com . orange . place . constants . Constants ; public class SqlLiteHelper extends SQLiteOpenHelper { private static final String LOG_EMPTY_LIST = \"Get an empty list, will not clear and update old list\" ; private static final String LOG_STORING_DATA_ERROR = \"Storing data error!\" ; private static final String LOG_ERROR_NO_DATA = \"No data found for DB to store, will just ignore!\" ; private static SQLiteDatabase writableDb = null ; public SqlLiteHelper ( Context context ) { super ( context , Constants . SQLITE_DB_NAME , null , Constants . SQLITE_DB_VERSION ) ; } @ Override public void onCreate ( SQLiteDatabase db ) { Log . v ( Constants . LOG_TAG , \"Creating database\" ) ; try { db . execSQL ( SqlConstants . SQL_CREATE_FOLLOWED_PLACE ) ; db . execSQL ( SqlConstants . SQL_CREATE_NEARBY_PLACE ) ; db . execSQL ( SqlConstants . SQL_CREATE_PLACE_POST ) ; db . execSQL ( SqlConstants . SQL_TABLE_NEARBY_POST ) ; db . execSQL ( SqlConstants . SQL_TABLE_FOLLOWED_POST ) ; db . execSQL ( SqlConstants . SQL_TABLE_REPLIED_POST ) ; } catch ( SQLException e ) { Log . e ( Constants . LOG_TAG , \"Get SQL exception!\" , e ) ; } } @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . w ( Constants . LOG_TAG , \"Upgrading db from version \" + oldVersion + \" to \" + newVersion ) ; this . onCreate ( db ) ; } @ Override public void onOpen ( SQLiteDatabase db ) { super . onOpen ( db ) ; Log . v ( Constants . LOG_TAG , \"Opening database\" ) ; } public int storePlacePosts ( JSONArray jsonArr , String placeId ) { int len = jsonArr . length ( ) ; if ( len <= 0 ) { Log . w ( Constants . LOG_TAG , LOG_ERROR_NO_DATA ) ; return Constants . ERROR_RESP_DATA_EMPTY ; } ContentValues cv = null ; cleanupPlacePosts ( placeId ) ; for ( int i = 0 ; i < len ; i ++ ) { try { cv = MappingHelper . mapJsonToCV_Post ( ( JSONObject ) jsonArr . get ( i ) ) ; getDatabase ( ) . insert ( Constants . TABLE_PLACE_POST , null , cv ) ; } catch ( Exception e ) { Log . e ( Constants . LOG_TAG , LOG_STORING_DATA_ERROR , e ) ; return Constants . ERROR_SQLITE ; } } return ErrorCode . ERROR_SUCCESS ; } public int storeFollowedPlaces ( JSONArray jsonArr ) { return cleanAndStorePlaces ( jsonArr , Constants . TABLE_FOLLOWED_PLACE ) ; } public int storeNearbyPlaces ( JSONArray jsonArr ) { return cleanAndStorePlaces ( jsonArr , Constants . TABLE_NEARBY_PLACE ) ; } private int cleanAndStorePlaces ( JSONArray jsonArr , String table ) { int len = jsonArr . length ( ) ; if ( len <= 0 ) { Log . w ( Constants . LOG_TAG , LOG_ERROR_NO_DATA ) ; return Constants . ERROR_RESP_DATA_EMPTY ; } Log . d ( Constants . LOG_TAG , \"Start to cleanup and store info for table: \" + table ) ; getDatabase ( ) . delete ( table , null , null ) ; ContentValues cv = null ; for ( int i = 0 ; i < len ; i ++ ) { try { cv = MappingHelper . mapJsonToCV_Place ( ( JSONObject ) jsonArr . get ( i ) ) ; getDatabase ( ) . insert ( table , null , cv ) ; } catch ( Exception e ) { Log . e ( Constants . LOG_TAG , LOG_STORING_DATA_ERROR , e ) ; return Constants . ERROR_SQLITE ; } } return ErrorCode . ERROR_SUCCESS ; } public int storeNearbyPosts ( JSONArray jsonArr ) { return cleanAndStorePosts ( jsonArr , Constants . TABLE_NEARBY_POST ) ; } public int storeFollowedPosts ( JSONArray jsonArr ) { return cleanAndStorePosts ( jsonArr , Constants . TABLE_FOLLOWED_POST ) ; } public int storeRepliedPosts ( JSONArray jsonArr ) { return cleanAndStorePosts ( jsonArr , Constants . TABLE_REPLIED_POST ) ; } private int cleanAndStorePosts ( JSONArray jsonArr , String table ) { int len = jsonArr . length ( ) ; if ( len <= 0 ) { Log . w ( Constants . LOG_TAG , LOG_ERROR_NO_DATA ) ; return Constants . ERROR_RESP_DATA_EMPTY ; } Log . d ( Constants . LOG_TAG , \"Start to cleanup and store info for table: \" + table ) ; getDatabase ( ) . delete ( table , null , null ) ; ContentValues cv = null ; for ( int i = 0 ; i < len ; i ++ ) { try { cv = MappingHelper . mapJsonToCV_Post ( ( JSONObject ) jsonArr . get ( i ) ) ; getDatabase ( ) . insert ( table , null , cv ) ; } catch ( Exception e ) { Log . e ( Constants . LOG_TAG , LOG_STORING_DATA_ERROR , e ) ; return Constants . ERROR_SQLITE ; } } return ErrorCode . ERROR_SUCCESS ; } public void cleanupPlacePosts ( String placeId ) { Log . d ( Constants . LOG_TAG , \"Cleanup place posts in DB, where placeId=\" + placeId ) ; String whereClause = DBConstants . F_PLACEID + \"=?\" ; String [ ] whereArgs = new String [ 1 ] ; whereArgs [ 0 ] = placeId ; getDatabase ( ) . delete ( Constants . TABLE_PLACE_POST , whereClause , whereArgs ) ; } public void getPlacePosts ( List < Map < String , Object > > list , String placeId ) { List < Map < String , Object > > tmpList = new ArrayList < Map < String , Object > > ( ) ; Cursor cur = queryPlacePosts ( placeId ) ; while ( cur . moveToNext ( ) ) { tmpList .", "gt": "add ( MappingHelper . mapCursorToMap_Post ( cur ) ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 14, "input": "<s> package com . sensor ; import android . os . Handler ; import android . os . Message ; class SensorDelayHandler extends Handler { MovementService movService = null ; public int delayType = - 1 ; public static final class DelayType { public static final int CALCULATE = 0 ; public static final int SENSOR_UPDATE = 1 ; public static final int DISPLAY_UPDATE = 2 ; } public SensorDelayHandler ( MovementService movService , int delayType ) { super ( ) ; this", "gt": ". delayType = delayType ;", "prediction": ";\n", "label": 0}
{"id": 9429, "input": "<s> package org . eclipse . ui . internal . activities . ws ; import java . util . HashMap ; import java . util . Set ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . dynamichelpers . ExtensionTracker ; import org . eclipse . core . runtime . dynamichelpers . IExtensionChangeHandler ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . ITriggerPoint ; import org . eclipse . ui . activities . ITriggerPointManager ; import org . eclipse . ui . internal . activities . Persistence ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class TriggerPointManager implements ITriggerPointManager , IExtensionChangeHandler { private HashMap triggerMap = new HashMap ( ) ; public TriggerPointManager ( ) { super ( ) ; triggerMap . put ( ITriggerPointManager . UNKNOWN_TRIGGER_POINT_ID , new AbstractTriggerPoint ( ) { public String getId ( ) { return ITriggerPointManager . UNKNOWN_TRIGGER_POINT_ID ; } public String getStringHint ( String key ) { if ( ITriggerPoint . HINT_INTERACTIVE . equals ( key ) ) { return Boolean . TRUE . toString ( ) ; } return null ; } public boolean getBooleanHint ( String key ) { if ( ITriggerPoint . HINT_INTERACTIVE . equals ( key ) ) { return true ; } return false ; } } ) ; IExtensionTracker tracker = PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) ; tracker . registerHandler ( this , ExtensionTracker . createExtensionPointFilter ( getExtensionPointFilter ( ) ) ) ; IExtensionPoint point = getExtensionPointFilter ( ) ; IExtension [ ] extensions = point . getExtensions ( ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { addExtension ( tracker , extensions [ i ] ) ; } } public ITriggerPoint getTriggerPoint ( String id ) { return ( ITriggerPoint ) triggerMap . get ( id ) ; } public Set getDefinedTriggerPointIds ( ) { return triggerMap . entrySet ( ) ; } public void removeExtension ( IExtension extension , Object [ ] objects ) { for ( int i = 0 ; i < objects . length ; i ++ ) { Object object = objects [ i ] ; if ( object instanceof RegistryTriggerPoint ) { triggerMap . remove ( ( ( RegistryTriggerPoint ) object ) . getId ( ) ) ; } } } public void addExtension ( IExtensionTracker tracker , IExtension extension ) { IConfigurationElement [ ] elements = extension . getConfigurationElements ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { IConfigurationElement element = elements [ i ] ; if ( element . getName ( ) . equals ( IWorkbenchRegistryConstants . TAG_TRIGGERPOINT ) ) { String id = element . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ; if ( id == null ) { Persistence . log ( element , Persistence . ACTIVITY_TRIGGER_DESC , \"missing a unique identifier\" ) ; continue ; } RegistryTriggerPoint triggerPoint = new RegistryTriggerPoint ( id , element ) ; triggerMap . put ( id , triggerPoint ) ; tracker . registerObject ( extension , triggerPoint , IExtensionTracker . REF_WEAK ) ; } } } private IExtensionPoint getExtensionPointFilter ( ) { return Platform . getExtensionRegistry ( ) .", "gt": "getExtensionPoint ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_ACTIVITYSUPPORT ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 5726, "input": "<s> package p ; import p . Tree . * ; public class TreeScanner < E extends Throwable > extends Visitor < E > { public void scan ( Tree tree ) throws E { if ( tree != null ) tree", "gt": ". accept ( this ) ;", "prediction": "\n", "label": 0}
{"id": 9438, "input": "<s> package org . nuxeo . ecm . automation . core . operations . services ; import java . io . Serializable ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . lang . StringUtils ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . DocumentModelListImpl ; import org . nuxeo . ecm . platform . relations . api . Node ; import org . nuxeo . ecm . platform . relations . api . QNameResource ; import org . nuxeo . ecm . platform . relations . api . RelationManager ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . ResourceAdapter ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . ecm . platform . relations . api . util . RelationConstants ; @ Operation ( id = GetRelations . ID , category = Constants . CAT_SERVICES , label = \"Get Linked Documents\" , description = \"Get the relations for the input document. The 'outgoing' parameter ca be used to specify whether outgoing or incoming relations should be returned. Retuns a document list.\" ) public class GetRelations { public static final String ID = \"Relations.GetRelations\" ; @ Context protected CoreSession session ; @ Context protected RelationManager relations ; @ Param ( name = \"predicate\" ) protected String predicate ; @ Param ( name = \"outgoing\" , required = false ) protected boolean outgoing = true ; @ Param ( name = \"graphName\" , required = false ) protected String graphName ; @ OperationMethod public DocumentModelList run ( DocumentModel doc ) throws Exception { QNameResource res = getDocumentResource ( doc ) ; Resource predicate = getPredicate ( ) ; return getDocuments ( res , predicate ) ; } protected QNameResource getDocumentResource ( DocumentModel document ) throws ClientException { return ( QNameResource ) relations . getResource ( RelationConstants . DOCUMENT_NAMESPACE ,", "gt": "document , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2899, "input": "<s> package pkg1 ; public class A { public < T > A ( ) { } public < T > void m1 ( T t ) { } public < T extends Number , U > void m2", "gt": "( T t , U u )", "prediction": ")\n", "label": 0}
{"id": 9441, "input": "<s> package org . seage . grammar . iif ; import org . seage . data . DataNode ; import org . seage . grammar . Symbol ; import org . seage . grammar . GrammarRule ; import org . seage . grammar . IntTerminalSymbol ; import org . seage . grammar . NonterminalSymbol ; import java . util . * ; public class FConstGrammarRule extends GrammarRule { private static final long serialVersionUID = - 5052451720529833538L ; public FConstGrammarRule ( int uniqueId ) { super ( new NonterminalSymbol ( \"F\" ) , new Vector < Symbol > ( ) , uniqueId ) ; IntTerminalSymbol it = new IntTerminalSymbol ( \"const\" , uniqueId ) ; it . setDomain ( 0 , 100 ) ; right . add ( it ) ; } public Object eval ( DataNode symbolTable , NonterminalSymbol treePos ) throws Exception { Vector < Symbol > children = treePos . getChildren ( ) ; if ( children . size ( ) != 1 ) throw new Exception ( \"Arity error: expected 1 children, found: \" + children . size ( ) ) ; return children . get ( 0", "gt": ") . eval ( symbolTable ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2590, "input": "<s> package com . sun . mirror . type ; import com . sun . mirror . declaration . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" )", "gt": "public interface TypeVariable extends ReferenceType", "prediction": ";\n", "label": 0}
{"id": 9448, "input": "<s> package commands ; import item . Item ; import actors . Actor ; import engine . Engine ; public class ItemCommand extends SpellCommand { Item item ; public ItemCommand ( Item item , Actor i , Actor [ ] t ) { super ( item . getBattleCommand ( ) , i , t ) ; this . item = item ; } @ Override", "gt": "public void start ( )", "prediction": "}\n", "label": 1}
{"id": 8968, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . util . Collection ; import java . util . ArrayList ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . SourcePosition ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Attribute ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . TypeTags ; @ SuppressWarnings ( \"deprecation\" ) public class AnnotationValueImpl implements AnnotationValue { protected final AptEnv env ; protected final Attribute attr ; protected final AnnotationMirrorImpl annotation ; AnnotationValueImpl ( AptEnv env , Attribute attr , AnnotationMirrorImpl annotation ) { this . env = env ; this . attr = attr ; this . annotation = annotation ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; Constants . Formatter fmtr = Constants . getFormatter ( sb ) ; fmtr . append ( getValue ( ) ) ; return fmtr . toString ( ) ; } public Object getValue ( ) { ValueVisitor vv = new ValueVisitor ( ) ; attr . accept ( vv ) ; return vv . value ; } public SourcePosition getPosition ( ) { return ( annotation == null ) ? null : annotation . getPosition ( ) ; } private class ValueVisitor implements Attribute . Visitor { public Object value ; public void visitConstant ( Attribute . Constant c ) { value = Constants .", "gt": "decodeConstant ( c . value , c . type ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9450, "input": "<s> package org . nuxeo . ecm . automation . core . scripting ; import java . io . Serializable ; import org . nuxeo . ecm . automation . OperationContext ;", "gt": "public interface Expression extends Serializable", "prediction": ";\n", "label": 1}
{"id": 9909, "input": "<s> package org . dawb . workbench . plotting . tools . profile ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import org . dawb . common . ui . menu . CheckableActionGroup ; import org . dawb . common . ui . menu . MenuAction ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . ILineTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . swt . widgets . Display ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . io . IDiffractionMetadata ; import uk . ac . diamond . scisoft . analysis . io . IMetaData ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . SectorROI ; public abstract class SectorProfileTool extends ProfileTool { private MenuAction center ; private IRegionListener sectorRegionListener ; @ Override protected void configurePlottingSystem ( AbstractPlottingSystem plotter ) { this . center = new MenuAction ( \"Center selection\" ) ; center . setImageDescriptor ( Activator . getImageDescriptor ( \"icons/sector-center-menu.png\" ) ) ; getSite ( ) . getActionBars ( ) . getToolBarManager ( ) . add ( center ) ; getSite ( ) . getActionBars ( ) . getMenuManager ( ) . add ( center ) ; updateSectors ( ) ; this . sectorRegionListener = new IRegionListener . Stub ( ) { @ Override public void regionsRemoved ( RegionEvent evt ) { updateSectors ( ) ; } @ Override public void regionRemoved ( RegionEvent evt ) { updateSectors ( ) ; } @ Override public void regionAdded ( RegionEvent evt ) { updateSectors ( ) ; if ( evt . getRegion ( ) != null && evt . getRegion ( ) . getRegionType ( ) == RegionType . SECTOR ) { SectorROI sroi = ( SectorROI ) evt . getRegion ( ) . getROI ( ) . copy ( ) ; sroi . setSymmetry ( preferredSymmetry ) ; sroi . setCombineSymmetry ( preferredCombine ) ; evt . getRegion ( ) . setROI ( sroi ) ; } } } ; final MenuAction symmetry = new MenuAction ( \"Symmetry setting\" ) ; symmetry . setImageDescriptor ( Activator . getImageDescriptor ( \"icons/sector-symmetry-menu.png\" ) ) ; getSite ( ) . getActionBars ( ) . getToolBarManager ( ) . add ( symmetry ) ; getSite ( ) . getActionBars ( ) . getMenuManager", "gt": "( ) . add ( symmetry ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 9455, "input": "<s> package org . eclipse . jface . tests . images ; import junit . framework . TestCase ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IconAndMessageDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . graphics . Image ; public class ImageRegistryTest extends TestCase { public ImageRegistryTest ( String name ) { super ( name ) ; } public static void main ( String args [ ] ) { junit . textui . TestRunner . run ( ImageRegistryTest . class ) ; } public void testGetNull ( ) { ImageRegistry reg = JFaceResources . getImageRegistry ( ) ; Image result = reg . get ( ( String ) null ) ; assertTrue ( \"Registry should handle null\" , result == null ) ; } public void testGetString ( ) { Dialog . getBlockedHandler ( ) ; String [ ] imageNames = new String [ ] { Dialog . DLG_IMG_ERROR , Dialog . DLG_IMG_INFO , Dialog . DLG_IMG_QUESTION , Dialog . DLG_IMG_WARNING , Dialog . DLG_IMG_MESSAGE_ERROR , Dialog . DLG_IMG_MESSAGE_INFO , Dialog . DLG_IMG_MESSAGE_WARNING } ; ImageRegistry reg = JFaceResources . getImageRegistry ( ) ; for ( int i = 0 ; i < imageNames . length ; i ++ ) { String imageName = imageNames [ i ] ; Image image1 = reg . get ( imageName ) ; assertTrue ( \"Returned null image\" , image1 != null ) ; } } public void testGetIconMessageDialogImages ( ) { IconAndMessageDialog iconDialog = new MessageDialog ( null , \"testGetDialogIcons\" , null , \"Message\" , Window . CANCEL , new String [ ] { \"cancel\" } , 0 ) ; Image [ ] images = new Image [ ] { iconDialog . getErrorImage ( ) , iconDialog . getInfoImage ( ) , iconDialog . getQuestionImage ( ) , iconDialog . getWarningImage ( ) } ; for", "gt": "( int i = 0 ;", "prediction": "( )\n", "label": 1}
{"id": 1115, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Balance extends Property , ReportAttribute { Account getCost ( ) ; void setCost ( Account value ) ; Account getRevenue ( ) ; void", "gt": "setRevenue ( Account value ) ;", "prediction": "}\n", "label": 0}
{"id": 9463, "input": "<s> package org . restlet . engine . header ; import java . io . IOException ; import java . util . Collection ; import org . restlet . data . Protocol ; import org . restlet . data . RecipientInfo ; public class RecipientInfoReader extends HeaderReader < RecipientInfo > { public static void addValues ( Header header , Collection < RecipientInfo > collection ) { new RecipientInfoReader ( header . getValue ( ) ) . addValues ( collection ) ; } public RecipientInfoReader ( String header ) { super ( header ) ; } @ Override public RecipientInfo readValue ( ) throws IOException { RecipientInfo result = new RecipientInfo ( ) ; String protocolToken = readToken ( ) ; if ( peek ( ) == '/' ) { read ( ) ; result . setProtocol ( new Protocol ( protocolToken , protocolToken , null , - 1 , readToken ( ) ) ) ; } else { result . setProtocol ( new Protocol ( \"HTTP\" ,", "gt": "\"HTTP\" , null , - 1 , protocolToken ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2685, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . fachwerte ; import java . util . Calendar ; import java . util . TimeZone ; public final class Datum implements Comparable < Datum > { private static final long MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24 ; private final int _jahr ; private final int _monat ; private final int _tag ; private static final Calendar CALENDAR = Calendar . getInstance ( ) ; static { CALENDAR . setLenient ( false ) ; CALENDAR . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; } public Datum ( int tag , int monat , int jahr ) { assert istGueltig ( tag , monat , jahr ) : \"Vorbedingung verletzt: istGueltig(tag, monat, jahr)\" ; _tag = tag ; _monat = monat ; _jahr = jahr ; } public static Datum heute ( ) { Datum datum = null ; synchronized ( CALENDAR ) { CALENDAR . clear ( ) ; CALENDAR . setTimeInMillis ( System . currentTimeMillis ( ) ) ; datum = new Datum ( CALENDAR . get ( Calendar . DAY_OF_MONTH ) , CALENDAR . get ( Calendar . MONTH ) + 1 , CALENDAR . get ( Calendar . YEAR ) ) ; } return datum ; } public static boolean istGueltig ( int tag , int monat , int jahr ) { boolean gueltig = ( ( monat >= 1 ) && ( monat <= 12 ) ) ; if ( gueltig ) { synchronized ( CALENDAR ) { CALENDAR . clear ( ) ; CALENDAR . set ( Calendar . YEAR , jahr ) ; CALENDAR . set ( Calendar . MONTH , monat - 1 ) ; gueltig = ( ( tag >= 1 ) && ( tag <= CALENDAR . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ) ; } } return gueltig ; } @ Override public int compareTo ( Datum datum ) { return tageSeit ( datum ) ; } @ Override public boolean equals ( Object o ) { boolean result = false ; if ( o instanceof Datum ) { Datum vergleichsdatum = ( Datum ) o ; result = ( ( getTag ( ) == vergleichsdatum . getTag ( ) ) && ( getMonat ( ) == vergleichsdatum . getMonat ( ) ) && ( getJahr ( ) == vergleichsdatum . getJahr ( ) ) ) ; } return result ; } @ Override public int hashCode ( ) { return getJahr ( ) * 365 + getMonat ( ) * 31 + getTag ( ) ; } public int getJahr ( ) { return _jahr ; } public int getMonat ( ) { return _monat ; } public int getTag ( ) { return _tag ; } public Datum minus ( int tage ) { assert tage >= 0 : \"Vorbedingung verletzt: tage >= 0\" ; Datum datum = null ; synchronized ( CALENDAR ) { CALENDAR . clear ( ) ; CALENDAR . set ( _jahr , _monat - 1 , _tag ) ; CALENDAR . add ( Calendar . DAY_OF_MONTH , - tage ) ; datum = new Datum ( CALENDAR . get ( Calendar . DAY_OF_MONTH ) , CALENDAR . get ( Calendar . MONTH ) + 1 , CALENDAR . get ( Calendar . YEAR ) ) ; } return datum ; } public Datum plus ( int tage ) { assert tage >= 0 : \"Vorbedingung verletzt: tage >= 0\" ; Datum datum = null ; synchronized ( CALENDAR ) { CALENDAR . clear ( ) ; CALENDAR . set ( _jahr , _monat - 1 , _tag ) ; CALENDAR . add ( Calendar . DAY_OF_MONTH , tage ) ; datum = new Datum ( CALENDAR . get ( Calendar . DAY_OF_MONTH ) , CALENDAR . get ( Calendar . MONTH ) + 1 , CALENDAR . get ( Calendar . YEAR ) ) ; } return datum ; } public Datum vorherigerTag ( ) { return this . minus ( 1 ) ; } public Datum naechsterTag ( ) { return this . plus ( 1 ) ; } public int tageSeit ( Datum startDatum ) { assert startDatum != null : \"Vorbedingung verletzt: startDatum != null\" ; long startMillis = startDatum . inMillisekunden ( ) ; long endMillis = this . inMillisekunden ( ) ; return ( int ) ( ( endMillis - startMillis ) / MILLISECONDS_PER_DAY ) ; } private long inMillisekunden ( ) { synchronized ( CALENDAR ) { CALENDAR . clear ( ) ; CALENDAR . set ( _jahr , _monat - 1 , _tag ) ; long", "gt": "endMillis = CALENDAR . getTimeInMillis ( ) ;", "prediction": "}\n", "label": 0}
{"id": 9473, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . expressions . PropertyTester ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IWorkbenchPage ; public class OpenPerspectivePropertyTester extends PropertyTester { private static final String PROPERTY_IS_PERSPECTIVE_OPEN = \"isPerspectiveOpen\" ; public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { if ( args . length == 0 && receiver instanceof WorkbenchWindow ) { final WorkbenchWindow window", "gt": "= ( WorkbenchWindow ) receiver ;", "prediction": ";\n", "label": 1}
{"id": 4275, "input": "<s> package com . deliciousdroid . util ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; public class Md5Hash { public static String md5 ( String s ) { try { MessageDigest digest = java . security . MessageDigest . getInstance ( \"MD5\" ) ; digest . update ( s . getBytes ( ) ) ; byte messageDigest [ ] = digest . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = 0 ; i < messageDigest . length ; i ++ ) { String h = Integer . toHexString ( 0xFF & messageDigest [ i ] ) ; while ( h . length ( ) < 2 ) h = \"0\" + h ; hexString . append ( h ) ; } return hexString . toString ( ) ; } catch ( NoSuchAlgorithmException e ) {", "gt": "e . printStackTrace ( ) ;", "prediction": "\n", "label": 0}
{"id": 9494, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import java . util . List ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm", "gt": ". core . api . impl . DocumentModelListImpl ;", "prediction": ";\n", "label": 1}
{"id": 9260, "input": "<s> public class Verify { public static void main ( String [ ] args ) { test ( args . length > 200 ) ; } static int test ( boolean b ) { int i ; try { if ( b ) return 1 ; i = 2 ; } finally { if (", "gt": "b ) i = 3 ;", "prediction": ") ;\n", "label": 0}
{"id": 9497, "input": "<s> package org . eclipse . jface . tests . labelProviders ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . IViewerLabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . ViewerLabel ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; public class ColorAndFontViewerLabelProviderTest extends CompositeLabelProviderTest { class ColorAndFontProvider extends LabelProvider implements IColorProvider , IFontProvider , IViewerLabelProvider { public ColorAndFontProvider ( ) { super ( ) ; } public Font getFont ( Object element ) { return font ; } public Color getBackground ( Object element ) { return background ; } public Color getForeground ( Object element ) { return foreground ; } public void updateLabel ( ViewerLabel label , Object element ) { } } public ColorAndFontViewerLabelProviderTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { initializeColors ( parent ) ; final TableViewer v = new TableViewer ( parent ) ; v . setContentProvider ( new LabelTableContentProvider ( ) ) ; v . setLabelProvider ( new ColorAndFontProvider ( ) ) ; ; v . getTable ( ) . setLinesVisible ( true ) ; return v ; } public void testColorsAndFonts ( ) { Table table = ( Table ) fViewer . getControl ( ) ; TableItem item = table . getItem ( 0 ) ; assertTrue ( \"Background was not set\" , item . getBackground ( 0 ) . equals ( background ) ) ; assertTrue ( \"Foreground was not set\" , item . getForeground ( 0 ) . equals ( foreground ) ) ; assertTrue ( \"Font was not set\" , item . getFont ( 0 ) . equals ( font ) ) ; Font oldFont = font ; clearColors ( ) ; fViewer . refresh ( item . getData ( ) ) ; Display display = table . getDisplay ( ) ; assertTrue ( \"Background was not cleared\" , item . getBackground ( 0 ) . equals ( display .", "gt": "getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4017, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class ThreeXMinus1TransferFunction extends AbstractTransferFunction { @ Override public double getPoint ( double value ) { double result = ( 3.0 * value ) - 1.0 ; if ( result", "gt": "< 0 ) return 0.0 ;", "prediction": ") ;\n", "label": 0}
{"id": 9541, "input": "<s> package org . nuxeo . ecm . platform . publisher . impl . core ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreInstance ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentLocation ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . PathRef ; import org . nuxeo . ecm . core . api . WrappedException ; import org . nuxeo . ecm . core . api . security . SecurityConstants ; import org . nuxeo . ecm . platform . publisher . api . AbstractBasePublicationTree ; import org . nuxeo . ecm . platform . publisher . api . PublicationNode ; import org . nuxeo . ecm . platform . publisher . api . PublicationTree ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocument ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocumentFactory ; import org . nuxeo . ecm . platform . publisher . helper . PublicationRelationHelper ; public class SectionPublicationTree extends AbstractBasePublicationTree implements PublicationTree { private static final long serialVersionUID = 1L ; protected static final String CAN_ASK_FOR_PUBLISHING = \"CanAskForPublishing\" ; protected static final String DEFAULT_ROOT_PATH = \"/default-domain/sections\" ; protected DocumentModel treeRoot ; protected String sessionId ; @ Override public void initTree ( String sid , CoreSession coreSession , Map < String , String > parameters , PublishedDocumentFactory factory , String configName , String title ) throws ClientException { super . initTree ( sid , coreSession , parameters , factory , configName , title ) ; DocumentRef ref = new PathRef ( rootPath ) ; try { if ( coreSession . hasPermission ( ref , SecurityConstants . READ ) ) { treeRoot = coreSession . getDocument ( new PathRef ( rootPath ) ) ; rootNode = new CoreFolderPublicationNode ( treeRoot , getConfigName ( ) , sid , factory ) ; } else { rootNode = new VirtualCoreFolderPublicationNode ( coreSession . getSessionId ( ) , rootPath , getConfigName ( ) , sid , factory ) ; sessionId = coreSession . getSessionId ( ) ; } } catch ( Throwable e ) { Throwable cause = e . getCause ( ) ; if ( cause != null && cause instanceof WrappedException && \"org.nuxeo.ecm.core.model.NoSuchDocumentException\" . equals ( ( ( WrappedException ) cause ) . getClassName ( ) ) ) { rootNode = new EmptyRoot ( getConfigName ( ) , sid , factory ) ; sessionId = coreSession . getSessionId ( ) ; } else { throw new ClientException ( \"Unable", "gt": "to initTree\" , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7220, "input": "<s> package org . bombusim . xmpp . exception ; public class XmppAuthException extends XmppException { private static final long serialVersionUID = 5747799072450019240L ;", "gt": "public XmppAuthException ( String exceptionMessage )", "prediction": "}\n", "label": 0}
{"id": 9545, "input": "<s> package br . org . archimedes . redo ; import br . org . archimedes . undo . UndoFactory ; public class RedoFactory extends UndoFactory { public String begin ( ) {", "gt": "setCommand ( new RedoCommand ( ) ) ;", "prediction": "\n", "label": 1}
{"id": 3767, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class PackageSummaryBuilder extends AbstractBuilder { public static final String ROOT = \"PackageDoc\" ; private PackageDoc packageDoc ; private PackageSummaryWriter packageWriter ; private Content contentTree ; private PackageSummaryBuilder ( Configuration configuration ) { super ( configuration ) ; } public static PackageSummaryBuilder getInstance ( Configuration configuration , PackageDoc pkg , PackageSummaryWriter packageWriter ) { PackageSummaryBuilder builder = new PackageSummaryBuilder ( configuration ) ; builder . packageDoc = pkg ; builder . packageWriter = packageWriter ; return builder ; } public void build ( ) throws IOException { if ( packageWriter == null ) { return ; } build ( LayoutParser . getInstance ( configuration ) . parseXML ( ROOT ) , contentTree ) ; } public String getName ( ) { return ROOT ; } public void buildPackageDoc ( XMLNode node , Content contentTree ) throws Exception { contentTree = packageWriter . getPackageHeader ( Util . getPackageName ( packageDoc ) ) ; buildChildren ( node , contentTree ) ; packageWriter . addPackageFooter ( contentTree ) ; packageWriter . printDocument ( contentTree ) ; packageWriter . close ( ) ; Util . copyDocFiles ( configuration , Util . getPackageSourcePath ( configuration , packageDoc ) , DirectoryManager . getDirectoryPath ( packageDoc ) + File . separator + DocletConstants . DOC_FILES_DIR_NAME , true ) ; } public void buildContent ( XMLNode node , Content contentTree ) { Content packageContentTree = packageWriter . getContentHeader ( ) ; buildChildren ( node , packageContentTree ) ; contentTree . addContent ( packageContentTree ) ; } public void buildSummary ( XMLNode node , Content packageContentTree ) { Content summaryContentTree = packageWriter . getSummaryHeader ( ) ; buildChildren ( node , summaryContentTree ) ; packageContentTree . addContent ( summaryContentTree ) ; } public void buildInterfaceSummary ( XMLNode node , Content summaryContentTree ) { String interfaceTableSummary = configuration . getText ( \"doclet.Member_Table_Summary\" , configuration . getText ( \"doclet.Interface_Summary\" ) , configuration . getText ( \"doclet.interfaces\" ) ) ; String [ ] interfaceTableHeader = new String [ ] { configuration . getText ( \"doclet.Interface\" ) , configuration . getText ( \"doclet.Description\" ) } ; ClassDoc [ ] interfaces = packageDoc . isIncluded ( ) ? packageDoc . interfaces ( ) : configuration . classDocCatalog . interfaces ( Util . getPackageName ( packageDoc ) ) ; if ( interfaces . length > 0 ) { packageWriter . addClassesSummary ( interfaces , configuration . getText ( \"doclet.Interface_Summary\" ) , interfaceTableSummary , interfaceTableHeader , summaryContentTree ) ; } } public void buildClassSummary ( XMLNode node , Content summaryContentTree ) { String classTableSummary = configuration . getText ( \"doclet.Member_Table_Summary\" , configuration . getText ( \"doclet.Class_Summary\" ) , configuration . getText ( \"doclet.classes\" ) ) ; String [ ] classTableHeader = new String [ ] { configuration . getText ( \"doclet.Class\" ) , configuration . getText ( \"doclet.Description\" ) } ; ClassDoc [ ] classes = packageDoc . isIncluded ( ) ? packageDoc . ordinaryClasses ( ) : configuration . classDocCatalog . ordinaryClasses ( Util . getPackageName ( packageDoc ) ) ; if ( classes . length > 0 ) { packageWriter . addClassesSummary ( classes , configuration . getText ( \"doclet.Class_Summary\" ) , classTableSummary , classTableHeader , summaryContentTree ) ; } } public void buildEnumSummary ( XMLNode node , Content summaryContentTree ) { String enumTableSummary = configuration . getText ( \"doclet.Member_Table_Summary\" , configuration . getText ( \"doclet.Enum_Summary\" ) , configuration . getText ( \"doclet.enums\" ) ) ; String [ ] enumTableHeader = new String [ ] { configuration . getText ( \"doclet.Enum\" ) , configuration . getText ( \"doclet.Description\" ) } ; ClassDoc [ ] enums = packageDoc . isIncluded ( ) ? packageDoc . enums ( ) : configuration . classDocCatalog . enums ( Util . getPackageName ( packageDoc ) ) ; if ( enums . length > 0 ) { packageWriter . addClassesSummary ( enums , configuration . getText ( \"doclet.Enum_Summary\" ) , enumTableSummary , enumTableHeader , summaryContentTree ) ; } } public void buildExceptionSummary ( XMLNode node , Content summaryContentTree ) { String exceptionTableSummary = configuration . getText ( \"doclet.Member_Table_Summary\" , configuration . getText ( \"doclet.Exception_Summary\" ) , configuration . getText ( \"doclet.exceptions\" ) ) ; String [ ] exceptionTableHeader = new String [ ] { configuration . getText ( \"doclet.Exception\" ) , configuration . getText ( \"doclet.Description\" ) } ; ClassDoc [ ] exceptions = packageDoc . isIncluded ( ) ? packageDoc . exceptions ( ) : configuration . classDocCatalog . exceptions ( Util . getPackageName ( packageDoc ) ) ; if ( exceptions . length > 0 ) { packageWriter . addClassesSummary ( exceptions , configuration . getText ( \"doclet.Exception_Summary\" ) , exceptionTableSummary , exceptionTableHeader , summaryContentTree ) ; } } public void buildErrorSummary (", "gt": "XMLNode node , Content summaryContentTree )", "prediction": ")\n", "label": 0}
{"id": 9551, "input": "<s> package org . apache . lucene . analysis ; import java . io . IOException ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; public final class PorterStemFilter extends TokenFilter { private PorterStemmer stemmer ; private TermAttribute termAtt ; public PorterStemFilter ( TokenStream in ) { super ( in ) ; stemmer = new PorterStemmer ( ) ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; } public final boolean incrementToken ( ) throws IOException { if ( ! input . incrementToken ( ) ) return false ; if ( stemmer . stem ( termAtt . termBuffer ( ) , 0 , termAtt . termLength ( ) ) ) termAtt . setTermBuffer ( stemmer . getResultBuffer ( ) , 0", "gt": ", stemmer . getResultLength ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8238, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . eclipse . gef . Tool ; import org . eclipse . gef . palette . PaletteContainer ; import org . eclipse . gef . palette . PaletteGroup ; import org . eclipse . gef . palette . PaletteRoot ; import org . eclipse . gef . palette . ToolEntry ; import org . eclipse . gmf . runtime . diagram . ui . tools . UnspecifiedTypeCreationTool ; import org . eclipse . gmf . runtime . emf . type . core . IElementType ; import org . msl . simple . gmfmap . simplemappings . diagram . providers . SimplemapElementTypes ; public class SimplemapPaletteFactory { public void fillPalette ( PaletteRoot paletteRoot ) { paletteRoot . add ( createSimplemappings1Group ( ) ) ; } private PaletteContainer createSimplemappings1Group ( ) { PaletteGroup paletteContainer = new PaletteGroup ( Messages . Simplemappings1Group_title ) ; paletteContainer . setId ( \"createSimplemappings1Group\" ) ; paletteContainer . add ( createNode1CreationTool ( ) ) ; paletteContainer . add ( createCompartment2CreationTool ( ) ) ; paletteContainer . add ( createLabelNode3CreationTool ( ) ) ; paletteContainer . add ( createLinkMapping4CreationTool ( ) ) ; paletteContainer . add ( createChildReference5CreationTool ( ) ) ; return paletteContainer ; } private ToolEntry createNode1CreationTool ( ) { ArrayList < IElementType > types = new ArrayList < IElementType > ( 2 ) ; types . add ( SimplemapElementTypes . SimpleTopNode_1001 ) ; types . add ( SimplemapElementTypes . SimpleSubNode_2003 ) ; NodeToolEntry entry = new NodeToolEntry ( Messages . Node1CreationTool_title , Messages . Node1CreationTool_desc , types ) ; entry . setId ( \"createNode1CreationTool\" ) ; entry . setSmallIcon ( SimplemapElementTypes . getImageDescriptor ( SimplemapElementTypes . SimpleTopNode_1001 ) ) ; entry . setLargeIcon ( entry . getSmallIcon ( ) ) ; return entry ; } private ToolEntry createCompartment2CreationTool ( ) { NodeToolEntry entry = new NodeToolEntry ( Messages . Compartment2CreationTool_title , Messages . Compartment2CreationTool_desc , Collections . singletonList ( SimplemapElementTypes . SimpleCompartment_2002 ) ) ; entry . setId ( \"createCompartment2CreationTool\" ) ; entry . setSmallIcon ( SimplemapElementTypes . getImageDescriptor ( SimplemapElementTypes . SimpleCompartment_2002 ) ) ; entry . setLargeIcon ( entry . getSmallIcon ( ) ) ; return entry ; } private ToolEntry createLabelNode3CreationTool ( ) { NodeToolEntry entry = new NodeToolEntry ( Messages . LabelNode3CreationTool_title , Messages . LabelNode3CreationTool_desc , Collections . singletonList ( SimplemapElementTypes . SimpleLabelNode_2001 ) ) ; entry . setId ( \"createLabelNode3CreationTool\" ) ; entry . setSmallIcon ( SimplemapElementTypes . getImageDescriptor ( SimplemapElementTypes . SimpleLabelNode_2001 ) ) ; entry . setLargeIcon ( entry . getSmallIcon ( ) ) ; return entry ; } private ToolEntry createLinkMapping4CreationTool ( ) { NodeToolEntry entry = new NodeToolEntry ( Messages . LinkMapping4CreationTool_title , Messages . LinkMapping4CreationTool_desc , Collections . singletonList ( SimplemapElementTypes . SimpleLinkMapping_1002 ) ) ; entry . setId ( \"createLinkMapping4CreationTool\" ) ; entry . setSmallIcon ( SimplemapElementTypes . getImageDescriptor ( SimplemapElementTypes . SimpleLinkMapping_1002 ) ) ; entry . setLargeIcon (", "gt": "entry . getSmallIcon ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9558, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse . emf . common . util . EList ; import org . eclipse .", "gt": "emf . ecore . EObject ;", "prediction": ";\n", "label": 1}
{"id": 7863, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Giant ; public interface LizaGiant extends Giant { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet <", "gt": "Byte > transparent , int maxDistance ) ;", "prediction": ")\n", "label": 0}
{"id": 9567, "input": "<s> package org . nuxeo . theme . webwidgets ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . nuxeo . common . xmap . annotation . XNode ; import org . nuxeo . common . xmap . annotation . XNodeList ; import org . nuxeo . common . xmap . annotation . XNodeMap ; import org . nuxeo . common . xmap . annotation . XObject ; @ XObject ( \"decoration\" ) public final class DecorationType { @ XNode ( \"@name\" ) private String name ; @ XNodeList ( value = \"resource\" , type = String [ ] . class , componentType = String . class ) public String [ ] resources ; @ XNodeMap ( value = \"panel-decoration\" , key = \"@mode\" , type = HashMap . class , componentType = PanelDecorationType .", "gt": "class ) public Map < String , PanelDecorationType > panelDecorations ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6014, "input": "<s> package com . mobeelizer . mobile . android ; import static junit . framework . Assert . assertNull ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . when ; import static org . powermock . api . mockito . PowerMockito . whenNew ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . Mockito ; import org . powermock . api . mockito . PowerMockito ; import org . powermock . core . classloader . annotations . PrepareForTest ; import org . powermock . modules . junit4 . PowerMockRunner ; import com . mobeelizer . java . api . MobeelizerCredential ; import com . mobeelizer . java . api . MobeelizerField ; import com . mobeelizer . java . api . MobeelizerModel ; import com . mobeelizer . java . definition . MobeelizerApplicationDefinition ; import com . mobeelizer . java . definition . MobeelizerDefinitionConverter ; import com . mobeelizer . java . definition . MobeelizerModelCredentialsDefinition ; import com . mobeelizer . java . definition . MobeelizerModelDefinition ; import com . mobeelizer . java . definition . MobeelizerModelFieldCredentialsDefinition ; import com . mobeelizer . java . definition . MobeelizerModelFieldDefinition ; import com . mobeelizer . java . definition . MobeelizerRoleDefinition ; import com . mobeelizer . java . model . MobeelizerFieldImpl ; import com . mobeelizer . java . model . MobeelizerModelImpl ; @ RunWith ( PowerMockRunner . class ) @ PrepareForTest ( { MobeelizerDefinitionConverter . class , Class . class } ) public class MobeelizerDefinitionManagerTest { private MobeelizerDefinitionConverter definitionManager ; private MobeelizerApplicationDefinition definition ; private Method modelHasAccess ; private Method fieldHasAccess ; @ Before public void init ( ) { definitionManager = PowerMockito . spy ( new MobeelizerDefinitionConverter ( ) ) ; MobeelizerRoleDefinition role = mock ( MobeelizerRoleDefinition . class ) ; when ( role . resolveName ( ) ) . thenReturn ( \"role\" ) ; definition = mock ( MobeelizerApplicationDefinition . class ) ; when ( definition . getModels ( ) ) . thenReturn ( Collections . < MobeelizerModelDefinition > emptySet ( ) ) ; when ( definition . getRoles ( ) ) . thenReturn ( Collections . < MobeelizerRoleDefinition > singleton ( role ) ) ; modelHasAccess = PowerMockito . method ( MobeelizerDefinitionConverter . class , \"hasAccess\" , MobeelizerModelDefinition . class , String . class ) ; fieldHasAccess = PowerMockito . method ( MobeelizerDefinitionConverter . class , \"hasAccess\" , MobeelizerModelFieldDefinition . class , String . class ) ; } @ Test public void shouldReturnEmptyModels ( ) throws Exception { Set < MobeelizerModel > convert = definitionManager . convert ( definition , \"com.mobeelizer.mobile.android\" , \"role\" ) ; assertTrue ( convert . isEmpty ( ) ) ; } @ Test ( expected = IllegalStateException . class ) public void shouldReturnFailIsGroupNotFound ( ) throws Exception { definitionManager . convert ( definition , \"com.mobeelizer.mobile.android\" , \"notExistingRole\" ) ; } @ Test public void shouldReturnNullIfEmptyFieldCredentials ( ) throws Exception { MobeelizerModelFieldDefinition field = mock ( MobeelizerModelFieldDefinition . class ) ; Set < MobeelizerModelFieldCredentialsDefinition > credentials = new HashSet < MobeelizerModelFieldCredentialsDefinition > ( ) ; when ( field . getCredentials ( ) ) . thenReturn ( credentials ) ; MobeelizerModelFieldCredentialsDefinition actualCredentials = ( MobeelizerModelFieldCredentialsDefinition ) fieldHasAccess . invoke ( definitionManager , field , \"role\" ) ; assertNull ( actualCredentials ) ; } @ Test public void shouldReturnNullIfNoRoleFieldCredentials ( ) throws Exception { checkFieldHasAccess ( \"otherRole\" , MobeelizerCredential . ALL , MobeelizerCredential . ALL , MobeelizerCredential . ALL , false ) ; } @ Test public void shouldReturnFieldCredentials ( ) throws Exception { for ( MobeelizerCredential createAllowed : MobeelizerCredential . values ( ) ) { for ( MobeelizerCredential updateAllowed : MobeelizerCredential . values ( ) ) { for ( MobeelizerCredential readAllowed : MobeelizerCredential . values ( ) ) { boolean hasAccess = createAllowed != MobeelizerCredential . NONE || updateAllowed != MobeelizerCredential . NONE || readAllowed != MobeelizerCredential . NONE ; checkFieldHasAccess ( \"role\" ,", "gt": "createAllowed , updateAllowed , readAllowed , hasAccess ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9577, "input": "<s> package it . sineo . android . tileMapEditor ; import android . app . AlertDialog ; import android . view . View ; import android . widget . AdapterView ; public class TileSelectViewOnItemClickListener implements AdapterView . OnItemClickListener { private AlertDialog dialog ; private TiledMapView view ; private int row ; private int column ; @ Override public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { String path = ( String ) ( ( ImageAdapter ) parent . getAdapter ( ) ) . getItem ( position ) ; view . setTile ( row , column , path ) ; dialog . dismiss ( ) ; } public void setDialog ( AlertDialog dialog ) { this . dialog = dialog ; } public void setView ( TiledMapView view ) {", "gt": "this . view = view ;", "prediction": "\n", "label": 1}
{"id": 3831, "input": "<s> package org . msl . simple . gmf . migrate . ui ; import java . text . MessageFormat ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . gmf . internal . common . migrate . ModelLoadHelper ; import org . eclipse . gmf . mappings . Mapping ; public class TransformToSimpleMappingOperation { private Mapping myMapping ; private final ResourceSet myResourceSet ; public TransformToSimpleMappingOperation ( ResourceSet rs ) { assert rs != null ; myResourceSet = rs ; } public final ResourceSet getResourceSet ( ) { return myResourceSet ; } Mapping getMapping ( ) { return this . myMapping ; } private void setMapping ( Mapping m ) { this . myMapping = m ; } public Mapping loadMappingModel ( URI uri , IProgressMonitor pm ) throws CoreException { Mapping content = null ; IStatus status = Status . CANCEL_STATUS ; IProgressMonitor monitor = null ; try { if ( uri == null ) { throw new IllegalArgumentException ( Messages . TransformToGenModelOperation_e_null_map_uri ) ; } monitor = ( pm != null ) ? new SubProgressMonitor ( pm , 1 , SubProgressMonitor . PREPEND_MAIN_LABEL_TO_SUBTASK ) : new NullProgressMonitor ( ) ; String cancelMessage = Messages . TransformToGenModelOperation_e_map_load_cancelled ; monitor . beginTask ( \"\" , 100 ) ; subTask ( monitor , 0 , Messages . TransformToGenModelOperation_task_load , cancelMessage ) ; ModelLoadHelper loadHelper = new ModelLoadHelper ( getResourceSet ( ) , uri ) ; if ( ! loadHelper . isOK ( ) ) { throw new CoreException ( loadHelper . getStatus ( ) ) ; } subTask ( monitor , 20 , Messages . TransformToGenModelOperation_task_validate , cancelMessage ) ; EObject root = loadHelper . getContentsRoot ( ) ; if ( ! ( root instanceof Mapping ) ) { String msg = MessageFormat . format ( Messages . TransformToGenModelOperation_e_wrong_root_element , root . getClass ( ) . getName ( ) ) ; status = Plugin . createError ( msg , null ) ; throw new CoreException ( status ) ; } content = ( Mapping ) loadHelper . getContentsRoot ( ) ; monitor . worked ( 60 ) ; return content ; } catch ( CoreException e ) { throw e ; } catch ( Exception e ) { IStatus error = Plugin . createError ( Messages . TransformToGenModelOperation_e_load_mapping_model , e ) ; throw new CoreException ( error ) ; } finally { setMapping ( content ) ; if ( monitor != null ) { monitor . done ( ) ; } } } private static void subTask ( IProgressMonitor monitor , int ticks", "gt": ", String name , String cancelMessage ) throws CoreException", "prediction": ")\n", "label": 0}
{"id": 9593, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . File ; import org . eclipse . rap . rwt . application . ApplicationRunner ; import org . eclipse . rap . rwt . internal . application . ApplicationContextUtil ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; public class ResourceDirectory { public static final String DIRNAME = \"rwt-resources\" ; private File resourcesDir ; public void configure ( String contextDirectory ) { ParamCheck . notNull ( contextDirectory , \"contextDirectory\" ) ; resourcesDir = new File ( contextDirectory , ApplicationRunner . RESOURCES ) ; } public void reset ( ) { resourcesDir = null ; }", "gt": "public void createDirectory ( )", "prediction": "}\n", "label": 1}
{"id": 2674, "input": "<s> package com . sun . mirror . declaration ; import com . sun . mirror . util . SourcePosition ; @ Deprecated @", "gt": "SuppressWarnings ( \"deprecation\" ) public interface AnnotationValue", "prediction": ";\n", "label": 0}
{"id": 9599, "input": "<s> package org . restlet . test . engine ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; import org . restlet . data . ClientInfo ; import org . restlet . data . Encoding ; import org . restlet . data . MediaType ; import org . restlet . engine . header . EncodingReader ; import org . restlet . engine . header . HeaderReader ; import org . restlet . engine . header . PreferenceReader ; import org . restlet . engine . header . TokenReader ; import org . restlet . engine . util . DateUtils ; import org . restlet . test . RestletTestCase ; public class HeaderTestCase extends RestletTestCase { public void testAddValues ( ) { List < Encoding > list = new ArrayList < Encoding > ( ) ; new EncodingReader ( \"gzip,deflate\" ) . addValues ( list ) ; assertEquals ( list . size ( ) , 2 ) ; assertEquals ( list . get ( 0 ) , Encoding . GZIP ) ; assertEquals ( list . get ( 1 ) , Encoding . DEFLATE ) ; list = new ArrayList < Encoding > ( ) ; new EncodingReader ( \"gzip,identity, deflate\" ) . addValues ( list ) ; assertEquals ( list . size ( ) , 2 ) ; assertEquals ( list . get ( 0 ) , Encoding . GZIP ) ; assertEquals ( list . get ( 1 ) , Encoding . DEFLATE ) ; list = new ArrayList < Encoding > ( ) ; new EncodingReader ( \"identity\" ) . addValues ( list ) ; assertTrue ( list . isEmpty ( ) ) ; list = new ArrayList < Encoding > ( ) ; new EncodingReader ( \"identity,\" ) . addValues ( list ) ; assertTrue ( list . isEmpty ( ) ) ; list = new ArrayList < Encoding > ( ) ; new EncodingReader ( \"\" ) . addValues ( list ) ; assertTrue ( list . isEmpty ( ) ) ; list = new ArrayList < Encoding > ( ) ; new EncodingReader ( null ) . addValues ( list ) ; assertTrue ( list . isEmpty ( ) ) ; TokenReader tr = new TokenReader ( \"bytes\" ) ; List < String > l = tr . readValues ( ) ; assertTrue ( l . contains ( \"bytes\" ) ) ; tr = new TokenReader ( \"bytes,\" ) ; l", "gt": "= tr . readValues ( ) ;", "prediction": "}\n", "label": 1}
{"id": 2479, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Work extends NewTaskAttribute , TaskTimesheetAttribute { float getValue ( ) ;", "gt": "void setValue ( float value ) ;", "prediction": "}\n", "label": 0}
{"id": 9610, "input": "<s> package com . codeslap . persistence ; import java . util . ArrayList ; import java . util . List ; @ SuppressWarnings ( \"UnusedDeclaration\" ) public class PrefsPersistence { private final List < Class < ? > > PREFS_MAP = new ArrayList < Class < ? > > ( ) ; public void match ( Class < ? > ... types ) { for ( Class < ? > type : types ) { if ( ! PREFS_MAP . contains ( type ) ) { PREFS_MAP . add ( type ) ; } } } boolean belongsToPreferences ( Class < ? > clazz ) { return PREFS_MAP .", "gt": "contains ( clazz ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1376, "input": "<s> package org . gk . ui . client . com . utils ; import java . util . Date ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBus ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import org . gk . ui . client . com . CoreIC ; import org . gk . ui . client . com . form . gkComboBox ; import org . gk . ui . client . com . form . gkDateField ; import org . gk . ui . client . com . form . gkLabelField ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . form . gkRadio ; import org . gk . ui . client . com . form . gkTimeField ; import org . gk . ui . client . com . form . gkYMField ; import org . gk . ui . client . com . panel . gkFieldAccessIfc ; import org . gk . ui . client . com . panel . gkFormPanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . KeyListener ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . SelectionChangedEvent ; import com . extjs . gxt . ui . client . event . SelectionChangedListener ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . form . AdapterField ; import com . extjs . gxt . ui . client . widget . form . CheckBox ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . LabelField ; import com . extjs . gxt . ui . client . widget . form . NumberField ; import com . extjs . gxt . ui . client . widget . form . Radio ; import com . extjs . gxt . ui", "gt": ". client . widget . form . SliderField ;", "prediction": ";\n", "label": 0}
{"id": 9627, "input": "<s> package br . org . archimedes . io . dxf . parsers ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . kabeja . dxf . DXFCircle ; import org . kabeja . dxf . DXFConstants ; import org . kabeja . dxf . DXFLayer ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; public class CircleParser extends ElementParser { @ Override public Collection < Element > parse ( DXFLayer layer ) throws NullArgumentException , InvalidArgumentException { Collection < Element > archimedesCircles = new ArrayList < Element > ( ) ; List < DXFCircle > dxfCircles = layer . getDXFEntities ( DXFConstants . ENTITY_TYPE_CIRCLE ) ; if ( dxfCircles != null ) { for ( DXFCircle dxfCircle : dxfCircles ) { org . kabeja . dxf . helpers . Point", "gt": "centerPoint = dxfCircle . getCenterPoint ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7316, "input": "<s> package org . ofbiz . service . calendar ; @ SuppressWarnings ( \"serial\" ) public class RecurrenceInfoException extends org . ofbiz . base . util . GeneralException { public RecurrenceInfoException ( ) { super ( ) ; } public RecurrenceInfoException ( String msg ) { super ( msg ) ; } public RecurrenceInfoException ( String msg , Throwable t ) {", "gt": "super ( msg , t ) ;", "prediction": "\n", "label": 0}
{"id": 9636, "input": "<s> package org . seage . metaheuristic . particles ; public interface IParticleSwarm { long getMaximalIterationCount ( ) ; void setMaximalIterationCount ( long maximalIterationCount ) ; double getMaximalVelocity ( ) ; void setMaximalVelocity ( double maximalVelocity ) ; double getMinimalVelocity ( ) ; void setMinimalVelocity ( double minimalVelocity ) ; void startSearching ( Particle [ ] particles ) ; void stopSearching ( ) ; Particle getBestParticle ( ) ; public Particle [", "gt": "] getParticles ( ) ;", "prediction": "\n", "label": 1}
{"id": 5569, "input": "<s> package ar . com . fdvs . dj . domain . entities . columns ; import ar . com . fdvs . dj . core . BarcodeTypes ; import ar . com . fdvs . dj . domain . entities . Entity ; public class BarCodeColumn extends ImageColumn implements BarcodeTypes { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private int barcodeType = _2_OF_7 ; private boolean showText = false ; private boolean checkSum = false ; private String applicationIdentifier = null ; private boolean haltWhenException = false ; public boolean isHaltWhenException ( ) { return haltWhenException ; } public void setHaltWhenException ( boolean haltWhenException ) { this . haltWhenException = haltWhenException ; } public String getApplicationIdentifier ( ) { return applicationIdentifier ; } public void setApplicationIdentifier ( String applicationIdentifier ) { this . applicationIdentifier = applicationIdentifier ; } public boolean isShowText ( ) { return showText ; } public void setShowText ( boolean showText ) { this . showText = showText ; } public int getBarcodeType ( ) { return barcodeType ; } public void setBarcodeType ( int barcodeType ) { this . barcodeType = barcodeType ; } public boolean isCheckSum ( ) { return checkSum ; } public void setCheckSum ( boolean checkSum ) { this", "gt": ". checkSum = checkSum ;", "prediction": "\n", "label": 0}
{"id": 9641, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . * ; public class oracleConnection1 { public static void main ( String args [ ] ) throws SQLException { try { Class . forName ( \"oracle.jdbc.driver.OracleDriver\" ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } Connection conn = DriverManager . getConnection ( \"jdbc:oracle:thin:@localhost:1521:orcl\" , \"scott\" , \"tiger\" ) ; Statement stmt = conn . createStatement ( ) ; ResultSet rset", "gt": "= stmt . executeQuery ( \"select* from belli\" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1756, "input": "<s> package ar . com . fdvs . dj . domain . chart . dataset ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignXyDataset ; import net . sf . jasperreports . charts . design . JRDesignXySeries ; import net . sf . jasperreports . engine . JRExpression ; import net . sf . jasperreports . engine . design . JRDesignChartDataset ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . util . ExpressionUtils ; public class XYDataset extends AbstractDataset { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private PropertyColumn xValue = null ; private List series = new ArrayList ( ) ; private Map seriesLabels = new HashMap ( ) ; public void setXValue ( PropertyColumn xValue ) { this . xValue = xValue ; } public PropertyColumn getXValue ( ) { return xValue ; } public void addSerie ( AbstractColumn column ) { series . add ( column ) ; } public void addSerie ( AbstractColumn column , String label ) { addSerie ( column , new LiteralExpression ( label ) ) ; } public void addSerie ( AbstractColumn column , StringExpression labelExpression ) { series . add ( column ) ; seriesLabels . put ( column , labelExpression ) ; } public void removeSerie ( AbstractColumn column ) { series . remove ( column ) ; seriesLabels . remove ( column ) ; } public void clearSeries ( ) { series . clear ( ) ; seriesLabels . clear ( ) ; } public List getSeries ( ) { return series ; } public JRDesignChartDataset transform ( DynamicJasperDesign design , String name , JRDesignGroup group , JRDesignGroup parentGroup , Map vars ) { JRDesignXyDataset data = new JRDesignXyDataset ( null ) ; for ( Iterator iterator = series . iterator ( ) ; iterator . hasNext ( ) ; ) { JRDesignXySeries serie = new JRDesignXySeries ( ) ; AbstractColumn column = ( AbstractColumn ) iterator . next ( ) ; JRDesignExpression varExp = getExpressionFromVariable (", "gt": "( JRDesignVariable ) vars . get ( column ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9644, "input": "<s> package fr . inria . zvtm . engine . portals ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Graphics2D ; import java . util . Timer ; import java . util . TimerTask ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . glyphs . Translucent ; import fr . inria . zvtm . event . ObservedRegionListener ; public class TrailingOverview extends TrailingCameraPortal { AlphaComposite orST = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.5f ) ; Camera observedRegionCamera ; View observedRegionView ; double [ ] observedRegion ; float orcoef ; Timer borderTimer ; public TrailingOverview ( int x , int y , int w , int h , Camera pc , Camera orc , float a , int xo , int yo ) { super ( x , y , w , h , pc , a , xo , yo ) ; this . observedRegionCamera = orc ; this . observedRegionView = orc . getOwningView ( ) ; observedRegion = new double [ 4 ] ; borderTimer = new Timer ( ) ; borderTimer . scheduleAtFixedRate ( new BorderTimer ( this ) , 40 , 40 ) ; } public void setTransparencyValue ( float a ) { if ( a < 0 ) { a = 0 ; } try { alphaC = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , a ) ; alpha = a ; orST = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , a / 2.0f ) ; } catch ( IllegalArgumentException ex ) { if ( VirtualSpaceManager . debugModeON ( ) ) { System . err . println ( \"Error animating translucency of \" + this . toString ( ) + \": \" + a ) ; } } } public boolean coordInsideObservedRegion ( int cx , int cy ) { return ( cx >= x + w / 2 + Math . round ( ( observedRegion [ 0 ] - camera . vx ) * orcoef ) && cy >= y + h / 2 + Math . round ( ( camera . vy - observedRegion [ 1 ] ) * orcoef ) && cx <= x + w / 2 + Math . round ( ( observedRegion [ 2 ] - camera . vx ) * orcoef ) && cy <= y + h / 2 + Math . round ( ( camera . vy - observedRegion [ 3 ] ) * orcoef ) ) ; } ObservedRegionListener observedRegionListener ; public void setObservedRegionListener ( ObservedRegionListener orl ) { this . observedRegionListener = orl ; } void observedRegionIntersects ( double [ ] wnes ) { if ( observedRegionListener != null ) { observedRegionListener . intersectsParentRegion ( wnes ) ; } } @ Override public void paint ( Graphics2D g2d , int viewWidth , int viewHeight ) { g2d . setClip ( x , y , w , h ) ; g2d . setComposite ( alphaC ) ; if ( bkgColor != null ) { g2d . setColor ( bkgColor ) ; g2d . fillRect ( x , y , w , h ) ; } standardStroke = g2d . getStroke ( ) ; standardTransform = g2d . getTransform ( ) ; drawnGlyphs = cameraSpace . getDrawnGlyphs ( camIndex ) ; synchronized ( drawnGlyphs ) { drawnGlyphs . removeAllElements ( ) ; uncoef = ( camera . focal + camera . altitude ) / camera . focal ; viewWC = camera . vx - ( w / 2 ) * uncoef ; viewNC = camera . vy + ( h / 2 ) * uncoef ; viewEC = camera . vx + ( w / 2 ) * uncoef ; viewSC = camera . vy - ( h / 2 ) * uncoef ; gll = cameraSpace . getDrawingList ( ) ; for ( int i = 0 ; i < gll . length ; i ++ ) { if ( gll [ i ] != null ) { synchronized ( gll [ i ] ) { if ( gll [ i ] . visibleInViewport ( viewWC , viewNC , viewEC , viewSC , camera ) ) { gll [ i ] . project ( camera , size ) ; if ( gll [ i ] . isVisible ( ) ) { gll [ i ] . draw ( g2d , w , h , camIndex , standardStroke , standardTransform , x , y ) ; } } } } } } observedRegion = observedRegionView . getVisibleRegion ( observedRegionCamera , observedRegion ) ; g2d . setColor ( Color . GREEN ) ; g2d . setComposite ( orST ) ; orcoef = ( float ) ( camera . focal / ( camera . focal + camera . altitude ) ) ; g2d . fillRect ( ( int ) ( x + w / 2 + Math . round ( ( observedRegion [ 0 ] - camera . vx ) * orcoef ) ) , ( int ) ( y + h / 2 - Math . round ( ( observedRegion [ 1 ] - camera . vy ) * orcoef ) ) , ( int ) Math . round ( ( observedRegion [ 2 ] - observedRegion [ 0 ] ) * orcoef ) , ( int ) Math . round ( ( observedRegion [ 1 ] - observedRegion [ 3 ] ) * orcoef ) ) ; g2d", "gt": ". setComposite ( alphaC ) ;", "prediction": ";\n", "label": 1}
{"id": 4429, "input": "<s> package org . gk . engine . client . build . portal ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class PortletBuilder extends Builder { public PortletBuilder ( String nodeName ) { super ( nodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List subNodes = new gkList ( ) ; super . parserNode ( subNodes , node", "gt": ". getChildNodes ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9650, "input": "<s> package org . restlet . engine . header ; import static org . restlet . engine . header . HeaderUtils . isCarriageReturn ; import static org . restlet . engine . header . HeaderUtils . isComma ; import static org . restlet . engine . header . HeaderUtils . isCommentText ; import static org . restlet . engine . header . HeaderUtils . isDoubleQuote ; import static org . restlet . engine . header . HeaderUtils . isLineFeed ; import static org . restlet . engine . header . HeaderUtils . isLinearWhiteSpace ; import static org . restlet . engine . header . HeaderUtils . isQuoteCharacter ; import static org . restlet . engine . header . HeaderUtils . isQuotedText ; import static org . restlet . engine . header . HeaderUtils . isSemiColon ; import static org . restlet . engine . header . HeaderUtils . isSpace ; import static org . restlet . engine . header . HeaderUtils . isTokenChar ; import java . io . IOException ; import java . io . InputStream ; import java . util . Collection ; import java . util . Date ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . data . Encoding ; import org . restlet . data . Parameter ; import org . restlet . engine . util . DateUtils ; import org . restlet . util . NamedValue ; public class HeaderReader < V > { private static final < NV extends NamedValue < String > > NV createNamedValue ( Class < NV > resultClass , String name ) { return createNamedValue ( resultClass , name , null ) ; } private static < NV extends NamedValue < String > > NV createNamedValue ( Class < NV > resultClass , String name , String value ) { try { return resultClass . getConstructor ( String . class , String . class ) . newInstance ( name , value ) ; } catch ( Exception e ) { Context . getCurrentLogger ( ) . log ( Level . WARNING , \"Unable to create named value\" , e ) ; return null ; } } public static Date readDate ( String date , boolean cookie ) { if ( cookie ) { return DateUtils . parse ( date , DateUtils . FORMAT_RFC_1036 ) ; } return DateUtils . parse ( date , DateUtils . FORMAT_RFC_1123 ) ; } public static Header readHeader ( CharSequence header ) throws IOException { Header result = null ; if ( header . length ( ) > 0 ) { int start = 0 ; int index = 0 ; int next = header . charAt ( index ++ ) ; if ( isCarriageReturn ( next ) ) { next = header . charAt ( index ++ ) ; if ( ! isLineFeed ( next ) ) { throw new IOException ( \"Invalid end of headers. Line feed missing after the carriage return.\" ) ; } } else { result = new Header ( ) ; while ( ( index < header . length ( ) ) && ( next != ':' ) ) { next = header . charAt ( index ++ ) ; } if ( index == header . length ( ) ) { throw new IOException ( \"Unable to parse the header name. End of line reached too early.\" ) ; } result . setName ( header . subSequence ( start , index - 1 ) . toString ( ) ) ; next = header . charAt ( index ++ ) ; while ( isSpace ( next ) ) { next = header . charAt ( index ++ ) ; } start = index - 1 ; result . setValue ( header . subSequence ( start , header . length ( ) ) . toString ( ) ) ; } } return result ; } public static Header readHeader ( InputStream is , StringBuilder sb ) throws IOException { Header result = null ; int next = is . read ( ) ; if ( isCarriageReturn ( next ) ) { next = is . read ( ) ; if ( ! isLineFeed ( next ) ) { throw new IOException ( \"Invalid end of headers. Line feed missing after the carriage return.\" ) ; } } else { result = new Header ( ) ; while ( ( next != - 1 ) && ( next != ':' ) ) { sb . append ( ( char ) next ) ; next = is . read ( ) ; } if ( next == - 1 ) { throw new IOException ( \"Unable to parse the header name. End of stream reached too early.\" ) ; } result . setName ( sb . toString ( ) ) ; sb . delete ( 0 , sb . length ( ) ) ; next = is . read ( ) ; while ( isSpace ( next ) ) { next = is . read ( ) ; } while ( ( next != - 1 ) && ( ! isCarriageReturn ( next ) ) ) { sb . append ( ( char ) next ) ; next = is . read ( ) ; } if ( next == - 1 ) { throw new IOException ( \"Unable to parse the header value. End of stream reached too early.\" ) ; } next = is . read ( ) ; if ( isLineFeed ( next ) ) { result . setValue ( sb . toString ( ) ) ; sb . delete ( 0 , sb . length ( ) ) ; } else { throw new IOException ( \"Unable to parse the HTTP header value. The carriage return must be followed by a line feed.\" ) ; } } return result ; } private final String header ; private volatile int index ; private volatile int mark ; public HeaderReader ( String header ) { this", "gt": ". header = header ;", "prediction": "\n", "label": 1}
{"id": 9989, "input": "<s> package FRC2115 . commands ; public class AutoShooterSpeed extends CommandBase { public AutoShooterSpeed ( ) { requires ( shooter ) ; } protected void initialize ( ) { } protected void execute ( ) { shooter . useRangeSpeed ( ) ; } protected boolean isFinished ( ) { return false ; }", "gt": "protected void end ( )", "prediction": "}\n", "label": 0}
{"id": 9653, "input": "<s> package br . org . archimedes . interfaces ; import java . io . IOException ; import java . io . InputStream ; import br . org . archimedes . exceptions . InvalidFileFormatException ; import br . org . archimedes . model . Element ; public interface ElementImporter < T extends Element > { public T importElement ( InputStream input", "gt": ") throws InvalidFileFormatException , IOException ;", "prediction": ") ;\n", "label": 1}
{"id": 8538, "input": "<s> public class Pos01 < X > { Pos01 ( X x ) { } < Z > Pos01 ( X x , Z z ) { } void test ( ) { Pos01 < Integer > p1 = new Pos01 < > ( 1 ) ; Pos01 < ? extends Integer > p2 = new Pos01 < > ( 1 ) ; Pos01 < ? > p3 = new Pos01 < > ( 1 ) ; Pos01 < ? super Integer > p4 = new Pos01 < > ( 1 ) ; Pos01 < Integer > p5 = new Pos01 < > ( 1 , \"\" ) ; Pos01 < ? extends Integer > p6 = new Pos01 < > ( 1 , \"\" ) ; Pos01 < ? > p7 = new Pos01 < > (", "gt": "1 , \"\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9661, "input": "<s> package org . apache . lucene . store . db ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . ByteArrayInputStream ; import java . io . DataInputStream ; import java . util . Random ; import com . sleepycat . db . DatabaseEntry ; import com . sleepycat . db . internal . DbConstants ; import com . sleepycat . db . internal . Dbc ; import com . sleepycat . db . internal . Db ; import com . sleepycat . db . internal . DbTxn ; import com . sleepycat . db . DatabaseException ; public class File extends Object { static protected Random random = new Random ( ) ; protected DatabaseEntry key , data ; protected long length , timeModified ; protected String name ; protected byte [ ] uuid ; protected File ( String name ) throws IOException { setName ( name ) ; data = new DatabaseEntry ( new byte [ 32 ] ) ; data . setUserBuffer ( data . getSize ( ) , true ) ; } protected File ( DbDirectory directory , String name , boolean create ) throws IOException { this ( name ) ; if ( ! exists ( directory ) ) { if ( ! create ) throw new IOException ( \"File does not exist: \" + name ) ; else { DatabaseEntry key = new DatabaseEntry ( new byte [ 24 ] ) ; DatabaseEntry data = new DatabaseEntry ( ( byte [ ] ) null ) ; Db blocks = directory . blocks ; DbTxn txn = directory . txn ; int flags = directory . flags ; key . setUserBuffer ( 24 , true ) ; data . setPartial ( true ) ; uuid = new byte [ 16 ] ; try { do { random . nextBytes ( uuid ) ; uuid [ 6 ] = ( byte ) ( ( byte ) 0x40 | ( uuid [ 6 ] & ( byte ) 0x0f ) ) ; uuid [ 8 ] = ( byte ) ( ( byte ) 0x80 | ( uuid [ 8 ] & ( byte ) 0x3f ) ) ; System . arraycopy ( uuid , 0 , key . getData ( ) , 0 , 16 ) ; } while ( blocks . get ( txn , key , data , flags ) != DbConstants . DB_NOTFOUND ) ; } catch ( DatabaseException e ) { throw new IOException ( e . getMessage ( ) ) ; } } } else if ( create ) length = 0L ; } protected String getName ( ) { return name ; } private void setName ( String name ) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( 128 ) ; DataOutputStream out = new DataOutputStream ( buffer ) ; out . writeUTF ( name ) ; out . close ( ) ; key = new DatabaseEntry ( buffer . toByteArray ( ) ) ; key . setUserBuffer ( key . getSize ( ) , true ) ; this . name = name ; } protected byte [ ] getKey ( ) throws IOException { if ( uuid == null ) throw new IOException ( \"Uninitialized file\" ) ; return uuid ; } protected long getLength ( ) { return length ; } protected long getTimeModified ( ) { return timeModified ; } protected boolean exists ( DbDirectory directory ) throws IOException { Db files = directory . files ; DbTxn txn = directory . txn ; int flags = directory . flags ; try { if ( files . get ( txn , key , data , flags ) == DbConstants . DB_NOTFOUND ) return false ; } catch ( DatabaseException e ) { throw new IOException ( e . getMessage ( ) ) ; } byte [ ] bytes", "gt": "= data . getData ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2486, "input": "<s> class Z { < U , T extends U > T g ( Object o ) {", "gt": "return ( T ) o ;", "prediction": "}\n", "label": 0}
{"id": 9663, "input": "<s> package litil . tc ; import litil . TypeScope ; import litil . ast . * ; import java . util . ArrayList ; import java . util . List ; public class MonomorphicTypeChecker { public Type analyze ( AstNode node , TypeScope scope ) { if ( node instanceof Program ) { for ( Instruction inst : ( ( Program ) node ) . instructions ) { if ( inst instanceof LetBinding ) { LetBinding let = ( LetBinding ) inst ; if ( let . args . size ( ) > 0 ) { scope . define ( let . name , Type . Function ( new Type . Variable ( ) , new Type . Variable ( ) ) ) ; } } } for ( Instruction inst : ( ( Program ) node ) . instructions ) { Type type = analyze ( inst , scope ) ; System . out . println ( inst . repr ( 1 ) + \"\\n\\n\\t=>\" + type + \"\\n-----------------\" ) ; } return null ; } else if ( node instanceof Expr . ENum ) { return Type . INT ; } else if ( node instanceof Expr . EBool ) { return Type . BOOL ; } else if ( node instanceof Expr . EStr ) { return Type . STR ; } else if ( node instanceof Expr . EName ) { Type res = scope . get ( ( ( Expr . EName ) node ) . name ) ; if ( res == null ) { throw new RuntimeException ( \"Undeclared entity '\" + node + \"'\" ) ; } return res ; } else if ( node instanceof Expr . EAp ) { Expr . EAp ap = ( Expr . EAp ) node ; Type funcType = analyze ( ap . fn , scope ) ; Type argType = analyze ( ap . arg , scope ) ; Type . Variable resType = new Type . Variable ( ) ; unify ( Type . Function ( argType , resType ) , funcType ) ; return resType ; } else if ( node instanceof Expr . EIf ) { Expr . EIf eif = ( Expr . EIf ) node ; Type condType = analyze ( eif . cond , scope ) ; unify ( condType , Type . BOOL ) ; Type thenType = null ; for ( Instruction instr : eif . thenInstructions ) { thenType = analyze ( instr , scope ) ; } Type elseType = null ; for ( Instruction instr : eif . elseInstructions ) { elseType = analyze ( instr , scope ) ; } unify ( thenType , elseType ) ; return thenType ; } else if ( node instanceof LetBinding ) { LetBinding let = ( LetBinding ) node ; TypeScope ss = new TypeScope ( scope ) ; List < Type > argTypes = new ArrayList < Type > ( ) ; ss . define ( let . name , new Type . Variable ( ) ) ; for ( Named arg : let . args ) { Type argType = new Type . Variable ( ) ; argTypes . add ( argType ) ; ss . define ( arg . name , argType ) ; } Type resultType = null ; for ( Instruction instr : let . instructions ) { resultType = analyze ( instr , ss ) ; } if ( let . type != null ) { unify ( resultType , let . type ) ; } Type letType = Type . Function (", "gt": "argTypes , resultType ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10107, "input": "<s> package api . requests ; import com . google . gson . annotations . SerializedName ; public class Comments { private String addedTime ; private Number authorId ; private String avatar ; @ SerializedName ( \"class\" ) private String userClass ; private String comment ; private boolean donor ; private String editedTime ; private Number editedUserId ; private String editedUsername ; private boolean enabled ; private String name ; private Number postId ; private boolean warned ; public String getAddedTime ( ) { return this . addedTime ; } public Number getAuthorId ( ) { return this . authorId ; } public String getAvatar ( ) { return this . avatar ; } public String getUserClass ( ) { return this . userClass ; } public String getComment ( ) { return this . comment ; } public boolean getDonor ( ) { return this . donor ; } public String getEditedTime ( ) { return this . editedTime ; } public Number getEditedUserId ( ) { return this . editedUserId ; } public String getEditedUsername ( ) { return this . editedUsername ; } public boolean getEnabled ( ) { return this . enabled ; } public String getName ( ) { return this . name ; } public Number getPostId ( ) { return this . postId ; }", "gt": "public boolean getWarned ( )", "prediction": "}\n", "label": 0}
{"id": 9685, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . widgets . Link ; public class LinkTextProperty extends WidgetStringValueProperty { String doGetStringValue ( Object source ) { return ( ( Link ) source ) . getText ( ) ; } void doSetStringValue ( Object source , String value ) { ( ( Link ) source ) . setText ( value == null ? \"\" : value ) ; }", "gt": "public String toString ( )", "prediction": "}\n", "label": 1}
{"id": 7799, "input": "<s> package me . chester . minitruco . core ; import java . util . Random ; import java . util . Vector ; public class Baralho { private boolean limpo ; private Random random = new Random ( ) ; private Vector < Carta > sorteadas = new Vector < Carta > ( ) ; public Baralho ( boolean isLimpo ) { limpo = isLimpo ; } public boolean isLimpo ( ) { return limpo ; } public Carta sorteiaCarta ( ) { Carta c ; String cartas = limpo ? \"A23JQK\" : \"A234567JQK\" ; do { char letra = cartas . charAt ( sorteiaDeZeroA ( cartas . length ( ) - 1 ) ) ; int naipe = Carta . NAIPES [ sorteiaDeZeroA ( 3 ) ] ; c = new Carta ( letra , naipe ) ; } while ( sorteadas . contains", "gt": "( c ) ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 9696, "input": "<s> package br . org . archimedes . interfaces ; import java . io . IOException ; import java . io . InputStream ; import br . org . archimedes . exceptions . InvalidFileFormatException ; import br . org .", "gt": "archimedes . model . Drawing ;", "prediction": "eclipse . eclipse . ;\n", "label": 1}
{"id": 4008, "input": "<s> class T6569057 { static class A < X extends B < ? > > { } static class B < X extends A < ? > > { D < ? extends B < X > > get ( ) { return null ; } } static class D < Y extends B < ? > > { } < E extends B < ? > > void test ( E x , D < B", "gt": "< A < ? > > > d )", "prediction": ")\n", "label": 0}
{"id": 9700, "input": "<s> package de . uos . igf . db3d . dbms . util ; public final class JoinResult { private final Object thisObject ; private final Object argObject ; public JoinResult ( Object thisObject , Object argObject ) { this . thisObject = thisObject ;", "gt": "this . argObject = argObject ;", "prediction": "}\n", "label": 1}
{"id": 1741, "input": "<s> class DALoop1 { String className ( ) { do { try { Class . forName ( \"\" ) ; } catch ( ClassNotFoundException e ) { } } while ( true ) ; } static class QualName { public final int X ; QualName ( ) { throw", "gt": "new Error ( ) ;", "prediction": "\n", "label": 0}
{"id": 9701, "input": "<s> package org . fuzzydb . client ; import org . fuzzydb . core . exceptions . ArchException ; import org . fuzzydb . core . marker . IAttributeContainer ; import org . fuzzydb . core . query . Result ; import org . fuzzydb . core . query . ResultSet ; import org . fuzzydb . core . whirlwind . SearchSpec ; public interface Searchable { < E extends IAttributeContainer > ResultSet < Result < E > > query ( Class < E > resultClazz , SearchSpec search ) throws ArchException ; < E extends IAttributeContainer > ResultSet < Result < E > > query ( Class < E > resultClazz , SearchSpec search ,", "gt": "int fetchSize ) throws ArchException ;", "prediction": ") ;\n", "label": 1}
{"id": 8460, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends Runnable , S extends", "gt": "String > void disjointness ( )", "prediction": ")\n", "label": 0}
{"id": 9711, "input": "<s> package org . modelgoon . jdt . editparts ; import org . eclipse . draw2d . ConnectionAnchor ; import org . eclipse . draw2d . IFigure ; import org . eclipse . gef . ConnectionEditPart ; import org . eclipse . gef . Request ; import org . eclipse . jdt . core . IJavaElement ; import org . modelgoon . classes . figures . FeatureFigure ; import org . modelgoon . core . ui . AbstractComponentEditPart ; import org . modelgoon . jdt . model . Field ; public class FieldEditPart extends AbstractComponentEditPart < Field > implements JavaElementProvider { FeatureFigure figure ; public ConnectionAnchor getSourceConnectionAnchor ( final ConnectionEditPart connection ) { return null ; } public ConnectionAnchor getTargetConnectionAnchor ( final ConnectionEditPart connection ) { return null ; } public ConnectionAnchor getSourceConnectionAnchor ( final Request request ) { return null ; } public ConnectionAnchor getTargetConnectionAnchor ( final Request request ) { return null ; } @ Override protected void doRefreshVisuals ( final Field model ) { String attributeString = model . getName ( ) ; if ( ! model . isLiteral ( ) ) { attributeString = model . getVisibility ( ) . getVisibilityString ( ) + model . getName ( ) + \":\" + model . getType ( ) . getName ( ) ; } this . figure . setStatic ( model . isStatic ( ) || model . isLiteral ( ) ) ; this . figure . setFeatureSummary ( attributeString ) ; } @ Override protected IFigure createFigure ( ) { this . figure = new FeatureFigure ( ) ;", "gt": "return this . figure ;", "prediction": "}\n", "label": 1}
{"id": 2357, "input": "<s> package com . farpost . ldt ; public class TestExecutionException extends RuntimeException { public", "gt": "TestExecutionException ( Exception cause )", "prediction": "\n", "label": 0}
{"id": 9715, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public class HheaTable implements Table { private short ascender ; private short descender ; private short lineGap ; private short advanceWidthMax ; private short minLeftSideBearing ; private short minRightSideBearing ; private short xMaxExtent ; private short caretSlopeRise ; private short caretSlopeRun ; private short metricDataFormat ; private short numberOfHMetrics ; @ SuppressWarnings ( \"unused\" ) protected HheaTable ( DirectoryEntry de , RandomAccessFile raf ) throws IOException { raf . seek ( de . getOffset ( ) ) ; int version = raf . readInt ( ) ; ascender = raf . readShort ( ) ; descender = raf . readShort ( ) ; lineGap = raf . readShort ( ) ; advanceWidthMax = raf . readShort ( ) ; minLeftSideBearing = raf . readShort ( ) ; minRightSideBearing = raf . readShort ( ) ; xMaxExtent = raf . readShort ( ) ; caretSlopeRise = raf . readShort ( ) ; caretSlopeRun = raf . readShort ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { raf . readShort ( ) ; } metricDataFormat = raf . readShort ( ) ; numberOfHMetrics = raf", "gt": ". readShort ( ) ;", "prediction": ";\n", "label": 1}
{"id": 6140, "input": "<s> package org . ofbiz . accounting . period ; import java . sql . Date ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; public class PeriodServices { public static String module = PeriodServices . class . getName ( ) ; public static final String resource = \"AccountingUiLabels\" ; public static Map < String , Object > findLastClosedDate ( DispatchContext dctx , Map < String , ? > context ) { Delegator delegator = dctx . getDelegator ( ) ; String organizationPartyId = ( String ) context . get ( \"organizationPartyId\" ) ; String periodTypeId = ( String ) context . get ( \"periodTypeId\" ) ; Date findDate = ( Date ) context . get ( \"findDate\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( findDate == null ) { findDate = new Date ( UtilDateTime . nowTimestamp ( ) . getTime ( ) ) ; } Timestamp lastClosedDate = null ; GenericValue lastClosedTimePeriod = null ; Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; try { List < EntityCondition > findClosedConditions = UtilMisc . toList ( EntityCondition . makeConditionMap ( \"organizationPartyId\" , organizationPartyId ) , EntityCondition . makeCondition ( \"thruDate\" , EntityOperator . LESS_THAN_EQUAL_TO , findDate ) , EntityCondition . makeConditionMap ( \"isClosed\" , \"Y\" ) ) ; if ( ( periodTypeId != null ) && ! ( periodTypeId . equals ( \"\" ) ) ) { findClosedConditions . add ( EntityCondition . makeConditionMap ( \"periodTypeId\" , periodTypeId ) ) ; } List < GenericValue > closedTimePeriods = delegator . findList ( \"CustomTimePeriod\" , EntityCondition . makeCondition ( findClosedConditions ) , UtilMisc . toSet ( \"customTimePeriodId\" , \"periodTypeId\" , \"isClosed\" , \"fromDate\" , \"thruDate\" ) , UtilMisc . toList ( \"thruDate DESC\" ) , null , false ) ; if ( ( closedTimePeriods != null ) && ( closedTimePeriods . size ( ) > 0 ) && ( closedTimePeriods . get ( 0 ) . get ( \"thruDate\" ) != null ) ) {", "gt": "lastClosedTimePeriod = closedTimePeriods . get ( 0 ) ;", "prediction": "}\n", "label": 0}
{"id": 9723, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"pageUrl\" , \"comment\" , \"checkinType\" } ) @ XmlRootElement ( name = \"CheckInFile\" ) public class CheckInFile { protected String pageUrl ; protected String comment ; @ XmlElement ( name = \"CheckinType\" ) protected String checkinType ; public String getPageUrl ( ) { return pageUrl ; } public void setPageUrl ( String value ) { this . pageUrl = value ; } public String getComment ( ) { return comment ; } public void setComment ( String value ) {", "gt": "this . comment = value ;", "prediction": "\n", "label": 1}
{"id": 2867, "input": "<s> package org . dawb . workbench . ui . editors . test ; import java . io . File ; import org . dawb . tango . extensions . editors . MultiScanEditor ; import org . dawb . tango . extensions . editors . MultiScanMultiEditor ; import org . eclipse . core . filesystem . EFS ; import org . eclipse . core . filesystem . IFileStore ; import org . eclipse . core . runtime . Platform ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . ide . FileStoreEditorInput ; import org . junit . Test ; import org . osgi . framework . Bundle ; import fable . framework . toolbox . EclipseUtils ; public class EditorsTest { @ Test public void testOpeningSpecEditor1 ( ) throws Throwable { testSpec ( \"inhouse_testfile_one_scan.dat\" , \"Scan 1\" , \"L\" , \"MA0\" , \"MA1\" , \"MA2\" , \"MA3\" ) ; } @ Test public void testOpeningSpecEditor2 ( ) throws Throwable { testSpec ( \"optics_april20110402.dat\" , \"Scan 3\" , \"pico0\" , \"pico1\" , \"pico2\" , \"pico3\" , \"pico4\" ) ; testSpec ( \"optics_april20110402.dat\" , \"Scan 150\" , \"pico0\" , \"pico1\" , \"pico2\" , \"pico3\" , \"pico4\" ) ; testSpec ( \"optics_april20110402.dat\" , \"Scan 300\" , \"pico0\" , \"pico1\" , \"pico2\" , \"pico3\" , \"pico4\" ) ; } private void testSpec ( String fileName , String scanName , String ... dataNames ) throws Exception { final Bundle bun = Platform . getBundle ( \"org.dawb.workbench.ui.test\" ) ; String path = ( bun . getLocation ( ) + \"/src/org/dawb/workbench/ui/editors/test/\" + fileName ) ; path = path . substring ( \"reference:file:\" . length ( ) ) ; if ( path . startsWith ( \"/C:\" ) ) path = path . substring ( 1 ) ; final IWorkbenchPage page = EclipseUtils . getPage ( ) ; final IFileStore externalFile = EFS . getLocalFileSystem ( ) . fromLocalFile ( new File ( path ) ) ; final long startSize = Runtime . getRuntime (", "gt": ") . totalMemory ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9724, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . service . test ; import java . io . File ; import java . util . ArrayList ; import java . util . GregorianCalendar ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . Before ; import org . junit . After ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . common . utils . FileUtils ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; import org . nuxeo . ecm . core . storage . sql . SQLRepositoryTestCase ; import org . nuxeo . ecm . platform . pictures . tiles . api . PictureTiles ; import org . nuxeo . ecm . platform . pictures . tiles . api . adapter . PictureTilesAdapter ; public class TestAdapters extends SQLRepositoryTestCase { @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.platform.types.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.commandline.executor\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.picture.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.picture.core\" ) ; deployContrib ( \"org.nuxeo.ecm.platform.pictures.tiles\" , \"OSGI-INF/pictures-tiles-framework.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.platform.pictures.tiles\" , \"OSGI-INF/pictures-tiles-contrib.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.platform.pictures.tiles\" , \"OSGI-INF/pictures-tiles-adapter-contrib.xml\" ) ; openSession ( ) ; } @ After public void tearDown ( ) throws Exception { closeSession ( ) ; super . tearDown ( ) ; } @ Test public void testAdapter ( ) throws Exception { DocumentModel root = session . getRootDocument ( ) ; DocumentModel doc = session . createDocumentModel ( root . getPathAsString ( ) , \"file\" , \"File\" ) ; doc . setProperty ( \"dublincore\" , \"title\" , \"MyDoc\" ) ; doc . setProperty ( \"dublincore\" , \"coverage\" , \"MyDocCoverage\" ) ; doc . setProperty ( \"dublincore\" , \"modified\" , new GregorianCalendar ( ) ) ; File file = FileUtils . getResourceFileFromContext ( \"test.jpg\" ) ; Blob image = new FileBlob ( file ) ; doc . setProperty ( \"file\" , \"content\" , image ) ; doc . setProperty ( \"file\" , \"filename\" , \"test.jpg\" ) ; doc = session . createDocument ( doc ) ; session . save ( ) ; assertTilingIsWorkingFor ( doc ) ; } protected void assertTilingIsWorkingFor ( DocumentModel doc ) throws Exception { PictureTilesAdapter tilesAdapter = doc . getAdapter ( PictureTilesAdapter . class ) ; assertNotNull ( tilesAdapter ) ; PictureTiles tiles = tilesAdapter . getTiles ( 255 , 255 , 15 ) ; assertNotNull ( tiles ) ; PictureTiles tiles2 = tilesAdapter . getTiles ( 255 , 255 , 20 ) ; assertNotNull ( tiles2 ) ; } @ Test public void testAdapterOnPicture ( ) throws Exception { DocumentModel root = session . getRootDocument ( ) ; DocumentModel picture = session . createDocumentModel ( root . getPathAsString ( ) , \"picture1\" , \"Picture\" ) ; picture . setProperty ( \"dublincore\" , \"description\" , \"test picture\" ) ; picture . setProperty ( \"dublincore\" , \"modified\" , new GregorianCalendar ( ) ) ; File file = FileUtils . getResourceFileFromContext ( \"test.jpg\" ) ; Blob image = new FileBlob ( file ) ; List < Map < String , Object > > viewsList = getDefaultViewsList ( image ) ; picture . getProperty ( \"picture:views\" ) . setValue ( viewsList ) ; picture = session . createDocument ( picture ) ; session . save ( ) ; assertTilingIsWorkingFor ( picture ) ; } @ Test public void testAdapterOnPictureWithOriginalJpegView ( ) throws Exception { DocumentModel root = session . getRootDocument ( ) ; DocumentModel picture = session . createDocumentModel ( root . getPathAsString ( ) , \"picture1\" , \"Picture\" ) ; picture . setProperty ( \"dublincore\" , \"description\" , \"test picture\" ) ; picture . setProperty ( \"dublincore\" , \"modified\" , new GregorianCalendar ( ) ) ; File file = FileUtils . getResourceFileFromContext ( \"test.jpg\" ) ; Blob image = new FileBlob ( file ) ; List < Map < String , Object > > viewsList = getDefaultViewsList ( image ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( \"title\" , \"OriginalJpeg\" ) ; map . put ( \"description\" , \"OriginalJpeg Size\" ) ; map . put ( \"filename\" , \"test.jpg\" ) ; map . put ( \"tag\" , \"originalJpeg\" ) ; map . put ( \"width\" , 3872 ) ; map . put ( \"height\" , 2592 ) ; image . setFilename ( \"OriginalJpeg\" + \"_\" + \"test.jpg\" ) ; map . put ( \"content\" , image ) ; viewsList . add ( map ) ; picture . getProperty ( \"picture:views\" ) . setValue ( viewsList ) ; picture = session . createDocument ( picture ) ; session . save ( ) ; assertTilingIsWorkingFor ( picture ) ; } protected List < Map < String , Object > > getDefaultViewsList ( Blob image ) { List < Map < String , Object > > viewsList = new ArrayList < Map < String , Object > > ( ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( \"title\" , \"Medium\" ) ; map . put ( \"description\" , \"Medium Size\" ) ; map . put ( \"filename\" , \"test.jpg\" ) ; map . put ( \"tag\" , \"medium\" ) ; map . put ( \"width\" , 3872 ) ; map . put ( \"height\" , 2592 ) ; image .", "gt": "setFilename ( \"Medium\" + \"_\" + \"test.jpg\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 5709, "input": "<s> package firstSentence ; public class B extends A {", "gt": "public void m ( )", "prediction": "if ( )\n", "label": 0}
{"id": 9742, "input": "<s> package org . eclipse . ui . internal . forms . widgets ; import java . util . Hashtable ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Canvas ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; public class ControlSegment extends ObjectSegment implements IFocusSelectable { private boolean fill ; private int width = SWT . DEFAULT ; private int height = SWT . DEFAULT ; public ControlSegment ( ) { } public void setFill ( boolean fill ) { this . fill = fill ; } public void setWidth ( int width ) { this . width = width ; } public void setHeight ( int height ) { this . height = height ; } public Control getControl ( Hashtable resourceTable ) { Object obj = resourceTable . get ( getObjectId ( ) ) ; if ( obj instanceof Control ) { Control c = ( Control ) obj ; if ( ! c . isDisposed ( ) ) return c ; } return null ; } protected Point getObjectSize ( Hashtable resourceTable , int wHint ) { Control control = getControl ( resourceTable ) ; if ( control == null ) return new Point ( 0 , 0 ) ; int realWhint = FormUtil . getWidthHint ( wHint , control ) ; Point size = control . computeSize ( realWhint , SWT . DEFAULT ) ; if ( realWhint != SWT . DEFAULT && fill ) size . x = Math . max ( size . x , realWhint ) ; if ( width != SWT . DEFAULT ) size . x = width ; if ( height != SWT . DEFAULT ) size . y = height ; return size ; } public void layout ( GC gc , int width , Locator loc , Hashtable resourceTable , boolean selected ) { super . layout ( gc , width , loc , resourceTable , selected ) ; Control control = getControl ( resourceTable ) ; if ( control != null ) control . setBounds", "gt": "( getBounds ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9496, "input": "<s> package com . b3rwynmobile . fayeclient . autobahn ; public class WampConnectionHandler implements Wamp . ConnectionHandler { public void onOpen ( ) { } public", "gt": "void onClose ( int code , String reason )", "prediction": "void ( )\n", "label": 0}
{"id": 9756, "input": "<s> package org . restlet . test . ext . jaxrs . core ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . HashMap ; import java . util . Map ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . ext . RuntimeDelegate ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import org . restlet . data . Reference ; import org . restlet . ext . jaxrs . ExtendedUriBuilder ; import org . restlet . ext . jaxrs . internal . core . UriBuilderImpl ; import org . restlet . test . ext . jaxrs . services . car . CarListResource ; import org . restlet . test . ext . jaxrs . services . car . CarResource ; import org . restlet . test . ext . jaxrs . services . resources . SimpleTrain ; @ SuppressWarnings ( \"all\" ) public class UriBuilderImplTest extends TestCase { private static final String TEMPL_VARS_EXPECTED = \"abc://username:password@www.secure.org:8080/def/ghi;jkl=mno/pqr;stu=vwx?ABC=DEF&GHI=JKL#MNO\" ; private static final URI URI_1 ; static { try { URI_1 = new URI ( \"http://localhost/path1/path2\" ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( \"Can not initialize JaxRsUriBuilderTest\" ) ; } } static void assertEqualsURI ( String expectedUri , URI actualUri ) throws URISyntaxException { assertEquals ( expectedUri , actualUri . toString ( ) ) ; assertEquals ( new URI ( expectedUri ) . toString ( ) , actualUri . toString ( ) ) ; } static void assertEqualsURI ( String expectedUri , UriBuilder actualBuilder ) throws Exception { assertEqualsURI ( expectedUri , actualBuilder , true ) ; } static void assertEqualsURI ( String expectedUri , UriBuilder actualBuilder , boolean encode ) throws Exception { URI actual ; if ( encode ) actual = actualBuilder . buildFromEncoded ( ) ; else actual = actualBuilder . build ( ) ; assertEqualsURI ( expectedUri , actual ) ; } static void assertEqualsUriSlashAllowed ( String expectedUri , UriBuilder actual ) throws URISyntaxException { try { assertEqualsURI ( expectedUri , actual . build ( ) ) ; } catch ( AssertionFailedError ife ) { assertEqualsURI ( expectedUri + \"/\" , actual . build ( ) ) ; } } private static void assertEqualUriBuilder ( String expectedScheme , String expectedUserInfo , String expectedHost , String expectedPort , String expectedPath , String expectedQuery , UriBuilder actualUriBuilder , boolean compareResult ) throws Exception { if ( actualUriBuilder . getClass ( ) . getPackage ( ) . getName ( ) . startsWith ( \"org.restlet.ext.jaxrs\" ) ) { assertEquals ( expectedScheme , getScheme ( actualUriBuilder ) ) ; assertEquals ( expectedUserInfo , getUserInfo ( actualUriBuilder ) ) ; assertEquals ( expectedHost , getHost ( actualUriBuilder ) ) ; assertEquals ( expectedPort , getPort ( actualUriBuilder ) ) ; final String actPath = getPath ( actualUriBuilder ) ; try { assertEquals ( expectedPath , actPath ) ; } catch ( junit . framework . ComparisonFailure cf ) { if ( expectedPath == null ) assertEquals ( \"\" , actPath ) ; } CharSequence actualQuery = getQuery ( actualUriBuilder ) ; if ( actualQuery != null ) { actualQuery = actualQuery . toString ( ) ; } assertEquals ( expectedQuery , actualQuery ) ; } if ( compareResult ) { UriBuilder expectedUriBuilder = RuntimeDelegate . getInstance ( ) . createUriBuilder ( ) ; if ( expectedScheme != null ) { expectedUriBuilder . scheme ( expectedScheme ) ; } if ( expectedUserInfo != null ) { expectedUriBuilder . userInfo ( expectedUserInfo ) ; } if ( expectedHost != null ) { expectedUriBuilder . host ( expectedHost ) ; } if ( expectedUriBuilder instanceof UriBuilderImpl ) { ( ( UriBuilderImpl ) expectedUriBuilder ) . port ( expectedPort ) ; } else if ( expectedUriBuilder instanceof ExtendedUriBuilder ) { ( ( ExtendedUriBuilder ) expectedUriBuilder ) . port ( expectedPort ) ; } else { if ( expectedPort == null || expectedPort . equals ( \"\" ) ) { expectedUriBuilder . port ( - 1 ) ; } else { try { int portInt = Integer . valueOf ( expectedPort ) ; } catch ( NumberFormatException e ) { System . out . println ( \"Sorry, could not do this test with an expected port \\\"\" + expectedPort + \"\\\" and an UriBuilder of type \" + expectedUriBuilder . getClass ( ) ) ; } } } expectedUriBuilder . path ( expectedPath ) ; if ( expectedQuery != null ) { expectedUriBuilder . replaceQuery ( expectedQuery ) ; } String expectedURI = expectedUriBuilder . build ( ) . toString ( ) ; String atualURI = actualUriBuilder . build ( ) . toString ( ) ; assertEquals ( expectedURI , atualURI ) ; } } static String getFieldValue ( UriBuilder uriBuilder , String fieldName ) throws Exception { Field queryField ; try { queryField = uriBuilder . getClass ( ) . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException e ) { queryField = uriBuilder . getClass ( ) . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } queryField . setAccessible ( true ) ; final Object value = queryField . get ( uriBuilder ) ; if ( value == null ) { return null ; } return value . toString ( ) ; } private static String getHost ( UriBuilder uriBuilder ) throws Exception { return getFieldValue ( uriBuilder , \"host\" ) ; } @ SuppressWarnings ( \"unchecked\" ) private static String getPath ( UriBuilder uriBuilder ) throws Exception { final Object path = getFieldValue ( uriBuilder , \"path\" ) ; if ( path == null ) { return null ; } return path . toString ( ) ; } private static String getPort ( UriBuilder uriBuilder ) throws Exception { return getFieldValue ( uriBuilder , \"port\" ) ; } private static String getQuery ( UriBuilder uriBuilder ) throws Exception { return getFieldValue ( uriBuilder , \"query\" ) ; } private static String getScheme ( UriBuilder uriBuilder ) throws Exception { return getFieldValue ( uriBuilder , \"scheme\" ) ; } private static String getUserInfo ( UriBuilder uriBuilder ) throws Exception { return getFieldValue ( uriBuilder , \"userInfo\" ) ; } public static void main ( String [ ] args ) { System . out . println ( Reference . encode ( \"%\" ) ) ; } private UriBuilder uriBuilder ; private UriBuilder uriBuilderWithVars ; private URI buildFromTemplVarsWithMap ( UriBuilder uriBuilder ) { final Map < String , Object > vars = new HashMap < String , Object > ( ) ; vars . put ( \"scheme\" , \"abc\" ) ; vars . put ( \"userInfo\" , \"username:password\" ) ; vars . put ( \"host\" , \"www.secure.org\" ) ; vars . put ( \"port\" , \"8080\" ) ; vars . put ( \"path1\" , \"def\" ) ; vars . put ( \"path2\" , \"ghi\" ) ;", "gt": "vars . put ( \"mp2Name\" , \"jkl\" ) ;", "prediction": "}\n", "label": 1}
{"id": 6184, "input": "<s> package org . ofbiz . crowd . user ; import java . util . Properties ; import java . util . List ; import java . util . Arrays ; import java . util . ArrayList ; import org . ofbiz . base . util . UtilProperties ; import com . atlassian . crowd . integration . soap . SOAPAttribute ; public class UserAttributeMapper { private List < SOAPAttribute > attributes ; public UserAttributeMapper ( SOAPAttribute [ ] attributes ) { this ( ) ; setAttributes ( attributes ) ; } public UserAttributeMapper ( ) { this . attributes = new ArrayList < SOAPAttribute > ( ) ; } public SOAPAttribute [ ] getAttributes ( ) { SOAPAttribute [ ] attrs = new SOAPAttribute [ attributes . size ( ) ] ; int index = 0 ; for ( SOAPAttribute a : attributes ) { attrs [ index ] = a ; index ++ ; } return attrs ; } public void setAttributes ( SOAPAttribute [ ] attributes ) { this . attributes . addAll ( Arrays . asList ( attributes ) ) ; } public String getFirstName ( ) { return getOFBizValue ( \"firstName\" ) ; } public void setFirstName ( String firstName ) { makeAttribute ( \"firstName\" , firstName ) ; } public String getLastName ( ) { return getOFBizValue ( \"lastName\" ) ; } public void setLastName ( String lastName ) { makeAttribute ( \"lastName\" , lastName ) ; } public String getEmail ( ) { return getOFBizValue ( \"email\" ) ; } public void setEmail ( String email ) { makeAttribute ( \"email\" , email ) ; } private String getOFBizValue ( String name ) { String key = getCrowdKey ( name ) ; if ( key != null ) { for ( SOAPAttribute a : attributes ) { if ( a . getName ( ) . equals ( key ) ) { if ( a . getValues ( ) != null && a . getValues ( ) . length > 0 ) { return a . getValues ( ) [ 0 ] ; } } } } return null ; } private String getCrowdKey ( String name ) { Properties props = UtilProperties . getProperties ( \"crowd.properties\" ) ; return ( String ) props . get ( \"crowd.attribute.map.\" + name ) ; } private SOAPAttribute makeAttribute ( String name , String value ) { SOAPAttribute attr = new SOAPAttribute ( ) ; attr .", "gt": "setName ( getCrowdKey ( name ) ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9757, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . part . EditorActionBarContributor ; import org . eclipse . ui . tests . harness . util . CallHistory ; public class MockEditorActionBarContributor extends EditorActionBarContributor { protected CallHistory callHistory ; protected IEditorPart target ; protected int ACTION_COUNT = 5 ; protected MockAction [ ] actions ; public MockEditorActionBarContributor ( ) { super ( ) ; callHistory = new CallHistory ( this ) ; } public CallHistory getCallHistory ( ) { return callHistory ; } public void init ( IActionBars bars ) { callHistory . add ( \"init\" ) ; actions = new MockAction [ ACTION_COUNT ] ; for ( int nX = 0 ; nX < ACTION_COUNT ; nX ++ ) { actions [ nX ] = new MockAction ( Integer . toString ( nX ) ) ; if ( nX % 2 > 0 ) actions [ nX ] . setEnabled ( false ) ; } super . init ( bars ) ; } public void contributeToToolBar ( IToolBarManager toolBarManager ) { for ( int i = 0 ; i < actions . length ; ++ i ) { toolBarManager . add ( actions [ i ] ) ; } } public void setActiveEditor ( IEditorPart targetEditor ) { callHistory . add ( \"setActiveEditor\" ) ; target = targetEditor ; } public IEditorPart getActiveEditor ( ) { return target ; } public MockAction [ ] getActions ( ) { return actions ; } public void enableActions ( boolean b ) { for ( int nX = 0 ; nX < ACTION_COUNT ; nX ++ ) { actions [ nX", "gt": "] . setEnabled ( b ) ;", "prediction": ";\n", "label": 1}
{"id": 7092, "input": "<s> package com . sun . tools . javac . file ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Writer ; import java . net . URI ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . charset . CharsetDecoder ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . file . JavacFileManager . Archive ; import com . sun . tools . javac . file . RelativePath . RelativeDirectory ; import com . sun . tools . javac . file . RelativePath . RelativeFile ; import com . sun . tools . javac . util . List ; import java . lang . ref . Reference ; import java . lang . ref . SoftReference ; public class ZipArchive implements Archive { public ZipArchive ( JavacFileManager fm , ZipFile zfile ) throws IOException { this ( fm , zfile , true ) ; } protected ZipArchive ( JavacFileManager fm , ZipFile zfile , boolean initMap ) throws IOException { this . fileManager = fm ; this . zfile = zfile ; this . map = new HashMap < RelativeDirectory , List < String > > ( ) ; if ( initMap ) initMap ( ) ; } protected void initMap ( ) throws IOException { for ( Enumeration < ? extends ZipEntry > e = zfile . entries ( ) ; e . hasMoreElements ( ) ; ) { ZipEntry entry ; try { entry = e . nextElement ( ) ; } catch ( InternalError ex ) { IOException io = new IOException ( ) ; io . initCause ( ex ) ; throw io ; } addZipEntry ( entry ) ; } } void addZipEntry ( ZipEntry entry ) { String name = entry . getName ( ) ; int i = name . lastIndexOf ( '/' ) ; RelativeDirectory dirname = new RelativeDirectory ( name . substring ( 0 , i + 1 ) ) ; String basename = name . substring ( i + 1 ) ; if ( basename . length ( ) == 0 ) return ; List < String > list = map . get ( dirname ) ; if ( list == null ) list = List . nil ( ) ; list = list . prepend ( basename ) ; map . put ( dirname , list ) ; } public boolean contains ( RelativePath name ) { RelativeDirectory dirname = name . dirname ( ) ; String basename = name . basename ( ) ; if ( basename . length ( ) == 0 ) return false ; List < String > list = map . get ( dirname ) ; return ( list != null && list . contains ( basename ) ) ; } public List < String > getFiles ( RelativeDirectory subdirectory ) { return map . get ( subdirectory ) ; } public JavaFileObject getFileObject ( RelativeDirectory subdirectory , String file ) { ZipEntry ze = new RelativeFile ( subdirectory , file ) . getZipEntry ( zfile ) ; return new ZipFileObject ( this , file , ze ) ; } public Set < RelativeDirectory > getSubdirectories ( ) { return map . keySet ( ) ; } public void close ( ) throws IOException { zfile . close ( ) ; } @ Override public String toString ( ) { return \"ZipArchive[\" + zfile . getName ( ) + \"]\" ; } private File getAbsoluteFile ( ) { File absFile = ( absFileRef == null ? null : absFileRef . get ( ) ) ; if ( absFile == null ) { absFile = new File ( zfile . getName ( ) ) . getAbsoluteFile ( ) ; absFileRef = new SoftReference < File > ( absFile ) ; } return absFile ; } protected JavacFileManager fileManager ; protected final Map < RelativeDirectory , List < String > > map ; protected final ZipFile zfile ; protected Reference < File > absFileRef ; public static class ZipFileObject extends BaseFileObject { private String name ; ZipArchive zarch ; ZipEntry entry ; protected ZipFileObject ( ZipArchive zarch , String name , ZipEntry entry ) { super ( zarch . fileManager ) ; this . zarch = zarch ; this . name = name ; this . entry = entry ; } public URI toUri ( ) { File zipFile = new File ( zarch . zfile . getName ( ) ) ; return createJarUri ( zipFile , entry . getName ( ) ) ; } @ Override public String getName ( ) { return zarch . zfile . getName ( ) + \"(\" + entry . getName ( ) + \")\" ; } @ Override public String getShortName ( ) { return new File ( zarch . zfile . getName ( ) ) . getName ( ) + \"(\" + entry + \")\" ; } @ Override public JavaFileObject . Kind getKind ( ) { return getKind ( entry . getName ( ) ) ; } @ Override public InputStream openInputStream ( ) throws IOException { return zarch . zfile . getInputStream ( entry ) ; } @ Override public OutputStream openOutputStream ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @ Override public CharBuffer getCharContent ( boolean ignoreEncodingErrors ) throws IOException { CharBuffer cb = fileManager . getCachedContent ( this ) ; if ( cb == null ) { InputStream in = zarch . zfile . getInputStream ( entry ) ; try { ByteBuffer bb = fileManager . makeByteBuffer ( in ) ; JavaFileObject prev = fileManager .", "gt": "log . useSource ( this ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9766, "input": "<s> package org . modelgoon . jdt . communication . editor ; import org . modelgoon . core . Note ; import org . modelgoon . core . editparts . NoteEditPart ; import org . modelgoon . jdt . communication . editParts . CommunicationClassEditPart ; import org . modelgoon . jdt . communication . editParts . CommunicationEditPart ; import org . modelgoon . jdt . editor . ClassModelElementFactory ; import org . modelgoon . jdt . editor . JDTDiagramEditor ; import org . modelgoon . jdt . editparts . JDTClassDiagramEditPart ; import org . modelgoon . jdt . model . CommunicationRelationship ; import org . modelgoon . jdt . model . UMLClass ; import org . modelgoon . jdt . model . UMLModel ; public class JDTCommunicationDiagramEditor extends JDTDiagramEditor { public JDTCommunicationDiagramEditor ( ) { super ( new UMLModel ( ) ) ; this . modelLoader . addMapping ( \"org/modelgoon/jdt/xml/UMLModel.cas\" ) ; this . modelLoader . addMapping ( \"org/modelgoon/jdt/xml/CommunicationDiagram.cas\" ) ; setModelElementFactory ( new ClassModelElementFactory ( this ) ) ; registerEditPart ( UMLModel . class , JDTClassDiagramEditPart . class ) ; registerEditPart ( UMLClass", "gt": ". class , CommunicationClassEditPart . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4234, "input": "<s> package com . l7 . mitra . client . ui ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; public class ConfigManager { public ConfigManager ( ) { } public static void loadProperties ( File file ) { Properties props = new Properties ( ) ; try { props . load ( new FileInputStream ( file ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; MessageLog . getInstance ( ) . addMessage ( \"Unable to load properties: \" + e . getMessage ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; MessageLog . getInstance ( ) . addMessage ( \"Unable to load properties: \" + e . getMessage ( ) ) ; } OAuthPropertyBean pBean = OAuthPropertyBean . getInstance ( ) ; pBean . setAzHost ( props . getProperty ( OAuthPropertyBean . AZ_HOST , \"\" ) ) ; pBean . setAzPort ( props . getProperty ( OAuthPropertyBean . AZ_PORT , \"\" ) ) ; pBean . setAzUri ( props . getProperty ( OAuthPropertyBean . AZ_URI , \"\" ) ) ; pBean . setClientId ( props . getProperty ( OAuthPropertyBean . CLIENT_ID , \"\" ) ) ; pBean . setClientSecret ( props . getProperty ( OAuthPropertyBean . CLIENT_SECRET , \"\" ) ) ; pBean . setScope ( props . getProperty ( OAuthPropertyBean . SCOPE , \"\" ) ) ; pBean . setState ( props . getProperty ( OAuthPropertyBean . STATE , \"\" ) ) ; pBean . setAccessUri ( props . getProperty ( OAuthPropertyBean . ACCESS_URI , \"\" ) ) ; } public static void saveProperties ( File file ) { Properties", "gt": "props = new Properties ( ) ;", "prediction": "\n", "label": 0}
{"id": 9792, "input": "<s> package org . apache . lucene ; import java . util . GregorianCalendar ; import java . io . PrintWriter ; import java . io . StringWriter ; import org . apache . lucene . util . LuceneTestCase ; import junit . framework . TestSuite ; import junit . textui . TestRunner ; import org . apache . lucene . store . * ; import org . apache . lucene . document . * ; import org . apache . lucene . analysis . * ; import org . apache . lucene . index . * ; import org . apache . lucene . search . * ; import org . apache . lucene . queryParser . * ; public class TestSearch extends LuceneTestCase { public static void main ( String args [ ] ) { TestRunner . run ( new TestSuite ( TestSearch . class ) ) ; } public void testSearch ( ) throws Exception { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; doTestSearch ( pw , false ) ; pw . close ( ) ; sw . close ( ) ; String multiFileOutput = sw . getBuffer ( ) . toString ( ) ; sw = new StringWriter ( ) ; pw = new PrintWriter ( sw , true ) ; doTestSearch ( pw , true ) ; pw . close ( ) ; sw . close ( ) ; String singleFileOutput = sw . getBuffer ( ) . toString ( ) ; assertEquals ( multiFileOutput , singleFileOutput ) ; } private void doTestSearch ( PrintWriter out , boolean useCompoundFile ) throws Exception { Directory directory = new RAMDirectory ( ) ; Analyzer analyzer = new SimpleAnalyzer ( ) ; IndexWriter writer = new IndexWriter ( directory , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; writer . setUseCompoundFile ( useCompoundFile ) ; String [ ] docs = { \"a b c d e\" , \"a b c d e a b c d e\" , \"a b c d e f g h i j\" , \"a c e\" , \"e c a\" , \"a c e a c e\" , \"a c e a b c\" } ; for ( int j = 0 ; j < docs . length ; j ++ ) { Document d = new Document ( ) ; d . add ( new Field ( \"contents\" , docs [ j ] , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( d ) ; } writer . close ( ) ; Searcher searcher = new IndexSearcher ( directory ) ; String [ ] queries = { \"a b\" , \"\\\"a b\\\"\" , \"\\\"a b c\\\"\" , \"a c\" , \"\\\"a c\\\"\" , \"\\\"a c e\\\"\" , } ; ScoreDoc [ ] hits = null ; QueryParser parser = new QueryParser ( \"contents\" , analyzer ) ; parser . setPhraseSlop ( 4 ) ; for ( int j = 0 ; j < queries . length ; j ++ ) { Query query = parser . parse ( queries [ j ] ) ; out . println ( \"Query: \" + query . toString ( \"contents\" ) ) ; hits = searcher . search ( query , null , 1000 ) . scoreDocs ; out . println ( hits . length + \" total results\" ) ; for ( int i = 0 ; i < hits . length && i < 10 ; i ++ ) { Document d = searcher . doc ( hits [ i ] . doc ) ; out . println ( i + \" \" + hits [ i ] . score + \" \" + d .", "gt": "get ( \"contents\" ) ) ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 1042, "input": "<s> package de . javawi . jstun . test . demo . ice ; import java . io . IOException ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; import de . javawi . jstun . attribute . MessageAttributeException ; import de . javawi . jstun . header . MessageHeaderParsingException ; import de . javawi . jstun . test . DiscoveryInfo ; import de . javawi . jstun . test . DiscoveryTest ; import de . javawi . jstun . test . demo . ice . Candidate . CandidateType ; import de . javawi . jstun . util . Address ; import de . javawi . jstun . util . UtilityException ; public class ICENegociator { private static final Logger LOGGER = LoggerFactory . getLogger ( ICENegociator . class ) ; private final static int LOCAL_PREFERENCE = 0 ; private final static int SERVER_REFLEXIVE_PREFERENCE = 42 ; private final static int PEER_REFLEXIVE_PREFERENCE = 84 ; private final static int RELAYED_PREFERENCE = 126 ; private short componentId ; private String stunServer = \"jstun.javawi.de\" ; private int stunPort = 3478 ; HashSet < Candidate > candidates ; public ICENegociator ( short componentId ) { this . componentId = componentId ; candidates = new HashSet < Candidate > ( ) ; } public ICENegociator ( String stunServer , int stunPort , short componentId ) { this . stunServer = stunServer ; this . stunPort = stunPort ; this . componentId = componentId ; candidates = new HashSet < Candidate > ( ) ; } public void gatherCandidateAddresses ( ) { try { candidates = new HashSet < Candidate > ( ) ; Enumeration < NetworkInterface > ifaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( ifaces . hasMoreElements ( ) ) { NetworkInterface iface = ifaces . nextElement ( ) ; Enumeration < InetAddress > iaddresses = iface . getInetAddresses ( ) ; while ( iaddresses . hasMoreElements ( ) ) { InetAddress iaddress = iaddresses . nextElement ( ) ; if ( ! iaddress . isLoopbackAddress ( ) && ! iaddress . isLinkLocalAddress ( ) ) { try { Candidate local = new Candidate ( new Address ( iaddress . getAddress ( ) ) , componentId ) ; candidates . add ( local ) ; DiscoveryTest test = new DiscoveryTest ( iaddress , stunServer , stunPort ) ; DiscoveryInfo di = test . test ( ) ; if ( di . getPublicIP ( ) != null ) { Candidate cand = new Candidate ( new Address ( di . getPublicIP ( ) . getAddress ( ) ) , CandidateType . ServerReflexive , componentId , local ) ; cand . setComponentId ( componentId ) ; candidates . add ( cand ) ; } } catch ( MessageHeaderParsingException mhpe ) { LOGGER . debug ( \"MessageHeaderParsingException while gathering candidate addresses.\" ) ; mhpe . printStackTrace ( ) ; } catch ( MessageAttributeException mae ) { LOGGER . debug ( \"MessageAttributeException while gathering candidate addresses.\" ) ; mae . printStackTrace ( ) ; } catch ( UtilityException ue ) { LOGGER . debug ( \"UtilityException while gathering candidate addresses.\" ) ; ue . printStackTrace ( ) ; } catch ( UnknownHostException uhe ) { LOGGER . debug ( \"MessageHeaderParsingException while gathering candidate addresses.\" ) ; uhe . printStackTrace ( ) ; } catch ( SocketException se ) { LOGGER . debug ( \"SocketException while gathering candidate addresses.\" ) ; se . printStackTrace ( ) ; } catch ( IOException ioe ) { LOGGER . debug ( \"IOException while gathering candidate addresses.\" ) ; ioe . printStackTrace ( ) ; } } } } } catch ( SocketException se ) { LOGGER . debug ( \"SocketException while enumatering over the network cards.\" ) ; se . printStackTrace ( ) ; } } public void prioritizeCandidates ( ) { int numberLocal = 0 ; int numberServerReflexive = 0 ; int numberPeerReflexive = 0 ; int numberRelayed = 0 ; Iterator < Candidate > iterCandidates = candidates . iterator ( ) ; while ( iterCandidates . hasNext ( ) ) { Candidate cand = iterCandidates . next ( ) ; CandidateType type = cand . getCandidateType ( ) ; if ( type == CandidateType . Local ) numberLocal ++ ; else if ( type == CandidateType . ServerReflexive ) numberServerReflexive ++ ; else if ( type == CandidateType . PeerReflexive ) numberPeerReflexive ++ ; else if ( type == CandidateType . Relayed ) numberRelayed ++ ; } iterCandidates = candidates . iterator ( ) ; while ( iterCandidates . hasNext ( ) ) { int typeValue = 0 ; int localValue = 0 ; int componentValue = 0 ; Candidate cand = iterCandidates . next ( ) ; CandidateType type = cand . getCandidateType ( ) ; if ( type == CandidateType . Local ) { typeValue = LOCAL_PREFERENCE ; localValue = numberLocal -- ; } else if ( type == CandidateType . ServerReflexive ) { typeValue = SERVER_REFLEXIVE_PREFERENCE ; localValue = numberServerReflexive -- ; } else if ( type == CandidateType . PeerReflexive ) { typeValue = PEER_REFLEXIVE_PREFERENCE ; localValue = numberPeerReflexive -- ; } else if ( type == CandidateType . Relayed ) { typeValue = RELAYED_PREFERENCE ; localValue = numberRelayed -- ; } componentValue = cand . getComponentId ( ) ; int priority = ( ( 2 ^ 24 ) * typeValue ) + ( ( 2 ^ 8 ) * localValue ) + componentValue ; cand . setPriority ( priority ) ; } } public List < Candidate > getSortedCandidates ( ) { Vector < Candidate > sortedCandidates = new Vector < Candidate > ( candidates ) ; Collections . sort ( sortedCandidates ) ; return sortedCandidates ; } public static void main ( String args [ ] ) { ICENegociator cc = new ICENegociator ( ( short ) 1 ) ; cc . gatherCandidateAddresses ( ) ;", "gt": "cc . prioritizeCandidates ( ) ;", "prediction": "}\n", "label": 0}
{"id": 9811, "input": "<s> package org . apache . lucene . analysis ; import java . io . IOException ; public class TeeTokenFilter extends TokenFilter { SinkTokenizer sink ; public TeeTokenFilter ( TokenStream input , SinkTokenizer sink ) { super ( input ) ; this . sink = sink ; } public", "gt": "Token next ( final Token reusableToken ) throws IOException", "prediction": "( ) ;\n", "label": 1}
{"id": 1246, "input": "<s> package org . bombusim . xmpp ; import java . io . IOException ; import org . bombusim . xmpp . exception . XmppException ; public abstract class XmppObjectListener implements Comparable < XmppObjectListener > { public final static int BLOCK_REJECTED = 0 ; public final static int BLOCK_PROCESSED = 1 ; public final static int NO_MORE_BLOCKS = 2 ; public static final int PRIORITY_STREAM = 50 ; public static final int PRIORITY_AUTH = 100 ; public static final int PRIORITY_AUTH_FALLBACK = 500 ; public static final int PRIORITY_MUC = 1000 ; public static final int PRIORITY_BASIC_IM = 2000 ; public", "gt": "static final int PRIORITY_DISCO = 2000 ;", "prediction": "void ( ) ;\n", "label": 0}
{"id": 9829, "input": "<s> package org . eclipse . ui . internal . cheatsheets . data ; public interface IPerformWhenItem {", "gt": "public PerformWhen getPerformWhen ( ) ;", "prediction": "return ;\n", "label": 1}
{"id": 183, "input": "<s> package org . ofbiz . pos . component ; import net . xoetrope . swing . XEdit ; import org . ofbiz . pos . screen . PosScreen ; import org . ofbiz . pos . PosTransaction ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . guiapp . xui . XuiSession ; import java . util . Locale ; public class Output { public static final String module = Output . class . getName ( ) ; private Locale defaultLocale = Locale . getDefault ( ) ; protected XuiSession session = null ; protected XEdit output = null ; public Output ( PosScreen page ) { this . output = ( XEdit ) page . findComponent ( \"pos_output\" ) ; this . session = page . getSession ( ) ; this . output . setFocusable ( false ) ; this . clear ( ) ; } public void setLock ( boolean lock ) { if ( lock ) { this . print ( UtilProperties . getMessage ( PosTransaction", "gt": ". resource , \"PosULogin\" , defaultLocale ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9835, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . BitSet ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . IndexWriter . MaxFieldLength ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . search . TimeLimitingCollector . TimeExceededException ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; public class TestTimeLimitingCollector extends LuceneTestCase { private static final int SLOW_DOWN = 47 ; private static final long TIME_ALLOWED = 17 * SLOW_DOWN ; private static final double MULTI_THREAD_SLACK = 7 ; private static final int N_DOCS = 3000 ; private static final int N_THREADS = 50 ; private Searcher searcher ; private final String FIELD_NAME = \"body\" ; private Query query ; public TestTimeLimitingCollector ( String name ) { super ( name ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; final String docText [ ] = { \"docThatNeverMatchesSoWeCanRequireLastDocCollectedToBeGreaterThanZero\" , \"one blah three\" , \"one foo three multiOne\" , \"one foobar three multiThree\" , \"blueberry pancakes\" , \"blueberry pie\" , \"blueberry strudel\" , \"blueberry pizza\" , } ; Directory directory = new RAMDirectory ( ) ; IndexWriter iw = new IndexWriter ( directory , new WhitespaceAnalyzer ( ) , true , MaxFieldLength . UNLIMITED ) ; for ( int i = 0 ; i < N_DOCS ; i ++ ) { add ( docText [ i % docText . length ] , iw ) ; } iw . close ( ) ; searcher = new IndexSearcher ( directory ) ; String qtxt = \"one\" ; for ( int i = 0 ; i < docText . length ; i ++ ) { qtxt += ' ' + docText [ i ] ; } QueryParser queryParser = new QueryParser ( FIELD_NAME , new WhitespaceAnalyzer ( ) ) ; query = queryParser . parse ( qtxt ) ; searcher . search ( query , null , 1000 ) ; } public void tearDown ( ) throws Exception { searcher . close ( ) ; super . tearDown ( ) ; } private void add ( String value , IndexWriter iw ) throws IOException { Document d = new Document ( ) ; d . add ( new Field ( FIELD_NAME , value , Field . Store . NO , Field . Index . ANALYZED ) ) ; iw . addDocument ( d ) ; } private void search ( Collector collector ) throws Exception { searcher . search ( query , collector ) ; } public void testSearch ( ) { doTestSearch ( ) ; } private void doTestSearch ( ) { int totalResults = 0 ; int totalTLCResults = 0 ; try { MyHitCollector myHc = new MyHitCollector ( ) ; search ( myHc ) ; totalResults = myHc . hitCount ( ) ; myHc = new MyHitCollector ( ) ; long oneHour = 3600000 ; Collector tlCollector = createTimedCollector ( myHc , oneHour , false ) ; search ( tlCollector ) ; totalTLCResults = myHc . hitCount ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; assertTrue ( \"Unexpected exception: \" + e , false ) ; } assertEquals ( \"Wrong number of results!\" , totalResults , totalTLCResults ) ; } private Collector createTimedCollector ( MyHitCollector hc , long timeAllowed , boolean greedy ) { TimeLimitingCollector res = new TimeLimitingCollector ( hc , timeAllowed ) ; res . setGreedy ( greedy ) ; return res ; } public void testTimeoutGreedy ( ) { doTestTimeout ( false , true ) ; } public void testTimeoutNotGreedy ( ) { doTestTimeout ( false , false ) ; } private void doTestTimeout ( boolean multiThreaded , boolean greedy ) { MyHitCollector myHc = new MyHitCollector ( ) ; myHc . setSlowDown ( SLOW_DOWN ) ; Collector tlCollector = createTimedCollector ( myHc , TIME_ALLOWED , greedy ) ; TimeExceededException timoutException = null ; try { search ( tlCollector ) ; } catch ( TimeExceededException x ) { timoutException = x ; } catch ( Exception e ) { assertTrue ( \"Unexpected", "gt": "exception: \" + e , false ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2356, "input": "<s> package models ; import java . util . List ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . Id ; import play . db . ebean . Model ; @ Entity public class Device extends Model { private static final long serialVersionUID = 1L ; @ Id public Long id ; @ Column ( columnDefinition = \"TEXT\" ) public String registrationID ; @ Column ( columnDefinition = \"TEXT\" ) public String authorizationToken ; public static Finder < Long , Device > find = new Finder < Long , Device > ( Long . class , Device . class ) ; public static List < Device > all ( ) { return find . all ( ) ; } public static Device get ( Long id ) {", "gt": "return find . byId ( id ) ;", "prediction": "\n", "label": 0}
{"id": 9845, "input": "<s> package org . eclipse . rap . demo ; import org . eclipse . ui . application . * ; public class DemoWorkbenchAdvisor extends WorkbenchAdvisor { public void initialize ( IWorkbenchConfigurer configurer ) { getWorkbenchConfigurer ( ) . setSaveAndRestore ( true ) ;", "gt": "super . initialize ( configurer ) ;", "prediction": "}\n", "label": 1}
{"id": 9570, "input": "<s> public class ArrayCast { String [ ] array = ( String [ ] ) new Object [ 0 ] ; public static void", "gt": "main ( String [ ] args )", "prediction": "( )\n", "label": 0}
{"id": 9858, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . OperationParameters ; import org . nuxeo . ecm . automation . OperationType ; import org . nuxeo . ecm . automation . core . scripting . Scripting ; import org . nuxeo . ecm . core . api . CoreSession ; public class ExecutionRequest { protected Object input ; protected RestOperationContext ctx ; protected Map < String , Object > params ; public ExecutionRequest ( ) { this ( null ) ; } public ExecutionRequest ( Object input ) { ctx = new RestOperationContext ( ) ; this . input = input ; this . params = new HashMap < String , Object > ( ) ; } public void setInput ( Object input ) { this . input = input ; } public Object getInput ( ) { return input ; } public void setContextParam ( String key , Object value ) { ctx . put ( key , value ) ; } public void setContextParam ( String key , String value ) { ctx . put ( key , value ) ; } public void setParam ( String key , Object jsonObject ) { params . put ( key , jsonObject ) ; } public void setParam ( String key , String value ) { if ( value . startsWith ( \"expr:\" ) ) { value = value . substring ( 5 ) . trim ( ) ; if ( value . contains ( \"@{\" ) ) { params . put ( key , Scripting . newTemplate ( value ) ) ; } else { params . put ( key , Scripting . newExpression ( value ) ) ; } } else { params . put ( key , value ) ; } } public Map < String , Object > getParams ( ) { return params ; } public OperationContext createContext ( HttpServletRequest request , CoreSession session ) throws Exception { ctx . addRequestCleanupHandler ( request ) ; ctx . setCoreSession ( session ) ; ctx . setInput ( input ) ; ctx . put ( \"request\" , request ) ; return ctx ; } public OperationChain createChain ( OperationType op ) { OperationChain chain = new OperationChain ( \"operation\" ) ; OperationParameters oparams = new OperationParameters ( op . getId (", "gt": ") , params ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 6684, "input": "<s> package packone ; class Secret { public void greet ( ) { System . out .", "gt": "println ( \"hello\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9888, "input": "<s> package org . nuxeo . ecm . platform . annotations . repository ; import java . net . URI ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . CoreInstance ; import org . nuxeo . ecm . core . api . repository . RepositoryManager ; import org . nuxeo . ecm . platform . annotations . api . AnnotationException ; import org . nuxeo . ecm . platform . annotations . repository . service . AnnotationsRepositoryService ; import org . nuxeo . ecm . platform . annotations . service . PermissionManager ; import org . nuxeo . ecm . platform . url . api . DocumentView ; import org . nuxeo . runtime . api . Framework ; public class DefaultNuxeoPermissionManager implements PermissionManager { private static final Log log = LogFactory . getLog ( DefaultNuxeoPermissionManager . class ) ; private AnnotationsRepositoryService service ; private final URNDocumentViewTranslator translator = new URNDocumentViewTranslator ( ) ; public DefaultNuxeoPermissionManager ( ) { try { service = Framework . getService ( AnnotationsRepositoryService . class ) ; } catch ( Exception e ) { log . error ( e ) ; } } public boolean check ( NuxeoPrincipal user , String permission , URI uri ) throws AnnotationException { DocumentView view = translator . getDocumentViewFromUri ( uri ) ; CoreSession session = null ; try { RepositoryManager mgr = Framework . getService ( RepositoryManager . class ) ; session = mgr . getDefaultRepository ( ) . open ( ) ; DocumentModel model = session . getDocument ( view . getDocumentLocation ( ) . getDocRef ( ) ) ; return service . check ( user , permission , model ) ; } catch ( Exception e ) { throw new AnnotationException ( e ) ; } finally { if ( session != null ) { CoreInstance", "gt": ". getInstance ( ) . close ( session ) ;", "prediction": ";\n", "label": 1}
{"id": 7729, "input": "<s> package com . matburt . mobileorg . Settings ; import android . content . Context ; import android . content . Intent ; import android . preference . Preference ; import android . util . AttributeSet ; import android . view . View ; import android . view . ViewGroup ; import android . widget . LinearLayout ; import android . widget . TextView ; import com . matburt . mobileorg . R ; public class WizardPreferences extends Preference { public WizardPreferences ( Context context ) { super ( context ) ; } public WizardPreferences ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public WizardPreferences ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } @ Override protected View onCreateView ( ViewGroup parent ) { LinearLayout layout = new LinearLayout ( getContext ( ) ) ; LinearLayout . LayoutParams params1 = new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; params1 . weight = 1.0f ; layout . setPadding ( 15 , 10 , 10 , 10 ) ; layout . setOrientation ( LinearLayout . HORIZONTAL ) ; TextView view = new TextView ( getContext ( ) ) ; view . setText ( R . string . rerun_setup_wizard ) ; view . setTextAppearance ( getContext ( ) , android . R . style . TextAppearance_Large ) ; view . setLayoutParams ( params1 ) ; this", "gt": ". setOnPreferenceClickListener ( new OnPreferenceClickListener ( )", "prediction": ";\n", "label": 0}
{"id": 9900, "input": "<s> package litil . ast ; import java . util . * ; public abstract class Type { public AstNode ast ; public static final class Variable extends Type { private static int idx = 1 , nIdx = 0 ; public Type instance ; private int id ; private String name ; public Variable ( ) { id = idx ++ ; name = \"'\" + String . valueOf ( ( char ) ( 'a' + ( id % 26 ) ) ) + ( id / 26 ) ; } public String getName ( ) { return name + ( instance == null ? \"\" : \"/\" + instance ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Variable variable = ( Variable ) o ; if ( id != variable . id ) return false ; return true ; } @ Override public int hashCode ( ) { return id ; } @ Override public String toString ( ) { if ( instance != null ) { return instance . toString ( ) ; } else { return getName ( ) ; } } } public static class Oper extends Type { public static interface Repr { String repr ( String name , List < ? extends Type > args ) ; } public final String name ; public final List < ? extends Type > args ; public final Repr repr ; public Oper ( String name , List < ? extends Type > args ) { this . args = args ; this . name = name ; this . repr = null ; } public Oper ( String name ) { this . args = Collections . emptyList ( ) ; this . name = name ; this . repr = null ; } public Oper ( String name , List < Type > args , Repr repr ) { this . args = args ; this . name = name ; this . repr = repr ; } @ Override public String toString ( ) { if ( repr != null ) { return repr . repr ( name , args ) ; } else if ( args . isEmpty ( ) ) { return name ; } else { StringBuilder res = new StringBuilder ( \"(\" ) ; res . append ( name ) . append ( \":\" ) ; for ( Type type : args ) { res . append ( \" \" ) . append ( type ) ; } res . append ( \")\" ) ; return res . toString ( ) ; } } } public static class RecordType extends Type { public final Map < String , Type > types ; public RecordType ( Map < String , Type > types ) { this . types = types ; } @ Override public String toString ( ) { return types . toString ( ) ; } } public static class TyCon extends Type { public final String name ; public final List < Type > types ; public final Type dataType ; public TyCon ( String name , List < Type > types , Type dataType ) { this", "gt": ". name = name ;", "prediction": ";\n", "label": 1}
{"id": 5810, "input": "<s> package org . remast . util ; import java . util . Date ; import org . joda . time . DateTime ; import org . joda . time . ReadableInstant ; public abstract class DateUtils { private DateUtils ( ) { } public static Date getNow ( ) { return getNowAsDateTime ( ) . toDate ( ) ; } public static DateTime getNowAsDateTime ( ) { final DateTime now = new DateTime ( ) ; final DateTime nowRounded = now . minuteOfDay ( ) . roundHalfCeilingCopy ( ) ; return nowRounded ; } public static DateTime adjustToSameDay ( final DateTime day", "gt": ", final DateTime timeToAdjust , final boolean midnightOnNextDay )", "prediction": ")\n", "label": 0}
{"id": 9904, "input": "<s> package org . fuzzydb . io . core ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . ObjectStreamClass ; import java . nio . ByteBuffer ; public class ArchInStream extends ObjectInputStream { private final int storeId ; private final ClassTokenCache ctc ; private final ClassLoaderInterface cli ; private ArchInStream ( InputStream in , ClassTokenCache ctc , ClassLoaderInterface cli ) throws IOException { super ( in ) ; this . storeId = readInt ( ) ; this . ctc = ctc ; this . cli = cli ; } public static ArchInStream newInputStream ( final ByteBuffer buf , ClassTokenCache ctc , ClassLoaderInterface cli ) throws IOException { InputStream is = new InputStream ( ) { @ Override public synchronized int read ( ) { if ( ! buf . hasRemaining ( ) ) { return - 1 ; } return buf . get ( ) ; } @ Override public synchronized int read ( byte [ ] bytes , int off , int len ) { len = Math . min ( len , buf . remaining ( ) ) ; buf . get ( bytes , off , len ) ; return len ; } } ; return new ArchInStream ( is , ctc , cli ) ; } public static ArchInStream newInputStream ( byte [ ] data , ClassTokenCache ctc , ClassLoaderInterface cli ) throws IOException { InputStream is = new ByteArrayInputStream ( data ) ; return new ArchInStream ( is , ctc , cli ) ; } public static ArchInStream newInputStream ( byte [ ] data , int offset , ClassTokenCache ctc , ClassLoaderInterface cli ) throws IOException { InputStream is = new ByteArrayInputStream ( data , offset , data . length ) ; return new ArchInStream ( is , ctc , cli ) ; } @ Override protected ObjectStreamClass readClassDescriptor ( ) throws IOException , ClassNotFoundException { int i = readInt ( ) ; if ( i == - 1 ) { return ctc . lookupOSCToken ( readInt ( ) ) . getOsc ( cli ) ; } else { StringBuilder sb = new StringBuilder ( ) ; while ( i > 0 ) { sb . append ( readChar ( ) ) ; i -- ; } String className = sb . toString ( ) ; long serialVersionUID = readLong ( ) ; Class < ? > c = cli . getClass ( storeId , className ) ;", "gt": "int token = readInt ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7888, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Now ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class NowImpl extends ProjectAttributeImpl implements Now { protected static final String NOW_EDEFAULT = null ; protected String now = NOW_EDEFAULT ; protected NowImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getNow ( ) ; } public String getNow ( ) { return now ; } public void setNow ( String newNow ) { String oldNow = now ; now = newNow ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . NOW__NOW , oldNow , now ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . NOW__NOW : return getNow ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage .", "gt": "NOW__NOW : setNow ( ( String ) newValue ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9927, "input": "<s> package org . eclipse . ui ; public interface IWorkbenchCommandConstants { public static final String FILE_NEW = \"org.eclipse.ui.newWizard\" ; public static final String FILE_NEW_PARM_WIZARDID = \"newWizardId\" ; public static final String FILE_CLOSE = \"org.eclipse.ui.file.close\" ; public static final String FILE_CLOSE_ALL = \"org.eclipse.ui.file.closeAll\" ; public static final String FILE_IMPORT = \"org.eclipse.ui.file.import\" ; public static final String FILE_IMPORT_PARM_WIZARDID = \"importWizardId\" ; public static final String FILE_EXPORT = \"org.eclipse.ui.file.export\" ; public static final String FILE_EXPORT_PARM_WIZARDID = \"exportWizardId\" ; public static final String FILE_SAVE = \"org.eclipse.ui.file.save\" ; public static final String FILE_SAVE_AS = \"org.eclipse.ui.file.saveAs\" ; public static final String FILE_SAVE_ALL = \"org.eclipse.ui.file.saveAll\" ; public static final String FILE_PRINT = \"org.eclipse.ui.file.print\" ; public static final String FILE_REVERT = \"org.eclipse.ui.file.revert\" ; public static final String FILE_RESTART = \"org.eclipse.ui.file.restartWorkbench\" ; public static final String FILE_REFRESH = \"org.eclipse.ui.file.refresh\" ; public static final String FILE_PROPERTIES = \"org.eclipse.ui.file.properties\" ; public static final String FILE_EXIT = \"org.eclipse.ui.file.exit\" ; public static final String FILE_MOVE = \"org.eclipse.ui.edit.move\" ; public static final String FILE_RENAME = \"org.eclipse.ui.edit.rename\" ; public static final String FILE_CLOSE_OTHERS = \"org.eclipse.ui.file.closeOthers\" ; public static final String EDIT_UNDO = \"org.eclipse.ui.edit.undo\" ; public static final String EDIT_REDO = \"org.eclipse.ui.edit.redo\" ; public static final String EDIT_CUT = \"org.eclipse.ui.edit.cut\" ; public static final String EDIT_COPY = \"org.eclipse.ui.edit.copy\" ; public static final String EDIT_PASTE = \"org.eclipse.ui.edit.paste\" ; public static final String EDIT_DELETE = \"org.eclipse.ui.edit.delete\" ; public static final String EDIT_CONTENT_ASSIST = \"org.eclipse.ui.edit.text.contentAssist.proposals\" ; public static final String EDIT_CONTEXT_INFORMATION = \"org.eclipse.ui.edit.text.contentAssist.contextInformation\" ; public static final String EDIT_SELECT_ALL = \"org.eclipse.ui.edit.selectAll\" ; public static final String EDIT_FIND_AND_REPLACE = \"org.eclipse.ui.edit.findReplace\" ; public static final String EDIT_ADD_TASK = \"org.eclipse.ui.edit.addTask\" ; public static final String EDIT_ADD_BOOKMARK = \"org.eclipse.ui.edit.addBookmark\" ; public static final String NAVIGATE_GO_INTO = \"org.eclipse.ui.navigate.goInto\" ; public static final String NAVIGATE_BACK = \"org.eclipse.ui.navigate.back\" ; public static final String NAVIGATE_FORWARD = \"org.eclipse.ui.navigate.forward\" ; public static final String NAVIGATE_UP = \"org.eclipse.ui.navigate.up\" ; public static final String NAVIGATE_NEXT = \"org.eclipse.ui.navigate.next\" ; public static final String NAVIGATE_BACKWARD_HISTORY = \"org.eclipse.ui.navigate.backwardHistory\" ; public static final String NAVIGATE_FORWARD_HISTORY = \"org.eclipse.ui.navigate.forwardHistory\" ; public static final String NAVIGATE_PREVIOUS = \"org.eclipse.ui.navigate.previous\" ; public static final String NAVIGATE_TOGGLE_LINK_WITH_EDITOR = \"org.eclipse.ui.navigate.linkWithEditor\" ; public static final String NAVIGATE_NEXT_PAGE = \"org.eclipse.ui.part.nextPage\" ; public static final String NAVIGATE_PREVIOUS_PAGE = \"org.eclipse.ui.part.previousPage\" ; public static final String NAVIGATE_COLLAPSE_ALL = \"org.eclipse.ui.navigate.collapseAll\" ; public static final String NAVIGATE_EXPAND_ALL = \"org.eclipse.ui.navigate.expandAll\" ; public static final String NAVIGATE_SHOW_IN = \"org.eclipse.ui.navigate.showIn\" ; public static final String NAVIGATE_SHOW_IN_PARM_TARGET = \"org.eclipse.ui.navigate.showIn.targetId\" ; public static final String NAVIGATE_SHOW_IN_QUICK_MENU = \"org.eclipse.ui.navigate.showInQuickMenu\" ; public static final String PROJECT_BUILD_ALL = \"org.eclipse.ui.project.buildAll\" ; public static final String PROJECT_BUILD_PROJECT = \"org.eclipse.ui.project.buildProject\" ; public static final String PROJECT_CLOSE_PROJECT = \"org.eclipse.ui.project.closeProject\" ; public static final String PROJECT_CLOSE_UNRELATED_PROJECTS = \"org.eclipse.ui.project.closeUnrelatedProjects\" ; public static final String PROJECT_OPEN_PROJECT = \"org.eclipse.ui.project.openProject\" ; public static final String WINDOW_NEW_WINDOW = \"org.eclipse.ui.window.newWindow\" ; public static final String WINDOW_NEW_EDITOR = \"org.eclipse.ui.window.newEditor\" ; public static final String WINDOW_SHOW_VIEW_MENU = \"org.eclipse.ui.window.showViewMenu\" ; public static final String WINDOW_ACTIVATE_EDITOR = \"org.eclipse.ui.window.activateEditor\" ; public static final String WINDOW_MAXIMIZE_ACTIVE_VIEW_OR_EDITOR = \"org.eclipse.ui.window.maximizePart\" ; public static final String WINDOW_MINIMIZE_ACTIVE_VIEW_OR_EDITOR = \"org.eclipse.ui.window.minimizePart\" ; public static final String WINDOW_NEXT_EDITOR = \"org.eclipse.ui.window.nextEditor\" ; public static final String WINDOW_PREVIOUS_EDITOR = \"org.eclipse.ui.window.previousEditor\" ; public static final String WINDOW_NEXT_VIEW = \"org.eclipse.ui.window.nextView\" ; public static final String WINDOW_PREVIOUS_VIEW = \"org.eclipse.ui.window.previousView\" ; public static final String WINDOW_NEXT_PERSPECTIVE = \"org.eclipse.ui.window.nextPerspective\" ; public static final String WINDOW_PREVIOUS_PERSPECTIVE = \"org.eclipse.ui.window.previousPerspective\" ; public static final String WINDOW_CLOSE_ALL_PERSPECTIVES = \"org.eclipse.ui.window.closeAllPerspectives\" ; public static final String WINDOW_CLOSE_PERSPECTIVE = \"org.eclipse.ui.window.closePerspective\" ; public static final String WINDOW_CLOSE_PERSPECTIVE_PARM_ID = \"org.eclipse.ui.window.closePerspective.perspectiveId\" ; public static final String WINDOW_CLOSE_PART = \"org.eclipse.ui.file.closePart\" ; public static final String WINDOW_CUSTOMIZE_PERSPECTIVE = \"org.eclipse.ui.window.customizePerspective\" ; public static final String WINDOW_PIN_EDITOR = \"org.eclipse.ui.window.pinEditor\" ; public static final String WINDOW_PREFERENCES = \"org.eclipse.ui.window.preferences\" ; public static final String WINDOW_PREFERENCES_PARM_PAGEID = \"preferencePageId\" ; public static final String WINDOW_RESET_PERSPECTIVE = \"org.eclipse.ui.window.resetPerspective\" ; public static final", "gt": "String WINDOW_SAVE_PERSPECTIVE_AS = \"org.eclipse.ui.window.savePerspective\" ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8207, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . selection ; import java . util . Arrays ; import org . dawb . common . ui . plot . axis . ICoordinateSystem ; import org . dawb . workbench . plotting . system . swtxy . translate . FigureTranslator ; import org . dawb . workbench . plotting . system . swtxy . util . Draw2DUtils ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . FigureListener ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . UpdateManager ; import org . eclipse . draw2d . geometry . Geometry ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . PointList ; import org . eclipse . draw2d . geometry . Rectangle ; import uk . ac . diamond . scisoft . analysis . roi . LinearROI ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; class LineSelection extends AbstractSelectionRegion { private static final int SIDE = 8 ; private SelectionHandle endBox , startBox ; private SelectionHandle endBox2 = null , startBox2 = null ; private Figure connection ; LineSelection ( String name , ICoordinateSystem coords ) { super ( name , coords ) ; setRegionColor ( ColorConstants . cyan ) ; setAlpha ( 80 ) ; setLineWidth ( 2 ) ; labelColour = ColorConstants . black ; } @ Override public void createContents ( final Figure parent ) { startBox = new RectangularHandle ( coords , getRegionColor ( ) , parent , SIDE , 100 , 100 ) ; FigureTranslator mover = new FigureTranslator ( getXyGraph ( ) , startBox ) ; mover . addTranslationListener ( createRegionNotifier ( ) ) ; endBox = new RectangularHandle ( coords , getRegionColor ( ) , parent , SIDE , 200 , 200 ) ; mover = new FigureTranslator ( getXyGraph ( ) , endBox ) ; mover . addTranslationListener ( createRegionNotifier ( ) ) ; this . connection = new RegionFillFigure ( this ) { PointList shape = new PointList ( 4 ) ; @ Override public void paintFigure ( Graphics gc ) { super . paintFigure ( gc ) ; final Point startCenter = startBox . getSelectionPoint ( ) ; final Point endCenter = endBox . getSelectionPoint ( ) ; Point start2 = null , end2 = null ; if ( startBox2 != null ) { start2 = startBox2 . getSelectionPoint ( ) ; end2 = endBox2 . getSelectionPoint ( ) ; } if ( shape . size ( ) == 0 ) { shape . addPoint ( startCenter ) ; shape . addPoint ( endCenter ) ; if ( startBox2 != null ) { shape . addPoint ( start2 ) ; shape . addPoint ( end2 ) ; } } else { shape . setPoint ( startCenter , 0 ) ; shape . setPoint ( endCenter , 1 ) ; if ( startBox2 != null ) { shape . setPoint ( start2 , 2 ) ; shape . setPoint ( end2 , 3 ) ; } } this . bounds = getConnectionBounds ( ) ; gc . setLineWidth ( getLineWidth ( ) ) ; gc . setAlpha ( getAlpha ( ) ) ; gc . drawLine ( startCenter , endCenter ) ; if ( start2 != null && end2 != null ) gc . drawLine ( start2 , end2 ) ; if ( isShowLabel ( ) && label != null ) { gc", "gt": ". setAlpha ( 255 ) ;", "prediction": ";\n", "label": 0}
{"id": 9931, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec2 . sub4 ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; public class MailClient { public static void", "gt": "main ( String [ ] args ) throws Exception", "prediction": "( ) ;\n", "label": 1}
{"id": 1237, "input": "<s> package com . shopzilla . api . client . model . request ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; public class ProductSearchRequest extends AbstractSearchRequest { private static final String EMPTY_STRING = \"\" ; public static enum ProductType { SZOID , SZPID , MPID , SKU ; } private String keyword ; private Integer start = 0 ; private Integer numResults = 25 ; private Integer backfillResults = 0 ; private Integer minRelevancyScore = 100 ; private String categoryId = EMPTY_STRING ; private String productId = EMPTY_STRING ; private Long merchantId ; private String zipCode = EMPTY_STRING ; private Boolean imageOnly = Boolean . FALSE ; private Boolean offersOnly = Boolean . FALSE ; private Boolean biddedOnly = Boolean . FALSE ; private Boolean showRawMerchantUrl = Boolean . FALSE ; private Boolean showAttributes = Boolean . FALSE ; private Boolean showProductAttributes = Boolean . FALSE ; private Integer minMarkdown = null ; private Integer resultsOffers = 0 ; private String attributeId = EMPTY_STRING ; private String attWeights = EMPTY_STRING ; private String attFilter = EMPTY_STRING ; private Long minPrice = 0L ; private Long maxPrice ; private Integer maxAge ; private boolean freeShipping = Boolean . FALSE ; private boolean showRedirectInfo = Boolean . FALSE ; private String sort = \"relevancy_desc\" ; private ProductType productType ; public void setMinMarkdown ( Integer minMarkdown ) { this . minMarkdown = minMarkdown ; } public Integer getMinMarkdown ( ) { return minMarkdown ; } public String getCategoryId ( ) { return categoryId ; } public void setCategoryId ( String categoryId ) { this . categoryId = categoryId ; } public String getKeyword ( ) { return keyword ; } public void setKeyword ( String keyword ) { this . keyword = keyword ; } public String getProductId ( ) { return productId ; } public void setProductId ( String productId ) { this . productId = productId ; } public String getZipCode ( ) { return zipCode ; } public void setZipCode ( String zipCode ) { this . zipCode = zipCode ; } public Integer getNumResults ( ) { return numResults ; } public void setNumResults ( Integer numResults ) { this . numResults = numResults ; } public Integer getBackfillResults ( ) { return backfillResults ; } public void setBackfillResults ( Integer backfillResults ) { this . backfillResults = backfillResults ; } public Integer getMinRelevancyScore ( ) { return minRelevancyScore ; } public void setMinRelevancyScore ( Integer minRelevancyScore ) { this . minRelevancyScore = minRelevancyScore ; } public Boolean getImageOnly ( ) { return imageOnly ; } public void setImageOnly ( Boolean imageOnly ) { this . imageOnly = imageOnly ; } public Boolean getOffersOnly ( ) { return offersOnly ; } public void setOffersOnly ( Boolean offersOnly ) { this . offersOnly = offersOnly ; } public Boolean getBiddedOnly ( ) { return biddedOnly ; } public void setBiddedOnly ( Boolean biddedOnly ) { this . biddedOnly = biddedOnly ; } public Boolean getShowRawMerchantUrl ( ) { return showRawMerchantUrl ; } public void setShowRawMerchantUrl ( Boolean showRawMerchantUrl ) { this . showRawMerchantUrl = showRawMerchantUrl ; } public ProductType getProductType ( ) { return productType ; } public void setProductType ( ProductType productType ) { this . productType = productType ; } public Boolean isShowAttributes ( ) { return showAttributes ; } public void setShowAttributes ( Boolean showAttributes ) { this . showAttributes = showAttributes ; } public Boolean isShowProductAttributes ( ) { return showProductAttributes ; } public void setShowProductAttributes ( Boolean showProductAttributes ) { this . showProductAttributes = showProductAttributes ; } public Integer getStart ( ) { return start ; } public void setStart ( Integer start ) { this . start = start ; } public Long getMerchantId ( ) { return merchantId ; } public void setMerchantId ( Long merchantId ) { this . merchantId = merchantId ; } public Integer getResultsOffers ( ) { return resultsOffers ; } public void setResultsOffers ( Integer resultsOffers ) { this . resultsOffers = resultsOffers ; } public String getSort ( ) { return sort ; } public void setSort ( String sort ) { this . sort = sort ; } public String getAttributeId ( ) { return attributeId ; } public void setAttributeId ( String attributeId ) { this . attributeId = attributeId ; } public String getAttWeights ( ) { return attWeights ; } public void setAttWeights ( String attWeights ) { this . attWeights = attWeights ; } public boolean isFreeShipping ( ) { return freeShipping ; } public void setFreeShipping ( boolean freeShipping ) { this . freeShipping = freeShipping ; } public Integer getMaxAge ( ) { return maxAge ; } public void setMaxAge ( Integer maxAge ) { this . maxAge = maxAge ; } public Long getMaxPrice ( ) { return maxPrice ; } public void setMaxPrice ( Long maxPrice ) { this . maxPrice = maxPrice ; } public Long getMinPrice ( ) { return minPrice ; } public void setMinPrice ( Long minPrice ) { this . minPrice = minPrice ; } public String getAttFilter ( ) { return attFilter ; } public", "gt": "void setAttFilter ( String attFilter )", "prediction": "void ( )\n", "label": 0}
{"id": 9945, "input": "<s> package org . seage . ael ; import aglobe . platform . Platform ; import org . seage . data . DataNode ; import org . seage . data . xml . XmlHelper ; import java . io . File ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { try { new Main ( ) . runPlatform ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } private void runPlatform ( ) throws Exception { String schemaPath = \"config.xsd\" ; InputStream schema = Main . class", "gt": ". getResourceAsStream ( schemaPath ) ;", "prediction": ";\n", "label": 1}
{"id": 8176, "input": "<s> package org . ofbiz . base . json . test ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . OutputStreamWriter ; import java . net . URL ; import java . util . ArrayList ; import java . util . HashMap ; import org . ofbiz . base . json . JSON ; import org . ofbiz . base . json . JSONConstants ; import org . ofbiz . base . json . JSONWriter ; import org . ofbiz . base . json . ParseException ; import org . ofbiz . base . json . Token ; import org . ofbiz . base . json . TokenMgrError ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; import org . ofbiz . base . util . IndentingWriter ; @ SourceMonitored public class JSONTests extends GenericTestCaseBase { public JSONTests ( String name ) { super ( name ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; } protected Object parseJSON ( String value , boolean allowResolve ) throws Exception { return new JSON ( new StringReader ( value ) ) . allowResolve ( allowResolve ) . JSONValue ( ) ; } protected String getJSON ( Object object , boolean allowResolve ) throws Exception { StringWriter writer = new StringWriter ( ) ; JSONWriter jsonWriter ; if ( allowResolve ) { jsonWriter = new JSONWriter ( writer , JSONWriter . ResolvingFallbackHandler ) ; } else { jsonWriter = new JSONWriter ( writer ) ; } assertTrue ( \"writer is IndentingWriter\" , jsonWriter . getWriter ( ) instanceof IndentingWriter ) ; jsonWriter . write ( object ) ; return writer . toString ( ) ; } protected void assertSimpleJSONByte ( byte n , String json ) throws Exception { assertSimpleJSON ( \"integer - byte\" , new Byte ( n ) , json , new Long ( n ) ) ; assertSimpleJSONShort ( n , json ) ; } protected void assertSimpleJSONShort ( short n , String json ) throws Exception { assertSimpleJSON ( \"integer - short\" , new Integer ( n ) , json , new Long ( n ) ) ; assertSimpleJSONInteger ( n , json ) ; } protected void assertSimpleJSONInteger ( int n , String json ) throws Exception { assertSimpleJSON ( \"integer - int\" , new Short ( ( short ) n ) , json , new Long ( n ) ) ; assertSimpleJSONLong ( n , json ) ; } protected void assertSimpleJSONLong ( long n , String json ) throws Exception { assertSimpleJSON ( \"integer - long\" , new Long ( n ) , json , new Long ( n ) ) ; } protected void assertSimpleJSONFloat ( float n , String json ) throws Exception { assertSimpleJSON ( \"float - float\" , new Float ( n ) , json , new Double ( n ) ) ; assertSimpleJSONDouble ( n , json ) ; } protected void assertSimpleJSONDouble ( double n , String json ) throws Exception { assertSimpleJSON ( \"float - double\" , new Double ( n ) , json ) ; } protected void assertSimpleJSON ( String type , Object object , String json ) throws Exception { assertSimpleJSON ( type , object , json , object ) ; } protected void assertSimpleJSON ( String type , Object before , String json , Object after ) throws Exception { assertEquals ( \"write \" + type , json , getJSON ( before , false ) ) ; assertEquals ( \"parse \" + type , after , parseJSON ( json , false ) ) ; } protected void assertResolveJSON ( String type , Object obj", "gt": ", String json ) throws Exception", "prediction": ") ;\n", "label": 0}
{"id": 9953, "input": "<s> package com . datastruct ; import com . math . CompPoint ; import com . math . Segment ; import java . util . List ; import java . util . Vector ; public class SegmentTree extends BinarySearchTree < Segment > { public Vector < Segment > [ ] findMatchingSegs ( CompPoint p ) { Vector < Segment > lowerPoints = new Vector < Segment > ( ) ; Vector < Segment > upperPoints = new Vector < Segment > ( ) ; Vector < Segment > containedPoints = new Vector < Segment > ( ) ; boolean startFlag = false ; boolean endFlag = false ; List < Segment > treeList = this . toList ( ) ; for ( int i = 0 ; i < treeList . size ( ) ; i ++ ) { switch ( treeList . get ( i ) . containsPoint ( p ) ) { case - 1 : upperPoints . addElement ( treeList . get ( i ) ) ; if ( ! startFlag ) ; startFlag = true ; break ; case 1 : lowerPoints . addElement ( treeList . get ( i ) ) ; if ( ! startFlag ) ; startFlag = true ; break ; case 2 : containedPoints . addElement ( treeList . get", "gt": "( i ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8157, "input": "<s> package com . sun . tools . javadoc ; import java . util . Locale ; import com . sun . javadoc . * ; import com . sun . tools . javac . util . ListBuffer ; class Comment { private final ListBuffer < Tag > tagList = new ListBuffer < Tag > ( ) ; private String text ; private final DocEnv docenv ; Comment ( final DocImpl holder , final String commentString ) { this . docenv = holder . env ; @ SuppressWarnings ( \"fallthrough\" ) class CommentStringParser { void parseCommentStateMachine ( ) { final int IN_TEXT = 1 ; final int TAG_GAP = 2 ; final int TAG_NAME = 3 ; int state = TAG_GAP ; boolean newLine = true ; String tagName = null ; int tagStart = 0 ; int textStart = 0 ; int lastNonWhite = - 1 ; int len = commentString . length ( ) ; for ( int inx = 0 ; inx < len ; ++ inx ) { char ch = commentString . charAt ( inx ) ; boolean isWhite = Character . isWhitespace ( ch ) ; switch ( state ) { case TAG_NAME : if ( isWhite ) { tagName = commentString . substring ( tagStart , inx ) ; state = TAG_GAP ; } break ; case TAG_GAP : if ( isWhite ) { break ; } textStart = inx ; state = IN_TEXT ; case IN_TEXT : if ( newLine && ch == '@' ) { parseCommentComponent ( tagName , textStart , lastNonWhite + 1 ) ; tagStart = inx ; state = TAG_NAME ; } break ; } ; if ( ch == '\\n' ) { newLine = true ; } else if ( ! isWhite ) { lastNonWhite = inx ; newLine = false ; } } switch ( state ) { case TAG_NAME : tagName = commentString . substring ( tagStart , len ) ; case TAG_GAP : textStart = len ; case IN_TEXT : parseCommentComponent ( tagName , textStart , lastNonWhite + 1 ) ; break ; } ; } void parseCommentComponent ( String tagName , int from , int upto ) { String tx = upto <= from ? \"\" : commentString . substring ( from , upto ) ; if ( tagName == null ) { text = tx ; } else { TagImpl tag ; if ( tagName . equals ( \"@exception\" ) || tagName . equals ( \"@throws\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new ThrowsTagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@param\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new ParamTagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@see\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new SeeTagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@serialField\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new SerialFieldTagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@return\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new TagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@author\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new TagImpl ( holder , tagName , tx ) ; } else if ( tagName . equals ( \"@version\" ) ) { warnIfEmpty ( tagName , tx ) ; tag = new TagImpl ( holder , tagName , tx ) ; } else { tag = new TagImpl ( holder , tagName , tx ) ; } tagList . append ( tag ) ; } } void warnIfEmpty ( String tagName , String tx ) { if ( tx . length ( ) == 0 ) { docenv . warning ( holder , \"tag.tag_has_no_arguments\" , tagName ) ; } } } new CommentStringParser ( ) . parseCommentStateMachine ( ) ; } String commentText ( ) { return text ; } Tag [ ] tags ( ) { return tagList . toArray ( new Tag [ tagList . length ( ) ] ) ; } Tag [ ] tags ( String tagname ) { ListBuffer < Tag > found = new ListBuffer < Tag > ( ) ; String target = tagname ; if ( target . charAt ( 0 ) != '@' ) { target = \"@\" + target ; } for ( Tag tag : tagList ) { if ( tag . kind ( ) . equals ( target ) ) { found . append ( tag ) ; } } return found . toArray ( new Tag [ found . length ( ) ] ) ; } ThrowsTag [ ] throwsTags ( ) { ListBuffer < ThrowsTag > found = new ListBuffer < ThrowsTag > ( ) ; for ( Tag next : tagList ) { if ( next instanceof ThrowsTag ) { found . append ( ( ThrowsTag ) next ) ; } } return found . toArray ( new ThrowsTag [ found . length", "gt": "( ) ] ) ;", "prediction": ") ;\n", "label": 0}
{"id": 9954, "input": "<s> package br . org . archimedes . controller . commands ; import br . org . archimedes . Constant ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; public class ZoomExtendCommand extends ZoomCommand { private ZoomCommand zoomByArea ; @ Override protected Point getNewViewport ( Drawing drawing ) { if ( zoomByArea == null ) { zoomByArea = calculateArea ( drawing ) ; } return zoomByArea . getNewViewport ( drawing ) ; } @ Override protected double calculateZoom ( Drawing drawing ) { if ( zoomByArea == null ) { zoomByArea = calculateArea ( drawing ) ; } return zoomByArea . calculateZoom ( drawing ) ; } private ZoomCommand calculateArea ( Drawing drawing ) { Rectangle area = drawing . getBoundary ( ) ; ZoomCommand zoomByArea = null ; if ( area != null ) { double x , y , width , height ; x = area . getLowerLeft ( ) . getX ( ) - area . getWidth ( ) * ( Constant . ZOOM_EXTEND_BORDER / 2.0 ) ; width = area . getWidth ( ) * ( 1.0 + Constant . ZOOM_EXTEND_BORDER ) ; y = area . getLowerLeft ( ) . getY ( ) - area . getHeight ( ) * ( Constant . ZOOM_EXTEND_BORDER / 2.0 ) ; height = area . getHeight ( ) * ( 1.0 + Constant . ZOOM_EXTEND_BORDER ) ; if ( width > Constant . EPSILON || height > Constant . EPSILON ) { Point p1 = new Point ( x , y ) ; Point p2 = new Point ( x + width , y + height ) ; try { zoomByArea = new", "gt": "ZoomByAreaCommand ( p1 , p2 ) ;", "prediction": ";\n", "label": 1}
{"id": 4524, "input": "<s> import java . io . IOException ; import javax . tools . * ; import static javax . tools . StandardLocation . * ; import static javax . tools . JavaFileObject . Kind . * ; public class T6437349 extends ToolTester { void test ( String ... args ) throws IOException { task = tool . getTask ( null , fm , null , null , null , null ) ; JavaFileObject fo = fm . getJavaFileForInput ( SOURCE_PATH , \"T6437349\" , SOURCE ) ; if ( fo . isNameCompatible ( \"T6437349.java\" , OTHER ) ) throw new AssertionError ( ) ; if ( ! fo . isNameCompatible ( \"T6437349\" , SOURCE ) ) throw new AssertionError ( ) ; fo = fm .", "gt": "getJavaFileForInput ( PLATFORM_CLASS_PATH , \"java.lang.Object\" , CLASS ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 9986, "input": "<s> package org . nuxeo . ecm . platform . mail . test ; import java . util . Properties ; import javax . mail . Address ; import javax . mail . Folder ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Store ; import javax . mail . Transport ; import javax . mail . Flags . Flag ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import org . junit . Before ; import org . junit . After ; import org . junit . Test ; import static org . junit . Assert . * ; public class TestServer { private static final String FACINATING_CONTENT = \"facinating content.\" ; private static final String TEST_EMAIL_SERVER = \"Test email server\" ; private Message message ; private final Properties props = new Properties ( ) ; @ Before protected void setUp ( ) throws Exception { Server . start ( ) ; props . put ( \"mail.store.protocol\" , \"pop3\" ) ; props . put ( \"mail.transport.protocol\" , \"smtp\" ) ; props . put ( \"mail.smtp.port\" , \"60025\" ) ; props . put ( \"mail.host\" , \"localhost\" ) ; props . put ( \"mail.user\" , \"alex@localhost\" ) ; props . put ( \"mail.from\" , \"alex@localhost\" ) ; props . put ( \"mail.pop3.port\" , \"60110\" ) ; Session session = Session . getDefaultInstance ( props ) ; message = new MimeMessage ( session ) ; message . setSubject ( TEST_EMAIL_SERVER ) ; Address address = new InternetAddress ( \"alex@localhost\" ) ; message . setRecipient ( Message . RecipientType . TO , address ) ; message . setFrom ( ) ; message . setText ( FACINATING_CONTENT ) ; Transport . send ( message ) ; } @ After protected void tearDown ( ) throws Exception { Server . shutdown ( ) ; } @ Test public void testServer ( ) throws Exception { Session session = Session . getDefaultInstance ( props ) ; Thread . sleep ( 1000 ) ; Store store = session . getStore ( ) ; store . connect ( \"alex@localhost\" , \"mdpalex\" ) ; Folder rootFolder = store . getFolder ( \"INBOX\" ) ; int count = 0 ; while ( count != 1 ) { rootFolder . open ( Folder . READ_ONLY ) ; count = rootFolder . getMessageCount ( ) ; rootFolder . close ( false ) ; } rootFolder . open ( Folder . READ_WRITE ) ; Message [ ] messages = rootFolder . getMessages ( ) ; assertEquals ( 1 , messages . length ) ; Message message = messages [ 0 ] ; assertEquals ( TEST_EMAIL_SERVER", "gt": ", message . getSubject ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3715, "input": "<s> package java . lang ; class Object extends Throwable { public final native Class getClass ( ) ; public native int hashCode ( ) ; public native boolean equals ( Object obj ) ; protected native Object clone ( ) throws CloneNotSupportedException ; public native String toString ( ) ; public final native void notify ( ) ; public final native void notifyAll ( ) ; public final native void wait ( long timeout ) throws InterruptedException ; public native final void wait ( long", "gt": "timeout , int nanos ) throws InterruptedException ;", "prediction": ")\n", "label": 0}
{"id": 9997, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . ISerializable ; import org . jscsi . target . scsi . sense . SenseData ; import org . jscsi . target . scsi . sense . SenseKey ; import org . jscsi . target . util . BitManip ; public abstract class SenseKeySpecificData implements ISerializable { public static final int SIZE = 3 ; protected final boolean senseKeySpecificDataValid ; public SenseKeySpecificData ( final boolean senseKeySpecificDataValid ) { this . senseKeySpecificDataValid = senseKeySpecificDataValid ; } private final void serializeCommonFields ( final ByteBuffer byteBuffer , final int index ) { byteBuffer . position ( index ) ; byte b = 0 ; if ( senseKeySpecificDataValid ) b = BitManip . getByteWithBitSet ( b , 7 , true ) ; byteBuffer . put ( b ) ; } protected abstract void serializeSpecificFields ( ByteBuffer byteBuffer , final int index ) ; public void serialize ( ByteBuffer byteBuffer , int index ) { serializeCommonFields ( byteBuffer , index ) ;", "gt": "serializeSpecificFields ( byteBuffer , index ) ;", "prediction": "}\n", "label": 1}
{"id": 5877, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ; public interface RGB extends EObject { String getValue ( ) ;", "gt": "void setValue ( String value ) ;", "prediction": "}\n", "label": 0}
{"id": 10002, "input": "<s> package org . nuxeo . ecm . platform . publisher . impl . core ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . PathRef ; import org . nuxeo . ecm . platform . publisher . api . AbstractBasePublishedDocumentFactory ; import org . nuxeo . ecm . platform . publisher . api . PublicationNode ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocument ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocumentFactory ; import org . nuxeo . ecm . platform . publisher . api . PublishingEvent ; import java . util . Map ; public class CoreProxyFactory extends AbstractBasePublishedDocumentFactory implements PublishedDocumentFactory { public PublishedDocument publishDocument ( DocumentModel doc , PublicationNode targetNode , Map < String , String > params ) throws ClientException { DocumentModel targetDocModel ; if ( targetNode instanceof CoreFolderPublicationNode ) { CoreFolderPublicationNode coreNode = ( CoreFolderPublicationNode ) targetNode ; targetDocModel = coreNode . getTargetDocumentModel ( ) ; } else { targetDocModel = coreSession . getDocument ( new PathRef ( targetNode . getPath ( ) ) ) ; } DocumentModel proxy ; if ( ( params != null ) &&", "gt": "( params . containsKey ( \"overwriteExistingProxy\" ) ) )", "prediction": "\n", "label": 1}
{"id": 39, "input": "<s> package org . papaours . yama . model . dataset ; import javax . xml . bind . annotation . XmlElement ; public class YamaDatasetItem { private int number ; private double value ; public YamaDatasetItem ( ) { super ( ) ; } public YamaDatasetItem ( final int theNumber , final double theValue ) { super ( ) ; this . number = theNumber ; this . value = theValue ; } @ XmlElement public int getNumber ( ) { return number ; } public void setNumber ( final int theNumber ) { this . number = theNumber ; } @ XmlElement public double getValue ( ) { return value ; } public", "gt": "void setValue ( final double theValue )", "prediction": "void ( )\n", "label": 0}
{"id": 10013, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"updates\" } ) @ XmlRootElement ( name = \"UpdateListItems\" ) public class UpdateListItems { protected String listName ; protected UpdateListItems . Updates updates ; public String getListName ( ) { return listName ; } public void setListName ( String value ) { this . listName = value ; } public UpdateListItems . Updates getUpdates ( ) { return updates ; } public void setUpdates ( UpdateListItems . Updates value ) { this . updates = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class Updates { @ XmlMixed @ XmlAnyElement ( lax = true ) protected List < Object > content ; public List < Object > getContent ( ) { if ( content == null ) { content = new ArrayList < Object > ( ) ; }", "gt": "return this . content ;", "prediction": "}\n", "label": 1}
{"id": 7191, "input": "<s> public class T6500343b { final static int i1 = 0 ; final static int i2 = 1 ; static void crash ( int i ) { switch ( i ) { case ( true ? 0 : 1 ) : case ( i1 == 5 ? 1 : 2 ) : case ( i1 == i2 ? 2 : 3 ) : } } public static void main (", "gt": "String [ ] args )", "prediction": ")\n", "label": 0}
{"id": 10014, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . Dimension ; import org . restlet . data . Method ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . resources . ResponseBuilderService ; public class ResponseBuilderTest extends JaxRsTestCase { @ Override protected Application getApplication ( ) { final Application appConfig = new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( ResponseBuilderService . class ) ; } } ; return appConfig ; } public void test1 ( ) { final Response response = get ( \"1\" ) ; final Set < Dimension > dimensions = response . getDimensions ( ) ; assertTrue ( \"dimension must contain MediaType\" , dimensions . contains ( Dimension . MEDIA_TYPE ) ) ; assertTrue ( \"dimension must contain Encoding\" , dimensions . contains ( Dimension . ENCODING ) ) ; } public void test2 ( ) { final Response response = get ( \"2\" ) ; final Set < Dimension > dimensions = response . getDimensions ( ) ; assertTrue ( \"dimension must contain Language\" , dimensions . contains ( Dimension . LANGUAGE ) ) ; assertTrue ( \"dimension must contain CharacterSet\" , dimensions . contains ( Dimension . CHARACTER_SET ) ) ; }", "gt": "public void testDelete ( )", "prediction": "}\n", "label": 1}
{"id": 1000, "input": "<s> package readers ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; class ByteReader { private byte [ ] bytes ; public ByteReader ( String pathToFile ) { try { this . bytes = this . getBytesFromFile ( new File ( pathToFile ) ) ; } catch ( IOException e ) { System . out . println ( \"Cant read file : \" + pathToFile ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } public byte [ ] getGetBytes ( ) { return this . bytes ; } private byte [ ] getBytesFromFile ( File file ) throws IOException { InputStream is = new FileInputStream ( file ) ; long length = file . length ( ) ; if ( length > Integer . MAX_VALUE ) { } byte [ ] bytes = new byte [ ( int ) length ] ; int offset = 0 ; int numRead = 0 ; while ( offset < bytes . length && ( numRead = is . read ( bytes , offset , bytes . length - offset ) ) >= 0 ) { offset += numRead ; } if ( offset < bytes . length ) { throw new IOException ( \"Could not completely read file \" + file . getName ( ) ) ; } is . close ( ) ; return bytes ; } public int readByte ( int index ) { return bytes [ index ] ; } public int readWord ( int offset ) { int left = bytes [ offset + 1 ] ; int right = bytes [ offset ] ; left <<= 8 ; right |= left ; return right ; } public int readDWord ( int offset ) { int leftmost = bytes [ offset + 3 ] ; int midleft = bytes [ offset + 2 ] ; int midright = bytes [ offset + 1 ] ; int rightmost = bytes [ offset ] ; leftmost <<= 24 ; midleft <<= 16 ; midright <<= 8 ; rightmost |= midright ; rightmost |= midleft ; rightmost |= leftmost ; return rightmost ; } public void printBytes ( ) { int i = 0 ; for ( i = 0 ; i < this . bytes . length ; i ++ ) { System . out . print ( Integer . toHexString (", "gt": "this . bytes [ i ] ) + \"\\t\" ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 10023, "input": "<s> package org . eclipse . ui . forms . widgets ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . ScrollBar ; import org . eclipse . ui . internal . forms . widgets . FormUtil ; public abstract class SharedScrolledComposite extends ScrolledComposite { private boolean ignoreLayouts = true ; private boolean ignoreResizes = false ; private boolean expandHorizontal = false ; private boolean expandVertical = false ; private SizeCache contentCache = new SizeCache ( ) ; private boolean reflowPending = false ; private boolean delayedReflow = false ; public SharedScrolledComposite ( Composite parent , int style ) { super ( parent , style ) ; addListener ( SWT . Resize , new Listener ( ) { public void handleEvent ( Event e ) { if ( ! ignoreResizes ) { scheduleReflow ( false ) ; } } } ) ; initializeScrollBars ( ) ; } public void setForeground ( Color fg ) { super . setForeground ( fg ) ; if ( getContent ( ) != null ) getContent ( ) . setForeground ( fg ) ; } public void setBackground ( Color bg ) { super . setBackground ( bg ) ; if ( getContent ( ) != null ) getContent ( ) . setBackground ( bg ) ; } public void setFont ( Font font ) { super . setFont ( font ) ; if ( getContent ( ) != null ) getContent ( ) . setFont ( font ) ; } public void setContent ( Control content ) { super . setContent ( content ) ; if ( content != null ) { content . setForeground ( getForeground ( ) ) ; content . setBackground ( getBackground ( ) ) ; content . setFont ( getFont ( ) ) ; } } public boolean setFocus ( ) { boolean result ; FormUtil . setFocusScrollingEnabled ( this , false ) ; if ( getContent ( ) != null ) result = getContent ( ) . setFocus ( ) ; else result = super . setFocus ( ) ; FormUtil . setFocusScrollingEnabled ( this , true ) ; return result ; } public void layout ( boolean changed ) { if ( ignoreLayouts ) { return ; } ignoreLayouts = true ; ignoreResizes = true ; super . layout ( changed ) ; ignoreResizes = false ; } public void setExpandHorizontal ( boolean expand ) { expandHorizontal = expand ; super . setExpandHorizontal ( expand ) ; } public void setExpandVertical ( boolean expand ) { expandVertical = expand ; super . setExpandVertical ( expand ) ; } public void reflow ( boolean flushCache ) { Composite c = ( Composite ) getContent ( ) ; Rectangle clientArea = getClientArea ( ) ; if ( c == null ) return ; if ( clientArea . width == getSize ( ) . x ) { ScrollBar bar = getVerticalBar ( ) ; if ( bar != null ) { clientArea . width -= bar . getSize ( ) . x ; } } contentCache . setControl ( c ) ; if ( flushCache ) { contentCache . flush ( ) ; } Point newSize = contentCache . computeSize ( FormUtil . getWidthHint ( clientArea . width , c ) , FormUtil . getHeightHint ( clientArea . height , c ) ) ; if ( ! ( expandHorizontal && expandVertical ) ) { c . setSize ( newSize ) ; } setMinSize ( newSize ) ; FormUtil . updatePageIncrement ( this ) ; ignoreLayouts = false ; layout ( flushCache ) ; ignoreLayouts = true ; contentCache . layoutIfNecessary ( ) ; } private void updateSizeWhilePending ( ) { Control c = getContent ( ) ; Rectangle area = getClientArea ( ) ; setMinSize ( area . width , c . getSize ( ) . y ) ; } private void scheduleReflow ( final boolean flushCache ) { if ( delayedReflow ) { if ( reflowPending ) { updateSizeWhilePending ( ) ; return ; } reflowPending = true ; getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { reflowPending = false ; if ( ! isDisposed", "gt": "( ) ) reflow ( flushCache ) ;", "prediction": "( ) )\n", "label": 1}
{"id": 4516, "input": "<s> package com . sun . mirror . type ; import com . sun . mirror . declaration . Declaration ; import com . sun . mirror . util . Types ; import com . sun . mirror . util . TypeVisitor ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface TypeMirror { String toString ( ) ; boolean", "gt": "equals ( Object obj ) ;", "prediction": "}\n", "label": 0}
{"id": 10061, "input": "<s> package de . uos . igf . db3d . dbms . newModel4d ; public class Triangle4D { private static final long serialVersionUID = 4121395257446711350L ; private int IDzero ; private int IDone ; private int IDtwo ; private int id ; public Triangle4D ( Integer [ ] pointIDs , Integer ID ) throws IllegalArgumentException { this . IDzero = pointIDs [ 0 ] ; this . IDone = pointIDs [ 1 ] ; this . IDtwo = pointIDs [ 2 ] ; this . id = ID ; } public Triangle4D ( Integer pointID1", "gt": ", Integer pointID2 , Integer pointID3 , Integer ID )", "prediction": ")\n", "label": 1}
{"id": 3476, "input": "<s> public class DefAssignNestedArg extends Object { private static final java . beans . PropertyChangeListener listener = new java . beans . PropertyChangeListener ( ) { public void propertyChange ( java", "gt": ". beans . PropertyChangeEvent ev )", "prediction": ") ;\n", "label": 0}
{"id": 10068, "input": "<s> package org . eclipse . ui . intro ; public abstract class IntroContentDetector { public", "gt": "abstract boolean isNewContentAvailable ( ) ;", "prediction": "( )\n", "label": 1}
{"id": 6795, "input": "<s> enum NoFinal5 { A , B , C ; void finalize ( ) { System . err", "gt": ". println ( \"FISK\" ) ;", "prediction": ";\n", "label": 0}
{"id": 10073, "input": "<s> package fr . inria . zvtm . glyphs ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics2D ; import java . awt . Stroke ; import java . awt . Shape ; import java . awt . geom . AffineTransform ; import java . util . ArrayList ; import java . util . List ; import fr . inria . zvtm . engine . Camera ; public class Composite extends Glyph { private ArrayList < Glyph > children ; private transient double [ ] bbox ; public Composite ( ) { vx = 0 ; vy = 0 ; children = new ArrayList < Glyph > ( ) ; bbox = new double [ 4 ] ; } public void addChild ( Glyph child ) { children . add ( child ) ; computeBounds ( ) ; } public boolean removeChild ( Glyph child ) { boolean removed = children . remove ( child ) ; if ( removed ) { computeBounds ( ) ; } return removed ; } public List < Glyph > peekAtChildren ( ) { return children ; } @ Override public double [ ] getBounds ( ) { double [ ] retval = new double [ bbox . length ] ; System . arraycopy ( bbox , 0 , retval , 0 , bbox . length ) ; return retval ; } @ Override public Composite clone ( ) { Composite retval = ( Composite ) super . clone ( ) ; retval . children = new ArrayList < Glyph > ( ) ; for ( Glyph g : children ) { retval . children . add ( ( Glyph ) g . clone ( ) ) ; } return retval ; } @ Override public boolean fillsView ( double w , double h , int camIndex ) { return false ; } @ Override public short mouseInOut ( int jpx , int jpy , int camIndex , double cvx , double cvy ) { return NO_CURSOR_EVENT ; } @ Override public void resetMouseIn ( ) { } @ Override public void resetMouseIn ( int i ) { } @ Override public boolean coordInside ( int jpx , int jpy , int camIndex , double cvx , double cvy ) { return true ; } @ Override public void removeCamera ( int index ) { for ( Glyph child : children ) { child . removeCamera ( index ) ; } } @ Override public void addCamera ( int index ) { for ( Glyph child : children ) { child . addCamera ( index ) ; } }", "gt": "@ Override public void initCams ( int nbCam )", "prediction": "}\n", "label": 1}
{"id": 9743, "input": "<s> package de . javawi . jstun . attribute ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; public class SourceAddress extends MappedResponseChangedSourceAddressReflectedFrom { private static final Logger LOGGER = LoggerFactory . getLogger ( SourceAddress . class ) ; public SourceAddress ( ) { super ( MessageAttribute . MessageAttributeType . SourceAddress ) ; } public static MessageAttribute parse ( byte [ ] data ) throws MessageAttributeParsingException { SourceAddress sa = new SourceAddress ( ) ; MappedResponseChangedSourceAddressReflectedFrom . parse ( sa , data ) ; LOGGER . debug ( \"Message Attribute: Source Address parsed: \" + sa", "gt": ". toString ( ) + \".\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10101, "input": "<s> package io . beancounter . listener . facebook ; import org . joda . time . DateTime ; import org . testng . annotations . Test ; import java . text . ParseException ; public class FacebookDateConverterTest { @ Test public", "gt": "void testDate ( ) throws ParseException", "prediction": "\n", "label": 1}
{"id": 9934, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . engine . client . event . IEventConstants ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . grid . column . gkComboBoxColumnConfig ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . store . ListStore ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class GComboBoxBuilder extends GridFieldBuilder { public GComboBoxBuilder ( String fieldType ) { super ( fieldType ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; ColumnConfig cc = new gkComboBoxColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ; ComboBox cb = ( ComboBox ) field ; ListStore ls = new ListStore < ModelData > ( ) ; String content = x . getContent ( ) ; if ( ! content . equals ( \"\" ) ) { content = content . replaceAll ( \"[ \\t\\n]*\" , \"\" ) ; String [ ] comma = content . split ( IEventConstants . SPLIT_COMMA ) ; for ( int i = 0 ; i < comma . length ; i ++ ) { String [ ] colon = comma [ i ] . split ( IEventConstants . SPLIT_COLON ) ; gkMap data = new gkMap ( \"text\" , colon [ 0 ] ) ; if ( colon . length == 2 ) { data . put ( \"value\" , colon [ 1 ] ) ; } else { data . put ( \"value\" , colon [ 0 ] ) ; } ls . add ( data ) ; } } cb . getPropertyEditor ( ) . setList ( ls . getModels ( ) ) ; cb . setStore ( ls ) ; String value = x . getValue ( ) ; if (", "gt": "! value . equals ( \"\" ) )", "prediction": ") ;\n", "label": 0}
{"id": 10112, "input": "<s> package com . onarandombox . MultiversePortals . commands ; import java . util . List ; import org . bukkit . ChatColor ; import org . bukkit . command . CommandSender ; import org . bukkit . entity . Player ; import org . bukkit . permissions . PermissionDefault ; import com . onarandombox . MultiversePortals . MVPortal ; import com . onarandombox . MultiversePortals . MultiversePortals ; import com . onarandombox . MultiversePortals . PortalPlayerSession ; public class InfoCommand extends PortalCommand { public InfoCommand ( MultiversePortals plugin ) { super ( plugin ) ; this . setName ( \"Portal Information\" ) ; this . setCommandUsage ( \"/mvp info \" + ChatColor . GREEN + \"{PORTAL}\" ) ; this . setArgRange ( 1 , 1 ) ; this . addKey ( \"mvp info\" ) ; this . addKey ( \"mvpi\" ) ; this . addKey ( \"mvpinfo\" ) ; this . setPermission ( \"multiverse.portal.info\" , \"Displays information about a portal.\" , PermissionDefault . OP ) ; } @ Override public void runCommand ( CommandSender sender , List < String > args ) { MVPortal selected = this . plugin . getPortalManager ( ) . getPortal ( args . get ( 0 ) , sender ) ; if ( selected == null ) { sender . sendMessage ( \"Sorry! That portal doesn't exist", "gt": "or you're not allowed to use it!\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8912, "input": "<s> package org . ofbiz . base . test ; import junit . framework . TestCase ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilValidate ; public class BaseUnitTests extends TestCase { public BaseUnitTests ( String name ) { super ( name ) ; } public void testDebug ( ) { Debug . set ( Debug . VERBOSE , true ) ; assertTrue ( Debug . verboseOn ( ) ) ; Debug . set ( Debug . VERBOSE , false ) ; assertFalse ( Debug . verboseOn ( ) ) ; Debug . set ( Debug . INFO , true ) ; assertTrue ( Debug . infoOn ( ) ) ; } public void testFormatPrintableCreditCard_1 ( ) { assertEquals ( \"test 4111111111111111 to ************111\" , \"************1111\" , UtilFormatOut . formatPrintableCreditCard ( \"4111111111111111\" ) ) ; } public void testFormatPrintableCreditCard_2 ( ) { assertEquals ( \"test 4111 to 4111\" , \"4111\" , UtilFormatOut . formatPrintableCreditCard ( \"4111\" ) ) ; } public void testFormatPrintableCreditCard_3 ( ) { assertEquals ( \"test null to null\" , null , UtilFormatOut . formatPrintableCreditCard ( null ) ) ; } public void testIsDouble_1 ( ) { assertFalse ( UtilValidate . isDouble ( \"10.0\" , true , true , 2 , 2 ) ) ; } public void testIsFloat_1 ( ) { assertFalse ( UtilValidate . isFloat ( \"10.0\" , true , true , 2 , 2 ) ) ; } public void testIsDouble_2 ( ) { assertTrue ( UtilValidate . isDouble ( \"10.000\" , true , true , 3 , 3 ) ) ; } public void testIsFloat_2 ( ) { assertTrue ( UtilValidate . isFloat ( \"10.000\" , true , true , 3 , 3 ) ) ; } public void testStringUtil ( ) { byte [ ] testArray = { - 1 } ; byte [ ] result = StringUtil . fromHexString", "gt": "( StringUtil . toHexString ( testArray ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10113, "input": "<s> package org . apache . lucene . analysis ; class CharacterCache { private static final Character cache [ ] = new Character [ 128 ] ; static { for ( int i = 0 ; i < cache . length ; i ++ ) { cache [ i ] = new Character ( ( char ) i ) ; } } public static Character valueOf ( char c ) { if ( c < cache . length ) { return cache [", "gt": "( int ) c ] ;", "prediction": ";\n", "label": 1}
{"id": 7974, "input": "<s> package org . gk . ui . client . com . tree . xml ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . tree . dir . gkTreeDirPanelIC ; import org . gk . ui . client . com . utils . TreeUtils ; import com . extjs . gxt . ui . client . core . XDOM ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . data . TreeModel ; import com . extjs . gxt . ui . client . dnd . DND . Feedback ; import com . extjs . gxt . ui . client . dnd . DND . Operation ; import com . extjs . gxt . ui . client . dnd . Insert ; import com . extjs . gxt . ui . client . dnd . TreePanelDragSource ; import com . extjs . gxt . ui . client . dnd . TreePanelDropTarget ; import com . extjs . gxt . ui . client . event . DNDEvent ; import com . extjs . gxt . ui . client . store . TreeStoreModel ; import com . extjs . gxt . ui . client . util . Format ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanel ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanel . TreeNode ; import com . google . gwt . user . client . Element ; import com . google . gwt . xml . client . Node ; public abstract class gkTreeHandler { private TreePanelDropTarget target ; public gkTreeHandler ( TreePanel tree , final Operation op ) { new TreePanelDragSource ( tree ) { @ Override protected void onDragDrop ( DNDEvent event ) { event . setOperation ( op ) ; } } ; target = new TreePanelDropTarget ( tree ) { @ Override protected void onDragFail ( DNDEvent event ) { tree . setTrackMouseOver ( true ) ; super . onDragFail ( event ) ; } @ Override protected void showFeedback ( DNDEvent event ) { final TreeNode overItem = tree . findNode ( event . getTarget ( ) ) ; if ( overItem == null ) { clearStyles ( event ) ; } if ( overItem != null && event . getDropTarget ( ) . getComponent ( ) == event . getDragSource ( ) . getComponent ( ) ) { List < TreeModel > list = event . getData ( ) ; ModelData overModel = overItem . getModel ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { ModelData sel = ( ModelData ) list . get ( i ) . get ( \"model\" ) ; if ( overModel == sel ) { clearStyles ( event ) ; return ; } List < ModelData > children = tree . getStore ( ) . getChildren ( sel , true ) ; if ( children . contains ( overItem . getModel ( ) ) ) { clearStyles ( event ) ; return ; } } } boolean append = feedback == Feedback . APPEND || feedback == Feedback . BOTH ; boolean insert = feedback == Feedback . INSERT || feedback == Feedback . BOTH ; if ( overItem == null ) { handleAppend ( event , overItem ) ; } else if ( insert ) { handleInsert ( event , overItem ) ; } else if ( ( ! overItem . isLeaf ( ) || isAllowDropOnLeaf ( ) ) && append ) { handleAppend ( event , overItem ) ; } else { if ( activeItem != null ) { tree . getView ( ) . onDropChange ( activeItem , false ) ; } status = - 1 ; activeItem = null ; appendItem = null ; Insert . get ( ) . hide ( ) ; event . getStatus ( ) . setStatus ( false ) ; } if ( activeItem == null ) { event . getStatus ( ) . setStatus ( false ) ; } } @ Override protected void onDragEnter ( DNDEvent event ) { removeDuplicateNode ( event ) ; super . onDragEnter ( event ) ; super . clearStyles ( event ) ; } private void removeDuplicateNode ( DNDEvent event ) { List < TreeStoreModel > modelList = ( List < TreeStoreModel > ) event . getData ( ) ; Set < String > parentNodeSet = new HashSet < String > ( ) ; for ( TreeStoreModel model : modelList ) { Node node = model . getModel ( ) . get ( \"node\" ) ; if ( ! model . isLeaf ( ) ) { parentNodeSet . add ( node . toString ( ) ) ; } } Iterator < TreeStoreModel > modelIt = modelList . iterator ( ) ; while ( modelIt . hasNext ( ) ) { TreeStoreModel model = modelIt . next ( ) ; Node node = model . getModel ( ) .", "gt": "get ( \"node\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10115, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import java . io . IOException ; import java . util . Set ; public class ConstantScoreQuery extends Query { protected final Filter filter ; public ConstantScoreQuery ( Filter filter ) { this . filter = filter ; } public Filter getFilter ( ) { return filter ; } public Query rewrite ( IndexReader reader ) throws IOException { return this ; } public void extractTerms ( Set terms ) { } protected class ConstantWeight extends Weight { private Similarity similarity ; private float queryNorm ; private float queryWeight ; public ConstantWeight ( Searcher searcher ) { this . similarity = getSimilarity ( searcher ) ; } public Query getQuery ( ) { return ConstantScoreQuery . this ; } public float getValue ( ) { return queryWeight ; } public float sumOfSquaredWeights ( ) throws IOException { queryWeight = getBoost ( ) ; return queryWeight * queryWeight ; } public void normalize ( float norm ) { this . queryNorm = norm ; queryWeight *= this . queryNorm ; } public Scorer scorer ( IndexReader reader , boolean scoreDocsInOrder , boolean topScorer ) throws IOException { return new ConstantScorer ( similarity , reader , this ) ; } public Explanation explain ( IndexReader reader , int doc ) throws IOException { ConstantScorer cs = new ConstantScorer ( similarity , reader , this ) ; boolean exists = cs . docIdSetIterator . advance ( doc ) == doc ; ComplexExplanation result = new ComplexExplanation ( ) ; if ( exists ) { result . setDescription ( \"ConstantScoreQuery(\" + filter + \"), product of:\" ) ; result . setValue ( queryWeight ) ; result . setMatch ( Boolean . TRUE ) ; result . addDetail ( new Explanation ( getBoost ( ) , \"boost\" ) ) ; result . addDetail ( new Explanation ( queryNorm , \"queryNorm\" ) ) ; } else { result . setDescription ( \"ConstantScoreQuery(\" + filter + \") doesn't match id \" + doc ) ; result . setValue ( 0 ) ; result . setMatch ( Boolean . FALSE ) ; } return result ; } } protected class ConstantScorer extends Scorer { final DocIdSetIterator docIdSetIterator ; final float theScore ; int doc = - 1 ; int [ ] sorts = new int [ Scorer . numSort ] ; public ConstantScorer ( Similarity similarity , IndexReader reader , Weight w ) throws IOException { super ( similarity ) ; theScore = w . getValue ( ) ; DocIdSet docIdSet =", "gt": "filter . getDocIdSet ( reader ) ;", "prediction": ";\n", "label": 1}
{"id": 9199, "input": "<s> package ar . com . fdvs . dj . test . web . webwork ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; import junit . framework . TestCase ; import org . apache . log4j . lf5 . util . StreamUtils ; import com . meterware . httpunit . WebResponse ; import com . meterware . servletunit . ServletRunner ; import com . meterware . servletunit . ServletUnitClient ; public class WWResultTypeTest extends TestCase { public void testDynamicReport ( ) throws Exception { ServletRunner sr = new ServletRunner ( getClass ( ) . getResourceAsStream ( \"/webwork/web.xml\" ) ) ; ServletUnitClient client = sr . newClient ( ) ; WebResponse r = client . getResponse ( \"http://localhost/generateReport.action\" ) ; String fname = r . getHeaderField ( \"CONTENT-DISPOSITION\" ) ; fname = fname . substring ( fname . indexOf ( \"=\" ) + 1 ) ; FileOutputStream fos = new FileOutputStream ( new File ( System . getProperty ( \"user.dir\" ) + \"/target/\" + fname ) ) ; InputStream is =", "gt": "r . getInputStream ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10119, "input": "<s> package org . fuzzydb . server . internal . server ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . fuzzydb . client . exceptions . StoreExistsException ; import org . fuzzydb . client . exceptions . UnknownStoreException ; import org . fuzzydb . client . internal . comms . messages . CreateStoreCmd ; import org . fuzzydb . client . internal . comms . messages . CreateStoreRsp ; import org . fuzzydb . io . core . MessageSink ; import org . fuzzydb . io . core . messages . Command ; public class ServerCreateStoreTransaction extends ServerTransaction { private int storeId ; public ServerCreateStoreTransaction ( ServerTransactionCoordinator stc , MessageSink source ) { super ( stc , source ) ; } @ Override public void setWriteCommand ( Command command , ByteBuffer packet ) { assert ( command instanceof CreateStoreCmd ) ; super . setWriteCommand ( command , packet ) ; } @ Override protected void doCommitChecks ( ) { String storeName = getStoreName ( ) ; try { stc . getRepository ( ) . getStore ( storeName ) ; }", "gt": "catch ( UnknownStoreException e )", "prediction": "}\n", "label": 1}
{"id": 290, "input": "<s> package pkg2 ; public class C4 { public static final", "gt": "int I = 1 ;", "prediction": ") ;\n", "label": 0}
{"id": 10121, "input": "<s> package org . eclipse . jface . databinding . swt ; import org . eclipse . jface . internal . databinding . swt . ControlBackgroundProperty ; import org . eclipse . jface . internal . databinding . swt . ControlBoundsProperty ; import org . eclipse . jface . internal . databinding . swt . ControlFocusedProperty ; import org . eclipse . jface . internal . databinding . swt . ControlFontProperty ; import org . eclipse . jface . internal . databinding . swt . ControlForegroundProperty ; import org . eclipse . jface . internal . databinding . swt . ControlLocationProperty ; import org . eclipse . jface . internal . databinding . swt . ControlSizeProperty ; import org . eclipse . jface . internal . databinding . swt . ControlVisibleProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetEditableProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetEnabledProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetImageProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetItemsProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetMaximumProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetMessageProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetMinimumProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetSelectionProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetSingleSelectionIndexProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetTextProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetTextWithEventsProperty ; import org . eclipse . jface . internal . databinding . swt . WidgetTooltipTextProperty ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . custom . CLabel ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . DateTime ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . List ; import org .", "gt": "eclipse . swt . widgets . Menu ;", "prediction": ";\n", "label": 1}
{"id": 923, "input": "<s> package pkg2 ; import pkg1 . * ; public class C3 { public C1 field = null ; public C1 method2 ( ) { return null ; } public void method (", "gt": "pkg1 . C1 c1 )", "prediction": ")\n", "label": 0}
{"id": 10125, "input": "<s> package org . eclipse . rap . rwt . apache . batik . util . io ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; public class GenericDecoder implements CharDecoder { protected Reader reader ; public GenericDecoder ( InputStream is , String enc ) throws IOException { reader = new InputStreamReader ( is , enc ) ; reader = new BufferedReader ( reader ) ; } public GenericDecoder ( Reader r ) { reader = r ; if ( ! ( r instanceof BufferedReader ) ) { reader = new BufferedReader ( reader ) ; } } public int readChar ( ) throws IOException { return reader . read ( ) ; } public", "gt": "void dispose ( ) throws IOException", "prediction": "}\n", "label": 1}
{"id": 7093, "input": "<s> package com . deliciousdroid . client ; import android . content . Context ; import android . os . Handler ; import android . util . Log ; import com . deliciousdroid . authenticator . AuthenticatorActivity ; import org . apache . http . auth . Credentials ; import org . apache . http . auth . UsernamePasswordCredentials ; import org . apache . http . client . CredentialsProvider ; import org . apache . http . auth . AuthScope ; import android . net . Uri ; import org . apache . http . HttpResponse ; import org . apache . http . HttpStatus ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . DefaultHttpClient ; import org . apache . http . protocol . HTTP ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; public class NetworkUtilities { private static final String TAG = \"NetworkUtilities\" ; public static final String PARAM_USERNAME = \"username\" ; public static final String PARAM_PASSWORD = \"password\" ; public static final String PARAM_UPDATED = \"timestamp\" ; public static final String USER_AGENT = \"AuthenticationService/1.0\" ; public static final String FETCH_FRIEND_UPDATES_URI = \"http://feeds.delicious.com/v2/json/networkmembers/\" ; public static final String FETCH_FRIEND_BOOKMARKS_URI = \"http://feeds.delicious.com/v2/json/\" ; public static final String FETCH_NETWORK_RECENT_BOOKMARKS_URI = \"http://feeds.delicious.com/v2/json/network/\" ; public static final String FETCH_STATUS_URI = \"http://feeds.delicious.com/v2/json/network/\" ; public static final String FETCH_TAGS_URI = \"http://feeds.delicious.com/v2/json/tags/\" ; private static final String SCHEME = \"http\" ; private static final String SCHEME_HTTP = \"http\" ; private static final String DELICIOUS_AUTHORITY = \"api.del.icio.us\" ; private static final int PORT = 80 ; private static final int PORT_HTTP = 80 ; private static final AuthScope SCOPE = new AuthScope ( DELICIOUS_AUTHORITY , PORT ) ; private static final AuthScope SCOPE_HTTP = new AuthScope ( DELICIOUS_AUTHORITY , PORT_HTTP ) ; public static Thread performOnBackgroundThread ( final Runnable runnable ) { final Thread t = new Thread ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } finally { } } } ; t . start ( ) ; return t ; } public static boolean deliciousAuthenticate ( String username , String password , Handler handler , final Context context ) { final HttpResponse resp ; Uri . Builder builder = new Uri . Builder ( ) ; builder . scheme ( SCHEME_HTTP ) ; builder . authority ( DELICIOUS_AUTHORITY ) ; builder . appendEncodedPath ( \"v1/posts/update\" ) ; Uri uri = builder . build ( ) ; Log . d ( \"auth uri\" , String . valueOf ( uri ) ) ; HttpGet request = new HttpGet ( String . valueOf ( uri ) ) ; DefaultHttpClient client = ( DefaultHttpClient ) HttpClientFactory . getThreadSafeClient ( ) ; CredentialsProvider provider = client . getCredentialsProvider ( ) ; Credentials credentials = new UsernamePasswordCredentials ( username , password ) ; provider . setCredentials ( SCOPE_HTTP , credentials ) ; client . addRequestInterceptor ( new PreemptiveAuthInterceptor ( ) , 0 ) ; try { resp = client . execute ( request ) ; if ( resp . getStatusLine ( ) . getStatusCode ( ) == HttpStatus . SC_OK ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Log . v ( TAG , \"Successful authentication\" ) ; } sendResult ( new LoginResult ( true ) , handler , context ) ; return true ; } else { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Log . v ( TAG , \"Error authenticating\" + resp . getStatusLine ( ) ) ; } sendResult ( new LoginResult ( false ) , handler , context ) ; return false ; } } catch ( final IOException e ) { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Log . v ( TAG , \"IOException when getting authtoken\" , e ) ; } sendResult ( new LoginResult ( false ) , handler , context ) ; return false ; } finally { if ( Log . isLoggable ( TAG , Log . VERBOSE ) ) { Log . v ( TAG , \"getAuthtoken completing\" ) ; } } } public static String getWebpageTitle ( String url ) { if ( url != null && ! url . equals ( \"\" ) ) { if ( ! url . startsWith ( \"http\" ) ) { url = \"http://\" + url ; } HttpResponse resp = null ; HttpGet post = null ; post = new HttpGet ( url ) ; post .", "gt": "setHeader ( \"User-Agent\" , \"Mozilla/5.0\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10128, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . internal . SWTEventListener ; public interface PaintListener extends SWTEventListener { public void", "gt": "paintControl ( PaintEvent event ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2876, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import java . awt . Color ; import java . util . List ; import org . jfree . chart . plot . PlotOrientation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . dataset . XYDataset ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . chart . plot . ScatterPlot ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; public class DJScatterChartBuilder extends AbstractChartBuilder { public DJScatterChartBuilder setOperation ( byte operation ) { this . chart . setOperation ( operation ) ; return this ; } public DJScatterChartBuilder setLink ( DJHyperLink link ) { this . chart . setLink ( link ) ; return this ; } public DJScatterChartBuilder setBackColor ( Color backColor ) { this . chart . getOptions ( ) . setBackColor ( backColor ) ; return this ; } public DJScatterChartBuilder setHeight ( int height ) { this . chart . getOptions ( ) . setHeight ( height ) ; return this ; } public DJScatterChartBuilder setWidth ( int width ) { this . chart . getOptions ( ) . setWidth ( width ) ; return this ; } public DJScatterChartBuilder setCentered ( boolean centered ) { this . chart . getOptions ( ) . setCentered ( centered ) ; return this ; } public DJScatterChartBuilder setPosition ( byte position ) { this . chart . getOptions ( ) . setPosition ( position ) ; return this ; } public DJScatterChartBuilder setY ( int y ) { this . chart . getOptions ( ) . setY ( y ) ; return this ; } public DJScatterChartBuilder setX ( int x ) { this . chart . getOptions ( ) . setX ( x ) ; return this ; } public DJScatterChartBuilder setShowLegend ( boolean showLegend ) { this . chart . getOptions ( ) . setShowLegend (", "gt": "new Boolean ( showLegend ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10140, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import javax . servlet . ServletContext ; import org . eclipse . rap . rwt . application . ApplicationConfiguration ; import org . eclipse . rap . rwt . internal . service . ApplicationStoreImpl ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . textsize . MeasurementListener ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackServiceHandler ; import org . eclipse . rap . rwt . service . IApplicationStore ; import org . eclipse . rap . rwt . service . RWTFileSettingStoreFactory ; class ApplicationContextConfigurator { private final ApplicationConfiguration configuration ; private final ServletContext servletContext ; ApplicationContextConfigurator ( ApplicationConfiguration configuration , ServletContext servletContext ) { this . configuration = configuration ; this . servletContext = servletContext ; } void configure ( ApplicationContext applicationContext ) { createDefaultTheme ( applicationContext ) ; configureCustomSettings ( applicationContext ) ; configureInternalSettings ( applicationContext ) ; } void reset ( ApplicationContext applicationContext ) { resetSubSystems ( applicationContext ) ; resetApplicationStore ( applicationContext ) ; } private void configureCustomSettings ( ApplicationContext applicationContext ) { configuration . configure ( createApplication ( applicationContext ) ) ; } private void configureInternalSettings ( ApplicationContext applicationContext ) { setContextDirectory ( applicationContext ) ; addInternalPhaseListeners ( applicationContext ) ; addInternalServiceHandlers ( applicationContext ) ; setInternalSettingStoreFactory ( applicationContext ) ; } private void setContextDirectory ( ApplicationContext applicationContext ) { String location = ( String ) servletContext . getAttribute ( ApplicationConfiguration . RESOURCE_ROOT_LOCATION ) ; if ( location == null ) { location = servletContext . getRealPath ( \"/\" ) ; } applicationContext . getResourceDirectory ( ) . configure ( location ) ; } private void resetApplicationStore ( ApplicationContext applicationContext ) { IApplicationStore storeInstance = applicationContext . getApplicationStore ( ) ; ApplicationStoreImpl applicationStore = ( ApplicationStoreImpl ) storeInstance ; applicationStore . reset ( ) ; } private void resetSubSystems ( ApplicationContext applicationContext ) { applicationContext . getBrandingManager ( ) . deregisterAll ( ) ; applicationContext . getEntryPointManager ( ) . deregisterAll ( ) ; applicationContext . getPhaseListenerRegistry ( ) . removeAll ( ) ; applicationContext . getResourceRegistry ( ) . clear ( ) ; applicationContext . getSettingStoreManager ( ) . deregisterFactory ( ) ; resetContextDirectory ( applicationContext ) ; } private void resetContextDirectory ( ApplicationContext applicationContext ) { applicationContext . getResourceDirectory", "gt": "( ) . reset ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3608, "input": "<s> class X < T > { } class T1 < A extends", "gt": "X < B > , B >", "prediction": ";\n", "label": 0}
{"id": 10148, "input": "<s> package agents ; import java . util . HashSet ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Random ; import risk . * ; import sim . util . Bag ; import evoga . * ; import ec . util . MersenneTwisterFast ; public class Evolver extends Agent { private BattleHistories attackHistories ; private BattleHistories defenseHistories ; private static Bag allEvoAgents = new Bag ( ) ; private static Bag allEvoTerritories = new Bag ( ) ; private static boolean flagNotInit = true ; protected static double fightingThreshold = 0.7 ; private double utility ; private double preUtility ; private int diffSubInfluence ; private double wealth ; private int terrWorldDomination ; private int preDiffSubInfluence ; private double preWealth ; private int preTerrWorldDomination ; private int numGAGenome = 20 ; private int straSelectTournamentSize = 5 ; private int numAttackStra = 4 ; private int numDefStra = 0 ; private int numTradStra = 0 ; private float probCrossover = 0.7f ; private float probMutate = 0.2f ; private float probPointMutate = 0.03f ; private float probMigrate = 0.03f ; private float probRepro = 0.07f ; private int selectedStraID = - 1 ; private GAIndividual strategy = null ; private float beta = 1 / 3f ; private static MersenneTwisterFast rand = new MersenneTwisterFast ( ) ; GAPopulation gaPop ; public Evolver ( int id , int type ) { super ( id , type ) ; empireName = \"GAEvolver\" ; attackHistories = new BattleHistories ( true ) ; defenseHistories = new BattleHistories ( false ) ; preUtility = 0 ; preDiffSubInfluence = 0 ; preWealth = 0 ; preTerrWorldDomination = 0 ; gaPop = new GAPopulation ( numGAGenome , numAttackStra , numDefStra , numTradStra , probCrossover , probMutate , probPointMutate , probMigrate , probRepro ) ; flagNotInit = true ; } private void init ( ) { if ( ! allEvoAgents . contains ( this ) ) { allEvoAgents . add ( this ) ; } StrategyScouting . calcuWorldWideTerritories ( myTerritory ) ; StrategyScouting . calcuInitPhysicalTerritories ( ) ; flagNotInit = false ; } private void calcuUtility ( ) { diffSubInfluence = calcuNumDiffSubordinates ( ) ; wealth = myTerritory . getSoldiers ( ) + myTerritory . getNatRes ( ) + myTerritory . getPeasants ( ) ; terrWorldDomination = calcuWorldDomination ( ) ; utility = Math . pow ( ( double ) diffSubInfluence , ( double ) beta ) * Math . pow ( wealth , ( double ) beta ) * Math . pow ( ( double ) terrWorldDomination , ( double ) beta ) ; } private int calcuNumDiffSubordinates ( ) { Bag tmpSubordinates = myTerritory . getSubordinates ( ) ; int tmpNumDiffSubordinates = 0 ; for ( int i = 0 ; i < tmpSubordinates . numObjs ; i ++ ) if ( ( ( Territory ) tmpSubordinates . get ( i ) ) . getType ( ) != this . getType ( ) ) tmpNumDiffSubordinates ++ ; return tmpNumDiffSubordinates ; } private int calcuWorldDomination ( ) { int tmpNumSameType = 0 ; for ( int i = 0 ; i < StrategyScouting . allTerritories . numObjs ; i ++ ) if ( ( ( Territory ) StrategyScouting . allTerritories . get ( i ) ) . getType ( ) == this . getType ( ) ) tmpNumSameType ++ ; return tmpNumSameType ; } private void MentalEvo ( ) { preUtility = utility ; calcuUtility ( ) ; double tmpDiffUtility = utility - preUtility ; if ( selectedStraID != - 1 ) { System . out . println ( \"Evolver\" + this . getId ( ) + \" is evolving!\" ) ; gaPop . EvolvePop ( tmpDiffUtility , selectedStraID ) ; strategy . setFlagSelected ( false ) ; } else gaPop . EvolvePop ( 1.0d , selectedStraID ) ; selectedStraID = gaPop . SelectTournament ( straSelectTournamentSize , true ) ; strategy = gaPop . getGAIndividual ( selectedStraID ) ; strategy . setFlagSelected ( true ) ; System . out . println ( \"Evolver\" + this . getId ( ) + \" selected \" + selectedStraID + \" GAGenome\" ) ; } protected void chooseTax ( ) { tax = 0.5 ; if ( flagNotInit ) init ( ) ; StrategyScouting . calcuAllHierarchyLevelThreat ( ) ; StrategyScouting . calcuWorldWideTerritories ( myTerritory ) ; MentalEvo ( ) ; } protected void attack ( ) { double [ ] tmpAttackStraProb = strategy . getStraProb ( 0 , numAttackStra ) ; AttackStrategy attackStra = new AttackStrategy ( this . myTerritory ) ; Territory selectedTerritory = attackStra . selectTarget ( fightingThreshold , tmpAttackStraProb ) ; if ( selectedTerritory != null ) { this . attackedTerritoryID = selectedTerritory . getId ( ) ; if ( selectedTerritory . getType ( ) == myTerritory . getType ( ) ) { this . attackingSoldiers = 0.000001 ; } else { if ( this", "gt": ". attackedTerritoryID != this . myTerritory . getId ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 4982, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface ExtendedTaskAttribute extends TaskAttribute { Extend getExtend ( ) ; void setExtend ( Extend value ) ;", "gt": "String getValue ( ) ;", "prediction": "}\n", "label": 0}
{"id": 10152, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . Index ; import org . apache . lucene . document . Field . Store ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; public class TestQueryWrapperFilter extends LuceneTestCase { public void testBasic ( ) throws Exception { Directory dir = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( dir , new StandardAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"field\" , \"value\" , Store . NO , Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; writer . close ( ) ; TermQuery termQuery = new TermQuery ( new Term ( \"field\" , \"value\" ) ) ; QueryWrapperFilter qwf = new QueryWrapperFilter ( termQuery ) ; IndexSearcher searcher = new IndexSearcher ( dir , true ) ; TopDocs hits = searcher . search ( new MatchAllDocsQuery ( ) , qwf , 10 ) ; assertEquals ( 1 , hits . totalHits ) ; hits = searcher . search ( new MatchAllDocsQuery ( ) , new CachingWrapperFilter ( qwf ) , 10 ) ; assertEquals ( 1 , hits . totalHits ) ; BooleanQuery booleanQuery = new BooleanQuery ( ) ; booleanQuery . add ( termQuery , Occur . MUST ) ; booleanQuery . add ( new TermQuery ( new Term ( \"field\"", "gt": ", \"missing\" ) ) , Occur . MUST_NOT ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 9023, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Skeleton ; public interface LizaSkeleton extends Skeleton { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte >", "gt": "transparent , int maxDistance ) ;", "prediction": ")\n", "label": 0}
{"id": 10154, "input": "<s> package org . eclipse . swt . internal . widgets . datetimekit ; import java . io . IOException ; import org . eclipse . swt . widgets . DateTime ; abstract class AbstractDateTimeLCADelegate { abstract void preserveValues ( DateTime dateTime ) ; abstract", "gt": "void readData ( DateTime dateTime ) ;", "prediction": "}\n", "label": 1}
{"id": 3439, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . Account ; import org . jjflyboy . tjpeditor . project . AccountAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . SupplementAccount ; public class SupplementAccountImpl extends PropertyImpl implements SupplementAccount { protected Account account ; protected EList < AccountAttribute > attributes ; protected SupplementAccountImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getSupplementAccount ( ) ; } public Account getAccount ( ) { if ( account != null && account . eIsProxy ( ) ) { InternalEObject oldAccount = ( InternalEObject ) account ; account = ( Account ) eResolveProxy ( oldAccount ) ; if ( account != oldAccount ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . SUPPLEMENT_ACCOUNT__ACCOUNT , oldAccount , account ) ) ; } } return account ; } public Account basicGetAccount ( ) { return account ; } public void setAccount ( Account newAccount ) { Account oldAccount = account ; account = newAccount ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SUPPLEMENT_ACCOUNT__ACCOUNT , oldAccount , account ) ) ; } public EList < AccountAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < AccountAttribute > ( AccountAttribute . class , this , ProjectPackage . SUPPLEMENT_ACCOUNT__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . SUPPLEMENT_ACCOUNT__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SUPPLEMENT_ACCOUNT__ACCOUNT : if ( resolve ) return getAccount ( ) ; return basicGetAccount ( ) ; case ProjectPackage . SUPPLEMENT_ACCOUNT__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . SUPPLEMENT_ACCOUNT__ACCOUNT", "gt": ": setAccount ( ( Account ) newValue ) ;", "prediction": ";\n", "label": 0}
{"id": 10155, "input": "<s> package org . gatein", "gt": ". common . logging ;", "prediction": ";\n", "label": 1}
{"id": 6842, "input": "<s> package org . ofbiz . base . util . collections ; import java . util . Locale ; public", "gt": "interface LocalizedMap < V >", "prediction": ";\n", "label": 0}
{"id": 10170, "input": "<s> package br . org . archimedes . controller ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . stub . StubCommandFactory ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class ActiveStateTest { private Drawing drawing ; private InputState state ; private CommandFactory factory ; private ActiveState activeSate ; @ Before public void setUp ( ) throws Exception { drawing = new Drawing ( \"hi\" ) ; factory = new StubCommandFactory ( ) ; state = new IdleState ( null ) ; activeSate = new ActiveState (", "gt": "state , factory , drawing ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1452, "input": "<s> import java . util . Collection ; import java . util . Collections ; public class T6650759c { static interface A { } static interface B < X extends A > { } static interface C < X extends A , Y extends B < X > > { } public static < T extends A , U extends B < T > > Collection < C < T , U > > get ( U u ) { return null ; } public < T extends A , U extends B < T > > Collection < C < T , U >", "gt": "> test ( U u )", "prediction": ")\n", "label": 0}
{"id": 10175, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec4 . sub1 ; import java . util . HashMap ; import java . util . Map ; import org . restlet . data . LocalReference ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . ext . freemarker . TemplateRepresentation ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Get ; import org . restlet . resource . ServerResource ; public class MailServerResource extends ServerResource { @ Get public Representation toXml ( ) { Mail mail = new Mail ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( )", "gt": ". toString ( ) ) ;", "prediction": ";\n", "label": 1}
{"id": 4799, "input": "<s> package org . jjflyboy . tjpeditor . serializer ;", "gt": "public class ProjectSemanticSequencer extends AbstractProjectSemanticSequencer", "prediction": "}\n", "label": 0}
{"id": 10176, "input": "<s> package org . robotframework . text . ui ; import org . eclipse . xtext . CrossReference ; import org . eclipse . xtext . diagnostics . DiagnosticMessage ; import org . eclipse . xtext . linking . impl . IllegalNodeException ; public class IgnoreLinkingErrorsDiagnosticMessageProvider implements org . eclipse . xtext . linking . ILinkingDiagnosticMessageProvider . Extended { @ Override public DiagnosticMessage getUnresolvedProxyMessage ( ILinkingDiagnosticContext context ) { return null ; } @ Override public DiagnosticMessage getIllegalNodeMessage ( ILinkingDiagnosticContext context , IllegalNodeException ex ) { return null ; } @ Override public DiagnosticMessage getIllegalCrossReferenceMessage ( ILinkingDiagnosticContext", "gt": "context , CrossReference reference )", "prediction": ")\n", "label": 1}
{"id": 5970, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ;", "gt": "public interface TimesheetReportAttribute extends EObject", "prediction": ";\n", "label": 0}
{"id": 10185, "input": "<s> package org . eclipse . jface . databinding . viewers ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . list . IObservableList ; import org . eclipse . core . databinding . property . list . SimpleListProperty ; import org . eclipse . jface . databinding . swt . SWTObservables ; import org . eclipse . jface . internal . databinding . viewers . ViewerObservableListDecorator ; import org . eclipse . jface . viewers . Viewer ; public abstract class ViewerListProperty extends SimpleListProperty implements IViewerListProperty { public IObservableList observe ( Object source ) { if ( source instanceof Viewer ) { return observe ( ( Viewer ) source ) ; } return super . observe ( source ) ; } public IObservableList observe ( Realm realm , Object source ) { IObservableList observable = super", "gt": ". observe ( realm , source ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3072, "input": "<s> package org . gk . engine . client . utils ; public interface IRegExpUtils { public static final String INTEGER = \"^-?\\\\d+$\" ; public static final String FLOAT = \"-?(\\\\d*\\\\.)?\\\\d+\" ; public final static String DECIMAL = \"^-?\\\\d+\\\\.\\\\d+$\" ; public final static String POSITIVE_INTEGER = \"^\\\\d*[1-9]\\\\d*$\" ; public final static", "gt": "String POSITIVE_FLOAT = \"(\\\\d*\\\\.)?\\\\d+\" ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10199, "input": "<s> package org . eclipse . rap . ui . tests . resources ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . IResourceManager . RegisterOptions ; public final class Resource5 implements IResource { public String getCharset ( ) { return \"UTF-8\" ; } public ClassLoader getLoader ( ) { return Resource5 . class . getClassLoader ( ) ; } public String getLocation ( ) { return \"org/eclipse/rap/ui/tests/resources/Resource.js\" ; } public RegisterOptions getOptions ( ) {", "gt": "return RegisterOptions . VERSION_AND_COMPRESS ;", "prediction": "\n", "label": 1}
{"id": 7470, "input": "<s> import java . io . IOException ; import java . util . Arrays ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" , \"-package\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; } public static boolean start ( RootDoc root ) { try { ClassDoc [ ] cds = root . classes ( ) ; Arrays . sort ( cds ) ; for ( ClassDoc cd : cds ) { tester . printClass ( cd ) ; tester", "gt": ". println ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10226, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Tree ; public class VirtualLazyTreeViewerTest extends TreeViewerTest { protected int setDataCalls = 0 ; public VirtualLazyTreeViewerTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { Tree tree = new Tree ( parent , SWT . VIRTUAL ) ; tree . addListener ( SWT . SetData , new Listener ( ) { public void handleEvent ( Event event ) { setDataCalls ++ ; } } ) ; fTreeViewer = new TreeViewer ( tree ) ; fTreeViewer . setContentProvider ( new TestModelLazyTreeContentProvider ( ( TreeViewer ) fTreeViewer ) ) ; return fTreeViewer ; } public void setUp ( ) { super . setUp ( ) ; processEvents ( ) ; } protected void setInput ( ) { super . setInput ( ) ; } public void tearDown ( ) { super . tearDown ( ) ; } public void testLeafIsExpandable ( ) { TestElement leafElement = fRootElement . getChildAt ( 2 ) . getChildAt ( 3 ) . getChildAt ( 2 ) ; assertEquals ( 0 , leafElement . getChildCount ( ) ) ; assertFalse ( fTreeViewer . isExpandable ( leafElement ) ) ; } public void testRootIsExpandable ( ) { TestElement rootElement = fRootElement . getChildAt ( 2 ) ; assertTrue ( rootElement . getChildCount ( ) > 0 ) ; assertTrue ( fTreeViewer . isExpandable ( rootElement ) ) ; } public void testNodeIsExpandable ( ) { TestElement nodeElement = fRootElement . getChildAt ( 2 ) . getChildAt ( 3 ) ; assertTrue ( nodeElement . getChildCount ( ) > 0 ) ; assertTrue ( fTreeViewer . isExpandable ( nodeElement ) ) ; } public void testRefreshWithDuplicateChild ( ) { } public void testSetExpandedWithCycle ( ) { } public void testFilterExpanded ( ) { } public void testFilter ( ) { } public void testSetFilters ( ) { } public void testInsertSiblingWithFilterFiltered ( ) { } public void testInsertSiblingWithFilterNotFiltered ( ) { } public void testInsertSiblingWithSorter ( ) { } public void testRenameWithFilter ( ) { }", "gt": "public void testRenameWithSorter ( )", "prediction": "}\n", "label": 1}
{"id": 2199, "input": "<s> package javax . tools ; import java . util . Set ; import java . io . InputStream ; import java . io . OutputStream ; import javax . lang . model . SourceVersion ; public interface Tool { int run ( InputStream in , OutputStream out ,", "gt": "OutputStream err , String ... arguments ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10249, "input": "<s> package org . apache . lucene . analysis . ngram ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import java . io . IOException ; import java . io . StringReader ; public class NGramTokenFilterTest extends BaseTokenStreamTestCase { private TokenStream input ; public void setUp ( ) throws Exception { super . setUp ( ) ; input = new WhitespaceTokenizer ( new StringReader ( \"abcde\" ) ) ; } public void testInvalidInput ( ) throws Exception { boolean gotException = false ; try { new NGramTokenFilter ( input , 2 , 1 ) ; } catch ( IllegalArgumentException e ) { gotException = true ; } assertTrue ( gotException ) ; } public void testInvalidInput2 ( ) throws Exception { boolean gotException = false ; try { new NGramTokenFilter ( input , 0 , 1 ) ; } catch ( IllegalArgumentException e ) { gotException = true ; } assertTrue ( gotException ) ; } public void testUnigrams ( ) throws Exception { NGramTokenFilter filter = new NGramTokenFilter ( input , 1 , 1 ) ; assertTokenStreamContents ( filter , new String [ ] { \"a\" , \"b\" , \"c\" , \"d\" , \"e\" } , new int [ ] { 0 , 1 , 2 , 3 , 4 } , new int [ ] { 1 , 2 , 3 , 4 , 5 } ) ; } public void testBigrams ( ) throws Exception { NGramTokenFilter filter = new NGramTokenFilter ( input , 2 , 2 ) ; assertTokenStreamContents ( filter , new String [ ] { \"ab\" , \"bc\" , \"cd\" , \"de\" } , new int [ ] { 0 , 1 , 2 , 3 } , new int [ ] { 2 , 3 , 4 , 5 } ) ; } public void testNgrams ( ) throws Exception { NGramTokenFilter filter = new NGramTokenFilter ( input , 1 , 3 ) ; assertTokenStreamContents ( filter , new String [ ] { \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"ab\" , \"bc\" , \"cd\" , \"de\" , \"abc\" , \"bcd\" , \"cde\" } , new int [ ] { 0 , 1 , 2 , 3 , 4 , 0 , 1 , 2 , 3 , 0 , 1 , 2 } , new int [ ] { 1 , 2 , 3 , 4 , 5 , 2 , 3 , 4 , 5 , 3 , 4 , 5 } ) ; } public void testOversizedNgrams ( ) throws Exception { NGramTokenFilter filter = new NGramTokenFilter ( input , 6 , 7 ) ; assertTokenStreamContents ( filter , new String [ 0 ] , new int [ 0 ] , new int [ 0 ] ) ; } public void testSmallTokenInStream ( ) throws Exception { input = new WhitespaceTokenizer ( new StringReader ( \"abc de fgh\" ) ) ; NGramTokenFilter filter = new", "gt": "NGramTokenFilter ( input , 3 , 3 ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 8011, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface SupplementTask extends Property , TaskAttribute { Task getTask ( ) ; void", "gt": "setTask ( Task value ) ;", "prediction": "}\n", "label": 0}
{"id": 10273, "input": "<s> package de . akquinet . innovation . play . maven ; import java . io . File ; import java . io . IOException ; import java . net . URL ; import org . apache . commons . io . FileUtils ; import org . apache . commons . lang . StringUtils ; import org . apache . maven . plugin . AbstractMojo ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; import org . codehaus . plexus . archiver . UnArchiver ; import org . codehaus . plexus . archiver . manager . ArchiverManager ; import org . codehaus . plexus . archiver . manager . NoSuchArchiverException ; public class Play2InstallPlayMojo extends AbstractMojo { private ArchiverManager archiverManager ; private String play2version ; private String play2basedir ; public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( StringUtils . isEmpty ( play2version ) ) { throw new MojoExecutionException ( \"play2version configuration parameter is not set\" ) ; } String debugLogPrefix = \"AutoInstall - Play! \" + play2version + ' ' ; File play2basedirFile = new File ( play2basedir ) ; File play2home = new File ( play2basedirFile , \"play-\" + play2version ) ; File play2 = new File ( play2home , AbstractPlay2Mojo . isWindows ( ) ? \"play.bat\" : \"play\" ) ; if ( play2 . isFile ( ) && play2 . canExecute ( ) ) { getLog ( ) . info ( debugLogPrefix + \"is already installed in \" + play2home ) ; return ; } getLog ( ) . info ( \"Play! \" + play2version + \" download and installation, please be patient ...\" ) ; File zipFile = new File ( play2basedirFile , \"play-\" + play2version + \".zip\" ) ; try { URL zipUrl = new URL ( \"http://download.playframework.org/releases/play-\" + play2version + \".zip\" ) ; FileUtils . forceMkdir ( play2basedirFile ) ; getLog ( ) . debug ( debugLogPrefix + \"is downloading to \" + zipFile ) ; FileUtils . copyURLToFile ( zipUrl , zipFile ) ; getLog ( ) . debug ( debugLogPrefix + \"is extracting to \" + play2basedir ) ; UnArchiver unarchiver = archiverManager . getUnArchiver ( zipFile ) ; unarchiver . setSourceFile ( zipFile ) ; unarchiver . setDestDirectory ( play2basedirFile ) ; unarchiver . extract ( ) ; File framework = new File ( play2home , \"framework\" ) ; File build = new File ( framework , AbstractPlay2Mojo .", "gt": "isWindows ( ) ? \"build.bat\" : \"build\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4341, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Egg ; public interface LizaEgg extends Egg { List < LizaEntity > getNearbyLizaEntities ( double x ,", "gt": "double y , double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10289, "input": "<s> package org . restlet . engine . io ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . SocketChannel ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . util . SelectionRegistration ; public class ReadableSocketChannel extends WrapperSocketChannel implements ReadableSelectionChannel { public ReadableSocketChannel ( SocketChannel wrappedChannel , SelectionRegistration registration ) { super ( wrappedChannel , registration ) ; if ( Context . getCurrentLogger ( ) . isLoggable ( Level . FINER ) ) { Context . getCurrentLogger ( ) . log ( Level . FINER , \"ReadableSocketChannel created from: \" + wrappedChannel + \",\" + registration + \". Registration: \" + getRegistration ( ) ) ; } } public int read ( ByteBuffer dst ) throws IOException { if", "gt": "( getWrappedChannel ( ) . isOpen ( ) )", "prediction": "( )\n", "label": 1}
{"id": 5429, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . AlertLevel ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . StatusTimesheet ; import org . jjflyboy . tjpeditor . project . StatusTimesheetAttribute ; public class StatusTimesheetImpl extends TaskTimesheetAttributeImpl implements StatusTimesheet { protected static final AlertLevel LEVEL_EDEFAULT = AlertLevel . RED ; protected AlertLevel level = LEVEL_EDEFAULT ; protected static final String TEXT_EDEFAULT = null ; protected String text = TEXT_EDEFAULT ; protected EList < StatusTimesheetAttribute > attributes ; protected StatusTimesheetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getStatusTimesheet ( ) ; } public AlertLevel getLevel ( ) { return level ; } public void setLevel ( AlertLevel newLevel ) { AlertLevel oldLevel = level ; level = newLevel == null ? LEVEL_EDEFAULT : newLevel ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_TIMESHEET__LEVEL , oldLevel , level ) ) ; } public String getText ( ) { return text ; } public void setText ( String newText ) { String oldText = text ; text = newText ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_TIMESHEET__TEXT , oldText , text ) ) ; } public EList < StatusTimesheetAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < StatusTimesheetAttribute > ( StatusTimesheetAttribute . class , this , ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . STATUS_TIMESHEET__LEVEL : return getLevel ( ) ; case ProjectPackage . STATUS_TIMESHEET__TEXT : return getText ( ) ; case ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . STATUS_TIMESHEET__LEVEL : setLevel ( ( AlertLevel ) newValue ) ; return ; case ProjectPackage . STATUS_TIMESHEET__TEXT : setText ( ( String ) newValue ) ; return ; case ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES : getAttributes ( ) . clear ( ) ; getAttributes ( ) . addAll ( ( Collection < ? extends StatusTimesheetAttribute > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . STATUS_TIMESHEET__LEVEL : setLevel ( LEVEL_EDEFAULT ) ; return ; case ProjectPackage . STATUS_TIMESHEET__TEXT : setText ( TEXT_EDEFAULT ) ; return ; case ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES : getAttributes ( ) . clear ( ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . STATUS_TIMESHEET__LEVEL : return level != LEVEL_EDEFAULT ; case ProjectPackage . STATUS_TIMESHEET__TEXT : return TEXT_EDEFAULT == null ? text != null : ! TEXT_EDEFAULT . equals ( text ) ; case ProjectPackage . STATUS_TIMESHEET__ATTRIBUTES : return attributes != null && ! attributes . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; } @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super .", "gt": "toString ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10313, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; public class SerialMergeScheduler extends MergeScheduler { synchronized public void merge ( IndexWriter writer ) throws CorruptIndexException , IOException { while ( true ) { MergePolicy . OneMerge merge =", "gt": "writer . getNextMerge ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5343, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . AnimalTamer ; import org . bukkit . entity . Tameable ; import Liza . LizaTameable ; public class LizaCraftTameable implements LizaTameable { private Tameable tameable ; public LizaCraftTameable ( Tameable tameable ) { this . tameable = tameable ; } @ Override public AnimalTamer getOwner ( ) { return this . tameable . getOwner ( ) ; } @ Override public boolean isTamed ( ) { return this . tameable . isTamed ( ) ; } @ Override public void setOwner ( AnimalTamer tamer ) { this . tameable . setOwner ( tamer ) ; } @ Override public void setTamed ( boolean tame ) { this . tameable .", "gt": "setTamed ( tame ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10316, "input": "<s> package fr . inria . zvtm . tests ; import java . awt . geom . Point2D ; import java . util . Arrays ; import java . util . Vector ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . engine . Location ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . event . RepaintListener ; public class RegressionTest extends TestCase { public RegressionTest ( String name ) { super ( name ) ; } public void setUp ( ) { vsm = VirtualSpaceManager . INSTANCE ; vs = vsm . addVirtualSpace ( \"testVS\" ) ; cam = vs . addCamera ( ) ; view = vsm . addFrameView ( new Vector ( Arrays . asList ( cam ) ) , \"RegressionTest\" , View . STD_VIEW , 300 , 200 , false ) ; } public void testCameraPosNeg ( ) { cam . moveTo ( - 100 , - 200 ) ; assertEquals ( - 100 , cam . getLocation ( ) . vx , 1. ) ; assertEquals ( - 200 , cam . getLocation ( )", "gt": ". vy , 1. ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1863, "input": "<s> class UnreportedExceptionImplicitClose { static class MyCloseable implements AutoCloseable { public void close ( ) throws Exception { } } void test ( ) { try ( MyCloseable", "gt": "x = new MyCloseable ( ) )", "prediction": ")\n", "label": 0}
{"id": 10318, "input": "<s> package agentStrategy . k ; import agents . K ; import java . util . Queue ; import risk . Territory ; import sim . util . Bag ; public class StrategySupport { public static Bag attackableTerritories ( K ruler ) { Bag empire = ruler . getEmpire ( ) ; Bag attackable = new Bag ( ) ; for ( Object o : empire ) { for ( Object t : attackableTerritories ( ( Territory ) o , true ) ) { if ( ! attackable . contains ( t ) ) { attackable . add ( t ) ; } } } return attackable ; } public static Bag attackableTerritories ( Territory attacker , boolean ignoreAttackerTerritories ) { Bag vt = new Bag ( ) ; int m = getEmpire ( attacker ) ; for ( Object i : attacker . getNeighbors ( ) ) { Territory t = ( Territory ) i ; if ( ignoreAttackerTerritories && t . getSuperior ( ) == attacker ) { continue ; } vt . add ( t ) ; } return vt ; } public static Bag getAllSubordinates ( Territory root , Bag existing ) { Bag unclaimedT = root . getSubordinates ( ) ; unclaimedT . removeAll ( existing ) ; for ( Object o : unclaimedT ) { existing . add ( o ) ; for ( Object i : getAllSubordinates ( ( Territory ) o , existing ) ) { if ( ! existing . contains ( i ) ) { existing . add ( i ) ; } } } return existing ; } public static Territory largestAttackableNeighbor ( Territory attacker ) { Bag attackable = attackableTerritories ( attacker , true ) ; if ( attackable . isEmpty ( ) ) { return null ; } int largestIndex = 0 ; int largest = getAllSubordinates ( ( Territory ) attackable . get ( 0 ) , new Bag ( ) ) . size ( ) ; for ( int i = 1 ; i < attackable . size ( ) ; i ++ ) { int t = getAllSubordinates ( ( Territory ) attackable . get ( i ) , new Bag ( ) ) . size ( ) ; if ( t > largest ) { largestIndex = i ; largest = t ; break ; } } return ( Territory ) attackable . get ( largestIndex ) ; } public static boolean isPartOfSameEmpire ( Territory t1 , Territory t2 ) { return getEmpire ( t1 ) == getEmpire ( t2 ) ; } public static boolean isPartOfSameEmpire ( int e , Territory t2 ) { return", "gt": "e == getEmpire ( t2 ) ;", "prediction": ";\n", "label": 1}
{"id": 4891, "input": "<s> public class AssignmentDifferentTypes9 { public static void main ( String [ ] args ) { Ref < Der > derexact = null ; Ref < Base > baseexact = null ; Ref < ? extends Der > derext = null ; Ref < ? extends Base > baseext = null ; Ref < ? super", "gt": "Der > dersuper = null ;", "prediction": ";\n", "label": 0}
{"id": 10319, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . parser ; public interface IStatusContainer { public void addStatus ( int severity ,", "gt": "String message , Throwable exception ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1554, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; public enum OutputStyle { SHORT { public String toString ( ) { return \"short\" ; } } , MEDIUM { public String toString ( ) { return \"medium\" ; } } , LONG {", "gt": "public String toString ( )", "prediction": "( ) ;\n", "label": 0}
{"id": 10326, "input": "<s> package org . eclipse . ui . tests . operations ; import org . eclipse . core . commands . operations . AbstractOperation ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; public class TestOperation extends AbstractOperation { private int fExecutionCount = 0 ; TestOperation ( String label ) { super ( label ) ; } public boolean canRedo ( ) {", "gt": "return fExecutionCount == 0 ;", "prediction": "\n", "label": 1}
{"id": 1580, "input": "<s> package org . ofbiz . webapp . event ; @ SuppressWarnings ( \"serial\" ) public class EventHandlerException extends org . ofbiz . base . util . GeneralException { public EventHandlerException ( String str , Throwable t ) { super ( str , t ) ; } public EventHandlerException ( Throwable t ) { super ( t ) ; } public EventHandlerException ( String str ) {", "gt": "super ( str ) ;", "prediction": "\n", "label": 0}
{"id": 10328, "input": "<s> package com . cloudera . sqoop . lib ; import java . io . * ; import com . cloudera . sqoop . testutil . BaseSqoopTestCase ; import com . cloudera . sqoop . testutil . CommonArgs ; import junit . framework . TestCase ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . cloudera . sqoop . io . LobFile ; public class TestClobRef extends TestCase { public void testEmptyStr ( ) { ClobRef r = ClobRef . parse ( \"\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"\" , r . toString ( ) ) ; } public void testInline ( ) throws IOException { ClobRef r = ClobRef . parse ( \"foo\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"foo\" , r . toString ( ) ) ; Reader reader = r . getDataStream ( null , null ) ; assertNotNull ( reader ) ; char [ ] buf = new char [ 4096 ] ; int chars = reader . read ( buf , 0 , 4096 ) ; reader . close ( ) ; String str = new String ( buf , 0 , chars ) ; assertEquals ( \"foo\" , str ) ; } public void testEmptyFile ( ) { ClobRef r = ClobRef . parse ( \"externalLob()\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"externalLob()\" , r . toString ( ) ) ; r = ClobRef . parse ( \"externalLob(lf,,0,0)\" ) ; assertTrue ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(lf,,0,0)\" , r . toString ( ) ) ; } public void testInlineNearMatch ( ) { ClobRef r = ClobRef . parse ( \"externalLob(foo)bar\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(foo)bar\" , r . toString ( ) ) ; r = ClobRef . parse ( \"externalLob(foo)\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(foo)\" , r . getData ( ) ) ; r = ClobRef . parse ( \"externalLob(lf,foo)\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(lf,foo)\" , r . getData ( ) ) ; r = ClobRef . parse ( \"externalLob(lf,foo,1,2)x\" ) ; assertFalse ( r . isExternal ( ) ) ; assertEquals ( \"externalLob(lf,foo,1,2)x\" , r . getData ( ) ) ; } public void testExternal ( ) throws IOException { final String DATA = \"This is the clob data!\" ; final String FILENAME = \"clobdata\" ; doExternalTest ( DATA , FILENAME ) ; } public void testExternalSubdir ( ) throws IOException { final String DATA = \"This is the clob data!\" ; final String FILENAME = \"_lob/clobdata\" ; try { doExternalTest ( DATA , FILENAME ) ; } finally { Configuration conf = new Configuration ( ) ; FileSystem fs = FileSystem . getLocal ( conf ) ; String tmpDir = System . getProperty ( \"test.build.data\" , \"/tmp/\" ) ; Path lobDir = new Path ( new Path ( tmpDir ) , \"_lob\" ) ; fs . delete ( lobDir , false ) ; } } private void doExternalTest ( final String data , final String filename ) throws IOException { Configuration conf = new Configuration ( ) ; if ( ! BaseSqoopTestCase . isOnPhysicalCluster ( ) ) { conf . set ( CommonArgs . FS_DEFAULT_NAME , CommonArgs . LOCAL_FS ) ; } FileSystem fs = FileSystem . get ( conf ) ; String tmpDir = System . getProperty ( \"test.build.data\" , \"/tmp/\" ) ; Path tmpPath = new Path ( tmpDir ) ; Path clobFile = new Path ( tmpPath , filename ) ; Path clobParent = clobFile . getParent ( ) ; if ( ! fs . exists ( clobParent ) ) { fs . mkdirs ( clobParent ) ; } LobFile . Writer lw = LobFile . create ( clobFile , conf , true ) ; try { long off = lw . tell ( ) ; long len = data . length ( ) ; Writer w = lw . writeClobRecord ( len ) ; w . append ( data ) ; w . close ( ) ; lw . close ( ) ; String refString = \"externalLob(lf,\" + filename + \",\" + off + \",\" + len + \")\" ; ClobRef clob = ClobRef . parse ( refString ) ; assertTrue (", "gt": "clob . isExternal ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 842, "input": "<s> package com . redhat . ceylon . ceylondoc ; import static com . redhat . ceylon . ceylondoc . Util . getDoc ; import static com . redhat . ceylon . ceylondoc . Util . getModifiers ; import java . io . IOException ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import com . redhat . ceylon . compiler . typechecker . model . Class ; import com . redhat . ceylon . compiler . typechecker . model . ClassOrInterface ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . Getter ; import com . redhat . ceylon . compiler . typechecker . model . Interface ; import com . redhat . ceylon . compiler . typechecker . model . Method ; import com . redhat . ceylon . compiler . typechecker . model . MethodOrValue ; import com . redhat . ceylon . compiler . typechecker . model . Package ; import com . redhat . ceylon . compiler . typechecker . model . Value ; public class PackageDoc extends ClassOrPackageDoc { private Package pkg ; private List < Class > classes ; private List < Interface > interfaces ; private List < MethodOrValue > attributes ; private List < Method > methods ; private List < Class > exceptions ; private final boolean sharingPageWithModule ; public PackageDoc ( CeylonDocTool tool , Writer writer , Package pkg ) throws IOException { super ( pkg . getModule ( ) , tool , writer ) ; this . sharingPageWithModule = tool . isRootPackage ( module , pkg ) ; this . pkg = pkg ; loadMembers ( ) ; } private void loadMembers ( ) { classes = new ArrayList < Class > ( ) ; interfaces = new ArrayList < Interface > ( ) ; attributes = new ArrayList < MethodOrValue > ( ) ; methods = new ArrayList < Method > ( ) ; exceptions = new ArrayList < Class > ( ) ; for ( Declaration m : pkg . getMembers ( ) ) { if ( ! shouldInclude ( m ) ) { continue ; } if ( m instanceof Interface ) { interfaces . add ( ( Interface ) m ) ; } else if ( m instanceof Class ) { Class c = ( Class ) m ; if ( Util . isException ( c ) ) { exceptions . add ( c ) ; } else { classes . add ( c ) ; } } else if ( m instanceof Value || m instanceof Getter ) { attributes . add ( ( MethodOrValue ) m ) ; } else if ( m instanceof Method ) { methods . add ( ( Method ) m ) ; } } Comparator < Declaration > comparator = new Comparator < Declaration > ( ) { @ Override public int compare ( Declaration a , Declaration b ) { return a . getName ( ) . compareTo ( b . getName ( ) ) ; } } ; Collections . sort ( classes , comparator ) ; Collections . sort ( interfaces , comparator ) ; Collections . sort ( attributes , comparator ) ; Collections . sort ( methods , comparator ) ; Collections . sort ( exceptions , comparator ) ; } public void generate ( ) throws IOException { if ( ! sharingPageWithModule ) { htmlHead ( ) ; writeNav ( module , pkg , DocType . PACKAGE ) ; } else { writeKeyboardShortcuts ( ) ; } subMenu ( ) ; summary ( ) ; attributes ( ) ; methods ( ) ; interfaces ( ) ; classes ( ) ; exceptions ( ) ; if ( ! sharingPageWithModule ) { close ( \"body\" ) ; close ( \"html\" ) ; } } private void htmlHead ( ) throws IOException { htmlHead ( \"Package \" + pkg . getName ( ) ) ; } private void summary ( ) throws IOException { open ( \"div class='head summary'\" ) ; String id = \"\" ; if ( tool . isRootPackage ( module , pkg ) ) { id = \" id='section-package'\" ; } open ( \"h1\" + id ) ; write ( \"Package \" ) ; around ( \"code\" , pkg . getNameAsString ( ) ) ; close ( \"h1\" ) ; writeSourceLink ( pkg ) ; close ( \"div\" ) ; around ( \"div class='doc'\" , getDoc ( pkg , linkRenderer ( ) ) ) ; writeBy ( Util . getAuthors ( pkg ) , false ) ; } protected void subMenu ( ) throws IOException { if ( attributes . isEmpty ( ) && methods . isEmpty ( ) && interfaces . isEmpty ( ) && classes . isEmpty ( ) && exceptions . isEmpty ( ) ) { return ; } open ( \"div class='submenu'\" ) ; if ( ! attributes . isEmpty ( ) ) { printSubMenuItem ( \"section-attributes\" , getAccessKeyed ( \"Attributes\" , 'A' , \"Jump to attributes\" ) ) ; } if ( ! methods . isEmpty ( ) ) { printSubMenuItem ( \"section-methods\" , getAccessKeyed ( \"Methods\" , 'M' , \"Jump to methods\" ) ) ; } if ( ! interfaces . isEmpty ( ) ) { printSubMenuItem ( \"section-interfaces\" , getAccessKeyed ( \"Interfaces\" , 'I' , \"Jump to interfaces\" ) ) ; } if ( ! classes . isEmpty ( ) ) { printSubMenuItem ( \"section-classes\" , getAccessKeyed ( \"Classes\" , 'C' , \"Jump to classes\" ) ) ; } if ( ! exceptions . isEmpty ( ) ) { printSubMenuItem ( \"section-exceptions\" , getAccessKeyed ( \"Exceptions\" , 'E' , \"Jump to exceptions\" ) ) ; } close ( \"div\" ) ; } private void methods ( ) throws IOException { if ( methods . isEmpty ( ) ) { return ; } openTable ( \"section-methods\" , \"Methods\" , \"Modifier and Type\" , \"Method and Description\" ) ; for ( Method m : methods ) { doc ( m ) ; } close ( \"table\" ) ; } private void attributes ( ) throws IOException { if ( attributes . isEmpty ( ) ) { return ; } openTable ( \"section-attributes\" , \"Attributes\" , \"Modifier and Type\" , \"Name and Description\" ) ; for ( MethodOrValue v : attributes ) { doc ( v ) ; } close ( \"table\" ) ; } private void interfaces ( ) throws IOException {", "gt": "if ( interfaces . isEmpty ( ) )", "prediction": "}\n", "label": 0}
{"id": 10338, "input": "<s> package org . powerbot . game . api . methods . input ; import java . awt . Canvas ; import java . awt . Component ; import java . awt . Point ; import java . awt . Rectangle ; import java . awt . event . MouseEvent ; import java . awt . event . MouseWheelEvent ; import java . util . HashMap ; import java . util . Map ; import org . powerbot . core . bot . Bot ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . Calculations ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . wrappers . ViewportEntity ; import org . powerbot . game . bot . Context ; import org . powerbot . game . bot . handler . input . MouseExecutor ; import org . powerbot . game . bot . handler . input . util . MouseNode ; import org . powerbot . game . client . Client ; public class Mouse { private static final Map < ThreadGroup , Integer > dragLengths = new HashMap < ThreadGroup , Integer > ( ) ; private static final Map < ThreadGroup , Integer > sides = new HashMap < ThreadGroup , Integer > ( ) ; public enum Speed { VERY_SLOW , SLOW , NORMAL , FAST , VERY_FAST } public static void setSpeed ( final Speed speed ) { Bot . setSpeed ( speed ) ; } public static int getX ( ) { final org . powerbot . game . client . input . Mouse mouse = getMouse ( ) ; return mouse == null ? - 1 : mouse . getX ( ) ; } public static int getY ( ) { final org . powerbot . game . client . input . Mouse mouse = getMouse ( ) ; return mouse == null ? - 1 : mouse . getY ( ) ; } public static Point getLocation ( ) { final org . powerbot . game . client . input . Mouse mouse = getMouse ( ) ; return mouse == null ? new Point ( - 1 , - 1 ) : new Point ( mouse . getX ( ) , mouse . getY ( ) ) ; } public static int getPressX ( ) { final org . powerbot . game . client", "gt": ". input . Mouse mouse = getMouse ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8646, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . matchervisitors . MatcherVisitor ; public class NothingMatcher extends AbstractMatcher { public NothingMatcher ( ) { super ( \"NOTHING\" ) ; } public boolean match ( MatcherContext context ) { return false ; } public < R > R accept ( MatcherVisitor < R > visitor ) { checkArgNotNull ( visitor , \"visitor\" ) ; return", "gt": "visitor . visit ( this ) ;", "prediction": ";\n", "label": 0}
{"id": 10345, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . * ; import org . eclipse . swt . internal . SWTEventListener ; public class TypedListener implements Listener { protected SWTEventListener eventListener ; public TypedListener ( SWTEventListener listener ) { eventListener = listener ; } public SWTEventListener getEventListener ( ) { return eventListener ; } public void handleEvent ( Event e ) { switch ( e . type ) { case SWT . Activate : { ( ( ShellListener ) eventListener ) . shellActivated ( new ShellEvent ( e ) ) ; break ; } case SWT . Arm : { ( ( ArmListener ) eventListener ) . widgetArmed ( new ArmEvent ( e ) ) ; break ; } case SWT . Close : { ShellEvent event = new ShellEvent ( e ) ; ( ( ShellListener ) eventListener ) . shellClosed ( event ) ; e . doit = event . doit ; break ; } case SWT . Collapse : { if ( eventListener instanceof TreeListener ) { ( ( TreeListener ) eventListener ) . treeCollapsed ( new TreeEvent ( e ) ) ; } else { ( ( ExpandListener ) eventListener ) . itemCollapsed ( new ExpandEvent ( e ) ) ; } break ; } case SWT . Deactivate : { ( ( ShellListener ) eventListener ) . shellDeactivated ( new ShellEvent ( e ) ) ; break ; } case SWT . DefaultSelection : { ( ( SelectionListener ) eventListener ) . widgetDefaultSelected ( new SelectionEvent ( e ) ) ; break ; } case SWT . Dispose : { ( ( DisposeListener ) eventListener ) . widgetDisposed ( new DisposeEvent ( e ) ) ; break ; } case SWT . DragDetect : { ( ( DragDetectListener ) eventListener ) . dragDetected ( new DragDetectEvent ( e ) ) ; break ; } case SWT . Expand : { if ( eventListener instanceof TreeListener ) { ( ( TreeListener ) eventListener ) . treeExpanded ( new TreeEvent ( e ) ) ; } else { ( ( ExpandListener ) eventListener ) . itemExpanded ( new ExpandEvent ( e ) ) ; } break ; } case SWT . FocusIn : { ( ( FocusListener ) eventListener ) . focusGained ( new FocusEvent ( e ) ) ; break ; } case SWT . FocusOut : { ( ( FocusListener ) eventListener ) . focusLost ( new FocusEvent ( e ) ) ; break ; } case SWT . Help : { ( ( HelpListener ) eventListener ) . helpRequested ( new HelpEvent ( e ) ) ; break ; } case SWT . Hide : { ( ( MenuListener ) eventListener ) . menuHidden ( new MenuEvent ( e ) ) ; break ; } case SWT . KeyDown : { KeyEvent event = new KeyEvent ( e ) ; ( ( KeyListener ) eventListener ) . keyPressed ( event ) ; e . doit = event . doit ; break ; } case SWT . KeyUp : { KeyEvent event = new KeyEvent ( e ) ; ( ( KeyListener ) eventListener ) . keyReleased ( event ) ; e . doit = event . doit ; break ; } case SWT . Modify : { ( ( ModifyListener ) eventListener ) . modifyText ( new ModifyEvent ( e ) ) ; break ; } case SWT . MenuDetect : { MenuDetectEvent event = new MenuDetectEvent ( e ) ; ( ( MenuDetectListener ) eventListener ) . menuDetected ( event ) ; e . x = event . x ; e . y = event . y ; e . doit = event . doit ; break ; } case SWT . MouseDown : { ( ( MouseListener ) eventListener ) . mouseDown ( new MouseEvent ( e ) ) ; break ; } case SWT . MouseDoubleClick : { ( ( MouseListener ) eventListener ) . mouseDoubleClick ( new MouseEvent ( e ) ) ; break ; } case SWT . MouseUp : { ( ( MouseListener ) eventListener ) . mouseUp ( new MouseEvent ( e ) ) ; break ; } case SWT . Move : { ( ( ControlListener ) eventListener ) . controlMoved ( new", "gt": "ControlEvent ( e ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3977, "input": "<s> package org . ofbiz . common . authentication ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Iterator ; import java . util . ServiceLoader ; import org . ofbiz . base . util . Debug ; import org . ofbiz . common . authentication . api . Authenticator ; import org . ofbiz . common . authentication . api . AuthenticatorException ; import org . ofbiz . service . LocalDispatcher ; public class AuthHelper { private static final String module = AuthHelper . class . getName ( ) ; protected static List < Authenticator > authenticators = new ArrayList < Authenticator > ( ) ; protected static boolean authenticatorsLoaded = false ; public static boolean authenticate ( String username , String password , boolean isServiceAuth ) throws AuthenticatorException { if ( ! authenticatorsLoaded ) throw new AuthenticatorException ( \"Authenticators never loaded; be sure to call AuthHelper.loadAuthenticators()\" ) ; for ( Authenticator auth : authenticators ) { boolean pass = auth . authenticate ( username , password , isServiceAuth ) ; if ( pass ) { return true ; } else if ( auth . isSingleAuthenticator ( ) ) { throw new AuthenticatorException ( ) ; } } return false ; } public static void logout ( String username ) throws AuthenticatorException { if ( ! authenticatorsLoaded ) throw new AuthenticatorException ( \"Authenticators never loaded; be sure to call AuthHelper.loadAuthenticators()\" ) ; for ( Authenticator auth : authenticators ) { auth . logout ( username ) ; } } public static void syncUser ( String username ) throws AuthenticatorException { if ( ! authenticatorsLoaded ) throw new AuthenticatorException ( \"Authenticators never loaded; be sure to call AuthHelper.loadAuthenticators()\" ) ; for ( Authenticator auth : authenticators ) { if ( auth . isUserSynchronized ( ) ) { auth . syncUser ( username ) ; } } } public static void updatePassword ( String username , String password , String newPassword ) throws AuthenticatorException { if ( ! authenticatorsLoaded ) throw new AuthenticatorException ( \"Authenticators never loaded; be", "gt": "sure to call AuthHelper.loadAuthenticators()\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10346, "input": "<s> package com . cloudera . sqoop . orm ; import com . cloudera . sqoop . SqoopOptions ; public class TableClassName extends org . apache . sqoop . orm . TableClassName { public", "gt": "TableClassName ( final SqoopOptions opts )", "prediction": ";\n", "label": 1}
{"id": 10047, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends", "gt": "Runnable , S extends String > void disjointness ( )", "prediction": ")\n", "label": 0}
{"id": 10349, "input": "<s> package org . restlet . ext . jaxrs . internal . provider ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import javax . activation . DataSource ; import javax . mail . util . ByteArrayDataSource ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import org . restlet . engine . io . BioUtils ; @ Provider public class DataSourceProvider extends AbstractProvider < DataSource > { @ Override public long getSize ( DataSource t , Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { return - 1 ; } @ Override public DataSource readFrom ( Class < DataSource > type , Type genericType , Annotation [ ] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException { return new ByteArrayDataSource ( entityStream , mediaType . toString ( ) ) ; } @ Override protected Class < ? > supportedClass ( ) { return DataSource . class ; } @ Override public void writeTo ( DataSource dataSource , Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType , MultivaluedMap < String , Object > httpHeaders , OutputStream entityStream ) throws IOException { final InputStream inputStream = dataSource . getInputStream ( ) ; BioUtils .", "gt": "copy ( inputStream , entityStream ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 2871, "input": "<s> package javax . lang . model . element ; import java . util . List ; import javax . lang . model . type . * ; public interface AnnotationValue {", "gt": "Object getValue ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10351, "input": "<s> package org . eclipse . ui . views . properties ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . ICellEditorValidator ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . widgets . Composite ; public class PropertyDescriptor implements IPropertyDescriptor { private Object id ; private String display ; private String category = null ; private String description = null ; private Object helpIds ; private String [ ] filterFlags ; private ILabelProvider labelProvider = null ; private ICellEditorValidator validator ; private boolean incompatible = false ; public PropertyDescriptor ( Object id , String displayName ) { Assert . isNotNull ( id ) ; Assert . isNotNull ( displayName ) ; this . id = id ; this . display = displayName ; } public CellEditor createPropertyEditor ( Composite parent ) { return null ; } protected boolean getAlwaysIncompatible ( ) { return incompatible ; } public String getCategory ( ) { return category ; } public String getDescription ( ) { return description ; } public String getDisplayName ( ) { return display ; } public String [ ] getFilterFlags ( ) { return filterFlags ; } public Object getHelpContextIds ( ) { return helpIds ; } public Object getId ( ) { return id ; } public ILabelProvider getLabelProvider ( ) { if ( labelProvider != null ) { return labelProvider ; } return new LabelProvider ( ) ; } protected ICellEditorValidator getValidator ( ) { return validator ; } public boolean isLabelProviderSet ( ) { return labelProvider != null ; } public boolean isCompatibleWith ( IPropertyDescriptor anotherProperty ) { if ( getAlwaysIncompatible ( ) ) { return false ; } Object id1 = getId ( ) ; Object id2 = anotherProperty . getId ( ) ; if", "gt": "( ! id1 . equals ( id2 ) )", "prediction": "( ) ;\n", "label": 1}
{"id": 5840, "input": "<s> package com . sap . prd . mobile . ios . mios ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . io . File ; import java . io . FileInputStream ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import junit . framework . Assert ; import org . apache . maven . it . VerificationException ; import org . apache . maven . it . Verifier ; import org . apache . maven . it . util . FileUtils ; import org . apache . maven . it . util . IOUtil ; import org . junit . Test ; public class XCodeVersionInfoSpecialTest extends XCodeTest { @ Test public void testVersionInfoWithoutDependentInformation ( ) throws Exception { final String testName = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getMethodName ( ) ; final File remoteRepositoryDirectory = getRemoteRepositoryDirectory ( getClass ( ) . getName ( ) ) ; prepareRemoteRepository ( remoteRepositoryDirectory ) ; Verifier verifier = test ( testName , new File ( getTestRootDirectory ( ) , \"versions-info/MyLibrary\" ) , \"pom.xml\" , \"deploy\" , THE_EMPTY_LIST , THE_EMPTY_MAP , remoteRepositoryDirectory ) ; File libraryVersionsInfo = new File ( remoteRepositoryDirectory , Constants . GROUP_ID_WITH_SLASH + \"/MyLibrary/\" + \"1.0.100\" + \"/MyLibrary-\" + \"1.0.100\" + \"-versions.xml\" ) ; libraryVersionsInfo . delete ( ) ; verifier . deleteArtifacts ( Constants . GROUP_ID_WITH_SLASH ) ; assertTrue ( ! libraryVersionsInfo . exists ( ) ) ; test ( testName , new File ( getTestRootDirectory ( ) , \"versions-info/MyApp\" ) , \"pom.xml\" , \"deploy\" , THE_EMPTY_LIST , THE_EMPTY_MAP , remoteRepositoryDirectory ) ; File versionFileAppExpected = new File ( \"src/test/resources/MyApp-1.0.0-without-dependent-info-versions.xml\" ) . getAbsoluteFile ( ) ; File versionFileApp = new File ( remoteRepositoryDirectory , Constants . GROUP_ID_WITH_SLASH + \"/MyApp/\" + Constants . APP_VERSION + \"/MyApp-\" + Constants . APP_VERSION + \"-versions.xml\" ) ; assertTrue ( versionFileApp . exists ( ) ) ; final InputStream actualVersionFileApp = new FileInputStream ( versionFileApp ) , expectedVersionFileApp = new FileInputStream ( versionFileAppExpected ) ; try { Assert . assertEquals ( IOUtil . toString ( expectedVersionFileApp , \"UTF-8\" ) , IOUtil . toString ( actualVersionFileApp , \"UTF-8\" ) ) ; } finally { IOUtil . close ( actualVersionFileApp ) ; IOUtil .", "gt": "close ( expectedVersionFileApp ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10362, "input": "<s> package org . modelgoon . core . ui ; import java . util . List ; import org . eclipse . core . resources . IResource ; import org . eclipse . draw2d", "gt": ". geometry . Point ;", "prediction": ";\n", "label": 1}
{"id": 9324, "input": "<s> package varargs . warn1 ; class T { static void f ( String fmt , Object ... args ) { } public static void main", "gt": "( String [ ] args )", "prediction": "( )\n", "label": 0}
{"id": 10378, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; public class GridLayoutTab extends ExampleTab { private boolean propPrefSize ; private boolean propEqualWidth ; public GridLayoutTab ( ) { super ( \"GridLayout\" ) ; } @ Override protected void createStyleControls ( final Composite parent ) { final Button prefSizeButton = createPropertyButton ( \"Preferred Size\" ) ; prefSizeButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { propPrefSize = prefSizeButton . getSelection ( ) ; createNew ( ) ; } } ) ; final Button equalButton = createPropertyButton ( \"Make Columns Equal Width\" ) ; equalButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { propEqualWidth = equalButton . getSelection ( ) ; createNew ( ) ; } } ) ; } @ Override protected void createExampleControls ( final Composite parent ) { GridLayout parentLayout = new GridLayout ( ) ; parentLayout . marginWidth = 5 ; parent . setLayout ( parentLayout ) ; Composite comp = new Composite ( parent , SWT . NONE ) ; comp . setBackground ( Graphics . getColor ( 0xcc , 0xb7 , 0x91 ) ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . numColumns = 3 ; gridLayout . marginWidth = 3 ; gridLayout . marginHeight = 3 ; gridLayout . makeColumnsEqualWidth = propEqualWidth ; comp . setLayout ( gridLayout ) ; Button button1 = new Button ( comp , SWT . PUSH ) ; button1 . setText ( \"B1\" ) ; GridData gridData = new GridData ( ) ; gridData . verticalAlignment = GridData . FILL ; button1 . setLayoutData ( gridData ) ; new Button ( comp , SWT . PUSH ) . setText ( \"Wide Button 2\" ) ; Button button3 = new Button ( comp , SWT . PUSH ) ; button3 . setText ( \"Button 3\" ) ; gridData = new GridData ( ) ; gridData .", "gt": "verticalAlignment = GridData . FILL ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 1598, "input": "<s> package org . msl . simple . gmfmap . model . triggers . parent ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . gmfgraph . Connection ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . GMFGraphFactory ; import org . eclipse . gmf . mappings . GMFMapFactory ; import org . eclipse . gmf . mappings . LabelMapping ; import org . eclipse . gmf . mappings . LinkMapping ; import org . eclipse . gmf . tooldef . CreationTool ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; class NewLinkMappingTrigger extends NewElementTrigger { protected SimpleLinkMapping newSimpleLinkMapping ; protected SimpleParentNode parent ; public NewLinkMappingTrigger ( TransactionalEditingDomain domain , SimpleParentNode parent , SimpleLinkMapping newSimpleLinkMapping ) { super ( domain , newSimpleLinkMapping ) ; this . newSimpleLinkMapping = newSimpleLinkMapping ; this . parent = parent ; } @ Override public void executeTrigger ( ) { Connection newConnection = GMFGraphFactory . eINSTANCE . createConnection ( ) ; DiagramLabel newLabel = GMFGraphFactory . eINSTANCE . createDiagramLabel ( ) ; updateCanvas ( newConnection , newLabel ) ; CreationTool newCreationTool = createNewTool ( ) ; updateMapping ( ( SimpleMapping ) parent , newConnection , newLabel , newCreationTool ) ; } protected void updateCanvas ( Connection newConnection , DiagramLabel newLabel ) { canvasFactory . createNewDefaultPolygon ( newConnection , newLabel ) ; } protected void updateMapping ( SimpleMapping mapping , Connection newConnection , DiagramLabel newLabel , CreationTool newCreationTool ) { LinkMapping newLinkMapping = createNewLinkMapping ( newConnection , newLabel , newCreationTool ) ; mapping . getMapping ( ) . getLinks ( ) . add ( newLinkMapping ) ; newSimpleLinkMapping . setLinkMapping ( newLinkMapping ) ; } protected LinkMapping createNewLinkMapping ( Connection newConnection , DiagramLabel newLabel , CreationTool newCreationTool ) { LinkMapping newLinkMapping = GMFMapFactory . eINSTANCE . createLinkMapping ( ) ; newLinkMapping . setDiagramLink ( newConnection ) ; newLinkMapping . setTool ( newCreationTool ) ; LabelMapping labelMapping", "gt": "= GMFMapFactory . eINSTANCE . createLabelMapping ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10386, "input": "<s> package risk ; import agents . * ; import sim . engine . * ; import sim . display . * ; import sim . portrayal . grid . * ; import java . awt . * ; import java . text . DecimalFormat ; import javax . swing . * ; import org . jfree . chart . ChartFactory ; import org . jfree . chart . ChartFrame ; import org . jfree . chart . JFreeChart ; import org . jfree . chart . axis . CategoryAxis ; import org . jfree . chart . axis . CategoryLabelPositions ; import org . jfree . chart . axis . DateAxis ; import org . jfree . chart . axis . NumberAxis ; import org . jfree . chart . labels . StandardXYToolTipGenerator ; import org . jfree . chart . plot . CategoryPlot ; import org . jfree . chart . plot . PlotOrientation ; import org . jfree . chart . plot . XYPlot ; import org . jfree . chart . renderer . category . BarRenderer ; import org . jfree . chart . renderer . category . CategoryItemRenderer ; import org . jfree . chart . renderer . xy . XYItemRenderer ; import org . jfree . data . category . CategoryDataset ; import org . jfree . data . category . DefaultCategoryDataset ; import org . jfree . data . general . DatasetUtilities ; import org . jfree . data . time . Day ; import org . jfree . data . time . TimeSeries ; import org . jfree . data . time . TimeSeriesCollection ; import org . jfree . data . xy . XYDataset ; public class ImperialWithUI extends GUIState { private Display2D display ; private JFrame displayFrame ; private HierarchiesGraph graph = new HierarchiesGraph ( ( Imperial ) state ) ; DefaultCategoryDataset territoriesBars ; DefaultCategoryDataset influenceBars ; DefaultCategoryDataset wealthBars ; XYDataset timeSeriesData ; private JFreeChart territoriesChart ; private JFreeChart influenceChart ; private JFreeChart peopleChart ; private JFreeChart timeSeriesChart ; private JFrame frameForTerritories ; private JFrame frameForInfluences ; private JFrame frameForPeople ; private JFrame graphFrame ; private JFrame frameForTimeSeries ; Day period ; TimeSeries E0 ; TimeSeries E1 ; TimeSeries E2 ; TimeSeries E3 ; TimeSeries E4 ; TimeSeries E5 ; TimeSeries E6 ; TimeSeries E7 ; TimeSeries E8 ; TimeSeries E9 ; private Color [ ] colorsMap = new Color [ ] { Color . white , Color . black , Color . red , Color . blue , Color . yellow , Color . pink , Color . green , Color . orange } ; private Color [ ] colorsBars = new Color [ ] { Color . black , Color . red , Color . blue , Color . yellow , Color . pink , Color . green , Color . orange } ; private DataWriter dataWriter ; private CategoryDataset createDataset ( String label ) { String name0 = ( new Rice ( 2 , 2 ) ) . getName ( ) ; String name1 = ( new chameleon ( 2 , 2 ) ) . getName ( ) ; String name2 = ( new Surprise2 ( 2 , 2 ) ) . getName ( ) ; String name3 = ( new K ( 2", "gt": ", 2 ) ) . getName ( ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 3113, "input": "<s> interface I1 { Number m ( ) ; } interface I2 { String m ( ) ; } public class T4856983a { < T extends", "gt": "I1 & I2 > T f ( )", "prediction": "\n", "label": 0}
{"id": 10396, "input": "<s> package org . restlet . service ; import java . util . logging . LogManager ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . log . LogFilter ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . restlet . routing . Filter ; import org . restlet . routing . Template ; public class LogService extends Service { private volatile boolean debugging ; private volatile boolean identityCheck ; private volatile Template loggableTemplate ; private volatile String loggerName ; private volatile Reference logPropertiesRef ; private volatile String responseLogFormat ; protected volatile Template responseLogTemplate ; public LogService ( ) { this ( true ) ; } public LogService ( boolean enabled ) { super ( enabled ) ; this . loggableTemplate = null ; this . loggerName = null ; this . responseLogFormat = null ; this . logPropertiesRef = null ; this . identityCheck = false ; } @ Override public Filter createInboundFilter ( Context context ) { return new LogFilter ( context , this ) ; } protected String getDefaultResponseLogMessage ( Response response , int duration ) { StringBuilder sb = new StringBuilder ( ) ; Request request = response . getRequest ( ) ; if ( isDebugging ( ) ) { } else { long currentTime = System . currentTimeMillis ( ) ; sb . append ( String . format ( \"%tF\" , currentTime ) ) ; sb . append ( '\\t' ) ; sb . append ( String . format ( \"%tT\" , currentTime ) ) ; sb . append ( '\\t' ) ; String clientAddress = request . getClientInfo ( ) . getUpstreamAddress ( ) ; sb . append ( ( clientAddress == null ) ? \"-\" : clientAddress ) ; sb . append ( '\\t' ) ; if ( isIdentityCheck ( ) ) { org . restlet . engine . log . IdentClient ic = new org . restlet . engine . log . IdentClient ( request . getClientInfo ( ) . getUpstreamAddress ( ) , request . getClientInfo ( ) . getPort ( ) , response . getServerInfo ( ) . getPort ( ) ) ; sb . append ( ( ic . getUserIdentifier ( ) == null ) ? \"-\" : ic", "gt": ". getUserIdentifier ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 820, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . Arrays ; import java . util . List ; import org . gk . ui . client . com . grid . gkGridIC ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . store . Store ; import com . extjs . gxt . ui . client . store . StoreFilter ; import com . extjs . gxt . ui . client . store . TreeStore ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . treepanel . TreePanel ; public class FilterAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof gkXMLTreePanelIC ) { gkXMLTreePanelIC tree = ( gkXMLTreePanelIC ) com ; if ( value == null ) { tree . getTree ( ) . setExpandOnFilter ( false ) ; TreeStore store = tree . getTree ( ) . getStore ( ) ; clearFilters ( store ) ; statefulExpand ( tree . getTree ( ) ) ; } else if ( value instanceof String ) { tree . getTree ( ) . setExpandOnFilter ( false ) ; TreeStore store = tree . getTree ( ) . getStore ( ) ; clearFilters ( store ) ; final List str = Arrays . asList ( ( ( String ) value ) . split ( \",\" ) ) ; StoreFilter filter = new StoreFilter ( ) { @ Override public boolean select ( Store store , ModelData parent , ModelData item , String property ) { String id = item . get ( property ) ; String [ ] strId = id . split ( \"_\" ) ; for ( int i = 0 ; i < strId . length ; i ++ ) { if ( str . contains ( strId [ i ] ) ) return false ; } return true ; } } ; store . addFilter ( filter ) ; store . filter ( gkXMLTreePanelIC . ID ) ; statefulExpand ( tree . getTree ( ) ) ; } } else if ( com instanceof gkGridIC ) { gkGridIC grid = ( gkGridIC ) com ; grid . filter ( value . toString ( ) ) ; } } public void clearFilters ( TreeStore store ) {", "gt": "List filters = store . getFilters ( ) ;", "prediction": "\n", "label": 0}
{"id": 10399, "input": "<s> package litil . cg . samples ; import org . objectweb . asm . * ; public class Sample3Dump implements Opcodes { public static byte [ ] dump ( ) throws Exception { ClassWriter cw = new ClassWriter ( 0 ) ; FieldVisitor fv ; MethodVisitor mv ; AnnotationVisitor av0 ; cw . visit ( V1_6 , ACC_PUBLIC + ACC_SUPER , \"litil/cg/samples/Sample3\" , null , \"java/lang/Object\" , null ) ; cw . visitSource ( \"Sample3.java\" , null ) ; { mv = cw . visitMethod ( ACC_PUBLIC , \"<init>\" , \"()V\" , null , null ) ; mv . visitCode ( ) ; Label l0 = new Label ( ) ; mv . visitLabel ( l0 ) ; mv . visitLineNumber ( 3 , l0 ) ; mv . visitVarInsn ( ALOAD , 0 ) ; mv . visitMethodInsn ( INVOKESPECIAL , \"java/lang/Object\" , \"<init>\" , \"()V\" ) ; mv . visitInsn ( RETURN ) ; Label l1 = new Label ( ) ; mv . visitLabel ( l1 ) ; mv . visitLocalVariable ( \"this\" , \"Llitil/cg/samples/Sample3;\" , null , l0 , l1 , 0 ) ; mv . visitMaxs ( 1 , 1 ) ; mv . visitEnd ( ) ; } { mv = cw . visitMethod ( ACC_PUBLIC , \"gcd\" , \"(II)I\" , null , null ) ; mv . visitCode ( ) ; Label l0 = new Label ( ) ; mv . visitLabel ( l0 ) ; mv . visitLineNumber ( 5 , l0 ) ; mv . visitVarInsn ( ILOAD , 2 ) ; Label l1 = new Label ( ) ; mv . visitJumpInsn ( IFNE , l1 ) ; Label l2 = new Label ( ) ; mv . visitLabel ( l2 ) ; mv", "gt": ". visitLineNumber ( 6 , l2 ) ;", "prediction": ";\n", "label": 1}
{"id": 3981, "input": "<s> package de . javawi . jstun . test . demo ; import java . util . logging . FileHandler ; import java . util . logging . Handler ; import java . util . logging . Level ; import java . util . logging . SimpleFormatter ; import de . javawi . jstun . test . BindingLifetimeTest ; public class BindingLifetimeTestDemo { public static void main ( String args [ ] ) { try { Handler fh = new FileHandler ( \"logging.txt\" ) ; fh . setFormatter ( new SimpleFormatter ( ) ) ; java . util . logging . Logger . getLogger ( \"de.javawi.stun\" ) . addHandler ( fh ) ; java . util . logging . Logger . getLogger ( \"de.javawi.stun\" ) . setLevel ( Level . ALL ) ; BindingLifetimeTest test = new BindingLifetimeTest ( \"jstun.javawi.de\" , 3478 ) ; test . test ( ) ; boolean continueWhile = true ; while ( continueWhile ) { Thread . sleep ( 5000 ) ; if ( test . getLifetime ( ) != - 1 ) { System . out . println ( \"Lifetime: \" + test . getLifetime ( ) + \" Finished: \" + test . isCompleted ( ) ) ; if ( test", "gt": ". isCompleted ( ) ) continueWhile = false ;", "prediction": ") ;\n", "label": 0}
{"id": 10423, "input": "<s> package com . poetry . install ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import com . poetry . dao . BinaryDao ; import com . poetry . dao . PoetDao ; import com . poetry . model . Binary ; import com . poetry . model . Poet ; @ Component public class InstallPoet extends AbstractInstall implements Install < Poet > { @ Autowired protected BinaryDao binaryDao ; @ Autowired protected PoetDao userDao ; public Map < String , Poet > install ( ) throws IOException { final HashMap < String , Poet > ret = new HashMap < String , Poet > ( ) ; final Poet [ ] poets = new Poet [ ] { new Poet ( \"bylee\" , \"Bon-Yong Lee\" , \"bylee\" , \"ROLE_ADMIN,ROLE_USER\" ) , new Poet ( \"anjong\" , \"Jong-Hyun Kwon\" , \"anjong\" ) , new Poet ( \"csoonoosc\" , \"Choong-Soon Park\" , \"csoonoosc\" ) , new Poet ( \"hellojintae\" , \"Jin-Tae Jung\" , \"hellojintae\" ) , new Poet ( \"hanseoung82\" , \"Han-Seoung Sung\" , \"hanseoung82\" ) } ; for ( final Poet poet : poets ) { String name = poet . getUsername ( ) + \".jpg\" ; byte [ ]", "gt": "icon = load ( name ) ;", "prediction": ";\n", "label": 1}
{"id": 626, "input": "<s> package ar . com . fdvs . dj . output ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import javax . servlet . http . HttpServletResponse ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRExporter ; import net . sf . jasperreports . engine . JRExporterParameter ; import net . sf . jasperreports . engine . JasperPrint ; public abstract class ReportWriter { public JRExporter getExporter ( ) { return exporter ; } private static final int BUFFER_SIZE = 10 * 1024 ; protected JasperPrint jasperPrint ; protected JRExporter exporter ; protected ReportWriter ( final JasperPrint _jasperPrint , final JRExporter _exporter ) { jasperPrint = _jasperPrint ; exporter = _exporter ; exporter . setParameter (", "gt": "JRExporterParameter . JASPER_PRINT , jasperPrint ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10439, "input": "<s> package org . eclipse . ui . part ; import java . util . Stack ; class DrillStack { Stack fStack = null ; public DrillStack ( ) { reset ( ) ; } public DrillFrame add ( DrillFrame oRecord ) { fStack . push ( oRecord ) ; return oRecord ; } public boolean canGoBack ( ) { return ( fStack . size ( ) > 0 ) ; } public boolean canGoHome ( ) { return ( fStack . size ( ) > 0 ) ; } public DrillFrame goBack ( ) { DrillFrame aFrame = ( DrillFrame ) fStack . pop ( ) ; return aFrame ; } public DrillFrame goHome ( ) { DrillFrame aFrame = ( DrillFrame ) fStack . elementAt ( 0 ) ; reset ( ) ; return aFrame ; } public void reset ( ) { fStack", "gt": "= new Stack ( ) ;", "prediction": ";\n", "label": 1}
{"id": 6715, "input": "<s> package org . ofbiz . webapp . taglib ; import javax . servlet . jsp . tagext . TagData ; import javax . servlet . jsp . tagext . TagExtraInfo ; import javax . servlet . jsp . tagext . VariableInfo ; public class IterateNextTEI extends TagExtraInfo { public IterateNextTEI ( ) { super ( ) ; } @ Override public VariableInfo [ ] getVariableInfo ( TagData data ) { String name = null ; String className = null ; name = data . getAttributeString ( \"name\" ) ; if ( name == null ) name = \"next\" ; className = data . getAttributeString ( \"type\" ) ; if ( className == null", "gt": ") className = \"org.ofbiz.entity.GenericValue\" ;", "prediction": ")\n", "label": 0}
{"id": 10449, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec2 . sub7 ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; public class MailClient { public static void main ( String [ ] args ) throws Exception { ClientResource mailClient", "gt": "= new ClientResource ( \"http://localhost:8111/accounts/chunkylover53/mails/123\" ) ;", "prediction": ";\n", "label": 1}
{"id": 2528, "input": "<s> package Liza ; import org . bukkit . entity . Tameable ;", "gt": "public interface LizaTameable extends Tameable", "prediction": "}\n", "label": 0}
{"id": 10457, "input": "<s> package org . restlet . ext . jaxrs ; public interface ObjectFactory { public < T > T getInstance", "gt": "( Class < T > jaxRsClass ) throws InstantiateException ;", "prediction": "( )\n", "label": 1}
{"id": 7986, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . Extend ; import org . jjflyboy . tjpeditor . project . ExtendTask ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ExtendTaskImpl extends ProjectAttributeImpl implements ExtendTask { protected EList < Extend > extends_ ; protected ExtendTaskImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getExtendTask ( ) ; } public EList < Extend > getExtends ( ) { if ( extends_ == null ) { extends_ = new EObjectContainmentEList < Extend > ( Extend . class , this , ProjectPackage . EXTEND_TASK__EXTENDS ) ; } return extends_ ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . EXTEND_TASK__EXTENDS : return ( ( InternalEList < ? > ) getExtends ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . EXTEND_TASK__EXTENDS : return getExtends ( ) ; } return super", "gt": ". eGet ( featureID , resolve , coreType ) ;", "prediction": ";\n", "label": 0}
{"id": 10478, "input": "<s> package org . eclipse . ui . tests . api ; import junit . framework . TestCase ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . PlatformUI ; public class PlatformUITest extends TestCase { public PlatformUITest ( String testName ) { super ( testName ) ; } public void", "gt": "testGetWorkbench ( ) throws Throwable", "prediction": "( )\n", "label": 1}
{"id": 4595, "input": "<s> package com . shopzilla . api . client ; import com . shopzilla . api . client . helper . CredentialFactory ; import com . shopzilla . services . catalog . ProductResponse ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import static junit . framework . Assert . assertEquals ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { \"classpath:spring/applicationContext-client-test.xml\" } ) public class ProductClientIntegrationTest { @ Autowired ProductClient client ; @ Autowired CredentialFactory credentialFactory ; private static String apiKey ; private static String publisherId ; private static final String keyword = \"nike+men%27s+shoes\" ; private static final Integer TEN_RESULTS = 10 ; private static final Integer ONE_HUNDRED_RESULTS = 100 ; ProductResponse productResponse ; @ Before public void setUp ( ) { apiKey = credentialFactory . getPublisherApiKey ( ) ; publisherId = credentialFactory . getPublisherId ( ) ; } @ Test public void testClientSuccessfullyParsedTenProducts ( ) { productResponse = client . doProductSearch ( apiKey , publisherId , keyword , TEN_RESULTS ) ; assertEquals ( TEN_RESULTS , ( Integer ) productResponse . getProducts ( ) . getProductOrOffer ( ) . size ( ) ) ; } @ Test public void testClientSuccessfullyParsedOneHundredProducts ( ) { productResponse = client . doProductSearch ( apiKey , publisherId , keyword , ONE_HUNDRED_RESULTS ) ; assertEquals ( true , ( Integer ) productResponse . getProducts ( ) . getProductOrOffer (", "gt": ") . size ( ) > TEN_RESULTS ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10480, "input": "<s> package tk . blackwolf12333 . grieflog . data . block ; import org . bukkit . Bukkit ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import tk . blackwolf12333 . grieflog . PlayerSession ; import tk . blackwolf12333 . grieflog . utils . Events ; public class BlockIgniteData extends BaseBlockData { String cause ; public BlockIgniteData ( Block block , String cause , String playerName , Integer gamemode ) { putBlock ( block ) ; this . cause = cause ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . IGNITE ; } public BlockIgniteData ( Integer blockX , Integer blockY , Integer blockZ , String blockType , byte blockData , String world , String cause , String playerName , Integer gamemode ) { this . blockX = blockX ; this . blockY = blockY ; this . blockZ = blockZ ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . cause = cause ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . IGNITE ; xyz = blockX + \", \" + blockY + \", \" + blockZ ; } public BlockIgniteData ( String time , Integer blockX , Integer blockY , Integer blockZ , String blockType , byte blockData , String world , String cause , String playerName , Integer gamemode ) { this . time = time ; this . blockX = blockX ; this . blockY = blockY ; this . blockZ = blockZ ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . cause = cause ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . IGNITE ; xyz = blockX + \", \" + blockY + \", \" + blockZ ; } public String getCause ( ) { return cause ; } public void setCause ( String cause ) { this . cause = cause ; } @ Override public void rollback ( ) { World w = Bukkit . getWorld ( worldName ) ; Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; w . getBlockAt ( loc ) . setTypeIdAndData ( Material . getMaterial ( blockType ) . getId ( ) , blockData , true ) ; } @ Override public String getMinimal ( ) { return time + \" \" + playerName + \" ignited \" + blockType . toLowerCase ( ) + \".\" ; } @ Override public boolean isInWorldEditSelectionOf ( PlayerSession player ) { Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; return player . getWorldEditSelection ( ) . contains ( loc ) ; } @ Override public String toString ( ) { if ( time != null ) { return time + \" \" + event + \" By: \" + playerName + \" GM: \" + gamemode + \" What: \" + blockType + \":\" + blockData + \" How: \" + cause + \" Where: \" + blockX + \", \" + blockY + \", \" + blockZ + \" In: \" + worldName", "gt": "+ System . getProperty ( \"line.separator\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6058, "input": "<s> package uk . ac . cam . cl . dtg . android . time . data ; import java . net . URL ; import java . util . List ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import uk . ac . cam . cl . dtg . android . time . buses . BusArrivalData ; import uk . ac . cam . cl . dtg . android . time . buses . BusStop ; import uk . ac . cam . cl . dtg . android . time . buses . StopGroup ; import uk . ac . cam . cl . dtg . android . time . data . handlers . ArrivalsSAXHandler ; import uk . ac . cam . cl . dtg . android . time . data . handlers . GetStopsSAXHandler ; import uk . ac . cam . cl . dtg . android . time . data . handlers . SAXDataHandler ; import uk . ac . cam . cl . dtg . android . time . data . handlers . StopGroupsSAXHandler ; import uk . ac . cam . cl . dtg . android . time . data . handlers . StopSAXHandler ; import uk . ac . cam . cl . dtg . android . time . data . handlers . StopsSAXHandler ; public class TransportDataProvider { private String feedURL ; private String apiKey ; public TransportDataProvider ( String apiKey , String feedURL ) { this . feedURL = feedURL ; this . apiKey = apiKey ; } public List < BusStop > getBusStops ( int level ) throws TransportDataException { return makeRequest ( \"GetStops\" , \"&level=\" + level , new GetStopsSAXHandler ( ) ) ; } public List < StopGroup > getStopGroupsNear ( double latitude , double longitude ) throws TransportDataException { return makeRequest ( \"FindStopGroups\" , \"&method=near\" + \"&lat=\" + latitude", "gt": "+ \"&long=\" + longitude , new StopGroupsSAXHandler ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10486, "input": "<s> package br . org . archimedes . fillet ; import static org . mockito . Mockito . when ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . util . Collections ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . controller . commands . PutOrRemoveElementCommand ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; public class FilletCommandTest extends Tester { private Drawing drawing ; private Line line1 ; private Line line2 ; private FilletCommand command ; private MockFilleter mockFilleter ; private Point click1 ; private Point click2 ; @ Before public void setUp ( ) throws Exception { line1 = new Line ( 0.0 , 1.0 , 0.0 , 2.0 ) ; line2 = new Line ( 1.0 , 0.0 , 2.0 , 0.0 ) ; drawing = new Drawing ( \"Test\" ) ; drawing . putElement ( line1 , drawing . getCurrentLayer ( ) ) ; drawing . putElement ( line2 , drawing . getCurrentLayer ( ) ) ; click1 = new Point ( 0.0 , 1.5 ) ; click2 = new Point ( 1.5 , 0.0 ) ; command = new FilletCommand ( line1 , click1 , line2 , click2 , 0 ) ; mockFilleter = new MockFilleter ( ) ; command . setFilleter ( mockFilleter ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentExceptionIfFirstPointIsNull ( ) throws Exception { new FilletCommand ( line1 , null , line2 , new Point ( 0 , 0 ) , 0 ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentExceptionIfSecondPointIsNull ( ) throws Exception { new FilletCommand ( line1 , new Point ( 0 , 0 ) , line2 , null , 0 ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentExceptionIfFirstElementIsNull ( ) throws Exception { new FilletCommand ( null , new Point ( 0 , 0 ) , line2 , new Point ( 0 , 0 ) , 0 ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentExceptionIfSecondElementIsNull ( ) throws Exception { new FilletCommand ( line1 , new Point ( 0 , 0 ) , null , new Point ( 0 , 0 ) , 0 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void throwsInvalidArgumentExceptionIfFirstPointIsNotInsideFirstElement ( ) throws Exception { new FilletCommand ( line1 , new Point ( 0 , 0 ) , line2 , new Point ( 1 , 0 ) , 0 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void throwsInvalidArgumentExceptionIfSecondPointIsNotInsideSecondElement ( ) throws Exception { new FilletCommand ( line1 , new Point ( 0 , 1 ) , line2 , new Point ( 0 , 0 ) , 0 ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentOnDoItExceptionIfDrawingIsNull ( ) throws Exception { command . doIt ( null ) ; } @ Test ( expected = NullArgumentException . class ) public void throwsNullArgumentOnUndoItExceptionIfDrawingIsNull ( ) throws Exception { command . undoIt ( null ) ; } @ Test public void testDoIt ( ) throws Exception { assertTrue ( mockFilleter . calledFillet ( ) ) ; assertEquals ( line1 , mockFilleter . getReceivedE1 ( ) ) ; assertEquals ( line2 , mockFilleter . getReceivedE2 ( ) ) ; assertEquals ( click1 , mockFilleter . getReceivedClick1 ( ) ) ; assertEquals ( click2 , mockFilleter . getReceivedClick2 ( ) ) ; assertTrue ( mockFilleter . getGeneratedMacroCommand ( ) . calledDoIt ( ) ) ; } @ Test public void testUndoIt ( ) throws Exception { command . doIt ( drawing ) ; command . undoIt ( drawing ) ; assertTrue ( mockFilleter . calledFillet ( ) ) ; assertTrue ( mockFilleter . getGeneratedMacroCommand ( ) . calledDoIt ( ) ) ; assertTrue ( mockFilleter . getGeneratedMacroCommand (", "gt": ") . calledUndoIt ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2804, "input": "<s> package javax . lang . model . type ;", "gt": "public interface NullType extends ReferenceType", "prediction": "}\n", "label": 0}
{"id": 10495, "input": "<s> package scenes . CreationScene . GUI ; import graphics . Sprite ; import groups . Party ; import java . awt . Graphics ; import scenes . CreationScene . System . CreationSystem ; public class PartyDisplay extends Sprite { PlayerWindow [ ] windows ; CreationSystem parent ; public PartyDisplay ( CreationSystem p ) { super ( null ) ; parent = p ; Party party = parent . getParty ( ) ; windows = new PlayerWindow [ party . size ( ) ] ; for ( int i = 0 ; i < party . size ( ) ; i ++ ) windows [ i ] = new PlayerWindow ( party . get ( i ) , 25 + 120 * ( i % ( party . size ( ) / 2 ) ) , 25 + 108 * ( i / ( party . size ( ) / 2 ) ) ) ; } public void update ( ) { windows [ parent . getIndex ( ) ] . update ( parent . getParty ( ) . get (", "gt": "parent . getIndex ( ) ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 7545, "input": "<s> package org . ofbiz . product . product ; import java . io . IOException ; import java . sql . Timestamp ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . common . KeywordSearchUtil ; import org . ofbiz . content . data . DataResourceWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; public class KeywordIndex { public static final String module = KeywordIndex . class . getName ( ) ; public static void forceIndexKeywords ( GenericValue product ) throws GenericEntityException { KeywordIndex . indexKeywords ( product , true ) ; } public static void indexKeywords ( GenericValue product ) throws GenericEntityException { KeywordIndex . indexKeywords ( product , false ) ; } public static void indexKeywords ( GenericValue product , boolean doAll ) throws GenericEntityException { if ( product == null ) return ; Timestamp nowTimestamp = UtilDateTime . nowTimestamp ( ) ; if ( ! doAll ) { if ( \"N\" . equals ( product . getString ( \"autoCreateKeywords\" ) ) ) { return ; } if ( \"Y\" . equals ( product . getString ( \"isVariant\" ) ) && \"true\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.ignore.variants\" ) ) ) { return ; } Timestamp salesDiscontinuationDate = product . getTimestamp ( \"salesDiscontinuationDate\" ) ; if ( salesDiscontinuationDate != null && salesDiscontinuationDate . before ( nowTimestamp ) && \"true\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.ignore.discontinued.sales\" ) ) ) { return ; } } Delegator delegator = product . getDelegator ( ) ; if ( delegator == null ) return ; String productId = product . getString ( \"productId\" ) ; String separators = KeywordSearchUtil . getSeparators ( ) ; String stopWordBagOr = KeywordSearchUtil . getStopWordBagOr ( ) ; String stopWordBagAnd = KeywordSearchUtil . getStopWordBagAnd ( ) ; boolean removeStems = KeywordSearchUtil . getRemoveStems ( ) ; Set < String > stemSet = KeywordSearchUtil . getStemSet ( ) ; Map < String , Long > keywords = new TreeMap < String , Long > ( ) ; List < String > strings = FastList . newInstance ( ) ; int pidWeight = 1 ; try { pidWeight = Integer . parseInt ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.productId\" , \"0\" ) ) ; } catch ( Exception e ) { Debug . logWarning ( \"Could not parse weight number: \" + e . toString ( ) , module ) ; } keywords . put ( product . getString ( \"productId\" ) . toLowerCase ( ) , Long . valueOf ( pidWeight ) ) ; if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.productName\" , \"0\" ) ) ) { addWeightedKeywordSourceString ( product , \"productName\" , strings ) ; } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.internalName\" , \"0\" ) ) ) { addWeightedKeywordSourceString ( product , \"internalName\" , strings ) ; } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.brandName\" , \"0\" ) ) ) { addWeightedKeywordSourceString ( product , \"brandName\" , strings ) ; } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.description\" , \"0\" ) ) ) { addWeightedKeywordSourceString ( product , \"description\" , strings ) ; } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Product.longDescription\" , \"0\" ) ) ) { addWeightedKeywordSourceString ( product , \"longDescription\" , strings ) ; } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.ProductFeatureAndAppl.description\" , \"0\" ) ) || ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.ProductFeatureAndAppl.abbrev\" , \"0\" ) ) || ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.ProductFeatureAndAppl.idCode\" , \"0\" ) ) ) { List < GenericValue > productFeatureAndAppls = delegator . findByAnd ( \"ProductFeatureAndAppl\" , UtilMisc . toMap ( \"productId\" , productId ) , null , false ) ; for ( GenericValue productFeatureAndAppl : productFeatureAndAppls ) { addWeightedKeywordSourceString ( productFeatureAndAppl , \"description\" , strings ) ; addWeightedKeywordSourceString ( productFeatureAndAppl , \"abbrev\" , strings ) ; addWeightedKeywordSourceString ( productFeatureAndAppl , \"idCode\" , strings ) ; } } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.ProductAttribute.attrName\" , \"0\" ) ) || ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.ProductAttribute.attrValue\" , \"0\" ) ) ) { List < GenericValue > productAttributes = delegator . findByAnd ( \"ProductAttribute\" , UtilMisc . toMap ( \"productId\" , productId ) , null , false ) ; for ( GenericValue productAttribute : productAttributes ) { addWeightedKeywordSourceString ( productAttribute , \"attrName\" , strings ) ; addWeightedKeywordSourceString ( productAttribute , \"attrValue\" , strings ) ; } } if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.GoodIdentification.idValue\" , \"0\" ) ) ) { List < GenericValue > goodIdentifications = delegator . findByAnd ( \"GoodIdentification\" , UtilMisc . toMap ( \"productId\" , productId ) , null , false ) ; for ( GenericValue goodIdentification : goodIdentifications ) { addWeightedKeywordSourceString ( goodIdentification , \"idValue\" , strings ) ; } } if ( \"Y\" . equals ( product . getString ( \"isVirtual\" ) ) ) { if ( ! \"0\" . equals ( UtilProperties . getPropertyValue ( \"prodsearch\" , \"index.weight.Variant.Product.productId\" , \"0\" ) ) ) { List < GenericValue > variantProductAssocs = delegator . findByAnd ( \"ProductAssoc\" , UtilMisc . toMap ( \"productId\" , productId , \"productAssocTypeId\" , \"PRODUCT_VARIANT\" ) , null , false ) ;", "gt": "variantProductAssocs = EntityUtil . filterByDate ( variantProductAssocs ) ;", "prediction": "}\n", "label": 0}
{"id": 10500, "input": "<s> package com . emf4sw . owl ; public interface ObjectAllValuesFrom extends ObjectPropertyRestriction { ClassExpression getAllValuesFrom ( ) ; void setAllValuesFrom", "gt": "( ClassExpression value ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 7963, "input": "<s> package LizaCraft . Entity ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . Server ; import org . bukkit . World ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Vehicle ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaVehicle ; public class LizaCraftVehicle implements LizaVehicle { private Vehicle vehicle ; public LizaCraftVehicle ( Vehicle vehicle ) { this . vehicle = vehicle ; } @ Override public Vector getVelocity ( ) { return this . vehicle . getVelocity ( ) ; } @ Override public void setVelocity ( Vector arg0 ) { this . vehicle . setVelocity ( arg0 ) ; } @ Override public boolean eject ( ) { return this . vehicle . eject ( ) ; } @ Override public int getEntityId ( ) { return this . vehicle . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . vehicle . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . vehicle . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . vehicle . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . vehicle . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . vehicle . getMaxFireTicks ( ) ; } @ Override public List < Entity > getNearbyEntities ( double arg0 , double arg1 , double arg2 ) { return this . vehicle . getNearbyEntities ( arg0 , arg1 , arg2 ) ; } @ Override public Entity getPassenger ( ) { return this . vehicle . getPassenger ( ) ; } @ Override public Server getServer ( ) { return this . vehicle . getServer ( ) ; } @ Override public int getTicksLived ( ) { return this . vehicle . getTicksLived ( ) ; } @ Override public UUID getUniqueId ( ) { return this . vehicle . getUniqueId ( ) ; } @ Override public World getWorld ( ) { return this . vehicle . getWorld ( ) ; } @ Override public boolean isDead ( ) { return this . vehicle . isDead ( ) ; } @ Override public boolean isEmpty ( ) { return this . vehicle . isEmpty ( ) ; } @ Override public void playEffect ( EntityEffect arg0 ) { this . vehicle . playEffect ( arg0 ) ; } @ Override public void remove ( ) { this . vehicle . remove ( ) ; } @ Override public void setFallDistance ( float arg0 ) { this . vehicle . setFallDistance ( arg0 ) ; } @ Override public void setFireTicks ( int arg0 ) { this . vehicle . setFireTicks ( arg0 ) ; } @ Override public void setLastDamageCause ( EntityDamageEvent arg0 ) { this . vehicle . setLastDamageCause ( arg0 ) ; } @ Override public boolean setPassenger ( Entity arg0 ) { return this . vehicle . setPassenger ( arg0 ) ; } @ Override public void setTicksLived ( int arg0 ) { this . vehicle . setTicksLived ( arg0 ) ; } @ Override public", "gt": "boolean teleport ( Location arg0 )", "prediction": "( )\n", "label": 0}
{"id": 10507, "input": "<s> package org . eclipse . rap . rwt . osgi . internal ; import java . io . IOException ; import java . util . Enumeration ; import javax . servlet . * ; import javax . servlet . http . * ; class CutOffContextPathWrapper extends HttpServlet { private static final long serialVersionUID = 1L ; private final HttpServlet servlet ; private final String alias ; private final ServletContext servletContext ; static class RequestWrapper extends HttpServletRequestWrapper { private final String alias ; private final HttpSession httpSession ; RequestWrapper ( HttpServletRequest request , ServletContext servletContext , String alias ) { super ( request ) ; httpSession = new HttpSessionWrapper ( request . getSession ( ) , servletContext ) ; this . alias = alias ; } @ Override public String getServletPath ( ) { return alias ; } @ Override public HttpSession getSession ( ) { return httpSession ; } } CutOffContextPathWrapper ( HttpServlet servlet , ServletContext servletContext , String alias ) { this . servlet = servlet ; this . servletContext = servletContext ; this . alias = alias ; } @ Override public void destroy ( ) { servlet . destroy ( ) ; } @ Override public String getInitParameter ( String name ) { return servlet . getInitParameter ( name ) ; } @ Override public ServletConfig getServletConfig ( ) { return servlet . getServletConfig ( ) ; } @ Override public Enumeration < String > getInitParameterNames ( ) { return servlet . getInitParameterNames ( ) ; } @ Override public ServletContext getServletContext ( ) { return servlet . getServletContext ( ) ; } @ Override public String getServletInfo ( ) { return servlet . getServletInfo ( ) ; } @ Override public void init ( ) throws ServletException { servlet . init ( ) ; } @ Override public void init ( ServletConfig config ) throws ServletException { servlet . init ( config ) ; } @ Override public String getServletName ( ) { return servlet . getServletName ( ) ; } @ Override public void service ( ServletRequest req , ServletResponse res ) throws ServletException , IOException { RequestWrapper request = new RequestWrapper ( ( HttpServletRequest ) req", "gt": ", servletContext , alias ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9148, "input": "<s> package hudson . plugins . dimensionsscm ; import hudson . plugins . dimensionsscm . DimensionsAPI ; import hudson . plugins . dimensionsscm . DimensionsSCM ; import hudson . plugins . dimensionsscm . Logger ; import com . serena . dmclient . api . DimensionsResult ; import hudson . scm . RepositoryBrowser ; import hudson . plugins . dimensionsscm . DimensionsChangeSet ; import hudson . Extension ; import hudson . Launcher ; import hudson . model . Descriptor . FormException ; import hudson . model . Descriptor ; import hudson . model . Result ; import hudson . util . FormValidation ; import hudson . Util ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import org . kohsuke . stapler . export . Exported ; import org . kohsuke . stapler . export . ExportedBean ; import java . io . IOException ; import java . io . Serializable ; import java . net . URL ; import javax . servlet . ServletException ; @ ExportedBean ( defaultVisibility = 999 ) public abstract class DimensionsSCMRepositoryBrowser extends RepositoryBrowser < DimensionsChangeSet > { private static final long serialVersionUID = 1L ; @ DataBoundConstructor public DimensionsSCMRepositoryBrowser ( ) { } public URL getDiffLink ( DimensionsChangeSet . DmFiles item ) throws IOException { String link = \"http://alink.com/link.html\" ; return new URL ( link .", "gt": "toString ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10510, "input": "<s> package com . google . gwt . emul . java . io ; public class ByteArrayInputStream extends InputStream { public ByteArrayInputStream ( ) { super ( ) ; } public", "gt": "ByteArrayInputStream ( String text )", "prediction": "}\n", "label": 1}
{"id": 9295, "input": "<s> package org . dawb . workbench . plotting . tools . profile ; import java . text . DecimalFormat ; import java . util . Collection ; import java . util . List ; import org . dawb . common . ui . plot . region . IROIListener ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . tool . AbstractToolPage ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . IPaletteListener ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . common . ui . plot . trace . ITraceListener ; import org . dawb . common . ui . plot . trace . PaletteEvent ; import org . dawb . common . ui . plot . trace . TraceEvent ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . common . ui . util . GridUtils ; import org . dawb . common . ui . views . ImageItem ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . core . runtime . preferences . InstanceScope ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . nebula . widgets . gallery . GalleryItem ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . part . IPageSite ; import org . eclipse . ui . preferences . ScopedPreferenceStore ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . io . IMetaData ; import uk . ac . diamond . scisoft . analysis . io . LoaderFactory ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . RectangularROI ; public class ImageTableTool extends AbstractToolPage implements IROIListener { private final static Logger logger = LoggerFactory . getLogger ( ProfileTool . class ) ; private Table table ; private Composite main ; private ITraceListener traceListener ; private IRegionListener regionListener ; private IPaletteListener paletteListener ; private ProfileTableJob updateProfiles ; public ImageTableTool ( ) { try { updateProfiles = new ProfileTableJob ( ) ; this . paletteListener = new IPaletteListener . Stub ( ) { @ Override public void maskChanged ( PaletteEvent evt ) { update ( null , null , false ) ; } } ; this . traceListener = new ITraceListener . Stub ( ) { @ Override public void tracesPlotted ( TraceEvent evt ) { if ( ! ( evt . getSource ( ) instanceof List < ? > ) ) { return ; } if ( getImageTrace ( ) != null ) getImageTrace ( ) . addPaletteListener ( paletteListener ) ; ImageTableTool . this . update ( null , null , false ) ; } @ Override protected void update ( TraceEvent evt ) { ImageTableTool . this . update ( null , null , false ) ; } } ; this . regionListener = new IRegionListener . Stub ( ) { @ Override public void regionRemoved ( RegionEvent evt ) { if ( evt . getRegion ( ) != null ) { evt . getRegion ( ) . removeROIListener ( ImageTableTool . this ) ; } } @ Override public void regionAdded ( RegionEvent evt ) { if ( evt . getRegion ( ) != null ) { ImageTableTool . this . update ( null , null , false ) ; } } @ Override public void regionCreated ( RegionEvent evt ) { if ( evt . getRegion ( ) != null ) { evt . getRegion ( ) . addROIListener ( ImageTableTool . this ) ; } } protected void update ( RegionEvent evt ) { ImageTableTool . this . update ( null , null , false ) ; } } ; } catch ( Exception e ) { logger . error ( \"Cannot get plotting system!\" , e ) ; } } @ Override public void createControl ( Composite parent ) { final IPageSite site = getSite ( ) ; final Action reselect = new Action ( \"Create new profile.\" , getImageDescriptor ( ) ) { public void run ( ) { createNewRegion ( ) ; } } ; site . getActionBars ( ) . getToolBarManager ( ) . add ( reselect ) ; site . getActionBars ( ) . getToolBarManager ( ) . add ( new Separator ( ) ) ; this . main = new Composite ( parent , SWT . NONE ) ; final GridLayout gridLayout = new GridLayout ( 1 , false ) ; gridLayout . verticalSpacing = 0 ; gridLayout . marginWidth = 0 ; gridLayout . marginHeight = 0 ; gridLayout . horizontalSpacing = 0 ; main . setLayout ( gridLayout ) ; } @ Override public ToolPageRole getToolPageRole ( ) { return ToolPageRole . ROLE_2D ; } @ Override public void setFocus ( ) { if ( table != null && ! table . isDisposed ( ) ) table . setFocus ( ) ; } public void activate ( ) { super . activate ( ) ; update ( null , null , false ) ;", "gt": "if ( getPlottingSystem ( ) != null )", "prediction": "}\n", "label": 0}
{"id": 10532, "input": "<s> package play . modules . chronostamp ; import play . PlayPlugin ; import play . classloading . ApplicationClasses . ApplicationClass ; public class ChronostampPlugin extends PlayPlugin { @ Override public void enhance ( ApplicationClass appClass ) throws Exception { new ChronostampEnhancer", "gt": "( ) . enhanceThisClass ( appClass ) ;", "prediction": ";\n", "label": 1}
{"id": 4951, "input": "<s> package org . jjflyboy . tjpeditor . ui . quickfix ; import org . eclipse .", "gt": "xtext . ui . editor . quickfix . DefaultQuickfixProvider ;", "prediction": ";\n", "label": 0}
{"id": 10537, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType", "gt": "( name = \"\" , propOrder =", "prediction": "( ) ;\n", "label": 1}
{"id": 8881, "input": "<s> package com . mobeelizer . mobile . android . search ; import com . mobeelizer . mobile . android", "gt": ". api . MobeelizerOrder ;", "prediction": ";\n", "label": 0}
{"id": 10549, "input": "<s> package org . eclipse . ui . internal . themes ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CLabel ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . custom . ViewForm ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . ToolBar ; import org . eclipse . swt . widgets . ToolItem ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . IWorkbenchGraphicConstants ; import org . eclipse . ui . internal . IWorkbenchThemeConstants ; import org . eclipse . ui . internal . WorkbenchImages ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . themes . ITheme ; import org . eclipse . ui . themes . IThemePreview ; public class WorkbenchPreview implements IThemePreview { private static int tabPos = PlatformUI . getPreferenceStore ( ) . getInt ( IWorkbenchPreferenceConstants . VIEW_TAB_POSITION ) ; private boolean disposed = false ; private CTabFolder folder ; private ITheme theme ; private ToolBar toolBar ; private CLabel viewMessage ; private ViewForm viewForm ; private IPropertyChangeListener fontAndColorListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( ! disposed ) { setColorsAndFonts ( ) ; viewForm . layout ( true ) ; } } } ; public void createControl ( Composite parent , ITheme currentTheme ) { this . theme = currentTheme ; folder = new CTabFolder ( parent , SWT . BORDER ) ; folder . setUnselectedCloseVisible ( false ) ; folder . setEnabled ( false ) ; folder . setMaximizeVisible ( true ) ; folder . setMinimizeVisible ( true ) ; viewForm = new ViewForm ( folder , SWT . NONE ) ; viewForm . marginHeight = 0 ; viewForm . marginWidth = 0 ; viewForm . verticalSpacing = 0 ; viewForm . setBorderVisible ( false ) ; toolBar = new ToolBar ( viewForm , SWT . FLAT | SWT . WRAP ) ; ToolItem toolItem = new ToolItem ( toolBar , SWT . PUSH ) ; Image hoverImage = WorkbenchImages . getImage ( IWorkbenchGraphicConstants . IMG_LCL_VIEW_MENU ) ; toolItem . setImage ( hoverImage ) ; viewForm .", "gt": "setTopRight ( toolBar ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8181, "input": "<s> package com . quirijngrootbluemink . iptools ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import android . app . Activity ; import android . os . Bundle ; import android . view . KeyEvent ; import android . view . View ; import android . view . View . OnClickListener ; import android . view . inputmethod . EditorInfo ; import android . widget . Button ; import android . widget . EditText ; import android . widget . TextView ; import android . widget . Toast ; import android . widget . TextView . OnEditorActionListener ; import com . markupartist . android . widget . ActionBar ; public class IpCalcMain extends Activity { Button btnCalc ; EditText txtURL ; TextView txtNetworkClass , txtBinaryAddress , txtNetworkAddress , txtBroadcastAddress , txtAddressRange , txtNumberOfHosts ; IpCalc ip ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . ip_calc_main ) ; btnCalc = ( Button ) findViewById ( R . id . btnCalc ) ; txtURL = ( EditText ) findViewById ( R . id . txtAddress ) ; txtNetworkClass = ( TextView ) findViewById ( R . id . txtNetworkClass ) ; txtBinaryAddress = ( TextView ) findViewById ( R . id . txtBinaryAddress ) ; txtNetworkAddress = ( TextView ) findViewById ( R . id . txtNetworkAddress ) ; txtBroadcastAddress = ( TextView ) findViewById ( R . id . txtBroadcastAddress ) ; txtAddressRange = ( TextView ) findViewById ( R . id . txtAddressRange ) ; txtNumberOfHosts = ( TextView ) findViewById ( R . id . txtNumberOfHosts ) ; txtURL . setOnEditorActionListener ( new OnEditorActionListener ( ) { @ Override public boolean onEditorAction ( TextView v , int actionId , KeyEvent event ) { if ( actionId == EditorInfo . IME_ACTION_GO ) { try { String temp = txtURL . getText ( ) . toString ( ) ; String [ ] parts = temp . split ( \"/\" ) ; if ( Integer . parseInt ( parts [ 1 ] ) > 32 ) { throw new Exception ( getString ( R . string . min_subnet ) ) ; } if ( ! checkIp ( parts [ 0 ] ) ) { throw new Exception ( getString ( R . string . invalid_ip ) ) ; } ip = new IpCalc ( parts [ 0 ] , parts [ 1 ] ) ; displayInfo ( ) ; } catch ( Exception e ) { txtURL . requestFocus ( ) ; showMe ( e . getMessage ( ) ) ; } } return true ; } } ) ; setActionBar ( ) ; btnCalc . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { try { String temp = txtURL . getText ( ) . toString ( ) ; String [ ] parts = temp . split ( \"/\" ) ; if ( Integer . parseInt ( parts [ 1 ] ) > 32 ) { throw new Exception ( getString ( R . string . min_subnet ) ) ; } if ( ! checkIp ( parts [ 0 ] ) ) { throw new Exception ( getString ( R . string . invalid_ip ) ) ; } ip = new IpCalc ( parts [ 0 ] , parts [ 1 ] ) ; displayInfo ( ) ; } catch ( Exception e ) { txtURL . requestFocus ( ) ; showMe ( e . getMessage ( ) ) ; } } } ) ; } private boolean checkIp ( String value ) { String IprRegex = \"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$\" ; Pattern patt = Pattern . compile ( IprRegex ) ; Matcher matcher = patt . matcher ( value ) ; if ( matcher . matches ( ) ) { return true ; } else { return false ; } } public void showMe ( String s ) { Toast . makeText ( getApplicationContext ( ) , s , Toast . LENGTH_SHORT ) . show ( ) ; } private void displayInfo ( ) { txtNetworkClass . setText ( ip . getNetworkClass ( ) ) ; txtBinaryAddress . setText ( ip . getBinaryAddress ( ) ) ; txtNetworkAddress . setText ( ip . getDecimalNetworkAddress ( ) ) ; txtBroadcastAddress . setText ( ip . getDecimalBroadcastAddress ( ) ) ; txtAddressRange . setText ( ip . getValidIpRange ( ) ) ; txtNumberOfHosts . setText ( \"\" + ip . getNumberOfHosts ( ) ) ; } private void setActionBar ( ) { ActionBar actionBar = ( ActionBar ) findViewById ( R . id . actionBar ) ; actionBar . setTitle ( getString ( R . string . app_name ) ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setOnTitleClickListener ( new OnClickListener ( ) { @ Override", "gt": "public void onClick ( View v )", "prediction": "}\n", "label": 0}
{"id": 10553, "input": "<s> package knowevo . myvizster . controls ; import java . awt . event . MouseEvent ; import java . util . TimerTask ; import javax . swing . SwingUtilities ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . activity . Activity ; import edu . berkeley . guir . prefuse . event . ControlAdapter ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Entity ; public class HighlightFreezeControl extends ControlAdapter { private FocusSet focusSet ; private Entity curFocus ; private Object focusSetKey ; private Activity activity ; private TimerTask task ; private long delay = 200L ; public HighlightFreezeControl ( Activity act , Object focusSetKey ) { this . activity = act ; this . focusSetKey = focusSetKey ; } public void setFocus ( VisualItem item ) { Entity focus = item . getEntity ( ) ; if ( focus != curFocus ) { ItemRegistry registry = item . getItemRegistry ( ) ; FocusManager fm = registry . getFocusManager ( ) ; focusSet = fm . getFocusSet ( focusSetKey ) ; curFocus = focus ; focusSet . set ( focus ) ; registry . touch ( item . getItemClass ( ) ) ; } } public void clearFocus ( ) { focusSet . clear ( ) ; focusSet = null ; curFocus = null ; } public void itemClicked ( final VisualItem item , MouseEvent e ) { if ( isAllowedType ( item ) && SwingUtilities . isLeftMouseButton ( e ) ) { if ( e . getClickCount ( ) == 1 ) { task = new TimerTask ( ) { public void run ( ) { setFocus ( item ) ; runActivity ( ) ; } } ; VizsterLib . getTimer ( ) . schedule ( task , delay ) ; } else if ( e . getClickCount ( ) > 1 ) { if ( task != null ) task . cancel ( ) ; } } } public void", "gt": "mouseClicked ( MouseEvent e )", "prediction": "( )\n", "label": 1}
{"id": 247, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . Type ; import org . objectweb . asm . tree . * ; import static org . objectweb . asm . Opcodes . * ; import static org . parboiled . transform . AsmUtils . getLoadingOpcode ; class RuleMethodRewriter implements RuleMethodProcessor { private RuleMethod method ; private InstructionGroup group ; private int actionNr ; private int varInitNr ; public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( classNode , \"classNode\" ) ; checkArgNotNull ( method , \"method\" ) ; return method . containsExplicitActions ( ) || method . containsVars ( ) ; } public void process ( ParserClassNode classNode , RuleMethod method ) throws Exception { this . method = checkArgNotNull ( method , \"method\" ) ; actionNr = 0 ; varInitNr = 0 ; for ( InstructionGroup group : method . getGroups ( ) ) { this . group = group ; createNewGroupClassInstance ( ) ; initializeFields ( ) ; InstructionGraphNode root = group . getRoot ( ) ; if ( root . isActionRoot ( ) ) { removeGroupRootInstruction ( ) ; } else { ( ( MethodInsnNode ) root . getInstruction ( ) ) . desc = \"(Lorg/parboiled/common/Factory;)V\" ; } } method . setBodyRewritten ( ) ; } private void createNewGroupClassInstance ( ) { String internalName = group . getGroupClassType ( ) . getInternalName ( ) ; InstructionGraphNode root =", "gt": "group . getRoot ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10570, "input": "<s> package org . restlet . ext . jaxrs . internal . core ; import javax . ws . rs . core . UriInfo ; import org . restlet . ext . jaxrs . ExtendedUriBuilder ; import org . restlet . ext . jaxrs . ExtendedUriInfo ; public class ThreadLocalizedExtendedUriInfo extends ThreadLocalizedUriInfo implements ExtendedUriInfo { public ThreadLocalizedExtendedUriInfo ( ThreadLocalizedContext tlContext ) { super ( tlContext ) ; } @ Override public ExtendedUriBuilder getAbsolutePathBuilder ( ) { return", "gt": "getCallContext ( ) . getAbsolutePathBuilderExtended ( ) ;", "prediction": "\n", "label": 1}
{"id": 3800, "input": "<s> package org . ofbiz . sql ; import java . util . Iterator ; import java . util . List ; import org . ofbiz . base . util . StringUtil ; public final class InsertRow extends Atom implements Iterable < Value > { private final List < Value > values ; public InsertRow ( List < Value > values ) { this . values = values ; } public Iterator < Value > iterator ( ) { return values . iterator ( ) ; } @ Override public boolean equals ( Object o ) { if ( o instanceof InsertRow ) {", "gt": "InsertRow other = ( InsertRow ) o ;", "prediction": "\n", "label": 0}
{"id": 10576, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . io . IOException ; import java . sql . Connection ; import java . sql . SQLException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . sqoop . mapreduce . DBWritable ; import com . cloudera . sqoop . mapreduce . db . DBConfiguration ; import com . cloudera . sqoop . mapreduce . db . DBInputFormat ; import com . cloudera . sqoop . mapreduce . db . DBRecordReader ; import com . cloudera . sqoop . mapreduce . db . DataDrivenDBInputFormat ; public class DataDrivenDBRecordReader < T extends DBWritable > extends DBRecordReader < T > { private static final Log LOG = LogFactory . getLog ( DataDrivenDBRecordReader . class ) ; private String dbProductName ; public DataDrivenDBRecordReader ( DBInputFormat . DBInputSplit split , Class < T > inputClass , Configuration conf , Connection conn , DBConfiguration dbConfig , String cond , String [ ] fields , String table , String dbProduct ) throws SQLException { super ( split , inputClass , conf , conn , dbConfig , cond , fields , table ) ; this . dbProductName = dbProduct ; } @ Override public float getProgress ( ) throws IOException { return isDone ( ) ? 1.0f : 0.0f ; } protected String getSelectQuery ( ) { StringBuilder query = new StringBuilder ( ) ; DataDrivenDBInputFormat . DataDrivenDBInputSplit dataSplit = ( DataDrivenDBInputFormat . DataDrivenDBInputSplit ) getSplit ( ) ; DBConfiguration dbConf = getDBConf ( ) ; String [ ] fieldNames = getFieldNames ( ) ; String tableName = getTableName ( ) ; String conditions = getConditions ( ) ; StringBuilder conditionClauses = new StringBuilder ( ) ; conditionClauses . append ( \"( \" ) . append ( dataSplit . getLowerClause ( ) ) ; conditionClauses . append ( \" ) AND ( \" ) . append ( dataSplit . getUpperClause ( ) ) ; conditionClauses . append ( \" )\" ) ; if ( dbConf . getInputQuery ( ) == null ) { query . append ( \"SELECT \" ) ; for ( int i = 0 ; i < fieldNames . length ; i ++ ) { query . append ( fieldNames [ i ] ) ; if ( i != fieldNames . length - 1 ) { query . append ( \", \" ) ; } } query . append ( \" FROM \" ) . append ( tableName ) ; if ( ! dbProductName . startsWith ( \"ORACLE\" ) && ! dbProductName . startsWith ( \"DB2\" ) && ! dbProductName . startsWith ( \"MICROSOFT SQL SERVER\" ) && ! dbProductName . startsWith ( \"POSTGRESQL\" ) ) { query . append ( \" AS \" ) . append ( tableName ) ; } query . append ( \" WHERE \" ) ; if ( conditions != null && conditions . length ( ) > 0 ) { query . append ( \"( \" ) . append (", "gt": "conditions ) . append ( \" ) AND \" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1927, "input": "<s> package de . javawi . jstun . attribute ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; public class ResponseAddress extends MappedResponseChangedSourceAddressReflectedFrom { private static final Logger LOGGER = LoggerFactory . getLogger ( ResponseAddress . class ) ; public ResponseAddress ( ) { super ( MessageAttribute . MessageAttributeType . ResponseAddress ) ; } public static MessageAttribute", "gt": "parse ( byte [ ] data ) throws MessageAttributeParsingException", "prediction": ";\n", "label": 0}
{"id": 10579, "input": "<s> package br . org . archimedes . trims . rcp ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import br . org . archimedes . model . Element ; import br . org . archimedes . rcp . ExtensionLoader ; import br . org . archimedes . rcp . ExtensionTagHandler ; import br . org . archimedes . rcp . extensionpoints . ElementEPLoader ; import br . org . archimedes . trims . interfaces . Trimmer ; public class TrimmerEPLoader implements ExtensionTagHandler { private static final String TRIMMER_EXTENSION_POINT_ID = \"br.org.archimedes.trims.trimmer\" ; private static final String CLASS_ATTRIBUTE_NAME = \"class\" ; private static final String ELEMENT_ATTRIBUTE_NAME = \"element\" ; private final Map < Class < ? extends Element > , Trimmer > trimmableElementsMap = new HashMap < Class < ? extends Element > , Trimmer > ( ) ; private ElementEPLoader elementLoader ; public TrimmerEPLoader ( ) { elementLoader = new ElementEPLoader ( ) ; if ( trimmableElementsMap . isEmpty ( ) ) { ExtensionLoader loader = new ExtensionLoader ( TRIMMER_EXTENSION_POINT_ID ) ; loader . loadExtension ( this ) ; } } public void handleTag ( IConfigurationElement elementTag ) throws CoreException { String elementId = elementTag . getAttribute ( ELEMENT_ATTRIBUTE_NAME ) ; Class < ? extends Element > element = elementLoader . getElementClass ( elementId ) ; if ( element != null ) { Trimmer trimmer = null ; trimmer = ( Trimmer )", "gt": "elementTag . createExecutableExtension ( CLASS_ATTRIBUTE_NAME ) ;", "prediction": ";\n", "label": 1}
{"id": 1734, "input": "<s> package org . ofbiz . project ; import java . sql . Timestamp ; import java . util . List ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class Various { public static final String module = Various . class . getName ( ) ; public static void setDatesFollowingTasks ( GenericValue task ) { try { List < GenericValue > assocs = task . getRelated ( \"FromWorkEffortAssoc\" , null , null , false ) ; if ( UtilValidate . isNotEmpty ( assocs ) ) { for ( GenericValue assoc : assocs ) { GenericValue nextTask = assoc . getRelatedOne ( \"ToWorkEffort\" , false ) ; Timestamp newStartDate = task . getTimestamp ( \"estimatedCompletionDate\" ) ; if ( nextTask . get ( \"estimatedStartDate\" ) == null || nextTask . getTimestamp ( \"estimatedStartDate\" ) . before ( newStartDate ) ) { nextTask . put ( \"estimatedStartDate\" , UtilDateTime . addDaysToTimestamp ( task . getTimestamp ( \"estimatedCompletionDate\" ) , 1 ) ) ; nextTask . put ( \"estimatedCompletionDate\" , calculateCompletionDate ( nextTask , task . getTimestamp ( \"estimatedCompletionDate\" ) ) ) ; nextTask . store ( ) ; } setDatesFollowingTasks ( nextTask ) ; } } } catch ( GenericEntityException e ) { Debug . logError ( \"Could not updte task: \" + e . getMessage ( ) , module ) ; } } public static Timestamp calculateCompletionDate ( GenericValue task , Timestamp startDate ) { Double plannedHours = 0.00 ; try { List < GenericValue > standards = task . getRelated ( \"WorkEffortSkillStandard\" , null , null , false ) ; for ( GenericValue standard : standards ) { if ( standard . getDouble ( \"estimatedNumPeople\" ) == null ) { standard . put ( \"estimatedNumPeople\" , new Double ( \"1\" ) ) ; } if ( standard . get ( \"estimatedDuration\" ) != null ) { plannedHours += standard . getDouble ( \"estimatedDuration\" ) . doubleValue ( ) / standard . getDouble ( \"estimatedNumPeople\" ) . doubleValue ( ) ; } } } catch ( GenericEntityException e ) { Debug . logError ( \"Could not updte task: \" + e . getMessage ( ) , module ) ; } if ( plannedHours == 0.00 ) { plannedHours = new Double ( \"24.00\" ) ; } int days = plannedHours . intValue ( ) / 8 ; while ( days > 0 ) { int dayNumber = UtilDateTime . dayNumber ( startDate ) ; if ( dayNumber != 1 && dayNumber != 7 ) { days -- ; } startDate = UtilDateTime . addDaysToTimestamp ( startDate , 1 ) ; } return startDate ; } public static double calculateActualHours ( Delegator delegator , String timesheetId ) { double actualHours = 0.00 ; if ( timesheetId != null ) { try { List < GenericValue > actuals = delegator . findByAnd ( \"TimeEntry\" , UtilMisc . toMap ( \"timesheetId\" , timesheetId ) , null , false ) ; if ( actuals . size ( ) > 0 ) { for ( GenericValue actual : actuals ) { Double hour = (", "gt": "Double ) actual . get ( \"hours\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10589, "input": "<s> package org . eclipse . ui . internal . wizards . preferences ; import org . eclipse . rap . rwt . RWT ; public class PreferencesMessages { private static final String BUNDLE_NAME = \"org.eclipse.ui.internal.wizards.preferences.messages\" ; public String WizardPreferences_description ; public String WizardPreferencesPage_noOptionsSelected ; public String WizardPreferences_noSpecificPreferenceDescription ; public String PreferencesExportWizard_export ; public String WizardPreferencesExportPage1_exportTitle ; public String WizardPreferencesExportPage1_exportDescription ; public String WizardPreferencesExportPage1_preferences ; public String WizardPreferencesExportPage1_noPrefFile ; public String WizardPreferencesExportPage1_overwrite ; public String WizardPreferencesExportPage1_title ; public String WizardPreferencesExportPage1_all ; public String WizardPreferencesExportPage1_choose ; public String WizardPreferencesExportPage1_file ; public String PreferencesExport_error ; public String PreferencesExport_browse ; public String PreferencesExport_createTargetDirectory ; public String PreferencesExport_directoryCreationError ; public String ExportFile_overwriteExisting ; public String PreferencesImportWizard_import ; public String WizardPreferencesImportPage1_importTitle ; public String WizardPreferencesImportPage1_importDescription ; public String WizardPreferencesImportPage1_all ; public String WizardPreferencesImportPage1_choose ; public String WizardPreferencesImportPage1_file ; public String WizardPreferencesImportPage1_title ; public String WizardPreferencesImportPage1_invalidPrefFile ; public String SelectionDialog_selectLabel ; public String SelectionDialog_deselectLabel ; public String WizardDataTransfer_existsQuestion ; public String WizardDataTransfer_overwriteNameAndPathQuestion ; public String Question ; public static PreferencesMessages get ( ) { return RWT . NLS", "gt": ". getISO8859_1Encoded ( BUNDLE_NAME , PreferencesMessages . class ) ;", "prediction": ";\n", "label": 1}
{"id": 3097, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import java . util . List ; import com . redhat . ceylon . compiler . typechecker . model . Class ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . Functional ; import com . redhat . ceylon . compiler . typechecker . model . FunctionalParameter ; import com . redhat . ceylon . compiler . typechecker . model . IntersectionType ; import com . redhat . ceylon . compiler . typechecker . model . Method ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . ParameterList ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . Setter ; import com . redhat . ceylon . compiler . typechecker . model . TypeDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . TypeParameter ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . UnionType ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AnyAttribute ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AnyClass ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AnyMethod ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AttributeArgument ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AttributeDeclaration ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . AttributeSetterDefinition ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . FunctionArgument ; import com . redhat . ceylon . compiler . typechecker . tree . Tree . Variable ; import com . redhat . ceylon . compiler . typechecker . tree . Visitor ; public abstract class BoxingDeclarationVisitor extends Visitor { protected abstract boolean isCeylonBasicType ( ProducedType type ) ; protected abstract boolean isNothing ( ProducedType type ) ; protected abstract boolean isObject ( ProducedType type ) ; protected abstract boolean willEraseToObject ( ProducedType type ) ; @ Override public void visit ( FunctionArgument that ) { super . visit ( that ) ; boxMethod ( that . getDeclarationModel ( ) ) ; } @ Override public void visit ( AnyMethod that ) { super . visit ( that ) ; boxMethod ( that . getDeclarationModel ( ) ) ; rawTypedDeclaration ( that . getDeclarationModel ( ) ) ; erasureToObject ( that . getDeclarationModel ( ) ) ; } private void erasureToObject ( TypedDeclaration decl ) { if ( decl == null ) return ; ProducedType type = decl . getType ( ) ; if ( type != null && willEraseToObject ( type ) ) { decl . setTypeErased ( true ) ; } } private void rawTypedDeclaration ( TypedDeclaration decl ) { if ( decl == null ) return ; ProducedType type = decl . getType ( ) ; if ( type != null ) { if ( containsRaw ( type ) ) type . setRaw ( true ) ; } } private boolean containsRaw ( ProducedType type ) { for ( ProducedType typeArg : type . getTypeArguments ( ) . values ( ) ) { if ( typeArg == null ) return false ; TypeDeclaration typeDeclaration = typeArg . getDeclaration ( ) ; if ( typeDeclaration instanceof UnionType ) { UnionType ut = ( UnionType ) typeDeclaration ; List < ProducedType > caseTypes = ut . getCaseTypes ( ) ; if ( caseTypes . size ( ) == 2 && ( isNothing ( caseTypes . get ( 0 ) ) || isNothing ( caseTypes . get ( 1 ) ) ) ) return false ; return true ; } if ( typeDeclaration instanceof IntersectionType ) { IntersectionType ut = ( IntersectionType ) typeDeclaration ; List < ProducedType > satisfiedTypes = ut . getSatisfiedTypes ( ) ; if ( satisfiedTypes . size ( ) == 2 && ( isObject ( satisfiedTypes . get ( 0 ) ) || isObject ( satisfiedTypes . get ( 1 ) ) ) ) return false ; return true ; } if ( containsRaw ( typeArg ) ) return true ; } return false ; } private void boxMethod ( Method method ) { if ( method == null ) return ; Declaration refined = CodegenUtil . getTopmostRefinedDeclaration ( method ) ; if ( refined == null || ( ! ( refined instanceof Method ) ) ) return ; Method refinedMethod = ( Method ) refined ; List < ParameterList > methodParameterLists = method . getParameterLists ( ) ; List < ParameterList > refinedParameterLists = refinedMethod . getParameterLists ( ) ; setBoxingState ( method , refinedMethod ) ; if ( methodParameterLists . isEmpty ( ) || refinedParameterLists . isEmpty ( ) ) return ; boxAndRawParameterLists ( methodParameterLists , refinedParameterLists ) ; } private void boxAndRawParameterLists ( List < ParameterList > paramLists , List < ParameterList > refinedParamLists ) { if ( paramLists . size ( ) !=", "gt": "refinedParamLists . size ( ) )", "prediction": ") ;\n", "label": 0}
{"id": 10594, "input": "<s> package org . eclipse . jface . dialogs ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; public class ControlEnableState { private List exceptions = null ; private List states ; private class ItemState { protected Control item ; protected boolean state ; public ItemState ( Control item , boolean state ) { this . item = item ; this . state = state ; } public void restore ( ) { if ( item == null || item . isDisposed ( ) ) { return ; } item . setEnabled ( state ) ; } } protected ControlEnableState ( Control w ) { this ( w , null ) ; } protected ControlEnableState ( Control w , List exceptions ) { super ( ) ; states = new ArrayList ( ) ; this . exceptions = exceptions ; readStateForAndDisable ( w ) ; } public static ControlEnableState disable ( Control w ) { return", "gt": "new ControlEnableState ( w ) ;", "prediction": ";\n", "label": 1}
{"id": 9781, "input": "<s> import java . util . * ; class CastTest { private class AA < T > { } private class AB < T > extends AA < T > { } private class AC < T > extends AA < Vector < T > > { } private class AD < T > extends AA < Vector < ? extends T > > { } private class AE < T > extends AA < Vector < ? super T > > { } private class AF < T > extends AA < T [ ] > { } private", "gt": "class AG < T > extends AA < String >", "prediction": "\n", "label": 0}
{"id": 10598, "input": "<s> package com . talis . hbase . rdf . layout . simple ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . ResultScanner ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . iterator . AbstractIterator ; public class HBaseRdfSingleTableIterator extends AbstractIterator < Triple > { ResultScanner scanner = null ; HBaseRdfSingleRowIterator rowIterator = null ; Node subject = null , predicate = null , object = null ; String columnFamily = null ; public HBaseRdfSingleTableIterator ( ResultScanner tableScanner , Node sm , Node pm , Node om , String columnFamily ) { this . scanner = tableScanner ; this . subject = sm ; this . predicate = pm ; this . object = om ; this . columnFamily = columnFamily ; } @ Override public void close ( ) { scanner . close ( ) ; } @ Override public boolean hasNext ( ) { try { if ( rowIterator == null || ! rowIterator . hasNext ( ) ) { Result rr = scanner . next ( ) ; if ( rr == null ) { rowIterator = null ; close ( ) ; return false ; } rowIterator = new HBaseRdfSingleRowIterator ( rr , subject , predicate , object , columnFamily ) ; rr = null ; } return rowIterator . hasNext ( ) ; } catch ( Exception e ) { throw new HBaseRdfException ( \"No next element found: \" , e ) ; } } @ Override public Triple _next ( ) { try { if ( rowIterator == null || !", "gt": "rowIterator . hasNext ( ) )", "prediction": ")\n", "label": 1}
{"id": 9160, "input": "<s> class ArrayDims3 { static Object y = new Object [ 1 ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ]", "gt": "[ ] [ ] [ ] ;", "prediction": ";\n", "label": 0}
{"id": 10609, "input": "<s> package org . eclipse . jface . viewers ; import java . util . List ; import org . eclipse . jface . viewers . CellEditor . LayoutData ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . TreeEditor ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; public class TreeViewerEditor extends ColumnViewerEditor { private TreeEditor treeEditor ; private SWTFocusCellManager focusCellManager ; TreeViewerEditor ( TreeViewer viewer , SWTFocusCellManager focusCellManager , ColumnViewerEditorActivationStrategy editorActivationStrategy , int feature ) { super ( viewer , editorActivationStrategy , feature ) ; treeEditor = new TreeEditor ( viewer . getTree ( ) ) ; this . focusCellManager = focusCellManager ; } public static void create ( TreeViewer viewer , SWTFocusCellManager focusCellManager , ColumnViewerEditorActivationStrategy editorActivationStrategy , int feature ) { TreeViewerEditor editor = new TreeViewerEditor ( viewer , focusCellManager , editorActivationStrategy , feature ) ; viewer . setColumnViewerEditor ( editor ) ; if ( focusCellManager != null ) { focusCellManager . init ( ) ; } } public static void create ( TreeViewer viewer , ColumnViewerEditorActivationStrategy editorActivationStrategy , int feature ) { create ( viewer , null , editorActivationStrategy , feature ) ; } protected void setEditor ( Control w , Item item , int fColumnNumber ) { treeEditor . setEditor ( w , ( TreeItem ) item , fColumnNumber ) ; } protected void setLayoutData ( LayoutData layoutData ) { treeEditor . grabHorizontal = layoutData . grabHorizontal ; treeEditor . horizontalAlignment = layoutData . horizontalAlignment ; treeEditor . minimumWidth = layoutData . minimumWidth ; treeEditor . verticalAlignment", "gt": "= layoutData . verticalAlignment ;", "prediction": ";\n", "label": 1}
{"id": 622, "input": "<s> package com . sap . prd . mobile . ios . mios ; import org . apache . maven . artifact . Artifact ; import org . apache . maven . artifact . handler . ArtifactHandler ; import org . sonatype . aether . util . artifact . DefaultArtifact ; class GAVUtil { static String toColonNotation ( String groupId , String artifactId , String version , String extension , String classifier ) { ensureNotNullOrEmpty ( groupId , \"groupId\" ) ; ensureNotNullOrEmpty ( artifactId , \"artifactId\" ) ; ensureNotNullOrEmpty ( version , \"version\" ) ; ensureNotNullOrEmpty ( extension , \"extension\" ) ; ensureNotNullOrEmpty ( classifier , \"classifier\" ) ; return groupId + \":\" + artifactId + \":\" + extension + \":\" + classifier + \":\" + version ; } private static void ensureNotNullOrEmpty ( String str , String parameterName ) { if ( str == null || str . isEmpty ( ) ) throw new IllegalStateException ( \"Value of parameter '\" + parameterName + \"' was null or empty.\" ) ; } static Artifact getArtifact ( String coords ) { DefaultArtifact aetherArtifact = new DefaultArtifact ( coords ) ; return new org . apache . maven . artifact . DefaultArtifact ( aetherArtifact . getGroupId ( ) , aetherArtifact . getArtifactId ( ) , aetherArtifact . getVersion ( ) , null , aetherArtifact . getExtension ( ) , aetherArtifact . getClassifier ( ) , null ) { @", "gt": "Override public String getScope ( )", "prediction": ";\n", "label": 0}
{"id": 10611, "input": "<s> package br . org . archimedes . copypaste ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.copypaste.messages\" ; public static String CommandFinished ; public static String PasteUndone ; public static String TargetExpected ; static { NLS .", "gt": "initializeMessages ( BUNDLE_NAME , Messages . class ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 2727, "input": "<s> package com . redhat . ceylon . ant ; import org . junit . runner . RunWith ; import org . junit . runners . Suite ; import org . junit . runners . Suite . SuiteClasses ; @ RunWith ( Suite . class ) @ SuiteClasses", "gt": "( ModuleDescriptorReaderTest . class ) public class AntToolTests", "prediction": ";\n", "label": 0}
{"id": 10625, "input": "<s> package org . nuxeo . ecm . platform . publisher . test ; import java . util . List ; import javax . naming . Context ; import javax . naming . InitialContext ; import org . junit . Before ; import org . junit . After ; import org . junit . Test ; import static org . junit . Assert . * ; import org . hsqldb . jdbc . jdbcDataSource ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . PathRef ; import org . nuxeo . ecm . core . storage . sql . SQLRepositoryTestCase ; import org . nuxeo . ecm . platform . publisher . api . PublisherService ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . jtajca . NuxeoContainer ; public class TestServiceWithMultipleDomains extends SQLRepositoryTestCase { protected DocumentModel doc2Publish ; public TestServiceWithMultipleDomains ( ) { super ( ) ; } public TestServiceWithMultipleDomains ( String name ) { super ( name ) ; } @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; NuxeoContainer . installNaming ( ) ; jdbcDataSource ds = new jdbcDataSource ( ) ; ds . setDatabase ( \"jdbc:hsqldb:mem:jena\" ) ; ds . setUser ( \"sa\" ) ; ds . setPassword ( \"\" ) ; NuxeoContainer . addDeepBinding ( \"java:comp/env/jdbc/nxrelations-default-jena\" , ds ) ; Framework . getProperties ( ) . setProperty ( \"org.nuxeo.ecm.sql.jena.databaseType\" , \"HSQL\" ) ; Framework . getProperties ( ) . setProperty ( \"org.nuxeo.ecm.sql.jena.databaseTransactionEnabled\" , \"false\" ) ; deployBundle ( \"org.nuxeo.ecm.core.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.content.template\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.types.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.types.core\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.versioning.api\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.versioning\" ) ; deployBundle ( \"org.nuxeo.ecm.relations\" ) ; deployBundle ( \"org.nuxeo.ecm.relations.jena\" ) ; deployContrib ( \"org.nuxeo.ecm.platform.publisher.test\" , \"OSGI-INF/relations-default-jena-contrib.xml\" ) ; deployContrib ( \"org.nuxeo.ecm.platform.publisher.test\" , \"OSGI-INF/publisher-content-template-contrib.xml\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.publisher.core.contrib\" ) ; deployBundle ( \"org.nuxeo.ecm.platform.publisher.core\" ) ; fireFrameworkStarted ( ) ; openSession ( ) ; } @ After public void tearDown ( ) throws Exception { try { closeSession ( ) ; } finally { if ( NuxeoContainer . isInstalled ( ) ) { NuxeoContainer . uninstall ( ) ; } super . tearDown ( ) ; } } protected void createInitialDocs ( String domainPath ) throws Exception { DocumentModel wsRoot = session . getDocument ( new PathRef ( domainPath + \"/workspaces\" ) ) ; DocumentModel ws = session . createDocumentModel ( wsRoot . getPathAsString ( ) , \"ws1\" , \"Workspace\" ) ; ws . setProperty ( \"dublincore\" , \"title\" , \"test WS\" ) ; ws = session . createDocument ( ws ) ; DocumentModel sectionsRoot = session . getDocument ( new PathRef ( domainPath + \"/sections\" ) ) ; DocumentModel section1 = session . createDocumentModel ( sectionsRoot . getPathAsString ( ) , \"section1\" , \"Section\" ) ; section1 . setProperty ( \"dublincore\" , \"title\" , \"section1\" ) ; section1 = session . createDocument ( section1 ) ; DocumentModel section2 = session . createDocumentModel ( sectionsRoot . getPathAsString ( ) , \"section2\" , \"Section\" ) ; section2 . setProperty ( \"dublincore\" , \"title\" , \"section2\" ) ; section2 = session . createDocument ( section2 ) ; DocumentModel section11 = session . createDocumentModel ( section1 . getPathAsString ( ) , \"section11\" , \"Section\" ) ; section11 . setProperty ( \"dublincore\" , \"title\" , \"section11\" ) ; section11 = session . createDocument ( section11 ) ; session . save ( ) ; } @ Test public void testTreeRegistration ( ) throws Exception { createInitialDocs ( \"default-domain\" ) ; createInitialDocs ( \"another-default-domain\" ) ; PublisherService", "gt": "service = Framework . getLocalService ( PublisherService . class ) ;", "prediction": ";\n", "label": 1}
{"id": 9901, "input": "<s> import static com . sun . tools . javac . util . Convert . enclosingCandidates ; import com . sun . tools . javac . util . * ; import java . util . Arrays ; import java . util . Locale ; public class EnclosingCandidates { Names names = Names . instance ( new Context ( ) ) ; void test ( String name , String ... expected ) { List < Name > result = enclosingCandidates ( names . fromString ( name ) ) ; if ( ! result . isEmpty ( ) || expected . length != 0 ) { Name [ ] expectedNames = new Name [ expected . length ] ; int i = 0 ; for ( String s : expected ) expectedNames [ i ++ ] = names . fromString ( s ) ; if ( ! Arrays . equals ( result . toArray ( ) , expectedNames ) ) throw new AssertionError ( name + \" : \" + Arrays . toString ( expectedNames ) + \" != \" + result ) ; } System . out . format ( ( Locale ) null , \"OK: %s -> [%s]%n\" , name , result ) ; } public static void main ( String ... args ) { EnclosingCandidates test =", "gt": "new EnclosingCandidates ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10653, "input": "<s> package org . apache . lucene . analysis ; import java . util . AbstractSet ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; public class CharArraySet extends AbstractSet { private final static int INIT_SIZE = 8 ; private char [ ] [ ] entries ; private int count ; private final boolean ignoreCase ; public CharArraySet ( int startSize , boolean ignoreCase ) { this . ignoreCase = ignoreCase ; int size = INIT_SIZE ; while ( startSize + ( startSize > > 2 ) > size ) size <<= 1 ; entries = new char [ size ] [ ] ; } public CharArraySet ( Collection c , boolean ignoreCase ) { this ( c . size ( ) , ignoreCase ) ; addAll ( c ) ; } private CharArraySet ( char [ ] [ ] entries , boolean ignoreCase , int count ) { this . entries = entries ; this . ignoreCase = ignoreCase ; this . count = count ; } public boolean contains ( char [ ] text , int off , int len ) { return entries [ getSlot ( text , off , len ) ] != null ; } public boolean contains ( CharSequence cs ) { return entries [ getSlot ( cs ) ] != null ; } private int getSlot ( char [ ] text , int off , int len ) { int code = getHashCode ( text , off , len ) ; int pos = code & ( entries . length - 1 ) ; char [ ] text2 = entries [ pos ] ; if ( text2 != null && ! equals ( text , off , len , text2 ) ) { final int inc = ( ( code > > 8 ) + code ) | 1 ; do { code += inc ; pos = code & ( entries . length - 1 ) ; text2 = entries [ pos ] ; } while ( text2 != null && ! equals ( text , off , len , text2 ) ) ; } return pos ; } private int getSlot ( CharSequence text ) { int code = getHashCode ( text ) ; int pos = code & ( entries . length - 1 ) ; char [ ] text2 = entries [ pos ] ; if ( text2 != null && ! equals ( text , text2 ) ) { final int inc = ( ( code > > 8 ) + code ) | 1 ; do { code += inc ; pos = code & ( entries . length - 1 ) ; text2 = entries [ pos ] ; } while ( text2 != null && ! equals ( text , text2 ) ) ; } return pos ; } public boolean add ( CharSequence text ) { return add ( text . toString ( ) ) ; } public boolean add ( String text ) { return add ( text . toCharArray ( ) ) ; } public boolean add ( char [ ] text ) { if ( ignoreCase ) for ( int i = 0 ; i < text . length ; i ++ ) text [ i ] = Character . toLowerCase ( text [ i ] ) ; int slot = getSlot ( text , 0 , text . length ) ; if ( entries [ slot ] != null ) return false ; entries [ slot ] = text ; count ++ ; if ( count + ( count > > 2 ) > entries . length ) { rehash ( ) ; } return true ; } private boolean equals ( char [ ] text1 , int off , int len , char [ ] text2 ) { if ( len != text2 . length ) return false ; if ( ignoreCase ) { for ( int i = 0 ; i < len ; i ++ ) { if ( Character . toLowerCase ( text1 [ off + i ] ) != text2 [ i ] ) return false ; } } else { for ( int i = 0 ; i < len ; i ++ ) { if ( text1 [ off + i ] != text2 [ i ] ) return false ; } } return true ; } private boolean equals ( CharSequence text1 , char [ ] text2 ) { int len = text1 . length ( ) ; if ( len != text2 . length ) return false ; if ( ignoreCase ) { for ( int i = 0 ; i < len ; i ++ ) { if ( Character . toLowerCase ( text1 . charAt ( i ) ) != text2 [ i ] ) return false ; } } else { for ( int i = 0 ; i < len ; i ++ ) { if ( text1 . charAt ( i ) != text2 [ i ] ) return false ; } } return true ; } private void rehash ( ) { final int newSize = 2 * entries . length ; char [ ] [ ] oldEntries = entries ; entries = new char [ newSize ] [ ] ; for ( int i = 0 ; i < oldEntries . length ; i ++ ) { char [ ] text = oldEntries [ i ] ; if ( text != null ) { entries [ getSlot ( text , 0 , text . length ) ] = text ; } } } private int getHashCode ( char [ ] text , int offset , int len ) { int code = 0 ; final int stop = offset + len ; if ( ignoreCase ) { for ( int i = offset ; i < stop ; i ++ ) { code = code * 31 + Character . toLowerCase ( text [ i ] ) ; } } else { for ( int i = offset ; i < stop ; i ++ ) { code = code * 31 + text [ i ] ; } } return code ; } private int getHashCode ( CharSequence text ) { int code = 0 ; int len = text . length ( ) ; if ( ignoreCase ) { for (", "gt": "int i = 0 ;", "prediction": ") ;\n", "label": 1}
{"id": 1797, "input": "<s> package y ; public final class R3 { x . B . C a = null ; x . C b = null ; R1 c", "gt": "= new R1 ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10655, "input": "<s> package com . rabbitmq . messagepatterns . unicast ; import com . rabbitmq . client . BasicProperties ; import com . rabbitmq . client . AMQP ; public interface Message { public AMQP . BasicProperties getProperties ( ) ; public void setProperties ( AMQP . BasicProperties properties ) ; public byte [ ] getBody ( ) ; public void setBody ( byte [ ] body ) ; public String getRoutingKey ( ) ; public void setRoutingKey ( String routingKey ) ; public String getFrom ( ) ; public void setFrom ( String from ) ; public", "gt": "String getTo ( ) ;", "prediction": "\n", "label": 1}
{"id": 4109, "input": "<s> package org . ofbiz . entity . sql ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . model . ModelViewEntity . ComplexAlias ; import org . ofbiz . entity . model . ModelViewEntity . ComplexAliasField ; import org . ofbiz . entity . model . ModelViewEntity . ComplexAliasMember ; import org . ofbiz . sql . ConstantValue ; import org . ofbiz . sql . FieldAll ; import org . ofbiz . sql . FieldDef ; import org . ofbiz . sql . FieldValue ; import org . ofbiz . sql . FunctionCall ; import org . ofbiz . sql . Joined ; import org . ofbiz . sql . KeyMap ; import org . ofbiz . sql . MathValue ; import org . ofbiz . sql . NumberValue ; import org . ofbiz . sql . OrderByItem ; import org . ofbiz . sql . Planner ; import org . ofbiz . sql . Relation ; import org . ofbiz . sql . SelectGroup ; import org . ofbiz . sql . SQLDelete ; import org . ofbiz . sql . SQLInsert ; import org . ofbiz . sql . SQLSelect ; import org . ofbiz . sql . SQLUpdate ; import org . ofbiz . sql . SQLView ; import org . ofbiz . sql . StaticValue ; import org . ofbiz . sql . StringValue ; import org . ofbiz . sql . Table ; import org . ofbiz . sql . TableName ; import org . ofbiz . sql . Unioned ; import org . ofbiz . sql . Value ; public class EntityPlanner extends Planner < EntityPlanner , EntityCondition , EntityDeletePlan , EntityInsertPlan , EntitySelectPlan , EntityUpdatePlan , EntityViewPlan > { public EntityPlanner ( ) { super ( new EntityConditionPlanner ( ) ) ; } @ Override public EntityDeletePlan planDelete ( SQLDelete deleteStatement ) { return null ; } @ Override public EntityInsertPlan planInsert ( SQLInsert insertStatement ) { return null ; } @ Override public EntitySelectPlan planSelect ( SQLSelect selectStatement ) { DynamicViewEntity dve = new DynamicViewEntity ( ) ; Unioned unioned = selectStatement . getUnioned ( ) ; if ( unioned != null ) { throw new IllegalArgumentException ( \"union views not yet supported\" ) ; } SelectGroup selectGroup = unioned . getGroup ( ) ; Table table = selectGroup . getTable ( ) ; addMember ( dve , table . getTableName ( ) ) ; addJoined ( dve , table . getTableName ( ) . getAlias ( ) , table . getJoined ( ) ) ; if ( selectGroup . getFieldAlls ( ) != null ) { for ( FieldAll fieldAll : selectGroup . getFieldAlls ( ) ) { List < String > excludes = FastList . newInstance ( ) ; for ( String exclude : fieldAll ) { excludes . add ( exclude ) ; } if ( excludes . isEmpty ( ) ) { excludes = null ; } dve . addAliasAll ( fieldAll . getAlias ( ) , null , excludes ) ; } } if ( selectStatement . getRelations ( ) != null ) { for ( Relation relation : selectStatement . getRelations ( ) . values ( ) ) { dve . addRelation ( relation . getType ( ) , relation . getTitle ( ) , relation . getEntityName ( ) , buildKeyMaps ( relation ) ) ; } } List < String > groupBy = selectGroup . getGroupBy ( ) ; if ( groupBy == null ) { groupBy = Collections . emptyList ( ) ; } if ( selectGroup . getFieldDefs ( ) != null ) { for ( FieldDef fieldDef : selectGroup . getFieldDefs ( ) ) { addFieldDef ( dve , groupBy , fieldDef . getAlias ( ) , fieldDef ) ; } } List < String > orderBy ; if ( selectStatement . getOrderBy ( ) == null ) { orderBy = null ; } else { orderBy = FastList . newInstance ( ) ; for ( OrderByItem orderByItem : selectStatement . getOrderBy ( ) ) { orderBy . add ( orderByItem . toString ( ) ) ; } } return new EntitySelectPlan ( dve , plan ( selectGroup . getWhereCondition ( ) ) , plan ( selectGroup . getHavingCondition ( ) ) , orderBy ) ; } @ Override public EntityUpdatePlan planUpdate ( SQLUpdate updateStatement ) { return null ; } @ Override public EntityViewPlan planView ( SQLView viewStatement ) { return null ; } private static void addFieldDef ( DynamicViewEntity dve , List < String > groupBy , String alias , FieldDef fieldDef ) { StaticValue value = fieldDef . getValue ( ) ; if ( value instanceof FieldValue ) { addFieldDef ( dve , groupBy , fieldDef . getAlias ( ) , ( FieldValue ) value , null ) ; } else if ( value instanceof ConstantValue ) { addFieldDef ( dve , groupBy , fieldDef . getAlias ( ) , value ) ; } else { throw new UnsupportedOperationException ( alias + \"[\" + fieldDef + \"]:\" + fieldDef . getClass ( ) ) ; } } private static void addFieldDef ( DynamicViewEntity dve , List < String > groupBy , String alias , FieldValue fieldValue , String function ) { dve . addAlias ( fieldValue . getTableName ( ) , alias , fieldValue . getFieldName ( ) , null , null , groupBy . contains ( alias ) , function ) ; } private static void addFieldDef ( DynamicViewEntity dve , List < String > groupBy , String alias , ComplexAliasMember member ) { dve . addAlias ( null , alias , null , null , null , groupBy . contains ( alias ) , null , member ) ; } private static void addFieldDef ( DynamicViewEntity dve , List < String > groupBy , String alias , ConstantValue value ) { if ( value instanceof FieldValue ) { addFieldDef ( dve , groupBy , alias , ( FieldValue ) value , null ) ; return ; } else if ( value instanceof FunctionCall ) { FunctionCall fc = ( FunctionCall ) value ; String name = fc . getName ( ) . toLowerCase ( ) ; Iterator < Value > it = fc . iterator ( ) ; if ( it . hasNext ( ) ) { Value firstValue = it . next ( ) ; if ( ! it . hasNext ( ) ) { if ( firstValue instanceof FieldValue ) { addFieldDef ( dve , groupBy , alias , (", "gt": "FieldValue ) firstValue , name ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 10657, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; public class L1FSFresnelLens extends FSFresnelLens { public L1FSFresnelLens ( ) { super ( ) ; } public L1FSFresnelLens ( float mm , int ns ) { super ( mm , ns ) ; } public L1FSFresnelLens ( float mm , int outerRadius , int innerRadius , int ns ) { super ( mm , outerRadius , innerRadius , ns ) ; } public L1FSFresnelLens ( float mm , int outerRadius , int innerRadius , int ns , int x , int y ) { super ( mm , outerRadius , innerRadius , ns , x , y ) ; } public void gf ( float x , float y , float [ ] g ) { d = Math . abs ( x - sw - lx ) + Math . abs ( y - sh - ly ) ; if ( d <= LR2 ) g [ 0 ] = g [ 1 ] = MM ; else if ( d <= LR1 ) { for ( int i = 0 ; i < Ri . length ; i ++ ) { if ( d <= Ri [ i ] ) { g [ 0 ] = g [ 1 ] = MMi [ i ] ; break ; } } } else g [ 0 ] = g [ 1 ] = 1 ; } public void drawBoundary ( Graphics2D g2d ) { if ( r1Color != null ) { g2d . setColor ( r1Color ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 - LR1 , lx + w / 2 + LR1 , ly + h / 2 ) ; g2d . drawLine ( lx + w / 2 + LR1 , ly + h / 2 , lx + w / 2 , ly + h / 2 + LR1 ) ; g2d . drawLine ( lx + w / 2 , ly + h / 2 + LR1 , lx + w / 2 - LR1 ,", "gt": "ly + h / 2 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2475, "input": "<s> package org . ofbiz . webapp . stats ; import java . net . InetAddress ; import java . util . Date ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import com . ibm . icu . util . Calendar ; public class ServerHitBin { public static final String module = ServerHitBin . class . getName ( ) ; public static final int REQUEST = 1 ; public static final int EVENT = 2 ; public static final int VIEW = 3 ; public static final int ENTITY = 4 ; public static final int SERVICE = 5 ; public static final String [ ] typeNames = { \"\" , \"Request\" , \"Event\" , \"View\" , \"Entity\" , \"Service\" } ; public static final String [ ] typeIds = { \"\" , \"REQUEST\" , \"EVENT\" , \"VIEW\" , \"ENTITY\" , \"SERVICE\" } ; public static void countRequest ( String id , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { countHit ( id , REQUEST , request , startTime , runningTime , userLogin ) ; } public static void countEvent ( String id , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { countHit ( id , EVENT , request , startTime , runningTime , userLogin ) ; } public static void countView ( String id , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { countHit ( id , VIEW , request , startTime , runningTime , userLogin ) ; } public static void countEntity ( String id , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { countHit ( id , ENTITY , request , startTime , runningTime , userLogin ) ; } public static void countService ( String id , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { countHit ( id , SERVICE , request , startTime , runningTime , userLogin ) ; } public static void countHit ( String id , int type , HttpServletRequest request , long startTime , long runningTime , GenericValue userLogin ) { if ( ! \"true\" . equals ( UtilProperties . getPropertyValue ( \"serverstats\" , \"stats.enable.\" + typeIds [ type ] ) ) ) return ; countHit ( id , type , request , startTime , runningTime , userLogin , true ) ; } public static void advanceAllBins ( long toTime ) { advanceAllBins ( toTime , requestHistory ) ; advanceAllBins ( toTime , eventHistory ) ; advanceAllBins ( toTime , viewHistory ) ; advanceAllBins ( toTime , entityHistory ) ; advanceAllBins ( toTime , serviceHistory ) ; } static void advanceAllBins ( long toTime , Map < String , List < ServerHitBin > > binMap ) { for ( Map . Entry < String , List < ServerHitBin > > entry : binMap . entrySet ( ) ) { if (", "gt": "entry . getValue ( ) != null )", "prediction": ") ;\n", "label": 0}
{"id": 10660, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . core . exceptions . ArchException ; import org . fuzzydb . expressions . LogicExpr ; public class QueryCmd extends TransactionCommand { private static final long serialVersionUID = 1L ; private final String namespace ; private final String forClass ; private final LogicExpr index ; private final LogicExpr expr ; private final int fetchSize ; private int qid ; private QueryCmd ( ) { super ( - 1 , - 1 , - 1 ) ; this . namespace = null ; this . forClass = null ; this . index = null ; this . expr = null ; this . fetchSize = 0 ; } public QueryCmd ( int storeId , String namespace , int cid , int tid , int qid , Class < ? > forClass , LogicExpr index , LogicExpr expr , int fetchSize ) { super ( storeId , cid , tid ) ; this . namespace = namespace ; this . qid = qid ; this . forClass = forClass", "gt": ". getCanonicalName ( ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 7766, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . entity . WaterMob ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaLivingEntity ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWaterMob ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftWaterMob implements LizaWaterMob { private WaterMob waterMob ; public LizaCraftWaterMob ( WaterMob waterMob ) { this . waterMob = waterMob ; } @ Override public LizaLivingEntity getTarget ( ) { return new LizaCraftLivingEntity ( this . waterMob . getTarget ( ) ) ; } @ Override public void setTarget ( LivingEntity target ) { this . waterMob . setTarget ( target ) ; } @ Override public void damage ( int amount ) { this . waterMob . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . waterMob . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . waterMob . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . waterMob . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . waterMob . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . waterMob . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . waterMob . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . waterMob . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . waterMob . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . waterMob . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . waterMob . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . waterMob . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . waterMob . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . waterMob . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . waterMob . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > transparent , int maxDistance ) { return new LizaCraftBlock ( this . waterMob . getTargetBlock ( transparent , maxDistance ) ) ; } @ Override public LizaVehicle getVehicle ( ) { return new LizaCraftVehicle ( this . waterMob . getVehicle ( ) ) ; }", "gt": "@ Override public boolean isInsideVehicle ( )", "prediction": "}\n", "label": 0}
{"id": 10676, "input": "<s> package org . eclipse . ui . internal . presentations ; import org . eclipse . jface . action . IAction ; public interface ISelfUpdatingAction extends IAction { public", "gt": "void update ( ) ;", "prediction": "\n", "label": 1}
{"id": 2155, "input": "<s> import java . io . * ; import java . util . zip . * ; public class T4876942 { public static void main ( String [ ] args ) throws Exception { new T4876942 ( ) . run ( ) ; } public void run ( ) throws IOException { String output = javap ( ) ; verify ( output , \"-public\" , \"-protected\" , \"-private\" ) ; if ( errors > 0 ) throw new Error ( errors + \" found.\" ) ; } String javap ( String ... args ) { StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; int rc = com . sun . tools .", "gt": "javap . Main . run ( args , out ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10694, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" } ) @ XmlRootElement ( name = \"DeleteList\" ) public class DeleteList { protected String listName ; public String getListName ( ) { return listName ; } public void", "gt": "setListName ( String value )", "prediction": "( )\n", "label": 1}
{"id": 838, "input": "<s> package com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 ; import javax . xml . bind . annotation . XmlType ; @ XmlType ( propOrder = { \"groupId\" , \"artifactId\" , \"version\" } ) public class Coordinates { private String groupId ; private String artifactId ; private String version ; public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getArtifactId ( ) { return artifactId ; } public void setArtifactId ( String artifactId ) { this . artifactId = artifactId ; } public String getVersion ( ) { return version ; } public", "gt": "void setVersion ( String version )", "prediction": "void ( )\n", "label": 0}
{"id": 10710, "input": "<s> package org . eclipse . ui . internal . cheatsheets . actions ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . window . Window ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . cheatsheets . dialogs . CheatSheetCategoryBasedSelectionDialog ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetCollectionElement ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetRegistryReader ; public class CheatSheetCategoryBasedSelectionAction extends Action { public CheatSheetCategoryBasedSelectionAction ( ) { } public CheatSheetCategoryBasedSelectionAction ( String text ) { super ( text ) ; } public CheatSheetCategoryBasedSelectionAction ( String text , ImageDescriptor image ) { super ( text , image ) ; } public void run ( ) { CheatSheetCollectionElement cheatSheets = ( CheatSheetCollectionElement ) CheatSheetRegistryReader . getInstance ( ) . getCheatSheets ( ) ; CheatSheetCategoryBasedSelectionDialog dialog = new CheatSheetCategoryBasedSelectionDialog ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , cheatSheets ) ; if ( dialog . open ( ) != Window . OK || ! dialog . getStatus ( ) . isOK ( ) ) {", "gt": "notifyResult ( false ) ;", "prediction": "}\n", "label": 1}
{"id": 7506, "input": "<s> package com . deliciousdroid . activity ; import com . deliciousdroid . Constants ; import com . deliciousdroid . providers . BookmarkContentProvider ; import android . app . ActivityGroup ; import android . content . Intent ; import android . database . Cursor ; import android . net . Uri ; import android . os . Bundle ; import android . provider . ContactsContract ; import android . util . Log ; import android . webkit . WebView ; public class Profile extends ActivityGroup { WebView mWebView ; @ Override public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; Intent i = getIntent ( ) ; Uri contact = Uri . parse ( i . getDataString ( ) ) ; Cursor c = managedQuery ( contact , null , null , null , null ) ; int userNameCol = c . getColumnIndex ( ContactsContract . Data . DATA1 ) ; String userName = \"\" ; try { if ( c . moveToFirst ( ) ) { userName = c . getString ( userNameCol ) ; Log . d ( \"username\" , userName ) ; } } finally { if ( c != null ) { c . close ( ) ; } } Intent bookmarkBrowseIntent = new Intent ( this , BrowseBookmarks . class ) ; bookmarkBrowseIntent . setAction ( Intent . ACTION_VIEW ) ; bookmarkBrowseIntent . addCategory ( Intent . CATEGORY_DEFAULT ) ; Uri . Builder data = new Uri . Builder ( ) ; data . scheme ( Constants . CONTENT_SCHEME ) ; data . encodedAuthority ( userName + \"@\" + BookmarkContentProvider . AUTHORITY ) ; data . appendEncodedPath ( \"bookmarks\" ) ; bookmarkBrowseIntent . setData (", "gt": "data . build ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10717, "input": "<s> package org . eclipse . swt . widgets ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . * ; public class CoolItem extends Item { Control control ; CoolBar parent ; boolean ideal ; int preferredWidth , preferredHeight , minimumWidth , minimumHeight , requestedWidth ; Rectangle itemBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; static final int MARGIN_WIDTH = 4 ; static final int GRABBER_WIDTH = 2 ; static final int MINIMUM_WIDTH = ( 2 * MARGIN_WIDTH ) + GRABBER_WIDTH ; private int CHEVRON_HORIZONTAL_TRIM = - 1 ; private int CHEVRON_VERTICAL_TRIM = - 1 ; private static final int CHEVRON_LEFT_MARGIN = 2 ; private static final int CHEVRON_IMAGE_WIDTH = 8 ; ToolBar chevron ; boolean wrap ; Image arrowImage = null ; private List < SelectionListener > selectionListeners ; public CoolItem ( CoolBar parent , int style ) { super ( parent , style ) ; this . parent = parent ; parent . createItem ( this , parent . getItemCount ( ) ) ; calculateChevronTrim ( ) ; } public CoolItem ( CoolBar parent , int style , int index ) { super ( parent , style ) ; this . parent = parent ; parent . createItem ( this , index ) ; calculateChevronTrim ( ) ; } public void addSelectionListener ( SelectionListener listener ) { checkWidget ( ) ; if ( listener == null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( selectionListeners == null ) { selectionListeners = new ArrayList < SelectionListener > ( ) ; } selectionListeners . add ( listener ) ; } protected void checkSubclass ( ) { } void calculateChevronTrim ( ) { ToolBar tb = new ToolBar ( parent , SWT . FLAT ) ; ToolItem ti = new ToolItem ( tb , SWT . PUSH ) ; Point size = tb . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; size = parent . fixPoint ( size . x , size . y ) ; CHEVRON_HORIZONTAL_TRIM = size . x - 1 ; CHEVRON_VERTICAL_TRIM = size . y - 1 ; tb . dispose ( ) ; ti . dispose ( ) ; } public Point computeSize ( int wHint , int hHint ) { checkWidget ( ) ; int width = wHint , height = hHint ; if ( wHint == SWT . DEFAULT ) width = 32 ; if ( hHint == SWT . DEFAULT ) height = 32 ; if ( ( parent . style & SWT . VERTICAL ) != 0 ) { height += MINIMUM_WIDTH ; } else { width += MINIMUM_WIDTH ; } return new Point ( width , height ) ; } public void dispose ( ) { if ( isDisposed ( ) ) return ; parent . destroyItem ( this ) ; super . dispose ( ) ; parent = null ; control = null ; if ( chevron != null && ! chevron . isDisposed ( ) ) chevron . dispose ( ) ; chevron = null ; arrowImage = null ; } public Rectangle getBounds ( ) { checkWidget ( ) ; return parent . fixRectangle ( itemBounds . x , itemBounds . y , itemBounds . width , itemBounds . height ) ; } Rectangle internalGetBounds ( ) { return new Rectangle ( itemBounds . x , itemBounds . y , itemBounds", "gt": ". width , itemBounds . height ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10099, "input": "<s> package org . dawb . workbench . plotting . views ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . dawb . common . ui . plot . EmptyTool ; import org . dawb . common . ui . plot . IPlottingSystem ; import org . dawb . common . ui . plot . tool . IToolChangeListener ; import org . dawb . common . ui . plot . tool . IToolPage ; import org . dawb . common . ui . plot . tool . IToolPage . ToolPageRole ; import org . dawb . common . ui . plot . tool . IToolPageSystem ; import org . dawb . common . ui . plot . tool . ToolChangeEvent ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . common . util . text . StringUtils ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . core . commands . common . EventManager ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . IPostSelectionProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . IURIEditorInput ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . SubActionBars ; import org . eclipse . ui . cheatsheets . OpenCheatSheetAction ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . util . Util ; import org . eclipse . ui . part . IPage ; import org . eclipse . ui . part . IPageBookViewPage ; import org . eclipse . ui . part . IPageSite ; import org . eclipse . ui . part . PageBook ; import org . eclipse . ui . part . ViewPart ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ToolPageView extends ViewPart implements IPartListener , IToolChangeListener { private PageBook book ; private PageRec defaultPageRec ; private Map < IToolPage , IPageSite > mapToolToSite = new HashMap < IToolPage , IPageSite > ( 7 ) ; private Map < IToolPage , Integer > mapToolToNumRecs = new HashMap < IToolPage , Integer > ( 7 ) ; private PageRec activeRec ; private IWorkbenchPart hiddenPart = null ; private static final Logger logger = LoggerFactory . getLogger ( ToolPageView . class ) ; public static final String ID = \"org.dawb.workbench.plotting.views.ToolPageView\" ; private Collection < IToolPageSystem > systems ; private Map < String , Map < String , PageRec > > recs ; private String unique_id ; public ToolPageView ( ) { super ( ) ; this . unique_id = StringUtils . getUniqueId ( ToolPageView . class ) ; this . systems = new HashSet < IToolPageSystem > ( 7 ) ; this . recs = new HashMap < String , Map < String , PageRec > > ( 7 ) ; } protected IToolPage createDefaultPage ( PageBook book ) { EmptyTool emptyTool = new EmptyTool ( getViewRole ( ) ) { public String toString ( ) { return \"Default page\" ; } } ; emptyTool . setTitle ( \"No tool\" ) ; initPage ( emptyTool ) ; emptyTool . createControl ( book ) ; return emptyTool ; } private IPropertyChangeListener actionBarPropListener = new IPropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( SubActionBars . P_ACTION_HANDLERS ) && activeRec != null && event . getSource ( ) == activeRec . subActionBars ) { refreshGlobalActionHandlers ( ) ; } } } ; private ISelectionChangedListener selectionChangedListener = new ISelectionChangedListener ( ) { public void selectionChanged ( SelectionChangedEvent event ) { pageSelectionChanged ( event ) ; } } ; private ISelectionChangedListener postSelectionListener = new ISelectionChangedListener ( ) { public void selectionChanged ( SelectionChangedEvent event ) { postSelectionChanged ( event ) ; } } ; private SelectionProvider selectionProvider", "gt": "= new SelectionProvider ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10736, "input": "<s> package org . eclipse . jface . internal ; public class InternalPolicy { public static boolean DEBUG_LOG_REENTRANT_VIEWER_CALLS = false ; public", "gt": "static boolean DEBUG_LOG_LABEL_PROVIDER_NOTIFICATIONS_WHEN_DISPOSED = false ;", "prediction": "void ( ) ;\n", "label": 1}
{"id": 6772, "input": "<s> package org . gk . engine . client . event . attrib ; import org . gk . engine . client . build . XComponent ; import com . extjs . gxt . ui . client . widget . Component ; public class DataAttribute implements IAttribute { @ Override public Object getAttributeValue ( Component com ) { return com . getData", "gt": "( XComponent . DATA ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10754, "input": "<s> package org . jscsi . parser . nop ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . Constants ; import org . jscsi . parser . InitiatorMessageParser ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . utils . Utils ; public final class NOPOutParser extends InitiatorMessageParser { protected int targetTransferTag ; public NOPOutParser ( final ProtocolDataUnit initProtocolDataUnit ) { super ( initProtocolDataUnit ) ; } public final int getTargetTransferTag ( ) { return targetTransferTag ; } @ Override public final String toString ( ) { final StringBuilder sb = new StringBuilder ( Constants . LOG_INITIAL_SIZE ) ; Utils . printField ( sb , \"LUN\" , logicalUnitNumber , 1 ) ; Utils . printField ( sb , \"Target Transfer Tag\" , targetTransferTag , 1 ) ; sb . append ( super . toString ( ) ) ; return sb . toString ( ) ; } @ Override public final DataSegmentFormat getDataSegmentFormat ( ) { return DataSegmentFormat . BINARY ; } @ Override public final void clear ( ) { super . clear ( ) ; targetTransferTag = 0x00000000 ; } @ Override protected final void deserializeBytes1to3 ( final int line ) throws InternetSCSIException { Utils . isReserved ( line & Constants . LAST_THREE_BYTES_MASK ) ; } @ Override protected final void", "gt": "deserializeBytes20to23 ( final int line ) throws InternetSCSIException", "prediction": "( )\n", "label": 1}
{"id": 8695, "input": "<s> package com . mobeelizer . mobile . android . types ; import static junit . framework . Assert . assertTrue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import static org . mockito . Matchers . anyString ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . powermock . core . classloader . annotations . PrepareForTest ; import org . powermock . modules . junit4 . PowerMockRunner ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . DatabaseUtils ; import com . mobeelizer . java . api . MobeelizerErrorsBuilder ; import com . mobeelizer . java . model . MobeelizerFieldAccessor ; import com . mobeelizer . java . model . MobeelizerReflectionUtil ; import com . mobeelizer . java . model . ReflectionMobeelizerFieldAccessor ; import com . mobeelizer . mobile . android . TestEntity ; @ RunWith ( PowerMockRunner . class ) @ PrepareForTest ( { DateFieldTypeHelper . class , ContentValues . class , DatabaseUtils . class } ) public class DateFieldTypeHelperTest { private MobeelizerFieldAccessor fieldDate ; private MobeelizerFieldAccessor fieldCalendar ; private MobeelizerFieldAccessor fieldLongO ; private MobeelizerFieldAccessor fieldLongP ; @ Before public void init ( ) { HashSet < Class < ? > > types = new HashSet < Class < ? > > ( Arrays . asList ( new Class < ? > [ ] { Date . class , Long . class , Long . TYPE , Calendar . class } ) ) ; fieldLongO = new ReflectionMobeelizerFieldAccessor ( MobeelizerReflectionUtil . getField ( TestEntity . class , \"longO\" , types ) ) ; fieldLongP = new ReflectionMobeelizerFieldAccessor ( MobeelizerReflectionUtil . getField ( TestEntity . class , \"longP\" , types ) ) ; fieldDate = new ReflectionMobeelizerFieldAccessor ( MobeelizerReflectionUtil . getField ( TestEntity . class , \"date\" , types ) ) ; fieldCalendar = new ReflectionMobeelizerFieldAccessor ( MobeelizerReflectionUtil . getField ( TestEntity . class , \"calendar\" , types ) ) ; } @ Test public void shouldInsertIntoEnum ( ) throws Exception { Field helperField = FieldType . DATE . getClass ( ) . getDeclaredField ( \"helper\" ) ; helperField . setAccessible ( true ) ; Object helper = helperField . get ( FieldType . DATE ) ; assertTrue ( helper instanceof DateFieldTypeHelper ) ; } @ Test public void shouldGetAccessibleTypes ( ) throws Exception { Set < Class < ? > > types = FieldType . DATE . getType ( ) . getAccessibleTypes ( ) ; assertEquals ( 4 , types . size ( ) ) ; assertTrue ( types . contains ( Long . class ) ) ; assertTrue ( types . contains ( Long . TYPE ) ) ; assertTrue ( types . contains ( Date . class ) ) ; assertTrue ( types . contains ( Calendar . class ) ) ; } @ Test public void shouldSetValueFromEntityToDatabase ( ) throws Exception { shouldSetValueFromEntityToDatabase ( fieldDate , new Date ( 10L ) , 10L ) ; shouldSetValueFromEntityToDatabase ( fieldLongP , 11L , 11L ) ; shouldSetValueFromEntityToDatabase ( fieldLongO , Long . valueOf ( 12L ) , 12L ) ; Calendar c = Calendar . getInstance ( ) ; c . setTime ( new Date ( 13L ) ) ; shouldSetValueFromEntityToDatabase ( fieldCalendar , c , 13L ) ; } private void shouldSetValueFromEntityToDatabase ( final MobeelizerFieldAccessor field , final Object entityValue , final Long contentValue ) { Map < String , String > options = new HashMap < String , String > ( ) ; ContentValues values = mock ( ContentValues . class ) ; MobeelizerErrorsBuilder errors = mock ( MobeelizerErrorsBuilder . class ) ; when ( errors . hasNoErrors ( ) ) . thenReturn ( true ) ; TestEntity entity = new TestEntity ( ) ; try { field . set ( entity , entityValue ) ; } catch ( IllegalArgumentException e ) { throw new IllegalStateException ( e . getMessage ( ) , e ) ; } FieldType . DATE . setValueFromEntityToDatabase ( values , entity , field , true , options , errors ) ; verify ( values ) . put ( field . getName ( ) , contentValue ) ; } @ Test public void shouldSetErrorWhileSetNullValueFromEntityToDatabase ( ) throws Exception { Map < String , String > options = new HashMap < String , String > ( ) ; ContentValues values = mock ( ContentValues . class ) ; MobeelizerErrorsBuilder errors = mock ( MobeelizerErrorsBuilder . class ) ; TestEntity entity = new TestEntity ( ) ; FieldType . DATE . setValueFromEntityToDatabase ( values , entity , fieldDate , true , options , errors ) ; verify ( values , never ( ) ) . put ( eq ( \"date\" ) , anyString ( ) ) ; verify ( errors ) . addFieldCanNotBeEmpty ( \"date\" ) ; } @ Test public void shouldSetValueFromDatabaseToEntity ( ) throws Exception { shouldSetValueFromDatabaseToEntity ( fieldDate , 10L , new Date ( 10L ) ) ; shouldSetValueFromDatabaseToEntity ( fieldLongO , 11L , Long . valueOf ( 11L ) ) ; shouldSetValueFromDatabaseToEntity ( fieldLongP , 12L , 12L ) ; Calendar c = Calendar . getInstance ( ) ; c . setTime ( new Date ( 13L ) ) ; shouldSetValueFromDatabaseToEntity ( fieldCalendar , 13L , c ) ; } private void shouldSetValueFromDatabaseToEntity ( final MobeelizerFieldAccessor field , final Long databaseValue , final Object entityValue ) { Map < String , String > options = new HashMap < String , String > ( ) ; TestEntity entity = new TestEntity ( ) ; Cursor cursor = mock ( Cursor . class ) ; when ( cursor . getColumnIndex ( field . getName ( ) ) ) . thenReturn ( 13 ) ; when ( cursor . isNull ( 13 ) ) . thenReturn ( false ) ; when ( cursor . getLong ( 13 ) ) . thenReturn ( databaseValue ) ; FieldType . DATE . setValueFromDatabaseToEntity ( cursor , entity , field , options ) ; try { assertEquals ( entityValue , field . get ( entity ) ) ; } catch ( IllegalArgumentException e ) { throw new", "gt": "IllegalStateException ( e . getMessage ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10772, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import com . emf4sw . owl . DataMaxCardinality ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . OWLPackage ; public class DataMaxCardinalityImpl extends DataPropertyRestrictionImpl implements DataMaxCardinality { protected static final int CARDINALITY_EDEFAULT = 0 ; protected int cardinality = CARDINALITY_EDEFAULT ; protected DataRange dataRange ; protected DataProperty property ; protected DataMaxCardinalityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . DATA_MAX_CARDINALITY ; } public int getCardinality ( ) { return cardinality ; } public void setCardinality ( int newCardinality ) { int oldCardinality = cardinality ; cardinality = newCardinality ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MAX_CARDINALITY__CARDINALITY , oldCardinality , cardinality ) ) ; } public DataRange getDataRange ( ) { if ( dataRange != null && dataRange . eIsProxy ( ) ) { InternalEObject oldDataRange = ( InternalEObject ) dataRange ; dataRange = ( DataRange ) eResolveProxy ( oldDataRange ) ; if ( dataRange != oldDataRange ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MAX_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } } return dataRange ; } public DataRange basicGetDataRange ( ) { return dataRange ; } public void setDataRange ( DataRange newDataRange ) { DataRange oldDataRange = dataRange ; dataRange = newDataRange ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MAX_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } public DataProperty getProperty ( ) { if ( property != null && property . eIsProxy ( ) ) { InternalEObject oldProperty = ( InternalEObject ) property ; property = ( DataProperty ) eResolveProxy ( oldProperty ) ; if ( property != oldProperty ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MAX_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } } return property ; } public DataProperty basicGetProperty ( ) { return property ; } public void setProperty ( DataProperty newProperty ) { DataProperty oldProperty = property ; property = newProperty ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MAX_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . DATA_MAX_CARDINALITY__CARDINALITY : return getCardinality ( ) ; case OWLPackage . DATA_MAX_CARDINALITY__DATA_RANGE : if ( resolve )", "gt": "return getDataRange ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2947, "input": "<s> package org . ofbiz . minilang . method . ifops ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MessageElement ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . security . Security ; import org . w3c . dom . Element ; public final class CheckPermission extends MethodOperation { private final List < PermissionInfo > altPermissionInfoList ; private final FlexibleMapAccessor < List < String > > errorListFma ; private final MessageElement messageElement ; private final PermissionInfo primaryPermissionInfo ; public CheckPermission ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"permission\" , \"action\" , \"error-list-name\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"error-list-name\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"alt-permission\" , \"fail-message\" , \"fail-property\" ) ; MiniLangValidate . requireAnyChildElement ( simpleMethod , element , \"fail-message\" , \"fail-property\" ) ; } errorListFma = FlexibleMapAccessor . getInstance ( MiniLangValidate . checkAttribute ( element . getAttribute ( \"error-list-name\" ) , \"error_list\" ) ) ; primaryPermissionInfo = new PermissionInfo ( element ) ; List < ? extends Element > altPermElements = UtilXml . childElementList ( element , \"alt-permission\" ) ; if ( ! altPermElements . isEmpty ( ) ) { List < PermissionInfo > permissionInfoList = new ArrayList < PermissionInfo > ( altPermElements . size ( ) ) ; for ( Element altPermElement : altPermElements ) { permissionInfoList . add ( new PermissionInfo ( altPermElement ) ) ; } altPermissionInfoList = Collections . unmodifiableList ( permissionInfoList ) ; } else { altPermissionInfoList = null ; } messageElement = MessageElement . fromParentElement ( element , simpleMethod ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { boolean hasPermission = false ; GenericValue userLogin = methodContext . getUserLogin ( ) ; if ( userLogin != null ) { Security security = methodContext . getSecurity ( ) ; hasPermission = this . primaryPermissionInfo . hasPermission ( methodContext , userLogin , security ) ; if ( ! hasPermission && altPermissionInfoList != null ) { for ( PermissionInfo altPermInfo : altPermissionInfoList ) { if ( altPermInfo . hasPermission ( methodContext , userLogin , security ) ) { hasPermission = true ; break ; } } } } if ( ! hasPermission && messageElement != null ) { List < String > messages = errorListFma . get ( methodContext . getEnvMap ( ) ) ; if ( messages == null ) { messages = FastList . newInstance ( ) ; errorListFma . put ( methodContext . getEnvMap ( ) , messages ) ; } messages . add ( messageElement . getMessage ( methodContext ) ) ; } return true ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<check-permission \" ) ; sb . append ( \"permission=\\\"\" ) . append ( this . primaryPermissionInfo . permissionFse ) . append ( \"\\\" \" ) ; if ( ! this . primaryPermissionInfo . actionFse . isEmpty ( ) ) { sb . append ( \"action=\\\"\" ) . append ( this . primaryPermissionInfo . actionFse ) . append ( \"\\\" \" ) ; } if ( ! \"error_list\" . equals ( this . errorListFma . getOriginalName ( ) ) ) { sb . append ( \"error-list-name=\\\"\" ) . append ( this . errorListFma ) . append ( \"\\\" \" ) ; } if ( messageElement != null ) { sb . append ( \">\" ) . append ( messageElement ) . append ( \"</check-permission>\" ) ; } else { sb . append ( \"/>\" ) ; } return sb . toString ( ) ; } public static final class CheckPermissionFactory implements Factory < CheckPermission > { @ Override public CheckPermission createMethodOperation ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { return new CheckPermission ( element , simpleMethod ) ; } @ Override public String getName ( ) { return \"check-permission\" ; } } private class PermissionInfo { private final FlexibleStringExpander actionFse ; private final FlexibleStringExpander permissionFse ; private PermissionInfo ( Element element ) throws MiniLangException { if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"permission\" , \"action\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"permission\" ) ; } this . permissionFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"permission\" ) ) ; this . actionFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"action\" ) ) ; } private boolean hasPermission ( MethodContext methodContext , GenericValue userLogin , Security security ) { String permission = permissionFse . expandString ( methodContext . getEnvMap ( ) ) ; String action = actionFse . expandString ( methodContext . getEnvMap ( ) ) ; if ( ! action . isEmpty ( ) ) { return security . hasEntityPermission ( permission ,", "gt": "action , userLogin ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10776, "input": "<s> package org . eclipse . swt . internal . widgets ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class ControlHolder_Test extends TestCase { private Display display ; private Composite shell ; private ControlHolder controlHolder ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; controlHolder = new ControlHolder ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testEmpty ( ) { assertEquals ( 0 , controlHolder . size ( ) ) ; assertEquals ( 0 , controlHolder . getControls ( ) . length ) ; } public void testAddControl ( ) { Control control = new Text ( shell , SWT . NONE ) ; controlHolder . add ( control ) ; assertEquals ( 1 , controlHolder . size ( ) ) ; assertSame ( control , controlHolder . getControls ( ) [ 0 ] ) ; } public void testRemoveControl ( ) { Control control = new Text ( shell , SWT . NONE ) ; controlHolder . add ( control ) ; controlHolder . remove ( control ) ; assertEquals ( 0 , controlHolder . size ( ) ) ; assertEquals ( 0 , controlHolder . getControls ( ) . length ) ; } public void testAddControlTwice ( ) { Control control = new Text ( shell , SWT . NONE ) ; controlHolder . add ( control ) ; try { controlHolder . add ( control ) ; fail ( \"The same control must not be added twice.\" ) ; } catch ( IllegalArgumentException iae ) { } } public void testRemoveNonExistingControl ( ) { Control control = new Text ( shell , SWT . NONE ) ; try { controlHolder . remove ( control ) ; String msg = \"Only controls", "gt": "that are contained in the item list can be removed.\" ;", "prediction": ";\n", "label": 1}
{"id": 1479, "input": "<s> package api . bookmarks ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URL ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . util . List ; import api . son . MySon ; import api . soup . MySoup ; import api . util . Tuple ; public class Bookmarks { private Response response ; private String status ; public static Bookmarks initTorrentBookmarks ( ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=bookmarks&type=torrents&auth=\" + authkey ; Bookmarks bookmarks = ( Bookmarks ) MySon . toObject ( url , Bookmarks . class ) ; return bookmarks ; } public static Bookmarks initArtistBookmarks ( ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=bookmarks&type=artists&auth=\" + authkey ; Bookmarks bookmarks = ( Bookmarks ) MySon . toObject ( url , Bookmarks . class ) ; return bookmarks ; } public boolean hasTorrentBookmarks ( ) { if ( ( response . getTorrents ( ) == null ) || response . getTorrents ( ) . isEmpty ( ) ) return false ; return true ; } public boolean hasArtistBookmarks ( ) { if ( ( response . getArtists ( ) == null ) || response . getArtists ( ) . isEmpty ( ) ) return false ; return true ; } public Response getResponse ( ) { return this . response ; } public boolean getStatus ( ) { if ( status . equalsIgnoreCase ( \"success\" ) ) return true ; return false ; } public void downloadList ( List < Tuple < String ,", "gt": "String > > list , String path )", "prediction": ")\n", "label": 0}
{"id": 10779, "input": "<s> package org . restlet . test . ext . jaxrs", "gt": ". services . path ;", "prediction": ";\n", "label": 1}
{"id": 3594, "input": "<s> package org . springframework . social . quickstart . service ; import org . springframework . social . quickstart . model . LocalUser ; public interface LocalUserManager { public LocalUser getUserByEmail ( String email ) ; public LocalUser createUser ( String nickName , String email , String password ) ; public", "gt": "LocalUser save ( LocalUser user ) ;", "prediction": "\n", "label": 0}
{"id": 10786, "input": "<s> package org . apache . lucene . index ; final class FieldInfo { String name ; boolean isIndexed ; int number ; boolean storeTermVector ; boolean storeOffsetWithTermVector ; boolean storePositionWithTermVector ; boolean omitNorms ; boolean omitTermFreqAndPositions ; boolean storePayloads ; FieldInfo ( String na , boolean tk , int nu , boolean storeTermVector , boolean storePositionWithTermVector , boolean storeOffsetWithTermVector , boolean omitNorms , boolean storePayloads , boolean omitTermFreqAndPositions ) { name = na ; isIndexed = tk ; number = nu ; if ( isIndexed ) { this . storeTermVector = storeTermVector ; this . storeOffsetWithTermVector = storeOffsetWithTermVector ; this . storePositionWithTermVector = storePositionWithTermVector ; this . storePayloads = storePayloads ; this . omitNorms = omitNorms ; this . omitTermFreqAndPositions = omitTermFreqAndPositions ; } else { this . storeTermVector = false ; this . storeOffsetWithTermVector = false ; this . storePositionWithTermVector = false ; this . storePayloads = false ; this . omitNorms = true ; this . omitTermFreqAndPositions = false ; } } public Object clone ( ) { return new FieldInfo ( name , isIndexed , number , storeTermVector , storePositionWithTermVector , storeOffsetWithTermVector , omitNorms , storePayloads , omitTermFreqAndPositions ) ; } void update ( boolean isIndexed , boolean storeTermVector , boolean storePositionWithTermVector , boolean storeOffsetWithTermVector , boolean omitNorms , boolean storePayloads , boolean omitTermFreqAndPositions ) { if ( this . isIndexed != isIndexed ) { this . isIndexed = true ; } if ( isIndexed ) { if ( this . storeTermVector != storeTermVector ) { this . storeTermVector = true ; } if ( this . storePositionWithTermVector != storePositionWithTermVector ) { this . storePositionWithTermVector = true ; } if ( this . storeOffsetWithTermVector != storeOffsetWithTermVector ) { this . storeOffsetWithTermVector = true ; } if ( this . storePayloads != storePayloads ) { this . storePayloads = true ; } if ( this . omitNorms != omitNorms ) { this . omitNorms = false ; } if ( this", "gt": ". omitTermFreqAndPositions != omitTermFreqAndPositions )", "prediction": ") ;\n", "label": 1}
{"id": 5003, "input": "<s> package org . ofbiz . widget . fo ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . widget . ModelWidget ; import org . ofbiz . widget . WidgetWorker ; import org . ofbiz . widget . form . FormStringRenderer ; import org . ofbiz . widget . form . ModelForm ; import org . ofbiz . widget . form . ModelFormField ; import org . ofbiz . widget . form . ModelFormField . CheckField ; import org . ofbiz . widget . form . ModelFormField . ContainerField ; import org . ofbiz . widget . form . ModelFormField . DateFindField ; import org . ofbiz . widget . form . ModelFormField . DateTimeField ; import org . ofbiz . widget . form . ModelFormField . DisplayField ; import org . ofbiz . widget . form . ModelFormField . DropDownField ; import org . ofbiz . widget . form . ModelFormField . FileField ; import org . ofbiz . widget . form . ModelFormField . HiddenField ; import org . ofbiz . widget . form . ModelFormField . HyperlinkField ; import org . ofbiz . widget . form . ModelFormField . IgnoredField ; import org . ofbiz . widget . form . ModelFormField . ImageField ; import org . ofbiz . widget . form . ModelFormField . LookupField ; import org . ofbiz . widget . form . ModelFormField . PasswordField ; import org . ofbiz . widget . form . ModelFormField . RadioField ; import org . ofbiz . widget . form . ModelFormField . RangeFindField ; import org . ofbiz . widget . form . ModelFormField . ResetField ; import org . ofbiz . widget . form . ModelFormField . SubmitField ; import org . ofbiz . widget . form . ModelFormField . TextField ; import org . ofbiz . widget . form . ModelFormField . TextFindField ; import org . ofbiz . widget . form . ModelFormField . TextareaField ; import org . ofbiz . widget . html . HtmlWidgetRenderer ; public class FoFormRenderer extends HtmlWidgetRenderer implements FormStringRenderer { public static final String module = FoFormRenderer . class . getName ( ) ; HttpServletRequest request ; HttpServletResponse response ; public FoFormRenderer ( ) { } public FoFormRenderer ( HttpServletRequest request , HttpServletResponse response ) throws IOException { this . request = request ; this . response = response ; } private void makeBlockString ( Appendable writer , String widgetStyle , String text ) throws IOException { writer . append ( \"<fo:block\" ) ; if ( UtilValidate . isNotEmpty ( widgetStyle ) ) { writer . append ( \" \" ) ; writer . append ( FoScreenRenderer . getFoStyle ( widgetStyle ) ) ; } writer . append ( \">\" ) ; writer . append ( UtilFormatOut . encodeXmlValue ( text ) ) ; writer . append ( \"</fo:block>\" ) ; } public void renderDisplayField ( Appendable writer , Map < String , Object > context , DisplayField displayField ) throws IOException { ModelFormField modelFormField = displayField . getModelFormField ( ) ; this . makeBlockString ( writer , modelFormField . getWidgetStyle ( ) , displayField . getDescription ( context ) ) ; appendWhitespace ( writer ) ; } public void renderHyperlinkField ( Appendable writer , Map < String , Object > context , HyperlinkField hyperlinkField ) throws IOException { ModelFormField modelFormField = hyperlinkField . getModelFormField ( ) ; this . makeBlockString ( writer , modelFormField . getWidgetStyle ( ) , hyperlinkField . getDescription ( context ) ) ; appendWhitespace ( writer ) ; } public void renderTextField ( Appendable writer , Map < String , Object > context , TextField textField ) throws IOException { ModelFormField modelFormField = textField . getModelFormField ( ) ; this . makeBlockString ( writer , modelFormField . getWidgetStyle ( ) , modelFormField . getEntry ( context , textField . getDefaultValue ( context ) ) ) ; appendWhitespace ( writer ) ; } public void renderTextareaField ( Appendable writer , Map < String , Object > context , TextareaField textareaField ) throws IOException { ModelFormField modelFormField = textareaField . getModelFormField ( ) ; this . makeBlockString ( writer , modelFormField . getWidgetStyle ( ) , modelFormField . getEntry ( context ,", "gt": "textareaField . getDefaultValue ( context ) ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 10809, "input": "<s> package io . beancounter . profiler . hdfs ; import com . google . inject . Provides ; import io . beancounter . commons . helper . PropertiesHelper ; import org . apache . camel . component . properties . PropertiesComponent ; import org . apache . camel . guice . CamelModuleWithMatchingRoutes ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hdfs . DistributedFileSystem ; import org . guiceyfruit . jndi . JndiBind ; import java . util . Properties ; public class ProfilerWriterModule extends CamelModuleWithMatchingRoutes { @ Override protected void configure ( ) { super . configure ( ) ; Properties properties = PropertiesHelper . readFromClasspath ( \"/beancounter.properties\" ) ; bind ( DistributedFileSystem . class ) . toInstance ( new DistributedFileSystem ( ) ) ; bind ( Configuration . class ) .", "gt": "toInstance ( new Configuration ( ) ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7556, "input": "<s> import com . sun . source . util . * ; import java . io . * ; import java . lang . annotation . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; import javax . tools . * ; import com . sun . tools . javac . api . JavacTool ; @ Wrap @ SupportedAnnotationTypes ( \"Wrap\" ) public class T6403466 extends AbstractProcessor { static final String testSrcDir = System . getProperty ( \"test.src\" ) ; static final String testClassDir = System . getProperty ( \"test.classes\" ) ; static final String self = T6403466 . class . getName ( ) ; static PrintWriter out = new PrintWriter ( System . err , true ) ; public static void main ( String [ ] args ) throws IOException { JavacTool tool = JavacTool . create ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( null , null , null ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( new File ( testSrcDir , self + \".java\" ) ) ) ; Iterable < String > options = Arrays . asList ( \"-processorpath\" , testClassDir , \"-processor\" , self , \"-s\" , \".\" , \"-d\" , \".\" ) ; JavacTask task = tool . getTask ( out , fm , null , options , null , files ) ; VerifyingTaskListener vtl = new VerifyingTaskListener ( new File ( testSrcDir , self + \".out\" ) ) ; task . setTaskListener ( vtl ) ; if ( ! task . call ( ) ) throw new AssertionError ( \"compilation failed\" ) ; if ( vtl . iter . hasNext ( ) || vtl . errors ) throw new AssertionError ( \"comparison against golden file failed.\" ) ; } public boolean process ( Set < ? extends TypeElement > annos , RoundEnvironment rEnv ) { if ( ! rEnv . processingOver ( ) ) { Filer filer = processingEnv . getFiler ( ) ; for ( TypeElement anno : annos ) { Set < ? extends Element > elts = rEnv . getElementsAnnotatedWith ( anno ) ; System . err . println ( \"anno: \" + anno ) ; System . err . println ( \"elts: \" + elts ) ; for ( TypeElement te : ElementFilter . typesIn ( elts ) ) { try { Writer out = filer . createSourceFile ( te . getSimpleName ( ) + \"Wrapper\" ) . openWriter ( ) ; out . write ( \"class \" + te . getSimpleName ( ) + \"Wrapper { }\" ) ; out . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return true ; } @ Override public SourceVersion getSupportedSourceVersion ( ) { return SourceVersion . latest ( ) ; } } @ Retention ( RetentionPolicy . SOURCE ) @ Target ( ElementType . TYPE ) @ interface Wrap { } class VerifyingTaskListener implements TaskListener { VerifyingTaskListener ( File ref ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( ref ) ) ; String line ; List < String > lines = new ArrayList < String > ( ) ; while ( ( line = in . readLine ( ) ) != null ) lines . add ( line ) ; in . close ( ) ; iter = lines . iterator ( ) ; } public void started ( TaskEvent e ) { check ( \"Started \" + toString ( e ) ) ; } public void finished ( TaskEvent e ) { check ( \"Finished \" + toString ( e ) ) ; } private String toString ( TaskEvent e ) { JavaFileObject file = e . getSourceFile ( ) ; return \"TaskEvent[\" + e . getKind ( ) + \",\" + ( file == null ? null : new File ( file . toUri ( ) . getPath ( ) ) . getName ( ) ) + \",\" + e . getTypeElement ( ) + \"]\" ; } private void check ( String s ) { System . out .", "gt": "println ( s ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10819, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getListItemChangesResult\" } ) @ XmlRootElement ( name = \"GetListItemChangesResponse\" ) public class GetListItemChangesResponse { @ XmlElement ( name = \"GetListItemChangesResult\"", "gt": ") protected GetListItemChangesResponse . GetListItemChangesResult getListItemChangesResult ;", "prediction": ") ;\n", "label": 1}
{"id": 5682, "input": "<s> import junit . framework . Assert ; import org . junit . Test ; public class TestMenu { @ Test public void shouldCreateRightMenu ( ) { Menu bookMenu = Menu . createMenu ( ) ; String expectedBookMenu = \"\\nMenu: \\n1. Login\\n2. View All Books\\n3. Show All Movies\\n4. Show Library Number\\n5. Exit\" ; Assert . assertEquals ( expectedBookMenu , bookMenu . toString ( ) ) ; } @ Test public void shouldCreateLoggedInMenu ( ) { Menu bookMenu = Menu . createLoggedInMenu ( ) ; String expectedBookMenu = \"\\nMenu: \\n1. Logout\\n2. View All Books\\n3. Show All Movies\\n4.", "gt": "Show Library Number\\n5. Reserve Book\\n6. Return Book\\n7. Exit\" ;", "prediction": ") ;\n", "label": 0}
{"id": 10853, "input": "<s> package org . restlet . test . resource ; import java . io . IOException ; import org . restlet . data . MediaType ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Finder ; import org . restlet . resource . ResourceException ; import org . restlet . test . RestletTestCase ; public class AnnotatedResource5TestCase extends RestletTestCase { private ClientResource clientResource ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Finder finder = new Finder ( ) ; finder . setTargetClass ( MyResource5 . class ) ; this . clientResource = new ClientResource ( \"http://local\" ) ; this . clientResource . setNext ( finder ) ; } @ Override protected void tearDown ( ) throws Exception { clientResource = null ; super . tearDown ( ) ; } public void testPost ( ) throws IOException , ResourceException { Representation result = clientResource . post ( \"[\\\"root\\\"]\" , MediaType . APPLICATION_JSON ) ; assertNotNull ( result ) ; assertEquals ( \"[\\\"root\\\"]\" , result . getText ( ) ) ; assertEquals ( MediaType . APPLICATION_JSON , result . getMediaType ( ) ) ; result = clientResource . post", "gt": "( \"<root/>\" , MediaType . APPLICATION_XML ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6118, "input": "<s> package org . dawb . workbench . plotting . preference ; public class FittingConstants { public static final String PEAK_NUMBER = \"org.dawb.workbench.plotting.tools.peakNumber\" ; public static final String PEAK_NUMBER_CHOICES = \"org.dawb.workbench.plotting.tools.peakNumberChoices\" ; public static final String FIT_SMOOTH_FACTOR = \"org.dawb.workbench.plotting.tools.fitSmoothFactor\" ; public static final String SHOW_FWHM_SELECTIONS = \"org.dawb.workbench.plotting.tools.showFWHMSelection\" ; public static final String SHOW_PEAK_SELECTIONS = \"org.dawb.workbench.plotting.tools.showPeakSelection\" ; public static", "gt": "final String SHOW_FITTING_TRACE = \"org.dawb.workbench.plotting.tools.showFittingTrace\" ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10856, "input": "<s> package org . restlet . ext . jaxrs . internal . exceptions ; import javax . ws . rs . CookieParam ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Response . Status ; public class ConvertCookieParamException extends WebApplicationException { private static final long serialVersionUID = 9098614715395362234L ; public", "gt": "ConvertCookieParamException ( ConvertParameterException cpe )", "prediction": "( )\n", "label": 1}
{"id": 5964, "input": "<s> package pkg ; public class BaseClass { public int pubField = 1 ; public class pubInnerClass { }", "gt": "public void pubMethod ( )", "prediction": "}\n", "label": 0}
{"id": 10861, "input": "<s> package org . apache . lucene . util ; import java . util . BitSet ; import org . apache . lucene . search . DocIdSet ; import org . apache . lucene . search . DocIdSetIterator ; public class DocIdBitSet extends DocIdSet { private BitSet bitSet ; public DocIdBitSet ( BitSet bitSet ) { this . bitSet = bitSet ; } public DocIdSetIterator iterator ( ) { return new DocIdBitSetIterator ( bitSet ) ; } public boolean isCacheable ( ) { return true ; } public BitSet getBitSet ( ) { return this . bitSet ; } private static class DocIdBitSetIterator extends DocIdSetIterator { private int docId ; private BitSet bitSet ; DocIdBitSetIterator ( BitSet bitSet ) { this . bitSet = bitSet ; this . docId = - 1 ; } public int doc ( ) { assert docId != - 1 ; return docId ; } public int docID ( ) { return docId ; }", "gt": "public boolean next ( )", "prediction": "}\n", "label": 1}
{"id": 6067, "input": "<s> package org . jjflyboy . tjpeditor . scoping ; import java . util . List ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . xtext . naming . QualifiedName ; import org . eclipse . xtext . resource . IEObjectDescription ; import org . eclipse . xtext . resource . ISelectable ; import org . eclipse . xtext . scoping . IScope ; import org . eclipse . xtext . scoping . impl . ImportNormalizer ; import org . eclipse . xtext . scoping . impl . ImportScope ; public class ProjectImportScope extends ImportScope { public ProjectImportScope ( List < ImportNormalizer > namespaceResolvers , IScope parent , ISelectable importFrom , EClass type , boolean ignoreCase ) { super ( namespaceResolvers , parent , importFrom , type , ignoreCase ) ; } public IEObjectDescription getSingleElement ( QualifiedName name ) { IEObjectDescription result = null ; ProjectQualifiedName searchname ; if ( name instanceof ProjectQualifiedName ) { searchname = ( ProjectQualifiedName ) name ; } else { searchname = new ProjectQualifiedName ( name ) ; } if ( searchname . isRelative ( ) ) { if ( searchname . isUp ( ) ) { searchname . advance ( ) ; } } if ( ! searchname . isRelative ( ) || searchname . isUp ( ) ) { result = getParent ( ) .", "gt": "getSingleElement ( searchname ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10871, "input": "<s> package org . restlet . security ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ClientInfo ; import org . restlet . data . Status ; import org . restlet . routing . Filter ; public abstract class Authenticator extends Filter { private volatile Enroler enroler ; private volatile boolean multiAuthenticating ; private volatile boolean optional ; public Authenticator ( Context context ) { this ( context , false ) ; } public Authenticator ( Context context , boolean optional ) { this ( context , optional , ( context != null ) ? context . getDefaultEnroler ( ) : null ) ; } public Authenticator ( Context context , boolean multiAuthenticating , boolean optional , Enroler enroler ) { super ( context ) ; this . multiAuthenticating = multiAuthenticating ; this . optional = optional ; this . enroler = enroler ; } public Authenticator ( Context context , boolean optional , Enroler enroler ) { this ( context , true , optional , enroler ) ; } protected abstract boolean authenticate ( Request request , Response response ) ; protected int authenticated ( Request request , Response response ) { boolean loggable = request . isLoggable ( ) && getLogger ( ) . isLoggable ( Level . FINE ) ; if ( loggable && request . getChallengeResponse ( ) != null ) { getLogger ( ) . log ( Level . FINE , \"The authentication succeeded for the identifer \\\"\" + request . getChallengeResponse ( ) . getIdentifier ( ) + \"\\\" using the \" + request . getChallengeResponse ( ) . getScheme ( ) + \" scheme.\" ) ; } if ( request . getClientInfo ( ) != null ) { request . getClientInfo ( ) . setAuthenticated ( true ) ; } response . getChallengeRequests ( ) . clear ( ) ; if ( getEnroler ( ) != null ) { getEnroler ( ) . enrole ( request . getClientInfo ( ) ) ; } return CONTINUE ; } @ Override protected int beforeHandle ( Request request , Response response ) { if ( isMultiAuthenticating ( ) || ! request . getClientInfo ( ) . isAuthenticated ( ) ) { if ( authenticate ( request , response ) ) { return authenticated ( request , response ) ; } else if ( isOptional ( ) ) { response . setStatus ( Status . SUCCESS_OK ) ; return CONTINUE ; } else { return unauthenticated ( request , response ) ; } } else { return CONTINUE ; } } public Enroler getEnroler ( ) { return enroler ; } public boolean isMultiAuthenticating ( ) { return multiAuthenticating ; } public boolean isOptional ( ) { return optional ; } public void setEnroler ( Enroler enroler ) { this . enroler = enroler ; } public void setMultiAuthenticating ( boolean multiAuthenticating ) { this . multiAuthenticating = multiAuthenticating ; } public void setOptional ( boolean optional ) { this . optional = optional ; }", "gt": "protected int unauthenticated ( Request request , Response response )", "prediction": "}\n", "label": 1}
{"id": 7502, "input": "<s> package org . apache . felix . resolver ; import java . util . List ; public interface FelixCapability {", "gt": "List < String > getUses ( ) ;", "prediction": ";\n", "label": 0}
{"id": 10876, "input": "<s> package org . fuzzydb . util ; import java . util . TreeSet ; public class ScreenNameValidator extends ScreenNameValidatorDB { TreeSet < String > malesDB = new TreeSet < String > ( ) ; TreeSet < String > femalesDB = new TreeSet < String > ( ) ; boolean built = false ; public ScreenNameValidator ( ) { build ( ) ; } private void build ( ) { if ( ! built ) { build ( males , malesDB ) ; build ( females , femalesDB ) ; built = true ; } } public String checkName ( String name ) { build ( ) ; String rval = checkName ( name , malesDB ) ; if ( rval == null ) { rval = checkName ( name , femalesDB ) ; } return rval ; } public String checkName ( String name , boolean isMale ) { build ( ) ; return checkName ( name , isMale ? malesDB : femalesDB ) ; } private static String checkName ( String name , TreeSet < String > db ) { if ( db . contains ( name . toLowerCase ( ) ) ) { return fixCase ( name ) ; } return null ; } private static String fixCase ( String name ) { if ( name . length ( ) < 2 ) { return name . toUpperCase ( ) ; } String fixed = name . substring ( 0 , 1 ) . toUpperCase ( ) + name . substring ( 1 ) . toLowerCase ( ) ; return fixed ; } private void build ( String array [ ] , TreeSet < String > output ) { for ( int i = 0 ; i < array . length ; i ++ ) { String name =", "gt": "array [ i ] ;", "prediction": ";\n", "label": 1}
{"id": 9956, "input": "<s> package org . globaleaks . android . net ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Random ; import org . apache . http . Header ; import org . apache . http . HttpEntity ; import org . apache . http . message . BasicHeader ; import android . util . Log ; public class MultipartEntity implements HttpEntity { private static final String TAG = \"SME\" ; private static final char [ ] MULTIPART_CHARS = \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . toCharArray ( ) ; private String boundary = null ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; boolean isSetLast = false ; boolean isSetFirst = false ; public MultipartEntity ( ) { final StringBuilder buf = new StringBuilder ( ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < 30 ; i ++ ) { buf . append ( MULTIPART_CHARS [ rand . nextInt ( MULTIPART_CHARS . length ) ] ) ; } boundary = buf . toString ( ) ; } public void writeFirstBoundaryIfNeeds ( ) { if ( ! isSetFirst ) { try { out . write ( ( \"--\" + boundary + \"\\r\\n\" ) . getBytes ( ) ) ; } catch ( final IOException e ) { Log . e ( TAG , e . getMessage ( ) , e ) ; } } isSetFirst = true ; } public void writeLastBoundaryIfNeeds ( ) { if ( isSetLast ) { return ; } try { out . write ( ( \"\\r\\n--\" + boundary + \"--\\r\\n\" ) . getBytes ( ) ) ; } catch ( final IOException e ) { Log . e ( TAG , e . getMessage ( ) , e ) ; } isSetLast = true ; } public void addPart ( final String key , final String value ) { writeFirstBoundaryIfNeeds ( ) ; try { out . write ( ( \"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"\\r\\n\" ) . getBytes ( ) ) ; out . write ( \"Content-Type: text/plain; charset=UTF-8\\r\\n\" . getBytes ( ) ) ; out . write ( \"Content-Transfer-Encoding: 8bit\\r\\n\\r\\n\" . getBytes ( ) ) ; out . write ( value . getBytes ( ) ) ; out . write ( ( \"\\r\\n--\" + boundary + \"\\r\\n\" )", "gt": ". getBytes ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 10894, "input": "<s> package org . eclipse . ui . internal . services ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . expressions . EvaluationContext ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . ISourceProvider ; import org . eclipse . ui . ISourceProviderListener ; import org . eclipse . ui . ISources ; public abstract class ExpressionAuthority implements ISourceProviderListener { private final IEvaluationContext context ; private IEvaluationContext currentState = null ; private final Collection providers = new ArrayList ( ) ; protected ExpressionAuthority ( ) { context = new EvaluationContext ( null , this ) ; context . setAllowPluginActivation ( true ) ; context . addVariable ( \"org.eclipse.core.runtime.Platform\" , Platform . class ) ; } public final void addSourceProvider ( final ISourceProvider provider ) { provider . addSourceProviderListener ( this ) ; providers . add ( provider ) ; final Map currentState = provider . getCurrentState ( ) ; final Iterator variableItr = currentState . entrySet ( ) . iterator ( ) ; while ( variableItr . hasNext ( ) ) { final Map . Entry entry = ( Map . Entry ) variableItr . next ( ) ; final String variableName = ( String ) entry . getKey ( ) ; final Object variableValue = entry . getValue ( ) ; if ( ( variableName != null ) && ( ! ISources . ACTIVE_WORKBENCH_WINDOW_SHELL_NAME . equals ( variableName ) ) ) { changeVariable ( variableName , variableValue ) ; } } sourceChanged ( 0 , currentState ) ; } public void dispose ( ) { final Iterator providerItr = providers . iterator ( ) ; while ( providerItr . hasNext ( ) ) { final ISourceProvider provider = ( ISourceProvider ) providerItr . next ( ) ; provider . removeSourceProviderListener ( this ) ; } providers . clear ( ) ; } protected final boolean evaluate ( final Collection collection ) { final Iterator iterator = collection . iterator ( ) ; while ( iterator . hasNext ( ) ) { final IEvaluationResultCache cache = ( IEvaluationResultCache ) iterator . next ( ) ; if ( evaluate ( cache ) ) { return true ; } } return false ; } protected final boolean evaluate ( final IEvaluationResultCache expression ) { final IEvaluationContext contextWithDefaultVariable = getCurrentState ( ) ; return expression . evaluate ( contextWithDefaultVariable ) ; } public final IEvaluationContext getCurrentState ( ) { if ( currentState == null ) { final Object defaultVariable = context . getVariable ( ISources . ACTIVE_CURRENT_SELECTION_NAME ) ; final IEvaluationContext contextWithDefaultVariable ; if ( defaultVariable instanceof IStructuredSelection ) { final IStructuredSelection selection = ( IStructuredSelection ) defaultVariable ; contextWithDefaultVariable = new EvaluationContext ( context , selection . toList ( ) ) ; } else if ( ( defaultVariable instanceof ISelection ) && ( ! ( ( ISelection ) defaultVariable ) . isEmpty ( ) ) ) { contextWithDefaultVariable = new EvaluationContext ( context , Collections . singleton ( defaultVariable ) ) ; } else { contextWithDefaultVariable = new EvaluationContext ( context , Collections . EMPTY_LIST ) ; } currentState = contextWithDefaultVariable ; } return currentState ; } protected final Object getVariable ( final String name ) { return context . getVariable ( name ) ; } public final void removeSourceProvider ( final ISourceProvider provider ) { provider . removeSourceProviderListener ( this ) ; providers . remove ( provider ) ; final Map currentState = provider . getCurrentState ( ) ; final Iterator variableItr = currentState . entrySet ( ) . iterator ( ) ; while ( variableItr . hasNext ( ) ) { final Map . Entry entry = ( Map . Entry ) variableItr . next ( ) ; final String variableName = ( String ) entry . getKey ( ) ; changeVariable ( variableName , null ) ; } } protected final void changeVariable ( final String name , final Object value ) { if ( value == null ) { context . removeVariable ( name ) ; } else { context . addVariable ( name , value ) ; } } protected abstract void sourceChanged ( final int sourcePriority ) ; protected void sourceChanged ( final String [ ] sourceNames ) { } public final void sourceChanged ( final int sourcePriority , final Map sourceValuesByName ) { if ( sourceValuesByName . containsKey ( ISources . ACTIVE_CURRENT_SELECTION_NAME ) ) { currentState = null ; } final Iterator entryItr = sourceValuesByName . entrySet ( ) . iterator ( ) ; while ( entryItr . hasNext ( ) ) { final Map . Entry entry = ( Map . Entry ) entryItr . next ( ) ; final String sourceName = ( String ) entry . getKey ( ) ; final Object sourceValue = entry . getValue ( ) ; updateEvaluationContext ( sourceName , sourceValue ) ; } sourceChanged ( sourcePriority , ( String [ ] ) sourceValuesByName . keySet ( ) . toArray ( new String [ 0 ] ) ) ; } public final void sourceChanged ( final int sourcePriority , final String sourceName , final Object sourceValue ) { if", "gt": "( ISources . ACTIVE_CURRENT_SELECTION_NAME . equals ( sourceName ) )", "prediction": "( )\n", "label": 1}
{"id": 4455, "input": "<s> class ArrayDims2 { static Object [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] [ ] o ; public static void", "gt": "main ( String [ ] args )", "prediction": "( ) ;\n", "label": 0}
{"id": 10898, "input": "<s> package br . org . archimedes . leader ; import br . org . archimedes . Constant ; import br . org . archimedes . Geometrics ; import br . org . archimedes . Utils ; import br . org . archimedes . controller . Controller ; import br . org . archimedes . controller . commands . PutOrRemoveElementCommand ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . gui . model . Workspace ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . Parser ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Vector ; import br . org . archimedes . parser . PointParser ; import br . org . archimedes . parser . VectorParser ; import java . util . ArrayList ; import java . util . List ; public class LeaderFactory implements CommandFactory { private Point p1 ; private Point p2 ; private Point p3 ; private Workspace workspace ; private Controller controller ; private boolean active ; private PutOrRemoveElementCommand command ; public LeaderFactory ( ) { workspace = Utils . getWorkspace ( ) ; controller = Utils . getController ( ) ; deactivate ( ) ; } public String begin ( ) { active = true ; return \"Enter the first point in form x;y or click the desired position\" ; } private void deactivate ( ) { controller . deselectAll ( ) ; active = false ; p1 = null ; p2 = null ; p3 = null ; } public String next ( Object parameter ) throws InvalidParameterException { String result = null ; if ( ! isDone ( ) ) { if ( parameter == null ) { throw new InvalidParameterException ( ) ; } else if ( p1 == null ) { Point point = null ; try { point = ( Point ) parameter ; } catch ( ClassCastException e ) { throw new InvalidParameterException ( \"Expected POINT\" ) ; } p1 = point ; result = \"Enter a point or a distance\" ; workspace . setPerpendicularGripReferencePoint ( point ) ; } else { Vector vector = null ; try { vector = ( Vector ) parameter ; } catch ( ClassCastException e ) { throw new InvalidParameterException ( \"Expected POINT\" ) ; } if ( p2 == null ) { p2 = p1 . addVector ( vector ) ; result = \"Enter a distance or a mouse-given point\" ; workspace . setPerpendicularGripReferencePoint ( p2 ) ; } else { p3 = p2 . addVector ( vector ) ; result = createLeader ( ) ; deactivate ( ) ; } } } else { throw new InvalidParameterException ( ) ; } return result ; } private String createLeader ( ) { String result ; try { Leader leader = new Leader ( p1 , p2 , p3 ) ; command = new PutOrRemoveElementCommand ( leader , false ) ; result = \"Leader created\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; result = \"Could not create the leader\" ; } return result ; } public String cancel ( ) { deactivate ( ) ; return \"Leader canceled\" ; } public boolean isDone ( ) { return ! active ; } public void drawVisualHelper ( ) { if ( p1 != null && p3 == null ) { Point point = workspace . getMousePosition ( ) ; Point initial = p1 ; try { List < Point > circle = getPointsForCircle ( p1 , Constant . LEADER_RADIUS ) ; Utils . getOpenGLWrapper ( ) . drawFromModel ( circle ) ; if ( p2 != null ) { Utils . getOpenGLWrapper ( ) . drawFromModel ( p1 , p2 ) ; initial = p2 ; } point = Utils . transformVector ( initial , point ) ; Utils . getOpenGLWrapper ( ) . drawFromModel ( initial , point ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } } } private List < Point > getPointsForCircle ( Point center , double radius ) { ArrayList < Point > points = new ArrayList < Point > ( ) ; double increment = Math . PI / 360 ; for ( double angle = 0 ; angle <= Math . PI * 2 ; angle += increment ) { double x = center . getX ( ) + radius * Math . cos ( angle ) ; double y = center . getY ( ) + radius * Math . sin ( angle ) ; points . add ( new Point ( x , y ) ) ; } double x = center . getX ( ) + radius * Math . cos ( Math . PI * 2 ) ; double y = center . getY ( ) + radius * Math . sin ( Math . PI * 2 ) ; points . add ( new Point ( x , y ) ) ; return points ; } public String getName ( ) { return \"leader\" ; } public Parser getNextParser ( ) { Parser parser = null ; if ( active ) { if", "gt": "( p1 == null )", "prediction": "( ) ;\n", "label": 1}
{"id": 2897, "input": "<s> package api . util ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Document ; public class Updater { private Document doc = null ; private String updateSite ; public Updater ( String updateSite ) { this . updateSite = updateSite ; } public void checkForUpdates ( ) throws CouldNotLoadException { try { doc = ( Jsoup . connect ( updateSite ) . get ( ) ) ; } catch ( Exception e ) { throw new CouldNotLoadException ( \"Could not load update site\" ) ; } } public Triple < String , String , String > getMessage ( ) { if ( getDoc ( ) != null ) { String title = getDoc ( ) . getElementsByTag ( \"subject\" ) . text ( ) . trim ( ) ; String body = getDoc ( ) . getElementsByTag ( \"info\" ) . html ( ) ; String valediction = getDoc ( ) . getElementsByTag ( \"valediction\" ) . text ( ) . trim ( ) ; return new Triple < String , String , String > ( title , body , valediction ) ; } return null ; } public Double getVersion ( ) {", "gt": "if ( getDoc ( ) != null )", "prediction": "\n", "label": 0}
{"id": 10900, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . custom . CLabel ; public class CLabelTextProperty extends WidgetStringValueProperty { String doGetStringValue ( Object source ) { return ( ( CLabel ) source ) . getText ( ) ; }", "gt": "void doSetStringValue ( Object source , String value )", "prediction": "}\n", "label": 1}
{"id": 9623, "input": "<s> package org . ofbiz . entity . testtools ; import junit . framework . TestCase ; import org . ofbiz . entity . Delegator ; public class EntityTestCase extends TestCase { protected Delegator delegator = null ; public EntityTestCase ( String name ) { super ( name ) ; } public void", "gt": "setDelegator ( Delegator delegator )", "prediction": "( )\n", "label": 0}
{"id": 10902, "input": "<s> package org . mitre . openid . connect . repository . impl ; import static org . mitre . util . jpa . JpaUtil . saveOrUpdate ; import java . util . Collection ; import java . util . Date ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; import javax . persistence . Query ; import javax . persistence . TemporalType ; import org . mitre . openid . connect . model . Event ; import org . mitre . openid . connect . repository . EventRepository ; import org . springframework . stereotype . Repository ; import org . springframework . transaction . annotation . Transactional ; @ Repository public class JpaEventRepository implements EventRepository { @ PersistenceContext private EntityManager manager ; @ Override @ Transactional public Event getById ( Long id ) { return manager . find ( Event . class , id ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override @ Transactional public Collection < Event > getEventsDuringPeriod ( Date start , Date end , int startChunk , int chunkSize ) { Query query = manager . createQuery ( \"SELECT e FROM Event e WHERE e.timestamp BETWEEN :start AND :end\" ) ; query = query . setParameter ( \"start\" , start , TemporalType . DATE ) ; query = query . setParameter ( \"end\" , end , TemporalType . DATE ) ; query = query . setFirstResult ( startChunk ) ; query = query . setMaxResults ( chunkSize ) ; return query . getResultList ( ) ; } @ Override @ Transactional public void remove ( Event event ) { Event found = manager . find ( Event . class , event . getId ( ) ) ; if ( found != null ) { manager . remove ( event ) ; } else { throw new IllegalArgumentException ( ) ; } }", "gt": "@ Override @ Transactional public void removeById ( Long id )", "prediction": "}\n", "label": 1}
{"id": 2031, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Flying ; public interface LizaFlying extends Flying { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities", "gt": "( double x , double y , double z ) ;", "prediction": "( )\n", "label": 0}
{"id": 10909, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import org . apache . lucene . search . Query ; import org . apache . lucene . benchmark . byTask . utils . Config ; import org . apache . lucene . benchmark . byTask . utils . Format ; public abstract class AbstractQueryMaker implements QueryMaker { protected int qnum = 0 ; protected Query [ ] queries ; protected Config config ; public void resetInputs ( ) { qnum = 0 ; } protected abstract Query [ ] prepareQueries ( ) throws Exception ; public void setConfig ( Config config ) throws Exception { this . config = config ; queries = prepareQueries ( ) ; } public String printQueries ( ) { String newline = System . getProperty ( \"line.separator\" ) ; StringBuffer sb = new StringBuffer ( ) ; if ( queries != null ) { for ( int i = 0 ; i < queries . length ; i ++ ) { sb . append ( i + \". \" + Format . simpleName ( queries [ i ] . getClass ( ) ) + \" - \" + queries [ i ] . toString ( ) ) ; sb . append ( newline ) ; } } return sb . toString ( ) ; } public Query makeQuery ( ) throws Exception { return queries [ nextQnum ( ) ] ; } protected synchronized int nextQnum ( ) { int res = qnum ; qnum = ( qnum + 1 ) % queries . length ; return res ; } public Query makeQuery ( int size ) throws Exception { throw new Exception ( this +", "gt": "\".makeQuery(int size) is not supported!\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3882, "input": "<s> package com . gisgraphy . client . gisfeature ; import org . junit . Test ; public class InMemoryAlternateNamesProviderTest { @ Test (", "gt": "expected = IllegalArgumentException . class ) public void shouldThrowExceptionWhenAlternateNamesIsNull ( )", "prediction": ") ;\n", "label": 0}
{"id": 10927, "input": "<s> package com . puppycrawl . tools . checkstyle . checks . xpath ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import org . apache . commons . beanutils . BeanUtils ; import com . puppycrawl . tools . checkstyle . api . DetailAST ; public class AttributeAxisIterator implements Iterator { private Iterator mIter = ( new ArrayList ( ) ) . iterator ( ) ; public AttributeAxisIterator ( DetailAST aAST ) { Map props = new HashMap ( ) ; try { props = BeanUtils . describe ( aAST ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } final List attributes = new ArrayList ( props . size ( ) ) ; final Set values = props . keySet ( ) ; for ( Iterator", "gt": "iter = values . iterator ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4117, "input": "<s> package org . ofbiz . service . mail ; import java . util . Collection ; import java . util . Set ; import java . util . TreeSet ; import org . ofbiz . base . component . ComponentConfig ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . config . MainResourceHandler ; import org . ofbiz . base . config . ResourceHandler ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . config . ServiceConfigUtil ; import org . w3c . dom . Element ; public class ServiceMcaUtil { public static final String module = ServiceMcaUtil . class . getName ( ) ; private static final UtilCache < String , ServiceMcaRule > mcaCache = UtilCache . createUtilCache ( \"service.ServiceMCAs\" , 0 , 0 , false ) ; public static void reloadConfig ( ) { mcaCache . clear ( ) ; readConfig ( ) ; } public static void readConfig ( ) { Element rootElement = null ; try { rootElement = ServiceConfigUtil . getXmlRootElement ( ) ; } catch ( GenericConfigException e ) { Debug . logError ( e , \"Error getting Service Engine XML root element\" , module ) ; return ; } for ( Element serviceMcasElement : UtilXml . childElementList ( rootElement , \"service-mcas\" ) ) { ResourceHandler handler = new MainResourceHandler ( ServiceConfigUtil . SERVICE_ENGINE_XML_FILENAME , serviceMcasElement ) ; addMcaDefinitions ( handler ) ; } for ( ComponentConfig . ServiceResourceInfo componentResourceInfo : ComponentConfig . getAllServiceResourceInfos ( \"mca\" ) ) { addMcaDefinitions ( componentResourceInfo . createResourceHandler ( ) ) ; } } public static void addMcaDefinitions ( ResourceHandler handler ) { Element rootElement = null ; try { rootElement = handler . getDocument ( ) . getDocumentElement ( ) ; } catch ( GenericConfigException e ) { Debug . logError ( e , module ) ; return ; } int numDefs = 0 ; for ( Element e : UtilXml . childElementList ( rootElement , \"mca\" ) ) { String", "gt": "ruleName = e . getAttribute ( \"mail-rule-name\" ) ;", "prediction": ";\n", "label": 0}
{"id": 10931, "input": "<s> package org . seage . problem . qap . fireflies ; import org . seage . problem . qap . fireflies . * ; import org . seage . problem . qap . AssignmentProvider ; public class QapRandomSolution extends QapSolution { public QapRandomSolution ( Double [ ] [ ] [ ] facilityLocation ) {", "gt": "super ( facilityLocation ) ;", "prediction": "}\n", "label": 1}
{"id": 7823, "input": "<s> package org . msl . simple . gmf . bridge . transform ; import java . io . IOException ; import java . net . URL ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . emf . codegen . ecore . genmodel . GenModel ; import org . eclipse . emf . common . util . BasicDiagnostic ; import org . eclipse . emf . common . util . Diagnostic ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . ecore . resource . ContentHandler ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . ecore . util . EcoreUtil . ExternalCrossReferencer ; import org . eclipse . emf . ecore . xmi . XMLResource ; import org . eclipse . gmf . codegen . gmfgen . GenEditorGenerator ; import org . eclipse . gmf . graphdef . codegen . MapModeCodeGenStrategy ; import org . eclipse . gmf . internal . bridge . genmodel . BasicDiagramRunTimeModelHelper ; import org . eclipse . gmf . internal . bridge . genmodel . DiagramGenModelTransformer ; import org . eclipse . gmf . internal . bridge . genmodel . DiagramRunTimeModelHelper ; import org . eclipse . gmf . internal . bridge . genmodel . GenModelProducer ; import org . eclipse . gmf . internal . bridge . genmodel . InnerClassViewmapProducer ; import org . eclipse . gmf . internal . bridge . genmodel . RuntimeGenModelAccess ; import org . eclipse . gmf . internal . bridge . genmodel . ViewmapProducer ; import org . eclipse . gmf . internal . bridge . naming . gen . GenNamingMediatorImpl ; import org . eclipse . gmf . internal . bridge . transform . GenModelDetector ; import org . eclipse . gmf . internal . bridge . transform . Messages ; import org . eclipse . gmf . internal . bridge . transform . StaleGenModelDetector ; import org . eclipse . gmf . internal . bridge . transform . ValidationHelper ; import org . eclipse . gmf . internal . bridge . transform . VisualIdentifierDispenserProvider ; import org . eclipse . gmf . internal . bridge . ui . Plugin ; import org . eclipse . gmf . internal . codegen . util . GMFGenConfig ; import org . eclipse . gmf . internal . common . migrate . ModelLoadHelper ; import org . eclipse . gmf . internal . common . reconcile . Reconciler ; import org . eclipse . gmf . mappings . Mapping ; import org . eclipse . m2m . qvt . oml . runtime . util . QvtoTransformationHelper ; import org . eclipse . m2m . qvt . oml . runtime . util . QvtoTransformationHelper . ModelExtent ; import org . eclipse . m2m . qvt . oml . runtime . util . QvtoTransformationHelper . TransfExecutionResult ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; public class SimpleTransformToGenModelOperation { private URI myGMFGenModelURI ; private TransformOptions myOptions ; private Mapping myMapping ; private GenModelDetector myGMDetector ; private GenModel myGenModel ; private Diagnostic myMapmodelValidationResult = Diagnostic . CANCEL_INSTANCE ; private Diagnostic myGMFGenValidationResult = Diagnostic . CANCEL_INSTANCE ; private IStatus myStaleGenmodelStatus = Status . CANCEL_STATUS ; private final ResourceSet myResourceSet ; public SimpleTransformToGenModelOperation ( ResourceSet rs ) { assert rs != null ; myResourceSet = rs ; this . myOptions = new TransformOptions ( ) ; } public TransformOptions getOptions ( ) { return myOptions ; } public URI getGenURI ( ) { return this . myGMFGenModelURI ; } public void setGenURI ( URI gmfGen ) { this . myGMFGenModelURI = gmfGen ; } public GenModel getGenModel ( ) { return this . myGenModel ; } public final ResourceSet getResourceSet ( ) { return myResourceSet ; } Mapping getMapping ( ) { return this . myMapping ; } private void setMapping ( Mapping m , Diagnostic validationResult ) { this . myMapping = m ; this . myMapmodelValidationResult = validationResult ; myGMDetector = ( m != null ) ? new GenModelDetector ( m ) : null ; myGenModel = null ; } private void setGMFGenValidationResult ( Diagnostic validationResult ) { this . myGMFGenValidationResult = validationResult ; } public GenModelDetector getGenModelDetector ( ) { return myGMDetector ; } public Diagnostic getGMFGenValidationResult ( ) { return this . myGMFGenValidationResult ; } public Diagnostic getMapmodelValidationResult ( ) { return this . myMapmodelValidationResult ; } public IStatus getStaleGenmodelStatus ( ) { return this . myStaleGenmodelStatus ; } public Mapping loadMappingModel ( URI uri , IProgressMonitor pm ) throws CoreException { Mapping content = null ; IStatus status = Status . CANCEL_STATUS ; Diagnostic validation = Diagnostic . CANCEL_INSTANCE ; IProgressMonitor monitor = null ; try { if ( uri == null ) { throw new IllegalArgumentException ( Messages . TransformToGenModelOperation_e_null_map_uri ) ; } monitor = ( pm != null ) ? new SubProgressMonitor ( pm , 1 , SubProgressMonitor . PREPEND_MAIN_LABEL_TO_SUBTASK ) : new NullProgressMonitor ( ) ; String", "gt": "cancelMessage = Messages . TransformToGenModelOperation_e_map_load_cancelled ;", "prediction": "}\n", "label": 0}
{"id": 10941, "input": "<s> package org . jscsi . scsi . protocol . mode ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . BufferUnderflowException ; public class DisconnectReconnect extends ModePage { public static final byte PAGE_CODE = 0x02 ; public static final int PAGE_LENGTH = 0x0E ; private int bufferFullRatio ; private int bufferEmptyRatio ; private int busInactivityLimit ; private int disconnectTimeLimit ; private int connectTimeLimit ; private int maximumBurstSize ; private boolean EMDP ; private int fairArbitration ; private boolean DIMM ; private int DTDC ; private int firstBurstSize ; public DisconnectReconnect ( ) { super ( PAGE_CODE , PAGE_LENGTH ) ; } @ Override protected void decodeModeParameters ( int dataLength , DataInputStream inputStream ) throws BufferUnderflowException , IllegalArgumentException { try { this . bufferFullRatio = inputStream . readUnsignedByte ( ) ; this . bufferEmptyRatio = inputStream . readUnsignedByte ( ) ; this . busInactivityLimit = inputStream . readUnsignedShort ( ) ; this . disconnectTimeLimit = inputStream . readUnsignedShort ( ) ; this . connectTimeLimit = inputStream . readUnsignedShort ( ) ; this . maximumBurstSize = inputStream . readUnsignedShort ( ) ; int b12 = inputStream . readUnsignedByte ( ) ; this . EMDP = ( ( b12 > > > 7 ) & 1 ) == 1 ; this . fairArbitration = ( ( b12 > > > 4 ) & 7 ) ; this . DIMM = ( ( b12 > > > 3 ) & 1 ) == 1 ; this . DTDC = ( b12 & 7 ) ; inputStream . readByte ( ) ; this . firstBurstSize = inputStream . readUnsignedShort ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( \"Error reading input data.\" ) ; } } @ Override protected void encodeModeParameters ( DataOutputStream output ) { try { output . writeByte ( this . bufferFullRatio ) ; output . writeByte ( this . bufferEmptyRatio ) ; output . writeByte ( this . busInactivityLimit ) ; output . writeByte ( this . disconnectTimeLimit ) ; output . writeByte ( this . connectTimeLimit ) ; output . writeByte ( this . maximumBurstSize ) ; int b = 0 ; if ( this . EMDP ) { b |= 0x80 ; } b |= ( this . fairArbitration << 4 ) ; if ( this . DIMM ) { b |= 8 ; } b |= ( this . DTDC ) ; output . writeByte ( b ) ; output . writeByte ( 0 ) ; output . writeShort ( this . firstBurstSize ) ; } catch ( IOException e ) { throw new RuntimeException ( \"Unable to encode CDB.\" ) ; } } public int getBufferFullRatio ( ) { return this . bufferFullRatio ; } public void setBufferFullRatio ( int bufferFullRatio ) { this . bufferFullRatio = bufferFullRatio ; } public int getBufferEmptyRatio ( ) { return this . bufferEmptyRatio ; } public void setBufferEmptyRatio ( int bufferEmptyRatio ) { this . bufferEmptyRatio = bufferEmptyRatio ; } public int getBusInactivityLimit ( ) { return this . busInactivityLimit ; } public void setBusInactivityLimit ( int busInactivityLimit ) { this . busInactivityLimit = busInactivityLimit ; } public int getDisconnectTimeLimit ( ) { return this . disconnectTimeLimit ; } public void setDisconnectTimeLimit ( int disconnectTimeLimit ) { this . disconnectTimeLimit = disconnectTimeLimit ; } public int getConnectTimeLimit ( ) { return this . connectTimeLimit ; } public void setConnectTimeLimit ( int connectTimeLimit ) { this . connectTimeLimit = connectTimeLimit ; } public int getMaximumBurstSize ( ) { return this . maximumBurstSize ; } public void setMaximumBurstSize ( int maximumBurstSize ) { this . maximumBurstSize = maximumBurstSize ; } public boolean isEMDP ( ) {", "gt": "return this . EMDP ;", "prediction": "\n", "label": 1}
{"id": 7709, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends", "gt": "Runnable , S extends String > void disjointness ( )", "prediction": ")\n", "label": 0}
{"id": 10951, "input": "<s> package org . eclipse . jface . viewers ; import java . util . EventObject ; import org . eclipse . core . runtime . Assert ; public class DoubleClickEvent extends EventObject { private static final long serialVersionUID = 3258408443605038133L ; protected ISelection selection ; public DoubleClickEvent ( Viewer source , ISelection selection ) { super ( source ) ; Assert . isNotNull ( selection ) ; this . selection = selection ; }", "gt": "public ISelection getSelection ( )", "prediction": "}\n", "label": 1}
{"id": 3735, "input": "<s> package org . ofbiz . accounting . thirdparty . clearcommerce ; import java . io . ByteArrayOutputStream ; import java . io . OutputStream ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . xml . transform . TransformerException ; import org . ofbiz . accounting . payment . PaymentGatewayServices ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . HttpClient ; import org . ofbiz . base . util . HttpClientException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class CCPaymentServices { public final static String module = CCPaymentServices . class . getName ( ) ; private static int decimals = UtilNumber . getBigDecimalScale ( \"invoice.decimals\" ) ; private static int rounding = UtilNumber . getBigDecimalRoundingMode ( \"invoice.rounding\" ) ; public final static String resource = \"AccountingUiLabels\" ; public static Map < String , Object > ccAuth ( DispatchContext dctx , Map < String , Object > context ) { String ccAction = ( String ) context . get ( \"ccAction\" ) ; if ( ccAction == null ) ccAction = \"PreAuth\" ; Document authRequestDoc = buildPrimaryTxRequest ( context , ccAction , ( BigDecimal ) context . get ( \"processAmount\" ) , ( String ) context . get ( \"orderId\" ) ) ; Document authResponseDoc = null ; try { authResponseDoc = sendRequest ( authRequestDoc , ( String ) context . get ( \"paymentConfig\" ) ) ; } catch ( ClearCommerceException cce ) { return ServiceUtil . returnError ( cce . getMessage ( ) ) ; } if ( getMessageListMaxSev ( authResponseDoc ) > 4 ) { Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"authResult\" , new Boolean ( false ) ) ; result . put ( \"processAmount\" , BigDecimal . ZERO ) ; result . put ( \"authRefNum\" , getReferenceNum ( authResponseDoc ) ) ; List < String > messages = getMessageList ( authResponseDoc ) ; if ( UtilValidate . isNotEmpty ( messages ) ) { result . put ( \"internalRespMsgs\" , messages ) ; } return result ; } return processAuthResponse ( authResponseDoc ) ; } public static Map < String , Object > ccCredit ( DispatchContext dctx , Map < String , Object > context ) { String action = \"Credit\" ; if ( context . get ( \"pbOrder\" ) != null ) { action = \"Auth\" ; } Document creditRequestDoc = buildPrimaryTxRequest ( context , action , ( BigDecimal ) context . get ( \"creditAmount\" ) , ( String ) context . get ( \"referenceCode\" ) ) ; Document creditResponseDoc = null ; try { creditResponseDoc = sendRequest ( creditRequestDoc , ( String ) context . get ( \"paymentConfig\" ) ) ; } catch ( ClearCommerceException cce ) { return ServiceUtil . returnError ( cce . getMessage ( ) ) ; } if ( getMessageListMaxSev ( creditResponseDoc ) > 4 ) { Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"creditResult\" , new Boolean ( false ) ) ; result . put ( \"creditAmount\" , BigDecimal . ZERO ) ; result . put ( \"creditRefNum\" , getReferenceNum ( creditResponseDoc ) ) ; List < String > messages = getMessageList ( creditResponseDoc ) ; if ( UtilValidate . isNotEmpty ( messages ) ) { result . put ( \"internalRespMsgs\" , messages ) ; } return result ; } return processCreditResponse ( creditResponseDoc ) ; } public static Map < String , Object > ccCapture ( DispatchContext dctx , Map < String , Object > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; GenericValue orderPaymentPreference = ( GenericValue ) context . get ( \"orderPaymentPreference\" ) ; GenericValue authTransaction = PaymentGatewayServices . getAuthTransaction ( orderPaymentPreference ) ; if ( authTransaction == null ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"AccountingPaymentTransactionAuthorizationNotFoundCannotCapture\" , locale ) ) ; } Document captureRequestDoc = buildSecondaryTxRequest ( context , authTransaction . getString ( \"referenceNum\" ) , \"PostAuth\" , ( BigDecimal ) context . get ( \"captureAmount\" ) ) ; Document captureResponseDoc = null ; try { captureResponseDoc = sendRequest ( captureRequestDoc , ( String ) context . get ( \"paymentConfig\" ) ) ; } catch ( ClearCommerceException cce ) { return ServiceUtil . returnError ( cce . getMessage ( ) ) ; } if ( getMessageListMaxSev ( captureResponseDoc ) > 4 ) { Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put", "gt": "( \"captureResult\" , new Boolean ( false ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10973, "input": "<s> package com . puppycrawl . tools . checkstyle . bcel ; import java . util . Set ; public interface IObjectSetVisitor { void visitSet ( Set aSet ) ; void leaveSet ( Set aSet ) ;", "gt": "void visitObject ( Object aObject ) ;", "prediction": "}\n", "label": 1}
{"id": 704, "input": "<s> import org . parboiled . common . FileUtils ; import org . parboiled . common . ImmutableList ; import org . scalatest . testng . TestNGWrapperSuite ; import java . io . File ; import java . io . IOException ; import static scala . collection . JavaConversions . collectionAsScalaIterable ; @ SuppressWarnings ( \"unchecked\" ) public class CoreTestWrapper extends TestNGWrapperSuite { public CoreTestWrapper ( ) throws IOException { super ( collectionAsScalaIterable ( ImmutableList . of ( getSuiteFileName ( ) ) ) . toList ( ) ) ; } public static String getSuiteFileName ( ) throws IOException { File temp = File . createTempFile ( \"parboiled_testng_suite\" , \".xml\" ) ; temp . deleteOnExit ( ) ; String xml = \"\" + \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<!DOCTYPE suite SYSTEM \\\"http://testng.org/testng-1.0.dtd\\\">\\n\" + \"<suite name=\\\"parboiled-core\\\">\\n\" + \"  <test verbose=\\\"1\\\" name=\\\"parboiled-core\\\" annotations=\\\"JDK\\\">\\n\" + \"    <packages>\\n\" + \"      <package name=\\\"org.parboiled.*\\\" />\\n\" + \"    </packages>\\n\" + \"  </test>\\n\" + \"</suite>\" ; FileUtils . writeAllText", "gt": "( xml , temp ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 10979, "input": "<s> package com . petpet . sc . listeners ; import android . view . MotionEvent ; import android . view . View ; import android . view . View . OnTouchListener ; import android . widget . Button ; import com . petpet . sc . widget . SegmentedControl ; public class SCTouchListener implements OnTouchListener { private SegmentedControl sc ; public SCTouchListener ( SegmentedControl sc ) { this . sc = sc ; } @ Override public boolean onTouch ( View v , MotionEvent e ) { System . out . println ( \"touched segmented outer\" ) ; boolean processed = false ; if ( e . getAction ( ) == MotionEvent . ACTION_UP ) { System . out . println ( \"touched segmented\" ) ; this . sc", "gt": ". stateChanged ( ( Button ) v ) ;", "prediction": ";\n", "label": 1}
{"id": 3523, "input": "<s> package org . ofbiz . order . shoppingcart ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . GeneralRuntimeException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . marketing . tracking . TrackingCodeEvents ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . party . party . PartyWorker ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . webapp . stats . VisitHandler ; public class CheckOutEvents { public static final String module = CheckOutEvents . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static String cartNotEmpty ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = ShoppingCartEvents . getCartObject ( request ) ; if ( cart != null && UtilValidate . isNotEmpty ( cart . items ( ) ) ) { return \"success\" ; } else { String errMsg = UtilProperties . getMessage ( resource_error , \"checkevents.cart_empty\" , ( cart != null ? cart . getLocale ( ) : UtilHttp . getLocale ( request ) ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } } public static String setCheckOutPages ( HttpServletRequest request , HttpServletResponse response ) { if ( \"error\" . equals ( CheckOutEvents . cartNotEmpty ( request , response ) ) == true ) { return \"error\" ; } HttpSession session = request . getSession ( ) ; String curPage = request . getParameter ( \"checkoutpage\" ) ; Debug . logInfo ( \"CheckoutPage: \" + curPage , module ) ; ShoppingCart cart = ( ShoppingCart ) session . getAttribute ( \"shoppingCart\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; GenericValue userLogin = cart . getUserLogin ( ) ; if ( userLogin == null ) userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; if ( curPage == null ) { try { cart . createDropShipGroups ( dispatcher ) ; } catch ( CartItemModifyException e ) { Debug . logError ( e , module ) ; } } else if ( \"shippingoptions\" . equals ( curPage ) == true ) { cart . cleanUpShipGroups ( ) ; } CheckOutHelper checkOutHelper = new CheckOutHelper ( dispatcher , delegator , cart ) ; if ( \"shippingaddress\" . equals ( curPage ) == true ) { String shippingContactMechId = request . getParameter ( \"shipping_contact_mech_id\" ) ; String taxAuthPartyGeoIds = request . getParameter ( \"taxAuthPartyGeoIds\" ) ; String partyTaxId = request . getParameter ( \"partyTaxId\" ) ; String isExempt = request . getParameter ( \"isExempt\" ) ; List < String > errorMessages = new ArrayList < String > ( ) ; Map < String , Object > errorMaps = new HashMap < String , Object > ( ) ; for ( int shipGroupIndex = 0 ; shipGroupIndex < cart . getShipGroupSize ( ) ; shipGroupIndex ++ ) { if ( shippingContactMechId == null ) { shippingContactMechId = ( String ) request . getAttribute ( \"contactMechId\" ) ; } String supplierPartyId = ( String ) request . getAttribute ( shipGroupIndex + \"_supplierPartyId\" ) ; Map < String , ? extends Object > callResult = checkOutHelper . finalizeOrderEntryShip ( shipGroupIndex , shippingContactMechId , supplierPartyId ) ; ServiceUtil . addErrors ( errorMessages , errorMaps , callResult ) ; } if ( UtilValidate . isNotEmpty ( taxAuthPartyGeoIds ) ) { try { Map < String , ? extends Object > createCustomerTaxAuthInfoResult = dispatcher . runSync ( \"createCustomerTaxAuthInfo\" , UtilMisc . < String , Object > toMap ( \"partyId\" , cart . getPartyId ( ) , \"taxAuthPartyGeoIds\" , taxAuthPartyGeoIds , \"partyTaxId\" , partyTaxId , \"isExempt\" , isExempt , \"userLogin\" , userLogin ) ) ; ServiceUtil . getMessages ( request , createCustomerTaxAuthInfoResult , null ) ; if ( ServiceUtil . isError ( createCustomerTaxAuthInfoResult ) ) { return \"error\" ; } } catch ( GenericServiceException e ) { String errMsg = \"Error setting customer tax info: \" + e . toString ( ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } } Map < String , ? extends Object > callResult = checkOutHelper . setCheckOutShippingAddress ( shippingContactMechId ) ; ServiceUtil . getMessages ( request , callResult , null ) ; if ( ! ( ServiceUtil . isError ( callResult ) ) ) { curPage = \"shippingoptions\" ; } } else if ( \"shippingoptions\" . equals ( curPage ) == true ) { String shippingMethod = request . getParameter ( \"shipping_method\" ) ; String shippingInstructions = request . getParameter ( \"shipping_instructions\" ) ; String orderAdditionalEmails = request . getParameter ( \"order_additional_emails\" ) ; String maySplit = request . getParameter ( \"may_split\" ) ; String giftMessage = request . getParameter ( \"gift_message\" ) ; String isGift = request . getParameter ( \"is_gift\" ) ; String internalCode = request . getParameter ( \"internalCode\" ) ; String", "gt": "shipBeforeDate = request . getParameter ( \"shipBeforeDate\" ) ;", "prediction": "}\n", "label": 0}
{"id": 10981, "input": "<s> package net . claribole . zgrviewer . dot ; import java . awt . Color ; import java . awt . geom . Point2D ; import java . util . StringTokenizer ; import java . util . Vector ; public class DotUtils { public static Rectangle readRectangle ( String v ) { if ( v . equals ( \"\" ) ) return null ; StringTokenizer st = new StringTokenizer ( v ) ; int x1 = Integer . parseInt ( st . nextToken ( \", \" ) ) ; int y1 = Integer . parseInt ( st . nextToken ( \", \" ) ) ; int x2 = Integer . parseInt ( st . nextToken ( \", \" ) ) ; int y2 = Integer . parseInt ( st . nextToken ( \", \" ) ) ; return new Rectangle ( x1 , y1 , x2 , y2 ) ; } public static boolean readBoolean ( String v ) { return Boolean . valueOf ( v ) . booleanValue ( ) ; } public static ViewPort readViewPort ( String v ) { StringTokenizer st = new StringTokenizer ( v ) ; int W = Integer . parseInt ( st . nextToken ( \", \" ) ) ; int H = Integer . parseInt ( st . nextToken ( \", \" ) ) ; double Z = Double . parseDouble ( st . nextToken ( \", \" ) ) ; double x = Double . parseDouble ( st . nextToken ( \", \" ) ) ; double y = Double . parseDouble ( st . nextToken ( \", \" ) ) ; return new ViewPort ( W , H , Z , x , y ) ; } public static Point2D . Double readPointf ( String v ) { StringTokenizer st = new StringTokenizer ( v ) ; double x = Double . parseDouble ( st . nextToken ( \", \" ) ) ; double y = Double . parseDouble ( st . nextToken ( \", \" ) ) ; return new Point2D . Double ( x , y ) ; } public static Point readPoint ( String v ) { Point p ; String r ; if ( v . endsWith ( \"!\" ) ) { p = new Point ( false ) ; r = v . substring ( 0 , v . length ( ) - 1 ) ; } else { p = new Point ( true ) ; r = v ; } String [ ] str = r . split ( \",\" ) ; p . coords = new long [ str . length ] ; for ( int i = 0 ; i < p . coords . length ; i ++ ) { try { p . coords [ i ] = Long . valueOf ( str", "gt": "[ i ] ) . longValue ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7724, "input": "<s> import java . util . Scanner ; public class UserInput { Scanner scanner ; public UserInput ( ) { scanner = new Scanner ( System . in ) ; } public String askBookName ( ) { System . out . print ( \"\\nEnter Book Name:\" ) ; return scanner . nextLine ( ) ; } public int askChoice ( ) { System . out . print ( \"\\nEnter your choice:\" ) ; int choice = 0 ; while ( true ) { try { choice = Integer . parseInt ( scanner . nextLine ( ) ) ; return choice ; } catch ( NumberFormatException numberFormatException ) { System . out .", "gt": "print ( \"\\nSorry! Wrong Choice. Enter Again:\" ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 10983, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import static javax . ws . rs . core . MediaType . APPLICATION_XML ; import static javax . ws . rs . core . MediaType . TEXT_XML ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . restlet . test . ext . jaxrs . services . others . Person ; @ Path (", "gt": "\"appPlusXml\" ) public class AppPlusXmlResource", "prediction": ") ;\n", "label": 1}
{"id": 1838, "input": "<s> package org . apache . felix . resolver . impl ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . osgi . framework . resource . Capability ; import org . osgi . framework . resource . Requirement ; import org . osgi . framework . resource . Resource ; import org . osgi . framework . resource . ResourceConstants ; class HostResource implements Resource { private final Resource m_host ; private final List < Resource > m_fragments ; private List < Capability > m_cachedCapabilities = null ; private List < Requirement > m_cachedRequirements = null ; public HostResource ( Resource host , List < Resource > fragments ) { m_host = host ; m_fragments = fragments ; } public Resource getHost ( ) { return m_host ; } public List < Resource > getFragments ( ) { return m_fragments ; } public List < Capability > getCapabilities ( String namespace ) { if ( m_cachedCapabilities == null ) { List < Capability > caps = new ArrayList < Capability > ( ) ; for ( Capability cap : m_host . getCapabilities ( null ) ) { caps . add ( new HostedCapability ( this , cap ) ) ; } if ( m_fragments != null ) { for ( Resource fragment : m_fragments ) { for ( Capability cap : fragment . getCapabilities ( null ) ) { caps . add ( new HostedCapability ( this , cap ) ) ; } } } m_cachedCapabilities = Collections . unmodifiableList ( caps ) ; } return m_cachedCapabilities ; } public List < Requirement > getRequirements ( String namespace ) { if ( m_cachedRequirements == null ) { List < Requirement > reqs = new ArrayList < Requirement > ( ) ; for ( Requirement req : m_host . getRequirements ( null ) ) { reqs . add ( new HostedRequirement ( this , req ) ) ; } if ( m_fragments != null ) { for ( Resource fragment : m_fragments ) { for ( Requirement req : fragment . getRequirements ( null ) ) { if ( ! req . getNamespace ( ) . equals ( ResourceConstants . WIRING_HOST_NAMESPACE ) ) { reqs . add ( new HostedRequirement (", "gt": "this , req ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 10985, "input": "<s> package org . eclipse . ui . internal . actions ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . IWorkingSetManager ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . WorkingSetFilterActionGroup ; import org . eclipse . ui . dialogs . IWorkingSetSelectionDialog ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchMessages ; public class SelectWorkingSetAction extends Action { private Shell shell ; private WorkingSetFilterActionGroup actionGroup ; public SelectWorkingSetAction ( WorkingSetFilterActionGroup actionGroup , Shell shell ) { super ( WorkbenchMessages . get ( ) . SelectWorkingSetAction_text ) ; Assert . isNotNull ( actionGroup ) ; setToolTipText ( WorkbenchMessages . get ( ) . SelectWorkingSetAction_toolTip ) ; this . shell = shell ; this . actionGroup = actionGroup ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IWorkbenchHelpContextIds . SELECT_WORKING_SET_ACTION ) ; } public void run ( ) { IWorkingSetManager manager = PlatformUI . getWorkbench ( ) . getWorkingSetManager ( ) ; IWorkingSetSelectionDialog dialog = manager . createWorkingSetSelectionDialog", "gt": "( shell , false ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 7926, "input": "<s> package org . ofbiz . party . party ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityTypeUtil ; public class PartyTypeHelper { public static final String module = PartyTypeHelper . class . getName ( ) ; public static Boolean checkPartyType ( Delegator delegator , String partyId , String checkedPartyType ) { GenericValue party = null ; GenericValue partyType = null ; GenericValue checkedTypeOfParty = null ; try { party = delegator . findOne ( \"Party\" , UtilMisc . toMap ( \"partyId\" , partyId ) , false ) ; if ( UtilValidate . isNotEmpty ( party ) ) { partyType = party . getRelatedOne", "gt": "( \"PartyType\" , true ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11020, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . PathParam ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . resources . PathParamTestService ; public class PathParamTest extends JaxRsTestCase { private Reference createReference2 ( String subPath ) { final String baseRef = createBaseRef ( ) + \"/pathParamTest/\" + subPath ; return new Reference ( createBaseRef ( ) , baseRef ) ; } @ Override protected Application getApplication ( ) { return new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( PathParamTestService . class ) ; } } ; } public void htestCheckUnmodifiable ( ) { final Response response = get ( createReference2 ( \"4711/checkUnmodifiable/1667\" ) ) ; assertTrue ( \"The List annotated with @PathParam must not be modifiable. Status is \" + response . getStatus ( ) , response . getStatus ( ) . isSuccess ( ) ) ; } public void testGet1 ( ) throws IOException { final Response response = get ( createReference2 ( \"4711\" ) ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"4711\" , response . getEntity ( ) . getText ( ) ) ; } public void testGet2 ( ) throws IOException { final Response response = get ( createReference2 ( \"4711/abc/677/def\" ) ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"4711\\n677\" , response . getEntity ( ) . getText ( ) ) ; } public void testGet4 ( ) throws IOException { final Response response = get ( createReference2 ( \"12/st/34\" ) ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"34\" , response . getEntity ( ) . getText ( ) ) ; } public void testGetRegExpPathEinBuchstabe ( ) throws IOException { Response response = get ( \"regExp/a\" ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"ein Buchstabe: a\" , response . getEntity ( ) . getText ( ) ) ; } public void testGetRegExpPathLangerString ( ) throws IOException { Response response = get ( \"regExp/aa\" ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"anderes: aa\" , response . getEntity ( ) . getText ( ) ) ; } public void", "gt": "testGetRegExpPathZahl ( ) throws IOException", "prediction": "( ) ;\n", "label": 1}
{"id": 3507, "input": "<s> package varargs . override ; class A { void f ( Object [ ] o ) { } } class B extends A { void", "gt": "f ( Object ... o )", "prediction": "( )\n", "label": 0}
{"id": 11022, "input": "<s> package br . org . archimedes . intersectors ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . util . Collection ; import java . util . Collections ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Point ; import br . org . archimedes . semiline . Semiline ; public class SemilineLineIntersectorTest extends Tester { @ Test public void simpleLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { SemilineLineIntersector lli = new SemilineLineIntersector ( ) ; Semiline line1 = new Semiline ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( - 1 , 3 , 10 , 3 ) ; Point p0 = new Point ( 3 , 3 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertCollectionTheSame ( Collections . singleton ( p0 ) , intersections ) ; } @ Test public void paralelsLinesIntersection ( ) throws InvalidArgumentException , NullArgumentException { SemilineLineIntersector lli = new SemilineLineIntersector ( ) ; Semiline line1 = new Semiline ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void sameLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { SemilineLineIntersector lli = new SemilineLineIntersector ( ) ; Semiline line1 = new Semiline ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void subLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { SemilineLineIntersector lli = new SemilineLineIntersector ( ) ; Semiline line1 = new Semiline ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line (", "gt": "3 , 3 , 10 , 10 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9651, "input": "<s> package com . atlassian . crowd . integration . exception ; @ SuppressWarnings ( \"serial\" ) public class InvalidGroupException extends org . apache . axis . AxisFault implements java . io . Serializable { public InvalidGroupException ( ) { } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof InvalidGroupException ) ) return false ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( InvalidGroupException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://exception.integration.crowd.atlassian.com\" , \"InvalidGroupException\" ) ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; } public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer", "gt": "( _javaType , _xmlType , typeDesc ) ;", "prediction": ";\n", "label": 0}
{"id": 11025, "input": "<s> package net . claribole . zgrviewer . dot ; import java . awt . Point ; import java . awt . geom . Point2D ; class ViewPort { Point dimensions ; Point2D . Double position ; double Z ; public ViewPort ( int W , int H , double Z , double x , double y ) { this . dimensions", "gt": "= new Point ( W , H ) ;", "prediction": ";\n", "label": 1}
{"id": 5323, "input": "<s> package ar . com . fdvs . dj . util ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . util . Collection ; import net . sf . jasperreports . engine . design . JRDesignStyle ; import org . apache . commons . beanutils . BeanUtils ; import org . apache . commons . beanutils . BeanUtilsBean ; import org . apache . commons . beanutils . PropertyUtils ; import ar . com . fdvs . dj . core . DJException ; import ar . com . fdvs . dj . domain . Style ; public class Utils { private Utils ( ) { } public static boolean isEmpty ( Collection col ) { if ( col == null ) return true ; return col . isEmpty ( ) ; } public static void copyProperties ( Object dest , Object orig ) { try { if ( orig != null && dest != null ) { BeanUtils . copyProperties ( dest , orig ) ; PropertyUtils putils = new PropertyUtils ( ) ; PropertyDescriptor origDescriptors [ ] = putils . getPropertyDescriptors ( orig ) ; for ( int i = 0 ; i < origDescriptors . length ; i ++ ) { String name = origDescriptors [ i ] . getName ( ) ; if ( \"class\" . equals ( name ) ) { continue ; } Class propertyType = origDescriptors [ i ] . getPropertyType ( ) ; if ( ! Boolean . class . equals ( propertyType ) && ! ( boolean . class . equals ( propertyType ) ) ) continue ; if ( ! putils . isReadable ( orig , name ) ) { Method m = orig . getClass ( ) . getMethod ( \"is\" + name . substring ( 0 , 1 ) . toUpperCase ( ) + name . substring ( 1 ) , null ) ; Object value = m . invoke ( orig , null ) ; if ( m != null && putils . isWriteable ( dest , name ) ) { BeanUtilsBean . getInstance ( ) . copyProperty ( dest , name , value ) ; } } } } } catch ( Exception e ) { throw new DJException ( \"Could not copy properties for shared object: \" + orig + \", message: \" + e . getMessage ( ) , e ) ; } } public static void main ( String [ ] args ) { JRDesignStyle s1 = new Style ( ) . transform ( ) ; JRDesignStyle s2 = new Style ( ) . transform ( ) ; s1 . setBold ( Boolean . TRUE ) ; s1 . setItalic ( Boolean . TRUE ) ; s1 . setUnderline ( Boolean . TRUE ) ; Utils . copyProperties ( s2 , s1 ) ; System . out . println ( s2 . isBold ( ) + \" - \" + s2 . isItalic ( ) + \" - \" + s2 . isUnderline ( ) ) ; } public static String", "gt": "escapeTextForExpression ( String text )", "prediction": "( ) ;\n", "label": 0}
{"id": 11043, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . ListViewer ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . List ; public class ListViewerTest extends StructuredViewerTest { public ListViewerTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { ListViewer viewer = new ListViewer ( parent ) ; viewer . setContentProvider ( new TestModelContentProvider ( ) ) ; return viewer ; } protected int getItemCount ( ) { TestElement first = fRootElement . getFirstChild ( ) ; List list = ( List ) fViewer . testFindItem ( first ) ; return list . getItemCount ( ) ; } protected String getItemText ( int at ) { List list = ( List ) fViewer . getControl ( ) ; return list . getItem ( at ) ; } public static void main ( String args [ ] ) { junit . textui . TestRunner . run ( ListViewerTest . class ) ; } public void testInsert ( ) { ListViewer v = ( ( ListViewer ) fViewer ) ; TestElement element = new TestElement ( fModel , fRootElement ) ; v . insert ( element , 1 ) ; assertSame ( \"test insert\" , element , v . getElementAt ( 1 ) ) ; assertEquals ( \"test insert\" , element . toString ( ) , v . getList ( ) . getItem ( 1 ) ) ; v . addFilter ( new ViewerFilter ( ) { public boolean select ( Viewer viewer , Object parentElement , Object element ) { return true ; } } ) ; TestElement element1 = new TestElement ( fModel , fRootElement ) ; v . insert ( element1 , 1 ) ; assertNotSame ( \"test insert\" , element1 , v . getElementAt ( 1 ) ) ; v . setFilters ( new ViewerFilter [ 0 ] ) ; v . remove ( element ) ; v . remove ( element1 ) ; } public void testRefreshBug141435 ( ) throws Exception { fViewer = null ; if ( fShell != null ) { fShell . dispose ( ) ; fShell = null ; } openBrowser ( ) ; TestElement model = TestElement . createModel ( 1 , 50 ) ; fViewer . setInput ( model ) ; int lastIndex = model . getChildCount ( ) - 1 ; fViewer . reveal ( model . getChildAt ( lastIndex ) ) ; List list = ( List ) fViewer . getControl ( ) ; int topIndex = list . getTopIndex ( ) ; assertTrue ( \"Top item should not be the first item.\" , topIndex != 0 ) ; fViewer . refresh ( ) ; processEvents ( ) ; assertEquals ( \"Top index was not preserved after refresh.\" , topIndex , list . getTopIndex ( ) ) ; model . deleteChildren ( ) ; try { fViewer . refresh ( ) ; assertEquals ( 0 , list . getTopIndex ( ) ) ; } catch ( Exception e ) { fail ( \"Refresh failure when refreshing with an empty model.\" ) ; } } public void testSelectionRevealBug177619 ( ) throws Exception { TestElement model = TestElement . createModel ( 1 , 100 ) ; fViewer . setInput ( model ) ; fViewer . setSelection ( new StructuredSelection ( ( ( ListViewer ) fViewer ) . getElementAt ( 50 ) ) , true ) ; assertTrue ( ( ( ListViewer ) fViewer ) . getList ( ) . getTopIndex ( ) != 0 ) ; } public void testSelectionNoRevealBug177619 ( ) throws Exception { TestElement model = TestElement . createModel ( 1 , 100 ) ; fViewer . setInput ( model ) ; fViewer . setSelection ( new StructuredSelection ( ( ( ListViewer ) fViewer ) . getElementAt ( 50 )", "gt": ") , false ) ;", "prediction": ";\n", "label": 1}
{"id": 592, "input": "<s> import java . util . * ; class IllegalInstanceof { List o ; boolean b = (", "gt": "o instanceof List < String > ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11053, "input": "<s> package org . restlet . ext . odata . internal . edm ; public class Namespace extends NamedObject { private String alias ; public Namespace ( String name ) { super ( name ) ; } public String getAlias ( ) { return alias ; } public void setAlias ( String alias ) { this", "gt": ". alias = alias ;", "prediction": "\n", "label": 1}
{"id": 749, "input": "<s> package org . globaleaks . android ; import java . net . Socket ; import org . globaleaks . android . net . WebClient ; import android . app . Activity ; import android . app . AlertDialog ; import android . content . ContentValues ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . pm . ApplicationInfo ; import android . content . pm . PackageManager ; import android . net . Uri ; import android . os . Bundle ; import android . preference . PreferenceManager ; import android . provider . MediaStore ; import android . util . Log ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . Button ; import android . widget . EditText ; import android . widget . ImageView ; import android . widget . Toast ; public class MainActivity extends Activity implements OnClickListener { public static final String LOG_TAG = \"GLDroid\" ; private static final int CODE_SELECT_IMG = 0 ; private static final int CODE_TAKE_IMG = 1 ; private static final String TMP_IMAGE = \"globaleaks.jpg\" ; private Button submitButton ; private Button clearButton ; private Button takePicture ; private Button selectPicture ; private ImageView torStatus ; private Bundle bundle ; private Uri uriImageResult ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Log . i ( LOG_TAG , \"onCreate()\" ) ; setLayout ( ) ; } @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; Log . i ( LOG_TAG , \"onDestroy\" ) ; } @ Override protected void onPause ( ) { super . onPause ( ) ; Log . i ( LOG_TAG , \"onPause\" ) ; } @ Override protected void onRestart ( ) { super . onRestart ( ) ; Log . i ( LOG_TAG , \"onRestart\" ) ; } @ Override protected void onResume ( ) { super . onResume ( ) ; refreshTorIcon ( ) ; Log . i ( LOG_TAG , \"onResume\" ) ; } @ Override protected void onStart ( ) { super . onStart ( ) ; Log . i ( LOG_TAG , \"onStart\" ) ; } @ Override protected void onStop ( ) { super . onStop ( ) ; Log . i ( LOG_TAG , \"onStop\" ) ; } private void setLayout ( ) { setContentView ( R . layout . main ) ; submitButton = ( Button ) findViewById ( R . id . submitButton ) ; submitButton . setOnClickListener ( this ) ; clearButton = ( Button ) findViewById ( R . id . clearButton ) ; clearButton . setOnClickListener ( this ) ; takePicture = ( Button ) findViewById ( R . id . takePictureButton ) ; takePicture . setOnClickListener ( this ) ; selectPicture = ( Button ) findViewById ( R . id . selectPictureButton ) ; selectPicture . setOnClickListener ( this ) ; torStatus = ( ImageView ) findViewById ( R . id . torStatusImage ) ; refreshTorIcon ( ) ; } private void refreshTorIcon ( ) { if ( isTorInstalled ( ) && isTorEnabled ( ) ) { torStatus . setVisibility ( ImageView . VISIBLE ) ; } else { torStatus . setVisibility ( ImageView . INVISIBLE ) ; } int iconId = R . drawable . tor_off ; if ( torProxy ( ) ) { iconId = R . drawable . tor_on ; } torStatus . setImageDrawable ( getResources ( ) . getDrawable ( iconId ) ) ; if ( isTorEnabled ( ) && ! ( isTorInstalled ( ) && isTorProxyRunning ( ) ) ) { submitButton . setEnabled ( false ) ; } else { submitButton . setEnabled ( true ) ; } } @ Override public void onClick ( View view ) { if ( bundle == null ) { bundle = new Bundle ( ) ; } System . out . println ( \"onClick\" ) ; if ( view == submitButton ) { SharedPreferences sp = PreferenceManager . getDefaultSharedPreferences ( this ) ; String baseUrl = sp . getString ( getResources ( ) . getString ( R . string . base_url ) , \"demo.globaleaks.org\" ) ; WebClient client = new WebClient ( baseUrl , this ) ; EditText title = ( EditText ) findViewById ( R . id . submitTitleText ) ; EditText desc = ( EditText ) findViewById ( R . id . submitDescriptionText ) ; Intent intent = new Intent ( this , WebClient . class ) ; bundle . putString ( \"title\" , title . getText ( ) . toString ( ) ) ; bundle . putString ( \"description\" , desc . getText ( ) . toString ( ) ) ; intent . putExtras ( bundle ) ; try { client . submit ( intent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; showDialog ( \"Error submitting data\" ) ; } }", "gt": "else if ( view == clearButton )", "prediction": "}\n", "label": 0}
{"id": 11056, "input": "<s> package future ; import org . lwjgl . BufferUtils ; import org . lwjgl . LWJGLException ; import org . lwjgl . input . Keyboard ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import org . lwjgl . opengl . GLContext ; import org . lwjgl . util . glu . Sphere ; import org . lwjgl . util . vector . Matrix4f ; import org . lwjgl . util . vector . Vector3f ; import java . nio . FloatBuffer ; import static org . lwjgl . opengl . ARBShadowAmbient . GL_TEXTURE_COMPARE_FAIL_VALUE_ARB ; import static org . lwjgl . opengl . EXTFramebufferObject . * ; import static org . lwjgl . opengl . GL11 . * ; import static org . lwjgl . opengl . GL12 . GL_CLAMP_TO_EDGE ; import static org . lwjgl . opengl . GL14 . * ; import static org . lwjgl . util . glu . GLU . gluLookAt ; import static org . lwjgl . util . glu . GLU . gluPerspective ; public class ShadowMapping { private static boolean ambientShadowsAvailable ; private static boolean showShadowMap = false ; private static boolean useFBO = true ; private static float factor = 4.0F ; public static int maxTextureSize ; private static int shadowWidth = 640 ; private static int shadowHeight = 480 ; private static int frameBuffer ; private static int renderBuffer ; private static FloatBuffer ambientLight = BufferUtils . createFloatBuffer ( 4 ) ; private static FloatBuffer diffuseLight = BufferUtils . createFloatBuffer ( 4 ) ; private static FloatBuffer lightPosition = BufferUtils . createFloatBuffer ( 4 ) ; private static FloatBuffer cameraPosition = BufferUtils . createFloatBuffer ( 4 ) ; private static FloatBuffer tempBuffer = BufferUtils . createFloatBuffer ( 4 ) ; private static Matrix4f textureMatrix = new Matrix4f ( ) ; private static Sphere sphere = new Sphere ( ) ; public static void main ( String [ ] args ) { setUpDisplay ( ) ; setUpBufferValues ( ) ; setUpOpenGL ( ) ; while ( ! Display . isCloseRequested ( ) ) { render ( ) ; input ( ) ; Display . update ( ) ; Display . sync ( 60 ) ; } cleanUp ( ) ; System . exit ( 0 ) ; } private static void setUpDisplay ( ) { try { Display . setDisplayMode ( new DisplayMode ( 640 , 480 ) ) ; Display . setTitle ( \"Shadow Mapping Demo\" ) ; Display . create ( ) ; } catch ( LWJGLException e ) { System . err . println ( \"Couldn't set up the display\" ) ; Display . destroy ( ) ; System . exit ( 1 ) ; } } private static void renderObjects ( boolean drawGround ) { if ( drawGround ) { glColor3f ( 0.0F , 0.0F , 0.9F ) ; glNormal3f ( 0.0F , 1.0F , 0.0F ) ; glBegin ( GL_QUADS ) ; glVertex3f ( - 100.0F , - 25.0F , - 100.0F ) ; glVertex3f ( - 100.0F , - 25.0F , 100.0F ) ; glVertex3f ( 100.0F , - 25.0F , 100.0F ) ; glVertex3f ( 100.0F , - 25.0F , - 100.0F ) ; glEnd ( ) ; } glColor3f ( 1.0F , 0.0F / 10 , 0.0F ) ; sphere . draw ( 12.0F , 50 , 50 ) ; glColor3f ( 0.0F , 1.0F , 0.0F ) ; glPushMatrix ( ) ; glTranslatef ( - 60.0F , 0.0F , 0.0F ) ; sphere . draw ( 14.0F , 50 , 50 ) ; glPopMatrix ( ) ; glColor3f ( 1.0F , 1.0F , 0.0F ) ; glPushMatrix ( ) ; glTranslatef ( - 60.0F , 0.0F , - 24.0F ) ; sphere . draw ( 15.0F , 50 , 50 ) ; glPopMatrix ( ) ; glColor3f ( 1.0F , 0.0F , 1.0F ) ; glPushMatrix ( ) ; glTranslatef ( 0.0F , 0.0F , 60.0F ) ; sphere . draw ( 16.0F , 50 , 50 ) ; glPopMatrix ( ) ; glColor3f ( 0.0F , 1.0F , 1.0F ) ; glPushMatrix ( ) ; glTranslatef ( 0.0F , 0.0F , - 60.0F ) ; sphere . draw ( 22.0F , 50 , 50 ) ; glPopMatrix ( ) ; } private static void generateShadowMap ( ) { float lightToSceneDistance , nearPlane , fieldOfView ; FloatBuffer lightModelView = BufferUtils . createFloatBuffer ( 16 ) ; FloatBuffer lightProjection = BufferUtils . createFloatBuffer ( 16 ) ; Matrix4f lightProjectionTemp = new Matrix4f ( ) ; Matrix4f lightModelViewTemp = new Matrix4f ( ) ; float sceneBoundingRadius = 95.0F ; lightToSceneDistance = ( float ) Math . sqrt ( lightPosition . get ( 0 ) * lightPosition . get ( 0 ) + lightPosition . get ( 1 ) * lightPosition . get ( 1 ) + lightPosition . get ( 2 ) * lightPosition . get ( 2 ) ) ; nearPlane = lightToSceneDistance - sceneBoundingRadius ; fieldOfView = ( float ) Math . toDegrees ( 2.0F * Math . atan ( sceneBoundingRadius / lightToSceneDistance ) ) ; glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; gluPerspective ( fieldOfView , 1.0F , nearPlane , nearPlane + ( 2.0F * sceneBoundingRadius ) ) ; glGetFloat ( GL_PROJECTION_MATRIX , lightProjection ) ; glMatrixMode ( GL_MODELVIEW ) ; glLoadIdentity ( ) ; gluLookAt ( lightPosition . get ( 0 ) , lightPosition . get ( 1 ) , lightPosition . get ( 2 ) , 0.0F , 0.0F , 0.0F , 0.0F , 1.0F , 0.0F ) ; glGetFloat ( GL_MODELVIEW_MATRIX , lightModelView ) ; glViewport ( 0 , 0 , shadowWidth , shadowHeight ) ; if ( useFBO ) { glBindFramebufferEXT ( GL_FRAMEBUFFER_EXT , frameBuffer ) ; } glClear ( GL_DEPTH_BUFFER_BIT ) ; glShadeModel ( GL_FLAT ) ; glDisable ( GL_LIGHTING ) ; glDisable ( GL_COLOR_MATERIAL ) ; glDisable ( GL_NORMALIZE ) ; glColorMask ( false , false , false , false ) ; glEnable ( GL_POLYGON_OFFSET_FILL ) ; renderObjects ( false ) ; glCopyTexImage2D ( GL_TEXTURE_2D , 0 , GL_DEPTH_COMPONENT , 0 , 0 , shadowWidth , shadowHeight , 0 ) ; if ( useFBO ) { glBindFramebufferEXT ( GL_FRAMEBUFFER_EXT , 0 ) ; } glShadeModel ( GL_SMOOTH ) ; glEnable ( GL_LIGHTING ) ; glEnable ( GL_COLOR_MATERIAL ) ; glEnable ( GL_NORMALIZE ) ; glColorMask ( true , true ,", "gt": "true , true ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2237, "input": "<s> package ar . com . fdvs . dj . core . layout ; import java . awt . Color ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Random ; import net . sf . jasperreports . crosstabs . design . JRDesignCellContents ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstab ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabBucket ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabCell ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabColumnGroup ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabDataset ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabMeasure ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabParameter ; import net . sf . jasperreports . crosstabs . design . JRDesignCrosstabRowGroup ; import net . sf . jasperreports . crosstabs . fill . calculation . BucketDefinition ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRParameter ; import net . sf . jasperreports . engine . base . JRBaseBox ; import net . sf . jasperreports . engine . design . JRDesignConditionalStyle ; import net . sf . jasperreports . engine . design . JRDesignDataset ; import net . sf . jasperreports . engine . design . JRDesignDatasetRun ; import net . sf . jasperreports . engine . design . JRDesignElement ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignField ; import net . sf . jasperreports . engine . design . JRDesignStyle ; import net . sf . jasperreports . engine . design . JRDesignTextField ; import net . sf . jasperreports . engine . design . JasperDesign ; import org . apache . commons . beanutils . BeanUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . core . DJDefaultScriptlet ; import ar . com . fdvs . dj . core . registration . EntitiesRegistrationException ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJCRosstabMeasurePrecalculatedTotalProvider ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJCrosstabColumn ; import ar . com . fdvs . dj . domain . DJCrosstabMeasure ; import ar . com . fdvs . dj . domain . DJCrosstabRow ; import ar . com . fdvs . dj . domain . DJValueFormatter ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . entities . conditionalStyle . ConditionStyleExpression ; import ar . com . fdvs . dj . domain . entities . conditionalStyle . ConditionalStyle ; import ar . com . fdvs . dj . util . ExpressionUtils ; import ar . com", "gt": ". fdvs . dj . util . HyperLinkUtil ;", "prediction": ";\n", "label": 0}
{"id": 11057, "input": "<s> package org . jscsi . scsi . protocol . mode ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . BufferUnderflowException ; public class Caching extends ModePage { public static final byte PAGE_CODE = 0x08 ; public static final int PAGE_LENGTH = 0x12 ; private boolean IC ; private boolean ABPF ; private boolean CAP ; private boolean DISC ; private boolean SIZE ; private boolean WCE ; private boolean MF ; private boolean RCD ; private int demandReadRetentionPriority ; private int writeRetentionPriority ; private int disablePrefetchTransferLength ; private int minimumPrefetch ; private int maximumPrefetch ; private int maximumPrefetchCeiling ; private boolean FSW ; private boolean LBCSS ; private boolean DRA ; private boolean NV_DIS ; private int numberOfCacheSegments ; private int cacheSegmentSize ; public Caching ( ) { super ( PAGE_CODE , PAGE_LENGTH ) ; } @ Override protected void decodeModeParameters ( int dataLength , DataInputStream inputStream ) throws BufferUnderflowException , IllegalArgumentException { try { int b = inputStream . readUnsignedByte ( ) ; this . IC = ( ( b > > > 7 ) & 1 ) == 1 ; this . ABPF = ( ( b > > > 6 ) & 1 ) == 1 ; this . CAP = ( ( b > > > 5 ) & 1 ) == 1 ; this . DISC = ( ( b > > > 4 ) & 1 ) == 1 ; this . SIZE = ( ( b > > > 3 ) & 1 ) == 1 ; this . WCE = ( ( b > > > 2 ) & 1 ) == 1 ; this . MF = ( ( b > > > 1 ) & 1 ) == 1 ; this . RCD = ( b & 1 ) == 1 ; b = inputStream . readUnsignedByte ( ) ; this . demandReadRetentionPriority = ( ( b > > > 4 ) & 0xF ) ; this . writeRetentionPriority = ( b & 0xF ) ; this . disablePrefetchTransferLength = inputStream . readUnsignedShort ( ) ; this . minimumPrefetch = inputStream . readUnsignedShort ( ) ; this . maximumPrefetch = inputStream . readUnsignedShort ( ) ; this . maximumPrefetchCeiling = inputStream . readUnsignedShort ( ) ; b = inputStream . readUnsignedByte ( ) ; this . FSW = ( ( b > > > 7 ) & 1 ) == 1 ; this . LBCSS = ( ( b > > > 6 ) & 1 ) == 1 ; this . DRA = ( ( b > > > 5 ) & 1 ) == 1 ; this . NV_DIS = ( b & 1 ) == 1 ; this . numberOfCacheSegments = inputStream . readUnsignedByte ( ) ; this . cacheSegmentSize = inputStream . readUnsignedShort ( ) ; inputStream . readByte ( ) ; inputStream . readByte ( ) ; inputStream . readByte ( ) ; inputStream . readByte ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( \"Error reading input data.\" ) ; } } @ Override protected void encodeModeParameters ( DataOutputStream output ) { try { int b = 0 ; if ( this . IC ) { b |= 0x80 ; } if ( this . ABPF ) { b |= 0x40 ; } if ( this . CAP ) { b |= 0x20 ; } if ( this . DISC ) { b |= 0x10 ; } if ( this . SIZE ) { b |= 0x08 ; } if ( this . WCE ) { b |= 0x04 ; } if ( this . MF ) { b |= 0x02 ; } if ( this . RCD ) { b |= 0x01 ; } output . writeByte ( b ) ; b = ( this . demandReadRetentionPriority << 4 ) ; b |= this . writeRetentionPriority ; output . writeByte ( b ) ; output . writeShort ( this . disablePrefetchTransferLength ) ; output . writeShort ( this . minimumPrefetch ) ; output . writeShort ( this . maximumPrefetch ) ; output . writeShort ( this . maximumPrefetchCeiling ) ; b = 0 ; if ( this . FSW ) { b |= 0x80 ; } if ( this . LBCSS ) { b |= 0x40 ; } if ( this . DRA ) { b |= 0x20 ; } if ( this . NV_DIS ) { b |= 0x01 ; } output . writeByte ( b ) ; output . writeByte ( this . numberOfCacheSegments ) ; output", "gt": ". writeShort ( this . cacheSegmentSize ) ;", "prediction": "}\n", "label": 1}
{"id": 3827, "input": "<s> package com . gisgraphy . client . commons ; public interface NameFormatter { String format", "gt": "( NameProvider nameProvider ) ;", "prediction": ";\n", "label": 0}
{"id": 11064, "input": "<s> package org . restlet . engine . io ; import java . io . IOException ; import org . restlet . util . SelectionRegistration ; public abstract class BufferedSelectionChannel < T extends SelectionChannel > extends WrapperSelectionChannel < T > implements BufferProcessor { private final Buffer buffer ; public BufferedSelectionChannel ( Buffer buffer , T source , WakeupListener wakeupListener ) { super ( source ) ; setRegistration ( new SelectionRegistration ( 0 , null , wakeupListener ) ) ; this . buffer = buffer ; }", "gt": "public boolean canLoop ( Buffer buffer , Object ... args )", "prediction": "}\n", "label": 1}
{"id": 4837, "input": "<s> package org . gk . engine . client . build . grid . field ; import java . util . List ; import java . util . Map ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . engine . client . event . IEventConstants ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . form . gkListFieldIC ; import org . gk . ui . client . com . form . gkMap ; import org . gk . ui . client . com . grid . column . gkListColumnConfig ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class GListFieldBuilder extends GridFieldBuilder { public GListFieldBuilder ( String fieldType ) { super ( fieldType ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; ColumnConfig cc = new gkListColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ; gkListFieldIC lf = ( gkListFieldIC ) field ; String content = x . getContent ( ) ; String value = x . getValue ( ) ; if ( ! content . equals ( \"\" ) ) { lf . setInfo ( parseInfo ( content ) ) ; } if ( ! value . equals ( \"\" ) ) { lf . setSelectItem ( parseInfo ( value ) ) ; } } } ; return cc ; } private List parseInfo ( String value ) { value = value . replaceAll ( \"[ \\t\\n]*\" , \"\" ) ; String [ ] comma = value . split ( IEventConstants . SPLIT_COMMA ) ; List list = new gkList ( ) ;", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 0}
{"id": 11073, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse . emf . common", "gt": ". util . EList ;", "prediction": ";\n", "label": 1}
{"id": 4246, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import java . io . File ; public class SourcePath { private final char dirSeparator = File . pathSeparatorChar ; private String pathstr ; private File [ ] sourcePath ; public SourcePath ( String pathstr ) { init ( pathstr ) ; } public SourcePath ( ) { init ( System . getProperty ( \"env.class.path\" ) ) ; } private void init ( String pathstr ) { if ( pathstr == null || pathstr . length ( ) == 0 ) { pathstr = \".\" ; } int noOfFileSep = 0 ; int index = 0 ; this . pathstr = pathstr ; while ( ( index = pathstr . indexOf ( dirSeparator , index ) ) != - 1 ) { noOfFileSep ++ ; index ++ ; } File [ ] tempPath = new File [ noOfFileSep + 1 ] ; int tempPathIndex = 0 ; int len = pathstr . length ( ) ; int sepPos = 0 ; for ( index = 0 ; index < len ; index = sepPos + 1 ) { sepPos = pathstr . indexOf ( dirSeparator , index ) ; if ( sepPos < 0 ) { sepPos = len ; } File file = new File ( pathstr . substring ( index , sepPos ) ) ; if ( file . isDirectory ( ) ) { tempPath [ tempPathIndex ++ ] = file ; } }", "gt": "sourcePath = new File [ tempPathIndex ] ;", "prediction": "}\n", "label": 0}
{"id": 11074, "input": "<s> package io . beancounter . usermanager ; public interface UserManagerFactory { public", "gt": "UserManager build ( ) throws UserManagerFactoryException ;", "prediction": "\n", "label": 1}
{"id": 1332, "input": "<s> package org . ofbiz . common . preferences ; import java . util . List ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; public class PreferenceWorker { public static final String module = PreferenceWorker . class . getName ( ) ; public static final String ADMIN_PERMISSION = \"USERPREF_ADMIN\" ; public static final String LOGINID_PARAMETER_NAME = \"userPrefLoginId\" ; public static final String DEFAULT_UID = \"_NA_\" ; public static Map < String , Object > addPrefToMap ( GenericValue rec , Map < String , Object > userPrefMap ) throws GeneralException { String prefDataType = rec . getString ( \"userPrefDataType\" ) ; if ( UtilValidate . isEmpty ( prefDataType ) ) { userPrefMap . put ( rec . getString ( \"userPrefTypeId\" ) , rec . getString ( \"userPrefValue\" ) ) ; } else { userPrefMap . put ( rec . getString ( \"userPrefTypeId\" ) , ObjectType . simpleTypeConvert ( rec . get ( \"userPrefValue\" ) , prefDataType , null , null , false ) ) ; } return userPrefMap ; } public static Map < String , Object > checkCopyPermission ( DispatchContext ctx , Map < String , ? > context ) { boolean hasPermission = false ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; if ( userLogin != null ) { String userLoginId = userLogin . getString ( \"userLoginId\" ) ; String userLoginIdArg = ( String ) context . get ( LOGINID_PARAMETER_NAME ) ; if ( userLoginIdArg == null || ( userLoginIdArg != null && userLoginId . equals ( userLoginIdArg ) ) ) { hasPermission = true ; } else { Security security = ctx . getSecurity ( ) ; hasPermission = security . hasPermission ( ADMIN_PERMISSION , userLogin ) ; } } Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"hasPermission\" , hasPermission ) ; return result ; } public static Map < String , Object > checkPermission ( DispatchContext ctx , Map < String , ? > context ) { boolean hasPermission = false ; String mainAction = ( String ) context . get ( \"mainAction\" ) ; if ( \"VIEW\" . equals ( mainAction ) ) { if ( DEFAULT_UID . equals ( context . get ( LOGINID_PARAMETER_NAME ) ) ) { hasPermission = true ; } else { hasPermission = isValidGetId ( ctx , context ) ; } } else if ( \"CREATE~UPDATE~DELETE\" . contains ( mainAction ) ) { hasPermission = isValidSetId ( ctx , context ) ; } else { hasPermission = false ; } Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"hasPermission\" , hasPermission ) ; return result ; } public static Map < String , Object > createUserPrefMap ( GenericValue rec ) throws GeneralException { return addPrefToMap ( rec , FastMap . < String , Object > newInstance ( ) ) ; } public static Map < String , Object > createUserPrefMap ( List < GenericValue > recList ) throws GeneralException { Map < String , Object > userPrefMap = FastMap . newInstance ( ) ; if ( recList != null ) { for ( GenericValue value : recList ) { addPrefToMap ( value , userPrefMap ) ; } } return userPrefMap ; } public static String getUserLoginId ( Map < String , ? > context , boolean returnDefault ) { String userLoginId = ( String ) context . get ( LOGINID_PARAMETER_NAME ) ; if", "gt": "( UtilValidate . isEmpty ( userLoginId ) )", "prediction": "( )\n", "label": 0}
{"id": 11081, "input": "<s> package nehsics . world ; import nehsics . math . * ; import static nehsics . math . Util . * ; import nehsics . bodies . * ; import java . util . * ; public class Walls extends WorldAdapter { private int wall ; private double damping = 1 ; private double internalEnergy = 0 ; private Set < Body > withinWalls = new HashSet < Body > ( ) ; public Walls ( int size ) { wall = size ; } public Walls ( int size , double d ) { wall = size ; damping = d ; } public double getInternalEnergy ( ) { return internalEnergy ; } public void rescale ( int size ) { wall = size ; withinWalls . clear ( ) ; } public void beginStep ( List < Body > bodies , double dt ) { for ( Body b : bodies ) { double k = b . getKineticEnergy ( ) ; Vector2d v = b . getVelocity ( ) ; Vector2d p = b . getPosition ( ) ; double x = p . getX ( ) , y = p . getY ( ) , r = b . getRadius ( ) ; if ( x + r > wall ) v = scale ( v , v ( v . getX ( ) > 0 ? - damping : 1 , 1 ) ) ; else if ( x - r < - wall ) v = scale ( v , v ( v . getX ( ) < 0 ? - damping : 1 , 1 ) ) ; if ( y + r > wall ) v = scale ( v , v ( 1 , v . getY ( ) < 0 ? 1 : - damping ) ) ; else if ( y - r < - wall ) v = scale ( v , v ( 1 , v . getY ( ) > 0 ? 1 : - damping ) ) ; b . setVelocity ( v ) ; internalEnergy += k - b . getKineticEnergy ( ) ; } } public void endStep ( List <", "gt": "Body > bodies , double dt )", "prediction": ")\n", "label": 1}
{"id": 737, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class PackageIndexFrameWriter extends AbstractPackageIndexWriter { public PackageIndexFrameWriter ( ConfigurationImpl configuration , String filename ) throws IOException { super ( configuration , filename ) ; } public static void generate ( ConfigurationImpl configuration ) { PackageIndexFrameWriter packgen ; String filename = \"overview-frame.html\" ; try { packgen = new PackageIndexFrameWriter ( configuration , filename ) ; packgen . buildPackageIndexFile ( \"doclet.Window_Overview\" , false ) ; packgen . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } protected void addPackagesList ( PackageDoc [ ] packages , String text , String tableSummary , Content body ) { Content heading = HtmlTree . HEADING ( HtmlConstants . PACKAGE_HEADING , true , packagesLabel ) ; Content div = HtmlTree . DIV ( HtmlStyle . indexContainer , heading ) ; HtmlTree ul = new HtmlTree ( HtmlTag . UL ) ; ul . addAttr ( HtmlAttr . TITLE , packagesLabel . toString ( ) ) ; for ( int i = 0 ; i < packages . length ; i ++ ) { if ( packages [ i ] != null && ( ! ( configuration . nodeprecated && Util . isDeprecated ( packages [ i ] ) ) ) ) { ul . addContent ( getPackage ( packages [ i ] ) ) ; } } div . addContent ( ul ) ; body . addContent ( div ) ; } protected Content getPackage ( PackageDoc pd ) { Content packageLinkContent ; Content packageLabel ; if ( pd . name ( )", "gt": ". length ( ) > 0 )", "prediction": ";\n", "label": 0}
{"id": 11094, "input": "<s> package io . beancounter . publisher . twitter ; import com . google . inject . Inject ; import io . beancounter . commons . model . activity . ResolvedActivity ; import io . beancounter . commons . model . activity . rai . TVEvent ; import io . beancounter . commons . model . activity . Object ; import io . beancounter . commons . model . auth . OAuthAuth ; import io . beancounter . publisher . twitter . adapters . Publisher ; import io . beancounter . publisher . twitter . adapters . TVEventPublisher ; import org . apache . camel . Exchange ; import org . apache . camel . Processor ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import twitter4j . Status ; import twitter4j . Twitter ; import twitter4j . auth . AccessToken ; import java . util . Properties ; public class TwitterPublisher implements Processor { private static final Logger LOGGER = LoggerFactory . getLogger ( TwitterPublisher . class ) ; @ Inject private Twitter twitter ; @ Override public void process ( Exchange exchange ) throws TwitterPublisherException { ResolvedActivity resolvedActivity = exchange . getIn ( ) . getBody ( ResolvedActivity . class ) ; Object object = resolvedActivity . getActivity ( ) . getObject ( ) ; OAuthAuth auth = ( OAuthAuth ) resolvedActivity . getUser ( ) . getServices ( ) . get ( \"twitter\" ) ; if ( auth == null ) { final String errMessage = \"Twitter service not authorized. Do you have the token?\" ; LOGGER . warn ( errMessage ) ; throw new TwitterPublisherException ( errMessage ) ; } setAccessToken ( twitter , auth ) ; Publisher publisher = getPublisher ( resolvedActivity . getActivity ( ) . getObject ( ) ) ; Status status = publisher . publish ( twitter , resolvedActivity . getActivity ( ) . getVerb ( ) , object ) ; LOGGER . debug ( \"Status updated to [\" + status . getText ( ) + \"]\" ) ; } private void setAccessToken ( Twitter twitter , OAuthAuth auth ) throws TwitterPublisherException { String tokenSession ; try { tokenSession = auth . getSession ( ) ; } catch ( NullPointerException e ) { final String errMessage = \"Error while getting the twitter token for user. Session not found!\" ; LOGGER . error ( errMessage ) ; throw new TwitterPublisherException ( errMessage , e ) ; } String tokenSecret ; try { tokenSecret = auth . getSecret ( ) ; } catch ( NullPointerException e ) { final String errMessage = \"Error while getting the twitter token for user. Secret not found!\" ; LOGGER . error ( errMessage ) ; throw new TwitterPublisherException ( errMessage , e ) ; } AccessToken token = getToken ( tokenSession , tokenSecret ) ; twitter . setOAuthAccessToken ( token ) ; } AccessToken getToken ( String session , String secret ) { return new AccessToken ( session , secret ) ; } Publisher getPublisher ( Object object ) throws TwitterPublisherException { Class clazz = ( Class ) getProperties ( ) . get ( object . getClass ( ) . getCanonicalName ( ) ) ; Publisher publisher ; try { publisher = ( Publisher ) clazz . newInstance ( ) ; } catch ( InstantiationException e ) { final String errMessage = \"Error while instantiating class [\" + clazz + \"]\" ; LOGGER . error ( errMessage ) ; throw new TwitterPublisherException ( errMessage , e ) ; } catch ( IllegalAccessException e ) { final String errMessage = \"Error while accessing [\" + clazz + \"]\" ; LOGGER . error ( errMessage ) ; throw new TwitterPublisherException ( errMessage , e ) ; } catch ( NullPointerException e ) { final String errMessage = \"Object not supported [\" + object . getClass ( ) . getCanonicalName ( ) + \"]\" ; LOGGER . error ( errMessage ) ; throw new TwitterPublisherException ( errMessage , e ) ; } return publisher ; } private Properties getProperties ( ) { Properties prop = new Properties ( ) ; prop . put ( TVEvent . class", "gt": ". getCanonicalName ( ) , TVEventPublisher . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 526, "input": "<s> package org . ofbiz . base . util ; import java . io . IOException ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . UnknownHostException ; import java . rmi . server . RMISocketFactory ; public class RMIExtendedSocketFactory extends RMISocketFactory { private InetAddress hostInetAddress ; public RMIExtendedSocketFactory ( ) { } public RMIExtendedSocketFactory ( InetAddress inetAddress ) { this . hostInetAddress = inetAddress ; } public RMIExtendedSocketFactory ( String hostIpAddress ) throws UnknownHostException { if ( hostIpAddress != null && hostIpAddress . length ( ) >= 7 ) { String [ ] octets = hostIpAddress . split ( \"\\\\.\" ) ; if ( octets == null || octets . length != 4 ) { throw new UnknownHostException ( \"Invalid IP address: \" + hostIpAddress ) ; } byte [ ] ipAddr = new byte [ 4 ] ; for ( int i = 0 ; i < octets . length ; i ++ ) { try { ipAddr [ i ] = ( byte ) Integer . parseInt ( octets [ i ] ) ; } catch ( NumberFormatException nfEx ) { throw", "gt": "new UnknownHostException ( \"Invalid IP address: \" + hostIpAddress ) ;", "prediction": ";\n", "label": 0}
{"id": 11103, "input": "<s> package org . modelgoon . classes . model ; import java . util . ArrayList ; import java . util . List ; public class Method extends StructuralFeature { List < String > parameterTypes = new ArrayList < String > ( ) ; public List < String > getParameterTypes ( ) { return this . parameterTypes ; }", "gt": "public void setParameterTypes ( final List < String > parameterTypes )", "prediction": "}\n", "label": 1}
{"id": 5702, "input": "<s> import p . C ; class X { int m ( ) { C c = new C ( ) ; return c", "gt": ". array . length ;", "prediction": ";\n", "label": 0}
{"id": 11113, "input": "<s> package org . nuxeo . ecm . platform . audit . service . management ; import org . nuxeo . ecm . platform . audit . service . NXAuditEventsService ; public class AuditEventMetricMBeanAdapter implements AuditEventMetricMBean { protected final NXAuditEventsService service ; protected final String eventName ; protected AuditEventMetricMBeanAdapter ( NXAuditEventsService service , String name ) { this", "gt": ". service = service ;", "prediction": ";\n", "label": 1}
{"id": 2813, "input": "<s> package org . ofbiz . minilang ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . minilang . operation . MapProcessor ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class SimpleMapProcessor { private static final UtilCache < String , Map < String , MapProcessor > > simpleMapProcessorsResourceCache = UtilCache . createUtilCache ( \"minilang.SimpleMapProcessorsResource\" , 0 , 0 ) ; private static final UtilCache < URL , Map < String , MapProcessor > > simpleMapProcessorsURLCache = UtilCache . createUtilCache ( \"minilang.SimpleMapProcessorsURL\" , 0 , 0 ) ; protected static Map < String , MapProcessor > getAllProcessors ( URL xmlURL ) throws MiniLangException { Map < String , MapProcessor > mapProcessors = FastMap . newInstance ( ) ; Document document = null ; try { document = UtilXml . readXmlDocument ( xmlURL , true ) ; } catch ( java . io . IOException e ) { throw new MiniLangException ( \"Could not read XML file\" , e ) ; } catch ( org . xml . sax . SAXException e ) { throw new MiniLangException ( \"Could not parse XML file\" , e ) ; } catch ( javax . xml . parsers . ParserConfigurationException e ) { throw new MiniLangException ( \"XML parser not setup correctly\" , e ) ; } if ( document == null ) { throw new MiniLangException ( \"Could not find SimpleMapProcessor XML document: \" + xmlURL . toString ( ) ) ; } Element rootElement = document . getDocumentElement ( ) ; for ( Element simpleMapProcessorElement : UtilXml . childElementList ( rootElement , \"simple-map-processor\" ) ) { MapProcessor processor = new MapProcessor ( simpleMapProcessorElement ) ; mapProcessors . put ( simpleMapProcessorElement . getAttribute ( \"name\" ) , processor ) ; } return mapProcessors ; } protected static Map < String , MapProcessor > getProcessors ( String xmlResource , String name , ClassLoader loader ) throws MiniLangException { Map < String , MapProcessor > simpleMapProcessors = simpleMapProcessorsResourceCache . get ( xmlResource ) ; if ( simpleMapProcessors == null ) { URL xmlURL = null ; try { xmlURL = FlexibleLocation . resolveLocation ( xmlResource , loader ) ; } catch ( MalformedURLException e ) { throw new MiniLangException ( \"Could not find SimpleMapProcessor XML document in resource: \" + xmlResource + \"; error was: \" + e . toString ( ) , e ) ; } if ( xmlURL == null ) { throw new MiniLangException ( \"Could not find SimpleMapProcessor XML document in resource: \" + xmlResource ) ; } simpleMapProcessors = simpleMapProcessorsResourceCache . putIfAbsentAndGet ( xmlResource , getAllProcessors ( xmlURL ) ) ; } return simpleMapProcessors ; } protected static Map < String , MapProcessor", "gt": "> getProcessors ( URL xmlURL , String name ) throws MiniLangException", "prediction": ";\n", "label": 0}
{"id": 11116, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . List ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . mapreduce . InputSplit ; import com . cloudera . sqoop . mapreduce . db . DBSplitter ; import com . cloudera . sqoop . mapreduce . db . DataDrivenDBInputFormat ; public class BooleanSplitter implements DBSplitter { public List < InputSplit > split ( Configuration conf , ResultSet results , String colName ) throws SQLException { List < InputSplit > splits = new ArrayList < InputSplit > ( ) ; if ( results . getString ( 1 ) == null && results . getString ( 2 ) == null ) { splits . add ( new DataDrivenDBInputFormat . DataDrivenDBInputSplit ( colName + \" IS NULL\" , colName + \" IS NULL\" ) ) ; return splits ; } boolean minVal = results . getBoolean ( 1 ) ; boolean maxVal = results . getBoolean ( 2 ) ; if ( ! minVal ) { splits . add ( new DataDrivenDBInputFormat . DataDrivenDBInputSplit ( colName + \" = FALSE\" , colName + \" = FALSE\" ) ) ; } if ( maxVal ) { splits . add ( new DataDrivenDBInputFormat . DataDrivenDBInputSplit ( colName + \" = TRUE\" , colName + \" = TRUE\" ) ) ; } if ( results . getString ( 1 ) == null || results . getString ( 2 ) == null ) { splits . add ( new DataDrivenDBInputFormat . DataDrivenDBInputSplit ( colName + \" IS", "gt": "NULL\" , colName + \" IS NULL\" ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5296, "input": "<s> package org . ofbiz . base . metrics ; public interface Metrics { public static final int ESTIMATION_SIZE = 100 ; public static final long ESTIMATION_TIME = 1000 ; public static final double SMOOTHING = 0.7 ; String getName ( ) ;", "gt": "double getServiceRate ( ) ;", "prediction": "}\n", "label": 0}
{"id": 11122, "input": "<s> package com . google . code . microlog4android . format . command . util ; public enum StringUtil { ; public static String extractPartialClassName ( String className , int parts ) { String partialCategoryName = className ; int nofDots = 0 ; int dotIndex = className . lastIndexOf ( '.' ) ; if ( dotIndex != - 1 ) { nofDots ++ ; } while ( nofDots", "gt": "< parts && dotIndex > - 1 )", "prediction": ")\n", "label": 1}
{"id": 4019, "input": "<s> import java . util . Iterator ; public class SpecIterable implements Iterable < String > { public static void main ( String [ ] args ) { int i = 0 ; for ( String s : new SpecIterable ( ) ) { if ( i ++ == 4 ) break ; System . out . println ( s ) ; } System . out . println ( \"passed\" ) ; } public Iterator < String > iterator ( ) { return new Iterator", "gt": "< String > ( )", "prediction": ";\n", "label": 0}
{"id": 11125, "input": "<s> package org . apache . lucene . index ; import java . util . Collection ; import java . io . IOException ; public interface IndexCommitPoint { public String getSegmentsFileName ( ) ; public Collection getFileNames ( ) throws IOException ;", "gt": "public void delete ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6499, "input": "<s> package P1 ; public class pubExposePriv extends priv { public priv baz ( ) { return new priv ( ) ; } public void bar ( priv p ) { }", "gt": "public pubExposePriv ( priv p )", "prediction": "}\n", "label": 0}
{"id": 11130, "input": "<s> package de . uos . igf . db3d . dbms . api ; import de . uos . igf . db3d . dbms . api . UpdateException ; public class TopologyException extends UpdateException { public TopologyException ( ) { super ( ) ; } public TopologyException ( String arg0 ) { super ( arg0 ) ; } public TopologyException ( Throwable arg0 ) { super ( arg0 ) ; } public TopologyException ( String arg0 , Throwable arg1 ) {", "gt": "super ( arg0 , arg1 ) ;", "prediction": "\n", "label": 1}
{"id": 2769, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Alternative extends AllocateResourceAttribute { EList", "gt": "< Resource > getResources ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11135, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . server ; import javax . servlet . ServletContextEvent ; import javax . servlet . ServletContextListener ; import org . eclipse . rap . rwt . application . Application ; import org . eclipse . rap . rwt . application . ApplicationConfiguration ; import org . eclipse . rap . rwt . application . ApplicationRunner ; import org . eclipse . rap . rwt . application . Application . OperationMode ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class RWTStartup { public static ServletContextListener createServletContextListener ( Class < ? extends IEntryPoint > entryPointClass ) { return new TestApplicationController ( entryPointClass ) ; } private static class TestApplicationController implements ServletContextListener { private final Class < ? extends IEntryPoint > entryPointClass ; private ApplicationRunner applicationRunner ; private TestApplicationController ( Class < ? extends IEntryPoint > entryPointClass ) { this . entryPointClass = entryPointClass ; } public void contextInitialized ( ServletContextEvent event ) { ApplicationConfiguration configuration = new TestApplicationConfigurator ( entryPointClass ) ; applicationRunner = new ApplicationRunner ( configuration , event . getServletContext ( ) ) ; applicationRunner . start ( ) ; } public void contextDestroyed ( ServletContextEvent event ) { applicationRunner . stop ( ) ; } } private static class TestApplicationConfigurator implements ApplicationConfiguration { private final Class <", "gt": "? extends IEntryPoint > entryPointClass ;", "prediction": "\n", "label": 1}
{"id": 7381, "input": "<s> package com . deliciousdroid . syncadapter ; import android . accounts . Account ; import android . content . AbstractThreadedSyncAdapter ; import android . content . ContentProviderClient ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . SyncResult ; import android . database . Cursor ; import android . net . Uri ; import android . preference . PreferenceManager ; import android . util . Log ; import com . deliciousdroid . Constants ; import com . deliciousdroid . client . DeliciousApi ; import com . deliciousdroid . client . Update ; import com . deliciousdroid . platform . BookmarkManager ; import com . deliciousdroid . platform . BundleManager ; import com . deliciousdroid . platform . TagManager ; import com . deliciousdroid . providers . BookmarkContent . Bookmark ; import com . deliciousdroid . providers . BundleContent . Bundle ; import com . deliciousdroid . providers . TagContent . Tag ; import org . apache . http . ParseException ; import org . apache . http . auth . AuthenticationException ; import java . io . IOException ; import java . util . ArrayList ; public class BookmarkSyncAdapter extends AbstractThreadedSyncAdapter { private static final String TAG = \"BookmarkSyncAdapter\" ; private final Context mContext ; public BookmarkSyncAdapter ( Context context , boolean autoInitialize ) { super ( context , autoInitialize ) ; mContext = context ; } @ Override public void onPerformSync ( Account account , android . os . Bundle extras , String authority , ContentProviderClient provider , SyncResult syncResult ) { try { InsertBookmarks ( account , syncResult ) ; } catch ( final ParseException e ) { syncResult . stats . numParseExceptions ++ ; Log . e ( TAG , \"ParseException\" , e ) ; } catch ( final AuthenticationException e ) { syncResult . stats . numAuthExceptions ++ ; Log . e ( TAG , \"AuthException\" , e ) ; } catch ( final IOException e ) { syncResult . stats . numIoExceptions ++ ; Log . e ( TAG , \"IOException\" , e ) ; } } private void InsertBookmarks ( Account account , SyncResult syncResult ) throws AuthenticationException , IOException { SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( mContext ) ; long lastUpdate = settings . getLong ( Constants . PREFS_LAST_SYNC , 0 ) ; Update update = null ; String username = account . name ; update = DeliciousApi . lastUpdate ( account , mContext ) ; if ( update . getLastUpdate ( ) > lastUpdate ) { ArrayList < Bookmark > addBookmarkList = new ArrayList < Bookmark > ( ) ; ArrayList < Bookmark > updateBookmarkList = new ArrayList < Bookmark > ( ) ; ArrayList < Bookmark > changeList = new ArrayList < Bookmark > ( ) ; ArrayList < Bookmark > addList = new ArrayList < Bookmark > ( ) ; ArrayList < Bookmark > updateList = new ArrayList < Bookmark > ( ) ; ArrayList < Tag > tagList = new ArrayList < Tag > ( ) ; ArrayList < Bundle > bundleList = new ArrayList < Bundle > ( ) ; if ( lastUpdate == 0 ) { Log . d ( \"BookmarkSync\" , \"In Bookmark Load\" ) ; tagList = DeliciousApi . getTags ( account , mContext ) ; bundleList = DeliciousApi . getBundles ( account , mContext ) ; ArrayList < String > accounts = new ArrayList < String > ( ) ; accounts . add ( account . name ) ; BookmarkManager . TruncateBookmarks ( accounts , mContext , false ) ; addBookmarkList = DeliciousApi . getAllBookmarks ( null , account , mContext ) ; } else { Log . d ( \"BookmarkSync\" , \"In Bookmark Update\" ) ; tagList = DeliciousApi . getTags ( account , mContext ) ; bundleList = DeliciousApi . getBundles ( account , mContext ) ; changeList = DeliciousApi . getChangedBookmarks ( account , mContext ) ; for ( Bookmark b : changeList ) { String [ ] projection = new String [ ] { Bookmark . Hash , Bookmark . Meta } ; String selection = Bookmark . Hash + \"=?\" ; String [ ] selectionArgs = new String [ ] { b . getHash ( ) } ; Uri bookmarks = Bookmark . CONTENT_URI ; Cursor c = mContext . getContentResolver ( ) . query ( bookmarks , projection , selection , selectionArgs , null ) ; if ( c . getCount ( ) == 0 ) { addList", "gt": ". add ( b ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11146, "input": "<s> package org . nuxeo . ecm . platform . syndication ; import java . util . Date ; import java . util . List ; import com . sun . syndication . feed . synd . SyndContentImpl ; import com . sun . syndication . feed . synd . SyndEntryImpl ; public class FeedItem extends SyndEntryImpl implements Comparable < FeedItem > { private static final long serialVersionUID = 1L ; public void setDescription ( String description ) { SyndContentImpl content = new SyndContentImpl ( ) ; content . setType ( \"text/plain\" ) ; if ( description == null || \"\" . equals ( description ) ) { description = \" \" ; } content . setValue ( description ) ; super . setDescription ( content ) ; } @ Override public void setAuthor ( String author ) { if ( author != null && ! \"\" . equals ( author ) ) { super . setAuthor ( author ) ; } } @ SuppressWarnings ( \"rawtypes\" ) @ Override public void setContributors ( List contributors ) { if ( contributors != null && ! contributors . isEmpty ( ) ) { super . setContributors ( contributors ) ; } } @ Override public void setTitle ( String title ) { if ( title != null && ! \"\" . equals ( title ) ) { super . setTitle ( title ) ; } } @ Deprecated public void setTitle ( String title , String type ) { if ( \"\" .", "gt": "equals ( type ) )", "prediction": ") ;\n", "label": 1}
{"id": 5588, "input": "<s> import java . util . * ; class CastTest { private class BA < T > { } private class BB < T , S > { } private class BC < T > extends BA < Integer > { } private class BD < T > extends BB < T , T > { } private void inconsistentMatches ( ) { Object o ; o = ( BD < String > ) ( BB <", "gt": "String , Number > ) null ;", "prediction": ")\n", "label": 0}
{"id": 11160, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getListAndViewResult\" } ) @ XmlRootElement ( name = \"GetListAndViewResponse\" ) public class GetListAndViewResponse { @ XmlElement ( name = \"GetListAndViewResult\" ) protected GetListAndViewResponse . GetListAndViewResult getListAndViewResult ; public GetListAndViewResponse . GetListAndViewResult getGetListAndViewResult ( ) { return getListAndViewResult ; } public void setGetListAndViewResult ( GetListAndViewResponse . GetListAndViewResult value ) { this . getListAndViewResult = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class GetListAndViewResult { @ XmlMixed @ XmlAnyElement ( lax = true ) protected List < Object > content ; public List < Object > getContent ( ) { if ( content == null ) { content", "gt": "= new ArrayList < Object > ( ) ;", "prediction": "\n", "label": 1}
{"id": 5039, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; import java . util . Properties ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . JAXBException ; import javax . xml . bind . Marshaller ; import javax . xml . bind . Unmarshaller ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . commons . io . IOUtils ; import org . apache . maven . plugin . MojoExecutionException ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; import com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 . Coordinates ; import com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 . Dependency ; import com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 . SCM ; import com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_2 . Versions ; public class VersionInfoManager { private static final String THREEDOTS = \"...\" ; private final static String SCHEMA_VERSION = \"1.2.2\" ; private final static String SCHEMA_GROUP_ID = \"com.sap.prd.mobile.ios.mios\" ; private final static String SCHEMA_ARTIFACT_ID = \"versionschema\" ; private final static String SCHEMA_REPOSITORY = \"deploy.release.ondevice.hosted\" ; private final static String NEXUS_URL = \"http://nexus.wdf.sap.corp:8081/nexus\" ; void createVersionInfoFile ( final String groupId , final String artifactId , final String version , final File syncInfoFile , List < Dependency > dependencies , OutputStream versionInfoStream ) throws MojoExecutionException { try { final Properties versionInfo = new Properties ( ) ; versionInfo . load ( new FileInputStream ( syncInfoFile ) ) ; createVersionInfoFile ( groupId , artifactId , version , versionInfo , dependencies , versionInfoStream ) ; } catch ( IOException e ) { throw new MojoExecutionException ( \"Could not load sync info from file '\" + syncInfoFile + \"'.\" , e ) ; } catch ( JAXBException e ) { throw new MojoExecutionException ( \"Could not load sync info from file '\" + syncInfoFile + \"'.\" , e ) ; } } private void createVersionInfoFile ( final String groupId , final String artifactId , final String version , Properties versionInfo , List < Dependency > dependencies , OutputStream os ) throws MojoExecutionException , JAXBException { try { final String connectionString = \"scm:perforce:\" + versionInfo . getProperty ( \"port\" ) + \":\" + getDepotPath ( versionInfo . getProperty ( \"depotpath\" ) ) ; final Versions versions = new Versions ( ) ; for ( final Dependency dep : dependencies ) versions . addDependency ( dep ) ; final SCM scm = new SCM ( ) ; scm . setConnection ( connectionString ) ; scm . setRevision ( versionInfo . getProperty ( \"changelist\" ) ) ; final Coordinates coordinates = new Coordinates ( ) ; coordinates . setGroupId ( groupId ) ; coordinates . setArtifactId ( artifactId ) ; coordinates . setVersion ( version ) ; versions . setScm ( scm ) ; versions . setCoordinates ( coordinates ) ; final JAXBContext context = JAXBContext . newInstance ( Versions . class ) ; final Marshaller marshaller = context . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , true ) ; marshaller . setProperty ( Marshaller . JAXB_SCHEMA_LOCATION , \"urn:xml.sap.com:XCodePlugin:VersionInfo\" + \" \" + NEXUS_URL + \"/content/repositories/\" + SCHEMA_REPOSITORY + \"/\" + SCHEMA_GROUP_ID . replace ( \".\" , \"/\" ) + \"/\" + SCHEMA_ARTIFACT_ID + \"/\" + SCHEMA_VERSION + \"/\" + SCHEMA_ARTIFACT_ID + \"-\" + SCHEMA_VERSION + \".xsd\" ) ; final ByteArrayOutputStream byteOs = new ByteArrayOutputStream ( ) ; marshaller . marshal ( versions , byteOs ) ; final byte [ ] b = byteOs . toByteArray ( ) ; DomUtils . validateDocument ( DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( new ByteArrayInputStream ( b ) ) ) ; IOUtils . write ( b , os ) ; } catch ( ParserConfigurationException e ) { throw new MojoExecutionException ( \"Cannot create versions.xml.\" , e ) ; } catch ( IOException e ) { throw new MojoExecutionException ( \"Cannot create versions.xml.\" , e ) ; } catch ( SAXException e ) { throw new MojoExecutionException ( \"Cannot create versions.xml.\" , e ) ; } } private static String getDepotPath ( String fullDepotPath ) { if ( fullDepotPath . endsWith ( THREEDOTS ) ) { fullDepotPath = fullDepotPath . substring ( 0 , fullDepotPath . length ( ) - THREEDOTS . length ( ) ) ; } return fullDepotPath ; } static Dependency parseDependency ( final File f ) throws JAXBException , SAXException , IOException { final String schemaVersion = getSchemaVersion ( f ) ; if ( schemaVersion == null ) { return parseOldDependency ( f ) ; } else if ( schemaVersion . equals ( \"1.2.0\" ) ) { return parseOldVersionsWithoutSchema ( f ) ; } else if ( ( schemaVersion . equals ( \"1.2.1\" ) ) || ( schemaVersion . equals ( \"1.2.2\" ) ) ) { return parseDependency_1_2_2 ( f ) ; } throw new IllegalStateException ( \"Unknown schemaVersion: '\" + schemaVersion + \"'.\" ) ; } private static Dependency parseOldDependency ( File f ) throws JAXBException { final JAXBContext context = JAXBContext . newInstance ( com . sap . prd . mobile . ios . mios . versioninfo . v_0_0_0 . Versions . class ) ; final Unmarshaller unmarshaller = context . createUnmarshaller ( ) ; final com . sap . prd . mobile . ios . mios . versioninfo . v_0_0_0 . Versions versions = ( com . sap . prd . mobile . ios . mios . versioninfo . v_0_0_0 . Versions ) unmarshaller . unmarshal ( f ) ; final Coordinates coordinates = new Coordinates ( ) ; coordinates . setGroupId ( versions . getCoordinates ( ) . getGroupId ( ) ) ; coordinates . setArtifactId ( versions . getCoordinates ( ) . getArtifactId ( ) ) ; coordinates . setVersion ( versions . getCoordinates ( ) . getVersion ( ) ) ; final SCM scm = new SCM ( ) ; scm . setConnection ( \"scm:perforce:\" + versions . getScm ( ) . getRepository ( ) + \":\" + getDepotPath ( versions . getScm ( ) . getPath ( ) ) ) ; scm . setRevision ( versions . getScm ( ) . getSnapshotId ( ) ) ; final Dependency dependency = new Dependency ( ) ; dependency .", "gt": "setCoordinates ( coordinates ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 11168, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . model ; import java . util . ArrayList ; import org . eclipse . ui . internal . cheatsheets . composite . parser . ITaskParseStrategy ; import org . eclipse . ui . internal . cheatsheets . composite . parser . TaskGroupParseStrategy ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ITaskGroup ; public class TaskGroup extends AbstractTask implements ITaskGroup { public interface CompletionStrategy { public int computeState ( TaskGroup taskGroup ) ; } private ITaskParseStrategy parserStrategy ; private ArrayList subtasks ; private CompletionStrategy completionStrategy ; public TaskGroup ( CompositeCheatSheetModel model , String id , String name , String kind ) { super ( model , id , name , kind ) ; if ( kind == null ) { this . kind = ITaskGroup . SET ; } parserStrategy = new TaskGroupParseStrategy ( ) ; completionStrategy = determineCompletionStrategy ( kind ) ; } private CompletionStrategy determineCompletionStrategy ( String kind ) { if ( ITaskGroup . CHOICE . equals ( kind ) ) { return new TaskChoiceCompletionStrategy ( ) ; } return new TaskSetCompletionStrategy ( ) ; } public ITaskParseStrategy getParserStrategy ( ) { return parserStrategy ; } public ICompositeCheatSheetTask [ ] getSubtasks ( ) { if ( subtasks == null ) return EMPTY ; return ( ICompositeCheatSheetTask [ ] ) subtasks . toArray ( new ICompositeCheatSheetTask", "gt": "[ subtasks . size ( ) ] ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6331, "input": "<s> package com . redhat . ceylon . compiler . java . test . quoting ; import org . junit . Assert ; import org . junit . Test ; import com . redhat . ceylon . compiler . java . test . CompilerTest ; public class QuotingTest extends CompilerTest { @ Test public void testKeywordInPackage ( ) { compareWithJavaSource ( \"goto/KeywordInPackage\" ) ; } @ Test public void testTwoKeywordsInPackage ( ) { compareWithJavaSource ( \"goto/transient/TwoKeywordsInPackage\" ) ; } @ Test public void testKeywordInClassValue ( ) { compareWithJavaSource ( \"goto/KeywordInClassValue\" ) ; } @ Test public void testKeywordInToplevelValue ( ) { compareWithJavaSource ( \"goto/KeywordInToplevelValue\" ) ; } @ Test public void testKeywordInClassGetter ( ) { compareWithJavaSource ( \"goto/KeywordInClassGetter\" ) ; } @ Test public void testKeywordInToplevelGetter ( ) { compareWithJavaSource ( \"goto/KeywordInToplevelGetter\" ) ; } @ Test public void testKeywordInClassMethod ( ) { compareWithJavaSource ( \"goto/KeywordInClassMethod\" ) ; } @ Test public void testKeywordInToplevelMethod ( ) { compareWithJavaSource ( \"goto/KeywordInToplevelMethod\" ) ; } @ Test public void testKeywordInToplevelObject ( ) { compareWithJavaSource ( \"goto/KeywordInToplevelObject\" ) ; } @ Test public void testKeywordInClassObject ( ) { compareWithJavaSource ( \"goto/KeywordInClassObject\" ) ; } @ Test public void testKeywordInMethodObject ( ) { compareWithJavaSource ( \"goto/KeywordInMethodObject\" ) ; } @ Test public void testKeywordInGetterObject ( ) { compareWithJavaSource ( \"goto/KeywordInGetterObject\" ) ; } @ Test public void testKeywordInSetterObject ( ) { compareWithJavaSource ( \"goto/KeywordInSetterObject\" ) ; } @ Test public void testKeywordInImport ( ) { compareWithJavaSource ( \"goto/KeywordInImport.src\" , \"goto/KeywordInImport.ceylon\" , \"goto/transient/TwoKeywordsInPackage.ceylon\" ) ; } @ Test public void testKeywordInInnerClassContainer ( ) { compareWithJavaSource ( \"goto/KeywordInInnerClassContainer\" ) ; } @ Test public void testKeywordInToplevelAssignment ( ) { compareWithJavaSource ( \"goto/KeywordInToplevelAssignment\" ) ; } @ Test public void testMangledToplevelAttribute ( ) { compareWithJavaSource ( \"goto/MangledToplevelAttribute\" ) ; } @ Test public void testMangledToplevelMethod ( ) { compareWithJavaSource ( \"goto/MangledToplevelMethod\" ) ; } @ Test public void testKeywordInCallable ( ) { compareWithJavaSource ( \"goto/KeywordInCallable\" ) ; } @ Test public void testKeywordInInnerClass ( ) { compareWithJavaSource ( \"goto/KeywordInInnerClass\" ) ; } @ Test public void testCaseCollision ( ) { try { compileAndRun ( \"com.redhat.ceylon.compiler.java.test.quoting.$goto.CaseCollision\" , \"goto/CaseCollision.ceylon\" ) ; Assert . fail ( ) ; } catch ( RuntimeException e ) { Assert . assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( \"i am the class\" ) ) ; } try { compileAndRun ( \"com.redhat.ceylon.compiler.java.test.quoting.$goto.caseCollision\" , \"goto/CaseCollision.ceylon\" ) ; } catch ( Exception e ) { Assert . assertTrue ( e . getCause ( ) . getCause ( ) . getMessage ( ) . contains ( \"i am the method\" ) ) ; } }", "gt": "@ Test public void testCaseLowerClass ( )", "prediction": "}\n", "label": 0}
{"id": 11169, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . index . IndexReader ; public class HitCollectorWrapper extends Collector { private HitCollector collector ; private int base = 0 ; private Scorer scorer = null ; public HitCollectorWrapper ( HitCollector collector ) { this . collector = collector ; } public void setNextReader ( IndexReader reader , int docBase ) { base = docBase ; } public void collect ( int doc , int [ ] sorts ) throws IOException { collector . collect ( doc + base", "gt": ", scorer . score ( ) , sorts ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1365, "input": "<s> package Liza ; import org . bukkit . entity . Skeleton ;", "gt": "public interface LizaSkeleton extends Skeleton", "prediction": "}\n", "label": 0}
{"id": 11189, "input": "<s> package org . apache . batik . svggen . font ; import org . apache . batik . svggen . font . table . GlyfDescript ; import org . apache . batik . svggen . font . table . GlyphDescription ; public class Glyph { protected short leftSideBearing ; protected int advanceWidth ; private Point [ ] points ; public Glyph ( GlyphDescription gd , short lsb , int advance ) { leftSideBearing = lsb ; advanceWidth = advance ; describe ( gd ) ; } public int getAdvanceWidth ( ) { return advanceWidth ; } public short getLeftSideBearing ( ) { return leftSideBearing ; } public Point getPoint ( int i ) { return points [ i ] ; } public int getPointCount ( ) { return points . length ; } public void reset ( ) { } public void scale ( int factor ) { for ( int i = 0 ; i < points . length ; i ++ ) { points [ i ] . x = ( ( points [ i ] . x << 10 ) * factor ) > > 26 ; points [ i ] . y = ( ( points [ i ] . y << 10 )", "gt": "* factor ) > > 26 ;", "prediction": ";\n", "label": 1}
{"id": 6170, "input": "<s> public class ExprQualifiedType { static class Nested { static int i ; static void m ( ) { i = 1 ; } } static void test ( ) { new ExprQualifiedType ( ) . Nested . i = 1 ; new ExprQualifiedType ( ) . Nested", "gt": ". m ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11194, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse . emf . ecore . EObject ; public interface XdocFile extends EObject { AbstractSection getMainSection ( ) ;", "gt": "void setMainSection ( AbstractSection value ) ;", "prediction": "}\n", "label": 1}
{"id": 9368, "input": "<s> package org . ofbiz . service ; import java . util . Map ; import org . ofbiz . base . util . Debug ; @ SuppressWarnings ( \"serial\" ) public class GenericResultWaiter implements GenericRequester { public static final String module = GenericResultWaiter . class . getName ( ) ; public static final int SERVICE_RUNNING = - 1 ; public static final int SERVICE_FAILED = 0 ; public static final int SERVICE_FINISHED = 1 ; private boolean completed = false ; private int status = - 1 ; private Map < String , Object > result = null ; private Throwable t = null ; public synchronized void receiveResult ( Map < String , Object > result ) { this . result = result ; completed = true ; status = SERVICE_FINISHED ; notify ( ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Received Result (\" + completed + \") -- \" + result , module ) ; } public synchronized void receiveThrowable ( Throwable t ) { this . t = t ; completed = true ; status = SERVICE_FAILED ; notify ( ) ; } public synchronized int status ( ) { return this . status ; } public synchronized boolean isCompleted ( ) { return completed ; } public synchronized Throwable getThrowable ( ) { if ( ! isCompleted ( ) ) throw new java . lang . IllegalStateException ( \"Cannot return exception, synchronous call has not completed.\" ) ; return this . t ; } public synchronized Map < String , Object > getResult ( ) { if ( ! isCompleted ( ) ) throw new java . lang . IllegalStateException ( \"Cannot return result, asynchronous call has not completed.\" ) ; return result ; } public synchronized Map < String , Object > waitForResult ( ) { return this", "gt": ". waitForResult ( 10 ) ;", "prediction": ";\n", "label": 0}
{"id": 11195, "input": "<s> package org . nuxeo . ecm . platform . localconfiguration . simple ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . localconfiguration . AbstractLocalConfiguration ; public class SimpleConfigurationAdapter extends AbstractLocalConfiguration < SimpleConfiguration > implements SimpleConfiguration { private static final Log log = LogFactory . getLog ( SimpleConfigurationAdapter . class ) ; protected DocumentModel detachedDocument ; protected Map < String , String > parameters ; public SimpleConfigurationAdapter ( DocumentModel doc ) { loadFromDocument ( doc ) ; } protected void loadFromDocument ( DocumentModel doc ) { detachedDocument = doc ; parameters = computeParametersFromDocument ( doc ) ; } @ SuppressWarnings ( \"unchecked\" ) protected Map < String , String > computeParametersFromDocument ( DocumentModel doc ) { Map < String , String > parameters = new HashMap < String , String > ( ) ; try { List < Map < String , String > > parametersFromDocument = ( List < Map < String , String > > ) doc . getPropertyValue ( SIMPLE_CONFIGURATION_PARAMETERS_PROPERTY ) ; if ( parametersFromDocument != null ) { for ( Map < String , String > parameter : parametersFromDocument ) { parameters . put ( parameter . get ( SIMPLE_CONFIGURATION_PARAMETER_KEY ) , parameter . get ( SIMPLE_CONFIGURATION_PARAMETER_VALUE ) ) ; } } } catch ( ClientException e ) { log . warn ( \"Unable to retrieve SimpleConfiguration parameters: \" + e ) ; log . debug ( e , e ) ; } return parameters ; } @ Override public String get ( String key ) { return get ( key , null ) ; } @ Override public String get ( String key , String defaultValue ) { String value = parameters . get ( key ) ; return value != null ? value : defaultValue ; } @ Override public String put ( String key , String value ) { return parameters . put ( key , value ) ; } @ Override public void putAll ( Map < String , String > parameters ) { this . parameters . putAll ( parameters ) ; } @ Override public DocumentRef getDocumentRef ( ) { return detachedDocument . getRef ( ) ; } @ Override public boolean canMerge ( ) { return true ; } @ Override public SimpleConfiguration merge ( SimpleConfiguration other ) { if ( other == null ) { return this ; } SimpleConfigurationAdapter adapter = ( SimpleConfigurationAdapter ) other ; detachedDocument = adapter . detachedDocument ; for ( Map . Entry < String , String > otherParameter", "gt": ": adapter . parameters . entrySet ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 9447, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Ghast ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaGhast ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftGhast implements LizaGhast { private Ghast ghast ; public LizaCraftGhast ( Ghast ghast ) { this . ghast = ghast ; } @ Override public void damage ( int amount ) { this . ghast . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . ghast . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . ghast . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . ghast . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . ghast . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . ghast . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . ghast . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . ghast . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . ghast . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . ghast . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . ghast . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . ghast . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . ghast . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . ghast . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . ghast . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > transparent , int maxDistance ) { return new LizaCraftBlock ( this . ghast . getTargetBlock ( transparent , maxDistance ) ) ; } @ Override public LizaVehicle getVehicle ( ) { return new LizaCraftVehicle ( this . ghast . getVehicle ( ) ) ; } @ Override public boolean isInsideVehicle ( ) { return this . ghast . isInsideVehicle ( ) ; } @ Override public boolean leaveVehicle ( ) { return this . ghast . leaveVehicle ( ) ; } @ Override public void setHealth ( int health ) { this . ghast . setHealth ( health ) ; } @ Override public void setLastDamage ( int damage ) { this . ghast . setLastDamage ( damage ) ; } @ Override public void setMaximumAir ( int ticks ) { this . ghast . setMaximumAir ( ticks ) ; } @ Override public void setMaximumNoDamageTicks ( int ticks ) { this . ghast . setMaximumNoDamageTicks ( ticks ) ; } @ Override public void setNoDamageTicks ( int ticks ) { this . ghast . setNoDamageTicks ( ticks ) ; } @ Override public void setRemainingAir ( int ticks ) { this . ghast . setRemainingAir ( ticks ) ; } @ Override public LizaArrow shootArrow ( ) { return new LizaCraftArrow ( this . ghast . shootArrow ( ) ) ; } @ Override public LizaEgg throwEgg ( ) { return new LizaCraftEgg ( this . ghast . throwEgg ( ) ) ; } @ Override public LizaSnowball throwSnowball ( ) { return new LizaCraftSnowball ( this . ghast . throwSnowball ( ) ) ; } @ Override public boolean eject ( ) { return this . ghast . eject ( ) ; } @ Override public int getEntityId ( ) { return this . ghast . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . ghast . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . ghast . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . ghast . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . ghast . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . ghast . getMaxFireTicks ( ) ; } @ Override @ Deprecated public List < Entity > getNearbyEntities ( double x , double y , double z ) { List < Entity > el = this . ghast . getNearbyEntities ( x , y , z ) ; for ( Entity e : el ) { el . remove ( e ) ; LizaEntity le = new LizaCraftEntity ( e ) ; el . add ( le ) ; } return el ; } @ Override public LizaEntity getPassenger ( ) { return new LizaCraftEntity ( this . ghast . getPassenger ( ) ) ; } @ Override public LizaServer getServer ( ) { return new LizaCraftServer ( this . ghast . getServer ( ) ) ; } @ Override public int getTicksLived ( ) { return this . ghast . getTicksLived ( ) ; } @", "gt": "Override public UUID getUniqueId ( )", "prediction": "}\n", "label": 0}
{"id": 11206, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; public final class MailItem { public String sender ; public String email ; public String subject ; public String body ; public boolean read ; public MailItem ( String sender , String email ,", "gt": "String subject , String body )", "prediction": ")\n", "label": 1}
{"id": 9334, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . navigator ; import org . eclipse . core . resources . IFile ; import org . eclipse . emf . common . ui . URIEditorInput ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . workspace . util . WorkspaceSynchronizer ; import org . eclipse . gef . EditPart ; import org . eclipse . gef . GraphicalViewer ; import org . eclipse . gmf . runtime . diagram . ui . parts . DiagramEditor ; import org . eclipse . gmf . runtime . diagram . ui . resources . editor . document . IDiagramDocument ; import org . eclipse . gmf . runtime . notation . Diagram ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . navigator . ILinkHelper ; import org . eclipse . ui . part . FileEditorInput ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapDiagramEditorPlugin ; public class SimplemapNavigatorLinkHelper implements ILinkHelper { private static IEditorInput getEditorInput ( Diagram diagram ) { Resource diagramResource = diagram . eResource ( ) ; for ( EObject nextEObject : diagramResource . getContents ( ) ) { if ( nextEObject == diagram ) { return new FileEditorInput ( WorkspaceSynchronizer . getFile ( diagramResource ) ) ; } if ( nextEObject instanceof Diagram ) { break ; } } URI uri = EcoreUtil . getURI ( diagram ) ; String editorName = uri . lastSegment ( ) + '#' + diagram . eResource ( ) . getContents ( ) . indexOf ( diagram ) ; IEditorInput editorInput = new URIEditorInput ( uri , editorName ) ; return editorInput ; }", "gt": "public IStructuredSelection findSelection ( IEditorInput anInput )", "prediction": "}\n", "label": 0}
{"id": 11221, "input": "<s> package play . modules . cream . helpers ; import java . lang . reflect . InvocationTargetException ; import org . apache . commons . beanutils . BeanUtilsBean ; public class NullAwareBeanUtilsBean extends BeanUtilsBean { @ Override public void copyProperty ( Object dest , String name ,", "gt": "Object value ) throws IllegalAccessException , InvocationTargetException", "prediction": ") ;\n", "label": 1}
{"id": 3792, "input": "<s> package com . nesscomputing . hbase . spill ; import java . io . File ; import java . io . FileFilter ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Collections ; import java . util . List ; import java . util . UUID ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import javax . annotation . Nonnull ; import com . google . common . base . Functions ; import com . google . common . base . Preconditions ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . io . Closeables ; import org . apache . hadoop . hbase . client . Put ; import org . weakref . jmx . Managed ; import com . nesscomputing . hbase . HBaseWriter ; import com . nesscomputing . hbase . HBaseWriterConfig ; import com . nesscomputing . logging . Log ; public class SpillController { private static final Log LOG = Log . findLog ( ) ; private final AtomicLong opsEnqSpilled = new AtomicLong ( 0L ) ; private final AtomicLong opsDeqSpilled = new AtomicLong ( 0L ) ; private final AtomicLong spillsOk = new AtomicLong ( 0L ) ; private final AtomicLong spillsFailed = new AtomicLong ( 0L ) ; private final AtomicLong spillsLost = new AtomicLong ( 0L ) ; private final AtomicLong spillFilesOk = new AtomicLong ( 0L ) ; private final AtomicLong spillFilesFailed = new AtomicLong ( 0L ) ; private final AtomicLong spilledPutsRead = new AtomicLong ( 0L ) ; private final String spillName ; private final File spillingSrcDir ; private final File spillingOkDir ; private final File spillingFailDir ; private final String spillingId ; private final boolean spillingEnabled ; private final AtomicInteger spillingCount = new AtomicInteger ( 0 ) ; private final FileFilter validSpillfileFilter ; public SpillController ( @ Nonnull final String spillName , @ Nonnull final HBaseWriterConfig hbaseWriterConfig ) { Preconditions . checkNotNull ( spillName , \"spill name must not be null!\" ) ; Preconditions . checkNotNull ( hbaseWriterConfig , \"config must not be null!\" ) ; this . spillName = spillName ; this . validSpillfileFilter = new ValidSpillfileFilter ( hbaseWriterConfig . getSpillFileMinAge ( ) . getMillis ( ) ) ; final File baseDir = hbaseWriterConfig . getSpillingDirectory ( ) ; if ( baseDir != null && hbaseWriterConfig . isSpillingEnabled ( ) && hbaseWriterConfig . isEnabled ( ) ) { spillingSrcDir = createSpillFolder ( baseDir , \"spill\" ) ; spillingOkDir = createSpillFolder ( baseDir , \"success\" ) ; spillingFailDir = createSpillFolder ( baseDir , \"failed\" ) ; this . spillingEnabled = ( spillingSrcDir != null ) && ( spillingOkDir != null ) && ( spillingFailDir != null ) ; } else { spillingSrcDir = null ; spillingOkDir = null ; spillingFailDir = null ; this . spillingEnabled = false ; } this . spillingId = UUID . randomUUID ( ) . toString ( ) ; if ( spillingEnabled ) { LOG . info ( \"Spilling enabled for %s, id is %s, directory is '%s'.\" , spillName , spillingId , spillingSrcDir . getAbsolutePath ( ) ) ; } else { LOG . info ( \"Spilling disabled for %s!\" , spillName ) ; } } private static File createSpillFolder ( final File baseDir , final String folderName ) { if ( baseDir == null ) { return null ; } final File spillingDirectory = new File ( baseDir , folderName ) ; if ( ! spillingDirectory . exists ( ) && ! spillingDirectory . mkdirs ( ) ) { LOG . error ( \"Could not create directory '%s', spilling will probably not work!\" , spillingDirectory ) ; return null ; } if ( spillingDirectory . exists ( ) && spillingDirectory . isDirectory ( ) && spillingDirectory . canWrite ( ) && spillingDirectory . canExecute ( ) ) { LOG . debug ( \"Directory is '%s' is usable.\" , spillingDirectory . getAbsolutePath ( ) ) ; return spillingDirectory ; } else { LOG . warn ( \"Directory '%s' is not usable.\" , spillingDirectory . getAbsolutePath ( ) ) ; return null ; } } public void spillEnqueueing ( final List < Callable < Put > > spillList ) { spill ( spillList ) ; opsEnqSpilled", "gt": ". addAndGet ( spillList . size ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 11222, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . core . databinding . observable . list . ListDiff ; import org . eclipse . core . databinding . observable . list . ListDiffVisitor ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . widgets . Control ; public class CComboItemsProperty extends ControlStringListProperty { protected void doUpdateStringList ( final Control control , ListDiff diff ) { diff . accept ( new ListDiffVisitor ( ) { CCombo combo = ( CCombo ) control ; public void handleAdd ( int index , Object element ) { combo . add ( ( String ) element , index ) ; } public", "gt": "void handleRemove ( int index , Object element )", "prediction": "}\n", "label": 1}
{"id": 340, "input": "<s> package org . ofbiz . webtools . print ; import java . util . Map ; import java . util . Locale ; import java . io . IOException ; import java . io . Writer ; import java . io . StringWriter ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . apache . commons . codec . binary . Base64 ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . widget . screen . ScreenRenderer ; import org . ofbiz . widget . html . HtmlScreenRenderer ; public class FoPrintServerEvents { public static final String module = FoPrintServerEvents . class . getName ( ) ; private static HtmlScreenRenderer htmlScreenRenderer = new HtmlScreenRenderer ( ) ; public static String getXslFo ( HttpServletRequest req , HttpServletResponse resp ) { LocalDispatcher dispatcher = ( LocalDispatcher ) req . getAttribute ( \"dispatcher\" ) ; Map < String , Object > reqParams = UtilHttp . getParameterMap ( req ) ; reqParams . put ( \"locale\" , UtilHttp . getLocale ( req ) ) ; String screenUri = ( String ) reqParams . remove ( \"screenUri\" ) ; if ( UtilValidate . isNotEmpty ( screenUri ) ) { String base64String = null ; try { byte [ ] bytes = FoPrintServerEvents . getXslFo ( dispatcher . getDispatchContext ( ) , screenUri , reqParams ) ; base64String = new String", "gt": "( Base64 . encodeBase64 ( bytes ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11223, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; public class SearchTravRetTask extends SearchTravTask {", "gt": "public SearchTravRetTask ( PerfRunData runData )", "prediction": ";\n", "label": 1}
{"id": 8722, "input": "<s> package com . atlassian . crowd . integration . exception ; @ SuppressWarnings ( \"serial\" ) public class ApplicationPermissionException extends org . apache . axis . AxisFault implements java . io . Serializable { public ApplicationPermissionException ( ) { } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof ApplicationPermissionException ) ) return false ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( ApplicationPermissionException . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName (", "gt": "\"http://exception.integration.crowd.atlassian.com\" , \"ApplicationPermissionException\" ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11249, "input": "<s> package org . nuxeo . ecm . platform . preview . restlet ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import javax . servlet . http . HttpServletResponse ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . international . LocaleSelector ; import org . nuxeo . common . utils . FileUtils ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . platform . preview . api . HtmlPreviewAdapter ; import org . nuxeo . ecm . platform . preview . api . PreviewException ; import org . nuxeo . ecm . platform . preview . helper . PreviewHelper ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . platform . ui . web . restAPI . BaseNuxeoRestlet ; import org . nuxeo . ecm . platform . util . RepositoryLocation ; import org . restlet . data . MediaType ; import org . restlet . data . Request ; import org . restlet . data . Response ; import org . restlet . resource . OutputRepresentation ; @ Name ( \"previewRestlet\" ) @ Scope ( ScopeType . EVENT ) public class PreviewRestlet extends BaseNuxeoRestlet { private static final Log log = LogFactory . getLog ( PreviewRestlet . class ) ; @ In ( create = true ) protected NavigationContext navigationContext ; protected CoreSession documentManager ; protected DocumentModel targetDocument ; @ In ( create = true ) protected transient LocaleSelector localeSelector ; protected static final List < String > previewInProcessing = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; @ Override public void handle ( Request req , Response res ) { localeSelector . setLocale ( getHttpRequest ( req ) . getLocale ( ) ) ; String repo = ( String ) req . getAttributes ( ) . get ( \"repo\" ) ; String docid = ( String ) req . getAttributes ( ) . get ( \"docid\" ) ; String xpath = ( String ) req . getAttributes ( ) . get ( \"fieldPath\" ) ; xpath = xpath . replace ( \"-\" , \"/\" ) ; List < String > segments = req . getResourceRef ( ) . getSegments ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 6 ; i < segments . size ( ) ; i ++ ) { sb . append ( segments . get ( i ) ) ; sb . append ( \"/\" ) ; } String subPath = sb . substring ( 0 , sb . length ( ) - 1 ) ; try { xpath = URLDecoder . decode ( xpath , \"UTF-8\" ) ; subPath = URLDecoder . decode ( subPath , \"UTF-8\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( e ) ; } String blobPostProcessingParameter = getQueryParamValue ( req , \"blobPostProcessing\" , \"false\" ) ; boolean blobPostProcessing = Boolean . parseBoolean ( blobPostProcessingParameter ) ; if ( repo == null || repo . equals ( \"*\" ) ) { handleError ( res , \"you must specify a repository\" ) ; return ; } if ( docid == null || repo . equals ( \"*\" ) ) { handleError ( res , \"you must specify a documentId\" ) ; return ; } try { navigationContext . setCurrentServerLocation ( new RepositoryLocation ( repo ) ) ; documentManager = navigationContext . getOrCreateDocumentManager ( ) ; targetDocument = documentManager . getDocument ( new IdRef ( docid ) ) ; } catch ( ClientException e ) { handleError ( res , e ) ; return ; } List < Blob > previewBlobs ; try { previewBlobs = initCachedBlob ( res , xpath , blobPostProcessing ) ; } catch ( Exception e ) { handleError", "gt": "( res , \"unable to get preview\" ) ;", "prediction": ";\n", "label": 1}
{"id": 7616, "input": "<s> package de . javawi . jstun . attribute ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; import de . javawi . jstun . util . Utility ; import de . javawi . jstun . util . UtilityException ; public abstract class MessageAttribute implements MessageAttributeInterface { private static final Logger LOGGER = LoggerFactory . getLogger ( MessageAttribute . class ) ; MessageAttributeType type ; public MessageAttribute ( ) { } public MessageAttribute ( MessageAttributeType type ) { setType ( type ) ; } public void setType ( MessageAttributeType type ) { this . type = type ; } public MessageAttribute . MessageAttributeType getType ( ) { return type ; } public static int typeToInteger ( MessageAttributeType type ) { if ( type == MessageAttributeType . MappedAddress ) return MAPPEDADDRESS ; if ( type == MessageAttributeType . ResponseAddress ) return RESPONSEADDRESS ; if ( type == MessageAttributeType . ChangeRequest ) return CHANGEREQUEST ; if ( type == MessageAttributeType . SourceAddress ) return SOURCEADDRESS ; if ( type == MessageAttributeType . ChangedAddress ) return CHANGEDADDRESS ; if ( type == MessageAttributeType . Username ) return USERNAME ; if ( type == MessageAttributeType . Password ) return PASSWORD ; if ( type == MessageAttributeType . MessageIntegrity ) return MESSAGEINTEGRITY ; if ( type == MessageAttributeType . ErrorCode ) return ERRORCODE ; if ( type == MessageAttributeType . UnknownAttribute ) return UNKNOWNATTRIBUTE ; if ( type == MessageAttributeType . ReflectedFrom ) return REFLECTEDFROM ; if ( type == MessageAttributeType . Dummy ) return DUMMY ; return - 1 ; } public static MessageAttributeType intToType ( long type ) { if ( type == MAPPEDADDRESS ) return MessageAttributeType . MappedAddress ; if ( type == RESPONSEADDRESS ) return MessageAttributeType . ResponseAddress ; if ( type == CHANGEREQUEST ) return MessageAttributeType . ChangeRequest ; if ( type == SOURCEADDRESS ) return MessageAttributeType . SourceAddress ; if ( type == CHANGEDADDRESS ) return MessageAttributeType . ChangedAddress ; if ( type == USERNAME ) return MessageAttributeType . Username ; if ( type == PASSWORD ) return MessageAttributeType . Password ; if ( type == MESSAGEINTEGRITY ) return MessageAttributeType . MessageIntegrity ; if ( type == ERRORCODE ) return MessageAttributeType . ErrorCode ; if ( type == UNKNOWNATTRIBUTE ) return MessageAttributeType . UnknownAttribute ; if ( type == REFLECTEDFROM ) return MessageAttributeType . ReflectedFrom ; if ( type == DUMMY ) return MessageAttributeType . Dummy ; return null ; } abstract public byte [ ] getBytes ( ) throws UtilityException ; public int getLength ( ) throws UtilityException { int length = getBytes ( ) . length ; return length ; } public static MessageAttribute parseCommonHeader ( byte [ ] data ) throws MessageAttributeParsingException { try { byte [ ] typeArray = new byte [ 2 ] ; System . arraycopy ( data , 0 , typeArray , 0 , 2 ) ; int type = Utility . twoBytesToInteger ( typeArray ) ; byte [ ] lengthArray = new byte [ 2 ] ; System . arraycopy ( data , 2 , lengthArray , 0 , 2 ) ; int lengthValue = Utility . twoBytesToInteger ( lengthArray ) ; byte [ ] valueArray = new byte [ lengthValue ] ; System . arraycopy ( data , 4 , valueArray , 0 , lengthValue ) ; MessageAttribute ma ; switch ( type ) { case MAPPEDADDRESS : ma = MappedAddress . parse ( valueArray ) ; break ; case RESPONSEADDRESS : ma = ResponseAddress . parse ( valueArray ) ; break ; case CHANGEREQUEST : ma = ChangeRequest .", "gt": "parse ( valueArray ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 11275, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec3 . common ; import java . util . List ; public class AccountRepresentation { private List < String > contactRefs ; private List < String > mailRefs ; private List < String > feedRefs ; public AccountRepresentation ( ) { } public List < String > getContactRefs ( ) { return contactRefs ; } public List < String > getFeedRefs ( ) { return feedRefs ; } public List < String > getMailRefs ( ) { return mailRefs ; } public void setContactRefs ( List < String > contactRefs ) { this . contactRefs = contactRefs ; } public void setFeedRefs ( List < String > feedRefs ) { this . feedRefs = feedRefs ; } public void setMailRefs ( List < String > mailRefs ) { this", "gt": ". mailRefs = mailRefs ;", "prediction": ";\n", "label": 1}
{"id": 6013, "input": "<s> package org . ofbiz . service . job ; import java . io . Serializable ; import java . util . Map ; import org . ofbiz . base . util . Assert ; import org . ofbiz . base . util . Debug ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; @ SuppressWarnings ( \"serial\" ) public class GenericServiceJob extends AbstractJob implements Serializable { public static final String module = GenericServiceJob . class . getName ( ) ; protected final transient GenericRequester requester ; protected final transient DispatchContext dctx ; private final String service ; private final Map < String , Object > context ; public GenericServiceJob ( DispatchContext dctx , String jobId , String jobName , String service , Map < String , Object > context , GenericRequester req ) { super ( jobId , jobName ) ; Assert . notNull ( \"dctx\" , dctx ) ; this . dctx = dctx ; this . service = service ; this . context = context ; this . requester = req ; } @ Override public void exec ( ) throws InvalidJobException { if ( currentState != State . QUEUED ) { throw new InvalidJobException ( \"Illegal state change\" ) ; } currentState = State . RUNNING ; init ( ) ; Throwable thrown = null ; Map < String , Object > result = null ; try { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; result = dispatcher . runSync ( getServiceName ( ) , getContext ( ) ) ; if ( ServiceUtil . isError ( result ) ) { thrown = new Exception ( ServiceUtil . getErrorMessage ( result ) ) ; } if ( requester != null ) { requester . receiveResult ( result ) ; } } catch ( Throwable t ) { if ( requester != null ) { requester . receiveThrowable ( t ) ; } thrown = t ; } if ( thrown == null ) { finish ( result ) ; } else { failed ( thrown ) ; } } protected void init ( ) throws InvalidJobException { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Async-Service initializing.\" , module ) ; } protected void finish ( Map < String , Object > result ) throws InvalidJobException { if ( currentState != State . RUNNING ) { throw new InvalidJobException ( \"Illegal state change\" ) ; } currentState = State . FINISHED ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Async-Service finished.\" , module ) ; } protected void failed ( Throwable t ) throws InvalidJobException { if ( currentState != State . RUNNING ) { throw new InvalidJobException ( \"Illegal state change\" ) ; } currentState = State . FAILED ; Debug . logError ( t , \"Async-Service failed.\" , module ) ; } protected Map < String , Object > getContext ( ) throws InvalidJobException { return context ; } protected String getServiceName ( ) { return service ; } @ Override public boolean isValid ( ) { return currentState == State . CREATED ; } @ Override public void deQueue ( ) throws InvalidJobException { super . deQueue ( ) ; throw new InvalidJobException ( \"Unable to queue job [\" + getJobId (", "gt": ") + \"]\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11281, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . controllers ; import android . app . Activity ; import android . app . Fragment ; import com . xtremelabs . androidtohackui . bubbles . fragments . SignInFragment ; public class SignInBubbleController extends AbstractBubbleController { public SignInBubbleController ( Activity activity ) { super ( activity ) ; } @ Override", "gt": "public void onBubbleAttachedToWindow ( )", "prediction": "}\n", "label": 1}
{"id": 168, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Resource ; import org . jjflyboy . tjpeditor . project . ResourceRoot ; public class ResourceRootImpl extends ReportAttributeImpl implements ResourceRoot { protected Resource resource ; protected ResourceRootImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getResourceRoot ( ) ; } public Resource getResource ( ) { if ( resource != null && resource . eIsProxy ( ) ) { InternalEObject oldResource = ( InternalEObject ) resource ; resource = ( Resource ) eResolveProxy ( oldResource ) ; if ( resource != oldResource ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . RESOURCE_ROOT__RESOURCE , oldResource , resource ) ) ; } } return resource ; } public Resource basicGetResource ( ) { return resource ; } public void setResource ( Resource newResource ) { Resource oldResource = resource ; resource = newResource ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . RESOURCE_ROOT__RESOURCE , oldResource , resource ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . RESOURCE_ROOT__RESOURCE : if ( resolve ) return getResource ( ) ; return basicGetResource ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . RESOURCE_ROOT__RESOURCE : setResource ( ( Resource ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . RESOURCE_ROOT__RESOURCE : setResource ( ( Resource ) null ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . RESOURCE_ROOT__RESOURCE : return resource != null ; } return super .", "gt": "eIsSet ( featureID ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 11285, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . util . * ; import java . util . Map . Entry ; import org . eclipse . rap . rwt . internal . theme . ThemePropertyAdapterRegistry . ThemePropertyAdapter ; import org . eclipse . rap . rwt . internal . theme . css . ConditionalValue ; public final class ThemeStoreWriter { private final IThemeCssElement [ ] allThemeableWidgetElements ; private final Collection < ThemeEntry > themes ; public ThemeStoreWriter ( IThemeCssElement [ ] elements ) { allThemeableWidgetElements = elements ; themes = new ArrayList < ThemeEntry > ( ) ; } public void addTheme ( Theme theme , boolean isFallback ) { themes . add ( new ThemeEntry ( theme , isFallback ) ) ; } public String createJs ( ) { QxType [ ] allValues = getValuesFromAllThemes ( ) ; Map valuesMap = createValuesMap ( allValues ) ; StringBuilder jsCode = new StringBuilder ( ) ; jsCode . append ( \"( function( ts ) {\\n\" ) ; jsCode . append ( \"ts.defineValues( \" ) ; jsCode . append ( createJsonFromValuesMap ( valuesMap ) ) ; jsCode . append ( \" );\\n\" ) ; Iterator iterator = themes . iterator ( ) ; while ( iterator . hasNext ( ) ) { ThemeEntry themeEntry = ( ThemeEntry ) iterator . next ( ) ; jsCode . append ( \"ts.setThemeCssValues( \" ) ; jsCode . append ( JsonValue . valueOf ( themeEntry . theme . getJsId ( ) ) ) ; jsCode . append ( \", \" ) ; jsCode . append ( createThemeJson ( themeEntry . theme ) ) ; jsCode . append ( \", \" ) ; jsCode . append ( themeEntry . isFallback ) ; jsCode . append ( \" );\\n\" ) ; } jsCode . append ( \"} )( rwt.theme.ThemeStore.getInstance() );\\n\" ) ; return jsCode . toString ( ) ; } private JsonObject createThemeJson ( Theme theme ) { JsonObject result = new JsonObject ( ) ; ThemeCssValuesMap valuesMap = theme . getValuesMap ( ) ; for ( int i = 0 ; i < allThemeableWidgetElements . length ; i ++ ) { IThemeCssElement element = allThemeableWidgetElements [ i ] ; String elementName = element . getName ( ) ; JsonObject elementObj = createThemeJsonForElement ( valuesMap , element ) ; result . append ( elementName , elementObj ) ; } return result ; } private JsonObject createThemeJsonForElement ( ThemeCssValuesMap valuesMap , IThemeCssElement element ) { JsonObject result = new JsonObject ( ) ; String [ ] properties = element . getProperties ( ) ; ThemePropertyAdapterRegistry registry = ThemePropertyAdapterRegistry . getInstance ( ) ; for ( int i = 0 ; i < properties . length ; i ++ ) { String propertyName = properties [ i ] ; JsonArray valuesArray = new JsonArray ( ) ; String elementName = element . getName ( ) ; ConditionalValue [ ] values = valuesMap . getValues ( elementName , propertyName ) ; for ( int j = 0 ; j < values . length ; j ++ ) { ConditionalValue conditionalValue = values [ j ] ; JsonArray array = new JsonArray ( ) ; array . append ( JsonArray . valueOf ( conditionalValue", "gt": ". constraints ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 755, "input": "<s> package org . meqantt . message ; import java . io . IOException ; public class PubRelMessage extends RetryableMessage { public PubRelMessage ( int messageId ) { super ( Type . PUBREL ) ; setMessageId ( messageId ) ; } public PubRelMessage ( Header header ) throws IOException { super ( header ) ; } @", "gt": "Override public void setRetained ( boolean retain )", "prediction": "}\n", "label": 0}
{"id": 11287, "input": "<s> package org . eclipse . xtext . xdoc . generator . util . lexer ; import java . io . File ; import java . net . URL ; import org . antlr . Tool ; public class GenerateLexer { public static void main ( String [ ] args ) { final Tool tool = new Tool ( ) ; URL resource = GenerateLexer . class . getResource ( \"Common.g\" ) ; tool . addGrammarFile ( resource", "gt": ". getFile ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8735, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class NTimesTest extends TestNgParboiledTest < Object > { @ BuildParseTree static class Parser extends BaseParser < Object > { public Rule Clause ( ) { return NTimes ( 3 , FourDigits ( ) , Operator ( ) ) ; } public Rule Operator ( ) { return FirstOf ( '+' , '-' ) ; } public Rule FourDigits ( ) { return NTimes ( 4 , CharRange ( '0' , '9' ) ) ; } } @ Test public void test ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; Rule rule = parser . Clause ( ) ; test ( rule , \"1234+2345-3456\" ) . hasNoErrors ( ) . hasParseTree ( \"\" + \"[Clause] '1234+2345-3456'\\n\" + \"  [FourDigits] '1234'\\n\" + \"    [0..9] '1'\\n\" + \"    [0..9] '2'\\n\" + \"    [0..9] '3'\\n\" + \"    [0..9] '4'\\n\" + \"  [Operator] '+'\\n\" + \"    ['+'] '+'\\n\" + \"  [FourDigits] '2345'\\n\" + \"    [0..9] '2'\\n\" + \"    [0..9] '3'\\n\" + \"    [0..9] '4'\\n\" + \"    [0..9] '5'\\n\" + \"  [Operator] '-'\\n\" + \"    ['-'] '-'\\n\" + \"  [FourDigits] '3456'\\n\" + \"    [0..9] '3'\\n\" + \"    [0..9] '4'\\n\" + \"    [0..9]", "gt": "'5'\\n\" + \"    [0..9] '6'\\n\" ) ;", "prediction": ";\n", "label": 0}
{"id": 11293, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . io . IOException ; import java . sql . SQLException ; import java . sql . Types ; import org . apache . hadoop . conf . Configurable ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . mapreduce . RecordReader ; import org . apache . sqoop . mapreduce . DBWritable ; import com . cloudera . sqoop . mapreduce . db . DBConfiguration ; import com . cloudera . sqoop . mapreduce . db . DBSplitter ; import com . cloudera . sqoop . mapreduce . db . DataDrivenDBInputFormat ; import com . cloudera . sqoop . mapreduce . db . OracleDataDrivenDBRecordReader ; import com . cloudera . sqoop . mapreduce . db . OracleDateSplitter ; import com . cloudera . sqoop . mapreduce . db . DBInputFormat . DBInputSplit ; public class OracleDataDrivenDBInputFormat < T extends DBWritable > extends DataDrivenDBInputFormat < T > implements Configurable { @ Override protected DBSplitter getSplitter ( int sqlDataType ) { switch ( sqlDataType ) { case Types . DATE : case Types . TIME : case Types . TIMESTAMP : return new OracleDateSplitter ( ) ; default : return super . getSplitter ( sqlDataType ) ; } } @ Override protected RecordReader < LongWritable , T > createDBRecordReader ( DBInputSplit split , Configuration conf ) throws IOException { DBConfiguration dbConf = getDBConf ( ) ; @ SuppressWarnings ( \"unchecked\" ) Class < T > inputClass = ( Class < T > ) ( dbConf . getInputClass ( ) ) ; try { return new OracleDataDrivenDBRecordReader < T > ( split , inputClass , conf , getConnection ( ) , dbConf , dbConf . getInputConditions ( ) , dbConf . getInputFieldNames ( ) , dbConf . getInputTableName ( ) ) ; } catch ( SQLException ex ) { throw new", "gt": "IOException ( ex ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4030, "input": "<s> package org . msl . simple . gmfmap . diagram . parsers ; import org . eclipse . emf . ecore . EAttribute ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleChildReferenceEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLabelNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleTopNodeNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . parsers . MessageFormatParser ; public class SimpleMapMessageFormatParserProvider { public static MessageFormatParser getParser ( int visualId , EAttribute [ ] features ) { return createParser ( visualId , features , null ) ; } public static MessageFormatParser getParser ( int visualId , EAttribute [ ] features , EAttribute [ ] editableFeatures ) { return createParser ( visualId , features , editableFeatures ) ; } private static MessageFormatParser createParser ( int visualId , EAttribute [ ] features , EAttribute [ ] editableFeatures ) { switch ( visualId ) { case SimpleTopNodeNameEditPart . VISUAL_ID : return SimpleNodeFormatParser . getInstance ( features , editableFeatures ) ; case SimpleSubNodeNameEditPart . VISUAL_ID : return SimpleNodeFormatParser . getInstance ( features , editableFeatures ) ; case SimpleLabelNodeEditPart . VISUAL_ID : return SimpleNodeFormatParser . getInstance ( features , editableFeatures ) ; case SimpleCompartmentNameEditPart . VISUAL_ID : return", "gt": "SimpleCompartmentFormatParser . getInstance ( features , editableFeatures ) ;", "prediction": ";\n", "label": 0}
{"id": 11319, "input": "<s> package org . nuxeo . ecm . platform . syndication . serializer ; import java . util . List ; import javax . servlet . http . HttpServletRequest ; import org . dom4j . dom . DOMDocument ; import org . dom4j . dom . DOMDocumentFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . w3c . dom . Element ; public class SimpleXMLSerializer extends AbstractDocumentModelSerializer { private static final String rootNodeName = \"results\" ; private static final String docNodeName = \"document\" ; @ Override public String serialize ( ResultSummary summary , DocumentModelList docList , List < String > columnsDefinition , HttpServletRequest req ) throws ClientException { if ( docList == null ) { return EMPTY_LIST ; } DOMDocumentFactory domfactory = new DOMDocumentFactory ( ) ; DOMDocument result = ( DOMDocument ) domfactory . createDocument ( ) ; Element current = result . createElement ( rootNodeName ) ; result . setRootElement ( ( org . dom4j . Element ) current ) ; Element pagesElement = result . createElement ( \"pages\" ) ; pagesElement . setAttribute ( \"pages\" , Integer . toString ( summary . getPages ( ) ) ) ; pagesElement . setAttribute ( \"pageNumber\" , Integer . toString", "gt": "( summary . getPageNumber ( ) ) ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 3556, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . TimesheetReport ; import org . jjflyboy . tjpeditor . project . TimesheetReportAttribute ; public class TimesheetReportImpl extends PropertyImpl implements TimesheetReport { protected static final String FILENAME_EDEFAULT = null ; protected String filename = FILENAME_EDEFAULT ; protected EList < TimesheetReportAttribute > attributes ; protected TimesheetReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getTimesheetReport ( ) ; } public String getFilename ( ) { return filename ; } public void setFilename ( String newFilename ) { String oldFilename = filename ; filename = newFilename ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TIMESHEET_REPORT__FILENAME , oldFilename , filename ) ) ; } public EList < TimesheetReportAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < TimesheetReportAttribute > ( TimesheetReportAttribute . class , this , ProjectPackage . TIMESHEET_REPORT__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . TIMESHEET_REPORT__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . TIMESHEET_REPORT__FILENAME : return getFilename ( ) ; case ProjectPackage . TIMESHEET_REPORT__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . TIMESHEET_REPORT__FILENAME : setFilename ( ( String ) newValue ) ; return ; case ProjectPackage . TIMESHEET_REPORT__ATTRIBUTES : getAttributes ( ) . clear ( ) ; getAttributes ( ) . addAll ( ( Collection < ? extends TimesheetReportAttribute > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . TIMESHEET_REPORT__FILENAME : setFilename ( FILENAME_EDEFAULT ) ; return ; case ProjectPackage . TIMESHEET_REPORT__ATTRIBUTES : getAttributes ( ) . clear ( ) ; return ; } super", "gt": ". eUnset ( featureID ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11321, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . util . ArrayList ; import java . util . Collection ; public class ThemeCssElement implements IThemeCssElement { private final String name ; private Collection < String > properties ; private Collection < String > styles ; private Collection < String > states ; public ThemeCssElement ( String name ) { this . name = name ; this . properties = new ArrayList < String > ( ) ; this . styles = new ArrayList < String > ( ) ; this . states = new ArrayList < String > ( ) ; } public String getName ( ) { return name ; } public String", "gt": "[ ] getProperties ( )", "prediction": "( )\n", "label": 1}
{"id": 3581, "input": "<s> import com . sun . tools . javap . Main ; import java . io . * ; public class ExtPath { public static void main ( String [ ] args ) { PrintWriter pw = new PrintWriter ( System . out , true ) ;", "gt": "Main . run ( args , pw ) ;", "prediction": "}\n", "label": 0}
{"id": 11335, "input": "<s> package fr . inria . zvtm . widgets ; import java . awt . Color ; import java . awt . geom . Point2D ; import java . util . ArrayList ; import java . util . List ; import fr . inria . zvtm . engine . Utils ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . PRectangle ; import fr . inria . zvtm . glyphs . VText ; public class Menu { protected double width = 200 ; protected static final double DEFAULT_ITEM_HEIGHT = 25 ; protected static final Color MENU_BGCOLOR = new Color ( 70 , 70 , 70 ) ; protected static final Color MENU_HCOLOR = new Color ( 120 , 120 , 120 ) ; protected static final String MENU_BOX_TYPE = \"MENU_BOX\" ; protected final VirtualSpace space ; protected final List < Glyph > elems = new ArrayList < Glyph > ( ) ; public Menu ( VirtualSpace space ) { this . space = space ; } public void show ( ) { for ( Glyph elem : elems ) { space . show ( elem ) ; } } public void hide ( ) { for ( Glyph elem : elems ) { space . hide ( elem ) ; } } public void clear ( ) { for ( Glyph elem : elems ) { space . removeGlyph ( elem ) ; } elems . clear ( ) ; } public double getWidth ( ) { return width ; } public void setWidth ( double width ) { if ( width <= 0 ) { throw new IllegalArgumentException ( \"setWidth: positive value expected\" ) ; } this . width = width ; } protected VText makeLabel ( MenuItem item , double xpos , double ypos ) { VText retval = new VText ( xpos , ypos , 0 , Color . WHITE , item . getText ( ) ) ; retval . setTextAnchor ( VText . TEXT_ANCHOR_MIDDLE ) ; return retval ; } public void populate ( List < MenuItem > items , Point2D . Double coords ) { double xpos = coords", "gt": ". getX ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8523, "input": "<s> package com . sun . tools . doclets . internal . toolkit . taglets ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . Configuration ; import com . sun . tools . doclets . internal . toolkit . util . * ; import java . util . * ; public class ValueTaglet extends BaseInlineTaglet { public ValueTaglet ( ) { name = \"value\" ; } public boolean inMethod ( ) { return true ; } public boolean inConstructor ( ) { return true ; } public boolean inOverview ( ) { return true ; } public boolean inPackage ( ) { return true ; } public boolean inType ( ) { return true ; } private FieldDoc getFieldDoc ( Configuration config , Tag tag , String name ) { if ( name == null || name . length ( ) == 0 ) { if ( tag . holder ( ) instanceof FieldDoc ) { return ( FieldDoc ) tag . holder ( ) ; } else { throw new DocletAbortException ( ) ; } } StringTokenizer st = new StringTokenizer ( name , \"#\" ) ; String memberName = null ; ClassDoc cd = null ; if ( st . countTokens ( ) == 1 ) { Doc holder = tag . holder ( ) ; if ( holder instanceof MemberDoc ) { cd = ( ( MemberDoc ) holder ) . containingClass ( ) ; } else if ( holder instanceof ClassDoc ) { cd = ( ClassDoc ) holder ; } memberName = st", "gt": ". nextToken ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11338, "input": "<s> package com . poetry . model ; import java . io . Serializable ; import javax . persistence . Entity ; import javax . persistence . Id ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; @ Entity public class Block implements Serializable { private static final long serialVersionUID = - 2698184432992671157L ; @ Id protected String following ; @ Id protected String follower ; public Block ( ) { } public Block ( final String following , final String follower ) { this . following = following ; this . follower = follower ; } public String getFollowing ( ) { return following ; } public void setFollowing ( final String following ) { this . following = following ; } public String getFollower ( ) { return follower ; } public void setFollower ( final String follower ) { this . follower = follower ; } @ Override public int hashCode ( ) { return new HashCodeBuilder ( ) . append ( following ) . append ( follower ) . toHashCode ( ) ; } @ Override public boolean equals ( final Object obj ) { if ( ! ( obj instanceof Block ) ) { return false ; } Block other = ( Block ) obj ; return new EqualsBuilder ( ) . append ( following , other . following ) . append (", "gt": "follower , other . follower ) . isEquals ( ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8904, "input": "<s> abstract class Abs { } class ClassIsAbstract { void method ( ) {", "gt": "new Abs ( ) ;", "prediction": "}\n", "label": 0}
{"id": 11357, "input": "<s> package org . springframework . tenancy . datasource ; import org . springframework . tenancy . context . TenancyContext ; import org . springframework . tenancy . context . TenancyContextHolder ; import org . springframework . tenancy . core . Tenant ; public class TenantAwareDataSource extends AbstractDatabaseSwitchingDataSource { @ Override protected String getDatabaseName ( ) { String dbName = null ; TenancyContext tenancyContext", "gt": "= TenancyContextHolder . getContext ( ) ;", "prediction": ";\n", "label": 1}
{"id": 9695, "input": "<s> package p1 ; public class D extends C < String > { public", "gt": "void m ( String arg )", "prediction": "( )\n", "label": 0}
{"id": 11364, "input": "<s> package org . eclipse . swt . accessibility ; import org . eclipse . swt . internal . * ; public class AccessibleAttributeEvent extends SWTEventObject { public int topMargin ; public int bottomMargin ; public int leftMargin ; public int rightMargin ; public int [ ] tabStops ; public boolean justify ; public int alignment ; public int indent ; public String [ ] attributes ; static final long serialVersionUID = 2237016128901566049L ; public AccessibleAttributeEvent ( Object source ) { super ( source ) ; } public String toString ( ) { return \"AccessibleAttributeEvent {\" + \" topMargin=\" + topMargin + \" bottomMargin=\" + bottomMargin + \" leftMargin=\" + leftMargin + \" rightMargin=\" + rightMargin + \" tabStops=\" + tabStops + \" justify=\" + justify + \" alignment=\" +", "gt": "alignment + \" indent=\" + indent + \"}\" ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 8356, "input": "<s> class ResourceNotApplicableToType { void m ( ) { try", "gt": "( String s = \"\" )", "prediction": ";\n", "label": 0}
{"id": 11402, "input": "<s> package org . apache . lucene . analysis ; import java . io . IOException ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . TermVector ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermPositions ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; public class TestCachingTokenFilter extends BaseTokenStreamTestCase { private String [ ] tokens = new String [ ] { \"term1\" , \"term2\" , \"term3\" , \"term2\" } ; public void testCaching ( ) throws IOException { Directory dir = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( dir , new SimpleAnalyzer ( ) , IndexWriter . MaxFieldLength . LIMITED ) ; Document doc = new Document ( ) ; TokenStream stream = new TokenStream ( ) { private int index = 0 ; private TermAttribute termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; private OffsetAttribute offsetAtt = ( OffsetAttribute ) addAttribute ( OffsetAttribute . class ) ; public boolean incrementToken ( ) throws IOException { if ( index == tokens . length ) { return false ; } else { clearAttributes ( ) ; termAtt . setTermBuffer ( tokens [ index ++ ] ) ; offsetAtt . setOffset ( 0 , 0 ) ; return true ; } } } ; stream = new CachingTokenFilter ( stream ) ; doc . add ( new Field ( \"preanalyzed\" , stream , TermVector . NO ) ) ; checkTokens ( stream ) ; stream . reset ( ) ; checkTokens ( stream ) ; writer . addDocument ( doc ) ; writer . close ( ) ; IndexReader reader = IndexReader . open ( dir ) ; TermPositions termPositions = reader . termPositions ( new Term ( \"preanalyzed\" , \"term1\" ) ) ; assertTrue ( termPositions . next ( ) ) ; assertEquals ( 1 , termPositions . freq ( ) ) ; assertEquals ( 0 , termPositions . nextPosition ( ) ) ; termPositions . seek ( new Term ( \"preanalyzed\" , \"term2\" ) ) ; assertTrue", "gt": "( termPositions . next ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 3659, "input": "<s> package com . sap . prd . mobile . ios . mios ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStream ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import junit . framework . Assert ; import org . apache . commons . io . IOUtils ; import org . apache . maven . it . VerificationException ; import org . apache . maven . it . Verifier ; import org . apache . maven . it . util . IOUtil ; import org . junit . Test ; public class XCodeLifecycleTest extends XCodeTest { @ Test public void testLifecycle ( ) throws Exception { final String testName = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getMethodName ( ) ; final File remoteRepositoryDirectory = getRemoteRepositoryDirectory ( getClass ( ) . getName ( ) ) ; prepareRemoteRepository ( remoteRepositoryDirectory ) ; test ( testName , new File ( getTestRootDirectory ( ) , \"straight-forward/MyLibrary\" ) , \"pom.xml\" , \"deploy\" , THE_EMPTY_LIST , THE_EMPTY_MAP , remoteRepositoryDirectory ) ; assertBuildEnvironmentPropertiesFile ( testName , \"MyLibrary\" ) ; final String myLibArtifactFilePrefix = Constants . GROUP_ID_WITH_SLASH + \"/MyLibrary/\" + Constants . LIB_VERSION + \"/MyLibrary-\" + Constants . LIB_VERSION ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-Release-iphoneos.headers.tar\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-Release-iphonesimulator.headers.tar\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-Debug-iphoneos.headers.tar\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-Debug-iphonesimulator.headers.tar\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-MyLibrary.xcode-bundle-zip\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-MyLibrary.raw.xcode-bundle-zip\" ) . exists ( ) ) ; assertTrue ( new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-Resources~Another.xcode-bundle-zip\" ) . exists ( ) ) ; File versionFileLib = new File ( remoteRepositoryDirectory , myLibArtifactFilePrefix + \"-versions.xml\" ) ; assertTrue ( versionFileLib . exists ( ) ) ; compareFileContent ( new File ( \"src/test/resources/MyLibrary-1.0.0-versions.xml\" ) , versionFileLib ) ; Map < String , String > additionalSystemProperties = new HashMap < String , String > ( ) ; additionalSystemProperties . put ( \"mios.ota-service.url\" , \"http://apple-ota.wdf.sap.corp:8080/ota-service/HTML\" ) ; additionalSystemProperties . put ( \"xcode.app.defaultConfigurations\" , \"Release\" ) ; additionalSystemProperties . put ( \"xcode.app.defaultSdks\" , \"iphoneos\" ) ; additionalSystemProperties . put ( \"archive.dir\" , \"archive\" ) ; Verifier appVerifier = test ( testName , new File ( getTestRootDirectory ( ) , \"straight-forward/MyApp\" ) , \"pom.xml\" , \"deploy\" , THE_EMPTY_LIST , additionalSystemProperties , remoteRepositoryDirectory ) ; final String myAppVersionRepoDir = Constants . GROUP_ID_WITH_SLASH + \"/MyApp/\" + Constants . APP_VERSION ; final String myAppArtifactFilePrefix = myAppVersionRepoDir +", "gt": "\"/MyApp-\" + Constants . APP_VERSION ;", "prediction": ";\n", "label": 0}
{"id": 11409, "input": "<s> package org . apache . lucene . wordnet ; import java . io . File ; import java . io . IOException ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Searcher ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . util . LuceneTestCase ; public class TestWordnet extends LuceneTestCase { private Searcher searcher ; File dataDir = new File ( System . getProperty ( \"dataDir\" , \"./bin\" ) ) ; File testFile = new File ( dataDir , \"org/apache/lucene/wordnet/testSynonyms.txt\" ) ; String storePathName = new File ( System . getProperty ( \"tempDir\" ) , \"testLuceneWordnet\" ) . getAbsolutePath ( ) ; protected void setUp ( ) throws Exception { super . setUp ( ) ; String commandLineArgs [ ] = { testFile . getAbsolutePath ( ) , storePathName } ; try { Syns2Index . main ( commandLineArgs ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } searcher = new IndexSearcher ( FSDirectory . open ( new File ( storePathName ) ) , true ) ; } public void testExpansion ( ) throws IOException { assertExpandsTo ( \"woods\" , new String [ ] { \"woods\" , \"forest\" , \"wood\" } ) ; } public void testExpansionSingleQuote ( ) throws IOException { assertExpandsTo ( \"king\" , new String [ ] { \"king\" , \"baron\" } ) ; } private void assertExpandsTo ( String term , String expected [ ] ) throws IOException { Query expandedQuery = SynExpand . expand ( term , searcher , new WhitespaceAnalyzer ( ) , \"field\" , 1F ) ; BooleanQuery expectedQuery = new BooleanQuery ( ) ; for ( int i = 0 ; i < expected . length ; i ++ ) expectedQuery . add ( new TermQuery ( new Term ( \"field\" , expected [ i ] ) ) , BooleanClause . Occur . SHOULD ) ; assertEquals ( expectedQuery , expandedQuery ) ; } protected void tearDown ( ) throws Exception {", "gt": "searcher . close ( ) ;", "prediction": "}\n", "label": 1}
{"id": 861, "input": "<s> package Liza ; import org . bukkit . Server ;", "gt": "public interface LizaServer extends Server", "prediction": "}\n", "label": 0}
{"id": 11421, "input": "<s> package org . apache . lucene . analysis . th ; import java . io . Reader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceTokenizer ; public class TestThaiAnalyzer extends BaseTokenStreamTestCase { public void testOffsets ( ) throws Exception { assertAnalyzesTo ( new ThaiAnalyzer ( ) , \"\u0e40\u0e14\u0e2d\u0e30\u0e19\u0e34\u0e27\u0e22\u0e2d\u0e23\u0e4c\u0e01\u0e44\u0e17\u0e21\u0e2a\u0e4c\" , new String [ ] { \"\u0e40\u0e14\" , \"\u0e2d\u0e30\u0e19\u0e34\u0e27\" , \"\u0e22\u0e2d\" , \"\u0e23\u0e4c\u0e01\" , \"\u0e44\u0e17\u0e21\u0e2a\u0e4c\" } , new int [ ] { 0 , 2 , 7 , 9 , 12 } , new int [ ] { 2 , 7 , 9 , 12 , 17 } ) ; } public void testBuggyTokenType ( ) throws Exception { assertAnalyzesTo ( new ThaiAnalyzer ( ) , \"\u0e40\u0e14\u0e2d\u0e30\u0e19\u0e34\u0e27\u0e22\u0e2d\u0e23\u0e4c\u0e01\u0e44\u0e17\u0e21\u0e2a\u0e4c \u0e51\u0e52\u0e53\" , new String [ ] { \"\u0e40\u0e14\" , \"\u0e2d\u0e30\u0e19\u0e34\u0e27\" , \"\u0e22\u0e2d\" , \"\u0e23\u0e4c\u0e01\" , \"\u0e44\u0e17\u0e21\u0e2a\u0e4c\" , \"\u0e51\u0e52\u0e53\" } , new String [ ] { \"<ALPHANUM>\" , \"<ALPHANUM>\" , \"<ALPHANUM>\" , \"<ALPHANUM>\" , \"<ALPHANUM>\" , \"<ALPHANUM>\" } ) ; } public void testAnalyzer ( ) throws Exception { ThaiAnalyzer analyzer = new ThaiAnalyzer ( ) ; assertAnalyzesTo ( analyzer , \"\" , new String [ ] { } ) ; assertAnalyzesTo ( analyzer , \"\u0e01\u0e32\u0e23\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e15\u0e49\u0e2d\u0e07\u0e41\u0e2a\u0e14\u0e07\u0e27\u0e48\u0e32\u0e07\u0e32\u0e19\u0e14\u0e35\" , new String [ ] { \"\u0e01\u0e32\u0e23\" , \"\u0e17\u0e35\u0e48\" , \"\u0e44\u0e14\u0e49\" , \"\u0e15\u0e49\u0e2d\u0e07\" , \"\u0e41\u0e2a\u0e14\u0e07\" , \"\u0e27\u0e48\u0e32\" , \"\u0e07\u0e32\u0e19\" , \"\u0e14\u0e35\" } ) ; assertAnalyzesTo ( analyzer , \"\u0e1a\u0e23\u0e34\u0e29\u0e31\u0e17\u0e0a\u0e37\u0e48\u0e2d XY&Z - \u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a xyz@demo.com\" , new String [ ] { \"\u0e1a\u0e23\u0e34\u0e29\u0e31\u0e17\" , \"\u0e0a\u0e37\u0e48\u0e2d\" , \"xy&z\" , \"\u0e04\u0e38\u0e22\" , \"\u0e01\u0e31\u0e1a\" , \"xyz@demo.com\" } ) ; assertAnalyzesTo ( analyzer , \"\u0e1b\u0e23\u0e30\u0e42\u0e22\u0e04\u0e27\u0e48\u0e32 The quick brown fox jumped over the lazy dogs\" , new String [ ] { \"\u0e1b\u0e23\u0e30\u0e42\u0e22\u0e04\" , \"\u0e27\u0e48\u0e32\" , \"quick\" , \"brown\" , \"fox\" , \"jumped\" , \"over\" , \"lazy\" , \"dogs\" } ) ; } public void testReusableTokenStream ( ) throws Exception { ThaiAnalyzer analyzer = new ThaiAnalyzer ( ) ; assertAnalyzesToReuse ( analyzer , \"\" , new String [ ] { } ) ; assertAnalyzesToReuse ( analyzer , \"\u0e01\u0e32\u0e23\u0e17\u0e35\u0e48\u0e44\u0e14\u0e49\u0e15\u0e49\u0e2d\u0e07\u0e41\u0e2a\u0e14\u0e07\u0e27\u0e48\u0e32\u0e07\u0e32\u0e19\u0e14\u0e35\" , new String [ ] { \"\u0e01\u0e32\u0e23\" , \"\u0e17\u0e35\u0e48\" , \"\u0e44\u0e14\u0e49\" , \"\u0e15\u0e49\u0e2d\u0e07\" , \"\u0e41\u0e2a\u0e14\u0e07\" , \"\u0e27\u0e48\u0e32\" , \"\u0e07\u0e32\u0e19\" , \"\u0e14\u0e35\" } ) ; assertAnalyzesToReuse ( analyzer , \"\u0e1a\u0e23\u0e34\u0e29\u0e31\u0e17\u0e0a\u0e37\u0e48\u0e2d XY&Z - \u0e04\u0e38\u0e22\u0e01\u0e31\u0e1a xyz@demo.com\" , new String [ ] { \"\u0e1a\u0e23\u0e34\u0e29\u0e31\u0e17\" , \"\u0e0a\u0e37\u0e48\u0e2d\" , \"xy&z\" , \"\u0e04\u0e38\u0e22\" , \"\u0e01\u0e31\u0e1a\" , \"xyz@demo.com\" } ) ; } private class ThaiSubclassAnalyzer extends ThaiAnalyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new WhitespaceTokenizer ( reader ) ; } } public void testLUCENE1678BWComp ( ) throws Exception { ThaiSubclassAnalyzer a", "gt": "= new ThaiSubclassAnalyzer ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2802, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . event . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import java . awt . * ; import java . awt . event . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . util . logging . Logger ; public class PgsTabbedPaneUI extends BasicTabbedPaneUI { private boolean paintFocus ; private int rolloverTabIndex ; private TabRolloverHandler tabHandler ; private MyPropertyChangeHandler propHandler ; private TabbedPaneMouseWheelScroller tabScrollHandler ; private TabSelectionMouseHandler tabSelectionHandler ; private static Logger logger = Logger . getLogger ( \"PgsTabbedPaneUI\" ) ; public static final String IS_SUB_TAB = \"pgs.isSubTab\" ; public static final String IS_BUTTON_STYLE = \"pgs.isButtonStyle\" ; public static final String NO_BORDER = \"pgs.noBorder\" ; public static ComponentUI createUI ( JComponent c ) { return new PgsTabbedPaneUI ( ) ; } protected void installDefaults ( ) { super . installDefaults ( ) ; updateBackgroundOpacity ( ) ; paintFocus = UIManager . getBoolean ( \"TabbedPane.focusPainted\" ) ; } protected void installListeners ( ) { super . installListeners ( ) ; if ( tabHandler == null ) { tabHandler = new TabRolloverHandler ( ) ; } tabPane . addMouseListener ( tabHandler ) ; tabPane . addMouseMotionListener ( tabHandler ) ; if ( propHandler == null ) { propHandler = new MyPropertyChangeHandler ( ) ; } tabPane . addPropertyChangeListener ( propHandler ) ; if ( PlafOptions . isWheelTabbedPaneEnabled ( ) ) { if ( tabScrollHandler == null ) { tabScrollHandler = new TabbedPaneMouseWheelScroller ( ) ; } tabPane . addMouseWheelListener ( tabScrollHandler ) ; } if ( PlafOptions . isTabbedPaneRightClickSelectionEnabled ( ) ) { if ( tabSelectionHandler == null ) { tabSelectionHandler = new TabSelectionMouseHandler ( ) ; } tabPane . addMouseListener ( tabSelectionHandler ) ; } if ( PlafOptions . isTabReorderingEnabled ( ) ) { enableReordering ( ) ; } } protected void uninstallListeners ( ) { super . uninstallListeners ( ) ; tabPane . removeMouseListener ( tabHandler ) ; tabPane . removeMouseMotionListener ( tabHandler ) ; tabPane . removePropertyChangeListener ( propHandler ) ; if ( tabScrollHandler != null ) { tabPane . removeMouseWheelListener ( tabScrollHandler ) ; } if ( tabSelectionHandler != null ) { tabPane . removeMouseListener ( tabSelectionHandler ) ; } disableReordering ( ) ; } private void updateBackgroundOpacity ( ) { if ( isSubTab ( ) || isButtonStyle ( ) ) { tabPane . setOpaque ( true ) ; if ( isSubTab ( ) ) { tabPane . setBackground ( UIManager . getColor ( \"TabbedPane.background\" ) ) ; } else if ( isButtonStyle ( ) ) { tabPane . setBackground ( UIManager . getColor ( \"TabbedPane.buttonStyle.background\" ) ) ; } } else { tabPane . setOpaque ( false ) ; } } private boolean checkBooleanClientProperty ( Object key ) { Object o = tabPane . getClientProperty ( key ) ; if ( o == null ) { return false ; } if ( o instanceof Boolean ) { return ( ( Boolean ) o ) . booleanValue ( ) ; } if ( o instanceof Integer ) { return ( ( Integer ) o ) . intValue ( ) != 0 ; } logger . warning ( \"It seems like you've used a wrong type for '\" + key + \"'. It should be a boolean, but is a \" + o . getClass ( ) . getName ( ) ) ; return true ; } private boolean isSubTab ( ) { return checkBooleanClientProperty ( IS_SUB_TAB ) ; } private boolean isButtonStyle ( ) { return checkBooleanClientProperty ( IS_BUTTON_STYLE ) ; } private void mySetRolloverTab ( int x , int y ) { mySetRolloverTab ( myTabForCoordinate ( tabPane , x , y ) ) ; } private int myTabForCoordinate ( JTabbedPane pane , int x , int y ) { Point p = new Point ( x , y ) ; int tabCount = tabPane . getTabCount ( ) ; for", "gt": "( int i = 0 ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11432, "input": "<s> package org . eclipse . ui . internal . activities ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . ui . activities . IActivityManager ; import org . eclipse . ui . activities . ICategory ; import org . eclipse . ui . activities . ICategoryActivityBinding ; public final class InternalActivityHelper { public static Set getActivityIdsForCategory ( IActivityManager activityManager , ICategory category ) { Set bindings = category . getCategoryActivityBindings ( ) ; Set activityIds = new HashSet ( ) ; for ( Iterator i = bindings . iterator ( ) ; i . hasNext ( ) ; ) { ICategoryActivityBinding binding = ( ICategoryActivityBinding ) i . next ( ) ; String id = binding . getActivityId ( ) ; if ( activityManager . getActivity ( id ) . getExpression ( ) == null ) activityIds . add ( id ) ; } return activityIds ; } private static boolean isEnabled ( IActivityManager activityManager , String categoryId ) { ICategory category = activityManager . getCategory ( categoryId ) ; if ( category . isDefined ( ) ) { Set activityIds = getActivityIdsForCategory ( activityManager , category ) ; if ( activityManager . getEnabledActivityIds ( ) . containsAll ( activityIds ) ) { return true ; } } return false ; } public static Set getEnabledCategories ( IActivityManager activityManager ) { Set definedCategoryIds = activityManager . getDefinedCategoryIds ( ) ; Set enabledCategories = new HashSet ( ) ; for ( Iterator i = definedCategoryIds . iterator ( ) ; i . hasNext ( ) ; ) { String categoryId = ( String ) i . next ( ) ; if ( isEnabled ( activityManager , categoryId ) ) { enabledCategories . add ( categoryId ) ; } } return enabledCategories ; } public static Set getPartiallyEnabledCategories ( IActivityManager activityManager ) { Set definedCategoryIds = activityManager . getDefinedCategoryIds ( ) ; Set partialCategories = new HashSet ( ) ; for ( Iterator i = definedCategoryIds . iterator ( ) ; i . hasNext ( ) ; ) { String categoryId = ( String ) i . next ( ) ; if ( isPartiallyEnabled ( activityManager , categoryId ) ) { partialCategories . add ( categoryId ) ; } } return partialCategories ; } private static boolean isPartiallyEnabled ( IActivityManager activityManager , String categoryId ) { Set activityIds = getActivityIdsForCategory ( activityManager , activityManager . getCategory ( categoryId ) ) ; int foundCount = 0 ; for ( Iterator i = activityIds . iterator ( ) ; i", "gt": ". hasNext ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4695, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class WireParseException extends IOException { public WireParseException ( ) { super ( ) ; } public WireParseException ( String s ) { super ( s ) ; }", "gt": "public WireParseException ( String s , Throwable cause )", "prediction": "}\n", "label": 0}
{"id": 11436, "input": "<s> package org . eclipse . swt . widgets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . events . TreeListener ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . ICellToolTipAdapter ; import org . eclipse . swt . internal . widgets . ICellToolTipProvider ; import org . eclipse . swt . internal . widgets . IItemHolderAdapter ; import org . eclipse . swt . internal . widgets . ITreeAdapter ; import org . eclipse . swt . internal . widgets . ItemHolder ; import org . eclipse . swt . internal . widgets . MarkupValidator ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . internal . widgets . treekit . TreeThemeAdapter ; public class Tree extends Composite { private static final TreeItem [ ] EMPTY_SELECTION = new TreeItem [ 0 ] ; private static final int MIN_ITEM_HEIGHT = 16 ; private static final int GRID_WIDTH = 1 ; private static final Rectangle TEXT_MARGIN = new Rectangle ( 3 , 0 , 8 , 0 ) ; private int itemCount ; private int customItemHeight ; private TreeItem [ ] items ; final ItemHolder < TreeColumn > columnHolder ; private TreeItem [ ] selection ; private boolean linesVisible ; private int [ ] columnOrder ; private int itemImageCount ; private TreeColumn sortColumn ; private int sortDirection ; private boolean headerVisible ; private final ITreeAdapter treeAdapter ; private int scrollLeft ; private int topItemIndex ; private boolean hasVScrollBar ; private boolean hasHScrollBar ; private Point itemImageSize ; LayoutCache layoutCache ; boolean isFlatIndexValid ; private int visibleItemsCount ; boolean markupEnabled ; boolean markupValidationDisabled ; public Tree ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; columnHolder = new ItemHolder < TreeColumn > ( TreeColumn . class ) ; treeAdapter = new InternalTreeAdapter ( ) ; setTreeEmpty ( ) ; sortDirection = SWT . NONE ; selection = EMPTY_SELECTION ; customItemHeight = - 1 ; layoutCache = new LayoutCache ( ) ; } TreeItem [ ] getCreatedItems ( ) { TreeItem [ ] result ; if ( isVirtual ( ) ) {", "gt": "int count = 0 ;", "prediction": "}\n", "label": 1}
{"id": 4714, "input": "<s> public class Primitives { @ java . lang . annotation . Retention ( java . lang . annotation . RetentionPolicy . RUNTIME ) @ interface A { Class value ( ) default void . class ; } @ java . lang . annotation . Retention ( java . lang . annotation . RetentionPolicy . RUNTIME ) @ interface B { Class [ ] value ( ) default { void . class } ; } @ A ( ) @ B ( ) static class T1 { } @ A ( int . class ) @ B ( { void . class , byte . class , char . class , short . class , int . class , long . class , boolean . class , float . class , double . class , A [ ] . class , int [ ] . class } ) static class T2 { } static void check ( Object actual , Object expected ) { if ( actual != expected ) throw new Error ( \"expected: \" + expected + \"; actual = \" + actual ) ; } public static void main ( String [ ] args ) { check ( T1 . class . getAnnotation ( A . class ) . value ( ) , void . class ) ; check ( T1 . class . getAnnotation ( B . class ) . value ( ) . length , 1 ) ; check ( T1 . class . getAnnotation ( B . class ) . value ( ) [ 0 ] , void . class ) ; check ( T2 . class . getAnnotation ( A . class ) . value ( ) , int . class ) ; check ( T2 . class . getAnnotation ( B . class ) . value ( ) . length , 11 ) ; check ( T2 . class . getAnnotation ( B . class ) . value ( ) [ 0 ] , void . class ) ; check ( T2 . class . getAnnotation ( B . class ) . value ( ) [ 1 ] , byte . class ) ; check ( T2 . class . getAnnotation ( B . class ) . value ( ) [ 2 ] , char . class ) ; check ( T2 . class . getAnnotation ( B . class ) . value ( ) [", "gt": "3 ] , short . class ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11441, "input": "<s> package fr . inria . zvtm . glyphs ; import java . awt . AlphaComposite ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Container ; import java . awt . Cursor ; import java . awt . Dialog ; import java . awt . Dimension ; import java . awt . FlowLayout ; import java . awt . Frame ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . GridLayout ; import java . awt . Polygon ; import java . awt . RenderingHints ; import java . awt . Stroke ; import java . awt . Window ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . ComponentAdapter ; import java . awt . event . ComponentEvent ; import java . awt . event . MouseEvent ; import java . awt . event . MouseListener ; import java . awt . event . MouseMotionListener ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . util . Vector ; import javax . swing . BorderFactory ; import javax . swing . JButton ; import javax . swing . JCheckBox ; import javax . swing . JColorChooser ; import javax . swing . JComboBox ; import javax . swing . JDialog ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JSpinner ; import javax . swing . SpinnerNumberModel ; import javax . swing . event . ChangeEvent ; import javax . swing . event . ChangeListener ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . VCircle ; import fr . inria . zvtm . glyphs . VEllipse ; import fr . inria . zvtm . glyphs . VRectangle ; import fr . inria . zvtm . glyphs . VRectangleOr ; import fr . inria . zvtm . glyphs . VShape ; public class GlyphFactory extends JDialog implements ActionListener , MouseListener , ChangeListener { public static Color PANEL_BKG = ( Color ) javax . swing . UIManager . getLookAndFeelDefaults ( ) . get ( \"Panel.background\" ) ; public static String V_Shape = \"VShape\" ; public static String V_Rectangle = \"VRectangle\" ; public static String V_Ellipse = \"VEllipse\" ; public static String V_Circle = \"VCircle\" ; private static Vector initShapeTypes ( ) { Vector res = new Vector ( ) ; res . add ( V_Shape ) ; res . add ( V_Rectangle ) ; res . add ( V_Ellipse ) ; res . add ( V_Circle ) ; return res ; } private", "gt": "static Vector allowedShapeTypes = initShapeTypes ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8872, "input": "<s> package ambig1 ; import static ambig1 . A . f ; import static ambig1 . B . f ; class A { static void f ( int i ) { } } class B { static void", "gt": "f ( int i )", "prediction": "( )\n", "label": 0}
{"id": 11443, "input": "<s> package com . talis . hbase . rdf . examples . benchmarks . lubm ; import org . mindswap . pellet . jena . PelletReasonerFactory ; import com . hp . hpl . jena . ontology . OntModel ; import com . hp . hpl . jena . query . Query ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . QueryFactory ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . talis . hbase . rdf . HBaseRdfFactory ; import com . talis . hbase . rdf . Store ; public class LubmQ5 { public static void main ( String [ ] args ) { Store store = HBaseRdfFactory . connectStore ( args [ 0 ] ) ; Model schema =", "gt": "HBaseRdfFactory . connectNamedModel ( store , \"http://cs.utdallas.edu/hbase-rdf/bm#LUBM\" ) ;", "prediction": ";\n", "label": 1}
{"id": 6092, "input": "<s> public class Closure4 { public int v ; public Closure4 ( ) { v = 0 ; Inner i = new Inner ( ) { public void foo ( ) { if ( v != 0 ) throw new Error ( ) ; } } ; i . foo ( ) ; } public static void main ( String [ ] arg ) {", "gt": "new Closure4 ( ) ;", "prediction": "\n", "label": 0}
{"id": 11446, "input": "<s> package org . eclipse . jface . fieldassist ; import org . eclipse . jface . util . Util ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Control ; public class ComboContentAdapter implements IControlContentAdapter , IControlContentAdapter2 { private static final boolean COMPUTE_TEXT_USING_CLIENTAREA = ! Util . isCarbon ( ) ; public String getControlContents ( Control control ) { return ( ( Combo ) control ) . getText ( ) ; } public void setControlContents ( Control control , String text , int cursorPosition ) { ( ( Combo ) control ) . setText ( text ) ; ( ( Combo ) control ) . setSelection ( new Point ( cursorPosition , cursorPosition ) ) ; } public void insertControlContents ( Control control , String text , int cursorPosition ) { Combo combo = ( Combo ) control ; String contents = combo . getText ( ) ; Point selection = combo . getSelection ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( contents . substring ( 0 , selection . x ) ) ; sb . append ( text ) ; if ( selection . y < contents . length ( ) ) { sb . append ( contents . substring ( selection . y , contents . length ( ) ) ) ; } combo . setText ( sb . toString ( ) ) ; selection . x = selection . x + cursorPosition ; selection . y = selection . x ; combo . setSelection ( selection ) ; } public int getCursorPosition ( Control control ) { return ( ( Combo ) control ) . getSelection ( ) . x ; } public Rectangle getInsertionBounds ( Control control ) { Combo combo = ( Combo ) control ; int position = combo . getSelection ( ) . y ; String contents = combo . getText ( ) ; GC gc = new GC ( combo ) ; gc . setFont ( combo . getFont ( ) ) ; Point extent = gc . textExtent ( contents . substring ( 0 , Math . min ( position , contents . length ( ) ) ) ) ; gc . dispose ( ) ; if ( COMPUTE_TEXT_USING_CLIENTAREA ) { return new Rectangle ( combo . getClientArea ( ) . x + extent . x , combo . getClientArea ( ) . y , 1 , combo . getClientArea ( ) . height ) ; } return new Rectangle ( extent . x , 0 , 1 , combo . getSize ( ) . y ) ; } public void", "gt": "setCursorPosition ( Control control , int index )", "prediction": "( )\n", "label": 1}
{"id": 9414, "input": "<s> import java . io . * ; public class T6937244 { public static void main ( String [ ] args ) throws Exception { new T6937244 ( ) . run ( ) ; } void run ( ) throws Exception { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; String [ ] args = { \"java.lang.String\" } ; int rc = com . sun . tools . javap . Main . run ( args , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; System . err . println ( out ) ; if ( rc != 0 ) throw new Exception ( \"unexpected exit from javap: \" + rc ) ; for ( String line : out . split ( \"[\\r\\n]+\" ) ) { if ( line . contains ( \"CASE_INSENSITIVE_ORDER\" ) ) { if ( line . matches ( \"\\\\s*\\\\Qpublic static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;\\\\E\\\\s*\" ) ) return ; throw new Exception ( \"declaration not shown as expected\" ) ; } } throw new Exception", "gt": "( \"declaration of CASE_INSENSITIVE_ORDER not found\" ) ;", "prediction": ";\n", "label": 0}
{"id": 11448, "input": "<s> package org . eclipse . jface . databinding . viewers ; import org . eclipse . core . databinding . observable", "gt": ". set . IObservableSet ;", "prediction": ";\n", "label": 1}
{"id": 9757, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignAreaPlot ; import net . sf . jasperreports . charts . design . JRDesignXyDataset ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJXYAreaChartBuilder ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class XYAreaChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnCode ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; drb . setUseFullPageWidth ( true ) ; DJAxisFormat categoryAxisFormat = new DJAxisFormat ( \"x\" ) ; categoryAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelMask ( \"#,###.#\" ) ; categoryAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJAxisFormat valueAxisFormat = new DJAxisFormat ( \"value\" ) ; valueAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelMask ( \"#,##0.0\" ) ; valueAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJChart djChart = new DJXYAreaChartBuilder ( ) . setX ( 20 ) . setY ( 10 ) . setWidth ( 500 ) . setHeight ( 250 ) . setCentered ( false ) . setBackColor ( Color . LIGHT_GRAY ) . setShowLegend ( true ) . setPosition ( DJChartOptions . POSITION_FOOTER ) . setTitle ( \"title\" ) . setTitleColor ( Color . DARK_GRAY ) . setTitleFont ( Font . ARIAL_BIG_BOLD ) . setSubtitle ( \"subtitle\" ) . setSubtitleColor ( Color . DARK_GRAY ) . setSubtitleFont ( Font . COURIER_NEW_BIG_BOLD ) . setLegendColor ( Color . DARK_GRAY ) . setLegendFont ( Font . COURIER_NEW_MEDIUM_BOLD ) . setLegendBackgroundColor ( Color . WHITE ) . setLegendPosition ( DJChartOptions . EDGE_BOTTOM ) . setTitlePosition ( DJChartOptions . EDGE_TOP ) . setLineStyle ( DJChartOptions . LINE_STYLE_DOTTED ) . setLineWidth ( 1 ) . setLineColor ( Color . DARK_GRAY ) . setPadding ( 5 ) . setXValue ( ( PropertyColumn ) columnCode ) . addSerie ( columnaQuantity , \"quant.\" ) . addSerie ( columnAmount ) . setCategoryAxisFormat ( categoryAxisFormat ) . setValueAxisFormat ( valueAxisFormat ) . build ( ) ; drb . addChart ( djChart ) ; DJHyperLink djlink = new DJHyperLink ( ) ; djlink . setExpression ( new StringExpression ( ) { public Object evaluate ( Map fields , Map variables , Map parameters ) { return \"http://thisIsAURL?count=\" + variables . get ( \"REPORT_COUNT\" ) ; } } ) ; djlink . setTooltip ( new LiteralExpression ( \"I'm a literal tootltip\" ) ) ; djChart . setLink ( djlink ) ; HashMap vars = new HashMap ( ) ; vars . put ( columnaQuantity , new JRDesignVariable ( ) ) ; vars . put ( columnAmount , new JRDesignVariable ( ) ) ; JRDesignGroup group = new JRDesignGroup ( ) ; chart = djChart . transform ( new DynamicJasperDesign ( ) , \"\" , group , group , vars , 0 ) ; } public void testChart ( ) { assertEquals ( 20 , chart . getX ( ) ) ; assertEquals ( 10 , chart . getY ( ) ) ; assertEquals ( 500 , chart . getWidth ( ) ) ; assertEquals ( 250 , chart . getHeight ( ) ) ; assertEquals ( Color . LIGHT_GRAY", "gt": ", chart . getBackcolor ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11473, "input": "<s> package org . restlet . test . ext . atom ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . engine . io . BioUtils ; import org . restlet . ext . atom . Categories ; import org . restlet . ext . atom . Feed ; import org . restlet . ext . atom . Service ; import org . restlet . representation . FileRepresentation ; import org . restlet . test . RestletTestCase ; public class AtomTestCase extends RestletTestCase { public void testCategories ( ) throws Exception { Categories atomCategories = new Categories ( \"clap://class/org/restlet/test/ext/atom/categories.xml\" ) ; assertEquals ( new Reference ( \"http://example.com/cats/big3\" ) , atomCategories . getScheme ( ) ) ; assertEquals ( \"animal\" , atomCategories . getEntries ( ) . get ( 0 ) . getTerm ( ) ) ; } public void testAtom ( ) throws Exception { final File testDir = new File ( System . getProperty ( \"java.io.tmpdir\" ) , \"AtomTestCase\" ) ; BioUtils . delete ( testDir , true ) ; testDir . mkdir ( ) ; final Service atomService = new Service ( \"clap://class/org/restlet/test/ext/atom/service.xml\" ) ; assertEquals ( \"AtomPub Test Site\" , atomService . getWorkspaces ( ) . get ( 0 ) . getTitle ( ) ) ; assertEquals ( \"entry\" , atomService . getWorkspaces ( ) . get ( 0 ) . getCollections ( ) . get ( 0", "gt": ") . getTitle ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5180, "input": "<s> package de . javawi . jstun . header ; import java . util . Iterator ; import java . util . TreeMap ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; import de . javawi . jstun . attribute . MessageAttribute ; import de . javawi . jstun . attribute . MessageAttributeParsingException ; import de . javawi . jstun . util . Utility ; import de . javawi . jstun . util . UtilityException ; public class MessageHeader implements MessageHeaderInterface { private static final Logger LOGGER = LoggerFactory . getLogger ( MessageHeader . class ) ; MessageHeaderType type ; byte [ ] id = new byte [ 16 ] ; TreeMap < MessageAttribute . MessageAttributeType , MessageAttribute > ma = new TreeMap < MessageAttribute . MessageAttributeType , MessageAttribute > ( ) ; public MessageHeader ( ) { super ( ) ; } public MessageHeader ( MessageHeaderType type ) { super ( ) ; setType ( type ) ; } public void setType ( MessageHeaderType type ) { this . type = type ; } public MessageHeaderType getType ( ) { return type ; } public static int typeToInteger ( MessageHeaderType type ) { if ( type == MessageHeaderType . BindingRequest ) return BINDINGREQUEST ; if ( type == MessageHeaderType . BindingResponse ) return BINDINGRESPONSE ; if ( type == MessageHeaderType . BindingErrorResponse ) return BINDINGERRORRESPONSE ; if ( type == MessageHeaderType . SharedSecretRequest ) return SHAREDSECRETREQUEST ; if ( type == MessageHeaderType . SharedSecretResponse ) return SHAREDSECRETRESPONSE ; if ( type == MessageHeaderType . SharedSecretErrorResponse ) return SHAREDSECRETERRORRESPONSE ; return - 1 ; } public void setTransactionID ( byte [ ] id ) { System . arraycopy ( id , 0 , this . id , 0 , 16 ) ; } public void generateTransactionID ( ) throws UtilityException { System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 0 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 2 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 4 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 6 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 8 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 10 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 12 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( ( int ) ( Math . random ( ) * 65536 ) ) , 0 , id , 14 , 2 ) ; } public byte [ ] getTransactionID ( ) { byte [ ] idCopy = new byte [ id . length ] ; System . arraycopy ( id , 0 , idCopy , 0 , id . length ) ; return idCopy ; } public boolean equalTransactionID ( MessageHeader header ) { byte [ ] idHeader = header . getTransactionID ( ) ; if ( idHeader . length != 16 ) return false ; if ( ( idHeader [ 0 ] == id [ 0 ] ) && ( idHeader [ 1 ] == id [ 1 ] ) && ( idHeader [ 2 ] == id [ 2 ] ) && ( idHeader [ 3 ] == id [ 3 ] ) && ( idHeader [ 4 ] == id [ 4 ] ) && ( idHeader [ 5 ] == id [ 5 ] ) && ( idHeader [ 6 ] == id [ 6 ] ) && ( idHeader [ 7 ] == id [ 7 ] ) && ( idHeader [ 8 ] == id [ 8 ] ) && ( idHeader [ 9 ] == id [ 9 ] ) && ( idHeader [ 10 ] == id [ 10 ] ) && ( idHeader [ 11 ] == id [ 11 ] ) && ( idHeader [ 12 ] == id [ 12 ] ) && ( idHeader [ 13 ] == id [ 13 ] ) && ( idHeader [ 14 ] == id [ 14 ] ) && ( idHeader [ 15 ] == id [ 15 ] ) ) { return true ; } else { return false ; } } public void addMessageAttribute ( MessageAttribute attri ) { ma . put ( attri . getType ( ) , attri ) ; } public MessageAttribute getMessageAttribute ( MessageAttribute . MessageAttributeType type ) { return ma . get ( type ) ; } public byte [ ] getBytes ( ) throws UtilityException { int length = 20 ; Iterator < MessageAttribute . MessageAttributeType > it = ma . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { MessageAttribute attri = ma . get ( it . next ( ) ) ; length += attri . getLength ( ) ; } byte [ ] result = new byte [ length ] ; System . arraycopy ( Utility . integerToTwoBytes ( typeToInteger ( type ) ) , 0 , result , 0 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( length - 20 ) , 0 , result , 2 , 2 ) ; System . arraycopy ( id , 0 , result , 4 , 16 ) ; int offset = 20 ; it = ma . keySet", "gt": "( ) . iterator ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11486, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . RandomAccessFile ; public class GlyfTable implements Table { private byte [ ] buf = null ; private GlyfDescript [ ] descript ; protected GlyfTable ( DirectoryEntry de , RandomAccessFile raf ) throws IOException { raf . seek ( de . getOffset ( ) ) ; buf = new byte [ de . getLength ( ) ] ; raf . read ( buf ) ; } public void init ( int numGlyphs , LocaTable loca ) { if ( buf == null ) { return ; } descript = new GlyfDescript [ numGlyphs ] ; ByteArrayInputStream bais = new ByteArrayInputStream ( buf ) ; for ( int i = 0 ; i < numGlyphs ; i ++ ) { int len = loca . getOffset ( ( short ) ( i + 1 ) ) - loca . getOffset ( i ) ; if ( len > 0 ) { bais . reset ( ) ; bais . skip ( loca . getOffset ( i ) ) ; short numberOfContours = ( short ) ( bais . read ( ) << 8 | bais . read ( ) ) ; if ( numberOfContours >= 0 ) { descript [ i ] = new GlyfSimpleDescript ( this , numberOfContours , bais ) ; } } else { descript [ i ] = null ; } } for ( int i = 0 ; i < numGlyphs ; i ++ ) { int len = loca . getOffset ( ( short ) ( i + 1 ) ) - loca . getOffset ( i ) ; if ( len > 0 ) { bais . reset ( ) ; bais . skip ( loca . getOffset ( i ) ) ; short numberOfContours = ( short ) ( bais . read ( ) << 8", "gt": "| bais . read ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3573, "input": "<s> public class InstanceOf3 { boolean m ( ) { return this . getClass", "gt": "( ) instanceof Class < ? extends InstanceOf3 > ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11493, "input": "<s> package com . talis . hbase . rdf . layout ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . store . StoreFormatterBase ; public abstract class FmtLayout extends StoreFormatterBase { public FmtLayout ( String storeName , HBaseRdfConnection connection ) { super ( storeName , connection ) ; } public void format ( ) { formatTables ( ) ; }", "gt": "public void truncate ( )", "prediction": "}\n", "label": 1}
{"id": 3857, "input": "<s> import java . util . StringTokenizer ; import java . io . IOException ; class Main1 { static int maxLg = 200 ; public static void main ( String args [ ] ) throws Exception { } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; } lin [ lg ++ ] += car ; } if ( (", "gt": "car < 0 ) && ( lg == 0 ) )", "prediction": ")\n", "label": 0}
{"id": 11494, "input": "<s> package org . nuxeo . ecm . platform . picture . api . adapters ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Map ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . model . PropertyException ; public interface PictureResourceAdapter { void setDocumentModel ( DocumentModel doc ) ; boolean createPicture ( Blob fileContent , String filename , String title , ArrayList < Map < String , Object > > pictureTemplates )", "gt": "throws IOException , ClientException ;", "prediction": "\n", "label": 1}
{"id": 8387, "input": "<s> package org . ofbiz . minilang . method . callops ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . collections . FlexibleServletAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; import org . w3c . dom . Element ; public final class CallService extends MethodOperation { public static final String module = CallService . class . getName ( ) ; public static final String resource = \"MiniLangErrorUiLabels\" ; private final boolean breakOnError ; private final FlexibleMessage defaultMessage ; private final String errorCode ; private final FlexibleMessage errorPrefix ; private final FlexibleMessage errorSuffix ; private final boolean includeUserLogin ; private final FlexibleMapAccessor < Map < String , Object > > inMapFma ; private final FlexibleMessage messagePrefix ; private final FlexibleMessage messageSuffix ; private final boolean requireNewTransaction ; private final List < String > resultsToMapList ; private final List < ResultToField > resultToFieldList ; private final List < ResultToRequest > resultToRequestList ; private final List < ResultToResult > resultToResultList ; private final List < ResultToSession > resultToSessionList ; private final FlexibleStringExpander serviceNameFse ; private final String successCode ; private final FlexibleMessage successPrefix ; private final FlexibleMessage successSuffix ; private final int transactionTimeout ; public CallService ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"service-name\" , \"in-map-name\" , \"include-user-login\" , \"break-on-error\" , \"error-code\" , \"require-new-transaction\" , \"transaction-timeout\" , \"success-code\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"include-user-login\" , \"break-on-error\" , \"error-code\" , \"require-new-transaction\" , \"transaction-timeout\" , \"success-code\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"service-name\" , \"in-map-name\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"service-name\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"error-prefix\" , \"error-suffix\" , \"success-prefix\" , \"success-suffix\" , \"message-prefix\" , \"message-suffix\" , \"default-message\" , \"results-to-map\" , \"result-to-field\" , \"result-to-request\" , \"result-to-session\" , \"result-to-result\" ) ; } serviceNameFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"service-name\" ) ) ; inMapFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"in-map-name\" ) ) ; includeUserLogin = ! \"false\" . equals ( element . getAttribute ( \"include-user-login\" ) ) ; breakOnError = ! \"false\" . equals ( element . getAttribute ( \"break-on-error\" ) ) ; errorCode = element . getAttribute ( \"error-code\" ) ; requireNewTransaction = \"true\" . equals ( element . getAttribute ( \"require-new-transaction\" ) ) ; String timeoutStr = UtilXml . checkEmpty ( element . getAttribute ( \"transaction-timeout\" ) ) ; int timeout = - 1 ; if ( ! timeoutStr . isEmpty ( ) ) { try { timeout", "gt": "= Integer . parseInt ( timeoutStr ) ;", "prediction": ";\n", "label": 0}
{"id": 11514, "input": "<s> package org . restlet . example . ext . wadl ; import org . restlet . Component ; import org . restlet . data . Protocol ; public class FirstResourceServerMain { public static void main ( String [ ] args ) throws Exception { Component component =", "gt": "new Component ( ) ;", "prediction": ";\n", "label": 1}
{"id": 1029, "input": "<s> public class TestBreakIterator extends JavadocTester { private static final String BUG_ID = \"4165985\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"BreakIteratorTest.html\" , \"The class is empty (i.e. it has no members).\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"-breakiterator\" , \"pkg\" } ; public static void main ( String [ ] args ) { TestBreakIterator tester = new TestBreakIterator ( ) ;", "gt": "run ( tester , ARGS , TEST , NEGATED_TEST ) ;", "prediction": "}\n", "label": 0}
{"id": 11520, "input": "<s> package br . org . archimedes . io . dxf . parsers ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . kabeja . dxf . DXFConstants ; import org . kabeja . dxf . DXFLayer ; import org . kabeja . dxf . DXFPolyline ; import org . kabeja . dxf . DXFVertex ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; public class PolylineParser extends ElementParser { @ Override public Collection < Element > parse ( DXFLayer layer ) throws NullArgumentException , InvalidArgumentException { List < DXFPolyline > dxfAllPolylines = new ArrayList < DXFPolyline > ( ) ; List < DXFPolyline > dxfPolylines = layer . getDXFEntities ( DXFConstants . ENTITY_TYPE_POLYLINE ) ; List < DXFPolyline > dxfLWPolylines = layer . getDXFEntities ( DXFConstants . ENTITY_TYPE_LWPOLYLINE ) ; if ( dxfPolylines", "gt": "!= null ) dxfAllPolylines . addAll ( dxfPolylines ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2984, "input": "<s> package org . kares . jruby . rack ; import org . jruby . Ruby ; import org . jruby . rack . RackApplication ; import org . jruby . rack . RackEnvironment ; import org . jruby . rack . RackInitializationException ; import org . jruby . rack . RackResponse ; class MockRackApplication implements RackApplication { private Ruby runtime ; MockRackApplication ( final Ruby runtime ) { this . runtime = runtime ; } public Ruby getRuntime ( ) { if ( runtime == null ) { runtime = Ruby . newInstance ( ) ; } return runtime ; } public RackResponse call ( RackEnvironment re ) { throw new UnsupportedOperationException ( \"call(RackEnvironment)\" ) ; } public void destroy ( ) { throw", "gt": "new UnsupportedOperationException ( \"destroy()\" ) ;", "prediction": "\n", "label": 0}
{"id": 11521, "input": "<s> package org . restlet . ext . jaxrs . internal . exceptions ; public class IllegalMethodParamTypeException extends IllegalTypeException { private static final long serialVersionUID = 6423619202690501704L ; public IllegalMethodParamTypeException ( IllegalTypeException ite ) { super (", "gt": "ite . getMessage ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5194, "input": "<s> public class TestTypeParameters extends JavadocTester { private static final String BUG_ID = \"4927167-4974929-7010344\" ; private static final String [ ] ARGS1 = new String [ ] { \"-d\" , BUG_ID , \"-use\" , \"-source\" , \"1.5\" , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; private static final String [ ] ARGS2 = new String [ ] { \"-d\" , BUG_ID , \"-linksource\" , \"-source\" , \"1.5\" , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; private static final String [ ] [ ] TEST1 = { { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<td class=\\\"colFirst\\\"><code>&lt;W extends java.lang.String,V extends \" + \"java.util.List&gt;&nbsp;<br>java.lang.Object</code></td>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<code>&lt;T&gt;&nbsp;java.lang.Object</code>\" } , { BUG_ID + FS + \"pkg\" + FS + \"package-summary.html\" , \"C</a>&lt;E extends <a href=\\\"../pkg/Parent.html\\\" \" + \"title=\\\"class in pkg\\\">Parent</a>&gt;\" } , { BUG_ID + FS + \"pkg\" + FS + \"class-use\" + FS + \"Foo4.html\" , \"<a href=\\\"../../pkg/ClassUseTest3.html\\\" title=\\\"class in pkg\\\">\" + \"ClassUseTest3</a>&lt;T extends <a href=\\\"../../pkg/ParamTest2.html\\\" \" + \"title=\\\"class in pkg\\\">ParamTest2</a>&lt;java.util.List&lt;? extends \" + \"<a href=\\\"../../pkg/Foo4.html\\\" title=\\\"class in pkg\\\">Foo4</a>&gt;&gt;&gt;\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<a name=\\\"formatDetails(java.util.Collection, java.util.Collection)\\\">\" + NL + \"<!--   -->\" + NL + \"</a>\" } , } ; private static final String [ ] [ ] TEST2 = { { BUG_ID + FS + \"pkg\" + FS + \"ClassUseTest3.html\" , \"public class <a href=\\\"../src-html/pkg/ClassUseTest3.html#line.28\\\">\" + \"ClassUseTest3</a>&lt;T extends <a href=\\\"../pkg/ParamTest2.html\\\" \" + \"title=\\\"class in pkg\\\">ParamTest2</a>&lt;java.util.List&lt;? extends \" + \"<a href=\\\"../pkg/Foo4.html\\\" title=\\\"class in pkg\\\">Foo4</a>&gt;&gt;&gt;\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; public static void main ( String [ ] args ) { TestTypeParameters tester", "gt": "= new TestTypeParameters ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11529, "input": "<s> package org . elasticsearch . memcached . test ; import net . spy . memcached . MemcachedClient ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . node . Node ; import org . hamcrest . Matchers ; import org . testng . annotations . AfterMethod ; import org . testng . annotations . BeforeMethod ; import org . testng . annotations . Test ; import java . io . IOException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . ImmutableSettings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . node . NodeBuilder . nodeBuilder ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . equalTo ; public abstract class AbstractMemcachedActionsTests { private Node node ; private MemcachedClient memcachedClient ; @ BeforeMethod public void setup ( ) throws IOException { node = nodeBuilder ( ) . settings ( settingsBuilder ( ) . put ( \"path.data\" , \"target/data\" ) . put ( \"cluster.name\" , \"test-cluster-\" + NetworkUtils . getLocalAddress ( ) ) . put ( \"gateway.type\" , \"none\" ) ) . node ( ) ; memcachedClient = createMemcachedClient ( ) ; } protected abstract MemcachedClient createMemcachedClient ( ) throws IOException ; @ AfterMethod public void tearDown ( ) { memcachedClient . shutdown ( ) ; node . close ( ) ; } @ Test public void testSimpleOperations ( ) throws Exception { Future < Boolean > setResult = memcachedClient . set ( \"/test/person/1\" , 0 , jsonBuilder ( ) . startObject ( ) . field ( \"test\" , \"value\" ) . endObject ( ) . bytes ( ) . copyBytesArray ( ) . array ( ) ) ; assertThat ( setResult . get ( 10 , TimeUnit . SECONDS ) , equalTo ( true ) ) ; ClusterHealthResponse health = node . client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( health . timedOut ( ) , equalTo ( false ) ) ; String getResult = ( String ) memcachedClient . get ( \"/_refresh\" ) ; System . out . println ( \"REFRESH \" + getResult ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"total\\\":10\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"successful\\\":5\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"failed\\\":0\" ) ) ; getResult = ( String ) memcachedClient . get ( \"/test/person/1\" ) ; System . out . println ( \"GET \" + getResult ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"_index\\\":\\\"test\\\"\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"_type\\\":\\\"person\\\"\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"_id\\\":\\\"1\\\"\" ) ) ; Future < Boolean > deleteResult = memcachedClient . delete ( \"/test/person/1\" ) ; assertThat ( deleteResult . get ( 10 , TimeUnit . SECONDS ) , equalTo ( true ) ) ; getResult = ( String ) memcachedClient . get ( \"/_refresh\" ) ; System . out . println ( \"REFRESH \" + getResult ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"total\\\":10\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"successful\\\":5\" ) ) ; assertThat ( getResult , Matchers . containsString ( \"\\\"failed\\\":0\" ) ) ; getResult = ( String", "gt": ") memcachedClient . get ( \"/test/person/1\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6511, "input": "<s> package ar . com . fdvs . dj . test . groups . labels ; import java . awt . Color ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJGroupLabel ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . ImageBanner ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . LabelPosition ; import ar . com . fdvs . dj . domain . constants . Stretching ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class GroupLabelTest3 extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorderBottom ( Border . PEN_1_POINT ) ; headerStyle . setBackgroundColor ( Color . gray ) ; headerStyle . setTextColor ( Color . white ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; headerStyle . setTransparency ( Transparency . OPAQUE ) ; Style headerVariables = new Style ( ) ; headerVariables . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; headerVariables . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign (", "gt": "HorizontalAlign . RIGHT ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11534, "input": "<s> import java . util . * ; import java . lang . Math ; public class C { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int testCount = in . nextInt ( ) ; for ( int test = 0 ; test < testCount ; ++ test ) { int pieCount = in . nextInt ( ) ; int friendCount = in . nextInt ( ) + 1 ; ArrayList < Integer > pies = new ArrayList < Integer > ( pieCount ) ; for ( int i = 0 ; i < pieCount ; ++ i ) { pies . add ( in . nextInt ( ) ) ; } Collections . sort ( pies ) ; int pieTotal = 0 ; for ( int i = pies . size ( ) - 1 ; i >= 0 ; -- i ) { int pie = pies . get ( i ) ; float pieSize = ( float ) Math . pow", "gt": "( pie , 2 ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 633, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . impl . EFactoryImpl ; import org . eclipse . emf . ecore . plugin . EcorePlugin ; import org . msl . simple . gmfmap . simplemappings . * ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsFactory ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimplemappingsFactoryImpl extends EFactoryImpl implements SimplemappingsFactory { public static SimplemappingsFactory init ( ) { try { SimplemappingsFactory theSimplemappingsFactory = ( SimplemappingsFactory ) EPackage . Registry . INSTANCE . getEFactory ( \"http://org.msl.simple.gmfmap/simplemappings_1.1\" ) ; if ( theSimplemappingsFactory != null ) { return theSimplemappingsFactory ; } } catch ( Exception exception ) { EcorePlugin . INSTANCE . log ( exception ) ; } return new SimplemappingsFactoryImpl ( ) ; } public SimplemappingsFactoryImpl ( ) { super ( ) ; } @ Override public EObject create ( EClass eClass ) { switch ( eClass . getClassifierID ( ) ) { case SimplemappingsPackage . SIMPLE_MAPPING : return createSimpleMapping ( ) ; case SimplemappingsPackage . SIMPLE_TOP_NODE : return createSimpleTopNode ( ) ; case SimplemappingsPackage . SIMPLE_COMPARTMENT : return createSimpleCompartment ( ) ; case SimplemappingsPackage . SIMPLE_LABEL_NODE : return createSimpleLabelNode ( ) ; case SimplemappingsPackage . SIMPLE_LINK_MAPPING : return createSimpleLinkMapping ( ) ; case SimplemappingsPackage . SIMPLE_NODE : return createSimpleNode ( ) ; case SimplemappingsPackage . SIMPLE_SUB_NODE : return createSimpleSubNode ( ) ; case SimplemappingsPackage . SIMPLE_MAPPING_ELEMENT_WITH_FIGURE : return createSimpleMappingElementWithFigure ( ) ; case SimplemappingsPackage . SIMPLE_CHILD_REFERENCE : return createSimpleChildReference ( ) ; case SimplemappingsPackage . SIMPLE_NODE_REFERENCE : return createSimpleNodeReference ( ) ; default : throw new IllegalArgumentException ( \"The class '\" + eClass . getName ( ) + \"' is not a valid classifier\" ) ; } } public SimpleMapping createSimpleMapping ( ) { SimpleMappingImpl simpleMapping = new SimpleMappingImpl ( ) ; return simpleMapping ; } public SimpleTopNode createSimpleTopNode ( ) { SimpleTopNodeImpl simpleTopNode = new SimpleTopNodeImpl ( ) ; return simpleTopNode ; } public SimpleCompartment createSimpleCompartment ( ) { SimpleCompartmentImpl simpleCompartment = new SimpleCompartmentImpl ( ) ; return simpleCompartment ; } public SimpleLabelNode createSimpleLabelNode ( ) { SimpleLabelNodeImpl simpleLabelNode = new SimpleLabelNodeImpl ( ) ; return simpleLabelNode ; } public SimpleLinkMapping createSimpleLinkMapping ( ) { SimpleLinkMappingImpl simpleLinkMapping = new SimpleLinkMappingImpl ( ) ; return simpleLinkMapping ; } public SimpleNode createSimpleNode ( ) { SimpleNodeImpl simpleNode = new SimpleNodeImpl ( ) ; return simpleNode ; } public SimpleSubNode createSimpleSubNode ( ) { SimpleSubNodeImpl simpleSubNode = new SimpleSubNodeImpl ( ) ; return simpleSubNode ; } public SimpleMappingElementWithFigure createSimpleMappingElementWithFigure ( ) { SimpleMappingElementWithFigureImpl simpleMappingElementWithFigure = new SimpleMappingElementWithFigureImpl ( ) ; return simpleMappingElementWithFigure ; } public SimpleChildReference createSimpleChildReference ( ) { SimpleChildReferenceImpl simpleChildReference =", "gt": "new SimpleChildReferenceImpl ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11556, "input": "<s> package io . beancounter . commons . tests . randomisers ; import io . beancounter . commons . tests . Randomiser ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; public class StringRandomiser implements Randomiser < String > { private String name ; private int ngrams ; private int length ; private List < Character > chars = new ArrayList < Character > ( ) ; private Random random = new Random ( ) ; public StringRandomiser ( String name , int ngrams , int length , boolean alphaOnly ) { this . name = name ; this . ngrams = ngrams ; this . length = length ; if ( alphaOnly ) { char [ ] charsPrimitive = \"abcdefghijklmnopqrstuvwxyz\" . toCharArray ( ) ; for ( char c : charsPrimitive ) { chars . add ( c ) ; } } else { for ( int i = 0 ; i <= 16384 ; i ++ ) { if ( Character . isDefined ( i ) ) { char [ ] cs = Character . toChars ( i ) ; for ( char c : cs ) { chars . add ( c ) ; } } } } } public StringRandomiser ( String name , int ngrams , int length ) { this ( name , ngrams , length , true ) ; } public Class < String > type ( ) { return String . class ; } public String name ( ) { return name ; } public String getRandom ( ) { int wordsNumber = random . nextInt ( ngrams ) + 1 ; String [ ] words = new String [ wordsNumber ] ; for ( int i = 0 ; i < wordsNumber ; i ++ ) { int length = random . nextInt ( this . length ) + 1 ; words [ i ] = getRandomString ( length ) ; } String result = \"\" ; for ( String word : words ) { result += word + ' ' ; } return result . substring ( 0 , result . length ( ) - 1 ) ; } private String getRandomString ( int length ) { String result = \"\" ; for ( int i = 0 ; i < length ; i ++ ) { int index = random . nextInt ( chars . size ( ) ) ; result += chars . get ( index ) ; } return result ; } @ Override public boolean equals ( Object o ) { if ( this", "gt": "== o ) return true ;", "prediction": ")\n", "label": 1}
{"id": 2251, "input": "<s> package api . subscriptions ; import java . util . List ; public class Response { private List < Threads > threads ; public List < Threads > getThreads ( ) { return this . threads ; }", "gt": "@ Override public String toString ( )", "prediction": "}\n", "label": 0}
{"id": 11557, "input": "<s> package org . restlet . ext . gwt ; import java . io . IOException ; import java . io . Serializable ; import java . util . List ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . converter . ConverterHelper ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; import com . google . gwt . user . client . rpc . IsSerializable ; public class GwtConverter extends ConverterHelper { private static final VariantInfo VARIANT_GWT = new VariantInfo ( MediaType . APPLICATION_JAVA_OBJECT_GWT ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; if ( VARIANT_GWT . isCompatible ( source ) ) { result = addObjectClass ( result , Serializable . class ) ; result = addObjectClass ( result , ObjectRepresentation . class ) ; } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( Serializable . class . isAssignableFrom ( source ) || IsSerializable . class . isAssignableFrom ( source ) || ObjectRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_GWT ) ; } return result ; } @ Override public float score ( Object source , Variant target , Resource resource ) { float result = - 1.0F ; if ( source instanceof Serializable || source instanceof IsSerializable ) { if ( target == null ) { result = 0.5F ; } else if ( MediaType . APPLICATION_JAVA_OBJECT_GWT . equals ( target . getMediaType ( ) ) ) { result = 1.0F ; } else if ( MediaType . APPLICATION_JAVA_OBJECT_GWT . isCompatible ( target . getMediaType ( ) ) ) { result = 0.6F ; } else { result = 0.5F ; } } return result ; } @ Override public < T > float score ( Representation source , Class < T > target , Resource resource ) { float result = - 1.0F ; if ( source instanceof ObjectRepresentation < ? > ) { result = 1.0F ; } else if ( ( target != null ) && ObjectRepresentation . class . isAssignableFrom ( target ) ) { result = 1.0F ; } else if ( ( target != null ) && ( Serializable . class . isAssignableFrom ( target ) || IsSerializable . class .", "gt": "isAssignableFrom ( target ) ) )", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7217, "input": "<s> package javax . lang . model . util ; import javax . lang . model . element . * ; import static javax . lang . model . element . ElementKind . * ; import javax . annotation . processing . SupportedSourceVersion ; import static javax . lang . model . SourceVersion . * ; import javax . lang . model . SourceVersion ; @ SupportedSourceVersion ( RELEASE_7 ) public class ElementKindVisitor7 < R , P >", "gt": "extends ElementKindVisitor6 < R , P >", "prediction": ";\n", "label": 0}
{"id": 11584, "input": "<s> package org . restlet . engine . io ; import java . nio . channels . WritableByteChannel ; public", "gt": "interface WritableSelectionChannel extends SelectionChannel , WritableByteChannel", "prediction": ";\n", "label": 1}
{"id": 5685, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . DurationQuantity ; import org . jjflyboy . tjpeditor . project . Limit ; import org . jjflyboy . tjpeditor . project . LimitAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class LimitImpl extends DailyMaxImpl implements Limit { protected DurationQuantity duration ; protected EList < LimitAttribute > attributes ; protected LimitImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getLimit ( ) ; } public DurationQuantity getDuration ( ) { return duration ; } public NotificationChain basicSetDuration ( DurationQuantity newDuration , NotificationChain msgs ) { DurationQuantity oldDuration = duration ; duration = newDuration ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . LIMIT__DURATION , oldDuration , newDuration ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setDuration ( DurationQuantity newDuration ) { if ( newDuration != duration ) { NotificationChain msgs = null ; if ( duration != null ) msgs = ( ( InternalEObject ) duration ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . LIMIT__DURATION , null , msgs ) ; if ( newDuration != null ) msgs = ( ( InternalEObject ) newDuration ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . LIMIT__DURATION , null , msgs ) ; msgs = basicSetDuration ( newDuration , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . LIMIT__DURATION , newDuration , newDuration ) ) ; } public EList < LimitAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < LimitAttribute > ( LimitAttribute . class , this , ProjectPackage . LIMIT__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . LIMIT__DURATION : return basicSetDuration ( null , msgs ) ; case ProjectPackage . LIMIT__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . LIMIT__DURATION : return getDuration ( ) ; case ProjectPackage . LIMIT__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int", "gt": "featureID , Object newValue )", "prediction": ")\n", "label": 0}
{"id": 11591, "input": "<s> package org . nuxeo . ecm . automation . server . test ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . IOException ; import java . util . List ; import org . junit . Assert ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . server . jaxrs . batch . BatchManager ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; import org . nuxeo . ecm . core . test . CoreFeature ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; @ RunWith ( FeaturesRunner . class ) @ Features ( CoreFeature . class ) @ Deploy ( { \"org.nuxeo.ecm.automation.core\" , \"org.nuxeo.ecm.automation.server\" } ) public class BatchManagerTest { @ Test public void testServiceRegistred ( ) { BatchManager bm = Framework . getLocalService ( BatchManager . class ) ; assertNotNull ( bm ) ; } @ Test public void testBatchCleanup ( ) throws IOException { BatchManager bm = Framework . getLocalService ( BatchManager . class ) ; String batchId = bm . initBatch ( null , null ) ; assertNotNull ( batchId ) ; for ( int i = 0 ; i < 10 ; i ++ ) { bm . addStream ( batchId , \"\" + i , new ByteArrayInputStream ( ( \"SomeContent\" + i ) . getBytes ( )", "gt": ") , i + \".txt\" , \"text/plain\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6360, "input": "<s> import java . io . * ; import java . net . URI ; import java . util . Arrays ; import javax . tools . Diagnostic ; import javax . tools . DiagnosticListener ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . ToolProvider ; import com . sun . source . util . JavacTask ; import java . util . EnumSet ; public class TestCircularClassfile { enum ClassName { A ( \"A\" ) , B ( \"B\" ) , C ( \"C\" ) , OBJECT ( \"Object\" ) ; String name ; ClassName ( String name ) { this . name = name ; } } static class JavaSource extends SimpleJavaFileObject { final static String sourceStub = \"class #C extends #S {}\" ; String source ; public JavaSource ( ClassName clazz , ClassName sup ) { super ( URI . create ( \"myfo:/Test.java\" ) , JavaFileObject . Kind . SOURCE ) ; source = sourceStub . replace ( \"#C\" , clazz . name ) . replace ( \"#S\" , sup . name ) ; } @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) { return source ; } } public static void main ( String ... args ) throws Exception { int count = 0 ; for ( ClassName clazz : EnumSet . of ( ClassName . A , ClassName . B , ClassName . C ) ) { for ( ClassName sup : EnumSet . of ( ClassName . A , ClassName . B , ClassName . C ) ) { if ( sup . ordinal ( ) < clazz . ordinal ( ) ) continue ; check ( \"sub_\" + count ++ , clazz , sup ) ; } } } static JavaSource [ ] initialSources = new JavaSource [ ] { new JavaSource ( ClassName . A , ClassName . OBJECT ) , new JavaSource ( ClassName . B , ClassName . A ) , new JavaSource ( ClassName . C , ClassName . B ) } ; static String workDir = System . getProperty ( \"user.dir\" ) ; static void check ( String destPath , ClassName clazz , ClassName sup ) throws Exception { File destDir = new File ( workDir , destPath ) ; destDir . mkdir ( ) ; final JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; JavacTask ct = ( JavacTask ) tool . getTask ( null , null , null , Arrays . asList ( \"-d\" , destPath ) , null , Arrays . asList ( initialSources ) ) ; ct . generate ( ) ; File fileToRemove = new File ( destPath , clazz . name + \".class\" ) ; fileToRemove . delete ( ) ; JavaSource newSource = new JavaSource ( clazz , sup ) ; DiagnosticChecker checker = new DiagnosticChecker ( ) ; ct = ( JavacTask ) tool . getTask ( null , null , checker , Arrays . asList ( \"-cp\" , destPath ) , null , Arrays . asList ( newSource ) ) ;", "gt": "ct . analyze ( ) ;", "prediction": "}\n", "label": 0}
{"id": 11598, "input": "<s> package org . eclipse . ui . internal . cheatsheets . views ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . forms . widgets . FormToolkit ; import org . eclipse . ui . forms . widgets . ScrolledForm ; import org . eclipse . ui . forms . widgets . TableWrapLayout ; import org . eclipse . ui . internal . cheatsheets . CheatSheetStopWatch ; public abstract class Page { protected final static int HORZ_SCROLL_INCREMENT = 20 ; protected final static int VERT_SCROLL_INCREMENT = 20 ; protected Color backgroundColor ; protected FormToolkit toolkit ; protected ScrolledForm form ; public Page ( ) { } public Control getControl ( ) { return form ; } public void createPart ( Composite parent ) { init ( parent . getDisplay ( ) ) ; CheatSheetStopWatch . startStopWatch ( \"Page.createInfoArea()\" ) ; CheatSheetStopWatch . printLapTime ( \"Page.createInfoArea()\" , \"Time in Page.createInfoArea() after new FormToolkit(): \" ) ; form = toolkit . createScrolledForm ( parent ) ; form . setData ( \"novarrows\" , Boolean . TRUE ) ; form . setText ( ViewUtilities . escapeForLabel ( getTitle ( ) ) ) ; form . setDelayedReflow ( true ) ; CheatSheetStopWatch . printLapTime ( \"Page.createInfoArea()\" , \"Time in Page.createInfoArea() after createScrolledForm(): \" ) ; GridData gd = new GridData ( GridData . FILL_BOTH ) ; gd . widthHint = 10 ; form . setLayoutData ( gd ) ; CheatSheetStopWatch . printLapTime ( \"Page.createInfoArea()\" , \"Time in", "gt": "Page.createInfoArea() after setLayoutData(): \" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3512, "input": "<s> import java . util . * ; import java . io . * ; class Main { static int maxLg = 200 ; public static void main ( String args [ ] ) throws Exception { int v [ ] = new int [ 1000 ] ; int vc , lv ; while ( true ) { long l = Long . valueOf ( readLine ( ) . trim ( ) ) . longValue ( ) ; if ( l == 0 ) return ; vc = 0 ; lv = 0 ; for ( int i = 0 ; i != l ; i ++ ) { v [ vc ] = Integer . parseInt ( readLine ( ) . trim ( ) ) ; if ( v [ vc ] != 0 ) { vc ++ ; lv = vc ; } } if ( vc == 0 ) { System . out . println ( \"0\" ) ; continue ; } String s = \"\" ; for ( int i = 0 ; i < vc ; i ++ ) { s += v [ i ] + \" \" ; } System . out . println ( s ) ; } } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \" \" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st . nextToken ( ) ; } return tokens ; } static String readLine ( ) throws IOException { byte lin [ ] = new byte [ maxLg ] ; int lg = 0 , car = - 1 ; while ( lg < maxLg ) { car = System . in . read ( ) ; if ( ( car < 0 ) || ( car == '\\n' ) ) { break ; } lin [ lg ++ ] += car ; } if ( ( car < 0 ) && (", "gt": "lg == 0 ) )", "prediction": ")\n", "label": 0}
{"id": 11639, "input": "<s> package org . eclipse . ui . tests . propertysheet ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . tests . harness . util . UITestCase ; import org . eclipse . ui . views . properties . PropertySheet ; public abstract class AbstractPropertySheetTest extends UITestCase { private static final String PIN_PROPERTY_SHEET_ACTION_ID_PREFIX = \"org.eclipse.ui.views.properties.PinPropertySheetAction\" ; protected IWorkbenchPage activePage ; protected PropertySheet propertySheet ; public AbstractPropertySheetTest ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; IWorkbenchWindow workbenchWindow = openTestWindow ( ) ; activePage = workbenchWindow . getActivePage ( ) ; } protected void doTearDown ( ) throws Exception { super . doTearDown ( ) ; activePage = null ; propertySheet = null ; } protected int countPropertySheetViews ( ) { int count = 0 ; IViewReference [ ] views = activePage . getViewReferences ( ) ; for ( int i = 0 ; i < views . length ; i ++ ) { IViewReference ref = views [ i ] ; if ( ref . getId ( ) . equals ( IPageLayout . ID_PROP_SHEET ) ) { count ++ ; } } return count ; } protected IAction getPinPropertySheetAction ( PropertySheet propertySheet ) { IActionBars actionBars = propertySheet . getViewSite ( ) . getActionBars ( ) ; IToolBarManager toolBarManager = actionBars . getToolBarManager ( ) ; IContributionItem [", "gt": "] items = toolBarManager . getItems ( ) ;", "prediction": ";\n", "label": 1}
{"id": 460, "input": "<s> package com . mcbans . mcbans ; import java . io . File ; import org . bukkit . configuration . file . FileConfiguration ; public class Config { private MCBansPlugin plugin ; private File configFile ; private FileConfiguration config ; public Config ( MCBansPlugin plugin ) { this . plugin = plugin ; } public void load ( ) { plugin . reloadConfig ( ) ; config = plugin . getConfig ( ) ; config . addDefault ( \"general.api-key\" , \"API-KEY-HERE\" ) ; config . addDefault ( \"general.on-join-mcbans-message\" , true ) ; config . addDefault ( \"general.minimum-rep\" , 8 ) ; config . addDefault ( \"general.callback-interval\" , 900000 ) ; config . addDefault ( \"default-reasons.local-ban\" , \"You have been banned\" ) ; config . addDefault ( \"default-reasons.temp-ban\" , \"You have been temporarily banned\" ) ; config . addDefault ( \"default-reasons.kick\" , \"You have been kicked\" ) ; config . addDefault ( \"logging.debug-mode\" , false ) ; config . addDefault ( \"logging.log-actions\" , true ) ; config . addDefault ( \"logging.log-file\" , \"plugins/mcbans/actions.log\" ) ; config . addDefault ( \"alt-limit.enable-maximum-alts\" , false ) ; config . addDefault ( \"alt-limit.maximum-alts\" , 3 ) ; config . addDefault ( \"user-connection-throttle.enable-throttle\" , true ) ; config . addDefault ( \"user-connection-throttle.connection-time-limit\" , 20 ) ; config . addDefault ( \"user-connection-throttle.connection-count-limit\" , 2 ) ; config . addDefault ( \"user-connection-throttle.lockout-message\" , \"Connecting too quickly. Please wait a few minutes.\" ) ; config . addDefault ( \"user-connection-throttle.lockout-time\" , 60 ) ; config . addDefault ( \"server-connection-throttle.enable-throttle\" , true ) ; config . addDefault ( \"server-connection-throttle.connection-time-limit\" , 15 ) ; config . addDefault ( \"server-connection-throttle.connection-count-limit\" , 5 ) ; config . addDefault ( \"server-connection-throttle.lockout-message\" , \"Connecting too quickly. Please wait a few minutes.\" ) ; config . addDefault ( \"server-connection-throttle.lockout-time\" , 20 ) ; config . addDefault ( \"plugins.flag-handler-timeout\" , 3000 ) ; config . options ( ) . copyDefaults ( true ) ; plugin . saveConfig ( ) ; } public String getKey ( ) { return config . getString ( \"api-key\" ) ; } public String getDefaultLocalBanReason ( ) { return config . getString ( \"default-reasons.local-ban\" ) ; } public String getDefaultTempBanReason ( ) { return config . getString ( \"default-reasons.temp-ban\" ) ; } public String getDefaultKickReason ( ) { return config . getString ( \"default-reasons.kick\" ) ; } public boolean isDebug ( ) { return config . getBoolean ( \"logging.debug-mode\" ) ; } public boolean isLoggingActions ( ) { return config . getBoolean ( \"logging.log-actions\" ) ; } public String getLogFile ( ) { return config . getString ( \"logging.log-file\" ) ; } public boolean isShowingJoinMessage ( ) { return config . getBoolean ( \"on-join-mcbans-message\" ) ; } public int getMinimumRep ( ) { int minRep = config . getInt ( \"minimum-rep\" ) ; if ( minRep > 10 ) { minRep = 10 ; } return minRep ; } public int getCallbackInterval ( ) { int callbackInterval = config . getInt ( \"callback-interval\" ) ; if ( callbackInterval < 60000 ) { callbackInterval = 60000 ; } else if ( callbackInterval > 3600000 ) { callbackInterval = 3600000 ; } return callbackInterval ; } public boolean isMaximumAltLimit ( ) { return config . getBoolean ( \"alt-limit.enable-maximum-alts\" ) ; } public int getMaximumAltLimit ( ) { return config . getInt ( \"alt-limit.maximum-alts\" ) ; } public boolean isThrottlingUsers ( ) { return config . getBoolean ( \"user-connection-throttle.enable-throttle\" ) ; } public int getUserConnectionTime ( ) { int time = config . getInt ( \"user-connection-throttle.connection-time-limit\" ) ; if ( time < 1 ) { time = 10 ; } return time ; } public int getUserConnectionCount ( ) { int count = config . getInt ( \"user-connection-throttle.connection-count-limit\" ) ; if ( count < 1 ) { count = 1 ; } return count ; } public String getUserLockoutMessage ( ) { return config . getString ( \"user-connection-throttle.lockout-message\" ) ; } public int getUserLockoutTime ( ) { int time = config . getInt ( \"user-connection-throttle.lockout-time\" ) ; if ( time < 1 ) { time = 20 ; } return time ; } public boolean isThrottlingServer ( ) { return config . getBoolean ( \"server-connection-throttle.enable-throttle\" ) ; } public int getServerConnectionTime ( ) { int time = config . getInt ( \"server-connection-throttle.connection-time-limit\" ) ; if ( time < 1 ) { time = 10 ; } return time ; } public int getServerConnectionCount ( ) { int count = config . getInt ( \"server-connection-throttle.connection-count-limit\" ) ; if ( count < 1 ) { count = 1 ; } return count ; } public String getServerLockoutMessage ( ) { return config . getString ( \"server-connection-throttle.lockout-message\" ) ; } public int getServerLockoutTime ( ) { int time = config . getInt ( \"server-connection-throttle.lockout-time\" ) ; if ( time < 1 ) { time = 10 ; } return time ; } public int getFlagHandlerTimeout ( ) { int", "gt": "time = config . getInt ( \"plugins.flag-handler-timeout\" ) ;", "prediction": "\n", "label": 0}
{"id": 11641, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . io . IOException ; import java . util . ArrayList ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . IPhase ; import org . eclipse . rap . rwt . internal . lifecycle . IUIThreadHolder ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . lifecycle . UIThread ; import org . eclipse . rap . rwt . internal . lifecycle . IPhase . IInterruptible ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . RequestParams ; import org . eclipse . rap . rwt . internal . service . ServiceContext ; import org . eclipse . rap . rwt . internal . service . ServiceStore ; import org . eclipse . rap . rwt . lifecycle . AbstractWidgetLCA ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseEvent ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . rap . rwt . service . IServiceStore ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . rap . rwt . service . SessionStoreEvent ; import org . eclipse . rap . rwt . service . SessionStoreListener ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Widget ; public class RWTLifeCycle_Test extends TestCase { private static final String ERR_MSG = \"TEST_ERROR\" ; private static final String MY_ENTRY_POINT = \"myEntryPoint\" ; private static final String BEFORE = \"before \" ; private static final String AFTER = \"after \" ; private static final String DISPLAY_CREATED = \"display created\" ; private static final String EXCEPTION_IN_RENDER = \"Exception in render\" ; private static StringBuilder log = new StringBuilder ( ) ; @ Override protected void setUp ( ) throws Exception { log . setLength ( 0 ) ; Fixture . setUp ( ) ; Fixture . fakeNewRequest ( ) ; Fixture . fakeResponseWriter ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testNoEntryPoint ( ) throws IOException { RWTLifeCycle lifeCycle = ( RWTLifeCycle ) RWTFactory . getLifeCycleFactory ( ) . getLifeCycle ( ) ; try { lifeCycle . execute ( ) ; fail ( \"Executing lifecycle without entry point must throw exception\" ) ; } catch ( IllegalArgumentException e ) { } } public void testDefaultEntryPoint ( ) throws IOException { RWTLifeCycle lifeCycle = ( RWTLifeCycle ) RWTFactory . getLifeCycleFactory ( ) . getLifeCycle ( ) ; RWTFactory . getEntryPointManager ( ) .", "gt": "registerByName ( EntryPointUtil . DEFAULT , TestEntryPointWithLog . class ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 4072, "input": "<s> public class MethodNeg { < A extends D , D extends E , E extends B , B extends C , C extends C1 , C1 extends B", "gt": "> void m ( E e , D d )", "prediction": ") ;\n", "label": 0}
{"id": 11647, "input": "<s> package com . emf4sw . rdf . resource . impl ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Map ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . URI ; import com . emf4sw . rdf . jena . JenaRDFReader ; import com . emf4sw . rdf . jena . JenaRDFWriter ; import com . emf4sw . rdf . resource . NTriplesResource ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; public class NTriplesResourceImpl extends JenaResourceImpl implements NTriplesResource { public NTriplesResourceImpl ( ) { super ( ) ; reader = new JenaRDFReader ( ) ; writer = new JenaRDFWriter ( ) ; } public NTriplesResourceImpl ( URI uri ) { super ( uri ) ; reader = new JenaRDFReader ( ) ; writer = new JenaRDFWriter ( ) ; } @ Override public void doLoad ( InputStream inputStream , Map < ? , ? > options ) throws IOException { Notification notification = setLoaded ( true ) ; try { final Model aModel = ModelFactory . createDefaultModel ( ) ; final com . hp . hpl . jena . rdf . model . RDFReader reader = aModel . getReader ( \"N-TRIPLES\" ) ; reader . setProperty ( \"WARN_REDEFINITION_OF_ID\" , \"EM_IGNORE\" ) ; try { try { reader . read ( aModel , inputStream , \"\" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( ! aModel . isEmpty ( ) ) { ( ( JenaRDFReader ) this . reader ) . read ( aModel , this ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } finally { if ( notification != null ) { eNotify ( notification ) ; } setModified ( false ) ; } } @ Override public void doSave ( OutputStream outputStream , Map < ? , ? > options ) throws IOException { final Model aModel = ModelFactory . createDefaultModel ( ) ; ( ( JenaRDFWriter ) writer ) . write ( this , aModel ) ; if ( ! aModel . isEmpty ( ) ) { com . hp . hpl . jena . rdf . model . RDFWriter writer = aModel .", "gt": "getWriter ( \"N-TRIPLES\" ) ;", "prediction": ";\n", "label": 1}
{"id": 6944, "input": "<s> package shuttle . hci . com ; public class RankedStop { private String startStopName ; private String endStopName ; private int startTime ; private int endTime ; private int travelTime ; private int shuttle_id ; private double distance ; public String getEndStopName ( ) { return endStopName ; } public int getEndTime ( ) { return endTime ; } public int getTravelTime ( ) { return travelTime ; } public int getShuttle_id ( ) { return shuttle_id ; } public double getDistance ( ) { return distance ; } public RankedStop ( String startStopName , int startTime , String endStopName , int endTime , double", "gt": "distance , int shuttle_id )", "prediction": ")\n", "label": 0}
{"id": 11648, "input": "<s> package org . nuxeo . ecm . platform . publisher . rules ; import org . nuxeo . ecm . core . api . ClientException ; public class PublishingValidatorException extends ClientException { private static final long serialVersionUID = 1L ; public PublishingValidatorException ( ) { } public PublishingValidatorException ( String message ) { super ( message ) ; } public PublishingValidatorException", "gt": "( String message , Throwable cause )", "prediction": "\n", "label": 1}
{"id": 8976, "input": "<s> package org . dawb . workbench . plotting . tools . profile ; import java . util . Arrays ; import java . util . Collection ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . gda . extensions . loaders . H5Utils ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . Status ; import org . eclipse . swt . widgets . Display ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . IntegerDataset ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . RectangularROI ; public class ZoomTool extends ProfileTool { private static Logger logger = LoggerFactory . getLogger ( ZoomTool . class ) ; @ Override protected void configurePlottingSystem ( AbstractPlottingSystem plotter ) { } @ Override protected String getRegionName ( ) { return \"Zoom\" ; } @ Override protected boolean isRegionTypeSupported ( RegionType type ) { return type == RegionType . BOX ; } @ Override protected RegionType getCreateRegionType ( ) { return RegionType . BOX ; } @ Override protected void createProfile ( final IImageTrace image , IRegion region , ROIBase rbs , boolean tryUpdate , boolean isDrag , IProgressMonitor monitor ) { if ( monitor . isCanceled ( ) ) return ; if ( image == null ) return ; if ( region . getRegionType ( ) != RegionType . BOX ) return ; final RectangularROI bounds = ( RectangularROI ) ( rbs == null ? region . getROI ( ) : rbs ) ; if ( bounds == null ) return ; if ( ! region . isVisible ( ) ) return ; if ( monitor . isCanceled ( ) ) return ; final int yInc = bounds . getPoint ( ) [ 1 ] < bounds . getEndPoint ( ) [ 1 ] ? 1 : - 1 ; final int xInc = bounds . getPoint ( ) [ 0 ] < bounds . getEndPoint ( ) [ 0 ] ? 1 : - 1 ; try { final AbstractDataset slice = image . getData ( ) . getSlice ( new int [ ] { ( int ) bounds . getPoint ( ) [ 1 ] , ( int ) bounds . getPoint ( ) [ 0 ] } , new int [ ] { ( int ) bounds . getEndPoint ( ) [ 1 ] , ( int ) bounds . getEndPoint ( ) [ 0 ] } , new int [ ] { yInc , xInc } ) ; slice . setName ( region . getName ( ) ) ; AbstractDataset yLabels = null ; AbstractDataset xLabels = null ; if ( image . getAxes ( ) != null ) { AbstractDataset xl = image . getAxes ( ) . get ( 0 ) ; if ( xl != null ) xLabels = getLabelsFromLabels ( xl , bounds , 0 ) ; AbstractDataset yl = image . getAxes ( ) . get ( 1 ) ; if ( yl != null ) yLabels = getLabelsFromLabels ( yl , bounds , 1 ) ; } if ( yLabels == null ) yLabels = IntegerDataset . arange ( bounds . getPoint ( ) [ 1 ] , bounds . getEndPoint ( ) [ 1 ] , yInc ) ; if ( xLabels == null ) xLabels = IntegerDataset . arange ( bounds . getPoint ( ) [ 0 ] , bounds . getEndPoint ( ) [ 0 ] , xInc ) ; final IImageTrace zoom_trace = ( IImageTrace ) profilePlottingSystem . updatePlot2D ( slice , Arrays . asList ( new AbstractDataset [ ] { xLabels , yLabels } ) , monitor ) ; registerTraces ( region , Arrays . asList ( new ITrace [ ] { zoom_trace } ) ) ; Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { zoom_trace . setPaletteData ( image . getPaletteData ( ) ) ; } } ) ; } catch ( IllegalArgumentException ne ) { logger . trace ( \"Slice outside bounds of image!\" , ne ) ; } catch ( Throwable ne ) { logger . warn ( \"Problem slicing image in \" + getClass ( ) . getSimpleName ( ) , ne ) ; } } private AbstractDataset getLabelsFromLabels ( AbstractDataset xl , RectangularROI bounds , int axisIndex ) { try { int fromIndex = ( int ) bounds", "gt": ". getPoint ( ) [ axisIndex ] ;", "prediction": ";\n", "label": 0}
{"id": 11653, "input": "<s> package org . eclipse . ui . activities ; import java . util . Set ; import org . eclipse . ui . internal . util . Util ; public final class ActivityManagerEvent { private IActivityManager activityManager ; private boolean definedActivityIdsChanged ; private boolean definedCategoryIdsChanged ; private boolean enabledActivityIdsChanged ; private final Set previouslyDefinedActivityIds ; private final Set previouslyDefinedCategoryIds ; private final Set previouslyEnabledActivityIds ; public ActivityManagerEvent ( IActivityManager activityManager , boolean definedActivityIdsChanged , boolean definedCategoryIdsChanged , boolean enabledActivityIdsChanged , final Set previouslyDefinedActivityIds , final Set previouslyDefinedCategoryIds , final Set previouslyEnabledActivityIds ) { if ( activityManager == null ) { throw new NullPointerException ( ) ; } if ( ! definedActivityIdsChanged && previouslyDefinedActivityIds != null ) { throw new IllegalArgumentException ( ) ; } if ( ! definedCategoryIdsChanged && previouslyDefinedCategoryIds != null ) { throw new IllegalArgumentException ( ) ; } if ( ! enabledActivityIdsChanged && previouslyEnabledActivityIds != null ) { throw new IllegalArgumentException ( ) ; } if ( definedActivityIdsChanged ) { this . previouslyDefinedActivityIds = Util . safeCopy ( previouslyDefinedActivityIds , String . class ) ; } else { this . previouslyDefinedActivityIds = null ; } if ( definedCategoryIdsChanged ) { this . previouslyDefinedCategoryIds = Util . safeCopy", "gt": "( previouslyDefinedCategoryIds , String . class ) ;", "prediction": ";\n", "label": 1}
{"id": 7210, "input": "<s> public class BinaryLiterals { public static void main ( String ... args ) throws Exception { new BinaryLiterals ( ) . run ( ) ; } public void run ( ) throws Exception { test ( 0 , 0B0 ) ; test ( 1 , 0B1 ) ; test ( 2 , 0B10 ) ; test ( 3 , 0B11 ) ; test ( 0 , 0b0 ) ; test ( 1 , 0b1 ) ; test ( 2 , 0b10 ) ; test ( 3 , 0b11 ) ; test ( - 0 , - 0b0 ) ; test ( - 1 , - 0b1 ) ; test ( - 2 , - 0b10 ) ; test ( - 3 , - 0b11 ) ; test ( - 1 , 0b11111111111111111111111111111111 ) ; test ( - 2 , 0b11111111111111111111111111111110 ) ; test ( - 3 , 0b11111111111111111111111111111101 ) ; test ( 1 , - 0b11111111111111111111111111111111 ) ; test ( 2 , - 0b11111111111111111111111111111110 ) ; test ( 3 , - 0b11111111111111111111111111111101 ) ; test ( 0 , 0b00 ) ; test ( 1 , 0b001 ) ; test ( 2 , 0b00010 ) ; test ( 3 , 0b000011 ) ; test ( 0x10 , 0b10000 ) ; test ( 0x100 , 0b100000000 ) ; test ( 0x10000 , 0b10000000000000000 ) ; test ( 0x80000000 , 0b10000000000000000000000000000000 ) ; test ( 0xffffffff , 0b11111111111111111111111111111111 ) ; test ( 0L , 0b0L ) ; test ( 1L , 0b1L ) ; test ( 2L , 0b10L ) ; test ( 3L , 0b11L ) ; test ( 0 , 0b00L ) ; test ( 1 , 0b001L ) ; test ( 2 , 0b00010L ) ; test ( 3 , 0b000011L ) ; test ( 0x10L , 0b10000L ) ; test ( 0x100L , 0b100000000L ) ; test ( 0x10000L , 0b10000000000000000L ) ; test ( 0x80000000L , 0b10000000000000000000000000000000L ) ; test ( 0xffffffffL , 0b11111111111111111111111111111111L ) ; test ( 0x8000000000000000L , 0b1000000000000000000000000000000000000000000000000000000000000000L ) ; test ( 0xffffffffffffffffL , 0b1111111111111111111111111111111111111111111111111111111111111111L ) ; test ( 0l , 0b0l ) ; test ( 1l , 0b1l ) ; test ( 2l , 0b10l ) ; test ( 3l , 0b11l ) ; test ( 0 , 0b00l ) ; test ( 1 , 0b001l ) ; test ( 2 , 0b00010l ) ; test ( 3 , 0b000011l ) ; test ( 0x10l , 0b10000l ) ; test ( 0x100l , 0b100000000l ) ; test ( 0x10000l , 0b10000000000000000l ) ; test ( 0x80000000l , 0b10000000000000000000000000000000l ) ; test ( 0xffffffffl , 0b11111111111111111111111111111111l ) ; test ( 0x8000000000000000l , 0b1000000000000000000000000000000000000000000000000000000000000000l ) ; test ( 0xffffffffffffffffl , 0b1111111111111111111111111111111111111111111111111111111111111111l ) ; if ( errors > 0 ) throw new Exception ( errors + \" errors found\" ) ; } void test ( int expect , int found ) { count ++ ; if ( found != expect ) error ( \"test \" + count + \"\\nexpected: 0x\" + Integer . toHexString ( expect ) + \"\\n   found: 0x\" + Integer . toHexString ( found ) ) ; } void test ( long expect , long found ) { count ++ ; if ( found != expect ) error ( \"test \" + count + \"\\nexpected: 0x\" + Long . toHexString ( expect ) + \"\\n  ", "gt": "found: 0x\" + Long . toHexString ( found ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11662, "input": "<s> package com . mycompany . listeners ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import com . puppycrawl . tools . checkstyle . DefaultLogger ; import com . puppycrawl . tools . checkstyle . api . AuditEvent ; import com . puppycrawl . tools . checkstyle . api . AuditListener ; import com . puppycrawl . tools . checkstyle . api . CheckstyleException ; import com . puppycrawl . tools . checkstyle . api . SeverityLevel ; public class MailLogger implements AuditListener { private ByteArrayOutputStream mOutputStream ; private DefaultLogger mLogger ; private int mErrors ; public MailLogger ( ) { mOutputStream = new ByteArrayOutputStream ( ) ; mLogger = new DefaultLogger ( mOutputStream , false ) ; mErrors = 0 ; } public void auditStarted ( AuditEvent aEvt ) { mLogger . auditStarted ( aEvt ) ; } public void auditFinished ( AuditEvent aEvt ) { mLogger . auditFinished ( aEvt ) ; final Properties properties = System . getProperties ( ) ; final Properties fileProperties = new Properties ( ) ; final String filename = ( String ) properties . get ( \"MailLogger.properties.file\" ) ; if ( filename != null ) { InputStream is = null ; try { is = new FileInputStream ( filename ) ; fileProperties . load ( is ) ; } catch ( IOException ioe ) { ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { ; } } } } for ( Enumeration e = fileProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { final String key = ( String ) e . nextElement ( ) ; final String value = fileProperties . getProperty ( key ) ; properties . put ( key , value ) ; } final boolean success = ( mErrors == 0 ) ; final String prefix = success ? \"success\" : \"failure\" ; try { final String mailhost = getValue ( properties , \"mailhost\" , \"localhost\" ) ; final String from = getValue ( properties , \"from\" , null ) ; final String toList = getValue ( properties , prefix + \".to\" , null ) ; final String subject = getValue ( properties , prefix + \".subject\" , ( success ) ? \"Checkstyle Audit Success\" : \"Checkstyle Audit Failure\" ) ; sendMail ( mailhost , from , toList , subject , mOutputStream . toString ( ) ) ; } catch ( Exception e ) { System . out . println ( \"MailLogger failed to send e-mail!\" ) ; e . printStackTrace ( System . err ) ; } } public void fileStarted ( AuditEvent aEvt ) { mLogger . fileStarted ( aEvt ) ; } public void fileFinished ( AuditEvent aEvt ) { mLogger . fileFinished ( aEvt ) ; } public void addError ( AuditEvent aEvt ) { if ( SeverityLevel . ERROR . equals ( aEvt . getSeverityLevel ( ) ) ) { mLogger . addError ( aEvt ) ; mErrors ++ ; } } public void addException ( AuditEvent aEvt , Throwable aThrowable ) { mLogger . addException", "gt": "( aEvt , aThrowable ) ;", "prediction": ";\n", "label": 1}
{"id": 82, "input": "<s> public class T6531075 { static class A { void a ( ) { } } static interface I { void i ( ) ; } static class E extends A implements I { public void i ( ) { } } static class C < W extends A & I , T extends W > { T t ; W w ; C ( W w , T t ) { this . w = w ; this . t = t ; } } public static void main", "gt": "( String ... args )", "prediction": ";\n", "label": 0}
{"id": 11669, "input": "<s> package org . eclipse . ui . internal . expressions ; import org . eclipse . core . expressions . EvaluationResult ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; public final class AlwaysEnabledExpression extends Expression { public", "gt": "static final AlwaysEnabledExpression INSTANCE = new AlwaysEnabledExpression ( ) ;", "prediction": "\n", "label": 1}
{"id": 4890, "input": "<s> package ar . com . fdvs . dj . webwork ; import java . io . IOException ; import java . sql . ResultSet ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRExporter ; import net . sf . jasperreports . engine . JRExporterParameter ; import net . sf . jasperreports . engine . JRParameter ; import net . sf . jasperreports . engine . JRResultSetDataSource ; import net . sf . jasperreports . engine . JasperPrint ; import net . sf . jasperreports . engine . data . JRBeanArrayDataSource ; import net . sf . jasperreports . engine . data . JRBeanCollectionDataSource ; import net . sf . jasperreports . engine . export . JRHtmlExporterParameter ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . core . DJException ; import ar . com . fdvs . dj . core . DynamicJasperHelper ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . core . layout . ListLayoutManager ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . output . FormatInfoRegistry ; import ar . com . fdvs . dj . output . ReportWriter ; import ar . com . fdvs . dj . output . ReportWriterFactory ; import com . opensymphony . util . TextUtils ; import com . opensymphony . webwork . WebWorkException ; import com . opensymphony . webwork . WebWorkStatics ; import com . opensymphony . webwork . views . jasperreports . JasperReportsResult ; import com . opensymphony . webwork . views . jasperreports . OgnlValueStackShadowMap ; import com . opensymphony . xwork . ActionInvocation ; import com . opensymphony . xwork . util . TextParseUtil ; public class DJResult extends JasperReportsResult { private static final long serialVersionUID = - 5135527859073133975L ; private static final Log LOG = LogFactory . getLog ( DJResult . class ) ; public static final String LAYOUT_CLASSIC = \"classic\" ; public static final String LAYOUT_LIST = \"list\" ; protected String dynamicReport ; protected String documentFormat ; protected String layoutManager ; protected String exportParams ; protected String parameters ; public void setDynamicReport ( final String _dynamicReport ) { dynamicReport = _dynamicReport ; } protected void doExecute ( final String _finalLocation , final ActionInvocation _invocation ) throws Exception { checkParams ( ) ; documentFormat = getFormat ( _invocation ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( \"Creating JasperReport for dynamicReport, format = \" + documentFormat ) ; } Map actionParametersMap = getParametersMap ( _invocation ) ; final JRDataSource ds = buildJRDataSource ( _invocation . getStack ( ) . findValue ( dataSource ) ) ; final HttpServletRequest request = ( HttpServletRequest ) _invocation . getInvocationContext ( ) . get ( WebWorkStatics . HTTP_REQUEST ) ; final HttpServletResponse response = ( HttpServletResponse ) _invocation . getInvocationContext ( ) . get ( WebWorkStatics . HTTP_RESPONSE ) ; if ( \"contype\" . equals ( request . getHeader ( \"User-Agent\" ) ) ) { handleConTypeRequest ( response ) ; } else { OgnlValueStackShadowMap parameters = new OgnlValueStackShadowMap ( _invocation . getStack ( ) ) ; parameters . putAll ( actionParametersMap ) ; parameters . put ( JRParameter . REPORT_LOCALE , _invocation . getInvocationContext ( ) . getLocale ( ) ) ; LayoutManager layoutManagerObj = getLayOutManagerObj ( _invocation ) ; JasperPrint jasperPrint = null ; if ( ds != null ) jasperPrint = DynamicJasperHelper . generateJasperPrint ( getDynamicReport ( _invocation ) , layoutManagerObj , ds , parameters ) ; else jasperPrint = DynamicJasperHelper . generateJasperPrint ( getDynamicReport ( _invocation ) , layoutManagerObj , parameters ) ; writeReponse ( request , response , jasperPrint , _invocation ) ; } } protected Map getParametersMap ( ActionInvocation _invocation ) { Map map = ( Map ) _invocation . getStack ( ) . findValue ( this . parameters ) ; if ( map == null ) map = new HashMap ( ) ; return map ; } protected JRDataSource buildJRDataSource ( Object dsCandidate ) { if ( dsCandidate == null ) return null ; if ( dsCandidate instanceof JRDataSource ) return ( JRDataSource ) dsCandidate ; if ( dsCandidate instanceof Collection ) return new JRBeanCollectionDataSource ( ( Collection ) dsCandidate ) ; if ( dsCandidate instanceof ResultSet ) return new JRResultSetDataSource ( ( ResultSet ) dsCandidate ) ; if ( dsCandidate . getClass ( ) . isArray ( ) ) return new JRBeanArrayDataSource ( ( Object [ ] ) dsCandidate ) ; throw new DJException ( \"class \" + dsCandidate . getClass ( ) . getName ( ) + \" is not supported \" + \"from the DynamicJasper WebWorK result type. Provide a JRDataSource implementation instead\" ) ; } protected LayoutManager getLayOutManagerObj ( ActionInvocation _invocation ) { if ( layoutManager == null || \"\" . equals ( layoutManager ) ) { LOG . warn ( \"No valid LayoutManager, using ClassicLayoutManager\" ) ; return new ClassicLayoutManager ( ) ; } Object los = conditionalParse ( layoutManager , _invocation ) ; if ( los instanceof LayoutManager ) { return ( LayoutManager ) los ; } LayoutManager lo = null ; if ( los instanceof String ) { if ( LAYOUT_CLASSIC . equalsIgnoreCase ( ( String ) los ) ) lo = new ClassicLayoutManager ( ) ; else if ( LAYOUT_LIST . equalsIgnoreCase ( ( String ) los ) ) lo = new ListLayoutManager ( ) ; else { try { lo = ( LayoutManager ) Class . forName ( ( String ) los ) . newInstance ( ) ; } catch ( Exception e ) { LOG . warn ( \"No valid LayoutManager:", "gt": "\" + e . getMessage ( ) , e ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11682, "input": "<s> package org . apache . lucene . store . je ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . util . Random ; import com . sleepycat . je . Cursor ; import com . sleepycat . je . Database ; import com . sleepycat . je . DatabaseEntry ; import com . sleepycat . je . DatabaseException ; import com . sleepycat . je . OperationStatus ; import com . sleepycat . je . Transaction ; public class File extends Object { static protected Random random = new Random ( ) ; protected DatabaseEntry key , data ; protected long length , timeModified ; protected String name ; protected byte [ ] uuid ; protected File ( String name ) throws IOException { setName ( name ) ; data = new DatabaseEntry ( new byte [ 32 ] ) ; } protected File ( JEDirectory directory , String name , boolean create ) throws IOException { this ( name ) ; if ( ! exists ( directory ) ) { if ( ! create ) throw new IOException ( \"File does not exist: \" + name ) ; else { DatabaseEntry key = new DatabaseEntry ( new byte [ 24 ] ) ; DatabaseEntry data = new DatabaseEntry ( null ) ; Database blocks = directory . blocks ; Transaction txn = directory . txn ; data . setPartial ( true ) ; uuid = new byte [ 16 ] ; try { do { random . nextBytes ( uuid ) ; uuid [ 6 ] = ( byte ) ( ( byte ) 0x40 | ( uuid [ 6 ] & ( byte ) 0x0f ) ) ; uuid [ 8 ] = ( byte ) ( ( byte ) 0x80 | ( uuid [ 8 ] & ( byte ) 0x3f ) ) ; System . arraycopy ( uuid , 0 , key . getData ( ) , 0 , 16 ) ; } while ( blocks . get ( txn , key , data , null ) != OperationStatus . NOTFOUND ) ; } catch ( DatabaseException e ) { throw new IOException ( e . getMessage ( ) ) ; } } } else if ( create ) length = 0L ; } protected String getName ( ) { return name ; } private void setName ( String name ) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( 128 ) ; DataOutputStream out = new DataOutputStream ( buffer ) ; out . writeUTF ( name ) ; out . close ( ) ; key = new DatabaseEntry ( buffer . toByteArray ( ) ) ; this . name = name ; } protected byte [ ] getKey ( ) throws IOException { if ( uuid == null ) throw new IOException ( \"Uninitialized file\" ) ; return uuid ; } protected long getLength ( ) { return length ; } protected long getTimeModified ( ) { return timeModified ; } protected boolean exists ( JEDirectory directory ) throws IOException { Database files = directory . files ; Transaction txn = directory . txn ; try { if ( files . get ( txn , key , data , null ) == OperationStatus . NOTFOUND ) return false ; } catch ( DatabaseException e ) { throw new IOException ( e . getMessage ( ) ) ; } byte [ ] bytes = data . getData ( ) ; ByteArrayInputStream buffer = new ByteArrayInputStream ( bytes ) ; DataInputStream in = new DataInputStream ( buffer ) ; length = in . readLong ( ) ; timeModified = in . readLong ( ) ; in . close ( ) ; uuid = new byte [ 16 ] ; System . arraycopy ( bytes , 16 , uuid , 0 , 16 ) ; return true ; } protected void modify ( JEDirectory directory , long length , long timeModified ) throws IOException { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( 32 ) ; DataOutputStream out = new DataOutputStream ( buffer ) ; Database files = directory . files ; Transaction txn = directory . txn ; out . writeLong ( length ) ; out . writeLong ( timeModified ) ; out . write ( getKey ( ) ) ; out . close ( ) ; System . arraycopy ( buffer . toByteArray ( ) , 0 , data . getData ( ) , 0 , 32 ) ; try { files . put ( txn , key , data ) ; } catch ( DatabaseException e ) { throw new IOException ( e . getMessage ( ) ) ; } this . length = length ; this . timeModified = timeModified ; } protected void delete ( JEDirectory directory ) throws IOException { if ( ! exists ( directory ) ) throw new IOException ( \"File does not exist: \" + getName ( ) ) ; Cursor cursor = null ; try { try { byte [ ] bytes = getKey ( ) ; int ulen = bytes . length + 8 ; byte [ ] cursorBytes = new byte [ ulen ] ; DatabaseEntry cursorKey = new", "gt": "DatabaseEntry ( cursorBytes ) ;", "prediction": ";\n", "label": 1}
{"id": 6587, "input": "<s> package com . sun . tools . javap ; import com . sun . tools . classfile . Attribute ; import com . sun . tools . classfile . Code_attribute ; import com . sun . tools . classfile . ConstantPool ; import com . sun . tools . classfile . ConstantPoolException ; import com . sun . tools . classfile . Descriptor ; import com . sun . tools . classfile . Descriptor . InvalidDescriptor ; import com . sun . tools . classfile . Instruction ; import com . sun . tools . classfile . LocalVariableTable_attribute ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; public class LocalVariableTableWriter extends InstructionDetailWriter { public enum NoteKind { START ( \"start\" ) { public boolean match ( LocalVariableTable_attribute . Entry entry , int pc ) { return ( pc == entry . start_pc ) ; } } , END ( \"end\" ) { public boolean match ( LocalVariableTable_attribute . Entry entry , int pc ) { return ( pc == entry . start_pc + entry . length ) ; } } ; NoteKind ( String text ) { this . text = text ; } public abstract boolean match ( LocalVariableTable_attribute . Entry entry , int pc ) ; public final String text ; } ; static LocalVariableTableWriter instance ( Context context ) { LocalVariableTableWriter instance = context . get ( LocalVariableTableWriter . class ) ; if ( instance == null ) instance = new LocalVariableTableWriter ( context ) ; return instance ; } protected LocalVariableTableWriter ( Context context ) { super ( context ) ; context . put ( LocalVariableTableWriter . class , this ) ; classWriter = ClassWriter . instance ( context ) ; } public void reset ( Code_attribute attr ) { codeAttr = attr ; pcMap = new HashMap < Integer , List < LocalVariableTable_attribute . Entry > > ( ) ; LocalVariableTable_attribute lvt = ( LocalVariableTable_attribute ) ( attr . attributes . get ( Attribute . LocalVariableTable ) ) ; if ( lvt == null ) return ; for ( int i = 0 ; i < lvt . local_variable_table . length ; i ++ ) { LocalVariableTable_attribute . Entry entry = lvt . local_variable_table [ i ] ; put ( entry . start_pc , entry ) ; put ( entry . start_pc + entry . length , entry ) ; } } public void writeDetails ( Instruction instr ) { int pc = instr . getPC ( ) ; writeLocalVariables ( pc , NoteKind . END ) ; writeLocalVariables ( pc , NoteKind . START ) ; } @ Override public void flush ( ) { int pc = codeAttr . code_length ; writeLocalVariables ( pc , NoteKind . END ) ; } public void writeLocalVariables ( int pc , NoteKind kind ) { ConstantPool constant_pool = classWriter . getClassFile ( ) . constant_pool ; String indent = space ( 2 ) ; List < LocalVariableTable_attribute . Entry > entries = pcMap . get ( pc ) ; if ( entries != null ) { for ( ListIterator < LocalVariableTable_attribute . Entry > iter = entries . listIterator ( kind == NoteKind . END ? entries . size ( ) : 0 ) ; kind == NoteKind . END ? iter . hasPrevious ( ) : iter . hasNext ( ) ; ) { LocalVariableTable_attribute . Entry entry = kind == NoteKind . END ? iter . previous ( ) : iter . next ( ) ; if ( kind . match ( entry , pc ) ) { print ( indent ) ; print ( kind . text ) ; print ( \" local \" ) ; print ( entry . index ) ; print ( \" // \" ) ; Descriptor d = new Descriptor ( entry . descriptor_index ) ; try { print ( d . getFieldType ( constant_pool ) ) ; } catch ( InvalidDescriptor e ) { print ( report ( e ) ) ; } catch ( ConstantPoolException e ) { print ( report ( e ) ) ; } print ( \" \" ) ; try { print ( constant_pool . getUTF8Value ( entry . name_index ) ) ; } catch ( ConstantPoolException e ) { print ( report ( e ) ) ; } println ( ) ; } } } } private void put ( int pc , LocalVariableTable_attribute . Entry entry ) { List < LocalVariableTable_attribute . Entry > list = pcMap . get ( pc ) ; if ( list == null ) { list = new ArrayList < LocalVariableTable_attribute . Entry > ( ) ; pcMap . put", "gt": "( pc , list ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11686, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . secret ; import org . restlet . security . SecretVerifier ; public class SimpleSecretVerifier extends SecretVerifier { @ Override public int verify (", "gt": "String identifier , char [ ] secret )", "prediction": ")\n", "label": 1}
{"id": 7621, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . impl . EObjectImpl ; import org . eclipse . gmf . mappings . NodeReference ; import org . msl . simple . gmfmap . simplemappings . SimpleNodeReference ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleNodeReferenceImpl extends EObjectImpl implements SimpleNodeReference { protected SimpleNodeReferenceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE ; } @ Override protected int eStaticFeatureCount ( ) { return 0 ; } public NodeReference getNodeReference ( ) { return ( NodeReference ) eGet ( SimplemappingsPackage . Literals .", "gt": "SIMPLE_NODE_REFERENCE__NODE_REFERENCE , true ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 11701, "input": "<s> package de . uos . igf . db3d . junittests . dbms . geom ; import junit . framework . TestCase ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . geom . Segment3D ; import de . uos . igf . db3d . dbms . geom . SimpleGeoObj ; import de . uos . igf . db3d . dbms . geom . Tetrahedron3D ; import de . uos . igf . db3d . dbms . geom . Triangle3D ; import de . uos . igf . db3d . dbms . geom . Wireframe3D ; public class TetrahedronTriangle3DTestCase extends TestCase { public void setUp ( ) throws Exception { } public void testIntersectionResult ( ) { ScalarOperator sop = new ScalarOperator ( ) ; Tetrahedron3D tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 1.0 , 2.0 ) , sop ) ; Triangle3D tri = new Triangle3D ( new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 4.0 , 0.0 , 0.0 ) , new Point3D ( 4.0 , 2.0 , 0.0 ) , sop ) ; SimpleGeoObj result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Point3D ) ; if ( result instanceof Point3D ) { Point3D resultPoint = ( Point3D ) result ; assertTrue ( resultPoint . getX ( ) == 2.0 ) ; assertTrue ( resultPoint . getY ( ) == 0.0 ) ; assertTrue ( resultPoint . getZ ( ) == 0.0 ) ; } tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 2.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 2.0 , 1.0 , 1.0 ) , new Point3D ( 4.0 , 0.0 , 1.0 ) , new Point3D ( 4.0 , 2.0 , 1.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Point3D ) ; if ( result instanceof Point3D ) { Point3D resultPoint = ( Point3D ) result ; assertTrue ( resultPoint . getX ( ) == 2.0 ) ; assertTrue ( resultPoint . getY ( ) == 1.0 ) ; assertTrue ( resultPoint . getZ ( ) == 1.0 ) ; } tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 4.0 , 4.0 , 0.0 ) , new Point3D ( 4.0 , 0.0 , 0.0 ) , new Point3D ( 4.0 , 0.0 , 4.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 4.0 , 1.0 , 1.0 ) , new Point3D ( 4.0 , 1.0 , 2.0 ) , new Point3D ( 6.0 , 1.0 , 2.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Segment3D ) ; tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 1.0 , 2.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Triangle3D ) ; tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 4.0 , 0.0 ) , new Point3D ( 4.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 2.0 , 4.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 3.0 , 1.0 , 1.0 ) , new Point3D ( 2.0 , 3.0 , 1.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Triangle3D ) ; tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 2.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 1.0 , 1.0 , 1.0 ) , new Point3D ( 4.0 , 0.0 , 1.0 ) , new Point3D ( 4.0 , 2.0 , 1.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Triangle3D ) ; tetr = new Tetrahedron3D ( new Point3D ( 0.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 0.0 , 0.0 ) , new Point3D ( 1.0 , 1.0 , 2.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 0.0 , 0.0 , 1.0 ) , new Point3D ( 8.0 , 0.0 , 1.0 ) , new Point3D ( 8.0 , 8.0 , 1.0 ) , sop ) ; result = tetr . intersection ( tri , sop ) ; assertTrue ( result instanceof Triangle3D ) ; tetr = new Tetrahedron3D ( new Point3D ( 1.0 , 0.0 , 0.0 ) , new Point3D ( 0.0 , 2.0 , 0.0 ) , new Point3D ( 2.0 , 2.0 , 0.0 ) , new Point3D ( 1.0 , 1.5 , 2.0 ) , sop ) ; tri = new Triangle3D ( new Point3D ( 0.0 , 1.0 , 0.0 ) , new Point3D ( 1.0 , 3.0 , 0.0 ) , new Point3D ( 2.0 , 1.0", "gt": ", 0.0 ) , sop ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5093, "input": "<s> package com . sun . source . tree ; public interface ThrowTree extends StatementTree {", "gt": "ExpressionTree getExpression ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 11702, "input": "<s> package monbulk . shared . Model . pojo ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map . Entry ; import com . google . gwt . core . client . GWT ; import com . google . gwt . xml . client . NodeList ; import com . google . gwt . xml . client . XMLParser ; import monbulk . client . Monbulk ; import monbulk . shared . Form . FormBuilder ; import monbulk . shared . Model . IPojo ; import monbulk . shared . util . GWTLogger ; import monbulk . shared . util . HtmlFormatter ; import com . google . gwt . xml . client . Document ; import com . google . gwt . xml . client . Node ; import com . google . gwt . xml . client . Element ; public class pojoMethodComplete implements IPojo { private pojoMethod MethodDetails ; private pojoSubjectProperties SubjectProperties ; private HashMap < String , pojoStepDetails > allSteps ; private String MethodID ; private String _XML ; private int stepsAdded ; private int stepsDeleted ; public pojoMethodComplete ( ) { GWTLogger . Log ( \"pmcComplete\" , \"MCP\" , \"Construct\" , \"82\" ) ; this . MethodDetails = new pojoMethod ( ) ; this . SubjectProperties = new pojoSubjectProperties ( ) ; this . allSteps = new HashMap < String , pojoStepDetails > ( ) ; stepsAdded = 0 ; stepsDeleted = 0 ; } public pojoMethodComplete ( String ID ) { this . MethodID = ID ; this . MethodDetails = new pojoMethod ( ) ; this . MethodDetails . setMethodID ( ID ) ; this . SubjectProperties = new pojoSubjectProperties ( ) ; this . allSteps = new HashMap < String , pojoStepDetails > ( ) ; } public void addStep ( pojoStepDetails tmpStep , String StepFormName ) { this . allSteps . put ( StepFormName , tmpStep ) ; this . stepsAdded ++ ; } public void addStep ( ) { String formName = pojoStepDetails . FormName + this . getStepCount ( ) ; pojoStepDetails tmpStep = new pojoStepDetails ( this . getStepCount ( ) ) ; this . allSteps . put ( formName , tmpStep ) ; this . stepsAdded ++ ; } public void sortSteps ( ) { } public void removeStep ( String StepFormName ) { pojoStepDetails tmpStep = this . allSteps . get ( StepFormName ) ; int index = tmpStep . getFormIndex ( ) ; this . allSteps . remove ( StepFormName ) ; Iterator < Entry < String , pojoStepDetails > > i = this . allSteps . entrySet ( ) . iterator ( ) ; HashMap < String , pojoStepDetails > transferList = new HashMap < String , pojoStepDetails > ( ) ; while ( i . hasNext ( ) ) { Entry < String , pojoStepDetails > item = i . next ( ) ; pojoStepDetails tmpPojo = item . getValue ( ) ; String oldKey = item . getKey ( ) ; if ( tmpPojo . getFormIndex ( ) > index ) { int oldIndex = tmpPojo . getFormIndex ( ) ; oldIndex -- ; tmpPojo . setFormIndex ( oldIndex ) ; oldKey", "gt": "= pojoStepDetails . FormName + tmpPojo . getFormIndex ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7251, "input": "<s> package com . shopzilla . api . client . model ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . collections . CollectionUtils ; import com . shopzilla . services . catalog . AttributeType ; import com . shopzilla . services . catalog . AttributeType . AttributeValues ; import com . shopzilla . services . catalog . AttributeValueType ; import com . shopzilla . services . catalog . CertificationType ; import com . shopzilla . services . catalog . OfferType ; import com . shopzilla . services . catalog . PriceSetType ; import com . shopzilla . services . catalog . PriceType ; import com . shopzilla . services . catalog . ProductOffersType ; import com . shopzilla . services . catalog . ProductResponse ; import com . shopzilla . services . catalog . ProductResponse . Classification ; import com . shopzilla . services . catalog . ProductResponse . RelatedAttributes ; import com . shopzilla . services . catalog . ProductType ; import com . shopzilla . services . catalog . RatingType ; public class CatalogResponseModelAdapter { protected CatalogResponseModelAdapter ( ) { } public static CatalogResponse fromCatalogAPI ( ProductResponse result ) { if ( result == null ) { return null ; } CatalogResponse toReturn = new CatalogResponse ( ) ; Classification classification = result . getClassification ( ) ; if ( classification != null ) { toReturn . setRelevancyScore ( classification . getRelevancyScore ( ) ) ; } RelatedAttributes catalogAttributes = result . getRelatedAttributes ( ) ; if ( catalogAttributes != null && CollectionUtils . isNotEmpty ( catalogAttributes . getAttribute ( ) ) ) { ArrayList < Attribute > attributes = new ArrayList < Attribute > ( catalogAttributes . getAttribute ( ) . size ( ) ) ; for ( AttributeType a : catalogAttributes . getAttribute ( ) ) { Attribute attr = new Attribute ( ) ; attr . setId ( a . getId ( ) ) ; attr . setLabel ( a . getName ( ) ) ; AttributeValues catalogValues = a . getAttributeValues ( ) ; if ( catalogValues != null && CollectionUtils . isNotEmpty ( catalogValues . getAttributeValue ( ) ) ) { ArrayList < AttributeValue > values = new ArrayList < AttributeValue > ( catalogValues . getAttributeValue ( ) . size ( ) ) ; for ( AttributeValueType t : catalogValues . getAttributeValue ( ) ) { AttributeValue v = new AttributeValue ( ) ; v . setLabel ( t . getId ( ) ) ; v . setValue ( t . getName ( ) ) ; values . add ( v ) ; } attr . setValues ( values ) ; } attributes . add ( attr ) ; } toReturn . setRelatedAttributes ( attributes ) ; } final ArrayList < Offer > offers = new ArrayList < Offer > ( ) ; if ( result . getProducts ( ) != null && CollectionUtils . isNotEmpty ( result . getProducts ( ) . getProductOrOffer ( ) ) ) { toReturn . setTotalResults ( result . getProducts ( ) . getTotalResults ( ) ) ; toReturn . setIncludedResults ( result . getProducts ( ) . getIncludedResults ( ) ) ; final PriceSetType priceSet = result . getProducts ( ) . getPriceSet ( ) ; if ( priceSet != null ) { toReturn . setMaxPrice ( convertPrice ( priceSet . getMaxPrice ( ) ) ) ; toReturn . setMinPrice ( convertPrice ( priceSet . getMinPrice ( ) ) ) ; } offers . addAll ( convertOffers ( result . getProducts ( ) . getProductOrOffer ( ) ) ) ; } if ( result . getOffers ( ) != null && CollectionUtils . isNotEmpty ( result . getOffers ( ) . getOffer ( ) ) ) { toReturn . setTotalResults ( result . getOffers ( ) . getTotalResults ( ) ) ; toReturn . setIncludedResults ( result . getOffers ( ) . getIncludedResults ( ) ) ; final PriceSetType priceSet = result . getOffers ( ) . getPriceSet ( ) ; if ( priceSet != null ) { toReturn . setMaxPrice ( convertPrice ( priceSet . getMaxPrice ( ) ) ) ; toReturn . setMinPrice ( convertPrice ( priceSet . getMinPrice ( ) ) ) ; } offers . addAll ( convertOffers ( result . getOffers ( ) . getOffer ( ) ) ) ; } toReturn . setOffers ( offers ) ; final ArrayList < Product > products = new ArrayList < Product > ( ) ; if ( result . getProducts ( ) != null && CollectionUtils . isNotEmpty ( result . getProducts ( ) . getProductOrOffer ( ) ) ) { toReturn . setTotalResults ( result . getProducts ( ) . getTotalResults ( ) ) ; toReturn . setIncludedResults ( result . getProducts ( ) . getIncludedResults ( ) ) ; final PriceSetType priceSet = result . getProducts ( ) . getPriceSet ( ) ; if ( priceSet != null ) { toReturn . setMaxPrice ( convertPrice ( priceSet . getMaxPrice ( ) ) ) ; toReturn . setMinPrice ( convertPrice ( priceSet . getMinPrice ( ) ) ) ; } products . addAll ( convertProducts ( result .", "gt": "getProducts ( ) . getProductOrOffer ( ) ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11706, "input": "<s> package org . restlet . ext . servlet ; import java . util . HashSet ; import org . osgi . service . http . HttpService ; import org . osgi . service . log . LogService ; import org . restlet . ext . osgi . IApplicationProvider ; public class RestletServletService { private HashSet < IApplicationProvider > applicationProviders = new HashSet < IApplicationProvider > ( ) ; private HttpService httpService ; private LogService logService ; public void bindApplicationProvider ( IApplicationProvider applicationProvider ) { applicationProviders . add ( applicationProvider ) ; if ( httpService != null ) registerServlet ( applicationProvider ) ; } public void bindHttpService ( HttpService httpService ) { this . httpService = httpService ; for ( IApplicationProvider applicationProvider : applicationProviders ) registerServlet ( applicationProvider ) ; } public void bindLogService ( LogService logService ) { this . logService = logService ; } private void registerServlet ( IApplicationProvider applicationProvider ) { ApplicationServlet servlet = new ApplicationServlet ( applicationProvider ) ; try { httpService . registerServlet ( applicationProvider . getAlias ( ) , servlet , applicationProvider . getInitParms ( ) , applicationProvider . getContext ( ) ) ; } catch ( Exception e ) { if ( logService != null ) logService . log ( LogService . LOG_ERROR , \"Failed to register the application servlet at alias: '\" +", "gt": "applicationProvider . getAlias ( ) + \"'\" , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10085, "input": "<s> package com . l7 . mitra . client . ui . panels ; import java . awt . Dimension ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JTextField ; import javax . swing . SpringLayout ; import javax . swing . UIManager ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import com . l7 . mitra . client . ui . AccessTokenSwingClient ; import com . l7 . mitra . client . ui . OAuthPropertyBean ; public class AccessPanel extends OAuthTestPanel implements PropertyChangeListener , DocumentListener , ActionListener { JLabel l_azToken = new JLabel ( \"Authorization Code: \" ) ; JLabel l_accessToken = new JLabel ( \"Access Token: \" ) ; JLabel l_refreshToken = new JLabel ( \"Refresh Token: \" ) ; JLabel l_accessTokenURI = new JLabel ( \"Token Endpoint URI: \" ) ; JTextField tf_azCode ; JTextField tf_accessTokenUri ; JTextField tf_accessToken ; JTextField tf_refreshToken ; JButton b_refreshToken = new JButton ( \"Refresh Token\" ) ; JButton b_accessToken = new JButton ( \"Retrieve Access Token\" ) ; public AccessPanel ( ) { super ( ) ; this . panelDescription = \"Request Access Token\" ; this . ID = \"access\" ; OAuthPropertyBean . getInstance ( ) . addChangeListener ( this ) ; SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setPreferredSize ( new Dimension ( 400 , 400 ) ) ; tf_azCode = new JTextField ( 25 ) ; tf_azCode . getDocument ( ) . addDocumentListener ( this ) ; tf_accessToken = new JTextField ( 25 ) ; tf_accessToken . setEditable ( false ) ; tf_refreshToken = new JTextField ( 25 ) ; tf_refreshToken . setEditable ( false ) ; tf_accessTokenUri = new JTextField ( 25 ) ; tf_accessTokenUri . getDocument ( ) . addDocumentListener ( this ) ; tf_accessTokenUri . setText ( \"/auth/oauth/v2/token\" ) ; add ( l_azToken ) ; add ( tf_azCode ) ; add ( l_accessTokenURI ) ; add ( tf_accessTokenUri ) ; add ( b_accessToken ) ; add ( l_accessToken ) ; add ( tf_accessToken ) ; add ( l_refreshToken ) ; add ( tf_refreshToken ) ; b_accessToken . addActionListener ( this ) ; b_refreshToken . addActionListener ( this ) ; layout . putConstraint ( SpringLayout . WEST , l_azToken , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , l_azToken , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , tf_azCode , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , tf_azCode , 3 , SpringLayout . SOUTH , l_azToken ) ; layout . putConstraint ( SpringLayout . WEST , l_accessTokenURI , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , l_accessTokenURI , 20 , SpringLayout . SOUTH , tf_azCode ) ; layout . putConstraint ( SpringLayout . WEST , tf_accessTokenUri , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , tf_accessTokenUri , 3 , SpringLayout . SOUTH , l_accessTokenURI ) ; layout . putConstraint ( SpringLayout . EAST , b_accessToken , 0 , SpringLayout . EAST , tf_accessTokenUri ) ; layout . putConstraint ( SpringLayout . NORTH , b_accessToken , 20 , SpringLayout . SOUTH , tf_accessTokenUri ) ; layout . putConstraint ( SpringLayout . WEST , l_accessToken , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , l_accessToken , 20 , SpringLayout . SOUTH , b_accessToken ) ; layout . putConstraint ( SpringLayout . WEST , tf_accessToken , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , tf_accessToken , 3 , SpringLayout . SOUTH , l_accessToken ) ; layout . putConstraint ( SpringLayout . WEST , l_refreshToken , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , l_refreshToken , 20 , SpringLayout . SOUTH , tf_accessToken ) ; layout . putConstraint ( SpringLayout . WEST , tf_refreshToken , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , tf_refreshToken , 3 , SpringLayout . SOUTH , l_refreshToken ) ; } @ Override public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . compareTo ( OAuthPropertyBean . AUTHORIZATION_CODE ) == 0 ) { if ( ( ( String ) evt . getNewValue ( ) ) . compareTo ( tf_azCode . getText ( ) ) != 0 ) tf_azCode . setText ( OAuthPropertyBean . getInstance ( ) . getAuthorizationCode ( ) ) ; } else if ( evt . getPropertyName ( ) . compareTo (", "gt": "OAuthPropertyBean . ACCESS_TOKEN ) == 0 )", "prediction": ") ;\n", "label": 0}
{"id": 11723, "input": "<s> package org . fuzzydb . util . context ; import org . slf4j . Logger ; public abstract class SessionContextMgrBase { protected Logger log ; @ SuppressWarnings ( \"unused\" ) private SessionContextMgrBase ( ) { assert ( false ) ; } protected SessionContextMgrBase ( SessionContext session , Logger log ) { this . log = log ; if ( session == null ) { log . warn ( \"Created session context with null session. Proceeding to see what happens...\" ) ; } else { log . debug ( \"{}, Create Session:\" , session . getSessionId ( ) ) ; } } public String getSessionId ( ) { SessionContext session = ContextManager . getCurrentSessionContext ( ) ; if ( session != null ) { return session . getSessionId ( ) ; } else { return \"[NULL SESSION!]\" ; } } public void invalidateSession ( ) { SessionContext session = ContextManager . getCurrentSessionContext ( ) ; log . trace ( session . getSessionId ( ) + \", invalidateSession: Thread = \" + Thread . currentThread ( ) . getId ( ) ) ; session . invalidate ( ) ; } protected < T extends IShutdown > T getServiceInternal ( Class < T > serviceClass ) { SessionContext session = ContextManager . getSession ( ) ; T objInstance = null ; synchronized ( session ) { String name = serviceClass . getSimpleName ( ) ; objInstance = serviceClass", "gt": ". cast ( session . get ( name ) ) ;", "prediction": ";\n", "label": 1}
{"id": 8120, "input": "<s> package org . parboiled . transform ; import org . objectweb . asm . tree . MethodNode ; import org . parboiled . common . Predicate ; import org . testng . annotations . BeforeClass ; import org . testng . annotations . Test ; import java . io . IOException ; import java . util . Collection ; import static org . testng . Assert . assertEquals ; public class ClassNodeInializerTest extends TransformationTest { @ BeforeClass public void setup ( ) throws IOException { setup ( TestParser . class ) ; } @ Test ( enabled = false ) public void testClassNodeSetup ( ) throws Exception { assertEquals ( classNode . name , \"org/parboiled/transform/TestParser$$parboiled\" ) ; assertEquals ( classNode . superName , \"org/parboiled/transform/TestParser\" ) ; assertEquals ( join ( classNode . getConstructors ( ) , null ) , \"<init>\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . containsExplicitActions ( ) ; } } ) , \"RuleWithDirectExplicitAction,RuleWithIndirectExplicitAction,RuleWithIndirectExplicitDownAction,\" + \"RuleWithIndirectExplicit2ParamAction,RuleWith2Returns,RuleWithCaptureInAction\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . containsImplicitActions ( ) ; } } ) , \"RuleWithDirectImplicitAction,RuleWithIndirectImplicitAction,RuleWithDirectImplicitUpAction,\" + \"RuleWithIndirectExplicitDownAction,RuleWithIndirectImplicitParamAction,\" + \"RuleWithCachedAnd2Params,RuleWithCaptureParameter,RuleWithIllegalImplicitAction,\" + \"RuleWithActionAccessingPrivateField,RuleWithActionAccessingPrivateMethod\" ) ; assertEquals ( join ( classNode . getRuleMethods ( ) . values ( ) , new Predicate < RuleMethod > ( ) { public boolean apply ( RuleMethod method ) { return method . hasCachedAnnotation ( ) ; } } ) , \"RuleWithoutAction,RuleWithLabel,RuleWithNamedLabel,RuleWithLeaf,RuleWithDirectImplicitAction,\" + \"RuleWithIndirectImplicitAction,RuleWithDirectExplicitAction,RuleWithIndirectExplicitAction,\" + \"RuleWithDirectImplicitUpAction,RuleWithIndirectExplicitDownAction,RuleWithCapture1,RuleWithCapture2,\" + \"RuleWithCachedAnd2Params,RuleWithCaptureInAction,RuleWithActionAccessingPrivateField,\"", "gt": "+ \"RuleWithActionAccessingPrivateMethod,Ch,IgnoreCase,CharRange,AnyOf,String,IgnoreCase,\" + \"FirstOf,OneOrMore,Optional,Sequence,Test,TestNot,ZeroOrMore,Eoi,Any,Empty\" ) ;", "prediction": ";\n", "label": 0}
{"id": 11739, "input": "<s> package org . fuzzydb . random ; import java . util . UUID ; import org . fuzzydb . dto . attributes . RandomGenerator ; import org . fuzzydb . dto . attributes . UuidAttribute ; public class RandomUuid implements RandomGenerator < UuidAttribute > {", "gt": "@ Override public UuidAttribute next ( String attrName )", "prediction": "return ;\n", "label": 1}
{"id": 5563, "input": "<s> package org . parboiled . parserunners ; import org . parboiled . buffers . InputBuffer ; import org . parboiled . errors . ParseError ; import org . parboiled . support . ParsingResult ; import org . parboiled . support . ValueStack ; import java . util . List ; public interface ParseRunner < V > { ParseRunner < V > withParseErrors ( List < ParseError > parseErrors ) ; ParseRunner < V > withValueStack ( ValueStack < V > valueStack ) ;", "gt": "ParsingResult < V > run ( String input ) ;", "prediction": "}\n", "label": 0}
{"id": 11746, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . part . AbstractMultiEditor ; import org . eclipse . ui . part . MultiEditor ; public class MultiEditorInnerPane extends EditorPane { EditorPane parentPane ; boolean multiEditorCompatibilityMode ; public MultiEditorInnerPane ( EditorPane pane , IEditorReference ref , WorkbenchPage page , EditorStack workbook , boolean multiEditor ) { super ( ref , page , workbook ) ; parentPane = pane ; multiEditorCompatibilityMode = multiEditor ; } AbstractMultiEditor getMultiEditor ( ) { return ( AbstractMultiEditor ) parentPane . getPartReference ( ) . getPart ( true ) ; } public void createControl ( Composite parent ) { super . createControl ( parent ) ; if ( ! multiEditorCompatibilityMode ) { Control control = getControl ( ) ; control . addListener ( SWT . Activate , new Listener ( ) { public void handleEvent ( Event event ) { if ( event . type == SWT . Activate ) { IEditorPart part = ( IEditorPart ) MultiEditorInnerPane . this . getEditorReference ( ) . getPart ( true ) ; AbstractMultiEditor multiEditor = getMultiEditor ( ) ; multiEditor . activateEditor ( part ) ; multiEditor . setFocus ( ) ; } } } ) ; control . setVisible ( true ) ; } } public EditorPane getParentPane ( ) { return parentPane ; } private void updateGradient ( ) { AbstractMultiEditor abstractMultiEditor = getMultiEditor ( ) ; if ( abstractMultiEditor != null && multiEditorCompatibilityMode ) { IEditorPart part = ( IEditorPart ) this . getEditorReference ( ) . getPart ( true ) ;", "gt": "if ( part != null )", "prediction": "}\n", "label": 1}
{"id": 6059, "input": "<s> package ar . com . fdvs . dj . domain . entities ; import ar . com . fdvs . dj . core . registration . AbstractEntityRegistrationManager ; public interface Entity { public static", "gt": "final long SERIAL_VERSION_UID = 10000 ;", "prediction": ";\n", "label": 0}
{"id": 11766, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . * ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . MultipleTermPositions ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermPositions ; import org . apache . lucene . util . ToStringUtils ; public class MultiPhraseQuery extends Query { private String field ; private ArrayList termArrays = new ArrayList ( ) ; private ArrayList positions = new ArrayList ( ) ; private int slop = 0 ; public void setSlop ( int s ) { slop = s ; } public int getSlop ( ) { return slop ; } public void add ( Term term ) { add ( new Term [ ] { term } ) ; } public void add ( Term [ ] terms ) { int position = 0 ; if ( positions . size ( ) > 0 ) position = ( ( Integer ) positions . get ( positions . size ( ) - 1 ) ) . intValue ( ) + 1 ; add ( terms , position ) ; } public void add ( Term [ ] terms , int position ) { if ( termArrays . size ( ) == 0 ) field = terms [ 0 ] . field ( ) ; for ( int i = 0 ; i < terms . length ; i ++ ) { if ( terms [ i ] . field ( ) != field ) { throw new IllegalArgumentException ( \"All phrase terms must be in the same field (\" + field + \"): \" + terms [ i ] ) ; } } termArrays . add ( terms ) ; positions . add ( new Integer ( position ) ) ; } public List getTermArrays ( ) { return Collections . unmodifiableList ( termArrays ) ; } public int [ ] getPositions ( ) { int [ ] result = new int [ positions . size ( ) ] ; for ( int i = 0 ; i < positions . size ( ) ; i ++ ) result [ i ] = ( ( Integer ) positions . get ( i ) ) . intValue ( ) ; return result ; } public void extractTerms ( Set terms ) { for ( Iterator iter = termArrays . iterator ( ) ; iter . hasNext ( ) ; ) { Term [ ] arr = ( Term [ ] ) iter . next ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { terms . add ( arr [ i ] ) ; } } } private class MultiPhraseWeight extends Weight { private Similarity similarity ; private float value ; private float idf ; private float queryNorm ; private float queryWeight ; public MultiPhraseWeight ( Searcher searcher ) throws IOException { this . similarity = getSimilarity ( searcher ) ; Iterator i = termArrays . iterator ( ) ; while ( i . hasNext ( ) ) { Term [ ] terms = ( Term [ ] ) i . next ( ) ; for ( int j = 0 ; j < terms . length ; j ++ ) { idf += getSimilarity ( searcher ) . idf ( terms [ j ] , searcher ) ; } } } public Query getQuery ( ) { return MultiPhraseQuery . this ; } public float getValue ( ) { return value ; } public float sumOfSquaredWeights ( ) { queryWeight = idf * getBoost ( ) ; return queryWeight * queryWeight ; } public void normalize ( float queryNorm ) { this . queryNorm = queryNorm ; queryWeight *= queryNorm ; value = queryWeight * idf ; } public Scorer scorer ( IndexReader reader , boolean scoreDocsInOrder , boolean topScorer ) throws IOException { if ( termArrays . size ( ) == 0 ) return null ; TermPositions [ ] tps = new TermPositions [ termArrays . size ( ) ] ; for ( int i = 0 ; i < tps . length ; i ++ ) { Term [ ] terms = ( Term [ ] ) termArrays . get ( i ) ; TermPositions p ; if ( terms . length > 1 ) p = new MultipleTermPositions ( reader , terms ) ; else p = reader . termPositions ( terms [ 0 ] ) ; if ( p == null ) return null ; tps [ i ] = p ; } if ( slop == 0 ) return new ExactPhraseScorer ( this , tps , getPositions ( ) , similarity , reader . norms ( field ) ) ; else return new SloppyPhraseScorer ( this , tps , getPositions ( ) , similarity , slop , reader . norms ( field ) ) ; } public Explanation explain ( IndexReader reader , int doc ) throws IOException { ComplexExplanation result = new ComplexExplanation ( ) ; result . setDescription ( \"weight(\" + getQuery ( ) + \" in \" + doc + \"), product of:\" ) ; Explanation idfExpl = new Explanation ( idf , \"idf(\" + getQuery ( ) + \")\" ) ; Explanation queryExpl = new Explanation ( ) ; queryExpl . setDescription ( \"queryWeight(\" + getQuery ( ) + \"), product of:\" ) ; Explanation boostExpl = new Explanation ( getBoost ( ) , \"boost\" ) ; if ( getBoost ( ) != 1.0f ) queryExpl . addDetail ( boostExpl ) ; queryExpl . addDetail ( idfExpl ) ; Explanation queryNormExpl = new Explanation ( queryNorm , \"queryNorm\" ) ; queryExpl . addDetail ( queryNormExpl ) ; queryExpl . setValue ( boostExpl . getValue ( ) * idfExpl . getValue ( ) * queryNormExpl . getValue ( ) ) ; result . addDetail ( queryExpl ) ; ComplexExplanation fieldExpl = new ComplexExplanation ( ) ; fieldExpl . setDescription ( \"fieldWeight(\" + getQuery ( ) + \" in \" + doc + \"), product of:\" ) ; Scorer scorer = scorer ( reader , true , false ) ; if ( scorer == null ) { return new Explanation ( 0.0f , \"no matching docs\" ) ; } Explanation tfExpl = scorer . explain ( doc ) ; fieldExpl . addDetail ( tfExpl ) ; fieldExpl . addDetail ( idfExpl ) ; Explanation fieldNormExpl = new Explanation ( ) ; byte [ ] fieldNorms = reader . norms ( field ) ; float fieldNorm = fieldNorms != null ? Similarity . decodeNorm ( fieldNorms [ doc ] ) : 1.0f ; fieldNormExpl . setValue ( fieldNorm ) ; fieldNormExpl . setDescription ( \"fieldNorm(field=\" + field", "gt": "+ \", doc=\" + doc + \")\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4702, "input": "<s> public class T6548436b { enum E { } static void test ( Enum < ? > o ) {", "gt": "Object e = ( E ) o ;", "prediction": "\n", "label": 0}
{"id": 11769, "input": "<s> package org . agoncal . book . javaee7 . chapter22 . ex10 ; import org . codehaus . jettison . json . JSONArray ; import javax . ejb . EJB ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriInfo ; import java . net . URI ; @ Path ( \"/10/customers\" ) public class CustomerRestService10 { @ Context UriInfo uriInfo ; @ EJB CustomerEJB10 customerEJB ; @ GET @ Produces ( MediaType . APPLICATION_JSON ) public JSONArray getListOfCustomers ( ) { JSONArray uriArray = new JSONArray ( ) ; for (", "gt": "Customer10 customer : customerEJB . findAll ( ) )", "prediction": ") ;\n", "label": 1}
{"id": 3126, "input": "<s> import java . util . * ; public class BridgeRestype extends Vector { public static void main ( String [ ] args ) { BridgeRestype t = new BridgeRestype ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) t . add ( args [ i ] ) ; Iterator", "gt": "i = t . iterator ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11774, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . IOException ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . Statement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . NullWritable ; import org . apache . hadoop . io . Text ; import org . apache . sqoop . mapreduce . db . DBConfiguration ; public class PGBulkloadExportReducer extends AutoProgressReducer < LongWritable , Text , NullWritable , NullWritable > { public static final Log LOG = LogFactory . getLog ( PGBulkloadExportReducer . class . getName ( ) ) ; private Configuration conf ; private DBConfiguration dbConf ; private Connection conn ; private String tableName ; protected void setup ( Context context ) throws IOException , InterruptedException { conf = context . getConfiguration ( ) ; dbConf = new DBConfiguration ( conf ) ; tableName = dbConf . getOutputTableName ( ) ; try { conn = dbConf . getConnection ( ) ; conn . setAutoCommit ( false ) ; } catch ( ClassNotFoundException ex ) { LOG . error ( \"Unable to load JDBC driver class\" , ex ) ; throw new IOException ( ex ) ; } catch ( SQLException ex ) { LOG . error ( \"Unable to connect to database\" , ex ) ; throw new IOException ( ex ) ; } } @ Override public void reduce ( LongWritable key , Iterable < Text > values , Context context ) throws IOException , InterruptedException { Statement stmt = null ; try { stmt", "gt": "= conn . createStatement ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7561, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . fachwerte ; public final class Platz { private final int _reihe ; private final int _sitz ; public Platz ( int reihe , int sitz ) { assert reihe >= 0 : \"Vorbedingung verletzt: reihe <=0\" ; assert sitz >= 0 : \"Vorbedingung verletzt: sitz <=0\" ; _reihe = reihe ; _sitz = sitz ; } public int getReihe ( ) { return _reihe ; } public int getSitz ( ) { return _sitz ; } @ Override public boolean equals ( Object o ) { boolean ergebnis = false ; if ( o instanceof Platz ) { Platz platz = ( Platz ) o ; ergebnis = ( ( platz . getReihe ( ) == this . getReihe ( ) ) && ( platz . getSitz ( ) == this . getSitz ( ) ) ) ; } return ergebnis ; } @ Override public int hashCode ( ) { return 1000 *", "gt": "getReihe ( ) + getSitz ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11794, "input": "<s> package org . apache . lucene . queryParser . standard . processors ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . core . nodes . AndQueryNode ; import org . apache . lucene . queryParser . core . nodes . BooleanQueryNode ; import org . apache . lucene . queryParser . core . nodes . GroupQueryNode ; import org . apache . lucene . queryParser . core . nodes . ModifierQueryNode ; import org . apache . lucene . queryParser . core . nodes . OrQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . core . nodes . ModifierQueryNode . Modifier ; import org . apache . lucene . queryParser . core . parser . SyntaxParser ; import org . apache . lucene . queryParser . core . processors . QueryNodeProcessor ; import org . apache . lucene . queryParser . standard . config . DefaultOperatorAttribute ; import org . apache . lucene . queryParser . standard . config . DefaultOperatorAttribute . Operator ; import org . apache . lucene . queryParser . standard . nodes . BooleanModifierNode ; public class GroupQueryNodeProcessor implements QueryNodeProcessor { private ArrayList < QueryNode > queryNodeList ; private boolean latestNodeVerified ; private QueryConfigHandler queryConfig ; private Boolean usingAnd = false ; public GroupQueryNodeProcessor ( ) { } public QueryNode process ( QueryNode queryTree ) throws QueryNodeException { if ( ! getQueryConfigHandler ( ) . hasAttribute ( DefaultOperatorAttribute . class ) ) { throw new IllegalArgumentException ( \"DefaultOperatorAttribute should be set on the QueryConfigHandler\" ) ; } usingAnd = Operator . AND == ( ( DefaultOperatorAttribute ) getQueryConfigHandler ( ) . getAttribute ( DefaultOperatorAttribute . class ) ) . getOperator ( ) ; if ( queryTree instanceof GroupQueryNode ) { queryTree = ( ( GroupQueryNode ) queryTree ) . getChild ( ) ; } this . queryNodeList = new ArrayList < QueryNode > ( ) ; this . latestNodeVerified = false ; readTree ( queryTree ) ; List < QueryNode > actualQueryNodeList = this . queryNodeList ; for ( int i = 0 ; i < actualQueryNodeList . size ( ) ; i ++ ) { QueryNode node = actualQueryNodeList . get ( i ) ; if ( node instanceof GroupQueryNode ) { actualQueryNodeList . set ( i , process ( node ) ) ; } } this . usingAnd = false ; if ( queryTree instanceof BooleanQueryNode ) { queryTree . set ( actualQueryNodeList ) ; return queryTree ; } else { return new BooleanQueryNode ( actualQueryNodeList ) ; } } private", "gt": "QueryNode applyModifier ( QueryNode node , QueryNode parent )", "prediction": "}\n", "label": 1}
{"id": 6163, "input": "<s> public class Boxing4 { public static void main ( String [ ] args ) { Character ch = 95 ; ch ++ ; System .", "gt": "out . println ( ch + 0 ) ;", "prediction": "get ( ) ;\n", "label": 0}
{"id": 11797, "input": "<s> package org . modelgoon . classes . figures ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . MarginBorder ; import org . eclipse . draw2d . PositionConstants ; import org . eclipse . draw2d . ToolbarLayout ; import org . eclipse . draw2d . geometry . Insets ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . modelgoon . ModelGoonActivator ; public class ClassFigure extends Figure { public static Color classColor = new Color ( null , 255 , 255 , 206 ) ; public static Color borderColor = new Color ( null , 100 , 100 , 206 ) ; private final Figure labelAndStereotypeFigure = new Figure ( ) ; private final CompartmentFigure featuresFigure = new CompartmentFigure ( 4 ) ; Label label ; Figure stereotypeFigure ; Map < String , Label > stereotype = new HashMap < String , Label > ( ) ; public ClassFigure ( ) { this . label = new Label ( ) ; this . label . setTextAlignment ( PositionConstants . CENTER ) ; ToolbarLayout layout = new ToolbarLayout ( ) ; layout . setSpacing ( 4 ) ; setLayoutManager ( layout ) ; int hinsets = 5 ; int vinsets = 5 ; setBorder ( new MarginBorder ( vinsets , hinsets , vinsets , hinsets ) ) ; setLayoutManager ( layout ) ; setBackgroundColor ( ClassFigure . classColor ) ; setOpaque ( false ) ; ToolbarLayout labelAndStereotypelayout = new ToolbarLayout ( ) ; labelAndStereotypelayout . setMinorAlignment ( ToolbarLayout . ALIGN_CENTER ) ; labelAndStereotypelayout . setStretchMinorAxis ( false ) ; labelAndStereotypelayout . setSpacing ( 2 ) ; this . labelAndStereotypeFigure . setLayoutManager ( labelAndStereotypelayout ) ; this . stereotypeFigure = new Figure ( ) ; ToolbarLayout stereotypelayout = new ToolbarLayout ( true ) ; stereotypelayout . setMinorAlignment ( ToolbarLayout . ALIGN_TOPLEFT ) ; stereotypelayout . setStretchMinorAxis ( false ) ; stereotypelayout . setSpacing ( 2 ) ; this . stereotypeFigure . setLayoutManager ( stereotypelayout ) ; this . labelAndStereotypeFigure . add ( this . label ) ; this . labelAndStereotypeFigure . add ( this . stereotypeFigure ) ; add ( this . labelAndStereotypeFigure ) ; add ( this . featuresFigure ) ; } public CompartmentFigure getFeaturesCompartment ( ) { return this . featuresFigure ; } @ Override public void paintFigure ( final Graphics graphics ) { Insets insets = getInsets ( ) ; Rectangle rect = new Rectangle ( getBounds ( ) ) ; rect . shrink ( 1 , 1 ) ; Color initialColor = getForegroundColor ( ) ; graphics . setForegroundColor ( ClassFigure . borderColor ) ; graphics . drawRectangle ( rect ) ; Rectangle headerBounds = this . labelAndStereotypeFigure . getBounds ( ) ; int attributeSeparation = rect . y + headerBounds . height + insets . top + 2 ; graphics . drawLine ( rect . x , attributeSeparation , rect . x + rect . width , attributeSeparation ) ; List < Figure > children = this . featuresFigure . getChildren ( ) ; if ( ! children . isEmpty ( ) ) { headerBounds = children . get ( 0 ) . getBounds ( ) ; int methodsSeparation = attributeSeparation + headerBounds . height + 4 ; graphics . drawLine ( rect . x , methodsSeparation , rect . x + rect . width , methodsSeparation ) ; graphics . setForegroundColor ( initialColor ) ; } } public void addStereotype ( final String string ) { Label stereotypeLabel = this . stereotype . get ( string ) ; if ( stereotypeLabel == null ) { stereotypeLabel = new Label ( \"\u00ab\" + string + \"\u00bb\" ) ; stereotypeLabel . setFont ( ModelGoonActivator . getDefaultFont ( 8 , SWT", "gt": ". ITALIC ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7539, "input": "<s> class T6863465a { static class a { static interface b { } } static class c extends a implements z . y { } static class x { static interface y { } } static class z extends", "gt": "x implements c . b", "prediction": "\n", "label": 0}
{"id": 11815, "input": "<s> package org . restlet . example . book . restlet .", "gt": "ch08 . gae . common ;", "prediction": ";\n", "label": 1}
{"id": 5137, "input": "<s> package exceptions ; public class PaymentInfoNotInitializedException extends Exception { private static final long serialVersionUID = - 8340464588289694122L ; public PaymentInfoNotInitializedException ( ) { super ( \"Payment infomation was not intitialized", "gt": "before pushing to database.\\n\" + \"Invoke setSessionPaymentInfo first.\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11819, "input": "<s> package org . nuxeo . ecm . virtualnavigation . tests ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . virtualnavigation . action . NavTreeDescriptor ; import org . nuxeo . ecm . virtualnavigation . service . NavTreeService ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . test . NXRuntimeTestCase ; public class TestNavTreeService extends NXRuntimeTestCase { @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployContrib ( \"org.nuxeo.platform.virtualnavigation.web\" , \"OSGI-INF/navtree-framework.xml\" ) ; deployContrib ( \"org.nuxeo.platform.virtualnavigation.web.test\" , \"OSGI-INF/navtree-contrib.xml\" ) ; } @ Test public void testServiceLookup ( ) { NavTreeService service = Framework . getLocalService ( NavTreeService . class ) ; assertNotNull ( service ) ; } @ Test public void testNavTrees ( ) throws Exception { NavTreeService service = Framework . getLocalService ( NavTreeService . class ) ; assertNotNull ( service ) ; List < NavTreeDescriptor > descs = service . getTreeDescriptors ( ) ; assertEquals ( 1 , descs . size ( ) ) ; assertNotNull ( descs . get ( 0 ) . getXhtmlview ( ) ) ; assertFalse ( descs . get ( 0", "gt": ") . isDirectoryTreeBased ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5491, "input": "<s> package org . ofbiz . base . util ; import java . io . PrintStream ; import java . io . PrintWriter ; @ SuppressWarnings ( \"serial\" ) public class GeneralRuntimeException extends RuntimeException { Throwable nested = null ; public GeneralRuntimeException ( ) { super ( ) ; } public GeneralRuntimeException ( String msg ) { super ( msg ) ; } public GeneralRuntimeException ( Throwable nested ) { super ( ) ; this . nested = nested ; } public GeneralRuntimeException ( String msg , Throwable nested ) { super ( msg ) ; this . nested = nested ; } @ Override public String getMessage ( ) { if ( nested != null ) return super . getMessage ( ) + \" (\" + nested . getMessage ( ) + \")\" ; else return super . getMessage ( ) ; } public String getNonNestedMessage ( ) { return super . getMessage ( ) ; }", "gt": "public Throwable getNested ( )", "prediction": "}\n", "label": 0}
{"id": 11821, "input": "<s> package org . jscsi . target . scsi . readCapacity ; import java . nio . ByteBuffer ; import org . jscsi . target . util . ReadWrite ; public final class ReadCapacity10ParameterData extends ReadCapacityParameterData { private static final long MAX_RETURNED_LOGICAL_BLOCK_ADDRESS = 0xffffffffL ; private static final int SIZE = 8 ; public ReadCapacity10ParameterData ( final long returnedLogicalBlockAddress , final int logicalBlockLengthInBytes ) { super ( returnedLogicalBlockAddress , logicalBlockLengthInBytes ) ; } public void serialize ( ByteBuffer byteBuffer , int index ) { final int rlba = ( int )", "gt": "Math . min ( returnedLogicalBlockAddress , MAX_RETURNED_LOGICAL_BLOCK_ADDRESS ) ;", "prediction": ";\n", "label": 1}
{"id": 1445, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . naming . IQualifiedNameConverter ; import org . eclipse . xtext . naming . IQualifiedNameProvider ; import org . jjflyboy . tjpeditor . scoping . ProjectImportUriGlobalScopeProvider ; import org . jjflyboy . tjpeditor . scoping . ProjectImportedNamespaceAwareLocalScopeProvider ; import org . jjflyboy . tjpeditor . scoping . ProjectQualifiedNameProvider ; public class ProjectRuntimeModule extends org . jjflyboy . tjpeditor . AbstractProjectRuntimeModule { @ Override public Class < ? extends IQualifiedNameProvider > bindIQualifiedNameProvider ( ) { return ProjectQualifiedNameProvider . class ; } public Class < ? extends IQualifiedNameConverter > bindIQualifiedNameConverter ( ) { return ProjectQualifiedNameConverter . class ; } public void configureIScopeProviderDelegate ( com . google . inject . Binder binder ) { binder . bind ( org . eclipse . xtext . scoping . IScopeProvider . class ) . annotatedWith ( com . google . inject . name . Names . named ( org . eclipse . xtext . scoping . impl . AbstractDeclarativeScopeProvider . NAMED_DELEGATE )", "gt": ") . to ( ProjectImportedNamespaceAwareLocalScopeProvider . class ) ;", "prediction": ";\n", "label": 0}
{"id": 11828, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . io . IOException ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . IPhase ; import org . eclipse . rap . rwt . internal . lifecycle . PrepareUIRoot ; import org . eclipse . rap . rwt . internal . service . RequestParams ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . widgets . Display ; public class PrepareUIRoot_Test extends TestCase { private IPhase phase ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; phase = new PrepareUIRoot ( ) ; TestEntryPoint . wasInvoked = false ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testGetPhaseId ( ) { assertEquals ( PhaseId . PREPARE_UI_ROOT , phase . getPhaseId ( ) ) ; } public void testExecuteInSubsequentRequests ( ) throws IOException { Display display = new Display ( ) ; PhaseId phaseId = phase . execute ( display ) ; assertEquals ( PhaseId . READ_DATA , phaseId ) ; } public void testExecuteInFirstRequestsWithNoStartupParameter ( ) throws IOException { RWTFactory . getEntryPointManager ( ) . registerByName ( EntryPointUtil . DEFAULT , TestEntryPoint . class ) ; PhaseId phaseId = phase . execute ( null ) ; assertEquals ( PhaseId . RENDER , phaseId ) ; assertTrue ( TestEntryPoint . wasInvoked ) ; } public void testExecuteInFirstRequestsWithStartupParameter ( ) throws IOException { RWTFactory . getEntryPointManager ( ) . registerByName ( \"myEntryPoint\" , TestEntryPoint . class ) ; Fixture . fakeRequestParam ( RequestParams . STARTUP , \"myEntryPoint\" ) ; PhaseId phaseId = phase . execute ( null ) ; assertEquals ( PhaseId . RENDER , phaseId ) ; assertTrue ( TestEntryPoint . wasInvoked ) ; } private", "gt": "static class TestEntryPoint implements IEntryPoint", "prediction": "( ) ;\n", "label": 1}
{"id": 6626, "input": "<s> package org . gk . engine . client . event ; public interface IEventConstants { public final static String HANDLER_BEAN = \"bean\" ; public final static String HANDLER_COM = \"com\" ; public final static String HANDLER_FILE = \"file\" ; public final static String HANDLER_HTTP = \"http\" ; public final static String HANDLER_JS = \"js\" ; public final static String HANDLER_PUB = \"pub\" ; public final static String HANDLER_SHOW = \"show\" ; public final static String HANDLER_SUB = \"sub\" ; public final static String EVENT_ONBLUR = \"onblur\" ; public final static String EVENT_ONCHANGE = \"onchange\" ; public final static String EVENT_ONCLICK = \"onclick\" ; public final static String EVENT_ONFOCUS = \"onfocus\" ; public final static String EVENT_ONSELECT = \"onselect\" ; public final static String EVENT_ONTRIGGERCLICK = \"ontriggerclick\" ; public final static String EVENT_ONTWINCLICK = \"ontwinclick\" ; public final static String ATTRIB_ADD = \"add\" ; public final static String ATTRIB_CELL = \"cell\" ; public final static String ATTRIB_CHECKED = \"checked\" ; public final static String ATTRIB_CLEAR = \"clear\" ; public final static String ATTRIB_COLLAPSE = \"collapse\" ; public final static String ATTRIB_DATA = \"data\" ; public final static String ATTRIB_DEL = \"del\" ; public final static String ATTRIB_EDITABLE = \"editable\" ; public final static String ATTRIB_ENABLE = \"enable\" ; public final static String ATTRIB_EXPAND = \"expand\" ; public final static String ATTRIB_FILTER = \"filter\" ; public final static String ATTRIB_FIRE = \"fire\" ; public final static String ATTRIB_FOCUS = \"focus\" ; public final static String ATTRIB_HEADING = \"heading\" ; public final static String ATTRIB_HEIGHT = \"height\" ; public final static String ATTRIB_ICON = \"icon\" ; public final static String ATTRIB_ID = \"id\" ; public final static String ATTRIB_LABEL = \"label\" ; public final static String ATTRIB_LAYOUT = \"layout\" ; public final static String ATTRIB_LIST = \"list\" ; public final static String ATTRIB_MARKINVALID = \"markinvalid\" ; public final static String ATTRIB_MASK = \"mask\" ; public final static String ATTRIB_MAXLENGTH = \"maxlength\" ; public final static String ATTRIB_NAME = \"name\" ; public final static String ATTRIB_OBJ = \"obj\" ; public final static String ATTRIB_PAGEBAR = \"pagebar\" ; public final static String ATTRIB_READONLY = \"readonly\" ; public final static String ATTRIB_RESET = \"reset\" ; public final static String ATTRIB_ROW = \"row\" ; public final static String ATTRIB_SELECT = \"select\" ; public final static String ATTRIB_TITLE = \"title\" ; public final static String ATTRIB_VALIDATE = \"validate\" ; public final static String ATTRIB_VALUE = \"value\" ; public final static", "gt": "String ATTRIB_VISIBLE = \"visible\" ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11838, "input": "<s> package com . emf4sw . rdf . vocabulary ; public final class RDF { public static final String NS = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" ; public static final String Property = NS + \"Property\" ; public static final String XMLLiteral = NS + \"XMLLiteral\" ; public static final String type = NS + \"type\" ; public static final String Bag = NS + \"Bag\" ; public static final String Alt = NS + \"Alt\" ; public static final String list = NS + \"list\" ; public static final String first = NS + \"first\" ; public static final String rest = NS + \"rest\" ; public static final String nil = NS + \"nil\" ; public static final String Statement = NS + \"Statement\" ; public static final String subject", "gt": "= NS + \"subject\" ;", "prediction": ";\n", "label": 1}
{"id": 2611, "input": "<s> package org . ofbiz . sql ; import java . util . List ; import org . ofbiz . base . util . StringUtil ; public final class SQLIndex extends SQLStatement < SQLIndex > { private final boolean isUnique ; private final String name ; private final String table ; private final String using ; private final List < ConstantValue > values ; public SQLIndex ( boolean isUnique , String name , String table , String using , List < ConstantValue > values ) { this . isUnique = isUnique ; this . name = name ; this . table = table ; this . using = using ; this . values = values ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } public boolean getIsUnique ( ) { return isUnique ; } public String getName ( ) { return name ; } public String getTable ( ) { return table ; } public String getUsing ( ) { return using ; } public List < ConstantValue > getValues ( ) { return values ; } @ Override public boolean equals ( Object o ) { if ( o instanceof SQLIndex ) { SQLIndex other = ( SQLIndex ) o ; return isUnique == other . isUnique && name . equals ( other . name ) && table . equals ( other . table ) && equalsHelper ( using , other . using ) && values . equals ( other . values ) ; } else { return false ; } } public StringBuilder appendTo ( StringBuilder sb ) { sb . append ( \"CREATE\" ) ; if ( isUnique ) { sb . append ( \" UNIQUE\" ) ; } sb . append ( \" INDEX \" ) ; sb . append ( name ) ; sb . append ( \" ON \" ) ; sb . append ( table ) ; if ( using != null ) { sb . append ( \" USING \" ) . append ( using ) ; } sb . append ( \" (\" ) ; StringUtil . append ( sb ,", "gt": "values , null , null , \", \" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11842, "input": "<s> package org . jscsi . target . settings ; import org . jscsi . target . settings . entry . BooleanEntry ; public enum BooleanResultFunction { AND , OR ; public final boolean getResult ( final boolean a , final boolean b ) { if ( this == AND )", "gt": "return a && b ;", "prediction": "\n", "label": 1}
{"id": 5404, "input": "<s> class A { B b = new B ( ) ; { System . out . println ( b . value ) ; } } class B { final", "gt": "B value = this ;", "prediction": "( )\n", "label": 0}
{"id": 11844, "input": "<s> package workflow ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . channels . FileChannel ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import org . apache . log4j . Logger ; import org . eclipse . emf . mwe2 . runtime . workflow . IWorkflowComponent ; import org . eclipse . emf . mwe2 . runtime . workflow . IWorkflowContext ; public class CopyFiles implements IWorkflowComponent { private String source ; private String destination ; private boolean verbose ; private Logger log = Logger . getLogger ( this . getClass ( ) ) ; private List < File > srcFiles ; public void preInvoke ( ) { if ( source != null && destination != null ) { if ( source . contains ( \"*\" ) ) { this . srcFiles = glob ( source ) ; } else if ( source . endsWith ( File . separator ) ) { this . srcFiles = expand ( new File ( source ) ) ; } else { this . srcFiles = new LinkedList < File > ( ) ; srcFiles . add ( new File ( source ) ) ; } } else { log . error ( \"source or destination not set\" ) ; } } private List < File > glob ( String source ) { List < File > ret = new LinkedList < File > ( ) ; String baseString = source . substring ( 0 , source . indexOf ( '*' ) ) ; File dir = new File ( baseString ) ; if ( dir . isDirectory ( ) && dir . canRead ( ) ) { for ( File file : Arrays . asList ( dir . listFiles ( ) ) ) { if ( file . isDirectory ( ) ) { ret . addAll ( expand ( file ) ) ; } else { ret . add ( file ) ; } } } return ret ; } private List < File > expand ( File dir ) { List < File > ret = new LinkedList < File > ( ) ; for ( File file : Arrays . asList ( dir . listFiles ( ) ) ) { if ( file . isDirectory ( ) ) { ret . addAll ( expand ( file ) ) ; } else { ret . add ( file ) ; } } return ret ; } public void invoke ( IWorkflowContext ctx ) { for ( File file : srcFiles ) { String destFilename = null ; if ( source . contains ( \"*\" ) ) { destFilename = destination + file . getPath ( ) . substring ( file . getPath ( ) . indexOf ( source . substring ( 0 , source . indexOf ( '*' ) ) ) ) ; } else { destFilename = destination + file . getPath ( ) . substring ( file . getPath ( ) . indexOf ( source ) + source . length ( ) ) ; } File destDir = new File ( destFilename . substring ( 0 , destFilename . lastIndexOf ( File . separatorChar ) ) ) ; destDir . mkdirs ( ) ; File destFile = new File ( destFilename ) ; if ( destFile . exists ( ) ) { destFile . delete ( ) ; } if ( verbose ) { log . info ( \"from \" + file . getPath ( ) + \" to \" + destFilename ) ; } FileChannel srcChannel = null ; FileChannel destChannel = null ; try { srcChannel = new FileInputStream ( file ) . getChannel ( ) ; destChannel = new FileOutputStream ( destFile ) . getChannel ( ) ; destChannel . transferFrom ( srcChannel ,", "gt": "0 , srcChannel . size ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8867, "input": "<s> package org . remast . baralga . gui . settings ; import java . awt . Dimension ; import java . awt . Point ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Date ; import java . util . Iterator ; import java . util . Properties ; import org . joda . time . DateTime ; import org . remast . baralga . model . filter . Filter ; import org . remast . baralga . model . filter . SpanType ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . google . common . base . Splitter ; public final class UserSettings { private static final Logger log = LoggerFactory . getLogger ( UserSettings . class ) ; public static final String DEFAULT_FILE_NAME = \"Data.baralga.xml\" ; public String getDataFileLocation ( ) { return ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) . getPath ( ) + File . separator + DEFAULT_FILE_NAME ; } private static String USER_PROPERTIES_FILENAME = \"baralga.properties\" ; private Properties userConfig ; private static UserSettings instance = new UserSettings ( ) ; public static UserSettings instance ( ) { return instance ; } private UserSettings ( ) { userConfigFile = new File ( ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) + File . separator + USER_PROPERTIES_FILENAME ) ; try { userConfig = new Properties ( ) ; userConfig . load ( new FileInputStream ( userConfigFile ) ) ; } catch ( Exception e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; } } private static final String LOCK_FILE_NAME = \"lock\" ; public static String getLockFileLocation ( ) { return ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) + File . separator + LOCK_FILE_NAME ; } private static final String LAST_EXCEL_EXPORT_LOCATION = \"export.excel\" ; public String getLastExcelExportLocation ( ) { return doGetString ( LAST_EXCEL_EXPORT_LOCATION , System . getProperty ( \"user.home\" ) ) ; } public void setLastExcelExportLocation ( final String excelExportLocation ) { userConfig . setProperty ( LAST_EXCEL_EXPORT_LOCATION , excelExportLocation ) ; save ( ) ; } private static final String LAST_DATA_EXPORT_LOCATION = \"export.data\" ; public String getLastDataExportLocation ( ) { return doGetString ( LAST_DATA_EXPORT_LOCATION , System .", "gt": "getProperty ( \"user.home\" ) ) ;", "prediction": "\" ) ;\n", "label": 0}
{"id": 11852, "input": "<s> package org . eclipse . jface . tests . viewers . interactive ; import org . eclipse . jface . tests . viewers . TestElement ; import org . eclipse . jface . tests . viewers . TestModelChange ; public class AddSiblingAction extends TestSelectionAction { int fEventKind ; public AddSiblingAction ( String label , TestBrowser browser ) { this ( label , browser , TestModelChange . INSERT ) ; } public AddSiblingAction ( String label , TestBrowser browser , int eventKind ) {", "gt": "super ( label , browser ) ;", "prediction": "\n", "label": 1}
{"id": 9911, "input": "<s> class Main { void test ( Obj o ) { o . test ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , undefined ) ; } } interface Test { public void test ( int i1 , int i2 , int i3 , int i4 , int i5 , int i6 , int i7 , int i8 , String str ) ; public void test ( int i1 , int i2 , int i3 , int i4 , int i5 , int i6 , int i7 , int i8 , long l ) ; } interface Obj extends Test , A , B ,", "gt": "C , D , E", "prediction": ", , , , , , , , , , , , , , , , , , , , , , , , , , ) ;\n", "label": 0}
{"id": 11854, "input": "<s> package org . fuzzydb . expressions ; public abstract class BoolExpr extends LogicExpr { protected LogicExpr left ; protected LogicExpr right ; public BoolExpr ( LogicExpr left , LogicExpr right ) { this . left = left ;", "gt": "this . right = right ;", "prediction": "}\n", "label": 1}
{"id": 2398, "input": "<s> package com . sun . source . tree ; public interface AssignmentTree extends ExpressionTree {", "gt": "ExpressionTree getVariable ( ) ;", "prediction": "( )\n", "label": 0}
{"id": 11856, "input": "<s> package br . org . archimedes . io . dxf . parsers ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . kabeja . dxf . DXFConstants ; import org . kabeja . dxf . DXFLayer ; import org . kabeja . dxf . DXFText ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . text . Text ; public class TextParser extends ElementParser { @ Override public Collection < Element > parse ( DXFLayer layer ) throws NullArgumentException , InvalidArgumentException { Collection < Element > archimedesTexts = new ArrayList < Element > ( ) ; List < DXFText > dxfTexts = layer . getDXFEntities ( DXFConstants . ENTITY_TYPE_TEXT ) ; if ( dxfTexts != null ) { for (", "gt": "DXFText dxfText : dxfTexts )", "prediction": ") ;\n", "label": 1}
{"id": 728, "input": "<s> package com . kodholken . stunclient ; import java . net . InetAddress ; import java . net . UnknownHostException ; import de . javawi . jstun . test . DiscoveryInfo ; import de . javawi . jstun . test . DiscoveryTest ; import android . app . Activity ; import android . app . AlertDialog ; import android . app . ProgressDialog ; import android . content . Context ; import android . content . DialogInterface ; import android . content . Intent ; import android . graphics . Color ; import android . os . Bundle ; import android . os . Handler ; import android . os . Message ; import android . view . Menu ; import android . view . MenuItem ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . ArrayAdapter ; import android . widget . Button ; import android . widget . LinearLayout ; import android . widget . ScrollView ; import android . widget . Spinner ; import android . widget . TextView ; public class MainActivity extends Activity implements Logger . Observer { private Button goButton ; private Spinner hostSpinner ; private Handler handler ; private LinearLayout resultLayout ; private long timeReference ; private ProgressDialog progressDialog ; private DiscoveryInfo di ; protected static final int OPTION_MENU_ABOUT = 0 ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; LoggerFactory . setObserver ( this ) ; final Context mainContext = this ; handler = new Handler ( ) { @ Override public void handleMessage ( android . os . Message msg ) { if ( msg . getData ( ) . getBoolean ( \"done\" ) ) { if ( msg . getData ( ) . getString ( \"error\" ) != null ) { AlertDialog alertDialog = new AlertDialog . Builder ( mainContext ) . create ( ) ; alertDialog . setTitle ( \"Discovery failed\" ) ; alertDialog . setMessage ( msg . getData ( ) . getString ( \"error\" ) ) ; alertDialog . setButton ( DialogInterface . BUTTON_NEUTRAL , \"Close\" , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) ; alertDialog . show ( ) ; return ; } Intent i = new Intent ( mainContext , ResultActivity . class ) ; i . putExtra ( \"localIP\" , di . getLocalIP ( ) . getHostAddress ( ) ) ; i . putExtra ( \"publicIP\" , di . getPublicIP ( ) . getHostAddress ( ) ) ; String NATType = \"Unknown\" ; if ( di . isOpenAccess ( ) ) NATType = \"No NAT\" ; if ( di . isBlockedUDP ( ) ) NATType = \"Blocked UDP\" ; if ( di . isFullCone ( ) ) NATType = \"Full Cone NAT\" ; if ( di . isRestrictedCone ( ) ) NATType = \"Restricted Cone NAT\" ; if ( di . isPortRestrictedCone ( ) ) NATType = \"Port restricted Cone NAT\" ; if ( di . isSymmetric ( ) ) NATType = \"Symmetric Cone NAT\" ; if ( di . isSymmetricUDPFirewall ( ) ) NATType = \"Symmetric UDP\" ; i . putExtra ( \"NATType\" , NATType ) ; startActivity ( i ) ; return ; } String message = msg . getData ( ) . getString ( \"message\" ) ; if ( message == null ) { return ; } long timeDelta = System . currentTimeMillis ( ) - timeReference ; TextView msgView = new TextView ( mainContext ) ; msgView . setTextColor ( Color . BLACK ) ; msgView . setText ( \"[\" + timeDelta / 1000.0 + \"] \" + message ) ; LinearLayout res = ( LinearLayout ) findViewById ( R . id . result_layout ) ; if ( ( res . getChildCount ( ) % 2 ) != 0 ) { msgView . setBackgroundColor ( 0xddaaaaaa ) ; } else { msgView . setBackgroundColor ( 0xddcccccc ) ; } res . addView ( msgView ) ; final ScrollView sv = ( ScrollView ) findViewById ( R . id . scroll_view ) ; sv . post ( new Runnable ( ) { public void run ( ) { sv . fullScroll ( ScrollView . FOCUS_DOWN ) ; } } ) ; } } ; resultLayout = ( LinearLayout ) findViewById ( R . id . result_layout ) ; hostSpinner = ( Spinner ) findViewById ( R . id . stun_servers ) ; ArrayAdapter < CharSequence > adapter = ArrayAdapter . createFromResource ( this , R . array . hosts , android . R .", "gt": "layout . simple_spinner_item ) ;", "prediction": ") ;\n", "label": 0}
{"id": 11862, "input": "<s> package org . nuxeo . webengine . sites . models ; import org . nuxeo .", "gt": "theme . models . AbstractModel ;", "prediction": ";\n", "label": 1}
{"id": 3274, "input": "<s> package ar . com . fdvs . dj . test", "gt": ". domain . db ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11872, "input": "<s> package org . fuzzydb . util ; import java . io . Serializable ; public class LinearScoreMapper implements ScoreMapper , Serializable { private static final long serialVersionUID = - 3409637404300553323L ; public float getScore ( float scoreFactor ) { return (", "gt": "scoreFactor >= 0f ) ? scoreFactor : 0f ;", "prediction": ") ;\n", "label": 1}
{"id": 7992, "input": "<s> package com . sun . mirror . declaration ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface AnnotationTypeElementDeclaration extends MethodDeclaration {", "gt": "AnnotationValue getDefaultValue ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 11879, "input": "<s> package org . restlet . test . ext . oauth ; public class MultipleUserAuthorizationServerHttpsTestCase extends MultipleUserAuthorizationServerTestCase { public MultipleUserAuthorizationServerHttpsTestCase ( ) {", "gt": "super ( true ) ;", "prediction": "\n", "label": 1}
{"id": 4344, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends Runnable , S extends String", "gt": "> void disjointness ( )", "prediction": ")\n", "label": 0}
{"id": 11880, "input": "<s> package org . json ; import java . io . IOException ; import java . io . Writer ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . TreeSet ; public class JSONObject { private static final class Null { protected final Object clone ( ) { return this ; } public boolean equals ( Object object ) { return object == null || object == this ; } public String toString ( ) { return \"null\" ; } } private Map map ; public static final Object NULL = new Null ( ) ; public JSONObject ( ) { this . map = new HashMap ( ) ; } public JSONObject ( JSONObject jo , String [ ] names ) throws JSONException { this ( ) ; for ( int i = 0 ; i < names . length ; i += 1 ) { putOnce ( names [ i ] , jo . opt ( names [ i ] ) ) ; } } public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != '{' ) { throw x . syntaxError ( \"A JSONObject text must begin with '{'\" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( \"A JSONObject text must end with '}'\" ) ; case '}' : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == '=' ) { if ( x . next ( ) != '>' ) { x . back ( ) ; } } else if ( c != ':' ) { throw x . syntaxError ( \"Expected a ':' after a key\" ) ; } putOnce ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ';' : case ',' : if ( x . nextClean ( ) == '}' ) { return ; } x . back ( ) ; break ; case '}' : return ; default : throw x . syntaxError ( \"Expected a ',' or '}'\" ) ; } } } public JSONObject ( Map map ) { this . map = ( map == null ) ? new HashMap ( ) : map ; } public JSONObject ( Map map , boolean includeSuperClass ) { this . map = new HashMap ( ) ; if ( map != null ) { Iterator i = map . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; if ( isStandardProperty ( e . getValue ( ) . getClass ( ) ) ) { this . map . put ( e . getKey ( ) , e . getValue ( ) ) ; } else { this . map . put ( e . getKey ( ) , new JSONObject ( e . getValue ( ) , includeSuperClass ) ) ; } } } } public JSONObject ( Object bean ) { this ( ) ; populateInternalMap ( bean , false ) ; } public JSONObject ( Object bean , boolean includeSuperClass ) { this ( ) ; populateInternalMap ( bean , includeSuperClass ) ; } private void populateInternalMap ( Object bean , boolean includeSuperClass ) { Class klass = bean . getClass ( ) ; if ( klass . getClassLoader ( ) == null ) { includeSuperClass = false ; } Method [ ] methods = ( includeSuperClass ) ? klass . getMethods ( ) : klass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i += 1 ) { try { Method method = methods [ i ] ; if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { String name = method . getName ( ) ; String key = \"\" ; if ( name . startsWith ( \"get\" ) ) { key = name .", "gt": "substring ( 3 ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 7192, "input": "<s> package org . remast . baralga . gui . panels . table ; import java . util . List ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . model . report . HoursByMonth ; import org . remast . baralga . gui . panels . report . HoursByMonthPanel ; import ca . odell . glazedlists . TextFilterator ; public class HoursByMonthTextFilterator implements TextFilterator < HoursByMonth > { @ Override public void getFilterStrings ( List < String > baseList , HoursByMonth hoursByMonth ) {", "gt": "if ( baseList == null || hoursByMonth == null )", "prediction": "\n", "label": 0}
{"id": 11884, "input": "<s> package org . restlet . engine . header ; import java . util . List ; import org . restlet . data . Tag ; public class TagWriter extends HeaderWriter < Tag > { public static String write ( List < Tag > tags ) { return new TagWriter ( ) . append ( tags ) . toString ( ) ; } public static String write ( Tag tag ) { return tag . format ( ) ; } @ Override public HeaderWriter < Tag > append ( Tag tag ) { return append", "gt": "( write ( tag ) ) ;", "prediction": ";\n", "label": 1}
{"id": 2739, "input": "<s> package com . mapr . storm ; import backtype . storm . task . OutputCollector ; import backtype . storm . task . TopologyContext ; import backtype . storm . tuple . Fields ; import backtype . storm . tuple . Tuple ; import com . google . common . collect . Lists ; import mockit . Mock ; import mockit . MockUp ; import java . lang . reflect . Field ; import java . util . Collection ; import java . util . Formatter ; import java . util . List ; import java . util . Set ; @ SuppressWarnings ( \"UnusedParameters\" ) public class Fake { private static final long [ ] time = { 1235L } ; private static final Clock adjuster = new Clock ( ) ; public static Tuple tuple ( Object ... data ) { final List < String > fields = Lists . newArrayList ( ) ; final List < Object > values = Lists . newArrayList ( ) ; for ( int i = 0 ; i < data . length ; i += 2 ) { fields . add ( ( String ) data [ i ] ) ; values . add ( data [ i + 1 ] ) ; } new MockUp < Tuple > ( ) { FakeTuple it ; @ Mock public void $init ( TopologyContext context , List < Object > values , int taskId , String streamId ) throws IllegalAccessException , NoSuchFieldException { Field f = Tuple . class . getDeclaredField ( \"values\" ) ; f . setAccessible ( true ) ; f . set ( it , values ) ; } @ Mock public Fields getFields ( ) { return it . fields ; } } ; return new FakeTuple ( fields , values ) ; } public static class FakeTuple extends Tuple { final Fields fields ; public FakeTuple ( List < String > fields , List < Object > values ) { super ( null , values , 0 , null ) ; this . fields = new Fields ( fields ) ; } @ Override public String toString ( ) { int i = 0 ; Formatter f = new Formatter ( ) ; f . format ( \"[\" ) ; String separator = \"\" ; for ( String field : fields ) { f . format ( \"%s%s=%s\" , separator , field , getValue ( i ++ ) ) ; separator = \", \" ; } f . format ( \"]\" ) ; return f . toString ( ) ; } } public static OutputCollector collector ( final List < AnchoredTuple > output , final Set < Tuple > acknowledgements , final Set < Tuple > failures ) { new MockUp < FakeOutputCollector > ( ) { public FakeOutputCollector it ; @ Mock public List < Integer > emit ( String streamId , Collection < Tuple > anchors , List < Object > tuple ) { it . output . add ( new AnchoredTuple ( anchors , tuple ) ) ; return null ; } @ Mock public void ack ( Tuple input ) { it . acknowledgements . add ( input ) ; } @ Mock public void fail ( Tuple tuple ) { it . failures . add ( tuple ) ; } } ; return new FakeOutputCollector ( output , acknowledgements , failures ) ; } private static class FakeOutputCollector extends OutputCollector { final List < AnchoredTuple > output ; final Set < Tuple > acknowledgements ; private final Set < Tuple > failures ; private FakeOutputCollector ( List < AnchoredTuple > output , Set < Tuple > acknowledgements , Set < Tuple > failures ) { this . output = output ; this . acknowledgements = acknowledgements ; this . failures = failures ; } @ Override public List < Integer > emit ( String streamId , Collection < Tuple > anchors , List < Object > tuple ) { output . add ( new AnchoredTuple ( anchors , tuple ) ) ; return null ; } @ Override public void emitDirect ( int taskId , String streamId , Collection < Tuple > anchors , List < Object > tuple ) { throw new UnsupportedOperationException ( \"Default operation\" ) ; } @ Override public void ack ( Tuple input ) { throw new UnsupportedOperationException ( \"Default operation\" ) ; } @ Override public void fail ( Tuple input ) { throw new UnsupportedOperationException ( \"Default operation\" ) ; } @ Override public void reportError ( Throwable error ) { throw new UnsupportedOperationException ( \"Default operation\" ) ; } } public static class AnchoredTuple { private final Collection < Tuple > anchors ; private final List < Object > tuple ; public AnchoredTuple ( Collection < Tuple > anchors , List < Object > tuple ) { this . anchors = anchors ; this . tuple = tuple ; } public Collection", "gt": "< Tuple > getAnchors ( )", "prediction": ";\n", "label": 0}
{"id": 11885, "input": "<s> package org . eclipse . ui . internal . part ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . util . SafeRunnable ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; class SelectionProviderAdapter implements ISelectionProvider { List listeners = new ArrayList ( ) ; ISelection theSelection = StructuredSelection . EMPTY ; public void addSelectionChangedListener ( ISelectionChangedListener listener ) { listeners . add ( listener ) ; } public ISelection getSelection ( ) { return theSelection ; } public", "gt": "void removeSelectionChangedListener ( ISelectionChangedListener listener )", "prediction": "( )\n", "label": 1}
{"id": 9604, "input": "<s> package hudson . plugins . dimensionsscm ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import java . io . Serializable ; public class DateUtils implements Serializable { private static final String DATE_PATTERN = \"dd-MMM-yyyy\" ; private static final String DATETIME_PATTERN = \"dd-MMM-yyyy HH:mm:ss\" ; private static final String RFCDATETIME_PATTERN = \"yyyy-MM-dd'T'HH:mm:ss'Z'\" ; private static final TimeZone UTC = TimeZone . getTimeZone ( \"UTC\" ) ; private static TimeZone tzl = TimeZone . getDefault ( ) ; private static final String PATTERNS [ ] = { DATETIME_PATTERN , DATE_PATTERN , RFCDATETIME_PATTERN } ; public static Date parse ( String dateStr ) { return parse ( dateStr , tzl ) ; } public static Date parse ( String dateStr , TimeZone tz ) { Date date = null ; dateStr = dateStr . trim ( ) ; for ( int i = 0 ; i < PATTERNS . length ; ++ i ) { try { SimpleDateFormat df = new SimpleDateFormat ( PATTERNS [ i ] , Locale . US ) ; df . setTimeZone ( tz ) ; date = df . parse ( dateStr ) ; if ( date != null ) { break ; } } catch ( ParseException pe ) { } } return date ; } public static boolean validate ( String dateStr ) { boolean ret = false ; dateStr = dateStr . trim ( ) ; for ( int i = 0 ; i < PATTERNS . length ; ++ i ) { try { SimpleDateFormat df = new SimpleDateFormat ( PATTERNS [ i ] , Locale . US ) ; Date date = df . parse ( dateStr ) ; if ( date != null && df . format ( date ) . equalsIgnoreCase ( dateStr ) ) { ret = true ; break ; } } catch ( ParseException pe ) { } } return ret ; } public static int compare ( Date d1 , Date d2 , long toleranceMillis ) { int ret ; long diff = d1 . getTime ( ) - d2 . getTime ( ) ; if ( Math . abs ( diff ) <= Math . abs ( toleranceMillis ) ) { ret = 0 ; } else if ( diff < 0L ) { ret = - 1 ; } else if ( diff > 0L ) { ret = 1 ; } else { ret = 0 ; } return ret ; } public static String format ( Date date ) { return format ( date , tzl ) ; } public static String format ( Date date , TimeZone tz ) { SimpleDateFormat df =", "gt": "new SimpleDateFormat ( DATETIME_PATTERN , Locale . US ) ;", "prediction": ";\n", "label": 0}
{"id": 11890, "input": "<s> package org . nuxeo . ecm . platform . mail . listener . action ; import static org . nuxeo . ecm . platform . mail . utils . MailCoreConstants . CORE_SESSION_ID_KEY ; import org . nuxeo . ecm . core . api . CoreInstance ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . mail . action . ExecutionContext ; import org . nuxeo . ecm . platform . mail . action . MessageAction ; public abstract class AbstractMailAction implements MessageAction { public boolean execute (", "gt": "ExecutionContext context ) throws Exception", "prediction": ")\n", "label": 1}
{"id": 2964, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; import java . util . * ; public class Group { private Map < String , String > regExpGroupMap = new HashMap < String , String > ( ) ; private List < String > sortedRegExpList = new ArrayList < String > ( ) ; private List < String > groupList = new ArrayList < String > ( ) ; private Map < String , String > pkgNameGroupMap = new HashMap < String , String > ( ) ; private final Configuration configuration ; private static class MapKeyComparator implements Comparator < String > { public int compare ( String key1 , String key2 ) { return key2 . length ( ) - key1 . length ( ) ; } } public Group ( Configuration configuration ) { this . configuration = configuration ; } public boolean checkPackageGroups ( String groupname , String pkgNameFormList ) { StringTokenizer strtok = new StringTokenizer ( pkgNameFormList , \":\" ) ; if ( groupList . contains ( groupname ) ) { configuration . message . warning ( \"doclet.Groupname_already_used\" , groupname ) ; return false ; } groupList . add ( groupname ) ; while ( strtok . hasMoreTokens ( ) ) { String id = strtok . nextToken ( ) ; if ( id . length ( ) == 0 ) { configuration . message . warning ( \"doclet.Error_in_packagelist\" , groupname , pkgNameFormList ) ; return false ; } if ( id . endsWith ( \"*\" ) ) { id = id . substring ( 0 , id . length ( ) - 1 ) ; if ( foundGroupFormat ( regExpGroupMap , id ) ) { return false ; } regExpGroupMap . put ( id , groupname ) ; sortedRegExpList . add ( id ) ; } else { if ( foundGroupFormat ( pkgNameGroupMap , id ) ) { return false ; } pkgNameGroupMap . put ( id , groupname ) ; } } Collections . sort ( sortedRegExpList , new MapKeyComparator ( ) ) ; return true ; } boolean foundGroupFormat ( Map < String , ? > map , String pkgFormat ) { if ( map . containsKey ( pkgFormat ) ) { configuration . message . error ( \"doclet.Same_package_name_used\" , pkgFormat ) ; return true ; } return false ; } public Map < String , List < PackageDoc > > groupPackages ( PackageDoc [ ] packages ) { Map < String , List < PackageDoc > > groupPackageMap = new HashMap < String , List < PackageDoc > > ( ) ; String defaultGroupName = ( pkgNameGroupMap . isEmpty ( ) && regExpGroupMap . isEmpty ( ) ) ? configuration . message . getText ( \"doclet.Packages\" ) : configuration . message . getText ( \"doclet.Other_Packages\" ) ; if ( ! groupList . contains ( defaultGroupName ) ) { groupList . add ( defaultGroupName ) ; } for ( int i = 0 ; i < packages . length ; i ++ ) { PackageDoc pkg = packages [ i ] ; String pkgName = pkg . name ( ) ; String groupName = pkgNameGroupMap . get ( pkgName ) ; if ( groupName == null ) { groupName = regExpGroupName ( pkgName ) ; } if ( groupName == null ) { groupName = defaultGroupName ; } getPkgList ( groupPackageMap , groupName ) . add ( pkg ) ; } return groupPackageMap ; } String regExpGroupName ( String pkgName ) { for ( int j = 0 ; j < sortedRegExpList . size ( ) ; j ++ ) { String regexp = sortedRegExpList . get ( j ) ; if ( pkgName . startsWith ( regexp ) ) { return", "gt": "regExpGroupMap . get ( regexp ) ;", "prediction": ";\n", "label": 0}
{"id": 11891, "input": "<s> package org . gatein . common . util ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; @ SuppressWarnings ( \"serial\" ) public abstract class CollectionMap < K , V > implements Serializable { private final Map < K , Collection < V > > map ; protected Comparator < V > comparator ; public CollectionMap ( ) { map = init ( null ) ; } public CollectionMap ( CollectionMap < K , V > other ) throws IllegalArgumentException { if ( other == null ) { throw new IllegalArgumentException ( \"Cannot copy null argument\" ) ; } map = init ( other ) ; } public CollectionMap ( CollectionMap < K , V > other , Comparator < V > comparator ) throws IllegalArgumentException { this ( other ) ; initComparator ( comparator ) ; } public CollectionMap ( Comparator < V > comparator ) { this ( ) ; initComparator ( comparator ) ; } private void initComparator ( Comparator < V > comparator ) { if ( comparator == null ) { throw new IllegalArgumentException ( \"No null comparator allowed\" ) ; } this . comparator = comparator ; } public final void put ( K key , V o ) throws NullPointerException { if ( key == null ) { throw new NullPointerException ( \"No null key\" ) ; } Collection < V > collection = map . get ( key ) ; if ( collection == null ) { collection = newCollection ( ) ; map . put ( key , collection ) ; } add ( collection , o ) ; } public final Set < K > keySet ( ) { return map . keySet ( ) ; } public final void remove ( K key ) throws NullPointerException { if ( key == null ) { throw new NullPointerException ( \"No null key\" ) ; } map . remove ( key ) ; } public final void remove ( K key , Object o ) throws NullPointerException { if ( key == null ) { throw new NullPointerException ( \"No null key\" ) ; } Collection < V >", "gt": "collection = map . get ( key ) ;", "prediction": ";\n", "label": 1}
{"id": 9245, "input": "<s> package me . moocar . logbackgelf ; import java . io . IOException ; import java . net . * ; import java . util . List ; public class Transport { private final InetAddress graylog2ServerAddress ; private final int graylog2ServerPort ; public Transport ( int graylog2ServerPort , InetAddress graylog2ServerAddress ) { this . graylog2ServerPort = graylog2ServerPort ; this . graylog2ServerAddress = graylog2ServerAddress ; } public void send ( byte [ ] data ) { DatagramPacket datagramPacket = new DatagramPacket ( data , data . length , graylog2ServerAddress , graylog2ServerPort ) ; sendPacket ( datagramPacket ) ; } public void send ( List < byte [ ] > packets ) { for ( byte [ ] packet : packets ) { send ( packet ) ; } } private void sendPacket ( DatagramPacket datagramPacket ) { DatagramSocket datagramSocket = getDatagramSocket ( ) ; try {", "gt": "datagramSocket . send ( datagramPacket ) ;", "prediction": "}\n", "label": 0}
{"id": 11912, "input": "<s> package org . jscsi", "gt": ". initiator . connection ;", "prediction": ";\n", "label": 1}
{"id": 707, "input": "<s> package org . hackreduce . mappers ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; import org . apache . hadoop . io . WritableComparable ; import org . apache . hadoop . mapreduce . Job ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . lib . input . TextInputFormat ; import org . hackreduce . models . FlightRecord ; public abstract class FlightMapper < K extends WritableComparable < ? > , V extends Writable > extends ModelMapper < FlightRecord , LongWritable , Text , K , V > { public static void configureJob ( Job job ) { job . setInputFormatClass ( TextInputFormat . class ) ; } @ Override protected FlightRecord instantiateModel ( LongWritable key , Text value ) { return", "gt": "new FlightRecord ( value ) ;", "prediction": ";\n", "label": 0}
{"id": 11954, "input": "<s> package org . nuxeo . ecm . automation . server . test ; import javax . servlet . http . HttpServletRequest ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . platform . web . common . ServletHelper ; @ Operation ( id = WaitForTxTimeoutOperation . ID , category = Constants . CAT_EXECUTION , label = \"TxTimeout\" , description = \"Wait for tx timeout\" ) public class WaitForTxTimeoutOperation { public static final String ID = \"WaitForTxTimeout\" ; @ Context protected OperationContext context ; @ OperationMethod public void run ( ) throws Exception { HttpServletRequest req = (", "gt": "HttpServletRequest ) context . get ( \"request\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9275, "input": "<s> package Liza ; import org . bukkit . entity . Spider ;", "gt": "public interface LizaSpider extends Spider", "prediction": "}\n", "label": 0}
{"id": 11970, "input": "<s> package knowevo . myvizster . action . linkage ; import java . util . Iterator ; import knowevo . myvizster . Vizster ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . NodeItem ; import edu . berkeley . guir . prefuse . action . assignment . Layout ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Node ; public class ReleaseFixedAction extends Layout { public void run ( ItemRegistry registry , double frac ) { FocusManager fman = registry . getFocusManager ( ) ; FocusSet click = fman . getFocusSet ( Vizster . CLICK_KEY ) ; FocusSet mouse = fman . getFocusSet ( Vizster . MOUSE_KEY ) ; Iterator nodeIter = click . iterator ( ) ; while ( nodeIter . hasNext ( ) ) { Node n = ( Node )", "gt": "nodeIter . next ( ) ;", "prediction": ";\n", "label": 1}
{"id": 4015, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NAPTRRecord extends Record { private static final long serialVersionUID = 5191232392044947002L ; private int order , preference ; private byte [ ] flags , service , regexp ; private Name replacement ; NAPTRRecord ( ) { } Record getObject ( ) { return new NAPTRRecord ( ) ; } public NAPTRRecord ( Name name , int dclass , long ttl , int order , int preference , String flags , String service , String regexp , Name replacement ) { super ( name , Type . NAPTR , dclass , ttl ) ; this . order = checkU16 ( \"order\" , order ) ; this . preference = checkU16 ( \"preference\" , preference ) ; try { this . flags = byteArrayFromString ( flags ) ; this . service = byteArrayFromString ( service ) ; this . regexp = byteArrayFromString ( regexp ) ; } catch ( TextParseException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } this . replacement = checkName ( \"replacement\" , replacement ) ; } void rrFromWire ( DNSInput in ) throws IOException { order = in . readU16 ( ) ; preference = in . readU16 ( ) ; flags = in . readCountedString ( ) ; service = in . readCountedString ( ) ; regexp = in . readCountedString ( ) ; replacement = new Name ( in ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { order = st . getUInt16 ( ) ; preference = st . getUInt16 ( ) ; try { flags = byteArrayFromString ( st . getString ( ) ) ; service = byteArrayFromString ( st . getString ( ) ) ; regexp = byteArrayFromString ( st . getString ( ) ) ; } catch ( TextParseException e ) { throw st . exception ( e . getMessage ( ) ) ; } replacement = st . getName ( origin ) ; } String rrToString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( order ) ; sb . append ( \" \" ) ; sb . append ( preference ) ; sb . append ( \" \" ) ; sb . append ( byteArrayToString ( flags , true ) ) ; sb . append ( \" \" ) ; sb . append ( byteArrayToString ( service , true ) ) ; sb . append ( \" \" ) ; sb . append ( byteArrayToString ( regexp , true ) ) ; sb . append ( \" \" ) ; sb . append ( replacement ) ; return sb . toString ( ) ; } public int getOrder ( ) { return order ; } public int getPreference ( ) { return preference ; } public String getFlags ( ) { return byteArrayToString ( flags , false ) ; } public String getService ( ) { return byteArrayToString ( service , false ) ; } public String getRegexp ( ) { return byteArrayToString ( regexp , false ) ; } public Name getReplacement ( ) { return replacement ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) { out . writeU16 ( order ) ; out . writeU16 ( preference ) ;", "gt": "out . writeCountedString ( flags ) ;", "prediction": "}\n", "label": 0}
{"id": 11972, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . ListViewer ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . widgets . Composite ; public class ListViewerComparatorTest extends ViewerComparatorTest { public ListViewerComparatorTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { ListViewer viewer = new ListViewer ( parent ) ; viewer . setContentProvider ( new TeamModelContentProvider ( ) ) ; viewer . setLabelProvider ( new TeamModelLabelProvider ( ) ) ; return viewer ; } public void testViewerSorter ( ) { fViewer . setSorter ( new ViewerSorter ( ) ) ; assertSortedResult ( TEAM1_SORTED ) ; } public void testViewerSorterInsertElement ( ) { fViewer . setSorter ( new ViewerSorter ( ) ) ; team1 . addMember ( \"Duong\" ) ; assertSortedResult ( TEAM1_SORTED_WITH_INSERT ) ; } public void testViewerComparator ( ) { fViewer . setComparator ( new ViewerComparator ( ) ) ; assertSortedResult ( TEAM1_SORTED ) ; } public void testViewerComparatorInsertElement ( ) { fViewer . setComparator ( new ViewerComparator ( ) ) ; team1 . addMember ( \"Duong\" ) ; assertSortedResult ( TEAM1_SORTED_WITH_INSERT ) ; } private void assertSortedResult ( String [ ] expected ) { String [ ] items = getListViewer ( ) . getList ( ) . getItems ( ) ; for ( int i = 0 ; i < items . length ; i ++ ) { String item = items [ i ] ; assertEquals ( \"Item not expected.  actual=\" + item + \" expected=\" , expected [ i ] , item ) ; } } protected void setInput ( ) { fViewer . setInput ( team1 ) ; } protected ListViewer getListViewer ( ) { return ( ListViewer ) fViewer ; } public static void main ( String [ ] args ) { junit . textui . TestRunner . run (", "gt": "ListViewerComparatorTest . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8835, "input": "<s> import java . io . * ; import java . text . * ; import java . util . * ; class Main { public static void main ( String [ ] args ) throws IOException { String linha ; int casos = Integer . parseInt ( readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < casos ; i ++ ) { int tartarugas = Integer . parseInt ( readLine ( ) . trim ( ) ) ; Vector fromList = new Vector ( ) ; for ( int t = 0 ; t < tartarugas ; t ++ ) { fromList . addElement ( readLine ( ) . trim ( ) ) ; } Vector to = new Vector ( ) ; for ( int t = 0 ; t < tartarugas ; t ++ ) { to . addElement ( readLine ( ) . trim ( ) ) ; } Vector miniPilha = new Vector ( ) ; int posFrom = tartarugas - 1 ; int posTo = tartarugas - 1 ; while ( posFrom != - 1 ) { if ( miniPilha . contains ( to . elementAt ( posTo ) ) ) { break ; } if ( fromList . elementAt ( posFrom ) . equals ( to . elementAt ( posTo ) ) ) { posFrom -- ; posTo -- ; } else { miniPilha . addElement ( fromList . elementAt ( posFrom ) ) ; posFrom -- ; } } if ( i != 0 ) System . out . println ( ) ; while (", "gt": "posTo != - 1 )", "prediction": ") ;\n", "label": 0}
{"id": 11977, "input": "<s> package pdgame ; import java . util . Random ; public class RandomPlayer extends BasicPlayer { public int makeMove ( ) { Random r = new Random ( ) ; if ( r .", "gt": "nextFloat ( ) >= 0.5 ) return GameMove . DEFECT ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8295, "input": "<s> class KindnameMethod { Object o", "gt": "= not_found ( ) ;", "prediction": ";\n", "label": 0}
{"id": 11980, "input": "<s> package org . gatein . common . text ; import junit . framework . TestCase ; import org . gatein . common . text . CharBuffer ; import org . gatein . common . text . CharEncoder ; import org . gatein . common . text . FastURLEncoder ; import java . net . URLEncoder ; public class FastURLEncoderTestCase extends TestCase { public void testEncodeThrowsIAE ( ) throws Exception { CharEncoder encoder = FastURLEncoder . getUTF8Instance ( ) ; try { encoder . encode ( new char [ 10 ] , - 1 , 0 , new CharBuffer ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { encoder . encode ( new char [ 10 ] , 5 , - 1 , new CharBuffer ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { encoder . encode ( new char [ 10 ] , 15 , 0 , new CharBuffer ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { encoder . encode ( new char [ 10 ] , 5 , 6 , new CharBuffer ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { encoder . encode ( null , 0 , 5 , new CharBuffer ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { encoder . encode ( ( char", "gt": "[ ] ) null , new CharBuffer ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9327, "input": "<s> class T6943278 < X extends Number & NonExistentInterface > { < X > T6943278 < X > m ( ) { return null ; } < X extends Number & NonExistentInterface > T6943278 < X", "gt": "> m ( X x )", "prediction": ")\n", "label": 0}
{"id": 11996, "input": "<s> package Servletspackage ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . ServletException ; import javax . servlet . annotation . WebServlet ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; @ WebServlet ( name = \"ChangeTextServlet\" , urlPatterns = { \"/ChangeTextServlet\" } ) public class ChangeTextServlet extends HttpServlet { public String Counters = \"\" ; public int intCounters = 0 ; protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( \"text/html;charset=UTF-8\" ) ; PrintWriter out = response . getWriter ( ) ; try { intCounters ++ ;", "gt": "Counters = Counters + intCounters + \" Point<br/>\" ;", "prediction": "}\n", "label": 1}
{"id": 5399, "input": "<s> package org . ofbiz . widget . screen ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javax . xml . parsers . ParserConfigurationException ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . control . LoginWorker ; import org . ofbiz . widget . cache . GenericWidgetOutput ; import org . ofbiz . widget . cache . ScreenCache ; import org . ofbiz . widget . cache . WidgetContextCacheKey ; import org . xml . sax . SAXException ; import freemarker . ext . jsp . TaglibFactory ; import freemarker . ext . servlet . HttpRequestHashModel ; import freemarker . ext . servlet . HttpSessionHashModel ; import freemarker . ext . servlet . ServletContextHashModel ; public class ScreenRenderer { public static final String module = ScreenRenderer . class . getName ( ) ; protected Appendable writer ; protected MapStack < String > context ; protected ScreenStringRenderer screenStringRenderer ; protected int renderFormSeqNumber = 0 ; public ScreenRenderer ( Appendable writer , MapStack < String > context , ScreenStringRenderer screenStringRenderer ) { this . writer = writer ; this . context = context ; if ( this . context == null ) this . context = MapStack . create ( ) ; this . screenStringRenderer = screenStringRenderer ; } public String render ( String combinedName ) throws GeneralException , IOException , SAXException , ParserConfigurationException { String resourceName = ScreenFactory . getResourceNameFromCombined ( combinedName ) ; String screenName = ScreenFactory . getScreenNameFromCombined ( combinedName ) ; this . render ( resourceName , screenName ) ; return \"\" ; } public String render ( String resourceName , String screenName ) throws GeneralException , IOException , SAXException , ParserConfigurationException { ModelScreen modelScreen = ScreenFactory . getScreenFromLocation ( resourceName , screenName ) ; if ( modelScreen . useCache ) { WidgetContextCacheKey wcck = new WidgetContextCacheKey ( context ) ; String screenCombinedName = resourceName + \":\" + screenName ; ScreenCache screenCache = new ScreenCache ( ) ; GenericWidgetOutput gwo = screenCache . get ( screenCombinedName , wcck ) ; if ( gwo == null ) { Writer sw = new StringWriter ( ) ; modelScreen . renderScreenString ( sw , context , screenStringRenderer ) ; gwo = new GenericWidgetOutput ( sw . toString ( ) ) ; screenCache . put ( screenCombinedName , wcck , gwo ) ; writer . append ( gwo . toString ( ) ) ; } else { writer . append ( gwo . toString ( ) ) ; } } else { context . put ( \"renderFormSeqNumber\" , String . valueOf ( renderFormSeqNumber ) ) ; modelScreen . renderScreenString ( writer , context , screenStringRenderer ) ; } return \"\" ; } public void setRenderFormUniqueSeq ( int renderFormSeqNumber ) { this . renderFormSeqNumber = renderFormSeqNumber ; } public ScreenStringRenderer getScreenStringRenderer ( ) { return this . screenStringRenderer ; } public void populateBasicContext ( Map < String , Object > parameters , Delegator delegator , LocalDispatcher dispatcher , Security security , Locale locale , GenericValue userLogin ) { populateBasicContext ( context , this , parameters , delegator , dispatcher , security , locale , userLogin ) ; } public static void populateBasicContext ( MapStack < String > context , ScreenRenderer screens , Map < String , Object > parameters , Delegator delegator , LocalDispatcher dispatcher , Security security ,", "gt": "Locale locale , GenericValue userLogin )", "prediction": ") ;\n", "label": 0}
{"id": 12011, "input": "<s> package org . restlet . ext . openid . internal ; import org . openid4java . message . ParameterList ; public class UserSession { private volatile ParameterList pl ; private volatile OpenIdUser user ; public UserSession ( ParameterList pl ) { this . pl = pl ; } public void setParameterList ( ParameterList pl ) {", "gt": "this . pl = pl ;", "prediction": "\n", "label": 1}
{"id": 2443, "input": "<s> package org . ofbiz . base . util ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectStreamClass ; import java . lang . reflect . Proxy ; public class ObjectInputStream extends java . io . ObjectInputStream { private ClassLoader classloader ; public ObjectInputStream ( InputStream in , ClassLoader loader ) throws IOException { super ( in ) ; this . classloader = loader ; } @ Override protected Class < ? > resolveClass ( ObjectStreamClass classDesc ) throws IOException , ClassNotFoundException { return ObjectType . loadClass ( classDesc . getName ( ) , classloader ) ; } @ Override protected Class < ? > resolveProxyClass ( String [ ] interfaces ) throws IOException , ClassNotFoundException { Class < ? > [ ] cinterfaces = new Class [ interfaces . length ] ; for ( int i = 0 ; i < interfaces . length ; i ++ ) cinterfaces [ i ] = classloader . loadClass ( interfaces [ i ] ) ; try { return Proxy . getProxyClass ( classloader , cinterfaces ) ; } catch ( IllegalArgumentException e ) { throw new ClassNotFoundException", "gt": "( null , e ) ;", "prediction": ";\n", "label": 0}
{"id": 12018, "input": "<s> package org . apache . lucene . queryParser . core . nodes ; import java . util . List ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeError ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . parser . EscapeQuerySyntax ; public class BoostQueryNode extends QueryNodeImpl { private static final long serialVersionUID = - 3929082630855807593L ; private float value = 0 ; public BoostQueryNode ( QueryNode query , float value ) throws QueryNodeException { if ( query == null ) { throw new QueryNodeError ( new MessageImpl ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED , new Object [ ] { \"query\" , \"null\" } ) ) ; } this . value = value ; setLeaf ( false ) ; allocate ( ) ; add ( query ) ; } public QueryNode getChild ( ) { List < QueryNode > children = getChildren ( ) ; if ( children == null || children . size ( ) == 0 ) { return null ; } return children . get ( 0 ) ; } public float getValue ( ) { return this . value ; } private CharSequence getValueString ( ) { Float f = new Float ( this . value ) ; if ( f == f . longValue ( ) ) return \"\" + f . longValue ( ) ; else return \"\" + f ; } public String toString ( ) { return \"<boost value='\" + getValueString ( ) + \"'>\" + \"\\n\" + getChild ( ) . toString ( ) + \"\\n</boost>\" ; } public CharSequence toQueryString ( EscapeQuerySyntax escapeSyntaxParser ) { if ( getChild ( ) == null ) return \"\" ; return getChild ( ) . toQueryString ( escapeSyntaxParser ) + \"^\" + getValueString ( ) ; } public QueryNode", "gt": "cloneTree ( ) throws CloneNotSupportedException", "prediction": "( )\n", "label": 1}
{"id": 6514, "input": "<s> package p ; class Inner extends Outer . Super { Inner ( Outer t ) { t . super ( ) ; }", "gt": "Outer this$0 = null ;", "prediction": "}\n", "label": 0}
{"id": 12035, "input": "<s> package episode_21 ; import de . matthiasmann . twl . utils . PNGDecoder ; import de . matthiasmann . twl . utils . PNGDecoder . Format ; import net . java . games . input . Component ; import net . java . games . input . Controller ; import net . java . games . input . ControllerEnvironment ; import org . lwjgl . BufferUtils ; import org . lwjgl . LWJGLException ; import org . lwjgl . Sys ; import org . lwjgl . input . Keyboard ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . DisplayMode ; import org . lwjgl . opengl . GLContext ; import org . lwjgl . util . vector . Vector3f ; import org . newdawn . slick . Color ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . FloatBuffer ; import java . util . logging . Level ; import java . util . logging . Logger ; import static org . lwjgl . opengl . GL11 . * ; import static org . lwjgl . util . glu . GLU . gluPerspective ; public class MineFront { public static final boolean resizable = true ; public static volatile boolean running = true ; public static Vector3f position = new Vector3f ( 0 , 0 , 0 ) ; public static Vector3f rotation = new Vector3f ( 0 , 0 , 0 ) ; public static float zNear = 0.001f ; public static final int gridSize = 10 ; public static final float tileSize = 0.20f ; public static float zFar = 35f ; public static float fogNear = 25f ; public static float fogFar = 33f ; public static Color fogColor = new Color ( 1f , 1f , 1f , 1f ) ; public static final boolean fullscreen = true ; public static int walkingSpeed = 10 ; public static int mouseSpeed = 2 ; public static int joystickSpeed = 2 ; public static final boolean vsync = false ; public static boolean printFPS = false ; public static final int maxLookUp = 85 ; public static final int maxLookDown = - 85 ; public static final float ceilingHeight = 10 ; public static final float floorHeight = - 1 ; public static int fov = 80 ; private static int fps ; private static long lastFPS ; private static long lastFrame ; private static long getTime ( ) { return ( Sys . getTime ( ) * 1000 ) / Sys . getTimerResolution ( ) ; } private static int getDelta ( ) { long currentTime = getTime ( ) ; int delta = ( int ) ( currentTime - lastFrame ) ; lastFrame = getTime ( ) ; return delta ; } public static void updateFPS ( ) { if ( getTime ( ) - lastFPS > 1000 ) { if ( printFPS ) { System . out . println ( \"FPS: \" + fps ) ; } fps = 0 ; lastFPS += 1000 ; } fps ++ ; } public static void main ( String [ ] args ) { try { if ( fullscreen ) { Display . setDisplayModeAndFullscreen ( Display . getAvailableDisplayModes ( ) [ 0 ] ) ; } else { Display . setResizable ( resizable ) ; Display . setDisplayMode ( new DisplayMode ( 800 , 600 ) ) ; } Display . setTitle ( \"Minefront Pre-Alpha 0.02 LWJGL Port\" ) ; Display . setVSyncEnabled ( vsync ) ; Display . create ( ) ; } catch ( LWJGLException ex ) { ex . printStackTrace ( ) ; Display . destroy ( ) ; System . exit ( 1 ) ; } if ( fullscreen ) { Mouse . setGrabbed ( true ) ; } else { Mouse . setGrabbed ( false ) ; } if ( ! GLContext . getCapabilities ( ) . OpenGL11 ) { System . err . println ( \"Your OpenGL version doesn't support the required functionality.\" ) ; Display . destroy ( ) ; System . exit ( 1 ) ; } glMatrixMode ( GL_PROJECTION ) ; glLoadIdentity ( ) ; gluPerspective ( fov , ( float ) Display . getWidth ( ) / ( float ) Display . getHeight ( ) , zNear , zFar ) ; glMatrixMode ( GL_MODELVIEW ) ; glLoadIdentity ( ) ; glEnable ( GL_DEPTH_TEST ) ; glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_ALPHA_TEST ) ; glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ) ; glHint ( GL_PERSPECTIVE_CORRECTION_HINT , GL_NICEST ) ; glEnable ( GL_CULL_FACE ) ; glCullFace ( GL_BACK ) ; glEnable ( GL_FOG ) ; Controller joystick = ControllerEnvironment . getDefaultEnvironment ( ) . getControllers ( ) [ 0 ] ; { FloatBuffer fogColours = BufferUtils .", "gt": "createFloatBuffer ( 4 ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8682, "input": "<s> package org . ofbiz . webpos ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . order . shoppingcart . ShoppingCartEvents ; import org . ofbiz . order . shoppinglist . ShoppingListEvents ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . securityext . login . LoginEvents ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webpos . session . WebPosSession ; public class WebPosEvents { public static String module = WebPosEvents . class . getName ( ) ; public static String posLogin ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( true ) ; String posTerminalId = ( String ) request . getParameter ( \"posTerminalId\" ) ; session . removeAttribute ( \"shoppingCart\" ) ; session . removeAttribute ( \"webPosSession\" ) ; WebPosSession webPosSession = WebPosEvents . getWebPosSession ( request , posTerminalId ) ; String responseString = LoginEvents . storeLogin ( request , response ) ; GenericValue userLoginNew = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; if ( UtilValidate . isNotEmpty ( userLoginNew ) && UtilValidate . isNotEmpty ( posTerminalId ) ) { webPosSession . setUserLogin ( userLoginNew ) ; } return responseString ; } public static String existsWebPosSession ( HttpServletRequest request , HttpServletResponse response ) { String responseString = \"success\" ; HttpSession session = request . getSession ( true ) ; WebPosSession webPosSession = ( WebPosSession ) session . getAttribute ( \"webPosSession\" ) ; if ( UtilValidate . isEmpty ( webPosSession ) ) { responseString = \"error\" ; } return responseString ; } public static WebPosSession getWebPosSession ( HttpServletRequest request , String posTerminalId ) { HttpSession session = request . getSession ( true ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; WebPosSession webPosSession = ( WebPosSession ) session . getAttribute ( \"webPosSession\" ) ; ShoppingCart cart = ( ShoppingCart ) session . getAttribute ( \"shoppingCart\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; if ( UtilValidate . isEmpty ( webPosSession ) ) { String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; GenericValue productStore = ProductStoreWorker . getProductStore ( productStoreId , delegator ) ; String facilityId = null ; String currencyUomId = request . getParameter ( \"currencyUomId\" ) ; if ( UtilValidate . isNotEmpty ( productStore ) ) { facilityId = productStore . getString ( \"inventoryFacilityId\" ) ; if ( UtilValidate . isEmpty ( currencyUomId ) ) { currencyUomId = productStore . getString ( \"defaultCurrencyUomId\" ) ; } } if ( UtilValidate . isNotEmpty ( userLogin ) ) { session . setAttribute ( \"userLogin\" , userLogin ) ; } if ( UtilValidate . isEmpty ( cart ) ) { cart = new ShoppingCart ( delegator , productStoreId , request . getLocale ( ) , currencyUomId ) ; session . setAttribute ( \"shoppingCart\" , cart ) ; } if ( UtilValidate . isNotEmpty ( posTerminalId ) ) { webPosSession = new WebPosSession ( posTerminalId , null , userLogin , request . getLocale ( ) , productStoreId , facilityId , currencyUomId , delegator , dispatcher , cart ) ; session . setAttribute ( \"webPosSession\" , webPosSession ) ; } else { Debug . logError ( \"PosTerminalId is empty cannot create a webPosSession\" , module ) ; } } return webPosSession ; } public static void removeWebPosSession ( HttpServletRequest request , String posTerminalId ) { HttpSession session = request . getSession ( true ) ; session . removeAttribute ( \"shoppingCart\" ) ; session . removeAttribute ( \"webPosSession\" ) ; getWebPosSession ( request , posTerminalId ) ; } public static String completeSale ( HttpServletRequest request , HttpServletResponse response ) throws GeneralException { HttpSession session = request . getSession ( true ) ; WebPosSession webPosSession = ( WebPosSession ) session . getAttribute ( \"webPosSession\" ) ; if ( UtilValidate . isNotEmpty ( webPosSession ) ) { webPosSession . getCurrentTransaction ( ) . processSale ( ) ; emptyCartAndClearAutoSaveList ( request , response ) ; String posTerminalId = webPosSession . getId ( ) ; removeWebPosSession ( request , posTerminalId ) ; } return \"success\" ; } public static String emptyCartAndClearAutoSaveList ( HttpServletRequest request , HttpServletResponse response ) throws GeneralException { HttpSession session = request . getSession ( true ) ; WebPosSession webPosSession = ( WebPosSession ) session . getAttribute ( \"webPosSession\" ) ; ShoppingCartEvents . clearCart ( request , response ) ; if ( UtilValidate . isNotEmpty ( webPosSession ) ) { String autoSaveListId = ShoppingListEvents . getAutoSaveListId ( webPosSession . getDelegator ( ) , webPosSession . getDispatcher ( ) , null , webPosSession . getUserLogin ( ) , webPosSession . getProductStoreId ( ) ) ; ShoppingListEvents . clearListInfo", "gt": "( webPosSession . getDelegator ( ) , autoSaveListId ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12043, "input": "<s> package org . jscsi . initiator . devices ; import java . util . Date ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class DummyDevice implements Device { private Date creationDate ; private final int blockSize ; private final long blockCount ; private boolean opened = false ; private static final Logger LOGGER = LoggerFactory . getLogger ( DummyDevice . class ) ; public DummyDevice ( final int initBlockSize , final long initBlockCount ) throws Exception { blockSize = initBlockSize ; blockCount = initBlockCount ; } public void close ( ) throws Exception { LOGGER . info ( \"Closed \" + getName ( ) + \".\" ) ; opened = false ; } public int getBlockSize ( ) { if ( ! opened ) { throw new IllegalStateException ( \"You first have to open the Device!\" ) ; } return blockSize ; } public String getName ( ) { if ( ! opened ) { throw new IllegalStateException ( \"You first have to open the Device!\" ) ; } return \"DummyDevice(\" + creationDate . getTime ( ) + \")\" ; } public long getBlockCount ( ) { if ( ! opened ) { throw new IllegalStateException ( \"You first have to open the Device!\" ) ; } return blockCount ; } public void open ( ) throws Exception { if ( opened ) { throw new IllegalStateException ( \"DummyDevice is already opened!\" ) ; } opened = true ; creationDate = new Date ( ) ; LOGGER . info ( \"Initialized \" + getName ( ) + \".\" ) ; } public void read ( final long address , final byte [ ] data ) throws Exception { if ( ! opened ) { throw new IllegalStateException (", "gt": "\"You first have to open the Device!\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3029, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . navigator ; import org . eclipse . core . runtime . IAdapterFactory ; import org . eclipse . core . runtime . Platform ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . gmf . runtime . notation . View ; public class SimplemapNavigatorItem extends SimplemapAbstractNavigatorItem { static { final Class [ ] supportedTypes = new Class [ ] { View . class , EObject . class } ; Platform . getAdapterManager ( ) . registerAdapters ( new IAdapterFactory ( ) { public Object getAdapter ( Object adaptableObject , Class adapterType ) { if ( adaptableObject instanceof org . msl . simple . gmfmap . simplemappings . diagram . navigator . SimplemapNavigatorItem && ( adapterType == View . class || adapterType == EObject . class ) ) { return ( ( org . msl . simple . gmfmap . simplemappings . diagram . navigator . SimplemapNavigatorItem ) adaptableObject ) . getView ( ) ; } return null ; } public Class [ ] getAdapterList ( ) { return supportedTypes ; } } , org . msl . simple . gmfmap . simplemappings . diagram . navigator . SimplemapNavigatorItem . class ) ; } private View myView ; private boolean myLeaf = false ; public SimplemapNavigatorItem ( View view , Object parent , boolean isLeaf ) { super ( parent ) ; myView = view ; myLeaf = isLeaf ; } public View getView ( ) { return myView ; } public boolean isLeaf ( ) { return myLeaf ; }", "gt": "public boolean equals ( Object obj )", "prediction": "}\n", "label": 0}
{"id": 12049, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . jaas ; import org . restlet . data . Reference ; import org . restlet . resource . ServerResource ; public class MailServerResource extends ServerResource implements MailResource { public Mail retrieve ( ) { Mail mail = new Mail ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) .", "gt": "getTargetRef ( ) . toString ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1676, "input": "<s> package java . lang ; public final class Integer { public static", "gt": "final Class TYPE = null ;", "prediction": "( )\n", "label": 0}
{"id": 12059, "input": "<s> package org . restlet . ext . rdf . internal . xml ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import org . restlet . Context ; import org . restlet . data . Reference ; import org . restlet . ext . rdf . Graph ; import org . restlet . ext . rdf . GraphHandler ; import org . restlet . ext . rdf . Link ; import org . restlet . ext . rdf . Literal ; import org . restlet . ext . rdf . internal . RdfConstants ; import org . restlet . ext . xml . XmlWriter ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . AttributesImpl ; public class RdfXmlWriter extends GraphHandler { private final String RDF_SYNTAX = RdfConstants . RDF_SYNTAX . toString ( true , true ) ; private XmlWriter writer ; private Reference lastSource ; public RdfXmlWriter ( Writer writer ) throws UnsupportedEncodingException { super ( ) ; this . writer = new XmlWriter ( writer ) ; this . lastSource = null ; } @ Override public void endGraph ( ) throws IOException { try { if ( this . lastSource != null ) { this . writer . endElement ( RDF_SYNTAX , \"Description\" ) ; } this . writer . endElement ( RDF_SYNTAX , \"RDF\" ) ; this . writer . endDocument ( ) ; } catch ( SAXException e ) { Context . getCurrentLogger ( ) . warning ( \"Cannot write the end of the graph: \" + e . getMessage ( ) ) ; } this . writer . flush ( ) ; } private String getNamespace ( Reference reference ) { String prefix = getPrefix ( reference ) ; String ref = reference . toString ( true , true ) ; if ( prefix != null ) { return ref . substring ( 0 , ref . length ( ) - prefix . length ( ) ) ; } return ref ; } private String getPrefix ( Reference ref ) { String result = null ; if ( ref . hasFragment ( ) ) { result = ref . getFragment ( ) ; } else { result = ref . getLastSegment ( ) ; } return result ; } @ Override public void link ( Graph source , Reference typeRef , Literal target ) { Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to the fact that the subject is not a Reference.\" ) ; } @ Override public void link ( Graph source , Reference typeRef , Reference target ) { Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to the fact that the subject is not a Reference.\" ) ; } @ Override public void link ( Reference source , Reference typeRef , Literal target ) { try { if ( this . lastSource == null ) { writeNode ( source , true ) ; } else if ( ! source . equals ( this . lastSource ) ) { this . writer . endElement ( RDF_SYNTAX , \"Description\" ) ; writeNode ( source , true ) ; } this . lastSource = source ; String typeRefNs = getNamespace ( typeRef . getTargetRef ( ) ) ; String typeRefPrefix = getPrefix ( typeRef . getTargetRef ( ) ) ; if ( target . getLanguage ( ) != null || target . getDatatypeRef ( ) != null ) { AttributesImpl attr = new AttributesImpl ( ) ; if ( target . getLanguage ( ) != null ) { attr . addAttribute ( null , \"lang\" , \"xml:lang\" , \"text\" , target . getLanguage ( ) . getName ( ) ) ; } if ( target . getDatatypeRef ( ) != null ) { attr . addAttribute ( RDF_SYNTAX , \"datatype\" , \"rdf:datatype\" , \"text\" , target . getDatatypeRef ( ) . toString ( true , true ) ) ; } this . writer . startElement ( typeRefNs , typeRefPrefix , null , attr ) ; } else { this . writer . startElement ( typeRefNs , typeRefPrefix ) ; } this . writer . characters ( target . getValue ( ) ) ; this . writer . endElement ( typeRefNs , typeRefPrefix ) ; } catch ( SAXException e ) { org . restlet . Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to: \" + e . getMessage ( ) ) ; } } @ Override public void link ( Reference source , Reference typeRef , Reference target ) { try { if ( this . lastSource == null ) { writeNode ( source , true ) ; } else if ( ! source . equals ( this . lastSource ) ) { this . writer . endElement ( RDF_SYNTAX , \"Description\" ) ; writeNode ( source , true ) ; } this . lastSource = source ; String typeRefNs = getNamespace ( typeRef . getTargetRef ( ) ) ; String typeRefPrefix = getPrefix ( typeRef . getTargetRef ( ) ) ; this . writer . startElement ( typeRefNs , typeRefPrefix ) ; writeNode ( target , false ) ; this . writer . endElement ( typeRefNs , typeRefPrefix ) ; } catch ( SAXException e ) { Context . getCurrentLogger ( ) . warning ( \"Cannot write the representation of a statement due to: \" + e . getMessage ( ) ) ; } } @ Override public void startGraph ( ) throws IOException { this . writer . setPrefix ( RDF_SYNTAX , \"rdf\" ) ; this . writer . setPrefix ( RdfConstants . XML_SCHEMA . toString ( true , true ) , \"type\" ) ; writer . setDataFormat ( true ) ; writer . setIndentStep ( 3 ) ; try { this . writer . startDocument ( ) ; this . writer .", "gt": "startElement ( RDF_SYNTAX , \"RDF\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8563, "input": "<s> package transformations ; import java . awt . Color ; import tmpimage . TmpImage ; public abstract class VerticalFlip implements Transformation { public static void transformOnTmpImage ( TmpImage image ) { Color temp ; for ( int i = 0 ; i < image . getHeight ( ) / 2 ; i ++ ) { for ( int j = 0 ; j < image . getWidth ( ) ; j ++ ) { temp = image . getColor ( i , j ) ; image . setColor ( i , j , image . getColor ( image . getHeight ( ) - i -", "gt": "1 , j ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12080, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . navigator ; import org . nuxeo . ecm . platform . gwt . client . ui . login . LoginDialog ; import com . google . gwt . user . client . Window ; import com . smartgwt . client . data . DSRequest ; import com . smartgwt . client . data . DSResponse ; import com . smartgwt . client . data . RestDataSource ; public class NuxeoDataSource extends RestDataSource { static { initErrorHandler ( ) ; } public static native void initErrorHandler ( ) ; public static Boolean handleError ( DSResponse response , DSRequest req ) { int status = response . getStatus ( ) ; if ( status == - 7 || response . getHttpResponseCode ( ) == 401 ) { LoginDialog dlg = new LoginDialog ( ) ; dlg . show ( ) ; } else { String [ ] errors = response .", "gt": "getAttributeAsStringArray ( \"data\" ) ;", "prediction": "get ( ) ;\n", "label": 1}
{"id": 8930, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface TaskStatusSheet extends StatusSheetAttribute , TaskStatusSheetAttribute { Task getTask ( ) ; void setTask ( Task value ) ; EList < TaskStatusSheetAttribute", "gt": "> getAttributes ( ) ;", "prediction": ";\n", "label": 0}
{"id": 12099, "input": "<s> package io . beancounter . resolver ; import com . google . inject . Guice ; import com . google . inject . Injector ; import org . joda . time . DateTime ; import org . testng . Assert ; import org . testng . annotations . * ; import redis . clients . jedis . Jedis ; import redis . clients . jedis . JedisPool ; import io . beancounter . commons . helper . jedis . JedisPoolFactory ; import io . beancounter . commons . model . activity . * ; import java . lang . Object ; import java . net . URL ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . UUID ; public class JedisResolverIntegrationTest { private Resolver resolver ; private Jedis jedis ; @ BeforeSuite public void setUp ( ) throws Exception { Injector injector = Guice . createInjector ( new ResolverModule ( ) ) ; JedisPool pool = injector . getInstance ( JedisPoolFactory . class ) . build ( ) ; jedis = pool . getResource ( ) ; resolver = injector . getInstance ( Resolver . class ) ; } @ BeforeMethod public void flush ( ) { jedis . flushAll ( ) ; } @ Test public void testResolveTweet ( ) throws Exception { jedis . select ( 3 ) ; UUID uuid = UUID . randomUUID ( ) ; jedis . hset ( \"twitter_username\" , \"uuid\" , uuid . toString ( ) ) ; jedis . hset ( \"twitter_username\" , \"username\" , \"beancounter-username\" ) ; Activity tweet = getTweetActivity ( ) ; UUID resolvedUserId = resolver . resolve ( tweet ) ; Assert . assertEquals ( resolvedUserId , uuid ) ; } @ Test public void testResolveFacebookEvent ( ) throws Exception { jedis . select ( 4 ) ; UUID uuid = UUID . randomUUID ( ) ; jedis . hset ( \"facebook_username\" , \"uuid\" , uuid . toString ( ) ) ; jedis . hset ( \"facebook_username\" , \"username\" , \"beancounter-username\" ) ; Activity event = getEventActivity ( ) ; UUID resolvedUserId = resolver . resolve ( event ) ; Assert . assertEquals ( resolvedUserId , uuid ) ; } @ Test public void testResolveFacebookEventNotStoredUser ( ) throws Exception { jedis . select ( 4 ) ; UUID uuid = UUID . randomUUID ( ) ; jedis . hset ( \"facebook_username\" , \"uuid\" , uuid . toString ( ) ) ; jedis . hset ( \"facebook_username\" , \"username\" , \"beancounter-username\" ) ; Activity event = getEventActivity ( ) ; event . getContext ( ) . setUsername ( \"not-existing-user\" ) ; try { resolver . resolve ( event ) ; Assert . fail ( ) ; } catch ( ResolverException e ) { Assert . assertEquals ( e . getMessage ( ) , \"User [not-existing-user] not found for [facebook]\" ) ; } } @ Test public void testResolveNotSupportedActivity ( ) throws Exception { jedis . select ( 3 ) ; jedis . hset ( \"twitter_username\" , \"uuid\" , UUID . randomUUID ( ) . toString ( ) ) ; jedis . hset ( \"twitter_username\" , \"username\" , \"beancounter-username\" ) ; Activity unsupportedActivity = getEventActivity ( ) ; unsupportedActivity . setVerb ( Verb . CHECKIN ) ; try { resolver . resolve ( unsupportedActivity ) ; Assert . fail ( ) ; } catch ( ResolverException e ) { Assert . assertEquals ( e . getMessage ( ) , \"User [facebook_username] not found for [facebook]\" ) ; } } @ Test public void findsUserIdsForTwitterService ( ) throws Exception { jedis . select ( 3 ) ; String serviceName = \"twitter\" ; jedis . rpush ( serviceName , \"121\" ) ; jedis . rpush ( serviceName , \"122\" ) ; jedis . rpush ( serviceName , \"120\" ) ; List < String > userIds = resolver . getUserIdsFor ( serviceName , 0 , 10 ) ; Assert . assertEquals ( userIds . get ( 0 ) , \"121\" ) ; Assert . assertEquals ( userIds . get ( 1 ) , \"122\" ) ; Assert . assertEquals ( userIds . get ( 2 ) , \"120\" ) ; } private Activity getTweetActivity ( ) throws Exception { ActivityBuilder builder = new DefaultActivityBuilder ( ) ; builder . push ( ) ; builder . setVerb ( Verb . TWEET ) ; Map < String , Object > fields = new HashMap < String , Object > ( ) ; fields . put ( \"setText\" , \"Some fake text\" ) ; builder . setObject ( Tweet . class , new URL ( \"http://test.com\" ) , \"Tweet Name\" , fields ) ; builder . setContext ( new DateTime ( ) , \"twitter\" , \"twitter_username\" ) ; return builder . pop ( ) ; } private Activity getEventActivity ( ) throws Exception { ActivityBuilder builder = new DefaultActivityBuilder ( ) ; builder . push ( ) ; builder . setVerb ( Verb . LIKE ) ; Map < String , Object > fields = new HashMap < String , Object > ( ) ; builder . setObject ( Event . class , new URL ( \"http://test.com\"", "gt": ") , \"Event Name\" , fields ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 5640, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . ui . INewWizard ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . actions . WorkspaceModifyOperation ; public class SimplemapCreationWizard extends Wizard implements INewWizard { private IWorkbench workbench ; protected IStructuredSelection selection ; protected SimplemapCreationWizardPage diagramModelFilePage ; protected Resource diagram ; private boolean openNewlyCreatedDiagramEditor = true ; public IWorkbench getWorkbench ( ) { return workbench ; } public IStructuredSelection getSelection ( ) { return selection ; } public final Resource getDiagram ( ) { return diagram ; } public final boolean isOpenNewlyCreatedDiagramEditor ( ) { return openNewlyCreatedDiagramEditor ; } public void setOpenNewlyCreatedDiagramEditor ( boolean openNewlyCreatedDiagramEditor ) { this . openNewlyCreatedDiagramEditor = openNewlyCreatedDiagramEditor ; } public void init ( IWorkbench workbench , IStructuredSelection selection ) { this . workbench = workbench ; this . selection = selection ; setWindowTitle ( Messages . SimplemapCreationWizardTitle ) ; setDefaultPageImageDescriptor ( SimplemapDiagramEditorPlugin . getBundledImageDescriptor ( \"icons/wizban/NewSimplemappingsWizard.gif\" ) ) ; setNeedsProgressMonitor ( true ) ; } public void addPages ( ) { diagramModelFilePage = new SimplemapCreationWizardPage ( \"DiagramModelFile\" , getSelection ( ) , \"simplemappings\" ) ; diagramModelFilePage . setTitle ( Messages . SimplemapCreationWizard_DiagramModelFilePageTitle ) ; diagramModelFilePage . setDescription ( Messages . SimplemapCreationWizard_DiagramModelFilePageDescription ) ; addPage ( diagramModelFilePage ) ; } public boolean performFinish ( ) { IRunnableWithProgress op = new WorkspaceModifyOperation ( null ) { protected void execute ( IProgressMonitor monitor ) throws CoreException , InterruptedException { diagram = SimplemapDiagramEditorUtil . createDiagram ( diagramModelFilePage .", "gt": "getURI ( ) , monitor ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12101, "input": "<s> package org . eclipse . swt . internal . image ; final class JPEGHuffmanTable extends JPEGVariableSizeSegment { JPEGHuffmanTable [ ] allTables ; int tableClass ; int tableIdentifier ; int [ ] dhMaxCodes ; int [ ] dhMinCodes ; int [ ] dhValPtrs ; int [ ] dhValues ; int [ ] ehCodes ; byte [ ] ehCodeLengths ; static byte [ ] DCLuminanceTable = { ( byte ) 255 , ( byte ) 196 , 0 , 31 , 0 , 0 , 1 , 5 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } ; static byte [ ] DCChrominanceTable = { ( byte ) 255 , ( byte ) 196 , 0 , 31 , 1 , 0 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } ; static byte [ ] ACLuminanceTable = { ( byte ) 255 , ( byte ) 196 , 0 , ( byte ) 181 , 16 , 0 , 2 , 1 , 3 , 3 , 2 , 4 , 3 , 5 , 5 , 4 , 4 , 0 , 0 , 1 , 125 , 1 , 2 , 3 , 0 , 4 , 17 , 5 , 18 , 33 , 49 , 65 , 6 , 19 , 81 , 97 , 7 , 34 , 113 , 20 , 50 , ( byte ) 129 , ( byte ) 145 , ( byte ) 161 , 8 , 35 , 66 , ( byte ) 177 , ( byte ) 193 , 21 , 82 , ( byte ) 209 , ( byte ) 240 , 36 , 51 , 98 , 114 , ( byte ) 130 , 9 , 10 , 22 , 23 , 24 , 25 , 26 , 37 , 38 , 39 , 40 , 41 , 42 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , ( byte ) 131 , ( byte ) 132 , ( byte ) 133 , ( byte ) 134 , ( byte ) 135 , ( byte ) 136 , ( byte ) 137 , ( byte ) 138 , ( byte ) 146 , ( byte ) 147 , ( byte ) 148 , ( byte ) 149 , ( byte ) 150 , ( byte ) 151 , ( byte ) 152 , ( byte ) 153 , ( byte ) 154 , ( byte ) 162 , ( byte ) 163 , ( byte ) 164 , ( byte ) 165 , ( byte ) 166 , ( byte ) 167 , ( byte ) 168 , ( byte ) 169 , ( byte ) 170 , ( byte ) 178 , ( byte ) 179 , ( byte ) 180 , ( byte ) 181 , ( byte ) 182 , ( byte ) 183 , ( byte ) 184 , ( byte ) 185 , ( byte ) 186 , ( byte ) 194 , ( byte ) 195 , ( byte ) 196 , ( byte ) 197 , ( byte ) 198 , ( byte ) 199 , ( byte ) 200 , ( byte ) 201 , ( byte ) 202 , ( byte ) 210 , ( byte ) 211 , ( byte ) 212 , ( byte ) 213 , ( byte ) 214 , ( byte ) 215 , ( byte ) 216 , ( byte ) 217 , ( byte ) 218 , ( byte ) 225 , ( byte ) 226 , ( byte ) 227 , ( byte ) 228 , ( byte ) 229 , ( byte ) 230 , ( byte ) 231 , ( byte ) 232 , ( byte ) 233 , ( byte ) 234 , ( byte ) 241 , ( byte ) 242 , ( byte ) 243 , ( byte ) 244 , ( byte ) 245 , ( byte ) 246 , ( byte ) 247 , ( byte ) 248 , ( byte )", "gt": "249 , ( byte ) 250 }", "prediction": ";\n", "label": 1}
{"id": 9474, "input": "<s> package fake . net ; import java . io . IOException ; import java . net . DatagramPacket ; import java . net . InetAddress ; public class Test_MulticastSocket implements Runnable { private MulticastSocket m_socket = null ; private boolean m_initiator = false ; public Test_MulticastSocket ( String addr , boolean initiator ) throws Exception { m_socket = new MulticastSocket ( 3778 , addr ) ; m_socket . setInterface ( InetAddress . getByName ( addr ) ) ; m_socket . joinGroup ( InetAddress . getByName ( \"224.0.0.1\" ) ) ; m_initiator = initiator ; } public void run ( ) { try { if ( m_initiator ) { byte [ ] data = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 } ; DatagramPacket toBeSent = new DatagramPacket ( data , data . length , InetAddress . getByName ( \"224.0.0.1\" ) , 3778 ) ; m_socket . send ( toBeSent ) ; System . out . println ( \"Sent1\" ) ; byte [ ] buf = new byte [ 8192 ] ; DatagramPacket received = new DatagramPacket ( buf , 8192 ) ; m_socket . receive ( received ) ; System . out . println ( \"Received1\" ) ; byte [ ] buf2 = new byte [ 8192 ] ; DatagramPacket received2 = new DatagramPacket ( buf2 , 8192 ) ; m_socket . receive ( received2 ) ; System . out . println ( \"Received2\" ) ; byte [ ] buf3 = new byte [ 8192 ] ; DatagramPacket received3 = new DatagramPacket ( buf3 , 8192 ) ; m_socket . receive ( received3 ) ; System . out . println ( \"Received3\" ) ; byte [ ] buf4 = new byte [ 8192 ] ; DatagramPacket received4 = new DatagramPacket ( buf4 , 8192 ) ; m_socket . receive ( received4 ) ; System . out . println ( \"Received4\" ) ; byte [ ] data2 = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 } ; DatagramPacket toBeSent2 = new DatagramPacket ( data2 , data2 . length , InetAddress . getByName ( \"224.224.224.224\" ) , 3778 ) ; m_socket . send ( toBeSent2 ) ; System . out . println ( \"Sent close\" ) ; m_socket . close ( ) ; } else { byte [ ] buf = new byte [ 8192 ] ; DatagramPacket received = new DatagramPacket ( buf , 8192 ) ; m_socket . receive ( received ) ; byte [ ] data = received . getData ( ) ; DatagramPacket toBeSent = new DatagramPacket ( data , data . length , InetAddress . getByName ( \"224.0.0.1\" ) , 3778 ) ; m_socket . send ( toBeSent ) ; System . out . println ( \"Sent packet back\" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { try { Test_MulticastSocket test1 = new Test_MulticastSocket ( \"192.168.0.1\" , true ) ;", "gt": "Test_MulticastSocket test2 = new Test_MulticastSocket ( \"192.168.0.2\" , false ) ;", "prediction": "}\n", "label": 0}
{"id": 12114, "input": "<s> package odatademo ; import java . util . Date ; import odatademo . Category ; import odatademo . Supplier ; public class Product { private String description ; private Date discontinuedDate ; private int id ; private String name ; private double price ; private int rating ; private Date releaseDate ; private Category category ; private Supplier supplier ; public Product ( ) { super ( ) ; } public Product ( int id ) { this ( ) ; this . id = id ; } public String getDescription ( ) { return description ; } public Date getDiscontinuedDate ( ) { return discontinuedDate ; } public int getId ( ) { return id ; } public String getName ( ) { return name ; } public double getPrice ( ) { return price ; } public int getRating ( ) { return rating ; } public Date getReleaseDate ( ) { return releaseDate ; } public Category getCategory ( ) { return category ; } public Supplier getSupplier ( ) { return supplier ; } public void setDescription ( String description ) { this . description = description ; } public void setDiscontinuedDate ( Date discontinuedDate ) { this . discontinuedDate = discontinuedDate ; } public void setId ( int id ) {", "gt": "this . id = id ;", "prediction": "\n", "label": 1}
{"id": 1147, "input": "<s> package org . ofbiz . minilang . method . conditional ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . List ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangUtil ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class ValidateMethodCondition extends MethodOperation implements Conditional { public static final String module = ValidateMethodCondition . class . getName ( ) ; private static final Class < ? > [ ] paramTypes = new Class < ? > [ ] { String . class } ; private final String className ; private final FlexibleMapAccessor < Object > fieldFma ; private final String methodName ; private final List < MethodOperation > elseSubOps ; private final List < MethodOperation > subOps ; public ValidateMethodCondition ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" , \"method\" , \"class\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" , \"method\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"method\" , \"class\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; this . methodName = element . getAttribute ( \"method\" ) ; this . className = MiniLangValidate . checkAttribute ( element . getAttribute ( \"class\" ) , \"org.ofbiz.base.util.UtilValidate\" ) ; Element childElement = UtilXml . firstChildElement ( element ) ; if ( childElement != null && ! \"else\" . equals ( childElement . getTagName ( ) ) ) { this . subOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( element , simpleMethod ) ) ; } else { this . subOps = null ; } Element elseElement = UtilXml . firstChildElement ( element , \"else\" ) ; if ( elseElement != null ) { this . elseSubOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( elseElement , simpleMethod ) ) ; } else { this . elseSubOps = null ; } } @ Override public boolean checkCondition ( MethodContext methodContext ) throws MiniLangException { Object fieldVal = fieldFma . get ( methodContext . getEnvMap ( ) ) ; if ( fieldVal == null ) { fieldVal = \"\" ; } else if ( ! ( fieldVal instanceof String ) ) { try { fieldVal = MiniLangUtil . convertType ( fieldVal , String . class , methodContext . getLocale ( ) , methodContext . getTimeZone ( ) , null ) ; } catch ( Exception e ) { throw new MiniLangRuntimeException ( e , this ) ; } } Object [ ] params = new Object [ ] { fieldVal } ; try { Class < ? > valClass = methodContext . getLoader ( ) . loadClass ( className ) ; Method valMethod = valClass . getMethod ( methodName , paramTypes ) ; Boolean resultBool = ( Boolean ) valMethod . invoke ( null , params ) ; return resultBool . booleanValue ( ) ; } catch ( Exception e ) { throw new MiniLangRuntimeException ( e , this ) ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { if ( checkCondition ( methodContext ) ) { if ( this . subOps != null ) { return SimpleMethod . runSubOps ( subOps , methodContext ) ; } } else { if ( elseSubOps != null ) { return SimpleMethod . runSubOps ( elseSubOps , methodContext ) ; } } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { if ( this . subOps != null ) { for ( MethodOperation method : this . subOps ) { method . gatherArtifactInfo ( aic ) ; } } if ( this . elseSubOps != null ) { for ( MethodOperation method : this . elseSubOps ) { method . gatherArtifactInfo ( aic ) ; } } }", "gt": "public void prettyPrint ( StringBuilder messageBuffer , MethodContext methodContext )", "prediction": "}\n", "label": 0}
{"id": 12122, "input": "<s> import java . util . * ; public class A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int zMin = input . nextInt ( ) ; int zMax = input . nextInt ( ) ; Triple [ ] points = new Triple [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] = new Triple ( input . nextInt ( ) , input . nextInt ( ) , input . nextInt ( ) ) ; } aero ( n , zMin , zMax , points ) ; } public static void aero ( int n , int zMin , int zMax , Triple [ ] points ) { for ( int i = zMin ; i <= zMax ; i ++ ) { ArrayList < Point > hullPoints = new ArrayList < Point > ( ) ; ArrayList < Triple > lessThan = new ArrayList < Triple > ( ) ; ArrayList < Triple > greaterThan = new ArrayList < Triple > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( points [ j ] . z < i ) lessThan . add ( points [ j ] ) ; else if ( points [ j ] . z > i ) greaterThan . add ( points [ j ] ) ; else hullPoints . add ( new Point ( ( double ) points [ j ] . x , ( double ) points [ j ] . y ) ) ; } for ( int j = 0 ; j < lessThan . length ; j ++ ) { Triple p1 = lessThan . get ( j ) ; int dLeft = Math . abs ( i - p1 . z ) ; for ( int k = 0 ; k < greaterThan . length ; k ++ ) { Triple p2 = greaterThan . get ( k ) ; int dx = p2 . x - p1 . x ; int dy = p2 . y - p1 . y ; int dz = p2 . z - p1 . z ; double x = ( double ) dx / ( double ) dz * ( double ) dLeft + ( double ) p1 . x ; double y = ( double ) dy / ( double ) dz * ( double ) dLeft +", "gt": "( double ) p1 . y ;", "prediction": ") ;\n", "label": 1}
{"id": 5906, "input": "<s> class GraphicalInstaller { private BackgroundInstaller backgroundInstaller ; private void installNext ( ) { final Integer x = 0 ; class X { Object o = new Object ( ) { int y = x ; } ; } ; new X ( ) ; if ( false ) { new Runnable ( ) { public void run ( ) { } } ; } } private void installSuiteCommon ( ) {", "gt": "backgroundInstaller = new BackgroundInstaller ( ) ;", "prediction": "\n", "label": 0}
{"id": 12124, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import org . eclipse . rap . rwt . internal . util . HTTP ; import org . eclipse . rap . rwt . resources . IResourceManager ; import org . eclipse . rap . rwt . resources . IResourceManager . RegisterOptions ; public class JSLibraryConcatenator { private final IResourceManager resourceManager ; private ContentBuffer jsBuffer ; private String location ; public JSLibraryConcatenator ( IResourceManager resourceManager ) { this . resourceManager = resourceManager ; } public void startJSConcatenation ( ) { jsBuffer = new ContentBuffer ( ) ; } public void appendJSLibrary ( byte [ ] content ) { if ( jsBuffer != null ) { jsBuffer . append ( content ) ; } } public String getLocation ( ) { return location ; } public void activate ( ) { synchronized ( JSLibraryConcatenator . class ) { if ( location == null ) {", "gt": "byte [ ] content = readContent ( ) ;", "prediction": "\n", "label": 1}
{"id": 447, "input": "<s> package org . ofbiz . base . container ; import java . net . UnknownHostException ; import java . rmi . registry . Registry ; import java . rmi . registry . LocateRegistry ; import java . rmi . RemoteException ; import java . rmi . NoSuchObjectException ; import java . rmi . server . UnicastRemoteObject ; import org . ofbiz . base . util . RMIExtendedSocketFactory ; public class NamingServiceContainer implements Container { public static final String module = NamingServiceContainer . class . getName ( ) ; protected String configFileLocation = null ; protected boolean isRunning = false ; protected Registry registry = null ; protected int namingPort = 1099 ; protected String namingHost = null ; protected RMIExtendedSocketFactory rmiSocketFactory ; private String name ; public void init ( String [ ] args , String name , String configFile ) throws ContainerException { this . name = name ; this . configFileLocation = configFile ; ContainerConfig . Container cfg = ContainerConfig . getContainer ( name , configFileLocation ) ; ContainerConfig . Container . Property port = cfg . getProperty ( \"port\" ) ; if ( port . value != null ) { try { this . namingPort = Integer . parseInt ( port . value ) ; } catch ( Exception e ) { throw new ContainerException ( \"Invalid port defined in container [naming-container]", "gt": "configuration; not a valid int\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12141, "input": "<s> package com . ovea . i18n ; import java . util . Locale ; public interface I18NService { I18NBundle", "gt": "forLocale ( Locale locale ) ;", "prediction": ";\n", "label": 1}
{"id": 184, "input": "<s> import java . io . * ; import java . util . Arrays ; import javax . tools . * ; public class T6258271 { public static void main ( String ... args ) { JavaCompiler javac = ToolProvider . getSystemJavaCompiler ( ) ; DiagnosticListener < JavaFileObject > dl = new DiagnosticListener < JavaFileObject > ( ) { public void report ( Diagnostic < ? extends JavaFileObject > message ) { JavaFileObject fo = message . getSource ( ) ; if ( \"__input\" . equals ( fo . toUri ( ) . getPath ( ) ) ) throw new AssertionError ( fo ) ; System . out . println ( message ) ; } } ; StandardJavaFileManager fm = javac . getStandardFileManager ( dl , null , null ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromStrings ( Arrays . asList", "gt": "( \"nofile.java\" ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12154, "input": "<s> package org . restlet . ext . velocity ; import java . io . IOException ; import java . io . Writer ; import java . util . Date ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . logging . Level ; import org . apache . velocity . Template ; import org . apache . velocity . VelocityContext ; import org . apache . velocity . app . VelocityEngine ; import org . apache . velocity . exception . ParseErrorException ; import org . apache . velocity . exception . ResourceNotFoundException ; import org . apache . velocity . runtime . RuntimeSingleton ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; import org . restlet . representation . Representation ; import org . restlet . representation . WriterRepresentation ; import org . restlet . util . Resolver ; public class TemplateRepresentation extends WriterRepresentation { private class ResolverContext implements org . apache . velocity . context . Context { private final Resolver < ? extends Object > resolver ; public ResolverContext ( Resolver < ? extends Object > resolver ) { super ( ) ; this . resolver = resolver ; } public boolean containsKey ( Object key ) { return this . resolver . resolve ( ( String ) key ) != null ; } public Object get ( String key ) { return this . resolver . resolve ( key ) ; } public Object [ ] getKeys ( ) { return null ; } public Object put ( String key , Object value ) { return null ; } public Object remove ( Object value ) { return null ; } } private volatile org . apache . velocity . context . Context context ; private volatile VelocityEngine engine ; private volatile Template template ; private volatile String templateName ; public TemplateRepresentation ( Representation templateRepresentation , Map < String , Object > dataModel , MediaType mediaType ) throws ResourceNotFoundException , ParseErrorException , IOException { super ( mediaType ) ; setDataModel ( dataModel ) ; this . engine = null ; this . template = new Template ( ) ; CharacterSet charSet = ( templateRepresentation . getCharacterSet ( ) != null ) ? templateRepresentation . getCharacterSet ( ) : CharacterSet . DEFAULT ; this . template . setEncoding ( charSet . getName ( ) ) ; if ( templateRepresentation . getModificationDate ( ) != null ) { this . template . setLastModified ( templateRepresentation . getModificationDate ( ) . getTime ( ) ) ; } this . template . setName ( \"org.restlet.resource.representation\" ) ; this . template . setRuntimeServices ( RuntimeSingleton . getRuntimeServices ( ) ) ; this . template . setResourceLoader ( new RepresentationResourceLoader ( templateRepresentation ) ) ; this . template . process ( ) ; this . templateName = null ; } public TemplateRepresentation ( Representation templateRepresentation , MediaType mediaType ) throws ResourceNotFoundException , ParseErrorException , IOException { super ( mediaType ) ; this . engine = null ; this . template = new Template ( ) ; CharacterSet charSet = ( templateRepresentation . getCharacterSet ( ) != null ) ? templateRepresentation . getCharacterSet ( ) : CharacterSet . DEFAULT ; this . template . setEncoding ( charSet . getName ( ) ) ; this . template . setLastModified ( ( templateRepresentation . getModificationDate ( ) == null ) ? new Date ( ) . getTime ( ) : templateRepresentation . getModificationDate ( ) . getTime ( ) ) ; this . template . setName ( \"org.restlet.resource.representation\" ) ; this . template . setRuntimeServices ( RuntimeSingleton . getRuntimeServices ( ) ) ; this . template . setResourceLoader ( new RepresentationResourceLoader ( templateRepresentation ) ) ; this . template . process ( ) ; this . templateName = null ; } public TemplateRepresentation ( String templateName , Map < String , Object > dataModel , MediaType mediaType ) { super ( mediaType ) ; try { setDataModel ( dataModel ) ; this . engine = new VelocityEngine ( ) ; this . template = null ; this . templateName = templateName ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public TemplateRepresentation ( String templateName , MediaType mediaType ) { this ( templateName , new ConcurrentHashMap < String , Object > ( ) , mediaType ) ; } public TemplateRepresentation ( Template template , Map < String , Object > dataModel , MediaType mediaType ) { super ( mediaType ) ; setDataModel ( dataModel ) ; this . engine = null ; this . template = template ; this . templateName = null ; } public TemplateRepresentation ( Template template , MediaType mediaType ) { super ( mediaType ) ; this . engine = null ; this . template = template ; this", "gt": ". templateName = null ;", "prediction": ";\n", "label": 1}
{"id": 4889, "input": "<s> package org . ofbiz . pos . adaptor ; import jpos . events . ErrorEvent ; public class ErrorEventAdaptor implements jpos . events . ErrorListener {", "gt": "public void errorOccurred ( ErrorEvent event )", "prediction": ";\n", "label": 0}
{"id": 12187, "input": "<s> package org . nuxeo . ecm . platform . webengine . jsf . wiki ; import static org . jboss . seam . ScopeType . CONVERSATION ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . HashMap ; import java . util . Map ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . platform . rendering . api . RenderingException ; import org . nuxeo . ecm . platform . rendering . api . ResourceLocator ; import org . nuxeo . ecm . platform . rendering . fm . FreemarkerEngine ; import org . nuxeo . ecm . platform . rendering . wiki . WikiSerializer ; import org . nuxeo . ecm . platform . rendering . wiki . WikiTransformer ; import org . nuxeo . ecm . platform . rendering . wiki . extensions . FreemarkerMacro ; import org . nuxeo . ecm . platform . rendering . wiki . extensions . PatternFilter ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . wikimodel . wem . WikiParserException ; @ Name ( \"wikiPreviewkActions\" ) @ Scope ( CONVERSATION ) public class WikiPreviewBean { @ In ( create = true ) private NavigationContext navigationContext ; protected FreemarkerEngine engine ; private boolean initDone = false ; public String getSimpleWikiPagePreview ( ) throws IOException , WikiParserException { DocumentModel doc = navigationContext . getCurrentDocument ( ) ; if ( doc == null || ! \"WikiPage\" . equals ( doc . getType ( ) ) ) { return \"\" ; } else { return getSimplePreview ( doc ) ; } } public String getWikiPagePreview ( ) throws RenderingException { DocumentModel doc = navigationContext . getCurrentDocument ( ) ; if ( doc == null || ! \"WikiPage\" .", "gt": "equals ( doc . getType ( ) ) )", "prediction": ") ;\n", "label": 1}
{"id": 3015, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; import java . util . Map ; import java . util . HashMap ; import java . io . * ; import java . net . * ; public class Extern { private Map < String , Item > packageToItemMap ; private final Configuration configuration ; private boolean linkoffline = false ; private class Item { final String packageName ; final String path ; final boolean relative ; Item ( String packageName , String path , boolean relative ) { this . packageName = packageName ; this . path = path ; this . relative = relative ; if ( packageToItemMap == null ) { packageToItemMap = new HashMap < String , Item > ( ) ; } if ( ! packageToItemMap . containsKey ( packageName ) ) { packageToItemMap . put ( packageName , this ) ; } } public String toString ( ) { return packageName + ( relative ? \" -> \" : \" => \" ) + path ; } } public Extern ( Configuration configuration ) { this . configuration = configuration ; } public boolean isExternal ( ProgramElementDoc doc ) { if ( packageToItemMap == null ) { return false ; } return packageToItemMap . get ( doc . containingPackage ( ) . name ( ) ) != null ; } public String getExternalLink ( String pkgName , String relativepath , String link ) { Item fnd = findPackageItem ( pkgName ) ; if ( fnd != null ) { String externlink = fnd . path + link ; if ( fnd . relative ) { return relativepath + externlink ; } else { return externlink ; } } return null ; } public boolean url ( String url , String pkglisturl , DocErrorReporter reporter , boolean linkoffline ) { this . linkoffline = linkoffline ; String errMsg = composeExternPackageList ( url , pkglisturl ) ; if ( errMsg != null ) { reporter . printWarning ( errMsg ) ; return false ; } else { return true ; } } private Item findPackageItem ( String pkgName ) { if ( packageToItemMap == null ) { return null ; } return packageToItemMap . get ( pkgName ) ; } private String composeExternPackageList ( String urlOrDirPath , String pkgListUrlOrDirPath ) { urlOrDirPath = adjustEndFileSeparator ( urlOrDirPath ) ; pkgListUrlOrDirPath = adjustEndFileSeparator ( pkgListUrlOrDirPath ) ; return isUrl ( pkgListUrlOrDirPath ) ? fetchURLComposeExternPackageList ( urlOrDirPath , pkgListUrlOrDirPath ) : readFileComposeExternPackageList ( urlOrDirPath , pkgListUrlOrDirPath ) ; } private String adjustEndFileSeparator ( String url ) { String filesep = \"/\" ; if ( ! url . endsWith ( filesep ) ) { url += filesep ; } return url ; }", "gt": "private String fetchURLComposeExternPackageList ( String urlpath , String pkglisturlpath )", "prediction": "}\n", "label": 0}
{"id": 12194, "input": "<s> package org . nuxeo . ecm . platform . annotations . repository . service ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . blobholder . BlobHolder ; import org . nuxeo . ecm . core . api . blobholder . SimpleBlobHolder ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; import org . nuxeo . ecm . core . convert . api . ConversionService ; import org . nuxeo . runtime . api . Framework ; public class AnnotationsFulltextInjector { public static final String RELATED_TEXT_PROPERTY = \"relatedtext\" ; public static final String RELATED_TEXT_ID_PROPERTY = \"relatedtextid\" ; public static final String RELATED_TEXT_LIST_PROPERTY = \"relatedtext:relatedtextresources\" ; public static final String ANNOTATION_RESOURCE_ID_PREFIX = \"annotation_\" ; public boolean removeAnnotationText ( DocumentModel doc , String annotationId ) throws ClientException { @ SuppressWarnings ( \"unchecked\" ) List < Map < String , String > > relatedResources = doc . getProperty ( RELATED_TEXT_LIST_PROPERTY ) . getValue ( List . class ) ; String resourceIdToRemove = annotationId == null ? null : makeResourceId ( annotationId ) ; List < Map < String , String > > resourcesToRemove = new ArrayList < Map < String , String > > ( ) ; for ( Map < String , String > resource : relatedResources ) { String resourceId = resource . get ( RELATED_TEXT_ID_PROPERTY ) ; if ( resourceIdToRemove != null ) { if ( resourceIdToRemove . equals ( resourceId ) ) { resourcesToRemove . add ( resource ) ; } } else { if ( resourceId == null || resourceId . startsWith ( ANNOTATION_RESOURCE_ID_PREFIX ) ) { resourcesToRemove . add ( resource ) ; } } } if ( ! resourcesToRemove . isEmpty ( ) ) { relatedResources . removeAll ( resourcesToRemove ) ; doc . setPropertyValue ( RELATED_TEXT_LIST_PROPERTY , ( Serializable ) relatedResources ) ; return true ; } return false ; } public void setAnnotationText ( DocumentModel doc , String annotationId , String annotationBody ) throws ClientException { if ( annotationBody == null ) { return ; } try { BlobHolder bh = new SimpleBlobHolder ( new StringBlob ( annotationBody , \"text/html\" ) ) ; ConversionService service = Framework . getService ( ConversionService . class ) ; if ( service != null ) { annotationBody = service . convert ( \"html2text\" , bh , null ) . getBlob ( ) . getString ( ) ; } } catch ( Exception e ) { throw new", "gt": "RuntimeException ( e ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4556, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . selection ; import java . util . ArrayList ; import java . util . List ; import org . dawb . common . ui . plot . axis . ICoordinateSystem ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegionContainer ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . workbench . plotting . system . swtxy . translate . FigureTranslator ; import org . dawb . workbench . plotting . system . swtxy . translate . TranslationEvent ; import org . dawb . workbench . plotting . system . swtxy . translate . TranslationListener ; import org . dawb . workbench . plotting . system . swtxy . util . Draw2DUtils ; import org . dawb . workbench . plotting . system . swtxy . util . Sector ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . FigureListener ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . geometry . Dimension ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . PointList ; import org . eclipse . draw2d . geometry . PrecisionPoint ; import org . eclipse . draw2d . geometry . Rectangle ; import uk . ac . diamond . scisoft . analysis . rcp . plotting . roi . HandleStatus ; import uk . ac . diamond . scisoft . analysis . rcp . plotting . roi . SectorROIHandler ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . SectorROI ; public class SectorSelection extends AbstractSelectionRegion { DecoratedSector sector ; public SectorSelection ( String name , ICoordinateSystem coords ) { super ( name , coords ) ; setRegionColor ( ColorConstants . red ) ; setAlpha ( 80 ) ; setLineWidth ( 2 ) ; } @ Override public void createContents ( Figure parent ) { sector = new DecoratedSector ( parent ) ; sector . setCursor ( Draw2DUtils . getRoiMoveCursor ( ) ) ; parent . add ( sector ) ; sync ( getBean ( ) ) ; sector . setForegroundColor ( getRegionColor ( ) ) ; sector . setAlpha ( getAlpha ( ) ) ; sector . setLineWidth ( getLineWidth ( ) ) ; updateROI ( ) ; if ( roi == null ) createROI ( true ) ; } @ Override public boolean containsPoint ( double x , double y ) { final int [ ] pix = coords . getValuePosition ( x , y ) ; return sector . containsPoint ( pix [ 0 ] , pix [ 1 ] ) ; } @ Override public RegionType getRegionType ( ) { return RegionType . SECTOR ; } @ Override protected void updateConnectionBounds ( ) { if ( sector != null ) { sector . updateFromHandles ( ) ; Rectangle b = sector . getBounds ( ) ; if ( b != null ) sector . setBounds ( b ) ; } } @ Override public void paintBeforeAdded ( Graphics g , PointList clicks , Rectangle parentBounds ) { if ( clicks . size ( ) < 2 ) return ; g . setLineStyle ( Graphics . LINE_DOT ) ; g . setForegroundColor ( getRegionColor ( ) ) ; g . setAlpha ( getAlpha ( ) ) ; final Point cen = clicks . getFirstPoint ( ) ; Point inn = clicks . getPoint ( 1 ) ; Dimension rd = inn . getDifference ( cen ) ; final double ri = Math . hypot ( rd . preciseWidth ( ) , rd . preciseHeight ( ) ) ; if ( clicks . size ( ) == 2 ) { g . setLineWidth ( getLineWidth ( ) ) ; g . drawOval ( ( int ) ( cen . preciseX ( ) - ri ) , ( int ) ( cen . preciseY ( ) - ri ) , ( int ) ( 2 * ri ) , ( int ) ( 2 * ri ) ) ; } else { double as = Math . toDegrees ( Math . atan2 ( - rd . preciseHeight ( ) , rd . preciseWidth ( ) ) ) ; Point out = clicks . getPoint ( 2 ) ; rd = out . getDifference ( cen ) ; final double ro = Math . hypot ( rd . preciseWidth ( ) , rd . preciseHeight ( ) ) ; double ae = Math . toDegrees ( Math . atan2 ( - rd . preciseHeight ( ) , rd . preciseWidth ( ) ) ) ; double [ ] a = calcAngles ( as , ae ) ; Sector s = new Sector ( cen . preciseX ( ) , cen . preciseY ( ) , ri , ro , a [ 0 ] , a [ 1 ] ) ; s . setLineStyle ( Graphics . LINE_DOT ) ; s . setLineWidth ( getLineWidth ( ) ) ; s . paintFigure ( g ) ; } } private Boolean clockwise = null ; private double [ ] calcAngles ( double anglea , double angleb ) { if ( anglea < 0 ) anglea += 360 ; if ( angleb < 0 ) angleb += 360 ; if ( clockwise == null ) { if ( anglea == 0 ) { clockwise = angleb > 180 ; } else { clockwise = anglea > angleb ; } } double l ; if ( clockwise ) { if ( anglea < 180 ) { if ( angleb < 180 ) { l = angleb - anglea ; if ( l > 0 ) l -= 360 ; } else l = angleb - 360 - anglea ; } else { if ( angleb < 180 ) { l = angleb - anglea ; } else { l = angleb - anglea ; if ( l > 0 ) l -= 360 ; } } } else { if ( anglea < 180 ) { if ( angleb < 180 ) { l = angleb - anglea ; if ( l < 0 ) l += 360 ; } else l = angleb - anglea ; } else { if ( angleb < 180 ) l =", "gt": "angleb - anglea + 360 ;", "prediction": ";\n", "label": 0}
{"id": 12203, "input": "<s> package org . nuxeo . ecm . automation . client . jaxrs . test ; import org . nuxeo . ecm . automation . client . RemoteException ; import org . nuxeo . ecm . automation . client . Session ; import org . nuxeo . ecm . automation . client . adapters . DocumentService ; import org . nuxeo . ecm . automation . client . jaxrs . impl . HttpAutomationClient ; import org . nuxeo . ecm . automation . client . model . Document ; import org . nuxeo . ecm . automation . client . model . Documents ; public class SampleQuery { public static void main ( String [ ] args ) throws Exception { try { HttpAutomationClient client = new HttpAutomationClient ( \"http://localhost:8080/nuxeo/site/automation\" ) ; Session session = client . getSession ( \"Administrator\" , \"Administrator\" ) ; DocumentService rs = session . getAdapter ( DocumentService . class ) ; Documents docs = rs . query ( \"SELECT * from Workspace\" ) ; System . out . println ( docs ) ; for ( Document d : docs ) { System . out . println ( d . getTitle ( ) + \" at \" + d . getLastModified ( ) + \" facets :\" + d . getFacets ( ) + \" token:\"", "gt": "+ d . getChangeToken ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7641, "input": "<s> package com . mcbans . mcbans . commands ; import com . mcbans . mcbans . MCBansPlugin ; import org . bukkit . command . Command ; import org . bukkit . command . CommandExecutor ; import org . bukkit . command . CommandSender ; public class BaseCommand implements CommandExecutor { private final MCBansPlugin MCBans ; public BaseCommand ( MCBansPlugin plugin ) { this", "gt": ". MCBans = plugin ;", "prediction": ";\n", "label": 0}
{"id": 12212, "input": "<s> package org . eclipse . jface . action ; import java . io . Serializable ; public interface IMenuListener extends Serializable { public void menuAboutToShow", "gt": "( IMenuManager manager ) ;", "prediction": "( )\n", "label": 1}
{"id": 8839, "input": "<s> package com . sun . tools . javac . jvm ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . jvm . Code . * ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . util . Assert ; import static com . sun . tools . javac . jvm . ByteCodes . * ; public class Items { Pool pool ; Code code ; Symtab syms ; Types types ; private final Item voidItem ; private final Item thisItem ; private final Item superItem ; private final Item [ ] stackItem = new Item [ TypeCodeCount ] ; public Items ( Pool pool , Code code , Symtab syms , Types types ) { this . code = code ; this . pool = pool ; this . types = types ; voidItem = new Item ( VOIDcode ) { public String toString ( ) { return \"void\" ; } } ; thisItem = new SelfItem ( false ) ; superItem = new SelfItem ( true ) ; for ( int i = 0 ; i < VOIDcode ; i ++ ) stackItem [ i ] = new StackItem ( i ) ; stackItem [ VOIDcode ] = voidItem ; this . syms = syms ; } Item makeVoidItem ( ) { return voidItem ; } Item makeThisItem ( ) { return thisItem ; } Item makeSuperItem ( ) { return superItem ; } Item makeStackItem ( Type type ) { return stackItem [ Code . typecode ( type ) ] ; } Item makeIndexedItem ( Type type ) { return new IndexedItem ( type ) ; } LocalItem makeLocalItem ( VarSymbol v ) { return new LocalItem ( v . erasure ( types ) , v . adr ) ; } private LocalItem makeLocalItem ( Type type , int reg ) { return new LocalItem ( type , reg ) ; } Item makeStaticItem ( Symbol member ) { return new StaticItem ( member ) ; } Item makeMemberItem ( Symbol member , boolean nonvirtual ) { return new MemberItem ( member , nonvirtual ) ; } Item makeImmediateItem ( Type type , Object value ) { return new ImmediateItem ( type , value ) ; } Item makeAssignItem ( Item lhs ) { return new AssignItem ( lhs ) ; } CondItem makeCondItem ( int opcode , Chain trueJumps , Chain falseJumps ) { return new CondItem ( opcode , trueJumps , falseJumps ) ; } CondItem makeCondItem ( int opcode ) { return makeCondItem (", "gt": "opcode , null , null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12222, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class Mailboxes_Images_default_StaticClientBundleGenerator implements org . restlet . example . book . restlet . ch09 . client . Mailboxes . Images { private static Mailboxes_Images_default_StaticClientBundleGenerator _instance0 = new Mailboxes_Images_default_StaticClientBundleGenerator ( ) ; private void draftsInitializer ( ) { drafts = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"drafts\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 80 , 0 , 16 , 16 , false , false ) ; } private static class draftsInitializer { static { _instance0 . draftsInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return drafts ; } } public com . google . gwt . resources . client . ImageResource drafts ( ) { return draftsInitializer . get ( ) ; } private void homeInitializer ( ) { home = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"home\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 64 , 0 , 16 , 16 , false , false ) ; } private static class homeInitializer { static { _instance0 . homeInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return home ; } } public com . google . gwt . resources . client . ImageResource home ( ) { return homeInitializer . get ( ) ; } private void inboxInitializer ( ) { inbox = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"inbox\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 48 , 0 , 16 , 16 , false , false ) ; } private static class inboxInitializer { static { _instance0 . inboxInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return inbox ; } } public com . google . gwt . resources . client . ImageResource inbox ( ) { return inboxInitializer . get ( ) ; } private void sentInitializer ( ) { sent = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"sent\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 32 , 0 , 16 , 16 , false , false ) ; } private static class sentInitializer { static { _instance0 . sentInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return sent ; } } public com . google . gwt . resources . client . ImageResource sent ( ) { return sentInitializer . get ( ) ; } private void templatesInitializer ( ) { templates = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"templates\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 16 , 0 , 16 , 16 , false , false ) ; } private static class templatesInitializer { static { _instance0 . templatesInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return templates ; } } public com . google . gwt . resources . client . ImageResource templates ( ) { return templatesInitializer . get ( ) ; } private void trashInitializer ( ) { trash = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"trash\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 0 , 0 , 16 , 16 , false , false ) ; } private static class trashInitializer { static { _instance0 . trashInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return trash ; } } public com . google . gwt . resources . client . ImageResource trash ( ) { return trashInitializer . get ( ) ; } private void treeClosedInitializer ( ) { treeClosed = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"treeClosed\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( bundledImage_None ) , 112 , 0 , 16 , 16 , false , false ) ; } private static class treeClosedInitializer { static { _instance0 . treeClosedInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return treeClosed ; } } public com . google", "gt": ". gwt . resources . client . ImageResource treeClosed ( )", "prediction": ";\n", "label": 1}
{"id": 497, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . navigator ; import org . eclipse . jface . viewers . ViewerSorter ; import org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry ; public class SimplemapNavigatorSorter extends ViewerSorter {", "gt": "private static final int GROUP_CATEGORY = 2006 ;", "prediction": "return ;\n", "label": 0}
{"id": 12232, "input": "<s> package org . seage . metaheuristic . tabusearch ; import java . text . * ; import java . util . * ; public class SolutionAdapter implements Solution { private static final long serialVersionUID = 7111455134039448412L ; private double [ ] objectiveValue ; public final double [ ] getObjectiveValue ( ) { return this . objectiveValue ; } public final void setObjectiveValue ( double [ ] objValue ) { this . objectiveValue = objValue ; } public Object clone ( ) { try { Solution sol = ( Solution ) super . clone ( ) ; double [ ] copyThisObjVal = getObjectiveValue ( ) ; if ( copyThisObjVal != null ) { this . objectiveValue = ( double [ ] ) copyThisObjVal . clone ( ) ; } return sol ; } catch (", "gt": "java . lang . CloneNotSupportedException e )", "prediction": ")\n", "label": 1}
{"id": 2915, "input": "<s> public class TestUseOption extends JavadocTester { private static final String BUG_ID = \"4496290-4985072-7006178\" ; private static final String [ ] TEST2 = { \"Field in C1.\" , \"Field in C2.\" , \"Field in C4.\" , \"Field in C5.\" , \"Field in C6.\" , \"Field in C7.\" , \"Field in C8.\" , \"Method in C1.\" , \"Method in C2.\" , \"Method in C4.\" , \"Method in C5.\" , \"Method in C6.\" , \"Method in C7.\" , \"Method in C8.\" , } ; private static final String [ ] [ ] TEST3 = { { BUG_ID + \"-3\" + FS + \"class-use\" + FS + \"UsedInC.html\" , \"Uses of <a href=\" + \"\\\"../UsedInC.html\\\" title=\\\"class in &lt;Unnamed&gt;\\\">\" + \"UsedInC</a> in <a href=\\\"../package-summary.html\\\">&lt;Unnamed&gt;</a>\" } , { BUG_ID + \"-3\" + FS + \"package-use.html\" , \"<td class=\\\"colOne\\\">\" + \"<a href=\\\"class-use/UsedInC.html#&lt;Unnamed&gt;\\\">UsedInC</a>&nbsp;</td>\" } } ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"-use\" , \"pkg1\" , \"pkg2\" } ; private static final String [ ] ARGS2 = new String [ ] { \"-d\" , BUG_ID + \"-2\" , \"-sourcepath\" , SRC_DIR , \"-use\" , \"pkg1\" , \"pkg2\" } ; private static final String [ ] ARGS3 = new String [ ] { \"-d\" , BUG_ID + \"-3\" , \"-sourcepath\" , SRC_DIR , \"-use\" , SRC_DIR + FS + \"C.java\" , SRC_DIR + FS + \"UsedInC.java\" } ; public static void main ( String [ ] args ) throws Exception { String [ ] [ ] tests = new String [ 11 ] [ 2 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { tests [ i ] [ 0 ] = BUG_ID + FS + \"pkg1\" + FS + \"class-use\" + FS + \"C1.html\" ; tests [ i ] [ 1 ] = \"Test \" + ( i + 1 ) + \" passes\" ; } for ( int i = 8 , j = 1 ; i < tests . length ; i ++ , j ++ ) { tests [ i ] [ 0 ] = BUG_ID + FS + \"pkg1\" + FS + \"package-use.html\" ; tests [ i ] [", "gt": "1 ] = \"Test \" + j + \" passes\" ;", "prediction": ") ;\n", "label": 0}
{"id": 12237, "input": "<s> package com . cloudera . sqoop . io ; import java . io . File ; public class NamedFifo extends org . apache . sqoop . io . NamedFifo { public NamedFifo ( String pathname ) {", "gt": "super ( pathname ) ;", "prediction": ";\n", "label": 1}
{"id": 8485, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . FigureListener ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . RectangleFigure ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . editpolicies . SelectionEditPolicy ; import org . eclipse . gmf . runtime . draw2d . ui . figures . WrappingLabel ; public class SimplemapTextSelectionEditPolicy extends SelectionEditPolicy { private IFigure selectionFeedbackFigure ; private IFigure focusFeedbackFigure ; private FigureListener hostPositionListener ; protected void showPrimarySelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { showSelection ( ) ; showFocus ( ) ; } } protected void showSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { hideSelection ( ) ; addFeedback ( selectionFeedbackFigure = createSelectionFeedbackFigure ( ) ) ; getHostFigure ( ) . addFigureListener ( getHostPositionListener ( ) ) ; refreshSelectionFeedback ( ) ; hideFocus ( ) ; } } protected void hideSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( false ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( selectionFeedbackFigure != null ) { removeFeedback ( selectionFeedbackFigure ) ; getHostFigure ( ) . removeFigureListener ( getHostPositionListener ( ) ) ; selectionFeedbackFigure = null ; } hideFocus ( ) ; } } protected void showFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { hideFocus ( ) ; addFeedback ( focusFeedbackFigure = createFocusFeedbackFigure ( ) ) ; refreshFocusFeedback ( ) ; } } protected void hideFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( focusFeedbackFigure != null ) { removeFeedback ( focusFeedbackFigure ) ; focusFeedbackFigure = null ; } } } protected Rectangle getFeedbackBounds ( ) { Rectangle bounds ; if ( getHostFigure ( ) instanceof Label ) { bounds = ( ( Label ) getHostFigure ( ) ) . getTextBounds ( ) ; bounds . intersect ( getHostFigure ( ) . getBounds ( ) ) ; } else { bounds = getHostFigure ( ) . getBounds ( ) . getCopy ( ) ; } getHostFigure ( ) . getParent ( ) . translateToAbsolute ( bounds ) ; getFeedbackLayer ( ) . translateToRelative ( bounds ) ; return bounds ; } protected IFigure createSelectionFeedbackFigure ( ) { if ( getHostFigure ( ) instanceof Label ) { Label feedbackFigure = new Label ( ) ; feedbackFigure . setOpaque ( true ) ; feedbackFigure . setBackgroundColor ( ColorConstants . menuBackgroundSelected ) ; feedbackFigure . setForegroundColor ( ColorConstants . menuForegroundSelected ) ; return feedbackFigure ; } else { RectangleFigure feedbackFigure = new RectangleFigure ( ) ; feedbackFigure . setFill ( false ) ; return feedbackFigure ; } } protected IFigure createFocusFeedbackFigure ( ) { return new Figure ( ) { protected void paintFigure ( Graphics graphics ) { graphics . drawFocus ( getBounds ( ) . getResized ( - 1 , - 1 ) ) ; } } ; } protected void updateLabel ( Label target ) { Label source = ( Label ) getHostFigure ( ) ; target . setText ( source . getText ( ) ) ; target . setTextAlignment ( source . getTextAlignment ( ) ) ;", "gt": "target . setFont ( source . getFont ( ) ) ;", "prediction": "}\n", "label": 0}
{"id": 12240, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . widgets . Control ; public class ControlUtil { public static IControlAdapter getControlAdapter ( Control control ) { return control", "gt": ". getAdapter ( IControlAdapter . class ) ;", "prediction": ";\n", "label": 1}
{"id": 3057, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface Minimum extends LimitsAttribute", "prediction": "}\n", "label": 0}
{"id": 12244, "input": "<s> package org . apache . lucene . util ; public abstract class SorterTemplate { private static final int MERGESORT_THRESHOLD = 12 ; private static final int QUICKSORT_THRESHOLD = 7 ; abstract protected void swap ( int i , int j ) ; abstract protected int compare ( int i , int j ) ; public void quickSort ( int lo , int hi ) { quickSortHelper ( lo , hi ) ; insertionSort ( lo , hi ) ; } private void quickSortHelper ( int lo , int hi ) { for ( ; ; ) { int diff = hi - lo ; if ( diff <= QUICKSORT_THRESHOLD ) { break ; } int i = ( hi + lo ) / 2 ; if ( compare ( lo , i ) > 0 ) { swap ( lo , i ) ; } if ( compare ( lo , hi ) > 0 ) { swap ( lo , hi ) ; } if ( compare ( i , hi ) > 0 ) { swap ( i , hi ) ; } int j = hi - 1 ; swap ( i , j ) ; i = lo ; int v = j ; for ( ; ; ) { while ( compare ( ++ i , v ) < 0 ) { ; } while ( compare ( -- j , v ) > 0 ) { ; } if ( j < i ) { break ; } swap ( i , j ) ; } swap ( i , hi - 1 ) ; if ( j - lo <= hi - i + 1 ) { quickSortHelper ( lo , j ) ; lo = i + 1 ; } else { quickSortHelper ( i + 1 , hi ) ; hi = j ; } } } private void insertionSort ( int lo , int hi ) { for ( int i = lo + 1 ; i <= hi ; i ++ ) { for ( int j = i ; j > lo ; j -- ) { if ( compare ( j - 1 , j ) > 0 ) { swap ( j - 1 , j ) ; } else { break ; } } } } protected void mergeSort ( int lo , int hi ) { int diff = hi - lo ; if ( diff <= MERGESORT_THRESHOLD ) { insertionSort ( lo , hi ) ; return ; } int mid = lo + diff / 2 ; mergeSort ( lo , mid ) ; mergeSort ( mid , hi ) ; merge ( lo , mid , hi , mid - lo , hi - mid ) ; } private void merge ( int lo , int pivot , int hi", "gt": ", int len1 , int len2 )", "prediction": ") ;\n", "label": 1}
{"id": 2081, "input": "<s> package de . javawi . jstun . header ; public class MessageHeaderException extends Exception { private static final", "gt": "long serialVersionUID = 3689066248944103737L ;", "prediction": "\n", "label": 0}
{"id": 12246, "input": "<s> package org . restlet . example . ext . rdf . foaf . objects ; import java . util . List ; import org . restlet . example . ext . rdf . foaf . data . DataFacade ; public class ObjectsFacade { protected DataFacade dataFacade ; public ObjectsFacade ( DataFacade dataFacade ) { super ( ) ; this . dataFacade = dataFacade ; } public Contact createContact ( User user , Contact contact ) { contact = this . dataFacade . createContact ( user , contact ) ; user . getContacts ( ) . add ( contact ) ; this . dataFacade . updateUser ( user ) ; return contact ; } public User createUser ( User user ) throws ObjectsException { user = this . dataFacade . createUser ( user ) ; return user ; } public void deleteContact ( User user , Contact contact ) { boolean found = false ; for ( int i = 0 ; ( i < user . getContacts ( ) . size ( ) ) && ! found ; i ++ ) { final Contact contact2 = user . getContacts ( ) . get ( i ) ; if ( contact2 . getId ( ) . equals ( contact . getId ( ) ) ) { user . getContacts ( ) . remove ( i ) ; found = true ; } } this . dataFacade . deleteContact ( contact ) ; this . dataFacade . updateUser ( user ) ; } public void deleteUser ( User user ) { for ( final Contact contact : user . getContacts ( ) ) { this . dataFacade . deleteContact ( contact ) ; } this . dataFacade . deleteUser ( user ) ; } public Contact", "gt": "getContactById ( String contactId )", "prediction": "( )\n", "label": 1}
{"id": 4457, "input": "<s> package resources ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; public class MockedPrintWriter extends PrintWriter { private String text ; public MockedPrintWriter ( ) throws FileNotFoundException { super ( \"temp\" ) ; } @ Override public void write ( String text ) {", "gt": "this . text = text ;", "prediction": "\n", "label": 0}
{"id": 12248, "input": "<s> package com . cloudera . sqoop . mapreduce . db ; import java . sql . Connection ; import java . sql . SQLException ; import org . apache . hadoop . conf . Configuration ; import org . apache . sqoop . mapreduce . DBWritable ; public class DataDrivenDBRecordReader < T extends DBWritable > extends org . apache . sqoop . mapreduce . db . DataDrivenDBRecordReader < T > { public DataDrivenDBRecordReader ( DBInputFormat . DBInputSplit split , Class < T > inputClass , Configuration conf , Connection conn , DBConfiguration dbConfig , String cond , String [ ] fields , String table , String dbProduct ) throws SQLException { super ( split , inputClass , conf , conn , dbConfig", "gt": ", cond , fields , table , dbProduct ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2800, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . text . * ; import java . util . * ; import org . xbill . DNS . utils . * ; public abstract class Record implements Cloneable , Comparable , Serializable { private static final long serialVersionUID = 2694906050116005466L ; protected Name name ; protected int type , dclass ; protected long ttl ; private static final DecimalFormat byteFormat = new DecimalFormat ( ) ; static { byteFormat . setMinimumIntegerDigits ( 3 ) ; } protected Record ( ) { } Record ( Name name , int type , int dclass , long ttl ) { if ( ! name . isAbsolute ( ) ) throw new RelativeNameException ( name ) ; Type . check ( type ) ; DClass . check ( dclass ) ; TTL . check ( ttl ) ; this . name = name ; this . type = type ; this . dclass = dclass ; this . ttl = ttl ; } abstract Record getObject ( ) ; private static final Record getEmptyRecord ( Name name , int type , int dclass , long ttl , boolean hasData ) { Record proto , rec ; if ( hasData ) { proto = Type . getProto ( type ) ; if ( proto != null ) rec = proto . getObject ( ) ; else rec = new UNKRecord ( ) ; } else rec = new EmptyRecord ( ) ; rec . name = name ; rec . type = type ; rec . dclass = dclass ; rec . ttl = ttl ; return rec ; } abstract void rrFromWire ( DNSInput in ) throws IOException ; private static Record newRecord ( Name name , int type , int dclass , long ttl , int length , DNSInput in ) throws IOException { Record rec ; rec = getEmptyRecord ( name , type , dclass , ttl , in != null ) ; if ( in != null ) { if ( in . remaining ( ) < length ) throw new WireParseException ( \"truncated record\" ) ; in . setActive ( length ) ; rec . rrFromWire ( in ) ; if ( in . remaining ( ) > 0 ) throw new WireParseException ( \"invalid record length\" ) ; in . clearActive ( ) ; } return rec ; } public static Record newRecord ( Name name , int type , int dclass , long ttl , int length , byte [ ] data ) { if ( ! name . isAbsolute ( ) ) throw new RelativeNameException ( name ) ; Type . check ( type ) ; DClass . check ( dclass ) ; TTL . check ( ttl ) ; DNSInput in ; if ( data != null ) in = new DNSInput ( data ) ; else in = null ; try { return newRecord ( name , type , dclass , ttl , length , in ) ; } catch ( IOException e ) { return null ; } } public static Record newRecord ( Name name , int type , int dclass , long ttl , byte [ ] data ) { return newRecord ( name , type , dclass , ttl , data . length , data ) ; } public static Record newRecord ( Name name , int type , int dclass , long ttl ) { if ( ! name . isAbsolute ( ) ) throw new RelativeNameException ( name ) ; Type . check ( type ) ; DClass . check ( dclass ) ; TTL . check ( ttl ) ; return getEmptyRecord ( name , type , dclass , ttl , false ) ; } public static Record newRecord ( Name name , int type , int dclass ) { return newRecord ( name , type , dclass , 0 ) ; } static Record fromWire ( DNSInput in , int section , boolean isUpdate ) throws IOException { int type , dclass ; long ttl ; int length ; Name name ; Record rec ; name = new Name ( in ) ; type = in . readU16 ( ) ; dclass = in . readU16 ( ) ; if ( section == Section . QUESTION ) return newRecord ( name , type , dclass ) ; ttl = in . readU32 ( ) ; length = in . readU16 ( ) ; if ( length == 0 && isUpdate && ( section == Section . PREREQ || section == Section . UPDATE ) ) return newRecord ( name , type , dclass , ttl ) ; rec = newRecord ( name , type , dclass , ttl , length , in ) ; return rec ; } static Record fromWire ( DNSInput in , int section ) throws IOException { return fromWire ( in , section , false ) ; } public static Record fromWire ( byte [ ] b , int section ) throws IOException { return fromWire ( new DNSInput (", "gt": "b ) , section , false ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12251, "input": "<s> package scenes . WorldScene . WorldSystem ; import map . NPC ; import engine . Input ; import graphics . ContentPanel ; import graphics . NES ; import graphics . SFont ; import scenes . GameState ; import scenes . GameSystem ; public class DialogState extends GameState { SFont font = NES . font ; String [ ] dialog ; int index ; public DialogState ( GameSystem c ) { super ( c ) ; dialog = new String [ 0 ] ; } @ Override public void finish ( ) { parent . setNextState ( ) ; } @ Override public void handle ( ) { } @ Override public void handleKeyInput ( int key ) { if ( key == Input . KEY_A ) { index += 3 ; if ( index >= dialog . length ) finish ( ) ; } } @ Override public void start ( ) { NPC n", "gt": "= ( ( WorldSystem ) parent ) . activeNPC ;", "prediction": "\n", "label": 1}
{"id": 5851, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . Silverfish ; import Liza . LizaSilverfish ; public class LizaCraftSilverfish extends LizaCraftMonster implements LizaSilverfish { public LizaCraftSilverfish ( Silverfish silverfish ) { super ( silverfish ) ; } @ Override public Silverfish getBukkitHandle ( ) { return (", "gt": "Silverfish ) this . entity ;", "prediction": ") ;\n", "label": 0}
{"id": 12280, "input": "<s> package ru . spbstu . telematics . objectCatalog ; import java . io . IOException ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class AddClassServlet extends HttpServlet { ObjectCatalog catalog = new ObjectCatalog ( ) ; @ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { String className = req . getParameter ( \"className\" ) ; String description = req . getParameter ( \"description\" ) ; if ( className != null && ! className . equals ( \"\" ) && description != null && ! description . equals ( \"\" ) ) { catalog . addClass ( className , description ) ; } req . getRequestDispatcher ( \"/class/add_class.jsp\"", "gt": ") . forward ( req , resp ) ;", "prediction": ") ;\n", "label": 1}
{"id": 5425, "input": "<s> package org . ofbiz . webapp . event ; import org . apache . commons . fileupload . ProgressListener ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) public class FileUploadProgressListener implements ProgressListener , Serializable { public static final String module = FileUploadProgressListener . class . getName ( ) ; protected long contentLength = - 1 ; protected long bytesRead = - 1 ; protected int items = - 1 ; protected boolean hasStarted = false ; public void update ( long bytesRead , long contentLength , int items ) { this . contentLength = contentLength ; this . bytesRead = bytesRead ; this . items = items ; if ( ! hasStarted ) { hasStarted = true ; } } public long getContentLength ( ) { return contentLength ; }", "gt": "public long getBytesRead ( )", "prediction": "}\n", "label": 0}
{"id": 12333, "input": "<s> package com . corundumstudio . socketio . messages ; import org . jboss . netty . buffer . ChannelBuffer ; import com . corundumstudio . socketio . transport . BaseClient ; public class PacketsMessage { private final BaseClient client ; private final ChannelBuffer content ; public PacketsMessage ( BaseClient client , ChannelBuffer content ) { this . client = client ; this", "gt": ". content = content ;", "prediction": ";\n", "label": 1}
{"id": 1882, "input": "<s> package org . ofbiz . content . survey ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . StringWriter ; import java . io . Writer ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; public class SurveyWrapper { public static final String module = SurveyWrapper . class . getName ( ) ; protected Delegator delegator = null ; protected String responseId = null ; protected String partyId = null ; protected String surveyId = null ; protected Map < String , Object > templateContext = null ; protected Map < String , Object > passThru = null ; protected Map < String , Object > defaultValues = null ; protected boolean edit = false ; protected SurveyWrapper ( ) { } public SurveyWrapper ( Delegator delegator , String responseId , String partyId , String surveyId , Map < String , Object > passThru , Map < String , Object > defaultValues ) { this . delegator = delegator ; this . responseId = responseId ; this . partyId = partyId ; this . surveyId = surveyId ; this . setPassThru ( passThru ) ; this . setDefaultValues ( defaultValues ) ; this . checkParameters ( ) ; } public SurveyWrapper ( Delegator delegator , String responseId , String partyId , String surveyId , Map < String , Object > passThru ) { this ( delegator , responseId , partyId , surveyId , passThru , null ) ; } public SurveyWrapper ( Delegator delegator , String surveyId ) { this ( delegator , null , null , surveyId , null ) ; } protected void checkParameters ( ) { if ( delegator == null || surveyId == null ) { throw new IllegalArgumentException ( \"Missing one or more required parameters (delegator, surveyId)\" ) ; } } public void setPassThru ( Map < String , Object > passThru ) { if ( passThru != null ) { this . passThru = FastMap . newInstance ( ) ; this . passThru . putAll ( passThru ) ; } } public void setDefaultValues ( Map < String , Object > defaultValues ) { if ( defaultValues != null ) { this . defaultValues = FastMap . newInstance ( ) ; this . defaultValues . putAll ( defaultValues ) ; } } public void addToTemplateContext ( String name , Object value ) { if ( templateContext == null ) { templateContext = FastMap . newInstance ( ) ; } templateContext . put ( name , value ) ; } public void removeFromTemplateContext ( String name ) { if ( templateContext != null ) templateContext . remove ( name ) ; } public Writer render ( String templatePath ) throws SurveyWrapperException { URL templateUrl = null ; try { templateUrl = FlexibleLocation . resolveLocation ( templatePath ) ; } catch ( MalformedURLException e ) { throw new SurveyWrapperException ( e ) ; } if ( templateUrl == null ) { String errMsg = \"Problem getting the template for Survey from URL: \" + templatePath ; Debug . logError ( errMsg , module ) ; throw new IllegalArgumentException ( errMsg ) ; } Writer writer = new StringWriter ( ) ; this . render ( templateUrl , writer ) ; return writer ; } public void render ( URL templateUrl , Writer writer ) throws SurveyWrapperException { String responseId = this . getThisResponseId ( ) ; GenericValue survey = this . getSurvey ( ) ; List < GenericValue > surveyQuestionAndAppls = this . getSurveyQuestionAndAppls ( ) ; Map < String , Object > results = this . getResults ( surveyQuestionAndAppls ) ; Map < String , Object > currentAnswers = null ; if ( responseId != null && canUpdate ( ) ) { currentAnswers = this . getResponseAnswers ( responseId ) ; } else { currentAnswers = this . getResponseAnswers ( null ) ; } Map < String , Object > sqaaWithColIdListByMultiRespId = FastMap . newInstance ( ) ; for ( GenericValue surveyQuestionAndAppl : surveyQuestionAndAppls ) { String surveyMultiRespColId = surveyQuestionAndAppl . getString ( \"surveyMultiRespColId\" ) ; if ( UtilValidate . isNotEmpty ( surveyMultiRespColId ) ) { String surveyMultiRespId = surveyQuestionAndAppl . getString ( \"surveyMultiRespId\" ) ; UtilMisc . addToListInMap ( surveyQuestionAndAppl , sqaaWithColIdListByMultiRespId , surveyMultiRespId ) ; } } if ( templateContext == null ) { templateContext = FastMap . newInstance ( ) ; } templateContext . put ( \"partyId\" , partyId ) ; templateContext . put (", "gt": "\"survey\" , survey ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12351, "input": "<s> package org . restlet . ext . jaxrs . internal . provider ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . util . logging . Logger ; import javax . ws . rs . Consumes ; import javax . ws . rs . Produces ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . MessageBodyWriter ; import javax . ws . rs . ext . Provider ; import javax . xml . XMLConstants ; import javax . xml . bind . JAXBContext ; import javax . xml . bind . Unmarshaller ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . sax . SAXSource ; import org . restlet . Context ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; @ Provider @ Produces ( { \"application/xml\" , MediaType . TEXT_XML , \"application/*+xml\" } ) @ Consumes ( { \"application/xml\" , MediaType . TEXT_XML , \"application/*+xml\" } ) public class JaxbProvider extends AbstractJaxbProvider < Object > { private volatile boolean expandingEntityRefs ; private final Logger logger = Context . getCurrentLogger ( ) ; private boolean secureProcessing ; private volatile boolean validatingDtd ; private volatile boolean xIncludeAware ; public JaxbProvider ( ) { this . expandingEntityRefs = false ; this . secureProcessing = true ; this . validatingDtd = false ; this . xIncludeAware = false ; } @ Override Logger getLogger ( ) { return this . logger ; } public boolean isExpandingEntityRefs ( ) { return expandingEntityRefs ; } @ Override public boolean isReadable ( Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { return type . isAnnotationPresent ( XmlRootElement . class ) ; } public boolean isSecureProcessing ( ) { return secureProcessing ; } public boolean isValidatingDtd ( ) { return validatingDtd ; } @ Override public boolean isWriteable ( Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { return type . isAnnotationPresent ( XmlRootElement . class ) ; } public boolean isXIncludeAware ( ) { return xIncludeAware ; } @ Override public Object readFrom ( Class < Object > type , Type genericType , Annotation [ ] annotations , MediaType mediaType , MultivaluedMap < String , String > httpHeaders , InputStream entityStream ) throws IOException { try { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; spf . setXIncludeAware ( isXIncludeAware ( ) ) ; spf . setNamespaceAware ( true ) ; spf . setValidating ( isValidatingDtd ( ) ) ; spf . setFeature ( XMLConstants . FEATURE_SECURE_PROCESSING , isSecureProcessing ( ) ) ; spf . setFeature ( \"http://xml.org/sax/features/external-general-entities\" , isExpandingEntityRefs ( ) ) ; spf . setFeature ( \"http://xml.org/sax/features/external-parameter-entities\" , isExpandingEntityRefs ( ) ) ; XMLReader reader = spf . newSAXParser ( ) . getXMLReader ( ) ; JAXBContext jaxbContext = getJaxbContext ( type ) ; Unmarshaller um = jaxbContext . createUnmarshaller ( ) ; return um . unmarshal ( new SAXSource ( reader , new InputSource ( entityStream ) ) ) ; } catch ( Exception e ) { throw new IOException ( \"Could not unmarshal to", "gt": "\" + type . getName ( ) , e ) ;", "prediction": ") ;\n", "label": 1}
{"id": 7613, "input": "<s> package org . remast . baralga . model ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . WeakHashMap ; import org . apache . commons . lang . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . h2 . tools . RunScript ; import org . joda . time . DateTime ; import org . joda . time . Duration ; import org . joda . time . format . PeriodFormat ; import org . remast . baralga . gui . settings . ApplicationSettings ; import org . remast . baralga . model . filter . Filter ; import org . remast . util . TextResourceBundle ; public class BaralgaDAO { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaDAO . class ) ; private static final Logger log = LoggerFactory . getLogger ( BaralgaDAO . class ) ; public static final int LATEST_DATABASE_VERSION = 1 ; private Connection connection ; private Map < String , PreparedStatement > preparedStatementCache = Collections . synchronizedMap ( new WeakHashMap < String , PreparedStatement > ( ) ) ; private int databaseVersion ; public void init ( ) throws SQLException { final String dataDirName = ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) . getAbsolutePath ( ) ; connection = DriverManager . getConnection ( \"jdbc:h2:\" + dataDirName + \"/baralga;DB_CLOSE_ON_EXIT=FALSE\" , \"baralga-user\" , \"\" ) ; updateDatabase ( ) ; } public void close ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { connection . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; } } private void updateDatabase ( ) throws SQLException { boolean databaseExists = false ; final Statement statement = connection . createStatement ( ) ; ResultSet resultSet = statement . executeQuery ( \"SHOW TABLES\" ) ; while ( resultSet . next ( ) ) { if ( \"db_version\" . equalsIgnoreCase ( resultSet . getString ( \"TABLE_NAME\" ) ) ) { databaseExists = true ; break ; } } if ( ! databaseExists ) { log . info ( \"Creating Baralga DB.\" ) ; executeScript ( \"setup_database.sql\" ) ; log . info ( \"Baralga DB successfully created.\" ) ; } connection . commit ( ) ; databaseVersion = - 1 ; resultSet = statement . executeQuery ( \"select max(version) as version, description from db_version\" ) ; String description = \"-\" ; if ( resultSet . next ( ) ) { databaseVersion = resultSet . getInt ( \"version\" ) ; description = resultSet . getString ( \"description\" ) ; } int versionDifference = LATEST_DATABASE_VERSION - databaseVersion ; for ( int i = 0 ; i < versionDifference ; i ++ ) { final int versionUpdate = databaseVersion + versionDifference ; log . info ( \"Updating database to version \" + versionUpdate + \".\" ) ; final String updateScript = \"db_version_\" + StringUtils . leftPad ( String . valueOf ( versionUpdate ) , 3 , \"0\" ) + \".sql\" ; executeScript ( updateScript ) ; } log . info ( \"Using Baralga DB Version: {}, description: {}.\" , databaseVersion , description ) ; } private void executeScript ( final String scriptName ) throws SQLException { log . info ( \"Executing sql script \" + scriptName + \".\" ) ; if ( StringUtils . isBlank ( scriptName ) ) { return ; } InputStream is = BaralgaDAO . class . getResourceAsStream ( \"sql/h2/\" + scriptName ) ; Reader reader = new InputStreamReader ( is ) ; RunScript . execute ( connection , reader ) ; } private PreparedStatement prepare ( final String sql ) throws SQLException { PreparedStatement preparedStatement = preparedStatementCache . get ( sql ) ; if ( preparedStatement == null ) { preparedStatement = connection . prepareStatement ( sql ) ; preparedStatementCache . put ( sql , preparedStatement ) ; } return preparedStatement ; } public void remove ( final Project project ) { if ( project == null ) { return ; } try { final PreparedStatement activityDelete = prepare ( \"delete from activity where project_id = ?\" ) ; activityDelete . setLong ( 1 , project . getId ( ) ) ; activityDelete . execute ( ) ; final PreparedStatement projectDelete = prepare ( \"delete from project where id = ?\" ) ; projectDelete . setLong ( 1 , project . getId ( ) ) ; projectDelete . execute ( ) ; } catch ( SQLException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; throw new RuntimeException ( textBundle . textFor ( \"BaralgaDB.DatabaseError.Message\" ) , e ) ; } } public void addProject ( final Project project ) { if ( project == null ) { return ; } try { final PreparedStatement pst = prepare ( \"insert into project (title, description, active) values (?, ?, ?)\" ) ; pst . setString ( 1 , project . getTitle ( ) ) ; pst . setString ( 2 , project . getDescription ( ) ) ; pst . setBoolean ( 3 , project . isActive ( ) ) ; pst . execute ( ) ; final Statement st = connection . createStatement ( ) ; final ResultSet rs = st . executeQuery ( \"select max(id) as id from project\" ) ; if ( rs . next ( ) ) { long id = rs . getLong ( \"id\" ) ; project . setId ( id ) ; } } catch ( SQLException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; throw new RuntimeException ( textBundle . textFor ( \"BaralgaDB.DatabaseError.Message\" ) , e ) ; } } public List < Project > getActiveProjects ( ) { final List < Project > activeProjects = new ArrayList < Project > ( ) ; try { final Statement st = connection . createStatement ( ) ; final ResultSet rs = st . executeQuery ( \"select * from project where active = True\" ) ; while ( rs . next ( ) ) { Project project = new Project ( rs . getLong ( \"id\" ) , rs . getString ( \"title\" ) , rs . getString ( \"description\" ) ) ; project . setActive ( true ) ; activeProjects . add ( project ) ; } } catch ( SQLException e ) { log . error ( e . getLocalizedMessage", "gt": "( ) , e ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 12389, "input": "<s> package org . nuxeo . ecm . platform . io . selectionReader ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . io . ExportedDocument ; import org . nuxeo . ecm . core . io . impl . AbstractDocumentReader ; import org . nuxeo . ecm . core . io . impl . ExportedDocumentImpl ; public class DocumentModelListReader extends AbstractDocumentReader { List", "gt": "< DocumentModel > docList ;", "prediction": ";\n", "label": 1}
{"id": 2770, "input": "<s> package api . announcements ; import api . son . MySon ; import api . soup . MySoup ; public class Announcements { private Response response ; private String status ; public static Announcements init ( ) { String authkey = MySoup . getAuthKey ( ) ; String url = \"ajax.php?action=announcements&auth=\" + authkey ; Announcements a = ( Announcements ) MySon . toObject ( url , Announcements . class ) ; return a ; } public Response getResponse ( ) { return this . response ; } public boolean getStatus ( ) { if ( status . equalsIgnoreCase ( \"success\" ) ) return true ; return false ; } @ Override public String toString ( ) { return \"Announcements [getResponse=\" + getResponse ( )", "gt": "+ \", getStatus=\" + getStatus ( ) + \"]\" ;", "prediction": ";\n", "label": 0}
{"id": 12394, "input": "<s> package br . org . archimedes . ellipse ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import br . org . archimedes . Constant ; import br . org . archimedes . Geometrics ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Offsetable ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . ReferencePoint ; import br . org . archimedes . model . Vector ; import br . org . archimedes . model . references . CirclePoint ; import br . org . archimedes . model . references . RhombusPoint ; public class Ellipse extends Element implements Offsetable { private Point center ; private Point widthPoint ; private Point heightPoint ; private double fi ; public Ellipse ( Point center , Point widthPoint , Point heightPoint ) throws NullArgumentException , InvalidArgumentException { validateArguments ( center , widthPoint , heightPoint ) ; this . center = center ; this . widthPoint = widthPoint ; this . heightPoint = calculateHeightPoint ( center , widthPoint , heightPoint ) ; this . fi = calculateFi ( center , widthPoint ) ; } public Ellipse ( Point focus1 , Point focus2 , Double radius ) throws NullArgumentException , InvalidArgumentException { validateArguments ( focus1 , focus2 , radius ) ; this . center = new Point ( ( focus1 . getX ( ) + focus2 . getX ( ) ) / 2 , ( focus1 . getY ( ) + focus2 . getY ( ) ) / 2 ) ; this . widthPoint = center . addVector ( new Vector ( focus1 , focus2 ) ) ; this . fi = calculateFi ( center , widthPoint ) ; double angle = this . fi + Math . PI / 2 ; this . heightPoint = new Point ( center . getX ( ) + radius * Math . cos ( angle ) , center . getY ( ) + radius * Math . sin ( angle ) ) ; } public Point getCenter ( ) { return center ; } public Point getWidthPoint ( ) { return widthPoint ; } public Point getHeightPoint ( ) { return heightPoint ; } public double getFi ( ) { return fi ; } public Vector getSemiMajorAxis ( ) { Vector widthVector = new Vector ( center , widthPoint ) ; Vector heightVector = new Vector ( center , heightPoint ) ; return ( widthVector . getNorm ( ) > heightVector . getNorm ( ) ) ? widthVector : heightVector ; } public Vector getSemiMinorAxis ( ) { Vector widthVector = new Vector ( center , widthPoint ) ; Vector heightVector = new Vector ( center , heightPoint ) ; return ( widthVector . getNorm ( ) > heightVector . getNorm ( ) ) ? heightVector : widthVector ; } @ Override public Element clone ( ) { Ellipse ellipse = null ; try { ellipse = new Ellipse ( center . clone ( ) , widthPoint . clone ( ) , heightPoint . clone ( ) ) ; ellipse . setLayer ( getLayer ( ) ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvalidArgumentException e ) { e . printStackTrace ( ) ; } return ellipse ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( center == null ) ? 0 : center . hashCode ( ) ) ; result = prime * result + ( ( heightPoint == null ) ? 0 : heightPoint . hashCode ( ) ) ; result = prime * result + ( ( widthPoint == null ) ? 0 : widthPoint . hashCode ( ) ) ; return result ; } public boolean equals ( Ellipse ellipse ) { boolean result = true ; if ( ellipse == null ) { result = false ; } else if ( ! this . center . equals ( ellipse . getCenter ( ) ) || ! this . widthPoint . equals ( ellipse . getWidthPoint ( ) ) || ! this . heightPoint . equals ( ellipse . getHeightPoint ( ) ) ) { result = false ; } return result ; } @ Override public boolean equals ( Object object ) { boolean result = false ; if ( object != null ) { try { Ellipse ellipse = ( Ellipse ) object ; result = this . equals ( ellipse ) ; } catch ( ClassCastException e ) { return false ; } } return result ; } @ Override public Rectangle getBoundaryRectangle ( ) { Rectangle boundary ; Point xmin , xmax , ymin , ymax ; double a = ( new Vector ( center , widthPoint ) ) . getNorm ( ) ; double b = ( new Vector ( center , heightPoint ) ) . getNorm ( ) ; double f = a * Math . cos ( this . fi ) ; double g = b * Math . sin ( this . fi ) ; double t1 = Math . acos ( f / Math . sqrt ( f * f + g * g ) ) ; double t2 = Math . acos ( - f / Math . sqrt ( f * f + g * g ) ) ; double t3 = - Math . acos ( f / Math . sqrt ( f * f + g * g ) ) ; double t4 = - Math . acos ( - f / Math . sqrt ( f * f + g * g ) ) ; if ( fi < 0 ) { Point x1 = calculatePointFromAngle", "gt": "( t1 , fi ) ;", "prediction": ";\n", "label": 1}
{"id": 3202, "input": "<s> import java . util . ArrayList ; public class Sieve { public static ArrayList < Integer > generatePrimes ( int n ) { ArrayList < Integer > ret = new ArrayList < Integer > ( ) ; ArrayList < Boolean > sieve = new ArrayList < Boolean > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sieve . add ( false ) ; } for ( int i = 2 ; i < Math . sqrt ( n ) ; i ++ ) { if ( !", "gt": "sieve . get ( i ) )", "prediction": ") ;\n", "label": 0}
{"id": 12423, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . jface . viewers . StructuredSelection ; public class StructuredSelectionTest extends TestCase { public StructuredSelectionTest ( String name ) { super ( name ) ; } public static void main ( String args [ ] ) { junit . textui . TestRunner . run ( StructuredSelectionTest . class ) ; } public void testEquals ( ) { String element = \"A selection\" ; StructuredSelection sel1 = new StructuredSelection ( element ) ; StructuredSelection sel2 = new StructuredSelection ( element ) ; assertEquals ( sel1 , sel2 ) ; } public void testEquals2 ( ) { String element1 = \"A selection\" ; String element2 = \"A selection\" ; String element3 = \"Other\" ; StructuredSelection sel1 = new StructuredSelection ( element1 ) ; StructuredSelection sel2 = new StructuredSelection ( element2 ) ; StructuredSelection sel3 = new StructuredSelection ( element3 ) ; assertEquals ( sel1 , sel2 ) ; assertTrue ( ! sel1 . equals ( sel3 ) ) ; } public void testEquals3 ( ) { StructuredSelection empty1 = new StructuredSelection ( ) ; StructuredSelection empty2 = new StructuredSelection ( ) ; assertTrue ( empty1 . equals ( empty2 ) ) ; assertTrue ( empty2 . equals ( empty1 ) ) ; } public void testEquals4 ( ) { StructuredSelection sel = new StructuredSelection ( \"A selection\" ) ; StructuredSelection empty = new StructuredSelection ( ) ; assertTrue ( ! sel . equals ( empty ) ) ; assertTrue ( ! empty . equals ( sel ) ) ; } public void testEquals5 ( ) { List l1 = new ArrayList ( ) ; l1 . add ( \"element 1\" ) ; l1 . add ( \"element 2\" ) ; List l2 = new ArrayList ( ) ; l2 . add ( \"element 2\" ) ; l2 . add ( \"element 1\" ) ; StructuredSelection sel1 = new StructuredSelection ( l1 ) ; StructuredSelection sel2 = new StructuredSelection ( l2 ) ; assertTrue ( ! sel1 . equals ( sel2 ) ) ; assertTrue", "gt": "( ! sel2 . equals ( sel1 ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 965, "input": "<s> package de . javawi . jstun . attribute ; import com . kodholken . stunclient . Logger ; import com . kodholken . stunclient . LoggerFactory ; public class ChangedAddress extends MappedResponseChangedSourceAddressReflectedFrom { private static final Logger LOGGER = LoggerFactory . getLogger ( ChangedAddress . class ) ; public ChangedAddress ( ) { super ( MessageAttribute . MessageAttributeType . ChangedAddress ) ; } public static MessageAttribute parse ( byte [ ] data ) throws MessageAttributeParsingException { ChangedAddress ca = new ChangedAddress ( ) ; MappedResponseChangedSourceAddressReflectedFrom . parse ( ca , data ) ; LOGGER . debug ( \"Message Attribute: Changed Address parsed: \" + ca", "gt": ". toString ( ) + \".\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12445, "input": "<s> package com . emf4sw . owl . transform . owl2ecore ; import static com . atl . common . trans . Transformations . transform ; import static com . atl . common . utils . Preconditions . checkNotNull ; import static com . emf4sw . owl . transform . OWLTransformations . ecoreRefine ; import org . eclipse . m2m . atl . core . emf . EMFModel ; import com . atl . common . trans . Transformation ; public class EcoreRefine implements Transformation < EMFModel , EMFModel > { @ Override public EMFModel apply ( EMFModel from ) { checkNotNull ( from , \"Cannot execute transformation \" + this + \", on null parameter.\" ) ; return transform (", "gt": "from , ecoreRefine ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3888, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . helpers ;", "gt": "public class SimpleChildNodeEditHelper extends SimplemapBaseEditHelper", "prediction": "}\n", "label": 0}
{"id": 12456, "input": "<s> package com . petpet . sc . widget ; import android . content . Context ; import android . content . res . TypedArray ; import android . util . AttributeSet ; import android . view . View ; import android . widget . Button ; import android . widget . LinearLayout ; import com . petpet . sc . R ; import com . petpet . sc . listeners . SCHierarchyChangeListener ; public class SegmentedControl extends LinearLayout { private static final int MAX_LENGTH = 10 ; private int leftState ; private int middleState ; private int rightState ; private int maxLength ; private boolean firstSelected ; public SegmentedControl ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; this . initAttributes ( context , attrs ) ; this . initState ( ) ; } public void stateChanged ( Button pressed ) { int count = this . getChildCount ( ) ; if ( count > 0 && pressed == null ) { View child = this . getChildAt ( 0 ) ; if ( child instanceof Button && isFirstSelected ( ) ) { ( ( Button ) child ) . setPressed ( true ) ; } return ; } for ( int i = 0 ; i < count ; i ++ ) { View child = this . getChildAt ( i ) ; if ( child instanceof Button ) { Button btn = ( Button ) child ; boolean clicked = ( pressed . getId ( ) == btn . getId ( ) ) ? true : false ; if ( clicked ) { btn . setPressed ( true ) ; } else { btn . setPressed ( false ) ; } } } } public void setLeftState ( int leftState ) { this . leftState = leftState ; } public int getLeftState ( ) { return leftState ; } public void setMiddleState ( int middleState ) { this . middleState = middleState ; } public int getMiddleState ( ) { return middleState ; } public void setRightState ( int rightState ) { this . rightState = rightState ; } public int getRightState ( ) { return rightState ; } public void setMaxLength ( int maxLength ) { this . maxLength = maxLength ; } public int getMaxLength ( ) { return maxLength ; } public void setFirstSelected ( boolean firstSelected ) { this . firstSelected = firstSelected ; } public boolean isFirstSelected ( ) { return firstSelected ; } private void initAttributes ( Context context , AttributeSet attrs ) { final TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . SegmentedControl ) ; setFirstSelected ( a . getBoolean ( R . styleable .", "gt": "SegmentedControl_first_selected , true ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6391, "input": "<s> package org . ofbiz . service . calendar ; import java . util . Arrays ; import com . ibm . icu . util . Calendar ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class RecurrenceRule { public static final String module = RecurrenceRule . class . getName ( ) ; public static final int MIN_SEC = 0 ; public static final int MAX_SEC = 59 ; public static final int MIN_MIN = 0 ; public static final int MAX_MIN = 59 ; public static final int MIN_HR = 0 ; public static final int MAX_HR = 23 ; public static final int MIN_MTH_DAY = - 31 ; public static final int MAX_MTH_DAY = 31 ; public static final int MIN_YEAR_DAY = - 366 ; public static final int MAX_YEAR_DAY = 366 ; public static final int MIN_WEEK_NO = - 53 ; public static final int MAX_WEEK_NO = 53 ; public static final int MIN_MTH = 1 ; public static final int MAX_MTH = 12 ; public static final int SECONDLY = 1 ; public static final int MINUTELY = 2 ; public static final int HOURLY = 3 ; public static final int DAILY = 4 ; public static final int WEEKLY = 5 ; public static final int MONTHLY = 6 ; public static final int YEARLY = 7 ; protected GenericValue rule ; protected List < String > bySecondList ; protected List < String > byMinuteList ; protected List < String > byHourList ; protected List < String > byDayList ; protected List < String > byMonthDayList ; protected List < String > byYearDayList ; protected List < String > byWeekNoList ; protected List < String > byMonthList ; protected List < String > bySetPosList ; public RecurrenceRule ( GenericValue rule ) throws RecurrenceRuleException { this . rule = rule ; if ( ! rule . getEntityName ( ) . equals ( \"RecurrenceRule\" ) ) throw new RecurrenceRuleException ( \"Invalid RecurrenceRule Value object.\" ) ; init ( ) ; } public void init ( ) throws RecurrenceRuleException { String freq = rule . getString ( \"frequency\" ) ; if ( ! checkFreq ( freq ) ) throw new RecurrenceRuleException ( \"Recurrence FREQUENCY is a required parameter.\" ) ; if ( rule . getLong ( \"intervalNumber\" ) . longValue ( ) < 1 ) throw new RecurrenceRuleException ( \"Recurrence INTERVAL must be a positive integer.\" ) ; bySecondList = StringUtil . split ( rule . getString ( \"bySecondList\" ) , \",\" ) ; byMinuteList = StringUtil . split ( rule . getString ( \"byMinuteList\" ) , \",\" ) ; byHourList = StringUtil . split ( rule . getString ( \"byHourList\" ) , \",\" ) ; byDayList = StringUtil . split ( rule . getString ( \"byDayList\" ) , \",\" ) ; byMonthDayList = StringUtil . split ( rule . getString ( \"byMonthDayList\" ) , \",\" ) ; byYearDayList = StringUtil . split ( rule . getString ( \"byYearDayList\" ) , \",\" ) ; byWeekNoList = StringUtil . split ( rule . getString ( \"byWeekNoList\" ) , \",\" ) ; byMonthList = StringUtil . split ( rule . getString ( \"byMonthList\" ) , \",\" ) ; bySetPosList = StringUtil . split ( rule . getString ( \"bySetPosList\" ) , \",\" ) ; } private boolean checkFreq ( String freq ) { if ( freq == null ) return false ; if ( freq . equalsIgnoreCase ( \"SECONDLY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"MINUTELY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"HOURLY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"DAILY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"WEEKLY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"MONTHLY\" ) ) return true ; if ( freq . equalsIgnoreCase ( \"YEARLY\" ) ) return true ; return false ; } public long getEndTime ( ) { if ( rule == null ) { Debug . logVerbose ( \"Rule is null.\" , module ) ; return - 1 ; } long time = 0 ; java . sql . Timestamp stamp = null ; stamp = rule . getTimestamp ( \"untilDateTime\" ) ; Debug . logVerbose ( \"Stamp value: \" + stamp , module ) ; if ( stamp != null ) { long nanos = stamp . getNanos ( ) ; time = stamp . getTime ( ) ; time += ( nanos / 1000000 ) ; } Debug . logVerbose ( \"Returning time: \" + time , module ) ; return time ; } public long getCount ( ) { if ( rule . get ( \"countNumber\" ) != null ) return rule . getLong ( \"countNumber\" ) . longValue ( ) ; return 0 ; } public String getFrequencyName ( ) { return rule . getString ( \"frequency\" ) . toUpperCase ( ) ; } public int getFrequency ( ) { String freq = rule . getString ( \"frequency\" ) ; if ( freq == null ) return 0 ; if ( freq . equalsIgnoreCase ( \"SECONDLY\" ) ) return SECONDLY ; if ( freq . equalsIgnoreCase ( \"MINUTELY\" ) ) return MINUTELY ; if ( freq . equalsIgnoreCase ( \"HOURLY\" ) ) return HOURLY ; if ( freq . equalsIgnoreCase ( \"DAILY\" ) ) return DAILY ; if ( freq . equalsIgnoreCase ( \"WEEKLY\" ) ) return WEEKLY ; if", "gt": "( freq . equalsIgnoreCase ( \"MONTHLY\" ) ) return MONTHLY ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12459, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . index . IndexReader ; public abstract class Collector { public abstract void setScorer ( Scorer scorer ) throws IOException ; public abstract void collect ( int doc , int [ ] sorts ) throws IOException ; public abstract void setNextReader ( IndexReader reader", "gt": ", int docBase ) throws IOException ;", "prediction": ")\n", "label": 1}
{"id": 4998, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class ShiftsTest extends XtextTest { @ Test public void testShiftsLimit ( ) { testParserRule ( \"s1 2010-01-16-9:30 - 2011-01-16-20:59\" , \"ShiftsLimit\" ) ; } @ Test public void testShiftsAllocate ( ) { testParserRule ( \"shifts s1\" , \"ShiftsAllocate\" ) ; } @ Test public void testShiftsAllocateWithInterval ( ) { testParserRule ( \"shifts s1 2010-01-16 + 4 m\" , \"ShiftsAllocate\" ) ; } @ Test public void testShiftsAllocateWithTwoIntervals ( ) { testParserRule ( \"shifts s1 2010-01-16 + 4 m, 2010-01-16 - 2011-01-16\" , \"ShiftsAllocate\" ) ; } @", "gt": "Test public void testShiftsResource ( )", "prediction": "}\n", "label": 0}
{"id": 12460, "input": "<s> package net . claribole . zgrviewer ; import java . awt . Container ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . HierarchyEvent ; import java . awt . event . HierarchyListener ; import java . awt . event . KeyEvent ; import java . awt . event . KeyListener ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . awt . event . WindowListener ; import javax . swing . JButton ; import javax . swing . JFrame ; import javax . swing . JScrollPane ; import javax . swing . JTextArea ; public class TextViewer extends JFrame implements ActionListener , KeyListener , Runnable { Thread runView ; JButton okBt ; JButton clearBt ; StringBuffer text ; int oldSize ; int period ; JTextArea ar ; public TextViewer ( StringBuffer msgs , String frameTitle , int d , boolean clear ) { text = msgs ; oldSize = text . length ( ) ; period = d ; ar = new JTextArea ( text . toString ( ) ) ; ar . setFont ( ConfigManager . defaultFont ) ; ar . setEditable ( false ) ; ar . setLineWrap ( true ) ; JScrollPane sp = new JScrollPane ( ar ) ; sp . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; Container cpane = this . getContentPane ( ) ; GridBagLayout gridBag = new GridBagLayout ( ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; constraints . anchor = GridBagConstraints . CENTER ; cpane . setLayout ( gridBag ) ; buildConstraints ( constraints , 0 , 0 , 2 , 1 , 100 , 98 ) ; gridBag . setConstraints ( sp , constraints ) ; cpane . add ( sp ) ; if ( clear ) { okBt = new JButton ( \"OK\" ) ; okBt . addActionListener ( this ) ; okBt . addKeyListener ( this ) ; constraints . anchor = GridBagConstraints . EAST ; constraints . fill = GridBagConstraints . NONE ; buildConstraints ( constraints , 0 , 1 , 1 , 1 , 50 , 2 ) ; gridBag . setConstraints ( okBt , constraints ) ; cpane . add ( okBt ) ; clearBt = new JButton ( \"Clear\" ) ; clearBt . addActionListener ( this ) ; clearBt . addKeyListener ( this ) ; constraints . anchor = GridBagConstraints . WEST ; buildConstraints ( constraints , 1 , 1 , 1 , 1 , 50 , 0 ) ; gridBag . setConstraints ( clearBt , constraints ) ; cpane . add ( clearBt ) ; } else { okBt = new JButton ( \"OK\" ) ; okBt . addActionListener ( this ) ; okBt . addKeyListener ( this ) ; constraints . anchor = GridBagConstraints . CENTER ; constraints . fill = GridBagConstraints . HORIZONTAL ; buildConstraints ( constraints , 0 , 1 ,", "gt": "2 , 1 , 100 , 2 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1690, "input": "<s> import java . util . * ; class NameClassSameErasure { void m ( List < Integer > list ) { }", "gt": "void m ( List < String > list )", "prediction": "}\n", "label": 0}
{"id": 12480, "input": "<s> package fr . inria . zvtm . animation . examples ; import java . awt . * ; import java . util . Vector ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . event . MouseWheelEvent ; import fr . inria . zvtm . engine . * ; import fr . inria . zvtm . glyphs . * ; import fr . inria . zvtm . event . * ; import fr . inria . zvtm . animation . * ; import org . jdesktop . animation . timing . interpolation . * ; public class TestDefaultHandler { VirtualSpaceManager vsm ; VirtualSpace vs ; ViewListener eh ; View testView ; Camera cam ; TestDefaultHandler ( String vt ) { vsm = VirtualSpaceManager . INSTANCE ; vsm . setDebug ( true ) ; initTest ( vt ) ; } public void initTest ( String vt ) { eh = new TestDefaultHandler . EventHandlerTestDTH ( this ) ; vs = vsm . addVirtualSpace ( \"src\" ) ; cam = vs . addCamera ( ) ; Vector cameras = new Vector ( ) ; cameras . add ( cam ) ; cam . setZoomFloor ( - 90 ) ; testView = vsm . addFrameView ( cameras , \"Test\" , vt , 800 , 600 , true ) ; testView . setBackgroundColor ( Color . LIGHT_GRAY ) ; testView . setListener ( eh ) ; final Glyph circle = new VCircle ( 100 , 0 , 0 , 40 , Color . WHITE ) ; cam . setAltitude ( 50 ) ; vs . addGlyph ( circle ) ; vsm . repaint ( ) ; AnimationManager am = vsm . getAnimationManager ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) { Animation anim = am . getAnimationFactory ( ) . createAnimation ( 3000 , 1.0 , Animation . RepeatBehavior . LOOP , circle , Animation . Dimension . POSITION , new DefaultTimingHandler ( ) { public void timingEvent ( float fraction , Object subject , Animation . Dimension dim ) { Glyph g = ( Glyph ) subject ; g . moveTo ( 100 - Double . valueOf ( 600 * fraction ) . doubleValue ( ) , 0 ) ; } } , new SplineInterpolator ( 0.7f , 0.1f , 0.3f , 0.9f ) ) ; am . startAnimation ( anim , false ) ; } Animation anim = am . getAnimationFactory ( ) . createAnimation ( 8000 , 1.0 , Animation . RepeatBehavior . LOOP , circle , Animation . Dimension . FILLCOLOR , new DefaultTimingHandler ( ) { public void timingEvent ( float fraction , Object subject ,", "gt": "Animation . Dimension dim )", "prediction": ") ;\n", "label": 1}
{"id": 9075, "input": "<s> package org . papaours . yama . model . multichoice ; public enum YamaMultiChoiceNumberings { NONE ,", "gt": "ABC , ABCD_CAP , NUMBER ;", "prediction": "= ;\n", "label": 0}
{"id": 12494, "input": "<s> package org . mitre . oauth2 . model ; import java . util . Date ; import javax . persistence . Basic ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . FetchType ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . JoinColumn ; import javax . persistence . ManyToOne ; import javax . persistence . NamedQueries ; import javax . persistence . NamedQuery ; import javax . persistence . Table ; import javax . persistence . Temporal ; import javax . persistence . Transient ; import org . mitre . jwt . model . Jwt ; import org . springframework . security . oauth2 . common . OAuth2RefreshToken ; @ Entity @ Table ( name = \"refresh_token\" ) @ NamedQueries ( { @ NamedQuery ( name = \"OAuth2RefreshTokenEntity.getByClient\" , query = \"select r from OAuth2RefreshTokenEntity r where r.client = :client\" ) , @ NamedQuery ( name = \"OAuth2RefreshTokenEntity.getExpired\" , query = \"select r from OAuth2RefreshTokenEntity r where r.expiration is not null and r.expiration < current_timestamp\" ) , @ NamedQuery ( name = \"OAuth2RefreshTokenEntity.getByTokenValue\" , query = \"select r from OAuth2RefreshTokenEntity r where r.value = :tokenValue\" ) , @ NamedQuery ( name = \"OAuth2RefreshTokenEntity.getByAuthentication\" , query = \"select r from OAuth2RefreshTokenEntity r where r.authenticationHolder.authentication = :authentication\" ) } ) public class OAuth2RefreshTokenEntity implements OAuth2RefreshToken { private Long id ; private AuthenticationHolderEntity authenticationHolder ; private ClientDetailsEntity client ; private Jwt jwt ; private Date expiration ; public OAuth2RefreshTokenEntity ( ) { setJwt ( new", "gt": "Jwt ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3286, "input": "<s> package com . gisgraphy . client . commons ; public interface Formattable { String", "gt": "formatName ( NameFormatter nameFormatter ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12513, "input": "<s> package org . eclipse . ui . tests . adaptable ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . swt . graphics . Image ; import org . eclipse . ui . model . IWorkbenchAdapter ; public class TestAdaptableWorkbenchAdapter extends LabelProvider implements IWorkbenchAdapter { private static TestAdaptableWorkbenchAdapter singleton = new TestAdaptableWorkbenchAdapter ( ) ; public static TestAdaptableWorkbenchAdapter getInstance ( ) { return singleton ; } public TestAdaptableWorkbenchAdapter ( ) { } public Object [ ] getChildren ( Object o ) { if ( o instanceof AdaptableResourceWrapper ) return ( ( AdaptableResourceWrapper ) o ) . getChildren ( ) ; if ( o instanceof IResource ) { AdaptableResourceWrapper wrapper = new AdaptableResourceWrapper ( ( IResource ) o ) ; return wrapper . getChildren ( ) ; } return new Object [ 0 ] ; } public ImageDescriptor getImageDescriptor ( Object object ) { return null ; } public String getLabel ( Object o ) { if ( o instanceof AdaptableResourceWrapper ) return ( ( AdaptableResourceWrapper ) o ) . getLabel ( ) ; else return null ; } public Object getParent ( Object o ) { if ( o instanceof AdaptableResourceWrapper ) return ( ( AdaptableResourceWrapper ) o ) . getParent ( ) ; else return null ; } protected ImageDescriptor decorateImage ( ImageDescriptor input , Object element ) { return input ; } protected String decorateText ( String input , Object element ) { return input ; } public final void dispose ( ) { } protected final IWorkbenchAdapter getAdapter ( Object o ) { if ( ! ( o instanceof IAdaptable ) ) { return null ; } return ( IWorkbenchAdapter ) ( ( IAdaptable ) o ) . getAdapter ( IWorkbenchAdapter . class ) ; } public final Image getImage ( Object element ) { IWorkbenchAdapter adapter = getAdapter ( element ) ; if ( adapter == null ) return null ; ImageDescriptor descriptor = adapter . getImageDescriptor ( element ) ; if ( descriptor == null ) return null ; descriptor = decorateImage ( descriptor , element ) ; return descriptor . createImage ( ) ; } public final String getText ( Object element ) { IWorkbenchAdapter adapter = getAdapter ( element ) ; if ( adapter == null ) return \"\" ; String label =", "gt": "adapter . getLabel ( element ) ;", "prediction": ";\n", "label": 1}
{"id": 841, "input": "<s> package org . davidsingleton . nnrccar ; import gnu . io . CommPortIdentifier ; import gnu . io . PortInUseException ; import gnu . io . SerialPort ; import gnu . io . UnsupportedCommOperationException ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Enumeration ; import java . util . TooManyListenersException ; public class TestSerial { public static void main ( String [ ] args ) { String portName = \"/dev/tty.usbmodemfd131\" ; Enumeration ports = CommPortIdentifier . getPortIdentifiers ( ) ; while ( ports . hasMoreElements ( ) ) { CommPortIdentifier id = ( CommPortIdentifier ) ports . nextElement ( ) ; System . out . println ( \"Port: \" + id . getName ( ) ) ; if ( id . getName ( ) . equals ( portName ) ) { System . out . println ( \"Found port\" ) ; try { SerialPort port = ( SerialPort ) id . open ( \"Driver\" , 1000 ) ; port . setSerialPortParams ( 9600 , SerialPort . DATABITS_8 , SerialPort . STOPBITS_1 , SerialPort . PARITY_NONE ) ; port", "gt": ". addEventListener ( new TestSerialEventListener ( ) ) ;", "prediction": ";\n", "label": 0}
{"id": 12516, "input": "<s> package org . nuxeo . ecm . automation . core . collectors ; import java . util . ArrayList ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . OperationException ; import org . nuxeo . ecm . automation . OutputCollector ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . DocumentRefList ; public class DocumentRefCollector extends ArrayList < DocumentRef > implements DocumentRefList , OutputCollector < DocumentRef , DocumentRefList > { private static final long serialVersionUID = 5732663048354570870L ; @ Override", "gt": "public long totalSize ( )", "prediction": ";\n", "label": 1}
{"id": 5033, "input": "<s> class Q extends P { @ Deprecated public void pDep_qDep_rDep ( ) { } @ Deprecated public void pDep_qDep_rUnd ( ) { } @ Deprecated public void pDep_qDep_rInh ( ) { } public void pDep_qUnd_rDep ( ) { } public void pDep_qUnd_rUnd ( ) { } public void pDep_qUnd_rInh ( ) { } @ Deprecated public void pUnd_qDep_rDep ( ) { } @ Deprecated public void pUnd_qDep_rUnd ( ) { } @ Deprecated public void pUnd_qDep_rInh ( ) { }", "gt": "public void pUnd_qUnd_rDep ( )", "prediction": "}\n", "label": 0}
{"id": 12517, "input": "<s> package org . fuzzydb . util ; import java . io . File ; import java . io . FileFilter ; public class FileFilters { private static final FileFilter isFile = new IsFile ( ) ; private static final FileFilter isDir = new IsDir ( ) ; public static class IsFile implements FileFilter { public boolean accept ( File file ) { return file . isFile ( ) ; } } public static class IsDir implements FileFilter { public boolean accept ( File file ) { return", "gt": "file . isFile ( ) ;", "prediction": "\n", "label": 1}
{"id": 2433, "input": "<s> package org . gk . ui . client . com . form ; import java . util . List ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBus ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import org . gk . ui . client . com . i18n . Msg ; import org . gk . ui . client . com . panel . gkFileUploadPanel ; import org . gk . ui . client . com . utils . StringUtils ; import org . gk . ui . client . icon . Icons ; import com . extjs . gxt . ui . client . Style . VerticalAlignment ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . ButtonEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . SelectionListener ; import com . extjs . gxt . ui . client . widget . HorizontalPanel ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . form . AdapterField ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . Anchor ; public class gkFileUploadField extends AdapterField { protected HorizontalPanel hp ; protected HorizontalPanel linkPanel ; protected Button uploadButton ; protected String beanName = \"\" ; public gkFileUploadField ( ) { super ( null ) ; init ( ) ; widget = hp ; } public gkFileUploadField ( String id ) { super ( null ) ; setId ( id ) ; init ( ) ; widget = hp ; } public gkFileUploadField ( String id , String label ) { this ( id ) ; setFieldLabel ( label ) ; } private void init ( ) { hp = new HorizontalPanel ( ) ; linkPanel = new HorizontalPanel ( ) ; linkPanel . setVerticalAlign ( VerticalAlignment . MIDDLE ) ; uploadButton = new Button ( ) ; uploadButton . setIconStyle ( \"icsc-create\" ) ; uploadButton . addSelectionListener (", "gt": "new SelectionListener < ButtonEvent > ( )", "prediction": ") ;\n", "label": 0}
{"id": 12529, "input": "<s> package io . beancounter . commons . model ; import io . beancounter . commons . model . activity . Activity ; import java . util . ArrayList ; import java . util . List ; public class UserActivities { private String username ; private List < Activity > activities = new ArrayList < Activity > ( ) ; public UserActivities ( String username , List < Activity > activities ) { this . username = username ; this . activities = activities ; } public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public List < Activity > getActivities ( ) { return activities ; } public void setActivities ( List < Activity > activities ) { this . activities = activities ; } public boolean addActivity ( Activity activity ) { return activities . add ( activity ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; UserActivities that", "gt": "= ( UserActivities ) o ;", "prediction": ";\n", "label": 1}
{"id": 9244, "input": "<s> package com . l7 . mitra . client . ui ; import java . io . IOException ; import javax . swing . SwingWorker ; import com . l7 . mitra . client . oauth . ProtectedResourceClient ; public class ProtectedResourceSwingClient extends SwingWorker { public String url = \"\" ; public String bearerToken = \"\" ; public ProtectedResourceSwingClient ( ) { } @ Override protected Object doInBackground ( ) throws Exception { try { ProtectedResourceClient resClient = new ProtectedResourceClient ( ) ; String response = resClient . call ( url , bearerToken ) ; MessageLog . getInstance", "gt": "( ) . addMessage ( response ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12540, "input": "<s> package org . gatein . common . i18n ; import org . gatein . common . io . UndeclaredIOException ; import org . gatein . common . util . ConversionException ; import org . gatein . common . util . NullConversionException ; import org . gatein . common . text . CharBuffer ; import org . gatein . common . text . CharWriter ; import java . io . IOException ; import java . util . Locale ; public abstract class AbstractLocaleFormat implements LocaleFormat { public Locale getLocale ( String value ) throws ConversionException { if ( value == null ) { throw new NullConversionException ( \"No null locale value accepted\" ) ; } return internalGetLocale ( value ) ; } public String toString ( Locale locale ) throws ConversionException { if ( locale == null ) { throw new NullConversionException ( \"No null locale accepted\" ) ; } return internalToString ( locale ) ; } public void write ( Locale locale", "gt": ", CharWriter writer ) throws IOException , ConversionException", "prediction": ")\n", "label": 1}
{"id": 8694, "input": "<s> package org . ofbiz . service . mail ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ByteArrayInputStream ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . sql . Timestamp ; import java . util . List ; import java . util . Properties ; import javax . mail . Address ; import javax . mail . BodyPart ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Multipart ; import javax . mail . Part ; import javax . mail . Session ; import javax . mail . internet . MimeMessage ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralRuntimeException ; import org . ofbiz . base . util . UtilDateTime ; @ SuppressWarnings ( \"serial\" ) public class MimeMessageWrapper implements java . io . Serializable { public static final String module = MimeMessageWrapper . class . getName ( ) ; protected transient MimeMessage message = null ; protected transient Session session = null ; protected Properties mailProperties = null ; protected String contentType = null ; protected byte [ ] serializedBytes = null ; protected int parts = 0 ; public MimeMessageWrapper ( Session session , MimeMessage message ) { this ( session ) ; this . setMessage ( message ) ; } public MimeMessageWrapper ( Session session ) { this . setSession ( session ) ; } public void setSession ( Session session ) { this . session = session ; this . mailProperties = session . getProperties ( ) ; } public synchronized Session getSession ( ) { if ( session == null ) { session = Session . getInstance ( mailProperties , null ) ; } return session ; } public void setMessage ( MimeMessage message ) { if ( message != null ) { this . message = message ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { message . writeTo ( baos ) ; baos . flush ( ) ; serializedBytes = baos . toByteArray ( ) ; this . contentType = message . getContentType ( ) ; Object content = message . getContent ( ) ; if ( content instanceof Multipart ) { Multipart mp = ( Multipart ) content ; this . parts = mp . getCount ( ) ; } else { this . parts = 0 ; } } catch ( MessagingException e ) { Debug . logError ( e , module ) ; } catch ( IOException e ) { Debug . logError ( e , module ) ; } finally { try { baos . close ( ) ; } catch ( IOException e ) { Debug . logError ( e , module ) ; } } } } public synchronized MimeMessage getMessage ( ) { if ( message == null ) { if ( serializedBytes != null ) { ByteArrayInputStream bais = new ByteArrayInputStream ( serializedBytes ) ; try { message = new MimeMessage ( this . getSession ( ) , bais ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; throw new GeneralRuntimeException ( e . getMessage ( ) , e ) ; } } } return message ; } public String getFirstHeader ( String header ) { String [ ] headers = getHeader ( header ) ; if ( headers != null && headers . length > 0 ) { return headers [ 0 ] ; } else { return null ; } } public String [ ] getHeader ( String header ) { MimeMessage message = getMessage ( ) ; try { return message . getHeader ( header ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public Address [ ] getFrom ( ) { MimeMessage message = getMessage ( ) ; try { return message . getFrom ( ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public Address [ ] getTo ( ) { MimeMessage message = getMessage ( ) ; try { return message . getRecipients ( MimeMessage . RecipientType . TO ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public Address [ ] getCc ( ) { MimeMessage message = getMessage ( ) ; try { return message . getRecipients ( MimeMessage . RecipientType . CC ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public Address [ ] getBcc ( ) { MimeMessage message = getMessage ( ) ; try { return message . getRecipients ( MimeMessage . RecipientType . BCC ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public String getSubject ( ) { MimeMessage message = getMessage ( ) ; try { return message . getSubject ( ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public String getMessageId ( ) { MimeMessage message = getMessage ( ) ; try { return message . getMessageID ( ) ; } catch ( MessagingException e ) { Debug . logError ( e , module ) ; return null ; } } public Timestamp getSentDate ( ) { MimeMessage message = getMessage ( ) ; try { return UtilDateTime . toTimestamp (", "gt": "message . getSentDate ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12546, "input": "<s> package org . apache . lucene . demo . html ; public class Token { public int kind ; public int beginLine , beginColumn , endLine , endColumn ; public String image ; public Token next ; public Token specialToken ; public String toString ( ) { return image ; } public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default :", "gt": "return new Token ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3712, "input": "<s> package com . matburt . mobileorg . util ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import android . content . Context ; import android . content . SharedPreferences ; import android . os . Environment ; import android . preference . PreferenceManager ; public class FileUtils { public static final String CAPTURE_FILE = \"mobileorg.org\" ; public static final String CAPTURE_FILE_ALIAS = \"Captures\" ; private Context context ; private String fileName ; public FileUtils ( String file , Context context ) { this . context = context ; this . fileName = file . replace ( \"/\" , \"_\" ) ; } public String read ( ) throws IOException { return read ( getReader ( ) ) ; } public static String read ( BufferedReader reader ) throws IOException { if ( reader == null ) { return \"\" ; } StringBuilder fileContents = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { fileContents . append ( line ) ; fileContents . append ( \"\\n\" ) ; } return fileContents . toString ( ) ; } public void write ( String filePath , String content ) throws IOException { File file = new File ( filePath ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file , true ) ) ; writer . write ( content ) ; writer . close ( ) ; } public BufferedReader getReader ( ) { String storageMode = getStorageMode ( ) ; String synchMode = getSynchMode ( ) ; BufferedReader reader = null ; try { if ( storageMode . equals ( \"sdcard\" ) || synchMode . equals ( \"sdcard\" ) ) { File root = Environment . getExternalStorageDirectory ( ) ; File morgDir = new File ( root , \"mobileorg\" ) ; File morgFile = new File ( morgDir , fileName ) ; if ( ! morgFile . exists ( ) ) { return null ; } FileReader freader = new FileReader ( morgFile ) ; reader = new BufferedReader ( freader ) ; } else if ( storageMode . equals ( \"internal\" ) || storageMode . equals ( \"\" ) ) { String dirActual = this . fileName ; FileInputStream fs ; fs = context . openFileInput ( dirActual ) ; reader = new BufferedReader ( new InputStreamReader ( fs ) ) ; } } catch ( FileNotFoundException e ) { return null ; } return reader ; } public BufferedWriter getWriter ( ) throws IOException { return getWriter ( false ) ; } public BufferedWriter getWriter ( boolean append ) throws IOException { String storageMode = getStorageMode ( ) ; BufferedWriter writer = null ; if ( storageMode . equals ( \"internal\" ) || storageMode . equals ( \"\" ) ) { FileOutputStream fs ; String normalized = fileName . replace ( \"/\" , \"_\" ) ; if ( append ) fs = context . openFileOutput ( normalized , Context . MODE_APPEND ) ; else fs = context . openFileOutput ( normalized , Context . MODE_PRIVATE ) ; writer = new BufferedWriter ( new OutputStreamWriter ( fs ) ) ; } else if ( storageMode . equals ( \"sdcard\" ) ) { File root = Environment . getExternalStorageDirectory ( ) ; File morgDir = new File ( root , \"mobileorg\" ) ; morgDir . mkdir ( ) ; if ( morgDir . canWrite ( ) ) { File orgFileCard = new File ( morgDir , fileName ) ; FileWriter orgFWriter = new FileWriter ( orgFileCard , append ) ; writer = new BufferedWriter ( orgFWriter ) ; } } return writer ; } public File getFile ( ) { String storageMode = getStorageMode ( ) ; if ( storageMode . equals ( \"internal\" ) || storageMode . equals ( \"\" ) ) { File morgFile = new File ( \"/data/data/com.matburt.mobileorg/files\" , fileName ) ; return morgFile ; } else if ( storageMode . equals ( \"sdcard\" ) ) { File root = Environment . getExternalStorageDirectory ( ) ; File morgDir = new File ( root , \"mobileorg\" ) ; File morgFile = new File ( morgDir , fileName ) ; if ( ! morgFile . exists ( ) ) { return null ; } return morgFile ; } return null ; } public void fetch ( BufferedReader reader ) throws IOException { BufferedWriter writer = getWriter ( ) ; final int BUFFER_SIZE = 23 * 1024 ; char [ ] baf", "gt": "= new char [ BUFFER_SIZE ] ;", "prediction": ";\n", "label": 0}
{"id": 12561, "input": "<s> package org . apache . lucene . analysis ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import java . io . StringReader ; public class TestISOLatin1AccentFilter extends BaseTokenStreamTestCase { public void testU ( ) throws Exception { TokenStream stream = new WhitespaceTokenizer ( new StringReader ( \"Des mot cl\u00e9s \u00c0 LA CHA\u00ceNE \u00c0 \u00c1 \u00c2 \u00c3 \u00c4 \u00c5 \u00c6 \u00c7 \u00c8 \u00c9 \u00ca \u00cb \u00cc \u00cd \u00ce \u00cf \u0132 \u00d0 \u00d1 \u00d2 \u00d3 \u00d4 \u00d5 \u00d6 \u00d8 \u0152 \u00de \u00d9 \u00da \u00db \u00dc \u00dd \u0178 \u00e0 \u00e1 \u00e2 \u00e3 \u00e4 \u00e5 \u00e6 \u00e7 \u00e8 \u00e9 \u00ea \u00eb \u00ec \u00ed \u00ee \u00ef \u0133 \u00f0 \u00f1 \u00f2 \u00f3 \u00f4 \u00f5 \u00f6 \u00f8 \u0153 \u00df \u00fe \u00f9 \u00fa \u00fb \u00fc \u00fd \u00ff \ufb01 \ufb02\" ) ) ; ISOLatin1AccentFilter filter = new ISOLatin1AccentFilter ( stream ) ; TermAttribute termAtt = ( TermAttribute ) filter . getAttribute ( TermAttribute . class ) ; assertTermEquals ( \"Des\" , filter , termAtt ) ; assertTermEquals ( \"mot\" , filter , termAtt ) ; assertTermEquals ( \"cles\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"LA\" , filter , termAtt ) ; assertTermEquals ( \"CHAINE\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"A\" , filter , termAtt ) ; assertTermEquals ( \"AE\" , filter , termAtt ) ; assertTermEquals ( \"C\" , filter , termAtt ) ; assertTermEquals ( \"E\" , filter , termAtt ) ; assertTermEquals ( \"E\" , filter , termAtt ) ; assertTermEquals ( \"E\" , filter , termAtt ) ; assertTermEquals ( \"E\" , filter , termAtt ) ; assertTermEquals ( \"I\" , filter , termAtt ) ; assertTermEquals ( \"I\" , filter , termAtt ) ; assertTermEquals ( \"I\" , filter , termAtt ) ; assertTermEquals ( \"I\" , filter , termAtt ) ; assertTermEquals ( \"IJ\" , filter , termAtt ) ; assertTermEquals ( \"D\" , filter , termAtt ) ; assertTermEquals ( \"N\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"O\" , filter , termAtt ) ; assertTermEquals ( \"OE\" , filter , termAtt ) ; assertTermEquals ( \"TH\" , filter , termAtt ) ; assertTermEquals ( \"U\" , filter , termAtt ) ; assertTermEquals ( \"U\" , filter , termAtt ) ; assertTermEquals ( \"U\" , filter , termAtt ) ; assertTermEquals ( \"U\" , filter , termAtt ) ; assertTermEquals ( \"Y\" , filter , termAtt ) ; assertTermEquals ( \"Y\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"a\" , filter , termAtt ) ; assertTermEquals ( \"ae\" , filter , termAtt ) ; assertTermEquals ( \"c\" , filter , termAtt ) ; assertTermEquals ( \"e\" , filter , termAtt ) ; assertTermEquals ( \"e\" , filter , termAtt ) ; assertTermEquals ( \"e\" , filter , termAtt ) ; assertTermEquals ( \"e\" , filter , termAtt ) ; assertTermEquals ( \"i\" , filter , termAtt ) ; assertTermEquals ( \"i\" , filter , termAtt ) ; assertTermEquals ( \"i\" , filter , termAtt ) ; assertTermEquals ( \"i\" , filter , termAtt ) ; assertTermEquals ( \"ij\" , filter , termAtt ) ; assertTermEquals ( \"d\" , filter , termAtt ) ; assertTermEquals ( \"n\" , filter , termAtt ) ; assertTermEquals ( \"o\" , filter , termAtt ) ; assertTermEquals ( \"o\" , filter , termAtt ) ; assertTermEquals ( \"o\"", "gt": ", filter , termAtt ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6974, "input": "<s> package com . extjs . gxt . ui . client . widget . form ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . DomEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . PreviewEvent ; import com . extjs . gxt . ui . client . util . BaseEventPreview ; import com . extjs . gxt . ui . client . util . Size ; import com . google . gwt . dom . client . Style . VerticalAlign ; import com . google . gwt . event . dom . client . KeyCodes ; import com . google . gwt . user . client . Command ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . DeferredCommand ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; @ SuppressWarnings ( \"deprecation\" ) public class TriggerField < D > extends TextField < D > { protected BaseEventPreview focusEventPreview ; protected El trigger ; protected String triggerStyle = \"x-form-trigger-arrow\" ; protected boolean mimicing ; private boolean editable = true ; private boolean monitorTab = true ; private boolean hideTrigger ; public TriggerField ( ) { super ( ) ; } public String getTriggerStyle ( ) { return triggerStyle ; } public boolean isEditable ( ) { return editable ; } public boolean isHideTrigger ( ) { return hideTrigger ; } public boolean isMonitorTab ( ) { return monitorTab ; } public void setEditable ( boolean editable ) { this . editable = editable ; if ( rendered ) { El fromEl = getInputEl ( ) ; if ( ! readOnly ) { fromEl . dom . setPropertyBoolean ( \"readOnly\" , ! editable ) ; } fromEl . setStyleName ( \"x-triggerfield-noedit\" , ! editable ) ; if ( GXT . isAriaEnabled ( ) ) { fromEl . dom . setAttribute ( \"aria-readonly\" , editable ? \"false\" : \"true\" ) ; } } } public void setHideTrigger ( boolean hideTrigger ) { this . hideTrigger = hideTrigger ; } public void setMonitorTab ( boolean monitorTab ) { this . monitorTab = monitorTab ; } public void setTriggerStyle ( String triggerStyle ) { this . triggerStyle = triggerStyle ; } @ Override public void setReadOnly ( boolean readOnly ) { this . readOnly = readOnly ; if ( rendered ) { el ( ) . setStyleName ( readOnlyFieldStyle , readOnly ) ; if ( editable || ( readOnly && ! editable ) ) { getInputEl ( ) . dom . setPropertyBoolean ( \"readOnly\" , readOnly ) ; } getInputEl ( ) . setStyleAttribute ( \"background\" , readOnly ? \"buttonface\" : \"\" ) ; } } @ Override protected Size adjustInputSize ( ) { return new Size ( hideTrigger ? 0 : trigger . getStyleSize ( ) . width , 0 ) ; } @ Override protected void afterRender ( ) { super . afterRender ( ) ; addStyleOnOver ( trigger . dom , \"x-form-trigger-over\" ) ; removeStyleName ( fieldStyle ) ; } protected void beforeBlur ( ) { } protected void mimicBlur ( PreviewEvent e , Element target ) { if ( ! el ( ) . dom . isOrHasChild ( target ) && validateBlur ( e , target ) ) { triggerBlur ( null ) ; } } @ Override protected void onKeyDown ( FieldEvent fe ) { super . onKeyDown ( fe ) ; if ( monitorTab && fe . getKeyCode ( ) == KeyCodes . KEY_TAB ) { triggerBlur ( fe ) ; } } @ Override protected void onBlur ( ComponentEvent ce ) { } @ Override protected void onClick ( ComponentEvent ce ) { if ( ! readOnly && ( ( ! editable && getInputEl ( ) . dom . isOrHasChild ( ce . getTarget ( ) ) ) || ( trigger . dom . isOrHasChild ( ce . getTarget ( ) ) ) ) ) { onTriggerClick ( ce ) ; } super . onClick ( ce ) ; } @ Override protected void onDisable ( ) { super . onDisable ( ) ; addStyleName ( \"x-item-disabled\" ) ; } @ Override protected void onEnable ( ) { super . onEnable ( ) ; removeStyleName ( \"x-item-disabled\" ) ; } @ Override protected void", "gt": "onFocus ( ComponentEvent ce )", "prediction": "( )\n", "label": 0}
{"id": 12568, "input": "<s> package org . mitre . openid . connect . client ; import java . util . Collection ; import org . mitre . openid . connect . model . UserInfo ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . security . authentication . AuthenticationProvider ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . core . authority . SimpleGrantedAuthority ; import org . springframework . security . core . authority . mapping . GrantedAuthoritiesMapper ; import org . springframework . security . core . authority . mapping . NullAuthoritiesMapper ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import com . google . common . base . Strings ; import com . google . common . collect . Sets ; public class OIDCAuthenticationProvider implements AuthenticationProvider , InitializingBean { private UserInfoFetcher userInfoFetcher = new UserInfoFetcher ( ) ; private GrantedAuthoritiesMapper authoritiesMapper = new NullAuthoritiesMapper ( ) ; @ Override public void afterPropertiesSet ( ) throws Exception { } @ Override public Authentication authenticate ( final Authentication authentication ) throws AuthenticationException { if ( ! supports ( authentication . getClass ( ) ) ) { return null ; } if ( authentication instanceof OIDCAuthenticationToken ) { Collection < SimpleGrantedAuthority > authorities = Sets . newHashSet ( new SimpleGrantedAuthority ( \"ROLE_USER\" ) ) ; OIDCAuthenticationToken token = ( OIDCAuthenticationToken ) authentication ; UserInfo userInfo =", "gt": "userInfoFetcher . loadUserInfo ( token ) ;", "prediction": ";\n", "label": 1}
{"id": 7151, "input": "<s> package com . sun . tools . javac . parser ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Names ; import static com . sun . tools . javac . parser . Token . * ; public class Keywords { public static final Context . Key < Keywords > keywordsKey = new Context . Key < Keywords > ( ) ; public static Keywords instance ( Context context ) { Keywords instance = context . get ( keywordsKey ) ; if ( instance == null ) instance = new Keywords ( context ) ; return instance ; } private final Names names ; protected Keywords ( Context context ) { context . put ( keywordsKey , this ) ; names = Names . instance ( context ) ; for ( Token t : Token . values ( ) ) { if ( t . name != null ) enterKeyword ( t . name , t ) ; else tokenName [ t . ordinal ( ) ] = null ; } key = new Token [ maxKey + 1 ] ; for ( int i = 0 ; i <= maxKey ; i ++ ) key [ i ] = IDENTIFIER ; for ( Token t : Token . values ( ) ) { if ( t . name != null ) key [ tokenName [ t . ordinal ( ) ] . getIndex ( ) ] = t ; } } public Token key ( Name name ) { return ( name . getIndex ( ) > maxKey ) ? IDENTIFIER : key [ name . getIndex ( ) ] ; } private final Token [ ] key ; private int maxKey = 0 ; private Name [ ] tokenName = new Name", "gt": "[ Token . values ( ) . length ] ;", "prediction": ";\n", "label": 0}
{"id": 12571, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . marshaling . io ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . io . ExportedDocument ; import org . nuxeo . ecm . core . io . impl . ExportedDocumentImpl ; import org . nuxeo . ecm . core . io . impl . plugins . DocumentModelReader ; import java . io . IOException ; public class SingleDocumentReaderWithInLineBlobs extends DocumentModelReader { protected DocumentModel doc ; private boolean readDone = false ; public SingleDocumentReaderWithInLineBlobs ( CoreSession session , DocumentModel doc ) { super ( session ) ; this . doc = doc ; } @ Override public void close ( ) { super . close ( ) ; session = null ; doc = null ; } @ Override public ExportedDocument read ( ) throws IOException { if ( doc != null ) { if ( readDone ) { return null ; } else { readDone = true ; return new ExportedDocumentImpl (", "gt": "doc , true ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3237, "input": "<s> package Liza ; import org . bukkit . entity . Cow ;", "gt": "public interface LizaCow extends Cow", "prediction": "}\n", "label": 0}
{"id": 12595, "input": "<s> package org . fuzzydb . io . packet . layer1 ; import java . io . IOException ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . ClosedSelectorException ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . nio . channels . spi . SelectorProvider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . io . core . SourcedMessage ; import org . fuzzydb . io . core . exceptions . NotListeningException ; import org . fuzzydb . io . core . layer2 . SourcedMessageImpl ; import org . fuzzydb . io . core . messages . PacketMessage ; import org . fuzzydb . io . packet . CommsStack ; import org . slf4j . Logger ; public abstract class ConnectionManagerImpl implements ConnectionManager { static private final Logger log = LogFactory . getLogger ( ConnectionManagerImpl . class ) ; protected Selector selector ; protected Map < SelectionKey , CommsStack > connections = Collections . synchronizedMap ( new HashMap < SelectionKey , CommsStack > ( ) ) ; protected ConnectionManagerImpl ( ) throws IOException { selector = SelectorProvider . provider ( ) . openSelector ( ) ; } public int getNumberOfConnections ( ) { return connections . size ( ) ; } public void close ( ) { synchronized ( connections ) { for ( Map . Entry < SelectionKey , CommsStack > entry : connections . entrySet ( ) ) { entry . getKey ( ) . cancel ( ) ; entry . getValue ( ) . getMessageInterface ( ) . close ( ) ; } connections . clear ( ) ; } try { selector . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } protected Collection < SourcedMessage > processReadyKeys ( Set < SelectionKey > readyKeys ) { Collection < SourcedMessage > messages = new ArrayList < SourcedMessage > ( ) ; Iterator < SelectionKey > i = readyKeys . iterator ( ) ; while ( i . hasNext ( ) ) { SelectionKey sk = i . next ( ) ; i . remove ( ) ; CommsStack stack = connections . get ( sk ) ; if ( stack != null ) { try { if ( sk . isReadable ( ) ) { stack . getDriver ( ) . eventReadable ( ) ; Collection <", "gt": "PacketMessage > incoming = null ;", "prediction": "}\n", "label": 1}
{"id": 5203, "input": "<s> package com . sun . tools . javac . parser ; import java . nio . CharBuffer ; import com . sun . tools . javac . code . Source ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Names ; public class ScannerFactory { public static final Context . Key < ScannerFactory > scannerFactoryKey = new Context . Key < ScannerFactory > ( ) ; public static ScannerFactory instance ( Context context ) { ScannerFactory instance = context . get ( scannerFactoryKey ) ; if ( instance == null ) instance = new ScannerFactory ( context ) ; return instance ; } final Log log ; final Names names ; final Source source ; final Keywords keywords ; protected ScannerFactory ( Context context ) { context . put ( scannerFactoryKey , this ) ; this . log = Log . instance ( context ) ; this . names = Names . instance ( context ) ; this . source = Source . instance ( context ) ; this . keywords = Keywords . instance ( context ) ; } public Scanner newScanner ( CharSequence input , boolean keepDocComments ) { if", "gt": "( input instanceof CharBuffer )", "prediction": "( )\n", "label": 0}
{"id": 12611, "input": "<s> package org . eclipse . ui . internal . commands ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionDelta ; import org . eclipse . core . runtime . IExtensionRegistry ; import org . eclipse . core . runtime . IRegistryChangeEvent ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . internal . services . RegistryPersistence ; import org . eclipse . ui . plugin . AbstractUIPlugin ; final class CommandImagePersistence extends RegistryPersistence { private static final int INDEX_IMAGES = 0 ; private static final void readImagesFromRegistry ( final IConfigurationElement [ ] configurationElements , final int configurationElementCount , final CommandImageManager commandImageManager , final ICommandService commandService ) { commandImageManager . clear ( ) ; final List warningsToLog = new ArrayList ( 1 ) ; for ( int i = 0 ; i < configurationElementCount ; i ++ ) { final IConfigurationElement configurationElement = configurationElements [ i ] ; final String commandId = readRequired ( configurationElement , ATT_COMMAND_ID , warningsToLog , \"Image needs an id\" ) ; if ( commandId == null ) { continue ; } if ( ! commandService . getCommand ( commandId ) . isDefined ( ) ) { addWarning ( warningsToLog , \"Cannot bind to an undefined command\" , configurationElement , commandId ) ; continue ; } final String style = readOptional ( configurationElement , ATT_STYLE ) ; final String icon = readRequired ( configurationElement , ATT_ICON , warningsToLog , commandId ) ; if ( icon == null ) { continue ; } final String disabledIcon = readOptional ( configurationElement , ATT_DISABLEDICON ) ; final String hoverIcon = readOptional ( configurationElement , ATT_HOVERICON ) ; String namespaceId = configurationElement . getNamespaceIdentifier ( ) ; ImageDescriptor iconDescriptor = AbstractUIPlugin . imageDescriptorFromPlugin ( namespaceId , icon ) ; commandImageManager . bind ( commandId , CommandImageManager . TYPE_DEFAULT , style , iconDescriptor ) ; if ( disabledIcon != null ) { ImageDescriptor disabledIconDescriptor = AbstractUIPlugin . imageDescriptorFromPlugin ( namespaceId , disabledIcon ) ; commandImageManager . bind ( commandId , CommandImageManager . TYPE_DISABLED , style , disabledIconDescriptor ) ; } if ( hoverIcon != null ) { ImageDescriptor hoverIconDescriptor = AbstractUIPlugin . imageDescriptorFromPlugin ( namespaceId , hoverIcon ) ; commandImageManager . bind ( commandId , CommandImageManager . TYPE_HOVER , style , hoverIconDescriptor ) ; } } logWarnings ( warningsToLog , \"Warnings while parsing the images from the 'org.eclipse.ui.commandImages' extension point.\" ) ; } private final CommandImageManager commandImageManager ; private final ICommandService commandService ; CommandImagePersistence ( final CommandImageManager commandImageManager , final ICommandService commandService ) { this . commandImageManager = commandImageManager ; this . commandService = commandService ; } protected final boolean isChangeImportant ( final IRegistryChangeEvent event ) { final IExtensionDelta [ ] imageDeltas = event . getExtensionDeltas ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_COMMAND_IMAGES ) ; return ( imageDeltas . length != 0 ) ; } protected final void read ( ) { super . read ( ) ; final IExtensionRegistry registry = Platform . getExtensionRegistry ( ) ; int imageCount = 0 ; final IConfigurationElement [ ] [ ] indexedConfigurationElements = new IConfigurationElement [ 1 ] [ ] ; final IConfigurationElement [ ] commandImagesExtensionPoint = registry . getConfigurationElementsFor ( EXTENSION_COMMAND_IMAGES ) ; for ( int i = 0 ; i < commandImagesExtensionPoint . length ; i ++ ) { final IConfigurationElement configurationElement = commandImagesExtensionPoint [ i ] ; final String name = configurationElement . getName ( ) ; if ( TAG_IMAGE . equals ( name ) ) { addElementToIndexedArray ( configurationElement , indexedConfigurationElements , INDEX_IMAGES , imageCount ++ ) ; } } readImagesFromRegistry ( indexedConfigurationElements [ INDEX_IMAGES ]", "gt": ", imageCount , commandImageManager , commandService ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9278, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Creature ; public interface LizaCreature extends Creature { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities (", "gt": "double x , double y , double z ) ;", "prediction": ")\n", "label": 0}
{"id": 12615, "input": "<s> package agentStrategy . k ; import risk . Territory ; import sim . util . Bag ; public class Util { public static String toString ( Territory t ) { return \"Territory Id: \" + Integer . toString ( t . getId ( ) ) + \" Type: \" + Integer . toString ( t . getType ( ) ) + \" Resources: \" + Double . toString ( t . getNatRes ( ) ) + \" Peasants: \" + Double . toString ( t . getPeasants ( ) ) + \" Alpha: \" + Double . toString ( t . getAlpha ( ) ) + \" Superior: \" + t . getSuperior ( ) == null ? \"none\" : ( \"(Id:\" + t . getSuperior ( ) . getId ( ) + \", Type:\" + t . getSuperior ( ) . getType ( ) + \")\" ) + \" Subjects: \" + toString ( t . getSubordinates ( ) ) ; } public static String toString ( Bag b ) { String t = \"\" ; for ( Object o : b ) { t . concat ( \", \" ) ; t . concat", "gt": "( o . toString ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 1746, "input": "<s> import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; import static javax . tools . Diagnostic . Kind . * ; public class TestMissingElement extends JavacTestingAbstractProcessor { @ Override public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { for ( TypeElement te : ElementFilter . typesIn ( roundEnv . getRootElements ( ) ) ) { if ( isSimpleName ( te , \"InvalidSource\" ) ) { for ( Element c : te . getEnclosedElements ( ) ) { for ( AnnotationMirror am : c . getAnnotationMirrors ( ) ) { Element ate = am . getAnnotationType ( ) . asElement ( ) ; if ( isSimpleName ( ate , \"ExpectInterfaces\" ) ) { checkInterfaces ( ( TypeElement ) c , getValue ( am ) ) ; } else if ( isSimpleName ( ate , \"ExpectSupertype\" ) ) { checkSupertype ( ( TypeElement ) c , getValue ( am ) ) ; } } } } } return true ; } private boolean isSimpleName ( Element e , String name ) { return e . getSimpleName ( ) . contentEquals ( name ) ; } private String getValue ( AnnotationMirror am ) { Map < ? extends ExecutableElement , ? extends AnnotationValue > map = am . getElementValues ( ) ; if ( map . size ( ) != 1 ) throw new IllegalArgumentException ( ) ; AnnotationValue v = map . values ( ) . iterator ( ) . next ( ) ; return ( String ) v . getValue ( ) ; } private void checkInterfaces ( TypeElement te , String expect ) { System . err . println ( \"check interfaces: \" + te + \" -- \" + expect ) ; String found = asString ( te . getInterfaces ( ) , \", \" ) ; checkEqual ( \"interfaces\" , te , found , expect ) ; } private void checkSupertype ( TypeElement te , String expect ) { System . err . println ( \"check supertype: \" + te + \" -- \" + expect ) ; String found = asString ( te . getSuperclass ( ) ) ; checkEqual ( \"supertype\" , te , found , expect ) ; } private void checkEqual ( String label , TypeElement te , String found , String expect ) { if ( found . equals ( expect ) ) { } else { System . err . println ( \"unexpected \" + label + \": \" + te + \"\\n\" + \" found: \" + found + \"\\n\" + \"expect: \" + expect ) ; messager . printMessage ( ERROR , \"unexpected \" + label + \" found: \" + found + \"; expected: \" + expect , te ) ; } } private String asString ( List < ? extends TypeMirror > ts , String sep ) { StringBuilder sb = new StringBuilder ( ) ; for ( TypeMirror t : ts ) { if ( sb . length ( ) != 0 ) sb . append ( sep ) ; sb . append ( asString ( t ) ) ; } return sb . toString ( ) ; } private String asString ( TypeMirror t ) { if ( t == null ) return \"[typ:null]\" ; return t . accept ( new SimpleTypeVisitor7 < String , Void > ( ) { @ Override public String defaultAction ( TypeMirror t , Void ignore ) { return \"[typ:\" + t", "gt": ". toString ( ) + \"]\" ;", "prediction": ";\n", "label": 0}
{"id": 12628, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . MediaType ; import org . restlet . example . book . restlet . ch09 . common . AccountRepresentation ; import org . restlet . example . book . restlet . ch09 . common . AccountsResource ; import org . restlet . ext . wadl . ApplicationInfo ; import org . restlet . ext . wadl . DocumentationInfo ; import org . restlet . ext . wadl . MethodInfo ; import org . restlet . ext . wadl . RepresentationInfo ; import org . restlet . ext . wadl . WadlServerResource ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; public class AccountsServerResource extends WadlServerResource implements AccountsResource { private static final List < AccountRepresentation > accounts = new CopyOnWriteArrayList < AccountRepresentation > ( ) ; @ Override protected void describe ( ApplicationInfo applicationInfo ) { RepresentationInfo rep = new RepresentationInfo ( MediaType . TEXT_PLAIN ) ; rep . setIdentifier ( \"account\" ) ; applicationInfo . getRepresentations ( ) . add ( rep ) ; DocumentationInfo doc = new DocumentationInfo ( ) ; doc . setTitle ( \"Account\" ) ; doc . setTextContent ( \"Simple string containing the account ID\" ) ; rep . getDocumentations", "gt": "( ) . add ( doc ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 9467, "input": "<s> package org . parboiled . support ; import org . testng . annotations . Test ; import java . util . * ; import static org . testng . Assert . assertEquals ; import static org . testng . Assert . assertFalse ; import static org . testng . Assert . assertTrue ; public class ValueStackTest { @ Test public void testValueStack ( ) { ValueStack < Integer > stack = new DefaultValueStack < Integer > ( ) ; assertTrue ( stack . isEmpty ( ) ) ; stack . push ( 18 ) ; assertEquals ( stack . size ( ) , 1 ) ; assertFalse ( stack . isEmpty ( ) ) ; assertEquals ( stack . peek ( ) , ( Integer ) 18 ) ; assertEquals ( stack . pop ( ) , ( Integer ) 18 ) ; assertTrue ( stack . isEmpty ( ) ) ; stack . pushAll ( 18 , 26 , 42 ) ; assertEquals ( stack . size ( ) , 3 ) ; assertFalse ( stack . isEmpty ( ) ) ; assertEquals ( stack . peek ( ) , ( Integer ) 42 ) ; assertEquals ( stack . peek ( 2 ) , ( Integer ) 18 ) ; assertEquals ( stack . pop ( ) , ( Integer ) 42 ) ; assertEquals ( stack . size ( ) , 2 ) ; stack . swap ( ) ; assertEquals ( stack . size ( ) , 2 ) ; assertEquals ( stack . peek ( ) ,", "gt": "( Integer ) 18 ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12637, "input": "<s> package org . nuxeo . ecm . platform . mail . service ; import java . util . Map ; import javax . mail . Address ; import javax . mail . Session ; import javax . mail . Store ; import javax . mail . Transport ; import org . nuxeo . ecm . platform . mail . action . MailBoxActions ; import org . nuxeo . ecm . platform . mail . action . MessageActionPipe ; import org . nuxeo . ecm . platform . mail . fetcher . PropertiesFetcher ; public interface MailService { MailBoxActions getMailBoxActions ( String factoryName , String folderName ) throws Exception ; MailBoxActions getMailBoxActions ( String factoryName , String folderName , Map < String , Object > context ) throws Exception ; MessageActionPipe getPipe ( String name ) ; void sendMail ( String text , String subject , String factory , Address [ ] recipients ) throws Exception ; void sendMail ( String text , String subject , String factory , Address [ ] recipients , Map <", "gt": "String , Object > context ) throws Exception ;", "prediction": ") ;\n", "label": 1}
{"id": 1192, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; import java . util . List ; public class MemoMismatchesMatcher implements Matcher { private final Matcher inner ; private int memo = Integer . MIN_VALUE ; public MemoMismatchesMatcher ( Rule inner ) { this . inner = checkArgNotNull ( ( Matcher ) inner , \"inner\" ) ; } @ SuppressWarnings ( { \"unchecked\" } ) public < V > boolean match ( MatcherContext < V > context ) { int pos = context . getCurrentIndex ( ) ; if ( memo == pos ) { return false ; } if ( inner . match ( context ) ) { memo = Integer . MIN_VALUE ; return true ; } memo = pos ; return false ; } public List < Matcher > getChildren ( ) { return inner . getChildren ( ) ; } public Rule label ( String label ) { return new MemoMismatchesMatcher ( inner . label ( label ) ) ; } public Rule suppressNode ( ) { return new MemoMismatchesMatcher ( inner . suppressNode ( ) ) ; } public Rule suppressSubnodes ( ) { return new MemoMismatchesMatcher ( inner . suppressSubnodes ( ) ) ; } public Rule skipNode ( ) { return new MemoMismatchesMatcher ( inner", "gt": ". skipNode ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12642, "input": "<s> package org . json ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; public class JSONArray { private final ArrayList myArrayList ; public JSONArray ( ) { this . myArrayList = new ArrayList ( ) ; } public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != '[' ) { throw x . syntaxError ( \"A JSONArray text must start with '['\" ) ; } if ( x . nextClean ( ) != ']' ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) == ',' ) { x . back ( ) ; this . myArrayList . add ( JSONObject . NULL ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ';' : case ',' : if ( x . nextClean ( ) == ']' ) { return ; } x . back ( ) ; break ; case ']' : return ; default : throw x . syntaxError ( \"Expected a ',' or ']'\" ) ; } } } } public JSONArray ( String source ) throws JSONException { this ( new JSONTokener ( source ) ) ; } public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } } public JSONArray ( Object array ) throws JSONException { this ( ) ; if ( array . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i += 1 ) { this . put ( JSONObject . wrap ( Array . get ( array , i ) ) ) ; } } else { throw new JSONException ( \"JSONArray initial value should be a string or collection or array.\" ) ; } } public Object get ( int index ) throws JSONException { Object object = this . opt ( index ) ; if ( object == null ) { throw new JSONException ( \"JSONArray[\" + index + \"] not found.\" ) ; } return object ; } public boolean getBoolean ( int index ) throws JSONException { Object", "gt": "object = this . get ( index ) ;", "prediction": "\n", "label": 1}
{"id": 7792, "input": "<s> package Liza ; import org . bukkit . entity . Egg ;", "gt": "public interface LizaEgg extends Egg", "prediction": "}\n", "label": 0}
{"id": 12644, "input": "<s> package org . apache . lucene . queryParser . surround . query ; import org . apache . lucene . queryParser . surround . parser . ParseException ; import org . apache . lucene . queryParser . surround . parser . QueryParser ; public class ExceptionQueryTst { private String queryText ; private boolean verbose ; public ExceptionQueryTst ( String queryText , boolean verbose ) { this . queryText = queryText ; this . verbose = verbose ; } public void doTest ( StringBuffer failQueries ) { boolean pass = false ; SrndQuery lq = null ; try { lq = QueryParser . parse ( queryText ) ; if ( verbose ) { System . out . println ( \"Query: \" + queryText + \"\\nParsed as: \" + lq . toString ( ) ) ; } } catch ( ParseException e ) { if ( verbose ) { System . out . println ( \"Parse exception for query:\\n\" + queryText + \"\\n\" + e . getMessage ( ) ) ; } pass = true ; } if ( ! pass ) { failQueries . append ( queryText ) ; failQueries", "gt": ". append ( \"\\nParsed as: \" ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2187, "input": "<s> package api . util ; @ SuppressWarnings ( \"serial\" ) public class CouldNotLoadException extends Exception { String error ; public CouldNotLoadException ( String error ) { this", "gt": ". error = error ;", "prediction": "\n", "label": 0}
{"id": 12646, "input": "<s> package br . org . archimedes . scale ; import br . org . archimedes . Geometrics ; import br . org . archimedes . controller . Controller ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NoActiveDrawingException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . gui . model . Workspace ; import br . org . archimedes . gui . opengl . OpenGLWrapper ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . Parser ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . parser . DistanceParser ; import br . org . archimedes . parser . DoubleDecoratorParser ; import br . org . archimedes . parser . PointParser ; import br . org . archimedes . parser . SimpleSelectionParser ; import br . org . archimedes . parser . StringDecoratorParser ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; public class ScaleFactory implements CommandFactory { private Set < Element > selection ; private Point scaleReference ; private Workspace workspace ; private Controller controller ; private boolean active ; private Command command ; private Double proportion ; private Double denominator ; private Point distanceReference ; private boolean getReference ; public ScaleFactory ( ) { controller = br . org . archimedes . Utils . getController ( ) ; workspace = br . org . archimedes . Utils . getWorkspace ( ) ; deactivate ( ) ; } public String begin ( ) { active = true ; String returnValue = Messages . GetSelection ; try { Set < Element > selection = controller . getCurrentSelectedElements ( ) ; if ( selection != null && ! selection . isEmpty ( ) ) { returnValue = next ( selection ) ; } else { selection = null ; } } catch ( NoActiveDrawingException e ) { returnValue = cancel ( ) ; } catch ( InvalidParameterException e ) { e . printStackTrace ( ) ; } return returnValue ; } private void deactivate ( ) { active = false ; selection = null ; scaleReference = null ; distanceReference = null ; denominator = null ; proportion = null ; getReference = false ; } public String next ( Object parameter ) throws InvalidParameterException { String result = null ; if ( ! active || parameter == null ) { throw new InvalidParameterException ( ) ; } if ( selection == null ) { result = tryGetSelection ( parameter ) ; } else if ( scaleReference == null ) { result = tryGetScaleReference ( parameter ) ; } else if ( getReference ) { result = tryGetReference ( parameter ) ; getReference = false ; } else if ( parameter . equals ( \"r\" ) ) { getReference = true ; result = Messages . AfterR ; } else if ( denominator != null ) { Double numerator = tryGetDouble ( parameter ) ; proportion = numerator / denominator ; } else { try { proportion = tryGetDouble ( parameter ) ; } catch ( InvalidParameterException e ) { Point distancePoint ; try { distancePoint = ( Point ) parameter ; denominator = Geometrics . calculateDistance ( distanceReference , distancePoint ) ; result = Messages . GetNumerator ; } catch ( ClassCastException e1 ) { throw new InvalidParameterException ( Messages . ExpectedDoubleOrPoint ) ; } catch ( NullArgumentException e1 ) { e . printStackTrace ( ) ; } } } if ( proportion != null ) { result = completeCommand ( ) ; deactivate ( ) ; } return result ; } private String tryGetReference ( Object parameter ) throws InvalidParameterException { String message = null ; try { denominator = ( Double ) parameter ; message = Messages . GetNumerator ; } catch ( ClassCastException e ) { try { distanceReference = ( Point ) parameter ; message = Messages . GetProportion ; } catch ( ClassCastException e1 ) { throw new InvalidParameterException ( Messages . ExpectedDoubleOrPoint ) ; } } return message ; } private Double tryGetDouble ( Object parameter ) throws InvalidParameterException { Double myDouble ; try { myDouble = ( Double ) parameter ; } catch ( ClassCastException e ) { throw new InvalidParameterException ( Messages . ExpectedDouble ) ; } return myDouble ; } private String tryGetScaleReference ( Object parameter ) throws InvalidParameterException { String result ; try { scaleReference = ( Point ) parameter ; } catch ( ClassCastException e ) { throw new InvalidParameterException ( Messages . ExpectedPoint ) ; } distanceReference = scaleReference ; result = Messages . GetProportion ; workspace . setPerpendicularGripReferencePoint ( scaleReference ) ; return result ; } @ SuppressWarnings ( \"unchecked\" ) private String tryGetSelection ( Object parameter ) throws InvalidParameterException { String result ; try { selection = ( Set < Element > ) parameter ; } catch ( ClassCastException e ) { throw new InvalidParameterException ( Messages . SelectionExpected ) ; } if ( selection . isEmpty ( ) ) { selection = null ; result", "gt": "= Messages . GetSelection ;", "prediction": ";\n", "label": 1}
{"id": 8826, "input": "<s> import java . util . * ; public class T6638712d { < U > U m ( U u , List < List < U > > list ) { return null ; } void test ( List < List < String > > lls ) { m (", "gt": "1 , lls ) ;", "prediction": ")\n", "label": 0}
{"id": 12648, "input": "<s> package org . restlet . ext . jaxrs . internal . util ; import static javax . ws . rs . core . HttpHeaders . CONTENT_TYPE ; import static org . restlet . data . CharacterSet . UTF_8 ; import java . io . IOException ; import java . lang . annotation . Annotation ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . Array ; import java . lang . reflect . Field ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . nio . charset . Charset ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import javax . ws . rs . Path ; import javax . ws . rs . core . MultivaluedMap ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . CharacterSet ; import org . restlet . data . Dimension ; import org . restlet . data . MediaType ; import org . restlet . data . Metadata ; import org . restlet . engine . header . ContentType ; import org . restlet . engine . header . DimensionWriter ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . HeaderUtils ; import org . restlet . engine . util . DateUtils ; import org . restlet . ext . jaxrs . internal . core . UnmodifiableMultivaluedMap ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnClassException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnMethodException ; import org . restlet . ext . jaxrs . internal . exceptions . ImplementationException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . exceptions . JaxRsRuntimeException ; import org . restlet . ext . jaxrs . internal . exceptions . MethodInvokeException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . Representation ; import org . restlet . util . Series ; public class Util { public static final CharacterSet JAX_RS_DEFAULT_CHARACTER_SET = UTF_8 ; public static final String JAX_RS_DEFAULT_CHARACTER_SET_AS_STRING = JAX_RS_DEFAULT_CHARACTER_SET . toString ( ) ; public static final Comparator < org . restlet . data . MediaType > MEDIA_TYPE_COMP = new Comparator < org . restlet . data . MediaType > ( ) { public int compare ( org . restlet . data . MediaType mediaType1 , org . restlet . data . MediaType mediaType2 ) { if ( mediaType1 == null ) { return mediaType2 == null ? 0 : 1 ; } if ( mediaType2 == null ) { return - 1 ; } if ( mediaType1 . equals ( mediaType2 , false ) ) { return 0 ; } final int specNess1 = specificness ( mediaType1 ) ; final int specNess2 = specificness ( mediaType2 ) ; final int rt = specNess1 - specNess2 ; if ( rt != 0 ) { return rt ; } return mediaType1 . toString ( ) . compareToIgnoreCase ( mediaType2 . toString ( ) ) ; } } ; private static final byte NAME_READ = 2 ; private static final byte NAME_READ_READY = 3 ; private static final byte NAME_READ_START = 1 ; public static final String ORG_RESTLET_EXT_JAXRS_HTTP_HEADERS = \"org.restlet.ext.jaxrs.http.headers\" ; public static void append ( Appendable stb , CharSequence string , boolean convertBraces ) throws IOException { append ( stb , string , convertBraces , 0 , string . length ( ) ) ; } public static void append ( Appendable stb , CharSequence string , boolean convertBraces , int startIndex ) throws IOException { append ( stb , string , convertBraces , startIndex , string . length ( ) ) ; } public static void append ( Appendable stb , CharSequence string , boolean convertBraces , int startIndex , int endIndex ) throws IOException { if ( ! convertBraces ) { stb . append ( string , startIndex , endIndex ) ; return ; } for ( int i = startIndex ; i < endIndex ; i ++ ) { final char c = string . charAt ( i ) ; if ( c == '{' ) { stb . append ( \"%7B\" ) ; } else if ( c == '}' ) { stb . append ( \"%7D\" ) ; } else { stb . append ( c ) ; } } } public static void append ( StringBuilder stb , Object [ ] array ) { if ( ( array == null ) || ( array . length == 0 ) ) { return ; } stb . append ( array [ 0 ] ) ; for ( int i = 1 ; i < array . length ; i ++ ) { stb . append ( \", \" ) ; stb . append ( array [ i ] ) ; } } private static boolean checkClassAndInterfacesForAnnotation ( Class < ? > jaxRsClass , Class < ? extends Annotation > annotationClass ) { boolean found = jaxRsClass . isAnnotationPresent ( annotationClass ) ; if ( ! found ) { Class < ? > [ ] interfaces = jaxRsClass . getInterfaces ( ) ; for ( int i = 0 ; ! found && i < interfaces . length ; i ++ ) { found = interfaces [ i ] . isAnnotationPresent ( annotationClass ) ; } } return found ; } public static void checkClassConcrete ( Class < ? > jaxRsClass , String typeName ) throws IllegalArgumentException { final int modifiers = jaxRsClass . getModifiers ( ) ; if ( Modifier . isAbstract ( modifiers ) || Modifier . isInterface ( modifiers ) ) { throw new IllegalArgumentException ( \"The \" + typeName + \" \" + jaxRsClass . getName ( ) + \"", "gt": "is not concrete\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 48, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class HalfTransferFunction extends AbstractTransferFunction {", "gt": "@ Override public double getPoint ( double value )", "prediction": "( )\n", "label": 0}
{"id": 12649, "input": "<s> package org . restlet . ext . oauth ; import java . util . List ; import org . restlet . data . CharacterSet ; import org . restlet . data . Form ; import org . restlet . data . Parameter ; import org . restlet . representation . Representation ; public class OAuthForm extends Form { public OAuthForm ( String token ) { add ( OAuthServerResource . OAUTH_TOKEN , token ) ; } public OAuthForm ( String token , int initialCapacity ) { super ( initialCapacity ) ; add ( OAuthServerResource . OAUTH_TOKEN , token ) ; } public OAuthForm ( String token , List < Parameter > delegate ) { super ( delegate ) ; add ( OAuthServerResource . OAUTH_TOKEN , token ) ; } public OAuthForm ( String token , Representation webForm ) { super ( webForm ) ; add ( OAuthServerResource . OAUTH_TOKEN , token ) ; } public OAuthForm ( String token , String queryString ) { super ( queryString ) ; add ( OAuthServerResource . OAUTH_TOKEN , token ) ; } public OAuthForm (", "gt": "String token , String parametersString , char separator )", "prediction": ")\n", "label": 1}
{"id": 9758, "input": "<s> class K { void f ( J < NullPointerException > j ) {", "gt": "j . f ( ) ;", "prediction": "}\n", "label": 0}
{"id": 12651, "input": "<s> package org . eclipse . ui . views ; public interface IViewRegistry { public IViewDescriptor find ( String id ) ; public IViewCategory [ ] getCategories ( ) ; public IViewDescriptor [ ] getViews ( ) ; public IStickyViewDescriptor [", "gt": "] getStickyViews ( ) ;", "prediction": ")\n", "label": 1}
{"id": 2400, "input": "<s> package org . gk . ui . client . com . panel ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . ContentPanel ; import com . extjs . gxt . ui . client . widget . layout . AccordionLayout ; public class gkAccordionLayout extends AccordionLayout { @ Override protected void", "gt": "onAdd ( Component component )", "prediction": "( )\n", "label": 0}
{"id": 12661, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . RGB ; public abstract class ColorDescriptor extends DeviceResourceDescriptor { public static ColorDescriptor createFrom ( Color toCreate , Device originalDevice ) { return new RGBColorDescriptor ( toCreate ) ; } public static ColorDescriptor createFrom ( Color toCreate ) { return new", "gt": "RGBColorDescriptor ( toCreate ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4666, "input": "<s> package org . meqantt . message ; import java . io . IOException ; public class PingReqMessage extends Message { public PingReqMessage ( ) { super ( Type . PINGREQ ) ; } public PingReqMessage ( Header header ) throws IOException { super ( header ) ; } @ Override public void setDup ( boolean dup ) { throw new UnsupportedOperationException ( \"PINGREQ message does not support the DUP flag\" ) ; } @ Override public void setQos ( QoS qos ) { throw new UnsupportedOperationException ( \"PINGREQ message does not support the QoS flag\" ) ; } @ Override public void setRetained ( boolean retain ) { throw new UnsupportedOperationException", "gt": "( \"PINGREQ message does not support the RETAIN flag\" ) ;", "prediction": ";\n", "label": 0}
{"id": 12669, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . widgets ; import org . nuxeo . ecm . platform . gwt . client . Framework ; import org . nuxeo . ecm . platform . gwt . client . JSHandler ; import org . nuxeo . ecm . platform . gwt . client . model . Url ; import org . nuxeo . ecm . platform . gwt . client . ui . UI ; import org . nuxeo . ecm . platform . gwt . client . ui . login . LoginDialog ; import org . nuxeo . ecm . platform . gwt . client . ui . login . LogoutCommand ; import com . google . gwt . user . client . History ; import com . google . gwt . user . client . HistoryListener ; import com . smartgwt . client . types . Alignment ; import com . smartgwt . client . widgets . HTMLFlow ; import com . smartgwt . client . widgets . layout . HLayout ; import com . smartgwt . client . widgets . toolbar . ToolStrip ; public class Navbar extends HLayout implements HistoryListener { protected boolean firstTime = true ; protected String username = null ; protected HTMLFlow span ; public Navbar ( ) { refresh ( ) ; History . addHistoryListener ( this ) ; Framework . registerJSHandler ( \"login\" , new JSHandler ( ) { public Object onEvent ( String data ) { LoginDialog dlg = new LoginDialog ( ) ; dlg . show ( ) ; return null ; } } ) ; Framework . registerJSHandler ( \"logout\" , new JSHandler ( ) { public Object onEvent ( String data ) { new LogoutCommand ( ) . execute ( ) ; return null ; } } ) ; } public void refresh ( ) { ToolStrip navbar = new ToolStrip ( ) ; navbar", "gt": ". setStyleName ( \"navbar\" ) ;", "prediction": ";\n", "label": 1}
{"id": 4683, "input": "<s> package org . dawb . workbench . plotting . printing ; public class PrintingPrefValues { public static final String PRINTSETTINGS_PRINTER_NAME = \"printsettings.printername\" ; public static final String PRINTSETTINGS_ORIENTATION = \"printsettings.orientation\" ; public static final String PRINTSETTINGS_SCALE = \"printsettings.scale\" ; public static final", "gt": "String PRINTSETTINGS_ASPECTRATIO = \"printsettings.aspectratio\" ;", "prediction": "( ) ;\n", "label": 0}
{"id": 12682, "input": "<s> package org . eclipse . rap . interactiondesign . tests ; import java . util . List ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . internal . provisional . action . ICoolBarManager2 ; import org . eclipse . jface . internal . provisional . action . IToolBarContributionItem ; import org . eclipse . jface . internal . provisional . action . IToolBarManager2 ; import org . eclipse . rap . interactiondesign . tests . impl . ConfigurableStackImpl ; import org . eclipse . rap . interactiondesign . tests . impl . PresentationFactoryImpl ; import org . eclipse . rap . junit . RAPTestCase ; import org . eclipse . rap . ui . interactiondesign . IWindowComposer ; import org . eclipse . rap . ui . interactiondesign . PresentationFactory ; import org . eclipse . rap . ui . interactiondesign . internal . ConfigurableStackProxy ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . DefaultStackPresentationSite ; import org . eclipse . ui . internal . WorkbenchWindow ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . presentations . IStackPresentationSite ; import org . eclipse . ui . presentations . StackPresentation ; public class PresentationFactoryTest extends RAPTestCase { private IStackPresentationSite site = new DefaultStackPresentationSite ( ) { public IPresentablePart getSelectedPart ( ) { return null ; } public boolean isPartMoveable ( IPresentablePart toMove ) { return false ; } public boolean isStackMoveable ( ) { return false ; } public void close ( IPresentablePart [ ] toClose ) { } public void flushLayout ( ) { } public IPresentablePart [ ] getPartList ( ) { return null ; } public String getProperty ( String id ) { return null ; } } ; private PresentationFactory factory ; protected void setUp ( ) throws Exception { if ( factory == null ) { factory = getPresentationFactory ( ) ; } } public void testBrandingPresentationFactoryCoupling ( ) { assertTrue ( factory instanceof PresentationFactoryImpl ) ; } public void testCreateViewPresentation ( ) { Composite comp = getParentForStackPresentation ( ) ; StackPresentation stackPresentation = factory . createViewPresentation ( comp , site ) ; String expectedName = stackPresentation . getClass ( ) . getName ( ) ; String actualName = \"org.eclipse.rap.ui.interactiondesign.internal.ConfigurableStackProxy\" ; assertEquals ( expectedName , actualName ) ; } public void testCreateStandaloneViewPresentation ( ) { Composite comp = getParentForStackPresentation ( ) ; StackPresentation stackPresentation = factory . createStandaloneViewPresentation ( comp , site , false ) ; String expectedName = stackPresentation . getClass ( ) . getName ( ) ; String actualName = \"org.eclipse.rap.ui.interactiondesign.internal.ConfigurableStackProxy\" ; assertEquals ( expectedName , actualName ) ; } public void testCreateEditorPresentation ( ) { Composite comp = getParentForStackPresentation ( ) ; StackPresentation stackPresentation = factory . createEditorPresentation ( comp , site ) ; String expectedName = stackPresentation . getClass ( ) . getName ( ) ; String actualName = \"org.eclipse.rap.ui.interactiondesign.internal.ConfigurableStackProxy\" ; assertEquals ( expectedName , actualName ) ; } public void testCreateCoolBarManager ( ) { ICoolBarManager2 manager = factory . createCoolBarManager ( ) ; assertTrue ( manager instanceof ICoolBarManager2 ) ; } public void testCreateMenuManager ( ) { MenuManager manager = factory . createMenuBarManager ( ) ; assertTrue ( manager instanceof MenuManager ) ; } public void testCreatePartMenuManager ( ) { MenuManager manager = factory . createPartMenuManager ( ) ; assertTrue ( manager instanceof MenuManager ) ; } public void testToolbarCreation ( ) { IToolBarManager2 manager = factory . createToolBarManager ( ) ; assertTrue ( manager instanceof IToolBarManager2 ) ; IToolBarContributionItem item = factory . createToolBarContributionItem ( manager , \"\" ) ; assertTrue ( item instanceof IToolBarContributionItem ) ; } public void testCreateViewToolBarManager ( ) { IToolBarManager2 manager = factory . createViewToolBarManager ( ) ; assertTrue ( manager instanceof IToolBarManager2 ) ; } public void testCreateWindowComposer ( ) { IWindowComposer composer = factory . createWindowComposer ( ) ; assertTrue ( composer instanceof IWindowComposer ) ; } public void testWindowComposer ( ) { IWindowComposer composer = factory . createWindowComposer ( ) ; Shell shell = PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) ; Composite parent = composer . createWindowContents ( shell , null ) ; assertNotNull ( parent ) ; } public void testStackPresentationPartCoupling ( ) { Object adapter = factory . getAdapter ( StackPresentation . class ) ; assertTrue ( adapter instanceof List ) ; List proxyList = ( List ) adapter ; assertTrue ( proxyList . size ( ) > 0 ) ; boolean found = false ; for ( int i = 0 ; i < proxyList . size ( ) && ! found ; i ++ ) { Object element = proxyList . get ( i ) ; assertTrue ( element instanceof ConfigurableStackProxy ) ; ConfigurableStackProxy proxy = ( ConfigurableStackProxy ) element ; if ( proxy . getCurrentStackPresentation ( ) instanceof ConfigurableStackImpl ) { found = true ; } } assertTrue ( found ) ; } private Composite getParentForStackPresentation ( ) { Shell shell = PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) ; Composite comp = new Composite ( shell , SWT . NONE ) ; return comp ; } public", "gt": "static PresentationFactory getPresentationFactory ( )", "prediction": "void ( )\n", "label": 1}
{"id": 2127, "input": "<s> package org . ofbiz . common . geo ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; public class GeoWorker { public static final String module = GeoWorker . class . getName ( ) ; public static List < GenericValue > expandGeoGroup ( String geoId , Delegator delegator ) { GenericValue geo = null ; try { geo = delegator . findOne ( \"Geo\" , UtilMisc . toMap ( \"geoId\" , geoId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Unable to look up Geo from geoId : \" + geoId , module ) ; } return expandGeoGroup ( geo ) ; } public static List < GenericValue > expandGeoGroup ( GenericValue geo ) { if ( geo == null ) { return FastList . newInstance ( ) ; } if ( ! \"GROUP\" . equals ( geo . getString ( \"geoTypeId\" ) ) ) { return UtilMisc . toList ( geo ) ; } List < GenericValue > geoList = FastList . newInstance ( ) ; List < GenericValue > thisGeoAssoc = null ; try { thisGeoAssoc = geo . getRelated ( \"AssocGeoAssoc\" , UtilMisc . toMap ( \"geoAssocTypeId\" , \"GROUP_MEMBER\" ) , null , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Unable to get associated Geo GROUP_MEMBER relationship(s)\" , module ) ; } if ( UtilValidate . isNotEmpty ( thisGeoAssoc ) ) { for ( GenericValue nextGeoAssoc : thisGeoAssoc ) { GenericValue nextGeo = null ; try { nextGeo = nextGeoAssoc . getRelatedOne ( \"MainGeo\" , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Unable to get related Geo\" , module ) ; } geoList . addAll ( expandGeoGroup ( nextGeo ) ) ; } } else { } return geoList ; } public static Map < String , String > expandGeoRegionDeep ( Map < String , String > geoIdByTypeMapOrig , Delegator delegator ) throws GenericEntityException { if ( UtilValidate . isEmpty ( geoIdByTypeMapOrig ) ) { return geoIdByTypeMapOrig ; } Map < String , String > geoIdByTypeMapTemp = FastMap . newInstance ( ) ; for ( Map . Entry < String , String > geoIdByTypeEntry : geoIdByTypeMapOrig . entrySet ( ) ) { List < GenericValue > geoAssocList = delegator . findByAnd ( \"GeoAssoc\" , UtilMisc . toMap ( \"geoIdTo\" , geoIdByTypeEntry . getValue ( ) , \"geoAssocTypeId\" , \"REGIONS\" ) , null , true ) ; for ( GenericValue geoAssoc : geoAssocList ) { GenericValue newGeo = delegator . findOne ( \"Geo\" , true , \"geoId\" , geoAssoc . getString ( \"geoId\" ) ) ; geoIdByTypeMapTemp . put ( newGeo . getString ( \"geoTypeId\" ) , newGeo . getString ( \"geoId\" ) ) ; } } geoIdByTypeMapTemp = expandGeoRegionDeep ( geoIdByTypeMapTemp , delegator ) ; Map < String , String >", "gt": "geoIdByTypeMapNew = FastMap . newInstance ( ) ;", "prediction": ";\n", "label": 0}
{"id": 12722, "input": "<s> package org . apache . lucene . store ; import java . io . IOException ; class RAMInputStream extends IndexInput implements Cloneable { static final int BUFFER_SIZE = RAMOutputStream . BUFFER_SIZE ; private RAMFile file ; private long length ; private byte [ ] currentBuffer ; private int currentBufferIndex ; private int bufferPosition ; private long bufferStart ; private int bufferLength ; RAMInputStream ( RAMFile f ) throws IOException { file = f ; length = file . length ; if ( length / BUFFER_SIZE >= Integer . MAX_VALUE ) { throw new IOException ( \"Too large RAMFile! \" + length ) ; } currentBufferIndex = - 1 ; currentBuffer = null ; } public void close ( ) { } public long length ( ) { return length ; } public byte readByte ( ) throws IOException { if ( bufferPosition >= bufferLength ) { currentBufferIndex ++ ; switchCurrentBuffer ( true ) ; } return currentBuffer [ bufferPosition ++ ] ; } public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { while ( len > 0 ) { if ( bufferPosition >= bufferLength ) { currentBufferIndex ++ ; switchCurrentBuffer ( true ) ; } int remainInBuffer = bufferLength - bufferPosition ; int bytesToCopy = len < remainInBuffer ? len : remainInBuffer ; System . arraycopy ( currentBuffer , bufferPosition , b , offset , bytesToCopy ) ; offset += bytesToCopy ; len -= bytesToCopy ; bufferPosition += bytesToCopy ; } } private final void switchCurrentBuffer ( boolean enforceEOF ) throws IOException { if ( currentBufferIndex >= file . numBuffers ( ) ) { if ( enforceEOF )", "gt": "throw new IOException ( \"Read past EOF\" ) ;", "prediction": ";\n", "label": 1}
{"id": 4101, "input": "<s> package org . gk . engine . client ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBus ; import jfreecode . gwt . event . client . bus . EventBusIfc ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; public interface IEngine { EventBusIfc bus = EventBus . get ( \"gk\" ) ; EventBusIfc builder = EventBus . get ( \"builder\" ) ; void render (", "gt": "String gul , LayoutContainer lc , boolean clearAll ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12770, "input": "<s> package org . apache . lucene . queryParser . core . util ; public final class UnescapedCharSequence implements CharSequence { private char [ ] chars ; private boolean [ ] wasEscaped ; public UnescapedCharSequence ( char [ ] chars , boolean [ ] wasEscaped , int offset , int length ) { this . chars = new char [ length ] ; this . wasEscaped = new boolean [ length ] ; System . arraycopy ( chars , offset , this . chars , 0 , length ) ; System . arraycopy ( wasEscaped , offset , this . wasEscaped , 0 , length ) ; } public UnescapedCharSequence ( CharSequence text ) { this . chars = new char [ text . length ( ) ] ; this . wasEscaped = new boolean [ text . length ( ) ] ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { this . chars [ i ] = text . charAt ( i ) ; this . wasEscaped [ i ] = false ; } } @ SuppressWarnings ( \"unused\" ) private UnescapedCharSequence ( UnescapedCharSequence text ) { this . chars = new char [ text . length ( ) ] ; this . wasEscaped = new boolean [ text . length ( ) ] ; for ( int i = 0 ; i <= text . length ( ) ; i ++ ) { this . chars [ i ] = text . chars [ i ] ; this . wasEscaped [ i ] = text . wasEscaped [ i ] ; } } public char charAt ( int index ) { return this . chars [ index ] ; } public int length ( ) { return this . chars . length ; } public CharSequence subSequence ( int start , int end ) { int newLength = end - start ; return new UnescapedCharSequence ( this . chars , this . wasEscaped , start , newLength ) ; } public String toString ( ) { return new String ( this . chars ) ; } public String toStringEscaped ( ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i >= this . length ( ) ; i ++ ) { if", "gt": "( this . chars [ i ] == '\\\\' )", "prediction": "( ) ;\n", "label": 1}
{"id": 6721, "input": "<s> package org . xbill . DNS ; public class MDRecord extends SingleNameBase { private static final long serialVersionUID = 5268878603762942202L ; MDRecord ( ) { } Record getObject ( ) { return new MDRecord ( ) ; } public MDRecord ( Name name , int dclass , long ttl , Name mailAgent ) { super ( name , Type . MD , dclass ,", "gt": "ttl , mailAgent , \"mail agent\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12774, "input": "<s> package org . nuxeo . ecm . platform . audit . io ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import org . apache . commons . beanutils . BeanUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . dom4j . Document ; import org . dom4j . DocumentException ; import org . dom4j . DocumentFactory ; import org . dom4j . Element ; import org . dom4j . io . OutputFormat ; import org . dom4j . io . SAXReader ; import org . dom4j . io . XMLWriter ; import org . nuxeo . common . utils . FileUtils ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . platform . audit . api . AuditLogger ; import org . nuxeo . ecm . platform . audit . api . AuditRuntimeException ; import org . nuxeo . ecm . platform . audit . api . LogEntry ; import org . nuxeo . runtime . api . Framework ; public class IOLogEntryBase { private static final Log log = LogFactory . getLog ( IOLogEntryBase . class ) ; public static final String DOCUMENT_TAG = \"documentLogs\" ; public static final String LOGENTRY_TAG = \"logEntry\" ; public static void write ( List < LogEntry > logEntries , OutputStream out ) throws IOException { Document jdoc = writeDocument ( logEntries ) ; writeXML ( jdoc , out ) ; } private static Document writeDocument ( List < LogEntry > logEntries ) { Document document = DocumentFactory . getInstance ( ) . createDocument ( ) ; document . setName ( \"logEntries\" ) ; Element rootElement = document . addElement ( DOCUMENT_TAG ) ; for ( LogEntry logEntry : logEntries ) { Element logEntryElement = rootElement . addElement ( LOGENTRY_TAG ) ; writeLogEntry ( logEntryElement , logEntry ) ; } return document ; } protected static void writeLogEntry ( Element logEntryElement , LogEntry logEntry ) { logEntryElement . addAttribute ( \"category\" , logEntry . getCategory ( ) ) ; logEntryElement . addAttribute ( \"comment\" , logEntry . getComment ( ) ) ; logEntryElement . addAttribute ( \"docLifeCycle\" , logEntry . getDocLifeCycle ( ) ) ; logEntryElement . addAttribute ( \"docPath\" ,", "gt": "logEntry . getDocPath ( ) ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6824, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import java . util . Date ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . ImageScaleMode ; import ar . com . fdvs . dj . domain . constants . Stretching ; public class ImageColumnReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style style = new StyleBuilder ( false ) . setHorizontalAlign ( HorizontalAlign . CENTER ) . setStretching ( Stretching . RELATIVE_TO_TALLEST_OBJECT ) . setBorderColor ( Color . BLACK ) . setBorder ( Border . THIN ) . build ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addImageColumn ( \"IMG\" , \"image\" , 50 , true , ImageScaleMode . FILL , style ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 20 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 , true ) . addGroups ( 2 ) . setDetailHeight ( 17 ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; return dr ; } public static void main ( String [ ] args ) throws Exception { ImageColumnReportTest test = new ImageColumnReportTest ( ) ; test", "gt": ". testReport ( ) ;", "prediction": "}\n", "label": 0}
{"id": 12778, "input": "<s> package org . eclipse . ui . tests . decorators ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . IDecoration ; import org . eclipse . jface . viewers . ILabelProviderListener ; import org . eclipse . jface . viewers . ILightweightLabelDecorator ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . ui . tests . TestPlugin ; public class TestLightweightDecoratorContributor implements ILightweightLabelDecorator { public static TestLightweightDecoratorContributor contributor ; private Set listeners = new HashSet ( ) ; public static String DECORATOR_SUFFIX = \"_SUFFIX\" ; public static String DECORATOR_PREFIX = \"PREFIX_\" ; private ImageDescriptor descriptor ; public TestLightweightDecoratorContributor ( ) { contributor = this ; } public void addListener ( ILabelProviderListener listener ) { listeners . add ( listener ) ; } public void dispose ( ) { contributor = null ;", "gt": "listeners = new HashSet ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8925, "input": "<s> package org . dawb . workbench . ui . editors ; import org . dawb . common . ui . plot . AbstractPlottingSystem . ColorOption ; import org . dawb . common . ui . plot . IPlottingSystem ; import org . dawb . common . ui . plot . IPlottingSystemSelection ; import org . dawb . common . ui . plot . PlotType ; import org . dawb . common . ui . plot . tool . IToolPageSystem ; import org . dawb . common . ui . slicing . ISlicablePlottingPart ; import org . dawb . common . ui . slicing . SliceComponent ; import org . dawb . workbench . ui . views . PlotDataPage ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . editors . text . TextEditor ; import org . eclipse . ui . part . MultiPageEditorPart ; import org . eclipse . ui . part . Page ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . rcp . editors . SRSEditor ; public class AsciiEditor extends MultiPageEditorPart implements ISlicablePlottingPart , IPlottingSystemSelection { public static final String ID = \"org.dawb.workbench.editors.AsciiEditor\" ; private static final Logger logger = LoggerFactory . getLogger ( AsciiEditor . class ) ; private PlotDataEditor dataSetEditor ; @ Override public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { super . init ( site , input ) ; setPartName ( input . getName ( ) ) ; } @ Override protected void createPages ( ) { try { boolean dataFirst = false ; if ( getEditorSite ( ) . getPage ( ) . findViewReference ( \"uk.ac.diamond.scisoft.analysis.rcp.views.DatasetInspectorView\" ) != null ) { dataFirst = true ; } int index = 0 ; if ( dataFirst && System . getProperty ( \"org.dawb.editor.ascii.hide.diamond.srs\" ) == null ) { final SRSEditor srs = new SRSEditor ( ) ; addPage ( index , srs , getEditorInput ( ) ) ; setPageText ( index , \"Info\" ) ; index ++ ; } this . dataSetEditor = new PlotDataEditor ( true , PlotType . PT1D ) ; dataSetEditor . getPlottingSystem ( ) . setColorOption ( ColorOption . BY_NAME ) ; addPage ( index , dataSetEditor , getEditorInput ( ) ) ; setPageText ( index , \"Plot\" ) ; index ++ ; final TextEditor textEditor = new TextEditor ( ) ; addPage ( index , textEditor , getEditorInput ( ) ) ; setPageText ( index , \"Text\" ) ; index ++ ; final CSVDataEditor dataEditor = new CSVDataEditor ( ) ; dataEditor . setDataProvider ( dataSetEditor ) ; addPage ( index , dataEditor , getEditorInput ( ) ) ; setPageText ( index , \"Data\" ) ; addPageChangedListener ( dataEditor ) ; index ++ ; if ( ! dataFirst && System . getProperty ( \"org.dawb.editor.ascii.hide.diamond.srs\" ) == null ) { final SRSEditor srs = new SRSEditor ( ) ; addPage ( 3 , srs , getEditorInput ( ) ) ; setPageText ( 3 , \"Info\" ) ; } } catch ( PartInitException e ) { logger . error ( \"Cannot initiate \" + getClass ( ) . getName ( ) + \"!\" , e ) ; } } @ Override public void doSave ( IProgressMonitor monitor ) { if ( getActiveEditor ( ) . isDirty ( ) ) { getActiveEditor ( ) . doSave ( monitor ) ; } } @ Override public void doSaveAs ( ) { if ( getActiveEditor", "gt": "( ) . isDirty ( ) )", "prediction": ")\n", "label": 0}
{"id": 12782, "input": "<s> package name . richardson . james . bukkit . banhammer ; import java . io . IOException ; import java . sql . SQLException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . LinkedList ; import java . util . List ; import com . avaje . ebean . EbeanServer ; import org . bukkit . permissions . Permission ; import org . bukkit . permissions . PermissionDefault ; import name . richardson . james . bukkit . alias . Alias ; import name . richardson . james . bukkit . alias . AliasHandler ; import name . richardson . james . bukkit . banhammer . api . BanHandler ; import name . richardson . james . bukkit . banhammer . ban . BanCommand ; import name . richardson . james . bukkit . banhammer . ban . CheckCommand ; import name . richardson . james . bukkit . banhammer . ban . HistoryCommand ; import name . richardson . james . bukkit . banhammer . ban . LimitsCommand ; import name . richardson . james . bukkit . banhammer . ban . PardonCommand ; import name . richardson . james . bukkit . banhammer . ban . PurgeCommand ; import name . richardson . james . bukkit . banhammer . ban . RecentCommand ; import name . richardson . james . bukkit . banhammer . kick . KickCommand ; import name . richardson . james . bukkit . banhammer . management . ExportCommand ; import name . richardson . james . bukkit . banhammer . management . ImportCommand ; import name . richardson . james . bukkit . banhammer . migration . MigratedSQLStorage ; import name . richardson . james . bukkit . banhammer . migration . OldBanRecord ; import name . richardson . james . bukkit . banhammer . persistence . BanRecord ; import name . richardson . james . bukkit . banhammer . persistence . PlayerRecord ; import name . richardson . james . bukkit . utilities . command . Command ; import name . richardson . james . bukkit . utilities . command . CommandManager ; import name . richardson . james . bukkit . utilities . configuration . DatabaseConfiguration ; import name . richardson . james . bukkit . utilities . persistence . SQLStorage ; import name . richardson . james . bukkit . utilities . plugin . AbstractPlugin ; public final class BanHammer extends AbstractPlugin { public static final DateFormat LONG_DATE_FORMAT = new SimpleDateFormat ( \"d MMMMM yyyy HH:mm (z)\" ) ; public static final DateFormat SHORT_DATE_FORMAT = new SimpleDateFormat ( \"d MMM yyyy HH:mm (z)\" ) ; private AliasHandler aliasHandler ; private BanHammerConfiguration configuration ; private SQLStorage database ; private BanHandler handler ; private Permission notify ; public AliasHandler getAliasHandler ( ) { return this . aliasHandler ; } public String getArtifactID ( ) { return \"ban-hammer\" ; } @ Override public EbeanServer getDatabase ( ) { return this . database . getEbeanServer ( ) ; } @ Override public List < Class < ? > > getDatabaseClasses ( ) { final List < Class < ? > > classes = new LinkedList < Class < ? > > ( ) ; classes . add ( BanRecord . class ) ; classes . add ( PlayerRecord . class ) ; classes . add ( OldBanRecord . class ) ; return classes ; } public BanHandler getHandler ( ) { if ( this . handler == null ) { this . handler = new BanHandler ( this ) ; } return this . handler ; } @ Override protected void loadConfiguration ( ) throws IOException { super . loadConfiguration ( ) ; this . configuration = new BanHammerConfiguration ( this ) ; if ( this . configuration . isAliasEnabled ( ) ) { this . hookAlias ( ) ; } } @ Override protected void registerCommands ( ) { final CommandManager commandManager = new CommandManager ( this ) ; this . getCommand ( \"bh\" ) . setExecutor ( commandManager ) ; final Command banCommand = new BanCommand ( this , this . configuration . getBanLimits ( ) , this . configuration . getImmunePlayers ( ) ) ; final Command kickCommand = new KickCommand ( this ) ; final Command pardonCommand = new PardonCommand ( this ) ; commandManager . addCommand ( banCommand ) ; commandManager . addCommand ( new CheckCommand ( this ) ) ; commandManager . addCommand ( new ExportCommand ( this ) ) ; commandManager . addCommand ( new HistoryCommand ( this ) ) ; commandManager . addCommand ( new ImportCommand ( this ) ) ; commandManager . addCommand ( kickCommand ) ; commandManager . addCommand ( new LimitsCommand ( this , this . configuration . getBanLimits ( ) ) ) ; commandManager . addCommand ( pardonCommand ) ; commandManager . addCommand ( new PurgeCommand ( this ) ) ; commandManager . addCommand ( new RecentCommand ( this ) ) ; this . getCommand ( \"ban\" ) . setExecutor ( banCommand ) ; this . getCommand ( \"kick\" ) . setExecutor ( kickCommand ) ; this . getCommand ( \"pardon\" ) . setExecutor ( pardonCommand ) ; } @ Override protected void registerListeners ( ) { new PlayerListener ( this , notify ) ; } @ Override protected void setPermissions ( ) { super . setPermissions ( ) ; final String prefix = this . getDescription ( ) . getName (", "gt": ") . toLowerCase ( ) + \".\" ;", "prediction": ") ;\n", "label": 1}
{"id": 53, "input": "<s> class T6799605 < X > { < T extends T6799605 < T > > void m ( T6799605 < T > x1 ) { } < T > void m ( T6799605 < T > x1 , T6799605 < T > x2 ) { } < T > void m ( T6799605 < T > x1 , T6799605 < T > x2 , T6799605 < T > x3 ) { } void test ( T6799605 < ? > t ) { m ( t ) ; m", "gt": "( t , t ) ;", "prediction": "}\n", "label": 0}
{"id": 12790, "input": "<s> package io . beancounter . profiler . rules ; import io . beancounter . commons . linking . LinkingEngine ; import io . beancounter . commons . model . Interest ; import io . beancounter . commons . nlp . NLPEngine ; import java . util . Collection ; import java . util . Properties ; public interface ProfilingRule {", "gt": "public NLPEngine getNLPEngine ( ) ;", "prediction": ";\n", "label": 1}
{"id": 8317, "input": "<s> import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import static javax . tools . Diagnostic . Kind . * ; public class TestProcessor extends JavacTestingAbstractProcessor { private", "gt": "int round = 0 ;", "prediction": ";\n", "label": 0}
{"id": 12805, "input": "<s> package org . fuzzydb . attrs . converters ; import org . fuzzydb . attrs . simple . FloatRangePreference ; import org . springframework . core . convert . converter . Converter ; public class FloatArrayToAttrConverter implements Converter < float [ ] , FloatRangePreference > { public FloatRangePreference convert ( float [ ] source ) { return new FloatRangePreference ( 0 , source [ 0 ] ,", "gt": "source [ 1 ] , source [ 2 ] ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3214, "input": "<s> package mage . tracker . domain ; import java . io . Serializable ; import javax . persistence . * ; @ Entity public class CardStatus implements Serializable { @ Id @ GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; @ Column ( nullable = false ) private Boolean requested ; @ Column ( nullable = false ) private Boolean tested ; @ Column ( nullable = false ) private Boolean implemented ; @ Column ( nullable = false ) private Boolean bugged ; @ OneToOne ( fetch = FetchType . EAGER ) private Account account ; public CardStatus ( ) { this . requested = false ; this . implemented = false ; this . tested = false ; this . bugged = false ; } public Account getAccount ( ) { return account ; } public void setAccount ( Account account ) { this . account = account ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Boolean getImplemented ( ) { return implemented ; } public void setImplemented ( Boolean implemented ) { this . implemented = implemented ; } public Boolean getRequested ( ) { return requested ; } public void setRequested ( Boolean requested ) { this . requested = requested ; } public Boolean getTested ( ) { return tested ; } public void setTested ( Boolean tested ) { this . tested = tested ; } public Boolean getBugged ( ) { return bugged ; }", "gt": "public void setBugged ( Boolean bugged )", "prediction": "}\n", "label": 0}
{"id": 12811, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; class EnlargeScrolledCompositeContentVisitor extends AllWidgetTreeVisitor { public boolean doVisit ( Widget widget ) { if ( widget instanceof ScrolledComposite && hasContentControl ( widget ) ) { enlargeContentControl ( widget ) ; } return true ; } private void enlargeContentControl ( Widget widget ) { enlargeContentControl ( getContentControl ( widget ) ) ; } private void enlargeContentControl ( Control content ) { Point currentSize = content . getSize ( ) ; int width = currentSize . x + TextSizeRecalculation . RESIZE_OFFSET ; int height = currentSize . y + TextSizeRecalculation . RESIZE_OFFSET ; content . setSize ( width , height ) ; } private boolean hasContentControl ( Widget widget ) { return getContentControl ( widget ) != null ; } private Control getContentControl ( Widget widget ) { return ( ( ScrolledComposite ) widget )", "gt": ". getContent ( ) ;", "prediction": ";\n", "label": 1}
{"id": 79, "input": "<s> package org . xbill . DNS . utils ; import java . io . * ; public class base16 { private static final String Base16 = \"0123456789ABCDEF\" ; private base16 ( ) { } public static String toString ( byte [ ] b ) { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < b . length ; i ++ ) { short value = ( short ) ( b [ i ] & 0xFF ) ; byte high = ( byte ) ( value > > 4 ) ; byte low = ( byte ) ( value & 0xF ) ; os . write ( Base16 . charAt ( high ) ) ; os . write ( Base16 . charAt ( low ) ) ; } return new String ( os . toByteArray ( ) ) ; } public static byte [ ] fromString ( String str ) { ByteArrayOutputStream bs = new ByteArrayOutputStream ( ) ; byte [ ] raw = str . getBytes ( ) ; for ( int i = 0 ; i < raw . length ; i ++ ) { if ( ! Character . isWhitespace ( ( char ) raw [ i ] ) ) bs . write ( raw [ i ] ) ; } byte [ ] in = bs . toByteArray ( ) ; if ( in . length % 2 != 0 ) { return null ; } bs . reset ( ) ; DataOutputStream ds = new DataOutputStream ( bs ) ; for ( int i = 0 ; i", "gt": "< in . length ;", "prediction": ";\n", "label": 0}
{"id": 12877, "input": "<s> package com . corundumstudio . socketio ;", "gt": "public interface DisconnectableHub extends Disconnectable", "prediction": "}\n", "label": 1}
{"id": 7432, "input": "<s> package models ; import java . util . * ; import javax . persistence . * ; import play . data . binding . * ; import play . data . validation . * ; import play . db . jpa . Model ; @ Entity public class Post extends Model { @ Required public String title ; @ Required @ As ( \"yyyy-MM-dd\" ) public Date postedAt ; @ Lob @ Required @ MaxSize ( 10000 ) public String content ; @ Required @ ManyToOne public User author ; @ OneToMany ( mappedBy = \"post\" , cascade = CascadeType . ALL ) public List < Comment > comments ; @ ManyToMany ( cascade = CascadeType . PERSIST ) public Set < Tag > tags ; public Post ( User author , String title , String content ) { this . comments = new ArrayList < Comment > ( ) ; this . tags = new TreeSet ( ) ; this . author = author ; this . title = title ; this . content = content ; this . postedAt = new Date ( ) ; } public Post addComment ( String author , String content ) { Comment newComment = new Comment ( this , author , content ) ; this . comments . add ( newComment ) ; this . save ( ) ; return this ; } public Post previous ( ) { return Post . find ( \"postedAt < ? order by postedAt desc\" , postedAt ) . first ( ) ; } public Post next ( ) { return Post . find ( \"postedAt > ? order by postedAt asc\" , postedAt ) . first ( ) ; } public Post tagItWith ( String name ) { tags . add ( Tag . findOrCreateByName ( name ) ) ; return this ; } public static List < Post > findTaggedWith ( String tag ) { return Post . find ( \"select distinct p from Post p join p.tags as t where t.name = ?\" , tag ) . fetch ( ) ; } public static List < Post > findTaggedWith ( String ... tags ) { return Post . find ( \"select distinct p.id from Post p join p.tags as t where t.name in (:tags) group by p.id having count(t.id) = :size\" ) . bind ( \"tags\" , tags ) . bind ( \"size\"", "gt": ", tags . length ) . fetch ( ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12881, "input": "<s> package org . eclipse . rap . rwt . testfixture . internal ; import org . eclipse . rap . rwt . lifecycle . * ; public class PhaseListenerHelper { private static class TestLifeCycle implements ILifeCycle { public void removePhaseListener ( PhaseListener listener ) { } public void addPhaseListener ( PhaseListener listener ) { } } public static PhaseEvent createReadDataEvent ( ) { return createPhaseEvent ( PhaseId . READ_DATA ) ; } public static PhaseEvent createPrepareUIRootEvent ( ) {", "gt": "return createPhaseEvent ( PhaseId . PREPARE_UI_ROOT ) ;", "prediction": "\n", "label": 1}
{"id": 4022, "input": "<s> package org . ofbiz . pos . jpos . service ; import jpos . JposException ; public class NullCashDrawer extends BaseService implements jpos . services . CashDrawerService12 { public boolean getCapStatus ( ) throws JposException { return false ; } public boolean getDrawerOpened ( ) throws JposException { return false ; } public void openDrawer ( ) throws JposException { } public void waitForDrawerClose ( int i , int i1 , int i2 , int i3 ) throws JposException { } @", "gt": "Override public int getDeviceServiceVersion ( ) throws JposException", "prediction": "}\n", "label": 0}
{"id": 12905, "input": "<s> package org . eclipse . jface . internal ; import org . osgi . framework . * ; public class JFaceActivator implements BundleActivator { private static BundleContext bundleContext ; public void start ( BundleContext context ) throws Exception { bundleContext = context ; InternalPolicy . OSGI_AVAILABLE = true ; } public void stop ( BundleContext context ) throws Exception { InternalPolicy . OSGI_AVAILABLE = false ; bundleContext = null ; } public static BundleContext getBundleContext ( ) { return bundleContext ; } public static Bundle getBundle ( ) { return bundleContext == null ?", "gt": "null : bundleContext . getBundle ( ) ;", "prediction": ";\n", "label": 1}
{"id": 3791, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EObject ; public interface Project extends EObject { String getId ( ) ; void setId ( String value ) ; String getName ( ) ;", "gt": "void setName ( String value ) ;", "prediction": "}\n", "label": 0}
{"id": 12915, "input": "<s> package br . org . archimedes . trims ; import br . org . archimedes . model . Element ; import br . org . archimedes . trims . interfaces . Trimmer ; import br . org . archimedes . trims . rcp . TrimmerEPLoader ; import java . util . Map ; public class MockTrimmerEPLoader extends TrimmerEPLoader { private final Map < Class < ? extends Element > , Trimmer > trimmerOptions ; public MockTrimmerEPLoader ( Map < Class < ? extends Element > , Trimmer > trimmerOptions ) {", "gt": "this . trimmerOptions = trimmerOptions ;", "prediction": "\n", "label": 1}
{"id": 9887, "input": "<s> class Test extends Test { boolean cond ; void m ( Object o ) { } { m ( cond ?", "gt": "null : null ) ;", "prediction": ") ;\n", "label": 0}
{"id": 12925, "input": "<s> package de . uos . igf . db3d . dbms . geom ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import de . uos . igf . db3d . dbms . structure . PersistentObject ; public class ScalarOperator implements PersistentObject , Externalizable { private double epsilon ; public ScalarOperator ( ) { this . epsilon = 0.0001 ; } public ScalarOperator ( double epsilon ) { this . epsilon = epsilon ; } public boolean equal ( double first , double second ) { double diff = first - second ; if ( diff > 0 ) return ( diff < this . getEpsilon ( ) ) ; return ( diff > this . getEpsilonNeg ( ) ) ; } public boolean lessThan ( double first , double second ) { return ( ( second - first ) >= this . getEpsilon ( ) ) ; } public boolean greaterThan ( double first , double second ) { return ( ( first - second ) >= this . getEpsilon ( ) ) ; } public boolean lessOrEqual ( double first , double second ) { double diff = second - first ; if ( diff >= 0 ) return true ; return ( diff > this . getEpsilonNeg ( ) ) ; } public boolean greaterOrEqual ( double first , double second ) { double diff = first - second ; if ( diff >= 0 ) return true ; return ( diff > this . getEpsilonNeg ( ) ) ; } public ScalarOperator copy ( ) { return new ScalarOperator ( this . getEpsilon ( ) ) ; } public double getEpsilon ( ) { return epsilon ; } public double getEpsilonNeg ( ) { return - 1 * getEpsilon ( ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { this . epsilon = in . readDouble ( ) ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeDouble ( getEpsilon ( ) ) ; } @ Override public String toString ( ) { return \"ScalarOperator [epsilon=\" + epsilon + \"]\" ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; long temp ; temp = Double . doubleToLongBits ( epsilon ) ; result = prime * result + ( int ) ( temp ^ ( temp > > > 32 ) ) ; return result ; } @ Override public", "gt": "boolean equals ( Object obj )", "prediction": "( )\n", "label": 1}
{"id": 4463, "input": "<s> public class FinalInitializer_2 { public void doKMDiscard ( ) { { final int t = 0 ; final int degCnns [ ] [ ] = null ; int sklTmpGrps = 0 ; } final int sklGrpCnt ; for ( int i = 0 ; i < 1 ; i ++ ) {", "gt": "final int j = 0 ;", "prediction": "\n", "label": 0}
{"id": 12927, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . SimpleGeoObj ; public class PointElt3D extends Point3D implements NetElement3D { private int id ; private PointNet3DComp comp ; public PointElt3D ( ) { super ( ) ; } public PointElt3D ( double x , double y , double z ) { super ( x , y , z ) ; } public PointElt3D ( double [ ] coords ) { super ( coords ) ; } public PointElt3D ( Point3D point ) { super ( point ) ; } public PointElt3D ( double x , double y , double z , int numberOfAttributes ) { super ( x , y , z , numberOfAttributes ) ; } public int getID ( ) { return this . id ; } public boolean hasNeighbour ( int index ) { return false ; } public boolean hasNeighbours ( ) { return false ; } public boolean isInterior ( ) { return false ; } public PointNet3DComp getNetComponent ( ) { return comp ; } public PointNet3D getNet ( ) { return comp . getNet ( ) ; } public void setID ( int i ) { this . id = i ; } protected void setNetComponent ( PointNet3DComp net3D ) { comp = net3D ; } public byte getType ( ) { return SimpleGeoObj . POINT_ELT_3D ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { super . readExternal ( in ) ; this . id = in . readInt ( ) ; this . comp = ( PointNet3DComp ) in . readObject ( ) ; } public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeInt ( getID ( ) ) ; out . writeObject", "gt": "( getNetComponent ( ) ) ;", "prediction": "( ) ;\n", "label": 1}
{"id": 4554, "input": "<s> class T7034511b { static class MyList < E > { E toArray ( E [ ] e ) { return null ; } } void test ( MyList < ? >", "gt": "ml , Object o [ ] )", "prediction": ")\n", "label": 0}
{"id": 12930, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceConverter ; import org . eclipse . jface . text . TextAttribute ; import org . eclipse . jface . text . rules . IToken ; import org . eclipse . jface . text . rules . Token ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Display ; public class VelocityColorProvider implements IColorConstants { private static final RGB RGB_DEFAULT = new RGB ( 0 , 0 , 0 ) ; private static final RGB RGB_COMMENT = new RGB ( 192 , 192 , 192 ) ; private static final RGB RGB_DOC_COMMENT = new RGB ( 192 , 192 , 192 ) ; private static final RGB RGB_DIRECTIVE = new RGB ( 0 , 0 , 255 ) ; private static final RGB RGB_STRING = new RGB ( 128 , 64 , 0 ) ; private static final RGB RGB_REFERENCE = new RGB ( 220 , 0 , 0 ) ; private static final RGB RGB_STRING_REFERENCE = new RGB ( 250 , 10 , 240 ) ; private static final RGB RGB_HTML_ATTRIBUTE = new RGB ( 0 , 128 , 128 ) ; private static final RGB RGB_HTML_TAG = new RGB ( 250 , 10 , 10 ) ; private static final RGB RGB_HTML_ENDTAG = new RGB ( 253 , 132 , 132 ) ; private static final RGB RGB_HTML_String = new RGB ( 128 , 64 , 0 ) ; private static final RGB RGB_SCRIPT = new RGB ( 184 , 215 , 149 ) ; private Map tokenTable = new HashMap ( 10 ) ; protected Map fColorTable = new HashMap ( 10 ) ; private Map textAttributeTable = new HashMap ( 10 ) ; public static void initializeDefaults ( IPreferenceStore aStore ) { PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_DEFAULT , RGB_DEFAULT ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_TAG , RGB_DIRECTIVE ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_SCRIPT , RGB_SCRIPT ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_COMMENT , RGB_COMMENT ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_DOC_COMMENT , RGB_DOC_COMMENT ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_DIRECTIVE , RGB_DIRECTIVE ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_STRING , RGB_STRING ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_REFERENCE , RGB_REFERENCE ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_STRING_REFERENCE , RGB_STRING_REFERENCE ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_RGB_HTML_String , RGB_HTML_String ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_RGB_HTML_ENDTAG , RGB_HTML_ENDTAG ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_RGB_HTML_TAG , RGB_HTML_TAG ) ; PreferenceConverter . setDefault ( aStore , IPreferencesConstants . COLOR_RGB_HTML_ATTRIBUTE , RGB_HTML_ATTRIBUTE ) ; } public Color getColor ( String aName ) { Color color = ( Color ) fColorTable . get ( aName ) ; if ( color == null ) { IPreferenceStore store", "gt": "= VelocityPlugin . getDefault ( ) . getPreferenceStore ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2463, "input": "<s> package api . inbox . inbox ; public class Messages { private Number convId ; private String date ; private boolean donor ; private boolean enabled ; private Number forwardedId ; private String forwardedName ; private Number senderId ; private boolean sticky ; private String subject ; private boolean unread ; private String username ; private boolean warned ; public Number getConvId ( ) { return convId ; } public String getDate ( ) { return date ; } public boolean isDonor ( ) { return donor ; } public boolean isEnabled ( ) { return enabled ; } public Number getForwardedId ( ) { return forwardedId ; } public String getForwardedName ( ) { return forwardedName ; } public Number getSenderId ( ) { return senderId ; } public boolean isSticky ( ) { return sticky ; } public String getSubject ( ) { return subject ; } public boolean isUnread ( ) { return unread ; } public String getUsername ( ) { if ( username == null | username", "gt": ". length ( ) == 0 ) username = \"System\" ;", "prediction": ")\n", "label": 0}
{"id": 12933, "input": "<s> package com . corundumstudio . socketio . transport ; import java . net . SocketAddress ; import java . util . Collections ; import java . util . UUID ; import com . corundumstudio . socketio . AckCallback ; import com . corundumstudio . socketio . SocketIOClient ; import com . corundumstudio . socketio . namespace . Namespace ; import com . corundumstudio . socketio . parser . Packet ; import com . corundumstudio . socketio . parser . PacketType ; public class NamespaceClient implements SocketIOClient { private final BaseClient baseClient ; private final Namespace namespace ; public NamespaceClient ( BaseClient baseClient , Namespace namespace ) { this . baseClient = baseClient ; this . namespace = namespace ; namespace . addClient ( this ) ; } public BaseClient getBaseClient ( ) { return baseClient ; } public Namespace getNamespace ( ) { return namespace ; } @ Override public void sendEvent ( String name , Object data ) { Packet packet = new Packet ( PacketType . EVENT ) ; packet . setName ( name ) ; packet . setArgs ( Collections . singletonList ( data ) ) ; send ( packet ) ; } @ Override public void sendEvent ( String name , Object data , AckCallback < ? > ackCallback ) { Packet packet = new Packet ( PacketType . EVENT ) ; packet . setName ( name ) ; packet . setArgs ( Collections . singletonList ( data ) ) ; send ( packet , ackCallback ) ; } @ Override public void sendMessage ( String message , AckCallback < ? > ackCallback ) { Packet packet = new Packet ( PacketType . MESSAGE ) ; packet . setData ( message ) ; send ( packet , ackCallback ) ; } @ Override public void sendMessage ( String message ) { Packet packet = new Packet ( PacketType . MESSAGE ) ; packet . setData ( message ) ; send ( packet ) ; } @ Override public void sendJsonObject ( Object object ) { Packet packet = new Packet ( PacketType . JSON ) ; packet . setData ( object ) ; send ( packet ) ; } @ Override public void send ( Packet packet , AckCallback < ? > ackCallback ) { long index = baseClient . getAckManager ( ) . registerAck ( getSessionId ( ) , ackCallback ) ; packet . setId ( index ) ; if ( ! ackCallback . getResultClass ( ) . equals ( Void . class ) ) { packet . setAck ( Packet . ACK_DATA ) ; } send ( packet ) ; } @ Override public void send ( Packet packet ) { packet . setEndpoint ( namespace . getName ( ) ) ; baseClient . send ( packet ) ; } @ Override public void sendJsonObject ( Object object , AckCallback < ? > ackCallback ) { Packet packet = new Packet ( PacketType . JSON ) ; packet . setData ( object ) ; send ( packet , ackCallback ) ; } public void onDisconnect ( ) { namespace . onDisconnect ( this ) ; baseClient . removeChildClient ( this ) ; } @ Override public void disconnect ( ) { send ( new Packet ( PacketType . DISCONNECT ) ) ; onDisconnect ( ) ; } @ Override public UUID getSessionId ( ) { return baseClient . getSessionId ( ) ; } @ Override public SocketAddress getRemoteAddress ( ) { return baseClient . getRemoteAddress ( ) ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( getSessionId ( ) == null ) ? 0 : getSessionId ( ) . hashCode ( ) ) ; result = prime * result + ( ( getNamespace ( ) . getName ( ) == null ) ? 0 : getNamespace ( ) . getName ( ) . hashCode ( ) ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ;", "gt": "NamespaceClient other = ( NamespaceClient ) obj ;", "prediction": "}\n", "label": 1}
{"id": 2666, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . platzverkauf ; import java . util . EventObject ; import java . util . HashSet ; import java . util . Set ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Platz ; class PlatzSelectionEvent extends EventObject { private Set < Platz > _ausgewaehltePlaetze ; public PlatzSelectionEvent ( Object source , Set < Platz > ausgewaehltePlaetze ) { super ( source ) ; _ausgewaehltePlaetze = new HashSet < Platz > ( ausgewaehltePlaetze ) ; } public Set <", "gt": "Platz > getAusgewaehltePlaetze ( )", "prediction": "( )\n", "label": 0}
{"id": 12953, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . client . Ref ; @ SuppressWarnings ( \"serial\" ) public class RetrieveByRefCmd extends TransactionCommand { private final Ref ref ; @ SuppressWarnings ( \"unused\" ) private RetrieveByRefCmd ( ) { this ( 0 , 0 , 0 , null ) ; } public RetrieveByRefCmd ( int storeId , int cid , int tid , Ref ref ) {", "gt": "super ( storeId , cid , tid ) ;", "prediction": "}\n", "label": 1}
{"id": 3387, "input": "<s> import static java . util . zip . ZipFile . ENDSIG ; public class StaticImportAccess { public", "gt": "static long i = ENDSIG ;", "prediction": "( )\n", "label": 0}
{"id": 12956, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . File ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import java . util . Arrays ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . junit . Before ; import org . junit . Test ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IOUtils ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; import com . cloudera . sqoop . util . FileListing ; public class PostgresqlImportTest extends ImportJobTestCase { public static final Log LOG = LogFactory . getLog ( PostgresqlImportTest . class . getName ( ) ) ; static final String HOST_URL = System . getProperty ( \"sqoop.test.postgresql.connectstring.host_url\" , \"jdbc:postgresql://localhost/\" ) ; static final String DATABASE_USER = \"sqooptest\" ; static final String DATABASE_NAME = \"sqooptest\" ; static final String TABLE_NAME = \"EMPLOYEES_PG\" ; static final String SPECIAL_TABLE_NAME = \"EMPLOYEES_PG's\" ; static final String DIFFERENT_TABLE_NAME = \"DIFFERENT_TABLE\" ; static final String SCHEMA_PUBLIC = \"public\" ; static final String SCHEMA_SPECIAL = \"special\" ; static final String CONNECT_STRING = HOST_URL + DATABASE_NAME ; @ Override protected boolean useHsqldbTestServer ( ) { return false ; } @ Before public void setUp ( ) { super . setUp ( ) ; LOG . debug ( \"Setting up another postgresql test: \" + CONNECT_STRING ) ; setUpData ( TABLE_NAME , SCHEMA_PUBLIC ) ; setUpData ( SPECIAL_TABLE_NAME , SCHEMA_PUBLIC ) ; setUpData ( DIFFERENT_TABLE_NAME , SCHEMA_SPECIAL ) ; LOG . debug ( \"setUp complete.\" ) ; } public void setUpData ( String tableName , String schema ) { SqoopOptions options = new SqoopOptions ( CONNECT_STRING , tableName ) ; options . setUsername ( DATABASE_USER ) ; ConnManager manager = null ; Connection connection = null ; Statement st = null ; try { manager = new PostgresqlManager ( options ) ; connection = manager . getConnection ( ) ; connection . setAutoCommit ( false ) ; st = connection . createStatement ( ) ; try { st . executeUpdate ( \"CREATE SCHEMA \" + manager . escapeTableName ( schema ) ) ; connection . commit ( ) ; } catch ( SQLException e ) { LOG . info ( \"Couldn't create schema \" + schema + \" (is o.k. as long as\" + \"the schema already exists.\" , e ) ; connection . rollback ( ) ; } String fullTableName = manager . escapeTableName ( schema ) + \".\" + manager . escapeTableName ( tableName ) ; try { st . executeUpdate ( \"DROP TABLE \" + fullTableName ) ; } catch ( SQLException e ) { LOG . info ( \"Couldn't drop table \" + schema + \".\" + tableName + \" (ok)\" , e ) ; connection . rollback ( ) ; } st . executeUpdate ( \"CREATE TABLE \" + fullTableName + \" (\" + manager . escapeColName ( \"id\" ) + \" INT NOT NULL PRIMARY KEY, \" + manager . escapeColName ( \"name\" ) + \" VARCHAR(24) NOT NULL, \" + manager . escapeColName ( \"start_date\" ) + \" DATE, \" + manager . escapeColName ( \"Salary\" ) + \" FLOAT, \" + manager . escapeColName ( \"dept\" ) + \" VARCHAR(32))\" ) ; st . executeUpdate ( \"INSERT INTO \"", "gt": "+ fullTableName + \" VALUES(1,'Aaron','2009-05-14',1000000.00,'engineering')\" ) ;", "prediction": ") ;\n", "label": 1}
