{"id": 257, "input": "<s> package uk . ac . cam . cl . dtg . android . time . buses ; import java . io . Serializable ; public class BusArrival implements Serializable { private static final long serialVersionUID = - 9046897187435560242L ; String serviceID ; String destination ; ArrivalTime dueTime ; public BusArrival ( String service , String dest , String due ) { serviceID = service ; try { dueTime = new ArrivalTime ( due ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; } destination = dest ; } public BusArrival ( String service , String dest , long dueTime ) { serviceID = service ; destination = dest ; this . dueTime = new ArrivalTime ( dueTime ) ; } public BusArrival ( String service , String destination , ArrivalTime dueTime ) { this . serviceID = service ; this . destination = destination ; this . dueTime = dueTime ; } public String getServiceID ( ) { return serviceID ; } public void setServiceID ( String serviceID ) { this . serviceID = serviceID ; } public String getDestination ( ) { return destination ; } public void setDestination ( String destination ) { this . destination = destination ; } public ArrivalTime getDueTime ( ) { return dueTime ; } public void setDueTime ( ArrivalTime dueTime ) { this . dueTime = dueTime ; } public void setDueTime ( long dueTime ) { this . dueTime = new ArrivalTime ( dueTime ) ; } @ Override public String toString ( ) { return serviceID + \" to \" + destination + \" (\"", "gt": "+ dueTime + \")\" ;", "prediction": "+ dueTime + \")\" ;\n", "label": 0}
{"id": 12999, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import org . restlet . data . Reference ; import org . restlet . example . book . restlet . ch09 . common . MailRepresentation ; import org . restlet . example . book . restlet . ch09 . common . MailsRepresentation ; import org . restlet . example . book . restlet . ch09 . common . MailsResource ; import org . restlet . ext . wadl . WadlServerResource ; public class MailsServerResource extends WadlServerResource implements MailsResource { public MailsRepresentation retrieve ( ) { MailsRepresentation mails = new MailsRepresentation ( ) ; MailRepresentation mail = new MailRepresentation ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( ) . toString ( ) ) ; mails . getEmails ( ) . add ( mail ) ; return mails ; } public void add ( MailRepresentation mail ) { System . out . println ( \"Status: \" + mail . getStatus ( ) ) ; System . out . println ( \"Subject: \" + mail . getSubject ( ) ) ; System . out . println", "gt": "( \"Content: \" + mail . getContent ( ) ) ;", "prediction": "( \"Content: \" + mail . getContent ( ) ) ;\n", "label": 1}
{"id": 3279, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . EndCredit ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class EndCreditImpl extends TaskAttributeImpl implements EndCredit { protected static final float CREDIT_EDEFAULT = 0.0F ; protected float credit = CREDIT_EDEFAULT ; protected EndCreditImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getEndCredit ( ) ; } public float getCredit ( ) { return credit ; } public void setCredit ( float newCredit ) { float oldCredit = credit ; credit = newCredit ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . END_CREDIT__CREDIT , oldCredit , credit ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . END_CREDIT__CREDIT : return getCredit ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . END_CREDIT__CREDIT : setCredit ( ( Float ) newValue ) ; return ; } super . eSet (", "gt": "featureID , newValue ) ;", "prediction": "featureID , newValue ) ;\n", "label": 0}
{"id": 13016, "input": "<s> package br . org . archimedes . trimmers ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; import br . org . archimedes . trims . interfaces . Trimmer ; import org . junit . Before ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; public class PolylineTrimTest extends Tester { Polyline poly1 ; Trimmer trimmer ; Collection < Point > cutPoints = new ArrayList < Point > ( ) ; @ Before public void setUp ( ) throws NullArgumentException , InvalidArgumentException { List < Point > polyPoints = new ArrayList < Point > ( ) ; polyPoints . add ( new Point ( 0.0 , - 1.0 ) ) ; polyPoints . add ( new Point ( 0.0 , 1.0 ) ) ; polyPoints . add ( new Point ( 1.0 , 1.0 ) ) ; polyPoints . add ( new Point ( 1.0 , 0.0 ) ) ; polyPoints . add ( new Point ( - 1.0 , 0.0 ) ) ; polyPoints . add ( new Point ( - 1.0 , - 1.0 ) ) ; poly1 = new Polyline ( polyPoints ) ; trimmer = new PolylineTrimmer ( ) ; } @ Test public void oneIntersectionReturnsPolyline ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( 0.0 , - 0.5 ) ) ; Collection < Element > smallerSide = trimmer . trim ( poly1 , cutPoints , new Point ( 0.0 , 0.0 ) ) ; List < Point > expectedPolyPoints = new ArrayList < Point > ( ) ; expectedPolyPoints . add ( new Point ( 0.0 , - 1.0 ) ) ; expectedPolyPoints . add ( new Point ( 0.0 , - 0.5 ) ) ; Polyline expected = new Polyline ( expectedPolyPoints ) ; assertCollectionTheSame ( Collections . singleton ( expected ) , smallerSide ) ; Collection < Element > biggerSide = trimmer . trim ( poly1 , cutPoints , new Point ( 0.0 , - 1.0 ) ) ; expectedPolyPoints = new ArrayList < Point > ( ) ; expectedPolyPoints . add ( new Point ( 0.0 , - 0.5 ) ) ; expectedPolyPoints . add ( new Point ( 0.0 , 1.0 ) ) ; expectedPolyPoints . add ( new Point ( 1.0 , 1.0 ) ) ; expectedPolyPoints . add ( new Point ( 1.0 , 0.0 ) ) ; expectedPolyPoints . add ( new Point ( - 1.0 , 0.0 ) ) ; expectedPolyPoints . add ( new Point ( - 1.0 , - 1.0 ) ) ; expected = new Polyline ( expectedPolyPoints ) ; assertCollectionTheSame ( Collections . singleton ( expected ) , biggerSide ) ; } @ Test public void twoIntersectionsReturnTwoPolylinesClickingUp ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( - 1.0 , - 0.5 ) ) ; cutPoints . add ( new Point ( 0.0 , - 0.5 ) ) ; Collection < Element > smallerSide = trimmer . trim ( poly1 , cutPoints , new Point ( 0.0 , 0.0 ) ) ; List < Point > expectedPoly1Points = new ArrayList < Point > ( ) ; expectedPoly1Points . add ( new Point ( 0.0 , - 1.0 ) ) ; expectedPoly1Points . add ( new Point ( 0.0 , - 0.5 ) ) ; Polyline expectedPoly1 = new Polyline ( expectedPoly1Points ) ; List < Point > expectedPoly2Points = new ArrayList < Point > ( ) ; expectedPoly2Points . add ( new Point ( - 1.0 , - 0.5 ) ) ; expectedPoly2Points . add ( new Point ( - 1.0 , - 1.0 ) ) ; Polyline expectedPoly2 = new Polyline ( expectedPoly2Points ) ; Collection < Element > expected = new ArrayList < Element > ( ) ; expected . add ( expectedPoly1 ) ; expected . add ( expectedPoly2 ) ; assertCollectionTheSame ( expected , smallerSide ) ; } @ Test public void twoIntersectionsReturnPolylineClickingDown ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( - 1.0 , - 0.5 ) ) ; cutPoints . add ( new Point ( 0.0 , - 0.5 ) ) ; Collection < Element > biggerSide = trimmer . trim ( poly1 , cutPoints , new Point ( 0.0 , - 1.0 ) ) ; List < Point > expectedPolyPoints", "gt": "= new ArrayList < Point > ( ) ;", "prediction": "= new ArrayList < Point > ( ) ;\n", "label": 1}
{"id": 4763, "input": "<s> package pkg ; import java . util . * ; import java . lang . * ; import java . io . * ; import java . util . zip . * ; public abstract class TestAbstractClass extends TestSuperSuperClass implements TestInterfaceForAbstractClass { public String testAbstractClass_method1 ( int p1 , int p2 ) throws java . io . IOException , java . lang . NullPointerException { return null ; } public String testAbstractClass_method2 ( int p1 , int p2 ) throws java . io .", "gt": "IOException , java . lang . NullPointerException", "prediction": "IOException , java . lang . NullPointerException\n", "label": 0}
{"id": 13018, "input": "<s> package org . eclipse . ui . tests . session ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . PlatformUI ; public class Bug98800Test extends TestCase { private static final String PROBLEM_VIEW_ID = \"org.eclipse.ui.views.ProblemView\" ; private static final String VIEW_WITH_STATE_ID = \"org.eclipse.ui.tests.session.ViewWithState\" ; public static TestSuite suite ( ) { return new TestSuite ( Bug98800Test . class ) ; } private IWorkbenchPage fPage ; public Bug98800Test ( String testName ) { super ( testName ) ; fPage = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; } public void testActivateView ( ) throws Throwable { IViewPart v = fPage . showView ( VIEW_WITH_STATE_ID ) ; fPage . showView ( PROBLEM_VIEW_ID ) ; ViewWithState view = ( ViewWithState ) v ; view . fState = 10 ; } public", "gt": "void testSecondOpening ( ) throws Throwable", "prediction": "void testRemoveView ( ) throws Throwable\n", "label": 1}
{"id": 8766, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Scenario ; import org . jjflyboy . tjpeditor . project . ScenarioIcal ; public class ScenarioIcalImpl extends IcalReportAttributeImpl implements ScenarioIcal { protected Scenario scenario ; protected ScenarioIcalImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getScenarioIcal ( ) ; } public Scenario getScenario ( ) { if ( scenario != null && scenario . eIsProxy ( ) ) { InternalEObject oldScenario = ( InternalEObject ) scenario ; scenario = ( Scenario ) eResolveProxy ( oldScenario ) ; if ( scenario != oldScenario ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . SCENARIO_ICAL__SCENARIO , oldScenario , scenario ) ) ; } } return scenario ; } public Scenario basicGetScenario ( ) { return scenario ; } public void setScenario ( Scenario newScenario ) { Scenario oldScenario = scenario ; scenario = newScenario ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SCENARIO_ICAL__SCENARIO , oldScenario , scenario ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SCENARIO_ICAL__SCENARIO : if ( resolve ) return getScenario ( ) ; return basicGetScenario ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . SCENARIO_ICAL__SCENARIO : setScenario ( ( Scenario ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . SCENARIO_ICAL__SCENARIO : setScenario ( ( Scenario ) null ) ; return ; } super", "gt": ". eUnset ( featureID ) ;", "prediction": ". eUnset ( featureID ) ;\n", "label": 0}
{"id": 13023, "input": "<s> package org . eclipse . swt . internal . image ; import java . io . * ; final class LEDataOutputStream extends OutputStream { OutputStream out ; public LEDataOutputStream ( OutputStream output ) { this . out = output ; } public void write ( byte b [ ] , int off , int len ) throws IOException { out . write ( b , off , len ) ; } public void write ( int b ) throws IOException { out . write ( b ) ; } public void writeByte ( byte b ) throws IOException { out . write ( b & 0xFF ) ; } public void writeInt ( int theInt ) throws IOException { out . write ( theInt & 0xFF ) ; out . write ( ( theInt > > 8 ) & 0xFF ) ; out . write ( ( theInt >", "gt": "> 16 ) & 0xFF ) ;", "prediction": "> 16 ) & 0xFF ) ;\n", "label": 1}
{"id": 3471, "input": "<s> package com . midtro . platform . modules ; public class MessageException extends IllegalArgumentException { private static final long serialVersionUID = 2379992181217683002L ; public MessageException", "gt": "( final String message )", "prediction": "( )\n", "label": 0}
{"id": 13037, "input": "<s> package org . mitre . openid . connect . view ; import java . io . IOException ; import java . io . Writer ; import java . util . Map ; import java . util . Set ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . mitre . openid . connect . model . UserInfo ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . stereotype . Component ; import org . springframework . validation . BeanPropertyBindingResult ; import org . springframework . web . servlet . view . AbstractView ; import com . google . gson . ExclusionStrategy ; import com . google . gson . FieldAttributes ; import com . google . gson . Gson ; import com . google . gson . GsonBuilder ; import com . google . gson . JsonObject ; @ Component ( \"jsonUserInfoView\" ) public class JSONUserInfoView extends AbstractView { private static Logger logger = LoggerFactory . getLogger ( JSONUserInfoView . class ) ; protected void renderMergedOutputModel ( Map < String , Object > model , HttpServletRequest request , HttpServletResponse response ) { UserInfo userInfo = ( UserInfo ) model . get ( \"userInfo\" ) ; Set < String > scope = ( Set < String > ) model . get ( \"scope\" ) ; Gson gson = new GsonBuilder ( ) . setExclusionStrategies ( new ExclusionStrategy ( ) { public boolean shouldSkipField ( FieldAttributes f ) { return false ; } public boolean shouldSkipClass ( Class < ? > clazz ) { if ( clazz . equals ( BeanPropertyBindingResult . class ) ) { return true ; } return false ; } } ) . create ( ) ; response . setContentType ( \"application/json\" ) ; Writer out ; try { out = response . getWriter ( ) ; gson . toJson ( toJson ( userInfo , scope ) , out ) ; } catch ( IOException e ) { logger . error ( \"IOException in JSONUserInfoView.java: \" , e ) ; } } private JsonObject toJson ( UserInfo ui , Set < String > scope ) { JsonObject obj = new JsonObject ( ) ; if ( scope . contains ( \"openid\" ) ) { obj . addProperty ( \"user_id\" , ui . getUserId ( ) ) ; }", "gt": "if ( scope . contains ( \"profile\" ) )", "prediction": "else\n", "label": 1}
{"id": 3988, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface", "gt": "Shifts extends ShiftsResource , ShiftsTask", "prediction": "EListFactory\n", "label": 0}
{"id": 13040, "input": "<s> package com . cloudera . sqoop . lib ; import junit . framework . TestCase ; public class TestBooleanParser extends TestCase { public void testBoolParser ( ) { assertTrue ( BooleanParser . valueOf ( \"true\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"TRUE\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"True\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"t\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"T\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"on\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"On\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"ON\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"yes\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"yEs\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"YES\" ) ) ; assertTrue ( BooleanParser . valueOf ( \"1\" ) ) ; assertFalse ( BooleanParser . valueOf ( null ) ) ; assertFalse ( BooleanParser . valueOf ( \"no\" ) ) ; assertFalse ( BooleanParser . valueOf ( \"false\" ) ) ; assertFalse ( BooleanParser . valueOf ( \"FALSE\" ) ) ; assertFalse ( BooleanParser . valueOf ( \"0\" ) ) ; assertFalse ( BooleanParser . valueOf ( \"off\" ) ) ; assertFalse", "gt": "( BooleanParser . valueOf ( \"OFF\" ) ) ;", "prediction": "( BooleanParser . valueOf ( \"off\" ) ) ;\n", "label": 1}
{"id": 5134, "input": "<s> public enum E { a", "gt": ", b , c }", "prediction": ", b , c }\n", "label": 0}
{"id": 13054, "input": "<s> package org . spliffy . sync . app ; import java . awt . Desktop ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import javax . swing . JOptionPane ; import org . openide . windows . WindowManager ; public class WindowController { private final Desktop desktop ; private final String url ; public WindowController ( String url ) { if ( Desktop . isDesktopSupported ( ) ) { desktop = Desktop . getDesktop ( ) ; } else { desktop = null ; } this . url = url ; } public void hideMain ( ) { WindowManager . getDefault ( ) . getMainWindow ( ) . setVisible ( false ) ; } public void showMain ( ) { WindowManager . getDefault ( ) . getMainWindow ( ) . setVisible ( true ) ; } public void openMediaLounge ( ) { if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { URI uri = null ; try { uri = new URI ( url ) ; } catch ( URISyntaxException use ) { showError ( \"Sorry, I can't open this web address: \" + url ) ; return ; } try { desktop . browse ( uri ) ; } catch ( IOException ex ) { showError ( \"Can't open: \" + url ) ; } } else { showError ( \"Can't open: \" + url ) ; } } private", "gt": "void showError ( String err )", "prediction": "void showError ( )\n", "label": 1}
{"id": 356, "input": "<s> package org . bombusim . xmpp . handlers ; import java . io . IOException ; import org . bombusim . xmpp . XmppObject ; import org . bombusim . xmpp . XmppObjectListener ; import org . bombusim . xmpp . XmppStream ; import org . bombusim . xmpp . exception . XmppException ; import org . bombusim . xmpp . stanza . Iq ; import android . text . format . Time ; public class IqTimeReply extends XmppObjectListener { public IqTimeReply ( ) { } ; private final static String CAPS_XMLNS = \"urn:xmpp:time\" ; @ Override public String capsXmlns ( ) { return CAPS_XMLNS ; } @ Override public int blockArrived ( XmppObject data , XmppStream stream ) throws IOException , XmppException { if ( ! ( data instanceof Iq ) ) return BLOCK_REJECTED ; if ( ! data . getAttribute ( \"type\" ) . equals ( \"get\" ) ) return BLOCK_REJECTED ; XmppObject query = data . findNamespace ( \"query\" , \"jabber:iq:time\" ) ; if ( query != null ) { android . text . format . Time t = getCurrentTime ( ) ; query . addChild ( \"display\" , t . format ( \"%d/%m/%Y %H:%M\" ) ) ; t . switchTimezone ( \"UTC\" ) ; query . addChild ( \"utc\" , t . format ( \"%Y%m%dT%H:%M:%S\" ) ) ; } else { query = data . findNamespace ( \"time\" , CAPS_XMLNS ) ; if ( query == null ) return BLOCK_REJECTED ; android . text . format . Time t = getCurrentTime ( ) ; StringBuilder tzo = new StringBuilder ( t . format ( \"%z\" ) ) ; if ( tzo . length ( ) == 0 ) tzo . append ( \"+0000\" ) ; tzo . insert ( 3 , ':' ) ; query . addChild ( \"tzo\" , tzo . toString ( ) ) ; t . switchTimezone ( \"UTC\" ) ; query . addChild ( \"utc\" , t . format3339 ( false ) ) ; } Iq reply = new Iq ( data . getAttribute ( \"from\" ) , Iq . TYPE_RESULT , data . getAttribute ( \"id\" ) ) ; reply . addChild ( query ) ; stream . send ( reply ) ; return BLOCK_PROCESSED ; } Time getCurrentTime ( ) { Time current = new Time", "gt": "( Time . getCurrentTimezone ( ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13055, "input": "<s> package org . eclipse . ui . tests . autotests ; import java . net . URL ; import org . eclipse . ui . WorkbenchException ; public class AutoTestLogger extends AbstractTestLogger { private TestResults errors = new TestResults ( ) ; private TestResults expectedResults ; private TestResults unknownTests = new TestResults ( ) ; public AutoTestLogger ( URL expectedResultsFile ) throws WorkbenchException { this ( new TestResults ( XmlUtil . read ( expectedResultsFile ) ) ) ; } public AutoTestLogger ( TestResults expectedResults ) { this . expectedResults = expectedResults ; } public AutoTestLogger ( ) { this ( new TestResults ( ) ) ; } public void setExpectedResults ( TestResults results ) { this . expectedResults = results ; } public TestResults getErrors ( ) { return errors ; } public TestResults getUnknownTests ( ) { return unknownTests ; } public void reportResult ( String testName , TestResult result ) throws Throwable { TestResultFilter expectedResult = expectedResults . get ( testName ) ; if ( expectedResult == null ) { unknownTests . put ( testName , new TestResultFilter ( result ) ) ; } else { try { expectedResult . assertResult ( result ) ; } catch ( Throwable t ) { errors .", "gt": "put ( testName , new TestResultFilter ( result ) ) ;", "prediction": "add ( t ) ;\n", "label": 1}
{"id": 8534, "input": "<s> package org . ofbiz . jetty . container ; import java . io . File ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . ofbiz . base . component . ComponentConfig ; import org . ofbiz . base . container . Container ; import org . ofbiz . base . container . ContainerConfig ; import org . ofbiz . base . container . ContainerException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . SSLUtil ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . eclipse . jetty . ajp . Ajp13SocketConnector ; import org . eclipse . jetty . server . Connector ; import org . eclipse . jetty . server . NCSARequestLog ; import org . eclipse . jetty . server . Server ; import org . eclipse . jetty . server . bio . SocketConnector ; import org . eclipse . jetty . server . handler . HandlerCollection ; import org . eclipse . jetty . server . handler . RequestLogHandler ; import org . eclipse . jetty . server . nio . SelectChannelConnector ; import org . eclipse . jetty . server . session . HashSessionManager ; import org . eclipse . jetty . server . session . SessionHandler ; import org . eclipse . jetty . server . ssl . SslConnector ; import org . eclipse . jetty . server . ssl . SslSelectChannelConnector ; import org . eclipse . jetty . server . ssl . SslSocketConnector ; import org . eclipse . jetty . util . ssl . SslContextFactory ; import org . eclipse . jetty . util . thread . QueuedThreadPool ; import org . eclipse . jetty . util . thread . ThreadPool ; import org . eclipse . jetty . webapp . WebAppContext ; public class JettyContainer implements Container { public static final String module = JettyContainer . class . getName ( ) ; private String name ; private Map < String , Server > servers = new HashMap < String , Server > ( ) ; @ Override public void init ( String [ ] args , String name , String configFile ) throws ContainerException { this . name = name ; SSLUtil . loadJsseProperties ( ) ; File sessionStoreDirectory = new File ( UtilProperties . getPropertyValue ( \"jetty\" , \"session.store.directory\" , \"runtime/jetty/sessions\" ) ) ; if ( ! sessionStoreDirectory . exists ( ) ) { if ( ! sessionStoreDirectory . mkdirs ( ) ) { throw new ContainerException ( \"error creating session store directory: \" + sessionStoreDirectory . getAbsolutePath ( ) ) ; } } ContainerConfig . Container jettyContainerConfig = ContainerConfig . getContainer ( name , configFile ) ; for ( ContainerConfig . Container . Property serverConfig : jettyContainerConfig . getPropertiesWithValue ( \"server\" ) ) { servers . put ( serverConfig . name , createServer ( serverConfig ) ) ; } for ( ComponentConfig componentConfig : ComponentConfig . getAllComponents ( ) ) { for ( ComponentConfig . WebappInfo webappInfo : componentConfig . getWebappInfos ( ) ) { Server server =", "gt": "servers . get ( webappInfo . server ) ;", "prediction": "componentConfig . getServer ( ) ;\n", "label": 0}
{"id": 13060, "input": "<s> package org . restlet . ext . osgi ; import java . util . Dictionary ; import org . osgi . service . component . ComponentContext ; import org . osgi . service . http . HttpContext ; import org . restlet . Application ; import org . restlet . Context ; public class ApplicationProvider implements IApplicationProvider { private String alias ; private Application application ; private IRouterProvider routerProvider ; protected void activate ( ComponentContext context ) { @ SuppressWarnings ( \"unchecked\" ) Dictionary < String , Object > properties = context . getProperties ( ) ; alias = ( String ) properties . get ( \"alias\" ) ; } public void bindRouterProvider ( IRouterProvider routerProvider ) { this . routerProvider = routerProvider ; if ( application != null ) application . setInboundRoot ( routerProvider . getInboundRoot ( application . getContext ( ) ) ) ; } @ Override public Application createApplication ( Context context ) { application = doCreateApplication ( context ) ; if ( routerProvider != null ) application . setInboundRoot ( routerProvider . getInboundRoot ( context ) ) ; return application ; } protected Application doCreateApplication ( Context context ) { Application app = new Application ( ) ; app .", "gt": "setContext ( context ) ;", "prediction": "setInboundRoot ( context ) ;\n", "label": 1}
{"id": 6176, "input": "<s> package com . buycentives . jrelax ; import org . restlet . data . Status ; public class CouchDbException extends RuntimeException { private Status status ; public CouchDbException ( Status status ) { this . status = status ; } public CouchDbException ( String message , Status status ) { super ( message ) ; this . status = status ; } public CouchDbException ( String message ,", "gt": "Throwable throwable , Status status )", "prediction": "Status status )\n", "label": 0}
{"id": 13081, "input": "<s> package org . modelgoon . classes . figures ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . ToolbarLayout ; public class CompartmentFigure extends Figure { public CompartmentFigure ( final int spacing ) { ToolbarLayout layout = new ToolbarLayout ( ) ; layout . setMinorAlignment (", "gt": "ToolbarLayout . ALIGN_TOPLEFT ) ;", "prediction": "true ) ;\n", "label": 1}
{"id": 9510, "input": "<s> import javax . lang . model . type . * ; public class NpeTest { public static void main ( String ... args ) { try { MirroredTypeException mte", "gt": "= new MirroredTypeException ( null ) ;", "prediction": "= new NpeTest ( ) ;\n", "label": 0}
{"id": 13087, "input": "<s> package org . spliffy . server . web ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import java . util . List ; public class JsonResult { private boolean status ; private String nextHref ; private List < String > messages ; private List < FieldMessage > fieldMessages ; public JsonResult ( ) { } public JsonResult ( boolean status , String nextHref , List < String > messages , List < FieldMessage > fieldMessages ) { this . status = status ; this . nextHref = nextHref ; this . messages = messages ; this . fieldMessages = fieldMessages ; } public JsonResult ( boolean status ) { this . status = status ; } public JsonResult ( boolean status , String message ) { this . status = status ; this . messages = Arrays . asList ( message ) ; } public JsonResult ( boolean status , String message , String nextHref ) { this . status = status ; this . nextHref = nextHref ; this . messages = Arrays . asList ( message ) ; } public void write ( OutputStream out ) throws IOException { JsonWriter jsonWriter = new JsonWriter ( ) ; jsonWriter . write ( this , out ) ; } public boolean isStatus ( ) { return status ; } public void setStatus ( boolean status ) { this . status = status ; } public String getNextHref ( ) { return nextHref ; } public void setNextHref ( String nextHref ) { this . nextHref = nextHref ; } public List < String > getMessages ( ) { return messages ; }", "gt": "public void setMessages ( List < String > messages )", "prediction": "public void setMessages ( List < String > messages )\n", "label": 1}
{"id": 6972, "input": "<s> class T6758789a { void m1 ( ) { } void m2 ( int i ) { } void test ( ) {", "gt": "m1 ( 1 ) ;", "prediction": "}\n", "label": 0}
{"id": 13093, "input": "<s> package br . org . archimedes . parser ; import org . junit . Assert ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . interfaces . Parser ; import br . org . archimedes . model . Point ; public class OffsetDirectionParserTest extends Tester { @ Test public void testPlus ( ) { Parser dp = new DirectionParser ( ) ; Assert . assertFalse ( \"Should not be done yet\" , dp . isDone ( ) ) ; doSafeNext ( dp , \"+\" ) ; Assert . assertTrue ( \"Should be done\" , dp . isDone ( ) ) ; Assert . assertEquals ( \"Should be true for positive\" , true , dp . getParameter ( ) ) ; } @ Test public void testMinus ( ) { Parser dp = new DirectionParser ( ) ; Assert . assertFalse ( \"Should not be done yet\" , dp . isDone ( ) ) ; doSafeNext ( dp , \"-\" ) ; Assert . assertTrue ( \"Should be done\" , dp . isDone ( ) ) ; Assert . assertEquals ( \"Should be false for negative\" , false , dp . getParameter ( ) ) ; } @ Test public void testPoint ( ) { Parser dp = new DirectionParser ( ) ; Assert . assertFalse ( \"Should not be done yet\" , dp . isDone ( ) ) ; testInvalids ( dp ) ; doSafeNext ( dp , \"15;35\" ) ; Assert . assertTrue ( \"Should be done\" , dp . isDone ( ) ) ; Assert . assertEquals ( \"Parameter should be correct\" , new Point ( 15 , 35 ) , dp . getParameter ( ) ) ; } @ Test public void testReturn ( ) { Parser dp = new DirectionParser ( ) ; Assert . assertFalse ( \"Should not be done yet\" , dp . isDone ( ) ) ; br . org . archimedes . Utils . getWorkspace ( ) . setMousePosition ( new Point ( 40 , 10 ) ) ; doSafeNext ( dp , \"\" ) ; Assert . assertTrue ( \"Should be done\" , dp . isDone ( ) ) ; Assert . assertEquals ( \"Parameter should be a point\" , new Point ( 40 , 10 ) , dp . getParameter ( ) ) ; } private", "gt": "void testInvalids ( Parser parser )", "prediction": "void doSafeNext ( )\n", "label": 1}
{"id": 4615, "input": "<s> package api . torrents . torrents ; public class Artists { private Number id ; private String name ; public Number getId ( ) { return this . id ; } public String getName ( ) { return this . name ; } @ Override public String toString ( ) { return \"Artists [getId()=\" + getId (", "gt": ") + \", getName()=\" + getName ( ) + \"]\" ;", "prediction": ") + \"]\" ;\n", "label": 0}
{"id": 13096, "input": "<s> package org . jscsi . initiator . devices ; public interface Device { public void open ( ) throws Exception ; public void close ( ) throws Exception ; public int getBlockSize ( ) ; public long getBlockCount ( ) ; public String getName ( ) ; public void read ( final long address , final byte [ ] data ) throws Exception ; public void write ( final long address , final byte [", "gt": "] data ) throws Exception ;", "prediction": "] data ) throws Exception ;\n", "label": 1}
{"id": 1455, "input": "<s> class CantResolve { Object o = new Object ( ) {", "gt": "int i = f ;", "prediction": "@ Override public String toString ( )\n", "label": 0}
{"id": 13097, "input": "<s> package com . onarandombox . MultiversePortals . enums ; public enum PortalConfigProperty { wand , useonmove , portalsdefaulttonether , enforceportalaccess , portalcooldown , clearonremove , teleportvehicles ; public static String getAllValues ( ) { String buffer = \"\" ; for ( PortalConfigProperty c : PortalConfigProperty . values ( ) ) { buffer", "gt": "+= c . toString ( ) + \" \" ;", "prediction": "= c . getValues ( ) ;\n", "label": 1}
{"id": 9447, "input": "<s> package LizaCraft . Entity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . block . Block ; import org . bukkit . entity . Entity ; import org . bukkit . entity . Ghast ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaBlock ; import Liza . LizaEgg ; import Liza . LizaEntity ; import Liza . LizaGhast ; import Liza . LizaPlayer ; import Liza . LizaServer ; import Liza . LizaSnowball ; import Liza . LizaVehicle ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; import LizaCraft . Block . LizaCraftBlock ; public class LizaCraftGhast implements LizaGhast { private Ghast ghast ; public LizaCraftGhast ( Ghast ghast ) { this . ghast = ghast ; } @ Override public void damage ( int amount ) { this . ghast . damage ( amount ) ; } @ Override public void damage ( int amount , Entity source ) { this . ghast . damage ( amount , source ) ; } @ Override public double getEyeHeight ( ) { return this . ghast . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean ignoreSneaking ) { return this . ghast . getEyeHeight ( ignoreSneaking ) ; } @ Override public Location getEyeLocation ( ) { return this . ghast . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . ghast . getHealth ( ) ; } @ Override public LizaPlayer getKiller ( ) { return new LizaCraftPlayer ( this . ghast . getKiller ( ) ) ; } @ Override public int getLastDamage ( ) { return this . ghast . getLastDamage ( ) ; } @ Override @ Deprecated public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > transparent , int maxDistance ) { List < Block > bl = this . ghast . getLastTwoTargetBlocks ( transparent , maxDistance ) ; for ( Block b : bl ) { bl . remove ( b ) ; LizaBlock lb = new LizaCraftBlock ( b ) ; bl . add ( lb ) ; } return bl ; } @ Override @ Deprecated public List < Block > getLineOfSight", "gt": "( HashSet < Byte > transparent , int maxDistance )", "prediction": "( )\n", "label": 0}
{"id": 13098, "input": "<s> package org . eclipse . core . tests . session ; import org . eclipse . core . tests . session . SetupManager . SetupException ; public class UIPerformanceSessionTestSuite extends PerformanceSessionTestSuite { public UIPerformanceSessionTestSuite ( String pluginId , int timesToRun ) { super ( pluginId , timesToRun ) ; setApplicationId ( SessionTestSuite . UI_TEST_APPLICATION ) ; } public UIPerformanceSessionTestSuite ( String pluginId , int timesToRun , Class theClass ) { super ( pluginId , timesToRun , theClass ) ; setApplicationId ( SessionTestSuite . UI_TEST_APPLICATION ) ; } public UIPerformanceSessionTestSuite ( String pluginId , int timesToRun , Class theClass , String name ) { super ( pluginId , timesToRun , theClass , name ) ; setApplicationId ( SessionTestSuite . UI_TEST_APPLICATION ) ; } public UIPerformanceSessionTestSuite ( String pluginId", "gt": ", int timesToRun , String name )", "prediction": ", int timesToRun , Class theClass , String name )\n", "label": 1}
{"id": 8286, "input": "<s> package org . ofbiz . service . calendar ; public interface TemporalExpressionVisitor { void visit ( TemporalExpressions . DateRange expr ) ; void visit ( TemporalExpressions . DayInMonth expr ) ; void visit ( TemporalExpressions . DayOfMonthRange expr ) ; void visit ( TemporalExpressions . DayOfWeekRange expr ) ; void visit ( TemporalExpressions . Difference expr ) ; void visit ( TemporalExpressions . Frequency expr ) ; void visit ( TemporalExpressions . HourRange expr ) ; void visit ( TemporalExpressions . Intersection expr ) ;", "gt": "void visit ( TemporalExpressions . MinuteRange expr ) ;", "prediction": "}\n", "label": 0}
{"id": 13109, "input": "<s> package com . datatype . voronoi ; import java . util . Comparator ; public class VorEventSorter implements Comparator < VorEvent > { public int compare ( VorEvent a , VorEvent b ) { if ( a . point . getY ( ) < b . point . getY ( ) ) { return 1 ; } else if ( a . point . getY ( ) == b . point . getY ( ) ) { if ( a . point . getX ( ) < b . point . getX ( ) ) { return - 1 ; } else { return 1 ; } } else if ( a . point . getY ( ) > b . point", "gt": ". getY ( ) )", "prediction": ". getY ( ) )\n", "label": 1}
{"id": 9879, "input": "<s> package javax . tools ; import javax . tools . JavaFileManager . Location ; import java . util . concurrent . * ; public enum StandardLocation implements Location { CLASS_OUTPUT , SOURCE_OUTPUT , CLASS_PATH , SOURCE_PATH , ANNOTATION_PROCESSOR_PATH , PLATFORM_CLASS_PATH ; public static Location locationFor ( final String name ) { if ( locations . isEmpty ( ) ) { for ( Location location : values ( ) ) locations . putIfAbsent ( location . getName ( ) , location ) ; } locations . putIfAbsent ( name . toString ( ) , new Location ( ) { public String getName ( ) { return name ; } public boolean isOutputLocation ( ) { return name . endsWith ( \"_OUTPUT\" ) ; } } ) ; return locations . get ( name ) ; } private static ConcurrentMap < String , Location > locations =", "gt": "new ConcurrentHashMap < String , Location > ( ) ;", "prediction": "new ConcurrentMap < String , Location > ( ) ;\n", "label": 0}
{"id": 13111, "input": "<s> package org . nuxeo . ecm . platform . task . dashboard ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . ClientRuntimeException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . platform . task . Task ; import org . nuxeo . ecm . platform . task . TaskComment ; public class DashBoardItemImpl extends AbstractDashBoardItemImpl implements DashBoardItem { private static final long serialVersionUID = 919752175741886376L ; protected final String id ; protected final String name ; protected final String description ; protected final Date startDate ; protected final Date dueDate ; protected final boolean expired ; protected final String directive ; protected final DocumentModel document ; protected final Task task ; protected String comment ; public DashBoardItemImpl ( Task task , Locale locale ) { this ( task , task . getDocument ( ) , locale ) ; } public DashBoardItemImpl ( Task task , DocumentModel document , Locale locale ) { try { this . task = task ; this . document = document ; this . locale = locale ; id = task . getId ( ) ; name = task . getName ( ) ; description = task . getDescription ( ) ; dueDate = task . getDueDate ( ) ; startDate = task . getCreated ( ) ; directive = task . getDirective ( ) ; List < TaskComment > comments = task . getComments ( ) ; if ( comments != null && ! comments . isEmpty ( ) ) { comment = comments . get ( comments . size ( ) - 1 ) . getText ( ) ; } else { comment = null ; } if ( dueDate != null ) {", "gt": "Date today = new Date ( ) ;", "prediction": "this . dueDate = dueDate ;\n", "label": 1}
{"id": 5626, "input": "<s> package com . example . business . testing ; import com . asakusafw . runtime . value . DateTime ; import com . example . business . modelgen . table . model . Stock ; public class StockFactory { private StockFactory ( ) { return ; } public static Stock create ( DateTime purchasedDate , long itemCode , int cost , int quantity ) { Stock result = new Stock ( ) ; result . setPurchasedDate ( purchasedDate ) ; result", "gt": ". setItemCode ( itemCode ) ;", "prediction": ". setPrice ( price ) ;\n", "label": 0}
{"id": 13112, "input": "<s> package org . nuxeo . ecm . automation . core . operations . execution ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; @ Operation ( id = RunOperation . ID , category = Constants . CAT_SUBCHAIN_EXECUTION , label = \"Run Chain\" , description = \"Run an operation chain in the current context\" ) public class RunOperation { public static final String ID = \"Context.RunOperation\" ; @ Context protected OperationContext ctx ; @ Context protected AutomationService service ; @ Param ( name = \"id\" ) protected String chainId ; @ Param ( name = \"isolate\" , required = false , values = \"false\" ) protected boolean isolate = false ; @ OperationMethod public void run ( ) throws Exception { Map < String , Object > vars = isolate ? new HashMap < String , Object > ( ctx . getVars ( ) ) : ctx . getVars ( ) ; OperationContext subctx = new OperationContext (", "gt": "ctx . getCoreSession ( ) , vars ) ;", "prediction": "ctx ) ;\n", "label": 1}
{"id": 1272, "input": "<s> package com . toedter . gwt . demo . contacts . client . ui ; import java . util . Comparator ; import java . util . List ; import com . google . gwt . core . client . GWT ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . user . cellview . client . CellTable ; import com . google . gwt . user . cellview . client . CellTable . Resources ; import com . google . gwt . user . cellview . client . ColumnSortEvent . ListHandler ; import com . google . gwt . user . cellview . client . HasKeyboardSelectionPolicy . KeyboardSelectionPolicy ; import com . google . gwt . user . cellview . client . TextColumn ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . IsWidget ; import com . google . gwt . user . client . ui . Widget ; import com . google . gwt . view . client . ListDataProvider ; import com . google . gwt . view . client . SelectionChangeEvent ; import com . google . gwt . view . client . SingleSelectionModel ; import com . toedter . gwt . demo . contacts . shared . Contact ; public class ContactListView2 extends Composite implements IContactListView { private static ContactListView2UiBinder uiBinder = GWT . create ( ContactListView2UiBinder . class ) ; @ UiField ( provided = true ) CellTable < Contact > cellTable = new CellTable < Contact > ( 1000 , ( Resources ) GWT . create ( TableResources . class ) ) ; private List < Contact > list ; private Presenter presenter ; interface ContactListView2UiBinder extends UiBinder < Widget , ContactListView2 > { } public ContactListView2 ( ) { initWidget ( uiBinder . createAndBindUi ( this ) ) ; cellTable . setKeyboardSelectionPolicy ( KeyboardSelectionPolicy . ENABLED ) ; TextColumn < Contact > firstNameColumn = new TextColumn < Contact > ( ) { @ Override public String getValue ( Contact contact ) { return contact . getFirstName ( ) ; } } ; firstNameColumn . setSortable ( true ) ; TextColumn < Contact > lastNameColumn = new TextColumn < Contact > ( ) { @ Override public String getValue ( Contact contact ) { return contact . getLastName ( ) ; } } ; lastNameColumn . setSortable ( true ) ; cellTable . addColumn ( firstNameColumn , \"First Name\" ) ; cellTable . addColumn ( lastNameColumn , \"Last Name\" ) ; ListDataProvider < Contact > dataProvider = new ListDataProvider < Contact > ( ) ; dataProvider . addDataDisplay ( cellTable ) ; list = dataProvider . getList ( ) ; ListHandler < Contact > columnSortHandler = new ListHandler < Contact > ( list ) ; columnSortHandler . setComparator ( firstNameColumn , new Comparator < Contact > ( ) { @ Override public int compare ( Contact o1 , Contact o2 ) { if ( o1 == o2 ) { return 0 ; } if ( o1 != null ) { return ( o2 != null ) ? o1 . getFirstName ( ) . compareTo ( o2 . getFirstName ( ) ) : 1 ; } return - 1 ; } } ) ; columnSortHandler . setComparator ( lastNameColumn , new Comparator < Contact > ( ) { @ Override public int compare ( Contact o1 , Contact o2 ) { if ( o1 == o2 ) { return 0 ; } if ( o1 != null ) { return ( o2 != null ) ? o1 . getLastName ( ) . compareTo ( o2 . getLastName ( ) ) : 1 ; } return - 1 ; } } ) ; cellTable . addColumnSortHandler ( columnSortHandler ) ; final SingleSelectionModel < Contact > selectionModel = new SingleSelectionModel < Contact > ( ) ; cellTable . setSelectionModel ( selectionModel ) ; selectionModel . addSelectionChangeHandler ( new SelectionChangeEvent . Handler ( ) { @ Override public void onSelectionChange ( SelectionChangeEvent event ) { Contact selectedContact = selectionModel", "gt": ". getSelectedObject ( ) ;", "prediction": ". getSelectedContact ( ) ;\n", "label": 0}
{"id": 13115, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . widgets . Item ; public interface ICellToolTipProvider { String ENABLE_CELL_TOOLTIP = ICellToolTipProvider . class", "gt": ". getName ( ) + \"#enableCellToolTip\" ;", "prediction": ";\n", "label": 1}
{"id": 6681, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . RGB ; public class RGBImpl extends MinimalEObjectImpl . Container implements RGB { protected static final String VALUE_EDEFAULT = null ; protected String value = VALUE_EDEFAULT ; protected RGBImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getRGB ( ) ; } public String getValue ( ) { return value ; } public void setValue ( String newValue ) { String oldValue = value ; value = newValue ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . RGB__VALUE , oldValue , value ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . RGB__VALUE : return getValue ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . RGB__VALUE : setValue ( ( String ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . RGB__VALUE : setValue ( VALUE_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . RGB__VALUE : return VALUE_EDEFAULT == null ? value != null : ! VALUE_EDEFAULT . equals ( value ) ; } return super . eIsSet ( featureID ) ; } @", "gt": "Override public String toString ( )", "prediction": "Override public boolean eIsNotSet ( int featureID )\n", "label": 0}
{"id": 13117, "input": "<s> package org . seage . grammar . iif ; import org . seage . grammar . Grammar ; import org . seage . grammar . NonterminalSymbol ; import java . util . Vector ; public class IifGrammar extends Grammar { public IifGrammar ( Vector < String > varNames ) { super ( new NonterminalSymbol ( \"STATEMENT\" ) ) ; addRule ( new StatementGrammarRule ( 1 ) , - 1 ) ; addRule ( new LValueGrammarRule ( 2 ) , - 1 ) ; addRule ( new TernaryGrammarRule ( 3 ) , - 1 ) ; addRule ( new TernaryDummyGrammarRule ( 4 ) , - 1 ) ; addRule ( new CondLessGrammarRule ( 5 ) , - 1 ) ; addRule ( new CondGreaterGrammarRule ( 6 ) , - 1 ) ; addRule ( new CondEqualGrammarRule ( 7 ) , - 1 ) ; addRule ( new CondNotEqualGrammarRule ( 8 ) , - 1 ) ; addRule ( new CondGreaterEqualGrammarRule ( 9 ) , - 1 ) ; addRule ( new CondLessEqualGrammarRule (", "gt": "10 ) , - 1 ) ;", "prediction": "10 ) , - 1 ) ;\n", "label": 1}
{"id": 7663, "input": "<s> package hudson . plugins . dimensionsscm ; import hudson . Util ; import hudson . FilePath ; import hudson . FilePath . FileCallable ; import hudson . model . Node ; import hudson . model . Computer ; import hudson . model . Hudson . MasterComputer ; import hudson . remoting . Callable ; import hudson . remoting . DelegatingCallable ; import hudson . remoting . Channel ; import hudson . remoting . VirtualChannel ; import hudson . model . TaskListener ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . TreeSet ; import java . util . Vector ; import java . util . regex . * ; public class FileScanner implements Serializable { private File [ ] arr = null ; private Collection < File > xfiles = null ; private File baseDir = null ; private ScannerFilter filter = null ; public class ScannerFilter implements FilenameFilter { private TreeSet < String > artifactFilter = new TreeSet < String > ( ) ; public ScannerFilter ( String [ ] extensions ) { Iterator < String > artifactList = Arrays . asList ( extensions ) . iterator ( ) ; while ( artifactList . hasNext ( ) ) { artifactFilter . add ( artifactList . next ( ) . trim ( ) ) ; } artifactFilter . remove ( \"\" ) ; } public boolean accept ( File dir , String name ) { final Iterator < String > artifactList = artifactFilter . iterator ( ) ; if ( name . equals ( \".metadata\" ) || name . equals ( \".dm\" ) ) { return false ; } while ( artifactList . hasNext ( ) ) { String filter = artifactList . next ( ) ; if ( Pattern . matches ( filter , name ) ) { return true ; } } return false ; } } public FileScanner ( File dirName , String [ ] patterns , int depth ) { baseDir = dirName ; filter = new ScannerFilter ( patterns ) ; xfiles = scanFiles ( dirName , filter , depth ) ; } public Collection < File > getFiles ( ) { return xfiles ; } public File [ ] toArray ( ) { arr = new", "gt": "File [ xfiles . size ( ) ] ;", "prediction": "ArrayList < File > ( ) ;\n", "label": 0}
{"id": 13121, "input": "<s> package it . unina . jdbc . access ; import java . net . URL ; import java . sql . * ; public class AccessDemo { static Connection theConn ; public static void main ( String args [ ] ) { try { theConn = MyConnection . getConnection ( ) ; ResultSet rs ; Statement stmt ; String sql ; sql = \"select objet from Email\" ; stmt = theConn . createStatement ( ) ; rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { System . out . println ( rs . getString ( \"objet\" ) ) ; } rs . close ( ) ; stmt . close ( ) ; } catch ( Exception e ) { e", "gt": ". printStackTrace ( ) ;", "prediction": ". printStackTrace ( ) ;\n", "label": 1}
{"id": 6053, "input": "<s> package org . ofbiz . common ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import static org . ofbiz . base . util . UtilGenerics . checkList ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; import org . apache . commons . net . ftp . FTP ; import org . apache . commons . net . ftp . FTPClient ; import org . apache . commons . net . ftp . FTPReply ; public class FtpServices { public final static String module = FtpServices . class . getName ( ) ; public static final String resource = \"CommonUiLabels\" ; public static Map < String , Object > putFile ( DispatchContext dctx , Map < String , ? > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; Debug . logInfo ( \"[putFile] starting...\" , module ) ; InputStream localFile = null ; try { localFile = new FileInputStream ( ( String ) context . get ( \"localFilename\" ) ) ; } catch ( IOException ioe ) { Debug . logError ( ioe , \"[putFile] Problem opening local file\" , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"CommonFtpFileCannotBeOpen\" , locale ) ) ; } List < String > errorList = FastList . newInstance ( ) ; FTPClient ftp = new FTPClient ( ) ; try { Debug . logInfo ( \"[putFile] connecting to: \" + ( String ) context . get ( \"hostname\" ) , module ) ; ftp . connect ( ( String ) context . get ( \"hostname\" ) ) ; if ( ! FTPReply . isPositiveCompletion ( ftp . getReplyCode ( ) ) ) { Debug . logInfo ( \"[putFile] Server refused connection\" , module ) ; errorList . add ( UtilProperties", "gt": ". getMessage ( resource , \"CommonFtpConnectionRefused\" , locale ) ) ;", "prediction": ". getMessage ( resource , \"CommonFtpFileCannotBeOpen\" , locale ) ) ;\n", "label": 0}
{"id": 13123, "input": "<s> package sk . m217 . actionbarcompatsample ; import sk . m217 . actionbarcompat . ActionBarActivity ; import sk . m217 . actionbarcompat . ActionBarCompat ; import sk . m217 . actionbarcompat . MenuItemCompat ; import android . os . Bundle ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . widget . EditText ; import android . widget . Toast ; public class ActionBarCompatSampleActivity extends ActionBarActivity { private Menu mMenu ; @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . main ) ; getActionBarHelper ( ) . initActionBar ( ) ; ActionBarCompat . setDisplayShowHomeEnabled ( this , true ) ; ActionBarCompat . setDisplayHomeAsUpEnabled ( this , false ) ; ActionBarCompat . setHomeButtonEnabled ( this , true ) ; ActionBarCompat . setBackgroundDrawable ( this , getResources ( ) . getDrawable ( R . drawable . actionbar_compat_background ) ) ; ActionBarCompat . setIcon ( this , getResources ( ) . getDrawable ( R . drawable . ic_launcher ) ) ; } @ Override protected void onPostCreate ( Bundle savedInstanceState ) { super . onPostCreate ( savedInstanceState ) ; ActionBarCompat . setDisplayShowTitleEnabled ( this , true ) ; ActionBarCompat . setTitle ( this , R . string . actionbar_custom_title ) ; } @ Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater menuInflater = getMenuInflater ( ) ; menuInflater . inflate ( R . menu . options , menu ) ; if ( mMenu != null ) { return super . onCreateOptionsMenu ( menu ) ; } mMenu = menu ; MenuItem item = mMenu . findItem ( R . id . menu_search ) ; if ( item != null ) { MenuItemCompat . setOnActionExpandListener ( item , new MenuItemCompat . OnActionExpandListenerCompat ( ) { @ Override public boolean onMenuItemActionExpand ( MenuItem item ) { Toast . makeText ( ActionBarCompatSampleActivity . this , \"onMenuItemActionExpand()\" , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } @ Override public boolean onMenuItemActionCollapse ( MenuItem item ) { Toast . makeText ( ActionBarCompatSampleActivity . this , \"onMenuItemActionCollapse()\" , Toast . LENGTH_SHORT ) . show ( ) ; return true ; } } ) ; } EditText editText = ( EditText ) MenuItemCompat . getActionView ( item ) ; if ( editText != null ) { editText . setText ( R . string . menu_search ) ; } item . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener ( ) { @ Override public boolean onMenuItemClick ( MenuItem item ) { Toast . makeText ( ActionBarCompatSampleActivity . this , \"onMenuItemClick()\" , Toast . LENGTH_LONG ) . show ( ) ; return false ; } } ) ; item . setIcon ( R . drawable . ic_action_search ) . setTitle ( R . string . menu_search ) . setIntent ( null ) . setVisible ( true ) . setEnabled ( true ) ; return super . onCreateOptionsMenu ( menu ) ; } @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : Toast . makeText ( this , \"Tapped home\" , Toast . LENGTH_SHORT ) . show ( ) ; break ; case R . id . menu_refresh : Toast . makeText ( this , \"Fake refreshing...\" , Toast . LENGTH_SHORT ) . show ( ) ; getActionBarHelper ( ) . setRefreshActionItemState ( true ) ; getWindow ( ) . getDecorView ( ) . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { getActionBarHelper ( ) . setRefreshActionItemState ( false ) ; } } , 1000 ) ; break ; case R . id . menu_search : Toast . makeText ( this , \"Tapped search\" ,", "gt": "Toast . LENGTH_SHORT ) . show ( ) ;", "prediction": "Toast . LENGTH_SHORT ) . show ( ) ;\n", "label": 1}
{"id": 7257, "input": "<s> package org . gk . engine . client . build . form . field ; import java . util . Iterator ; import java . util . List ; import org . gk . engine . client . build . field . XField ; import org . gk . engine . client . build . form . XFormField ; import org . gk . ui . client . com . panel . gkFormPanelIC ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . HorizontalPanel ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com . extjs . gxt . ui . client . widget . VerticalPanel ; import com . extjs . gxt . ui . client . widget . button . Button ; import com . extjs . gxt . ui . client . widget . form . AdapterField ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . form . Radio ; import com . google . gwt . user . client . ui . Widget ; public class AdaptFieldBuilder extends FormFieldBuilder { public AdaptFieldBuilder ( String fieldType ) { super ( fieldType ) ; } @ Override public Component create ( ) { return createField ( null ) ; } @ Override public Component create ( gkFormPanelIC form ) { return createField ( form ) ; } private Field createField ( gkFormPanelIC form ) { XField xf = getField ( ) . clone ( ) ; String vertical = xf . getAttribute ( \"vertical\" , \"false\" ) ; String space = xf . getAttribute ( \"space\" , \"0\" ) ; String adaptingrid = xf . getAttribute ( \"adaptingrid\" , \"false\" ) ; LayoutContainer lc ; String ver = \"\" ; List childs = xf . getWidgets ( ) ; if ( Boolean . parseBoolean ( vertical ) ) { lc = new VerticalPanel ( ) ; ( ( VerticalPanel ) lc ) . setTableWidth ( \"100%\" ) ; ver = \"bottom\" ; } else { lc = new HorizontalPanel ( ) ; if ( childs . size ( ) == 1 ) { ( ( HorizontalPanel ) lc", "gt": ") . setTableWidth ( \"100%\" ) ;", "prediction": ") . setTableWidth ( \"100%\" ) ;\n", "label": 0}
{"id": 13142, "input": "<s> package br . org . archimedes . io . svg . elements ; import java . io . IOException ; import java . io . OutputStream ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . exceptions . NotSupportedException ; import br . org . archimedes . interfaces . ElementExporter ; import br . org . archimedes . model . Rectangle ; public class CircleExporter implements ElementExporter < Circle > { public void exportElement ( Circle circle , Object outputObject ) throws IOException { OutputStream output = ( OutputStream ) outputObject ; StringBuilder lineTag = new StringBuilder ( ) ; int x = ( int ) circle . getCenter ( ) . getX ( ) ; int y = ( int ) circle . getCenter ( ) . getY ( ) ; int r = ( int ) circle . getRadius ( ) ; lineTag . append ( \"<circle fill=\\\"none\\\" cx=\\\"\" + x + \"\\\" cy=\\\"\" + - y + \"\\\" r=\\\"\" + r + \"\\\"/>\\n\" ) ; output . write ( lineTag . toString ( ) . getBytes ( ) ) ; } public void exportElement (", "gt": "Circle element , Object outputObject , Rectangle boundingBox ) throws NotSupportedException", "prediction": "Circle circle , Object outputObject ) throws IOException\n", "label": 1}
{"id": 4105, "input": "<s> package ar . com . fdvs . dj . domain . constants ; import net . sf . jasperreports . engine . design . JRDesignImage ; public class ImageScaleMode extends BaseDomainConstant { private static final long serialVersionUID = 1L ; private byte value = JRDesignImage . SCALE_IMAGE_RETAIN_SHAPE ; public static ImageScaleMode NO_RESIZE = new ImageScaleMode ( JRDesignImage . SCALE_IMAGE_CLIP ) ; public static ImageScaleMode FILL = new ImageScaleMode (", "gt": "JRDesignImage . SCALE_IMAGE_FILL_FRAME ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13144, "input": "<s> package org . fuzzydb . server . internal . pager ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FilenameFilter ; import java . io . IOException ; import java . util . Arrays ; import java . util . BitSet ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . io . core . ArchInStream ; import org . fuzzydb . io . core . ArchOutStream ; import org . fuzzydb . server . internal . server . CurrentTransactionHolder ; import org . fuzzydb . server . internal . server . DatabaseVersionState ; import org . fuzzydb . server . internal . server . ServerStore ; import org . fuzzydb . server . internal . server . TransactionControl ; import org . fuzzydb . server . internal . server . WorkerThread ; import org . fuzzydb . util . MeteredOutputStream ; import org . slf4j . Logger ; public class Page < T > implements FilenameFilter { @ SuppressWarnings ( \"unused\" ) static private final Logger log = LogFactory . getLogger ( Page . class ) ; @ SuppressWarnings ( \"serial\" ) public static class PagePurgedException extends Exception { } static private final byte eightZeros [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; private final String path ; private final String filterString ; private byte [ ] pageData = null ; private final Element < T > [ ] elements ; private final ExclusiveWrite exclusiveWrite ; private boolean purged = false ; private final long offset ; private final int length ; private long latestDbVersion = - 1L ; private boolean dirty = false ; private final AccessHistory accessedForRead = new AccessHistory ( ) ; private final AccessHistory accessedForWrite = new AccessHistory ( ) ; private final ServerStore store ; private final long loadedTime = System . currentTimeMillis ( ) ; private static final long timeBias = 2000 ; static private final char VERSION_SEPARATOR = '_' ; private BitSet modifiedFlags ; private boolean disableDelete ; private DatabaseVersionState vp ; public static < P > Page < P > blankPage ( int length , String path , PagerContext context , DatabaseVersionState vp , long offset ) { return new Page < P > ( length , path , context , vp , offset ) ; } @ SuppressWarnings ( \"unchecked\" ) private Page ( int length , String path , PagerContext context , DatabaseVersionState vp , long offset ) { this . length = length ; this . path = path ; this . vp = vp ; this . elements = new Element [ length ] ; exclusiveWrite = new ExclusiveWrite ( ) ; this . offset = offset ; this . filterString = path . substring ( path . lastIndexOf ( File . separatorChar ) + 1 ) + VERSION_SEPARATOR ; this . store = context . getStore ( ) ; this . modifiedFlags = new BitSet ( length ) ; this . disableDelete = path . contains ( \"@\" ) && ! path . contains ( \"@Leaves\" ) ; } public float getCostBias ( ) { long elapsedTime = System . currentTimeMillis ( ) - loadedTime ; if ( elapsedTime > timeBias ) return 0 ; return 1.0f - ( ( float ) elapsedTime / ( float ) timeBias ) ; } private long getVersionFromFilename ( String filename ) { String version = filename . substring ( filename . lastIndexOf ( '_' ) + 1 ) ; return Long . parseLong ( version ) ; } public boolean load ( ) { assert ( pageData == null ) ; WorkerThread . beginIO ( ) ; try { File dir = getParentDir ( ) ; File files [ ] = dir . listFiles ( this ) ; if ( files == null || files . length == 0 ) { return false ; } File bestFile = files [ 0 ] ; long bestVersion = getVersionFromFilename ( files [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < files . length ; i ++ ) { long version = getVersionFromFilename ( files [ i ] . getName ( ) ) ; if ( version > bestVersion ) { bestVersion = version ; bestFile = files [ i ] ; } } if ( bestVersion > vp . getCurrentDbVersion ( ) ) { if ( bestVersion >", "gt": "vp . getCurrentDbVersion ( ) + 1 )", "prediction": "vp . getCurrentDbVersion ( ) )\n", "label": 1}
{"id": 4472, "input": "<s> package next . interfaces . controller ; import next . i . controller . XController ; import next . i . view . XBarItem . Type ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; import com . google . gwt . user . client . ui . IsWidget ; public abstract class GitXController extends XController { public GitXController ( ) { getNavigationBar ( ) . setLeftTitle ( \"Back\" , Type . BACK_BUTTON ) ; getNavigationBar ( ) . getLeftButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { getNavigationController ( ) . popController ( true ) ; } } ) ; getNavigationBar ( ) . setRightTitle ( \"Source\" ) ; getNavigationBar ( ) . getRightButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { DemoUtils . openGit ( getGitPath ( ) ) ; } } ) ; } @ Override public Scroll getScrollOrientation ( ) { return XController . Scroll . VERTICAL ; }", "gt": "public abstract IsWidget getViewContent ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13147, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . ui . IWorkbenchPart ; public class PartPluginAction extends PluginAction { public PartPluginAction ( IConfigurationElement actionElement , String id , int style ) { super ( actionElement , id , style ) ; } protected void registerSelectionListener ( IWorkbenchPart aPart ) { ISelectionProvider selectionProvider = aPart . getSite ( ) . getSelectionProvider ( ) ; if ( selectionProvider != null ) { selectionProvider . addSelectionChangedListener ( this ) ; selectionChanged ( selectionProvider .", "gt": "getSelection ( ) ) ;", "prediction": "getSelection ( ) ) ;\n", "label": 1}
{"id": 7185, "input": "<s> package org . ofbiz . service . calendar ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Arrays ; import com . ibm . icu . util . Calendar ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastSet ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; public class ExpressionUiHelper { public static final int Occurrence [ ] = { 1 , 2 , 3 , 4 , 5 , - 1 , - 2 , - 3 , - 4 - 5 } ; public static List < ? > getOccurrenceList ( ) { return Arrays . asList ( Occurrence ) ; } public static List < Map < String , Object > > getDayValueList ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . DAY_OF_WEEK , tempCal . getFirstDayOfWeek ( ) ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( \"EEEE\" , locale ) ; List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) { result . add ( UtilMisc . toMap ( \"description\" , ( Object ) dateFormat . format ( tempCal . getTime ( ) ) , \"value\" , tempCal . get ( Calendar . DAY_OF_WEEK ) ) ) ; tempCal . roll ( Calendar . DAY_OF_WEEK , 1 ) ; } return result ; } public static int getFirstDayOfWeek ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; return tempCal . getFirstDayOfWeek ( ) ; } public static int getLastDayOfWeek ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . DAY_OF_WEEK , tempCal . getFirstDayOfWeek ( ) ) ; tempCal . roll ( Calendar . DAY_OF_WEEK , - 1 ) ; return tempCal . get ( Calendar . DAY_OF_WEEK ) ; } public static List < Map < String , Object > > getMonthValueList ( Locale locale ) { Calendar tempCal = Calendar . getInstance ( locale ) ; tempCal . set ( Calendar . MONTH , Calendar . JANUARY ) ; SimpleDateFormat dateFormat = new SimpleDateFormat ( \"MMMM\" , locale ) ; List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 13 ) ; for ( int i = Calendar . JANUARY ; i <= tempCal . getActualMaximum ( Calendar . MONTH ) ; i ++ ) { result . add ( UtilMisc . toMap ( \"description\" , ( Object ) dateFormat . format ( tempCal . getTime ( ) ) , \"value\" , i ) ) ; tempCal . roll ( Calendar . MONTH , 1 ) ; } return result ; } public static List < Map < String , Object > > getFrequencyValueList ( Map < String , Object > uiLabelMap ) { List < Map < String , Object > > result = new ArrayList < Map < String , Object > > ( 6 ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonSecond\" ) , \"value\" , Calendar . SECOND ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonMinute\" ) , \"value\" , Calendar . MINUTE ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonHour\" ) , \"value\" , Calendar . HOUR_OF_DAY ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonDay\" ) , \"value\" , Calendar . DAY_OF_MONTH ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonMonth\" ) , \"value\" , Calendar . MONTH ) ) ; result . add ( UtilMisc . toMap ( \"description\" , uiLabelMap . get ( \"CommonYear\" ) ,", "gt": "\"value\" , Calendar . YEAR ) ) ;", "prediction": "\"value\" , Calendar . YEAR ) ) ;\n", "label": 0}
{"id": 13154, "input": "<s> package org . eclipse . ui . presentations ; import org . eclipse . swt . graphics . Point ; public interface IPartMenu {", "gt": "public void showMenu ( Point location ) ;", "prediction": "}\n", "label": 1}
{"id": 2303, "input": "<s> package org . gk . ui . client . com . panel ; import java . util . Iterator ; import java . util . Map ; import org . gk . ui . client . com . form . gkMap ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . widget . HtmlContainer ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; public class gkHtmlContainer extends HtmlContainer { private Element elem ; private String html = \"\" ; private Map info = new gkMap ( ) ; public void setInfo ( Map info ) { this . info = info ; setHtml ( html ) ; } public String getHtml ( ) { return html ; } @ Override public void setHtml ( String html ) { if ( elem != null ) { String htm = scrubHTML ( scrubScriptTag ( injectInfo ( html ) ) ) ; elem . setInnerHTML ( htm ) ; renderAll ( ) ; } else { this . html = html ; } } public gkHtmlContainer ( ) { } public gkHtmlContainer ( Element elem ) { super ( elem ) ; } public gkHtmlContainer ( String html ) { this . html = html ; } @ Override protected void onRender ( Element target , int index ) { elem = DOM . createElement ( getTagName ( ) ) ; setElement ( elem , target , index ) ; String htm = scrubHTML ( scrubScriptTag ( injectInfo ( html ) ) ) ; elem . setInnerHTML ( htm ) ; renderAll ( ) ; if ( GXT . isFocusManagerEnabled ( ) && ! getFocusSupport ( ) . isIgnore ( ) ) { el ( ) . setTabIndex ( 0 ) ; el ( ) . setElementAttribute ( \"hideFocus\" , \"true\" ) ; sinkEvents ( Event . FOCUSEVENTS ) ; } } private String injectInfo ( String html ) { Iterator < String > it = info . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String key = it . next ( ) ; html = html . replaceAll ( \"\\\\$\\\\{\" + key + \"}\" , info . get ( key ) + \"\" ) ; } return html ; } protected native String scrubHTML ( String html ) ; protected native", "gt": "String scrubScriptTag ( String html ) ;", "prediction": "String getHtml ( )\n", "label": 0}
{"id": 13159, "input": "<s> package com . google . code . microlog4android . integration . tests . microlog ; import junit . framework . TestCase ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . LoggerFactory ; import com . google . code . microlog4android . appender . LogCatAppender ; import com . google . code . microlog4android . integration . tests . appender . JunitTestAppender ; import com . google . code . microlog4android . integration . tests . slf4j . Slf4jIntegrationTest ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; public class MicrologIntegrationTest extends TestCase { private JunitTestAppender testAppender ; public void setUp ( ) { testAppender = new JunitTestAppender ( ) ; } public void tearDown ( ) { DefaultLoggerRepository . INSTANCE . reset ( ) ; } private void setTestAppenders ( final Logger logger ) {", "gt": "logger . addAppender ( testAppender ) ;", "prediction": "this . logger = logger ;\n", "label": 1}
{"id": 4224, "input": "<s> package model ; import java . util . ArrayList ; import exceptions . CartException ; public class Cart extends ArrayList < Book > { private static final long serialVersionUID = - 5188451462474667464L ; String shopDate ; public Cart ( ) { super ( ) ; this . shopDate = null ; } public Cart ( String date ) { super ( ) ; this . setShopDate ( date ) ; } public void setShopDate ( String date ) { this . shopDate = date ; } public String getShopDate ( ) { return this . shopDate ; } public void addBookToCart ( Book book ) throws CartException { if ( contains ( book ) ) { throw new CartException ( \"Book is already in cart\\n\" ) ; } add ( book ) ; } public void removeBook ( Book book ) throws CartException { if ( ! contains ( book ) ) { throw", "gt": "new CartException ( \"Book isn't in cart\\n\" ) ;", "prediction": "new CartException ( \"Book is already removed from cart\\n\" ) ;\n", "label": 0}
{"id": 13160, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import java . util . Collection ; public abstract class Spans { public abstract boolean next ( ) throws IOException ; public abstract boolean skipTo ( int target ) throws IOException ; public abstract int doc ( ) ; public", "gt": "abstract int start ( ) ;", "prediction": "abstract Collection < Span > spans ( )\n", "label": 1}
{"id": 6815, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . TimesheetAttribute ; public class TimesheetAttributeImpl extends MinimalEObjectImpl . Container implements TimesheetAttribute { protected TimesheetAttributeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage", "gt": ". eINSTANCE . getTimesheetAttribute ( ) ;", "prediction": ". class . getName ( ) ;\n", "label": 0}
{"id": 13171, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class Write10 extends AbstractTransferCDB { public static final int OPERATION_CODE = 0x2A ; private boolean DPO ; private boolean FUA ; private boolean FUA_NV ; private int groupNumber ; public Write10 ( ) { this ( OPERATION_CODE ) ; } protected Write10 ( int operationCode ) { super ( operationCode ) ; } public Write10 ( int groupNumber , boolean dpo , boolean fua , boolean fua_nv , boolean linked , boolean normalACA , long logicalBlockAddress , long transferLength ) { this ( OPERATION_CODE , groupNumber , dpo , fua , fua_nv , linked , normalACA , logicalBlockAddress , transferLength ) ; } protected Write10 ( int operationCode , int groupNumber , boolean dpo , boolean fua , boolean fua_nv , boolean linked , boolean normalACA , long logicalBlockAddress , long transferLength ) { super ( operationCode , linked , normalACA , logicalBlockAddress , transferLength ) ; this . groupNumber = groupNumber ; this . DPO = dpo ; this . FUA = fua ; this . FUA_NV = fua_nv ; } public Write10 ( long logicalBlockAddress , long transferLength ) { this ( 0 , false , false , false , false , false , logicalBlockAddress , transferLength ) ; } protected void decodeByte1 ( int unsignedByte ) throws IllegalArgumentException { if ( ( ( unsignedByte > > > 5 ) & 0x07 ) != 0 ) { throw new IllegalArgumentException ( \"Write protection information is not supported\" ) ; } this . DPO = ( ( unsignedByte > > > 4 ) & 0x01 ) == 1 ; this . FUA = ( ( unsignedByte > > > 3 ) & 0x01 ) == 1 ; this . FUA_NV = ( ( unsignedByte > > > 1 ) & 0x01 ) == 1 ; } protected int encodeByte1 ( ) { int b = 0 ; if ( DPO ) { b |= 0x02 ; } if ( FUA ) { b |= 0x08 ; } if ( FUA_NV ) { b |= 0x10 ; } return b ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int operationCode = in . readUnsignedByte ( ) ; this . decodeByte1 ( in . readUnsignedByte ( ) ) ; long mss = in . readUnsignedShort ( ) ; long lss = in . readUnsignedShort ( ) ; setLogicalBlockAddress ( ( mss << 16 ) | lss ) ; this . groupNumber = in . readUnsignedByte ( ) & 0x1F ; setTransferLength ( in . readUnsignedShort ( ) ) ; super . setControl ( in . readUnsignedByte ( ) ) ; if ( operationCode != OPERATION_CODE ) { throw new IOException ( \"Invalid operation code: \" + Integer . toHexString ( operationCode ) ) ; } } public byte [ ] encode ( ) { ByteArrayOutputStream cdb = new ByteArrayOutputStream ( this . size ( ) ) ; DataOutputStream out = new DataOutputStream ( cdb ) ; try { out . writeByte ( OPERATION_CODE ) ; out . writeByte ( this . encodeByte1 ( ) ) ; out . writeInt ( ( int ) getLogicalBlockAddress ( ) ) ; out .", "gt": "writeByte ( this . groupNumber & 0x1F ) ;", "prediction": "writeInt ( ( int ) getTransferLength ( ) ) ;\n", "label": 1}
{"id": 5068, "input": "<s> public interface Element < E extends Element < E , P , V > , P extends PlainForm < E , P , V > , V extends VariableForm < E , P , V > > {", "gt": "State getState ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13176, "input": "<s> package com . emf4sw . owl . examples ; import java . io . IOException ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . ecore . resource . impl . ResourceSetImpl ; import com . emf4sw . owl . OWLClass ; import com . emf4sw . owl . Ontology ; import com . emf4sw . owl . resource . impl . OWLXMLResourceFactory ; public class ReadOwlFile { public static void main ( String [ ] args ) throws IOException { Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"owl\" , new OWLXMLResourceFactory ( ) ) ; ResourceSet resourceSet = new ResourceSetImpl ( ) ; Resource onto = resourceSet . createResource ( URI . createURI ( \"src/software.owl\" ) ) ; onto . load ( null ) ; Ontology ontology = ( Ontology ) onto . getContents ( ) . get ( 0 ) ; for ( OWLClass oClass", "gt": ": ontology . getClasses ( ) )", "prediction": ": ontology )\n", "label": 1}
{"id": 6590, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import java . io . * ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; public class ClassBuilder extends AbstractBuilder { public static final String ROOT = \"ClassDoc\" ; private ClassDoc classDoc ; private ClassWriter writer ; private boolean isInterface = false ; private boolean isEnum = false ; private Content contentTree ; private ClassBuilder ( Configuration configuration ) { super ( configuration ) ; } public static ClassBuilder getInstance ( Configuration configuration , ClassDoc classDoc , ClassWriter writer ) throws Exception { ClassBuilder builder = new ClassBuilder ( configuration ) ; builder . configuration = configuration ; builder . classDoc = classDoc ; builder . writer = writer ; if ( classDoc . isInterface ( ) ) { builder . isInterface = true ; } else if ( classDoc . isEnum ( ) ) { builder . isEnum = true ; Util . setEnumDocumentation ( configuration , classDoc ) ; } if ( containingPackagesSeen == null ) { containingPackagesSeen = new HashSet < String > ( ) ; } return builder ; } public void build ( ) throws IOException { build ( LayoutParser . getInstance ( configuration ) . parseXML ( ROOT ) , contentTree ) ; } public String getName ( ) { return ROOT ; } public void buildClassDoc ( XMLNode node , Content contentTree ) throws Exception { String key ; if ( isInterface ) { key = \"doclet.Interface\" ; } else if ( isEnum ) { key = \"doclet.Enum\" ; } else { key = \"doclet.Class\" ; } contentTree = writer . getHeader ( configuration . getText ( key ) + \" \" + classDoc . name ( ) ) ; Content classContentTree = writer . getClassContentHeader ( ) ; buildChildren ( node , classContentTree ) ; contentTree . addContent ( classContentTree ) ; writer . addFooter ( contentTree ) ; writer . printDocument ( contentTree ) ; writer . close ( ) ; copyDocFiles ( ) ; } public void buildClassTree ( XMLNode node , Content classContentTree ) { writer . addClassTree ( classContentTree ) ; } public void buildClassInfo ( XMLNode node , Content classContentTree ) { Content classInfoTree = writer . getClassInfoTreeHeader ( ) ; buildChildren ( node , classInfoTree ) ; classContentTree . addContent ( writer . getClassInfo ( classInfoTree ) ) ; } public void buildTypeParamInfo ( XMLNode node , Content classInfoTree ) { writer . addTypeParamInfo ( classInfoTree ) ; } public void buildSuperInterfacesInfo ( XMLNode node , Content classInfoTree ) { writer . addSuperInterfacesInfo ( classInfoTree ) ; } public void buildImplementedInterfacesInfo ( XMLNode node , Content classInfoTree ) { writer . addImplementedInterfacesInfo ( classInfoTree ) ; } public void buildSubClassInfo ( XMLNode node , Content classInfoTree ) { writer . addSubClassInfo ( classInfoTree ) ; } public void buildSubInterfacesInfo ( XMLNode node , Content classInfoTree ) { writer . addSubInterfacesInfo ( classInfoTree ) ; } public void buildInterfaceUsageInfo ( XMLNode node , Content classInfoTree ) { writer . addInterfaceUsageInfo ( classInfoTree ) ; } public void buildDeprecationInfo ( XMLNode node , Content classInfoTree ) { writer . addClassDeprecationInfo ( classInfoTree ) ; } public void buildNestedClassInfo ( XMLNode node , Content classInfoTree ) { writer . addNestedClassInfo ( classInfoTree ) ; } private void copyDocFiles ( ) { PackageDoc containingPackage = classDoc . containingPackage ( ) ; if ( ( configuration . packages == null || Arrays . binarySearch ( configuration . packages , containingPackage ) < 0 ) && ! containingPackagesSeen . contains ( containingPackage . name ( ) ) ) { Util . copyDocFiles ( configuration , Util . getPackageSourcePath ( configuration , classDoc . containingPackage ( ) ) + DirectoryManager . getDirectoryPath ( classDoc . containingPackage ( ) ) + File . separator , DocletConstants . DOC_FILES_DIR_NAME , true ) ; containingPackagesSeen . add ( containingPackage . name ( ) ) ; } } public void buildClassSignature ( XMLNode node , Content classInfoTree ) { StringBuffer modifiers = new StringBuffer ( classDoc . modifiers ( ) + \" \" ) ; if ( isEnum ) { modifiers . append ( \"enum \" ) ; int index ; if ( ( index = modifiers . indexOf ( \"abstract\" ) ) >= 0 ) { modifiers . delete ( index , index + ( new String ( \"abstract\" ) ) . length ( ) ) ; modifiers = new StringBuffer ( Util . replaceText ( modifiers . toString ( ) , \"  \" , \" \" ) ) ; } if ( ( index = modifiers . indexOf ( \"final\" ) ) >= 0 ) { modifiers . delete ( index , index + ( new String ( \"final\" ) ) . length ( ) ) ; modifiers = new StringBuffer ( Util . replaceText ( modifiers . toString ( ) , \"  \" , \" \" ) ) ; } } else if ( ! isInterface ) { modifiers . append ( \"class \" ) ; } writer . addClassSignature ( modifiers . toString ( ) , classInfoTree ) ; } public void buildClassDescription ( XMLNode node , Content classInfoTree ) { writer . addClassDescription ( classInfoTree ) ; }", "gt": "public void buildClassTagInfo ( XMLNode node , Content classInfoTree )", "prediction": "}\n", "label": 0}
{"id": 13181, "input": "<s> package org . restlet . ext . jaxrs . internal . core ; import java . net . URI ; import java . net . URISyntaxException ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . ws . rs . MatrixParam ; import javax . ws . rs . PathParam ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . Cookie ; import javax . ws . rs . core . EntityTag ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . core . PathSegment ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . Response . ResponseBuilder ; import javax . ws . rs . core . SecurityContext ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriInfo ; import javax . ws . rs . core . Variant ; import org . restlet . Application ; import org . restlet . Request ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . CharacterSet ; import org . restlet . data . Dimension ; import org . restlet . data . Form ; import org . restlet . data . Language ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . data . Tag ; import org . restlet . ext . jaxrs . ExtendedUriBuilder ; import org . restlet . ext . jaxrs . internal . todo . NotYetImplementedException ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . EmptyIterator ; import org . restlet . ext . jaxrs . internal . util . SecurityUtil ; import org . restlet . ext . jaxrs . internal . util . SortedMetadata ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . representation . Representation ; import org . restlet . security . Role ; public class CallContext implements javax . ws . rs . core . Request , HttpHeaders , SecurityContext { private static class MatrixParamEncIter implements Iterator < String > { private Iterator < Map . Entry < String , List < String > > > matrixParamIter ; private final String mpName ; private Iterator < String > mpValueIter ; private String nextMpValue ; private final Iterator < PathSegment > pathSegmentIter ; MatrixParamEncIter ( String mpName , List < PathSegment > pathSegmentsEnc ) { this . pathSegmentIter = pathSegmentsEnc . iterator ( ) ; this . mpName = mpName ; } public boolean hasNext ( ) { if ( this . nextMpValue != null ) { return true ; } while ( ( this . mpValueIter != null ) && ( this . mpValueIter . hasNext ( ) ) ) { this . nextMpValue = this . mpValueIter . next ( ) ; return true ; } while ( ( this . matrixParamIter != null ) && ( matrixParamIter . hasNext ( ) ) ) { final Map . Entry < String , List < String > > entry = matrixParamIter . next ( ) ; if ( entry . getKey ( ) . equals ( this . mpName ) ) { this . mpValueIter = entry . getValue ( ) . iterator ( ) ; return hasNext ( ) ; } } while ( this . pathSegmentIter . hasNext ( ) ) { this . matrixParamIter = this . pathSegmentIter . next ( ) . getMatrixParameters ( ) . entrySet ( ) . iterator ( ) ; return hasNext ( ) ; } return false ; } public String next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } final String nextMpValue = this . nextMpValue ; this . nextMpValue = null ; return nextMpValue ; } public void remove ( ) { throw new UnsupportedOperationException ( \"unmodifiable\" ) ; } } private static final int STATUS_PREC_FAILED = Status . CLIENT_ERROR_PRECONDITION_FAILED . getCode ( ) ; private static final Logger unexpectedLogger = org . restlet . Context . getCurrentLogger ( ) ; private List < Locale > acceptedLanguages ; private List < MediaType > acceptedMediaTypes ; private final SortedMetadata < org . restlet . data . MediaType > accMediaTypes ; private String baseUri ; private Map < String , Cookie > cookies ; private Locale language ; private final LinkedList < Object > matchedResources = new LinkedList < Object > ( ) ; private final LinkedList < String > matchedURIs = new LinkedList < String > ( ) ; private MediaType mediaType ; private MultivaluedMap < String , String > pathParametersDecoded ; private MultivaluedMap < String , String > pathParametersEncoded ; private List < PathSegment > pathSegmentsDecoded = null ; private List < PathSegment > pathSegmentsEncoded = null ; private MultivaluedMap < String , String > queryParametersDecoded ; private MultivaluedMap <", "gt": "String , String > queryParametersEncoded ;", "prediction": "String , String > queryEncoded = null ;\n", "label": 1}
{"id": 3530, "input": "<s> package com . twofortyfouram . locale ; import android . content . pm . PackageManager ; import android . content . res . Resources ; import android . text . TextUtils ; import android . util . Log ; final class SharedResources { static final String STRING_PLUGIN_MESSAGE_PRIMARY = \"plugin_dialog_message\" ; static final String STRING_PLUGIN_INFORMATIVE_SETTING = \"plugin_dialog_informative_setting\" ; static final String STRING_PLUGIN_INFORMATIVE_CONDITION = \"plugin_dialog_informative_condition\" ; static final String STRING_PLUGIN_INFORMATIVE_CONDITION_AND_SETTING = \"plugin_dialog_informative_condition_and_setting\" ; static final String STRING_PLUGIN_OPEN = \"plugin_open\" ; static CharSequence getTextResource ( final PackageManager packageManager , final String callingPackageHint , final String resourceName ) { if ( null == packageManager ) { throw new IllegalArgumentException ( \"packageManager cannot be null\" ) ; } if ( TextUtils . isEmpty ( resourceName ) ) { throw new IllegalArgumentException", "gt": "( \"resourceName cannot be null or empty\" ) ;", "prediction": "( \"resourceName cannot be null\" ) ;\n", "label": 0}
{"id": 13188, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import java . util . Iterator ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . jface . action . AbstractGroupMarker ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . GroupMarker ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IContributionManager ; import org . eclipse . jface . action . ICoolBarManager ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . internal . provisional . action . IToolBarContributionItem ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IWorkbenchActionConstants ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . internal . registry . ActionSetRegistry ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . services . IDisposable ; public class PluginActionSetBuilder extends PluginActionBuilder { private PluginActionSet actionSet ; private IWorkbenchWindow window ; private ArrayList adjunctContributions = new ArrayList ( 0 ) ; public static class Binding implements IDisposable { PluginActionSetBuilder builder ; PluginActionSet set ; IWorkbenchWindow window ; IExtensionTracker tracker ; public void dispose ( ) { if ( tracker != null ) { tracker . unregisterObject ( set . getConfigElement ( ) . getDeclaringExtension ( ) , this ) ; tracker = null ; } } } public PluginActionSetBuilder ( ) { } public void buildMenuAndToolBarStructure ( PluginActionSet set , IWorkbenchWindow window ) { this . actionSet = set ; this . window = window ; cache = null ; currentContribution = null ; targetID = null ; targetContributionTag = IWorkbenchRegistryConstants . TAG_ACTION_SET ; readElements ( new IConfigurationElement [ ] { set . getConfigElement ( ) } ) ; if ( cache != null ) { for ( int i = 0 ; i < cache . size ( ) ; i ++ ) { ActionSetContribution contribution = ( ActionSetContribution ) cache . get ( i ) ; contribution . contribute ( actionSet . getBars ( ) , true , true ) ; if ( contribution . isAdjunctContributor ( ) ) { adjunctContributions . add ( contribution ) ; } } } for ( int i = 0 ; i < adjunctContributions . size ( ) ; i ++ ) { ActionSetContribution contribution = ( ActionSetContribution ) adjunctContributions . get ( i ) ; ActionSetActionBars bars = actionSet . getBars ( ) ; for ( int j = 0 ; j < contribution . adjunctActions . size ( ) ; j ++ ) { ActionDescriptor adjunctAction = ( ActionDescriptor ) contribution . adjunctActions . get ( j ) ; contribution . contributeAdjunctCoolbarAction ( adjunctAction , bars ) ; } } registerBinding ( set ) ; } protected ActionDescriptor createActionDescriptor ( IConfigurationElement element ) { boolean pullDownStyle = false ; String style = element . getAttribute ( IWorkbenchRegistryConstants . ATT_STYLE ) ; if ( style != null ) { pullDownStyle = style . equals ( ActionDescriptor . STYLE_PULLDOWN ) ; } else { String pulldown = element . getAttribute ( ActionDescriptor . STYLE_PULLDOWN ) ; pullDownStyle = pulldown != null && pulldown . equals ( \"true\" ) ; } ActionDescriptor desc = null ; if ( pullDownStyle ) { desc = new ActionDescriptor ( element , ActionDescriptor . T_WORKBENCH_PULLDOWN , window ) ; } else { desc = new ActionDescriptor ( element , ActionDescriptor . T_WORKBENCH , window ) ; } WWinPluginAction action = ( WWinPluginAction ) desc . getAction ( ) ; action . setActionSetId ( actionSet . getDesc ( ) . getId ( ) ) ; actionSet . addPluginAction ( action ) ; return desc ; } protected BasicContribution createContribution ( ) { return new ActionSetContribution ( actionSet . getDesc ( ) . getId ( ) , window ) ; } public static IContributionItem findInsertionPoint ( String startId , String sortId , IContributionManager mgr , boolean startVsEnd ) { IContributionItem [ ] items = mgr . getItems ( ) ; int insertIndex = 0 ; while ( insertIndex < items . length ) { if ( startId . equals ( items [ insertIndex ] . getId ( ) ) ) { break ; } ++ insertIndex ; } if ( insertIndex >= items . length ) { return null ; } int compareMetric = 0 ; if ( startVsEnd ) { compareMetric = 1 ; } for ( int nX = insertIndex + 1 ; nX < items . length ; nX ++ ) { IContributionItem item = items [ nX ] ; if ( item .", "gt": "isSeparator ( ) || item . isGroupMarker ( ) )", "prediction": "isAdjunctContributor ( ) )\n", "label": 1}
{"id": 1880, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import com . sun . tools . javac . file . * ; import com . sun . tools . javac . file . JavacFileManager ; import com . sun . tools . javac . util . * ; public class T6625520 { public static void main ( String [ ] args ) throws Exception { new T6625520 ( ) . run ( ) ; } void run ( ) throws Exception { Context c = new Context ( ) ; DiagnosticCollector < JavaFileObject > dc = new DiagnosticCollector < JavaFileObject > ( ) ; c . put ( DiagnosticListener . class , dc ) ; StandardJavaFileManager fm", "gt": "= new JavacFileManager ( c , false , null ) ;", "prediction": "= new StandardJavaFileManager ( ) ;\n", "label": 0}
{"id": 13189, "input": "<s> package org . eclipse . jface . internal . util ; import java . io . Serializable ; public", "gt": "interface SerializableRunnable extends Runnable , Serializable", "prediction": "class Serializable extends Serializable\n", "label": 1}
{"id": 8511, "input": "<s> package org . ofbiz . base . concurrent ; public final class GeneratedResult < T > { public final long lastModifiedTime ; public final T object ; public GeneratedResult ( long lastModifiedTime , T object ) { this", "gt": ". lastModifiedTime = lastModifiedTime ;", "prediction": ". object = object ;\n", "label": 0}
{"id": 13190, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; class PngIdatChunk extends PngChunk { static final int HEADER_BYTES_LENGTH = 2 ; static final int ADLER_FIELD_LENGTH = 4 ; static final int HEADER_BYTE1_DATA_OFFSET = DATA_OFFSET + 0 ; static final int HEADER_BYTE2_DATA_OFFSET = DATA_OFFSET + 1 ; static final int ADLER_DATA_OFFSET = DATA_OFFSET + 2 ; PngIdatChunk ( byte headerByte1 , byte headerByte2 , byte [ ] data , int adler ) { super ( data . length + HEADER_BYTES_LENGTH + ADLER_FIELD_LENGTH ) ; setType ( TYPE_IDAT ) ; reference [ HEADER_BYTE1_DATA_OFFSET ] = headerByte1 ; reference [ HEADER_BYTE2_DATA_OFFSET ] = headerByte2 ; System . arraycopy ( data , 0 , reference , DATA_OFFSET , data . length ) ; setInt32 ( ADLER_DATA_OFFSET , adler ) ; setCRC ( computeCRC ( ) ) ; } PngIdatChunk ( byte [ ] reference ) { super ( reference ) ; } int getChunkType ( ) { return CHUNK_IDAT ; } void validate ( PngFileReadState readState , PngIhdrChunk headerChunk ) { if ( ! readState . readIHDR || ( headerChunk . getMustHavePalette ( ) && ! readState . readPLTE ) || readState . readIEND ) { SWT . error ( SWT . ERROR_INVALID_IMAGE ) ; } else {", "gt": "readState . readIDAT = true ;", "prediction": "return ;\n", "label": 1}
{"id": 1680, "input": "<s> package org . msl . simple . gmfmap . diagram . properties ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . gmf . runtime . diagram . ui . properties . sections . AbstractModelerPropertySection ; import org . eclipse . gmf . runtime . notation . View ; import org . eclipse . jface . viewers . IFilter ; import org . eclipse . swt . layout . FormLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . views . properties . tabbed . TabbedPropertySheetPage ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; public abstract class AbstractExtendedPropertiesSection extends AbstractModelerPropertySection implements IFilter { protected Composite composite ; public void createControls ( Composite parent , TabbedPropertySheetPage aTabbedPropertySheetPage ) { super . createControls ( parent , aTabbedPropertySheetPage ) ; initializeControls ( parent ) ; } protected void initializeControls ( Composite parent ) { composite = getWidgetFactory ( ) .", "gt": "createFlatFormComposite ( parent ) ;", "prediction": "getAdapter ( Composite . class ) ;\n", "label": 0}
{"id": 13191, "input": "<s> package org . nuxeo . webengine . blogs . models ; import org . nuxeo . theme . models . AbstractModel ; public class BlogPostModel extends AbstractModel { private String title ; private String path ; private String description ; private String content ; private String author ; public BlogPostModel ( String title , String path ) { this . title = title ; this . path = path ; } public BlogPostModel ( String title , String path , String description , String content , String author ) { this ( title , path ) ; this . description = description ; this . content = content ; this . author = author ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this", "gt": ". title = title ;", "prediction": ". title = title ;\n", "label": 1}
{"id": 1537, "input": "<s> package objects ; import java . awt . Image ; import java . awt . Point ; import java . io . IOException ; import java . net . URL ; import javax . imageio . ImageIO ; import javax . swing . ImageIcon ; import javax . swing . JLabel ; import servercontact . Server ; public class AlbumCover extends JLabel { public static int TINY = 25 ; public static int SMALL = 100 ; public static int LARGE = 256 ; public AlbumCover ( String albumID , Point index , int size ) { super ( ) ; setTheBounds ( index , size ) ; setImage ( albumID , size ) ; setClick ( ) ; } private void setTheBounds ( Point point , int size ) { int spacerSpaceX = 10 * ( point . x + 1 ) ; int labelSpace = 15 * point . y ; int spacerSpaceY = ( 10 * point . y ) + labelSpace ; int x", "gt": "= spacerSpaceX + ( size * point . x ) ;", "prediction": "= spacerSpaceX ;\n", "label": 0}
{"id": 13195, "input": "<s> package org . fuzzydb . attrs . string ; import java . util . TreeSet ; import org . fuzzydb . attrs . internal . BranchConstraint ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; public class StringConstraint extends BranchConstraint { private static final long serialVersionUID = 1L ; private boolean delimited = false ; private char delimiter = ' ' ; private TreeSet < String > values = new TreeSet < String > ( ) ; public TreeSet < String > getValues ( ) { return values ; } @ Override public boolean consistent ( IAttribute attribute ) { if ( attribute == null ) { return isIncludesNotSpecified ( ) ; } return true ; } public StringConstraint ( int attrId , StringValue value ) { super ( attrId ) ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringMultiValue value ) { super ( attrId ) ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringValue value , char delimter ) { super ( attrId ) ; this . delimited = true ; this . delimiter = delimter ; expandNonNull ( value ) ; } public StringConstraint ( int attrId , StringMultiValue value , char delimter ) { super ( attrId ) ; this . delimited = true ; this . delimiter = delimter ; expandNonNull ( value ) ; } public StringConstraint ( StringConstraint clonee ) { super ( clonee ) ; delimited = clonee . delimited ; delimiter = clonee . delimiter ; values . addAll ( clonee . values ) ; } @ Override protected boolean expandNonNull ( IAttribute value ) { if ( ! delimited ) { return true ; } if ( value instanceof StringValue ) { return expand ( ( ( StringValue ) value ) . getValue ( ) ) ; } else { StringMultiValue val = ( StringMultiValue ) value ; boolean result = false ; for ( String str : val . getValue ( ) ) { if ( expand ( str ) == true ) { result = true ; } } return result ; } } private boolean expand ( String value ) { String start = value . split ( String . valueOf ( delimiter ) , 2 ) [ 0 ] ; if ( ! values . contains ( start ) ) { values . add ( start ) ; return true ; } return false ; } @ Override public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof StringConstraint ) ) { return false ; } StringConstraint val = ( StringConstraint ) rhs ; assert ( getAttrId ( ) == val . getAttrId ( ) && super . equals ( val ) ) ; return values . equals ( val . values ) ; } @ Override public String toString ( ) { if ( delimited ) { return \"{ \" + values + \" }\" ; } return \"StringConstraint\" ; } @ Override public StringConstraint clone ( ) { return new StringConstraint ( this ) ; } @ Override public boolean isExpandedByNonNull ( IAttribute value ) { if ( ! delimited ) { return true ; } if ( value instanceof StringValue ) { return canExpand ( ( ( StringValue ) value ) . getValue ( ) ) ; } else {", "gt": "StringMultiValue val = ( StringMultiValue ) value ;", "prediction": "StringMultiValue val = ( StringMultiValue ) value ;\n", "label": 1}
{"id": 647, "input": "<s> package com . sap . prd . mobile . ios . mios ; import static org . junit . Assert . * ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import junit . framework . Assert ; import org . apache . commons . io . IOUtils ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TemporaryFolder ; public class FileUtilsTest { @ Rule public TemporaryFolder tmpFolder = new TemporaryFolder ( ) ; @ Test public void testStraightForward ( ) throws Exception { Assert . assertEquals ( \"source/dir\" , FileUtils . getDelta ( new File ( \"/home/abc/def\" ) , new File ( \"/home/abc/def/source/dir\" ) ) ) ; } @ Test ( expected = IllegalStateException . class ) public void testNoCommonPath ( ) throws Exception { FileUtils . getDelta ( new File ( \"/home/abc\" ) , new File ( \"/home/def\" ) ) ; } @ Test public void testCreateSymbolicLink ( ) throws Exception { File source = prepareFile ( ) ; File target = tmpFolder . newFile ( \"target\" ) ; FileUtils . createSymbolicLink ( source , target ) ; Assert . assertTrue ( checkForSymbolicLink ( target ) ) ; } @ Test public void testIsSymbolicLinkForNullFile ( ) throws Exception { assertFalse ( FileUtils . isSymbolicLink ( null ) ) ; } @ Test public void testIsSymbolicLinkWithSymbolicLink ( ) throws Exception { File source = prepareFile ( ) ; File target = tmpFolder . newFile ( \"target\" ) ; FileUtils . createSymbolicLink ( source , target ) ; assertTrue ( FileUtils . isSymbolicLink ( target ) ) ; } @ Test public void testIsSymbolicLinkWithRealFile ( ) throws Exception { File file = prepareFile ( ) ; assertFalse ( FileUtils . isSymbolicLink ( file ) ) ; }", "gt": "private static boolean checkForSymbolicLink ( final File f ) throws IOException", "prediction": "}\n", "label": 0}
{"id": 13198, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentRef ; public class DocRefToDocModel implements TypeAdapter { public Object getAdaptedValue ( OperationContext ctx , Object objectToAdapt ) throws TypeAdaptException { DocumentRef ref = ( DocumentRef ) objectToAdapt ; try { return", "gt": "ctx . getCoreSession ( ) . getDocument ( ref ) ;", "prediction": "ref ;\n", "label": 1}
{"id": 2289, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; public abstract class CustomMatcher extends AbstractMatcher { protected CustomMatcher ( String label ) { super ( label ) ; } protected CustomMatcher ( Rule subRule , String label ) { super ( checkArgNotNull ( subRule , \"subRule\" ) , label ) ; } protected CustomMatcher ( Rule [ ] subRules , String label ) { super ( checkArgNotNull ( subRules , \"subRules\" ) , label ) ; } public abstract boolean isSingleCharMatcher ( ) ; public abstract boolean canMatchEmpty ( ) ; public abstract boolean isStarterChar ( char c ) ; public abstract char getStarterChar ( ) ; public < R > R accept ( MatcherVisitor < R > visitor ) { checkArgNotNull (", "gt": "visitor , \"visitor\" ) ;", "prediction": "visitor ) ;\n", "label": 0}
{"id": 13199, "input": "<s> package org . nuxeo . ecm . automation . core . operations . management ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . impl . blob . ByteArrayBlob ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . management . counters . CounterHistoryStack ; import org . nuxeo . runtime . management . counters . CounterManager ; @ Operation ( id = GetCounters . ID , category = Constants . CAT_SERVICES , label = \"Retrieve counters values\" , description = \"Retrieve data collected by one or more Counters\" ) public class GetCounters { public static final String ID = \"Counters.GET\" ; @ Context protected OperationContext ctx ; @ Param ( name = \"counterNames\" , required = true ) protected StringList counterNames ; @ OperationMethod public Blob run ( ) throws Exception { CounterManager cm = Framework . getLocalService ( CounterManager . class ) ; JSONObject collection = new JSONObject ( ) ; Principal principal = ctx . getPrincipal ( ) ; if ( principal instanceof NuxeoPrincipal ) {", "gt": "NuxeoPrincipal nuxeoUser = ( NuxeoPrincipal ) principal ;", "prediction": "collection . add ( principal ) ;\n", "label": 1}
{"id": 9634, "input": "<s> package pkg1 ; public class C { public C ( @ A ( \"p0\" ) boolean p0 ) { } public void m ( @ A ( \"p1\" ) int p1 , int p2 ,", "gt": "@ Deprecated @ A ( \"p3\" ) String p3 )", "prediction": "int p3 )\n", "label": 0}
{"id": 13211, "input": "<s> package org . restlet . ext . gwt ; import com . google . gwt . user . client . rpc . SerializationException ; import com . google . gwt . user . server . rpc . SerializationPolicy ; public class SimpleSerializationPolicy extends SerializationPolicy { private static final SimpleSerializationPolicy instance = new SimpleSerializationPolicy ( ) ; public static SerializationPolicy getInstance ( ) { return instance ; } @ Override public boolean shouldDeserializeFields ( Class < ? > clazz ) { return ( clazz != null ) ; } @ Override public boolean shouldSerializeFields ( Class < ? > clazz ) { return ( clazz != null ) ; } @ Override public void validateDeserialize ( Class < ? > clazz ) throws SerializationException { } @ Override public void validateSerialize (", "gt": "Class < ? > clazz ) throws SerializationException", "prediction": "Class < ? > clazz ) throws SerializationException\n", "label": 1}
{"id": 8500, "input": "<s> package org . jdesktop . swinghelper . tray ; import java . awt . AWTException ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Frame ; import java . awt . Graphics2D ; import java . awt . Image ; import java . awt . SystemTray ; import java . awt . TrayIcon ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . geom . Ellipse2D ; import java . awt . image . BufferedImage ; import javax . swing . JDialog ; import javax . swing . JMenu ; import javax . swing . JMenuItem ; import javax . swing . JPopupMenu ; import javax . swing . SwingUtilities ; import javax . swing . UIManager ; import javax . swing . event . PopupMenuEvent ; import javax . swing . event . PopupMenuListener ; public class JXTrayIcon extends TrayIcon { private JPopupMenu menu ; private static JDialog dialog ; static { dialog = new JDialog ( ( Frame ) null , \"TrayDialog\" ) ; dialog . setUndecorated ( true ) ; dialog . setAlwaysOnTop ( true ) ; } private static PopupMenuListener popupListener = new PopupMenuListener ( ) { public void popupMenuWillBecomeVisible ( final PopupMenuEvent e ) { } public void popupMenuWillBecomeInvisible ( final PopupMenuEvent e ) { dialog . setVisible ( false ) ; } public void popupMenuCanceled ( final PopupMenuEvent e ) { dialog . setVisible ( false ) ; } } ; public JXTrayIcon ( final Image image ) { super ( image ) ; addMouseListener ( new MouseAdapter ( ) { public void mousePressed ( final MouseEvent e ) { showJPopupMenu ( e ) ; } public void mouseReleased ( final MouseEvent e ) { showJPopupMenu ( e ) ; } } ) ; } private void showJPopupMenu ( final MouseEvent e ) { if ( e . isPopupTrigger ( ) && menu != null ) { Dimension size = menu . getPreferredSize ( ) ; dialog . setLocation ( e . getX ( ) , e . getY ( ) - size . height ) ; dialog . setVisible ( true ) ; menu . show ( dialog . getContentPane ( ) , 0 , 0 ) ; dialog . toFront ( ) ; } } public JPopupMenu getJPopupMenu ( ) { return menu ; } public void setJPopupMenu ( final JPopupMenu menu ) { if ( this . menu != null ) { this . menu . removePopupMenuListener ( popupListener ) ; } this . menu = menu ; menu . addPopupMenuListener ( popupListener ) ; } private static void createGui ( ) { JXTrayIcon tray = new JXTrayIcon ( createImage ( ) ) ; tray . setJPopupMenu ( createJPopupMenu ( ) ) ; try { SystemTray . getSystemTray ( ) . add ( tray ) ; } catch ( AWTException e ) { e . printStackTrace ( ) ; } } public static void main ( final String [ ] args ) throws Exception { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { createGui ( ) ; } } ) ; } static Image createImage ( ) { BufferedImage i = new BufferedImage ( 32 , 32 , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2 = ( Graphics2D ) i . getGraphics ( ) ; g2 . setColor ( Color . RED ) ; g2 . fill ( new Ellipse2D . Float ( 0 , 0 , i . getWidth ( ) , i . getHeight ( ) ) ) ; g2 . dispose ( ) ; return i ; } static JPopupMenu createJPopupMenu ( ) { final JPopupMenu m = new JPopupMenu ( ) ; m . add ( new JMenuItem ( \"Item 1\" ) ) ; m . add ( new JMenuItem ( \"Item 2\" ) ) ; JMenu submenu = new JMenu ( \"Submenu\" ) ; submenu . add ( new JMenuItem ( \"item 1\" ) ) ; submenu . add ( new JMenuItem ( \"item 2\" ) ) ; submenu . add ( new", "gt": "JMenuItem ( \"item 3\" ) ) ;", "prediction": "JMenuItem ( \"item 3\" ) ) ;\n", "label": 0}
{"id": 13213, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . ToolBarManager ; import org . eclipse . jface . commands . ActionHandler ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . IPreferencePage ; import org . eclipse . jface . preference . PreferenceContentProvider ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceLabelProvider ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . FocusAdapter ; import org . eclipse . swt . events . FocusEvent ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . Sash ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . ActiveShellExpression ; import org . eclipse . ui . IWorkbenchCommandConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . dialogs . FilteredTree ; import org . eclipse . ui . dialogs . PatternFilter ; import org . eclipse . ui . handlers . IHandlerActivation ; import org . eclipse . ui . handlers . IHandlerService ; import org . eclipse . ui . internal . IWorkbenchGraphicConstants ; import org . eclipse . ui . internal . WorkbenchImages ; import org . eclipse . ui . internal . WorkbenchMessages ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . model . IContributionService ; import org . eclipse . ui . preferences . IWorkbenchPreferenceContainer ; import org . eclipse . ui . preferences . IWorkingCopyManager ; import org . eclipse . ui . preferences . WorkingCopyManager ; import org . eclipse . ui . statushandlers . StatusManager ; import org . osgi . service . prefs . BackingStoreException ; public abstract class FilteredPreferenceDialog extends PreferenceDialog implements IWorkbenchPreferenceContainer { private static final int PAGE_MULTIPLIER = 9 ; private static final int INCREMENT = 10 ; protected class PreferenceFilteredTree extends FilteredTree { private ViewerFilter viewerFilter ; private String cachedTitle ; PreferenceFilteredTree ( Composite parent , int treeStyle , PatternFilter filter ) { super ( parent , treeStyle , filter , true ) ; } protected void addFilter ( ViewerFilter filter ) { viewerFilter = filter ; getViewer ( ) . addFilter ( filter ) ; setInitialText ( WorkbenchMessages . get ( ) . FilteredTree_FilterMessage ) ; if ( filterText != null ) { setFilterText ( WorkbenchMessages . get ( ) . FilteredTree_FilterMessage ) ; textChanged ( ) ; } cachedTitle = getShell ( ) . getText ( ) ; getShell ( ) . setText ( NLS . bind ( WorkbenchMessages . get ( ) . FilteredTree_FilteredDialogTitle , cachedTitle ) ) ; } protected void updateToolbar ( boolean visible ) { super . updateToolbar ( viewerFilter != null || visible ) ; } protected void clearText ( ) { setFilterText ( \"\" ) ; if ( ! locked && viewerFilter != null ) { getViewer ( ) . removeFilter ( viewerFilter ) ; viewerFilter = null ; getShell ( ) . setText ( cachedTitle ) ; } textChanged ( ) ; } } protected PreferenceFilteredTree filteredTree ; private Object pageData ; IWorkingCopyManager workingCopyManager ; private Collection updateJobs = new ArrayList ( ) ; PreferencePageHistory history ; private Sash sash ; private IHandlerActivation showViewHandler ; private boolean locked ; public FilteredPreferenceDialog ( Shell parentShell , PreferenceManager manager ) { super ( parentShell , manager ) ; history = new PreferencePageHistory ( this ) ; } protected IPreferenceNode findNodeMatching ( String nodeId ) { IPreferenceNode node = super . findNodeMatching ( nodeId ) ; if ( WorkbenchActivityHelper . filterItem ( node ) ) { return null ; } return node ; } protected TreeViewer createTreeViewer ( Composite parent ) { int styleBits = SWT . SINGLE ; TreeViewer tree ; if ( ! hasAtMostOnePage ( ) ) { filteredTree = new PreferenceFilteredTree ( parent , styleBits , new PreferencePatternFilter ( ) ) ; GridData gd = new GridData ( SWT . FILL , SWT . FILL , true , true ) ; gd . horizontalIndent = IDialogConstants . HORIZONTAL_MARGIN ; filteredTree . setBackground ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; tree = filteredTree . getViewer ( ) ; } else tree = new TreeViewer ( parent , styleBits ) ; setContentAndLabelProviders ( tree ) ; tree . setInput ( getPreferenceManager ( ) ) ; tree . addFilter ( new CapabilityFilter ( ) ) ; tree . addSelectionChangedListener ( new ISelectionChangedListener ( ) { public void selectionChanged ( SelectionChangedEvent event ) { handleTreeSelectionChanged ( event ) ; } } ) ; super", "gt": ". addListeners ( tree ) ;", "prediction": ". createTreeViewer ( tree ) ;\n", "label": 1}
{"id": 8631, "input": "<s> package org . ofbiz . service . rmi ; import java . util . Map ; import java . rmi . Remote ; import java . rmi . RemoteException ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . GenericResultWaiter ; import org . ofbiz . service . GenericServiceException ; public interface RemoteDispatcher extends Remote { public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , boolean persist ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public GenericResultWaiter runAsyncWait ( String serviceName , Map < String , ? extends Object > context , boolean persist )", "gt": "throws GenericServiceException , RemoteException ;", "prediction": "throws GenericServiceException , RemoteException ;\n", "label": 0}
{"id": 13214, "input": "<s> package br . org . archimedes . extend ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . extend . interfaces . Extender ; import br . org . archimedes . extend . rcp . ExtenderEPLoader ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import java . util . Collection ; public class ExtendManager implements br . org . archimedes . interfaces . ExtendManager { private static final Extender NULL_EXTENDER = new NullExtender ( ) ; private ExtenderEPLoader loader ; public ExtendManager ( ) { loader = new ExtenderEPLoader ( ) ; } public ExtendManager ( ExtenderEPLoader loader ) { this . loader = loader ; } public Element extend ( Element element , Collection <", "gt": "Element > references , Point click ) throws NullArgumentException", "prediction": "Point > points )\n", "label": 1}
{"id": 4915, "input": "<s> public enum SynthValues { red , blue , green ; SynthValues [ ] $VALUES = null ; public static void main ( String [ ] args ) { for ( SynthValues t : values ( ) ) { System .", "gt": "out . println ( t ) ;", "prediction": "out . println ( t ) ;\n", "label": 0}
{"id": 13219, "input": "<s> package org . eclipse . ui . internal . views . properties ; import org . eclipse . rap . rwt . RWT ; public class PropertiesMessages { private static final String BUNDLE_NAME = \"org.eclipse.ui.internal.views.properties.messages\" ; public String Categories_text ; public String Categories_toolTip ; public String CopyProperty_text ; public String Defaults_text ; public String Defaults_toolTip ; public String Filter_text ; public String Filter_toolTip ; public String PropertyViewer_property ; public String PropertyViewer_value ; public String PropertyViewer_misc ; public String CopyToClipboardProblemDialog_title ; public String CopyToClipboardProblemDialog_message ;", "gt": "public static PropertiesMessages get ( )", "prediction": "}\n", "label": 1}
{"id": 3518, "input": "<s> import pkg . SuperClass ; class ProtectedMemberAccess1a extends SuperClass { int i = pi ; int j = spi ; int x = pm ( ) ; int y = spm ( ) ; pC obj1 ; spC obj2 ; pI obj3 ; spI obj4 ; Object o1 = ( pC ) null ; Object o2 = ( spC ) null ; Object o3 = ( pI ) null ; Object o4 = ( spI ) null ; class C1 extends pC { } class C2 extends spC { } interface I1 extends pI { } interface I2 extends spI { } static { spi = 2 ; int y = spm ( ) ; pC obj1 ; spC obj2 ; pI obj3 ; spI obj4 ; Object o1 = ( pC ) null ; Object o2 = ( spC ) null ; Object o3 = ( pI ) null ; Object o4 = ( spI ) null ; class C2 extends spC { } } void m ( ) { pi = 1 ; spi = 2 ; int x = pm ( ) ; int y = spm ( ) ; pC obj1 ; spC obj2 ; pI obj3 ; spI obj4 ; Object o1 = ( pC ) null ; Object o2 = ( spC ) null ; Object o3 = ( pI ) null ; Object o4 = ( spI ) null ; class C1 extends pC { } class C2 extends spC { } } class Inner { int i = pi ; int j = spi ; int x = pm ( ) ; int y = spm ( ) ; pC obj1 ; spC obj2 ; pI obj3 ; spI obj4 ; Object o1 = ( pC ) null ; Object o2 = ( spC ) null ; Object o3 = ( pI ) null ; Object o4 = ( spI ) null ; class C1 extends pC { } class C2 extends spC { } void m ( ) { pi = 1 ; spi = 2 ; int x = pm ( ) ; int y = spm ( ) ; pC obj1 ; spC obj2 ; pI obj3 ; spI obj4 ; Object o1 = ( pC ) null ; Object o2 = ( spC ) null ; Object o3 = ( pI ) null ; Object o4 = ( spI ) null ; class C1 extends pC { } class C2 extends spC { } } } } class ProtectedMemberAccess2a extends pkg . SuperClass { ProtectedMemberAccess2a x = new ProtectedMemberAccess2a ( ) ; static ProtectedMemberAccess2a sx = new ProtectedMemberAccess2a ( ) ; int i = x . pi ; int j = x . spi ; int n = sx . pi ; int m = sx . spi ; static int sn = sx . pi ; static int sm = sx . spi ; int w = x . pm ( ) ; int y = x . spm ( ) ; int u = sx . pm ( ) ; int v = sx . spm ( ) ; ProtectedMemberAccess2a . pC obj1 ; ProtectedMemberAccess2a . spC obj2 ; ProtectedMemberAccess2a . pI obj3 ; ProtectedMemberAccess2a . spI obj4 ; Object o1 = ( ProtectedMemberAccess2a . pC ) null ; Object o2 = ( ProtectedMemberAccess2a . spC ) null ; Object o3 = ( ProtectedMemberAccess2a . pI ) null ; Object o4 = ( ProtectedMemberAccess2a . spI ) null ; class C1 extends ProtectedMemberAccess2a . pC { } class C2 extends ProtectedMemberAccess2a . spC { } interface I1 extends ProtectedMemberAccess2a . pI { } interface I2 extends ProtectedMemberAccess2a . spI { } static { ProtectedMemberAccess2a lx = new ProtectedMemberAccess2a ( ) ; sx . pi = 1 ; sx . spi = 2 ; lx . pi = 1 ; lx . spi = 2 ; int n = sx . pi ; int m = sx . spi ; int k = lx . pi ; int l = lx . spi ; int u = sx . pm ( ) ; int v = sx . spm ( ) ; int w = lx . pm ( ) ; int z = lx . spm ( ) ; ProtectedMemberAccess2a . pC obj1 ; ProtectedMemberAccess2a . spC obj2 ; ProtectedMemberAccess2a . pI obj3 ; ProtectedMemberAccess2a . spI obj4 ; Object o1 = ( ProtectedMemberAccess2a . pC ) null ; Object o2 = ( ProtectedMemberAccess2a . spC ) null ; Object o3 = ( ProtectedMemberAccess2a . pI ) null ; Object o4 = ( ProtectedMemberAccess2a . spI ) null ; class C2 extends ProtectedMemberAccess2a . spC { } } void m ( ) { ProtectedMemberAccess2a lx = new ProtectedMemberAccess2a ( ) ; x . pi = 1 ; x . spi = 2 ; sx . pi = 1 ; sx . spi = 2 ; lx . pi = 1 ; lx . spi = 2 ; int t = x . pm ( ) ; int y = x . spm ( ) ; int u = sx . pm ( ) ; int v = sx . spm ( ) ; int w = lx . pm ( ) ; int z = lx . spm ( ) ; int i = x . pi ; int j = x . spi ; int n = sx . pi ; int m = sx . spi ; int", "gt": "k = lx . pi ;", "prediction": "w = lx . pm ( ) ;\n", "label": 0}
{"id": 13220, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . IBaseLabelProvider ; import org . eclipse . jface . viewers . ITableLabelProvider ; import org . eclipse . swt . graphics . Image ; public class CheckboxTreeViewerMissingTest extends CheckboxTreeViewerTest { private static Image testImage ; public static Image getMissingImage ( ) { if ( testImage == null ) testImage = ImageDescriptor . createFromFile ( TestLabelProvider . class , \"images/missing.gif\" ) . createImage ( ) ; return testImage ; } public static class CheckboxMissingTableTestLabelProvider extends", "gt": "CheckboxTreeViewerTest . CheckboxTableTestLabelProvider implements ITableLabelProvider", "prediction": "CheckboxTreeViewerTest\n", "label": 1}
{"id": 6572, "input": "<s> package me . chester . minitruco . core ; public class Carta { public Carta ( char letra , int naipe ) { setLetra ( letra ) ; setNaipe ( naipe ) ; } public Carta ( String sCarta ) { this ( sCarta . charAt ( 0 ) , \"coepx\" . indexOf ( sCarta . charAt ( 1 ) ) ) ; } public static final int NAIPE_COPAS = 0 ; public static final int NAIPE_OUROS = 1 ; public static final int NAIPE_ESPADAS = 2 ; public static final int NAIPE_PAUS = 3 ; public static final int [ ] NAIPES = { NAIPE_COPAS , NAIPE_ESPADAS , NAIPE_OUROS , NAIPE_PAUS } ; public static final int NAIPE_NENHUM = 4 ; public static final char LETRA_NENHUMA = 'X' ; private static final String LETRAS_VALIDAS = \"A23456789JQK\" ; private boolean cartaEmJogo = true ; private char letra = LETRA_NENHUMA ; private int naipe = NAIPE_NENHUM ; private boolean fechada = false ; public void setLetra ( char letra ) { if ( LETRAS_VALIDAS . indexOf ( letra ) != - 1 || letra == LETRA_NENHUMA ) { this . letra = letra ; } } public char getLetra ( ) { return letra ; } public void setNaipe ( int naipe ) { if ( naipe == NAIPE_COPAS || naipe == NAIPE_OUROS || naipe == NAIPE_PAUS || naipe == NAIPE_ESPADAS || naipe == NAIPE_NENHUM ) { this . naipe = naipe ; } } public int getNaipe ( ) { return naipe ; } public int getValor ( ) { return LETRAS_VALIDAS . indexOf ( letra ) ; } public void setFechada ( boolean fechada ) { this . fechada = fechada ; } public boolean isFechada ( ) { return fechada ; } public boolean equals ( Object outroObjeto ) { if ( ( outroObjeto != null ) && ( outroObjeto instanceof Carta ) ) { Carta outraCarta = ( Carta ) outroObjeto ; return outraCarta . getNaipe ( ) == this . getNaipe ( ) && outraCarta . getLetra ( ) == this . getLetra ( ) ; } return false ; } public int hashCode ( ) { return getLetra (", "gt": ") * 256 + getNaipe ( ) ;", "prediction": ") . hashCode ( ) ;\n", "label": 0}
{"id": 13234, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . eclipse . xtext . xdoc . xdoc . MarkupInCode ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class MarkupInCodeImpl extends MinimalEObjectImpl . Container implements MarkupInCode { protected MarkupInCodeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return XdocPackage", "gt": ". Literals . MARKUP_IN_CODE ;", "prediction": ". class ;\n", "label": 1}
{"id": 5174, "input": "<s> package org . jjflyboy . tjpeditor . project ; public", "gt": "interface TaskReport extends Property , ReportAttribute", "prediction": "class TestPlugin extends TestPlugin\n", "label": 0}
{"id": 13239, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import com . emf4sw . owl . DataMinCardinality ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . OWLPackage ; public class DataMinCardinalityImpl extends DataPropertyRestrictionImpl implements DataMinCardinality { protected static final int CARDINALITY_EDEFAULT = 0 ; protected int cardinality = CARDINALITY_EDEFAULT ; protected DataRange dataRange ; protected DataProperty property ; protected DataMinCardinalityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . DATA_MIN_CARDINALITY ; } public int getCardinality ( ) { return cardinality ; } public void setCardinality ( int newCardinality ) { int oldCardinality = cardinality ; cardinality = newCardinality ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY , oldCardinality , cardinality ) ) ; } public DataRange getDataRange ( ) { if ( dataRange != null && dataRange . eIsProxy ( ) ) { InternalEObject oldDataRange = ( InternalEObject ) dataRange ; dataRange = ( DataRange ) eResolveProxy ( oldDataRange ) ; if ( dataRange != oldDataRange ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } } return dataRange ; } public DataRange basicGetDataRange ( ) { return dataRange ; } public void setDataRange ( DataRange newDataRange ) { DataRange oldDataRange = dataRange ; dataRange = newDataRange ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } public DataProperty getProperty ( ) { if ( property != null && property . eIsProxy ( ) ) { InternalEObject oldProperty = ( InternalEObject ) property ; property = ( DataProperty ) eResolveProxy ( oldProperty ) ; if ( property != oldProperty ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } } return property ; } public DataProperty basicGetProperty ( ) { return property ; } public void setProperty ( DataProperty newProperty ) { DataProperty oldProperty = property ; property = newProperty ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : return getCardinality ( ) ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : if (", "gt": "resolve ) return getDataRange ( ) ;", "prediction": "coreType == null )\n", "label": 1}
{"id": 179, "input": "<s> import com . sun . source . tree . * ; import com . sun . source . util . * ; import java . io . * ; import java . lang . annotation . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . * ; import javax . lang . model . type . * ; import javax . tools . * ; import com . sun . tools . javac . api . JavacTool ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . TreeInfo ; @ Anno @ SupportedAnnotationTypes ( \"*\" ) public class TestTrees extends AbstractProcessor { @ Anno void annoMethod ( ) { } @ Anno int annoField ; static final String testSrcDir = System . getProperty ( \"test.src\" ) ; static final String testClassDir = System . getProperty ( \"test.classes\" ) ; static final String self = TestTrees . class . getName ( ) ; static PrintWriter out = new PrintWriter ( System . err , true ) ; public static void main ( String [ ] args ) throws IOException { new TestTrees ( ) . run ( ) ; } void run ( ) throws IOException { JavacTool tool = JavacTool . create ( ) ; DiagnosticListener < JavaFileObject > dl = new DiagnosticListener < JavaFileObject > ( ) { public void report ( Diagnostic d ) { error ( d . toString ( ) ) ; } } ; StandardJavaFileManager fm = tool . getStandardFileManager ( dl , null , null ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( new File ( testSrcDir , self + \".java\" ) ) ) ; Iterable < String > opts = Arrays . asList ( \"-d\" , \".\" ) ; System . err . println ( \"simple compilation, no processing\" ) ; JavacTask task = tool . getTask ( out , fm , dl , opts , null , files ) ; task . setTaskListener ( new MyTaskListener ( task ) ) ; if ( ! task . call ( ) ) throw new AssertionError ( \"compilation failed\" ) ; opts = Arrays . asList ( \"-d\" , \".\" , \"-processorpath\" , testClassDir , \"-processor\" , self ) ; System . err . println ( ) ; System . err . println ( \"compilation with processing\" ) ; task = tool . getTask ( out , fm , dl , opts , null , files ) ; if ( ! task . call ( ) ) throw new AssertionError ( \"compilation failed\" ) ; if ( errors > 0 ) throw new AssertionError ( errors + \" errors occurred\" ) ; } void testElement ( Trees trees , Element e ) { trees . getClass ( ) ; e . getClass ( ) ; System . err . println ( \"testElement: \" + e ) ; Tree tree = trees . getTree ( e ) ; if ( TreeInfo . symbolFor ( ( JCTree ) tree ) != e ) error ( \"bad result from getTree\" ) ; TreePath path = trees . getPath ( e ) ; if ( path == null ) { error ( \"getPath returned null\" ) ; return ; } if ( path . getLeaf ( ) != tree ) error ( \"bad result from getPath\" ) ; Element e2 = trees . getElement ( path ) ; if ( e2 == null ) { error ( \"getElement returned null\" ) ; return ; } if ( e2 != e ) error ( \"bad result from getElement\" ) ; TypeMirror t = trees . getTypeMirror ( path ) ; if ( t != null && t . getKind ( ) == TypeKind . DECLARED && ( ( DeclaredType ) t ) . asElement ( ) != e2 ) error ( \"bad result from getTypeMirror\" ) ; for ( AnnotationMirror m : e . getAnnotationMirrors ( ) ) { testAnnotation ( trees , e , m ) ; } } void testAnnotation ( Trees trees , Element e , AnnotationMirror a ) { System . err . println ( \"testAnnotation: \" + e + \" \" + a ) ; Tree tree = trees . getTree ( e , a ) ; if ( tree . getKind ( ) != Tree . Kind . ANNOTATION ) error ( \"bad result from getTree\" ) ; TreePath path = trees . getPath ( e , a ) ; if ( path . getLeaf ( ) != tree ) error ( \"bad result from getPath\" ) ; } void error ( String msg ) { if ( messager != null ) messager . printMessage ( Diagnostic . Kind . ERROR , msg ) ; else { System . err . println ( msg ) ; errors ++ ; } } Messager messager ; int errors ; public boolean process ( Set < ? extends TypeElement > annos , RoundEnvironment rEnv ) { Trees trees = Trees . instance ( processingEnv ) ; messager = processingEnv . getMessager ( ) ; for ( Element e : rEnv . getRootElements ( ) ) { testElement ( trees , e ) ; } for ( TypeElement anno : annos ) { Set < ? extends Element > elts = rEnv . getElementsAnnotatedWith ( anno ) ; System . err . println ( \"anno: \" + anno ) ; System . err . println ( \"elts: \" + elts ) ; if ( elts != null ) { for ( Element e : rEnv . getElementsAnnotatedWith ( anno ) ) testElement ( trees , e ) ; } } return true ; } @ Override public SourceVersion getSupportedSourceVersion ( ) { return SourceVersion . latest ( ) ; } class MyTaskListener implements TaskListener { MyTaskListener ( JavacTask task ) { this . task = task ; } public void started ( TaskEvent e ) { System . err . println ( \"started \" + e ) ; } public void finished ( TaskEvent e ) { switch ( e . getKind ( ) ) { case ANALYZE : testElement ( Trees . instance ( task ) ,", "gt": "e . getTypeElement ( ) ) ;", "prediction": "e ) ;\n", "label": 0}
{"id": 13240, "input": "<s> package org . modelgoon . sequencediagram . ui ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . draw2d . geometry . Point ; public class SequenceDiagramFigure extends FragmentFigure { Map < String , LifelineFigure > lifelinesRegistry = new HashMap < String , LifelineFigure > ( ) ; int preferedWidth = 0 ; public SequenceDiagramFigure ( ) { super ( ) ; setFirstOffset ( 50 ) ; } public void addActor ( final String objectName ) { LifelineFigure lifelineFigure = new LifelineFigure ( ) ; lifelineFigure . setActor ( true ) ; lifelineFigure . setLabel ( objectName ) ; add ( lifelineFigure ) ; this . lifelinesRegistry . put ( objectName , lifelineFigure ) ; } public void addLifeline ( final String objectName ) { LifelineFigure lifelineFigure = new LifelineFigure ( ) ; lifelineFigure . setLabel ( objectName ) ; add ( lifelineFigure ) ; this . lifelinesRegistry . put ( objectName , lifelineFigure ) ; } public void addMessage ( final String message , final String source , final String destination ) { MessageConnection messageConnection = createMessageConnection ( message , source , destination ) ; add ( messageConnection ) ; } public MessageConnection createMessageConnection ( final String message , final String source , final String destination ) { LifelineFigure sourceFigure = this . lifelinesRegistry . get ( source ) ; LifelineFigure destFigure = this . lifelinesRegistry . get ( destination ) ; return new MessageConnection ( message , sourceFigure , destFigure ) ; } @ Override protected void layout ( ) { super . layout ( ) ; int x = 5 ; int lifelineLength = getVerticalExtent ( ) == 0 ? 40 + this . firstOffset : getVerticalExtent ( ) ; for ( Object children : getChildren ( ) ) { if", "gt": "( children instanceof LifelineFigure )", "prediction": "( children == null )\n", "label": 1}
{"id": 3858, "input": "<s> class StringLength { public static final String l5e0 = \"abcde\" ; public static final String l1e1 = l5e0 + l5e0 ; public static final String l3e1 = l1e1 + l1e1 + l1e1 ; public static final String l1e2 = l3e1 + l3e1 + l3e1 + l1e1 ; public static final String l5e2 = l1e2 + l1e2 + l1e2 + l1e2 + l1e2 ; public static final String l1e3 = l5e2 + l5e2 ; public static final String l5e3 = l1e3 + l1e3 + l1e3 + l1e3 + l1e3 ; public static final String l1e4 = l5e3 + l5e3 ; public static final String l6e4 = l1e4 + l1e4 + l1e4 + l1e4 + l1e4 + l1e4 ; public static final String l65530 =", "gt": "l6e4 + l5e3 + l5e2 + l3e1 ;", "prediction": "\"abcde\" ;\n", "label": 0}
{"id": 13242, "input": "<s> package org . fuzzydb . attrs . simple ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . Score . Direction ; import org . fuzzydb . attrs . dimensions . DimensionsRangeConstraint ; import org . fuzzydb . attrs . internal . IConstraintMap ; import org . fuzzydb . attrs . internal . MappedTwoAttrScorer ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; import org . fuzzydb . core . whirlwind . internal . IAttributeMap ; import org . fuzzydb . util . ScoreMapper ; public class FloatRangePreferenceScorer extends MappedTwoAttrScorer { private static final long serialVersionUID = - 2314631712003854132L ; @ SuppressWarnings ( \"unused\" ) private FloatRangePreferenceScorer ( ) { this ( 1 , 1 , null ) ; } public FloatRangePreferenceScorer ( int scoreAttrId , int otherAttrId , ScoreMapper scoreMapper ) { super ( scoreAttrId , otherAttrId , scoreMapper ) ; } @ Override public void scoreSearchToNode ( Score score , Direction d , IConstraintMap c , IAttributeMap < ? extends IAttribute > scoreAttrs ) { IAttribute attr = scoreAttrs . findAttr ( scorerAttrId ) ; if ( attr == null ) { return ; } FloatRangePreference want = ( FloatRangePreference ) attr ; IAttributeConstraint na = c . findAttr ( otherAttrId ) ; if ( na == null ) { score . addNull ( this , d ) ; return ; } float result = 0.0f ; if ( na . isIncludesNotSpecified ( ) ) { if ( isScoreNull ( ) ) { result = getScoreOnNull ( ) ; } } FloatConstraint bc = ( FloatConstraint ) na ; float branchMin = bc . getMin ( ) ; float branchMax = bc . getMax ( ) ; float myPref = want . getPreferred ( ) ; float s ; if ( branchMin <= myPref && myPref <= branchMax ) { s = maxScore ; } else if ( myPref > branchMax ) { s = scoreGap ( want , branchMax ) ; } else { s = scoreGap ( want , branchMin ) ; } result = Math . max ( result , s ) ; score . add ( this , result , d ) ; } @ Override public void scoreNodeToSearch ( Score score , Direction d , IAttributeMap < IAttributeConstraint > c , IAttributeMap < IAttribute > searchAttrs ) { IAttributeConstraint bNa = c . findAttr ( scorerAttrId ) ; if ( bNa == null ) { return ; } FloatValue otherAttr = ( FloatValue ) searchAttrs . findAttr ( otherAttrId ) ; if ( otherAttr == null ) { score . addNull ( this , d ) ; return ; } if ( bNa . isIncludesNotSpecified ( ) ) { score . add ( this , maxScore , d ) ; return ; } DimensionsRangeConstraint want = ( DimensionsRangeConstraint ) bNa ; float scoreFactor = getNodeScoreFactor ( want , otherAttr . getValue ( ) ) ; float scoreVal = getMappedScore ( scoreFactor ) ; score . add ( this , scoreVal , d ) ; } @ Override public void scoreItemToItem ( Score score , Score . Direction d , IAttributeMap < IAttribute > c , IAttributeMap < IAttribute > scoreAttrs ) { IAttribute wantAttr", "gt": "= scoreAttrs . findAttr ( scorerAttrId ) ;", "prediction": "= scoreAttrs . findAttr ( scorerAttrId ) ;\n", "label": 1}
{"id": 7021, "input": "<s> package net . minecraft . src ; public class ThxEntityMissile extends ThxEntityMissileBase implements ISpawnable { public ThxEntityMissile ( World world ) { super ( world ) ; } public ThxEntityMissile ( Entity owner , double x , double y , double z , double dx , double dy , double dz", "gt": ", float yaw , float pitch )", "prediction": ")\n", "label": 0}
{"id": 13246, "input": "<s> package org . eclipse . ui . internal . contexts ; import org . eclipse . core . expressions . Expression ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . internal . expressions . ActivePartExpression ; import org . eclipse . ui . internal . expressions . WorkbenchWindowExpression ; import org . eclipse . ui . internal . services . IWorkbenchLocationService ; import org . eclipse . ui . services . AbstractServiceFactory ; import org . eclipse . ui . services . IServiceLocator ; public class ContextServiceFactory extends AbstractServiceFactory { public Object create ( Class serviceInterface , IServiceLocator parentLocator , IServiceLocator locator ) { if ( ! IContextService . class . equals ( serviceInterface ) ) { return null ; } IWorkbenchLocationService wls = ( IWorkbenchLocationService ) locator . getService ( IWorkbenchLocationService . class ) ; final IWorkbench wb = wls . getWorkbench ( ) ; if ( wb == null ) { return null ; } Object parent = parentLocator . getService ( serviceInterface ) ; if ( parent == null ) { return null ; } final IWorkbenchWindow window = wls . getWorkbenchWindow ( ) ; final IWorkbenchPartSite site = wls . getPartSite ( ) ; if ( site == null ) { Expression exp = new WorkbenchWindowExpression ( window ) ; return new SlaveContextService ( ( IContextService ) parent , exp ) ; } if ( parent instanceof SlaveContextService ) { Expression exp =", "gt": "( ( SlaveContextService ) parent ) . fDefaultExpression ;", "prediction": "new SlaveContextService ( ( IContextService ) parent , exp ) ;\n", "label": 1}
{"id": 8599, "input": "<s> class CatchWithoutTry { void m ( ) {", "gt": "catch ( Exception e )", "prediction": "try\n", "label": 0}
{"id": 13255, "input": "<s> package org . nuxeo . ecm . platform . gwt . client . ui . old ; import org . nuxeo . ecm . platform . gwt . client . ui . login . LoginCommand ; import com . google . gwt . user . client . ui . Button ; import com . google . gwt . user . client . ui . ClickListener ; import com . google . gwt . user . client . ui . DialogBox ; import com . google . gwt . user . client . ui . FlexTable ; import com . google . gwt . user . client . ui . FlowPanel ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . HasHorizontalAlignment ; import com . google . gwt . user . client . ui . Label ; import com . google . gwt . user . client . ui . PasswordTextBox ; import com . google . gwt . user . client . ui . TextBox ; import com . google . gwt . user . client . ui . VerticalPanel ; import com . google . gwt . user . client . ui . Widget ; public class LoginDialog2 extends DialogBox implements ClickListener { protected TextBox userBox ; protected PasswordTextBox passBox ; public LoginDialog2 ( ) { this ( \"Authentication Requried\" ) ; setAnimationEnabled ( true ) ; } public LoginDialog2 ( String message ) { super ( ) ; setAnimationEnabled ( true ) ; VerticalPanel dialogContents = new VerticalPanel ( ) ; dialogContents . setSpacing ( 2 ) ; setWidget ( dialogContents ) ; HTML details = new HTML ( message ) ; dialogContents . add ( details ) ; dialogContents . setCellHorizontalAlignment ( details , HasHorizontalAlignment . ALIGN_CENTER ) ; dialogContents . add ( createContent ( ) ) ; } protected Widget createContent ( ) { userBox = new TextBox ( ) ; passBox = new PasswordTextBox ( ) ; Button submit = new Button ( \"Login\" ) ; submit . addClickListener ( this ) ; VerticalPanel panel = new VerticalPanel ( ) ; panel . add ( new Label ( \"Username:\" ) ) ; panel . add ( userBox ) ; panel . add ( new Label ( \"Password:\" ) ) ; panel . add ( passBox ) ; panel . add ( submit ) ; panel . setSpacing ( 2 ) ; FlexTable grid = new FlexTable ( ) ; grid . setWidget ( 0 , 0 , new Label ( \"Username\" ) ) ; grid . setWidget ( 0 , 1 , userBox ) ; grid . setWidget ( 0 , 0 , new Label", "gt": "( \"Password\" ) ) ;", "prediction": "( \"Password:\" ) ) ;\n", "label": 1}
{"id": 9253, "input": "<s> package ar . com . fdvs . dj . domain . entities . conditionalStyle ; import java . util . Map ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . entities . Entity ; public class StatusLightCondition extends ConditionStyleExpression implements CustomExpression { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private Double min ; private Double max ; private int mode = 0 ; public StatusLightCondition ( Double min , Double max ) { this . min = min ; this . max = max ; if ( min != null && max == null ) mode = 0 ; else if ( min != null && max != null ) mode = 1 ; else if ( min == null && max != null ) mode = 2 ; } public Object evaluate ( Map fields , Map variables , Map parameters ) { Object value = getCurrentValue ( ) ; if ( value == null ) return null ; Number number = ( Number ) value ; if ( mode == 0 ) { return Boolean . valueOf ( ( min . doubleValue", "gt": "( ) > number . doubleValue ( ) ) ) ;", "prediction": "( ) ) ) ;\n", "label": 0}
{"id": 13268, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . widgets . IDialogAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . widgets . DialogCallback ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; public class Dialog_Test extends TestCase { private static class TestDialog extends Dialog { private TestDialog ( Shell parent ) { super ( parent ) ; } private TestDialog ( Shell parent , int style ) { super ( parent , style ) ; } @ Override protected void prepareOpen ( ) { shell = new Shell ( parent ) ; } } private Display display ; private Shell shell ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConstructorWithNullParent ( ) { try { new TestDialog ( null ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertEquals ( \"Argument cannot be null\" , expected . getMessage ( ) ) ; } } public void testDefaults ( ) { Dialog dialog = new TestDialog ( shell ) ; assertSame ( shell , dialog . getParent ( ) ) ; assertEquals ( \"\" , dialog . getText ( ) ) ; assertEquals ( SWT . PRIMARY_MODAL , dialog . getStyle ( ) ) ; } public void testStyleApplicationModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . APPLICATION_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . APPLICATION_MODAL ) != 0 ) ; } public void testStylePrimaryModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . PRIMARY_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . PRIMARY_MODAL ) != 0 ) ; } public void testStyleSystemModal ( ) { Dialog dialog = new TestDialog ( shell , SWT . SYSTEM_MODAL ) ; assertTrue ( ( dialog . getStyle ( ) & SWT . SYSTEM_MODAL ) != 0 ) ; } public void testSetText ( ) { Dialog dialog = new TestDialog ( shell ) ; dialog . setText ( \"Test\" ) ; assertEquals ( \"Test\" , dialog . getText ( ) ) ; } public void testSetTextWithNullArgument ( ) { Dialog dialog = new TestDialog ( shell ) ; try { dialog . setText ( null ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertEquals ( \"Argument cannot be null\" , expected . getMessage ( ) ) ; } } public void testConvertHorizontalDLUsToPixels ( ) { int pixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ; assertTrue ( pixels >= 10 ) ; } public void testConvertHorizontalDLUsToPixelsWithDifferentFonts ( ) { shell . setFont ( new Font ( display , \"roman\" , 10 , SWT . NORMAL ) ) ; int smallPixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ; shell . setFont ( new Font ( display , \"roman\" , 22 , SWT . NORMAL ) ) ; int largePixels = Dialog . convertHorizontalDLUsToPixels ( shell , 10 ) ; assertTrue ( smallPixels < largePixels ) ; } public void testIsSerializable ( ) throws Exception { String text = \"text\" ; TestDialog dialog = new TestDialog ( shell ) ; dialog . setText ( text ) ; IDialogAdapter adapter = dialog . getAdapter ( IDialogAdapter . class ) ; adapter . openNonBlocking ( mock ( DialogCallback . class ) ) ; TestDialog deserializedDialog = Fixture . serializeAndDeserialize ( dialog ) ; assertEquals ( text , deserializedDialog . getText ( ) ) ; } public void testGetAdapter ( ) { Dialog dialog = new TestDialog ( shell ) ; Object adapter = dialog . getAdapter ( IDialogAdapter . class ) ; assertTrue ( adapter instanceof IDialogAdapter ) ; } public void testNonBlockingDialogWithDefaultReturnCode ( ) { Dialog dialog = new TestDialog ( shell ) ; IDialogAdapter adapter = dialog . getAdapter ( IDialogAdapter . class ) ; DialogCallback dialogCallback = mock ( DialogCallback . class ) ; adapter . openNonBlocking ( dialogCallback ) ; dialog . shell . close ( ) ; verify ( dialogCallback ) . dialogClosed ( SWT . CANCEL ) ; } public void testNonBlockingDialogWithCustomReturnCode ( ) { Dialog dialog = new TestDialog ( shell ) ; IDialogAdapter adapter = dialog . getAdapter ( IDialogAdapter . class ) ; DialogCallback dialogCallback = mock (", "gt": "DialogCallback . class ) ;", "prediction": "DialogCallback . class ) ;\n", "label": 1}
{"id": 6570, "input": "<s> abstract class Base { abstract void m ( ) ; } class AbstractCantBeAccessed extends Base { void m ( ) { super", "gt": ". m ( ) ;", "prediction": ". m ( ) ;\n", "label": 0}
{"id": 13280, "input": "<s> package org . seage . aal . reporter ; import java . io . File ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . seage . data . DataNode ; import org . seage . data . xml . XmlHelper ; public class AlgorithmReport extends DataNode { private static Logger _logger = Logger . getLogger ( AlgorithmReport . class . getName ( ) ) ; private static final long serialVersionUID = - 2598529749932239606L ; private int _id ; public AlgorithmReport ( String name ) { super ( name ) ; } public int getId ( ) { return _id ; } public void setId ( int id ) { _id = id ; putValue ( \"id\" , id ) ; } public void save ( String path ) { File f = new File ( path ) ; if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; try { XmlHelper", "gt": ". writeXml ( this , path ) ;", "prediction": "xmlHelper = new XmlHelper ( f ) ;\n", "label": 1}
{"id": 8861, "input": "<s> package hudson . plugins . dimensionsscm ; import hudson . plugins . dimensionsscm . DimensionsAPI ; import hudson . plugins . dimensionsscm . DimensionsSCM ; import hudson . plugins . dimensionsscm . Logger ; import com . serena . dmclient . api . DimensionsResult ; import hudson . Extension ; import hudson . Launcher ; import hudson . model . AbstractBuild ; import hudson . model . AbstractProject ; import hudson . model . BuildListener ; import hudson . model . Descriptor . FormException ; import hudson . model . Descriptor ; import hudson . model . Result ; import hudson . tasks . BuildWrapper . Environment ; import hudson . tasks . BuildWrapper ; import hudson . tasks . BuildWrapperDescriptor ; import hudson . util . FormValidation ; import net . sf . json . JSONObject ; import org . kohsuke . stapler . DataBoundConstructor ; import org . kohsuke . stapler . QueryParameter ; import org . kohsuke . stapler . StaplerRequest ; import org . kohsuke . stapler . StaplerResponse ; import javax . servlet . ServletException ; import java . io . IOException ; import java . util . Map ; public class DimensionsBuildWrapper extends BuildWrapper { private DimensionsSCM scm = null ; public Descriptor < BuildWrapper > getDescriptor ( ) { return DMWBLD_DESCRIPTOR ; } @ Extension public static final DescriptorImpl DMWBLD_DESCRIPTOR = new DescriptorImpl ( ) ; @ DataBoundConstructor public DimensionsBuildWrapper ( ) { } @ Override public Environment setUp ( final AbstractBuild build , Launcher launcher , final BuildListener listener ) throws IOException , InterruptedException { long key = - 1 ; if ( build . getProject ( ) . getScm ( ) instanceof DimensionsSCM ) { Logger . Debug ( \"Invoking build setup callout \" + this . getClass ( ) . getName ( ) ) ; if ( scm == null ) scm = ( DimensionsSCM ) build . getProject ( ) . getScm ( ) ; Logger . Debug ( \"Dimensions user is \" + scm . getJobUserName ( ) + \" , Dimensions installation is \" + scm . getJobServer ( ) ) ; try { key = scm . getAPI ( ) . login ( scm . getJobUserName ( ) , scm . getJobPasswd ( ) , scm . getJobDatabase ( ) , scm . getJobServer ( ) , build ) ; if ( key > 0 ) { DimensionsResult res = scm . getAPI ( ) . lockProject ( key , scm . getProject ( ) ) ; if ( res == null ) { listener . getLogger ( ) . println ( \"[DIMENSIONS] Locking the project in Dimensions failed\" ) ; build . setResult ( Result . FAILURE ) ; listener . getLogger ( ) . flush ( ) ; } else { listener . getLogger ( ) . println ( \"[DIMENSIONS] Dimensions project was successfully locked\" ) ; listener . getLogger ( ) . flush ( ) ; } } } catch ( Exception e ) { listener . fatalError ( \"Unable to lock Dimensions project - \" + e . getMessage ( ) ) ; } finally { scm . getAPI ( ) . logout ( key , build ) ; } } else { listener . fatalError ( \"[DIMENSIONS] This plugin only works with a Dimensions SCM engine\" ) ; build . setResult ( Result . FAILURE ) ; throw new IOException ( \"[DIMENSIONS] This plugin only works with a Dimensions SCM engine\" ) ; } return new EnvironmentImpl ( build ) ; } public static final class DescriptorImpl extends BuildWrapperDescriptor { public DescriptorImpl ( ) { super ( DimensionsBuildWrapper . class ) ; load ( ) ; Logger . Debug ( \"Loading \" + this . getClass ( ) . getName ( ) ) ; } public String getDisplayName ( ) { return \"Lock Dimensions project while the build is in progress\" ; } @ Override public boolean isApplicable ( AbstractProject < ? , ? > item ) { return true ; } @ Override public boolean configure ( StaplerRequest req , JSONObject formData ) throws FormException { req . bindParameters ( this , \"DimensionsBuildWrapper\" ) ; save ( ) ; return true ; } @ Override public String getHelpFile ( ) { return \"/plugin/dimensionsscm/helpbwrapper.html\" ; } } class EnvironmentImpl extends Environment { AbstractBuild < ? , ? > elbuild ; EnvironmentImpl ( AbstractBuild < ? , ? > build ) { this . elbuild = build ; } @ Override public void buildEnvVars ( Map < String , String > env ) { } @ Override public boolean tearDown ( AbstractBuild build , BuildListener listener ) throws IOException { long key = - 1 ; if ( scm != null ) { Logger . Debug ( \"Invoking build tearDown callout \" + this . getClass ( ) . getName ( ) ) ; Logger . Debug ( \"Dimensions user is \" + scm . getJobUserName ( ) + \" , Dimensions installation is \" + scm . getJobServer ( ) ) ; try { key = scm . getAPI ( ) . login ( scm . getJobUserName ( ) , scm . getJobPasswd ( ) , scm . getJobDatabase ( ) , scm . getJobServer ( ) , build ) ; if ( key > 0 ) { Logger . Debug ( \"Unlocking the project\" ) ; DimensionsResult res = scm . getAPI ( ) . unlockProject ( key , scm . getProject ( ) ) ; if ( res == null ) { listener . getLogger ( ) . println ( \"[DIMENSIONS] Unlocking the project in Dimensions failed\" ) ; build . setResult ( Result . FAILURE ) ; listener . getLogger ( ) . flush ( ) ; } else { listener . getLogger ( ) . println ( \"[DIMENSIONS] Dimensions project was successfully unlocked\" ) ; listener . getLogger ( ) . flush ( ) ; } } else { listener . fatalError ( \"[DIMENSIONS] Login to Dimensions failed.\" ) ;", "gt": "build . setResult ( Result . FAILURE ) ;", "prediction": "}\n", "label": 0}
{"id": 13285, "input": "<s> package br . org . archimedes . model ; import java . util . ArrayList ; import java . util . List ; public class Rectangle { private double x ; private double y ; private double width ; private double height ; public Rectangle ( double x1 , double y1 , double x2 , double y2 ) { this . x = Math . min ( x1 , x2 ) ; this . y = Math . min ( y1 , y2 ) ; this . width = Math . abs ( x1 - x2 ) ; this . height = Math . abs ( y1 - y2 ) ; } public List < Point > getPoints ( ) { ArrayList < Point > points = new ArrayList < Point > ( ) ; Point lowerLeft = new Point ( x , y ) ; Point upperLeft = new Point ( x , y + height ) ; Point upperRight = new Point ( x + width , y + height ) ; Point lowerRight = new Point ( x + width , y ) ; points . add ( lowerLeft ) ; points . add ( lowerRight ) ; points . add ( upperRight ) ; points . add ( upperLeft ) ; return points ; } public String toString ( ) { String s = \"(x,y,w,h) = (\" + this . x + \", \" + this . y + \", \" + this . width + \", \" + this . height + \")\" ; return s ; } public boolean equals ( Object object ) { boolean equal = ( object == this ) ; if ( ! equal && object != null && object . getClass ( ) == this . getClass ( ) ) { Rectangle rectangle = ( Rectangle ) object ; equal = getPoints ( ) .", "gt": "equals ( rectangle . getPoints ( ) ) ;", "prediction": "size ( ) ;\n", "label": 1}
{"id": 156, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class RuntimeInvisibleAnnotations_attribute extends RuntimeAnnotations_attribute { RuntimeInvisibleAnnotations_attribute ( ClassReader cr , int name_index , int length ) throws IOException , AttributeException { super ( cr , name_index , length ) ; } public RuntimeInvisibleAnnotations_attribute ( ConstantPool cp , Annotation [ ] annotations ) throws ConstantPoolException { this ( cp . getUTF8Index ( Attribute . RuntimeInvisibleAnnotations ) , annotations ) ; } public RuntimeInvisibleAnnotations_attribute ( int name_index , Annotation [ ] annotations ) { super ( name_index , annotations ) ; } public < R , P > R accept ( Visitor < R , P > visitor , P p ) {", "gt": "return visitor . visitRuntimeInvisibleAnnotations ( this , p ) ;", "prediction": "return visitor ;\n", "label": 0}
{"id": 13287, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec5 . website ; import java . util . ArrayList ; import java . util . List ; import org . restlet . ext . atom . Entry ; import org . restlet . ext . atom . Feed ; import org . restlet . ext . atom . Text ; import org . restlet . resource . Get ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; import com . sun . syndication . feed . synd . SyndContent ; import com . sun . syndication . feed . synd . SyndContentImpl ; import com . sun . syndication . feed . synd . SyndEntry ; import com . sun . syndication . feed . synd . SyndEntryImpl ; import com . sun . syndication . feed . synd . SyndFeed ; import com . sun . syndication . feed . synd . SyndFeedImpl ; public class FeedServerResource extends ServerResource { @ Get ( \"atom\" ) public Feed toAtom ( ) throws ResourceException { Feed result = new Feed ( ) ; result . setTitle ( new Text ( \"Homer's feed\" ) ) ; Entry entry ; for ( int i = 1 ; i < 11 ; i ++ ) { entry = new Entry ( ) ; entry . setTitle ( new Text ( \"Mail n\ufffd\" + i ) ) ; entry . setSummary ( \"Doh! This is the content of mail n\ufffd\" + i ) ; result . getEntries ( ) . add ( entry ) ; } return result ; } @ Get ( \"rss\" ) public SyndFeed toRss ( ) throws ResourceException { SyndFeed result = new SyndFeedImpl ( ) ; result . setTitle ( \"Homer's feed\" ) ; result . setDescription ( \"Homer's feed\" ) ; result . setLink ( getReference ( ) . toString ( ) ) ; List < SyndEntry > entries", "gt": "= new ArrayList < SyndEntry > ( ) ;", "prediction": "= new ArrayList < SyndEntry > ( ) ;\n", "label": 1}
{"id": 1127, "input": "<s> class X { Object o = new p", "gt": ". C ( ) ;", "prediction": "x ( ) ;\n", "label": 0}
{"id": 13290, "input": "<s> package com . design ; import com . datastruct . DCHalfEdge ; import com . math . CompPoint ; import com . math . Geom ; import java . util . Vector ; public class Base extends Part { public String type ; public Base ( double width , double height , String type ) { super ( width , height ) ; this . type = type ; } public void addNotches ( double notchWidth , double notchHeight , double ribNotchOffset , int ribNum , boolean reverse ) { for ( int i = ribNum - 1 ; i >= 0 ; i -- ) { double startTheta = Geom . cartToPolar ( edges . get ( i ) . start . getX ( ) , edges . get ( i ) . start . getY ( ) ) [ 1 ] ; double alpha = 360 / ribNum ; double theta = startTheta + ( i ) * alpha ; Notch notch = new Notch ( notchWidth , notchHeight ) ; notch . rotate ( startTheta + 180 , notch . focus ) ; int after = 0 ; if ( i == 0 ) { after = ribNum - 1 ; } else { after = i - 1 ; } this . setNotch ( notch , i , after , reverse ) ; } } public void largeTabs ( double dist ) { Vector < DCHalfEdge > newEdges = new Vector < DCHalfEdge > ( ) ; for ( int i = 0 ; i < this . edges . size ( ) ; i ++ ) { DCHalfEdge newEdge = this . expandEdge ( this . edges . get ( i ) , dist ) ; DCHalfEdge rightEdge = new DCHalfEdge ( newEdge . end , new CompPoint ( this . edges . get ( i ) . end . getX ( ) , this . edges . get ( i ) . end . getY ( ) ) ) ; DCHalfEdge leftEdge = new DCHalfEdge ( newEdge . start , new CompPoint ( this . edges . get ( i ) . start . getX ( ) , this . edges . get ( i ) . start . getY ( ) ) ) ; newEdges . addElement ( rightEdge ) ; newEdges . addElement ( newEdge ) ; newEdges . addElement ( leftEdge ) ; } this . edges = newEdges ; } public double findRad ( ) { double rad = Geom . cartToPolar ( edges . get ( 0 ) . start . getX ( ) , edges . get ( 0 ) . start . getY ( ) ) [ 0 ] ; return rad ; } private void setNotch ( Notch notch , int edgeNum , int edgeNumAfter , boolean reverse ) { notch . translate ( this . edges . get ( edgeNum ) . start . getX ( ) , this . edges . get ( edgeNum ) . start . getY ( ) ) ; if ( reverse ) { notch . mergeReverse ( this , edgeNumAfter , edgeNum ) ; } else { notch . merge ( this , edgeNumAfter , edgeNum ) ; } } public void generateHole ( double radius ) { int res = 50 ; Vector < CompPoint > points = new Vector < CompPoint > ( ) ; for ( int i = 0 ; i < res ; i ++ ) { double alpha = Math . PI * 2 / res ; double theta = i * alpha ; double xPos = Math . sin ( theta ) * radius + focus . getX ( ) ; double yPos = Math . cos ( theta ) * radius + focus . getY ( ) ; points . addElement ( new CompPoint ( xPos , yPos ) ) ; } for ( int i = 0 ; i < res ; i ++ ) { int after = i + 1 ; if (", "gt": "i == res - 1 )", "prediction": "i == 0 )\n", "label": 1}
{"id": 2210, "input": "<s> package org . ofbiz . base . util ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . security . cert . CertificateException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class HttpClient { public static final String module = HttpClient . class . getName ( ) ; private int hostVerification = SSLUtil . HOSTCERT_NORMAL_CHECK ; private int timeout = 30000 ; private boolean debug = false ; private boolean lineFeed = true ; private boolean trustAny = false ; private boolean followRedirects = true ; private boolean keepAlive = false ; private String contentType = null ; private String streamCharset = null ; private String url = null ; private String rawStream = null ; private String clientCertAlias = null ; private String basicAuthUsername = null ; private String basicAuthPassword = null ; private Map < String , Object > parameters = null ; private Map < String , String > headers = null ; private URL requestUrl = null ; private URLConnection con = null ; public HttpClient ( ) { } public HttpClient ( URL url ) { this . url = url . toExternalForm ( ) ; } public HttpClient ( String url ) { this . url = url ; } public HttpClient ( String url , Map < String , Object > parameters ) { this . url = url ; this . parameters = parameters ; } public HttpClient ( URL url , Map < String , Object > parameters ) { this . url = url . toExternalForm ( ) ; this . parameters = parameters ; } public HttpClient ( String url , Map < String , Object > parameters , Map < String , String > headers ) { this . url = url ; this . parameters = parameters ; this . headers = headers ; } public HttpClient ( URL url , Map < String , Object > parameters , Map < String , String > headers ) { this . url = url . toExternalForm ( ) ; this . parameters = parameters ; this . headers = headers ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setTimeout ( int timeout ) { this . timeout = timeout ; } public void followRedirects ( boolean followRedirects ) { this . followRedirects = followRedirects ; } public void setLineFeed ( boolean lineFeed ) { this . lineFeed = lineFeed ; } public void setRawStream ( String stream ) { this . rawStream = stream ; } public void setUrl ( URL url ) { this . url = url . toExternalForm ( ) ; } public void setUrl ( String url ) { this . url = url ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public void setParameter ( String name , String value ) { if ( parameters == null ) parameters = new HashMap < String , Object > ( ) ; parameters . put ( name , value ) ; } public void setHeaders ( Map < String , String > headers ) { this . headers = headers ; } public void setHeader ( String name , String value ) { if ( headers == null ) headers = new HashMap < String , String > ( ) ; headers . put ( name , value ) ; } public Map < String , String > getHeaders ( ) { return headers ; } public Map < String , Object > getParameters ( ) { return parameters ; } public String getUrl ( ) { return url ; } public void setContentType ( String contentType ) { this . contentType = contentType ; } public String getContentType ( ) { return this . contentType ; } public void setStreamCharset ( String streamCharset ) { this . streamCharset = streamCharset ; } public String getStreamCharset ( ) { return this . streamCharset ; } public void setKeepAlive ( boolean keepAlive ) { this . keepAlive = keepAlive ; } public boolean getKeepAlive ( ) { return this . keepAlive ; } public void setClientCertificateAlias ( String alias ) { this . clientCertAlias = alias ; } public String getClientCertificateAlias ( ) { return this . clientCertAlias ; } public void setHostVerificationLevel ( int level ) { this . hostVerification = level ; } public int getHostVerificationLevel ( ) { return this . hostVerification ; } public void setAllowUntrusted ( boolean trustAny ) { this . trustAny = trustAny ; } public boolean getAllowUntrusted ( ) { return this . trustAny ; } public", "gt": "void setBasicAuthInfo ( String basicAuthUsername , String basicAuthPassword )", "prediction": "boolean getAllowUntrusted ( )\n", "label": 0}
{"id": 13293, "input": "<s> package org . eclipse . rap . rwt . internal . uicallback ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyZeroInteractions ; import static org . mockito . Mockito . when ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; import javax . servlet . http . HttpSession ; import javax . servlet . http . HttpSessionBindingListener ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . ServiceContext ; import org . eclipse . rap . rwt . internal . service . ServiceStore ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackManager ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackServiceHandler ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . TestRequest ; import org . eclipse . rap . rwt . testfixture . TestResponse ; import org . eclipse . rap . rwt . testfixture . internal . NoOpRunnable ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . widgets . Display ; public class UICallBackManager_Test extends TestCase { public static final String SYS_PROP_SLEEP_TIME = \"sleepTime\" ; public static final String SYS_PROP_TIMER_EXEC_DELAY = \"timerExecDelay\" ; private static final int SLEEP_TIME ; private static final int TIMER_EXEC_DELAY ; private static final String ID_1 = \"id_1\" ; private static final String ID_2 = \"id_2\" ; private static final String RUN_ASYNC_EXEC = \"run async exec|\" ; private static final Runnable EMPTY_RUNNABLE = new NoOpRunnable ( ) ; static { String sleepTimeProp = System . getProperty ( SYS_PROP_SLEEP_TIME ) ; SLEEP_TIME = sleepTimeProp == null ? 200 : Integer . parseInt ( sleepTimeProp ) ; String timerExecDelayProp = System . getProperty ( SYS_PROP_TIMER_EXEC_DELAY ) ; TIMER_EXEC_DELAY = timerExecDelayProp == null ? 5000 : Integer . parseInt ( timerExecDelayProp ) ; } private volatile String log = \"\" ; private Display display ; private UICallBackManager manager ; private UICallBackServiceHandler uiCallBackServiceHandler ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; log = \"\" ; display = new Display ( ) ; manager = UICallBackManager . getInstance ( ) ; uiCallBackServiceHandler = new UICallBackServiceHandler ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testWakeClient ( ) throws InterruptedException { final Throwable [ ] uiCallBackServiceHandlerThrowable = { null } ; final ServiceContext context [ ] = { ContextProvider . getContext ( ) } ; Thread thread = new Thread ( new Runnable ( ) { public void run ( ) { ContextProvider . setContext ( context [ 0 ] ) ; Fixture . fakeResponseWriter ( ) ; UICallBackServiceHandler uiCallBackServiceHandler = new UICallBackServiceHandler ( ) ; try { manager . activateUICallBacksFor ( \"foo\" ) ; uiCallBackServiceHandler . service ( ) ; } catch ( Throwable thr ) { uiCallBackServiceHandlerThrowable [ 0 ] = thr ; } } } ) ; thread . start ( ) ; Thread . sleep ( SLEEP_TIME ) ; if ( uiCallBackServiceHandlerThrowable [ 0 ] != null ) { uiCallBackServiceHandlerThrowable [ 0 ] . printStackTrace ( ) ; } assertNull ( uiCallBackServiceHandlerThrowable [ 0 ] ) ; assertTrue ( manager . isCallBackRequestBlocked ( ) ) ; manager . setHasRunnables ( true ) ; manager . wakeClient ( ) ; thread . join ( ) ; assertFalse ( manager . isCallBackRequestBlocked ( ) ) ; assertFalse ( thread . isAlive ( ) ) ; } public void testWaitOnUIThread ( ) throws Exception { CallBackRequestSimulator callBackRequestSimulator = new CallBackRequestSimulator ( ) ; callBackRequestSimulator . sendRequest ( ) ; display . wake ( ) ; assertTrue ( manager . isCallBackRequestBlocked ( ) ) ; assertFalse ( callBackRequestSimulator . exceptionOccured ( ) ) ; manager . releaseBlockedRequest ( ) ; } public void testWaitOnBackgroundThread ( ) throws Throwable { CallBackRequestSimulator callBackRequestSimulator = new CallBackRequestSimulator ( ) ; callBackRequestSimulator . sendRequest ( ) ; assertTrue ( manager", "gt": ". isCallBackRequestBlocked ( ) ) ;", "prediction": ". isCallBackRequestBlocked ( ) ) ;\n", "label": 1}
{"id": 4881, "input": "<s> package org . gk . ui . client . com . form ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . widget . form . ListModelPropertyEditor ; public class gkListModelPropertyEditor < Data extends ModelData > extends ListModelPropertyEditor < Data > { private String valueProperty = \"value\" ; @ Override public Data convertStringValue ( String value ) { if ( models . isEmpty ( ) && ! value . equals ( \"\" ) ) { ModelData md = new gkMap ( ) ; md . set ( displayProperty , value ) ; md . set ( valueProperty , value ) ; return ( Data ) md ; } for ( Data d : models ) {", "gt": "Object val = d . get ( displayProperty ) ;", "prediction": "if ( d instanceof ModelData )\n", "label": 0}
{"id": 13297, "input": "<s> public class Exor extends Gate { public Exor ( int numInputs , int delay ) { super ( numInputs , delay ) ; } public boolean logic ( ) { boolean result = false ; int i = 0 ;", "gt": "for ( Signal s : inputSignals )", "prediction": "for ( int i = 0 ;\n", "label": 1}
{"id": 2088, "input": "<s> import com . sun . mirror . apt . AnnotationProcessorFactory ; public class WrappedStaticApf { public static void main ( String argv [ ] ) { AnnotationProcessorFactory factory = new StaticApf ( ) ; System . exit ( com . sun . tools . apt .", "gt": "Main . process ( factory , argv ) ) ;", "prediction": "AnnotationProcessorFactory . class ) ;\n", "label": 0}
{"id": 13298, "input": "<s> package org . nuxeo . ecm . automation . server . test ; import java . io . IOException ; import java . io . StringWriter ; import org . codehaus . jackson . JsonGenerator ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . server . jaxrs . io . JsonWriter ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; @ Operation ( id = TestDataCapsule . ID , category = \"Test\" ) public class TestDataCapsule { public static final String ID = \"TestDataCapsule\" ; @ OperationMethod public Blob getDataCapsule ( ) throws IOException { StringWriter writer = new StringWriter ( ) ; JsonGenerator generator = JsonWriter . getFactory ( ) . createJsonGenerator ( writer ) ; generator . writeObject ( new MyObject ( ) ) ; writer . close ( ) ; String", "gt": "json = writer . toString ( ) ;", "prediction": "blob = generator . getBlob ( ) ;\n", "label": 1}
{"id": 9467, "input": "<s> package org . parboiled . support ; import org . testng . annotations . Test ; import java . util . * ; import static org . testng . Assert . assertEquals ; import static org . testng . Assert . assertFalse ; import static org . testng . Assert . assertTrue ; public class ValueStackTest { @ Test public void testValueStack ( ) { ValueStack < Integer > stack = new DefaultValueStack < Integer > ( ) ; assertTrue ( stack . isEmpty ( ) ) ; stack . push ( 18 ) ; assertEquals ( stack . size ( ) , 1 ) ; assertFalse ( stack . isEmpty ( ) ) ; assertEquals ( stack . peek ( ) , ( Integer ) 18 ) ; assertEquals ( stack . pop ( ) , ( Integer ) 18 ) ; assertTrue ( stack . isEmpty ( ) ) ; stack . pushAll ( 18 , 26 , 42 ) ; assertEquals ( stack . size ( ) , 3 ) ; assertFalse ( stack . isEmpty ( ) ) ; assertEquals ( stack . peek ( ) , ( Integer ) 42 ) ; assertEquals ( stack . peek ( 2 ) , ( Integer ) 18 ) ; assertEquals ( stack . pop ( ) , ( Integer ) 42 ) ; assertEquals ( stack . size ( ) , 2 ) ; stack . swap ( ) ; assertEquals ( stack . size ( ) , 2 ) ; assertEquals ( stack . peek ( ) , ( Integer ) 18 ) ; assertEquals ( stack . peek ( 1 ) , ( Integer ) 26 ) ; assertEquals ( stack . pop ( 1 ) , ( Integer ) 26 ) ; assertEquals ( stack . size ( ) , 1 ) ; assertEquals ( stack . peek ( ) , ( Integer ) 18 ) ; assertEquals ( stack . peek ( 0 ) , ( Integer ) 18 ) ; stack . pushAll ( 19 , 20 ) ; stack . swap3 ( ) ; List < Integer >", "gt": "list = new LinkedList < Integer > ( ) ;", "prediction": "stack = new ArrayList < Integer > ( ) ;\n", "label": 0}
{"id": 13303, "input": "<s> package org . fuzzydb . tests . functional ; import org . junit . BeforeClass ; public class TCPBasedCRUDTest extends CRUDTest { @ BeforeClass", "gt": "static public void setNonEmbedded ( )", "prediction": "public void setUp ( ) throws Exception\n", "label": 1}
{"id": 1065, "input": "<s> package ar . com . fdvs . dj . test", "gt": ". domain . db ;", "prediction": ";\n", "label": 0}
{"id": 13325, "input": "<s> package com . poetry . model ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; public class PoetryDetail extends Poetry { protected HashSet < String > tags = new HashSet < String > ( ) ; public Collection < String > getTags ( ) { return Collections . unmodifiableCollection ( this . tags ) ; } public", "gt": "void setTags ( final Collection < String > tags )", "prediction": "PoetryDetail ( )\n", "label": 1}
{"id": 905, "input": "<s> package ar . com . fdvs . dj . test . domain ; public class DummyLevel3 { private String name ; private Long number ; public DummyLevel3 ( String name , Long number ) { super ( ) ; this . name = name ; this . number = number ; } public String getName ( ) { return name ; } public void", "gt": "setName ( String name )", "prediction": "setName ( String name )\n", "label": 0}
{"id": 13335, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Map ; abstract class TermsHashConsumer { abstract int bytesPerPosting ( ) ; abstract void createPostings ( RawPostingList [ ] postings , int start , int count ) ; abstract TermsHashConsumerPerThread addThread ( TermsHashPerThread perThread ) ; abstract void flush ( Map threadsAndFields , final", "gt": "SegmentWriteState state ) throws IOException ;", "prediction": "Map fields ) ;\n", "label": 1}
{"id": 6305, "input": "<s> package com . redhat . ceylon . ceylondoc ; import java . io . File ; import java . io . IOException ; import java . util . LinkedList ; import java . util . List ; import com . redhat . ceylon . cmr . api . RepositoryManagerBuilder ; import com . redhat . ceylon . cmr . ceylon . CeylonUtils ; public class Main { private static final String CEYLOND_VERSION = \"0.4 'Ratatouille'\" ; private static final int SC_OK = 0 ; private static final int SC_ARGS = 1 ; private static final int SC_ERROR = 2 ; public static void main ( String [ ] args ) throws IOException { String destDir = null ; List < String > sourceDirs = new LinkedList < String > ( ) ; boolean includeNonShared = false ; boolean includeSourceCode = false ; List < String > modules = new LinkedList < String > ( ) ; List < String > repositories = new LinkedList < String > ( ) ; String systemRepo = null ; String user = null , pass = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; int argsLeft = args . length - 1 - i ; if ( \"-h\" . equals ( arg ) || \"-help\" . equals ( arg ) || \"--help\" . equals ( arg ) ) { printUsage ( SC_OK , systemRepo , repositories , destDir ) ; } else if ( \"-v\" . equals ( arg ) || \"-version\" . equals ( arg ) || \"--version\" . equals ( arg ) ) { printVersion ( ) ; } else if ( \"-d\" . equals ( arg ) ) { System . err . println ( CeylondMessages . msg ( \"error.optionDnotSupported\" ) ) ; exit ( SC_ARGS ) ; } else if ( \"-out\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } destDir = args [ ++ i ] ; } else if ( \"-src\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } sourceDirs . addAll ( readPath ( args [ ++ i ] ) ) ; } else if ( \"-rep\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } repositories . add ( args [ ++ i ] ) ; } else if ( \"-sysrep\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } systemRepo = args [ ++ i ] ; } else if ( \"-non-shared\" . equals ( arg ) ) { includeNonShared = true ; } else if ( \"-source-code\" . equals ( arg ) ) { includeSourceCode = true ; } else if ( \"-user\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } user = args [ ++ i ] ; } else if ( \"-pass\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } pass = args [ ++ i ] ; } else if ( arg . startsWith ( \"-\" ) ) { System . err . println ( CeylondMessages . msg ( \"error.optionUnknown\" , arg ) ) ; exit ( SC_ARGS ) ; } else { modules . add ( arg ) ; } } if ( modules . isEmpty ( ) ) { System . err . println ( CeylondMessages . msg ( \"error.noModulesSpecified\" ) ) ; printUsage ( SC_ARGS , systemRepo , repositories , destDir ) ; } if ( destDir == null ) { destDir = \"modules\" ; } List < File > sourceFolders = new LinkedList < File > ( ) ; if ( sourceDirs . isEmpty ( ) ) { File src = new File ( \"source\" ) ; if ( src . isDirectory ( ) ) sourceFolders . add ( src ) ; } else { for ( String srcDir : sourceDirs ) { File src = new File ( srcDir ) ; if ( ! src . isDirectory ( ) ) { System . err . println ( CeylondMessages . msg ( \"error.noSuchSourceDirectory\" , srcDir ) ) ; exit ( SC_ARGS ) ; } sourceFolders . add ( src ) ; } } try { CeylonDocTool ceylonDocTool = new CeylonDocTool ( ) ; ceylonDocTool . setSourceFolders ( sourceFolders ) ; ceylonDocTool . setRepositories ( repositories ) ; ceylonDocTool . setModuleSpecs ( modules ) ; ceylonDocTool . setHaltOnError ( false ) ; ceylonDocTool . setOutputRepository ( destDir , user , pass ) ; ceylonDocTool . setIncludeNonShared ( includeNonShared ) ; ceylonDocTool . setIncludeSourceCode ( includeSourceCode ) ; ceylonDocTool . init ( ) ; ceylonDocTool . makeDoc ( ) ; } catch ( CeylondException x ) { System . err . println ( CeylondMessages . msg ( \"error\" , x . getLocalizedMessage ( ) ) ) ; exit ( SC_ERROR ) ; } catch ( Exception x ) { System . err . println ( CeylondMessages . msg ( \"error\" , x . getLocalizedMessage ( ) ) ) ; x . printStackTrace ( ) ; exit ( SC_ERROR ) ; } } private static void exit ( int statusCode ) { System . exit ( statusCode ) ; } private static void optionMissingArgument ( String arg ) { System . err . println ( CeylondMessages . msg ( \"error.optionMissing\" , arg ) ) ; exit ( SC_ARGS ) ; } private static List < String > readPath ( String path ) { List < String > ret = new LinkedList < String > ( ) ; int start = 0 ; int sep ; while ( ( sep = path . indexOf ( File . pathSeparatorChar , start ) ) != - 1 ) { String part = path . substring ( start , sep ) ; if ( ! part . isEmpty ( ) ) ret . add ( part ) ; start = sep + 1 ; } String part = path . substring ( start ) ; if ( ! part . isEmpty ( ) ) ret . add ( part ) ; return ret ; } private static void printVersion ( ) { System . out . println ( CeylondMessages", "gt": ". msg ( \"info.version\" , CEYLOND_VERSION ) ) ;", "prediction": ". msg ( \"error.printVersion\" ) ) ;\n", "label": 0}
{"id": 13339, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"contentTypeId\" , \"documentUri\" } ) @ XmlRootElement ( name = \"DeleteContentTypeXmlDocument\" ) public class DeleteContentTypeXmlDocument { protected String listName ; protected String contentTypeId ; protected String documentUri ; public String getListName ( ) { return listName ; } public void setListName ( String value ) { this . listName = value ; } public String getContentTypeId ( ) { return contentTypeId ; } public void setContentTypeId ( String value ) { this . contentTypeId = value ; } public String getDocumentUri ( ) { return documentUri ; } public void", "gt": "setDocumentUri ( String value )", "prediction": "setDocumentUri ( String value )\n", "label": 1}
{"id": 2508, "input": "<s> class TrustMeOnNonVarargsMeth { @ SafeVarargs static void m (", "gt": "String [ ] args )", "prediction": ")\n", "label": 0}
{"id": 13343, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . nodes . BoostQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . search . Query ; public class BoostQueryNodeBuilder implements StandardQueryBuilder { public BoostQueryNodeBuilder ( ) { } public Query build ( QueryNode queryNode ) throws QueryNodeException { BoostQueryNode boostNode = ( BoostQueryNode ) queryNode ; QueryNode child = boostNode . getChild ( ) ; if ( child == null ) { return null ; } Query query = ( Query ) child", "gt": ". getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ;", "prediction": ";\n", "label": 1}
{"id": 2277, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . entities . Entity ; public abstract class AbstractCategoryAxisPlot extends AbstractPlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private DJAxisFormat categoryAxisFormat = new DJAxisFormat ( ) ; private DJAxisFormat valueAxisFormat = new DJAxisFormat ( ) ; public", "gt": "void setCategoryAxisFormat ( DJAxisFormat categoryAxisFormat )", "prediction": "AbstractCategoryAxisPlot ( )\n", "label": 0}
{"id": 13350, "input": "<s> package io . beancounter . platform ; import com . google . inject . Inject ; import io . beancounter . platform . validation . Validations ; import org . codehaus . jackson . map . ObjectMapper ; import io . beancounter . applications . ApplicationsManager ; import io . beancounter . filter . manager . FilterManager ; import io . beancounter . filter . manager . FilterManagerException ; import io . beancounter . filter . model . Filter ; import io . beancounter . filter . model . pattern . ActivityPattern ; import io . beancounter . platform . responses . FilterPlatformResponse ; import io . beancounter . platform . responses . StringsPlatformResponse ; import javax . ws . rs . * ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . Response ; import java . io . IOException ; import java . util . Collection ; import java . util . Set ; import static io . beancounter . applications . ApplicationsManager . Action . * ; import static io . beancounter . applications . ApplicationsManager . Object . FILTER ; @ Path ( \"rest/filters\" ) @ Produces ( MediaType . APPLICATION_JSON ) public class FilterService extends JsonService { private ApplicationsManager applicationsManager ; private FilterManager filterManager ; @ Inject public FilterService ( ApplicationsManager applicationsManager , FilterManager filterManager ) { this . applicationsManager = applicationsManager ; this . filterManager = filterManager ; } @ POST @ Path ( \"/register/{name}\" ) public Response register ( @ PathParam ( \"name\" ) String name , @ FormParam ( \"description\" ) String description , @ FormParam ( \"pattern\" ) String patternJson , @ FormParam ( \"queue\" ) Set < String > queues , @ QueryParam ( \"apikey\" ) String apiKey ) { try { Validations . checkNotEmpty ( name , \"Filter name must not be empty\" ) ; Validations . checkNotEmpty ( description , \"Missing description parameter\" ) ; Validations . checkNotEmpty ( patternJson , \"Missing filter pattern JSON\" ) ; Validations . checkNotEmpty ( queues , \"You must specify at least one queue\" ) ; Validations . validateApiKey ( apiKey , applicationsManager , CREATE , FILTER ) ; } catch ( Exception ex ) { return error ( ex . getMessage ( ) ) ; } ActivityPattern pattern ; try { pattern = parse ( patternJson ) ; } catch ( IOException e ) { return error ( e ,", "gt": "\"Error: cannot parse your input json\" ) ;", "prediction": "e . getMessage ( ) ) ;\n", "label": 1}
{"id": 5774, "input": "<s> package org . gk . engine . client . build . menu ; import java . util . Iterator ; import java . util . List ; import org . gk . engine . client . build . XComponent ; import org . gk . engine . client . gen . UIGen ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . menu . MenuBar ; import com . extjs . gxt . ui . client . widget . menu . MenuBarItem ; import com . google . gwt . xml . client . Node ; public class XMenuBar extends XComponent { public XMenuBar ( Node node , List widgets ) { super ( node , widgets ) ; } @ Override public Component build ( ) { MenuBar mb = new MenuBar ( ) ; super . initComponent ( mb ) ; Iterator < XMenuBarItem > it", "gt": "= widgets . iterator ( ) ;", "prediction": "= new Iterator < XMenuBarItem > ( ) ;\n", "label": 0}
{"id": 13377, "input": "<s> package org . restlet . engine . header ; import java . io . IOException ; import java . util . Collection ; import org . restlet . data . Status ; import org . restlet . data . Warning ; import org . restlet . engine . util . DateUtils ; public class WarningReader extends HeaderReader < Warning > { public static void addValues ( Header header , Collection < Warning > collection ) { new WarningReader ( header . getValue ( ) ) . addValues ( collection ) ; } public WarningReader ( String header ) { super ( header ) ; } @ Override public Warning readValue ( ) throws IOException { Warning result = new Warning ( ) ; String code = readToken ( ) ; skipSpaces ( ) ; String agent = readRawText ( ) ; skipSpaces ( ) ; String text = readQuotedString ( ) ; skipSpaces ( ) ; String date = null ; if ( peek ( ) != - 1 ) { date = readQuotedString ( ) ; } if ( ( code == null ) || (", "gt": "agent == null ) || ( text == null ) )", "prediction": "text == null ) )\n", "label": 1}
{"id": 3112, "input": "<s> package com . sun . mirror . apt ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface RoundState {", "gt": "boolean finalRound ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13384, "input": "<s> package org . spliffy . server . manager ; import java . util . Date ; public class DefaultCurrentDateService implements CurrentDateService { @", "gt": "Override public Date getNow ( )", "prediction": "Override public Date getCurrentDate ( )\n", "label": 1}
{"id": 4037, "input": "<s> package LizaCraft . LivingEntity ; import java . util . HashSet ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . Server ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . entity . Arrow ; import org . bukkit . entity . Egg ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . entity . Player ; import org . bukkit . entity . Snowball ; import org . bukkit . entity . Vehicle ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaBlock ; import Liza . LizaEntity ; import Liza . LizaLivingEntity ; import LizaCraft . Block . LizaCraftBlock ; import LizaCraft . Entity . LizaCraftEntity ; public class LizaCraftLivingEntity implements LizaLivingEntity { private LivingEntity livingEntity ; public LizaCraftLivingEntity ( LivingEntity livingEntity ) { this . livingEntity = livingEntity ; } @ Override public void damage ( int arg0 ) { this . livingEntity . damage ( arg0 ) ; } @ Override public void damage ( int arg0 , Entity arg1 ) { this . livingEntity . damage ( arg0 , arg1 ) ; } @ Override public double getEyeHeight ( ) { return this . livingEntity . getEyeHeight ( ) ; } @ Override public double getEyeHeight ( boolean arg0 ) { return this . livingEntity . getEyeHeight ( arg0 ) ; } @ Override public Location getEyeLocation ( ) { return this . livingEntity . getEyeLocation ( ) ; } @ Override public int getHealth ( ) { return this . livingEntity . getHealth ( ) ; } @ Override public Player getKiller ( ) { return this . livingEntity . getKiller ( ) ; } @ Override public int getLastDamage ( ) { return this . livingEntity . getLastDamage ( ) ; } @ Override public List < Block > getLastTwoTargetBlocks ( HashSet < Byte > arg0 , int arg1 ) { List < Block > bl = this . livingEntity . getLastTwoTargetBlocks ( arg0 , arg1 ) ; for ( Block b : bl ) { b = new LizaCraftBlock ( b ) ; } return bl ; } @ Deprecated public List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > arg0 , int arg1 ) { List < Block > bl = this . livingEntity . getLastTwoTargetBlocks ( arg0 , arg1 ) ; Class < ? extends List > c = bl . getClass ( ) ; List < LizaBlock > lbl = null ; try { lbl = c . newInstance ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } for ( Block b : bl ) { lbl . add ( new LizaCraftBlock ( b ) ) ; } return lbl ; } @ Override public List < Block > getLineOfSight ( HashSet < Byte > arg0 , int arg1 ) { List < Block > bl = this . livingEntity . getLineOfSight ( arg0 , arg1 ) ; for ( Block b : bl ) { b = new LizaCraftBlock ( b ) ; } return bl ; } @ Override public int getMaxHealth ( ) { return this . livingEntity . getMaxHealth ( ) ; } @ Override public int getMaximumAir ( ) { return this . livingEntity . getMaximumAir ( ) ; } @ Override public int getMaximumNoDamageTicks ( ) { return this . livingEntity . getMaximumNoDamageTicks ( ) ; } @ Override public int getNoDamageTicks ( ) { return this . livingEntity . getNoDamageTicks ( ) ; } @ Override public int getRemainingAir ( ) { return this . livingEntity . getRemainingAir ( ) ; } @ Override public LizaBlock getTargetBlock ( HashSet < Byte > arg0 , int arg1 ) { return new LizaCraftBlock ( this . livingEntity . getTargetBlock ( arg0 , arg1 ) ) ; } @ Override public Vehicle getVehicle ( ) { return this . livingEntity . getVehicle ( ) ; } @ Override public boolean isInsideVehicle ( ) { return this . livingEntity . isInsideVehicle ( ) ; } @ Override public boolean leaveVehicle ( ) { return this . livingEntity . leaveVehicle ( ) ; } @ Override public void setHealth ( int arg0 ) { this . livingEntity . setHealth ( arg0 ) ; } @ Override public void setLastDamage ( int arg0 ) { this . livingEntity . setLastDamage ( arg0 ) ; } @ Override public void setMaximumAir ( int arg0 ) { this . livingEntity . setMaximumAir ( arg0 ) ; } @ Override public void setMaximumNoDamageTicks ( int arg0 ) { this . livingEntity . setMaximumNoDamageTicks ( arg0 ) ; } @ Override public void setNoDamageTicks ( int arg0 ) { this . livingEntity . setNoDamageTicks ( arg0 ) ; } @ Override public void setRemainingAir ( int arg0 ) { this . livingEntity . setRemainingAir ( arg0 ) ; } @ Override public Arrow shootArrow ( ) { return this . livingEntity . shootArrow ( ) ; } @ Override public Egg throwEgg ( ) { return this . livingEntity . throwEgg ( ) ; } @ Override public Snowball throwSnowball ( ) { return this . livingEntity . throwSnowball ( ) ; } @ Override public boolean eject ( ) { return this . livingEntity . eject ( ) ; } @ Override public int getEntityId ( ) { return this . livingEntity . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . livingEntity . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . livingEntity . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . livingEntity . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . livingEntity . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . livingEntity . getFireTicks ( ) ; } @ Override public List < Entity > getNearbyEntities ( double arg0 ,", "gt": "double arg1 , double arg2 )", "prediction": "int arg1 )\n", "label": 0}
{"id": 13390, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . Connection ; import java . sql . SQLException ; import oracle . jdbc . pool . OracleDataSource ; public class DemoConnectionFactory { public static Connection getHRConnection ( String [ ] args ) throws SQLException { return getConnection ( args , \"hr\" , \"hr\" ) ; } public static Connection getConnection ( String [ ] args , String user , String password ) throws SQLException { String url = \"jdbc:oracle:oci8:@\" ; try { String url1 = System . getProperty ( \"JDBC_URL\" ) ; if ( url1 != null ) url = url1 ; } catch ( Exception e ) { } OracleDataSource ods = new OracleDataSource ( ) ; ods . setUser ( user ) ; ods . setPassword ( password ) ;", "gt": "ods . setURL ( url ) ;", "prediction": "try\n", "label": 1}
{"id": 2571, "input": "<s> package org . xbill . DNS ; public final class Credibility { private Credibility ( ) { } public static final int HINT = 0 ; public static final int ADDITIONAL = 1 ; public static final int GLUE = 2 ; public static final int NONAUTH_AUTHORITY = 3 ; public static final int NONAUTH_ANSWER = 3 ; public static final int AUTH_AUTHORITY = 4 ; public static final int AUTH_ANSWER = 4 ; public static final int ZONE = 5 ; public static final int NORMAL = 3 ; public static", "gt": "final int ANY = 1 ;", "prediction": "final int NORMAL = 4 ;\n", "label": 0}
{"id": 13392, "input": "<s> package org . eclipse . ui . tests . api ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . IParameter ; import org . eclipse . core . commands . Parameterization ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . IEditorActionDelegate ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IObjectActionDelegate ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . IWorkbenchWindowActionDelegate ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . handlers . IHandlerService ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class GenericCommandActionDelegate implements IWorkbenchWindowActionDelegate , IViewActionDelegate , IEditorActionDelegate , IObjectActionDelegate , IExecutableExtension { public static final String PARM_COMMAND_ID = \"commandId\" ; private String commandId = null ; private Map parameterMap = null ; private ParameterizedCommand parameterizedCommand = null ; private IHandlerService handlerService = null ; public void dispose ( ) { handlerService = null ; parameterizedCommand = null ; parameterMap = null ; } public void run ( IAction action ) { if ( handlerService == null ) { return ; } try { if ( commandId != null ) { handlerService . executeCommand ( commandId , null ) ; } else if ( parameterizedCommand != null ) { handlerService . executeCommand ( parameterizedCommand , null ) ; } } catch ( Exception e ) { } } public void selectionChanged ( IAction action , ISelection selection ) { } public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) throws CoreException { String id = config . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ; if ( data instanceof String ) { commandId = ( String ) data ; } else if ( data instanceof Map ) { parameterMap = ( Map ) data ; if ( parameterMap . get ( PARM_COMMAND_ID ) == null ) { Status status = new Status ( IStatus . ERROR , \"org.eclipse.ui.tests\" , \"The '\" + id + \"'", "gt": "action won't work without a commandId\" ) ;", "prediction": "does not exist\" ) ;\n", "label": 1}
{"id": 2336, "input": "<s> class T < X > { class U < Y > extends T < X > { < B > U ( ) { < Object > super ( ) ; } U ( int i ) { < Object > this ( ) ; } } class V < Z > extends U < Z > { < C > V ( T < X > t ) { t . < Object > super ( ) ; } } < A > T ( ) { } < K > void f ( K k ) { this . < Object > f ( \"\" ) ; } public static void main ( String [ ] args ) { T < Integer > x = new < Object > T", "gt": "< Integer > ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13414, "input": "<s> package com . yahoo . ycsb . db ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . UnknownHostException ; import java . util . LinkedList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import net . spy . memcached . CASResponse ; import net . spy . memcached . MemcachedClient ; import com . yahoo . ycsb . memcached . Memcached ; public class MembaseClient extends Memcached { MemcachedClient client ; public static final String VERBOSE = \"memcached.verbose\" ; public static final String VERBOSE_DEFAULT = \"true\" ; public static final String SIMULATE_DELAY = \"memcached.simulatedelay\" ; public static final String SIMULATE_DELAY_DEFAULT = \"0\" ; public static final String MEMCACHED_ADDRESS = \"memcached.address\" ; public static final String MEMCACHED_ADDRESS_DEFAULT = \"10.2.1.67\" ; public static final String MEMBASE_BUCKET = \"membase.bucket\" ; public static final String MEMBASE_BUCKET_DEFAULT = \"default\" ; public static final String MEMBASE_PASSWORD = \"membase.password\" ; public static final String MEMBASE_PASSWORD_DEFAULT = \"\" ; public static long endtime ; Random random ; boolean verbose ; int todelay ; public MembaseClient ( ) { random = new Random ( ) ; todelay = 0 ; } public void init ( ) { String address = getProperties ( ) . getProperty ( MEMCACHED_ADDRESS , MEMCACHED_ADDRESS_DEFAULT ) ; String bucketName = getProperties ( ) . getProperty ( MEMBASE_BUCKET , MEMBASE_BUCKET_DEFAULT ) ; String password = getProperties ( ) . getProperty ( MEMBASE_PASSWORD , MEMBASE_PASSWORD_DEFAULT ) ; verbose = Boolean . parseBoolean ( getProperties ( ) . getProperty ( VERBOSE , VERBOSE_DEFAULT ) ) ; todelay = Integer . parseInt ( getProperties ( ) . getProperty ( SIMULATE_DELAY , SIMULATE_DELAY_DEFAULT ) ) ; try { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( new URI ( \"http://\" + address + \":8091/pools\" ) ) ; client = new MemcachedClient ( uris , bucketName , password ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } } public void cleanup ( ) { if ( client . isAlive ( ) ) client . shutdown ( ) ; } @ Override public int add ( String key , Object value ) { try { if ( ! client . add ( key , 0 , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out . println ( \"ADD Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"ADD Execution\" ) ; } catch ( RuntimeException e ) { System . out . println ( \"ADD Runtime\" ) ; } return 0 ; } @ Override public int get ( String key , Object value ) { Future < Object > f = client . asyncGet ( key ) ; try { if ( f . get ( ) == null ) { System . out . println ( \"Error\" ) ; return - 1 ; } } catch ( InterruptedException e ) { System . out . println ( \"GET Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"GET Execution\" ) ; e . printStackTrace ( ) ; return - 2 ; } catch ( RuntimeException e ) { System . out . println ( \"GET Runtime\" ) ; return - 3 ; } return 0 ; } @ Override public int set ( String key , Object value ) { try { if ( ! client . set ( key , 0 , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out . println ( \"SET Interrupted\" ) ; } catch ( ExecutionException e ) { System . out . println ( \"SET Execution\" ) ; } catch ( RuntimeException e ) { System . out . println ( \"SET Runtime\" ) ; } return 0 ; } private byte [ ] ipv4AddressToByte ( String address ) { byte [ ] b = new byte [ 4 ] ; String [ ] str = address . split ( \"\\\\.\" ) ; b [ 0 ] = Integer . valueOf ( str [ 0 ] ) . byteValue ( ) ; b [ 1 ] = Integer . valueOf ( str [ 1 ] ) . byteValue ( ) ; b [ 2 ] = Integer . valueOf ( str [ 2 ] ) . byteValue ( ) ; b [ 3 ] = Integer . valueOf ( str [ 3 ] ) . byteValue ( ) ; return b ; } @ Override public int append ( String key , long cas , Object value ) { try { if ( ! client . append ( cas , key , value ) . get ( ) . booleanValue ( ) ) return - 1 ; } catch ( InterruptedException e ) { System . out .", "gt": "println ( \"APPEND Interrupted\" ) ;", "prediction": "println ( \"EOF\" ) ;\n", "label": 1}
{"id": 7562, "input": "<s> package hudson . plugins . dimensionsscm ; import hudson . plugins . dimensionsscm . DimensionsChangeSet ; import hudson . plugins . dimensionsscm . DimensionsChangeSetList ; import hudson . plugins . dimensionsscm . Logger ; import org . apache . commons . digester . Digester ; import org . apache . commons . io . IOUtils ; import org . xml . sax . SAXException ; import hudson . model . AbstractBuild ; import hudson . scm . ChangeLogParser ; import hudson . util . Digester2 ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . Reader ; import java . util . ArrayList ; import java . util . List ; public class DimensionsChangeLogParser extends ChangeLogParser { @ Override public DimensionsChangeSetList parse ( AbstractBuild build , File changelogFile ) throws IOException , SAXException { Logger . Debug ( \"Looking for '\" + changelogFile . getPath ( ) + \"'\" ) ; if ( ! changelogFile . exists ( ) ) { Logger . Debug ( \"Change log file does not exist\" ) ; throw new IOException ( \"Specified change log file does not exist - \" + changelogFile . getPath ( ) ) ; } else { FileReader reader = new FileReader ( changelogFile ) ; try { return parse ( build , reader ) ; } finally { IOUtils . closeQuietly ( reader ) ; } } } public DimensionsChangeSetList parse ( AbstractBuild build , FileReader reader ) throws IOException , SAXException { List < DimensionsChangeSet > changesetList = new ArrayList < DimensionsChangeSet > ( ) ; Digester digester = new Digester2 ( ) ; digester . push ( changesetList ) ; digester . addObjectCreate ( \"*/changeset\" , DimensionsChangeSet . class ) ; digester . addSetProperties ( \"*/changeset\" ) ; digester . addBeanPropertySetter ( \"*/changeset/date\" , \"dateString\" ) ; digester . addBeanPropertySetter ( \"*/changeset/user\" ) ; digester . addBeanPropertySetter ( \"*/changeset/comment\" ) ; digester . addSetNext ( \"*/changeset\" , \"add\" ) ; digester . addObjectCreate ( \"*/changeset/items/item\" , DimensionsChangeSet . DmFiles . class ) ; digester . addSetProperties ( \"*/changeset/items/item\" ) ; digester . addBeanPropertySetter ( \"*/changeset/items/item\" , \"file\" ) ; digester . addSetNext ( \"*/changeset/items/item\" , \"add\" ) ; digester . addObjectCreate ( \"*/changeset/requests/request\" , DimensionsChangeSet . DmRequests . class ) ; digester", "gt": ". addSetProperties ( \"*/changeset/requests/request\" ) ;", "prediction": ". addSetProperties ( \"*/changeset/requests/request\" ) ;\n", "label": 0}
{"id": 13416, "input": "<s> package org . restlet . ext . oauth ; public enum GrantType { assertion ,", "gt": "authorization_code , none , password , refresh_token ;", "prediction": "authorization , authToken ;\n", "label": 1}
{"id": 5692, "input": "<s> package com . matburt . mobileorg . Settings . Synchronizers ; import android . content . Intent ; import android . content . SharedPreferences ; import android . content . SharedPreferences . OnSharedPreferenceChangeListener ; import android . os . Bundle ; import android . preference . Preference ; import android . preference . Preference . OnPreferenceClickListener ; import android . preference . PreferenceActivity ; import android . preference . PreferenceManager ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Synchronizers . DropboxAuthActivity ; public class DropboxSettingsActivity extends PreferenceActivity implements OnPreferenceClickListener , OnSharedPreferenceChangeListener { private Preference triggerLogin ; public static final String KEY_DROPBOX_PATH = \"dropboxPath\" ; @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . dropbox_preferences ) ; triggerLogin = ( Preference ) findPreference ( \"dropboxLogin\" ) ; triggerLogin . setOnPreferenceClickListener ( this ) ; setPreferenceSummary ( PreferenceManager . getDefaultSharedPreferences ( this ) , KEY_DROPBOX_PATH ) ; } @ Override public void onPause ( ) { getPreferenceScreen ( ) . getSharedPreferences ( ) . unregisterOnSharedPreferenceChangeListener ( this ) ; super . onPause ( ) ; } @ Override public void onResume ( ) { super . onResume ( ) ; getPreferenceScreen ( ) . getSharedPreferences ( ) . registerOnSharedPreferenceChangeListener ( this ) ; } @ Override public void onSharedPreferenceChanged ( SharedPreferences sharedPreferences , String key ) { setPreferenceSummary ( sharedPreferences , key ) ; } protected void setPreferenceSummary ( SharedPreferences sharedPreferences , String key ) { Preference pref = findPreference ( key ) ; if ( pref != null ) { if ( key . equals ( KEY_DROPBOX_PATH ) ) { String value = sharedPreferences . getString ( key , \"\" ) ; pref . setSummary ( value ) ; } } } public boolean onPreferenceClick ( Preference p ) { if ( p == this . triggerLogin ) { Intent loginIntent = new Intent", "gt": "( this , DropboxAuthActivity . class ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13418, "input": "<s> package br . org . archimedes . orto ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.orto.messages\" ; public static String ActivateTooltip ; public static String DeactivateTooltip ; public static String OrtoName ;", "gt": "public static String OrtoOff ;", "prediction": "}\n", "label": 1}
{"id": 2380, "input": "<s> class Neg04eff_final { static class A extends Exception { } static class B extends Exception { } void test ( ) throws B { try { if ( true ) { throw new A ( ) ; } else if ( false ) { throw new B ( ) ; } else { throw ( Throwable ) new Exception ( ) ; } }", "gt": "catch ( A e )", "prediction": "}\n", "label": 0}
{"id": 13427, "input": "<s> package br . org . archimedes . intersectors ; import br . org . archimedes . Tester ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . intersections . interfaces . Intersector ; import br . org . archimedes . model . Point ; import org . junit . Assert ; import org . junit . Before ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import static org . junit . Assert . fail ; public class ArcArcIntersectorTest extends Tester { Arc baseArc ; Intersector intersector ; @ Before public void setUp ( ) throws NullArgumentException , InvalidArgumentException { intersector = new ArcArcIntersector ( ) ; baseArc = new Arc ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , 1.0 ) , new Point ( 2.0 , 0.0 ) ) ; } @ Test public void nullArgumentsShouldThrowNullArgumentException ( ) { try { intersector . getIntersections ( baseArc , null ) ; fail ( \"The otherElement is null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } try { intersector . getIntersections ( null , baseArc ) ; fail ( \"The element is null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } try { intersector . getIntersections ( null , null ) ; fail ( \"Both elements are null and getIntersections should have thrown a NullArgumentException\" ) ; } catch ( NullArgumentException e ) { } Assert . assertTrue ( \"Threw all exceptions it should throw.\" , true ) ; } @ Test public void notIntersectingArcsShouldReturnNoIntersections ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 1.0 , 0.5 ) , new Point ( 2.0 , - 0.5 ) , new Point ( 3.0 , 0.5 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void noIntersectionPointsButWouldIfArcExtendedReturnsNoIntersections ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 4.0 , 0.0 ) , new Point ( 3.0 , 1.0 ) , new Point ( 1.0 , 1.1 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void tangentArcInsideOnLimitReturnsNoIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 1.0 , 0.9 ) , new Point ( 1.9 , 0.1 ) , new Point ( 2.0 , 0.0 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void tangentArcOutsideReturnsOneIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 0.0 , 2.0 ) , new Point ( 1.0 , 1.0 ) , new Point ( 2.0 , 2.0 ) ) ; assertCollectionTheSame ( Collections . singleton ( new Point ( 1.0 , 1.0 ) ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcCompletesACircleReturnsTwoIntersectionPoints ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , - 1.0 ) , new Point ( 2.0 , 0.0 ) ) ; Collection < Point > expected = new ArrayList < Point > ( ) ; expected . add ( new Point ( 0.0 , 0.0 ) ) ; expected . add ( new Point ( 2.0 , 0.0 ) ) ; assertCollectionTheSame ( expected , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcAlmostCompletesACircleReturnsOneIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , - 1.0 ) , new Point ( 1.0 + Math . sqrt ( 3 ) / 2 , - 0.5 ) ) ; Collection < Point > expected = new ArrayList < Point > ( ) ; expected . add ( new Point ( 0.0 , 0.0 ) ) ; assertCollectionTheSame ( expected , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcsCompletesACircleAndBypassAnExtremePointReturnsNoIntersectionPoints ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , - 1.0 ) , new Point ( 1.0 , 1.0 ) ) ; assertCollectionTheSame ( Collections . emptyList ( ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcCrossesArcReturnsTwoIntersectionPoints ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 0.0 , 1.0 ) , new Point ( 1.0 , 0.0 ) , new Point ( 2.0 , 1.0 ) ) ; Collection < Point > expected = new ArrayList < Point > ( ) ; expected . add ( new Point ( 1.0 - Math . sqrt ( 3.0 ) / 2.0 , 0.5 ) ) ; expected . add ( new Point ( 1.0 + Math . sqrt ( 3.0 ) / 2.0 , 0.5 ) ) ; assertCollectionTheSame ( expected , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcCrossesOneSideReturnsOneIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 2.0 , 2.0 ) , new Point ( 1.0 , 1.0 ) , new Point ( 1.5 , 0.5 ) ) ; assertCollectionTheSame ( Collections . singleton ( new Point ( 1.0 , 1.0 ) ) , intersector . getIntersections ( arc , baseArc ) ) ; } @ Test public void arcCompletesWaveReturnsOneIntersectionPoint ( ) throws NullArgumentException , InvalidArgumentException { Arc arc = new Arc ( new Point ( 2.0 , 0.0 ) , new Point ( 3.0 , - 1.0 )", "gt": ", new Point ( 4.0 , 0.0 ) ) ;", "prediction": ", new Point ( 2.0 , 0.0 ) ) ;\n", "label": 1}
{"id": 8303, "input": "<s> public class T6751514 { static class Foo < X > { X x ; Foo ( X x ) { this . x = x ; } } static void test1 ( Foo < Integer > foo ) { int start = foo . x ; equals ( foo . x += 1 , start + 1 ) ; equals ( foo . x ++ , start + 1 ) ; equals ( ++ foo . x , start + 3 ) ; equals ( foo . x -- , start + 3 ) ; equals ( foo . x -= 1 , start + 1 ) ; equals ( -- foo . x , start ) ; } static void test2 ( Foo < Integer > foo ) { int start = foo . x ; equals ( ( foo . x ) += 1 , start + 1 ) ; equals ( ( foo . x ) ++ , start + 1 ) ; equals ( ++ ( foo . x ) , start + 3 ) ; equals ( ( foo . x ) -- , start + 3 ) ; equals ( ( foo . x ) -= 1 , start + 1 ) ; equals ( -- ( foo . x ) , start ) ; } static void test3 ( Foo < Integer > foo ) { int start = foo . x ; equals ( ( ( foo . x ) ) += 1 , start + 1 ) ; equals ( ( ( foo . x ) ) ++ , start + 1 ) ; equals ( ++ ( ( foo . x ) ) , start + 3 ) ; equals ( ( ( foo . x ) ) -- , start + 3 ) ; equals ( ( ( foo . x ) ) -= 1 , start + 1 ) ; equals ( -- ( ( foo . x ) ) , start ) ; } public static void main ( String [ ] args ) { test1 ( new Foo < Integer > ( 1 ) ) ; test2 (", "gt": "new Foo < Integer > ( 1 ) ) ;", "prediction": "new Foo < Integer > ( 2 ) ) ;\n", "label": 0}
{"id": 13430, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . MediaType ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . providers . TextCrazyPersonProvider ; import org . restlet . test . ext . jaxrs . services . resources . OwnProviderTestService ; import org . restlet . test . ext . jaxrs . util . TestUtils ; public class OwnProviderTest extends JaxRsTestCase { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) protected Application getApplication ( ) { final Application appConfig = new Application ( ) { @ Override public Set < Object > getSingletons ( ) { return ( Set ) TestUtils . createSet ( new TextCrazyPersonProvider ( ) ) ; } @ Override public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( OwnProviderTestService . class ) ; } } ; return appConfig ; } public void test1 ( ) throws Exception { final Response response = get ( ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEqualMediaType ( new MediaType ( \"text/crazy-person\" ) , response ) ; final String actualEntity = response . getEntity ( ) . getText ( ) ; final String expectedEntity = \"abc def is crazy.\\nHeader value for name h1 is h1v\" ;", "gt": "assertEquals ( expectedEntity , actualEntity ) ;", "prediction": "assertEquals ( expectedEntity , actualEntity ) ;\n", "label": 1}
{"id": 3134, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . Giant ; import Liza . LizaGiant ; public class LizaCraftGiant extends LizaCraftMonster implements LizaGiant { public LizaCraftGiant ( Giant giant ) { super ( giant ) ; } @ Override", "gt": "public Giant getBukkitHandle ( )", "prediction": "public void setUp ( ) throws Exception\n", "label": 0}
{"id": 13431, "input": "<s> package org . eclipse . rap . rwt . internal . protocol ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Set ; import org . eclipse . rap . rwt . internal . theme . JsonArray ; import org . eclipse . rap . rwt . internal . theme . JsonValue ; final class Operation { private final String action ; private final String target ; private final Map < String , Object > details ; private final Map < String , JsonValue > properties ; Operation ( String target , String action ) { this . target = target ; this . action = action ; details = new LinkedHashMap < String , Object > ( ) ; properties = new LinkedHashMap < String , JsonValue > ( ) ; } String getTarget ( ) { return target ; } String getAction ( ) { return action ; } void appendProperty ( String key , JsonValue value ) { if ( properties . containsKey ( key ) ) { throw new IllegalArgumentException ( \"Duplicate property \" + key ) ; } properties . put ( key , value ) ; } void appendProperties ( Map < String , Object > properties ) { if ( properties != null && ! properties . isEmpty ( ) ) { Set < String > keySet = properties . keySet ( ) ; for ( String key : keySet ) { appendProperty ( key , JsonUtil . createJsonValue ( properties . get ( key ) ) ) ; } } } Object getDetail ( String key ) { return details . get ( key ) ; } void appendDetail ( String key , Object value ) { if ( details . containsKey ( key ) ) { throw new IllegalArgumentException ( \"Duplicate detail \" + key ) ; } replaceDetail ( key , value ) ; } void replaceDetail ( String key , Object value ) { details . put ( key , value ) ; } JsonValue toJson ( ) { JsonArray json = new JsonArray ( ) ; json . append ( action ) ; json . append ( target ) ; if ( ! details . isEmpty ( ) ) { Set < String > keySet = details . keySet ( ) ; for ( String key : keySet ) { json . append ( JsonUtil . createJsonValue ( details . get ( key ) ) ) ; } } if ( ! properties . isEmpty ( ) ) { JsonValue jsonObject", "gt": "= JsonUtil . createJsonObject ( properties ) ;", "prediction": "= new JsonObject ( ) ;\n", "label": 1}
{"id": 531, "input": "<s> import java . io . IOException ; import com . sun . javadoc . * ; public class Main extends Tester . Doclet { private static final Tester tester = new Tester ( \"Main\" , \"pkg1\" ) ; public static void main ( String [ ] args ) throws IOException { tester . run ( ) ; tester . verify ( ) ; } public static boolean start ( RootDoc root ) { try { for ( PackageDoc p : root . specifiedPackages ( ) ) { for ( AnnotationTypeDoc a : p . annotationTypes ( ) ) { for ( AnnotationTypeElementDoc e : a . elements ( ) ) { tester . printAnnotationTypeElement ( e ) ; } tester . println ( ) ; } for ( ClassDoc e : p . enums ( ) ) { for (", "gt": "FieldDoc ec : e . enumConstants ( ) )", "prediction": "AnnotationTypeDoc e : e . elements ( ) )\n", "label": 0}
{"id": 13434, "input": "<s> package org . apache . lucene . util ; import java . io . Serializable ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; public abstract class AttributeImpl implements Cloneable , Serializable , Attribute { public abstract void clear ( ) ; public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; Class clazz = this . getClass ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; try { for ( int i = 0 ; i < fields . length ; i ++ ) { Field f = fields [ i ] ; if ( Modifier . isStatic ( f . getModifiers ( ) ) ) continue ; f . setAccessible ( true ) ; Object value = f . get ( this ) ; if ( buffer . length ( ) > 0 ) { buffer . append ( ',' ) ; } if ( value == null ) { buffer . append ( f . getName ( ) + \"=null\" ) ; } else { buffer . append (", "gt": "f . getName ( ) + \"=\" + value ) ;", "prediction": "'=' ) ;\n", "label": 1}
{"id": 3264, "input": "<s> package org . jjflyboy . tjpeditor . scoping ; import static java . util . Collections . singletonList ; import java . util . List ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . xtext . naming . QualifiedName ; import org . eclipse . xtext . resource . IEObjectDescription ; import org . eclipse . xtext . resource . ISelectable ; import org . eclipse . xtext . scoping . IGlobalScopeProvider ; import org . eclipse . xtext . scoping . IScope ; import org . eclipse . xtext . scoping . impl . ImportNormalizer ; import org . eclipse . xtext . scoping . impl . ImportScope ; import org . eclipse . xtext . scoping . impl . ImportedNamespaceAwareLocalScopeProvider ; import org . eclipse . xtext . scoping . impl . SelectableBasedScope ; import org . jjflyboy . tjpeditor . project . Global ; import com . google . common . base . Predicate ; import com . google . inject . Inject ; public class ProjectImportedNamespaceAwareLocalScopeProvider extends ImportedNamespaceAwareLocalScopeProvider implements IProjectScopeProvider { @ Inject private IGlobalScopeProvider globalScopeProvider ; @ Override public IScope getScope ( EObject context , EReference reference , EObject originalContext ) { if ( context == null ) throw new NullPointerException ( \"context\" ) ; IScope result = null ; EObject refcontainer = reference . eContainer ( ) ; if ( context . eContainer ( ) != null ) { result = getScope ( context . eContainer ( ) , reference , originalContext ) ; } else { result = getResourceScope ( context . eResource ( ) , reference , originalContext ) ; } return getLocalElementsScope ( result , context , reference , originalContext ) ; } @ Override public IScope getScope ( EObject context , EReference reference ) { return getScope ( context , reference , context ) ; } protected IScope getResourceScope ( Resource res , EReference reference , EObject originalContext ) { EObject context = res . getContents ( ) . get ( 0 ) ; IScope globalScope = getGlobalScope ( res , reference , originalContext ) ; List < ImportNormalizer > normalizers = getImplicitImports ( isIgnoreCase ( reference ) ) ; if ( ! normalizers . isEmpty ( ) ) { globalScope = createImportScope ( globalScope , normalizers , null , reference . getEReferenceType ( ) , isIgnoreCase ( reference ) ) ; } return getResourceScope ( globalScope , context , reference ) ; } protected IScope getResourceScope ( final IScope parent , final EObject context , final EReference reference ) { if ( context . eResource ( ) == null ) return parent ; ISelectable allDescriptions = getAllDescriptions ( context . eResource ( ) ) ; return ProjectSelectableBasedScope . createScope ( parent , allDescriptions , reference . getEReferenceType ( ) , isIgnoreCase ( reference ) ) ; } protected IScope getGlobalScope ( final Resource context ,", "gt": "final EReference reference , EObject originalContext )", "prediction": "final EObject reference )\n", "label": 0}
{"id": 13443, "input": "<s> package org . fuzzydb . server . internal . search ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . Scorer ; public class ResultsQ extends Q < NextItem > { private int resultsQAdded = 0 ; private volatile Score currentScoreThreshold ; private final int targetNumResults ; public ResultsQ ( final int maxNonMatches , final float scoreThreshold , int targetNumResults ) { this . targetNumResults = targetNumResults ; this . currentScoreThreshold = new Score ( ) { private static final long serialVersionUID = 1L ; @ Override public void add ( Scorer s , float score , Direction d ) { throw new UnsupportedOperationException ( ) ; } @ Override protected void update ( ) { this . linear = scoreThreshold ; this . nonMatches = maxNonMatches ; } } ; } @ Override final public void", "gt": "add ( NextItem newItem )", "prediction": "remove ( )\n", "label": 1}
{"id": 2479, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Work extends NewTaskAttribute , TaskTimesheetAttribute { float getValue ( ) ; void setValue ( float value ) ; WorkQuantityUnit getUnit ( ) ;", "gt": "void setUnit ( WorkQuantityUnit value ) ;", "prediction": "}\n", "label": 0}
{"id": 13447, "input": "<s> package com . cloudera . sqoop ; import org . apache . hadoop . conf . Configuration ; public class ConnFactory extends org . apache . sqoop . ConnFactory { public static final String FACTORY_CLASS_NAMES_KEY = org . apache . sqoop . ConnFactory . FACTORY_CLASS_NAMES_KEY ; public static final String DEFAULT_FACTORY_CLASS_NAMES = org . apache . sqoop", "gt": ". ConnFactory . DEFAULT_FACTORY_CLASS_NAMES ;", "prediction": ". ConnFactory . FACTORY_CLASS_NAMES ;\n", "label": 1}
{"id": 5387, "input": "<s> package org . ofbiz . content ; import java . math . BigDecimal ; import java . nio . ByteBuffer ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . content . content . ContentServices ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . ModelUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . security . Security ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceAuthException ; import org . ofbiz . service . ServiceUtil ; import com . ibm . icu . util . Calendar ; public class ContentManagementServices { public static final String module = ContentManagementServices . class . getName ( ) ; public static final String resource = \"ContentUiLabels\" ; public static Map < String , Object > getSubContent ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String contentId = ( String ) context . get ( \"contentId\" ) ; String subContentId = ( String ) context . get ( \"subContentId\" ) ; String mapKey = ( String ) context . get ( \"mapKey\" ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Timestamp fromDate = ( Timestamp ) context . get ( \"fromDate\" ) ; List < String > assocTypes = UtilGenerics . checkList ( context . get ( \"assocTypes\" ) ) ; String assocTypesString = ( String ) context . get ( \"assocTypesString\" ) ; if ( UtilValidate . isNotEmpty ( assocTypesString ) ) { List < String > lst = StringUtil . split ( assocTypesString , \"|\" ) ; if ( assocTypes == null ) { assocTypes = FastList . newInstance ( ) ; } assocTypes . addAll ( lst ) ; } GenericValue content = null ; GenericValue view = null ; try { view = ContentWorker . getSubContentCache ( delegator , contentId , mapKey , subContentId , userLogin , assocTypes , fromDate , Boolean . FALSE , null ) ; content = ContentWorker . getContentFromView ( view ) ; } catch ( GenericEntityException e ) { return ServiceUtil . returnError ( e . toString ( ) ) ; } Map < String , Object > results = ServiceUtil . returnSuccess ( ) ; results . put ( \"view\" , view ) ; results . put ( \"content\" , content ) ; return results ; } public static Map < String , Object > getContent ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String contentId = ( String ) context . get ( \"contentId\" ) ; GenericValue view = null ; try { view = ContentWorker . getContentCache ( delegator , contentId ) ; } catch ( GenericEntityException e ) { return ServiceUtil .", "gt": "returnError ( e . toString ( ) ) ;", "prediction": "returnError ( e . toString ( ) ) ;\n", "label": 0}
{"id": 13450, "input": "<s> package org . nuxeo . ecm . platform . publisher . test ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinder ; import org . nuxeo . ecm . platform . publisher . helper . RootSectionFinderFactory ; public class SampleRootSectionFinderFactory implements RootSectionFinderFactory { @ Override public RootSectionFinder", "gt": "getRootSectionFinder ( CoreSession session )", "prediction": "getRootSectionFactory ( )\n", "label": 1}
{"id": 7036, "input": "<s> package com . redhat . ceylon . compiler . java . test . issues . bug02xx ; public abstract class Bug233_Java { public Bug233_Java ( Bug233_Type arg ) { } public abstract Bug233_Type", "gt": "f ( Bug233_Type arg ) ;", "prediction": "getType ( )\n", "label": 0}
{"id": 13457, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . io . Serializable ; import org . apache . lucene . index . IndexReader ; public abstract class Weight implements Serializable { public abstract Explanation explain ( IndexReader reader , int doc ) throws IOException ; public abstract Query getQuery ( ) ;", "gt": "public abstract float getValue ( ) ;", "prediction": "}\n", "label": 1}
{"id": 843, "input": "<s> package com . mcbans . mcbans . api ; import com . mcbans . mcbans . MCBansPlugin ; import java . util . HashMap ; public class MCBansPluginManager { private MCBansPlugin plugin ; private HashMap < Character , FlagHandler > flags = new HashMap < Character , FlagHandler > ( ) ; public MCBansPluginManager ( MCBansPlugin plugin ) { this . plugin = plugin ; } public FlagHandler getHandler ( char flag ) { return flags . get ( flag ) ; } public FlagHandler registerHandler", "gt": "( char flag , FlagHandler handler )", "prediction": "( char flag )\n", "label": 0}
{"id": 13458, "input": "<s> package org . seage . metaheuristic . particles ; public class ParticleSwarmEvent extends java . util . EventObject { private static final long serialVersionUID = - 6183156859352794637L ; public ParticleSwarmEvent ( Object source ) {", "gt": "super ( source ) ;", "prediction": "super ( source ) ;\n", "label": 1}
{"id": 3091, "input": "<s> package org . ofbiz . service . rmi ; import java . rmi . Naming ; import java . rmi . NotBoundException ; import java . rmi . RemoteException ; import java . util . Map ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; import org . ofbiz . service . engine . GenericAsyncEngine ; public class RmiServiceEngine extends GenericAsyncEngine { public RmiServiceEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } @ Override public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { return run ( modelService , context ) ; } @ Override public void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { run ( modelService , context ) ; } protected Map < String , Object > run ( ModelService service , Map < String , Object > context ) throws GenericServiceException { RemoteDispatcher rd = null ; try { rd = ( RemoteDispatcher ) Naming . lookup ( this . getLocation ( service ) ) ; } catch ( NotBoundException e ) { throw new GenericServiceException ( \"RemoteDispatcher not bound to : \" + service . location , e ) ; } catch ( java . net . MalformedURLException e ) { throw new GenericServiceException ( \"Invalid format for location\" ) ; } catch ( RemoteException e ) { throw new GenericServiceException ( \"RMI Error\" , e ) ; } Map < String , Object > result = null ; if ( rd != null ) { try { result = rd . runSync ( service . invoke , context ) ; } catch ( RemoteException e ) { throw new GenericServiceException ( \"RMI Invocation Error\" , e ) ; } } else { throw new GenericServiceException ( \"RemoteDispatcher came", "gt": "back as null\" ) ;", "prediction": "from: \" + service . location , e ) ;\n", "label": 0}
{"id": 13460, "input": "<s> package org . fuzzydb . dto . attributes ; import java . io . Serializable ; public abstract class Attribute < V > implements Serializable { private static final long serialVersionUID = 1L ; private String name ; public Attribute ( String name ) { assert name != null ; this . name = name ; } public String getName ( ) { return name ; } public void", "gt": "setName ( String name )", "prediction": "setName ( String name )\n", "label": 1}
{"id": 7200, "input": "<s> @ CompilerAnnotationTest ( @ CompilerAnnotationTest2 ( name = \"test\" , name2 = \"test2\" )", "gt": ") public @ interface CompilerAnnotationTest", "prediction": "public class TestTest extends TestCase\n", "label": 0}
{"id": 13462, "input": "<s> package vanilla . java . affinity . impl ; import org . junit . Assume ; import org . junit . BeforeClass ; import vanilla . java . affinity . IAffinity ; public class NativeAffinityTest extends AbstractAffinityImplTest { @", "gt": "BeforeClass public static void checkJniLibraryPresent ( )", "prediction": "BeforeClass public void setUp ( ) throws Exception\n", "label": 1}
{"id": 8730, "input": "<s> package objects ; import java . awt . Color ; import java . awt . Point ; import java . awt . Rectangle ; import javax . swing . JLabel ; public class AlbumLabel extends JLabel { public AlbumLabel ( String text , Point index , int width ) { super ( text , null , JLabel . LEADING ) ; setBounds ( getBounds ( index , width ) ) ; setForeground ( Color . WHITE ) ; } private Rectangle getBounds ( Point point , int width ) { int spacerSpaceX = 10 * ( point . x + 1 ) ; int spacerSpaceY = ( 100 * ( point . y + 1 ) ) ; int x = spacerSpaceX + ( width *", "gt": "point . x ) ;", "prediction": "spacerSpaceX ) ;\n", "label": 0}
{"id": 13463, "input": "<s> package com . symbol8 . moneytracker ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import com . symbol8 . moneytracker . domain . Account ; import com . symbol8 . moneytracker . domain . Transaction ; import com . symbol8 . moneytracker . domain . Transaction . Type ; public class AccountService { private static final Account CREDIT_CARD_ACCOUNT = new Account ( \"**** **** **** 7688\" ) ; private static final Account EVERY_DAY_ACCOUNT = new Account ( \"03 0881 0047975 000\" ) ; public List < Account > getAccounts ( ) { List < Account > accounts = new ArrayList < Account > ( ) ; accounts . add ( CREDIT_CARD_ACCOUNT ) ; accounts . add ( EVERY_DAY_ACCOUNT ) ; return accounts ; } public List < Transaction > getFilteredTransactions ( Account account , Calendar filterDate ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; if ( CREDIT_CARD_ACCOUNT . equals ( account ) ) { trans . addAll ( filter ( getCreditCardSavings ( ) , filterDate ) ) ; trans . addAll ( filter ( getCreditCardAprTransactions ( ) , filterDate ) ) ; } else if ( EVERY_DAY_ACCOUNT . equals ( account ) ) { trans . addAll ( filter ( getEveryDayAprTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayMarTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayFebTransactions ( ) , filterDate ) ) ; trans . addAll ( filter ( getEveryDayJanTransactions ( ) , filterDate ) ) ; } return trans ; } public List < Transaction > filter ( List < Transaction > trans , Calendar filterDate ) { List < Transaction > filterTrans = new ArrayList < Transaction > ( ) ; for ( Transaction tran : trans ) { if ( isCurrent ( tran , filterDate ) ) { filterTrans . add ( tran ) ; } } return filterTrans ; } public boolean isCurrent ( Transaction tran , Calendar filterDate ) { if ( tran . getActualPaymentDate ( ) == null ) { return true ; } if ( tran . getActualPaymentDate ( ) . after ( filterDate ) ) { return true ; } return false ; } public List < Transaction > getCreditCardSavings ( ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Car Savings\" , - 102.00 , true , Type . SAVINGS ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Power Savings - March\" , - 50.00 , true , Type . SAVINGS ) ) ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Power Savings - April\" , - 20.00 , true , Type . SAVINGS ) ) ; return trans ; } public List < Transaction > getCreditCardAprTransactions ( ) throws java . text . ParseException { List < Transaction > trans = new ArrayList < Transaction > ( ) ; String month = \"2011/04/\" ; trans . add ( new Transaction ( CREDIT_CARD_ACCOUNT , \"Car - Warrent & Wiper blades & Handbrake adjustment\" , toDate ( month , \"14\" ) , -", "gt": "116.00 , true ) ) ;", "prediction": "100 ) ) ;\n", "label": 1}
{"id": 889, "input": "<s> import java . util . * ; public class FooDepr { public", "gt": "void method ( Vector < Object > o )", "prediction": "static void main ( String [ ] args )\n", "label": 0}
{"id": 13466, "input": "<s> package org . eclipse . rap . demo . controls ; import java . lang . reflect . InvocationTargetException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . IInputValidator ; import org . eclipse . jface . dialogs . InputDialog ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . ProgressMonitorDialog ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . window . Window ; import org . eclipse . rap . rwt . widgets . DialogCallback ; import org . eclipse . rap . rwt . widgets . DialogUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . ColorDialog ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . FontDialog ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . MessageBox ; public class DialogsTab extends ExampleTab { private Label inputDlgResLabel ; private Label loginDlgResLabel ; private Label messageDlgResLabel ; private Label errorDlgResLabel ; private Label messageBoxDlgResLabel ; private Button okButton ; private Button cancelButton ; private Button yesButton ; private Button noButton ; private Button retryButton ; private Button abortButton ; private Button ignoreButton ; private Button iconErrorButton ; private Button iconInformationButton ; private Button iconQuestionButton ; private Button iconWarningButton ; private Button iconWorkingButton ; private Button noIconButton ; private Button showMessageBoxDlgButton ; private Button showColorDialogButton ; private Button showFontDialogButton ; protected boolean useDialogCallback ; public DialogsTab ( ) { super ( \"Dialogs\" ) ; } @ Override protected void createStyleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 1 , true ) ) ; createMessageBoxStyleControls ( parent ) ; } @ Override protected void createExampleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( ) ) ; Group group1 = new Group ( parent , SWT . NONE ) ; group1 . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; group1 . setText ( \"JFace Dialogs\" ) ; group1 . setLayout ( new GridLayout ( 3 , true ) ) ; Button showInputDlgButton = new Button ( group1 , SWT . PUSH ) ; showInputDlgButton . setText ( \"Input Dialog\" ) ; showInputDlgButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { showInputDialog ( ) ; } } ) ; showInputDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ; Button showProgressDlgButton = new Button ( group1 , SWT . PUSH ) ; showProgressDlgButton . setText ( \"ProgressDialog\" ) ; showProgressDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ; showProgressDlgButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent e ) { showProgressDialog ( ) ; } } ) ; insertSpaceLabels ( group1 , 1 ) ; inputDlgResLabel = new Label ( group1 , SWT . WRAP ) ; inputDlgResLabel . setText ( \"Result:\" ) ; GridData gdInputDlgResLabel = new GridData ( ) ; gdInputDlgResLabel . horizontalSpan = 3 ; inputDlgResLabel . setLayoutData ( gdInputDlgResLabel ) ; Button showMessageInfoDlgButton = new Button ( group1 , SWT . PUSH ) ; showMessageInfoDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ; showMessageInfoDlgButton . setText ( \"Info Message\" ) ; showMessageInfoDlgButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { showMessageDialogInfo ( ) ; } } ) ; Button showMessageWarningDlgButton = new Button ( group1 , SWT . PUSH ) ; showMessageWarningDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ; showMessageWarningDlgButton . setText ( \"Warning Dialog\" ) ; showMessageWarningDlgButton . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( final SelectionEvent event ) { showMessageDialogWarning ( ) ; } } ) ; Button showMessageErrorDlgButton = new Button ( group1 , SWT . PUSH ) ; showMessageErrorDlgButton . setLayoutData ( createGridDataFillBoth ( ) ) ; showMessageErrorDlgButton . setText ( \"Error Message\" ) ;", "gt": "showMessageErrorDlgButton . addSelectionListener ( new SelectionAdapter ( )", "prediction": "showMessageErrorDlgButton . addSelectionListener ( new SelectionAdapter ( )\n", "label": 1}
{"id": 756, "input": "<s> package com . pagosoft . plaf . themes ; import javax . swing . plaf . * ; import java . awt . * ; final class Colors { static final ColorUIResource GRAY_DARKEST = new ColorUIResource ( 64 , 64 , 64 ) ; static final ColorUIResource GRAY_DARKER = new ColorUIResource ( 82 , 82 , 82 ) ; static final ColorUIResource GRAY_DARK = new ColorUIResource ( 90 , 90 , 90 ) ; static final ColorUIResource GRAY_MEDIUMDARK = new ColorUIResource ( 110 , 110 , 110 ) ; static final ColorUIResource GRAY_MEDIUM = new ColorUIResource ( 128 , 128 , 128 ) ; static final ColorUIResource GRAY_MEDIUMLIGHT = new ColorUIResource ( 150 , 150 , 150 ) ; static final ColorUIResource GRAY_LIGHT = new ColorUIResource ( 170 , 170 , 170 ) ; static final ColorUIResource GRAY_LIGHTER = new ColorUIResource ( 220 , 220 , 220 ) ; static final ColorUIResource GRAY_LIGHTER2 = new ColorUIResource ( 230 , 230 , 230 ) ; static final ColorUIResource GRAY_LIGHTEST = new ColorUIResource ( 240 , 240 , 240 ) ; static final ColorUIResource BROWN_LIGHTEST = new ColorUIResource ( 242 , 241 , 238 ) ; static final ColorUIResource BLUE_LOW_MEDIUM = new ColorUIResource ( 166 , 202 , 240 ) ; static final ColorUIResource BLUE_LOW_LIGHTEST = new ColorUIResource ( 195 , 212 , 232 ) ; static final ColorUIResource BLUE_MEDIUM_DARKEST = new ColorUIResource ( 44 , 73 , 135 ) ; static final ColorUIResource BLUE_MEDIUM_DARK = new ColorUIResource ( 49 , 106 , 196 ) ; static final ColorUIResource BLUE_MEDIUM_MEDIUM = new ColorUIResource ( 85 , 115 , 170 ) ; static final ColorUIResource BLUE_MEDIUM_LIGHTEST = new ColorUIResource ( 172 , 210 , 248 ) ; static final ColorUIResource GREEN_LOW_DARK = new ColorUIResource ( 75 , 148 , 75 ) ; static final ColorUIResource GREEN_LOW_MEDIUM = new ColorUIResource ( 112 , 190 , 112 ) ; static final ColorUIResource GREEN_LOW_LIGHTEST = new ColorUIResource ( 200 , 222 , 200 ) ; static final ColorUIResource GREEN_CHECK = new ColorUIResource ( 33 , 161 , 33 ) ; static final ColorUIResource PINK_HIGH_DARK = new ColorUIResource ( 128 , 0 , 128 ) ; static final ColorUIResource PINK_LOW_DARK = new ColorUIResource ( 128", "gt": ", 70 , 128 ) ;", "prediction": ", 0 , 128 ) ;\n", "label": 0}
{"id": 13468, "input": "<s> package knowevo . myvizster . action ; import java . util . Iterator ; import prefusex . community . CommunitySet ; import edu . berkeley . guir . prefuse . EdgeItem ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . NodeItem ; import edu . berkeley . guir . prefuse . action . AbstractAction ; import edu . berkeley . guir . prefuse . graph . Node ; public class CommunityEdgeLabeler extends AbstractAction { private Object m_key ; public CommunityEdgeLabeler ( Object communityKey ) { m_key = communityKey ; } public void run ( ItemRegistry registry , double frac ) { FocusManager fman = registry . getFocusManager ( ) ; CommunitySet comm = ( CommunitySet ) fman . getFocusSet ( m_key ) ; if ( comm . getCommunityCount ( ) == 0 ) return ; Iterator iter = registry . getEdgeItems ( ) ; while ( iter . hasNext ( ) ) { EdgeItem ei = ( EdgeItem ) iter . next ( ) ; NodeItem n1 = ( NodeItem ) ei . getFirstNode ( ) ; NodeItem n2 = ( NodeItem ) ei . getSecondNode ( ) ; int c1 = comm . getCommunity ( ( Node ) n1 . getEntity ( ) ) ; int c2 = comm . getCommunity ( ( Node ) n2 . getEntity ( ) ) ; boolean b = ( c1 != c2 &&", "gt": "c1 != - 1 && c2 != - 1 ) ;", "prediction": "b != c1 ) ;\n", "label": 1}
{"id": 7907, "input": "<s> import java . io . IOException ; import java . util . StringTokenizer ; import java . util . Vector ; interface Figure { public boolean contains ( double x , double y ) ; } class Rectangle implements Figure { double x1 , y1 , x2 , y2 ; public boolean contains ( double px , double py ) { return ( ( px > x1 && px < x2 && py > y1 && py < y2 ) ) ; } Rectangle ( double a , double b , double c , double d ) { x1 = a ; y1 = b ; x2 = c ; y2 = d ; } } class Circle implements Figure { double x , y ; double r ; Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public boolean contains ( double px , double py ) { double dist2 = ( px - x ) * ( px - x ) + ( py - y ) * ( py - y ) ; return dist2 < r * r ; } } class Triangle implements Figure { double x1 , y1 ; double x2 , y2 ; double x3 , y3 ; Triangle ( double a , double b , double c , double d , double e , double f ) { x1 = a ; y1 = b ; x2 = c ; y2 = d ; x3 = e ; y3 = f ; } public boolean contains ( double x , double y ) { double a = ( x2 - x1 ) * ( y - y1 ) - ( y2 - y1 ) * ( x - x1 ) ; double b = ( x3 - x2 ) * ( y - y2 ) - ( y3 - y2 ) * ( x - x2 ) ; double c = ( x1 - x3 ) * ( y - y3 ) - ( y1 - y3 ) * ( x - x3 ) ; return ( ( a > 0 && b > 0 && c > 0 ) || ( a < 0 && b < 0 && c < 0 ) ) ; } } class Main { static int maxLg = 200 ; public static void main ( String args [ ] ) throws Exception { Vector v = new Vector ( ) ; while ( true ) { String l = readLine ( ) ; if ( l . charAt ( 0 ) == '*' ) break ; if ( l . charAt ( 0 ) == 'r' ) { double [ ] parsed = splitDoubleLineR ( l ) ; Rectangle r1 = new Rectangle ( parsed [ 0 ] , parsed [ 3 ] , parsed [ 2 ] , parsed [ 1 ] ) ; v . addElement ( r1 ) ; } else if ( l . charAt ( 0 ) == 'c' ) { double [ ] parsed = splitDoubleLineR ( l ) ; Circle r1 = new Circle ( parsed [ 0 ] , parsed [ 1 ] , parsed [ 2 ] ) ; v . addElement ( r1 ) ; } else if ( l . charAt ( 0 ) == 't' ) { double [ ] parsed = splitDoubleLineR ( l ) ; Triangle r1 = new Triangle ( parsed [ 0 ] , parsed [ 1 ] , parsed [ 2 ] , parsed [ 3 ] , parsed [ 4 ] , parsed [ 5 ] ) ; v . addElement ( r1 ) ; } } int p = 0 ; while ( true ) { double [ ] parsed = splitDoubleLine ( ) ; p ++ ; if ( parsed [ 0 ] == 9999.9 && parsed [ 1 ] == 9999.9 ) break ; boolean contained = false ; for ( int i = 0 ; i != v . size ( ) ; i ++ ) { Figure r = ( Figure ) v . elementAt ( i ) ; if ( r . contains ( parsed [ 0 ] , parsed [ 1 ] ) ) { System . out . println ( \"Point \" + p + \" is contained in figure \" + ( i + 1 ) ) ; contained = true ; } } if ( ! contained ) { System . out . println ( \"Point \" + p + \" is", "gt": "not contained in any figure\" ) ;", "prediction": "contained in figure \" + ( i + 1 ) ) ;\n", "label": 0}
{"id": 13472, "input": "<s> package org . eclipse . ui . forms . events ; public interface IExpansionListener { void expansionStateChanging ( ExpansionEvent e ) ;", "gt": "void expansionStateChanged ( ExpansionEvent e ) ;", "prediction": "}\n", "label": 1}
{"id": 5362, "input": "<s> import jns . Simulator ; import jns . agent . * ; import jns . trace . * ; import jns . element . * ; import jns . util . * ; import jns . command . * ; import java . io . IOException ; public class Test_GoBackN { public static void main ( String args [ ] ) { Simulator sim = Simulator . getInstance ( ) ; Trace trace = null ; try { trace = new JavisTrace ( \"test_gobackn.jvs\" ) ; } catch ( IOException e ) { System . out . println ( \"Could not create test_gobackn.jvs!\" ) ; } sim . setTrace ( trace ) ; Node src = new Node ( \"Source node\" ) ; Node router = new Node ( \"Router\" ) ; Node dest = new Node ( \"Destination node\" ) ; sim . attachWithTrace ( src , trace ) ; sim . attachWithTrace ( router , trace ) ; sim . attachWithTrace ( dest , trace ) ; Interface src_iface = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 10 ) ) ; src . attach ( src_iface ) ; src . addDefaultRoute ( src_iface ) ; Interface dest_iface = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 20 ) ) ; dest . attach ( dest_iface ) ; dest . addDefaultRoute ( dest_iface ) ; sim . attachWithTrace ( src_iface , trace ) ; sim . attachWithTrace ( dest_iface , trace ) ; Interface route_iface192 = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 1 ) ) ; Interface route_iface128 = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 1 ) ) ; router . attach ( route_iface192 ) ; router . attach ( route_iface128 ) ; router . addRoute ( new IPAddr ( 192 , 168 , 1 , 0 ) , new IPAddr ( 255 , 255 , 255 , 0 ) , route_iface192 ) ; router . addRoute ( new IPAddr ( 128 , 116 , 11 , 0 ) , new IPAddr ( 255 , 255 , 255 , 0 ) , route_iface128 ) ; route_iface128 . setMTU ( 600 ) ; sim . attachWithTrace ( route_iface192 , trace ) ; sim . attachWithTrace ( route_iface128 , trace ) ; Link link1", "gt": "= new DuplexLink ( 10000000 , 0.005 ) ;", "prediction": "= new Link ( ) ;\n", "label": 0}
{"id": 13500, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; public class CComboSingleSelectionIndexProperty extends SingleSelectionIndexProperty { public CComboSingleSelectionIndexProperty ( ) { super ( new int [ ] { SWT . Selection , SWT . DefaultSelection } ) ; } int doGetIntValue ( Object source ) { return ( ( CCombo ) source ) . getSelectionIndex ( ) ; } void", "gt": "doSetIntValue ( Object source , int value )", "prediction": "doGetIntValue ( Object source )\n", "label": 1}
{"id": 47, "input": "<s> package com . matburt . mobileorg . test . Synchronizers ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . security . cert . CertificateException ; import java . util . HashMap ; import javax . net . ssl . SSLHandshakeException ; import com . matburt . mobileorg . Synchronizers . SynchronizerInterface ; public class SynchronizerStub implements SynchronizerInterface { int putRemoteFileCount = 0 ; int getRemoteFileCount = 0 ; HashMap < String , String > files = new HashMap < String , String > ( ) ; SynchronizerStub ( ) { } @ Override public boolean isConfigured ( ) { return true ; } @ Override public void putRemoteFile ( String filename , String contents ) throws IOException { putRemoteFileCount ++ ; addFile ( filename , contents ) ; } @ Override public BufferedReader getRemoteFile ( String filename ) throws IOException , CertificateException , SSLHandshakeException { getRemoteFileCount ++ ; String contents = files . get ( filename ) ; if ( contents == null ) throw new IOException ( \"File \\\"\" + filename + \"\\\" not found\" ) ; InputStream is =", "gt": "new ByteArrayInputStream ( contents . getBytes ( ) ) ;", "prediction": "files . get ( filename ) ;\n", "label": 0}
{"id": 13501, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . util . LinkedHashSet ; import java . util . Set ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . resources . IResource ; public class ResourceRegistry { private final Set < IResource > resources ; public ResourceRegistry ( ) { resources = new LinkedHashSet <", "gt": "IResource > ( ) ;", "prediction": "IResource > ( ) ;\n", "label": 1}
{"id": 6803, "input": "<s> package pkg ; import static pkg . B . b ; class A { public static void", "gt": "main ( String [ ] args )", "prediction": "main ( String [ ] args )\n", "label": 0}
{"id": 13503, "input": "<s> package org . eclipse . rap . rwt . internal . service ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . branding . AbstractBranding ; import org . eclipse . rap . rwt . branding . Header ; import org . eclipse . rap . rwt . client . WebClient ; import org . eclipse . rap . rwt . internal . RWTMessages ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . branding . BrandingUtil ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . protocol . ProtocolMessageWriter ; import org . eclipse . rap . rwt . internal . resources . ResourceRegistry ; import org . eclipse . rap . rwt . internal . service . StartupPageTemplateHolder . Variable ; import org . eclipse . rap . rwt . internal . textsize . MeasurementUtil ; import org . eclipse . rap . rwt . internal . theme . JsonValue ; import org . eclipse . rap . rwt . internal . theme . Theme ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . internal . theme . ThemeUtil ; import org . eclipse . rap . rwt . internal . util . HTTP ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . resources . IResource ; final class StartupPageConfigurer { private static final String PACKAGE_NAME = StartupPageConfigurer . class . getPackage ( ) . getName ( ) ; private final static String FOLDER = PACKAGE_NAME . replace ( '.' , '/' ) ; private final static String INDEX_TEMPLATE = FOLDER + \"/rwt-index.html\" ; private static final String DISPLAY_TYPE = \"rwt.widgets.Display\" ; private static final String PROPERTY_URL = \"url\" ; private final ResourceRegistry resourceRegistry ; private final List < String > jsLibraries ; private final List < String > themeDefinitions ; private StartupPageTemplateHolder template ; StartupPageConfigurer ( ResourceRegistry resourceRegistry ) { this . resourceRegistry = resourceRegistry ; jsLibraries = new ArrayList < String > ( ) ; themeDefinitions = new ArrayList < String > ( ) ; } public StartupPageTemplateHolder getTemplate ( ) throws IOException { readContent ( ) ; template . reset ( ) ; applyBranding ( ) ; applyEntryPointProperties ( ) ; applyLocalizeableMessages ( ) ; addThemeDefinitions ( ) ; template . replace ( StartupPageTemplateHolder . VAR_LIBRARIES , getJsLibraries ( ) ) ; template . replace ( StartupPageTemplateHolder . VAR_APPSCRIPT , getAppScript ( ) ) ; return template ; } public void addJsLibrary ( String location ) { ParamCheck . notNull ( location , \"resource\" ) ; jsLibraries . add ( location ) ; } private void readContent ( ) throws IOException { if ( template == null ) { InputStream stream = loadTemplateFile ( ) ; InputStreamReader streamReader = new InputStreamReader ( stream , HTTP . CHARSET_UTF_8 ) ; BufferedReader reader = new BufferedReader ( streamReader ) ; try { String line = reader . readLine ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( line != null ) { buffer . append ( line ) ; buffer . append ( '\\n' ) ; line = reader . readLine ( ) ; } template = new StartupPageTemplateHolder ( buffer . toString ( ) ) ; } finally { reader . close ( ) ; } } } private static InputStream loadTemplateFile ( ) throws IOException { ClassLoader classLoader = StartupPageConfigurer . class . getClassLoader ( ) ; InputStream result = classLoader . getResourceAsStream ( INDEX_TEMPLATE ) ; if ( result == null ) { throw new IOException ( \"Failed to startup page: \" + INDEX_TEMPLATE ) ; } return result ; } private static String getAppScript ( ) { StringBuilder code = new StringBuilder ( ) ; code . append ( \"if( rwt.runtime.System.getInstance().isSupported() ) {\" ) ; code . append ( \"rwt.protocol.MessageProcessor.processMessage( \" ) ; code . append ( getStartupProtocolMessage ( \"w1\" ) ) ; code . append ( \");/*EOM*/ }\" ) ; return code . toString ( ) ; } private static String getStartupProtocolMessage ( String id ) { ProtocolMessageWriter writer = new ProtocolMessageWriter ( ) ; appendCreateDisplay ( id , writer ) ; MeasurementUtil . appendStartupTextSizeProbe ( writer ) ; return writer . createMessage ( ) ; } private static void appendCreateDisplay ( String id , ProtocolMessageWriter writer ) { writer . appendCreate ( id , DISPLAY_TYPE ) ; writer . appendHead ( PROPERTY_URL , JsonValue . valueOf ( getUrl ( ) ) ) ; } private static String getUrl ( ) { HttpServletRequest request = ContextProvider . getRequest ( ) ; String url = request . getServletPath ( ) . substring ( 1 ) ; return ContextProvider . getResponse ( ) . encodeURL ( url ) ; } private void", "gt": "applyBranding ( ) throws IOException", "prediction": "appendHead ( String id )\n", "label": 1}
{"id": 4314, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . util . ExpressionUtils ; import net . sf . jasperreports . charts . design . JRDesignScatterPlot ; import net . sf . jasperreports . engine . JRChartPlot ; import net . sf . jasperreports . engine . design . JRDesignExpression ; public class ScatterPlot extends AbstractPlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private DJAxisFormat xAxisFormat = new DJAxisFormat ( ) ; private DJAxisFormat yAxisFormat = new DJAxisFormat ( ) ; private Boolean showShapes = null ; private Boolean showLines = null ; public void setShowShapes ( Boolean showShapes ) { this . showShapes = showShapes ; } public Boolean getShowShapes ( ) { return showShapes ; } public void setShowLines ( Boolean showLines ) { this . showLines = showLines ; } public Boolean getShowLines ( ) { return showLines ; } public void setXAxisFormat ( DJAxisFormat xAxisFormat ) { this . xAxisFormat = xAxisFormat ; } public DJAxisFormat getXAxisFormat ( ) { return xAxisFormat ; } public void setYAxisFormat ( DJAxisFormat yAxisFormat ) { this . yAxisFormat = yAxisFormat ; } public DJAxisFormat getYAxisFormat ( ) { return yAxisFormat ; } public void transform ( DynamicJasperDesign design , JRChartPlot plot , String name ) { super . transform ( design , plot , name ) ; JRDesignScatterPlot scatterPlot = ( JRDesignScatterPlot ) plot ; StringExpression xAxisLabelExp = getXAxisFormat ( ) . getLabelExpression ( ) ; if ( xAxisLabelExp != null ) { JRDesignExpression exp = ExpressionUtils . createAndRegisterExpression ( design , \"xAxisLabel_\" + name , xAxisLabelExp ) ; scatterPlot . setXAxisLabelExpression ( exp ) ; } if ( xAxisFormat . getTickLabelMask ( ) != null ) scatterPlot . setXAxisTickLabelMask ( xAxisFormat . getTickLabelMask ( ) ) ; if ( xAxisFormat . getLabelColor ( ) != null ) scatterPlot . setXAxisLabelColor ( xAxisFormat . getLabelColor ( ) ) ; if ( xAxisFormat . getLabelFont ( ) != null ) scatterPlot . setXAxisLabelFont ( xAxisFormat . getLabelFont ( ) . transform ( ) ) ; if ( xAxisFormat . getLineColor ( ) != null ) scatterPlot", "gt": ". setXAxisLineColor ( xAxisFormat . getLineColor ( ) ) ;", "prediction": ". setXAxisLineColor ( xAxisFormat . getLineColor ( ) ) ;\n", "label": 0}
{"id": 13513, "input": "<s> package org . jscsi . parser . nop ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . Constants ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . TargetMessageParser ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . utils . Utils ; public final class NOPInParser extends TargetMessageParser { private int targetTransferTag ; public NOPInParser ( final ProtocolDataUnit initProtocolDataUnit ) { super ( initProtocolDataUnit ) ; } public final int getTargetTransferTag ( ) { return targetTransferTag ; } public final void setTargetTransferTag ( final int targetTransferTag ) { this . targetTransferTag = targetTransferTag ; } @ Override public final String toString ( ) { final StringBuilder sb = new StringBuilder ( Constants . LOG_INITIAL_SIZE ) ; Utils . printField ( sb , \"LUN\" , logicalUnitNumber , 1 ) ; Utils . printField ( sb , \"Target Transfer Tag\" , targetTransferTag , 1 ) ; sb . append ( super . toString ( ) ) ; return sb . toString ( ) ; } @ Override public final DataSegmentFormat getDataSegmentFormat ( ) { return DataSegmentFormat . BINARY ; } @ Override public final void clear ( ) { super . clear ( ) ; targetTransferTag = 0x00000000 ; } @ Override protected final void deserializeBytes1to3 ( final int line ) throws InternetSCSIException { Utils . isReserved ( line & Constants . LAST_THREE_BYTES_MASK ) ; } @ Override", "gt": "protected final void deserializeBytes20to23 ( final int line ) throws InternetSCSIException", "prediction": "protected final void deserializeBytes2to3 ( final int line ) throws InternetSCSIException\n", "label": 1}
{"id": 1151, "input": "<s> package FRC2115 . subsystems ; import FRC2115 . RobotMap ; import edu . wpi . first . wpilibj . Jaguar ; import edu . wpi . first . wpilibj . command . Subsystem ; public class BridgeArm extends Subsystem { private final double speed = 1.0 ; private Jaguar armMotor ; public BridgeArm ( ) { armMotor = new Jaguar ( RobotMap . armMotor ) ; } public void initDefaultCommand ( ) { } public void extend ( ) { armMotor . set ( speed ) ; } public void retract ( ) { armMotor .", "gt": "set ( - speed ) ;", "prediction": "set ( speed ) ;\n", "label": 0}
{"id": 13517, "input": "<s> package wiki ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Response ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . IdRef ; import org . nuxeo . ecm . webengine . WebException ; import org . nuxeo . ecm . webengine . model . WebObject ; import org . nuxeo . ecm . webengine . model . exceptions . WebResourceNotFoundException ; import org . nuxeo . ecm . webengine . model . exceptions . WebSecurityException ; import org . nuxeo . ecm . webengine . model . impl . ModuleRoot ; @ Path ( \"/wikis\" ) @ WebObject ( type = \"wikis\" , facets = { \"mainWiki\" } ) @ Produces ( \"text/html; charset=UTF-8\" ) public class Main extends ModuleRoot { public Main ( ) { } @ GET public Object doGet ( ) throws ClientException { CoreSession session = ctx . getCoreSession ( ) ; DocumentModelList wikiSites = session . query ( \"SELECT * FROM Wiki WHERE ecm:currentLifeCycleState != 'deleted' \" ) ; return getView ( \"index\" ) . arg ( \"wikis\" , wikiSites ) ; } @ Path ( \"{segment}\" ) public Object getWiki ( @ PathParam ( \"segment\" ) String segment ) { try { CoreSession session = ctx . getCoreSession ( ) ; DocumentModel wikiSite = session . getDocument ( new IdRef ( segment ) ) ; return newObject ( \"Wiki\" , wikiSite . getId ( ) ) ; } catch ( Exception e ) { throw WebException . wrap ( e ) ; } } @ Override public Object handleError ( WebApplicationException e ) { if ( e instanceof WebSecurityException ) { return Response . status ( 401 ) . entity ( getTemplate ( \"error/error_401.ftl\" ) ) . build ( ) ; } else if ( e instanceof WebResourceNotFoundException ) { return Response . status ( 404 ) . entity ( getTemplate ( \"error/error_404.ftl\" ) ) . build ( ) ; } else { return super . handleError ( e ) ; } } @ Override public String getLink ( DocumentModel doc ) { String type = doc . getType ( ) ;", "gt": "if ( \"Wiki\" . equals ( type ) )", "prediction": "try\n", "label": 1}
{"id": 5317, "input": "<s> package org . ofbiz . content . content ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . GenericValue ; public class PermissionRecorder { public static final int PRE_PURPOSE = 0 ; public static final int PRE_ROLE = 1 ; public static final int WITH_ROLES = 2 ; protected boolean isOn = false ; protected GenericValue userLogin ; protected List < Map < String , Object > > permCheckResults = FastList . newInstance ( ) ; protected boolean entityPermCheckResult = false ; protected String currentContentId = \"\" ; protected Map < String , Object > currentContentMap ; protected String privilegeEnumId ; protected int currentCheckMode ; protected GenericValue [ ] contentPurposeOperations ; protected String [ ] statusTargets ; protected String [ ] targetOperations ; public static final String module = PermissionRecorder . class . getName ( ) ; public static final String [ ] opFields = { \"contentPurposeTypeId\" , \"contentOperationId\" , \"roleTypeId\" , \"statusId\" , \"privilegeEnumId\" } ; public static final String [ ] fieldTitles = { \"Purpose\" , \"Operation\" , \"Role\" , \"Status\" , \"Privilege\" } ; public PermissionRecorder ( ) { isOn = UtilProperties . propertyValueEqualsIgnoreCase ( \"content.properties\" , \"permissionRecorderOn\" , \"true\" ) ; } public void setCheckMode ( int val ) { currentCheckMode = val ; } public int getCheckMode ( ) { return currentCheckMode ; } public boolean isOn ( ) { return isOn ; } public void setOn ( boolean b ) { isOn = b ; } public void setUserLogin ( GenericValue user ) { userLogin = user ; } public GenericValue getUserLogin ( ) { return userLogin ; } public boolean getEntityPermCheckResult ( ) { return entityPermCheckResult ; } public void setEntityPermCheckResult ( boolean b ) { entityPermCheckResult = b ; } public GenericValue [ ] getContentPurposeOperations ( ) { return contentPurposeOperations ; } public void setContentPurposeOperations ( List < GenericValue > opList ) { contentPurposeOperations = opList . toArray ( new GenericValue [ opList . size ( ) ] ) ; } public void setPrivilegeEnumId ( String id ) { privilegeEnumId = id ; } public String getPrivilegeEnumId ( ) { return privilegeEnumId ; } public String [ ] getStatusTargets ( ) { return statusTargets ; } public void setStatusTargets ( List < String > opList ) { statusTargets = opList . toArray ( new String [ opList . size ( ) ] ) ; } public String [ ] getTargetOperations ( ) { return targetOperations ; } public void setTargetOperations ( List < String > opList ) { targetOperations = opList . toArray ( new String [ opList . size ( ) ] ) ; } public void setCurrentContentId ( String id ) { if ( ! currentContentId . equals ( id ) ) { currentContentMap = FastMap . newInstance ( ) ; permCheckResults . add ( currentContentMap ) ; currentContentMap . put ( \"contentId\" , id ) ; currentContentMap . put ( \"checkResults\" , FastList . newInstance ( ) ) ; } currentContentId = id ; } public String getCurrentContentId ( ) { return currentContentId ; } public void setRoles ( List < String > roles ) { if ( currentContentMap != null ) { if ( roles != null ) currentContentMap . put ( \"roles\" , roles . toArray ( ) ) ; else currentContentMap . put ( \"roles\" , null ) ; } } public void setPurposes ( List < String > purposes ) { if ( currentContentMap != null ) { if ( purposes != null ) currentContentMap . put ( \"purposes\" , purposes . toArray ( ) ) ; else currentContentMap . put ( \"purposes\" , null ) ; } } public void startMatchGroup ( List < String > targetOperations , List < String > purposes , List < String > roles , List < String > targStatusList , String targPrivilegeEnumId , String contentId ) { currentContentMap = FastMap . newInstance ( ) ; permCheckResults . add ( currentContentMap ) ; String s = null ; if ( targetOperations != null ) { s = targetOperations . toString ( ) ; currentContentMap . put", "gt": "( \"contentOperationId\" , s ) ;", "prediction": "( \"contentId\" , s ) ;\n", "label": 0}
{"id": 13518, "input": "<s> package org . eclipse . ui ; public interface IInPlaceEditorInput extends IPathEditorInput {", "gt": "public void setInPlaceEditor ( IInPlaceEditor editor ) ;", "prediction": "void setUp ( ) ;\n", "label": 1}
{"id": 1165, "input": "<s> package org . ofbiz . order . shoppingcart ; import org . ofbiz . base . util . GeneralException ; @ SuppressWarnings ( \"serial\" ) public class CartItemModifyException extends GeneralException { public CartItemModifyException ( ) { super ( ) ; } public CartItemModifyException ( String str ) { super ( str ) ; } public", "gt": "CartItemModifyException ( Throwable nested )", "prediction": "CartItemModifyException ( String str )\n", "label": 0}
{"id": 13520, "input": "<s> import java . util . HashMap ; import junit . framework . TestCase ; import org . eclipse . cdt . core . dom . ast . ASTVisitor ; import org . eclipse . cdt . core . dom . ast . IASTArrayModifier ; import org . eclipse . cdt . core . dom . ast . IASTDeclSpecifier ; import org . eclipse . cdt . core . dom . ast . IASTDeclaration ; import org . eclipse . cdt . core . dom . ast . IASTDeclarator ; import org . eclipse . cdt . core . dom . ast . IASTEnumerationSpecifier . IASTEnumerator ; import org . eclipse . cdt . core . dom . ast . IASTExpression ; import org . eclipse . cdt . core . dom . ast . IASTInitializer ; import org . eclipse . cdt . core . dom . ast . IASTName ; import org . eclipse . cdt . core . dom . ast . IASTParameterDeclaration ; import org . eclipse . cdt . core . dom . ast . IASTPointerOperator ; import org . eclipse . cdt . core . dom . ast . IASTPreprocessorMacroDefinition ; import org . eclipse . cdt . core . dom . ast . IASTProblem ; import org . eclipse . cdt . core . dom . ast . IASTStatement ; import org . eclipse . cdt . core . dom . ast . IASTTranslationUnit ; import org . eclipse . cdt . core . dom . ast . IASTTypeId ; import org . eclipse . cdt . core . dom . ast . c . ICASTDesignator ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTCapture ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTCompositeTypeSpecifier . ICPPASTBaseSpecifier ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTNamespaceDefinition ; import org . eclipse . cdt . core . dom . ast . cpp . ICPPASTTemplateParameter ; import org . eclipse . cdt . core . dom . ast . gnu . c . GCCLanguage ; import org . eclipse . cdt . core . parser . DefaultLogService ; import org . eclipse . cdt . core . parser . FileContent ; import org . eclipse . cdt . core . parser . IncludeFileContentProvider ; import org . eclipse . cdt . core . parser . ScannerInfo ; import org . eclipse . core . runtime . CoreException ; public class WhileDoForLoopTestCase extends TestCase { public void testBasicTest ( ) throws CoreException { StringBuilder content = new StringBuilder ( ) ; content . append ( \"void funWithWhileLoop(){\\n\" ) ; content . append ( \"while(){ \\n\" ) ; content . append ( \"\tint8_t localVar;\\n\" ) ; content . append ( \"}\\n\" ) ; content . append ( \"};\\n\" ) ; HashMap < String , String > options = new HashMap < String , String > ( ) ; ScannerInfo scannerInfo = new ScannerInfo ( options ) ; IASTTranslationUnit astTranslationUnit = GCCLanguage . getDefault ( ) . getASTTranslationUnit ( FileContent . create ( \"someFile.h\" , content . toString ( ) . toCharArray ( ) ) , scannerInfo , IncludeFileContentProvider . getEmptyFilesProvider ( ) , null , 0 , new DefaultLogService ( ) ) ; astTranslationUnit . accept ( new ASTVisitor ( true ) { } ) ; astTranslationUnit . accept ( new ASTVisitor ( true ) { public int visist ( IASTTranslationUnit x ) { System . out . println ( \"Visit IASTPreprocessorMacroDefinition\" ) ; for ( IASTPreprocessorMacroDefinition m : x . getMacroDefinitions ( ) ) { String name = m . getName ( ) . toString ( ) ; String valueAsString = m . getExpansion ( ) ; } return PROCESS_CONTINUE ; } public int visit ( IASTTranslationUnit x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTName x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTDeclaration x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTInitializer x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTParameterDeclaration x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTDeclarator x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTDeclSpecifier x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTArrayModifier x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTPointerOperator x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTExpression x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTStatement x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTTypeId x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTEnumerator x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( IASTProblem x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( ICPPASTBaseSpecifier x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( ICPPASTNamespaceDefinition x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( ICPPASTTemplateParameter x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( ICPPASTCapture x ) { System . err . println ( x . toString ( ) ) ; return PROCESS_CONTINUE ; } public int visit ( ICASTDesignator x ) { System . err", "gt": ". println ( x . toString ( ) ) ;", "prediction": ". println ( x . toString ( ) ) ;\n", "label": 1}
{"id": 8792, "input": "<s> package org . dawb . workbench . plotting . system . swtxy ; import java . lang . ref . Reference ; import java . lang . ref . SoftReference ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import org . csstudio . swt . xygraph . figures . Axis ; import org . csstudio . swt . xygraph . figures . IAxisListener ; import org . csstudio . swt . xygraph . linearscale . Range ; import org . dawb . common . services . HistogramBound ; import org . dawb . common . services . IImageService ; import org . dawb . common . services . ImageServiceBean ; import org . dawb . common . services . ImageServiceBean . HistoType ; import org . dawb . common . services . ImageServiceBean . ImageOrigin ; import org . dawb . common . ui . image . PaletteFactory ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . IPaletteListener ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . common . ui . plot . trace . ITraceContainer ; import org . dawb . common . ui . plot . trace . PaletteEvent ; import org . dawb . workbench . plotting . Activator ; import org . dawb . workbench . plotting . preference . PlottingConstants ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . PaletteData ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . PlatformUI ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . function . Downsample ; import uk . ac . diamond . scisoft . analysis . dataset . function . DownsampleMode ; import uk . ac . diamond . scisoft . analysis . roi . LinearROI ; import uk . ac . diamond . scisoft . analysis . roi . PointROI ; import uk . ac .", "gt": "diamond . scisoft . analysis . roi . PolygonalROI ;", "prediction": "diamond . scisoft . analysis . roi . RectangleROI ;\n", "label": 0}
{"id": 13522, "input": "<s> package com . talis . hbase . rdf . test . junit ; import static org . openjena . atlas . lib . StrUtils . strjoinNL ; import java . util . ArrayList ; import java . util . List ; import org . openjena . atlas . iterator . Iter ; import org . openjena . atlas . iterator . Transform ; import com . hp . hpl . jena . query . Query ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . QueryFactory ; import com . hp . hpl . jena . query . QuerySolution ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . Resource ; import com . hp . hpl . jena . util . FileManager ; import com . talis . hbase . rdf . HBaseRdf ; import com . talis . hbase . rdf . Store ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . store . StoreFactory ; import com . talis . hbase . rdf . util . Pair ; import com . talis . hbase . rdf . util . Vocab ; public class StoreList { static Property description = Vocab . property ( HBaseRdf . namespace , \"description\" ) ; static Property list = Vocab . property ( HBaseRdf . namespace , \"list\" ) ; static Resource storeListClass = Vocab . property ( HBaseRdf . namespace , \"StoreList\" ) ; static boolean formatStores = false ; static String queryString = strjoinNL ( \"PREFIX hbaserdf: <http://rdf.hbase.talis.com/2011/hbase-rdf#>\" , \"PREFIX rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\" , \"PREFIX rdfs:     <http://www.w3.org/2000/01/rdf-schema#>\" , \"PREFIX list:     <http://jena.hpl.hp.com/ARQ/list#>\" , \"SELECT ?desc ?label\" , \"{ [] rdf:type hbaserdf:StoreList ;\" , \"     hbaserdf:list ?l .\" , \"  ?l list:member [ rdfs:label ?label ; hbaserdf:description ?desc ]\" , \"}\" ) ; static Transform < Pair < String , String > , Pair < String , StoreDesc > > t1 = new Transform < Pair < String , String > , Pair < String , StoreDesc > > ( ) { public Pair < String , StoreDesc > convert ( Pair < String , String > pair ) { return new Pair < String , StoreDesc > ( pair . car ( ) , StoreDesc . read ( pair . cdr ( ) ) ) ; } } ; static Transform < Pair < String , StoreDesc > , Pair < String , Store > > t2 = new Transform < Pair < String , StoreDesc > , Pair < String , Store > > ( ) { public Pair < String , Store > convert ( Pair < String , StoreDesc > pair ) { Store store = testStore ( pair . cdr ( ) ) ; return new Pair < String , Store > ( pair . car ( ) , store ) ; } } ; public static Store testStore ( StoreDesc desc ) { Store store = StoreFactory . create ( desc ) ; if ( formatStores || inMem ( store ) ) store . getTableFormatter ( ) . create ( ) ; return store ; } public static boolean inMem ( Store store ) { return false ; } public static List < Pair < String , StoreDesc > > stores ( String fn ) { List < Pair < String , String > > x = storesByQuery ( fn ) ; List < Pair < String , StoreDesc > > z = Iter . iter ( x ) . map ( t1 ) . toList ( ) ; return z ; } public static List < Pair < String , StoreDesc > > storeDesc ( String fn ) { List < Pair < String , String > > x = storesByQuery ( fn ) ; List < Pair < String , StoreDesc > > y = Iter . iter ( x ) . map ( t1 ) . toList ( ) ; return y ; } private static List < Pair < String , String > > storesByQuery ( String fn ) { Model model = FileManager . get ( ) . loadModel ( fn ) ; List < Pair < String , String > > data = new ArrayList < Pair < String , String > > ( ) ; Query query = QueryFactory . create ( queryString ) ; QueryExecution qExec = QueryExecutionFactory . create ( query , model ) ; try { ResultSet rs = qExec . execSelect ( ) ; for ( ; rs . hasNext ( ) ; ) { QuerySolution qs", "gt": "= rs . nextSolution ( ) ;", "prediction": "= rs . next ( ) ;\n", "label": 1}
{"id": 7724, "input": "<s> import java . util . Scanner ; public class UserInput { Scanner scanner ; public UserInput ( ) { scanner = new Scanner ( System . in ) ; } public String askBookName ( ) { System . out . print ( \"\\nEnter Book Name:\" ) ; return scanner . nextLine ( ) ; } public int askChoice ( ) { System . out . print ( \"\\nEnter your choice:\" ) ; int choice = 0 ; while ( true ) { try { choice = Integer . parseInt ( scanner . nextLine ( ) ) ; return choice ; } catch ( NumberFormatException numberFormatException ) { System . out . print ( \"\\nSorry! Wrong Choice. Enter Again:\" ) ; } } } public String askUserName ( ) { System . out .", "gt": "print ( \"\\nEnter User name:\" ) ;", "prediction": "print ( \"\\nEnter User Name:\" ) ;\n", "label": 0}
{"id": 13525, "input": "<s> package org . eclipse . xtext . xdoc . images . util ; import org . eclipse . emf . common . notify . Adapter ; import org . eclipse . emf . common . notify . Notifier ; import org . eclipse . emf . common . notify . impl . AdapterFactoryImpl ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . xtext . xdoc . images . * ; public class ImagesAdapterFactory extends AdapterFactoryImpl { protected static ImagesPackage modelPackage ; public ImagesAdapterFactory ( ) { if ( modelPackage == null ) { modelPackage = ImagesPackage . eINSTANCE ; } } @ Override public boolean isFactoryForType ( Object object ) { if ( object == modelPackage ) { return true ; } if ( object instanceof EObject ) { return ( ( EObject ) object ) . eClass ( ) . getEPackage ( ) == modelPackage ; } return false ; } protected ImagesSwitch < Adapter > modelSwitch = new ImagesSwitch < Adapter > ( ) { @ Override public Adapter caseImageProxy ( ImageProxy object ) {", "gt": "return createImageProxyAdapter ( ) ;", "prediction": "return ( ( EObject ) object ) . eClass ( ) . getEPackage ( ) == modelSwitch ;\n", "label": 1}
{"id": 4214, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignBar3DPlot ; import net . sf . jasperreports . charts . design . JRDesignCategoryDataset ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJStackedBar3DChartBuilder ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class StackedBar3DChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnState ) ; drb . addColumn ( columnBranch ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; GroupBuilder gb1 = new GroupBuilder ( ) ; DJGroup g1 = gb1 . setCriteriaColumn ( ( PropertyColumn ) columnState ) . addFooterVariable ( columnAmount , DJCalculation . SUM ) . addFooterVariable ( columnaQuantity , DJCalculation . SUM ) . addVariable ( \"group_state_name\" , columnState , DJCalculation . FIRST ) . setGroupLayout ( GroupLayout . VALUE_IN_HEADER_WITH_HEADERS ) . build ( ) ; drb . addGroup ( g1 ) ; drb . setUseFullPageWidth ( true ) ; DJAxisFormat categoryAxisFormat = new DJAxisFormat ( \"category\" ) ; categoryAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelMask ( \"\" ) ; categoryAxisFormat .", "gt": "setLineColor ( Color . DARK_GRAY ) ;", "prediction": "setTickLabelFont ( Font . ARIAL_GRAY ) ;\n", "label": 0}
{"id": 13532, "input": "<s> package org . restlet . engine ; import org . restlet . Client ; public class ClientHelper extends ConnectorHelper < Client > { public ClientHelper ( Client client ) { super ( client ) ; } @ SuppressWarnings ( \"deprecation\" ) public int getSocketConnectTimeoutMs ( ) { int result =", "gt": "getHelped ( ) . getConnectTimeout ( ) ;", "prediction": "0 ;\n", "label": 1}
{"id": 3278, "input": "<s> class SunApiPlural { sun .", "gt": "misc . Unsafe x ;", "prediction": "sun ;\n", "label": 0}
{"id": 13538, "input": "<s> package knowevo . springbox . vizster ; import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . AffineTransform ; import knowevo . myvizster . ui . Legend ; import edu . berkeley . guir . prefuse . Display ; import edu . berkeley . guir . prefuse . util . ColorLib ; import edu . berkeley . guir . prefuse . util . FontLib ; public class MyVizsterDisplay extends Display { private VizsterApplet vizster ; private AffineTransform id = new AffineTransform ( ) ; private Legend legend = null ; public MyVizsterDisplay ( VizsterApplet vizster ) { super ( vizster . getItemRegistry ( ) ) ; this . vizster = vizster ; } public void prePaint ( Graphics2D g ) { Object o = g . getRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING ) ; g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; AffineTransform at = g . getTransform ( ) ; g . setTransform ( id ) ; Color c = ColorLib . getColor ( 200 , 200 , 200 , 255 ) ; Font f = FontLib . getFont ( \"SansSerif\" , Font . BOLD | Font . ITALIC , 48 ) ; FontMetrics fm = g . getFontMetrics ( f ) ; String s = \"vizster\" ; int x = 8 , y = fm . getAscent ( ) ; g . setColor ( c ) ; g . setFont ( f ) ; g . drawString ( s , x , y ) ; if ( vizster . isXRayMode ( ) ) { f = FontLib . getFont ( \"SansSerif\" , Font . BOLD | Font . ITALIC , 18 ) ; fm = g . getFontMetrics ( f ) ; s = \"x-ray\" ; g . setFont ( f ) ; g . drawString ( s , 140 , fm . getAscent ( ) - 2 ) ; } if ( legend != null ) { x = this . getWidth ( ) - legend . getWidth ( ) ; legend . paint ( g , this , x , 0 ) ; } g . setRenderingHint ( RenderingHints . KEY_TEXT_ANTIALIASING , o ) ; g . setTransform ( at ) ; } public", "gt": "void setLegend ( Legend l )", "prediction": "void render ( Graphics2D g )\n", "label": 1}
{"id": 620, "input": "<s> public class Method { < E extends D , D > void m ( E e , D d ) { m ( e , d ) ; m", "gt": "( null , null ) ;", "prediction": "( e , d ) ;\n", "label": 0}
{"id": 13543, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . client ; import java . io . IOException ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackServiceHandler ; import org . eclipse . rap . rwt . service . IServiceHandler ; import org . eclipse . swt . dnd . Transfer ; @ SuppressWarnings ( \"restriction\" ) public class RWTClient { private static final String TEXT_TRANSFER_DATA_TYPE = String . valueOf ( Transfer . registerType ( \"text\" ) ) ; private IServletEngine servletEngine ; private final IConnectionProvider connectionProvider ; private final long startTime ; private String sessionId ; private int requestCounter ; public RWTClient ( IServletEngine servletEngine ) { this ( servletEngine , new DefaultConnectionProvider ( ) ) ; } RWTClient ( IServletEngine servletEngine , IConnectionProvider connectionProvider ) { this . servletEngine = servletEngine ; this . connectionProvider = connectionProvider ; startTime = System . currentTimeMillis ( ) ; sessionId = \"\" ; requestCounter = - 2 ; } public void changeServletEngine ( IServletEngine servletEngine ) { this . servletEngine = servletEngine ; } public Object getServletEngine ( ) { return servletEngine ; } public String getSessionId ( ) { return sessionId ; } public Response sendStartupRequest ( ) throws IOException { return sendRequest ( \"GET\" , new HashMap < String , String > ( ) ) ; } public Response sendInitializationRequest ( ) throws IOException { Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( \"rwt_initialize\" , \"true\" ) ; parameters . put ( \"uiRoot\" , \"w1\" ) ; parameters . put ( \"w1.bounds.width\" , \"800\" ) ; parameters . put ( \"w1.bounds.height\" , \"600\" ) ; parameters . put ( \"w1.dpi.x\" , \"96\" ) ; parameters . put ( \"w1.dpi.y\" , \"96\" ) ; parameters . put ( \"w1.colorDepth\" , \"32\" ) ; parameters . put ( \"w1.cursorLocation.x\" , \"0\" ) ; parameters . put ( \"w1.cursorLocation.y\" , \"0\" ) ; return sendPostRequest ( parameters ) ; } public Response sendDisplayResizeRequest ( int width , int height ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"w1.bounds.width\" , String . valueOf ( width ) ) ; parameters . put ( \"w1.bounds.height\" , String . valueOf ( height ) ) ; return sendPostRequest ( parameters ) ; } public Response sendWidgetSelectedRequest ( String widgetId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.events.widgetSelected\" , widgetId ) ; return sendPostRequest ( parameters ) ; } public Response sendShellCloseRequest ( String shellId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters . put ( \"org.eclipse.swt.widgets.Shell_close\" , shellId ) ; return sendPostRequest ( parameters ) ; } public Response sendDragStartRequest ( String widgetId ) throws IOException { Map < String , String > parameters = createDefaultParameters ( ) ; parameters .", "gt": "put ( \"org.eclipse.swt.dnd.dragStart\" , widgetId ) ;", "prediction": "put ( \"org.eclipse.swt.widgets.Drag_start\" , widgetId ) ;\n", "label": 1}
{"id": 2592, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface HideResource extends ReportAttribute , IcalReportAttribute , ExportAttribute , NikuReportAttribute , StatusSheetReportAttribute , TimesheetReportAttribute { LogicalExpression getExpression ( ) ;", "gt": "void setExpression ( LogicalExpression value ) ;", "prediction": "}\n", "label": 0}
{"id": 13547, "input": "<s> package org . eclipse . ui ; public interface IViewSite extends IWorkbenchPartSite { public IActionBars getActionBars ( ) ;", "gt": "public String getSecondaryId ( ) ;", "prediction": "}\n", "label": 1}
{"id": 1797, "input": "<s> package y ; public final class R3 { x . B . C a = null ;", "gt": "x . C b = null ;", "prediction": "y . B . C b = null ;\n", "label": 0}
{"id": 13557, "input": "<s> package org . eclipse . ui . internal ; public class ContainerPlaceholder extends PartPlaceholder implements ILayoutContainer { private static int nextId = 0 ; private ILayoutContainer realContainer ; public ContainerPlaceholder ( String id ) { super ( ( ( id == null ) ? \"Container Placeholder \" + nextId ++ : id ) ) ; } public void add ( LayoutPart child ) { if ( ! ( child instanceof PartPlaceholder ) ) { return ; } realContainer . add ( child ) ; } public boolean allowsBorder ( ) { return true ; } public LayoutPart [ ] getChildren ( ) { return realContainer . getChildren ( ) ; } public LayoutPart getFocus ( ) { return null ; } public LayoutPart getRealContainer ( ) { return ( LayoutPart ) realContainer ; } public boolean isChildVisible ( LayoutPart child ) { return false ; } public void remove ( LayoutPart child ) { if ( ! ( child instanceof PartPlaceholder ) ) { return ; } realContainer . remove ( child ) ; } public void replace ( LayoutPart oldChild , LayoutPart newChild ) { if ( ! ( oldChild instanceof PartPlaceholder ) && ! ( newChild instanceof PartPlaceholder ) ) { return ; } realContainer . replace ( oldChild , newChild ) ; } public void setChildVisible ( LayoutPart child , boolean visible ) { } public void setFocus ( LayoutPart child ) { } public void setRealContainer ( ILayoutContainer container ) { if ( container == null ) { if ( realContainer != null ) { LayoutPart [ ] children = realContainer . getChildren ( ) ; if ( children != null ) { for ( int i = 0 , length = children . length ; i < length ; i ++ ) { children [ i ] . setContainer ( realContainer ) ; } } } } else { LayoutPart [ ] children = container . getChildren ( ) ; if ( children != null ) { for ( int i = 0 , length = children . length ; i < length ; i ++ ) { children [ i ] . setContainer ( this ) ; } } } this . realContainer = container ; } public void findSashes ( LayoutPart part , PartPane . Sashes sashes ) { ILayoutContainer container = getContainer ( ) ; if ( container != null ) { container . findSashes ( this , sashes ) ; } }", "gt": "public boolean allowsAutoFocus ( )", "prediction": "}\n", "label": 1}
{"id": 8300, "input": "<s> package org . ofbiz . product . image ; import java . awt . image . BufferedImage ; import java . awt . image . ImagingOpException ; import java . awt . image . RenderedImage ; import java . io . File ; import java . io . IOException ; import java . lang . NullPointerException ; import java . lang . SecurityException ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . imageio . ImageIO ; import javolution . util . FastMap ; import org . jdom . JDOMException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . common . image . ImageTransform ; public class ScaleImage { public static final String module = ScaleImage . class . getName ( ) ; public static final String resource = \"ProductErrorUiLabels\" ; public static final List < String > sizeTypeList = UtilMisc . toList ( \"small\" , \"medium\" , \"large\" , \"detail\" ) ; public ScaleImage ( ) { } public static Map < String , Object > scaleImageInAllSize ( Map < String , ? extends Object > context , String filenameToUse , String viewType , String viewNumber ) throws IllegalArgumentException , ImagingOpException , IOException , JDOMException { Locale locale = ( Locale ) context . get ( \"locale\" ) ; int index ; Map < String , Map < String , String > > imgPropertyMap = FastMap . newInstance ( ) ; BufferedImage bufImg , bufNewImg ; double imgHeight , imgWidth ; Map < String , String > imgUrlMap = FastMap . newInstance ( ) ; Map < String , Object > resultXMLMap = FastMap . newInstance ( ) ; Map < String , Object > resultBufImgMap = FastMap . newInstance ( ) ; Map < String , Object > resultScaleImgMap = FastMap . newInstance ( ) ; Map < String , Object > result = FastMap . newInstance ( ) ; String imgPropertyFullPath = System . getProperty ( \"ofbiz.home\" ) + \"/applications/product/config/ImageProperties.xml\" ; resultXMLMap . putAll ( ImageTransform . getXMLValue ( imgPropertyFullPath , locale ) ) ; if ( resultXMLMap . containsKey ( \"responseMessage\" ) && resultXMLMap . get ( \"responseMessage\" ) . equals ( \"success\" ) ) { imgPropertyMap . putAll ( UtilGenerics . < Map < String , Map < String , String > > > cast ( resultXMLMap . get ( \"xml\" ) ) ) ; } else { String errMsg = UtilProperties . getMessage ( resource , \"ScaleImage.unable_to_parse\" , locale ) + \" : ImageProperties.xml\" ; Debug . logError ( errMsg , module ) ; result . put ( \"errorMessage\" , errMsg ) ; return result ; } index = filenameToUse . lastIndexOf ( \".\" ) ; String imgExtension = filenameToUse . substring ( index + 1 ) ; String imageServerPath = FlexibleStringExpander . expandString ( UtilProperties . getPropertyValue ( \"catalog\" , \"image.server.path\" ) , context ) ; String imageUrlPrefix = UtilProperties . getPropertyValue ( \"catalog\" , \"image.url.prefix\" ) ; FlexibleStringExpander filenameExpander ; String fileLocation = null ; String type = null ; String id = null ; if ( viewType . toLowerCase ( ) . contains ( \"main\" ) ) { String filenameFormat = UtilProperties . getPropertyValue ( \"catalog\" , \"image.filename.format\" ) ; filenameExpander = FlexibleStringExpander . getInstance ( filenameFormat ) ; id = ( String ) context . get ( \"productId\" ) ; fileLocation = filenameExpander . expandString ( UtilMisc . toMap ( \"location\" , \"products\" , \"id\" , id , \"type\" , \"original\" ) ) ; } else if ( viewType . toLowerCase ( ) . contains ( \"additional\" ) && viewNumber != null && ! viewNumber . equals ( \"0\" ) ) { String filenameFormat = UtilProperties . getPropertyValue ( \"catalog\" , \"image.filename.additionalviewsize.format\" ) ; filenameExpander = FlexibleStringExpander . getInstance ( filenameFormat ) ; id = ( String ) context . get ( \"productId\" ) ; if ( filenameFormat . endsWith ( \"${id}\" ) ) { id = id + \"_View_\" + viewNumber ; } else { viewType = \"additional\" + viewNumber ; } fileLocation = filenameExpander . expandString ( UtilMisc . toMap ( \"location\" , \"products\" , \"id\" , id , \"viewtype\" , viewType , \"sizetype\" , \"original\" ) ) ; } else { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ProductImageViewType\" , UtilMisc . toMap ( \"viewType\" , type ) , locale ) ) ; } if ( fileLocation . lastIndexOf ( \"/\" ) != - 1 ) { fileLocation . substring ( 0 , fileLocation . lastIndexOf ( \"/\" ) + 1 ) ; } resultBufImgMap . putAll ( ImageTransform . getBufferedImage ( imageServerPath + \"/\" + fileLocation + \".\" + imgExtension , locale ) ) ; if ( resultBufImgMap . containsKey ( \"responseMessage\" ) && resultBufImgMap . get ( \"responseMessage\" ) . equals ( \"success\" ) ) { bufImg = ( BufferedImage ) resultBufImgMap . get ( \"bufferedImage\" ) ; imgHeight = bufImg . getHeight ( ) ; imgWidth = bufImg . getWidth ( ) ; if ( imgHeight == 0.0 || imgWidth == 0.0 ) { String errMsg = UtilProperties . getMessage ( resource , \"ScaleImage.one_current_image_dimension_is_null\" , locale ) + \" : imgHeight = \" + imgHeight + \" ; imgWidth = \" + imgWidth ; Debug . logError ( errMsg , module ) ; result . put ( \"errorMessage\" , errMsg ) ; return result ; } for ( Map . Entry < String , Map < String , String > > entry : imgPropertyMap . entrySet ( ) ) { String sizeType = entry . getKey ( ) ; resultScaleImgMap . putAll ( ImageTransform . scaleImage ( bufImg , imgHeight , imgWidth , imgPropertyMap , sizeType , locale ) ) ; if ( resultScaleImgMap . containsKey ( \"responseMessage\" ) && resultScaleImgMap . get ( \"responseMessage\" ) . equals ( \"success\" ) ) { bufNewImg = ( BufferedImage ) resultScaleImgMap . get ( \"bufferedImage\" ) ; String newFileLocation = null ; filenameToUse = sizeType + filenameToUse . substring ( filenameToUse . lastIndexOf", "gt": "( \".\" ) ) ;", "prediction": "( \".\" ) ) ;\n", "label": 0}
{"id": 13558, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import org . eclipse . rap . rwt . internal . theme . QxFont ; import junit . framework . TestCase ; public class QxFont_Test extends TestCase { public void testIllegalArguments ( ) { try { QxFont . valueOf ( null ) ; fail ( \"null arguement should throw NPE\" ) ; } catch ( NullPointerException e ) { } try { QxFont . valueOf ( \"\" ) ; fail ( \"empty imput should throw IAE\" ) ; } catch ( IllegalArgumentException e ) { } } public void testParse1 ( ) { String def = \"bold 16 \\\"Bitstream Vera Sans\\\" , Helvetica,sans-serif\" ; QxFont qxFont = QxFont . valueOf ( def ) ; assertTrue ( qxFont . bold ) ; assertFalse ( qxFont . italic ) ; assertEquals ( 16 , qxFont . size ) ; assertEquals ( 3 , qxFont . family . length ) ; assertEquals ( \"Bitstream Vera Sans\" , qxFont . family [ 0 ] ) ; assertEquals ( \"Helvetica\" , qxFont . family [ 1 ] ) ; assertEquals ( \"sans-serif\" , qxFont . family [ 2 ] ) ; } public void testParse2 ( ) { String def = \"italic 11px 'Bitstream Vera Sans', Helvetica, sans-serif\" ; QxFont qxFont = QxFont . valueOf ( def ) ; assertFalse ( qxFont . bold ) ; assertTrue ( qxFont . italic ) ; assertEquals ( 11 , qxFont . size ) ; assertEquals ( 3 , qxFont . family . length ) ; assertEquals ( \"Bitstream Vera Sans\" , qxFont . family [ 0 ] ) ; assertEquals ( \"Helvetica\" , qxFont . family [ 1 ] ) ; assertEquals", "gt": "( \"sans-serif\" , qxFont . family [ 2 ] ) ;", "prediction": "( \"sans-serif\" , qxFont . family [ 2 ] ) ;\n", "label": 1}
{"id": 6529, "input": "<s> package PackageClassClash ; public class PackageClassClash { private void foo ( ) { } class Inner {", "gt": "private void bar ( )", "prediction": "}\n", "label": 0}
{"id": 13562, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import org . restlet . Restlet ; import org . restlet . ext . wadl . WadlApplication ; import org . restlet . routing . Router ; public class MailServerApplication extends WadlApplication { public MailServerApplication ( ) { setName ( \"RESTful Mail API application\" ) ; setDescription ( \"Example API for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; } @ Override public Restlet createInboundRoot ( ) { Router router", "gt": "= new Router ( getContext ( ) ) ;", "prediction": "= new Router ( ) ;\n", "label": 1}
{"id": 1202, "input": "<s> package pack1 ; public class Symbol { public", "gt": "static class CompletionFailure extends RuntimeException", "prediction": "static final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 13569, "input": "<s> package org . eclipse . xtext . xdoc . validation ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . xtext . validation . Check ; import org . eclipse . xtext . validation . ValidationMessageAcceptor ; import org . eclipse . xtext . xdoc . generator . util . LatexUtils ; import org . eclipse . xtext . xdoc . xdoc . AbstractSection ; import org . eclipse . xtext . xdoc . xdoc . CodeBlock ; import org . eclipse . xtext . xdoc . xdoc . CodeRef ; import org . eclipse . xtext . xdoc . xdoc . ImageRef ; import org . eclipse . xtext . xdoc . xdoc . Ref ; import org . eclipse . xtext . xdoc . xdoc . Table ; import org . eclipse . xtext . xdoc . xdoc . TableRow ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class XdocJavaValidator extends AbstractXdocJavaValidator { @ Check public void checkConsistentNumberOfColumns ( Table t ) { int columns = - 1 ; EList < TableRow > rows = t . getRows ( ) ; for ( TableRow tableRow : rows ) { if ( columns == - 1 ) columns = tableRow . getData ( ) . size ( ) ; if ( tableRow . getData ( ) . size ( ) != columns ) { error ( \"Each row must have the same number of entries (expected \" + columns + \" but was \" + tableRow . getData ( ) . size ( ) + \")\" , tableRow , XdocPackage . Literals . TABLE_ROW__DATA , ValidationMessageAcceptor . INSIGNIFICANT_INDEX ) ; } } } @ Check public void checkAbstractSectionHasTitle ( AbstractSection section ) { if ( section . getTitle ( ) == null ) warning ( \"This element should have a title.\" , null , 0 ) ; } @ Check public void checkNoCodeInTitle ( CodeBlock code ) { if ( ! LatexUtils . inline ( code ) ) { EObject tom = code . eContainer ( ) ; while ( ! ( tom . eContainer ( ) instanceof AbstractSection ) ) { tom = tom . eContainer ( ) ; } if ( tom . eContainer ( ) instanceof AbstractSection ) { AbstractSection section = ( AbstractSection ) tom . eContainer ( ) ; if ( section . getTitle ( ) == tom ) { error ( \"Headings can not contain code blocks\" , null ) ; } } } } @ Check public void checkImagePath ( ImageRef image ) { URI inPath = URI . createURI ( image . eResource ( ) . getURI ( ) . trimSegments ( 1 ) . toString ( ) + \"/\" + image . getPath ( ) ) ; if ( ! image . eResource ( ) . getResourceSet ( ) . getURIConverter ( ) . exists ( inPath , null ) ) error ( \"Cannot find image\" , XdocPackage . Literals . IMAGE_REF__PATH ) ; } @ Check public void checkNestedLinkElements ( EObject linkElement ) { if ( isLinkElement ( linkElement ) ) { EObject currentElement = linkElement . eContainer ( ) ; while ( currentElement != null ) { if ( isLinkElement ( currentElement ) ) { error ( \"Cannot nest link element \" + linkElement . eClass ( ) . getName ( ) + \" in \" + currentElement . eClass ( ) . getName ( ) , null ) ; } currentElement = currentElement . eContainer ( ) ; } } } private boolean isLinkElement ( EObject element ) { return element instanceof Ref || element instanceof CodeRef ; } @ Override protected List < EPackage > getEPackages ( ) { return Collections . singletonList (", "gt": "( EPackage ) XdocPackage . eINSTANCE ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10002, "input": "<s> package org . ofbiz . base . config ; import java . net . URL ; import java . io . InputStream ; import org . ofbiz . base . util . UtilURL ; @ SuppressWarnings ( \"serial\" ) public class FileLoader extends ResourceLoader implements java . io . Serializable { @ Override public URL getURL ( String location ) throws GenericConfigException { String fullLocation = fullLocation ( location ) ; URL fileUrl = null ; fileUrl = UtilURL . fromFilename ( fullLocation ) ; if ( fileUrl == null ) { throw new GenericConfigException ( \"File Resource not found: \" + fullLocation ) ; } return fileUrl ; } @ Override public InputStream loadResource ( String location ) throws GenericConfigException { URL fileUrl = getURL ( location ) ; try { return fileUrl . openStream ( ) ; } catch ( java .", "gt": "io . IOException e )", "prediction": "io . IOException e )\n", "label": 0}
{"id": 13576, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . actions . PartEventAction ; import org . eclipse . ui . actions . ActionFactory . IWorkbenchAction ; public abstract class PageEventAction extends PartEventAction implements IPageListener , ActionFactory . IWorkbenchAction { private IWorkbenchPage activePage ; private IWorkbenchWindow workbenchWindow ; protected PageEventAction ( String text , IWorkbenchWindow window ) { super ( text ) ; if ( window == null ) { throw new IllegalArgumentException ( ) ; } this . workbenchWindow = window ; this . activePage = window . getActivePage ( ) ; this . workbenchWindow .", "gt": "addPageListener ( this ) ;", "prediction": "setActivePage ( activePage ) ;\n", "label": 1}
{"id": 1907, "input": "<s> package com . sun . mirror . declaration ; import java . util . Collection ; @ Deprecated @ SuppressWarnings ( \"deprecation\" )", "gt": "public interface EnumDeclaration extends ClassDeclaration", "prediction": "@ SuppressWarnings ( \"unchecked\" ) @ Deprecated public class AbstractDeclaration\n", "label": 0}
{"id": 13580, "input": "<s> package org . apache . lucene . search . similar ; import org . apache . lucene . util . PriorityQueue ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermFreqVector ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . DefaultSimilarity ; import org . apache . lucene . search . Similarity ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Hits ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . document . Document ; import java . util . Set ; import java . util . HashMap ; import java . util . Map ; import java . util . Collection ; import java . util . Iterator ; import java . io . IOException ; import java . io . Reader ; import java . io . File ; import java . io . PrintStream ; import java . io . StringReader ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . net . URL ; import java . util . ArrayList ; public final class MoreLikeThis { public static final int DEFAULT_MAX_NUM_TOKENS_PARSED = 5000 ; public static final Analyzer DEFAULT_ANALYZER = new StandardAnalyzer ( ) ; public static final int DEFAULT_MIN_TERM_FREQ = 2 ; public static final int DEFAULT_MIN_DOC_FREQ = 5 ; public static final boolean DEFAULT_BOOST = false ; public static final String [ ] DEFAULT_FIELD_NAMES = new String [ ] { \"contents\" } ; public static final int DEFAULT_MIN_WORD_LENGTH = 0 ; public static final int DEFAULT_MAX_WORD_LENGTH = 0 ; public static final Set DEFAULT_STOP_WORDS = null ; private Set stopWords = DEFAULT_STOP_WORDS ; public static final int DEFAULT_MAX_QUERY_TERMS = 25 ; private Analyzer analyzer = DEFAULT_ANALYZER ; private int minTermFreq = DEFAULT_MIN_TERM_FREQ ; private int minDocFreq = DEFAULT_MIN_DOC_FREQ ; private boolean boost = DEFAULT_BOOST ; private String [ ] fieldNames = DEFAULT_FIELD_NAMES ; private int maxNumTokensParsed = DEFAULT_MAX_NUM_TOKENS_PARSED ; private int minWordLen = DEFAULT_MIN_WORD_LENGTH ; private int maxWordLen = DEFAULT_MAX_WORD_LENGTH ; private int maxQueryTerms = DEFAULT_MAX_QUERY_TERMS ; private Similarity similarity ; private final IndexReader ir ; private float boostFactor = 1 ; public float getBoostFactor ( ) { return boostFactor ; } public void setBoostFactor ( float boostFactor ) { this . boostFactor = boostFactor ; } public MoreLikeThis ( IndexReader ir ) { this ( ir , new DefaultSimilarity ( ) ) ; } public MoreLikeThis ( IndexReader ir , Similarity sim ) { this . ir = ir ; this . similarity = sim ; } public Similarity getSimilarity ( ) { return similarity ; } public void setSimilarity ( Similarity similarity ) { this . similarity = similarity ; } public Analyzer getAnalyzer ( ) { return analyzer ; } public void setAnalyzer ( Analyzer analyzer ) { this . analyzer = analyzer ; } public int getMinTermFreq ( ) { return minTermFreq ; } public void setMinTermFreq ( int minTermFreq ) { this . minTermFreq = minTermFreq ; } public int getMinDocFreq ( ) { return minDocFreq ; } public void setMinDocFreq ( int minDocFreq ) { this . minDocFreq = minDocFreq ; } public boolean isBoost ( ) { return boost ; } public void setBoost ( boolean boost ) { this . boost = boost ; } public String [ ] getFieldNames ( ) { return fieldNames ; } public void setFieldNames ( String [ ] fieldNames ) { this . fieldNames = fieldNames ; } public int getMinWordLen ( ) { return minWordLen ; } public void setMinWordLen ( int minWordLen ) { this . minWordLen = minWordLen ; } public int getMaxWordLen ( ) { return maxWordLen ; } public void setMaxWordLen ( int maxWordLen ) { this . maxWordLen = maxWordLen ; } public void setStopWords ( Set stopWords ) { this . stopWords = stopWords ; } public Set getStopWords ( ) { return stopWords ; } public int getMaxQueryTerms ( ) { return maxQueryTerms ; } public void setMaxQueryTerms ( int maxQueryTerms ) { this . maxQueryTerms = maxQueryTerms ; } public int getMaxNumTokensParsed ( ) { return maxNumTokensParsed ; } public void setMaxNumTokensParsed ( int i ) { maxNumTokensParsed = i ; } public Query like ( int docNum ) throws IOException { if ( fieldNames == null ) { Collection fields = ir . getFieldNames ( IndexReader . FieldOption . INDEXED ) ; fieldNames = ( String [ ] ) fields . toArray ( new String [ fields . size ( ) ] ) ; } return createQuery ( retrieveTerms ( docNum ) ) ; } public Query", "gt": "like ( File f ) throws IOException", "prediction": "like ( int docNum ) throws IOException\n", "label": 1}
{"id": 8386, "input": "<s> public class VarDeclarationWithAssignment { int x ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < 1 ; i ++ ) ; VarDeclarationWithAssignment c = new VarDeclarationWithAssignment ( ) ; int j = ( j = 4 ) ;", "gt": "c . x = 11 ;", "prediction": "for ( int j = 0 ;\n", "label": 0}
{"id": 13598, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . stats . Report ; import org . apache . lucene . benchmark . byTask . stats . TaskStats ; public class RepSumByNameRoundTask extends ReportTask { public RepSumByNameRoundTask ( PerfRunData runData ) { super ( runData ) ; } public int doLogic ( ) throws Exception { Report rp = reportSumByNameRound ( getRunData ( ) . getPoints ( ) . taskStats ( ) ) ; System . out . println ( ) ; System . out . println ( \"------------> Report Sum By (any) Name and Round (\" + rp . getSize ( ) + \" about \" + rp . getReported ( ) + \" out of \" + rp . getOutOf ( ) + \")\" ) ; System . out . println ( rp . getText ( ) ) ; System . out . println ( ) ; return 0 ; } protected Report reportSumByNameRound ( List taskStats ) { LinkedHashMap p2 = new LinkedHashMap ( ) ; int reported = 0 ; for ( Iterator it = taskStats . iterator ( ) ; it . hasNext ( ) ; ) { TaskStats stat1 = ( TaskStats ) it . next ( ) ; if ( stat1 . getElapsed ( ) >= 0 ) { reported ++ ; String name = stat1 . getTask ( ) . getName ( ) ; String rname = stat1 . getRound ( ) + \".\" + name ; TaskStats stat2 = ( TaskStats ) p2 . get ( rname ) ; if ( stat2 == null ) { try { stat2 = ( TaskStats ) stat1", "gt": ". clone ( ) ;", "prediction": ";\n", "label": 1}
{"id": 5534, "input": "<s> package org . meqantt . message ; import java . io . IOException ; public class PubRecMessage extends RetryableMessage { public PubRecMessage ( int messageId ) { super ( Type . PUBREC ) ; setMessageId ( messageId ) ; } public PubRecMessage ( Header header ) throws IOException { super ( header ) ; } @ Override public void setDup ( boolean dup ) { throw new UnsupportedOperationException ( \"PubRec messages don't use the DUP flag.\" ) ; } @ Override public void setRetained ( boolean retain ) { throw new UnsupportedOperationException ( \"PubRec messages don't use the RETAIN flag.\" ) ; } @ Override public void", "gt": "setQos ( QoS qos )", "prediction": "setRetrieved ( boolean retrieved )\n", "label": 0}
{"id": 13599, "input": "<s> package org . restlet . ext . xdb . internal ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PushbackInputStream ; public class ChunkedInputStream extends InputEntityStream { private static final int PUSHBBACK_BUFFER_SIZE = 2 ; private volatile long chunkSize ; private volatile boolean endReached ; private volatile boolean initialized ; private volatile long position ; private final PushbackInputStream source ; public ChunkedInputStream ( Notifiable notifiable , InputStream inboundStream ) { super ( notifiable , inboundStream ) ; this . source = new PushbackInputStream ( inboundStream , PUSHBBACK_BUFFER_SIZE ) ; this . initialized = false ; this . endReached = false ; this . position = 0 ; this . chunkSize = 0 ; } private boolean canRead ( ) throws IOException { boolean result = false ; initialize ( ) ; if ( ! this . endReached ) { if ( ! chunkAvailable ( ) ) { initializeChunk ( ) ; } result = ! this . endReached ; } return result ; } private void checkCRLF ( ) throws IOException { final int cr = this . source . read ( ) ; final int lf = this . source . read ( ) ; if ( ( cr != '\\r' ) || ( lf != '\\n' ) ) { this . source . unread ( lf ) ; this . source . unread ( cr ) ; } } private boolean chunkAvailable ( ) { return this . position < this . chunkSize ; } @ Override public void close ( ) throws IOException { super . close ( ) ; this . initialized = true ; onEndReached ( ) ; } private void initialize ( ) throws IOException { if ( ! this . initialized ) { checkCRLF ( ) ; this . initialized = true ; } } private void initializeChunk ( ) throws IOException { this . chunkSize = readChunkSize ( ) ; this . position = 0 ; if ( this . chunkSize == 0 ) { onEndReached ( ) ; checkCRLF ( ) ; } } @ Override protected void onEndReached ( ) { super . onEndReached ( ) ; this . endReached = true ; } @ Override public int read ( ) throws IOException { int result = - 1 ; if ( canRead ( ) ) { result = this . source . read ( ) ; this . position ++ ; if ( ( result == - 1 ) ) { onEndReached ( ) ; } } return result ; } @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { int result = - 1 ; if ( canRead ( ) ) { result = this . source . read ( b , off , Math . min ( len , ( int ) ( this . chunkSize", "gt": "- this . position ) ) ) ;", "prediction": ") ) ) ;\n", "label": 1}
{"id": 4807, "input": "<s> package com . redhat . ceylon . compiler . java . loader . model ; import com . redhat . ceylon . compiler . java . loader . CeylonModelLoader ; import com . redhat . ceylon . compiler . loader . AbstractModelLoader ; import com . redhat . ceylon . compiler . loader . model . LazyModule ; import com . sun . tools . javac . util . Context ; public class CompilerModule extends LazyModule { private Context context ; private AbstractModelLoader modelLoader ; public CompilerModule ( com . sun . tools . javac . util . Context context ) { this . context = context ; } public CompilerModule ( AbstractModelLoader modelLoader ) { this . modelLoader = modelLoader ; } @ Override", "gt": "protected AbstractModelLoader getModelLoader ( )", "prediction": "public Context getContext ( )\n", "label": 0}
{"id": 13603, "input": "<s> package org . nuxeo . theme . editor . filters ; import org . nuxeo . theme . rendering . RenderingInfo ; import org . nuxeo . theme . rendering . StandaloneFilter ; public final class IdentifiableContainer extends StandaloneFilter { @ Override public RenderingInfo process ( final RenderingInfo info , final boolean cache ) { info . setMarkup ( String . format ( \"<div id=\\\"e%s\\\">%s</div>\" , info . getElement ( ) . getUid ( ) ,", "gt": "info . getMarkup ( ) ) ) ;", "prediction": "cache ) ) ;\n", "label": 1}
{"id": 1382, "input": "<s> package pkg3 ; public interface I2 {", "gt": "public void foo ( ) ;", "prediction": "public void setUp ( ) ;\n", "label": 0}
{"id": 13605, "input": "<s> package org . nuxeo . ecm . automation . server . jaxrs ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationDocumentation ; import org . nuxeo . ecm . automation . OperationParameters ; public class AutomationInfo { protected final List < OperationDocumentation > ops ; protected final List < OperationDocumentation > chains ; public AutomationInfo ( AutomationService service ) { ops = service . getDocumentation ( ) ; Map < String , OperationDocumentation > map = new HashMap < String , OperationDocumentation > ( ) ; for ( OperationDocumentation doc : ops ) { map . put ( doc . id , doc ) ; } chains = new ArrayList < OperationDocumentation > ( ) ; for ( OperationChain chain : service . getOperationChains ( ) ) { OperationDocumentation doc = new OperationDocumentation ( chain . getId ( ) ) ; doc . description = chain . getDescription ( ) ; doc . category = \"Chain\" ; doc . label = doc . id ; doc . params = Collections . emptyList ( ) ; List < OperationParameters > ops = chain . getOperations ( ) ; if ( ops . isEmpty ( ) ) { doc . signature = new String [ ] { \"void\" , \"void\" } ; } else if ( ops . size ( ) == 1 ) { OperationDocumentation opdoc = map . get ( ops . get ( 0 ) . id ( ) ) ; doc . signature = opdoc . signature ; } else { ArrayList < String [ ] > sigs = new ArrayList < String [ ] > ( ) ; for ( OperationParameters o : ops ) { sigs . add ( map . get ( o . id ( ) ) . signature ) ; } String [ ] head = sigs . get ( 0 ) ; ArrayList < String > rs = new ArrayList < String > ( ) ; for ( int i = 0 ; i < head . length ; i += 2 ) { String in = head [ i ] ; String out = head [ i + 1 ] ; List < String > result = new ArrayList < String > ( ) ; checkPath ( out , sigs , 1 , result ) ; for ( String r : result ) { rs . add ( in ) ; rs . add ( r ) ; } } doc . signature = rs . toArray ( new String [ rs . size ( ) ] ) ; } chains . add ( doc ) ; } } protected void checkPath ( String in , List < String [ ] > sigs , int offset , List < String > result ) { boolean last = sigs . size ( ) - 1 == offset ; String [ ] sig = sigs . get ( offset ) ; for ( int i = 0 ; i < sig . length ; i += 2 ) { if ( \"void\" . equals ( in ) || \"void\" . equals ( sig [ i ] ) || in . equals ( sig [ i ] ) ) { if ( last ) { result . add", "gt": "( sig [ i + 1 ] ) ;", "prediction": "( in ) ;\n", "label": 1}
{"id": 7322, "input": "<s> package com . sun . tools . classfile ; public class DescriptorException extends Exception { private static", "gt": "final long serialVersionUID = 2411890273788901032L ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 13608, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . * ; import oracle . jdbc . * ; import oracle . jdbc . pool . OracleDataSource ; public class BatchUpdates { public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; PreparedStatement pstmt = null ; ResultSet rset = null ; int i = 0 ; try { String url = \"jdbc:oracle:oci8:@\" ; try { String url1 = System . getProperty ( \"JDBC_URL\" ) ; if ( url1 != null ) url = url1 ; } catch ( Exception e ) { } OracleDataSource ods = new OracleDataSource ( ) ; ods . setUser ( \"hr\" ) ; ods . setPassword ( \"hr\" ) ; ods . setURL ( url ) ; conn = ods . getConnection ( ) ; stmt = conn . createStatement ( ) ; try { stmt . execute ( \"create table mytest_table (col1 number, col2 varchar2(20))\" ) ; } catch ( Exception e1 ) { } pstmt = conn . prepareStatement ( \"insert into mytest_table values (?, ?)\" ) ; pstmt . setInt ( 1 , 1 ) ; pstmt .", "gt": "setString ( 2 , \"row 1\" ) ;", "prediction": "setInt ( 2 , 2 ) ;\n", "label": 1}
{"id": 934, "input": "<s> package com . redhat . ceylon . compiler . loader . mirror ; public interface AnnotationMirror {", "gt": "Object getValue ( String fieldName ) ;", "prediction": "}\n", "label": 0}
{"id": 13617, "input": "<s> package org . restlet . ext . rdf . internal . turtle ; import java . io . IOException ; public abstract class LexicalUnit { private RdfTurtleReader contentReader ; private Context context ; private String value ; public LexicalUnit ( RdfTurtleReader contentReader , Context context ) { super ( ) ; this . contentReader = contentReader ; this . context = context ; } public LexicalUnit ( String value ) { super ( ) ; setValue ( value ) ; } public RdfTurtleReader getContentReader ( ) { return contentReader ; } public Context getContext ( ) { return context ; } public String getValue ( ) { return value ; } public abstract void parse ( ) throws IOException ;", "gt": "public abstract Object resolve ( ) ;", "prediction": "}\n", "label": 1}
{"id": 5648, "input": "<s> package org . ofbiz . pos . jpos . service ; import java . util . List ; import javolution . util . FastList ; import jpos . services . EventCallbacks ; import jpos . JposException ; import jpos . JposConst ; import jpos . events . DataEvent ; import jpos . events . ErrorEvent ; import jpos . events . DirectIOEvent ; import jpos . events . OutputCompleteEvent ; import jpos . events . StatusUpdateEvent ; import jpos . config . JposEntry ; public class BaseService implements jpos . services . BaseService , jpos . loader . JposServiceInstance { public static final String module = BaseService . class . getName ( ) ; protected static boolean claimed = false ; protected List < Object > eventQueue = FastList . newInstance ( ) ; protected JposEntry entry = null ; protected boolean freezeEvents = false ; protected boolean deviceEnabled = false ; protected boolean eventsEnabled = true ; protected String deviceName = null ; protected String healthText = null ; protected String physicalName = null ; protected String physicalDesc = null ; protected String serviceDesc = null ; protected int serviceVer = 1007000 ; protected int state = JposConst . JPOS_S_CLOSED ; private EventCallbacks ecb = null ; public void open ( String deviceName , EventCallbacks ecb ) throws JposException { this . deviceName = deviceName ; this . ecb = ecb ; this . healthText = \"OK\" ; this . state = JposConst . JPOS_S_IDLE ; this . serviceDesc = entry . getProp ( JposEntry . DEVICE_CATEGORY_PROP_NAME ) . getValueAsString ( ) ; this . physicalDesc = entry . getProp ( JposEntry . PRODUCT_DESCRIPTION_PROP_NAME ) . getValueAsString ( ) ; this . physicalName = entry . getProp ( JposEntry . PRODUCT_NAME_PROP_NAME ) . getValueAsString ( ) ; } public void claim ( int i ) throws JposException { BaseService . claimed = true ; } public void release ( ) throws JposException { BaseService . claimed = false ; } public void close ( ) throws JposException { BaseService . claimed = false ; this . freezeEvents = false ; this . deviceEnabled = false ; this . ecb = null ; this . healthText = \"CLOSED\" ; this . state = JposConst . JPOS_S_CLOSED ; } public String getCheckHealthText ( ) throws JposException { return this . healthText ; } public boolean getClaimed ( ) throws JposException { return BaseService . claimed ; } public int getDataCount ( ) throws JposException { return this . eventQueue . size ( ) ; } public boolean getDataEventEnabled ( ) throws JposException { return this . eventsEnabled ; } public void setDataEventEnabled ( boolean b ) throws JposException { boolean fireEvents = false ; if ( ! this . eventsEnabled && b ) { fireEvents = true ; } this . eventsEnabled = b ; if ( fireEvents ) { this . fireQueuedEvents ( ) ; } } public boolean getDeviceEnabled ( ) throws JposException { return this . deviceEnabled ; } public void setDeviceEnabled ( boolean b ) throws JposException { this . deviceEnabled = b ; } public String getDeviceServiceDescription ( ) throws JposException { return this . serviceDesc ; } public int getDeviceServiceVersion ( ) throws JposException { return this . serviceVer ; } public boolean getFreezeEvents ( ) throws JposException { return this . freezeEvents ; } public void setFreezeEvents ( boolean b ) throws JposException { this . freezeEvents = b ; } public String getPhysicalDeviceDescription ( ) throws JposException { return this . physicalDesc ; } public String getPhysicalDeviceName ( ) throws JposException { return this . physicalName ; } public int getState ( ) throws JposException { return this . state ; } public void checkHealth ( int i ) throws JposException { } public void directIO ( int i , int [ ] ints , Object o ) throws JposException { } public void setEntry ( JposEntry entry ) { this . entry = entry ; } public void deleteInstance ( ) throws JposException { } protected void fireEvent ( Object ev ) { if ( this . eventsEnabled && this . ecb != null ) { if ( ev instanceof DataEvent ) { this . ecb . fireDataEvent ( ( DataEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireDirectIOEvent ( ( DirectIOEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireErrorEvent ( ( ErrorEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb .", "gt": "fireOutputCompleteEvent ( ( OutputCompleteEvent ) ev ) ;", "prediction": "fireErrorEvent ( ( ErrorEvent ) ev ) ;\n", "label": 0}
{"id": 13622, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Iterator ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . document . CompressionTools ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMOutputStream ; import org . apache . lucene . store . IndexOutput ; import org . apache . lucene . store . IndexInput ; final class FieldsWriter { static final byte FIELD_IS_TOKENIZED = 0x1 ; static final byte FIELD_IS_BINARY = 0x2 ; static final byte FIELD_IS_COMPRESSED = 0x4 ; static final int FORMAT = 0 ; static final int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES = 1 ; static final int FORMAT_CURRENT = FORMAT_VERSION_UTF8_LENGTH_IN_BYTES ; private FieldInfos fieldInfos ; private IndexOutput fieldsStream ; private IndexOutput indexStream ; private boolean doClose ; FieldsWriter ( Directory d , String segment , FieldInfos fn ) throws IOException { fieldInfos = fn ; boolean success = false ; final String fieldsName = segment + \".\" + IndexFileNames . FIELDS_EXTENSION ; try { fieldsStream = d . createOutput ( fieldsName ) ; fieldsStream . writeInt ( FORMAT_CURRENT ) ; success = true ; } finally { if ( ! success ) { try { close ( ) ; } catch ( Throwable t ) { } try { d . deleteFile ( fieldsName ) ; } catch ( Throwable t ) { } } } success = false ; final String indexName = segment + \".\" + IndexFileNames . FIELDS_INDEX_EXTENSION ; try { indexStream = d . createOutput ( indexName ) ; indexStream . writeInt ( FORMAT_CURRENT ) ; success = true ; } finally { if ( ! success ) { try { close ( ) ; } catch ( IOException ioe ) { } try { d . deleteFile ( fieldsName ) ; } catch ( Throwable t ) { } try { d . deleteFile ( indexName ) ; } catch ( Throwable t ) { } } } doClose = true ; } FieldsWriter ( IndexOutput fdx , IndexOutput fdt , FieldInfos fn ) { fieldInfos = fn ; fieldsStream = fdt ; indexStream = fdx ; doClose = false ; } void setFieldsStream ( IndexOutput stream ) { this . fieldsStream = stream ; } void flushDocument ( int numStoredFields , RAMOutputStream buffer ) throws IOException { indexStream . writeLong ( fieldsStream . getFilePointer ( ) ) ; fieldsStream . writeVInt ( numStoredFields ) ; buffer . writeTo ( fieldsStream ) ; } void skipDocument ( ) throws IOException { indexStream . writeLong ( fieldsStream . getFilePointer ( ) ) ; fieldsStream . writeVInt ( 0 ) ; } void flush ( ) throws IOException { indexStream . flush ( ) ; fieldsStream . flush ( ) ; } final void close ( ) throws IOException { if ( doClose ) { try { if ( fieldsStream != null ) { try { fieldsStream . close ( ) ; } finally { fieldsStream = null ; } } } catch ( IOException ioe ) { try { if ( indexStream != null ) { try { indexStream . close ( ) ; } finally { indexStream = null ; } } } catch ( IOException ioe2 ) { } throw ioe ; } finally { if ( indexStream != null ) { try { indexStream . close ( ) ; } finally { indexStream = null ; } } } } } final void writeField ( FieldInfo fi , Fieldable field ) throws IOException { boolean disableCompression = ( field instanceof FieldsReader . FieldForMerge ) ; fieldsStream . writeVInt ( fi . number ) ; byte bits = 0 ; if ( field . isTokenized ( ) ) bits |= FieldsWriter . FIELD_IS_TOKENIZED ; if ( field . isBinary ( ) ) bits |= FieldsWriter . FIELD_IS_BINARY ; if ( field", "gt": ". isCompressed ( ) ) bits |= FieldsWriter . FIELD_IS_COMPRESSED ;", "prediction": ". isCOMPRESSED ( ) ) bits |= FieldsWriter . FIELD_IS_COMPRESSED ;\n", "label": 1}
{"id": 7219, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . gmf . runtime . emf . core . util . EObjectAdapter ; import org . eclipse . gmf . runtime . emf . type . core . IElementType ; public class SimplemapLinkDescriptor extends SimplemapNodeDescriptor { private EObject mySource ; private EObject myDestination ; private IAdaptable mySemanticAdapter ; private SimplemapLinkDescriptor ( EObject source , EObject destination , EObject linkElement , int linkVID ) { super ( linkElement , linkVID ) ; mySource = source ; myDestination = destination ; } public SimplemapLinkDescriptor ( EObject source , EObject destination , IElementType elementType , int linkVID ) { this ( source , destination , ( EObject ) null , linkVID ) ; final IElementType elementTypeCopy = elementType ; mySemanticAdapter = new IAdaptable ( ) { public Object getAdapter ( Class adapter ) { if ( IElementType . class . equals ( adapter ) ) { return elementTypeCopy ; } return null ; } } ; } public SimplemapLinkDescriptor ( EObject source , EObject destination , EObject linkElement , IElementType elementType , int linkVID ) { this ( source , destination , linkElement , linkVID ) ; final", "gt": "IElementType elementTypeCopy = elementType ;", "prediction": "IAdaptable mySemanticAdapter = new IAdaptable ( )\n", "label": 0}
{"id": 13629, "input": "<s> package org . apache . sqoop . tool ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . cli . ToolOptions ; public class ListTablesTool extends com . cloudera . sqoop . tool . BaseSqoopTool { public static final Log LOG = LogFactory . getLog ( ListTablesTool . class . getName ( ) ) ; public ListTablesTool ( ) { super ( \"list-tables\" ) ; } @ Override public int run ( SqoopOptions options ) { if ( ! init ( options ) ) { return 1 ; } try { String [ ] tables = manager . listTables ( ) ; if ( null == tables ) { System . err . println ( \"Could not retrieve tables list from server\" ) ; LOG . error ( \"manager.listTables() returned null\" ) ; return 1 ; } else { for ( String tbl : tables ) { System . out . println ( tbl ) ; } } } finally { destroy ( options ) ; } return 0 ; } @ Override public void configureOptions ( ToolOptions toolOptions ) { toolOptions . addUniqueOptions ( getCommonOptions ( ) ) ; } @ Override public void applyOptions ( CommandLine in , SqoopOptions out ) throws InvalidOptionsException { applyCommonOptions ( in , out ) ; } @ Override public", "gt": "void validateOptions ( SqoopOptions options ) throws InvalidOptionsException", "prediction": "void removeCommonOptions ( ToolOptions toolOptions ) throws InvalidOptionsException\n", "label": 1}
{"id": 9310, "input": "<s> package org . ofbiz . base . util . collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; public class MapComparator implements Comparator < Map < Object , Object > > { public static final String module = MapComparator . class . getName ( ) ; private List < ? extends Object > keys ; public MapComparator ( List < ? extends Object > keys ) { this . keys = keys ; } @ Override public boolean equals ( Object obj ) { return obj . equals ( this ) ; } public int compare ( Map < Object , Object > map1 , Map < Object , Object > map2 ) { if ( keys == null || keys . size ( ) < 1 ) { throw new IllegalArgumentException ( \"No sort fields defined\" ) ; } for ( Object key : keys ) { boolean ascending = true ; Object o1 = null ; Object o2 = null ; if ( key instanceof FlexibleMapAccessor < ? > ) { FlexibleMapAccessor < Object > fmaKey = UtilGenerics . cast ( key ) ; ascending = fmaKey . getIsAscending ( ) ; o1 = fmaKey . get ( UtilGenerics . < String , Object > checkMap ( map1 ) ) ; o2 = fmaKey . get ( UtilGenerics . < String , Object > checkMap ( map2 ) ) ; } else { if ( key instanceof String ) { String keyStr = ( String ) key ; if ( keyStr . charAt ( 0 ) == '-' ) { ascending = false ; key = keyStr . substring ( 1 ) ; } else if ( keyStr . charAt ( 0 ) == '+' ) { ascending = true ; key = keyStr . substring ( 1 ) ; } }", "gt": "o1 = map1 . get ( key ) ;", "prediction": "}\n", "label": 0}
{"id": 13640, "input": "<s> package org . spliffy . server . web ; import org . spliffy . server . web . templating . Templater ; import org . hashsplit4j . api . BlobStore ; import org . hashsplit4j . api . HashStore ; import org . spliffy . server . apps . ApplicationManager ; import org . spliffy . server . manager . CurrentDateService ; import org . spliffy . server . manager . DefaultCurrentDateService ; import org . spliffy . server . manager . ResourceManager ; import org . spliffy . server . manager . ShareManager ; import org . spliffy . server . web . templating . Formatter ; import org . spliffy . server . web . templating . HtmlTemplateParser ; import org . spliffy . server . web . templating . HtmlTemplater ; import org . spliffy . server . web . templating . TextTemplater ; public class Services { private final HashStore hashStore ; private final BlobStore blobStore ; private final Templater htmlTemplater ; private final Templater textTemplater ; private final SpliffySecurityManager securityManager ; private final ResourceManager resourceManager ; private final ShareManager shareManager ; private final ApplicationManager applicationManager ; private HtmlTemplateParser templateParser ; private final CurrentDateService currentDateService ; public Services ( HashStore hashStore , BlobStore blobStore , SpliffySecurityManager securityManager , ResourceManager resourceManager , ShareManager shareManager , ApplicationManager applicationManager ) { this . hashStore = hashStore ; this . blobStore = blobStore ; this . securityManager = securityManager ; this . resourceManager = resourceManager ; this . shareManager = shareManager ; this . applicationManager = applicationManager ; templateParser = new HtmlTemplateParser ( ) ; this . textTemplater = new", "gt": "TextTemplater ( securityManager ) ;", "prediction": "HtmlTemplateParser ( ) ;\n", "label": 1}
{"id": 2734, "input": "<s> package com . gisgraphy . client . administrativedivision ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . builder . ToStringStyle ; public final class GeonamesGeographicCountryInformation implements GeographicCountryInformation { private Long population ; private Double area ; private GeonamesGeographicCountryInformation ( Long population , Double area ) { super ( ) ; this . population = population ; this . area = area ; } public static GeonamesGeographicCountryInformation geographicCountryInformation ( ) { return new GeonamesGeographicCountryInformation ( null , null ) ; } public GeonamesGeographicCountryInformation withPopulation ( Long population ) { return new GeonamesGeographicCountryInformation ( population , this . area ) ; } public GeographicCountryInformation withArea ( Double area ) { return new GeonamesGeographicCountryInformation ( this . population , area ) ; } @ Override public int hashCode ( ) { return new HashCodeBuilder ( ) . append ( area ) . append ( population ) . toHashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; GeonamesGeographicCountryInformation other = ( GeonamesGeographicCountryInformation ) obj ; return new EqualsBuilder ( ) . append ( area , other . getArea ( ) ) . append ( population , other . getPopulation ( ) ) . isEquals ( ) ; } @ Override public String toString ( ) { return ToStringBuilder . reflectionToString ( this", "gt": ", ToStringStyle . SHORT_PREFIX_STYLE ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13646, "input": "<s> package cs224u . ingredients ; import java . util . List ; import cs224n . util . Counter ; public class SimpleRecipeClassifier extends RecipeClassifier { @ Override public void train ( List < Recipe > recipes ) { } @ Override public double assignSimilarity ( Recipe r1 , Recipe r2 ) { List < String > is1 = r1 . getIngredients ( ) ; List < String > is2 = r2 . getIngredients ( ) ; Counter < String > c1 = new Counter < String > ( ) ; Counter < String > c2 = new Counter < String > ( ) ; for ( String line : is1 ) { for ( String ingred : line . split ( \" \" ) ) { c1 . incrementCount ( ingred , 1.0 ) ; } } for ( String line : is2 ) { for ( String ingred : line . split ( \" \" ) ) { c2 . incrementCount ( ingred , 1.0 ) ; } } return c1", "gt": ". cosineSimilarity ( c2 ) ;", "prediction": ";\n", "label": 1}
{"id": 475, "input": "<s> package javax . lang . model . type ;", "gt": "public interface PrimitiveType extends TypeMirror", "prediction": "import java . lang . reflect . Type ;\n", "label": 0}
{"id": 13647, "input": "<s> package org . restlet . ext . sip . internal ; import java . util . Iterator ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . logging . Level ; import org . restlet . Client ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Protocol ; import org . restlet . engine . connector . ClientConnectionHelper ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . connector . InboundWay ; import org . restlet . engine . connector . OutboundWay ; import org . restlet . ext . sip . SipRequest ; import org . restlet . ext . sip . SipResponse ; import org . restlet . ext . sip . SipStatus ; public class SipClientHelper extends ClientConnectionHelper { private final Map < String , SipRequest > requests ; public SipClientHelper ( Client client ) { super ( client ) ; this . requests = new ConcurrentHashMap < String , SipRequest > ( ) ; getProtocols ( ) . add ( Protocol . SIP ) ; getProtocols ( ) . add ( Protocol . SIPS ) ; } @ Override protected boolean control ( ) { boolean result = super . control ( ) ; SipRequest request ; for ( Iterator < SipRequest > iter = getRequests ( ) . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { request = iter . next ( ) ; if ( request . hasTimedOut ( ) ) { Level level ; if ( request . isHandled ( ) || ! request . isExpectingResponse ( ) ) { level = Level . FINE ; } else { level = Level . INFO ; SipResponse response = new SipResponse ( request ) ; response . setStatus ( SipStatus . CLIENT_ERROR_REQUEST_TIMEOUT , \"The SIP client connector has timeout due to lack of activity on this transaction: \" + request . getTransaction ( ) ) ; handleInbound ( response , false ) ; } getLogger ( ) . log ( level , \"This SIP transaction has timed out: \" + request . getTransaction ( ) ) ; iter . remove ( ) ; } } return result ; } @ Override public InboundWay createInboundWay ( Connection < Client > connection , int bufferSize ) { return new SipClientInboundWay ( connection , bufferSize ) ; } @ Override public OutboundWay createOutboundWay ( Connection < Client > connection , int bufferSize ) { return new SipClientOutboundWay ( connection , bufferSize ) ; } @ Override public Request getRequest ( Response response ) { Request result = null ; if ( response != null ) { result = response . getRequest ( ) ; if ( result == null ) { SipResponse sipResponse = ( SipResponse ) response ; String tid = sipResponse . getTransactionId ( ) ; result = getRequests ( ) . get ( tid ) ; } } return result ; } public Map < String , SipRequest > getRequests ( ) { return requests ; } @ Override protected void unblock ( Response response ) { if ( response . getRequest ( ) != null ) { SipRequest request = ( SipRequest ) response", "gt": ". getRequest ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7611, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . tree . * ; import org . parboiled . support . Checks ; import static org . objectweb . asm . Opcodes . * ; import static org . parboiled . transform . AsmUtils . createArgumentLoaders ; class ConstructorGenerator { public void process ( ParserClassNode classNode ) { checkArgNotNull ( classNode , \"classNode\" ) ; Checks . ensure ( ! classNode . getConstructors ( ) . isEmpty ( ) , \"Could not extend parser class '%s', no constructor visible to derived classes found\" , classNode . getParentType ( ) . getClassName ( ) ) ; for ( MethodNode constructor : classNode . getConstructors ( ) ) { createConstuctor ( classNode , constructor ) ; } createNewInstanceMethod ( classNode ) ; } @ SuppressWarnings ( { \"unchecked\" } ) private void createConstuctor ( ParserClassNode classNode , MethodNode constructor ) { MethodNode newConstructor = new MethodNode ( ACC_PUBLIC , constructor . name , constructor . desc , constructor . signature , ( String [ ] ) constructor . exceptions . toArray ( new String [ constructor . exceptions . size ( ) ] ) ) ; InsnList instructions = newConstructor . instructions ; instructions . add ( new VarInsnNode ( ALOAD , 0 ) ) ; instructions . add ( createArgumentLoaders ( constructor . desc ) ) ; instructions . add ( new MethodInsnNode ( INVOKESPECIAL , classNode . getParentType ( ) . getInternalName ( ) , \"<init>\"", "gt": ", constructor . desc ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 13651, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . HeaderParam ; import javax . ws . rs . Path ; import javax . ws . rs . PathParam ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . Request ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . SecurityContext ; import javax . ws . rs . core . UriInfo ; import org . restlet . test . ext . jaxrs . services . tests . InjectionTest ; @ Path ( \"/InjectionTestService/two/{idf}\" ) public class InjectionTestService2 { @ Context private SecurityContext securityContext ; @ Context private UriInfo uriInfo ; @ Context private Request request ; @ Context private HttpHeaders httpHeaders ; @ PathParam ( \"idf\" ) private Integer idf ; @ HeaderParam ( \"host\" ) private String hostHost ; @ GET @ Produces ( \"text/plain\" ) public Response get ( ) { String msg = \"\" ; if ( this . securityContext == null ) { msg += \"\\n* securityContext\" ; } if ( this . uriInfo == null ) { msg += \"\\n* uriInfo\" ; } if ( this . request == null ) { msg += \"\\n* request\" ; } if ( this . httpHeaders == null ) { msg += \"\\n* httpHeaders\" ; } if ( this . idf == null ) { msg += \"\\n* id\" ; } if ( this . hostHost == null ) { msg += \"\\n* host\" ; } if ( msg . length ( ) > 0 ) { return Response . serverError ( ) . entity ( \"missing:\" + msg )", "gt": ". build ( ) ;", "prediction": ";\n", "label": 1}
{"id": 7127, "input": "<s> package com . sun . tools . classfile ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; public class ClassReader { ClassReader ( ClassFile classFile , InputStream in , Attribute . Factory attributeFactory ) throws IOException { classFile . getClass ( ) ; attributeFactory . getClass ( ) ; this . classFile = classFile ; this . in = new DataInputStream ( new BufferedInputStream ( in ) ) ; this . attributeFactory = attributeFactory ; } ClassFile getClassFile ( ) { return classFile ; } ConstantPool getConstantPool ( ) { return classFile . constant_pool ; } public Attribute readAttribute ( ) throws IOException { int name_index = readUnsignedShort ( ) ; int length = readInt ( ) ; byte [ ] data = new byte [ length ] ; readFully ( data ) ; DataInputStream prev = in ; in = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; try { return attributeFactory . createAttribute ( this , name_index , data ) ; } finally { in = prev ; } } public void readFully ( byte [ ] b ) throws IOException { in . readFully ( b ) ; } public int readUnsignedByte ( ) throws IOException { return in . readUnsignedByte ( ) ; } public int readUnsignedShort ( ) throws IOException { return in . readUnsignedShort ( ) ; } public int readInt ( ) throws IOException { return in . readInt ( ) ; } public long readLong ( ) throws IOException { return in . readLong ( ) ; } public float readFloat ( ) throws IOException { return", "gt": "in . readFloat ( ) ;", "prediction": "in . readFloat ( ) ;\n", "label": 0}
{"id": 13659, "input": "<s> package org . restlet . example . misc ; import org . restlet . Client ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . Representation ; import org . restlet . util . Series ; public class AwsTest { public static void main ( String [ ] args ) throws Exception { Request request = new Request ( Method . GET , \"http://s3.amazonaws.com/quotes/nelson\" ) ; request . setChallengeResponse ( new ChallengeResponse ( ChallengeScheme . HTTP_AWS_S3 ,", "gt": "\"44CF9590006BF252F707\" , \"OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV\" ) ) ;", "prediction": "challengeResponse ) ) ;\n", "label": 1}
{"id": 5420, "input": "<s> package org . gk . ui . client . com . toolbar ; import java . util . Iterator ; import java . util . List ; import org . gk . ui . client . com . form . gkList ; import org . gk . ui . client . com . i18n . Msg ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . event . ButtonEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . EventType ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . event . MessageBoxEvent ; import com . extjs . gxt . ui . client . event . SelectionListener ; import com . extjs . gxt . ui . client . widget . MessageBox ; import com . extjs . gxt . ui . client . widget . button . Button ; public class gkButton extends Button { private boolean showConfirm ; private String value , confirmText ; private List listenerList = new gkList ( ) ; public gkButton ( ) { init ( ) ; } public gkButton ( String text , boolean showConfirm ) { setText ( text ) ; setShowConfirm ( showConfirm ) ; init ( ) ; } public gkButton ( String text , String confirmText ) { this ( text , true ) ; if ( ! confirmText . toLowerCase ( ) . equals ( \"true\" ) ) { setConfirmText ( confirmText ) ; } } public String getConfirmText ( ) { return confirmText ; } public void setConfirmText ( String confirmText ) { this . confirmText = confirmText ; } private void init ( ) { super . addListener ( Events . Select , new SelectionListener ( ) { @ Override public void componentSelected ( final ComponentEvent ce ) { if ( isShowConfirm ( ) ) { String msg = confirmText != null ? confirmText : Msg . get . areuSure ( ) + getText ( ) + \"?\" ; MessageBox . confirm ( getText ( ) , msg , new Listener < MessageBoxEvent > ( ) { @ Override public void handleEvent ( MessageBoxEvent be ) { Button btn = be . getButtonClicked ( ) ; if ( btn . getText ( ) . equals ( GXT . MESSAGES . messageBox_yes ( ) ) ) { fireSelectionEvents ( ce ) ; } } } ) ; } else { fireSelectionEvents ( ce ) ; } } } ) ; } public boolean isShowConfirm ( ) { return showConfirm ; } public void setShowConfirm ( boolean showConfirm ) { this . showConfirm = showConfirm ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } @ Override public void addSelectionListener ( SelectionListener < ButtonEvent > listener ) { listenerList . add ( listener ) ; } @ Override public void addListener ( EventType eventType , Listener listener ) { if ( eventType == Events . Select ) { listenerList . add ( listener ) ; } else { super . addListener (", "gt": "eventType , listener ) ;", "prediction": "Events . Select , new SelectionListener ( )\n", "label": 0}
{"id": 13660, "input": "<s> package fr . inria . zvtm . tests ; import java . awt . Color ; import junit . framework . TestCase ; import fr . inria . zvtm . engine . Utils ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . engine . VirtualSpaceManager ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . VRectangle ; public class UtilsTest extends TestCase { public UtilsTest ( String name ) { super ( name ) ; } public void setUp ( ) { vsm = VirtualSpaceManager . INSTANCE ; vs = vsm . addVirtualSpace ( \"testVS\" ) ; } public void testWidthHeight ( ) { Glyph gl = new VRectangle ( 0 , 0 , 0 , 42 , 314 , Color . GREEN ) ; double [ ] wh = Utils .", "gt": "widthHeight ( gl ) ;", "prediction": "getWidth ( ) ;\n", "label": 1}
{"id": 2686, "input": "<s> package com . sap . prd . mobile . ios . mios ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . fail ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; import org . apache . maven . it . VerificationException ; import org . apache . maven . it . util . FileUtils ; import org . junit . Test ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . BuildConfiguration ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . BuildSettings ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . Plist ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . Project ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . ProjectFile ; import com . sap . prd . mobile . ios . mios . xcodeprojreader . jaxb . JAXBPlistParser ; public class XcodeSigningTest extends XCodeTest { @ Test public void testProvisioningProfile ( ) throws Exception { final String testName = Thread . currentThread ( ) . getStackTrace ( ) [ 1 ] . getMethodName ( ) ; final File remoteRepositoryDirectory = getRemoteRepositoryDirectory ( getClass ( ) . getName ( ) ) ; prepareRemoteRepository ( remoteRepositoryDirectory ) ; File intermediateAppDir = new File ( new File ( \".\" ) . getAbsolutePath ( ) , \"target/tests/\" + getClass ( ) . getName ( ) + \"/\" + testName + \"/intermediate/MyApp\" ) ; FileUtils . copyDirectoryStructure ( new File ( getTestRootDirectory ( ) , \"simple-app/MyApp\" ) , intermediateAppDir ) ; String xcodeProjFileName = intermediateAppDir . getCanonicalPath ( ) + \"/src/xcode/MyApp.xcodeproj/project.pbxproj\" ; JAXBPlistParser parser = new JAXBPlistParser ( ) ; parser . convert ( xcodeProjFileName , xcodeProjFileName ) ; Plist plist = parser . load ( xcodeProjFileName ) ; ProjectFile projectFile = new ProjectFile ( plist ) ; Project project = projectFile . getProject ( ) ; BuildConfiguration config = project . getTargets ( ) . getByName ( \"MyApp\" ) . getBuildConfigurationList ( ) . getBuildConfigurations ( ) . getByName ( \"Release\" ) ; assertNotNull ( \"Could not find the 'Release' build configuration\" , config ) ; BuildSettings buildSettings = config . getBuildSettings ( ) ; buildSettings . getDict ( ) . setString ( \"PROVISIONING_PROFILE[sdk=iphoneos*]\" , \"InvalidProvisioningProfile\" ) ; parser . save ( plist , xcodeProjFileName ) ; try { test ( testName , intermediateAppDir , \"pom.xml\" , \"compile\" , THE_EMPTY_LIST , THE_EMPTY_MAP , remoteRepositoryDirectory ) ; fail ( \"Expected the Maven call to fail due", "gt": "to an invalid provisioning profile.\" ) ;", "prediction": "to \" + testName ) ;\n", "label": 0}
{"id": 13664, "input": "<s> package org . spliffy . server . apps . versions ; import com . bradmcevoy . http . CollectionResource ; import com . bradmcevoy . http . Resource ; import org . spliffy . server . web . templating . MenuItem ; import java . util . List ; import org . spliffy . server . apps . AppConfig ; import org . spliffy . server . apps . Application ; import org . spliffy . server . db . BaseEntity ; import org . spliffy . server . db . Profile ; import org . spliffy . server . web . RootFolder ; import org . spliffy . server . web . Services ; import org . spliffy . server . web . SpliffyResourceFactory ; import org . spliffy . server . web . UserResource ; public class VersionsApp implements Application { private Services services ; @ Override public String getInstanceId ( ) { return \"versions\" ; } @ Override public void init ( SpliffyResourceFactory resourceFactory , AppConfig config ) throws Exception { this . services = resourceFactory . getServices ( ) ; } @ Override public Resource getPage ( Resource parent , String requestedName ) { return null ; }", "gt": "@ Override public void shutDown ( )", "prediction": "}\n", "label": 1}
{"id": 4712, "input": "<s> import readers . BmpReader ; import readers . ImageReader ; import readers . PpmReader ; public class ReaderFactory { public static ImageReader getReader ( String reader , String pathToFile ) { reader = reader . toLowerCase ( ) ; if ( reader . equals ( \"ppm\" ) ) return new PpmReader ( pathToFile ) ; if ( reader . equals ( \"bmp\" )", "gt": ") return new BmpReader ( pathToFile ) ;", "prediction": ") return new PpmReader ( pathToFile ) ;\n", "label": 0}
{"id": 13666, "input": "<s> package org . eclipse . ui . dialogs ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . ui . IWorkbenchPropertyPage ; public abstract class PropertyPage extends PreferencePage implements IWorkbenchPropertyPage { private IAdaptable element ; public PropertyPage ( ) { } public IAdaptable getElement ( ) { return element ; } public", "gt": "void setElement ( IAdaptable element )", "prediction": "PreferencePage getPreferencePage ( )\n", "label": 1}
{"id": 3620, "input": "<s> package com . mcbans . mcbans . calls ; import com . mcbans . mcbans . MCBansPlugin ; import com . mcbans . mcbans . utils . JSONHandler ; import com . mcbans . mcbans . utils . PlayerMethods ; import java . util . ArrayList ; import java . util . HashMap ; import org . bukkit . command . CommandSender ; import org . bukkit . entity . Player ; import org . json . JSONException ; import org . json . JSONObject ; public class Lookup implements Runnable { private final MCBansPlugin plugin ; private final String playerName ; private final CommandSender sender ; private final String senderName ; public Lookup ( MCBansPlugin plugin , String playerName , CommandSender sender , String senderName ) { this . plugin = plugin ; this . playerName = playerName ; this . sender = sender ; this . senderName = senderName ; } public void run ( ) { HashMap < String , String > urlItems = new HashMap < String , String > ( ) ; JSONHandler webHandler = new JSONHandler ( plugin ) ; urlItems . put ( \"player\" , playerName ) ; urlItems . put ( \"admin\" , senderName ) ; urlItems . put ( \"exec\" , \"playerLookup\" ) ; JSONObject result = webHandler . handleJob ( urlItems ) ; try { ArrayList < String > lines = new ArrayList ( ) ; lines . add ( plugin . lang . getFormat ( \"lookupSummary\" , playerName , result . getString ( \"total\" ) , result . getString ( \"reputation\" ) ) ) ; if ( result . getJSONArray ( \"global\" ) . length ( ) > 0 ) { lines . add ( plugin . lang . getFormat ( \"lookupGlobalBansHeader\" ) ) ; for ( int i = 0 ; i < result . getJSONArray ( \"global\" ) . length ( ) ; i ++ ) { lines . add ( result . getJSONArray ( \"global\" ) . getString ( i ) ) ; } } if ( result . getJSONArray ( \"local\" ) . length ( ) > 0 ) { lines . add ( plugin . lang . getFormat ( \"lookupLocalBansHeader\" ) ) ; for ( int i = 0 ; i < result . getJSONArray ( \"local\" ) . length ( ) ; i ++ ) { lines . add ( result . getJSONArray ( \"local\" ) . getString ( i ) ) ; } } PlayerMethods . message ( plugin , sender , lines ) ; }", "gt": "catch ( JSONException ex )", "prediction": "}\n", "label": 0}
{"id": 13670, "input": "<s> package com . poetry . install ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import escode . util . StreamUtils ; public class AbstractInstall { protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; protected byte [ ] load ( final String name ) throws IOException { logger . trace ( \"Trying load image :{}\" , name ) ; final Class < ? > clazz = getClass ( ) ; final Package pack = clazz . getPackage ( ) ; final String packageName = pack . getName ( ) ; final String path = \"/\" + packageName . replace ( '.' , '/' ) + \"/\" + name ; final InputStream in = getClass ( ) . getResourceAsStream ( path ) ; return StreamUtils . getBytes ( in , true ) ; } protected String read ( final", "gt": "String name ) throws IOException", "prediction": "String name ) throws IOException\n", "label": 1}
{"id": 9824, "input": "<s> public class FauxEnum2 extends java . lang . Enum { FauxEnum2 ( ) { super", "gt": "( \"\" , 0 ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13675, "input": "<s> package org . nuxeo . connect . client . jsf ; import java . io . Serializable ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import java . util . TimeZone ; import javax . faces . context . FacesContext ; import javax . faces . model . SelectItem ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . In ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . faces . FacesMessages ; import org . jboss . seam . international . StatusMessage ; import org . nuxeo . connect . client . ui . SharedPackageListingsSettings ; import org . nuxeo . connect . client . vindoz . InstallAfterRestart ; import org . nuxeo . connect . client . we . StudioSnapshotHelper ; import org . nuxeo . connect . data . DownloadablePackage ; import org . nuxeo . connect . data . DownloadingPackage ; import org . nuxeo . connect . packages . PackageManager ; import org . nuxeo . connect . update . LocalPackage ; import org . nuxeo . connect . update . PackageType ; import org . nuxeo . connect . update . PackageUpdateService ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . ecm . admin . AdminViewManager ; import org . nuxeo . ecm . admin . setup . SetupWizardActionBean ; import org . nuxeo . ecm . platform . ui . web . util . ComponentUtils ; import org . nuxeo . ecm . webapp . seam . NuxeoSeamHotReloadContextKeeper ; import org . nuxeo . launcher . config . ConfigurationGenerator ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"appsViews\" ) @ Scope ( ScopeType . CONVERSATION ) public class AppCenterViewsManager implements Serializable { private static final long serialVersionUID = 1L ; protected static final Log log = LogFactory . getLog ( AppCenterViewsManager . class ) ; protected enum SnapshotStatus { downloading , saving , installing , error , completed , restartNeeded ; } protected static final Map < String , String > view2PackageListName = new HashMap < String , String > ( ) { private static final long serialVersionUID = 1L ; { put ( \"ConnectAppsUpdates\" , \"updates\" ) ; put ( \"ConnectAppsStudio\" , \"studio\" ) ; put ( \"ConnectAppsRemote\" , \"remote\" ) ; put ( \"ConnectAppsLocal\" , \"local\" ) ; } } ; @ In ( create = true ) protected String currentAdminSubViewId ; @ In ( create = true ) protected NuxeoSeamHotReloadContextKeeper seamReloadContext ; @ In ( create = true ) protected SetupWizardActionBean setupWizardAction ; @ In ( create = true , required = false ) protected FacesMessages facesMessages ; @ In ( create = true ) protected Map < String , String > messages ; protected String searchString ; protected SnapshotStatus studioSnapshotStatus ; protected int studioSnapshotDownloadProgress ; protected boolean isStudioSnapshopUpdateInProgress = false ; protected Calendar lastStudioSnapshotUpdate ; protected String studioSnapshotUpdateError ; public String getSearchString ( ) { if ( searchString == null ) { return \"\" ; } return searchString ; } public void setSearchString ( String searchString ) { this . searchString = searchString ; } public boolean getOnlyRemote ( ) { return SharedPackageListingsSettings . instance ( ) . get ( \"remote\" ) . isOnlyRemote ( ) ; } public void setOnlyRemote ( boolean onlyRemote ) { SharedPackageListingsSettings . instance ( ) . get ( \"remote\" ) . setOnlyRemote ( onlyRemote ) ; } protected String getListName ( ) { return view2PackageListName . get ( currentAdminSubViewId ) ; } public void setPlatformFilter ( boolean doFilter ) { SharedPackageListingsSettings . instance ( ) . get ( getListName ( ) ) . setPlatformFilter ( doFilter ) ; } public boolean getPlatformFilter ( ) { return SharedPackageListingsSettings . instance ( ) . get ( getListName ( ) ) . getPlatformFilter ( ) ; } public String getPackageTypeFilter ( ) { return SharedPackageListingsSettings . instance ( ) . get ( getListName ( ) ) . getPackageTypeFilter ( ) ; } public void setPackageTypeFilter ( String filter ) { SharedPackageListingsSettings . instance ( ) . get ( getListName ( ) ) . setPackageTypeFilter ( filter ) ; } public List < SelectItem > getPackageTypes ( ) { List < SelectItem > types = new ArrayList < SelectItem > ( ) ; SelectItem allItem = new SelectItem ( \"\" , \"label.packagetype.all\" ) ; types . add ( allItem ) ; for ( PackageType ptype : PackageType . values ( ) ) { SelectItem item = new SelectItem ( ptype . getValue ( ) , \"label.packagetype.\" + ptype . getValue ( ) ) ; types . add ( item ) ; } return types ; } public void flushCache ( ) { PackageManager pm = Framework . getLocalService ( PackageManager . class ) ; pm . flushCache ( ) ; } public String installStudioSnapshotAndRedirect ( ) throws Exception { installStudioSnapshot ( ) ; return AdminViewManager . VIEW_ADMIN ; } public void installStudioSnapshot ( ) throws Exception { if ( isStudioSnapshopUpdateInProgress ) { return ; } PackageManager pm = Framework . getLocalService ( PackageManager . class ) ; List < DownloadablePackage > pkgs = pm . listAllStudioRemotePackages ( ) ; DownloadablePackage snapshotPkg = StudioSnapshotHelper . getSnapshot ( pkgs ) ; studioSnapshotUpdateError = null ; if ( snapshotPkg != null ) { isStudioSnapshopUpdateInProgress = true ; try { StudioAutoInstaller studioAutoInstaller = new StudioAutoInstaller ( pm , snapshotPkg . getId ( ) ) ; studioAutoInstaller . run ( ) ; } finally { isStudioSnapshopUpdateInProgress = false ; } } else { studioSnapshotUpdateError = translate ( \"label.studio.error.noSnapshotPackageFound\" ) ; } } public boolean isStudioSnapshopUpdateInProgress ( ) { return isStudioSnapshopUpdateInProgress ; } protected static String translate ( String label , Object ... params ) { return ComponentUtils . translate ( FacesContext . getCurrentInstance ( ) , label , params ) ; } protected String getLastUpdateDate ( ) { DateFormat df = new SimpleDateFormat ( \"EEE, dd MMM yyyy HH:mm:ss z\" , Locale . US ) ; df . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; return df . format", "gt": "( lastStudioSnapshotUpdate . getTime ( ) ) ;", "prediction": "( df . getTimeZone ( ) ) ;\n", "label": 1}
{"id": 10001, "input": "<s> package next . interfaces . controller . widgets ; import next . i . mobile . SelectionChangedEvent ; import next . i . mobile . SelectionChangedHandler ; import next . i . view . widgets . XFlexTable ; import next . i . view . widgets . XLabel ; import next . i . view . widgets . XRadioButton ; import next . i . view . widgets . XRadioButtonGroup ; import next . i . view . widgets . XLabel . XLabelType ; import next . interfaces . controller . GitXController ; import com . google . gwt . user . client . ui . HTML ; import com . google . gwt . user . client . ui . IsWidget ; public class RadioButtonController extends GitXController { public RadioButtonController ( ) { setTitle ( \"Radio Button\" ) ; } @ Override public IsWidget getViewContent ( ) { XFlexTable panel = new XFlexTable ( ) ; panel . setCellSpacing ( 20 ) ; XRadioButton radio0 = new XRadioButton ( \"Red\" , \"Red\" ) ; XRadioButton radio1 = new XRadioButton ( \"Green\" , \"Green\" ) ; XRadioButton radio2 = new XRadioButton ( \"Blue\" , \"Blue\" ) ; final XRadioButtonGroup group1 = new XRadioButtonGroup ( true ) ; group1 . add ( radio0 , radio1 , radio2 ) ; XRadioButton radioA = new XRadioButton ( \"Red\" , \"Red\" ) ; XRadioButton radioB = new XRadioButton ( \"Green\" , \"Green\" ) ; XRadioButton radioC = new XRadioButton (", "gt": "\"Blue\" , \"Blue\" ) ;", "prediction": "\"Blue\" , \"Blue\" ) ;\n", "label": 0}
{"id": 13680, "input": "<s> package org . spliffy . server . db . store ; import java . util . UUID ; public interface ReplicationManager { void newBlob ( long volumeInstanceId", "gt": ", long hash ) ;", "prediction": ") ;\n", "label": 1}
{"id": 8657, "input": "<s> import com . sun . javadoc . * ; public class BreakIteratorWarning extends Doclet { public static void main ( String [ ] args ) { String thisFile = \"\" + new java . io . File ( System . getProperty ( \"test.src\" , \".\" ) , \"BreakIteratorWarning.java\" ) ; if ( com . sun . tools . javadoc . Main . execute ( \"javadoc\" , \"BreakIteratorWarning\" , BreakIteratorWarning . class . getClassLoader ( ) , new String [ ] { \"-Xwerror\" , thisFile } ) != 0 ) throw new Error ( \"Javadoc encountered warnings or errors.\" ) ; } public static boolean start ( RootDoc root ) { ClassDoc cd = root . classes ( ) [ 0 ] ; FieldDoc fd = cd . fields", "gt": "( ) [ 0 ] ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13685, "input": "<s> package org . nuxeo . ecm . platform . rendering ; import java . util . Collection ; public interface RenderingService { Collection < RenderingResult > process ( RenderingContext ctx ) throws RenderingException ; RenderingEngine getEngine ( String format ) ; void registerEngine ( RenderingEngine engine ) ; void", "gt": "unregisterEngine ( String format ) ;", "prediction": "setEngine ( RenderingEngine engine ) ;\n", "label": 1}
{"id": 401, "input": "<s> import java . io . * ; import java . net . URI ; import javax . tools . * ; public class T6501502 { public static void main ( String ... args ) throws Exception { new T6501502 ( ) . run ( ) ; } void run ( ) throws Exception { JavaCompiler c = ToolProvider . getSystemJavaCompiler ( ) ; fm = c . getStandardFileManager ( null , null , null ) ; System . err . println ( System . getProperties ( ) ) ; File tmpDir = new File ( System . getProperty ( \"java.io.tmpdir\" ) ) ; File testSrcDir = new File ( System . getProperty ( \"test.src\" ) ) ; File testClassesDir = new File ( System . getProperty ( \"test.classes\" ) ) ; test ( new File ( \"abc.tmp\" ) ) ; test ( new File ( tmpDir , \"bad.file\" ) ) ; test ( new File ( testSrcDir , \"T6501501.java\" ) ) ; test ( new File ( testClassesDir , \"T6501501.class\" ) ) ; test ( new File ( \"a b\" ) ) ; } void test ( File f ) throws Exception { System . err . println ( \"test \" + f ) ; FileObject fo = fm . getJavaFileObjects ( f ) . iterator ( ) . next ( ) ; URI uri = fo . toUri ( ) ; System . err . println ( \"FileObject uri: \" + uri ) ; if ( ! new File ( uri ) . equals ( f . getAbsoluteFile ( ) ) ) throw new Exception (", "gt": "\"unexpected URI returned\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13691, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . model ; import java . util . Iterator ; import java . util . Vector ; public class Template extends AbstractTreeNode implements IBlock { private String fName ; private Vector fDirectives = new Vector ( ) ; public Template ( String aName ) { super ( null , - 1 , - 1 ) ; fName = aName ; } public void addDirective ( Directive aDirective ) { fDirectives . add ( aDirective ) ; } public String getName ( ) { return fName ; } public boolean hasChildren ( ) { return ! fDirectives . isEmpty ( ) ; } public Object [ ] getChildren ( ) { return fDirectives . toArray ( ) ; } public", "gt": "boolean accept ( ITreeVisitor aVisitor )", "prediction": "Object [ ] getDirectives ( )\n", "label": 1}
{"id": 2420, "input": "<s> import jns . Simulator ; import jns . agent . MPTCP ; import jns . agent . MPTCPAgent ; import jns . agent . RandomSink ; import jns . agent . RandomSource ; import jns . command . StopCommand ; import jns . element . * ; import jns . trace . JavisTrace ; import jns . trace . Trace ; import jns . util . IPAddr ; import jns . util . Protocols ; import java . io . IOException ; public class Test_MMPTCP { public static void main ( String args [ ] ) { Trace trace = null ; try { trace = new JavisTrace ( \"test_mptcp.jvs\" ) ; } catch ( IOException e ) { System . out . println ( \"Could not create test_mptcp.jvs!\" ) ; } Simulator sim = Simulator . getInstance ( ) ; sim . setTrace ( trace ) ; Node A = new Node ( \"A\" ) ; sim . attachWithTrace ( A , trace ) ; Node B = new Node ( \"B\" ) ; sim . attachWithTrace ( B , trace ) ; Node C = new Node ( \"C\" ) ; sim . attachWithTrace ( C , trace ) ; Node D = new Node ( \"D\" ) ; sim . attachWithTrace ( D , trace ) ; Node X = new Node ( \"X\" ) ; sim . attachWithTrace ( X , trace ) ; Node E = new Node ( \"E\" ) ; sim . attachWithTrace ( E , trace ) ; Node F = new Node ( \"F\" ) ; sim . attachWithTrace ( F , trace ) ; Node G = new Node ( \"G\" ) ; sim . attachWithTrace ( G , trace ) ; Node H = new Node ( \"H\" ) ; sim . attachWithTrace ( H , trace ) ; Interface ABIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 1 ) ) ; A . attach ( ABIface ) ; sim . attachWithTrace ( ABIface , trace ) ; Interface ACIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 10 ) ) ; A . attach ( ACIface ) ; sim . attachWithTrace ( ACIface , trace ) ; Interface ADIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 20 ) ) ; A . attach ( ADIface ) ; sim . attachWithTrace ( ADIface , trace ) ; Interface XBIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 50 ) ) ; X . attach ( XBIface ) ; sim . attachWithTrace ( XBIface , trace ) ; Interface XCIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 51 ) ) ; X . attach ( XCIface ) ; sim . attachWithTrace ( ACIface , trace ) ; Interface XDIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 52 ) ) ; X . attach ( XDIface ) ; sim . attachWithTrace ( XDIface , trace ) ; Interface BAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BAIface ) ; sim . attachWithTrace ( BAIface , trace ) ; Interface BXIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BXIface ) ; sim . attachWithTrace ( BXIface , trace ) ; Interface BEIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BEIface ) ; sim . attachWithTrace ( BEIface , trace ) ; Interface CAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CAIface ) ; sim . attachWithTrace ( CAIface , trace ) ; Interface CXIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CXIface ) ; sim . attachWithTrace ( CAIface , trace ) ; Interface CFIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CFIface ) ; sim . attachWithTrace ( CFIface , trace ) ; Interface DAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DAIface ) ; sim . attachWithTrace ( DAIface , trace ) ; Interface DXIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DXIface ) ; sim . attachWithTrace ( DAIface , trace ) ; Interface DGIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DGIface ) ; sim . attachWithTrace ( DGIface , trace ) ; Interface EBIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 5 ) ) ; E . attach ( EBIface ) ; sim . attachWithTrace ( EBIface , trace ) ; Interface EHIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 5 ) ) ; E . attach ( EHIface ) ; sim . attachWithTrace ( EHIface , trace ) ; Interface FCIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 6 ) ) ; F . attach ( FCIface ) ; sim .", "gt": "attachWithTrace ( FCIface , trace ) ;", "prediction": "attachWithTrace ( FIface , trace ) ;\n", "label": 0}
{"id": 13701, "input": "<s> package com . cloudera . sqoop ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . sql . Connection ; import java . sql . Timestamp ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . List ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . HsqldbTestServer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . FileStatus ; import org . apache . hadoop . fs . FileSystem ; import org . apache . hadoop . fs . Path ; import com . cloudera . sqoop . SqoopOptions . IncrementalMode ; import com . cloudera . sqoop . manager . ConnManager ; import com . cloudera . sqoop . testutil . BaseSqoopTestCase ; import com . cloudera . sqoop . tool . CodeGenTool ; import com . cloudera . sqoop . tool . ImportTool ; import com . cloudera . sqoop . tool . MergeTool ; import com . cloudera . sqoop . util . ClassLoaderStack ; public class TestMerge extends BaseSqoopTestCase { private static final Log LOG = LogFactory . getLog ( TestMerge . class . getName ( ) ) ; protected ConnManager manager ; protected Connection conn ; public static final String SOURCE_DB_URL = \"jdbc:hsqldb:mem:merge\" ; @ Override public void setUp ( ) { super . setUp ( ) ; manager = getManager ( ) ; try { conn = manager . getConnection ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } public static final String TABLE_NAME = \"MergeTable\" ; public Configuration newConf ( ) { Configuration conf = new Configuration ( ) ; if ( ! BaseSqoopTestCase . isOnPhysicalCluster ( ) ) { conf . set ( CommonArgs . FS_DEFAULT_NAME , CommonArgs . LOCAL_FS ) ; } conf . set ( \"mapred.job.tracker\" , \"local\" ) ; return conf ; } public SqoopOptions getSqoopOptions ( Configuration conf ) { SqoopOptions options = new SqoopOptions ( conf ) ; options . setConnectString ( HsqldbTestServer . getDbUrl ( ) ) ; return options ; } protected void createTable ( ) throws SQLException { PreparedStatement s = conn . prepareStatement ( \"DROP TABLE \" + TABLE_NAME + \" IF EXISTS\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } s = conn . prepareStatement ( \"CREATE TABLE \" + TABLE_NAME + \" (id INT NOT NULL PRIMARY KEY, val INT, lastmod TIMESTAMP)\" ) ; try { s . executeUpdate ( ) ; } finally { s . close ( ) ; } s = conn . prepareStatement ( \"INSERT INTO \" +", "gt": "TABLE_NAME + \" VALUES (\" + \"0, 0, NOW())\" ) ;", "prediction": "TABLE_NAME + \" (id INT NOT NULL PRIMARY KEY, val INT, lastmod TIMESTAMP)\" ) ;\n", "label": 1}
{"id": 1104, "input": "<s> package javax . lang . model . element ; import javax . lang . model . UnknownEntityException ; public class UnknownAnnotationValueException extends UnknownEntityException { private static final long serialVersionUID = 269L ; private transient AnnotationValue av ; private transient Object parameter ; public UnknownAnnotationValueException ( AnnotationValue av , Object p ) { super ( \"Unknown annotation value: \" + av ) ; this . av = av ;", "gt": "this . parameter = p ;", "prediction": "this . parameter = p ;\n", "label": 0}
{"id": 13707, "input": "<s> package org . gatein . common . util ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Map ; public class MapAdapters { private final static ArrayElementConverter < String > stringArrayElementConverter = new ArrayElementConverter < String > ( String . class ) ; private final static AbstractTypedMap . Converter < String , String > stringConverter = AbstractTypedMap . Converter . identityConverter ( ) ; public static < K , V > Map < K , V > adapt ( Map < K , V [ ] > adapted , Class < ? extends V > type ) { if ( adapted == null ) { throw new IllegalArgumentException ( \"Cannot adapt a null map\" ) ; } ArrayElementConverter < V > valueConverter = new ArrayElementConverter < V > ( type ) ; AbstractTypedMap . Converter < K , K > keyConverter = AbstractTypedMap . Converter . identityConverter ( ) ; return new TypedMap < K , V , K , V [ ] > ( adapted , keyConverter , valueConverter ) ; } public static Map < String , String > adapt ( Map < String , String [ ] > adapted ) { if ( adapted == null ) { throw new IllegalArgumentException ( \"Cannot adapt a null map\" ) ; } return new TypedMap < String , String , String , String [ ] > ( adapted , stringConverter , stringArrayElementConverter ) ; } private static class ArrayElementConverter < T > extends AbstractTypedMap . Converter < T , T [ ] > { private final Class < ? extends T > type ; private ArrayElementConverter ( Class < ? extends T > type ) { if ( type == null ) { throw new IllegalArgumentException ( \"No null type accepted\" ) ; } this . type = type ; } @ SuppressWarnings ( \"unchecked\" ) protected T [ ] getInternal ( T external ) throws IllegalArgumentException , ClassCastException { if ( external == null ) { throw new NullPointerException ( ) ; } T [ ] array = ( T [ ] )", "gt": "Array . newInstance ( type , 1 ) ;", "prediction": "external ;\n", "label": 1}
{"id": 9255, "input": "<s> package com . redhat . ceylon . ant ; public class Rep { public String url ; public void setUrl ( String url ) { this . url = url ; } @", "gt": "Override public String toString ( )", "prediction": "Override public String toString ( )\n", "label": 0}
{"id": 13709, "input": "<s> package org . spliffy . server . db . store ; import java . io . File ; public class FsHashUtils { public static String toHex ( long hash ) { String hex = Long . toHexString ( hash ) ; return hex ; } public static File toFile ( File root , long hash ) { File f = root ; String hex = toHex ( hash ) ; String name = hex ; while ( name . length ( ) > 3 ) { String subdir = name . substring ( 0 , 2 ) ; f = new File (", "gt": "f , subdir ) ;", "prediction": "f ) ;\n", "label": 1}
{"id": 2812, "input": "<s> package org . ofbiz . widget ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . security . Security ; public class PortalPageWorker { public static final String module = PortalPageWorker . class . getName ( ) ; public PortalPageWorker ( ) { } public String renderPortalPageAsTextExt ( Delegator delegator , String portalPageId , Map < String , Object > templateContext , boolean cache ) throws GeneralException , IOException { return \"success\" ; } public static List < GenericValue > getPortalPages ( String parentPortalPageId , Map < String , Object > context ) { List < GenericValue > portalPages = null ; if ( UtilValidate . isNotEmpty ( parentPortalPageId ) ) { Delegator delegator = WidgetWorker . getDelegator ( context ) ; try { EntityCondition cond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , \"_NA_\" ) , EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"portalPageId\" , EntityOperator . EQUALS , parentPortalPageId ) , EntityCondition . makeCondition ( \"parentPortalPageId\" , EntityOperator . EQUALS , parentPortalPageId ) ) , EntityOperator . OR ) ) , EntityOperator . AND ) ; portalPages = delegator . findList ( \"PortalPage\" , cond , null , null , null , false ) ; if ( UtilValidate . isNotEmpty ( context . get ( \"userLogin\" ) ) ) { String userLoginId = ( ( GenericValue ) context . get ( \"userLogin\" ) ) . getString ( \"userLoginId\" ) ; for ( GenericValue portalPage : portalPages ) { cond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , userLoginId ) , EntityCondition . makeCondition ( \"originalPortalPageId\" , EntityOperator . EQUALS , portalPage . getString ( \"portalPageId\" ) ) ) , EntityOperator . AND ) ; List < GenericValue > privatePortalPages = delegator . findList ( \"PortalPage\" , cond , null , null , null , false ) ; if ( UtilValidate . isNotEmpty ( privatePortalPages ) ) { portalPages . remove ( portalPage ) ; portalPages . add ( privatePortalPages . get ( 0 ) ) ; } } cond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , userLoginId ) , EntityCondition . makeCondition ( \"originalPortalPageId\" , EntityOperator . EQUALS , null ) , EntityCondition . makeCondition ( \"parentPortalPageId\" , EntityOperator . EQUALS , parentPortalPageId ) ) , EntityOperator . AND ) ; portalPages . addAll ( delegator . findList ( \"PortalPage\" , cond , null , null , null , false ) ) ; } portalPages = EntityUtil . orderBy ( portalPages , UtilMisc . toList ( \"sequenceNum\" ) ) ; } catch ( GenericEntityException e ) { Debug . logError ( \"Could not retrieve portalpages:\" + e . getMessage ( ) , module ) ; } } return portalPages ; } public static GenericValue getPortalPage ( String portalPageId , Map < String , Object > context ) { GenericValue portalPage = null ; if ( UtilValidate . isNotEmpty ( portalPageId ) ) { Delegator delegator = WidgetWorker . getDelegator ( context ) ; try { String userLoginId = \"_NA_\" ; if ( UtilValidate . isNotEmpty ( context . get ( \"userLogin\" ) ) ) { userLoginId = ( ( GenericValue ) context . get ( \"userLogin\" ) ) . getString ( \"userLoginId\" ) ; } EntityCondition cond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"portalPageId\" , EntityOperator . EQUALS , portalPageId ) , EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , \"_NA_\" ) , EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , userLoginId ) ) , EntityOperator . OR ) ) , EntityOperator . AND ) ; List < GenericValue > portalPages = delegator . findList ( \"PortalPage\" , cond , null , null , null , false ) ; if ( UtilValidate . isNotEmpty ( portalPages ) ) { portalPage = EntityUtil . getFirst ( portalPages ) ; } cond = EntityCondition . makeCondition ( UtilMisc . toList ( EntityCondition . makeCondition ( \"originalPortalPageId\" , EntityOperator . EQUALS , portalPageId ) , EntityCondition . makeCondition ( \"ownerUserLoginId\" , EntityOperator . EQUALS , userLoginId ) ) , EntityOperator . AND ) ; List < GenericValue > privateDerivedPortalPages = delegator . findList ( \"PortalPage\" , cond , null , null , null , false ) ; if ( UtilValidate . isNotEmpty ( privateDerivedPortalPages ) ) { portalPage = EntityUtil . getFirst ( privateDerivedPortalPages ) ; } } catch ( GenericEntityException e ) { Debug . logError ( \"Could not retrieve portalpage:\"", "gt": "+ e . getMessage ( ) , module ) ;", "prediction": "+ e . getMessage ( ) , module ) ;\n", "label": 0}
{"id": 13710, "input": "<s> package org . restlet . security ; import java . security . Principal ; import org . restlet . data . ClientInfo ; public interface Enroler { public void", "gt": "enrole ( ClientInfo clientInfo ) ;", "prediction": "setUp ( ) ;\n", "label": 1}
{"id": 9423, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposeableAdapterFactory ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ItemProviderAdapter ; import org . eclipse . emf . edit . provider . ViewerNotification ; import org . eclipse . gmf . gmfgraph . GMFGraphFactory ; import org . eclipse . gmf . mappings . GMFMapFactory ; import org . eclipse . gmf . tooldef . GMFToolFactory ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleMappingItemProvider extends ItemProviderAdapter implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleMappingItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; addDomainModelPropertyDescriptor ( object ) ; addDomainMetaElementPropertyDescriptor ( object ) ; } return itemPropertyDescriptors ; } protected void addDomainModelPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleMapping_domainModel_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleMapping_domainModel_feature\" , \"_UI_SimpleMapping_type\" ) , SimplemappingsPackage . Literals . SIMPLE_MAPPING__DOMAIN_MODEL , false , false , true , null , null , null ) ) ; } protected void addDomainMetaElementPropertyDescriptor ( Object object ) { itemPropertyDescriptors . add ( createItemPropertyDescriptor ( ( ( ComposeableAdapterFactory ) adapterFactory ) . getRootAdapterFactory ( ) , getResourceLocator ( ) , getString ( \"_UI_SimpleMapping_domainMetaElement_feature\" ) , getString ( \"_UI_PropertyDescriptor_description\" , \"_UI_SimpleMapping_domainMetaElement_feature\" , \"_UI_SimpleMapping_type\" ) , SimplemappingsPackage . Literals . SIMPLE_MAPPING__DOMAIN_META_ELEMENT , true , false , true", "gt": ", null , null , null ) ) ;", "prediction": ", null , null ) ) ;\n", "label": 0}
{"id": 13727, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . common . util . EList ; public interface ObjectProperty extends ClassProperty { Boolean getIsInverseFunctional ( ) ; void setIsInverseFunctional ( Boolean value ) ; Boolean getIsSymmetric ( ) ; void setIsSymmetric ( Boolean value ) ; Boolean getIsAsymmetric ( ) ; void setIsAsymmetric ( Boolean value ) ; Boolean getIsTransitive ( ) ; void setIsTransitive ( Boolean value ) ; Boolean getIsReflexive ( ) ; void setIsReflexive ( Boolean value ) ; Boolean getIsIrreflexive ( ) ; void setIsIrreflexive ( Boolean value ) ; EList < ObjectProperty", "gt": "> getInverseOf ( ) ;", "prediction": "> properties ;\n", "label": 1}
{"id": 2796, "input": "<s> abstract class B extends A { @ Deprecated public void iDep_aDep_bDep ( ) { } public void iDep_aDep_bUnd ( ) { } @ Deprecated public void iDep_aUnd_bDep ( ) { } public void iDep_aUnd_bUnd ( ) { } @ Deprecated public void iDep_aInh_bDep ( ) { } public void iDep_aInh_bUnd ( ) { } @", "gt": "Deprecated public void iUnd_aDep_bDep ( )", "prediction": "Deprecated public void iInh_bUnd ( )\n", "label": 0}
{"id": 13728, "input": "<s> package org . spliffy . sync . triplets ; import com . bradmcevoy . common . Path ; import java . util . List ;", "gt": "import org . spliffy . common . Triplet ;", "prediction": "import java . util . Map ;\n", "label": 1}
{"id": 576, "input": "<s> package com . sun . tools . doclets . internal . toolkit . builders ; import java . io . * ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; public class AnnotationTypeBuilder extends AbstractBuilder { public static final String ROOT = \"AnnotationTypeDoc\" ; private AnnotationTypeDoc annotationTypeDoc ; private AnnotationTypeWriter writer ; private Content contentTree ; private AnnotationTypeBuilder ( Configuration configuration ) { super ( configuration ) ; } public static AnnotationTypeBuilder getInstance ( Configuration configuration , AnnotationTypeDoc annotationTypeDoc , AnnotationTypeWriter writer ) throws Exception { AnnotationTypeBuilder builder = new AnnotationTypeBuilder ( configuration ) ; builder . configuration = configuration ; builder . annotationTypeDoc = annotationTypeDoc ; builder . writer = writer ; if ( containingPackagesSeen == null ) { containingPackagesSeen = new HashSet < String > ( ) ; } return builder ; } public void build ( ) throws IOException { build ( LayoutParser . getInstance ( configuration ) . parseXML ( ROOT ) , contentTree ) ; } public String getName ( ) { return ROOT ; } public void buildAnnotationTypeDoc ( XMLNode node , Content contentTree ) throws Exception { contentTree = writer . getHeader ( configuration . getText ( \"doclet.AnnotationType\" ) + \" \" + annotationTypeDoc . name ( ) ) ; Content annotationContentTree = writer . getAnnotationContentHeader ( ) ; buildChildren ( node , annotationContentTree ) ; contentTree . addContent ( annotationContentTree ) ; writer . addFooter ( contentTree ) ; writer . printDocument ( contentTree ) ; writer . close ( ) ; copyDocFiles ( ) ; } private void copyDocFiles ( ) { PackageDoc containingPackage = annotationTypeDoc . containingPackage ( ) ; if ( ( configuration . packages == null || Arrays . binarySearch ( configuration . packages , containingPackage ) < 0 ) && ! containingPackagesSeen . contains ( containingPackage . name ( ) ) ) { Util . copyDocFiles ( configuration , Util . getPackageSourcePath ( configuration , annotationTypeDoc . containingPackage ( ) ) + DirectoryManager . getDirectoryPath ( annotationTypeDoc . containingPackage ( ) ) + File . separator , DocletConstants . DOC_FILES_DIR_NAME , true ) ; containingPackagesSeen . add ( containingPackage . name ( ) ) ; } } public void buildAnnotationTypeInfo ( XMLNode node , Content annotationContentTree ) { Content annotationInfoTree = writer . getAnnotationInfoTreeHeader ( ) ; buildChildren ( node , annotationInfoTree ) ; annotationContentTree . addContent ( writer . getAnnotationInfo ( annotationInfoTree ) ) ; } public void buildDeprecationInfo ( XMLNode node , Content annotationInfoTree ) { writer . addAnnotationTypeDeprecationInfo ( annotationInfoTree ) ; } public void buildAnnotationTypeSignature ( XMLNode node , Content annotationInfoTree ) { StringBuffer modifiers = new StringBuffer ( annotationTypeDoc . modifiers ( ) + \" \" ) ; writer . addAnnotationTypeSignature ( Util . replaceText ( modifiers . toString ( ) , \"interface\" , \"@interface\" ) , annotationInfoTree ) ; } public void buildAnnotationTypeDescription ( XMLNode node , Content annotationInfoTree ) { writer . addAnnotationTypeDescription ( annotationInfoTree ) ; } public void buildAnnotationTypeTagInfo ( XMLNode node , Content annotationInfoTree ) { writer . addAnnotationTypeTagInfo ( annotationInfoTree ) ; } public void buildMemberSummary ( XMLNode node , Content annotationContentTree ) throws Exception { Content memberSummaryTree =", "gt": "writer . getMemberTreeHeader ( ) ;", "prediction": "writer . getMemberSummaryTreeHeader ( ) ;\n", "label": 0}
{"id": 13734, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getListAndViewResult\" } ) @ XmlRootElement (", "gt": "name = \"GetListAndViewResponse\" ) public class GetListAndViewResponse", "prediction": "propOrder =\n", "label": 1}
{"id": 8218, "input": "<s> public class InstanceOf1 { boolean m ( ) { return this", "gt": ". getClass ( ) instanceof Class < ? > ;", "prediction": ". m ;\n", "label": 0}
{"id": 13743, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . document . * ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . TermFreqVector ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . English ; import java . io . IOException ; public class TestMultiThreadTermVectors extends LuceneTestCase { private RAMDirectory directory = new RAMDirectory ( ) ; public int numDocs = 100 ; public int numThreads = 3 ; public TestMultiThreadTermVectors ( String s ) { super ( s ) ; } public void setUp ( ) throws Exception { super . setUp ( ) ; IndexWriter writer = new IndexWriter ( directory , new SimpleAnalyzer ( ) , true , IndexWriter . MaxFieldLength . LIMITED ) ; for ( int i = 0 ; i < numDocs ; i ++ ) { Document doc = new Document ( ) ; Fieldable fld = new Field ( \"field\" , English . intToEnglish ( i ) , Field . Store . YES , Field . Index . NOT_ANALYZED , Field . TermVector . YES ) ; doc . add ( fld ) ; writer . addDocument ( doc ) ; } writer . close ( ) ; } public void test ( ) throws Exception { IndexReader reader = null ; try { reader = IndexReader . open ( directory ) ; for ( int i = 1 ; i <= numThreads ; i ++ ) testTermPositionVectors ( reader , i ) ; } catch ( IOException ioe ) { fail ( ioe . getMessage ( ) ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } } } public void testTermPositionVectors ( final IndexReader reader , int threadCount ) throws Exception { MultiThreadTermVectorsReader [ ] mtr = new MultiThreadTermVectorsReader [ threadCount ] ; for ( int i = 0 ; i < threadCount ; i ++ ) { mtr [ i ] = new MultiThreadTermVectorsReader ( ) ; mtr [ i ] . init ( reader ) ; } int threadsAlive = mtr . length ; while ( threadsAlive > 0 ) { Thread . sleep ( 10 ) ; threadsAlive = mtr . length ; for ( int i = 0 ; i < mtr . length ; i ++ ) { if ( mtr [ i ] . isAlive ( ) == true ) { break ; } threadsAlive -- ; } } long totalTime = 0L ; for ( int i = 0 ; i < mtr . length ; i ++ ) { totalTime += mtr [ i ] . timeElapsed ; mtr [ i ] = null ; } } } class MultiThreadTermVectorsReader implements Runnable { private IndexReader reader = null ; private Thread t = null ; private final int runsToDo = 100 ; long timeElapsed = 0 ; public void init ( IndexReader reader ) { this . reader = reader ; timeElapsed = 0 ; t = new Thread ( this ) ; t . start ( ) ; } public boolean isAlive ( ) { if ( t == null ) return false ; return t . isAlive ( ) ; } public void run ( ) { try { for ( int i = 0 ; i < runsToDo ; i ++ ) testTermVectors ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return ; } private void testTermVectors ( ) throws Exception { int numDocs = reader . numDocs ( ) ; long start = 0L ; for ( int docId = 0 ; docId < numDocs ; docId ++ ) { start = System . currentTimeMillis ( ) ; TermFreqVector [ ] vectors = reader . getTermFreqVectors ( docId ) ; timeElapsed += System . currentTimeMillis ( ) - start ; verifyVectors ( vectors , docId ) ; start = System . currentTimeMillis ( ) ; TermFreqVector vector = reader . getTermFreqVector ( docId , \"field\" ) ; timeElapsed += System . currentTimeMillis ( ) - start ; vectors = new TermFreqVector [ 1 ] ; vectors [ 0 ] = vector ; verifyVectors ( vectors , docId ) ; } } private void verifyVectors ( TermFreqVector [ ] vectors , int num ) { StringBuffer temp = new StringBuffer ( ) ; String [ ] terms = null ; for ( int i = 0 ; i < vectors . length ; i ++ ) { terms = vectors [ i ] . getTerms ( ) ; for ( int z = 0 ; z < terms . length ; z ++ ) { temp .", "gt": "append ( terms [ z ] ) ;", "prediction": "append ( z ) ;\n", "label": 1}
{"id": 8581, "input": "<s> import java . util . Set ; import javax . annotation . processing . * ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import static javax . lang . model . util . ElementFilter . * ; import static javax . tools . Diagnostic . Kind . * ; import static javax . tools . StandardLocation . * ; public class TestPackageElement extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ! roundEnv . processingOver ( ) ) { PackageElement unnamedPkg = eltUtils . getPackageElement ( \"\" ) ; if ( ! unnamedPkg . getQualifiedName ( ) . contentEquals ( \"\" ) ) throw new RuntimeException ( \"The unnamed package is named!\" ) ; if ( ! unnamedPkg . toString ( ) . equals ( \"unnamed package\" ) ) throw new RuntimeException ( \"toString on unnamed package: \" + unnamedPkg ) ; if ( ! unnamedPkg . isUnnamed ( ) ) throw new RuntimeException ( \"The isUnnamed method on the unnamed package returned false!\" ) ; PackageElement javaLang = eltUtils . getPackageElement ( \"java.lang\" ) ; if ( javaLang . isUnnamed ( ) ) throw new RuntimeException (", "gt": "\"Package java.lang is unnamed!\" ) ;", "prediction": "\"The javaLang method on the javaLang returned false!\" ) ;\n", "label": 0}
{"id": 13749, "input": "<s> package org . eclipse . jface . tests . performance ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . widgets . Shell ; public abstract class TreeTest extends ViewerTest { TreeViewer viewer ; public TreeTest ( String testName , int tagging ) { super ( testName , tagging ) ; } public TreeTest ( String testName ) { super ( testName ) ; } protected StructuredViewer createViewer ( Shell shell ) { viewer = createTreeViewer ( shell ) ; viewer . setContentProvider ( getContentProvider ( ) ) ; viewer . setLabelProvider ( getLabelProvider ( ) ) ; viewer . setSorter ( new ViewerSorter ( ) ) ; viewer . setUseHashlookup ( true ) ; return viewer ; } protected TreeViewer createTreeViewer ( Shell shell ) { return new TreeViewer ( shell ) ; } protected Object getInitialInput ( ) { return", "gt": "new TestTreeElement ( 0 , null ) ;", "prediction": "viewer ;\n", "label": 1}
{"id": 14, "input": "<s> package com . sensor ; import android . os . Handler ; import android . os . Message ; class SensorDelayHandler extends Handler { MovementService movService = null ; public int delayType = - 1 ; public static final class DelayType { public static final int CALCULATE = 0 ; public static final int SENSOR_UPDATE = 1 ; public static final int DISPLAY_UPDATE = 2 ; } public SensorDelayHandler ( MovementService movService , int delayType ) { super ( ) ;", "gt": "this . delayType = delayType ;", "prediction": "this . delayType = delayType ;\n", "label": 0}
{"id": 13757, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . io . IOException ; public class SingleDocSource extends ContentSource { private int docID = 0 ; static final String DOC_TEXT = \"Well, this is just some plain text we use for creating the \" + \"test documents. It used to be a text from an online collection \" + \"devoted to first aid, but if there was there an (online) lawyers \" + \"first aid collection with legal advices, \\\"it\\\" might have quite \" + \"probably advised one not to include \\\"it\\\"'s text or the text of \" + \"any other online collection in one's code, unless one has money \" + \"that one don't need and one is happy to donate for lawyers \" + \"charity. Anyhow at some point, rechecking the usage of this text, \" + \"it became uncertain that this text is free to use, because \" + \"the web site in the disclaimer of he eBook containing that text \" + \"was not responding anymore, and at the same time, in projGut, \" + \"searching for first aid no longer found that eBook as well. \" + \"So here we are, with a perhaps much less interesting \" + \"text for the test, but oh much much safer. \" ; private synchronized int newdocid ( ) throws NoMoreDataException { if ( docID > 0 && ! forever ) { throw new NoMoreDataException ( ) ; } return docID ++ ; } public void close ( ) throws IOException { } public DocData getNextDocData ( DocData docData ) throws NoMoreDataException { int id = newdocid ( ) ; addBytes (", "gt": "DOC_TEXT . length ( ) ) ;", "prediction": "docData ) ;\n", "label": 1}
{"id": 2799, "input": "<s> abstract class B3 extends A implements I { public void iDep_aDep_bDep ( ) { } public void iDep_aDep_bUnd ( ) { } public void iDep_aUnd_bDep ( ) { } public void iDep_aUnd_bUnd ( ) { } public void iDep_aInh_bDep ( ) { } public void iDep_aInh_bUnd ( ) { } public void iUnd_aDep_bDep ( ) { } public void iUnd_aDep_bUnd ( ) { } public void iUnd_aUnd_bDep ( ) { }", "gt": "public void iUnd_aUnd_bUnd ( )", "prediction": "}\n", "label": 0}
{"id": 13759, "input": "<s> package org . eclipse . swt . widgets ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; public class Monitor_Test extends TestCase { private Display display ; public void testBounds ( ) { Object adapter = display . getAdapter ( IDisplayAdapter . class ) ; IDisplayAdapter displayAdapter = ( IDisplayAdapter ) adapter ; Rectangle expectedBounds = new Rectangle ( 10 , 20 , 30 , 40 ) ; displayAdapter . setBounds ( expectedBounds ) ; Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; assertNotNull ( primaryMonitor ) ; Rectangle monitorBounds = primaryMonitor . getBounds ( ) ; assertNotNull ( monitorBounds ) ; assertEquals ( new Rectangle ( 10 , 20 , 30 , 40 ) , monitorBounds ) ; displayAdapter . setBounds ( new Rectangle ( 100 , 200 , 300 , 400 ) ) ; Rectangle newMonitorBounds = primaryMonitor . getBounds ( ) ; assertEquals ( new Rectangle ( 100 , 200 , 300 , 400 ) , newMonitorBounds ) ; } public void testClientArea ( ) { Object adapter = display . getAdapter ( IDisplayAdapter . class ) ; IDisplayAdapter displayAdapter = ( IDisplayAdapter ) adapter ; Rectangle expectedBounds = new Rectangle ( 10 , 20 , 30 , 40 ) ; displayAdapter . setBounds ( expectedBounds ) ; Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; assertNotNull ( primaryMonitor ) ; Rectangle monitorClientArea = primaryMonitor . getClientArea ( ) ; assertNotNull ( monitorClientArea ) ; assertEquals ( new Rectangle ( 10 , 20 , 30 , 40 ) , monitorClientArea ) ; displayAdapter . setBounds ( new Rectangle ( 100 , 200 , 300 , 400 ) ) ; Rectangle newMonitorClientArea = primaryMonitor . getClientArea ( ) ; assertEquals ( new Rectangle ( 100 , 200 , 300 , 400 ) , newMonitorClientArea ) ; } public void testEquals ( ) { Monitor primaryMonitor = display . getPrimaryMonitor ( ) ; Monitor [", "gt": "] monitors = display . getMonitors ( ) ;", "prediction": "] expectedBounds = new Rectangle ( 10 , 20 , 30 , 40 ) ;\n", "label": 1}
{"id": 6612, "input": "<s> package org . ofbiz . common ; import static org . ofbiz . base . util . UtilGenerics . checkList ; import static org . ofbiz . base . util . UtilGenerics . checkMap ; import java . sql . Timestamp ; import java . util . Collection ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityComparisonOperator ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityFunction ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class FindServices { public static final String module = FindServices . class . getName ( ) ; public static final String resource = \"CommonUiLabels\" ; public static Map < String , EntityComparisonOperator < ? , ? > > entityOperators ; static { entityOperators = FastMap . newInstance ( ) ; entityOperators . put ( \"between\" , EntityOperator . BETWEEN ) ; entityOperators . put ( \"equals\" , EntityOperator . EQUALS ) ; entityOperators . put ( \"greaterThan\" , EntityOperator . GREATER_THAN ) ; entityOperators . put ( \"greaterThanEqualTo\" , EntityOperator . GREATER_THAN_EQUAL_TO ) ; entityOperators . put ( \"in\" , EntityOperator . IN ) ; entityOperators . put ( \"not-in\" , EntityOperator . NOT_IN ) ; entityOperators . put ( \"lessThan\" , EntityOperator . LESS_THAN ) ; entityOperators . put ( \"lessThanEqualTo\" , EntityOperator . LESS_THAN_EQUAL_TO ) ; entityOperators . put ( \"like\" , EntityOperator . LIKE ) ; entityOperators . put ( \"notLike\" , EntityOperator . NOT_LIKE ) ; entityOperators . put ( \"not\" , EntityOperator . NOT ) ; entityOperators . put ( \"notEqual\" , EntityOperator . NOT_EQUAL ) ; } public FindServices ( ) { } public static Map < String , Map < String , Map < String , Object > > > prepareField ( Map < String , ? > inputFields , Map < String , Object > queryStringMap , Map < String , List < Object [ ] > > origValueMap ) { Map < String , Map < String , Map < String , Object > > > normalizedFields = FastMap . newInstance ( ) ; for ( String fieldNameRaw : inputFields . keySet ( ) ) { String fieldNameRoot = null ; String fieldPair = null ; Object fieldValue = null ; int iPos = - 1 ; int iPos2 = - 1 ; Map < String , Map < String , Object > > subMap = null ; Map < String , Object", "gt": "> subMap2 = null ;", "prediction": "> subValueMap = null ;\n", "label": 0}
{"id": 13760, "input": "<s> package org . restlet . test . routing ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . routing . Filter ; import org . restlet . test . AbstractFilterTestCase ; import org . restlet . test . MockFilter ; import org . restlet . test . MockRestlet ; public class FilterTestCase extends AbstractFilterTestCase { @ Override protected Filter getFilter ( ) { return new MockFilter ( null ) ; } @ Override protected Request getRequest ( ) { return new Request ( ) ; } @ Override protected Response getResponse ( Request request ) { return new Response ( request ) ; } @ Override protected Restlet getRestlet ( ) { return new MockRestlet ( null ) ; } @ Override protected", "gt": "Class < ? > getRestletClass ( )", "prediction": "Filter getFilter ( )\n", "label": 1}
{"id": 1494, "input": "<s> public class TestCast6979683_GOOD { public static void main ( String ... av ) { bugReportExample ( ) ; for ( int x = - 1 ; x <= 2 ; x ++ ) { zconvTests ( x != 0 ) ; iconvTests ( x ) ; bconvTests ( ( byte ) x ) ; cconvTests ( ( char ) x ) ; } System . out . println ( \"Successfully ran \" + tests + \" tests.\" ) ; } static int tests ; static void assertEquals ( Object x , Object y ) { if ( ! x . equals ( y ) ) { throw new RuntimeException ( \"assertEquals: \" + x + \" != \" + y ) ; } ++ tests ; } static void bugReportExample ( ) { { } Object x = ( Object ) 1 ; int y = ( int ) x ; { } } static boolean zconv1 ( Boolean o ) { return o ; } static boolean zconv2 ( Object o ) { return ( boolean ) o ; } static boolean zconv3 ( Comparable < Boolean > o ) { return ( boolean ) o ; } static void zconvTests ( boolean x ) { assertEquals ( x , zconv1 ( x ) ) ; assertEquals ( x , zconv2 ( x ) ) ; assertEquals ( x , zconv3 ( x ) ) ; } static int iconv1 ( Integer o ) { return o ; } static int iconv2 ( Object o ) { return ( int ) o ; } static int iconv3 ( java . io . Serializable o ) { return ( int ) o ; } static int iconv4 ( Number o ) { return ( int ) o ; } static int iconv5 ( Comparable < Integer > o ) { return ( int ) o ; } static void iconvTests ( int x ) { assertEquals ( x , iconv1 ( x ) ) ; assertEquals ( x , iconv2 ( x ) ) ; assertEquals ( x , iconv3 ( x ) ) ; assertEquals ( x , iconv4 ( x ) ) ; assertEquals ( x , iconv5 ( x ) ) ; } static float bconv1 ( Byte o ) { return o ; } static float bconv2 ( Object o ) { return ( byte ) o ; } static float bconv3 ( java . io . Serializable o ) { return ( byte ) o ; } static float bconv4 ( Number o ) { return ( byte ) o ; } static void bconvTests ( byte x ) { float xf = x ; assertEquals ( xf , bconv1 ( x ) ) ; assertEquals ( xf , bconv2 ( x ) ) ; assertEquals ( xf , bconv3 ( x ) ) ; assertEquals ( xf , bconv4 ( x ) ) ; } static float cconv1 ( Character o ) { return o ; } static float cconv2 ( Object o ) { return ( char ) o ; } static float cconv3 ( java . io . Serializable o ) {", "gt": "return ( char ) o ;", "prediction": "return ( char ) o ;\n", "label": 0}
{"id": 13763, "input": "<s> package org . fuzzydb . util ; public interface ScoreMapper { float", "gt": "getScore ( float scoreFactor ) ;", "prediction": "score ;\n", "label": 1}
{"id": 8206, "input": "<s> package org . ofbiz . content . content ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . content . content . ContentKeywordIndex ; import org . ofbiz . security . Security ; public class ContentEvents { public static final String module = ContentEvents . class . getName ( ) ; public static final String resource = \"ContentErrorUiLabels\" ; public static String updateAllContentKeywords ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; Security security = ( Security ) request . getAttribute ( \"security\" ) ; String updateMode = \"CREATE\" ; String errMsg = null ; String doAll = request . getParameter ( \"doAll\" ) ; if ( ! security . hasEntityPermission ( \"CONTENTMGR\" , \"_\" + updateMode , request . getSession ( ) ) ) { Map < String , String > messageMap = UtilMisc . toMap ( \"updateMode\" , updateMode ) ; errMsg = UtilProperties . getMessage ( resource , \"contentevents.not_sufficient_permissions\" , messageMap , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; return \"error\" ; } EntityListIterator entityListIterator = null ; int numConts = 0 ; int errConts = 0 ; boolean beganTx = false ; try { beganTx = TransactionUtil . begin ( 7200 ) ; try { if ( Debug . infoOn ( ) ) { long count = delegator . findCountByCondition ( \"Content\" , null , null , null ) ; Debug . logInfo ( \"========== Found \" + count + \" contents to index ==========\" , module ) ; } entityListIterator = delegator . find ( \"Content\" , null , null , null , null , null ) ; } catch ( GenericEntityException gee ) { Debug . logWarning ( gee , gee . getMessage ( ) , module ) ; Map < String , String > messageMap = UtilMisc . toMap ( \"gee\" , gee . toString ( ) ) ; errMsg = UtilProperties . getMessage ( resource , \"contentevents.error_getting_content_list\" , messageMap , UtilHttp . getLocale ( request ) ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errMsg ) ; throw gee ; } GenericValue content ; while ( ( content = entityListIterator . next ( ) ) != null ) { try { ContentKeywordIndex . indexKeywords ( content , \"Y\" . equals ( doAll ) ) ; } catch ( GenericEntityException e ) { Debug . logWarning ( \"[ContentEvents.updateAllContentKeywords] Could not create content-keyword (write error); message: \" + e . getMessage ( ) , module ) ; errConts ++ ; } numConts ++ ; if ( numConts % 500 == 0 ) { Debug . logInfo ( \"Keywords indexed for \" + numConts + \" so far\" , module ) ; } } } catch ( GenericEntityException e ) { try { TransactionUtil . rollback ( beganTx , e . getMessage ( ) , e ) ; } catch ( Exception e1 ) { Debug . logError ( e1 , module ) ; } return \"error\" ; } catch ( Throwable t ) { Debug . logError ( t , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , t . getMessage ( ) ) ; try { TransactionUtil . rollback ( beganTx , t . getMessage ( ) , t ) ; } catch ( Exception e2 ) { Debug . logError ( e2 , module ) ; } return \"error\" ; } finally { if ( entityListIterator != null ) { try { entityListIterator . close ( ) ; } catch ( GenericEntityException gee ) { Debug . logError ( gee , \"Error", "gt": "closing EntityListIterator when indexing content keywords.\" , module ) ;", "prediction": ": \" + gee . getMessage ( ) , module ) ;\n", "label": 0}
{"id": 13775, "input": "<s> package org . fuzzydb . client ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import java . net . URLStreamHandler ; import org . fuzzydb . core . Settings ; public class WWMDBProtocolHander extends URLStreamHandler { static private WWMDBProtocolHander instance = new WWMDBProtocolHander ( ) ; static public WWMDBProtocolHander getInstance ( ) { return instance ; } private WWMDBProtocolHander ( ) { } @ Override protected URLConnection openConnection ( URL url ) { throw new UnsupportedOperationException ( ) ; } @ Override protected int getDefaultPort ( ) { return Settings . getInstance ( ) . getPrimaryServerPort ( ) ; } static public URL getAsURL ( String strUrl ) throws MalformedURLException { URL url = new URL ( null , strUrl , getInstance ( ) ) ; if ( ! url . getPath (", "gt": ") . startsWith ( \"/\" ) )", "prediction": ") . equals ( strUrl ) )\n", "label": 1}
{"id": 4448, "input": "<s> package next . interfaces . controller . widgets ; import next . i . controller . XTableController ; import next . i . view . CellData ; import next . i . view . TableData ; import next . i . view . XTableCell ; import next . i . view . XTableView ; import next . interfaces . controller . DemoUtils ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; public class PopupController extends XTableController { public PopupController ( ) { setTitle ( \"Popups\" ) ; getNavigationBar ( ) . setRightTitle ( \"Source\" ) ; getNavigationBar ( ) . getRightButton ( ) . addClickHandler ( new ClickHandler ( ) { public void onClick ( ClickEvent event ) { DemoUtils . openGit ( getGitPath ( ) ) ; } } ) ; ( ( XTableView ) getView (", "gt": ") ) . showChevron ( true ) ;", "prediction": ") ) . setTitle ( \"Source\" ) ;\n", "label": 0}
{"id": 13778, "input": "<s> package editor . PassabilityEditor ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Image ; import java . awt . Rectangle ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . MouseEvent ; import java . awt . event . MouseListener ; import java . awt . event . MouseMotionListener ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; import javax . swing . JComponent ; import javax . swing . Scrollable ; import map . TileSet ; public class PassabilityGrid extends JComponent implements ActionListener , MouseListener , MouseMotionListener , Scrollable { TileSet tileSet ; Image dbImage ; int tileSelected ; PassabilityEditor parent ; int x ; int y ; private boolean updating ; char [ ] [ ] passabilitySet ; private Dimension preferredScrollableSize ; BufferedImage pTiles ; public PassabilityGrid ( PassabilityEditor p ) { parent = p ; tileSet = parent . activeTileSet ; x = 0 ; y = 0 ; passabilitySet = tileSet . getPassabilitySet ( ) ; try { pTiles = ImageIO . read ( new File ( \"data/passabilityTiles.png\" ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } dbImage = null ; setVisible ( true ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; } public int getTileSelected ( ) { return tileSelected ; } public void refreshTileSet ( ) { tileSet = parent . activeTileSet ; x = 0 ; y = 0 ; passabilitySet = tileSet . getPassabilitySet ( ) ; dbImage = null ; repaint ( ) ; } @ Override public void mouseClicked ( MouseEvent arg0 ) { if ( ! updating ) return ; if ( passabilitySet [ x ] [ y ] == TileSet . PASSABLE ) passabilitySet [ x ] [ y ] = TileSet . OVERLAY ; else if ( passabilitySet [ x ] [ y ] == TileSet . OVERLAY ) passabilitySet [ x ] [ y ] = TileSet . IMPASSABLE ; else passabilitySet [ x ] [ y ] = TileSet . PASSABLE ; paintTile ( x , y ) ; } @ Override public void mouseEntered ( MouseEvent arg0 ) { updating = true ; repaint ( ) ; } @ Override public void mouseExited ( MouseEvent arg0 ) { updating = false ; x = - 1 ; y = - 1 ; repaint ( ) ; } @ Override public void mousePressed ( MouseEvent arg0 ) { } @ Override public void mouseReleased ( MouseEvent arg0 ) { } public void paintTile ( int x , int y ) { Graphics g = dbImage . getGraphics ( ) ; tileSet . drawEditorTile ( g , x * TileSet . TILE_DIMENSION , y * TileSet . TILE_DIMENSION , x , y ) ; g . setColor ( Color . BLACK ) ; String p = \"\" + passabilitySet [ x ] [ y ] ; int xpos ; int ypos ; if ( pTiles != null ) { xpos = x * TileSet . TILE_DIMENSION ; ypos = y * TileSet . TILE_DIMENSION ; if ( passabilitySet [ x ] [ y ] == TileSet . OVERLAY ) g . drawImage ( pTiles , xpos , ypos , xpos + TileSet . TILE_DIMENSION , ypos + TileSet . TILE_DIMENSION , 0 , 0 , 32 , 32 , null ) ; else if ( passabilitySet [ x ] [ y ] == TileSet . IMPASSABLE ) g . drawImage ( pTiles , xpos , ypos , xpos + TileSet . TILE_DIMENSION , ypos + TileSet . TILE_DIMENSION , 32 , 0 , 64 , 32 , null ) ; } else { xpos = x * TileSet . TILE_DIMENSION + ( TileSet . TILE_DIMENSION / 2 ) ; ypos = y * TileSet . TILE_DIMENSION + ( TileSet . TILE_DIMENSION / 2 ) ; for ( int i = 0 ; i < 9 ; i ++ ) g . drawString ( p , xpos - 1 * ( ( i % 3 ) - 1 ) , ypos - 1 * ( ( i / 3 ) - 1 ) ) ; g . setColor ( Color . WHITE ) ; g . drawString ( p , xpos , ypos ) ; } repaint ( ) ; } @ Override public void paint ( Graphics g ) { if ( g == null ) return ; if ( dbImage == null ) { dbImage = createImage ( getWidth ( ) , getHeight ( ) ) ; Graphics g2 = dbImage . getGraphics ( ) ; g2 . setColor ( Color . GRAY ) ; g2 . fillRect ( 0 , 0 , dbImage . getWidth (", "gt": "null ) , dbImage . getHeight ( null ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 6374, "input": "<s> interface I { void method ( ) ; } class A { public void method ( ) throws Exception { } } public", "gt": "class ThrowsConflict extends A implements I", "prediction": "class B\n", "label": 0}
{"id": 13785, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . Vector ; public class TestModel { Vector fListeners = new Vector ( ) ; int fNumLevels ; int fNumChildren ; public TestModel ( int numLevels , int numChildren ) { fNumLevels = numLevels ; fNumChildren = numChildren ; } public void addListener ( ITestModelListener listener ) { fListeners . addElement ( listener ) ; } public void fireModelChanged ( TestModelChange change ) { for (", "gt": "int i = 0 ;", "prediction": "int i = 0 ;\n", "label": 1}
{"id": 5865, "input": "<s> package com . matburt . mobileorg . util ; public class OrgNodeNotFoundException extends Exception { private static final long serialVersionUID = 6603637490966826497L ; public OrgNodeNotFoundException ( ) { super ( ) ; } public OrgNodeNotFoundException ( String message ) { super ( message ) ; } public", "gt": "OrgNodeNotFoundException ( OrgFileNotFoundException e )", "prediction": "OrgNodeNotFoundException ( String message )\n", "label": 0}
{"id": 13787, "input": "<s> package org . eclipse . swt . internal . graphics ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . CRC32 ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer ; import org . eclipse . rap . rwt . internal . util . SharedInstanceBuffer . IInstanceCreator ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . ImageLoader ; import org . eclipse . swt . graphics . RGB ; public class InternalImageFactory { private final SharedInstanceBuffer < String , InternalImage > cache ; public InternalImageFactory ( ) { cache = new SharedInstanceBuffer < String , InternalImage > ( ) ; } public InternalImage findInternalImage ( final String fileName ) { return cache . get ( fileName , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { return createInternalImage ( fileName ) ; } } ) ; } public InternalImage findInternalImage ( InputStream stream ) { final BufferedInputStream bufferedStream = new BufferedInputStream ( stream ) ; final ImageData imageData = readImageData ( bufferedStream ) ; final String path = createGeneratedImagePath ( imageData ) ; return cache . get ( path , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { return createInternalImage ( path , bufferedStream , imageData ) ; } } ) ; } public InternalImage findInternalImage ( final ImageData imageData ) { final String path = createGeneratedImagePath ( imageData ) ; return cache . get ( path , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { InputStream stream = createInputStream ( imageData ) ; return createInternalImage ( path , stream , imageData ) ; } } ) ; } InternalImage findInternalImage ( String key , final InputStream inputStream ) { return cache . get ( key , new IInstanceCreator < InternalImage > ( ) { public InternalImage createInstance ( ) { BufferedInputStream bufferedStream = new BufferedInputStream ( inputStream ) ; ImageData imageData = readImageData ( bufferedStream ) ; String path = createGeneratedImagePath ( imageData ) ; return createInternalImage ( path , bufferedStream , imageData ) ; } } ) ; } static ImageData readImageData ( InputStream stream ) throws SWTException { stream . mark ( Integer . MAX_VALUE ) ; ImageData result = new ImageData ( stream ) ; try { stream . reset ( ) ; } catch ( IOException shouldNotHappen ) { String msg = \"Could not reset input stream after reading image\" ; throw new RuntimeException ( msg , shouldNotHappen ) ; } return result ; } static InputStream createInputStream ( ImageData imageData ) { ImageLoader imageLoader = new ImageLoader ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; imageLoader . data = new ImageData [ ] { imageData } ; imageLoader . save ( outputStream , getOutputFormat ( imageData ) ) ; byte [ ] bytes = outputStream . toByteArray ( ) ; return new ByteArrayInputStream ( bytes ) ; } private static InternalImage createInternalImage ( String fileName ) { InternalImage result ; try { FileInputStream stream = new FileInputStream ( fileName ) ; try { result = createInternalImage ( stream ) ; } finally { stream . close ( ) ; } } catch ( IOException ioe ) { throw new SWTException ( SWT . ERROR_IO , ioe . getMessage ( ) ) ; } return result ; } private static InternalImage createInternalImage ( InputStream stream ) { InputStream bufferedStream = new BufferedInputStream ( stream ) ; ImageData imageData = readImageData ( bufferedStream ) ; String path = createGeneratedImagePath ( imageData ) ; return createInternalImage ( path , bufferedStream , imageData ) ; } private static InternalImage createInternalImage ( String path , InputStream stream , ImageData imageData ) { RWT . getResourceManager ( ) . register ( path , stream ) ; return new InternalImage ( path , imageData . width , imageData . height ) ; } private static int getOutputFormat ( ImageData imageData ) { int result = imageData . type ; if ( imageData . type == SWT . IMAGE_UNDEFINED ) { result = SWT . IMAGE_PNG ; } return result ; } private static String createGeneratedImagePath ( ImageData data ) { String hash = getHash ( data ) ; return \"generated/\" + hash ; } private static String getHash ( ImageData imageData ) { CRC32 crc32 = new CRC32 ( ) ; if ( imageData . data != null ) { crc32 . update ( 1 ) ; crc32 . update ( imageData . data ) ; } if ( imageData . alphaData != null ) { crc32 . update ( 2 ) ; crc32 . update ( imageData . alphaData ) ; } if ( imageData . maskData != null ) { crc32 . update ( 3 ) ; crc32 . update ( imageData . maskData ) ; } if ( imageData . palette != null ) { crc32 . update ( 4 ) ; if ( imageData . palette . isDirect ) { crc32 . update ( 5 ) ; crc32 . update ( imageData . palette . redMask ) ; crc32 . update ( imageData . palette . greenMask ) ; crc32 . update ( imageData . palette . blueMask ) ; } else { crc32 . update ( 6 ) ; RGB [ ] rgb = imageData . palette . getRGBs ( ) ; for ( int i = 0 ; i < rgb . length ; i ++ ) { crc32 . update ( rgb [ i ] . red ) ; crc32 . update ( rgb [ i ] . green ) ; crc32 . update ( rgb [ i ] . blue ) ; } } } crc32 . update ( imageData . alpha ) ; crc32 . update ( imageData . transparentPixel ) ; crc32 . update ( imageData . type ) ; crc32 . update ( imageData . bytesPerLine ) ; crc32 . update (", "gt": "imageData . scanlinePad ) ;", "prediction": "imageData . width ) ;\n", "label": 1}
{"id": 7461, "input": "<s> package com . redhat . ceylon . tools . test ; import java . util . Arrays ; import java . util . Collections ; import org . junit . Assert ; import org . junit . Test ; import com . redhat . ceylon . ceylondoc . CeylonDocTool ; import com . redhat . ceylon . common . tool . OptionArgumentException ; import com . redhat . ceylon . common . tool . ToolFactory ; import com . redhat . ceylon . common . tool . ToolLoader ; import com . redhat . ceylon . common . tool . ToolModel ; import com . redhat . ceylon . tools . CeylonToolLoader ; public class DocToolTest { protected final ToolFactory pluginFactory = new ToolFactory ( ) ; protected final ToolLoader pluginLoader = new CeylonToolLoader ( null ) ; @ Test public void testNoModules ( ) throws Exception { ToolModel < CeylonDocTool > model = pluginLoader . loadToolModel ( \"doc\" ) ; Assert . assertNotNull ( model ) ; try { pluginFactory . bindArguments ( model , Collections . < String > emptyList ( ) ) ; Assert . fail ( ) ; } catch ( OptionArgumentException e ) { Assert . assertEquals ( \"Argument modules should appear at least 1 time(s)\" , e . getMessage ( ) ) ; } } @ Test public void testDoc ( ) throws Exception { ToolModel < CeylonDocTool > model = pluginLoader . loadToolModel ( \"doc\" ) ; Assert . assertNotNull ( model ) ; CeylonDocTool tool = pluginFactory . bindArguments ( model , Arrays . asList ( \"--src=test/src\" , \"com.redhat.ceylon.tools.test.ceylon\" ) ) ; tool . run ( ) ; } @ Test public void testDocNonShared ( ) throws Exception { ToolModel < CeylonDocTool > model = pluginLoader .", "gt": "loadToolModel ( \"doc\" ) ;", "prediction": "loadToolModel ( \"doc\" ) ;\n", "label": 0}
{"id": 13791, "input": "<s> package org . modelgoon . core ; import java . util . Observable ; import org . eclipse . draw2d . geometry . Point ; public class ModelElement extends Observable { Point location = new Point ( 0 , 0 ) ; public final void setLocation ( final int x , final int y ) { this . location . x = x ; this . location . y = y ; propertyChanged ( ) ; } public final void setLocation ( final Point newLocation ) { this . location . x = newLocation . x ; this . location . y = newLocation . y ; propertyChanged ( ) ; } public final Point getLocation ( ) { return this . location ; } public void propertyChanged ( ) { setChanged ( ) ; notifyObservers ( ) ; } public void setX ( final int x ) { this . location . x = x ; } public void setY ( final int y ) { this", "gt": ". location . y = y ;", "prediction": ". location . y = y ;\n", "label": 1}
{"id": 3410, "input": "<s> class T { class iC { } static class iSC { } private class iVC { } static private class iSVC { } final class iFC { } static final class iSFC { } final private class iFVC { } static final private class iSFVC { } abstract class iAC { } static abstract class iSAC { } abstract private class iAVC { } static abstract private class iSAVC { } protected class iRC { } static protected class iSRC { } public class iUC { } static public class iSUC { } final protected class iFRC { } static final protected class iSFRC { } final public class iFUC { } static final public class iSFUC { } abstract protected class iARC { } static abstract protected class iSARC { } abstract public class iAUC { } static abstract public class iSAUC { } interface iI { } static interface iSI { } abstract interface iAI { } static abstract interface iSAI { } protected interface iRI { } static protected interface iSRI { } abstract protected interface iARI { } static abstract protected interface iSARI { } private interface iVI { } static private interface iSVI { } abstract private interface iAVI { } static abstract private interface iSAVI { } public interface iUI { } static public interface iSUI { } abstract public interface iAUI { } static abstract public interface iSAUI { } } interface U { class jC { } static class jSC { } public class jUC { } static public class jSUC { } final class jFC { } static final class jSFC { } final public class jFUC { }", "gt": "static final public class jSFUC", "prediction": "}\n", "label": 0}
{"id": 13793, "input": "<s> package org . eclipse . ui . tests . zoom ; import org . eclipse . ui . IFolderLayout ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IPerspectiveFactory ; public class ZoomPerspectiveFactory implements IPerspectiveFactory { public static final String PERSP_ID = \"org.eclipse.ui.tests.zoom.ZoomPerspectiveFactory\" ; public static final String STACK1_VIEW1 = IPageLayout . ID_OUTLINE ; public static final String STACK1_VIEW2 = IPageLayout . ID_PROBLEM_VIEW ; public static final String STACK1_PLACEHOLDER1 = IPageLayout . ID_PROP_SHEET ; public static final String STACK1_VIEW3 = IPageLayout . ID_TASK_LIST ; public static final String UNSTACKED_VIEW1 = IPageLayout . ID_RES_NAV ; public static final String FASTVIEW1 = IPageLayout . ID_BOOKMARKS ; public void createInitialLayout ( IPageLayout layout ) { String folderId = \"org.eclipse.ui.test.zoom.mystack\" ; IFolderLayout folder = layout . createFolder ( folderId , IPageLayout . LEFT", "gt": ", 0.5f , IPageLayout . ID_EDITOR_AREA ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3061, "input": "<s> public class TestJavascript extends JavadocTester { private static final String BUG_ID = \"4665566-4855876\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" , SRC_DIR + FS + \"TestJavascript.java\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"<a href=\\\"../index.html?pkg/C.html\\\" target=\\\"_top\\\">Frames</a>\" } , { BUG_ID + FS + \"TestJavascript.html\" , \"<a href=\\\"index.html?TestJavascript.html\\\" target=\\\"_top\\\">Frames</a>\" } , { BUG_ID + FS + \"index.html\" , \"<script type=\\\"text/javascript\\\">\" + NL + \"    targetPage = \\\"\\\" + window.location.search;\" + NL + \"    if (targetPage != \\\"\\\" && targetPage != \\\"undefined\\\")\" + NL + \"        targetPage = targetPage.substring(1);\" + NL + \"    if (targetPage.indexOf(\\\":\\\") != -1)\" + NL + \"        targetPage = \\\"undefined\\\";\" + NL + \"    function loadFrames() {\" + NL + \"        if (targetPage != \\\"\\\" && targetPage != \\\"undefined\\\")\" + NL + \"             top.classFrame.location = top.targetPage;\" + NL + \"    }\" + NL + \"</script>\" } , { BUG_ID + FS + \"pkg\" + FS + \"C.html\" , \"    if (location.href.indexOf('is-external=true') == -1) {\" + NL + \"        parent.document.title=\\\"C\\\";\" + NL + \"    }\" } , } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; public static void main ( String [ ] args ) { TestJavascript tester = new TestJavascript ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return", "gt": "getClass ( ) . getName ( ) ;", "prediction": "BUG_NAME ;\n", "label": 0}
{"id": 13796, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . graphics . Image ; public class LabelProvider extends BaseLabelProvider implements ILabelProvider { public LabelProvider ( ) { } public Image getImage ( Object element ) { return null ; } public String", "gt": "getText ( Object element )", "prediction": "toString ( )\n", "label": 1}
{"id": 3852, "input": "<s> import java . io . * ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; class MessageFile { static final Pattern emptyOrCommentPattern = Pattern . compile ( \"( *#.*)?\" ) ; static final Pattern infoPattern = Pattern . compile ( \"# ([0-9]+: [-A-Za-z ]+, )*[0-9]+: [-A-Za-z ]+\" ) ; class Line { String text ; Line prev ; Line next ; Line ( String text ) { this . text = text ; } boolean isEmptyOrComment ( ) { return emptyOrCommentPattern . matcher ( text ) . matches ( ) ; } boolean isInfo ( ) { return infoPattern . matcher ( text ) . matches ( ) ; } boolean hasContinuation ( ) { return ( next != null ) && text . endsWith ( \"\\\\\" ) ; } Line insertAfter ( String text ) { Line l = new Line ( text ) ; insertAfter ( l ) ; return l ; } void insertAfter ( Line l ) { assert prev == null && next == null ; l . prev = this ; l . next = next ; if ( next == null ) lastLine = l ; else next . prev = l ; next = l ; } Line insertBefore ( String text ) { Line l = new Line ( text ) ; insertBefore ( l ) ; return l ; } void insertBefore ( Line l ) { assert prev == null && next == null ; l . prev = prev ; l . next = this ; if ( prev == null ) firstLine = l ; else prev . next = l ; prev = l ; } void remove ( ) { if ( prev == null ) firstLine = next ; else prev . next = next ; if ( next == null ) lastLine = prev ; else next . prev = prev ; prev = null ; next = null ; } } static final class Message { final Line firstLine ; private Info info ; Message ( Line l ) { firstLine = l ; } boolean needInfo ( ) { Line l = firstLine ; while ( true ) { if ( l . text . matches ( \".*\\\\{[0-9]+\\\\}.*\" ) ) return true ; if ( ! l . hasContinuation ( ) ) return false ; l = l . next ; } } Set < Integer > getPlaceholders ( ) { Pattern p = Pattern . compile ( \"\\\\{([0-9]+)\\\\}\" ) ; Set < Integer > results = new TreeSet < Integer > ( ) ; Line l = firstLine ; while ( true ) { Matcher m = p . matcher ( l . text ) ; while ( m . find ( ) ) results . add ( Integer . parseInt ( m . group ( 1 ) ) ) ; if ( ! l . hasContinuation ( ) ) return results ; l = l . next ; } } Info getInfo ( ) { if ( info == null ) { Line l = firstLine . prev ; if ( l != null && l . isInfo ( ) ) info = new Info ( l . text ) ; else info = new Info ( ) ; } return info ; } void setInfo ( Info info ) { this . info = info ; Line l = firstLine . prev ; if ( l != null && l . isInfo ( ) ) l . text = info . toComment ( ) ; else firstLine . insertBefore ( info . toComment ( ) ) ; } List < Line > getLines ( boolean includeAllPrecedingComments ) { List < Line > lines = new ArrayList < Line > ( ) ; Line l = firstLine ; if ( includeAllPrecedingComments ) { while ( l . prev != null && l . prev . isEmptyOrComment ( ) ) l = l . prev ; while ( l . text . isEmpty ( ) ) l = l . next ; } else { if ( l . prev != null && l . prev . isInfo ( ) ) l = l . prev ; } for ( ; l != firstLine ; l = l . next ) lines . add ( l ) ; for ( l = firstLine ; l != null && l . hasContinuation ( ) ; l = l . next ) lines . add ( l ) ; lines . add ( l ) ; l = l . next ; if ( l != null && l . text . isEmpty ( ) ) lines . add ( l ) ; return lines ; } } static final class Info { static class Field { boolean unused ; Set < String > values ; boolean listOfAny = false ;", "gt": "boolean setOfAny = false ;", "prediction": "for ( int i = 0 ;\n", "label": 0}
{"id": 13797, "input": "<s> package org . jscsi . utils ; import static org . testng . AssertJUnit . assertEquals ; import static org . testng . AssertJUnit . assertTrue ; import org . testng . annotations . Test ; public final class SerialArithmeticNumberTest { @ Test public final void testInitialize ( ) { final SerialArithmeticNumber serialNumber = new SerialArithmeticNumber ( 1 ) ; assertEquals ( 1 , serialNumber . getValue ( ) ) ; } @ Test public final void testCompare1 ( ) { final SerialArithmeticNumber serialNumber = new SerialArithmeticNumber ( ) ; assertEquals ( 0 , serialNumber . getValue ( ) ) ; assertTrue ( serialNumber . compareTo ( 4 ) < 0 ) ; } @ Test public final void testCompare2 ( ) {", "gt": "final SerialArithmeticNumber sNumber = new SerialArithmeticNumber ( 4 ) ;", "prediction": "final SerialArithmeticNumber serialNumber = new SerialArithmeticNumber ( ) ;\n", "label": 1}
{"id": 737, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class PackageIndexFrameWriter extends AbstractPackageIndexWriter { public PackageIndexFrameWriter ( ConfigurationImpl configuration , String filename ) throws IOException { super ( configuration , filename ) ; } public static void generate ( ConfigurationImpl configuration ) { PackageIndexFrameWriter packgen ; String filename = \"overview-frame.html\" ; try { packgen = new PackageIndexFrameWriter ( configuration , filename ) ; packgen . buildPackageIndexFile ( \"doclet.Window_Overview\" , false ) ; packgen . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } protected void addPackagesList ( PackageDoc [ ] packages , String text , String tableSummary , Content body ) { Content heading = HtmlTree . HEADING ( HtmlConstants . PACKAGE_HEADING , true , packagesLabel ) ; Content div = HtmlTree . DIV ( HtmlStyle . indexContainer , heading ) ; HtmlTree ul = new HtmlTree ( HtmlTag . UL ) ; ul . addAttr ( HtmlAttr . TITLE , packagesLabel . toString ( ) ) ; for ( int i = 0 ; i < packages . length ; i ++ ) { if ( packages [ i ] != null && ( ! ( configuration . nodeprecated && Util . isDeprecated ( packages [ i ] ) ) ) ) { ul . addContent ( getPackage ( packages [ i ] ) ) ; } } div . addContent ( ul ) ; body . addContent ( div ) ; } protected Content getPackage ( PackageDoc pd ) { Content packageLinkContent ; Content packageLabel ; if ( pd . name ( ) . length ( ) > 0 ) { packageLabel = getPackageLabel ( pd . name ( ) ) ; packageLinkContent = getHyperLink ( pathString ( pd , \"package-frame.html\" ) , \"\" , packageLabel , \"\" , \"packageFrame\" ) ; } else { packageLabel = new RawHtml ( \"&lt;unnamed package&gt;\" ) ; packageLinkContent = getHyperLink ( \"package-frame.html\" , \"\" , packageLabel , \"\" , \"packageFrame\" ) ; } Content li = HtmlTree . LI ( packageLinkContent ) ; return li ; } protected void addNavigationBarHeader ( Content body ) { Content headerContent ; if ( configuration . packagesheader . length ( ) > 0 ) { headerContent = new RawHtml ( replaceDocRootDir ( configuration . packagesheader ) ) ; } else { headerContent = new RawHtml ( replaceDocRootDir ( configuration . header ) ) ; } Content heading = HtmlTree . HEADING ( HtmlConstants . TITLE_HEADING , true , HtmlStyle . bar , headerContent ) ; body . addContent ( heading ) ; } protected void addOverviewHeader ( Content body ) { } protected void addAllClassesLink ( Content body ) { Content linkContent = getHyperLink ( \"allclasses-frame.html\" , \"\" , allclassesLabel , \"\" , \"packageFrame\" ) ; Content div = HtmlTree . DIV ( HtmlStyle . indexHeader , linkContent ) ; body . addContent ( div ) ; } protected void addNavigationBarFooter ( Content body ) { Content p = HtmlTree . P", "gt": "( getSpace ( ) ) ;", "prediction": "USH ( body ) ;\n", "label": 0}
{"id": 13801, "input": "<s> package org . eclipse . jface . internal . databinding . viewers ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . core . databinding . observable . Diffs ; import org . eclipse . core . databinding . observable . Realm ; import org . eclipse . core . databinding . observable . set . AbstractObservableSet ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ICheckable ; import org . eclipse . jface . viewers . IElementComparer ; public class CheckableCheckedElementsObservableSet extends AbstractObservableSet { private ICheckable checkable ; private Set wrappedSet ; private Object elementType ; private IElementComparer elementComparer ; private ICheckStateListener listener ; public CheckableCheckedElementsObservableSet ( Realm realm , final Set wrappedSet , Object elementType , IElementComparer elementComparer , ICheckable checkable ) { super ( realm ) ; Assert . isNotNull ( checkable , \"Checkable cannot be null\" ) ; Assert . isNotNull ( wrappedSet , \"Wrapped set cannot be null\" ) ; this . checkable = checkable ; this . wrappedSet = wrappedSet ; this . elementType = elementType ; this . elementComparer = elementComparer ; listener = new ICheckStateListener ( ) { public void checkStateChanged ( CheckStateChangedEvent event ) { Object element = event . getElement ( ) ; if ( event . getChecked ( ) ) { if ( wrappedSet . add ( element ) ) fireSetChange ( Diffs . createSetDiff ( Collections . singleton ( element ) , Collections . EMPTY_SET ) ) ; } else { if ( wrappedSet . remove ( element ) ) fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , Collections . singleton ( element ) ) ) ; } } } ; checkable . addCheckStateListener ( listener ) ; } protected Set getWrappedSet ( ) { return wrappedSet ; } Set createDiffSet ( ) { return ViewerElementSet . withComparer ( elementComparer ) ; } public Object getElementType ( ) { return elementType ; } public boolean add ( Object o ) { getterCalled ( ) ; boolean added = wrappedSet . add ( o ) ; if ( added ) { checkable . setChecked ( o , true ) ; fireSetChange ( Diffs . createSetDiff ( Collections . singleton ( o ) , Collections . EMPTY_SET ) ) ; } return added ; } public boolean remove ( Object o ) { getterCalled ( ) ; boolean removed = wrappedSet . remove ( o ) ; if ( removed ) { checkable . setChecked ( o , false ) ; fireSetChange ( Diffs . createSetDiff ( Collections . EMPTY_SET , Collections . singleton ( o ) ) ) ; } return removed ; } public boolean addAll ( Collection c ) { getterCalled ( ) ; Set additions = createDiffSet ( ) ; for ( Iterator iterator = c . iterator ( ) ; iterator . hasNext ( ) ; ) { Object element = iterator . next ( ) ; if ( wrappedSet . add ( element ) ) { checkable . setChecked ( element , true ) ; additions . add ( element ) ; } } boolean changed = ! additions . isEmpty ( ) ; if ( changed ) fireSetChange ( Diffs . createSetDiff ( additions , Collections . EMPTY_SET ) ) ; return changed ; } public boolean removeAll ( Collection c ) { getterCalled ( ) ; Set removals = createDiffSet ( ) ; for ( Iterator iterator = c", "gt": ". iterator ( ) ;", "prediction": ". iterator ( ) ;\n", "label": 1}
{"id": 8494, "input": "<s> public class T6594284 { class A { public void a ( ) { } } class B extends A { public void b ( ) { } } interface I { void i ( ) ; } interface I1 { void i1 ( ) ; } class E extends B implements I { public void i ( ) { } ; } class C < W extends B", "gt": "& I1 , T extends W >", "prediction": "> implements I\n", "label": 0}
{"id": 13804, "input": "<s> package org . restlet . example . book . restlet . ch02 . sec4 . sub2 ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . MediaType ; public class Tracer extends Restlet { public Tracer ( Context context ) { super ( context ) ; } @ Override public void handle ( Request request , Response response ) { String entity = \"Method       : \" + request . getMethod ( ) + \"\\nResource URI : \" + request . getResourceRef ( ) + \"\\nIP address   : \" + request . getClientInfo ( ) . getAddress ( ) + \"\\nAgent name   : \" + request . getClientInfo ( ) . getAgentName ( ) + \"\\nAgent version: \" + request . getClientInfo ( ) . getAgentVersion ( ) ; response . setEntity ( entity ,", "gt": "MediaType . TEXT_PLAIN ) ;", "prediction": "response ) ;\n", "label": 1}
{"id": 1188, "input": "<s> package org . remast . swing ; import java . awt . BorderLayout ; import java . awt . KeyboardFocusManager ; import java . awt . Toolkit ; import java . awt . event . InputEvent ; import java . awt . event . KeyEvent ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . swing . JComponent ; import javax . swing . JScrollPane ; import javax . swing . KeyStroke ; import javax . swing . UIManager ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import javax . swing . text . DefaultEditorKit ; import org . jdesktop . swingx . JXPanel ; import org . jdesktop . swingx . JXTextArea ; import org . remast . util . StringUtils ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public class JTextEditor extends JXPanel { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( JTextEditor . class ) ; public interface TextChangeObserver { void onTextChange ( ) ; } private List < TextChangeObserver > textObservers = new ArrayList < TextChangeObserver > ( ) ; JXTextArea textArea ; private boolean scrollable = false ; private void notifyTextObservers ( ) { for ( TextChangeObserver txtObserver : textObservers ) { txtObserver . onTextChange ( ) ; } } public void addTextObserver ( final TextChangeObserver txtObserver ) { textObservers . add ( txtObserver ) ; } public JTextEditor ( ) { initialize ( ) ; } public JTextEditor ( final boolean scrollable ) { this . scrollable = scrollable ; initialize ( ) ; } private void initialize ( ) { this . setLayout ( new BorderLayout ( ) ) ; UIManager . put ( \"TextArea.font\" , UIManager . get ( \"TextField.font\" ) ) ; textArea = new JXTextArea ( ) ; textArea . setPrompt ( textBundle . textFor ( \"TextEditor.prompt\" ) ) ; textArea . setLineWrap ( true ) ; textArea . setEnabled ( true ) ; textArea . setEditable ( true ) ; setTabBehavior ( ) ; textArea . getDocument ( ) .", "gt": "addDocumentListener ( new DocumentListener ( )", "prediction": "setText ( ) ;\n", "label": 0}
{"id": 13807, "input": "<s> package org . eclipse . swt . internal . widgets . toolbarkit ; import java . io . IOException ; import java . util . Arrays ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . ToolBar ; import junit . framework . TestCase ; public class ToolBarLCA_Test extends TestCase { private Display display ; private Shell shell ; private ToolBarLCA lca ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; lca = new ToolBarLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . NONE ) ; ControlLCATestUtil . testActivateListener ( toolBar ) ; ControlLCATestUtil . testFocusListener ( toolBar ) ; ControlLCATestUtil . testMouseListener ( toolBar ) ; ControlLCATestUtil . testKeyListener ( toolBar ) ; ControlLCATestUtil . testTraverseListener ( toolBar ) ; ControlLCATestUtil . testMenuDetectListener ( toolBar ) ; ControlLCATestUtil . testHelpListener ( toolBar ) ; } public void testRenderCreate ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . NONE ) ; lca . renderInitialization ( toolBar ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( toolBar ) ; assertEquals ( \"rwt.widgets.ToolBar\" , operation . getType ( ) ) ; Object [ ] styles = operation . getStyles ( ) ; assertTrue ( Arrays . asList ( styles ) . contains ( \"HORIZONTAL\" ) ) ; assertFalse ( Arrays . asList ( styles ) . contains ( \"H_SCROLL\" ) ) ; } public void testRenderCreate_Vertical ( ) throws IOException { ToolBar toolBar = new ToolBar ( shell , SWT . VERTICAL ) ; lca . renderInitialization ( toolBar ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( toolBar ) ; Object [ ] styles = operation . getStyles ( ) ; assertTrue ( Arrays . asList ( styles ) . contains ( \"VERTICAL\" ) ) ; assertFalse ( Arrays .", "gt": "asList ( styles ) . contains ( \"V_SCROLL\" ) ) ;", "prediction": "asList ( styles ) . contains ( \"HORIZONTAL\" ) ) ;\n", "label": 1}
{"id": 4509, "input": "<s> package shuttle . hci . com ; public final class R { public static final class attr { } public static final class drawable { public static final int ic_launcher = 0x7f020000 ; public static final int marker = 0x7f020001 ; public static final int person_drop = 0x7f020002 ; } public static final class id { public static final int RelativeLayout1 = 0x7f050000 ; public static final int actualLocation = 0x7f05000e ; public static final int destToggle = 0x7f05000d ; public static final int destination = 0x7f050002 ; public static final int destinationLabel = 0x7f050003 ; public static final int destinationSublabel = 0x7f050004 ; public static final int fastest = 0x7f05000a ; public static final int favorites = 0x7f050007 ; public static final int go = 0x7f050001 ; public static final int mapView = 0x7f050009 ; public static final int shortest = 0x7f05000b ; public static final int shuttleStop = 0x7f050008 ; public static final int shuttleTime = 0x7f05000c ; public static final int timeLabel = 0x7f050005 ; public static final int timePicker1 = 0x7f050006 ; } public static final class layout { public static final int list_item = 0x7f030000 ; public static final int main = 0x7f030001 ; public static final int results_view = 0x7f030002 ; } public static final class string { public static final int LocationHint = 0x7f040003 ; public static final int app_name = 0x7f040001 ; public static final int dept_time = 0x7f040002 ; public static final int hello = 0x7f040000 ; public static", "gt": "final int map_key = 0x7f040004 ;", "prediction": "final int hi = 0x7f040004 ;\n", "label": 0}
{"id": 13809, "input": "<s> package org . restlet . example . book . restlet . ch06 . sec2 . server ; import org . restlet . example . book . restlet . ch02 . sec5 . sub5 . common . AccountResource ; import org . restlet . ext . wadl . MethodInfo ; import org . restlet . ext . wadl . RepresentationInfo ; import org . restlet . ext . wadl . WadlServerResource ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; public class AccountServerResource extends WadlServerResource implements AccountResource { private int accountId ; @ Override protected RepresentationInfo describe ( MethodInfo methodInfo , Class < ? > representationClass , Variant variant ) { RepresentationInfo result = super . describe ( methodInfo , representationClass , variant ) ; result . setReference ( \"account\" ) ; return result ; } @ Override protected void doInit ( ) throws ResourceException { String accountIdAttribute = getAttribute ( \"accountId\" ) ; if ( accountIdAttribute != null ) { this . accountId = Integer", "gt": ". parseInt ( accountIdAttribute ) ;", "prediction": ". parseInt ( accountIdAttribute ) ;\n", "label": 1}
{"id": 1606, "input": "<s> package org . ofbiz . widget ; import java . io . IOException ; import java . util . Map ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . entity . Delegator ; public interface PortalPageWorkerInterface { public String renderPortalPageAsTextExt ( Delegator delegator , String portalPageId , Map < String , Object > templateContext ,", "gt": "boolean cache ) throws GeneralException , IOException ;", "prediction": "Map < String , Object > parameters )\n", "label": 0}
{"id": 13810, "input": "<s> package org . eclipse . rap . internal . design . example . stacks ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . swt . widgets . Control ; public class ViewToolBarRegistry { private List presentationList = new ArrayList ( ) ; private ViewToolBarRegistry ( ) { } public static ViewToolBarRegistry getInstance ( ) { return SingletonUtil . getSessionInstance ( ViewToolBarRegistry . class ) ; } public void addViewPartPresentation ( ViewStackPresentation presentation ) { presentationList . add ( presentation ) ; } public void removeViewPartPresentation ( ViewStackPresentation presentation ) { presentationList . remove ( presentation ) ; } public void fireToolBarChanged ( ) {", "gt": "for ( int i = 0 ;", "prediction": "}\n", "label": 1}
{"id": 9544, "input": "<s> package uk . ac . cam . cl . dtg . android . time . data . handlers ; import java . util . List ; import uk . ac . cam . cl . dtg . android . time . buses . BusStop ; public class StopsSAXHandler extends", "gt": "AbstractStopsSAXHandler < List < BusStop > >", "prediction": "BusStop\n", "label": 0}
{"id": 13813, "input": "<s> package org . eclipse . swt . internal . browser . browserkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . eclipse . rap . rwt . testfixture . Fixture . fakeNewRequest ; import static org . eclipse . rap . rwt . testfixture . Fixture . fakeSetParameter ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . rap . rwt . widgets . BrowserCallback ; import org . eclipse . rap . rwt . widgets . BrowserUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . browser . * ; import org . eclipse . swt . internal . widgets . IBrowserAdapter ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; public class BrowserLCA_Test extends TestCase { private Display display ; private Shell shell ; private BrowserLCA lca ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display ) ; lca = new BrowserLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { Browser browser = new Browser ( shell , SWT . NONE ) ; ControlLCATestUtil . testActivateListener ( browser ) ; ControlLCATestUtil . testFocusListener ( browser ) ; ControlLCATestUtil . testMouseListener ( browser ) ; ControlLCATestUtil . testKeyListener ( browser ) ; ControlLCATestUtil . testTraverseListener ( browser ) ; ControlLCATestUtil . testMenuDetectListener ( browser ) ; ControlLCATestUtil . testHelpListener ( browser ) ; } public void testTextChanged ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; String expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; assertFalse ( BrowserLCA . hasUrlChanged ( browser ) ) ; browser = new Browser ( shell , SWT . NONE ) ; browser . setText ( \"Hello\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"Hello\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; browser . setText ( \"GoodBye\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"GoodBye\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . preserveWidgets ( ) ; browser . setText ( \"GoodBye\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( \"GoodBye\" . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; browser = new Browser ( shell , SWT . NONE ) ; browser . setText ( \"\" ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; } public void testUrlChanged ( ) throws IOException { Fixture . markInitialized ( display ) ; Browser browser = new Browser ( shell , SWT . NONE ) ; assertTrue ( BrowserLCA . hasUrlChanged ( browser ) ) ; String expected = String . valueOf ( BrowserLCA . BLANK_HTML . hashCode ( ) ) ; assertTrue ( BrowserLCA . getUrl ( browser ) . contains ( expected ) ) ; Fixture . markInitialized ( browser ) ; Fixture . preserveWidgets ( ) ; assertFalse ( BrowserLCA . hasUrlChanged ( browser ) ) ; browser", "gt": "= new Browser ( shell , SWT . NONE ) ;", "prediction": "= new Browser ( shell , SWT . NONE ) ;\n", "label": 1}
{"id": 4079, "input": "<s> package org . gk . ui . client . icon ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ClientBundle ; import com . google . gwt . resources . client . ImageResource ; public interface Icons extends ClientBundle { public static final Icons get = GWT . create ( Icons . class ) ; @ Source ( \"create.png\" ) ImageResource create ( ) ; @ Source ( \"cross.gif\" ) ImageResource cross ( ) ; @ Source ( \"delete.png\" ) ImageResource delete ( ) ; @ Source ( \"query.png\" ) ImageResource query ( ) ; @ Source ( \"edit.png\" ) ImageResource edit ( ) ; @ Source (", "gt": "\"edit.png\" ) ImageResource update ( ) ;", "prediction": "\"delete.gif\" ) ImageResource delete ( ) ;\n", "label": 0}
{"id": 13822, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . service ; import java . io . File ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . platform . picture . api . ImageInfo ; import org . nuxeo . ecm . platform . picture . magick . utils . ImageIdentifier ; import org . nuxeo . ecm . platform . picture . magick . utils . ImageResizer ; import org . nuxeo . ecm . platform . pictures . tiles . api . PictureTiles ; import org . nuxeo . ecm . platform . pictures . tiles . helpers . StringMaker ; public class PictureTilingCacheInfo { public static int SHRINK_DOWN_LIMIT_PX = 2000 ; private static final Log log = LogFactory . getLog ( PictureTilingCacheInfo . class ) ; protected String cacheKey ; protected String workingDir ; protected ImageInfo originalPictureInfos ; protected Map < Integer , ImageInfo > shrinkedImages ; protected List < Integer > shrinkedImagesWidths ; protected Map < String , PictureTiles > tilesSet ; protected String syncShrink = \"oneOncePerInstance\" ; protected Date lastAccessTime ; protected void updateAccessTime ( ) { lastAccessTime = new Date ( ) ; } public Date getLastAccessedTime ( ) { return lastAccessTime ; } protected long getFileSize ( String path ) { if ( path == null ) return 0 ; File file = new File ( path ) ; if ( file . exists ( ) ) { return file . length ( ) ; } else return 0 ; } public long getDiskSpaceUsageInBytes ( ) { long diskSpaceUsage = 0 ; diskSpaceUsage += getFileSize ( originalPictureInfos . getFilePath ( ) ) ; for ( Integer s : shrinkedImages . keySet ( ) ) { diskSpaceUsage += getFileSize ( shrinkedImages . get ( s ) . getFilePath ( ) ) ; } for ( String tileDef : tilesSet . keySet ( ) ) { PictureTiles tiles = tilesSet . get ( tileDef ) ; File tileDir = new File ( tiles . getTilesPath ( ) ) ; if ( tileDir . exists ( ) ) { for ( File tileFile : tileDir . listFiles ( ) ) { diskSpaceUsage += tileFile . length ( ) ; } } } return diskSpaceUsage ; } public PictureTilingCacheInfo ( String cacheKey , String workingDir , String filePath ) throws Exception { this . cacheKey = cacheKey ; this . workingDir = workingDir ; originalPictureInfos = ImageIdentifier . getInfo ( filePath ) ; shrinkedImages = new HashMap < Integer , ImageInfo > ( ) ; shrinkedImagesWidths = new ArrayList < Integer > ( ) ; tilesSet = new HashMap < String , PictureTiles > ( ) ; updateAccessTime ( ) ; } public void addPictureTilesToCache ( PictureTiles tiles ) { tilesSet . put ( tiles . getTileFormatCacheKey ( ) , tiles ) ; updateAccessTime ( ) ; } public PictureTiles getCachedPictureTiles ( int tileWidth , int tileHeight , int maxTiles ) { String ptKey = StringMaker . getTileFormatString ( tileWidth , tileHeight , maxTiles ) ; updateAccessTime ( ) ; return tilesSet . get ( ptKey ) ; } public String getWorkingDir ( ) { return workingDir ; } public String getOriginalPicturePath ( ) { return originalPictureInfos . getFilePath ( ) ; } public String getTilingDir ( int tileWidth , int tileHeight , int maxTiles ) { String dirPath = \"tiles-\" + tileWidth + \"-\" +", "gt": "tileHeight + \"-\" + maxTiles ;", "prediction": "tileHeight + \"-\" + maxTiles ;\n", "label": 1}
{"id": 7786, "input": "<s> package ar . com . fdvs . dj . domain . entities . columns ; import java . text . Format ; import java . util . ArrayList ; import java . util . List ; import ar . com . fdvs . dj . domain . DJBaseElement ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . Entity ; public abstract class AbstractColumn extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private String name ; private String title ; private Integer posX = new Integer ( 0 ) ; private Integer posY = new Integer ( 0 ) ; private Integer width = new Integer ( 100 ) ; private Boolean fixedWidth = Boolean . FALSE ; private Style style = new Style ( ) ; private Style headerStyle = null ; private String pattern ; private Boolean printRepeatedValues = Boolean . TRUE ; private Boolean blankWhenNull = Boolean . TRUE ; private String truncateSuffix = null ; private Format textFormatter ; private DJHyperLink link ; private List conditionalStyles = new ArrayList ( ) ; public List getConditionalStyles ( ) { return conditionalStyles ; } public void setConditionalStyles ( List conditionalStyles ) { this . conditionalStyles = conditionalStyles ; } public String getTitle ( ) { return title ; } public void setTitle ( String label ) { this . title = label ; } public Integer getPosX ( ) { return posX ; } public void setPosX ( Integer posX ) { this . posX = posX ; } public Integer getPosY ( ) { return posY ; } public void setPosY ( Integer posY ) { this . posY = posY ; } public Style getHeaderStyle ( ) { return headerStyle ; } public void setHeaderStyle ( Style headerStyle ) { this . headerStyle = headerStyle ; } public Style getStyle ( ) { return style ; } public void setStyle ( Style style ) { this . style = style ; } public Integer getWidth ( ) { return width ; } public void setWidth ( Integer width ) { this . width = width ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public Boolean getPrintRepeatedValues ( ) { return printRepeatedValues ; } public void setPrintRepeatedValues ( Boolean printRepeatedValues ) { this . printRepeatedValues = printRepeatedValues ; } public abstract String getTextForExpression ( ) ; public abstract String getValueClassNameForExpression ( ) ; public abstract String getGroupVariableName ( String type , String columnToGroupByProperty ) ; public abstract String getVariableClassName ( DJCalculation op ) ; public abstract String getInitialExpression ( DJCalculation op ) ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public Boolean getBlankWhenNull ( ) { return blankWhenNull ; } public void setBlankWhenNull ( Boolean blankWhenNull ) { this . blankWhenNull = blankWhenNull ; } public Boolean getFixedWidth ( ) { return fixedWidth ; } public void setFixedWidth ( Boolean fixedWidth ) { this . fixedWidth = fixedWidth ; } public String getTruncateSuffix ( ) { return truncateSuffix ; } public void setTruncateSuffix ( String truncateSuffix ) { this . truncateSuffix = truncateSuffix ; } public Format getTextFormatter ( ) { return textFormatter ; } public void", "gt": "setTextFormatter ( Format textFormatter )", "prediction": "setTextFormatter ( Format textFormatter )\n", "label": 0}
{"id": 13825, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public class MouseEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public int button ; public int stateMask ; public int x ; public int y ; public int count ; public MouseEvent ( Event event ) { super ( event ) ; x = event . x ; y = event . y ; button = event . button ; stateMask = event . stateMask ; count = event . count ; } @ Override public String toString ( ) { String", "gt": "string = super . toString ( ) ;", "prediction": "Buffer buffer = new StringBuffer ( ) ;\n", "label": 1}
{"id": 7747, "input": "<s> import java . io . IOException ; public interface Iface {", "gt": "void foo ( ) throws IOException ;", "prediction": "}\n", "label": 0}
{"id": 13827, "input": "<s> package org . spliffy . server . db . utils ; import com . bradmcevoy . http . Filter ; import com . bradmcevoy . http . FilterChain ; import com . bradmcevoy . http . Request ; import com . bradmcevoy . http . Response ; public class MiltonOpenSessionInViewFilter implements Filter { private final SessionManager sessionManager ; public MiltonOpenSessionInViewFilter ( SessionManager sessionManager ) { this . sessionManager = sessionManager ; } @ Override public void process ( FilterChain chain , Request request , Response response ) { try { sessionManager . open ( ) ; chain . process ( request , response ) ; } finally {", "gt": "sessionManager . close ( ) ;", "prediction": "}\n", "label": 1}
{"id": 4676, "input": "<s> package src ; import java . io . File ; import org . bukkit . event . block . BlockBreakEvent ; import org . bukkit . event . player . PlayerJoinEvent ; import org . bukkit . event . player . PlayerQuitEvent ; import LizaCraft . LizaCraftTestModule ; public class BobTest { public static void main ( String [ ] args ) { File plugin = new File ( \"bobplugin.jar\" ) ; if ( plugin . exists ( ) ) { LizaCraftTestModule testModule = new LizaCraftTestModule ( \"Bob's Test\" ) ; testModule . startModule ( ) ; testModule . getServer ( ) ; testModule . enableEvents ( ) ; testModule . getEventListener ( ) . registerEvent ( PlayerJoinEvent . class ) ; testModule . getEventListener ( ) . registerEvent ( BlockBreakEvent . class ) ; testModule . getEventListener ( ) . registerEvent (", "gt": "PlayerQuitEvent . class ) ;", "prediction": "PlayerQuitEvent . class ) ;\n", "label": 0}
{"id": 13831, "input": "<s> package org . seage . metaheuristic . grasp ; public class HillClimber implements IHillClimber { private int _numIter ; private Solution _currentSolution ; private IMoveManager _moveManager ; private IObjectiveFunction _objectiveFunction ; private ISolutionGenerator _solutionGenerator ; public HillClimber ( IObjectiveFunction objectiveFunction , IMoveManager moveManager , ISolutionGenerator solutionGenerator , int numIter ) { _moveManager = moveManager ; _objectiveFunction = objectiveFunction ; _solutionGenerator = solutionGenerator ; _numIter = numIter ; } public void startSearching ( Solution solution ) throws Exception { _currentSolution = solution ; int iter = 0 ; double bestVal = 0 ; while ( iter < _numIter ) { IMove [ ] moves = _moveManager . getAllMoves ( _currentSolution ) ; bestVal = solution . getObjectiveValue ( ) ; IMove best = null ; double val ; boolean noBetterMove = true ; for ( IMove m : moves ) { val = _objectiveFunction . evaluateMove ( _currentSolution , m ) ; if ( val < bestVal ) { best = m ; bestVal = val ; noBetterMove = false ; } } if ( noBetterMove ) { return ; } if ( best != null ) { _currentSolution = best . apply ( _currentSolution ) ; _currentSolution . setObjectiveValue ( bestVal ) ; } _objectiveFunction . reset ( ) ; iter ++ ; } } public void startRestartedSearching ( int numRestarts ) throws Exception { int countRest = 0 ; double bestDist = Double . MAX_VALUE ; Solution bestSolution = null ; while ( countRest <= numRestarts ) { startSearching ( _solutionGenerator . generateSolution ( ) ) ; countRest ++ ; if", "gt": "( bestDist > getBestSolution ( ) . getObjectiveValue ( ) )", "prediction": "( bestSolution == null )\n", "label": 1}
{"id": 2107, "input": "<s> package org . ofbiz . base . lang ; public interface Range < T > { boolean after ( Range < T > range ) ; boolean after ( T value ) ; boolean before ( Range < T > range ) ; boolean before ( T value ) ; T end ( ) ; boolean includes ( Range <", "gt": "T > range ) ;", "prediction": "T > range ) ;\n", "label": 0}
{"id": 13837, "input": "<s> package org . restlet . test . ext . oauth . app ; import org . restlet . data . MediaType ; import org . restlet . ext . oauth . OAuthUser ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . resource . ServerResource ; public class DummyResource extends ServerResource { @ Get public Representation getDummy ( ) { org . restlet . security . User u = getRequest ( ) . getClientInfo ( ) . getUser ( ) ; if ( u != null && u instanceof OAuthUser ) getContext ( ) . getAttributes ( ) . put ( \"testuser\" , u ) ; return new StringRepresentation ( \"TestSuccessful\" , MediaType . TEXT_HTML ) ; } @ Post ( \"form\" ) public Representation postDummy ( Representation input ) { org . restlet . security . User u = getRequest ( ) . getClientInfo ( ) . getUser ( ) ; if ( u", "gt": "!= null && u instanceof OAuthUser )", "prediction": "!= null && u instanceof OAuthUser ) getContext ( ) . getAttributes ( ) . put ( \"testuser\" , u ) ;\n", "label": 1}
{"id": 861, "input": "<s> package Liza ; import org . bukkit . Server ;", "gt": "public interface LizaServer extends Server", "prediction": "import org . bukkit . Test ;\n", "label": 0}
{"id": 13838, "input": "<s> package org . restlet . test . connector ; import java . io . Serializable ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . LocalReference ; import org . restlet . data . Method ; import org . restlet . data . Reference ; import org . restlet . representation . ObjectRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . ClientResource ; import org . restlet . test . RestletTestCase ; public class RiapTestCase extends RestletTestCase { private static final String DEFAULT_MSG = \"no-default\" ; private static final Serializable JUST_SOME_OBJ = new Serializable ( ) { private static final long serialVersionUID = 1L ; } ; private static final String ECHO_TEST_MSG = JUST_SOME_OBJ . toString ( ) ; private String buildAggregate ( String echoMessage , String echoCopy ) { return \"ORIGINAL: \" + echoMessage + \"\\n\" + \"ECHOCOPY: \" + echoCopy + \"\\n\" ; } public void testRiap ( ) throws Exception { final Component comp = new Component ( ) ; final Application localOnly = new Application ( ) { @ Override public Restlet createInboundRoot ( ) { return new Restlet ( getContext ( ) ) { @ Override public void handle ( Request request , Response response ) { final String selfBase = \"riap://application\" ; final Reference ref = request . getResourceRef ( ) ; final String remainder = ref . getRemainingPart ( ) ; Representation result = new StringRepresentation ( DEFAULT_MSG ) ; if ( remainder . startsWith ( \"/echo/\" ) ) { result = new StringRepresentation ( remainder . substring ( 6 ) ) ; } else if ( remainder . equals ( \"/object\" ) ) { result = new ObjectRepresentation < Serializable > ( JUST_SOME_OBJ ) ; } else if ( remainder . equals ( \"/null\" ) ) { result = new ObjectRepresentation < Serializable > ( ( Serializable ) null ) ; } else if ( remainder . equals ( \"/self-aggregated\" ) ) { final String echoMessage = ECHO_TEST_MSG ; final Reference echoRef = new LocalReference ( selfBase + \"/echo/\" + echoMessage ) ; String echoCopy = null ; try { ClientResource r = new ClientResource ( echoRef ) ; echoCopy = r . get ( ) . getText ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( \"Error getting internal reference to \" + echoRef ) ; } assertEquals ( \"expected echoMessage back\" , echoMessage , echoCopy ) ; result = new StringRepresentation ( buildAggregate ( echoMessage , echoCopy ) ) ; } response . setEntity ( result ) ; } } ; } } ; comp . getInternalRouter ( ) . attach ( \"/local\" , localOnly ) ; String localBase = \"riap://component/local\" ; Restlet dispatcher", "gt": "= comp . getContext ( ) . getClientDispatcher ( ) ;", "prediction": "= new Restlet ( getContext ( ) )\n", "label": 1}
{"id": 5157, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import java . awt . Color ; import java . util . List ; import org . jfree . chart . plot . PlotOrientation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . dataset . CategoryDataset ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . chart . plot . LinePlot ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; public class DJLineChartBuilder extends AbstractChartBuilder { public DJLineChartBuilder setOperation ( byte operation ) { this . chart . setOperation ( operation ) ; return this ; } public DJLineChartBuilder setLink ( DJHyperLink link ) { this . chart . setLink ( link ) ; return this ; } public DJLineChartBuilder setBackColor ( Color backColor ) { this . chart . getOptions ( ) . setBackColor ( backColor ) ; return this ; } public DJLineChartBuilder setHeight ( int height ) { this . chart . getOptions ( ) . setHeight ( height ) ; return this ; } public DJLineChartBuilder setWidth ( int width ) { this . chart . getOptions ( ) . setWidth ( width ) ; return this ; } public DJLineChartBuilder setCentered ( boolean centered ) { this . chart . getOptions ( ) . setCentered ( centered ) ; return this ; } public DJLineChartBuilder setPosition ( byte position ) { this . chart . getOptions ( ) . setPosition ( position ) ; return this ; } public DJLineChartBuilder setY ( int y ) { this . chart . getOptions ( ) . setY ( y ) ; return this ; } public DJLineChartBuilder setX ( int x ) { this . chart . getOptions ( ) . setX ( x ) ; return this ; } public DJLineChartBuilder setShowLegend ( boolean showLegend ) { this . chart . getOptions ( ) . setShowLegend ( new Boolean ( showLegend ) ) ; return this ; } public DJLineChartBuilder setTitleColor ( Color titleColor ) { this . chart . getOptions ( ) . setTitleColor ( titleColor ) ; return this ; } public DJLineChartBuilder setSubtitleColor ( Color subtitleColor ) { this . chart . getOptions ( ) . setSubtitleColor ( subtitleColor ) ; return this ; } public DJLineChartBuilder setLegendColor ( Color legendColor ) { this . chart . getOptions ( ) . setLegendColor ( legendColor ) ; return this ; } public DJLineChartBuilder setLegendBackgroundColor ( Color legendBackgroundColor ) { this . chart . getOptions ( ) . setLegendBackgroundColor ( legendBackgroundColor ) ; return this ; } public DJLineChartBuilder setTheme ( String theme ) { this . chart . getOptions ( ) . setTheme ( theme ) ; return this ; } public DJLineChartBuilder setTitleFont ( Font titleFont ) { this . chart . getOptions ( ) . setTitleFont ( titleFont ) ; return this ; } public DJLineChartBuilder setSubtitleFont ( Font subtitleFont ) { this . chart . getOptions ( ) . setSubtitleFont ( subtitleFont ) ; return this ; } public DJLineChartBuilder setLegendFont ( Font legendFont ) { this . chart . getOptions ( ) . setLegendFont ( legendFont ) ; return this ; } public DJLineChartBuilder setLegendPosition ( byte legendPosition ) { this . chart . getOptions ( ) . setLegendPosition ( legendPosition ) ; return this ; } public DJLineChartBuilder setTitlePosition ( byte titlePosition ) { this . chart . getOptions ( ) . setTitlePosition ( titlePosition ) ; return this ; } public DJLineChartBuilder setTitle ( String title ) { this . chart . getOptions ( ) . setTitleExpression ( new LiteralExpression ( title ) ) ; return this ; } public DJLineChartBuilder setTitle ( StringExpression titleExpression ) { this . chart . getOptions ( ) . setTitleExpression ( titleExpression ) ; return this ; } public DJLineChartBuilder setSubtitle ( String subtitle ) { this . chart . getOptions ( ) . setSubtitleExpression ( new LiteralExpression ( subtitle ) ) ; return this ; } public DJLineChartBuilder setSubtitle ( StringExpression subtitleExpression ) { this . chart . getOptions ( ) . setSubtitleExpression ( subtitleExpression ) ; return this ; } public DJLineChartBuilder setLineStyle ( byte lineStyle ) { this . chart . getOptions ( ) . setLineStyle ( lineStyle ) ; return this ; } public DJLineChartBuilder setLineWidth ( float lineWidth ) { this . chart . getOptions ( ) . setLineWidth ( new Float ( lineWidth ) ) ; return this ; } public DJLineChartBuilder setLineColor ( Color lineColor ) { this . chart . getOptions ( ) . setLineColor ( lineColor ) ; return this ; } public DJLineChartBuilder setPadding ( int padding ) { this . chart . getOptions ( ) . setPadding ( new Integer ( padding ) ) ; return this ; } public DJLineChartBuilder setCustomizerClass ( String customizerClass ) { this . chart . getOptions ( ) . setCustomizerClass ( customizerClass ) ; return this ; } public DJLineChartBuilder setCategory ( PropertyColumn category ) { getDataset ( ) . setCategory ( category ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column ) { getDataset ( ) . addSerie ( column ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column , String label ) { getDataset ( ) . addSerie ( column , label ) ; return this ; } public DJLineChartBuilder addSerie ( AbstractColumn column , StringExpression labelExpression ) { getDataset ( ) . addSerie ( column , labelExpression ) ; return this ; } public DJLineChartBuilder setUseSeriesAsCategory ( boolean useSeriesAsCategory ) { getDataset ( ) . setUseSeriesAsCategory ( useSeriesAsCategory ) ; return this ; } public DJLineChartBuilder setLabelRotation ( double labelRotation ) { this . getPlot ( ) . setLabelRotation ( new Double ( labelRotation ) ) ; return this ; } public DJLineChartBuilder setOrientation ( PlotOrientation orientation ) {", "gt": "getPlot ( ) . setOrientation ( orientation ) ;", "prediction": "getDataset ( ) . setOrientation ( orientation ) ;\n", "label": 0}
{"id": 13852, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import org . apache . lucene . benchmark . byTask . feeds . ContentSource ; import org . apache . lucene . benchmark . byTask . feeds . DocData ; import org . apache . lucene . benchmark . byTask . utils . Config ; public class ConsumeContentSourceTask extends PerfTask { private ContentSource source ; private DocData dd = new DocData ( ) ; public ConsumeContentSourceTask ( PerfRunData runData ) { super ( runData ) ; Config config = runData . getConfig ( ) ; String sourceClass = config . get ( \"content.source\" , null ) ; if ( sourceClass == null ) { throw new IllegalArgumentException ( \"content.source must be defined\" ) ; } try { source = ( ContentSource ) Class . forName ( sourceClass ) . newInstance ( ) ; source . setConfig ( config ) ; source . resetInputs ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } protected String getLogMessage ( int recsCount ) { return \"read \" + recsCount + \" documents from the content source\" ; } public", "gt": "void close ( ) throws Exception", "prediction": "void setConfig ( Config config )\n", "label": 1}
{"id": 5751, "input": "<s> package com . sun . tools . apt . mirror ; import com . sun . tools . apt . mirror . declaration . DeclarationMaker ; import com . sun . tools . apt . mirror . type . TypeMaker ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . CompletionFailure ; import com . sun . tools . javac . comp . Attr ; import com . sun . tools . javac . comp . Enter ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . Names ; @ SuppressWarnings ( \"deprecation\" ) public class AptEnv { public Names names ; public Symtab symtab ; public Types jctypes ; public Enter enter ; public Attr attr ; public TypeMaker typeMaker ; public DeclarationMaker declMaker ; private static final Context . Key < AptEnv > aptEnvKey = new Context . Key < AptEnv > ( ) ; public static AptEnv instance ( Context context ) { AptEnv instance = context . get ( aptEnvKey ) ;", "gt": "if ( instance == null )", "prediction": "if ( instance == null )\n", "label": 0}
{"id": 13861, "input": "<s> package org . gatein . common . util ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . TreeMap ; public class MapBuilder < M extends Map < K , V > , K , V > { private final M map ; private MapBuilder ( M map ) { if ( map == null ) { throw new IllegalArgumentException ( ) ; } this . map = map ; } public static < K , V > MapBuilder < HashMap < K , V > , K , V > hashMap ( ) { return new MapBuilder < HashMap < K , V > , K , V > ( new HashMap < K , V > ( ) ) ; } public static < K , V > MapBuilder < HashMap < K , V > , K , V > hashMap ( K k , V v ) { MapBuilder < HashMap < K , V > , K , V > builder = new MapBuilder < HashMap < K , V > , K , V > ( new HashMap < K , V > ( ) ) ; builder . put ( k , v ) ; return builder ; } public static < K , V > MapBuilder < TreeMap < K , V > , K , V > treeMap ( ) { return new MapBuilder < TreeMap < K , V > , K , V > ( new TreeMap < K , V > ( ) ) ; } public static < K , V > MapBuilder < TreeMap < K , V > , K , V > treeMap ( K k , V v ) { MapBuilder < TreeMap < K , V > , K , V > builder = new MapBuilder < TreeMap < K , V > , K , V > ( new TreeMap < K , V > ( ) ) ; builder . put ( k , v ) ; return builder ; } public static < K , V > MapBuilder < LinkedHashMap < K , V > , K , V > linkedHashMap ( ) { return new MapBuilder < LinkedHashMap < K , V > , K , V > ( new LinkedHashMap < K , V > ( ) ) ; } public static < K , V > MapBuilder < LinkedHashMap < K , V > , K , V > linkedHashMap ( K k , V v ) { MapBuilder < LinkedHashMap < K , V > , K , V > builder = new MapBuilder < LinkedHashMap < K , V > , K , V > ( new LinkedHashMap <", "gt": "K , V > ( ) ) ;", "prediction": "K , V > ( ) ) ;\n", "label": 1}
{"id": 9091, "input": "<s> import java . util . * ; class CastTest { private class BA < T > { } private class BB < T , S > { } private class BC < T > extends BA < Integer > { } private class BD < T > extends BB < T , T > { } private void inconsistentMatches ( ) { Object o ; o = ( BC < ? > ) (", "gt": "BA < String > ) null ;", "prediction": ") ;\n", "label": 0}
{"id": 13873, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import org . fuzzydb . io . core . messages . Command ; import org . fuzzydb . io . core . messages . Loggable ; @ SuppressWarnings ( \"serial\" ) public class BeginAndCommitCmd extends BeginTransactionCmd implements Loggable { private BeginAndCommitCmd ( ) { super ( 0 , 0 , 0 , null ) ; } public BeginAndCommitCmd ( int storeId , int cid , int tid , Command payload ) { super (", "gt": "storeId , cid , tid , payload ) ;", "prediction": "storeId , cid , tid , payload ) ;\n", "label": 1}
{"id": 8689, "input": "<s> import java . lang . annotation . Annotation ; import java . io . * ; import java . util . Collections ; import java . util . Set ; import java . util . HashSet ; import java . util . List ; import java . util . ArrayList ; import java . util . Arrays ; import javax . annotation . processing . * ; import javax . tools . * ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import static javax . lang . model . util . ElementFilter . * ; @ AnnotatedElementInfo ( annotationName = \"java.lang.SuppressWarnings\" , expectedSize = 0 , names = { } ) public class TestElementsAnnotatedWith extends JavacTestingAbstractProcessor { public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnvironment ) { TypeElement annotatedElementInfoElement = elements . getTypeElement ( \"AnnotatedElementInfo\" ) ; Set < ? extends Element > resultsMeta = Collections . emptySet ( ) ; Set < ? extends Element > resultsBase = Collections . emptySet ( ) ; if ( ! roundEnvironment . processingOver ( ) ) { testNonAnnotations ( roundEnvironment ) ; TypeElement firstType = typesIn ( roundEnvironment . getRootElements ( ) ) . iterator ( ) . next ( ) ; AnnotatedElementInfo annotatedElementInfo = firstType . getAnnotation ( AnnotatedElementInfo . class ) ; boolean failed = false ; if ( annotatedElementInfo == null ) throw new IllegalArgumentException ( \"Missing AnnotatedElementInfo annotation on \" + firstType ) ; else { Set < String > expectedNames = new HashSet < String > ( Arrays . asList ( annotatedElementInfo . names ( ) ) ) ; resultsMeta = roundEnvironment . getElementsAnnotatedWith ( elements . getTypeElement ( annotatedElementInfo . annotationName ( ) ) ) ; System . err . println ( \"Results: \" + resultsMeta ) ; if ( resultsMeta . size ( ) != annotatedElementInfo . expectedSize ( ) ) { failed = true ; System . err . printf ( \"Bad number of elements; expected %d, got %d%n\" , annotatedElementInfo . expectedSize ( ) , resultsMeta . size ( ) ) ; } else { for ( Element element : resultsMeta ) { String simpleName = element . getSimpleName ( ) . toString ( ) ; if ( ! expectedNames . contains ( simpleName ) ) { failed = true ; System . err . println ( \"Name ``\" + simpleName + \"'' not expected.\" ) ; } } } } resultsBase = computeResultsBase ( roundEnvironment , annotatedElementInfo . annotationName ( ) ) ;", "gt": "if ( ! resultsMeta . equals ( resultsBase ) )", "prediction": "}\n", "label": 0}
{"id": 13874, "input": "<s> package org . nuxeo . ecm . automation . core . operations . users ; import java . util . Set ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . automation . features . PrincipalHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . security . PermissionProvider ; import org . nuxeo . ecm . platform . usermanager . UserManager ; @ Operation ( id = GetDocumentUsersAndGroups . ID , category = Constants . CAT_USERS_GROUPS , label = \"Get Users and Groups\" , description = \"\" + \"Fetch the users and groups that have a given permission \" + \"on the input document and then set them in the context under the \" + \"given key variable name. The operation returns the input \" + \"document. You can later use the list of identifiers set by this \" + \"operation on the context from another operation. The 'key' \" + \"argument represents the variable name and the 'permission' argument \" + \"the permission to check. If the 'ignore groups' argument is false \" + \"then groups will be part of the result. If the 'resolve groups' \" + \"argument is true then groups are recursively resolved, adding \" + \"user members of these groups in place of them. Be <b>warned</b> \" + \"that this may be a very consuming operation. If the 'prefix \" + \"identifiers' argument is true, then user identifiers are \" + \"prefixed by 'user:' and groups identifiers are prefixed by 'group:'.\" ) public class GetDocumentUsersAndGroups { public static final String ID = \"Document.GetUsersAndGroups\" ; @ Context protected PermissionProvider permissionProvider ; @ Context protected UserManager umgr ;", "gt": "@ Context protected OperationContext ctx ;", "prediction": "@ Context protected UserManager userManager ;\n", "label": 1}
{"id": 4522, "input": "<s> package org . jjflyboy . tjpeditor . generator ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . xtext . generator . IFileSystemAccess ; import org . eclipse . xtext . generator . IGenerator ; @ SuppressWarnings ( \"all\"", "gt": ") public class ProjectGenerator implements IGenerator", "prediction": ") public class FileSystemResource extends Resource\n", "label": 0}
{"id": 13881, "input": "<s> package org . apache . lucene . queryParser . core . nodes ; import java . util . ArrayList ; import java . util . Hashtable ; import java . util . List ; import java . util . Map ; import java . util . ResourceBundle ; import org . apache . lucene . messages . NLS ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; public abstract class QueryNodeImpl implements QueryNode , Cloneable { private static final long serialVersionUID = 5569870883474845989L ; public static final String PLAINTEXT_FIELD_NAME = \"_plain\" ; private boolean isLeaf = true ; private Hashtable < CharSequence , Object > tags = new Hashtable < CharSequence , Object > ( ) ; private List < QueryNode > clauses = null ; protected void allocate ( ) { if ( this . clauses == null ) { this . clauses = new ArrayList < QueryNode > ( ) ; } else { this . clauses . clear ( ) ; } } public final void add ( QueryNode child ) { if ( isLeaf ( ) || this . clauses == null || child == null ) { throw new IllegalArgumentException ( NLS . getLocalizedMessage ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED ) ) ; } this . clauses . add ( child ) ; ( ( QueryNodeImpl ) child ) . setParent ( this ) ; } public final void add ( List < QueryNode > children ) { if ( isLeaf ( ) || this . clauses == null ) { throw new IllegalArgumentException ( NLS . getLocalizedMessage ( QueryParserMessages . NODE_ACTION_NOT_SUPPORTED ) ) ; } for ( QueryNode child : getChildren ( ) ) { add ( child ) ; } } public boolean isLeaf ( ) { return this . isLeaf ; } public final void set ( List < QueryNode > children ) { if ( isLeaf ( ) || this . clauses == null ) { ResourceBundle bundle = ResourceBundle . getBundle ( \"org.apache.lucene.queryParser.messages.QueryParserMessages\" ) ; String message = bundle . getObject ( \"Q0008E.NODE_ACTION_NOT_SUPPORTED\" ) . toString ( ) ; throw new IllegalArgumentException ( message ) ; } for ( QueryNode child : children ) { ( ( QueryNodeImpl ) child ) . setParent ( null ) ; } allocate ( ) ; for ( QueryNode child : children ) { add ( child ) ; } } public QueryNode cloneTree ( ) throws CloneNotSupportedException { QueryNodeImpl clone = ( QueryNodeImpl ) super . clone ( ) ; clone . isLeaf = this . isLeaf ; clone . tags = new Hashtable < CharSequence , Object > ( ) ; if ( this . clauses != null ) { List < QueryNode > localClauses = new ArrayList < QueryNode > ( ) ; for ( QueryNode clause : this . clauses ) { localClauses . add ( clause . cloneTree ( ) ) ; } clone . clauses = localClauses ; } return clone ; } public Object clone ( ) throws CloneNotSupportedException { return cloneTree ( ) ; } protected void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public final List < QueryNode > getChildren ( ) { if ( isLeaf", "gt": "( ) || this . clauses == null )", "prediction": "( ) || this . clauses == null )\n", "label": 1}
{"id": 53, "input": "<s> class T6799605 < X > { < T extends T6799605 < T > > void m ( T6799605 < T > x1 ) { } < T > void m ( T6799605 < T > x1 , T6799605 < T > x2 ) { } < T > void m ( T6799605 < T > x1 , T6799605", "gt": "< T > x2 , T6799605 < T > x3 )", "prediction": "< T > x2 )\n", "label": 0}
{"id": 13882, "input": "<s> package com . codeslap . persistence ; import android . content . Context ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; class RawQueryImpl implements RawQuery { private final SQLiteDatabase mDb ; private final DatabaseSpec mDatabaseSpec ; RawQueryImpl ( Context context , String name , String specId ) { mDatabaseSpec = PersistenceConfig . getDatabaseSpec ( specId ) ; SqliteDb helper = SqliteDb . getInstance ( context , name , mDatabaseSpec ) ; mDb = helper . getDatabase ( ) ; } @ Override public Cursor findAll ( Class < ? > theClass ) { return mDb . query ( SQLHelper . getTableName ( theClass ) , null , null , null , null , null , null , null ) ; } @ Override public Cursor findAll ( Object where ) { return findAll ( where , null ) ; } @ Override public Cursor findAll ( Object where , Constraint constraint ) { return SQLHelper . getCursorFindAllWhere ( mDb , where . getClass ( ) , where , null , constraint , mDatabaseSpec ) ; } @ Override public Cursor findAll ( Object where , Object attachedTo ) { return SQLHelper . getCursorFindAllWhere ( mDb , where . getClass ( ) , where , attachedTo , null , mDatabaseSpec ) ; } @ Override public Cursor findAll ( Class < ? > theClass , String where , String [ ] whereArgs ) { return mDb . query ( SQLHelper . getTableName ( theClass ) , null , where , whereArgs , null , null , null , null ) ; } @ Override public Cursor rawQuery ( String rawQuery ) { return mDb . rawQuery ( rawQuery , null ) ; } @ Override public Cursor findAll ( String table , String [ ] projection , String selection , String [ ] selectionArgs , String groupBy , String having , String sortOrder , String limit ) { return mDb . query ( table , projection , selection , selectionArgs , groupBy ,", "gt": "having , sortOrder , limit ) ;", "prediction": "having , sortOrder , limit ) ;\n", "label": 1}
{"id": 9317, "input": "<s> package org . meqantt ; public interface MqttListener { void disconnected ( ) ; void publishArrived", "gt": "( String topic , byte [ ] data ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13886, "input": "<s> package org . apache . lucene . analysis . tokenattributes ; import org . apache . lucene . util . Attribute ; public interface OffsetAttribute extends Attribute { public int startOffset ( ) ;", "gt": "public void setOffset ( int startOffset , int endOffset ) ;", "prediction": "public int endOffset ( ) ;\n", "label": 1}
{"id": 8419, "input": "<s> package org . parboiled . support ; import org . parboiled . common . Factory ; import org . parboiled . common . Reference ; import java . util . LinkedList ; import static org . parboiled . common . Preconditions . checkArgNotNull ; public class Var < T > extends Reference < T > { private Factory < T > initialValueFactory ; private LinkedList < T > stack ; private int level ; private String name ; public Var ( ) { this ( ( T ) null ) ; } public Var ( final T value ) { super ( value ) ; initialValueFactory = new Factory < T > ( ) { public T create ( ) { return value ; } } ; } public Var ( Factory < T > initialValueFactory ) { this . initialValueFactory = checkArgNotNull ( initialValueFactory , \"initialValueFactory\" ) ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public int getLevel ( ) { return level ; } public boolean enterFrame ( ) { if ( level ++ > 0 ) { if ( stack == null ) stack = new LinkedList < T > ( ) ; stack . add ( get ( ) ) ; } return set ( initialValueFactory . create ( ) ) ; } public boolean exitFrame ( ) { if", "gt": "( -- level > 0 )", "prediction": "( stack == null ) stack = new LinkedList < T > ( ) ;\n", "label": 0}
{"id": 13888, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . Vector ; public class TestElement implements Cloneable { TestModel fModel ; TestElement fContainer ; String fSomeName ; String fId ; Vector fChildren = new Vector ( ) ; boolean fIsDeleted = false ; public static final String P_SOMENAME = \"org.eclipse.jface.viewertest.name\" ; public static final String P_COLUMN_1 = \"org.eclipse.jface.viewertest.column1\" ; public TestElement ( TestModel model , TestElement container ) { fModel = model ; fContainer = container ; int p = 0 ; TestElement lastSibling = container . getLastChild ( ) ; if ( lastSibling != null ) { p = lastSibling . childId ( ) + 1 ; } fId = container . getID ( ) + \"-\" + p ; } public TestElement ( TestModel model , TestElement container , int level , int position ) { fModel = model ; fContainer = container ; if ( container != null ) fId = container . getID ( ) + \"-\" + position ; else fId = Integer . toString ( position ) ; fSomeName = \"name-\" + position ; if ( level < model . getNumLevels ( ) ) { for ( int i = 0 ; i < model . getNumChildren ( ) ; i ++ ) { fChildren . add ( new TestElement ( model , this , level + 1 , i ) ) ; } } } public TestElement addChild ( int event ) { TestElement element = new TestElement ( fModel , this ) ; element . fSomeName = \"added\" ; addChild ( element , new TestModelChange ( event , this , element ) ) ; return element ; } public TestElement addChild ( TestElement element , TestModelChange change ) { fChildren . add ( element ) ; fModel . fireModelChanged ( change ) ; return element ; } public void addChildren ( TestElement [ ] elements , TestModelChange change ) { for ( int i = 0 ; i < elements . length ; i ++ ) fChildren . add ( elements [ i ] ) ; fModel . fireModelChanged ( change ) ; } public TestElement [ ] addChildren ( int event ) { TestElement elements [ ] = new TestElement [ ] { new TestElement ( fModel , this ) , new TestElement ( fModel , this ) } ; elements [ 0 ] . fSomeName = \"added1\" ; elements [ 1 ] . fSomeName = \"added2\" ; elements [ 1 ] . fId += \"madeUnique\" ; addChildren ( elements , new TestModelChange ( event , this , elements ) ) ; return elements ; } public TestElement basicAddChild ( ) { TestElement element = new TestElement ( fModel , this ) ; element . fSomeName = \"added\" ; fChildren . add ( element ) ; return element ; } public void basicDeleteChild ( TestElement element ) { fChildren . remove ( element ) ; element . fIsDeleted = true ; } private int childId ( ) { String id = fId . substring ( fId . lastIndexOf ( \"-\" ) + 1 ) ; return Integer . parseInt ( id ) ; }", "gt": "public Object clone ( )", "prediction": "}\n", "label": 1}
{"id": 1628, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . common . Factory ;", "gt": "public abstract class BaseVarInit extends BaseGroupClass implements Factory", "prediction": "import org . parboiled . common . Map ;\n", "label": 0}
{"id": 13889, "input": "<s> package org . eclipse . swt . dnd ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . ImageData ; public class ImageTransfer extends ByteArrayTransfer { private static final String TYPE_NAME = \"image\" ; private static final int TYPE_ID = registerType ( TYPE_NAME ) ; private ImageTransfer ( ) { } public static ImageTransfer getInstance ( ) { return SingletonUtil . getSessionInstance ( ImageTransfer . class ) ; } public void javaToNative ( Object object , TransferData transferData ) { if ( ! checkImage ( object ) || ! isSupportedType ( transferData ) ) { DND . error ( DND . ERROR_INVALID_DATA ) ; } ImageData imageData = ( ImageData ) object ; if ( imageData == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; transferData . data = imageData ; transferData . result = 1 ; } public Object nativeToJava ( TransferData transferData ) { if ( ! isSupportedType ( transferData ) || transferData . data == null ) return null ; ImageData imageData = ( ImageData ) transferData . data ; Object result = imageData", "gt": ". clone ( ) ;", "prediction": ";\n", "label": 1}
{"id": 2733, "input": "<s> package com . sun . source . tree ; import java . util . List ; import javax . lang . model . element . Name ; public interface ClassTree extends StatementTree { ModifiersTree getModifiers ( ) ; Name getSimpleName ( ) ; List < ? extends TypeParameterTree > getTypeParameters ( ) ; Tree getExtendsClause ( ) ; List < ? extends Tree > getImplementsClause ( ) ; List < ? extends", "gt": "Tree > getMembers ( ) ;", "prediction": "Tree > getExtensions ( ) ;\n", "label": 0}
{"id": 13902, "input": "<s> package org . eclipse . ui ; import java . util . Map ; import org . eclipse . core . commands . util . Tracing ; import org . eclipse . ui . internal . misc . Policy ; import org . eclipse . ui . services . IServiceLocator ; public abstract class AbstractSourceProvider implements ISourceProvider { protected static boolean DEBUG = Policy . DEBUG_SOURCES ; private ISourceProviderListener [ ] listeners = new ISourceProviderListener [ 7 ] ; private int listenerCount = 0 ; public final void addSourceProviderListener ( final ISourceProviderListener listener ) { if ( listener == null ) { throw new NullPointerException ( \"The listener cannot be null\" ) ; } if ( listenerCount == listeners . length ) { final ISourceProviderListener [ ] growArray = new ISourceProviderListener [ listeners . length + 4 ] ; System . arraycopy ( listeners , 0 , growArray , 0 , listeners . length ) ; listeners = growArray ; } listeners [ listenerCount ++ ] = listener ; } protected final void fireSourceChanged ( final int sourcePriority , final String sourceName , final Object sourceValue ) { for ( int i = 0 ; i < listenerCount ; i ++ ) { final ISourceProviderListener listener = listeners [ i ] ; listener . sourceChanged ( sourcePriority , sourceName , sourceValue ) ; } } protected final", "gt": "void fireSourceChanged ( final int sourcePriority , final Map sourceValuesByName )", "prediction": "void removeSourceProviderListener ( final ISourceProviderListener listener )\n", "label": 1}
{"id": 8733, "input": "<s> package com . asakusafw . example . clob . jobflow ; import com . asakusafw . example . clob . modelgen . table . model . Document ; import com . asakusafw . vocabulary . bulkloader . DbImporterDescription ; public class DocumentFromDb extends DbImporterDescription { @ Override public Class < ? > getModelType ( ) { return Document . class ; } @ Override", "gt": "public String getTargetName ( )", "prediction": "public String getName ( )\n", "label": 0}
{"id": 13905, "input": "<s> package graphics . transitions ; import graphics . NES ; import java . awt . Color ; import java . awt . Graphics ; abstract public class HorizontalCurtain extends Transition { Color c = NES . BLACK ; int rHeight = 0 ; abstract public void updateHeight ( ) ; @ Override public void paint ( Graphics g ) { updateHeight ( ) ; g .", "gt": "drawImage ( buffer , 0 , 0 , null ) ;", "prediction": "paint ( g ) ;\n", "label": 1}
{"id": 1472, "input": "<s> package org . parboiled . examples . java ; import org . parboiled . BaseParser ; import org . parboiled . Rule ; import org . parboiled . annotations . * ; @ SuppressWarnings ( { \"InfiniteRecursion\" } ) @ BuildParseTree public class JavaParser extends BaseParser < Object > { public Rule CompilationUnit ( ) { return Sequence ( Spacing ( ) , Optional ( PackageDeclaration ( ) ) , ZeroOrMore ( ImportDeclaration ( ) ) , ZeroOrMore ( TypeDeclaration ( ) ) , EOI ) ; } Rule PackageDeclaration ( ) { return Sequence ( ZeroOrMore ( Annotation ( ) ) , Sequence ( PACKAGE , QualifiedIdentifier ( ) , SEMI ) ) ; } Rule ImportDeclaration ( ) { return Sequence ( IMPORT , Optional ( STATIC ) , QualifiedIdentifier ( ) , Optional ( DOT , STAR ) , SEMI ) ; } Rule TypeDeclaration ( ) { return FirstOf ( Sequence ( ZeroOrMore ( Modifier ( ) ) , FirstOf ( ClassDeclaration ( ) , EnumDeclaration ( ) , InterfaceDeclaration ( ) , AnnotationTypeDeclaration ( ) ) ) , SEMI ) ; } Rule ClassDeclaration ( ) { return Sequence ( CLASS , Identifier ( ) , Optional ( TypeParameters ( ) ) , Optional ( EXTENDS , ClassType ( ) ) , Optional ( IMPLEMENTS , ClassTypeList ( ) ) , ClassBody ( ) ) ; } Rule ClassBody ( ) { return Sequence ( LWING , ZeroOrMore ( ClassBodyDeclaration ( ) ) , RWING ) ; } Rule ClassBodyDeclaration ( ) { return FirstOf ( SEMI , Sequence ( Optional ( STATIC ) , Block ( ) ) , Sequence ( ZeroOrMore ( Modifier ( ) ) , MemberDecl ( ) ) ) ; } Rule MemberDecl ( ) { return FirstOf ( Sequence ( TypeParameters ( ) , GenericMethodOrConstructorRest ( ) ) , Sequence ( Type ( ) , Identifier ( ) , MethodDeclaratorRest ( ) ) , Sequence ( Type ( ) , VariableDeclarators ( ) , SEMI ) , Sequence ( VOID , Identifier ( ) , VoidMethodDeclaratorRest ( ) ) , Sequence ( Identifier ( ) , ConstructorDeclaratorRest ( ) ) , InterfaceDeclaration ( ) , ClassDeclaration ( ) , EnumDeclaration ( ) , AnnotationTypeDeclaration ( ) ) ; } Rule GenericMethodOrConstructorRest ( ) { return FirstOf ( Sequence ( FirstOf ( Type ( ) , VOID ) , Identifier ( ) , MethodDeclaratorRest ( ) ) , Sequence ( Identifier ( ) , ConstructorDeclaratorRest ( ) ) ) ; } Rule MethodDeclaratorRest ( ) { return Sequence ( FormalParameters ( ) , ZeroOrMore ( Dim ( ) ) , Optional ( THROWS , ClassTypeList ( ) ) , FirstOf ( MethodBody ( ) , SEMI ) ) ; } Rule VoidMethodDeclaratorRest ( ) { return Sequence ( FormalParameters ( ) , Optional ( THROWS , ClassTypeList ( ) ) , FirstOf ( MethodBody ( ) , SEMI ) ) ; } Rule ConstructorDeclaratorRest ( ) { return Sequence ( FormalParameters ( ) , Optional ( THROWS , ClassTypeList ( ) ) , MethodBody ( ) ) ; } Rule MethodBody ( ) { return Block ( ) ; } Rule InterfaceDeclaration ( ) { return Sequence ( INTERFACE , Identifier ( ) , Optional ( TypeParameters ( ) ) , Optional ( EXTENDS , ClassTypeList ( ) ) , InterfaceBody ( ) ) ; } Rule InterfaceBody ( ) { return Sequence ( LWING , ZeroOrMore ( InterfaceBodyDeclaration ( ) ) , RWING ) ; } Rule InterfaceBodyDeclaration ( ) { return FirstOf ( Sequence ( ZeroOrMore ( Modifier ( ) ) , InterfaceMemberDecl ( ) ) , SEMI ) ; } Rule InterfaceMemberDecl ( ) { return FirstOf ( InterfaceMethodOrFieldDecl ( ) , InterfaceGenericMethodDecl ( ) , Sequence ( VOID , Identifier ( ) , VoidInterfaceMethodDeclaratorsRest ( ) ) , InterfaceDeclaration ( ) , AnnotationTypeDeclaration ( ) , ClassDeclaration ( ) , EnumDeclaration ( ) ) ; } Rule InterfaceMethodOrFieldDecl ( ) { return Sequence ( Sequence ( Type ( ) , Identifier ( ) ) , InterfaceMethodOrFieldRest ( ) ) ; } Rule InterfaceMethodOrFieldRest ( ) { return FirstOf ( Sequence ( ConstantDeclaratorsRest ( ) , SEMI ) , InterfaceMethodDeclaratorRest ( ) ) ; } Rule InterfaceMethodDeclaratorRest ( ) { return Sequence ( FormalParameters ( ) , ZeroOrMore ( Dim ( ) ) , Optional ( THROWS , ClassTypeList ( ) ) , SEMI ) ; } Rule InterfaceGenericMethodDecl ( ) { return Sequence ( TypeParameters ( ) , FirstOf ( Type ( ) , VOID ) , Identifier ( ) , InterfaceMethodDeclaratorRest ( ) ) ; } Rule VoidInterfaceMethodDeclaratorsRest ( ) { return Sequence ( FormalParameters ( ) , Optional ( THROWS , ClassTypeList ( ) ) , SEMI ) ; } Rule ConstantDeclaratorsRest ( ) { return Sequence ( ConstantDeclaratorRest ( ) , ZeroOrMore ( COMMA", "gt": ", ConstantDeclarator ( ) ) ) ;", "prediction": ", ClassDeclaratorRest ( ) ) , SEMI ) ;\n", "label": 0}
{"id": 13911, "input": "<s> package org . eclipse . ui . tests . internal ; import org . eclipse . ui . internal . util . Util ; import junit . framework . TestCase ; public class UtilTest extends TestCase { public UtilTest ( String name ) { super ( name ) ; } public void testBasicSplit ( ) { final String field = \"field1\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( field , result [ 0 ] ) ; } public void testBasic2Split ( ) { final String field = \"field1,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( \"field2\" , result [ 1 ] ) ; } public void testBasic3Split ( ) { final String field = \"field1,field3,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 3 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( \"field3\" , result [ 1 ] ) ; assertEquals ( \"field2\" , result [ 2 ] ) ; } public void testNothingSplit ( ) { final String field = \"\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( 0 , result [ 0 ] . length ( ) ) ; } public void testNothingUsefulSplit ( ) { final String field = \",\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 0 , result . length ) ; } public void testNothingUseful2Split ( ) { final String field = \",,\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 0 , result . length ) ; } public void testNothingUsefulSpaceSplit ( ) { final String field = \" ,\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 1 , result . length ) ; assertEquals ( \" \" , result [ 0 ] ) ; } public void testNothingUsefulSpaceSplit2 ( ) { final String field = \", \" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( 0 , result [ 0 ] . length ( ) ) ; assertEquals ( \" \" , result [ 1 ] ) ; } public void testNothingUsefulSpaceSplit3 ( ) { final String field = \" , \" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 2 , result . length ) ; assertEquals ( \" \" , result [ 0 ] ) ; assertEquals ( \" \" , result [ 1 ] ) ; } public void test2Delimiters ( ) { final String field = \"field1,,field3,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 4 , result . length ) ; assertEquals ( \"field1\" , result [ 0 ] ) ; assertEquals ( 0 , result [ 1 ] . length ( ) ) ; assertEquals ( \"field3\" , result [ 2 ] ) ; assertEquals ( \"field2\" , result [ 3 ] ) ; } public void test3Delimiters ( ) { final String field = \"field1,,,field3,field2\" ; String [ ] result = Util . split ( field , ',' ) ; assertEquals ( 5 , result . length ) ; assertEquals", "gt": "( \"field1\" , result [ 0 ] ) ;", "prediction": "( \"field1\" , result [ 0 ] ) ;\n", "label": 1}
{"id": 2842, "input": "<s> package com . redhat . ceylon . compiler . java . loader . mirror ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeParameterMirror ; import com . sun . tools . javac . code . Attribute . Compound ; import com . sun . tools . javac . code . Symbol ; import com . sun . tools . javac . code . Symbol . TypeSymbol ; public class JavacUtil { public static Map < String , AnnotationMirror > getAnnotations ( Symbol symbol ) { HashMap < String , AnnotationMirror > result = new HashMap < String , AnnotationMirror > ( ) ; com . sun . tools . javac . util . List < Compound > annotations = symbol . getAnnotationMirrors ( ) ; for ( Compound annotation : annotations ) { result . put ( annotation . type . tsym . getQualifiedName ( ) . toString ( ) , new JavacAnnotation ( annotation ) ) ; } return result ; } public static", "gt": "List < TypeParameterMirror > getTypeParameters ( Symbol symbol )", "prediction": "Map < String , AnnotationMirror > getAnnotations ( Symbol symbol )\n", "label": 0}
{"id": 13921, "input": "<s> package io . beancounter . listener . facebook ; import org . apache . camel . EndpointInject ; import org . apache . camel . component . mock . MockEndpoint ; import org . apache . camel . testng . CamelTestSupport ; public class RoutingTest extends CamelTestSupport { @", "gt": "EndpointInject ( uri = \"mock:getEndpoint\" ) private MockEndpoint getEndpoint ;", "prediction": "Override public void testRouting ( ) throws Exception\n", "label": 1}
{"id": 379, "input": "<s> import java . util . * ; public class T5070671 { void foo1 ( ) { Comparator < int [ ] > c = new Comparator < int [ ] > ( ) { public int compare ( int [ ] c1 , int [ ] c2 ) { return 0 ; } } ; int [ ] [ ] arr = { { 1 } } ; int [ ] elem = arr [ 0 ] ; Arrays . sort ( arr , c ) ; Arrays . binarySearch ( arr , elem , c ) ; Arrays . < int [ ] > binarySearch ( arr , elem , c ) ; } void foo2 ( ) { Comparator < Integer [ ] > c = new Comparator < Integer [ ] > ( ) { public int compare ( Integer [ ] c1 , Integer [ ] c2 ) { return 0 ; } } ; Integer [ ] [ ] arr = { { 1 } } ; Integer", "gt": "[ ] elem = arr [ 0 ] ;", "prediction": "[ ] elem = c [ 0 ] ;\n", "label": 0}
{"id": 13927, "input": "<s> package org . nuxeo . ecm . platform . io . test ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . io . DocumentTranslationMap ; import org . nuxeo . ecm . platform . io . api . IOResourceAdapter ; import org . nuxeo . ecm . platform . io . api . IOResources ; public class DummyIOResourceAdapter implements IOResourceAdapter { private static final long serialVersionUID = 5411716618665857482L ; private static final Log log = LogFactory . getLog ( DummyIOResourceAdapter . class ) ; public static final Map < String , String > backend = new HashMap < String , String > ( ) ; private Map < String , Serializable > properties ; public IOResources extractResources ( String repo , Collection < DocumentRef > sources ) { Map < String , String > extracted = new HashMap < String , String > ( ) ; for ( DocumentRef ref : sources ) { String key = ref . toString ( ) ; if ( backend . containsKey ( key ) ) { extracted . put ( key , backend . get ( key ) ) ; } } return new DummyIOResources ( extracted ) ; } public IOResources translateResources ( String repo , IOResources resources , DocumentTranslationMap map ) { if ( ! ( resources instanceof DummyIOResources ) ) { return null ; } Map < String , String > givenResources = ( ( DummyIOResources ) resources ) . getResources ( ) ; Map < String , String > translated = new HashMap < String , String > ( ) ; for ( Map . Entry < DocumentRef , DocumentRef > cor : map . getDocRefMap ( ) . entrySet ( ) ) { String oldKey = cor . getKey ( ) . toString ( ) ; if ( givenResources . containsKey ( oldKey ) ) { String newKey = cor . getValue ( ) . toString ( ) ; translated . put ( newKey , givenResources . get ( oldKey ) ) ; } } return new DummyIOResources ( translated ) ; } public void getResourcesAsXML ( OutputStream out , IOResources resources ) { if ( ! ( resources instanceof DummyIOResources ) ) { return ; } Map < String , String > givenResources = ( ( DummyIOResources ) resources ) . getResources ( ) ; try { out . write ( \"<?xml version=\\\"1.0\\\">\\n\" . getBytes ( ) ) ; for ( Map . Entry < String , String > entry : givenResources . entrySet ( ) ) { String xml = String . format ( \"<dummy for=\\\"%s\\\">%s</dummy>\\n\" , entry . getKey ( ) , entry . getValue ( ) ) ; out . write ( xml . getBytes ( ) ) ; } out . close ( ) ; } catch ( IOException e ) { } } public IOResources loadResourcesFromXML ( InputStream stream ) { Map < String , String > resources = new HashMap < String , String > ( ) ; BufferedReader reader = null ; Pattern pattern = Pattern . compile ( \"<dummy for=\\\"([a-zA-Z_0-9\\\\-]+)\\\">([a-zA-Z_0-9\\\\-]+)</dummy>\" ) ; try { reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { Matcher m = pattern . matcher ( line ) ; if ( m . matches ( ) ) { resources . put ( m . group ( 1 ) , m . group ( 2 ) ) ; } } } catch ( IOException e ) { log . error ( e ) ; } return new DummyIOResources ( resources ) ; } public void storeResources ( IOResources resources ) { if ( ! ( resources instanceof DummyIOResources ) ) { return ; } Map < String , String > givenResources = ( ( DummyIOResources ) resources ) . getResources ( ) ; for ( Map . Entry < String , String > entry : givenResources . entrySet ( ) ) { backend . put ( entry . getKey ( ) , entry .", "gt": "getValue ( ) ) ;", "prediction": "getValue ( ) ) ;\n", "label": 1}
{"id": 7128, "input": "<s> package api . comments ; public class Userinfo { private boolean artist ; private Number authorId ; private String authorName ; private String avatar ; private boolean donor ; private boolean enabled ; private String userTitle ; private boolean warned ; public boolean isArtist ( ) { return this . artist ; } public Number getAuthorId ( ) { return this . authorId ; } public String getAuthorName ( ) { return this . authorName ; } public String getAvatar ( ) { return this . avatar ; } public boolean isDonor ( ) { return this . donor ; } public boolean isEnabled ( ) {", "gt": "return this . enabled ;", "prediction": "return this . enabled ;\n", "label": 0}
{"id": 13948, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import java . io . Serializable ; public class MailRepresentation implements Serializable { private static final long serialVersionUID = 1L ; private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public void setContent ( String content ) { this . content = content ; }", "gt": "public void setStatus ( String status )", "prediction": "public void setSubject ( String subject )\n", "label": 1}
{"id": 8515, "input": "<s> package org . ofbiz . base . util . test ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . lang . management . MemoryType ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . sql . Time ; import java . text . SimpleDateFormat ; import java . util . Arrays ; import java . util . Locale ; import java . util . TimeZone ; import java . util . UUID ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; import org . ofbiz . base . util . UtilIO ; import org . ofbiz . base . util . UtilMisc ; @ SourceMonitored public class UtilIOTests extends GenericTestCaseBase { private static final byte [ ] trademarkBytes = new byte [ ] { ( byte ) 0xE2 , ( byte ) 0x84 , ( byte ) 0xA2 } ; public UtilIOTests ( String name ) { super ( name ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; } @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; } public void testReadString ( ) throws Exception { readStringTest_0 ( \"unix line ending\" , \"\\n\" , new byte [ ] { 0x0A } ) ; readStringTest_0 ( \"mac line ending\" , \"\\r\" , new byte [ ] { 0x0D } ) ; readStringTest_0 ( \"windows line ending\" , \"\\r\\n\" , new byte [ ] { 0x0D , 0x0A } ) ; } private static byte [ ] join ( byte [ ] ... parts ) { int count = 0 ; for ( byte [ ] part : parts ) { count += part . length ; } byte [ ] result = new byte [ count ] ; int i = 0 ; for ( byte [ ] part : parts ) { System . arraycopy ( part , 0 , result , i , part . length ) ; i += part . length ; } return result ; } private static void readStringTest_0 ( String label , String lineSeparator , byte [ ] extra ) throws IOException { String originalLineSeparator = System . getProperty ( \"line.separator\" ) ; try { System . getProperties ( ) . put ( \"line.separator\" , lineSeparator ) ; readStringTest_1 ( label + \":mark\" , \"\u2122\" , join ( trademarkBytes ) ) ; readStringTest_1 ( label + \":mark NL\" , \"\u2122\\n\" , join ( trademarkBytes , extra ) ) ; readStringTest_1 ( label + \":NL mark\" , \"\\n\u2122\" , join ( extra , trademarkBytes ) ) ; } finally { System . getProperties ( ) . put ( \"line.separator\" , originalLineSeparator ) ; } } private static void readStringTest_1 ( String label , String wanted , byte [ ] toRead ) throws IOException { assertEquals ( \"readString bytes default:\" + label , wanted ,", "gt": "UtilIO . readString ( toRead ) ) ;", "prediction": "toRead ) ;\n", "label": 0}
{"id": 13963, "input": "<s> package org . apache . sqoop . hbase ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . hbase . client . Put ; import org . apache . hadoop . hbase . util . Bytes ; import com . cloudera . sqoop . hbase . PutTransformer ; public class ToStringPutTransformer extends PutTransformer { public static final Log LOG = LogFactory . getLog ( ToStringPutTransformer . class . getName ( ) ) ; private Map < String , byte [ ] > serializedFieldNames ; public ToStringPutTransformer ( ) { serializedFieldNames = new TreeMap < String , byte [ ] > ( ) ; } private byte [ ] getFieldNameBytes ( String fieldName ) { byte [ ] cachedName = serializedFieldNames . get ( fieldName ) ; if ( null != cachedName ) { return cachedName ; } byte [ ] nameBytes = Bytes . toBytes ( fieldName ) ; serializedFieldNames . put ( fieldName , nameBytes ) ; return nameBytes ; } @ Override public List < Put > getPutCommand ( Map < String , Object > fields ) throws IOException { String rowKeyCol = getRowKeyColumn ( ) ; String colFamily = getColumnFamily ( ) ; byte [ ] colFamilyBytes = Bytes . toBytes ( colFamily ) ; Object rowKey = fields . get ( rowKeyCol ) ; if ( null == rowKey ) { LOG . warn ( \"Could not insert row with null value for row-key column: \" + rowKeyCol ) ; return null ; } Put put = new Put ( Bytes . toBytes ( rowKey . toString ( ) ) ) ; for ( Map . Entry < String , Object > fieldEntry : fields . entrySet ( ) ) { String colName = fieldEntry . getKey ( ) ; if ( ! colName . equals ( rowKeyCol ) ) { Object val = fieldEntry . getValue ( ) ; if ( null != val ) { put . add ( colFamilyBytes , getFieldNameBytes ( colName ) , Bytes . toBytes ( val .", "gt": "toString ( ) ) ) ;", "prediction": "toString ( ) ) ) ;\n", "label": 1}
{"id": 2275, "input": "<s> import gui . LoginFrame ; import java . awt . EventQueue ; import java . awt . Toolkit ; public class Main { public static void main ( final String [ ] args ) { EventQueue queue = Toolkit . getDefaultToolkit ( ) . getSystemEventQueue ( ) ; queue . push ( new EventQueueProxy ( ) ) ; LoginFrame", "gt": "loginFrame = new LoginFrame ( ) ;", "prediction": "loginFrame = new LoginFrame ( ) ;\n", "label": 0}
{"id": 13965, "input": "<s> package br . org . archimedes . io . pdf ; import br . org . archimedes . model . Point ; import com . lowagie . text . Rectangle ; import com . lowagie . text . pdf . PdfContentByte ; public class PDFWriterHelper { private PdfContentByte cb ; private Rectangle documentArea ; private Point viewport ; private double zoom ; public PDFWriterHelper ( PdfContentByte cb , Rectangle documentArea ) { this . documentArea = documentArea ; this . cb = cb ; } public br . org . archimedes . model . Rectangle getModelArea ( ) { double x1 = - documentArea . getWidth ( ) / ( 2 * zoom ) ; double x2 = - x1 ; x1 += viewport . getX ( ) ; x2 += viewport . getX ( ) ; double y1 = documentArea . getHeight ( ) / ( 2 * zoom ) ; double y2 = - y1 ; y1 += viewport . getY ( ) ; y2 += viewport . getY ( ) ; return new br . org . archimedes . model . Rectangle ( x1 , y1 , x2 , y2 ) ; } public Point modelToDocument ( Point modelPoint ) { double x = modelPoint . getX ( ) - viewport . getX ( ) ; x *= zoom ; x += ( documentArea . getWidth ( ) / 2 ) ; double y = modelPoint . getY ( ) - viewport . getY ( ) ; y *= zoom ; y += ( documentArea .", "gt": "getHeight ( ) / 2 ) ;", "prediction": "getHeight ( ) / 2 ) ;\n", "label": 1}
{"id": 10035, "input": "<s> public class T6450290 { static class Box < X extends Box < ? , ? > , T extends X > { T value ; Box < X , T > same ; } static class A extends Box < A , A > { } static class B extends Box < B , B > { } public static void main ( String [ ] args ) { Box < ? , ? > b = new Box < Box < A , A > , Box < A , A > > ( ) ; b . value . same = new", "gt": "Box < B , B > ( ) ;", "prediction": "Box < A , A > ( ) ;\n", "label": 0}
{"id": 13982, "input": "<s> package org . agoncal . book . javaee7 . chapter22 ; import javax . enterprise . inject . Produces ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; public class DatabaseProducer { @ Produces @ PersistenceContext", "gt": "( unitName = \"chapter22PU\" ) private EntityManager em ;", "prediction": "public EntityManager getEntityManager ( )\n", "label": 1}
{"id": 80, "input": "<s> package org . gk . engine . client . build ; import java . util . List ; import org . gk . engine . client . gen . UIGen ; import com . google . gwt . xml . client . Node ; import com . google .", "gt": "gwt . xml . client . NodeList ;", "prediction": "gwt . xml . client . NodeType ;\n", "label": 0}
{"id": 13985, "input": "<s> package org . eclipse . ui . internal . services ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import org . eclipse . ui . AbstractSourceProvider ; import org . eclipse . ui . ISourceProvider ; import org . eclipse . ui . services . IDisposable ; import org . eclipse . ui . services . IServiceLocator ; import org . eclipse . ui . services . ISourceProviderService ; public final class SourceProviderService implements ISourceProviderService , IDisposable { private final Map sourceProvidersByName = new HashMap ( ) ; private final Set sourceProviders = new HashSet ( ) ; private IServiceLocator locator ; public SourceProviderService ( final IServiceLocator locator ) { this . locator = locator ; } public final void dispose ( ) { final Iterator sourceProviderItr = sourceProviders . iterator ( ) ; while ( sourceProviderItr . hasNext ( ) ) { final ISourceProvider sourceProvider = ( ISourceProvider ) sourceProviderItr . next ( ) ; sourceProvider . dispose ( ) ; } sourceProviders . clear ( ) ; sourceProvidersByName . clear ( ) ; } public final ISourceProvider getSourceProvider ( final String sourceName ) { return ( ISourceProvider ) sourceProvidersByName . get ( sourceName ) ; } public final ISourceProvider [ ] getSourceProviders ( ) { return ( ISourceProvider [ ] ) sourceProviders . toArray ( new ISourceProvider [ sourceProviders . size ( ) ] ) ; } public final void registerProvider", "gt": "( final ISourceProvider sourceProvider )", "prediction": "( ISourceProvider provider )\n", "label": 1}
{"id": 4102, "input": "<s> package com . sun . tools . doclets . formats . html ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . internal . toolkit . builders . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class AnnotationTypeWriterImpl extends SubWriterHolderWriter implements AnnotationTypeWriter { protected AnnotationTypeDoc annotationType ; protected Type prev ; protected Type next ; public AnnotationTypeWriterImpl ( AnnotationTypeDoc annotationType , Type prevType , Type nextType ) throws Exception { super ( ConfigurationImpl . getInstance ( ) , DirectoryManager . getDirectoryPath ( annotationType . containingPackage ( ) ) , annotationType . name ( ) + \".html\" , DirectoryManager . getRelativePath ( annotationType . containingPackage ( ) . name ( ) ) ) ; this . annotationType = annotationType ; configuration . currentcd = annotationType . asClassDoc ( ) ; this . prev = prevType ; this . next = nextType ; } protected Content getNavLinkPackage ( ) { Content linkContent = getHyperLink ( \"package-summary.html\" , \"\" , packageLabel ) ; Content li = HtmlTree . LI ( linkContent ) ; return li ; } protected Content getNavLinkClass ( ) { Content li = HtmlTree . LI ( HtmlStyle . navBarCell1Rev , classLabel ) ; return li ; } protected Content getNavLinkClassUse ( ) { Content linkContent = getHyperLink ( \"class-use/\" + filename , \"\" , useLabel ) ; Content li = HtmlTree . LI ( linkContent ) ; return li ; } public Content getNavLinkPrevious ( ) { Content li ; if ( prev != null ) { Content prevLink = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS , prev . asClassDoc ( ) , \"\" , configuration . getText ( \"doclet.Prev_Class\" ) , true ) ) ) ; li = HtmlTree . LI ( prevLink ) ; } else li = HtmlTree . LI ( prevclassLabel ) ; return li ; } public Content getNavLinkNext ( ) { Content li ; if ( next != null ) { Content nextLink = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS , next . asClassDoc ( ) , \"\" , configuration . getText ( \"doclet.Next_Class\" ) , true ) ) ) ; li = HtmlTree . LI ( nextLink ) ; } else li = HtmlTree . LI ( nextclassLabel ) ; return li ; } public Content getHeader ( String header ) { String pkgname = ( annotationType . containingPackage ( ) != null ) ? annotationType . containingPackage ( ) . name ( ) : \"\" ; String clname = annotationType . name ( ) ; Content bodyTree = getBody ( true , getWindowTitle ( clname ) ) ; addTop ( bodyTree ) ; addNavLinks ( true , bodyTree ) ; bodyTree . addContent ( HtmlConstants . START_OF_CLASS_DATA ) ; HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . header ) ; if ( pkgname . length ( ) > 0 ) { Content pkgNameContent = new StringContent ( pkgname ) ; Content pkgNameDiv = HtmlTree . DIV ( HtmlStyle . subTitle , pkgNameContent ) ; div . addContent ( pkgNameDiv ) ; } LinkInfoImpl linkInfo = new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS_HEADER , annotationType , false ) ; Content headerContent = new StringContent ( header ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . CLASS_PAGE_HEADING , true , HtmlStyle . title , headerContent ) ; heading . addContent ( new RawHtml ( getTypeParameterLinks ( linkInfo ) ) ) ; div . addContent ( heading ) ; bodyTree . addContent ( div ) ; return bodyTree ; } public Content getAnnotationContentHeader ( ) { return getContentHeader ( ) ; } public void addFooter ( Content contentTree ) { contentTree . addContent ( HtmlConstants . END_OF_CLASS_DATA ) ; addNavLinks ( false , contentTree ) ; addBottom ( contentTree ) ; } public void printDocument ( Content contentTree ) { printHtmlDocument ( configuration . metakeywords . getMetaKeywords ( annotationType ) , true , contentTree ) ; } public Content getAnnotationInfoTreeHeader ( ) { return getMemberTreeHeader ( ) ; } public Content getAnnotationInfo ( Content annotationInfoTree ) { return getMemberTree ( HtmlStyle . description , annotationInfoTree ) ; } public void addAnnotationTypeSignature ( String modifiers , Content annotationInfoTree ) { annotationInfoTree . addContent ( new HtmlTree ( HtmlTag . BR ) ) ; Content pre = new HtmlTree ( HtmlTag . PRE ) ; addAnnotationInfo ( annotationType , pre ) ; pre . addContent ( modifiers ) ; LinkInfoImpl linkInfo = new LinkInfoImpl ( LinkInfoImpl . CONTEXT_CLASS_SIGNATURE , annotationType , false ) ; Content annotationName = new StringContent ( annotationType . name ( ) ) ; Content parameterLinks = new RawHtml ( getTypeParameterLinks ( linkInfo ) ) ; if ( configuration ( ) . linksource ) { addSrcLink ( annotationType , annotationName , pre ) ; pre . addContent ( parameterLinks ) ; } else { Content span = HtmlTree . SPAN ( HtmlStyle . strong , annotationName ) ; span . addContent ( parameterLinks ) ; pre . addContent ( span ) ; } annotationInfoTree . addContent ( pre ) ; } public void addAnnotationTypeDescription ( Content annotationInfoTree ) { if ( ! configuration . nocomment ) { if ( annotationType . inlineTags ( ) . length > 0 ) { addInlineComment ( annotationType , annotationInfoTree ) ; } } } public void addAnnotationTypeTagInfo ( Content annotationInfoTree ) { if ( ! configuration . nocomment ) { addTagsInfo ( annotationType , annotationInfoTree ) ; } } public void addAnnotationTypeDeprecationInfo ( Content annotationInfoTree ) { Content hr = new HtmlTree ( HtmlTag . HR ) ; annotationInfoTree . addContent ( hr ) ; Tag [ ] deprs = annotationType . tags ( \"deprecated\" ) ; if ( Util . isDeprecated ( annotationType ) ) { Content strong = HtmlTree . STRONG ( deprecatedPhrase ) ; Content div = HtmlTree . DIV ( HtmlStyle . block , strong ) ; if ( deprs . length > 0 ) { Tag [ ] commentTags = deprs [ 0 ] . inlineTags ( ) ; if ( commentTags . length > 0 ) { div . addContent ( getSpace ( ) ) ; addInlineDeprecatedComment ( annotationType , deprs", "gt": "[ 0 ] , div ) ;", "prediction": "[ 0 ] . inlineTags ( ) ) ;\n", "label": 0}
{"id": 13988, "input": "<s> package org . eclipse . rap . demo . databinding . nestedselection ; import java . util . * ; public class SimplePerson extends ModelObject { private String name = \"\" ; private String address = \"\" ; private String city = \"\" ; private String state = \"\" ; private final List orders = new LinkedList ( ) ; public SimplePerson ( final String name , final String address , final String city , final String state ) { this . name = name ; this . address = address ; this . city = city ; this . state = state ; int numOrders = ( int ) ( Math . random ( ) * 5 ) ; for ( int i = 0 ; i < numOrders ; ++ i ) { orders . add ( new SimpleOrder ( i , new Date ( ) ) ) ; } } public SimplePerson ( ) { } public String getAddress ( ) { return address ; } public void setAddress ( final String address ) { String old = this . address ; this . address = address ; firePropertyChange ( \"address\" , old , address ) ; } public String getCity ( ) { return city ; } public void setCity ( final String city ) { String old = this . city ; firePropertyChange ( \"city\" , old , this . city = city ) ; } public String getName ( ) { return name ; } public void setName ( final String name ) { firePropertyChange ( \"name\" , this .", "gt": "name , this . name = name ) ;", "prediction": "name , name ) ;\n", "label": 1}
{"id": 9083, "input": "<s> package com . asakusafw . example . jdbc . jobflow ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . CategorySummary ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ErrorRecord ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . ItemInfo ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . SalesDetail ; import com . asakusafw . example . jdbc . modelgen . dmdl . model . StoreInfo ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . CheckStore ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . JoinItemInfo ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . SetErrorMessage ; import com . asakusafw . example . jdbc . operator . CategorySummaryOperatorFactory . SummarizeByCategory ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; @ JobFlow ( name = \"byCategory\" ) public class CategorySummaryJob extends FlowDescription { final In < SalesDetail > salesDetail ; final In < StoreInfo > storeInfo ; final In < ItemInfo > itemInfo ; final Out < CategorySummary > categorySummary ; final Out < ErrorRecord > errorRecord ; public CategorySummaryJob ( @ Import ( name = \"salesDetail\" , description = SalesDetailFromJdbc . class ) In < SalesDetail > salesDetail , @ Import ( name = \"storeInfo\" , description = StoreInfoFromJdbc . class ) In < StoreInfo > storeInfo , @ Import ( name = \"itemInfo\" , description = ItemInfoFromJdbc . class ) In < ItemInfo > itemInfo , @ Export ( name = \"categorySummary\" , description = CategorySummaryToJdbc . class ) Out < CategorySummary > categorySummary , @ Export ( name = \"errorRecord\" , description = ErrorRecordToJdbc . class ) Out < ErrorRecord > errorRecord ) { this . salesDetail = salesDetail ; this . storeInfo = storeInfo ; this . itemInfo = itemInfo ; this . categorySummary = categorySummary ; this . errorRecord = errorRecord ; } @ Override protected void describe ( ) { CoreOperatorFactory core =", "gt": "new CoreOperatorFactory ( ) ;", "prediction": "new CoreOperatorFactory ( ) ;\n", "label": 0}
{"id": 13998, "input": "<s> package org . jscsi . target . scsi . cdb ; import java . nio . ByteBuffer ; import org . jscsi . parser . scsi . SCSICommandParser ; import org . jscsi . target . scsi . sense . AdditionalSenseCodeAndQualifier ; import org . jscsi . target . scsi . sense . SenseData ; import org . jscsi . target . scsi . sense . SenseKey ; import org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific . FieldPointerSenseKeySpecificData ; import org . jscsi . target . util . BitManip ; public abstract class CommandDescriptorBlock { private FieldPointerSenseKeySpecificData [ ] illegalFieldPointers = null ; private ScsiOperationCode scsiOperationCode ; private boolean normalAutoContingentAllegiance ; public CommandDescriptorBlock ( ByteBuffer buffer ) { scsiOperationCode = ScsiOperationCode . valueOf ( buffer . get ( 0 ) ) ; if ( scsiOperationCode == null ) addIllegalFieldPointer ( 0 ) ; final CdbType cdbType = scsiOperationCode . getCdbType ( ) ; int controlByteIndex ; switch ( cdbType ) { case SIX_BYTE_COMMANDS : controlByteIndex = 5 ; break ; case TEN_BYTE_COMMANDS : controlByteIndex = 9 ; break ; case TWELVE_BYTE_COMMANDS : controlByteIndex = 11 ; break ; case SIXTEEN_BYTE_COMMANDS : controlByteIndex = 15 ; break ; default : controlByteIndex = - 1 ; } normalAutoContingentAllegiance = BitManip . getBit ( buffer . get ( controlByteIndex ) , 2 ) ; if ( normalAutoContingentAllegiance ) { addIllegalFieldPointer ( controlByteIndex , 2 ) ; } } public final ScsiOperationCode getScsiOperationCode ( ) { return scsiOperationCode ; } public final boolean isNormalACA ( ) { return normalAutoContingentAllegiance ; } protected final void addIllegalFieldPointer ( int byteNumber ) { final FieldPointerSenseKeySpecificData fp = new FieldPointerSenseKeySpecificData ( true , true ,", "gt": "false , 0 , byteNumber ) ;", "prediction": "false ) ;\n", "label": 1}
{"id": 7244, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class Signature_attribute extends Attribute { Signature_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; signature_index = cr . readUnsignedShort ( ) ; } public Signature_attribute ( ConstantPool constant_pool , int signature_index ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . Signature ) , signature_index ) ; } public Signature_attribute ( int name_index , int signature_index ) { super ( name_index , 2 ) ; this . signature_index = signature_index ; } public String getSignature ( ConstantPool constant_pool ) throws ConstantPoolException { return constant_pool . getUTF8Value ( signature_index ) ; } public Signature getParsedSignature ( ) { return new Signature ( signature_index ) ; } public < R , D > R accept ( Visitor < R , D > visitor , D data ) { return visitor", "gt": ". visitSignature ( this , data ) ;", "prediction": ";\n", "label": 0}
{"id": 14004, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor . actions ; public interface IVelocityActionDefinitionIds { public static final String GOTO_DEFINITION = \"com.googlecode.veloeclipse.vaulttec.ui.edit.goto.definition\" ; public static final String TOGGLE_COMMENT = \"com.googlecode.veloeclipse.vaulttec.ui.edit.toggle.comment\" ; public static", "gt": "final String JTIDY = \"com.googlecode.veloeclipse.vaulttec.ui.edit.jtidy\" ;", "prediction": "final String TOGGLE_TEXT = \"com.googlecode.veloeclipse.vaulttec.ui.edit.toggle.text\" ;\n", "label": 1}
{"id": 8593, "input": "<s> package org . ofbiz . webtools . artifactinfo ; import java . net . MalformedURLException ; import java . net . URL ; public abstract class ArtifactInfoBase implements Comparable < ArtifactInfoBase > { protected ArtifactInfoFactory aif ; private String fullName = null ; public ArtifactInfoBase ( ArtifactInfoFactory aif ) { this . aif = aif ; } public int compareTo ( ArtifactInfoBase that ) { if ( that == null ) { return - 1 ; } return this . toString ( ) . compareTo ( that . toString ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } try { ArtifactInfoBase that = ( ArtifactInfoBase ) obj ; return this . toString ( ) . equals ( that . toString ( ) ) ; } catch ( Exception e ) { return false ; } } abstract public String getDisplayName ( ) ; abstract public String getDisplayType ( ) ; abstract public URL getLocationURL ( ) throws MalformedURLException ; abstract public String getType ( ) ; abstract public", "gt": "String getUniqueId ( ) ;", "prediction": "boolean equals ( Object obj )\n", "label": 0}
{"id": 14008, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . MapFieldSelector ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . vectorhighlight . FieldFragList . WeightedFragInfo ; import org . apache . lucene . search . vectorhighlight . FieldFragList . WeightedFragInfo . SubInfo ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo . Toffs ; public abstract class BaseFragmentsBuilder implements FragmentsBuilder { protected String [ ] preTags , postTags ; public static final String [ ] COLORED_PRE_TAGS = { \"<b style=\\\"background:yellow\\\">\" , \"<b style=\\\"background:lawngreen\\\">\" , \"<b style=\\\"background:aquamarine\\\">\" , \"<b style=\\\"background:magenta\\\">\" , \"<b style=\\\"background:palegreen\\\">\" , \"<b style=\\\"background:coral\\\">\" , \"<b style=\\\"background:wheat\\\">\" , \"<b style=\\\"background:khaki\\\">\" , \"<b style=\\\"background:lime\\\">\" , \"<b style=\\\"background:deepskyblue\\\">\" } ; public static final String [ ] COLORED_POST_TAGS = { \"</b>\" } ; protected BaseFragmentsBuilder ( ) { this ( new String [ ] { \"<b>\" } , new String [ ] { \"</b>\" } ) ; } protected BaseFragmentsBuilder ( String [ ] preTags , String [ ] postTags ) { this . preTags = preTags ; this . postTags = postTags ; } static Object checkTagsArgument ( Object tags ) { if ( tags instanceof String ) return tags ; else if ( tags instanceof String [ ] ) return tags ; throw new IllegalArgumentException ( \"type of preTags/postTags must be a String or String[]\" ) ; } public abstract List < WeightedFragInfo > getWeightedFragInfoList ( List < WeightedFragInfo > src ) ; public String createFragment ( IndexReader reader , int docId , String fieldName , FieldFragList fieldFragList ) throws IOException { String [ ] fragments = createFragments ( reader , docId , fieldName , fieldFragList , 1 ) ; if ( fragments == null || fragments . length == 0 ) return null ; return fragments [ 0 ] ; } public String [ ] createFragments ( IndexReader reader , int docId , String fieldName , FieldFragList fieldFragList , int maxNumFragments ) throws IOException { if ( maxNumFragments < 0 ) throw new IllegalArgumentException ( \"maxNumFragments(\" + maxNumFragments + \") must be positive number.\" ) ; List < WeightedFragInfo > fragInfos = getWeightedFragInfoList ( fieldFragList . fragInfos ) ; List < String > fragments = new ArrayList < String > ( maxNumFragments ) ; String [ ] values = getFieldValues ( reader , docId , fieldName ) ; if ( values . length == 0 ) return null ; StringBuilder buffer = new StringBuilder ( ) ; int [ ] nextValueIndex = { 0 } ; for ( int n = 0 ; n < maxNumFragments && n < fragInfos . size ( ) ; n ++ ) { WeightedFragInfo fragInfo = fragInfos . get ( n ) ; fragments . add ( makeFragment ( buffer , nextValueIndex , values , fragInfo ) ) ; } return fragments . toArray ( new String [ fragments . size ( ) ] ) ; } protected String [ ] getFieldValues ( IndexReader reader , int docId , String fieldName ) throws IOException { Document doc = reader . document ( docId , new MapFieldSelector ( new String [ ] { fieldName } ) ) ; return doc . getValues ( fieldName ) ; } protected String makeFragment ( StringBuilder buffer , int [ ] index , String [ ] values , WeightedFragInfo fragInfo ) { StringBuilder fragment = new StringBuilder ( ) ; final int s = fragInfo . startOffset ; String src = getFragmentSource ( buffer , index , values , s , fragInfo . endOffset ) ; int srcIndex = 0 ; for ( SubInfo subInfo : fragInfo . subInfos ) { for ( Toffs to : subInfo . termsOffsets ) { fragment . append ( src . substring ( srcIndex , to . startOffset - s ) ) . append ( getPreTag ( subInfo . seqnum ) ) . append ( src . substring ( to . startOffset - s , to . endOffset - s ) ) . append ( getPostTag ( subInfo . seqnum ) ) ; srcIndex = to . endOffset - s ; } } fragment . append ( src . substring ( srcIndex ) ) ; return fragment . toString ( ) ; } protected String getFragmentSource ( StringBuilder buffer , int [ ] index , String [ ] values , int startOffset , int endOffset ) { while ( buffer . length ( ) < endOffset && index [ 0 ] < values . length ) { if ( index [ 0 ] > 0 && values [ index [ 0 ] ] . length ( ) > 0 ) buffer . append ( ' ' ) ; buffer . append ( values [ index [ 0 ] ++ ] ) ; } int eo = buffer . length ( ) < endOffset ? buffer . length ( ) : endOffset ; return buffer", "gt": ". substring ( startOffset , eo ) ;", "prediction": ". toString ( ) ;\n", "label": 1}
{"id": 5101, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class StackMap_attribute extends Attribute { StackMap_attribute ( ClassReader cr , int name_index , int length ) throws IOException , StackMapTable_attribute . InvalidStackMap { super ( name_index , length ) ; number_of_entries = cr . readUnsignedShort ( ) ; entries = new stack_map_frame [ number_of_entries ] ; for ( int i = 0 ; i < number_of_entries ; i ++ ) entries [ i ] = new stack_map_frame ( cr ) ; } public StackMap_attribute ( ConstantPool constant_pool , stack_map_frame [ ] entries ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . StackMap ) , entries ) ; } public StackMap_attribute ( int name_index , stack_map_frame [ ] entries ) { super ( name_index , StackMapTable_attribute . length ( entries ) ) ; this . number_of_entries = entries . length ; this", "gt": ". entries = entries ;", "prediction": ". length = entries . length ;\n", "label": 0}
{"id": 14010, "input": "<s> package org . apache . lucene . analysis . compound . hyphenation ; import org . xml . sax . XMLReader ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . DefaultHandler ; import org . xml . sax . Attributes ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . StringReader ; import java . net . MalformedURLException ; import java . util . ArrayList ; import javax . xml . parsers . SAXParserFactory ; public class PatternParser extends DefaultHandler implements PatternConsumer { XMLReader parser ; int currElement ; PatternConsumer consumer ; StringBuffer token ; ArrayList exception ; char hyphenChar ; String errMsg ; static final int ELEM_CLASSES = 1 ; static final int ELEM_EXCEPTIONS = 2 ; static final int ELEM_PATTERNS = 3 ; static final int ELEM_HYPHEN = 4 ; public PatternParser ( ) throws HyphenationException { token = new StringBuffer ( ) ; parser = createParser ( ) ; parser . setContentHandler ( this ) ; parser . setErrorHandler ( this ) ; parser . setEntityResolver ( this ) ; hyphenChar = '-' ; } public PatternParser ( PatternConsumer consumer ) throws HyphenationException { this ( ) ; this . consumer = consumer ; } public void setConsumer ( PatternConsumer consumer ) { this . consumer = consumer ; } public void parse ( String filename ) throws HyphenationException { parse ( new File ( filename ) ) ; } public void parse ( File file ) throws HyphenationException { try { InputSource src = new InputSource ( file . toURL ( ) . toExternalForm ( ) ) ; parse ( src ) ; } catch ( MalformedURLException e ) { throw new HyphenationException ( \"Error converting the File '\" + file + \"' to a URL: \" + e . getMessage ( ) ) ; } } public void parse ( InputSource source ) throws HyphenationException { try { parser . parse ( source ) ; } catch ( FileNotFoundException fnfe ) { throw new HyphenationException ( \"File not found: \" + fnfe . getMessage ( ) ) ; } catch ( IOException ioe ) { throw new HyphenationException ( ioe . getMessage ( ) ) ; } catch ( SAXException e ) { throw new HyphenationException ( errMsg ) ; } } static XMLReader createParser ( ) { try { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; return factory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Couldn't create XMLReader: \" + e . getMessage ( ) ) ; } } protected String readToken ( StringBuffer chars ) { String word ; boolean space = false ; int i ; for ( i = 0 ; i < chars . length ( ) ; i ++ ) { if ( Character . isWhitespace ( chars . charAt ( i ) ) ) { space = true ; } else { break ; } } if ( space ) { for ( int countr = i ; countr < chars . length ( ) ; countr ++ ) { chars . setCharAt ( countr - i , chars . charAt ( countr ) ) ; } chars .", "gt": "setLength ( chars . length ( ) - i ) ;", "prediction": "add ( word ) ;\n", "label": 1}
{"id": 7284, "input": "<s> package org . ofbiz . content . search ; import java . io . IOException ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . LocalDispatcher ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . Index ; import org . apache . lucene . document . Field . Store ; import org . apache . lucene . document . Field . TermVector ; public class ContentDocument { static char dirSep = System . getProperty ( \"file.separator\" ) . charAt ( 0 ) ; public static final String module = ContentDocument . class . getName ( ) ; public static Document Document ( String id , Delegator delegator , LocalDispatcher dispatcher ) throws InterruptedException { Document doc = null ; GenericValue content ; try { content = delegator . findOne ( \"Content\" , UtilMisc . toMap ( \"contentId\" , id ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; return doc ; } Map < String , Object > map = FastMap . newInstance ( ) ; doc = Document ( content , map , dispatcher ) ; return doc ; } public static Document Document ( GenericValue content , Map < String , Object > context , LocalDispatcher dispatcher ) throws InterruptedException { Document doc ; doc = new Document ( ) ; String contentId = content . getString ( \"contentId\" ) ; doc . add ( new Field ( \"contentId\" , contentId , Store . YES ,", "gt": "Index . NOT_ANALYZED , TermVector . NO ) ) ;", "prediction": "false ) ) ;\n", "label": 0}
{"id": 14011, "input": "<s> package com . digitalsanctum . idea . plugins . buildr ; import com . digitalsanctum . idea . plugins . buildr . ui . BuildrTasksPane ; import com . intellij . openapi . actionSystem . DataContext ; import com . intellij . openapi . components . ProjectComponent ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . wm . ToolWindow ; import com . intellij . openapi . wm . ToolWindowAnchor ; import com . intellij . openapi . wm . ToolWindowManager ; import com . intellij . ui . content . Content ; import com . intellij . ui . content . ContentFactory ; import org . jetbrains . annotations . NotNull ; import static com . digitalsanctum . idea . plugins . buildr . Buildr . * ; public class BuildrTasksListComponent implements ProjectComponent { private Project project ; private ToolWindow buildrToolWindow ; private BuildrTasksPane buildrTasksPane ; private ContentFactory contentFactory ; public BuildrTasksListComponent ( Project project ) { this . project = project ; } public void projectOpened ( ) { ToolWindowManager toolWindowManager = ToolWindowManager . getInstance ( this . project ) ; initBuildrToolWindow ( toolWindowManager ) ; } public void projectClosed ( ) { ToolWindowManager toolWindowManager = ToolWindowManager . getInstance ( project ) ; toolWindowManager . unregisterToolWindow ( BUILDR_TOOL_WINDOW_ID ) ; } @ NotNull public String getComponentName ( ) { return BuildrComponents . BUILDR_TASK_LIST_COMPONENT ; } public void initComponent ( ) { } public void disposeComponent ( ) { } public void refreshTaskList ( ) { this . buildrTasksPane . refreshTaskList ( ) ; } public void runSelectedTask ( ) { BuildrProjectComponent bpc = project . getComponent ( BuildrProjectComponent . class ) ; bpc . runTask ( this . buildrTasksPane . getCommand ( ) ) ; } public boolean isTaskSelected ( ) { return null != this . buildrTasksPane && this . buildrTasksPane . isTaskSelected ( ) ; } private ContentFactory getContentFactory ( ) { if", "gt": "( contentFactory == null )", "prediction": "( contentFactory == null )\n", "label": 1}
{"id": 2362, "input": "<s> package com . sun . source . tree ; public interface TreeVisitor < R , P > { R visitAnnotation ( AnnotationTree node , P p ) ; R visitMethodInvocation ( MethodInvocationTree node , P p ) ; R visitAssert ( AssertTree node , P p ) ; R visitAssignment ( AssignmentTree node , P p ) ; R visitCompoundAssignment ( CompoundAssignmentTree node , P p ) ; R visitBinary ( BinaryTree node , P p ) ; R visitBlock ( BlockTree node , P p ) ; R visitBreak ( BreakTree node , P p ) ; R visitCase ( CaseTree node , P p ) ; R visitCatch ( CatchTree node , P p ) ; R visitClass ( ClassTree node , P p ) ; R visitConditionalExpression ( ConditionalExpressionTree node , P p ) ; R visitContinue ( ContinueTree node , P p ) ; R visitDoWhileLoop ( DoWhileLoopTree node , P p ) ; R visitErroneous ( ErroneousTree node , P p ) ; R visitExpressionStatement ( ExpressionStatementTree node , P p ) ; R visitEnhancedForLoop ( EnhancedForLoopTree node , P p ) ; R visitForLoop ( ForLoopTree node , P p ) ; R visitIdentifier ( IdentifierTree node , P p ) ; R visitIf ( IfTree node , P p ) ; R visitImport ( ImportTree node , P p ) ; R visitArrayAccess ( ArrayAccessTree node , P p ) ; R visitLabeledStatement ( LabeledStatementTree node , P p ) ; R visitLiteral ( LiteralTree node , P p ) ; R visitMethod ( MethodTree node , P p ) ; R visitModifiers ( ModifiersTree node , P p ) ; R visitNewArray ( NewArrayTree node , P p ) ; R visitNewClass ( NewClassTree node , P p ) ; R visitParenthesized ( ParenthesizedTree node , P p ) ; R visitReturn ( ReturnTree node , P p ) ; R visitMemberSelect ( MemberSelectTree node , P p ) ; R visitEmptyStatement ( EmptyStatementTree node , P p ) ; R visitSwitch ( SwitchTree node , P p ) ; R visitSynchronized ( SynchronizedTree node , P p ) ; R visitThrow ( ThrowTree node , P p ) ; R visitCompilationUnit ( CompilationUnitTree node , P p ) ; R visitTry ( TryTree node , P p ) ; R visitParameterizedType ( ParameterizedTypeTree node , P p ) ; R visitUnionType ( UnionTypeTree node , P p ) ; R visitArrayType ( ArrayTypeTree node , P p ) ; R visitTypeCast ( TypeCastTree node", "gt": ", P p ) ;", "prediction": ", P p ) ;\n", "label": 0}
{"id": 14013, "input": "<s> package org . eclipse . rap . rwt . internal . util ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public final class ActiveKeysUtil { private static final Map < String , Integer > KEY_MAP = new HashMap < String , Integer > ( ) ; static { KEY_MAP . put ( \"BACKSPACE\" , new Integer ( 8 ) ) ; KEY_MAP . put ( \"BS\" , new Integer ( 8 ) ) ; KEY_MAP . put ( \"TAB\" , new Integer ( 9 ) ) ; KEY_MAP . put ( \"RETURN\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"ENTER\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"CR\" , new Integer ( 13 ) ) ; KEY_MAP . put ( \"PAUSE\" , new Integer ( 19 ) ) ; KEY_MAP . put ( \"BREAK\" , new Integer ( 19 ) ) ; KEY_MAP . put ( \"CAPS_LOCK\" , new Integer ( 20 ) ) ; KEY_MAP . put ( \"ESCAPE\" , new Integer ( 27 ) ) ; KEY_MAP . put ( \"ESC\" , new Integer ( 27 ) ) ; KEY_MAP . put ( \"SPACE\" , new Integer ( 32 ) ) ; KEY_MAP . put ( \"PAGE_UP\" , new Integer ( 33 ) ) ; KEY_MAP . put ( \"PAGE_DOWN\" , new Integer ( 34 ) ) ; KEY_MAP . put ( \"END\" , new Integer ( 35 ) ) ; KEY_MAP . put ( \"HOME\" , new Integer ( 36 ) ) ; KEY_MAP . put ( \"ARROW_LEFT\" , new Integer ( 37 ) ) ; KEY_MAP . put ( \"ARROW_UP\" , new Integer ( 38 ) ) ; KEY_MAP . put ( \"ARROW_RIGHT\" , new Integer ( 39 ) ) ; KEY_MAP . put ( \"ARROW_DOWN\" , new Integer ( 40 ) ) ; KEY_MAP . put ( \"PRINT_SCREEN\" , new Integer ( 44 ) ) ; KEY_MAP . put ( \"INSERT\" , new Integer ( 45 ) ) ; KEY_MAP . put ( \"DEL\" , new Integer ( 46 ) ) ; KEY_MAP . put ( \"DELETE\" , new Integer ( 46 ) ) ; KEY_MAP . put ( \"F1\" , new Integer ( 112 ) ) ; KEY_MAP . put ( \"F2\" , new Integer ( 113 ) ) ; KEY_MAP . put ( \"F3\" , new Integer ( 114 ) ) ; KEY_MAP . put ( \"F4\" , new Integer ( 115 ) ) ; KEY_MAP . put ( \"F5\" , new Integer ( 116 ) ) ; KEY_MAP . put ( \"F6\" , new Integer ( 117 ) ) ; KEY_MAP . put ( \"F7\" , new Integer ( 118 ) ) ; KEY_MAP . put ( \"F8\" , new Integer ( 119 ) ) ; KEY_MAP . put ( \"F9\" , new Integer ( 120 ) ) ; KEY_MAP . put ( \"F10\" , new Integer ( 121 ) ) ; KEY_MAP . put ( \"F11\" , new Integer ( 122 ) ) ; KEY_MAP . put ( \"F12\" , new Integer ( 123 ) ) ; KEY_MAP . put ( \"NUMPAD_0\" , new Integer ( 96 ) ) ; KEY_MAP . put ( \"NUMPAD_1\" , new Integer ( 97 ) ) ; KEY_MAP . put ( \"NUMPAD_2\" , new Integer ( 98 ) ) ; KEY_MAP . put ( \"NUMPAD_3\" , new Integer ( 99 ) ) ; KEY_MAP . put ( \"NUMPAD_4\" , new Integer ( 100 ) ) ; KEY_MAP . put ( \"NUMPAD_5\" , new Integer ( 101 ) ) ; KEY_MAP . put ( \"NUMPAD_6\" , new Integer ( 102 ) ) ; KEY_MAP . put ( \"NUMPAD_7\" , new Integer ( 103 ) ) ; KEY_MAP . put ( \"NUMPAD_8\" , new Integer ( 104 ) ) ; KEY_MAP . put ( \"NUMPAD_9\" , new Integer ( 105 ) ) ; KEY_MAP . put ( \"NUMPAD_MULTIPLY\" , new Integer ( 106 ) ) ; KEY_MAP . put ( \"NUMPAD_ADD\" , new Integer ( 107 ) ) ; KEY_MAP . put ( \"NUMPAD_SUBTRACT\" , new Integer ( 109 ) ) ; KEY_MAP . put ( \"NUMPAD_DECIMAL\" , new Integer ( 110 ) ) ; KEY_MAP . put ( \"NUMPAD_DIVIDE\" , new Integer ( 111 ) ) ; KEY_MAP . put ( \"NUM_LOCK\" , new Integer ( 144 ) ) ; KEY_MAP . put", "gt": "( \"SCROLL_LOCK\" , new Integer ( 145 ) ) ;", "prediction": "( \"NUM_PAUSE\" , new Integer ( 145 ) ) ;\n", "label": 1}
{"id": 8664, "input": "<s> package org . xbill . DNS ; public class Compression { private static class Entry { Name name ; int pos ; Entry next ; } private static final int TABLE_SIZE = 17 ; private static final int MAX_POINTER = 0x3FFF ; private Entry [ ] table ; private boolean verbose = Options . check ( \"verbosecompression\" ) ; public Compression ( ) { table = new Entry [ TABLE_SIZE ] ; } public void add ( int pos , Name name ) { if ( pos > MAX_POINTER ) return ; int row = ( name . hashCode ( ) & 0x7FFFFFFF ) % TABLE_SIZE ; Entry entry = new Entry ( ) ; entry . name = name ; entry . pos = pos ; entry . next = table [ row ] ; table [ row ] = entry ; if ( verbose ) System . err . println ( \"Adding \" + name + \" at \" + pos ) ; } public int get ( Name name ) { int row = ( name . hashCode ( ) & 0x7FFFFFFF ) % TABLE_SIZE ; int pos = - 1 ; for ( Entry entry = table [ row ] ; entry != null ; entry", "gt": "= entry . next )", "prediction": ". pos ++ )\n", "label": 0}
{"id": 14035, "input": "<s> package org . eclipse . ui . tests . keys ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class Bug43597Test extends UITestCase { private Font textFont ; public Bug43597Test ( String name ) { super ( name ) ; } public void testFontReset ( ) { String metaCharacter = \"\u2325X\" ; Display display = Display . getCurrent ( ) ; Shell shell = new Shell ( display ) ; GridLayout gridLayout = new GridLayout ( ) ; shell . setLayout ( gridLayout ) ; Text text = new Text ( shell , SWT . LEFT ) ; text . setFont ( Graphics . getFont ( \"Lucida Grande\" , 13 , SWT . NORMAL ) ) ; text . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; shell . pack ( ) ; shell . open ( ) ; text . setText ( metaCharacter ) ; Font", "gt": "fontBefore = text . getFont ( ) ;", "prediction": "font = new Font ( textFont ) ;\n", "label": 1}
{"id": 8288, "input": "<s> public class Switch2 { private boolean isZero ( int d ) { switch ( d ) { case 0 : return true ; default : return false ; } } void useSecondArgument ( String a , int b ) { if ( ! isZero ( b ) ) throw new RuntimeException ( \"isZero(0) returns false?!\" ) ; } public static void main ( String [ ] args ) { Switch2 object = new Switch2 ( ) ;", "gt": "object . useSecondArgument ( \"42\" , 0 ) ;", "prediction": "switch ( object )\n", "label": 0}
{"id": 14042, "input": "<s> package litil . eval ; import litil . TypeScope ; import litil . Utils ; import litil . ast . * ; import litil . lexer . * ; import litil . parser . LitilParser ; import litil . tc . HMTypeChecker ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . * ; public class Evaluator { private int depth ; private boolean dbgAp = false ; private void dbgAp ( String msg ) { if ( dbgAp ) { System . out . println ( Utils . tab ( depth ) + msg ) ; } } public Object eval ( AstNode node , ValScope scope ) { if ( node instanceof Expr ) { if ( node instanceof Expr . EName ) { Object val = scope . get ( ( ( Expr . EName ) node ) . name ) ; if ( val == null ) { throw new EvalException ( \"Unknwon identifier \" + node ) ; } else { return val ; } } else if ( node instanceof Expr . EAccessor ) { Expr . EAccessor acc = ( Expr . EAccessor ) node ; Object obj = eval ( acc . obj , scope ) ; if ( ! ( obj instanceof Map ) ) { throw new EvalException ( \"Not a record \" + acc . obj ) ; } else { Map < String , Object > fields = ( Map < String , Object > ) obj ; if ( ! fields . containsKey ( acc . field ) ) { throw new EvalException ( \"No field \" + acc . field + \"in \" + obj ) ; } return fields . get ( acc . field ) ; } } else if ( node instanceof Expr . ENum ) { return ( ( Expr . ENum ) node ) . value ; } else if ( node instanceof Expr . EBool ) { return ( ( Expr . EBool ) node ) . value ; } else if ( node instanceof Expr . EChar ) { return ( ( Expr . EChar ) node ) . value ; } else if ( node instanceof Expr . EStr ) { String s = ( ( Expr . EStr ) node ) . value ; List < Object > chars = new ArrayList < Object > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { chars . add ( s . charAt ( i ) ) ; } return makeList ( chars ) ; } else if ( node == Expr . EUnit ) { return node ; } else if ( node instanceof Expr . ETuple ) { Expr . ETuple tuple = ( ( Expr . ETuple ) node ) ; List < Object > res = new ArrayList < Object > ( ) ; for ( Expr value : tuple . values ) { res . add ( eval ( value , scope ) ) ; } return res ; } else if ( node instanceof Expr . EList ) { Expr . EList list = ( ( Expr . EList ) node ) ; List < Object > res = new ArrayList < Object > ( ) ;", "gt": "for ( Expr value : list . values )", "prediction": "for ( Expr value : list . values )\n", "label": 1}
{"id": 2297, "input": "<s> package p1 ; class NonStaticFieldExpr4a { protected int i ; } interface NonStaticFieldExpr4b { static", "gt": "int i = 1 ;", "prediction": "int i ;\n", "label": 0}
{"id": 14048, "input": "<s> package com . northconcepts . eventbus . filter ; import com . northconcepts . eventbus . EventFilter ; import org . junit . Test ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class NotFilterTest extends LogicalFilterTest { @ Test public void testNullFilters ( ) { EventFilter filter = new NotFilter ( ( EventFilter [ ] ) null ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testZeroFilters ( ) { EventFilter filter = new NotFilter ( ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneTrueFilter ( ) { EventFilter filter = new NotFilter ( TRUE_FILTER ) ; assertFalse ( filter . allow ( event , listener ) ) ; } @ Test public void testOneFalseFilter ( ) { EventFilter filter = new NotFilter ( FALSE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testManyTrueFilters ( ) { EventFilter filter = new NotFilter ( TRUE_FILTER , TRUE_FILTER , TRUE_FILTER ) ; assertFalse ( filter . allow ( event , listener ) ) ; } @ Test public void testManyFalseFilters ( ) { EventFilter filter = new NotFilter ( FALSE_FILTER , FALSE_FILTER , FALSE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testManyMixedFilters ( ) { EventFilter filter = new NotFilter (", "gt": "TRUE_FILTER , FALSE_FILTER , TRUE_FILTER ) ;", "prediction": "TRUE_FILTER , TRUE_FILTER , TRUE_FILTER ) ;\n", "label": 1}
{"id": 3697, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . javadoc . * ; import java . util . * ; public class MetaKeywords { private final Configuration configuration ; public MetaKeywords ( Configuration configuration ) { this . configuration = configuration ; } public String [ ] getMetaKeywords ( ClassDoc classdoc ) { ArrayList < String > results = new ArrayList < String > ( ) ; if ( configuration . keywords ) { results . addAll ( getClassKeyword ( classdoc ) ) ; results . addAll ( getMemberKeywords ( classdoc . fields ( ) ) ) ; results . addAll ( getMemberKeywords ( classdoc . methods ( ) ) ) ; } return results . toArray ( new String [ ] { } ) ; } protected ArrayList < String > getClassKeyword ( ClassDoc classdoc ) { String cltypelower = classdoc . isInterface ( ) ? \"interface\" : \"class\" ; ArrayList < String > metakeywords = new ArrayList < String > ( 1 ) ; metakeywords . add ( classdoc . qualifiedName ( ) + \" \" + cltypelower ) ; return metakeywords ; } public String [ ] getMetaKeywords ( PackageDoc packageDoc ) { if ( configuration . keywords ) { String pkgName = Util . getPackageName ( packageDoc ) ; return new String [ ] { pkgName + \" \" + \"package\" } ; } else { return new String [ ] { } ; } } public String [ ] getOverviewMetaKeywords ( String title , String docTitle ) { if ( configuration . keywords ) { String windowOverview = configuration . getText ( title ) ; String [ ] metakeywords = { windowOverview } ; if ( docTitle . length ( ) > 0 ) { metakeywords [ 0 ] += \", \" + docTitle ; } return metakeywords ; } else { return new String [ ] { } ; } } protected ArrayList < String > getMemberKeywords ( MemberDoc [ ] memberdocs ) { ArrayList < String > results = new ArrayList < String > ( ) ; String membername ; for ( int i = 0 ; i < memberdocs . length ; i ++ ) { membername = memberdocs [ i ] . name ( ) + ( memberdocs [ i", "gt": "] . isMethod ( ) ? \"()\" : \"\" ) ;", "prediction": "] . fields ( ) ) ;\n", "label": 0}
{"id": 14050, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . CookieParam ; import javax . ws . rs . core . Application ; import junit . framework . AssertionFailedError ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Cookie ; import org . restlet . data . Status ; import org . restlet . representation . Representation ; import org . restlet . test . ext . jaxrs . services . resources . CookieParamTestService ; public class CookieParamTest extends JaxRsTestCase { @ Override protected Application getApplication ( ) { return new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( CookieParamTestService . class ) ; } } ; } public void test1 ( ) throws IOException { Response response = get ( new Cookie ( \"c\" , \"value\" ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"value\" , response . getEntity ( ) . getText ( ) ) ; response = get ( new Cookie ( \"c\" , \"sdfgdfg\" ) ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"sdfgdfg\" , response . getEntity ( ) . getText ( ) ) ; } public void test2 ( ) throws IOException { final Response response = get ( ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_NO_CONTENT , response . getStatus ( ) ) ; final Representation entity = response . getEntity ( ) ; String text ; if ( entity != null ) { text = entity . getText ( ) ; } else { text = null ; } assertEquals ( null , text ) ; } public void testCookieArray ( ) throws Exception { final Request request = createGetRequest ( \"array\" ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c1\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c2\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"d\" , \"c3\" ) ) ; final Response response = accessServer ( request ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; final String entity = response . getEntity ( ) . getText ( ) ; final String entityWithoutBrackets = entity . substring ( 1 , entity . length ( ) - 1 ) ; assertEquals ( \"c1, c2\" , entityWithoutBrackets ) ; } public void testCookieSet ( ) throws Exception { final Request request = createGetRequest ( \"Set\" ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c1\" ) ) ; request . getCookies ( ) . add ( new Cookie ( \"c\" , \"c2\" ) ) ; request . getCookies ( ) . add", "gt": "( new Cookie ( \"d\" , \"c3\" ) ) ;", "prediction": "( new Cookie ( \"d\" , \"c3\" ) ) ;\n", "label": 1}
{"id": 5254, "input": "<s> public class T6569404a { static class Outer { public class Inner { } } static class Test < T extends Outer > { public Test ( T t ) { Outer . Inner inner", "gt": "= t . new Inner ( ) ;", "prediction": "= t ;\n", "label": 0}
{"id": 14055, "input": "<s> package org . jscsi . initiator . connection . state ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . initiator . connection . TargetCapacityInformations ; import org . jscsi . parser . OperationCode ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . data . DataInParser ; import org . jscsi . parser . scsi . SCSICommandParser . TaskAttributes ; import org . jscsi . parser . scsi . SCSIResponseParser ; import org . jscsi . parser . scsi . SCSIStatus ; public final class CapacityResponseState extends AbstractState { private final TargetCapacityInformations capacityInformation ; protected CapacityResponseState ( final Connection initConnection , final TargetCapacityInformations initCapacityInformation ) { super ( initConnection ) ; capacityInformation = initCapacityInformation ; } public final void execute ( ) throws InternetSCSIException { final ProtocolDataUnit protocolDataUnit = connection . receive ( ) ; if ( ! ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) instanceof DataInParser ) ) { if ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) instanceof SCSIResponseParser ) { connection . nextState ( new CapacityRequestState ( connection , capacityInformation , TaskAttributes . SIMPLE ) ) ; super . stateFollowing = true ; return ; } else { throw new InternetSCSIException ( protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) . getClass ( ) . getSimpleName ( ) + \" is not the expected type of PDU.\" ) ; } } final DataInParser parser = ( DataInParser ) protocolDataUnit . getBasicHeaderSegment ( ) . getParser ( ) ; capacityInformation . deserialize", "gt": "( protocolDataUnit . getDataSegment ( ) ) ;", "prediction": "( parser ) ;\n", "label": 1}
{"id": 3281, "input": "<s> package org . ofbiz . minilang . method . otherops ; import java . math . BigDecimal ; import java . text . DecimalFormat ; import java . util . List ; import java . util . Locale ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . minilang . MiniLangElement ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangUtil ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class Calculate extends MethodOperation { public static final String module = Calculate . class . getName ( ) ; public static final int TYPE_DOUBLE = 1 ; public static final int TYPE_FLOAT = 2 ; public static final int TYPE_LONG = 3 ; public static final int TYPE_INTEGER = 4 ; public static final int TYPE_STRING = 5 ; public static final int TYPE_BIG_DECIMAL = 6 ; private final Calculate . SubCalc calcops [ ] ; private final FlexibleStringExpander decimalFormatFse ; private final FlexibleStringExpander decimalScaleFse ; private final FlexibleMapAccessor < Object > fieldFma ; private final FlexibleStringExpander roundingModeFse ; private final int type ; private final String typeString ; public Calculate ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . handleError ( \"<calculate> element is deprecated (use <set>)\" , simpleMethod , element ) ; MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" , \"decimal-scale\" , \"decimal-format\" , \"rounding-mode\" , \"type\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . childElements ( simpleMethod , element , \"calcop\" , \"number\" ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; this . decimalFormatFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"decimal-format\" ) ) ; this . decimalScaleFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"decimal-scale\" ) ) ; this . roundingModeFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"rounding-mode\" ) ) ; this . typeString = element . getAttribute ( \"type\" ) ; int type = Calculate . TYPE_BIG_DECIMAL ; if ( \"Double\" . equals ( typeString ) ) { type = Calculate . TYPE_DOUBLE ; } else if ( \"Float\" . equals ( typeString ) ) { type = Calculate . TYPE_FLOAT ; } else if ( \"Long\" . equals ( typeString ) ) { type = Calculate . TYPE_LONG ; } else if ( \"Integer\" . equals ( typeString ) ) { type = Calculate . TYPE_INTEGER ; } else if ( \"String\" . equals ( typeString ) ) { type = Calculate . TYPE_STRING ; } else if ( \"BigDecimal\" . equals ( typeString ) ) { type = Calculate . TYPE_BIG_DECIMAL ; } this . type = type ; List < ? extends Element > calcopElements = UtilXml . childElementList ( element ) ; calcops = new Calculate . SubCalc [ calcopElements . size ( ) ] ; int i = 0 ; for ( Element calcopElement : calcopElements ) { String nodeName = calcopElement . getNodeName ( ) ; if ( \"calcop\" . equals ( nodeName ) ) { calcops [ i ] = new CalcOp ( calcopElement , simpleMethod ) ; } else if ( \"number\" . equals ( nodeName ) ) { calcops [ i ] = new NumberOp ( calcopElement , simpleMethod ) ; } else { MiniLangValidate . handleError ( \"Invalid calculate sub-element.\" , simpleMethod , calcopElement ) ; calcops [ i ] = new InvalidOp ( calcopElement , simpleMethod ) ; } i ++ ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { String roundingModeString = roundingModeFse . expandString ( methodContext . getEnvMap ( ) ) ; int roundingMode = BigDecimal . ROUND_HALF_EVEN ; if ( \"Ceiling\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_CEILING ; } else if ( \"Floor\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_FLOOR ; } else if ( \"Up\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_UP ; } else if ( \"Down\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_DOWN ; } else if ( \"HalfUp\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_HALF_UP ; } else if ( \"HalfDown\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_HALF_DOWN ; } else if ( \"Unnecessary\" . equals ( roundingModeString ) ) { roundingMode = BigDecimal . ROUND_UNNECESSARY ; } String decimalScaleString = decimalScaleFse . expandString ( methodContext . getEnvMap ( ) ) ; int decimalScale = 2 ; if ( ! decimalScaleString . isEmpty ( ) ) { decimalScale = Integer . valueOf ( decimalScaleString ) . intValue ( ) ; } BigDecimal resultValue = BigDecimal . ZERO . setScale ( decimalScale , roundingMode ) ; for ( Calculate . SubCalc calcop : calcops ) { resultValue = resultValue . add ( calcop . calcValue ( methodContext , decimalScale , roundingMode ) ) ; } resultValue = resultValue . setScale ( decimalScale , roundingMode ) ; Object resultObj = null ; switch ( type ) { case TYPE_DOUBLE : resultObj = Double . valueOf ( resultValue . doubleValue ( ) ) ; break ; case TYPE_FLOAT : resultObj = Float . valueOf ( resultValue . floatValue ( ) ) ; break ; case TYPE_LONG :", "gt": "resultValue = resultValue . setScale ( 0 , roundingMode ) ;", "prediction": "resultObj = Long . valueOf ( resultValue . longValue ( ) ) ;\n", "label": 0}
{"id": 14058, "input": "<s> package com . ornament ; import java . util . Vector ; import processing . core . PApplet ; import com . datatype . Point ; import com . primitive2d . Ellipse ; import com . primitive2d . Line ; import com . primitive2d . Polygon ; import com . primitive2d . Drawable ; public class Fractal extends Pattern { public Point a = new Point ( 0 , 0 ) ; public Point b = new Point ( 800 , 500 ) ; private int levelLimit = 5 ; private double tri_Angle = 60 ; private String seedShape ; private double width = 500 ; private double height = 500 ; public Fractal ( Point start , Point end ) { super ( ) ; a = start . copy ( ) ; b = end . copy ( ) ; } public Fractal ( double startX , double startY , double endX , double endY ) { super ( ) ; a = new Point ( startX , startY ) ; b = new Point ( endX , endY ) ; } public void setAngle ( double angle ) { this . tri_Angle = angle ; } public void setLevelLimit ( int setLevel ) { levelLimit = setLevel ; } public void setSeedShape ( String setShape ) { seedShape = setShape ; } public void generate ( ) { Line line = new Line ( a , b ) ; this . addLine ( line ) ; for ( int i = 0 ; i < levelLimit ; i ++ ) iterate ( this . getAllLines ( ) ) ; } public void iterate ( Vector before ) { Vector now = new Vector ( ) ; for ( int i = 0 ; i < before . size ( ) ; i ++ ) { Line l = this . getLineAt ( i ) ; if ( seedShape == \"rectangle\" ) { now . addAll ( lineUp ( recPoints ( l ) ) ) ; } else { now . addAll ( lineUp ( triPoints ( l ) ) ) ; } } this . setAllLines ( now ) ; } public Vector triPoints ( Line l ) { Vector now = new Vector ( ) ; now . add ( start ( l ) ) ; now . add ( kochleft ( l ) ) ; now . add ( kochmiddle ( l ) ) ; now . add ( kochright ( l ) ) ; now . add ( end ( l ) ) ; return now ; } public Vector recPoints ( Line l ) { Vector now = new Vector ( ) ; now . add ( start ( l ) ) ; now . add ( recLeftDown ( l ) ) ; now . add ( recLeftUp ( l ) ) ; now . add ( recMidUp ( l ) ) ; now . add ( recMidMid ( l ) ) ; now . add ( recMidDown ( l ) ) ; now . add ( recRightDown ( l ) ) ; now . add ( recRightUp ( l ) ) ; now . add ( end ( l ) ) ; return now ; } Vector lineUp ( Vector dots ) { Vector orig = new Vector ( ) ; for ( int i = 0 ; i < dots . size ( ) - 1 ; i ++ ) { orig . add ( new Line ( ( Point ) dots . get ( i ) , ( Point ) dots . get ( i + 1 ) ) ) ; } return orig ; } public Point start ( Line l ) { return l . start . copy ( ) ; } public Point end ( Line l ) { return l . end . copy ( ) ; } public Point kochleft ( Line l ) { float x = ( float ) ( l . start . getX ( ) + ( l . end . getX ( ) - l . start . getX ( ) ) / 3f ) ; float y = ( float ) ( l . start . getY ( ) + ( l . end . getY ( ) - l . start . getY ( ) ) / 3f ) ; return", "gt": "new Point ( x , y ) ;", "prediction": "x ;\n", "label": 1}
{"id": 6643, "input": "<s> package org . jboss . arquillian . android . impl ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . StringTokenizer ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . jboss . arquillian . android . api . AndroidBridge ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . android . api . AndroidExecutionException ; import org . jboss . arquillian . android . configuration . AndroidExtensionConfiguration ; import org . jboss . arquillian . android . configuration . AndroidSdk ; import org . jboss . arquillian . android . spi . event . AndroidDeviceReady ; import org . jboss . arquillian . android . spi . event . AndroidVirtualDeviceEvent ; import org . jboss . arquillian . core . api . Event ; import org . jboss . arquillian . core . api . InstanceProducer ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . core . api . annotation . Observes ; import org . jboss . arquillian . test . spi . annotation . SuiteScoped ; import com . android . ddmlib . AndroidDebugBridge ; import com . android . ddmlib . AndroidDebugBridge . IDeviceChangeListener ; import com . android . ddmlib . IDevice ; public class EmulatorStartup { private static final Logger log = Logger . getLogger ( EmulatorStartup . class . getName ( ) ) ; @ Inject @ SuiteScoped private InstanceProducer < AndroidEmulator > androidEmulator ; @ Inject @ SuiteScoped private InstanceProducer < AndroidDevice > androidDevice ; @ Inject private Event < AndroidDeviceReady > androidDeviceReady ; public void createAndroidVirtualDeviceAvailable ( @ Observes AndroidVirtualDeviceEvent event , AndroidBridge bridge , AndroidExtensionConfiguration configuration , AndroidSdk sdk , ProcessExecutor executor ) throws AndroidExecutionException { if ( ! bridge . isConnected ( ) ) { throw new IllegalStateException ( \"Android debug bridge must be connected in order to spawn emulator\" ) ; } String name = configuration . getAvdName ( ) ; AndroidDevice running = null ; for ( AndroidDevice device : bridge . getDevices ( ) ) { if ( equalsIgnoreNulls ( name , device . getAvdName ( ) ) ) { running = device ; break ; } } if ( running == null ) { CountDownWatch countdown = new CountDownWatch ( configuration . getEmulatorBootupTimeoutInSeconds ( ) , TimeUnit . SECONDS ) ; log . log ( Level . INFO , \"Waiting {0} seconds for emulator {1} to be started and connected.\" , new Object [ ] { countdown . timeout ( ) , name } ) ; DeviceConnectDiscovery deviceDiscovery = new DeviceConnectDiscovery ( ) ; AndroidDebugBridge . addDeviceChangeListener ( deviceDiscovery ) ; Process emulator = startEmulator ( executor , sdk , name , configuration . getEmulatorOptions ( ) ) ; androidEmulator . set ( new AndroidEmulator ( emulator ) ) ; log . log ( Level . FINE , \"Emulator process started, {0} seconds remaining to start the device {1}\" , new Object [ ] { countdown . timeLeft ( ) , name } ) ; waitUntilBootUpIsComplete ( deviceDiscovery , executor , sdk , countdown ) ; running = deviceDiscovery . getDiscoveredDevice ( ) ; AndroidDebugBridge . removeDeviceChangeListener ( deviceDiscovery ) ; } else { log . info ( \"Emulator for device \" + name + \" is already started, device serial is \" + running . getSerialNumber ( ) + \". Emulator will not be reinitialized.\" ) ; } androidDevice . set ( running ) ; androidDeviceReady . fire ( new AndroidDeviceReady ( running ) ) ; } private Process startEmulator ( ProcessExecutor executor , AndroidSdk sdk , String name , String emulatorOptions ) throws AndroidExecutionException { List < String > emulatorCommand = new ArrayList < String > ( Arrays . asList ( sdk . getEmulatorPath ( ) , \"-avd\" , name ) ) ; emulatorCommand = getEmulatorOptions ( emulatorCommand , emulatorOptions ) ; try { return executor . spawn ( emulatorCommand ) ; } catch ( InterruptedException e ) { throw new AndroidExecutionException ( e , \"Unable to start emulator for {0} with options {1}\" , name , emulatorOptions ) ; } catch ( ExecutionException e ) { throw new AndroidExecutionException ( e , \"Unable to start emulator for {0} with options {1}\" , name , emulatorOptions ) ; } } private void waitUntilBootUpIsComplete ( final DeviceConnectDiscovery deviceDiscovery , final ProcessExecutor executor , final AndroidSdk sdk , final CountDownWatch countdown ) throws AndroidExecutionException { try { boolean isOnline = executor . scheduleUntilTrue ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { return deviceDiscovery . isOnline ( ) ; } } , countdown . timeLeft ( ) , countdown . getTimeUnit ( ) . convert ( 1 , TimeUnit . SECONDS ) , countdown . getTimeUnit ( ) ) ; if ( isOnline == false ) { throw new IllegalStateException ( \"No emulator device was brough online during \" + countdown . timeout ( ) + \" seconds to Android Debug Bridge. Please increase the time limit in order to get emulator connected.\" ) ; } final AndroidDevice connectedDevice = deviceDiscovery . getDiscoveredDevice ( ) ; isOnline = executor . scheduleUntilTrue ( new Callable < Boolean > ( ) { @ Override public Boolean call ( ) throws Exception { List < String > props = executor . execute ( Collections . < String , String > emptyMap ( ) , sdk . getAdbPath ( ) , \"-s\" , connectedDevice . getSerialNumber ( ) , \"shell\" , \"getprop\" ) ; for ( String line : props ) { if ( line . contains ( \"[ro.runtime.firstboot]\" ) ) { return true ; } } return false ; } } , countdown . timeLeft ( ) , countdown . getTimeUnit ( ) . convert ( 1 , TimeUnit . SECONDS ) , countdown . getTimeUnit ( ) ) ; if ( log . isLoggable ( Level . INFO ) ) { log . log ( Level . INFO , \"Android emulator {0} was started within {1} seconds\" , new Object [ ] { connectedDevice . getAvdName ( ) , countdown . timeElapsed ( ) } ) ; } if ( isOnline == false ) { throw new AndroidExecutionException ( \"Emulator device hasn't started properly in \" + countdown . timeout ( ) + \" seconds. Please increase the time limit in order to get emulator booted.\" ) ; } } catch ( InterruptedException e ) { throw new", "gt": "AndroidExecutionException ( e , \"Emulator device startup failed.\" ) ;", "prediction": "AndroidExecutionException ( e , \"Unable to start emulator for\n", "label": 0}
{"id": 14065, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . connection . DataType ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . query . SortQuery ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisKeyTest extends RedisTestSupport { private RedisTemplate redisTemplate ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteDEL ( ) throws Exception { Collection < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"DEL\" , RedisConstants . KEYS , keys ) ; verify ( redisTemplate ) . delete ( keys ) ; } @ Test public void shouldExecuteEXISTS ( ) throws Exception { when ( redisTemplate . hasKey ( anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXISTS\" , RedisConstants . KEY , \"key\" ) ; verify ( redisTemplate ) . hasKey ( \"key\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIRE ( ) throws Exception { when ( redisTemplate . expire ( anyString ( ) , anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIRE\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" ) ; verify ( redisTemplate ) . expire ( \"key\" , 10L , TimeUnit . SECONDS ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIREAT ( ) throws Exception { when ( redisTemplate . expireAt ( anyString ( ) , any ( Date . class ) ) ) . thenReturn ( true ) ; long unixTime = System . currentTimeMillis ( ) / 1000L ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIREAT\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMESTAMP , unixTime ) ; verify ( redisTemplate ) . expireAt ( \"key\" , new Date ( unixTime * 1000L ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteKEYS ( ) throws Exception { Set < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; when ( redisTemplate . keys ( anyString ( ) ) ) . thenReturn ( keys ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"KEYS\" , RedisConstants . PATTERN , \"key*\" ) ; verify ( redisTemplate ) . keys ( \"key*\" ) ; assertEquals ( keys , result ) ; } @ Test public void shouldExecuteMOVE ( ) throws Exception { when ( redisTemplate . move ( anyString ( ) , anyInt (", "gt": ") ) ) . thenReturn ( true ) ;", "prediction": ") ) ) . thenReturn ( true ) ;\n", "label": 1}
{"id": 3205, "input": "<s> import java . util . * ; class GenericIterator < T > { void main ( String [ ] strings ) { HashSet < T > buffer = new", "gt": "HashSet < T > ( ) ;", "prediction": "HashSet < T > ( ) ;\n", "label": 0}
{"id": 14072, "input": "<s> package br . org . archimedes . io . pdf . rcp ; import br . org . archimedes . interfaces . DrawingExporter ; import br . org . archimedes . interfaces . FileModel ; import br . org . archimedes . interfaces . FileModelImpl ; import br . org . archimedes . io . pdf . PDFExporter ; import br . org . archimedes . model . Drawing ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . swt . widgets . MessageBox ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IExportWizard ; import org . eclipse . ui . IWorkbench ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PDFWizardExporter extends Wizard implements IExportWizard , DrawingExporter { private FileModel fileModel = new FileModelImpl ( ) ; private IStructuredSelection selection ; private IWorkbench workbench ; @ Override public boolean canFinish ( ) { String filePath = fileModel . getFilePath ( ) ; if ( filePath == null || selection . isEmpty ( ) || selection . getFirstElement ( ) . getClass ( ) != Drawing . class ) { return false ; } File file = new File ( filePath ) ; if ( file . isDirectory ( ) ) { return false ; } else if ( ! file . exists ( ) ) { File parent = file . getParentFile ( ) ; return parent != null && parent . isDirectory ( ) && parent . canWrite ( ) ; } else { return", "gt": "file . canWrite ( ) ;", "prediction": "false ;\n", "label": 1}
{"id": 4410, "input": "<s> import java . io . * ; import java . net . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . tools . * ; import com . sun . tools . javac . api . JavacTool ; @ SupportedAnnotationTypes ( { \"*\" } ) public class T6348193 extends AbstractProcessor { private static final boolean verbose = true ; enum NoYes { NO , YES } ; enum NoGoodBad { NO , GOOD , BAD } ; public static final String myName = T6348193 . class . getName ( ) ; public static void main ( String ... args ) throws IOException { if ( System . getSecurityManager ( ) != null ) throw new AssertionError ( \"unexpected security manager\" ) ; for ( NoYes secMgr : EnumSet . allOf ( NoYes . class ) ) for ( NoGoodBad config : EnumSet . allOf ( NoGoodBad . class ) ) for ( NoYes proc : EnumSet . allOf ( NoYes . class ) ) test ( secMgr , config , proc ) ; } private static File processed = new File ( \"processed\" ) ; public static void test ( NoYes secMgr , NoGoodBad config , NoYes proc ) throws IOException { if ( verbose ) System . err . println ( \"secMgr:\" + secMgr + \" config:\" + config + \" proc:\" + proc ) ; if ( secMgr == NoYes . YES && System . getSecurityManager ( ) == null ) System . setSecurityManager ( new NoLoaderSecurityManager ( ) ) ; installConfigFile ( config ) ; processed . delete ( ) ; List < String > args = new ArrayList < String > ( ) ; if ( proc == NoYes . YES ) { args . add ( \"-processor\" ) ; args . add ( myName ) ; } args . add ( \"-processorpath\" ) ; args . add ( System . getProperty ( \"java.class.path\" ) ) ; args . add ( \"-d\" ) ; args . add ( \".\" ) ; JavacTool t = JavacTool . create ( ) ; MyDiagListener dl = new MyDiagListener ( ) ; PrintWriter out = new PrintWriter ( System . err , true ) ; StandardJavaFileManager fm = t . getStandardFileManager ( dl , null , null ) ; File file = new File ( System . getProperty ( \"test.src\" ) , myName + \".java\" ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( file ) ) ; boolean ok = t . getTask ( out , null , dl , args , null , files ) . call ( ) ; if ( config == NoGoodBad . GOOD || proc == NoYes . YES ) { if ( secMgr == NoYes . YES ) { if ( dl . last == null ) throw new AssertionError ( \"Security manager installed, and processors present, \" + \" but no diagnostic received\" ) ; } else { if ( ! processed . exists ( ) ) throw new AssertionError ( \"No security manager installed, and processors present, \" + \" but no processing occurred\" ) ; } } else if ( config == NoGoodBad . BAD ) { } else { if ( processed . exists ( ) ) throw new AssertionError ( \"No processors present, but processing occurred!\" ) ; } if ( verbose ) System . err . println ( \"OK\" ) ; } static void installConfigFile", "gt": "( NoGoodBad type ) throws IOException", "prediction": "( ConfigFile configFile ) throws IOException\n", "label": 0}
{"id": 14085, "input": "<s> package org . restlet . routing ; import java . util . logging . Level ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . Representation ; import org . restlet . util . Resolver ; public class Redirector extends Restlet { public static final int MODE_CLIENT_PERMANENT = 1 ; public static final int MODE_CLIENT_FOUND = 2 ; public static final int MODE_CLIENT_SEE_OTHER = 3 ; public static final int MODE_CLIENT_TEMPORARY = 4 ; public static final int MODE_SERVER_OUTBOUND = 6 ; public static final int MODE_SERVER_INBOUND = 7 ; protected volatile String targetTemplate ; protected volatile int mode ; public Redirector ( Context context , String targetTemplate ) { this ( context , targetTemplate , MODE_SERVER_OUTBOUND ) ; } public Redirector ( Context context , String targetPattern , int mode ) { super ( context ) ; this . targetTemplate = targetPattern ; this . mode = mode ; } public int getMode ( ) { return this . mode ; } protected Reference getTargetRef ( Request request , Response response ) { Template rt = new Template ( this . targetTemplate ) ; rt . setLogger ( getLogger ( ) ) ; if ( new Reference ( this . targetTemplate ) . isRelative ( ) ) { return new Reference ( request . getResourceRef ( ) , rt . format ( request , response ) ) ; } return new Reference ( rt . format ( request , response ) ) ; } public String getTargetTemplate ( ) { return this . targetTemplate ; } @ Override public void handle ( Request request , Response response ) { Reference targetRef = getTargetRef ( request , response ) ; switch ( this . mode ) { case MODE_CLIENT_PERMANENT : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Permanently redirecting client to: \" + targetRef ) ; } response . redirectPermanent ( targetRef ) ; break ; case MODE_CLIENT_FOUND : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Redirecting client to found location: \" + targetRef ) ; } response . setLocationRef ( targetRef ) ; response . setStatus ( Status . REDIRECTION_FOUND ) ; break ; case MODE_CLIENT_SEE_OTHER : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Redirecting client to another location: \" + targetRef ) ; } response . redirectSeeOther ( targetRef ) ; break ; case MODE_CLIENT_TEMPORARY : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Temporarily redirecting client to: \" + targetRef ) ; } response . redirectTemporary ( targetRef ) ; break ; case MODE_SERVER_OUTBOUND : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Redirecting via client dispatcher to: \" + targetRef ) ; } outboundServerRedirect ( targetRef , request , response ) ; break ; case MODE_SERVER_INBOUND : if ( request . isLoggable ( ) ) { getLogger ( ) . log ( Level . FINE , \"Redirecting via server dispatcher to: \" + targetRef ) ; } inboundServerRedirect ( targetRef , request , response ) ; break ; } } protected void inboundServerRedirect ( Reference targetRef , Request request , Response response ) { serverRedirect ( getContext ( ) . getServerDispatcher ( ) , targetRef , request , response ) ; } protected void outboundServerRedirect ( Reference targetRef , Request request , Response response ) { Restlet next = ( getApplication ( ) == null ) ? null : getApplication ( ) . getOutboundRoot ( ) ; if ( next == null ) { next = getContext ( ) . getClientDispatcher ( ) ; } serverRedirect ( next , targetRef , request , response ) ; if ( response . getEntity ( ) != null && ! request . getResourceRef ( ) . getScheme ( ) . equalsIgnoreCase ( targetRef . getScheme ( ) ) ) { response . getEntity ( ) . setLocationRef ( ( Reference ) null ) ; } } protected Representation rewrite ( Representation initialEntity ) { return initialEntity ; } protected void serverRedirect ( Restlet next , Reference targetRef , Request request , Response response ) { if ( next == null ) { getLogger ( ) . warning ( \"No next Restlet provided for server redirection to \" + targetRef ) ; } else { Reference resourceRef = request . getResourceRef ( ) ; Reference baseRef", "gt": "= resourceRef . getBaseRef ( ) ;", "prediction": "= request . getBaseRef ( ) ;\n", "label": 1}
{"id": 1285, "input": "<s> package org . ofbiz . widget . screen ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . Writer ; import javax . servlet . ServletContext ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilJ2eeCompat ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . webapp . view . AbstractViewHandler ; import org . ofbiz . webapp . view . ViewHandlerException ; import org . ofbiz . widget . form . FormStringRenderer ; import org . ofbiz . widget . form . MacroFormRenderer ; import org . ofbiz . widget . tree . TreeStringRenderer ; import org . ofbiz . widget . tree . MacroTreeRenderer ; import org . xml . sax . SAXException ; import freemarker . template . TemplateException ; import freemarker . template . utility . StandardCompress ; public class MacroScreenViewHandler extends AbstractViewHandler { public static final String module = MacroScreenViewHandler . class . getName ( ) ; protected ServletContext servletContext = null ; public void init ( ServletContext context ) throws ViewHandlerException { this . servletContext = context ; } public void render ( String name , String page , String info , String contentType , String encoding , HttpServletRequest request , HttpServletResponse response ) throws ViewHandlerException { Writer writer = null ; try { boolean useOutputStreamNotWriter = false ; if ( this . servletContext != null ) { useOutputStreamNotWriter = UtilJ2eeCompat . useOutputStreamNotWriter ( this . servletContext ) ; } if ( useOutputStreamNotWriter ) { ServletOutputStream ros = response . getOutputStream ( ) ; writer = new OutputStreamWriter ( ros , UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".default.contenttype\" , \"UTF-8\" ) ) ; } else { writer = response . getWriter ( ) ; } if ( UtilValidate . isEmpty ( encoding ) ) { encoding = UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".default.encoding\" , \"none\" ) ; } boolean compressOutput = \"compressed\" . equals ( encoding ) ; if ( ! compressOutput ) { compressOutput = \"true\" . equals ( UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".compress\" ) ) ; } if ( ! compressOutput && this . servletContext != null ) { compressOutput = \"true\" . equals ( this . servletContext . getAttribute ( \"compressHTML\" ) ) ; } if ( compressOutput ) { writer = new StandardCompress ( ) . getWriter ( writer , null ) ; } ScreenStringRenderer screenStringRenderer = new MacroScreenRenderer ( UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".name\" ) , UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".screenrenderer\" ) ) ; FormStringRenderer formStringRenderer = new MacroFormRenderer ( UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".formrenderer\" ) , request , response ) ; TreeStringRenderer treeStringRenderer = new MacroTreeRenderer ( UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".treerenderer\" ) , writer ) ; ScreenRenderer screens = new ScreenRenderer ( writer , null , screenStringRenderer ) ; screens . populateContextForRequest ( request , response , servletContext ) ; screens . getContext ( ) . put ( \"formStringRenderer\" , formStringRenderer ) ; screens . getContext ( ) . put ( \"treeStringRenderer\" , treeStringRenderer ) ; screens . getContext ( ) . put ( \"simpleEncoder\" , StringUtil . getEncoder ( UtilProperties . getPropertyValue ( \"widget\" , getName ( ) + \".encoder\" ) ) ) ; screenStringRenderer . renderScreenBegin ( writer ,", "gt": "screens . getContext ( ) ) ;", "prediction": "null ) ;\n", "label": 0}
{"id": 14095, "input": "<s> package org . spliffy . server . web ; import com . bradmcevoy . http . Auth ; import com . bradmcevoy . http . GetableResource ; import com . bradmcevoy . http . Range ; import com . bradmcevoy . http . Request ; import com . bradmcevoy . http . Request . Method ; import com . bradmcevoy . http . exceptions . BadRequestException ; import com . bradmcevoy . http . exceptions . NotAuthorizedException ; import com . bradmcevoy . http . exceptions . NotFoundException ; import com . ettrema . http . acl . Principal ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Date ; import java . util . List ; import java . util . Map ; import org . spliffy . server . db . BaseEntity ; import org . spliffy . server . db . Organisation ; import org . spliffy . server . db . Profile ; public class TemplatedTextPage extends AbstractResource implements GetableResource { protected final String name ; protected final SpliffyCollectionResource parent ; protected final String contentType ; protected final String template ; public TemplatedTextPage ( String name , SpliffyCollectionResource parent , Services services , String contentType , String template ) { super ( services ) ; this . name = name ; this . parent = parent ; this . contentType = contentType ; this . template = template ; } @ Override public boolean authorise ( Request request , Method method , Auth auth ) { return true ; } @ Override public void sendContent ( OutputStream out , Range range , Map < String , String > params , String contentType ) throws IOException , NotAuthorizedException , BadRequestException , NotFoundException { System . out . println ( \"template: \" + template ) ; services . getTextTemplater ( ) . writePage ( template , this , params , out ) ; } @ Override public Long getContentLength ( ) { return null ; } @ Override public String getContentType ( String accepts ) { return contentType ; } @ Override public boolean isDir ( ) { return false ; } @ Override public SpliffyCollectionResource getParent ( ) { return parent ; } @ Override public BaseEntity getOwner ( ) { return parent . getOwner ( ) ; } @ Override public Organisation getOrganisation ( ) { return parent . getOrganisation ( ) ; } @ Override public void addPrivs ( List < Priviledge > list , Profile user ) { parent . addPrivs ( list , user ) ; } @", "gt": "Override public String getName ( )", "prediction": "Override public void removePrivs ( List < Priviledge > list , Profile user )\n", "label": 1}
{"id": 8031, "input": "<s> package org . json ; import java . util . Iterator ; public class XML { public static final Character AMP = new Character ( '&' ) ; public static final Character APOS = new Character ( '\\'' ) ; public static final Character BANG = new Character ( '!' ) ; public static final Character EQ = new Character ( '=' ) ; public static final Character GT = new Character ( '>' ) ; public static final Character LT = new Character ( '<' ) ; public static final Character QUEST = new Character ( '?' ) ; public static final Character QUOT = new Character ( '\"' ) ; public static final Character SLASH = new Character ( '/' ) ; public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case '&' : sb . append ( \"&amp;\" ) ; break ; case '<' : sb . append ( \"&lt;\" ) ; break ; case '>' : sb . append ( \"&gt;\" ) ; break ; case '\"' : sb . append ( \"&quot;\" ) ; break ; case '\\'' : sb . append ( \"&apos;\" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; } public static void noSpace ( String string ) throws JSONException { int i , length = string . length ( ) ; if ( length == 0 ) { throw new JSONException ( \"Empty string.\" ) ; } for ( i = 0 ; i < length ; i += 1 ) { if ( Character . isWhitespace ( string . charAt ( i ) ) ) { throw new JSONException ( \"'\" + string + \"' contains a space character.\" ) ; } } } private static boolean parse ( XMLTokener x , JSONObject context , String name ) throws JSONException { char c ; int i ; JSONObject jsonobject = null ; String string ; String tagName ; Object token ; token = x . nextToken ( ) ; if ( token == BANG ) { c = x . next ( ) ; if ( c == '-' ) { if ( x . next ( ) == '-' ) { x . skipPast ( \"-->\" ) ; return false ; } x . back ( ) ; } else if ( c == '[' ) { token = x . nextToken ( ) ; if ( \"CDATA\" . equals ( token ) ) { if ( x . next ( ) == '[' ) { string = x . nextCDATA ( ) ; if ( string . length ( ) > 0 ) { context . accumulate ( \"content\" , string ) ; } return false ; } } throw x . syntaxError ( \"Expected 'CDATA['\" ) ; } i = 1 ; do { token = x . nextMeta ( ) ; if ( token == null ) { throw x . syntaxError ( \"Missing '>' after '<!'.\" ) ; } else if ( token == LT ) { i += 1 ; } else if ( token == GT ) { i -= 1 ; } } while ( i > 0 ) ; return false ; } else if ( token == QUEST ) { x . skipPast ( \"?>\" ) ; return false ; } else if ( token == SLASH ) { token = x . nextToken ( ) ; if ( name == null ) { throw x . syntaxError ( \"Mismatched close tag \" + token ) ; } if ( ! token . equals ( name ) ) { throw x . syntaxError ( \"Mismatched \" + name + \" and \" + token ) ; } if ( x . nextToken ( ) != GT ) { throw x . syntaxError ( \"Misshaped close tag\" ) ; } return true ; } else if ( token instanceof Character ) { throw x . syntaxError ( \"Misshaped tag\" ) ; } else { tagName = ( String ) token ; token = null ; jsonobject = new JSONObject ( ) ; for ( ; ; ) { if ( token == null ) { token = x . nextToken ( ) ; } if ( token instanceof String ) { string = ( String ) token ; token = x . nextToken ( ) ; if ( token == EQ ) { token = x . nextToken ( ) ; if ( ! ( token instanceof String ) ) { throw x . syntaxError ( \"Missing value\" ) ; } jsonobject . accumulate ( string , XML . stringToValue ( ( String ) token ) ) ; token = null ; } else { jsonobject . accumulate ( string , \"\" ) ; } } else if ( token == SLASH ) { if ( x . nextToken ( ) != GT ) { throw x . syntaxError ( \"Misshaped tag\" ) ; } if (", "gt": "jsonobject . length ( ) > 0 )", "prediction": "! token . equals ( name ) )\n", "label": 0}
{"id": 14096, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . File ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . ArrayList ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IOUtils ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; public class MySQLAuthTest extends ImportJobTestCase { public static final Log LOG = LogFactory . getLog ( MySQLAuthTest . class . getName ( ) ) ; static final String HOST_URL = System . getProperty ( \"sqoop.test.mysql.connectstring.host_url\" , \"jdbc:mysql://localhost/\" ) ; static final String AUTH_TEST_DATABASE = \"sqooppasstest\" ; static final String AUTH_TEST_USER = \"sqooptest\" ; static final String AUTH_TEST_PASS = \"12345\" ; static final String AUTH_TABLE_NAME = \"authtest\" ; static final String AUTH_CONNECT_STRING = HOST_URL + AUTH_TEST_DATABASE ; private DirectMySQLManager manager ; @ Override protected boolean useHsqldbTestServer ( ) { return false ; } @ Before public void setUp ( ) { super . setUp ( ) ; SqoopOptions options = new SqoopOptions ( AUTH_CONNECT_STRING , AUTH_TABLE_NAME ) ; options . setUsername ( AUTH_TEST_USER ) ; options . setPassword ( AUTH_TEST_PASS ) ; LOG . debug ( \"Setting up another MySQLAuthTest: \" + AUTH_CONNECT_STRING ) ; manager = new DirectMySQLManager ( options ) ; Connection connection = null ; Statement st = null ; try { connection = manager . getConnection ( ) ; connection . setAutoCommit ( false ) ; st = connection . createStatement ( ) ; st . executeUpdate ( \"DROP TABLE IF EXISTS \" + AUTH_TABLE_NAME ) ; st . executeUpdate ( \"CREATE TABLE \" + AUTH_TABLE_NAME + \" (\" + \"id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, \" + \"name VARCHAR(24) NOT NULL)\" ) ; st . executeUpdate ( \"INSERT INTO \" + AUTH_TABLE_NAME + \" VALUES(\" + \"NULL,'Aaron')\" ) ; connection . commit ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Encountered SQL Exception: \" + sqlE ) ; sqlE . printStackTrace ( ) ; fail ( \"SQLException when running test setUp(): \" + sqlE ) ; } finally { try { if ( null != st ) { st . close ( ) ; } if ( null != connection ) { connection . close ( ) ; } } catch ( SQLException sqlE ) { LOG . warn ( \"Got SQLException when closing connection: \" + sqlE ) ; } } } @ After public void tearDown ( ) { super . tearDown ( ) ; try { manager . close ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Got SQLException: \" + sqlE . toString ( ) ) ; fail ( \"Got SQLException: \" + sqlE . toString ( ) ) ; } } private String [ ] getArgv ( boolean includeHadoopFlags , boolean useDirect , String connectString , String tableName ) { ArrayList < String > args = new ArrayList < String > ( ) ; if ( includeHadoopFlags ) { CommonArgs . addHadoopFlags ( args ) ; } args . add ( \"--table\" ) ; args . add ( tableName ) ; args . add ( \"--warehouse-dir\" ) ;", "gt": "args . add ( getWarehouseDir ( ) ) ;", "prediction": "args . add ( tableName ) ;\n", "label": 1}
{"id": 8086, "input": "<s> package org . parboiled . trees ; import java . util . List ; public interface GraphNode <", "gt": "T extends GraphNode < T > >", "prediction": "T >\n", "label": 0}
{"id": 14112, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class VerifyEvent extends KeyEvent { private static final long serialVersionUID = 1L ; public String text ; public int start , end ; public VerifyEvent ( Event event ) { super ( event ) ; this . start = event . start ; this . end = event . end ; this . text = event . text ; } @ Override public String toString ( ) {", "gt": "String string = super . toString ( ) ;", "prediction": "return text ;\n", "label": 1}
{"id": 8869, "input": "<s> package org . papaours . yama . model . questiontext ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlSeeAlso ; import javax . xml . bind . annotation . XmlTransient ; import org . eclipse . persistence . oxm . annotations . XmlDiscriminatorNode ; import universite . toulouse . moodlexmlapi . core . data . QuestionTextFormat ; @ XmlSeeAlso ( { YamaHtmlQuestionText . class , YamaMarkdownQuestionText . class , YamaMoodleAutoFormatQuestionText . class , YamaPlainTextQuestionText . class } ) @ XmlDiscriminatorNode ( \"@format\" ) public class YamaGenericQuestionText { private String questionText ; public YamaGenericQuestionText ( ) { } public YamaGenericQuestionText ( final String theQuestionText ) { this . questionText = theQuestionText ; } @ XmlElement public String getText ( ) { return questionText ; } public void setText ( final String text ) { this", "gt": ". questionText = text ;", "prediction": ". text = text ;\n", "label": 0}
{"id": 14113, "input": "<s> package utility ; import org . lwjgl . input . Keyboard ; import org . lwjgl . input . Mouse ; import org . lwjgl . opengl . GLContext ; import org . lwjgl . util . glu . GLU ; import static java . lang . Math . * ; import static org . lwjgl . opengl . ARBDepthClamp . GL_DEPTH_CLAMP ; import static org . lwjgl . opengl . GL11 . * ; public final class EulerCamera implements Camera { private float x = 0 ; private float y = 0 ; private float z = 0 ; private float pitch = 0 ; private float yaw = 0 ; private float roll = 0 ; private float fov = 90 ; private float aspectRatio = 1 ; private final float zNear ; private final float zFar ; public EulerCamera ( Builder builder ) { this . x = builder . x ; this . y = builder . y ; this . z = builder . z ; this . pitch = builder . pitch ; this . yaw = builder . yaw ; this . roll = builder . roll ; this . aspectRatio = builder . aspectRatio ; this . zNear = builder . zNear ; this . zFar = builder . zFar ; this . fov = builder . fov ; } public EulerCamera ( ) { this . zNear = 0.3f ; this . zFar = 100 ; } public EulerCamera ( float aspectRatio ) { if ( aspectRatio <= 0 ) { throw new IllegalArgumentException ( \"aspectRatio \" + aspectRatio + \" was 0 or was smaller than 0\" ) ; } this . aspectRatio = aspectRatio ; this . zNear = 0.3f ; this . zFar = 100 ; } public EulerCamera ( float aspectRatio , float x , float y , float z ) { this ( aspectRatio ) ; this . x = x ; this . y = y ; this . z = z ; } public EulerCamera ( float aspectRatio , float x , float y , float z , float pitch , float yaw , float roll ) { this ( aspectRatio , x , y , z ) ; this . pitch = pitch ; this . yaw = yaw ; this . roll = roll ; } public EulerCamera ( float aspectRatio , float x , float y , float z , float pitch , float yaw , float roll , float zNear , float zFar ) { if ( aspectRatio <= 0 ) { throw new IllegalArgumentException ( \"aspectRatio \" + aspectRatio + \" was 0 or was smaller than 0\" ) ; } if ( zNear <= 0 ) { throw new IllegalArgumentException ( \"zNear \" + zNear + \" was 0 or was smaller than 0\" ) ; } if ( zFar <= zNear ) { throw new IllegalArgumentException ( \"zFar \" + zFar + \" was smaller or the same as zNear \" + zNear ) ; } this . aspectRatio = aspectRatio ; this . x = x ; this . y = y ; this . z = z ; this . pitch = pitch ; this . yaw = yaw ; this . roll = roll ; this . zNear = zNear ; this . zFar = zFar ; } public void processMouse ( ) { final float MAX_LOOK_UP = 90 ; final float MAX_LOOK_DOWN = - 90 ; float mouseDX = Mouse . getDX ( ) * 0.16f ; float mouseDY = Mouse . getDY ( ) * 0.16f ; if ( yaw + mouseDX >= 360 ) { yaw", "gt": "= yaw + mouseDX - 360 ;", "prediction": "+= mouseDX ;\n", "label": 1}
{"id": 6093, "input": "<s> import java . io . File ; import java . util . Arrays ; import javax . tools . * ; import javax . tools . JavaFileManager . Location ; import static javax . tools . StandardLocation . CLASS_OUTPUT ; public class T6397104 { JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; void test ( StandardJavaFileManager fm , Location location , File siblingFile , String relName , String expectedPath ) throws Exception { JavaFileObject sibling = siblingFile == null ? null : fm . getJavaFileObjectsFromFiles ( Arrays . asList ( siblingFile ) ) . iterator ( ) . next ( ) ; FileObject fileObject = fm . getFileForOutput ( location , \"java.lang\" , relName , sibling ) ; if ( ! fileObject . toUri ( ) . getPath ( ) . equals ( expectedPath ) ) throw new AssertionError ( \"Expected \" + expectedPath + \", got \" + fileObject . toUri ( ) . getPath ( ) ) ; System . out . format ( \"OK: (%s, %s) => %s%n\" , siblingFile , relName , fileObject . toUri ( ) ) ; } void test ( boolean hasLocation , File siblingFile , String relName , String expectedPath ) throws Exception { StandardJavaFileManager fm ; if ( hasLocation ) { for ( Location location : StandardLocation . values ( ) ) { fm = tool . getStandardFileManager ( null , null , null ) ; fm . setLocation ( location , Arrays", "gt": ". asList ( new File ( \".\" ) ) ) ;", "prediction": ". asList ( siblingFile ) ) ;\n", "label": 0}
{"id": 14116, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public abstract class CmapFormat { protected int format ; protected int length ; protected int version ; protected CmapFormat ( RandomAccessFile raf ) throws IOException { length = raf . readUnsignedShort ( ) ; version = raf . readUnsignedShort ( ) ; } protected static CmapFormat create ( int format , RandomAccessFile raf ) throws IOException { switch ( format ) { case 0 : return new CmapFormat0 ( raf ) ; case 2 : return new CmapFormat2 ( raf ) ; case 4 : return new CmapFormat4 ( raf ) ; case", "gt": "6 : return new CmapFormat6 ( raf ) ;", "prediction": "6 : return new CmapFormat6 ( raf ) ;\n", "label": 1}
{"id": 8590, "input": "<s> package ar . com . fdvs . dj . domain . chart . builder ; import ar . com . fdvs . dj . domain . builders . ChartBuilderException ; import ar . com . fdvs . dj . domain . chart . DJChart ; public abstract class AbstractChartBuilder { protected DJChart chart ; public AbstractChartBuilder ( ) { chart = new DJChart ( getChartType ( ) ) ; } protected abstract byte getChartType ( ) ; public DJChart", "gt": "build ( ) throws ChartBuilderException", "prediction": "( )\n", "label": 0}
{"id": 14123, "input": "<s> package org . eclipse . ui . tests . keys ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . jface . bindings . Binding ; import org . eclipse . jface . bindings . TriggerSequence ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . keys . IBindingService ; import org . eclipse . ui . tests . harness . util . UITestCase ; public class Bug36537Test extends UITestCase { public Bug36537Test ( String name ) { super ( name ) ; } public void testForRedundantKeySequenceBindings ( ) { final IWorkbenchWindow window = openTestWindow ( ) ; final IWorkbench workbench = window . getWorkbench ( ) ; final IBindingService bindingService = ( IBindingService ) workbench . getAdapter ( IBindingService . class ) ; final Binding [ ] bindings = bindingService . getBindings ( ) ; final int bindingCount = bindings . length ; Map keySequenceBindingsByKeySequence = new HashMap ( ) ; for ( int i = 0 ; i < bindingCount ; i ++ ) { final Binding binding = bindings [ i ] ; TriggerSequence triggerSequence = binding . getTriggerSequence ( ) ; List matches = ( List ) keySequenceBindingsByKeySequence . get ( triggerSequence ) ; if ( matches == null ) { matches = new ArrayList ( ) ; keySequenceBindingsByKeySequence . put ( triggerSequence , matches ) ; } Iterator matchItr = matches . iterator ( ) ; while ( matchItr . hasNext ( ) ) { final Binding matchedBinding = ( Binding ) matchItr . next ( ) ; ParameterizedCommand commandA = binding . getParameterizedCommand ( ) ; ParameterizedCommand commandB = matchedBinding . getParameterizedCommand ( ) ; String contextA = binding . getContextId ( ) ; String contextB = matchedBinding . getContextId ( ) ; String keyConfA = binding . getSchemeId ( ) ; String keyConfB = matchedBinding . getSchemeId ( ) ; String localeA = binding . getLocale ( ) ; String localeB = matchedBinding . getLocale ( ) ; String platformA = binding . getPlatform ( ) ; String platformB = matchedBinding . getPlatform ( ) ; boolean same = true ; int nullMatches = 0 ; same &= ( commandA == null ) ? ( commandB == null ) : ( commandA . equals ( commandB ) ) ; same &= ( contextA == null ) || ( contextB == null ) || ( contextA . equals ( contextB ) ) ; if ( ( ( contextA == null ) || ( contextB == null ) ) && ( contextA != contextB ) ) { nullMatches ++ ; } same &= ( keyConfA == null ) || ( keyConfB == null ) || ( keyConfA . equals ( keyConfB ) ) ; if ( ( ( keyConfA == null ) || ( keyConfB == null ) ) && ( keyConfA != keyConfB ) ) { nullMatches ++ ; } same &= ( localeA == null ) || ( localeB == null ) || ( localeA . equals ( localeB ) ) ; if ( ( ( localeA == null ) || ( localeB == null ) ) && ( localeA != localeB ) ) { nullMatches ++ ; } same &= ( platformA == null ) || ( platformB == null ) || ( platformA . equals ( platformB ) ) ; if ( ( ( platformA == null ) || ( platformB", "gt": "== null ) ) && ( platformA != platformB ) )", "prediction": "== null ) ) && ( platformA != platformB ) )\n", "label": 1}
{"id": 5866, "input": "<s> import com . sun . tools . javac . code . Type ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . code . Symbol . * ; import java . lang . reflect . Array ; import java . util . EnumSet ; public class BoxingConversionTest extends TypeHarness { Type [ ] types1 ; Type [ ] types2 ; Type [ ] types3 ; enum Result { OK_BOTH ( true ) , FAIL_BOTH ( false ) , OK_ASSIGN_ONLY ( true ) ; boolean value ; Result ( boolean value ) { this . value = value ; } } enum ConversionKind { ASSIGNMENT_CONVERSION ( EnumSet . of ( Result . OK_BOTH , Result . OK_ASSIGN_ONLY ) ) { @ Override void check ( TypeHarness harness , Type from , Type to , Result expected ) { harness . assertAssignable ( from , to , resSet . contains ( expected ) ) ; } } , METHOD_CONVERSION ( EnumSet . of ( Result . OK_BOTH ) ) { @ Override void check ( TypeHarness harness , Type from , Type to , Result expected ) { harness . assertConvertible ( from , to , resSet . contains ( expected ) ) ; } } ; EnumSet < Result > resSet ; private ConversionKind ( EnumSet < Result > resSet ) { this . resSet = resSet ; } abstract void check ( TypeHarness harness , Type from , Type to , Result expected ) ; } enum TestKind { SIMPLE { @ Override Type [ ] getFromTypes ( BoxingConversionTest harness ) { return harness . types1 ; } @ Override Type [ ] getToTypes ( BoxingConversionTest harness ) { return harness . types1 ; } @ Override Result [ ] [ ] getResults ( BoxingConversionTest harness ) { return harness . results1 ; } } , CONSTANT_TYPES { @ Override Type [ ] getFromTypes ( BoxingConversionTest harness ) { return harness . types2 ; } @ Override Type [ ] getToTypes ( BoxingConversionTest harness ) { return harness . types3 ; } @ Override Result [ ] [ ] getResults ( BoxingConversionTest harness ) { return harness . results2 ; } } ; abstract Type [ ] getFromTypes ( BoxingConversionTest harness ) ; abstract Type [ ] getToTypes ( BoxingConversionTest harness ) ; abstract Result [ ] [ ] getResults ( BoxingConversionTest harness ) ; } static final Result T = Result . OK_BOTH ; static", "gt": "final Result F = Result . FAIL_BOTH ;", "prediction": "final Result T = Result . FAIL_BOTH ;\n", "label": 0}
{"id": 14125, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import java . util . List ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . DocumentModelListImpl ; import org . nuxeo . ecm . webapp . documentsLists . DocumentsListsManager ; @ Operation ( id = GetSelectedDocuments . ID , category = Constants . CAT_FETCH , requires = Constants . SEAM_CONTEXT , label = \"UI Selected documents\" , description = \"Fetch the documents selected in the", "gt": "current folder listing\" ) public class GetSelectedDocuments", "prediction": "list\" ) public class DocumentsListsManager implements DocumentModelListImpl\n", "label": 1}
{"id": 2453, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . JournalAttributes ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class JournalAttributesTest extends XtextTest { @ Test public void testNone ( ) { testParserRule ( \"journalattributes -\" , getRule ( ) ) ; } @ Test public void testAll ( ) { testParserRule ( \"journalattributes *\" , getRule ( ) ) ; } @ Test public void testSome1 ( ) { testParserRule ( \"journalattributes flags property details author\" , getRule ( ) ) ; } @ Test public void testSome2 ( ) { testParserRule ( \"journalattributes headline date timesheet\" , getRule ( ) ) ; } @ Test public void testSome3 ( ) {", "gt": "testParserRule ( \"journalattributes propertyid summary\" , getRule ( ) ) ;", "prediction": "try\n", "label": 0}
{"id": 14127, "input": "<s> package org . jscsi . scsi . protocol . sense ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; public enum SenseKey { NO_SENSE ( 0x00 ) , RECOVERED_ERROR ( 0x01 ) , NOT_READY ( 0x02 ) , MEDIUM_ERROR ( 0x03 ) , HARDWARE_ERROR ( 0x04 ) , ILLEGAL_REQUEST ( 0x05 ) , UNIT_ATTENTION ( 0x06 ) , DATA_PROTECT ( 0x07 ) , BLANK_CHECK ( 0x08 ) , VENDOR_SPECIFIC ( 0x09 ) , COPY_ABORTED ( 0x0A ) , ABORTED_COMMAND ( 0x0B ) , VOLUME_OVERFLOW ( 0x0D ) , MISCOMPARE ( 0x0E ) ; private final int value ; private static Map < Integer , SenseKey > mapping ; private SenseKey", "gt": "( final int value )", "prediction": "key ;\n", "label": 1}
{"id": 3579, "input": "<s> package org . bombusim . lime . data ; public class SelfContact extends Contact { public SelfContact ( String jid , String name , long id ) { super ( jid , name , id ) ; } @ Override public int getSubscription ( ) { return SUBSCR_BOTH ; } @ Override public String getAllGroups ( ) { return null ; } @ Override", "gt": "public void setUpdate ( int upd )", "prediction": "public void setSubscription ( String jid )\n", "label": 0}
{"id": 14133, "input": "<s> package org . apache . lucene . queryParser . standard . processors ; import java . util . List ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . core . nodes . FieldQueryNode ; import org . apache . lucene . queryParser . core . nodes . FuzzyQueryNode ; import org . apache . lucene . queryParser . core . nodes . ParametricQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . core . processors . QueryNodeProcessorImpl ; import org . apache . lucene . queryParser . core . util . UnescapedCharSequence ; import org . apache . lucene . queryParser . standard . config . LowercaseExpandedTermsAttribute ; import org . apache . lucene . queryParser . standard . nodes . WildcardQueryNode ; public class LowercaseExpandedTermsQueryNodeProcessor extends QueryNodeProcessorImpl { public LowercaseExpandedTermsQueryNodeProcessor ( ) { } public QueryNode process ( QueryNode queryTree ) throws QueryNodeException { if (", "gt": "getQueryConfigHandler ( ) . hasAttribute ( LowercaseExpandedTermsAttribute . class ) )", "prediction": "queryTree == null )\n", "label": 1}
{"id": 3653, "input": "<s> import jns . Simulator ; import jns . agent . MPTCP ; import jns . agent . MPTCPAgent ; import jns . agent . RandomSink ; import jns . agent . RandomSource ; import jns . command . StopCommand ; import jns . element . * ; import jns . trace . JavisTrace ; import jns . trace . Trace ; import jns . util . IPAddr ; import jns . util . Preferences ; import jns . util . Protocols ; import java . io . IOException ; public class Test_MPTCP { public static void main ( String args [ ] ) { Preferences . mode = 2 ; Trace trace = null ; try { trace = new JavisTrace ( \"test_mptcp.jvs\" ) ; } catch ( IOException e ) { System . out . println ( \"Could not create test_mptcp.jvs!\" ) ; } Simulator sim = Simulator . getInstance ( ) ; sim . setTrace ( trace ) ; Node A = new Node ( \"A\" ) ; sim . attachWithTrace ( A , trace ) ; Node B = new Node ( \"B\" ) ; sim . attachWithTrace ( B , trace ) ; Node C = new Node ( \"C\" ) ; sim . attachWithTrace ( C , trace ) ; Node D = new Node ( \"D\" ) ; sim . attachWithTrace ( D , trace ) ; Node E = new Node ( \"E\" ) ; sim . attachWithTrace ( E , trace ) ; Node F = new Node ( \"F\" ) ; sim . attachWithTrace ( F , trace ) ; Node G = new Node ( \"G\" ) ; sim . attachWithTrace ( G , trace ) ; Node H = new Node ( \"H\" ) ; sim . attachWithTrace ( H , trace ) ; Interface ABIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 1 ) ) ; A . attach ( ABIface ) ; sim . attachWithTrace ( ABIface , trace ) ; Interface ACIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 10 ) ) ; A . attach ( ACIface ) ; sim . attachWithTrace ( ACIface , trace ) ; Interface ADIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 20 ) ) ; A . attach ( ADIface ) ; sim . attachWithTrace ( ADIface , trace ) ; Interface BAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BAIface ) ; sim . attachWithTrace ( BAIface , trace ) ; Interface BEIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 2 ) ) ; B . attach ( BEIface ) ; sim . attachWithTrace ( BEIface , trace ) ; Interface CAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CAIface ) ; sim . attachWithTrace ( CAIface , trace ) ; Interface CFIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 3 ) ) ; C . attach ( CFIface ) ; sim . attachWithTrace ( CFIface , trace ) ; Interface DAIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DAIface ) ; sim . attachWithTrace ( DAIface , trace ) ; Interface DGIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 4 ) ) ; D . attach ( DGIface ) ; sim . attachWithTrace ( DGIface , trace ) ; Interface EBIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 5 ) ) ; E . attach ( EBIface ) ; sim . attachWithTrace ( EBIface , trace ) ; Interface EHIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 5 ) ) ; E . attach ( EHIface ) ; sim . attachWithTrace ( EHIface , trace ) ; Interface FCIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 6 ) ) ; F . attach ( FCIface ) ; sim . attachWithTrace ( FCIface , trace ) ; Interface FHIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 6 ) ) ; F . attach ( FHIface ) ; sim . attachWithTrace ( FHIface , trace ) ; Interface GDIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 7 ) ) ; G . attach ( GDIface ) ; sim . attachWithTrace ( GDIface , trace ) ; Interface GHIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 7 ) ) ; G . attach ( GHIface ) ; sim . attachWithTrace ( GHIface , trace ) ; Interface HEIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 8 ) ) ; H . attach ( HEIface ) ; sim . attachWithTrace ( HEIface , trace ) ; Interface HFIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 90 ) ) ; H . attach ( HFIface ) ; sim . attachWithTrace ( HFIface , trace ) ; Interface HGIface = new DuplexInterface ( new IPAddr ( 192 , 168 , 0 , 100 ) ) ; H . attach ( HGIface ) ; sim . attachWithTrace ( HGIface , trace ) ; Link ab = new DuplexLink ( 500000 , 0.008 ) ; Link ac = new DuplexLink ( 500000 , 0.008 ) ; Link ad = new DuplexLink ( 500000 , 0.008 ) ; Link be = new DuplexLink ( 500000 , 0.008 ) ; Link cf = new DuplexLink ( 500000 , 0.008 ) ; Link dg = new DuplexLink ( 500000 , 0.008 ) ; Link eh = new DuplexLink ( 500000 , 0.008 ) ; Link fh = new DuplexLink ( 500000 , 0.008 ) ; Link gh = new DuplexLink ( 500000 , 0.008 ) ; ABIface . attach ( ab , true ) ; ACIface . attach ( ac , true ) ; ADIface . attach ( ad , true ) ; BAIface . attach ( ab , true ) ; BEIface . attach ( be , true ) ; CAIface . attach ( ac , true ) ; CFIface . attach ( cf , true ) ; DAIface . attach ( ad , true ) ; DGIface . attach ( dg , true ) ; EBIface .", "gt": "attach ( be , true ) ;", "prediction": "attach ( ad , true ) ;\n", "label": 0}
{"id": 14138, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . File ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . Statement ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . ArrayList ; import java . text . ParseException ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . IOUtils ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . testutil . CommonArgs ; import com . cloudera . sqoop . testutil . ImportJobTestCase ; import com . cloudera . sqoop . util . FileListing ; public class OracleManagerTest extends ImportJobTestCase { public static final Log LOG = LogFactory . getLog ( OracleManagerTest . class . getName ( ) ) ; static final String TABLE_NAME = \"EMPLOYEES\" ; static final String SECONDARY_TABLE_NAME = \"CUSTOMER\" ; static final String QUALIFIED_SECONDARY_TABLE_NAME = OracleUtils . ORACLE_SECONDARY_USER_NAME + \".\" + SECONDARY_TABLE_NAME ; private static final String [ ] MAIN_TABLE_SQL_STMTS = new String [ ] { \"CREATE TABLE \" + TABLE_NAME + \" (\" + \"id INT NOT NULL, \" + \"name VARCHAR2(24) NOT NULL, \" + \"start_date DATE, \" + \"salary FLOAT, \" + \"dept VARCHAR2(32), \" + \"timestamp_tz TIMESTAMP WITH TIME ZONE, \" + \"timestamp_ltz TIMESTAMP WITH LOCAL TIME ZONE, \" + \"PRIMARY KEY (id))\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"1,'Aaron',to_date('2009-05-14','yyyy-mm-dd'),\" + \"1000000.00,'engineering','29-DEC-09 12.00.00.000000000 PM',\" + \"'29-DEC-09 12.00.00.000000000 PM')\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"2,'Bob',to_date('2009-04-20','yyyy-mm-dd'),\" + \"400.00,'sales','30-DEC-09 12.00.00.000000000 PM',\" + \"'30-DEC-09 12.00.00.000000000 PM')\" , \"INSERT INTO \" + TABLE_NAME + \" VALUES(\" + \"3,'Fred',to_date('2009-01-23','yyyy-mm-dd'),15.00,\" + \"'marketing','31-DEC-09 12.00.00.000000000 PM',\" + \"'31-DEC-09 12.00.00.000000000 PM')\" , } ; private static final String [ ] SECONDARY_TABLE_SQL_STMTS = new String [ ] { \"CREATE TABLE \" + SECONDARY_TABLE_NAME + \" (\" + \"id INT NOT NULL, \" + \"name VARCHAR2(24) NOT NULL, \" + \"PRIMARY KEY (id))\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"1,'MercuryCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"2,'VenusCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"3,'EarthCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"4,'MarsCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"5,'JupiterCorp')\" , \"INSERT INTO \" + SECONDARY_TABLE_NAME + \" VALUES(\" + \"6,'SaturnCorp')\" , \"GRANT SELECT, INSERT ON \" + SECONDARY_TABLE_NAME + \" TO \" + OracleUtils . ORACLE_USER_NAME , } ; private OracleManager manager ; @ Override protected boolean useHsqldbTestServer ( ) { return false ; } private void executeUpdates ( OracleManager mgr , String [ ] sqlStmts ) { Connection connection = null ; Statement st = null ; try { connection = mgr . getConnection ( ) ; connection . setAutoCommit ( false ) ; st = connection . createStatement ( ) ; for ( String sql : sqlStmts ) { st . executeUpdate ( sql ) ; } connection . commit ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Encountered SQL Exception: \" + sqlE ) ; sqlE . printStackTrace ( ) ; fail ( \"SQLException when running test setUp(): \" + sqlE ) ; } finally { try { if ( null != st ) { st . close ( ) ; } if ( null != connection ) { connection . close ( ) ; } } catch ( SQLException sqlE ) { LOG . warn ( \"Got SQLException when closing connection: \" + sqlE ) ; } } } private void provisionSecondaryTable ( ) { SqoopOptions options = new SqoopOptions ( OracleUtils . CONNECT_STRING , SECONDARY_TABLE_NAME ) ; OracleUtils . setOracleSecondaryUserAuth ( options ) ; OracleManager mgr = new OracleManager ( options ) ; try { OracleUtils . dropTable ( SECONDARY_TABLE_NAME , mgr ) ; } catch ( SQLException sqlE ) { fail ( \"Could not drop table \" + SECONDARY_TABLE_NAME + \": \" + sqlE ) ; } executeUpdates ( mgr , SECONDARY_TABLE_SQL_STMTS ) ; try { mgr . close ( ) ; } catch ( SQLException sqlE ) { fail ( \"Failed to close secondary manager instance : \" + sqlE ) ; } } @ Before public void setUp ( ) { super . setUp ( ) ; provisionSecondaryTable ( ) ; SqoopOptions options = new SqoopOptions ( OracleUtils . CONNECT_STRING , TABLE_NAME ) ; OracleUtils . setOracleAuth ( options ) ; manager = new OracleManager ( options ) ; options . getConf ( ) . set ( \"oracle.sessionTimeZone\" , \"US/Pacific\" ) ; try { OracleUtils . dropTable ( TABLE_NAME , manager ) ; } catch ( SQLException sqlE ) { fail ( \"Could not drop table \" + TABLE_NAME + \": \" + sqlE ) ; } executeUpdates ( manager , MAIN_TABLE_SQL_STMTS ) ; } @ After public void tearDown ( ) { super . tearDown ( ) ; try { manager . close ( ) ; } catch ( SQLException sqlE ) { LOG . error ( \"Got SQLException: \" + sqlE . toString ( ) ) ; fail ( \"Got SQLException: \" + sqlE . toString ( ) ) ; } } private String [ ] getArgv ( ) { return getArgv ( TABLE_NAME ) ; } private String [ ] getArgv ( String tableName ) { ArrayList < String > args = new ArrayList < String > ( ) ; CommonArgs . addHadoopFlags ( args ) ; args . add ( \"-D\" ) ; args . add ( \"oracle.sessionTimeZone=US/Pacific\" ) ; args . add ( \"--table\" ) ; args . add ( tableName ) ; args . add ( \"--warehouse-dir\" ) ; args . add ( getWarehouseDir ( ) ) ; args . add ( \"--connect\" ) ; args . add ( OracleUtils . CONNECT_STRING ) ; args . add ( \"--username\" ) ; args . add ( OracleUtils . ORACLE_USER_NAME ) ; args . add ( \"--password\" ) ; args . add ( OracleUtils . ORACLE_USER_PASS ) ; args . add ( \"--num-mappers\" ) ; args . add ( \"1\" ) ; return", "gt": "args . toArray ( new String [ 0 ] ) ;", "prediction": "args ;\n", "label": 1}
{"id": 9492, "input": "<s> class T4717164 { public static void main ( String [ ] args ) { try { try { throw new ClassNotFoundException ( ) ; } catch ( ClassNotFoundException e ) { throw e ; } finally { return ; } }", "gt": "catch ( ClassNotFoundException e1 )", "prediction": "}\n", "label": 0}
{"id": 14143, "input": "<s> package org . eclipse . swt . internal . widgets . menuitemkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . internal . widgets . ItemLCAUtil ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; final class MenuItemLCAUtil { private static final String TYPE = \"rwt.widgets.MenuItem\" ; private static final String [ ] ALLOWED_STYLES = new String [ ] { \"CHECK\" , \"CASCADE\" , \"PUSH\" , \"RADIO\" , \"SEPARATOR\" } ; private static final String PROP_MENU = \"menu\" ; private static final String PROP_ENABLED = \"enabled\" ; private static final String PROP_SELECTION = \"selection\" ; private static final String PROP_SELECTION_LISTENER = \"selection\" ; static void preserveValues ( MenuItem item ) { WidgetLCAUtil . preserveCustomVariant ( item ) ; ItemLCAUtil . preserve ( item ) ; preserveProperty ( item , PROP_MENU , item . getMenu ( ) ) ; preserveProperty ( item , PROP_ENABLED , item . getEnabled ( ) ) ; preserveProperty ( item , PROP_SELECTION , item . getSelection ( ) ) ; preserveListener ( item , PROP_SELECTION_LISTENER , SelectionEvent . hasListener ( item ) ) ; WidgetLCAUtil . preserveHelpListener ( item ) ; } static void renderInitialization ( MenuItem item ) { IClientObject clientObject = ClientObjectFactory . getClientObject ( item ) ; clientObject . create ( TYPE ) ; Menu parent = item . getParent ( ) ; clientObject . set ( \"parent\" , WidgetUtil . getId ( parent ) ) ; clientObject . set ( \"style\" , WidgetLCAUtil . getStyles ( item , ALLOWED_STYLES ) ) ; clientObject . set ( \"index\" , parent . indexOf ( item ) ) ; } static void renderChanges ( MenuItem item ) { WidgetLCAUtil . renderCustomVariant ( item ) ; ItemLCAUtil . renderChanges ( item ) ; WidgetLCAUtil . renderMenu ( item , item . getMenu ( ) ) ; renderProperty ( item , PROP_ENABLED , item . getEnabled ( ) , true ) ; renderProperty ( item , PROP_SELECTION , item . getSelection ( ) , false ) ; renderListener ( item , PROP_SELECTION_LISTENER , SelectionEvent . hasListener ( item ) , false ) ; WidgetLCAUtil .", "gt": "renderListenHelp ( item ) ;", "prediction": "renderHelpListener ( item ) ;\n", "label": 1}
{"id": 3289, "input": "<s> package org . ofbiz . minilang . method . entityops ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class RemoveByAnd extends MethodOperation { public static final String module = RemoveByAnd . class . getName ( ) ; private final FlexibleStringExpander doCacheClearFse ; private final FlexibleStringExpander entityNameFse ; private final FlexibleMapAccessor < Map < String , ? extends Object > > mapFma ; public RemoveByAnd ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"entity-name\" , \"map\" , \"do-cache-clear\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"entity-name\" , \"map\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"map\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } entityNameFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"entity-name\" ) ) ; mapFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"map\" ) ) ; doCacheClearFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"do-cache-clear\" ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { boolean doCacheClear = ! \"false\" . equals ( doCacheClearFse . expandString ( methodContext . getEnvMap ( ) ) ) ; String entityName = entityNameFse . expandString ( methodContext . getEnvMap ( ) ) ; try { methodContext . getDelegator ( ) . removeByAnd ( entityName , mapFma . get ( methodContext . getEnvMap ( ) ) , doCacheClear ) ; } catch ( GenericEntityException e ) { String errMsg = \"Exception thrown while removing entities: \" + e . getMessage ( ) ; Debug . logWarning ( e , errMsg , module ) ; simpleMethod . addErrorMessage ( methodContext , errMsg ) ; return false ; } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { aic . addEntityName ( entityNameFse . toString ( ) ) ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<remove-by-and \" ) ; sb . append ( \"entity-name=\\\"\" ) . append ( this . entityNameFse )", "gt": ". append ( \"\\\" \" ) ;", "prediction": ";\n", "label": 0}
{"id": 14145, "input": "<s> package org . modelgoon . core . ui ; import org . eclipse . draw2d . IFigure ; import org . eclipse . gef . LayerConstants ; import org . eclipse . gef . commands . Command ; import org . eclipse . gef . editpolicies . GraphicalNodeEditPolicy ; import org . eclipse . gef . requests . CreateConnectionRequest ; import org . eclipse . gef . requests . ReconnectRequest ; public class ConnectionEditPolicyImpl extends GraphicalNodeEditPolicy { @ Override public void activate ( ) { super . activate ( ) ; } @ Override", "gt": "protected IFigure getFeedbackLayer ( )", "prediction": "public void tearDown ( )\n", "label": 1}
{"id": 5336, "input": "<s> public class NameClashSameErasureNoOverride1 { interface I < X > { void m ( X l ) ; } class A { void m ( Object l ) { } }", "gt": "class B extends A implements I < Integer >", "prediction": "}\n", "label": 0}
{"id": 14154, "input": "<s> package org . jscsi", "gt": ". initiator . devices ;", "prediction": ". scsi . protocol ;\n", "label": 1}
{"id": 2881, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import com . sun . tools . javap . * ; public class T6866657 { public static void main ( String ... args ) { new T6866657 ( ) . run ( ) ; } void run ( ) { verify ( \"java.lang.Object\" ) ; verify ( \"java.lang.String\" ) ; verify ( \"java.util.List\" ) ; verify ( \"java.util.ArrayList\" ) ; if ( errors > 0 ) throw new Error ( errors + \" found.\" ) ; } void verify ( String className ) { try { PrintWriter log = new PrintWriter ( System . out ) ; JavaFileManager fileManager = JavapFileManager . create ( null , log ) ; JavaFileObject fo = fileManager . getJavaFileForInput ( StandardLocation . PLATFORM_CLASS_PATH , className , JavaFileObject . Kind . CLASS ) ; if ( fo == null ) { error ( \"Can't find \" + className ) ; } else { JavapTask t = new", "gt": "JavapTask ( log , fileManager , null ) ;", "prediction": "JavapTask ( ) ;\n", "label": 0}
{"id": 14159, "input": "<s> package de . uos . igf . db3d . dbms . newModel4d ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; public class TriangleNet4DComp { Map < Integer , Triangle4D > elements ; Date start ; Date end ; public TriangleNet4DComp ( Date start ) { super ( ) ; elements = new HashMap < Integer , Triangle4D > ( ) ; this . start = start ; this . end = null ; } public void addTriangle ( Triangle4D triangle ) { if ( elements . containsKey ( triangle . getID ( ) ) ) { throw new IllegalArgumentException ( \"You tried to add a triangle that already", "gt": "exists to the TriangleNet.\" ) ;", "prediction": "exists\" ) ;\n", "label": 1}
{"id": 8629, "input": "<s> public class T6663588 < T extends T6663588 . Inner > extends T6663588 { class", "gt": "Inner extends T6663588 . Inner", "prediction": "Inner\n", "label": 0}
{"id": 14168, "input": "<s> package org . apache . sqoop . mapreduce . db ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . SQLException ; import org . apache . hadoop . conf . Configuration ; import org . apache . sqoop . mapreduce . DBWritable ; import com . cloudera . sqoop . mapreduce . db . DBInputFormat . NullDBWritable ; public class DBConfiguration { public static final String DRIVER_CLASS_PROPERTY = \"mapreduce.jdbc.driver.class\" ; public static final String URL_PROPERTY = \"mapreduce.jdbc.url\" ; public static final String USERNAME_PROPERTY = \"mapreduce.jdbc.username\" ; public static final String PASSWORD_PROPERTY = \"mapreduce.jdbc.password\" ; public static final String FETCH_SIZE = \"mapreduce.jdbc.fetchsize\" ; public static final String INPUT_TABLE_NAME_PROPERTY = \"mapreduce.jdbc.input.table.name\" ; public static final String INPUT_FIELD_NAMES_PROPERTY = \"mapreduce.jdbc.input.field.names\" ; public static final String INPUT_CONDITIONS_PROPERTY = \"mapreduce.jdbc.input.conditions\" ; public static final String INPUT_ORDER_BY_PROPERTY = \"mapreduce.jdbc.input.orderby\" ; public static final String INPUT_QUERY = \"mapreduce.jdbc.input.query\" ; public static final String INPUT_COUNT_QUERY = \"mapreduce.jdbc.input.count.query\" ; public static final String INPUT_BOUNDING_QUERY = \"mapred.jdbc.input.bounding.query\" ; public static final String INPUT_CLASS_PROPERTY = \"mapreduce.jdbc.input.class\" ; public static final String OUTPUT_TABLE_NAME_PROPERTY = \"mapreduce.jdbc.output.table.name\" ; public static final String OUTPUT_FIELD_NAMES_PROPERTY = \"mapreduce.jdbc.output.field.names\" ; public static final String OUTPUT_FIELD_COUNT_PROPERTY = \"mapreduce.jdbc.output.field.count\" ; public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd , Integer fetchSize ) { conf . set ( DRIVER_CLASS_PROPERTY , driverClass ) ; conf . set ( URL_PROPERTY , dbUrl ) ; if ( userName != null ) { conf . set ( USERNAME_PROPERTY , userName ) ; } if ( passwd != null ) { conf . set ( PASSWORD_PROPERTY , passwd ) ; } if ( fetchSize != null ) { conf . setInt ( FETCH_SIZE , fetchSize ) ; } } public static void configureDB ( Configuration job , String driverClass , String dbUrl , Integer fetchSize ) { configureDB ( job , driverClass , dbUrl , null , null , fetchSize ) ; } public static void configureDB ( Configuration conf , String driverClass , String dbUrl , String userName , String passwd ) { configureDB ( conf , driverClass , dbUrl , userName , passwd , null ) ; } public static void configureDB ( Configuration job , String driverClass , String dbUrl ) { configureDB ( job , driverClass , dbUrl , null ) ; } private Configuration conf ; public DBConfiguration ( Configuration job ) { this . conf = job ; } public Connection getConnection ( ) throws ClassNotFoundException , SQLException { Class . forName ( conf . get ( DBConfiguration . DRIVER_CLASS_PROPERTY ) ) ; if ( conf . get ( DBConfiguration . USERNAME_PROPERTY ) == null ) { return DriverManager . getConnection ( conf . get ( DBConfiguration . URL_PROPERTY ) ) ; } else { return DriverManager . getConnection ( conf . get ( DBConfiguration . URL_PROPERTY ) , conf . get ( DBConfiguration . USERNAME_PROPERTY ) , conf . get ( DBConfiguration . PASSWORD_PROPERTY ) ) ; } } public Configuration getConf ( ) { return conf ; } public Integer getFetchSize ( ) { if ( conf . get ( DBConfiguration . FETCH_SIZE ) == null ) { return null ; } return conf .", "gt": "getInt ( DBConfiguration . FETCH_SIZE , 0 ) ;", "prediction": "get ( DBConfiguration . FETCH_SIZE ) ;\n", "label": 1}
{"id": 7309, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . RollupTask ; public class RollupTaskImpl extends ReportAttributeImpl implements RollupTask { protected LogicalExpression expression ; protected RollupTaskImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getRollupTask ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . ROLLUP_TASK__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . ROLLUP_TASK__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . ROLLUP_TASK__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . ROLLUP_TASK__EXPRESSION , newExpression , newExpression ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . ROLLUP_TASK__EXPRESSION : return basicSetExpression ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . ROLLUP_TASK__EXPRESSION : return getExpression ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . ROLLUP_TASK__EXPRESSION : setExpression ( ( LogicalExpression ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . ROLLUP_TASK__EXPRESSION : setExpression (", "gt": "( LogicalExpression ) null ) ;", "prediction": "( LogicalExpression ) newValue ) ;\n", "label": 0}
{"id": 14169, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"listName\" , \"contentTypeId\" } ) @ XmlRootElement ( name = \"GetListContentType\" ) public class GetListContentType { protected String listName ; protected String contentTypeId ; public String getListName ( ) { return listName ; } public void setListName ( String value ) {", "gt": "this . listName = value ;", "prediction": "this . listName = value ;\n", "label": 1}
{"id": 8312, "input": "<s> package org . dawb . workbench . plotting . system . swtxy ; import java . util . ArrayList ; import java . util . List ; import org . csstudio . swt . xygraph . undo . XYGraphMemento ; public class XYRegionMemento extends XYGraphMemento { private List < RegionBean > regionBeanList ; public XYRegionMemento ( ) { super ( ) ; this . regionBeanList = new", "gt": "ArrayList < RegionBean > ( ) ;", "prediction": "ArrayList < RegionBean > ( ) ;\n", "label": 0}
{"id": 14178, "input": "<s> package com . puppycrawl . tools . checkstyle . bcel . generic ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUTFIELD ; public class PUTFIELDReference extends FieldReference { public", "gt": "PUTFIELDReference ( PUTFIELD aInstruction , ConstantPoolGen aPoolGen )", "prediction": "static final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 2899, "input": "<s> package pkg1 ; public class A { public < T > A ( ) { } public < T > void m1 ( T t ) { } public < T extends Number ,", "gt": "U > void m2 ( T t , U u )", "prediction": "T > void m2 ( T t )\n", "label": 0}
{"id": 14181, "input": "<s> package org . jscsi . scsi . protocol . cdb ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . jscsi . scsi . protocol . util . ByteBufferInputStream ; public class RequestSense extends AbstractParameterCDB { public static final int OPERATION_CODE = 0x03 ; private boolean DESC ; public RequestSense ( ) { super ( OPERATION_CODE ) ; } public RequestSense ( boolean useDescriptorFormat , boolean linked , boolean normalACA , long allocationLength ) { super ( OPERATION_CODE , linked , normalACA , allocationLength , 0 ) ; if ( allocationLength > 256 ) { throw new IllegalArgumentException ( \"Allocation length out of bounds for command type\" ) ; } this . DESC = useDescriptorFormat ; } public RequestSense ( boolean useDescriptorFormat , long allocationLength ) { this ( useDescriptorFormat , false , false , allocationLength ) ; } public void decode ( byte [ ] header , ByteBuffer input ) throws IOException { DataInputStream in = new DataInputStream ( new ByteBufferInputStream ( input ) ) ; int operationCode = in . readUnsignedByte ( ) ; int format = in . readUnsignedByte ( ) & 0x01 ; this . DESC = ( format == 1 ) ; in . readShort ( ) ; setAllocationLength ( in . readUnsignedByte ( ) ) ; super . setControl ( in . readUnsignedByte ( ) ) ; if ( operationCode != OPERATION_CODE ) { throw new IOException ( \"Invalid operation code: \" + Integer . toHexString ( operationCode ) ) ; } } public byte [ ] encode ( ) { ByteArrayOutputStream cdb = new ByteArrayOutputStream ( this . size ( ) ) ; DataOutputStream out = new DataOutputStream ( cdb ) ; try { out . writeByte ( OPERATION_CODE ) ; if ( this . DESC ) { out . writeByte ( 1 ) ; } else { out . writeByte ( 0 ) ; } out . writeShort ( 0 ) ; out . writeByte ( ( int ) getAllocationLength ( ) ) ; out . writeByte ( super . getControl ( ) ) ; return cdb . toByteArray ( ) ; }", "gt": "catch ( IOException e )", "prediction": "catch ( IOException e )\n", "label": 1}
{"id": 2017, "input": "<s> package com . ui ; import java . io . File ; import java . io . FileOutputStream ; import org . achartengine . ChartFactory ; import org . achartengine . GraphicalView ; import org . achartengine . chart . PointStyle ; import org . achartengine . model . SeriesSelection ; import org . achartengine . model . XYMultipleSeriesDataset ; import org . achartengine . model . XYSeries ; import org . achartengine . renderer . XYMultipleSeriesRenderer ; import org . achartengine . renderer . XYSeriesRenderer ; import org . achartengine . tools . PanListener ; import org . achartengine . tools . ZoomEvent ; import org . achartengine . tools . ZoomListener ; import android . app . Activity ; import android . content . Intent ; import android . graphics . Bitmap ; import android . graphics . Bitmap . CompressFormat ; import android . graphics . Color ; import android . os . Bundle ; import android . os . Environment ; import android . util . Log ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . ViewGroup . LayoutParams ; import android . widget . LinearLayout ; import android . widget . Toast ; import com . main . MainActivity ; import com . main . R ; import com . sensor . MotionState ; import com . sensor . MovementService ; public class GraphPlotter extends Activity { public static final String TYPE = \"type\" ; public static final String TAG = \"GraphPlotter\" ; private XYMultipleSeriesDataset mDataset = new XYMultipleSeriesDataset ( ) ; private XYMultipleSeriesRenderer mRenderer = new XYMultipleSeriesRenderer ( ) ; private XYSeries mCurrentSeries ; private XYSeriesRenderer mCurrentRenderer ; private String mDateFormat ; private GraphicalView mChartView ; UpdateDelayHandler displayDelayHandler ; GraphUpdateDelayThread dispDelayThread ; private int index = 0 ; private int displayRefreshDelay = 500 ; MotionState currentState = new MotionState ( ) ; private float [ ] totDisp ; private int pointNumber = - 1 ; @ Override protected void onRestoreInstanceState ( Bundle savedState ) { super . onRestoreInstanceState ( savedState ) ; mDataset = ( XYMultipleSeriesDataset ) savedState . getSerializable ( \"dataset\" ) ; mRenderer = ( XYMultipleSeriesRenderer ) savedState . getSerializable ( \"renderer\" ) ; mCurrentSeries = ( XYSeries ) savedState . getSerializable ( \"current_series\" ) ; mCurrentRenderer = ( XYSeriesRenderer ) savedState . getSerializable ( \"current_renderer\" ) ; mDateFormat = savedState . getString ( \"date_format\" ) ; } @ Override protected void onSaveInstanceState ( Bundle outState ) { super . onSaveInstanceState ( outState ) ; outState . putSerializable ( \"dataset\" , mDataset ) ; outState . putSerializable ( \"renderer\" , mRenderer ) ; outState . putSerializable ( \"current_series\" , mCurrentSeries ) ; outState . putSerializable ( \"current_renderer\" , mCurrentRenderer ) ; outState . putString ( \"date_format\" , mDateFormat ) ; } @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; displayDelayHandler = new UpdateDelayHandler ( this ) ; dispDelayThread = new GraphUpdateDelayThread ( displayDelayHandler , displayRefreshDelay ) ; setContentView ( R . layout . xy_chart ) ; mRenderer . setApplyBackgroundColor ( true ) ; mRenderer . setBackgroundColor ( Color . argb ( 100 , 50 , 50 , 50 ) ) ; mRenderer . setAxisTitleTextSize ( 16 ) ; mRenderer . setChartTitleTextSize ( 20 ) ; mRenderer . setLabelsTextSize ( 15 ) ; mRenderer . setLegendTextSize ( 15 ) ; mRenderer . setMargins ( new int [ ] { 20 , 30 , 15 , 0 } ) ; mRenderer . setZoomButtonsVisible ( true ) ; mRenderer . setPointSize ( 5 ) ; mRenderer . setXLabels ( 5 ) ; mRenderer . setYLabels ( 5 ) ; { String seriesTitle = \"Recommended Path\" ; XYSeries series = new XYSeries ( seriesTitle ) ; mDataset . addSeries ( series ) ; mCurrentSeries = series ; XYSeriesRenderer renderer = new XYSeriesRenderer ( ) ; mRenderer . addSeriesRenderer ( renderer ) ; renderer . setPointStyle ( PointStyle . DIAMOND ) ; renderer . setColor ( Color . CYAN ) ; renderer . setFillPoints ( true ) ; mCurrentRenderer = renderer ; double xs = 1 ; double ys = 1 ; double xg = 35 ; double yg = 25 ; mCurrentSeries . add ( xs , ys ) ; mCurrentSeries . add ( xg , yg ) ; mRenderer . setXAxisMin ( xs - 5 ) ; mRenderer . setXAxisMax ( xg + 5 ) ; mRenderer . setYAxisMin ( ys - 5 ) ; mRenderer . setYAxisMax ( yg + 5 ) ; mRenderer . setShowGrid ( true ) ; } { String seriesTitle = \"Your Path\" ; XYSeries series = new XYSeries ( seriesTitle ) ; mDataset . addSeries ( series ) ; mCurrentSeries = series ; XYSeriesRenderer renderer = new XYSeriesRenderer ( ) ; mRenderer . addSeriesRenderer ( renderer ) ; renderer . setPointStyle ( PointStyle . TRIANGLE ) ; renderer . setColor ( Color . GREEN ) ; renderer . setFillPoints ( true ) ; mCurrentRenderer = renderer ; mCurrentSeries", "gt": ". add ( 0 , 0 ) ;", "prediction": ". add ( xs , ys ) ;\n", "label": 0}
{"id": 14186, "input": "<s> package org . nuxeo . ecm . platform . publisher . task ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org .", "gt": "nuxeo . ecm . core . api . DocumentModel ;", "prediction": "nuxeo . ecm . core . api . DocumentModel ;\n", "label": 1}
{"id": 1431, "input": "<s> import java . util . StringTokenizer ; import java . io . IOException ; import java . util . Vector ; class Main { static int maxLg = 200 ; public static void sort ( Vector v ) { int n = v . size ( ) ; Vector v2 = new Vector ( ) ; char us [ ] = new char [ n ] ; int j , t , i ; P p1 , p2 ; for ( i = 0 ; i < n ; i ++ ) { p1 = null ; t = - 1 ; for ( j = 0 ; j < n ; j ++ ) { if ( us [ j ] == 1 ) continue ; p2 = ( P ) v . elementAt ( j ) ; if ( p1 == null || p1 . compareTo ( p2 ) > 0 ) { t = j ; p1 = p2 ; } } us [ t ] = 1 ; v2 . addElement ( p1 ) ; } v . removeAllElements ( ) ; for ( i = 0 ; i != n ; i ++ ) { v . addElement ( v2 . elementAt ( i ) ) ; } } public static void main ( String args [ ] ) throws Exception { } static String [ ] split ( String s ) { StringTokenizer st = new StringTokenizer ( s , \",\" ) ; String [ ] tokens = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i != tokens . length ; i ++ ) { tokens [ i ] = st", "gt": ". nextToken ( ) ;", "prediction": "[ i ] ;\n", "label": 0}
{"id": 14201, "input": "<s> package org . restlet . example . book . restlet . ch09 . server ; import org . restlet . example . book . restlet . ch09 . common . AccountRepresentation ; import org . restlet . example . book . restlet . ch09 . common . AccountResource ; import org . restlet . ext . wadl . MethodInfo ; import org . restlet . ext . wadl . RepresentationInfo ; import org . restlet . ext . wadl . WadlServerResource ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; public class AccountServerResource extends WadlServerResource implements AccountResource { private int accountId ; @ Override protected RepresentationInfo describe ( MethodInfo methodInfo , Class < ? > representationClass , Variant variant ) { RepresentationInfo result = new RepresentationInfo ( variant ) ; result . setReference ( \"account\" ) ; return result ; } @ Override protected void doInit ( ) throws ResourceException {", "gt": "String accountIdAttribute = getAttribute ( \"accountId\" ) ;", "prediction": "try\n", "label": 1}
{"id": 5556, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; import redstone . xmlrpc . XmlRpcArray ; public class User { public Integer id ; public XmlRpcArray user_permissions ; public XmlRpcArray groups ; public String first_name ; public String username ; public String last_name ; public String email ; public String date_joined ; public Boolean is_staff ; public Boolean is_active ; public Boolean is_superuser ; public String last_login ; public static class get extends TcmsArrayCommand { @ RequiredField public Integer id ; } public static class filter extends TcmsHashCommand { public String username__startswith ; } public static class get_me extends TcmsArrayCommand { } public static class update extends TcmsArrayCommand { public update . Values values", "gt": "= new Values ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14204, "input": "<s> package org . gatein . common . text ; import org . gatein . common . io . UndeclaredIOException ; import org . gatein . common . util . ParameterValidation ; import java . io . IOException ; import java . io . Writer ; public class FastURLEncoder extends AbstractCharEncoder { private static final FastURLEncoder DEFAULT_ENCODER = new FastURLEncoder ( CharToByteEncoder . Generic . UTF8 ) ; public static FastURLEncoder getUTF8Instance ( ) { return DEFAULT_ENCODER ; } private final char [ ] [ ] table ; private static final char MAX = ( char ) 0x10FFFD ; public FastURLEncoder ( CharToByteEncoder encoder ) throws IllegalArgumentException { if ( encoder == null ) { throw new IllegalArgumentException ( \"No encoding provided\" ) ; } this . table = new char [ MAX + 1 ] [ ] ; for ( char c = 0 ; c <= MAX ; c ++ ) { char [ ] z ; if ( TextTools . isAlphaNumeric ( c ) ) { z = new char [ ] { c } ; } else { switch ( c ) { case ' ' : z = new char [ ] { '+' } ; break ; case '.' : case '-' : case '*' : case '_' : z = new char [ ] { c } ; break ; default : byte [ ] v = encoder . encode ( c ) ; if ( v . length > 0 ) { z = new char [ v . length * 3 ] ; int index = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { byte b = v [ i ] ; z [ index ++ ] = '%' ; z [ index ++ ] = TextTools . toHex ( ( b & 0xF0 ) > > 4 ) ; z [ index ++ ] = TextTools . toHex ( b & 0x0F ) ; } } else { z = null ; } break ; } } table [ c ] = z ; } } public void encode ( char c , CharWriter writer ) { ParameterValidation . throwIllegalArgExceptionIfNull ( writer , \"CharWriter\" ) ; char [ ]", "gt": "z = getEncoding ( c ) ;", "prediction": "z = new char [ c ] ;\n", "label": 1}
{"id": 2002, "input": "<s> package org . xbill . DNS ; import java . util . * ; import java . io . * ; import java . net . * ; public class ExtendedResolver implements Resolver { private static class Resolution implements ResolverListener { Resolver [ ] resolvers ; int [ ] sent ; Object [ ] inprogress ; int retries ; int outstanding ; boolean done ; Message query ; Message response ; Throwable thrown ; ResolverListener listener ; public Resolution ( ExtendedResolver eres , Message query ) { List l = eres . resolvers ; resolvers = ( Resolver [ ] ) l . toArray ( new Resolver [ l . size ( ) ] ) ; if ( eres . loadBalance ) { int nresolvers = resolvers . length ; int start = eres . lbStart ++ % nresolvers ; if ( eres . lbStart > nresolvers ) eres . lbStart %= nresolvers ; if ( start > 0 ) { Resolver [ ] shuffle = new Resolver [ nresolvers ] ; for ( int i = 0 ; i < nresolvers ; i ++ ) { int pos = ( i + start ) % nresolvers ; shuffle [ i ] = resolvers [ pos ] ; } resolvers = shuffle ; } } sent = new int [ resolvers . length ] ; inprogress = new Object [ resolvers . length ] ; retries = eres . retries ; this . query = query ; } public void send ( int n ) { sent [ n ] ++ ; outstanding ++ ; try { inprogress [ n ] = resolvers [ n ] . sendAsync ( query , this ) ; } catch ( Throwable t ) { synchronized ( this ) { thrown = t ; done = true ; if ( listener == null ) { notifyAll ( ) ; return ; } } } } public Message start ( ) throws IOException { try { sent [ 0 ] ++ ; outstanding ++ ; inprogress [ 0 ] = new Object ( ) ; return resolvers [ 0 ] . send ( query ) ; } catch ( Exception e ) { handleException ( inprogress [ 0 ] , e ) ; } synchronized ( this ) { while ( ! done ) { try { wait ( ) ; } catch ( InterruptedException e ) { } } } if ( response != null ) return response ; else if ( thrown instanceof IOException ) throw ( IOException ) thrown ; else if ( thrown instanceof RuntimeException ) throw ( RuntimeException ) thrown ; else if ( thrown instanceof Error ) throw ( Error ) thrown ; else throw new IllegalStateException ( \"ExtendedResolver failure\" ) ; } public void startAsync ( ResolverListener listener ) { this . listener = listener ; send ( 0 ) ; } public void receiveMessage ( Object id , Message m ) { if ( Options . check ( \"verbose\" ) ) System . err . println ( \"ExtendedResolver: \" + \"received message\" ) ; synchronized ( this ) { if ( done ) return ; response = m ; done = true ; if ( listener == null ) { notifyAll ( ) ; return ; } } listener . receiveMessage ( this , response ) ; } public void handleException ( Object id , Exception e ) { if ( Options . check ( \"verbose\" ) ) System . err . println ( \"ExtendedResolver: got \" + e ) ; synchronized ( this ) { outstanding -- ; if ( done ) return ; int n ; for ( n = 0 ; n < inprogress . length ; n ++ ) if ( inprogress [ n ] == id ) break ; if ( n == inprogress . length ) return ; boolean startnext = false ; if ( sent [ n ] == 1 && n < resolvers . length - 1 ) startnext = true ; if ( e instanceof InterruptedIOException ) { if ( sent [ n ] < retries ) send ( n ) ; if ( thrown == null ) thrown = e ; } else if ( e instanceof SocketException ) { if ( thrown == null || thrown instanceof InterruptedIOException ) thrown = e ; } else { thrown = e ; } if ( done ) return ; if ( startnext ) send ( n + 1 ) ; if ( done ) return ; if ( outstanding == 0 ) { done = true ; if ( listener == null ) { notifyAll ( ) ; return ; } } if ( ! done ) return ; } if ( ! ( thrown instanceof Exception ) ) thrown = new RuntimeException ( thrown . getMessage ( ) ) ; listener . handleException ( this , ( Exception ) thrown ) ; } } private static final int quantum = 5 ; private List resolvers ; private boolean loadBalance = false ; private int lbStart = 0 ; private int retries = 3 ; private void init ( ) { resolvers = new ArrayList ( ) ; } public ExtendedResolver ( ) throws UnknownHostException { init ( ) ; String [ ] servers = ResolverConfig . getCurrentConfig ( ) . servers ( ) ; if ( servers != null ) { for (", "gt": "int i = 0 ;", "prediction": "int i = 0 ;\n", "label": 0}
{"id": 14209, "input": "<s> package monbulk . shared . Services ; import java . util . ArrayList ; import java . util . List ; import java . util . HashMap ; import java . util . Collection ; import monbulk . shared . util . XmlHelper ; public class Dictionary { public static class Entry { private ArrayList < String > m_definitions = new ArrayList < String > ( ) ; private String m_term ; public Entry ( String term ) { m_term = term ; } public ArrayList < String > getDefinitions ( ) { return m_definitions ; } public String getTerm ( ) { return m_term ; } } private HashMap < String , Entry > m_entries = new HashMap < String , Entry > ( ) ; private String m_name ; public Dictionary ( String name ) { m_name = name ; } public Collection < Entry > getEntries ( ) { return m_entries . values ( ) ; } public String getDefinition ( String name , String defaultValue ) { Entry e = m_entries . get ( name ) ; String value = defaultValue ; if ( e != null && e . getDefinitions ( ) . size ( ) > 0 ) { value = e . getDefinitions ( ) . get ( 0 ) ; } return value ; } public String getName ( ) { return m_name ; } public Entry addEntry ( String term ) { Entry entry = new Entry ( term ) ; m_entries . put ( term , entry ) ; return entry ; } public Entry addEntry ( String term , List < String > definitions ) { Entry entry = new Entry ( term ) ; if ( definitions != null ) { entry . getDefinitions ( ) . addAll ( definitions ) ; } m_entries . put ( term , entry ) ; return entry ; } public void addDictionary ( Dictionary dictionary ) { for ( Entry e : dictionary . getEntries ( ) ) { addEntry ( e . getTerm ( ) , e . getDefinitions ( ) ) ; } } public String getXmlForEntry ( Entry entry ) { StringBuilder sb = new StringBuilder ( ) ; XmlHelper . addTagWithValue ( sb , \"dictionary\" , m_name ) ; for ( String d : entry . getDefinitions ( ) ) { XmlHelper . addTagWithValue ( sb , \"definition\" , d ) ; } XmlHelper . addTagWithValue ( sb ,", "gt": "\"term\" , entry . getTerm ( ) ) ;", "prediction": "\"entry\" , m_name ) ;\n", "label": 1}
{"id": 3886, "input": "<s> package com . toedter . gwt . demo . contacts . server ; public class ContactsRepositoryFactory { private static final IContactsRepository CONTACTS_REPOSITORY = new VCardContactsRepository ( ) ; public", "gt": "static IContactsRepository getContactsRepository ( )", "prediction": "ContactsRepositoryFactory ( )\n", "label": 0}
{"id": 14223, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class FocusEvent extends TypedEvent { private static final long serialVersionUID = 1L ;", "gt": "public FocusEvent ( Event event )", "prediction": "public FocusEvent ( )\n", "label": 1}
{"id": 8122, "input": "<s> package org . ofbiz . service . test ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericResultWaiter ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class ServiceEngineTestServices { public static final String module = ServiceEngineTestServices . class . getName ( ) ; public static final String resource = \"ServiceErrorUiLabels\" ; public static Map < String , Object > testServiceDeadLockRetry ( DispatchContext dctx , Map < String , ? extends Object > context ) { Locale locale = ( Locale ) context . get ( \"locale\" ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; try { GenericResultWaiter threadAWaiter = dispatcher . runAsyncWait ( \"testServiceDeadLockRetryThreadA\" , null , false ) ; GenericResultWaiter threadBWaiter = dispatcher . runAsyncWait ( \"testServiceDeadLockRetryThreadB\" , null , false ) ; Map < String , Object > threadAResult = threadAWaiter . waitForResult ( ) ; Map < String , Object > threadBResult = threadBWaiter . waitForResult ( ) ; List < Object > errorList = FastList . newInstance ( ) ; if ( ServiceUtil . isError ( threadAResult ) ) { errorList . add ( UtilProperties . getMessage ( resource , \"ServiceTestDeadLockThreadA\" , UtilMisc . toMap ( \"errorString\" , ServiceUtil . getErrorMessage ( threadAResult ) ) , locale ) ) ; } if ( ServiceUtil . isError ( threadBResult ) ) { errorList . add ( UtilProperties . getMessage ( resource , \"ServiceTestDeadLockThreadB\" , UtilMisc . toMap ( \"errorString\" , ServiceUtil . getErrorMessage ( threadBResult ) ) , locale ) ) ; } if ( errorList . size ( ) > 0 ) { return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ServiceTestDeadLockRetry\" , locale ) , errorList , null , null ) ; } } catch ( Exception e ) { Debug . logError ( e , \"Error running deadlock test services: \" + e . toString ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ServiceTestDeadLockError\" , UtilMisc . toMap ( \"errorString\" , e . toString ( ) ) , locale ) ) ; } return ServiceUtil . returnSuccess ( ) ; } public static Map < String , Object > testServiceDeadLockRetryThreadA ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; try { GenericValue testingTypeA = delegator . findOne ( \"TestingType\" , false , \"testingTypeId\" , \"SVCLRT_A\" ) ; testingTypeA . set ( \"description\" , \"New description for SVCLRT_A\" ) ; testingTypeA . store ( ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadA just updated SVCLRT_A, beginning wait\" , module ) ; Thread . sleep ( 100 ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadA done with wait, updating SVCLRT_B\" , module ) ; GenericValue testingTypeB = delegator . findOne ( \"TestingType\" , false , \"testingTypeId\" , \"SVCLRT_B\" ) ; testingTypeB . set ( \"description\" , \"New description for SVCLRT_B\" ) ; testingTypeB . store ( ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadA done with updating SVCLRT_B, updating SVCLRT_AONLY\" , module ) ; GenericValue testingTypeAOnly = delegator . findOne ( \"TestingType\" , false , \"testingTypeId\" , \"SVCLRT_AONLY\" ) ; testingTypeAOnly . set ( \"description\" , \"New description for SVCLRT_AONLY; this is only changed by thread A so if it doesn't match something happened to thread A!\" ) ; testingTypeAOnly . store ( ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Entity Engine Exception running dead lock test thread A: \" + e . toString ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ServiceTestEntityEngineExceptionThreadA\" , UtilMisc . toMap ( \"errorString\" , e . toString ( ) ) , locale ) ) ; } catch ( InterruptedException e ) { Debug . logError ( e , \"Wait Interrupted Exception running dead lock test thread A: \" + e . toString ( ) , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource , \"ServiceTestEntityEngineWaitInterruptedExceptionThreadA\" , UtilMisc . toMap ( \"errorString\" , e . toString ( ) ) , locale ) ) ; } return ServiceUtil . returnSuccess ( ) ; } public static Map < String , Object > testServiceDeadLockRetryThreadB ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; try { GenericValue testingTypeB = delegator . findOne ( \"TestingType\" , false , \"testingTypeId\" , \"SVCLRT_B\" ) ; testingTypeB . set ( \"description\" , \"New description for SVCLRT_B\" ) ; testingTypeB . store ( ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadB just updated SVCLRT_B, beginning wait\" , module ) ; Thread . sleep ( 100 ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadB done with wait, updating SVCLRT_A\" , module ) ; GenericValue testingTypeA = delegator . findOne ( \"TestingType\" , false , \"testingTypeId\" , \"SVCLRT_A\" ) ; testingTypeA . set ( \"description\" , \"New description for SVCLRT_A\" ) ; testingTypeA . store ( ) ; Debug . logInfo ( \"In testServiceDeadLockRetryThreadA done with updating SVCLRT_A, updating SVCLRT_BONLY\" , module ) ; GenericValue testingTypeAOnly = delegator . findOne ( \"TestingType\" , false ,", "gt": "\"testingTypeId\" , \"SVCLRT_BONLY\" ) ;", "prediction": "\"testingTypeId\" , \"SVCLRT_AONLY\" ) ;\n", "label": 0}
{"id": 14227, "input": "<s> package org . eclipse . ui . internal . services ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . part . IPageSite ; import org . eclipse . ui . part . MultiPageEditorSite ; import org . eclipse . ui . part . PageBookView ; import org . eclipse . ui . services . IServiceScopes ; public interface IWorkbenchLocationService { public String getServiceScope ( ) ;", "gt": "public int getServiceLevel ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7289, "input": "<s> package org . gk . engine . client . exception ; public class GKEngineException extends RuntimeException { private static final long serialVersionUID = 1L ; public", "gt": "GKEngineException ( String msg )", "prediction": "GKEngineException ( )\n", "label": 0}
{"id": 14229, "input": "<s> package org . eclipse . ui . internal . contexts ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . commands . contexts . ContextManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . ISources ; import org . eclipse . ui . LegacyHandlerSubmissionExpression ; import org . eclipse . ui . contexts . EnabledSubmission ; import org . eclipse . ui . contexts . IContextActivation ; import org . eclipse . ui . contexts . IContextManager ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . contexts . IWorkbenchContextSupport ; import org . eclipse . ui . internal . Workbench ; public class WorkbenchContextSupport implements IWorkbenchContextSupport { private Map activationsBySubmission = null ; private IContextService contextService ; private ContextManagerLegacyWrapper contextManagerWrapper ; private final Workbench workbench ; public WorkbenchContextSupport ( final Workbench workbenchToSupport , final ContextManager contextManager ) { workbench = workbenchToSupport ; contextService = ( IContextService ) workbench . getService ( IContextService . class ) ; contextManagerWrapper = ContextManagerFactory . getContextManagerWrapper ( contextManager ) ; } public final void addEnabledSubmission ( final EnabledSubmission enabledSubmission ) { int sourcePriorities = 0 ; if ( enabledSubmission . getActivePartId ( ) != null ) { sourcePriorities |= ISources . ACTIVE_PART_ID ; } if ( enabledSubmission . getActiveShell ( ) != null ) { sourcePriorities |= ( ISources . ACTIVE_SHELL | ISources . ACTIVE_WORKBENCH_WINDOW ) ; } if ( enabledSubmission . getActiveWorkbenchPartSite ( ) != null ) { sourcePriorities |= ISources . ACTIVE_SITE ; } final IContextActivation activation = contextService . activateContext ( enabledSubmission . getContextId ( ) , new LegacyHandlerSubmissionExpression ( enabledSubmission . getActivePartId ( ) , enabledSubmission . getActiveShell ( ) , enabledSubmission . getActiveWorkbenchPartSite ( ) ) ) ; if ( activationsBySubmission == null ) { activationsBySubmission = new HashMap ( ) ; } activationsBySubmission . put ( enabledSubmission , activation ) ; } public final void addEnabledSubmissions ( final Collection enabledSubmissions ) { final Iterator submissionItr = enabledSubmissions . iterator ( ) ; while ( submissionItr . hasNext ( ) ) { addEnabledSubmission ( ( EnabledSubmission ) submissionItr . next ( ) ) ; } } public final IContextManager getContextManager ( ) { return contextManagerWrapper ; } public", "gt": "final int getShellType ( Shell shell )", "prediction": "final IContextService getContextService ( )\n", "label": 1}
{"id": 6287, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . AccountReport ; import org . jjflyboy . tjpeditor . project . ProjectPackage ;", "gt": "public class AccountReportImpl extends PropertyImpl implements AccountReport", "prediction": "import org . junit . Before ;\n", "label": 0}
{"id": 14231, "input": "<s> package org . eclipse . ui . tests . session ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . themes . IThemeManager ; import junit . framework . TestCase ; public class ThemeStateTest extends TestCase { public ThemeStateTest ( final String name ) { super ( name ) ; } public void testBadPreference ( ) { String themeId = PlatformUI . getWorkbench ( ) . getThemeManager ( ) . getCurrentTheme ( ) . getId ( ) ; assertNotNull ( themeId ) ; assertEquals ( IThemeManager .", "gt": "DEFAULT_THEME , themeId ) ;", "prediction": "getCurrentTheme ( ) , themeId ) ;\n", "label": 1}
{"id": 280, "input": "<s> package com . kodholken . stunclient ; import com . kodholken . stunclient . R ; import android . app . Activity ; import android . content . Context ; import android . content . pm . PackageManager . NameNotFoundException ; import android . os . Bundle ; import android . view . Window ; import android . widget . TextView ; public class AboutActivity extends Activity { @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . about ) ; TextView title = ( TextView ) findViewById ( R . id . about_title ) ; title . setText ( \"STUN Client v\" + getVersion ( this ) ) ; getString ( R . string . about_text ) ; ( ( TextView ) findViewById ( R . id . about_content ) ) . setText ( getString ( R . string . about_text ) . replace ( \"${VERSION}\" , getVersion ( this ) ) ) ; } private String getVersion ( Context context ) { try { return context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , 0 ) . versionName ; }", "gt": "catch ( NameNotFoundException ex )", "prediction": "catch ( PackageManagerException e )\n", "label": 0}
{"id": 14236, "input": "<s> package org . fuzzydb . server . internal . index . btree ;", "gt": "public interface NodeW extends NodeR", "prediction": "import java . io . IOException ;\n", "label": 1}
{"id": 2041, "input": "<s> package org . gk . ui . client . binding ; import java . util . Map ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . widget . form . Field ; public class gkRadioBinding extends gkFieldBinding { private String radioValue ; public gkRadioBinding ( Field field , String name , Map info , String radioValue ) { super ( field , name , info ) ; this . radioValue = radioValue ; } @ Override protected void bindingListener ( ) { field . addListener ( Events . Change , new Listener < FieldEvent > ( ) { @ Override public void handleEvent ( FieldEvent fe ) { updateDirtyField ( ) ; Boolean value = ( Boolean )", "gt": "fe . getField ( ) . getValue ( ) ;", "prediction": "field . getValue ( ) ;\n", "label": 0}
{"id": 14239, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . tomcat ; import org . eclipse . rap . rwt . cluster . testfixture . internal . server . ServletEngineClusterTestBase ; import org . eclipse . rap . rwt . cluster .", "gt": "testfixture . server . IServletEngineFactory ;", "prediction": "testfixture . testfixture . testfixture . testfixture ;\n", "label": 1}
{"id": 5301, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ListType ; import org . jjflyboy . tjpeditor . project . ListTypeValues ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class ListTypeImpl extends ColumnAttributeImpl implements ListType { protected static final ListTypeValues TYPE_EDEFAULT = ListTypeValues . BULLETS ; protected ListTypeValues type = TYPE_EDEFAULT ; protected ListTypeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getListType ( ) ; } public ListTypeValues getType ( ) { return type ; } public void setType ( ListTypeValues newType ) { ListTypeValues oldType = type ; type = newType == null ? TYPE_EDEFAULT : newType ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . LIST_TYPE__TYPE , oldType , type ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . LIST_TYPE__TYPE : return getType ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . LIST_TYPE__TYPE : setType ( ( ListTypeValues ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public", "gt": "void eUnset ( int featureID )", "prediction": "ListTypeValues getType ( )\n", "label": 0}
{"id": 14242, "input": "<s> package org . eclipse . jface . tests . dialogs ; import junit . framework . TestCase ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . jface . util . SafeRunnable ; public class SafeRunnableErrorTest extends TestCase { int count ; protected Thread runner ( ) { return new Thread ( new Runnable ( ) { public void run ( ) { ISafeRunnable runnable = new SafeRunnable ( ) { public void run ( ) throws Exception { throw new RuntimeException ( \"test exception \" + ++ count ) ; } } ; SafeRunnable . run ( runnable ) ; } } ) ; } public void testSafeRunnableHandler ( ) { SafeRunnable . run ( new SafeRunnable ( ) { public void run ( ) throws Exception { throw new RuntimeException ( \"test exception\" ) ; } } ) ; } public void testSafeRunnableHandlerOtherThread ( ) throws Exception { Thread t = runner ( ) ; t . run ( ) ; t . join ( ) ; } public void testSafeRunnableHandlerMulti ( ) { ISafeRunnable runnable = new SafeRunnable ( ) { public", "gt": "void run ( ) throws Exception", "prediction": "void run ( ) throws Exception\n", "label": 1}
{"id": 37, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . annotations . SuppressNode ; import org . parboiled . annotations . SuppressSubnodes ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class NodeSuppressionTest extends TestNgParboiledTest < Object > { @ BuildParseTree public static class Parser extends BaseParser < Object > { public Rule ABCDEFGH ( ) { return Sequence ( ABCD ( ) , EFGH ( ) ) ; } public Rule ABCD ( ) { return Sequence ( AB ( ) , CD ( ) ) ; } public Rule EFGH ( ) { return Sequence ( EF ( ) , GH ( ) ) ; } public Rule AB ( ) { return Sequence ( A ( ) , B ( ) ) ; } @ SuppressSubnodes public Rule CD ( ) { return Sequence ( C ( ) , D ( ) ) ; } public Rule EF ( ) { return Sequence ( E ( ) , F ( ) ) ; } public Rule GH ( ) { return Sequence ( G ( ) , H ( ) ) . suppressNode ( ) ; } public Rule A ( ) { return Ch ( 'a' ) ; } @ SuppressNode", "gt": "public Rule B ( )", "prediction": "public String toString ( )\n", "label": 0}
{"id": 14243, "input": "<s> package io . beancounter . platform . alive ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . http . HttpStatus ; import org . testng . Assert ; import org . testng . annotations . Test ; import io . beancounter . platform . APIResponse ; import io . beancounter . platform . AbstractJerseyTestCase ; import java . io . IOException ; public class AliveServiceTestCase extends AbstractJerseyTestCase { protected AliveServiceTestCase ( ) { super ( 9995 ) ; } @ Test public void testCheck ( ) throws IOException { HttpClient client = new HttpClient ( ) ; String baseQuery = \"api/check\" ; GetMethod getMethod = new GetMethod ( base_uri + baseQuery ) ; int result = client . executeMethod ( getMethod ) ; Assert . assertEquals ( result , HttpStatus . SC_OK ) ; String responseBody = new String ( getMethod . getResponseBody ( ) ) ; Assert . assertNotNull ( responseBody ) ; Assert . assertNotEquals ( responseBody , \"\" ) ; logger . info ( \"response: \" + responseBody ) ; APIResponse actual = fromJson ( responseBody , APIResponse . class ) ; APIResponse expected = new APIResponse ( actual . getObject ( ) , \"system up and running at\" , \"OK\" ) ; Assert . assertEquals ( actual , expected ) ; Assert . assertNotNull ( actual . getObject ( ) ) ; Assert . assertNotNull ( Long .", "gt": "parseLong ( actual . getObject ( ) ) ) ;", "prediction": "MAX_VALUE ) ;\n", "label": 1}
{"id": 7388, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . Global ; import org . jjflyboy . tjpeditor . project . Project ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Property ; public class GlobalImpl extends MinimalEObjectImpl . Container implements Global { protected Project project ; protected EList < Property > properties ; protected GlobalImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getGlobal ( ) ; } public Project getProject ( ) { return project ; } public NotificationChain basicSetProject ( Project newProject , NotificationChain msgs ) { Project oldProject = project ; project = newProject ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . GLOBAL__PROJECT , oldProject , newProject ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setProject ( Project newProject ) { if ( newProject != project ) { NotificationChain msgs = null ; if ( project != null ) msgs = ( ( InternalEObject ) project ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . GLOBAL__PROJECT , null , msgs ) ; if ( newProject != null ) msgs = ( ( InternalEObject ) newProject ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . GLOBAL__PROJECT , null , msgs ) ; msgs = basicSetProject ( newProject , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage .", "gt": "GLOBAL__PROJECT , newProject , newProject ) ) ;", "prediction": "GLOBAL__PROJECT , null , msgs ) ) ;\n", "label": 0}
{"id": 14245, "input": "<s> package org . eclipse . swt . widgets ; import java . io . IOException ; import java . io . InputStream ; import java . util . * ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . ITreeItemAdapter ; @ SuppressWarnings ( \"deprecation\" ) public class TreeItem_Test extends TestCase { private Display display ; private Shell shell ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConstructor ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; assertSame ( display , item . getDisplay ( ) ) ; assertEquals ( \"\" , item . getText ( ) ) ; assertSame ( item , tree . getItem ( tree . getItemCount ( ) - 1 ) ) ; try { new TreeItem ( ( TreeItem ) null , SWT . NONE ) ; fail ( \"Must not allow null-parent\" ) ; } catch ( IllegalArgumentException iae ) { } try { new TreeItem ( ( Tree ) null , SWT . NONE ) ; fail ( \"Must not allow null-parent\" ) ; } catch ( IllegalArgumentException iae ) { } try { new TreeItem ( tree , SWT . NONE , 5 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } try { new TreeItem ( item , SWT . NONE , 5 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } try { new TreeItem ( item , SWT . NONE , - 1 ) ; fail ( \"No exception thrown for illegal index argument\" ) ; } catch ( IllegalArgumentException e ) { } } public void testRemoveAll ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item1 = new TreeItem ( tree , SWT . NONE ) ; TreeItem item11 = new TreeItem ( item1 , SWT . NONE ) ; TreeItem item111 = new TreeItem ( item11 , SWT . NONE ) ; TreeItem item2 = new TreeItem ( tree , SWT . NONE ) ; item1 . removeAll ( ) ; assertEquals ( false , item1 . isDisposed ( ) ) ; assertEquals ( true , item11 . isDisposed ( ) ) ; assertEquals ( true , item111 . isDisposed ( ) ) ; assertEquals ( 0 , item1 . getItemCount ( ) ) ; assertEquals ( false , item2 . isDisposed ( ) ) ; } public void testVirtualRemoveAll ( ) { Tree tree = new Tree ( shell , SWT . VIRTUAL ) ; tree . setItemCount ( 1 ) ; TreeItem item = tree . getItem ( 0 ) ; item . setItemCount ( 100 ) ; TreeItem lastSubItem = item . getItem ( 99 ) ; assertFalse ( lastSubItem . isDisposed ( ) ) ; item . removeAll ( ) ; assertTrue ( lastSubItem . isDisposed ( ) ) ; } public void testFont ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; Font treeFont = Graphics . getFont ( \"BeautifullyCraftedTreeFont\" , 15 , SWT . BOLD ) ; tree . setFont ( treeFont ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; assertSame ( treeFont , item . getFont ( ) ) ; Font itemFont = Graphics . getFont ( \"ItemFont\" , 40 , SWT . NORMAL ) ; item . setFont ( itemFont ) ; assertSame ( itemFont , item . getFont ( ) ) ; item . setFont ( null ) ; assertSame ( treeFont , item . getFont ( ) ) ; } public void testChecked ( ) { Tree tree = new Tree ( shell , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; Tree checkedTree = new Tree ( shell , SWT . CHECK ) ; TreeItem checkedItem = new TreeItem ( checkedTree , SWT . NONE ) ; assertEquals ( false , item . getChecked ( ) ) ; item . setChecked ( true ) ; assertEquals ( false , item . getChecked ( ) ) ; assertEquals ( false , checkedItem . getChecked ( ) ) ; checkedItem . setChecked ( true ) ; assertEquals ( true , checkedItem . getChecked ( ) ) ; } public void testGetExpanded ( ) { Tree tree", "gt": "= new Tree ( shell , SWT . SINGLE ) ;", "prediction": "= new Tree ( shell , SWT . NONE ) ;\n", "label": 1}
{"id": 6269, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Projectile ; public interface LizaProjectile extends Projectile { List < LizaEntity > getNearbyLizaEntities ( double x , double y", "gt": ", double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14246, "input": "<s> package org . nuxeo . ecm . automation . core . scripting ; import java . util . Calendar ; import java . util . Date ; import org . apache . commons . lang . StringEscapeUtils ; public class CoreFunctions { public DateWrapper date ( Date date ) { return new DateWrapper ( date ) ; } public DateWrapper calendar ( Calendar date ) { return new", "gt": "DateWrapper ( date ) ;", "prediction": "DateWrapper ( date ) ;\n", "label": 1}
{"id": 8079, "input": "<s> package com . redhat . ceylon . ant ; public class Java7Checker { public static void check ( ) { String version = System . getProperty ( \"java.version\" ) ; if ( version == null || version . isEmpty ( ) ) { System . err . println ( \"Unable to determine Java version (java.version property missing or empty). Aborting.\" ) ; System . exit ( 1 ) ; }", "gt": "if ( ! version . startsWith ( \"1.7\" ) )", "prediction": "}\n", "label": 0}
{"id": 14252, "input": "<s> package org . jscsi . target . connection . stage ; import java . io . IOException ; import java . security . DigestException ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . target . connection . Connection ; import org . jscsi . target . connection . TargetSession ; import org . jscsi . target . connection . phase . TargetPhase ; import org . jscsi . target . settings . Settings ; import org . jscsi . target . settings . SettingsException ; public abstract class TargetStage { protected final TargetPhase targetPhase ; protected final Connection connection ; protected final TargetSession session ; protected final Settings settings ; public TargetStage ( TargetPhase targetPhase ) { this . targetPhase = targetPhase ; this . connection = targetPhase . getTargetConnection ( ) ; this . session =", "gt": "connection . getTargetSession ( ) ;", "prediction": "targetPhase . getSession ( ) ;\n", "label": 1}
{"id": 8183, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . common . util . EList ; public interface SimpleTopNode extends SimpleNode , SimpleParentNode {", "gt": "EList < SimpleLinkMapping > getLinks ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14261, "input": "<s> package org . nuxeo . ecm . platform . publisher . api ; import java . io . Serializable ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . VersioningOption ; import org . nuxeo . ecm . core . api . event . CoreEventConstants ; import org . nuxeo . ecm . core . api . event . DocumentEventCategories ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventProducer ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; import org . nuxeo . ecm . platform . publisher . rules . PublishingValidatorException ; import org . nuxeo . ecm . platform . publisher . rules . ValidatorsRule ; import org . nuxeo . runtime . api . Framework ; public abstract class AbstractBasePublishedDocumentFactory implements PublishedDocumentFactory { public static final String ENABLE_SNAPSHOT = \"enableSnapshot\" ; public static final String TARGET_PUBLISHED_DOCUMENT_STATE = \"targetPublishedDocumentState\" ; protected CoreSession coreSession ; protected Map < String , String > parameters ; protected PublicationTree publicationTree ; protected ValidatorsRule validatorsRule ; protected EventProducer eventProducer ; public void init ( CoreSession coreSession , ValidatorsRule validatorsRule , Map < String , String > parameters ) throws ClientException { this . coreSession = coreSession ; this . parameters = parameters ; this . validatorsRule = validatorsRule ; if ( this . parameters == null ) { this . parameters = new HashMap < String , String > ( ) ; } } public void init ( CoreSession coreSession , Map < String , String > parameters ) throws ClientException { init ( coreSession , null , parameters ) ; } public String getName ( ) { return this . getClass ( ) . getSimpleName ( ) ; } protected String getParameter ( String name ) { return parameters . get ( name ) ; } protected boolean isSnapshotingEnabled ( ) { String snap = getParameter ( ENABLE_SNAPSHOT ) ; if ( snap == null ) { return false ; } else { return snap . equalsIgnoreCase ( \"true\" ) ; } } protected String getTargetPublishedDocumentState ( ) { return getParameter ( TARGET_PUBLISHED_DOCUMENT_STATE ) ; } public PublishedDocument publishDocument ( DocumentModel doc , PublicationNode targetNode ) throws ClientException { return publishDocument ( doc , targetNode , null ) ; } protected boolean needToVersionDocument ( DocumentModel doc ) { if ( ! doc . isVersion ( ) && doc . isVersionable ( ) ) { return true ; } return false ; } public DocumentModel snapshotDocumentBeforePublish ( DocumentModel doc ) throws ClientException { if ( isSnapshotingEnabled ( ) && needToVersionDocument ( doc ) ) { if ( doc . isCheckedOut ( ) ) { doc . checkIn ( VersioningOption . MINOR , null ) ; } coreSession . save ( ) ; List < DocumentModel > versions = coreSession . getVersions ( doc . getRef ( ) ) ; return versions . get ( versions . size ( ) - 1 ) ; } else { return doc ; } } public String [ ] getValidatorsFor ( DocumentModel dm ) throws PublishingValidatorException { return validatorsRule . computesValidatorsFor ( dm ) ; } public ValidatorsRule getValidatorsRule ( ) throws PublishingValidatorException { return validatorsRule ; } public void validatorPublishDocument ( PublishedDocument publishedDocument , String comment ) throws ClientException { } public void validatorRejectPublication ( PublishedDocument publishedDocument , String comment ) throws ClientException { } public boolean canManagePublishing ( PublishedDocument publishedDocument ) throws ClientException { return false ; } public boolean hasValidationTask ( PublishedDocument publishedDocument ) throws ClientException { return false ; } protected void notifyEvent ( PublishingEvent event , DocumentModel doc , CoreSession coreSession ) throws PublishingException { try { notifyEvent ( event . name ( ) , null , null , null , doc , coreSession ) ; } catch ( ClientException e ) { throw new PublishingException ( e ) ; } } protected void notifyEvent ( String eventId , Map < String , Serializable > properties , String comment , String category , DocumentModel dm , CoreSession coreSession ) throws ClientException { if ( category == null ) { category = DocumentEventCategories . EVENT_DOCUMENT_CATEGORY ; } if ( properties == null ) { properties = new HashMap < String , Serializable > ( ) ; } properties . put ( CoreEventConstants . REPOSITORY_NAME , dm . getRepositoryName ( ) ) ; properties . put ( CoreEventConstants . SESSION_ID , coreSession . getSessionId ( ) ) ; properties . put ( CoreEventConstants . DOC_LIFE_CYCLE , dm . getCurrentLifeCycleState ( ) ) ; DocumentEventContext ctx = new DocumentEventContext ( coreSession , coreSession", "gt": ". getPrincipal ( ) , dm ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1281, "input": "<s> package org . msl . simple . gmfmap . model . triggers . parent ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . gmfgraph . BasicFont ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . GMFGraphFactory ; import org . eclipse . gmf . gmfgraph . Label ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse . gmf . mappings . FeatureLabelMapping ; import org . eclipse . gmf . mappings . GMFMapFactory ; import org . eclipse . gmf . mappings . NodeMapping ; import org . eclipse . gmf . mappings . TopNodeReference ; import org . eclipse . gmf . tooldef . CreationTool ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; class NewTopNodeTrigger extends NewElementTrigger { protected SimpleNode newSimpleNode ; protected SimpleParentNode parent ; public NewTopNodeTrigger ( TransactionalEditingDomain domain , SimpleParentNode parent , SimpleNode newSimpleNode ) { super ( domain , newSimpleNode ) ; this . newSimpleNode = newSimpleNode ; this . parent = parent ; } @ Override public void executeTrigger ( ) { Node newNode = GMFGraphFactory . eINSTANCE . createNode ( ) ; DiagramLabel newLabel = GMFGraphFactory . eINSTANCE . createDiagramLabel ( ) ; Label parentLabel = getLabelFigure ( parent ) ; BasicFont parentFont = parentLabel != null ? ( BasicFont ) parentLabel . getFont ( ) : null ; updateCanvas ( newNode , newLabel , parentFont ) ; CreationTool newCreationTool = createNewTool ( ) ; updateMapping ( ( SimpleMapping ) parent , newNode , newLabel , newCreationTool ) ; } protected void updateCanvas ( Node newNode , DiagramLabel newLabel , BasicFont parentFont ) { canvasFactory . createDefaultRoundedRectangleWithLabel ( newNode , newLabel , true , parentFont ) ; } protected void updateMapping ( SimpleMapping mapping , Node newNode , DiagramLabel newLabel , CreationTool newCreationTool ) { NodeMapping newNodeMapping = createNewNodeMapping ( newNode , newLabel , newCreationTool ) ; TopNodeReference newTopNodeReference = GMFMapFactory . eINSTANCE . createTopNodeReference ( ) ; newTopNodeReference . setOwnedChild ( newNodeMapping ) ; mapping . getMapping ( ) . getNodes ( ) . add ( newTopNodeReference ) ; newSimpleNode . setNodeReference ( newTopNodeReference ) ; } protected NodeMapping createNewNodeMapping ( Node newNode ,", "gt": "DiagramLabel newLabel , CreationTool newCreationTool )", "prediction": "DiagramLabel newLabel , CreationTool newCreationTool )\n", "label": 0}
{"id": 14276, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo . ecm . automation . TypeAdapter ; import org . nuxeo . ecm . core . api . DocumentModel ; public class DocModelToDocRef implements TypeAdapter { public Object getAdaptedValue (", "gt": "OperationContext ctx , Object objectToAdapt ) throws TypeAdaptException", "prediction": ")\n", "label": 1}
{"id": 982, "input": "<s> package com . shopzilla . api . client . model . request ; public class ClassificationRequest extends AbstractSearchRequest { private String keyword ; private Boolean showAll ; public String getKeyword ( ) { return keyword ; } public void setKeyword ( String keyword ) {", "gt": "this . keyword = keyword ;", "prediction": "this . keyword = keyword ;\n", "label": 0}
{"id": 14285, "input": "<s> package org . restlet . test . bench ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . data . Protocol ; import org . restlet . engine . ConnectorHelper ; import org . restlet . engine . Engine ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; public class NioClient { public static void main ( String [ ] args ) throws Exception { ConnectorHelper < Client > helper ; helper = new org . restlet . engine . connector . HttpClientHelper ( null ) ; Engine . getInstance ( ) . getRegisteredClients ( ) . add ( 0 , helper ) ; final Client client = new Client ( new Context ( ) , Protocol . HTTP ) ; String uri = \"http://127.0.0.1:7777/\" ; int iterations = 100 ; ClientResource cr = new ClientResource ( uri ) ; cr . setRetryOnError ( false ) ; cr . setNext ( client ) ; Representation r = null ; System . out . println ( \"Calling resource: \" + uri + \" \" + iterations + \" times\" ) ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < iterations ; i ++ ) { r = cr . get ( ) ; System . out . println ( \"Copying to the local file \" + i + \"/\" + iterations ) ; ClientResource fr = new ClientResource ( \"file://C/Test/run\" + i + \".pdf\" ) ; fr", "gt": ". put ( r ) ;", "prediction": ". setRetryOnError ( false ) ;\n", "label": 1}
{"id": 2190, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . AllocateResource ; import org . jjflyboy . tjpeditor . project . AllocateResourceAttribute ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Resource ; public class AllocateResourceImpl extends MinimalEObjectImpl . Container implements AllocateResource { protected Resource resource ; protected EList < AllocateResourceAttribute > attributes ; protected AllocateResourceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getAllocateResource ( ) ; } public Resource getResource ( ) { if ( resource != null && resource . eIsProxy ( ) ) { InternalEObject oldResource = ( InternalEObject ) resource ; resource = ( Resource ) eResolveProxy ( oldResource ) ; if ( resource != oldResource ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . ALLOCATE_RESOURCE__RESOURCE , oldResource , resource ) ) ; } } return resource ; } public Resource basicGetResource ( ) { return resource ; } public void setResource ( Resource newResource ) { Resource oldResource = resource ; resource = newResource ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . ALLOCATE_RESOURCE__RESOURCE , oldResource , resource ) ) ; } public EList < AllocateResourceAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < AllocateResourceAttribute > ( AllocateResourceAttribute . class , this , ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . ALLOCATE_RESOURCE__RESOURCE : if ( resolve ) return getResource ( ) ; return basicGetResource ( ) ; case ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES : return getAttributes ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . ALLOCATE_RESOURCE__RESOURCE : setResource ( ( Resource ) newValue ) ; return ; case ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES : getAttributes ( ) . clear ( ) ; getAttributes ( ) . addAll ( ( Collection < ? extends AllocateResourceAttribute > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProjectPackage . ALLOCATE_RESOURCE__RESOURCE : setResource ( ( Resource ) null ) ; return ; case ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES : getAttributes ( ) . clear ( ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProjectPackage . ALLOCATE_RESOURCE__RESOURCE : return resource != null ; case ProjectPackage . ALLOCATE_RESOURCE__ATTRIBUTES : return attributes != null &&", "gt": "! attributes . isEmpty ( ) ;", "prediction": "coreType != null ;\n", "label": 0}
{"id": 14288, "input": "<s> package org . mitre . jwt . signer . impl ; import static org . junit . Assert . assertEquals ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . PrivateKey ; import java . security . PublicKey ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mitre . jwt . model . Jwt ; import org . mitre . jwt . model . JwtClaims ; import org . mitre . jwt . model . JwtHeader ; import org . mitre . jwt . signer . JwsAlgorithm ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . SpringJUnit4ClassRunner ; import com . google . gson . JsonIOException ; import com . google . gson . JsonObject ; import com . google . gson . JsonParser ; import com . google . gson . JsonSyntaxException ; @ RunWith ( SpringJUnit4ClassRunner . class ) @ ContextConfiguration ( locations = { \"classpath:test-context.xml\" } ) public class Rsa384Test { URL claimsUrl = this . getClass ( ) . getResource ( \"/jwt/claims\" ) ; URL rs384Url = this . getClass ( ) . getResource ( \"/jwt/rs384\" ) ; Jwt jwt = null ; JwtClaims claims = null ; JwtHeader header = null ; KeyPairGenerator keyGen ; KeyPair keyPair ; PublicKey publicKey ; PrivateKey privateKey ; @ Before public void setUp", "gt": "( ) throws JsonIOException , JsonSyntaxException , IOException", "prediction": "( ) throws Exception\n", "label": 1}
{"id": 8324, "input": "<s> public class T4916620 { static class BB < T , S > { } static class BD < T > extends BB < T , T > { } void f ( ) { BD < Number > bd = new BD < Number > ( ) ; BB < ? extends Number ,", "gt": "? super Integer > bb = bd ;", "prediction": "S > bd = new BD < ? extends Number , S > ( ) ;\n", "label": 0}
{"id": 14297, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CCombo ; import org . eclipse . swt . widgets . Composite ; abstract class AbstractComboBoxCellEditor extends CellEditor { public static final int DROP_DOWN_ON_MOUSE_ACTIVATION = 1 ; public static final int DROP_DOWN_ON_KEY_ACTIVATION = 1 << 1 ; public static final int DROP_DOWN_ON_PROGRAMMATIC_ACTIVATION = 1 << 2 ; public static final int DROP_DOWN_ON_TRAVERSE_ACTIVATION = 1 << 3 ; private int activationStyle = SWT . NONE ; AbstractComboBoxCellEditor ( Composite parent , int style ) { super ( parent , style ) ; } AbstractComboBoxCellEditor ( ) { } public void activate ( ColumnViewerEditorActivationEvent activationEvent ) { super . activate ( activationEvent ) ; if ( activationStyle != SWT . NONE ) { boolean dropDown = false ; if ( ( activationEvent . eventType == ColumnViewerEditorActivationEvent . MOUSE_CLICK_SELECTION || activationEvent . eventType == ColumnViewerEditorActivationEvent . MOUSE_DOUBLE_CLICK_SELECTION ) && ( activationStyle & DROP_DOWN_ON_MOUSE_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent . KEY_PRESSED && ( activationStyle & DROP_DOWN_ON_KEY_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent . PROGRAMMATIC && ( activationStyle & DROP_DOWN_ON_PROGRAMMATIC_ACTIVATION ) != 0 ) { dropDown = true ; } else if ( activationEvent . eventType == ColumnViewerEditorActivationEvent . TRAVERSAL && ( activationStyle & DROP_DOWN_ON_TRAVERSE_ACTIVATION ) != 0 ) { dropDown = true ; } if ( dropDown ) { getControl ( ) . getDisplay ( ) . asyncExec", "gt": "( new Runnable ( )", "prediction": "( ) ;\n", "label": 1}
{"id": 422, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; public class WErrorLast extends JavacTestingAbstractProcessor { @ Override public boolean process (", "gt": "Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv )", "prediction": ")\n", "label": 0}
{"id": 14307, "input": "<s> package org . restlet . test . ext . odata . cafecustofeeds ; public class Item { private String description ; private String id ; public Item ( ) { super ( ) ; } public Item ( String id ) { this ( ) ; this . id = id ; } public String getDescription ( ) { return description ; } public String getId ( ) { return id ; } public void setDescription ( String description ) { this . description = description ; }", "gt": "public void setId ( String id )", "prediction": "public void setId ( String id )\n", "label": 1}
{"id": 9092, "input": "<s> class a { public static void main ( String [ ] args ) { System . out . println ( new a ( ) . m ( ) ) ; } int m ( ) {", "gt": "float f1 = 1f + 2f ;", "prediction": "return m ;\n", "label": 0}
{"id": 14313, "input": "<s> package org . apache . sqoop . mapreduce ; import java . io . IOException ; import java . sql . Connection ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import com . cloudera . sqoop . lib . SqoopRecord ; import com . cloudera . sqoop . mapreduce . ExportOutputFormat ; public class ExportBatchOutputFormat < K extends SqoopRecord , V > extends ExportOutputFormat < K , V > { private static final Log LOG = LogFactory . getLog ( ExportBatchOutputFormat . class ) ; @ Override public RecordWriter < K , V > getRecordWriter ( TaskAttemptContext context ) throws IOException { try { return new ExportBatchRecordWriter ( context ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } public class ExportBatchRecordWriter extends ExportRecordWriter { public ExportBatchRecordWriter ( TaskAttemptContext context ) throws ClassNotFoundException , SQLException { super ( context ) ; } @ Override protected boolean isBatchExec ( ) { return true ; } @ Override protected PreparedStatement getPreparedStatement ( List < SqoopRecord > userRecords ) throws SQLException { PreparedStatement stmt = null ; Connection conn = getConnection ( ) ; synchronized ( conn ) { stmt = conn . prepareStatement ( getInsertStatement ( userRecords . size ( ) ) ) ; } for ( SqoopRecord record : userRecords ) { record . write ( stmt , 0 ) ; stmt . addBatch ( ) ; } return stmt ; } protected String getInsertStatement ( int numRows ) { StringBuilder sb =", "gt": "new StringBuilder ( ) ;", "prediction": "new StringBuilder ( ) ;\n", "label": 1}
{"id": 5357, "input": "<s> import java . io . * ; import java . util . * ; import sun . misc . * ; public class T6873845 { public static void main ( String ... args ) throws Exception { new T6873845 ( ) . run ( ) ; } public void run ( ) throws Exception { String out = compile ( Arrays . asList ( \"-XDrawDiagnostics\" , \"-X\" ) ) ; if ( out . contains ( \"sunapi\" ) ) throw new Exception ( \"unexpected output for -X\" ) ; String warn1 = \"T6873845.java:72:9: compiler.warn.sun.proprietary: sun.misc.Unsafe\" + newline ; String warn2 = \"T6873845.java:77:9: compiler.warn.sun.proprietary: sun.misc.Unsafe\" + newline ; String note1 = \"- compiler.note.sunapi.filename: T6873845.java\" + newline ; String note2 = \"- compiler.note.sunapi.recompile\" + newline ; test ( opts ( ) , warn1 + warn2 + \"2 warnings\" + newline ) ; test ( opts ( \"-XDenableSunApiLintControl\" ) , note1 + note2 ) ; test ( opts ( \"-XDenableSunApiLintControl\" , \"-XDsuppressNotes\" ) , \"\" ) ; test ( opts ( \"-XDenableSunApiLintControl\" , \"-Xlint:sunapi\" ) , warn1 + \"1 warning\" + newline ) ; test ( opts ( \"-XDenableSunApiLintControl\" , \"-Xlint:all\" ) , warn1 + \"1 warning\" + newline ) ; test ( opts ( \"-XDenableSunApiLintControl\" , \"-Xlint:all,-sunapi\" ) , note1 + note2 ) ; } List < String > opts ( String ... opts ) { return Arrays . asList ( opts ) ; } void test ( List < String > opts , String expect ) throws Exception { List < String > args = new ArrayList < String > ( ) ; args . addAll ( opts ) ; args . add ( \"-d\" ) ; args . add ( testClasses . getPath ( ) ) ; args . add ( new File ( testSrc , \"T6873845.java\" ) . getPath ( ) ) ; compile ( args ) ; args . add ( 0 , \"-XDrawDiagnostics\" ) ; String out = compile ( args ) ; if ( ! out . equals ( expect ) ) throw new Exception ( \"unexpected output from compiler\" ) ; } String compile ( List < String > args ) throws Exception { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; System . out . println ( \"compile: \" + args ) ; int rc = com . sun . tools . javac . Main . compile ( args . toArray ( new String [ args . size ( ) ] ) , pw ) ; pw . close ( ) ; String out = sw . toString ( ) ; System . out . println ( out ) ; if ( rc != 0 ) throw new Exception ( \"compilation failed unexpectedly\" ) ; return out ; } void m1 ( ) { Unsafe . getUnsafe ( ) ; } @ SuppressWarnings ( \"sunapi\" ) void m2 ( ) { Unsafe . getUnsafe ( ) ; } private File testSrc = new File", "gt": "( System . getProperty ( \"test.src\" , \".\" ) ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 14325, "input": "<s> package org . eclipse . ui . internal . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ;", "gt": "import org . eclipse . core . runtime . IExecutableExtension ;", "prediction": "import org . eclipse . core . runtime . PlatformUI ;\n", "label": 1}
{"id": 3221, "input": "<s> public class InterfaceCast1 { public static void main ( String [ ] args ) throws Exception { } } interface Collection < E > { < T > T [ ] toArray ( T [ ] a ) ; } interface Set < E > extends Collection < E > { < T > T [ ] toArray ( T [ ] a ) ; } interface", "gt": "SortedSet < E > extends Set < E >", "prediction": "Set < E > extends Collection < E >\n", "label": 0}
{"id": 14338, "input": "<s> package com . xjtu . dao ; import com . xjtu . domain . User ; import org . junit . Test ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . test . context . ContextConfiguration ; import org . springframework . test . context . junit4 . AbstractTransactionalJUnit4SpringContextTests ; import org . springframework . test . context . transaction . TransactionConfiguration ; import static org . junit . Assert . assertEquals ; @ ContextConfiguration ( locations = { \"classpath:applicationContext.xml\" } ) @ TransactionConfiguration ( defaultRollback = false ) public class UserDaoTest extends AbstractTransactionalJUnit4SpringContextTests { @ Autowired private UserDao userDao ; @ Test public void should_select_all_names ( ) throws Exception { userDao . deleteAll ( ) ; User user = new User ( \"wangyan\" , \"xjty\" ) ; userDao . save ( user ) ; assertEquals ( 1 , userDao .", "gt": "all ( ) . size ( ) ) ;", "prediction": "getId ( ) ) ;\n", "label": 1}
{"id": 788, "input": "<s> package org . parboiled . examples . time ; import org . parboiled . Parboiled ; import org . parboiled . parserunners . RecoveringParseRunner ; import org . parboiled . common . StringUtils ; import static org . parboiled . support . ParseTreeUtils . printNodeTree ; import org . parboiled . support . ParsingResult ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { TimeParser parser = Parboiled . createParser ( TimeParser . class ) ; while ( true ) { System . out . print ( \"Enter a time expression (hh:mm(:ss)?, hh(mm(ss)?)? or h(mm)?, single RETURN to exit)!\\n\" ) ; String input = new Scanner ( System . in ) . nextLine ( ) ; if ( StringUtils . isEmpty ( input ) ) break ; ParsingResult < ? > result = new RecoveringParseRunner ( parser . Time ( ) ) . run ( input ) ; System . out . println ( input + \" = \" + result . parseTreeRoot", "gt": ". getValue ( ) + '\\n' ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 14339, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . sense . information . EightByteInformation ; import org . jscsi . target . util . BitManip ; public final class InformationSenseDataDescriptor extends SenseDataDescriptor { private static final int VALID_FLAG_BYTE_INDEX = 2 ; private static final int INFORMATION_INDEX = 4 ; private final boolean valid = true ; private final EightByteInformation information ; public InformationSenseDataDescriptor ( final EightByteInformation information ) { super ( SenseDataDescriptorType . INFORMATION , 0x0a ) ; this . information = information ; } @ Override protected final void serializeSpecificFields ( final ByteBuffer byteBuffer , final int index ) {", "gt": "byte b = 0 ;", "prediction": "this . byteBuffer = byteBuffer ;\n", "label": 1}
{"id": 1779, "input": "<s> package com . sun . tools . classfile ; import java . io . ByteArrayInputStream ; import java . io . DataInputStream ; import java . io . IOException ; public class SourceDebugExtension_attribute extends Attribute { SourceDebugExtension_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; debug_extension = new byte [ attribute_length ] ; cr . readFully ( debug_extension ) ; } public SourceDebugExtension_attribute ( ConstantPool constant_pool , byte [ ] debug_extension ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . SourceDebugExtension ) , debug_extension ) ; } public SourceDebugExtension_attribute ( int name_index , byte [ ] debug_extension ) { super ( name_index , debug_extension . length ) ; this . debug_extension = debug_extension ; } public String getValue ( ) { DataInputStream d = new", "gt": "DataInputStream ( new ByteArrayInputStream ( debug_extension ) ) ;", "prediction": "ByteArrayInputStream ( ) ;\n", "label": 0}
{"id": 14340, "input": "<s> package org . fuzzydb . core ; import java . net . InetSocketAddress ; public interface SettingsMBean { public boolean isWindows ( ) ; public String getPrimaryServer ( ) ; public int getPrimaryServerPort ( ) ; public String getSecondaryServer ( ) ; public int getSecondaryServerPort ( ) ; public boolean getCompressLogs ( ) ; public boolean getXmlLogs ( ) ; public String getDbRoot ( ) ; public String getPostcodeRoot ( ) ; public String getIpLookupRoot ( ) ; public int getListenPort ( ) ; public String getLogDir ( ) ; public String getReposDir ( ) ; public String getTxDir ( ) ; public int getLeafCriticalMass ( ) ; public int getDefaultTargetNumResults ( ) ;", "gt": "public float getDefaultScoreThreshold ( ) ;", "prediction": "}\n", "label": 1}
{"id": 7539, "input": "<s> class T6863465a { static class a { static interface b { } } static class c extends a implements z . y { } static class x { static interface y { } } static class z extends", "gt": "x implements c . b", "prediction": "a implements z . z\n", "label": 0}
{"id": 14341, "input": "<s> package jssp . algorithm . tabusearch ; import ailibrary . algorithm . tabusearch . * ; public class JsspLongTermMemory implements LongTermMemory { public JsspLongTermMemory ( ) { } public void clearMemory ( ) { }", "gt": "public void memorizeSolution ( Solution soln , boolean newBestSoln )", "prediction": "}\n", "label": 1}
{"id": 189, "input": "<s> package com . asakusafw . example . direct . seqfile . writable ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import java . util . Date ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . io . Writable ; public class ItemInfoWritable implements Writable { protected String itemName ; protected String departmentCode ; protected String departmentName ; protected String categoryCode ; protected String categoryName ; protected int unitSellingPrice ; protected Date registeredDate ; protected Date beginDate ; protected Date endDate ; public String getItemName ( ) { return itemName ; } public void setItemName ( String itemName ) { this . itemName = itemName ; } public String getDepartmentCode ( ) { return departmentCode ; } public void setDepartmentCode ( String departmentCode ) { this . departmentCode = departmentCode ; } public String getDepartmentName ( ) { return departmentName ; } public void setDepartmentName ( String departmentName ) { this . departmentName = departmentName ; } public String getCategoryCode ( ) { return categoryCode ; } public void setCategoryCode ( String categoryCode ) { this . categoryCode = categoryCode ; } public String getCategoryName ( ) { return categoryName ; } public void setCategoryName ( String categoryName ) { this . categoryName = categoryName ; } public int getUnitSellingPrice ( ) { return unitSellingPrice ; } public void setUnitSellingPrice ( int unitSellingPrice ) { this . unitSellingPrice = unitSellingPrice ; } public Date getRegisteredDate ( ) { return registeredDate ; } public void setRegisteredDate ( Date registeredDate ) { this . registeredDate = registeredDate ; } public Date getBeginDate ( ) { return beginDate ; } public void setBeginDate ( Date beginDate ) { this . beginDate = beginDate ; } public Date getEndDate ( ) { return endDate ; } public void setEndDate ( Date endDate ) { this . endDate = endDate ; } @ Override public void write ( DataOutput out ) throws IOException { Text . writeString ( out , itemName ) ; Text . writeString ( out , departmentCode ) ; Text . writeString ( out , departmentName ) ; Text . writeString ( out , categoryCode ) ; Text . writeString ( out , categoryName ) ; out . writeInt ( unitSellingPrice ) ; out . writeLong ( registeredDate", "gt": ". getTime ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14343, "input": "<s> package org . tinyradius . dictionary ; import java . io . IOException ; import java . io . InputStream ; public class DefaultDictionary extends MemoryDictionary { public static Dictionary getDefaultDictionary ( ) { return instance ; } private DefaultDictionary ( ) { } private static final String DICTIONARY_RESOURCE = \"org/tinyradius/dictionary/default_dictionary\" ; private static DefaultDictionary instance = null ; static { try { instance = new DefaultDictionary ( ) ; InputStream source = DefaultDictionary . class . getClassLoader ( )", "gt": ". getResourceAsStream ( DICTIONARY_RESOURCE ) ;", "prediction": ";\n", "label": 1}
{"id": 4439, "input": "<s> package org . ofbiz . entity . model ; import java . io . PrintWriter ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TimeZone ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilPlist ; import org . ofbiz . base . util . UtilTimer ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . jdbc . DatabaseUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class ModelEntity extends ModelInfo implements Comparable < ModelEntity > , Serializable { public static final String module = ModelEntity . class . getName ( ) ; public static final String STAMP_FIELD = \"lastUpdatedStamp\" ; public static final String STAMP_TX_FIELD = \"lastUpdatedTxStamp\" ; public static final String CREATE_STAMP_FIELD = \"createdStamp\" ; public static final String CREATE_STAMP_TX_FIELD = \"createdTxStamp\" ; protected ModelReader modelReader = null ; protected String entityName = \"\" ; protected String tableName = \"\" ; protected String packageName = \"\" ; protected String dependentOn = \"\" ; protected Integer sequenceBankSize = null ; protected List < ModelField > fields = FastList . newInstance ( ) ; protected Map < String , ModelField > fieldsMap = null ; protected List < ModelField > pks = FastList . newInstance ( ) ; protected List < ModelField > nopks = FastList . newInstance ( ) ; protected List < ModelRelation > relations = FastList . newInstance ( ) ; protected List < ModelIndex", "gt": "> indexes = FastList . newInstance ( ) ;", "prediction": "> indices = FastList . newInstance ( ) ;\n", "label": 0}
{"id": 14349, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers ; import java . lang . reflect . InvocationTargetException ; import java . util . logging . Logger ; import javax . ws . rs . WebApplicationException ; import org . restlet . ext . jaxrs . InstantiateException ; import org . restlet . ext . jaxrs . ObjectFactory ; import org . restlet . ext . jaxrs . internal . core . ThreadLocalizedContext ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalBeanSetterTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalConstrParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalFieldTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnClassException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathParamTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingConstructorException ; import org . restlet . ext . jaxrs", "gt": ". internal . wrappers . provider . ExtensionBackwardMapping ;", "prediction": ". internal . exceptions . MissingConstructorException ;\n", "label": 1}
{"id": 1761, "input": "<s> package LizaCraft . Entity ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . entity . Arrow ; import org . bukkit . entity . Entity ; import org . bukkit . entity . LivingEntity ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaArrow ; import Liza . LizaEntity ; import Liza . LizaLivingEntity ; import Liza . LizaServer ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; public class LizaCraftArrow implements LizaArrow { private Arrow arrow ; public LizaCraftArrow ( Arrow arrow ) { this . arrow = arrow ; } @ Override public boolean doesBounce ( ) { return this . arrow . doesBounce ( ) ; } @ Override public LizaLivingEntity getShooter ( ) { return new LizaCraftLivingEntity ( this . arrow . getShooter ( ) ) ; } @ Override public void setBounce ( boolean doesBounce ) { this . arrow . setBounce ( doesBounce ) ; } @ Override public void setShooter ( LivingEntity shooter ) { this . arrow . setShooter ( shooter ) ; } @ Override public boolean eject ( ) { return this . arrow . eject ( ) ; } @ Override public int getEntityId ( ) { return this . arrow . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . arrow . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . arrow . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . arrow . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . arrow . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . arrow . getMaxFireTicks ( ) ; } @ Override @ Deprecated public List < Entity > getNearbyEntities ( double x , double y , double z ) { List < Entity > el = this . arrow . getNearbyEntities ( x , y , z ) ; for ( Entity e : el ) { el . remove ( e ) ; LizaEntity le", "gt": "= new LizaCraftEntity ( e ) ;", "prediction": "= ( LizaEntity ) el ;\n", "label": 0}
{"id": 14350, "input": "<s> package org . restlet . engine . adapter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PushbackInputStream ; import java . security . cert . Certificate ; import java . util . List ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . Response ; import org . restlet . Server ; import org . restlet . data . Digest ; import org . restlet . engine . ConnectorHelper ; import org . restlet . engine . header . ContentType ; import org . restlet . engine . header . DispositionReader ; import org . restlet . engine . header . EncodingReader ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . HeaderReader ; import org . restlet . engine . header . HeaderUtils ; import org . restlet . engine . header . LanguageReader ; import org . restlet . engine . header . RangeReader ; import org . restlet . engine . io . BioUtils ; import org . restlet . engine . util . Base64 ; import org . restlet . engine . util . StringUtils ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . Representation ; import org . restlet . service . ConnectorService ; public abstract class ServerCall extends Call { private volatile boolean hostParsed ; public ServerCall ( Server server ) { this ( server . getAddress ( ) , server . getPort ( ) ) ; } public ServerCall ( String serverAddress , int serverPort ) { setServerAddress ( serverAddress ) ; setServerPort ( serverPort ) ; this . hostParsed = false ; } public abstract boolean abort ( ) ; public void complete ( ) { } public List < Certificate > getCertificates ( ) { return null ; } public String getCipherSuite ( ) { return null ; } protected long getContentLength ( ) { return HeaderUtils . getContentLength ( getRequestHeaders ( ) ) ; } @ Override public String getHostDomain ( ) { if ( ! this . hostParsed ) { parseHost ( ) ; } return super . getHostDomain ( ) ; } @ Override public int getHostPort ( ) { if ( ! this . hostParsed ) { parseHost ( ) ; } return super . getHostPort ( ) ; } public Representation getRequestEntity ( ) { Representation result = null ; long contentLength = getContentLength ( ) ; boolean chunkedEncoding = HeaderUtils . isChunkedEncoding ( getRequestHeaders ( ) ) ; boolean connectionClosed = HeaderUtils . isConnectionClose ( getRequestHeaders ( ) ) ; if ( ( ( contentLength != Representation . UNKNOWN_SIZE ) && ( contentLength != 0 ) ) || chunkedEncoding || connectionClosed ) { InputStream requestStream = getRequestEntityStream ( contentLength ) ; if ( connectionClosed ) { PushbackInputStream pbi = new PushbackInputStream ( requestStream ) ; try { int next = pbi . read ( ) ; if ( next != - 1 ) { pbi . unread ( next ) ; requestStream = pbi ; } else { requestStream = null ; } } catch ( IOException e ) { getLogger ( ) . fine ( \"Unable to read request entity\" ) ; } } if ( requestStream != null ) { result = new InputRepresentation ( requestStream , null , contentLength ) ; } else { result = new EmptyRepresentation ( ) ; } result . setSize ( contentLength ) ; } else { result = new EmptyRepresentation ( ) ; } for ( Header header : getRequestHeaders ( ) ) { if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_ENCODING ) ) { new EncodingReader ( header . getValue ( ) ) . addValues ( result . getEncodings ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_LANGUAGE ) ) { new LanguageReader ( header . getValue ( ) ) . addValues ( result . getLanguages ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_TYPE ) ) { ContentType contentType = new ContentType ( header . getValue ( ) ) ; result . setMediaType ( contentType . getMediaType ( ) ) ; result . setCharacterSet ( contentType . getCharacterSet ( ) ) ; } else if ( header . getName ( ) . equalsIgnoreCase ( HeaderConstants . HEADER_CONTENT_RANGE ) ) { RangeReader . update ( header . getValue", "gt": "( ) , result ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 6843, "input": "<s> package ar . com . fdvs . dj . domain . entities . columns ; import ar . com . fdvs . dj . domain . constants . ImageScaleMode ; import ar . com . fdvs . dj . domain . entities . Entity ; public class ImageColumn extends SimpleColumn { private static", "gt": "final long serialVersionUID = Entity . SERIAL_VERSION_UID ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 14363, "input": "<s> package org . eclipse . ui . dialogs ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . ui . IFileEditorMapping ; public class FileEditorMappingContentProvider implements IStructuredContentProvider { public final static FileEditorMappingContentProvider INSTANCE = new FileEditorMappingContentProvider ( ) ; private FileEditorMappingContentProvider ( ) { super ( ) ; } public void dispose ( ) { } public Object [ ] getElements ( Object element ) { IFileEditorMapping [ ] array = ( IFileEditorMapping", "gt": "[ ] ) element ;", "prediction": "[ ] ) element ;\n", "label": 1}
{"id": 2772, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public class JavascriptWinTitle { private static final String BUGID = \"4645058\" ; private static final String BUGNAME = \"JavascriptWinTitle\" ; private static final String FS = System . getProperty ( \"file.separator\" ) ; private static final String PS = System . getProperty ( \"path.separator\" ) ; private static final String LS = System . getProperty ( \"line.separator\" ) ; private static final String TMPDEST_DIR1 = \".\" + FS + \"docs1\" + FS ; private static final String TMPDEST_DIR2 = \".\" + FS + \"docs2\" + FS ; public static int subtestNum = 0 ; public static int numSubtestsPassed = 0 ; public static void main ( String [ ] args ) { String srcdir = System . getProperty ( \"test.src\" , \".\" ) ; runJavadoc ( new String [ ] { \"-d\" , TMPDEST_DIR1 , \"-doctitle\" , \"Document Title\" , \"-windowtitle\" , \"Window Title\" , \"-overview\" , ( srcdir + FS + \"overview.html\" ) , \"-linkoffline\" , \"http://java.sun.com/j2se/1.4/docs/api\" , srcdir , \"-sourcepath\" , srcdir , \"p1\" , \"p2\" } ) ; runTestsOnHTML ( testArray ) ; printSummary ( ) ; } public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( javadocArgs ) != 0 ) { throw new Error ( \"Javadoc failed to execute\" ) ; } } private static final String [ ] [ ] testArray = { { \"<script type=\\\"text/javascript\\\">\" , TMPDEST_DIR1 + \"overview-summary.html\" } , { \"<body>\" , TMPDEST_DIR1 + \"overview-summary.html\" } , { \"<body>\" , TMPDEST_DIR1 + FS + \"p1\" + FS + \"package-summary.html\" } , { \"<body>\" , TMPDEST_DIR1 + \"overview-frame.html\" } , { \"<body>\" , TMPDEST_DIR1 + \"allclasses-frame.html\" } , { \"<body>\" , TMPDEST_DIR1 + FS + \"p1\" + FS + \"package-frame.html\" } , { \"<script type=\\\"text/javascript\\\"><!--\" + LS + \"    if (location.href.indexOf('is-external=true') == -1) {\" + LS + \"        parent.document.title=\\\"C (Window Title)\\\";\" + LS + \"    }\" + LS + \"//-->\" + LS + \"</script>\" , TMPDEST_DIR1 + FS + \"p1\" + FS + \"C.html\" } } ; public static void runTestsOnHTML ( String [ ] [ ] testArray ) { for ( int i = 0 ; i < testArray . length ; i ++ ) { subtestNum += 1 ; String fileString = readFileToString ( testArray [ i ] [ 1 ] ) ; String stringToFind = testArray [ i ] [ 0 ] ; if ( findString ( fileString , stringToFind ) == - 1 ) { System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" for bug \" + BUGID + \" (\" + BUGNAME + \") FAILED\\n\" + \"when searching for:\\n\" + stringToFind ) ; } else { numSubtestsPassed += 1 ; System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" passed:\\n\" + stringToFind ) ; } } } public static void printSummary ( ) { if ( numSubtestsPassed == subtestNum ) { System . out . println ( \"\\nAll \" +", "gt": "numSubtestsPassed + \" subtests passed\" ) ;", "prediction": "numSubtestsPassed ) ;\n", "label": 0}
{"id": 14369, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . text . MessageFormat ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . swt . widgets . Display ; public final class DisplayUtil { private DisplayUtil ( ) { } public static IDisplayLifeCycleAdapter getLCA ( Display display ) { Class < ILifeCycleAdapter > clazz = ILifeCycleAdapter . class ; IDisplayLifeCycleAdapter result = ( IDisplayLifeCycleAdapter ) display . getAdapter ( clazz ) ; if ( result == null ) { throwAdapterException ( clazz ) ; } return result ; } public static String getId ( Display display ) { return getAdapter ( display ) . getId ( ) ; } public static IWidgetAdapter getAdapter ( Display display ) { IWidgetAdapter result = display . getAdapter ( IWidgetAdapter . class ) ; if ( result == null ) { throwAdapterException ( IWidgetAdapter . class ) ; } return result ; } private static void throwAdapterException ( Class clazz ) { String text = \"Could not retrieve an instance of ''{0}''. Probably the \" + \"AdapterFactory was not properly registered.\" ; Object [ ] param = new Object [ ] { clazz . getName ( ) } ; String msg = MessageFormat .", "gt": "format ( text , param ) ;", "prediction": "getMessage ( ) ;\n", "label": 1}
{"id": 5400, "input": "<s> package org . ofbiz . webtools . artifactinfo ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Set ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilURL ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . webapp . control . ConfigXMLReader ; public class ControllerViewArtifactInfo extends ArtifactInfoBase { public static final String module = ControllerViewArtifactInfo . class . getName ( ) ; protected URL controllerXmlUrl ; protected String viewUri ; protected ConfigXMLReader . ViewMap viewInfoMap ; protected ScreenWidgetArtifactInfo screenCalledByThisView = null ; public ControllerViewArtifactInfo ( URL controllerXmlUrl , String viewUri , ArtifactInfoFactory aif ) throws GeneralException { super ( aif ) ; this . controllerXmlUrl = controllerXmlUrl ; this . viewUri = viewUri ; this . viewInfoMap = aif . getControllerViewMap ( controllerXmlUrl , viewUri ) ; if ( this . viewInfoMap == null ) { throw new GeneralException ( \"Could not find Controller View [\" + viewUri + \"] at URL [\" + controllerXmlUrl . toExternalForm ( ) + \"]\" ) ; } if ( this . viewInfoMap == null ) { throw new GeneralException ( \"Controller view with name [\" + viewUri + \"] is not defined in controller file [\" + controllerXmlUrl + \"].\" ) ; } if ( \"screen\" . equals ( this . viewInfoMap . type ) || \"screenfop\" . equals ( this . viewInfoMap . type ) || \"screentext\" . equals ( this . viewInfoMap . type ) || \"screenxml\" . equals ( this . viewInfoMap . type ) ) { String fullScreenName = this . viewInfoMap . page ; if ( UtilValidate . isNotEmpty ( fullScreenName ) ) { int poundIndex = fullScreenName . indexOf ( '#' ) ; this . screenCalledByThisView = this . aif . getScreenWidgetArtifactInfo ( fullScreenName . substring ( poundIndex + 1 ) , fullScreenName . substring ( 0 , poundIndex ) ) ; if ( this . screenCalledByThisView != null ) { UtilMisc . addToSortedSetInMap ( this , aif . allViewInfosReferringToScreen , this . screenCalledByThisView . getUniqueId ( ) ) ; } } } } public URL getControllerXmlUrl ( ) { return this . controllerXmlUrl ; } public String getViewUri ( ) { return this . viewUri ; } @ Override public String getDisplayName ( ) { String location = UtilURL . getOfbizHomeRelativeLocation ( this . controllerXmlUrl ) ; if ( location . endsWith ( \"/WEB-INF/controller.xml\" ) ) { location = location . substring ( 0 , location . length ( ) - 23 ) ; } return this . viewUri + \" (\" + location + \")\" ; } @ Override public String getDisplayType ( ) { return \"Controller View\" ; } @ Override public String getType ( ) { return ArtifactInfoFactory . ControllerViewInfoTypeId ; } @ Override public String getUniqueId ( ) { return this . controllerXmlUrl . toExternalForm ( ) + \"#\" + this . viewUri ; } @ Override public URL getLocationURL ( ) throws MalformedURLException { return this . controllerXmlUrl ; } @ Override public boolean equals ( Object obj ) { if ( obj instanceof ControllerViewArtifactInfo ) { ControllerViewArtifactInfo that = ( ControllerViewArtifactInfo ) obj ; return UtilObject . equalsHelper ( this . controllerXmlUrl , that . controllerXmlUrl ) && UtilObject . equalsHelper ( this . viewUri , that . viewUri ) ; } else { return false ; } } public Set < ControllerRequestArtifactInfo > getRequestsThatThisViewIsResponseTo ( ) { return this . aif . allRequestInfosReferringToView .", "gt": "get ( this . getUniqueId ( ) ) ;", "prediction": "getUniqueId ( ) ;\n", "label": 0}
{"id": 14383, "input": "<s> package io . beancounter . usermanager . services . auth ; import com . google . inject . Inject ; import io . beancounter . commons . model . Service ; import io . beancounter . commons . model . auth . AuthHandler ; import io . beancounter . commons . model . auth . AuthHandlerException ; import io . beancounter . commons . model . User ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Map ; import java . util . Properties ; public final class DefaultServiceAuthorizationManager extends AbstractServiceAuthorizationManager { private static final String SERVICE = \"service\" ; @ Inject public DefaultServiceAuthorizationManager ( Map < Service , AuthHandler > authHandlers ) { for ( Map . Entry < Service , AuthHandler > authHandler : authHandlers . entrySet ( ) ) { handlers . put ( authHandler . getKey ( ) , authHandler . getValue ( ) ) ; } } public static Service buildService ( String service , Properties properties ) { Service serviceObj = new Service ( service ) ; serviceObj . setDescription ( property ( properties , service , \"description\" ) ) ; try { serviceObj . setEndpoint ( new URL ( property ( properties , service , \"endpoint\" ) ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] endpoint is not a valid URL\" , e ) ; } String sessionStr = property ( properties , true , service , \"session\" ) ; if ( sessionStr != null ) { try { serviceObj . setSessionEndpoint ( new URL ( sessionStr ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] session endpoint is not a valid URL\" , e ) ; } } serviceObj . setApikey ( property ( properties , service , \"apikey\" ) ) ; serviceObj . setSecret ( property ( properties , service , \"secret\" ) ) ; try { serviceObj . setOAuthCallback ( new URL ( property ( properties , service , \"oauthcallback\" ) ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] oauth callback endpoint is not a valid URL\" , e ) ; } try { serviceObj . setAtomicOAuthCallback ( new URL ( property ( properties , service , \"atomicoauth\" ) ) ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( \"service [\" + service + \"] oauth callback endpoint is not a valid URL\" , e ) ; } return serviceObj ; } private static String property ( Properties properties , String ... names ) { return property ( properties , false , names ) ; } private static String property ( Properties properties , boolean optional , String ... names ) { String key = SERVICE ; for ( String name : names ) { key += \".\" + name ; } String result = properties . getProperty ( key ) ; if ( ! optional && result == null ) { throw new RuntimeException ( \"[\" + key + \"] is null\" ) ; } return result ; } public User register ( User user , String", "gt": "service , String token ) throws ServiceAuthorizationManagerException", "prediction": "username )\n", "label": 1}
{"id": 4168, "input": "<s> package javax . annotation . processing ; import javax . lang . model . element . Element ; import javax . lang . model . element . TypeElement ; import java . util . Set ; import java . lang . annotation . Annotation ; public interface RoundEnvironment { boolean processingOver ( ) ; boolean errorRaised ( ) ; Set < ? extends Element > getRootElements ( ) ; Set < ? extends Element > getElementsAnnotatedWith", "gt": "( TypeElement a ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 14389, "input": "<s> package org . fuzzydb . client . userobjects ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) public class BaseMutableString implements Serializable { public String value ; public BaseMutableString ( String s ) { value = s ; } @ Override public int hashCode ( ) { return value . hashCode ( ) ; } @ Override public boolean equals ( Object o ) { if ( o instanceof BaseMutableString ) { BaseMutableString rhs = ( BaseMutableString ) o ; return value . equals ( rhs . value ) ; } if ( o instanceof String ) { String rhs =", "gt": "( String ) o ;", "prediction": "( String ) o ;\n", "label": 1}
{"id": 3154, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class CharacterRangeTable_attribute extends Attribute { public static final int CRT_STATEMENT = 0x0001 ; public static final int CRT_BLOCK = 0x0002 ; public static final int CRT_ASSIGNMENT = 0x0004 ; public static final int CRT_FLOW_CONTROLLER = 0x0008 ; public static final int CRT_FLOW_TARGET = 0x0010 ; public static final int CRT_INVOKE = 0x0020 ; public static final int CRT_CREATE = 0x0040 ; public static final int CRT_BRANCH_TRUE = 0x0080 ; public static final int CRT_BRANCH_FALSE = 0x0100 ; CharacterRangeTable_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; int character_range_table_length = cr . readUnsignedShort ( ) ; character_range_table = new Entry [ character_range_table_length ] ; for ( int i = 0 ; i < character_range_table_length ; i ++ ) character_range_table [ i ] = new Entry ( cr ) ; } public CharacterRangeTable_attribute ( ConstantPool constant_pool , Entry [ ] character_range_table ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . CharacterRangeTable ) , character_range_table ) ; } public CharacterRangeTable_attribute ( int name_index , Entry [ ] character_range_table ) { super ( name_index , 2 + character_range_table . length * Entry . length ( ) ) ; this . character_range_table = character_range_table ; } public < R , D > R accept ( Visitor < R , D > visitor , D data ) { return visitor . visitCharacterRangeTable ( this , data ) ; } public final Entry [ ] character_range_table ; public static class Entry { Entry ( ClassReader cr ) throws IOException { start_pc = cr . readUnsignedShort ( ) ; end_pc = cr . readUnsignedShort ( ) ; character_range_start", "gt": "= cr . readInt ( ) ;", "prediction": "_pc = cr . readUnsignedShort ( ) ;\n", "label": 0}
{"id": 14394, "input": "<s> package org . modelgoon . dao ; public class DAOException extends Exception { public DAOException ( final String message , final Throwable cause ) { super ( message , cause ) ; }", "gt": "public DAOException ( final Throwable cause )", "prediction": "}\n", "label": 1}
{"id": 3260, "input": "<s> package ar . com . fdvs . dj . test . crosstab ; import java . awt . Color ; import java . util . Date ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJCrosstabColumn ; import ar . com . fdvs . dj . domain . DJCrosstabRow ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . CrosstabBuilder ; import ar . com . fdvs . dj . domain . builders . CrosstabColumnBuilder ; import ar . com . fdvs . dj . domain . builders . CrosstabRowBuilder ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Page ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . test . BaseDjReportTest ; import ar . com . fdvs . dj . test . TestRepositoryProducts ; import ar . com . fdvs . dj . util . SortUtils ; public class CrosstabReportTest3 extends BaseDjReportTest { private Style totalHeader ; private Style colAndRowHeaderStyle ; private Style mainHeaderStyle ; private Style totalStyle ; private Style measureStyle ; public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 80 , true ) . addGroups ( 1 ) . setGroupLayout ( 1 , GroupLayout . DEFAULT_WITH_HEADER ) . addFooterVariable ( 1 , 7 , DJCalculation . SUM , null ) . addFooterVariable ( 1 , 6 , DJCalculation . SUM , null ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setPageSizeAndOrientation ( Page . Page_A4_Landscape ( ) ) . setPrintColumnNames ( false ) . setUseFullPageWidth ( true ) ; initStyles ( ) ; DJCrosstab djcross = createCrosstab ( ) ; drb . addHeaderCrosstab ( 1 , djcross ) ; DynamicReport dr = drb . build ( ) ; DJGroup g = ( DJGroup ) dr . getColumnsGroups ( ) . get ( 0 ) ; g . setHeaderHeight ( new Integer ( 40 ) ) ; params . put ( \"sr\" , SortUtils . sortCollection ( TestRepositoryProducts . getDummyCollection ( ) , djcross ) ) ; return dr ; } private DJCrosstab createCrosstab ( ) { CrosstabBuilder cb = new CrosstabBuilder ( ) ; cb . setHeight ( 100 ) . setWidth ( 500 ) . setHeaderStyle ( mainHeaderStyle ) . setDatasource ( \"sr\" , DJConstants . DATA_SOURCE_ORIGIN_PARAMETER , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) . setUseFullWidth ( true ) . setColorScheme ( 2 ) . setAutomaticTitle ( true ) . setCellBorder ( Border . THIN ) ; cb . addMeasure ( \"amount\" , Float . class . getName ( ) , DJCalculation . SUM , \"Amount\" , measureStyle ) ; DJCrosstabRow row = new CrosstabRowBuilder ( ) . setProperty ( \"productLine\" , String . class . getName ( ) ) . setHeaderWidth ( 100 ) . setHeight ( 0 ) . setTitle ( \"Product Line my mother teressa\" ) . setShowTotals ( true ) . setTotalStyle ( totalStyle ) . setTotalHeaderStyle ( totalHeader ) . setHeaderStyle ( colAndRowHeaderStyle ) . build ( ) ; cb . addRow ( row ) ; row = new CrosstabRowBuilder ( ) . setProperty ( \"item\" , String . class . getName ( ) ) . setHeaderWidth ( 100 ) . setHeight ( 20 ) . setTitle ( \"Item\" ) . setShowTotals ( true ) . setTotalStyle ( totalStyle ) . setTotalHeaderStyle ( totalHeader ) . setHeaderStyle ( colAndRowHeaderStyle ) . build ( ) ; cb . addRow ( row ) ; DJCrosstabColumn col = new CrosstabColumnBuilder ( ) . setProperty ( \"state\" , String . class . getName ( ) ) . setHeaderHeight ( 60 ) . setWidth ( 80 ) . setTitle ( \"State\" ) . setShowTotals ( true ) . setTotalStyle ( totalStyle ) . setTotalHeaderStyle ( totalHeader ) . setHeaderStyle ( colAndRowHeaderStyle ) . build ( ) ; col = new CrosstabColumnBuilder ( ) . setProperty ( \"branch\" , String . class . getName ( ) ) . setHeaderHeight ( 30 ) . setWidth ( 70 ) . setShowTotals ( true ) . setTitle ( \"Branch\" ) . setTotalStyle ( totalStyle ) . setTotalHeaderStyle ( totalHeader ) . setHeaderStyle ( colAndRowHeaderStyle ) . build ( ) ; cb . addColumn ( col ) ; return cb . build ( ) ; }", "gt": "private void initStyles ( )", "prediction": "}\n", "label": 0}
{"id": 14396, "input": "<s> package org . eclipse . ui . internal . services ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . ui . AbstractSourceProvider ; import org . eclipse . ui . ISources ; public final class MenuSourceProvider extends AbstractSourceProvider { private static final String [ ] PROVIDED_SOURCE_NAMES = new String [ ] { ISources . ACTIVE_MENU_NAME , ISources . ACTIVE_MENU_SELECTION_NAME , ISources . ACTIVE_MENU_EDITOR_INPUT_NAME } ; private Set menuIds = new HashSet ( ) ; public final void addShowingMenus ( final Set menuIds , final ISelection localSelection , final ISelection localEditorInput ) { this . menuIds . addAll ( menuIds ) ; if ( DEBUG ) { logDebuggingInfo ( \"Menu ids changed to \" + this . menuIds ) ; } Map m = new HashMap ( ) ; m . put ( ISources . ACTIVE_MENU_NAME , this . menuIds ) ; if ( selection != localSelection ) { selection = localSelection ; m . put ( ISources . ACTIVE_MENU_SELECTION_NAME , selection == null ? IEvaluationContext . UNDEFINED_VARIABLE : selection ) ; } if ( input != localEditorInput ) { input = localEditorInput ; m . put ( ISources . ACTIVE_MENU_EDITOR_INPUT_NAME , input == null ? IEvaluationContext . UNDEFINED_VARIABLE : input ) ; } fireSourceChanged ( ISources . ACTIVE_MENU , m ) ; } public final void dispose ( ) { menuIds . clear ( ) ; selection = null ; input = null ; } public final Map getCurrentState ( ) { final Map state = new HashMap ( ) ; state . put ( ISources . ACTIVE_MENU_NAME , menuIds ) ; state . put ( ISources . ACTIVE_MENU_SELECTION_NAME , selection == null ? IEvaluationContext . UNDEFINED_VARIABLE : selection ) ; state . put ( ISources . ACTIVE_MENU_EDITOR_INPUT_NAME , input == null ? IEvaluationContext . UNDEFINED_VARIABLE : input ) ; return state ; } public final", "gt": "String [ ] getProvidedSourceNames ( )", "prediction": "void dispose ( )\n", "label": 1}
{"id": 9415, "input": "<s> package org . ofbiz . service . test ; import java . util . List ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . testtools . OFBizTestCase ; public class ServiceSOAPTests extends OFBizTestCase { public final static String module = ServiceSOAPTests . class . getName ( ) ; public ServiceSOAPTests ( String name ) { super ( name ) ; } public void testSOAPSimpleService ( ) throws Exception { Map < String , Object > serviceContext = FastMap . newInstance ( ) ; serviceContext . put ( \"defaultValue\" , new Double ( \"123.4567\" ) ) ; serviceContext . put ( \"message\" , \"Test Message !!!\" ) ; dispatcher . runSync ( \"testSoapSimple\" , serviceContext ) ; } public void testSOAPService ( ) throws Exception { Map < String , Object >", "gt": "serviceContext = FastMap . newInstance ( ) ;", "prediction": "serviceContext = FastMap . newInstance ( ) ;\n", "label": 0}
{"id": 14400, "input": "<s> package org . nuxeo . ecm . automation . core . operations . services ; import java . io . Serializable ; import java . util . Locale ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import org . nuxeo . common . utils . i18n . I18NUtils ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . blob . StringBlob ; import org . nuxeo . ecm . core . schema . SchemaManager ; import org . nuxeo . ecm . core . schema . types . Field ; import org . nuxeo . ecm . core . schema . types . QName ; import org . nuxeo . ecm . core . schema . types . Schema ; import org . nuxeo . ecm . directory . Directory ; import org . nuxeo . ecm . directory . Session ; import org . nuxeo . ecm . directory . api . DirectoryService ; @ Operation ( id = GetDirectoryEntries . ID , category = Constants . CAT_SERVICES , label = \"Get directory entries\" , description = \"Get the entries of a directory. This is returning a blob containing a serialized JSON array. The input document, if specified, is used as a context for a potential local configuration of the directory.\" ) public class GetDirectoryEntries { public static final String ID = \"Directory.Entries\" ; @ Context protected OperationContext ctx ; @ Context protected DirectoryService directoryService ; @ Context protected SchemaManager schemaManager ; @ Param ( name = \"directoryName\" , required = true ) protected String directoryName ; @ Param ( name = \"translateLabels\" , required = false ) protected boolean translateLabels ; @ Param ( name = \"lang\" , required = false ) protected String lang ; @", "gt": "OperationMethod public Blob run ( DocumentModel doc ) throws Exception", "prediction": "Param ( name = \"description\" , required = false ) protected String description ;\n", "label": 1}
{"id": 3477, "input": "<s> package org . gk . ui . client . com . utils ; import java . util . Iterator ; import java . util . Map ; import jfreecode . gwt . event . client . bus . EventBus ; import jfreecode . gwt . event . client . bus . EventObject ; import jfreecode . gwt . event . client . bus . EventProcess ; import org . gk . ui . client . com . form . gkMap ; import com . google . gwt . dom . client . NativeEvent ; import com . google . gwt . user . client . Event ; import com . google . gwt . user . client . Event . NativePreviewEvent ; import com . google . gwt . user . client . Event . NativePreviewHandler ; import com . google . gwt . user . client . ui . Widget ; public class KeyTrigger { private static Map < String , Object > eventMap = new gkMap ( ) ; public static String TRIGGER = \".keyTrigger\" ; public static String [ ] keepKey = { \"ctrl+C\" , \"ctrl+V\" , \"ctrl+X\" , \"ctrl+A\" } ; public static String Ctrl_Z = \"ctrl+Z\" ; public static String Ctrl_Y = \"ctrl+Y\" ; public static String Ctrl_A = \"ctrl+A\" ; public static String Ctrl_C = \"ctrl+C\" ; public static String Ctrl_V = \"ctrl+V\" ; public static String Ctrl_X = \"ctrl+X\" ; static { Event . addNativePreviewHandler ( new NativePreviewHandler ( ) { @ Override public void onPreviewNativeEvent ( NativePreviewEvent event ) { if ( eventMap . size ( ) == 0 ) return ; String eventId = event . getNativeEvent ( ) . getType ( ) ; NativeEvent ne = event . getNativeEvent ( ) ; int keyCode = ne . getKeyCode ( ) ; if ( eventId . equals ( \"keydown\" ) && ! ( keyCode >= 16 && keyCode <= 18 ) ) { String specKey = \"\" ; specKey += ne . getCtrlKey ( ) ? \"+ctrl\" : \"\" ; specKey += ne . getAltKey ( ) ? \"+alt\" : \"\" ; if ( ne . getCtrlKey ( ) || ne . getAltKey ( ) ) { specKey += ne . getShiftKey ( ) ? \"+shift\" : \"\" ; } if ( specKey . length ( ) == 0 ) return ; specKey = specKey . substring ( 1 ) ; specKey += \"+\" + ( char ) ne . getKeyCode ( ) ; for ( int i = 0 ; i < keepKey . length ; i ++ ) { if ( specKey . toUpperCase ( ) . equals ( keepKey [ i ] . toString ( ) . toUpperCase ( ) ) ) return ; } ne . preventDefault ( ) ; broadcast ( specKey ) ; } } } ) ; } private static void broadcast ( String key ) { Iterator it = eventMap . values ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Object obj = it . next ( ) ; if ( obj instanceof Widget ) { String id = ( ( Widget ) obj ) . getElement ( ) . getId ( ) ; EventBus . get ( ) . publish ( new EventObject ( id + TRIGGER , key ) ) ; } if ( obj instanceof EventProcess ) { EventObject eo = new EventObject ( key , key ) ; ( ( EventProcess ) obj ) . execute ( key , eo ) ; } } } public static void bind ( Widget widget ) { String id = widget . getElement ( ) . getId ( ) ; eventMap . put ( id , widget ) ; } public static void bind ( EventProcess ep ) { eventMap . put ( ep + \"\" , ep ) ; } public static void bind ( Widget widget , String ... Keys ) { String id = widget", "gt": ". getElement ( ) . getId ( ) ;", "prediction": ". getElement ( ) . getId ( ) ;\n", "label": 0}
{"id": 14407, "input": "<s> package org . powerbot . game . api . methods . widget ; import java . awt . Dimension ; import java . awt . Rectangle ; import java . util . ArrayList ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . powerbot . core . script . job . Task ; import org . powerbot . game . api . methods . Game ; import org . powerbot . game . api . methods . Widgets ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . util . Timer ; import org . powerbot . game . api . wrappers . widget . Widget ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; public class Lobby { public static final int STATE_LOBBY_IDLE = 7 ; public static final int STATE_LOGGING_IN = 9 ; public static final int LOGIN_DEFAULT_TIMEOUT = 30000 ; public static final int WIDGET_MAIN_LOBBY = 906 ; public static final int WIDGET_BUTTON_PLAY_GAME = 197 ; public static final int WIDGET_BUTTON_LOGOUT = 221 ; public static final int WIDGET_LABEL_CURRENT_WORLD = 11 ; public static final int WIDGET_WORLDS_TABLE = 62 ; public static final int WIDGET_WORLDS_TABLE_SCROLLBAR = 86 ; public static final int WIDGET_WORLDS_ROWS = 77 ; public static final int WIDGET_WORLDS_COLUMN_FAVOURITE = 68 ; public static final int WIDGET_WORLDS_COLUMN_WORLD_NUMBER = 69 ; public static final int WIDGET_WORLDS_COLUMN_MEMBERS = 70 ; public static final int WIDGET_WORLDS_COLUMN_PLAYERS = 71 ; public static final int WIDGET_WORLDS_COLUMN_ACTIVITY = 72 ; public static final int WIDGET_WORLDS_COLUMN_LOOT_SHARE = 75 ; public static final int WIDGET_WORLDS_COLUMN_PING = 76 ; public static enum Tab { PLAYER_INFO ( 230 , 907 ) , WORLD_SELECT ( 28 , 910 ) , FRIENDS ( 27 , 909 ) , FRIENDS_CHAT ( 280 , 589 ) , CLAN_CHAT ( 26 , 912 ) , OPTIONS ( 25 , 911 ) ; private final int widgetTabIndex ; private final int widgetPanelIndex ; private Tab ( final int widgetTabIndex , final int widgetPanelIndex ) { this . widgetTabIndex = widgetTabIndex ; this . widgetPanelIndex = widgetPanelIndex ; } public WidgetChild getWidget ( ) { if ( ! Lobby . isOpen ( ) ) { return null ; } return Widgets . get ( WIDGET_MAIN_LOBBY , widgetTabIndex ) ; } public Widget getPanelWidget ( ) { if ( ! Lobby . isOpen ( ) ) { return null ; } return Widgets . get ( widgetPanelIndex ) ; } public boolean isOpen ( ) { final WidgetChild child = getWidget ( ) ; return child != null && child . validate ( ) && child . getTextureId ( ) == 4671 ; } public boolean open ( ) { final WidgetChild child = getWidget ( ) ; if ( isOpen ( ) ) { return true ; } if ( child != null && child . validate ( ) && child . click ( true ) ) { Task . sleep", "gt": "( Random . nextInt ( 1200 , 2000 ) ) ;", "prediction": "( 1000 ) ;\n", "label": 1}
{"id": 5617, "input": "<s> package pkg ; public class Parent { public void nonMatchingParams ( int", "gt": "param1 , int param2 )", "prediction": "parentId )\n", "label": 0}
{"id": 14408, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . Graphics2D ; import java . awt . geom . Point2D ; import java . util . Timer ; import java . util . TimerTask ; import fr . inria . zvtm . glyphs . Translucent ; import fr . inria . zvtm . glyphs . Translucency ; import fr . inria . zvtm . engine . LowPassFilter ; public class LPDGaussianLens extends LPFSGaussianLens implements TemporalLens { double frequency = - 1 ; long mLastSampleTime = - 1 ; int xOffset = - 10 ; int yOffset = 10 ; double maxDist = 2 * Math . abs ( xOffset ) ; LowPassFilter filter = new LowPassFilter ( ) ; Point2D currentPos = new Point2D . Double ( 0 , 0 ) ; Point2D parentPos = new Point2D . Double ( 0 , 0 ) ; Point2D targetPos = new Point2D . Double ( 0 , 0 ) ; Timer timer ; LPDLTrailingTimer mouseStillUpdater ; double cutoffParamA = 0.1 ; double cutoffParamB = 0.001 ; float a = 1 ; float b = 0 ; TemporalParamListener tpl ; public LPDGaussianLens ( ) { super ( ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp ) { super ( mm , lp ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp , int outerRadius , int innerRadius ) { super ( mm , lp , outerRadius , innerRadius ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } public LPDGaussianLens ( float mm , float lp , float minLp , float maxLp , int outerRadius , int innerRadius , int x , int y ) { super ( mm , lp , outerRadius , innerRadius , x , y ) ; computeLPFactors ( minLp , maxLp ) ; initTimer ( ) ; } void computeLPFactors ( float minLp , float maxLp ) { a = maxLp - minLp ; b = minLp ; } void initTimer ( ) { timer = new Timer ( ) ; mouseStillUpdater = new LPDLTrailingTimer ( this ) ; timer . scheduleAtFixedRate ( mouseStillUpdater , 40 , 10 ) ; } public synchronized void setAbsolutePosition ( int ax , int ay , long absTime ) { synchronized ( this ) { super . setAbsolutePosition ( ax , ay ) ; updateFrequency ( absTime ) ; updateTimeBasedParams ( ax , ay ) ; } } public void updateFrequency ( ) { updateFrequency ( System . currentTimeMillis ( ) ) ; } public void updateFrequency ( long currentTime ) { if ( frequency == - 1 ) { frequency = 1 ; } else { if ( currentTime != mLastSampleTime ) { frequency = 1000.0 / ( ( double ) ( currentTime - mLastSampleTime ) ) ; } } mLastSampleTime = currentTime ; } public void updateTimeBasedParams ( int cx , int cy ) { parentPos . setLocation ( cx , cy ) ; updateTimeBasedParams ( ) ; } public void updateTimeBasedParams ( ) { targetPos . setLocation ( parentPos . getX ( ) + xOffset , parentPos . getY ( ) + yOffset ) ; double distAway = targetPos . distance ( currentPos ) ; double opacity = 1.0 - Math . min ( 1.0 , distAway / maxDist ) ; filter . setCutOffFrequency ( ( ( 1.0 - opacity ) * cutoffParamA ) + cutoffParamB ) ; currentPos = filter . apply ( targetPos , frequency ) ; int tx = ( int ) Math . round ( currentPos . getX ( ) ) ; int ty = ( int ) Math . round ( currentPos . getY ( ) ) ; tx = Math . max ( tx , w / 2 ) ; ty = Math . min ( ty , owningView . parent . getPanelSize ( ) . height - h / 2 ) ; float nLp = ( ( float ) opacity ) * a + b ; if ( Math . abs ( nLp - this . P ) > 0.01f ) { this . setDistanceMetrics ( nLp ) ; owningView . parent . repaint ( ) ; if ( tpl != null ) { tpl . parameterUpdated ( ) ; } } } public void setCutoffFrequencyParameters ( double a , double b ) { cutoffParamA = a ; cutoffParamB = b ; } public void setNoUpdateWhenMouseStill ( boolean b ) { mouseStillUpdater . setEnabled ( ! b ) ; } public void dispose ( ) { super . dispose ( ) ; timer . cancel ( ) ; } java . awt . BasicStroke bs = new java . awt . BasicStroke ( 2.0f ) ; java . awt . Stroke os ; public void drawBoundary ( Graphics2D g2d ) { g2d . setComposite ( Translucency . acs [ Math . round ( ( 1.0f - ( P - b ) / a ) * Translucency", "gt": ". ACS_ACCURACY ) - 1 ] ) ;", "prediction": ". acs ) ] ) ;\n", "label": 1}
{"id": 9488, "input": "<s> package org . ofbiz . shipment . test ; import java . math . BigDecimal ; import java . util . List ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . shipment . packing . PackingSession ; import org . ofbiz . service . testtools . OFBizTestCase ; public class IssuanceTest extends OFBizTestCase { protected GenericValue userLogin = null ; public IssuanceTest ( String name ) { super ( name ) ; } @ Override protected void setUp ( ) throws Exception { userLogin = delegator . findOne ( \"UserLogin\" , UtilMisc . toMap ( \"userLoginId\" , \"system\" ) , false ) ; } @ Override protected void tearDown ( ) throws Exception { } public void testMultipleInventoryItemIssuance ( ) throws Exception { String facilityId = \"WebStoreWarehouse\" ; String productId = \"GZ-2644\" ; String orderId = \"DEMO81015\" ; String orderItemSeqId = \"00001\" ; String shipGroupSeqId = \"00001\" ; String shipmentItemSeqId = \"00001\" ; PackingSession packSession = new PackingSession ( dispatcher , userLogin , facilityId , null , orderId , shipGroupSeqId ) ; packSession . addOrIncreaseLine ( orderId , orderItemSeqId , shipGroupSeqId , productId , BigDecimal . valueOf ( 6L ) , 1 , BigDecimal . valueOf ( 1000L ) , false ) ; String shipmentId = packSession . complete ( false ) ; GenericValue orderHeader = delegator . findOne ( \"OrderHeader\" , UtilMisc . toMap ( \"orderId\" , orderId ) , true ) ; List < GenericValue > orderShipments = orderHeader . getRelated ( \"OrderShipment\" , null , null , false ) ; assertFalse ( \"No OrderShipment for order\" , UtilValidate . isEmpty ( orderShipments ) ) ; assertEquals ( \"Incorrect number of OrderShipments for order\" , 1 , orderShipments . size ( ) ) ; GenericValue orderShipment = orderShipments . get ( 0 ) ; assertEquals ( orderItemSeqId , orderShipment . getString ( \"orderItemSeqId\" ) ) ; assertEquals ( shipGroupSeqId , orderShipment . getString ( \"shipGroupSeqId\" ) ) ; assertEquals ( shipmentId , orderShipment . getString ( \"shipmentId\" ) ) ; assertEquals ( shipmentItemSeqId , orderShipment . getString ( \"shipmentItemSeqId\" ) ) ; BigDecimal actual = orderShipment . getBigDecimal ( \"quantity\" ) ; assertTrue ( \"Incorrect quantity in OrderShipment. Expected 6.00000 actual \" + actual , actual . compareTo ( BigDecimal . valueOf ( 6L ) ) == 0 ) ; List < GenericValue > itemIssuances = orderHeader . getRelated ( \"ItemIssuance\" , null , UtilMisc . toList ( \"itemIssuanceId\" ) , false ) ; assertFalse ( \"No ItemIssuances for order\" , UtilValidate . isEmpty ( itemIssuances ) ) ; assertEquals ( \"Incorrect number of ItemIssuances for order\" , 2 , itemIssuances . size ( ) ) ; GenericValue itemIssuance = itemIssuances . get ( 0 ) ; assertEquals ( orderItemSeqId , itemIssuance . getString ( \"orderItemSeqId\" ) ) ; assertEquals ( shipGroupSeqId , itemIssuance . getString ( \"shipGroupSeqId\" ) ) ; assertEquals ( shipmentId , itemIssuance . getString ( \"shipmentId\" ) ) ; assertEquals ( shipmentItemSeqId , itemIssuance . getString ( \"shipmentItemSeqId\" ) ) ; assertEquals ( \"9001\" , itemIssuance . getString ( \"inventoryItemId\" ) ) ; actual = itemIssuance . getBigDecimal ( \"quantity\" ) ; assertTrue ( \"Incorrect quantity in ItemIssuance. Expected 5.00000 actual \" + actual , actual . compareTo ( BigDecimal . valueOf ( 5L ) ) == 0 ) ; itemIssuance = itemIssuances . get ( 1 ) ; assertEquals ( orderItemSeqId , itemIssuance . getString ( \"orderItemSeqId\" ) ) ; assertEquals ( shipGroupSeqId , itemIssuance . getString ( \"shipGroupSeqId\" ) ) ; assertEquals ( shipmentId , itemIssuance . getString ( \"shipmentId\" ) ) ; assertEquals ( shipmentItemSeqId , itemIssuance . getString ( \"shipmentItemSeqId\" ) ) ; assertEquals ( \"9025\" , itemIssuance . getString ( \"inventoryItemId\" ) ) ; actual = itemIssuance .", "gt": "getBigDecimal ( \"quantity\" ) ;", "prediction": "getBigDecimal ( \"quantity\" ) ;\n", "label": 0}
{"id": 14420, "input": "<s> package com . corundumstudio . socketio . parser ; public enum ErrorAdvice { RECONNECT ( 0 ) ; private int value ; ErrorAdvice ( int value ) { this . value = value ; }", "gt": "public int getValue ( )", "prediction": "}\n", "label": 1}
{"id": 10101, "input": "<s> package com . sun . source . util ; public interface TaskListener { public void started ( TaskEvent e ) ; public void finished", "gt": "( TaskEvent e ) ;", "prediction": "( TaskEvent e ) ;\n", "label": 0}
{"id": 14431, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . jface . preference . JFacePreferences ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public class JFaceColors { public static Color getBannerBackground ( Display display ) { return display . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ; } public static Color getBannerForeground ( Display display ) { return display . getSystemColor ( SWT . COLOR_LIST_FOREGROUND ) ; } public static Color getErrorBackground ( Display display ) { return display . getSystemColor ( SWT . COLOR_WIDGET_BACKGROUND ) ; } public static Color getErrorBorder ( Display display ) { return display . getSystemColor ( SWT . COLOR_WIDGET_DARK_SHADOW ) ; } public static Color getErrorText ( Display display ) { return JFaceResources . getColorRegistry (", "gt": ") . get ( JFacePreferences . ERROR_COLOR ) ;", "prediction": "display ) ;\n", "label": 1}
{"id": 3290, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; public class TestNotMatcher extends CustomDefaultLabelMatcher < TestNotMatcher > { public final Matcher subMatcher ; public TestNotMatcher ( Rule subRule ) { super ( checkArgNotNull ( subRule , \"subRule\" ) , \"TestNot\" ) ; this . subMatcher = getChildren ( ) . get ( 0 ) ; } public boolean match ( MatcherContext context ) {", "gt": "int lastIndex = context . getCurrentIndex ( ) ;", "prediction": "return true ;\n", "label": 0}
{"id": 14434, "input": "<s> package org . apache . lucene . index ; import java . io . IOException ; import java . util . Random ; import org . apache . lucene . store . * ; import org . apache . lucene . util . * ; import org . apache . lucene . analysis . * ; import org . apache . lucene . document . * ; public class TestTransactions extends LuceneTestCase { private Random RANDOM ; private static volatile boolean doFail ; private class RandomFailure extends MockRAMDirectory . Failure { public void eval ( MockRAMDirectory dir ) throws IOException { if ( TestTransactions . doFail && RANDOM . nextInt ( ) % 10 <= 3 ) throw new IOException ( \"now failing randomly but on purpose\" ) ; } } private static abstract class TimedThread extends Thread { boolean failed ; private static int RUN_TIME_SEC = 6 ; private TimedThread [ ] allThreads ; abstract public void doWork ( ) throws Throwable ; TimedThread ( TimedThread [ ] threads ) { this . allThreads = threads ; } public void run ( ) { final long stopTime = System . currentTimeMillis ( ) + 1000 * RUN_TIME_SEC ; try { while ( System . currentTimeMillis ( ) < stopTime && ! anyErrors ( ) ) doWork ( ) ; } catch ( Throwable e ) { System . out . println ( Thread . currentThread ( ) + \": exc\" ) ; e . printStackTrace ( System . out ) ; failed = true ; } } private boolean anyErrors ( ) { for ( int i = 0 ; i < allThreads . length ; i ++ ) if ( allThreads [ i ] != null && allThreads [ i ] . failed ) return true ; return false ; } } private class IndexerThread extends TimedThread { Directory dir1 ; Directory dir2 ; Object lock ; int nextID ; public IndexerThread ( Object lock , Directory dir1 , Directory dir2 , TimedThread [ ] threads ) { super ( threads ) ; this . lock = lock ; this . dir1 = dir1 ; this . dir2 = dir2 ; } public void doWork ( ) throws Throwable { IndexWriter writer1 = new IndexWriter ( dir1 , new WhitespaceAnalyzer ( ) , IndexWriter . MaxFieldLength . LIMITED ) ; writer1 . setMaxBufferedDocs ( 3 ) ; writer1 . setMergeFactor ( 2 ) ; ( ( ConcurrentMergeScheduler ) writer1 . getMergeScheduler ( ) ) . setSuppressExceptions ( ) ; IndexWriter writer2 = new IndexWriter ( dir2 , new WhitespaceAnalyzer ( ) , IndexWriter . MaxFieldLength . LIMITED ) ; writer2 . setMaxBufferedDocs ( 2 ) ; writer2 . setMergeFactor ( 3 ) ; ( ( ConcurrentMergeScheduler ) writer2 . getMergeScheduler ( ) ) . setSuppressExceptions ( ) ; update ( writer1 ) ; update ( writer2 ) ; TestTransactions . doFail = true ; try { synchronized ( lock ) { try { writer1 . prepareCommit ( ) ; } catch ( Throwable t ) { writer1 . rollback ( ) ; writer2 . rollback ( ) ; return ; } try { writer2 . prepareCommit ( ) ; } catch ( Throwable t ) { writer1 . rollback ( ) ; writer2 . rollback ( ) ; return ; } writer1 . commit ( ) ; writer2 . commit ( ) ; } } finally { TestTransactions . doFail = false ; } writer1 . close ( ) ; writer2 . close ( ) ; } public void update ( IndexWriter writer ) throws IOException { for ( int j = 0 ; j < 10 ; j ++ ) { Document d = new Document ( ) ;", "gt": "int n = RANDOM . nextInt ( ) ;", "prediction": "for ( int k = 0 ;\n", "label": 1}
{"id": 1428, "input": "<s> class CountError { void m ( ) {", "gt": "throw new Exception ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14439, "input": "<s> package br . org . archimedes . controller . commands ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; public class PanCommandTest { private PanCommand pan ; private Drawing drawing ; @ Before public void setUp ( ) throws Exception { Point original = new Point ( 0 , 0 ) ; Point viewport = new Point ( 14 , 42 ) ; pan = new PanCommand ( original , viewport ) ; drawing = new Drawing ( \"Drawing\" ) ; } @ After public void tearDown ( ) throws Exception { pan = null ; drawing = null ; } @ Test ( expected = IllegalActionException . class ) public void creatingPanWithTwoEqualPointsThrowsException ( ) throws Exception { new PanCommand ( new Point ( 10 , 10 ) , new Point ( 10 , 10 ) ) ; } @ Test ( expected = NullArgumentException . class ) public void creatingPanWithNullsThrowsException ( ) throws Exception { new PanCommand ( null , null ) ; } @ Test ( expected =", "gt": "NullArgumentException . class ) public void executingOnANullDrawingThrowsException ( ) throws Exception", "prediction": "IllegalActionException . class ) public void creatingPanWithNullsThrowsException ( ) throws Exception\n", "label": 1}
{"id": 9993, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . List ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerBetweenRestritionImpl implements MobeelizerInternalCriterion { private final String field ; private final Object lo ; private final Object hi ; public MobeelizerBetweenRestritionImpl ( final String field , final Object lo , final Object hi ) { this . field = field ; this . lo = lo ; this . hi = hi ; } @ Override public String addToQuery ( final List <", "gt": "String > selectionArgs , final MobeelizerAndroidModel model )", "prediction": "String > queries )\n", "label": 0}
{"id": 14442, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . BitSet ; import org . apache . lucene . index . IndexReader ; public class RemoteCachingWrapperFilter extends Filter { protected Filter filter ; public RemoteCachingWrapperFilter ( Filter filter ) { this . filter = filter ; } public BitSet bits ( IndexReader reader ) throws IOException { Filter cachedFilter = FilterManager . getInstance ( ) . getFilter ( filter ) ; return cachedFilter . bits ( reader ) ; } public DocIdSet getDocIdSet ( IndexReader reader ) throws IOException { Filter cachedFilter = FilterManager", "gt": ". getInstance ( ) . getFilter ( filter ) ;", "prediction": ". getInstance ( ) . getFilter ( filter ) ;\n", "label": 1}
{"id": 5972, "input": "<s> package org . dawb . workbench . ui . editors . test ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . axis . IAxis ; import org . dawb . workbench . plotting . system . LightWeightPlottingSystem ; import org . dawb . workbench . ui . editors . AsciiEditor ; import org . dawb . workbench . ui . editors . PlotDataEditor ; import org . eclipse . core . filesystem . EFS ; import org . eclipse . core . filesystem . IFileStore ; import org . eclipse . core . runtime . Platform ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . ide . FileStoreEditorInput ; import org . junit . Test ; import org . osgi . framework . Bundle ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . LongDataset ; import fable . framework . toolbox . EclipseUtils ; public class SWTXYAxisTest { @ Test public void testChoerant1 ( ) throws Throwable { createAxisTest ( createTestArraysCoherant ( 10 , 1000 , \"Long set \" ) , false ) ; } @ Test public void testChoerant2 ( ) throws Throwable { createAxisTest ( createTestArraysCoherant ( 5 , 1000 , \"Long set \" ) , true ) ; } @ Test public void testRandom1 ( ) throws Throwable { createAxisTest ( createTestArraysRandom ( 10 , 1000 ) , false ) ; } @ Test public void testRandom2 ( ) throws Throwable { createAxisTest ( createTestArraysRandom ( 5 , 1000 ) , true ) ; } private void createAxisTest ( final List < AbstractDataset > ys , boolean multipleAxes ) throws Throwable { final Bundle bun = Platform . getBundle ( \"org.dawb.workbench.ui.test\" ) ; String path = ( bun . getLocation ( ) + \"src/org/dawb/workbench/ui/editors/test/ascii.dat\" ) ; path = path . substring ( \"reference:file:\" . length ( ) ) ; if ( path . startsWith ( \"/C:\" ) ) path = path . substring ( 1 ) ; final IWorkbenchPage page = EclipseUtils . getPage ( ) ; final IFileStore externalFile = EFS . getLocalFileSystem ( ) . fromLocalFile ( new File ( path ) ) ; final IEditorPart part = page . openEditor ( new FileStoreEditorInput ( externalFile ) , AsciiEditor . ID ) ; final AsciiEditor editor = ( AsciiEditor ) part ; final PlotDataEditor plotter = ( PlotDataEditor ) editor . getActiveEditor ( ) ; final AbstractPlottingSystem sys = plotter . getPlottingSystem ( ) ; if ( ! ( sys instanceof LightWeightPlottingSystem ) ) throw new Exception ( \"This test is designed for \" + LightWeightPlottingSystem . class . getName ( ) ) ; page . setPartState ( EclipseUtils . getPage ( ) . getActivePartReference ( ) , IWorkbenchPage . STATE_MAXIMIZED ) ; sys . clear ( ) ; AbstractDataset indices = AbstractDataset . arange ( 0 , ys . get ( 0 ) . getSize ( ) , 1 , AbstractDataset . INT32 ) ; if ( ! multipleAxes ) { final IAxis primaryY = sys . getSelectedYAxis ( ) ; final IAxis alternateYaxis = sys . createAxis ( \"Alternate\" , true , SWT . LEFT ) ; alternateYaxis . setForegroundColor ( sys . getPlotComposite ( ) . getDisplay ( ) . getSystemColor ( SWT . COLOR_DARK_CYAN ) ) ; alternateYaxis . setLog10 ( true ) ; sys . setXfirst ( true ) ; sys . setSelectedYAxis ( alternateYaxis ) ; sys . setSelectedYAxis ( primaryY ) ; for ( int i = 0 ; i < ys . size ( ) ; i ++ ) { final AbstractDataset y = ys . get ( i ) ; if ( i % 2 == 0 ) { sys . setSelectedYAxis ( primaryY ) ; } else { sys . setSelectedYAxis ( alternateYaxis ) ; } sys . createPlot1D ( indices", "gt": ", Arrays . asList ( new AbstractDataset [ ]", "prediction": ") ;\n", "label": 0}
{"id": 14445, "input": "<s> package org . eclipse . ui . internal ; interface IReorderListener { public void", "gt": "reorder ( Object obj , int newIndex ) ;", "prediction": "setUp ( ) ;\n", "label": 1}
{"id": 5381, "input": "<s> public class StandaloneQualifiedSuper { public class AS { } public class BS { } public class CS { } public class A extends AS { A ( ) { super ( ) ; } public class B extends BS { B ( ) { super ( ) ; } public class C extends CS { C ( ) { super ( ) ; } void test ( ) { System . out .", "gt": "println ( B . super ) ;", "prediction": "println ( \"A\" ) ;\n", "label": 0}
{"id": 14451, "input": "<s> package com . northconcepts . eventbus . filter ; import com . northconcepts . eventbus . EventFilter ; import org . junit . Test ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class OrFilterTest extends LogicalFilterTest { @ Test public void testNullFilters ( ) { EventFilter filter = new OrFilter ( ( EventFilter [ ] ) null ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testZeroFilters ( ) { EventFilter filter = new OrFilter ( ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneTrueFilter ( ) { EventFilter filter = new OrFilter ( TRUE_FILTER ) ; assertTrue ( filter . allow ( event , listener ) ) ; } @ Test public void testOneFalseFilter ( ) { EventFilter filter = new OrFilter ( FALSE_FILTER ) ; assertFalse ( filter .", "gt": "allow ( event , listener ) ) ;", "prediction": "allow ( event , listener ) ) ;\n", "label": 1}
{"id": 2370, "input": "<s> package com . redhat . ceylon . tools . help ; import com . redhat . ceylon . common . tool . Argument ; import com . redhat . ceylon . common . tool . Description ; import com . redhat . ceylon . common . tool . Option ; import com . redhat . ceylon . common . tool . RemainingSections ; import com . redhat . ceylon . common . tool . Summary ; import com . redhat . ceylon . common . tool . Tool ; import com . redhat . ceylon . common . tool . ToolLoader ; import com . redhat . ceylon . common . tool . ToolModel ; import com . redhat . ceylon . common . tool . WordWrap ; import com . redhat . ceylon . tools . CeylonTool ; import com . redhat . ceylon . tools . help . model . Doc ; import com . redhat . ceylon . tools . help . model . Visitor ; @ Summary ( \"Display help information about other ceylon tools\" ) @ Description ( \"If a `<tool>` is given, displays help about that ceylon tool on the standard output.\\n\\n\" + \"If no `<tool>` is given, displays the synopsis of the top level `ceylon` command. \" ) @ RemainingSections ( \"## SEE ALSO\\n\\n\" + \"* `ceylon doc-tool` for generating documentation about ceylon tools\\n\" ) public class CeylonHelpTool implements Tool { private Appendable out = System . out ; private boolean includeHidden ; private ToolLoader toolLoader ; private DocBuilder docBuilder ; private ToolModel < ? > tool ; public final void setToolLoader ( ToolLoader toolLoader ) { this . toolLoader = toolLoader ; this . docBuilder = new DocBuilder ( toolLoader ) ; } @ Option public void setIncludeHidden ( boolean includeHidden ) { this . includeHidden = includeHidden ; } @ Argument ( argumentName = \"tool\" , multiplicity = \"?\" ) public void setTool ( ToolModel < ? > tool ) { this . tool = tool ; } public void setOut ( Appendable out ) { this . out = out ; } @ Override public void run ( ) { docBuilder . setIncludeHidden ( includeHidden ) ; Doc doc ; if ( tool != null ) { doc = docBuilder . buildDoc ( tool ) ; } else { final ToolModel < CeylonTool > root = toolLoader . loadToolModel ( \"\" ) ; doc = docBuilder . buildDoc ( root , true ) ; } final WordWrap wrap =", "gt": "new WordWrap ( out ) ;", "prediction": "null ;\n", "label": 0}
{"id": 14458, "input": "<s> package org . apache . lucene . analysis . reverse ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import java . io . IOException ; public final class ReverseStringFilter extends TokenFilter { private TermAttribute termAtt ; private final char marker ; private static final char NOMARKER = '\uffff' ; public static final char START_OF_HEADING_MARKER = '\u0001' ; public static final char INFORMATION_SEPARATOR_MARKER = '\u001f' ; public static final char PUA_EC00_MARKER = '\uec00' ; public static final char RTL_DIRECTION_MARKER = '\u200f' ; public ReverseStringFilter ( TokenStream in ) { this ( in , NOMARKER ) ; } public ReverseStringFilter ( TokenStream in , char marker ) { super ( in ) ; this . marker = marker ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; } public boolean incrementToken ( ) throws IOException { if ( input . incrementToken ( ) ) { int len = termAtt . termLength ( ) ; if ( marker != NOMARKER ) { len ++ ; termAtt . resizeTermBuffer ( len ) ; termAtt . termBuffer ( ) [ len - 1 ] = marker ; } reverse ( termAtt . termBuffer ( ) , len ) ; termAtt . setTermLength ( len ) ; return true ; } else { return false ; } } public static String reverse ( final String input ) { char [ ] charInput = input . toCharArray ( ) ; reverse ( charInput ) ; return new String ( charInput ) ; } public static void reverse ( char [ ] buffer ) { reverse ( buffer , buffer . length ) ; } public static void reverse ( char [ ] buffer , int len ) { reverse ( buffer , 0 , len ) ; } public static void reverse ( char [ ] buffer , int start , int len ) { if ( len <= 1 ) return ; int num", "gt": "= len > > 1 ;", "prediction": "= buffer . length ;\n", "label": 1}
{"id": 912, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; public class DupOk extends Doclet { public static void main ( String [ ] args ) { if ( com . sun . tools . javadoc . Main . execute ( \"javadoc\" , \"DupOk\" , DupOk . class . getClassLoader ( ) , new String [ ] { \"-sourcepath\" , System . getProperty ( \"test.src\" , \".\" ) + java . io . File . separatorChar + \"sp1\" + System . getProperty ( \"path.separator\" ) + System . getProperty ( \"test.src\" , \".\" ) + java . io . File . separatorChar + \"sp2\" , \"p\" } ) != 0 ) throw new Error ( ) ; } public static boolean start ( com . sun . javadoc . RootDoc root ) { ClassDoc [ ] classes = root . classes ( ) ; if ( classes . length != 2 ) throw new Error ( \"1 \" + Arrays .", "gt": "asList ( classes ) ) ;", "prediction": "asList ( classes ) ) ;\n", "label": 0}
{"id": 14469, "input": "<s> package org . eclipse . ui ; import java . util . Map ; public interface ISourceProviderListener { public void sourceChanged ( final int sourcePriority , final Map sourceValuesByName ) ; public void sourceChanged ( final int sourcePriority", "gt": ", final String sourceName , final Object sourceValue ) ;", "prediction": ", final Map sourceValuesByName ) ;\n", "label": 1}
{"id": 6483, "input": "<s> class T5003235c { private static class B { static class Inner { } } }", "gt": "class C extends T5003235c . B . Inner", "prediction": ";\n", "label": 0}
{"id": 14481, "input": "<s> package org . eclipse . jface . tests . wizards ; import junit . framework . TestCase ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; public class ButtonAlignmentTest extends TestCase { private TheTestWizard wizard ; private TheTestWizardDialog dialog ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Display . getDefault ( ) ; } protected void tearDown ( ) throws Exception { if ( dialog != null && dialog . getShell ( ) != null && ! dialog . getShell ( ) . isDisposed ( ) ) { dialog . close ( ) ; } super . tearDown ( ) ; } public ButtonAlignmentTest ( ) { super ( \"ButtonAlignmentTest\" ) ; } public void testButtonAlignment ( ) { wizard = new TheTestWizard ( ) ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ; dialog . open ( ) ; Composite parent = dialog . getFinishedButton ( ) . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; assertEquals ( \"There should be three children, a composite for back/next buttons, the finish button, and the cancel button\" , 3 , children . length ) ; assertTrue ( children [ 0 ] instanceof Composite ) ; Composite backNextParent = ( Composite ) children [ 0 ] ; Control [ ] backNextChildren = backNextParent . getChildren ( ) ; assertEquals ( \"Back button should be the first button\" , dialog . getBackButton ( ) , backNextChildren [ 0 ] ) ; assertEquals ( \"Next button should be the second button\" , dialog . getNextButton ( ) , backNextChildren [ 1 ] ) ; int finishIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 1 : 2 ; int cancelIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 2 : 1 ; assertEquals ( \"Finish button's alignment is off\" , dialog . getFinishedButton ( ) , children [ finishIndex ] ) ; assertEquals ( \"Cancel button's alignment is off\" , dialog . getCancelButton ( ) , children [ cancelIndex ] ) ; } public void testButtonAlignmentWithoutBackNextButtons ( ) { wizard = new TheTestWizard ( ) { public void addPages ( ) { addPage ( new TheTestWizardPage ( page1Name ) ) ; } } ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ; dialog . open ( ) ; Composite parent = dialog . getFinishedButton ( ) . getParent ( ) ; Control [ ] children = parent . getChildren ( ) ; assertEquals ( \"There should be two children, the finish button, and the cancel button\" , 2 , children . length ) ; int finishIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 0 : 1 ; int cancelIndex = parent . getDisplay ( ) . getDismissalAlignment ( ) == SWT . LEFT ? 1 : 0 ; assertEquals ( \"Finish button's alignment is off\" , dialog . getFinishedButton ( ) , children [ finishIndex ] ) ; assertEquals ( \"Cancel button's alignment is off\" , dialog . getCancelButton ( ) , children [ cancelIndex ] ) ; } public void testBug270174 ( ) { wizard = new TheTestWizard ( ) { public boolean canFinish ( ) { return false ; } } ; dialog = new TheTestWizardDialog ( null , wizard ) ; dialog . create ( ) ;", "gt": "dialog . open ( ) ;", "prediction": "dialog . open ( ) ;\n", "label": 1}
{"id": 3606, "input": "<s> package org . ofbiz . pos . event ; import org . ofbiz . pos . screen . PosScreen ; import org . ofbiz . pos . component . Journal ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . pos . screen . NumericKeypad ; public class TestEvents { public static final String module = TestEvents . class . getName ( ) ; public static synchronized void testAlert ( PosScreen pos ) { pos . showDialog ( \"dialog/error/testerror\" ) ; } public static synchronized void logSelectedIndex ( PosScreen pos ) { Journal journal = pos . getJournal ( ) ; Debug . logInfo ( \"Selected IDX - \" + journal . getSelectedIdx ( ) , module ) ; } public static synchronized void testMsr ( PosScreen pos ) { try { org . ofbiz . pos . jpos . service . MsrTestService . sendTest ( ) ; } catch ( GeneralException e ) { Debug . logError ( e , module ) ; pos . showDialog ( \"dialog/error/exception\" , e . getMessage ( ) ) ; } } public static synchronized void testNumericKeypad ( PosScreen pos ) { try { NumericKeypad numericKeypad = new NumericKeypad ( pos ) ; numericKeypad . setMinus ( true ) ; numericKeypad . setPercent ( false ) ;", "gt": "numericKeypad . openDlg ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14492, "input": "<s> package org . restlet . example . book . restlet . ch10 . sec3 . server ; import org . restlet . Component ; import org . restlet . Server ; import org . restlet . data . Protocol ; public class MailServerComponent extends Component { public static void main ( String [ ] args ) throws Exception { new MailServerComponent ( ) . start ( ) ; } public MailServerComponent ( ) throws Exception { setName ( \"RESTful Mail Server component\" ) ; setDescription ( \"Example for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; Server server = getServers ( ) . add ( Protocol . HTTP , 8111 ) ; server . getContext ( ) . getParameters ( ) . set", "gt": "( \"tracing\" , \"false\" ) ;", "prediction": "( Protocol . HTTPS ) ;\n", "label": 1}
{"id": 7302, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class RealFormatTest extends XtextTest { @ Test public void testNumberFormat ( ) { testParserRule ( \"numberformat \\\"-\\\" \\\"\\\" \\\"\\\"", "gt": "\\\",\\\" 2\" , \"NumberFormat\" ) ;", "prediction": "\" ) ;\n", "label": 0}
{"id": 14496, "input": "<s> package org . restlet . ext . oauth . internal ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import org . restlet . ext . oauth . AuthenticatedUser ; public abstract class TokenGenerator { private volatile SecureRandom random ; protected volatile long maxTokenTimeSec ; private static final int tokens = 1000 ; private volatile int count = 0 ; public TokenGenerator ( ) { try { random = SecureRandom . getInstance ( \"SHA1PRNG\" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } } public String generateCode ( AuthenticatedUser user ) { StringBuilder raw = new StringBuilder ( generate ( 20 ) ) ; raw . append ( '|' ) . append ( System . currentTimeMillis ( ) ) ; String code = raw . toString ( ) ; user . setCode ( code ) ; return code ; } public Token generateToken ( AuthenticatedUser user , long expire ) { long individualExp = user . getTokenExpire ( ) ; if ( individualExp > 0 ) { expire = individualExp ; } expire = ( expire <= maxTokenTimeSec ) ? expire : maxTokenTimeSec ; StringBuilder raw = new StringBuilder ( generate ( 40 ) ) ; String token = raw . toString ( ) ; Token t = null ; if ( expire != Token . UNLIMITED ) { t = new ExpireToken ( token , expire , generate ( 20 ) , user ) ; } else { t = new UnlimitedToken ( token , user ) ; } return t ; } public long expiresInSec ( Token token ) { if ( token instanceof ExpireToken ) { ExpireToken et = ( ExpireToken ) token ; ScheduledFuture < ? > sf =", "gt": "et . getFuture ( ) ;", "prediction": "new ScheduledFuture < ? > ( ) ;\n", "label": 1}
{"id": 4506, "input": "<s> package com . sun . tools . javac . processing ; import java . io . Closeable ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FilterOutputStream ; import java . io . Reader ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . PrintWriter ; import java . io . IOException ; import java . util . * ; import static java . util . Collections . * ; import javax . annotation . processing . * ; import javax . lang . model . SourceVersion ; import javax . lang . model . element . NestingKind ; import javax . lang . model . element . Modifier ; import javax . lang . model . element . Element ; import javax . tools . * ; import javax . tools . JavaFileManager . Location ; import static javax . tools . StandardLocation . SOURCE_OUTPUT ; import static javax . tools . StandardLocation . CLASS_OUTPUT ; import com . sun . tools . javac . code . Lint ; import com . sun . tools . javac . util . * ; import static com . sun . tools . javac . code . Lint . LintCategory . PROCESSING ; public class JavacFiler implements Filer , Closeable { private static final String ALREADY_OPENED = \"Output stream or writer has already been opened.\" ; private static final String NOT_FOR_READING = \"FileObject was not opened for reading.\" ; private static final String NOT_FOR_WRITING = \"FileObject was not opened for writing.\" ; private class FilerOutputFileObject extends ForwardingFileObject < FileObject > { private boolean opened = false ; private String name ; FilerOutputFileObject ( String name , FileObject fileObject ) { super ( fileObject ) ; this . name = name ; } @ Override public synchronized OutputStream openOutputStream ( ) throws IOException { if ( opened ) throw new IOException ( ALREADY_OPENED ) ; opened = true ; return new FilerOutputStream ( name , fileObject ) ; } @ Override public synchronized Writer openWriter ( ) throws IOException { if ( opened ) throw new IOException ( ALREADY_OPENED ) ; opened = true ; return new FilerWriter ( name , fileObject ) ; } @ Override public InputStream openInputStream ( ) throws IOException { throw new IllegalStateException ( NOT_FOR_READING ) ; } @ Override public Reader openReader ( boolean ignoreEncodingErrors ) throws IOException { throw new IllegalStateException ( NOT_FOR_READING ) ; } @", "gt": "Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) throws IOException", "prediction": "Override public void close ( ) throws IOException\n", "label": 0}
{"id": 14509, "input": "<s> package org . restlet . test . resource ; import org . restlet . resource . Get ; import org . restlet . resource . ServerResource ; public class MyResource4 extends ServerResource { @ Get ( \"xml\" ) public String toXml ( ) { return \"<root/>\" ; } @ Get", "gt": "( \"json\" ) public String toJson ( )", "prediction": "( \"html\" ) public String toHTML ( )\n", "label": 1}
{"id": 3328, "input": "<s> public class SuperNew4 { void foo ( ) { class One { One ( Object o ) { } One ( ) { this", "gt": "( new Object ( )", "prediction": ". o = o ;\n", "label": 0}
{"id": 14510, "input": "<s> package org . eclipse . rap . demo . controls ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class LoginDialog extends Dialog { private static final int LOGIN_ID = IDialogConstants . CLIENT_ID + 1 ; private Text userText ; private Text passText ; private Label mesgLabel ; private final String title ; private final String message ; private String username ; private String password ; public LoginDialog ( final Shell parent , final String title , final String message ) { super ( parent ) ; this . title = title ; this . message = message ; } public String getPassword ( ) { return password ; } public void setUsername ( final String username ) { this . username = username ; } public String getUsername ( ) { return username ; } @ Override protected void configureShell ( final Shell shell ) { super . configureShell ( shell ) ; if ( title != null ) { shell . setText ( title ) ; } shell . addControlListener ( new ControlAdapter ( ) { @ Override public void controlResized ( ControlEvent e ) { initializeBounds ( ) ; } } ) ; } @ Override protected Control createDialogArea ( final Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; composite . setLayout ( new GridLayout ( 2 , false ) ) ; mesgLabel = new Label ( composite , SWT . NONE ) ; GridData messageData = new GridData ( SWT . FILL , SWT . CENTER , true , false ) ; messageData . horizontalSpan = 2 ; mesgLabel . setLayoutData ( messageData ) ; Label userLabel = new Label", "gt": "( composite , SWT . NONE ) ;", "prediction": "( composite , SWT . NONE ) ;\n", "label": 1}
{"id": 2359, "input": "<s> package com . quirijngrootbluemink . iptools ; public final class R { public static final class array { public static final int numberPings = 0x7f090000 ; public static final int numberPingsValues = 0x7f090001 ; } public static final class attr { public static final int title = 0x7f010000 ; } public static final class color { public static final int actionbar_background_end = 0x7f050003 ; public static final int actionbar_background_item_pressed_end = 0x7f050005 ; public static final int actionbar_background_item_pressed_start = 0x7f050004 ; public static final int actionbar_background_start = 0x7f050002 ; public static final int actionbar_separator = 0x7f050000 ; public static final int actionbar_title = 0x7f050001 ; public static final int background = 0x7f050007 ; public static final int list_item = 0x7f050008 ; public static final int text_color = 0x7f050006 ; } public static final class dimen { public static final int actionbar_height = 0x7f060000 ; public static final int actionbar_item_height = 0x7f060001 ; public static final int actionbar_item_width = 0x7f060002 ; } public static final class drawable { public static final int actionbar_back_indicator = 0x7f020000 ; public static final int actionbar_background = 0x7f020001 ; public static final int actionbar_btn = 0x7f020002 ; public static final int actionbar_btn_normal = 0x7f020003 ; public static final int actionbar_btn_pressed = 0x7f020004 ; public static final int ic_charts = 0x7f020005 ; public static final int ic_diagnostic_tools = 0x7f020006 ; public static final int ic_ip_calc = 0x7f020007 ; public static final int ic_ip_calculator = 0x7f020008 ; public static final int ic_menu_gallery = 0x7f020009 ; public static final int ic_menu_home = 0x7f02000a ; public static final int ic_menu_preferences = 0x7f02000b ; public static final int ic_menu_refresh = 0x7f02000c ; public static final int ic_ns_lookup = 0x7f02000d ; public static final int ic_nslookup = 0x7f02000e ; public static final int ic_ping = 0x7f02000f ; public static final int ic_signal_strength = 0x7f020010 ; public static final int ic_signal_strength_1 = 0x7f020011 ; public static final int ic_signal_strength_2 = 0x7f020012 ; public static final int ic_signal_strength_3 = 0x7f020013 ; public static final int ic_signal_strength_4 = 0x7f020014 ; public static final int ic_star = 0x7f020015 ; public static final int ic_wifi = 0x7f020016 ; public static final int ic_wifi_networks = 0x7f020017 ; public static final int icon = 0x7f020018 ; } public static final class id { public static final int IPCalc = 0x7f0b001a ; public static final int Utilities = 0x7f0b001e ; public static final int Wifi = 0x7f0b001f ; public static final int actionBar = 0x7f0b000a ; public static final int actionbar_actions = 0x7f0b0006 ; public static final int actionbar_home = 0x7f0b0001 ; public static final int actionbar_home_bg = 0x7f0b0003 ; public static final int actionbar_home_btn = 0x7f0b0004 ; public static final int actionbar_home_is_back = 0x7f0b0005 ; public static final int actionbar_home_logo = 0x7f0b0002 ; public static final int actionbar_item = 0x7f0b0009 ; public static final int actionbar_progress = 0x7f0b0007 ; public static final int actionbar_title = 0x7f0b0008 ; public static final", "gt": "int btnCalc = 0x7f0b000c ;", "prediction": "int actionbar_title_bg = 0x7f0b0009 ;\n", "label": 0}
{"id": 14516, "input": "<s> package org . mitre . oauth2 . service . impl ; import java . util . Date ; import java . util . List ; import java . util . Set ; import org . mitre . oauth2 . model . AuthenticationHolderEntity ; import org . mitre . oauth2 . model . ClientDetailsEntity ; import org . mitre . oauth2 . model . OAuth2AccessTokenEntity ; import org . mitre . oauth2 . model . OAuth2RefreshTokenEntity ; import org . mitre . oauth2 . repository . AuthenticationHolderRepository ; import org . mitre . oauth2 . repository . OAuth2TokenRepository ; import org . mitre . oauth2 . service . ClientDetailsEntityService ; import org . mitre . oauth2 . service . OAuth2TokenEntityService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . scheduling . annotation . Scheduled ; import org . springframework . security . authentication . AuthenticationCredentialsNotFoundException ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . oauth2 . common . exceptions . InvalidClientException ; import org . springframework . security . oauth2 . common . exceptions . InvalidTokenException ; import org . springframework . security . oauth2 . provider . AuthorizationRequest ; import org . springframework . security . oauth2 . provider . OAuth2Authentication ; import org . springframework . security . oauth2 . provider . token . TokenEnhancer ; import org . springframework . stereotype . Service ; import com . google . common . collect . Sets ; @ Service public class DefaultOAuth2ProviderTokenService implements OAuth2TokenEntityService { private static Logger logger = LoggerFactory . getLogger ( DefaultOAuth2ProviderTokenService . class ) ; @ Autowired private OAuth2TokenRepository tokenRepository ; @ Autowired private AuthenticationHolderRepository authenticationHolderRepository ; @ Autowired private ClientDetailsEntityService clientDetailsService ; @ Autowired private TokenEnhancer tokenEnhancer ; @ Override public OAuth2AccessTokenEntity createAccessToken ( OAuth2Authentication authentication ) throws AuthenticationException , InvalidClientException { if ( authentication != null && authentication . getAuthorizationRequest ( ) != null ) { AuthorizationRequest clientAuth = authentication . getAuthorizationRequest ( ) ; ClientDetailsEntity client = clientDetailsService . loadClientByClientId ( clientAuth . getClientId ( ) ) ; if ( client == null ) { throw new InvalidClientException ( \"Client not found: \" + clientAuth . getClientId ( ) ) ; } OAuth2AccessTokenEntity token = new OAuth2AccessTokenEntity ( ) ; token . setClient ( client ) ; Set < String > scopes = Sets . newHashSet ( clientAuth . getScope ( ) ) ; token . setScope ( scopes ) ; if ( client . getAccessTokenValiditySeconds ( ) != null && client . getAccessTokenValiditySeconds ( ) > 0 ) { Date expiration = new Date ( System . currentTimeMillis ( ) + ( client . getAccessTokenValiditySeconds ( ) * 1000L ) ) ; token . setExpiration ( expiration ) ; } AuthenticationHolderEntity authHolder = new AuthenticationHolderEntity ( ) ; authHolder . setAuthentication ( authentication ) ; authHolder = authenticationHolderRepository . save ( authHolder ) ; token . setAuthenticationHolder ( authHolder ) ; if ( client . isAllowRefresh ( ) ) { OAuth2RefreshTokenEntity refreshToken = new OAuth2RefreshTokenEntity ( ) ; if ( client . getRefreshTokenValiditySeconds ( ) != null ) { Date expiration = new Date ( System . currentTimeMillis ( ) + ( client . getRefreshTokenValiditySeconds ( ) * 1000L ) ) ; refreshToken . setExpiration ( expiration ) ; }", "gt": "refreshToken . setAuthenticationHolder ( authHolder ) ;", "prediction": "}\n", "label": 1}
{"id": 3457, "input": "<s> package org . ofbiz . entity ; @ SuppressWarnings ( \"serial\" ) public class GenericCreateException extends GenericEntityException { public GenericCreateException ( ) { super ( ) ; } public GenericCreateException ( String str ) { super ( str ) ; } public GenericCreateException ( String str , Throwable nested ) { super (", "gt": "str , nested ) ;", "prediction": "str , nested ) ;\n", "label": 0}
{"id": 14517, "input": "<s> package org . powerbot . game . api . wrappers ; public class RegionOffset { protected final int x , y , plane ; public RegionOffset ( final int x , final int y , final int plane ) { this . x = x ; this . y = y ; this . plane = plane ; } public int getX ( ) { return x ; } public int getY ( ) { return y ; }", "gt": "public int getPlane ( )", "prediction": "}\n", "label": 1}
{"id": 7693, "input": "<s> enum Color { red , green , blue } @ interface Colored { Color value ( ) ; }", "gt": "@ Colored ( teal ) class Martian", "prediction": "}\n", "label": 0}
{"id": 14520, "input": "<s> package org . fuzzydb . attrs . unused ; public interface IRange { public boolean contains ( Comparable < Object > val ) ; public Comparable < Object > getMax ( ) ; public Comparable < Object", "gt": "> getMin ( ) ;", "prediction": "> getMin ( ) ;\n", "label": 1}
{"id": 3432, "input": "<s> package org . parboiled . common ; public interface Predicate < T > { boolean apply", "gt": "( T input ) ;", "prediction": ";\n", "label": 0}
{"id": 14521, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . ui . IElementFactory ; import org . eclipse . ui . IMemento ; public class WorkingSetFactory implements IElementFactory { public IAdaptable createElement ( IMemento memento ) { String workingSetName = memento . getString ( IWorkbenchConstants . TAG_NAME ) ; String label = memento . getString ( IWorkbenchConstants . TAG_LABEL ) ; if ( label == null ) { label = workingSetName ; } String workingSetEditPageId = memento . getString ( IWorkbenchConstants . TAG_EDIT_PAGE_ID ) ; String aggregateString = memento . getString ( AbstractWorkingSet . TAG_AGGREGATE ) ; boolean isAggregate = aggregateString != null && Boolean . valueOf ( aggregateString )", "gt": ". booleanValue ( ) ;", "prediction": "== 0 ;\n", "label": 1}
{"id": 5963, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . lang . annotation . * ; import java . lang . reflect . Array ; import java . lang . reflect . Method ; import java . util . * ; import sun . reflect . annotation . * ; import com . sun . mirror . type . TypeMirror ; import com . sun . mirror . type . MirroredTypeException ; import com . sun . mirror . type . MirroredTypesException ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Pair ; @ SuppressWarnings ( \"deprecation\" ) class AnnotationProxyMaker { private final AptEnv env ; private final Attribute . Compound attrs ; private final Class < ? extends Annotation > annoType ; private AnnotationProxyMaker ( AptEnv env , Attribute . Compound attrs , Class < ? extends Annotation > annoType ) { this . env = env ; this . attrs = attrs ; this . annoType = annoType ; } public static < A extends Annotation > A generateAnnotation ( AptEnv env , Attribute . Compound attrs , Class < A > annoType ) { AnnotationProxyMaker apm = new AnnotationProxyMaker ( env , attrs , annoType ) ; return annoType . cast ( apm . generateAnnotation ( ) ) ; } private Annotation generateAnnotation ( ) { return AnnotationParser . annotationForMap ( annoType , getAllReflectedValues ( ) ) ; } private Map < String , Object > getAllReflectedValues ( ) { Map < String , Object > res = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < MethodSymbol , Attribute > entry : getAllValues ( ) . entrySet ( ) ) { MethodSymbol meth = entry . getKey ( ) ; Object value = generateValue ( meth , entry . getValue ( ) ) ; if ( value != null ) { res . put ( meth . name . toString ( ) , value ) ; } else { } } return res ; } private Map < MethodSymbol , Attribute > getAllValues ( ) { Map < MethodSymbol , Attribute > res = new LinkedHashMap < MethodSymbol , Attribute > ( ) ; ClassSymbol sym = ( ClassSymbol ) attrs . type . tsym ; for ( Scope . Entry e = sym . members ( ) . elems ; e != null ; e = e . sibling ) { if ( e . sym . kind == Kinds . MTH ) { MethodSymbol m = ( MethodSymbol ) e . sym ; Attribute def = m . defaultValue ; if ( def != null ) { res . put ( m , def ) ; } } } for ( Pair < MethodSymbol , Attribute > p : attrs . values ) { res . put ( p . fst , p . snd ) ; } return res ; } private Object generateValue ( MethodSymbol meth , Attribute attr ) { ValueVisitor vv = new ValueVisitor ( meth ) ; return vv . getValue ( attr ) ; } private class ValueVisitor implements Attribute . Visitor { private MethodSymbol meth ; private Class < ? > runtimeType ; private Object value ; ValueVisitor ( MethodSymbol meth ) { this . meth = meth ; } Object getValue ( Attribute attr ) { Method method ; try { method = annoType . getMethod ( meth . name . toString ( ) ) ; } catch ( NoSuchMethodException e ) { return null ; } runtimeType = method . getReturnType ( ) ; attr . accept ( this ) ; if ( ! ( value instanceof ExceptionProxy ) && ! AnnotationType . invocationHandlerReturnType ( runtimeType ) . isInstance ( value ) ) { typeMismatch ( method , attr ) ; } return value ; } public void visitConstant ( Attribute . Constant c ) { value = Constants . decodeConstant ( c . value , c . type ) ; } public void visitClass ( Attribute . Class c ) { value = new MirroredTypeExceptionProxy ( env . typeMaker . getType ( c . type ) ) ; } public void visitArray ( Attribute . Array a ) { Type elemtype = env . jctypes . elemtype ( a . type ) ; if ( elemtype . tsym == env . symtab . classType . tsym ) { ArrayList < TypeMirror > elems = new ArrayList < TypeMirror > ( ) ; for ( int i = 0 ; i < a . values . length ; i ++ ) { Type elem = ( ( Attribute . Class ) a . values [ i ] ) . type ; elems . add ( env . typeMaker . getType ( elem ) ) ; } value = new MirroredTypesExceptionProxy ( elems ) ; } else { int len = a . values . length ; Class < ? > runtimeTypeSaved = runtimeType ; runtimeType = runtimeType . getComponentType ( ) ; try { Object res = Array . newInstance ( runtimeType , len ) ; for ( int i = 0 ; i < len ; i ++ ) { a . values [ i ] . accept ( this ) ; if ( value == null || value instanceof ExceptionProxy ) { return ; } try { Array . set ( res , i , value ) ; } catch ( IllegalArgumentException e ) { value = null ; return ; } } value = res ; } finally { runtimeType = runtimeTypeSaved ; } } } @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public void visitEnum ( Attribute . Enum e ) { if ( runtimeType . isEnum ( ) ) { String constName = e . value . toString ( ) ; try { value = Enum . valueOf ( ( Class ) runtimeType , constName ) ; } catch ( IllegalArgumentException ex ) { value = new EnumConstantNotPresentExceptionProxy ( ( Class < Enum < ?", "gt": "> > ) runtimeType , constName ) ;", "prediction": "> > ) ex ) ;\n", "label": 0}
{"id": 14553, "input": "<s> package io . beancounter . commons . helper . jedis ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import com . google . inject . name . Named ; import org . apache . commons . pool . impl . GenericObjectPool ; import redis . clients . jedis . JedisPool ; import redis . clients . jedis . JedisPoolConfig ; @ Singleton public class DefaultJedisPoolFactory implements JedisPoolFactory { private static JedisPool pool ; @ Inject", "gt": "public DefaultJedisPoolFactory ( @ Named ( \"address\" ) String address )", "prediction": "public DefaultJedisPoolFactory ( )\n", "label": 1}
{"id": 7928, "input": "<s> package com . sun . tools . apt . mirror . type ; import com . sun . mirror . type . VoidType ; import com . sun . mirror . util . TypeVisitor ; import com . sun . tools . apt . mirror . AptEnv ; @ SuppressWarnings ( \"deprecation\" )", "gt": "class VoidTypeImpl extends TypeMirrorImpl implements VoidType", "prediction": "public class TypeVisitor\n", "label": 0}
{"id": 14561, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . resources . client . CssResource ;", "gt": "public interface AboutDialog_BinderImpl_GenCss_style extends CssResource", "prediction": "import com . google . gwt . resources . client . Context ;\n", "label": 1}
{"id": 8128, "input": "<s> import annot . * ; import annot . annot2 . * ; public class MethodAnnotations { static double d ; @ MySimple ( \"value\" ) @ MyMarker @ AnnotMarker @ AnnotSimple ( \"foo\" ) @ AnnotMarker2 @ AnnotSimple2 ( \"bar\" ) public void foo ( ) { return ; } private double bar ( int baz ) { @", "gt": "AnnotShangri_la int local = 0 ;", "prediction": "Override public void foo ( )\n", "label": 0}
{"id": 14568, "input": "<s> package org . seage . problem . qap . sannealing ; import java . util . Random ; import org . seage . metaheuristic . sannealing . IMoveManager ; import org . seage . metaheuristic . sannealing . Solution ; public class QapMoveManager implements IMoveManager { public Solution getModifiedSolution ( Solution solution ) { QapSolution qapSolution = ( ( QapSolution ) solution ) . clone ( ) ; Random rnd = new Random ( ) ; int qapSolutionLength = qapSolution . getAssign ( ) . length ; int a = rnd . nextInt ( qapSolutionLength ) ; int b = rnd . nextInt ( qapSolutionLength ) ; if ( a != b ) { qapSolution . getAssign ( ) [ a ] = qapSolution . getAssign ( ) [ a ] + qapSolution . getAssign ( ) [ b ] ; qapSolution . getAssign ( ) [ b ] = qapSolution . getAssign ( ) [ a ] - qapSolution . getAssign ( ) [ b ] ; qapSolution . getAssign ( ) [ a ] = qapSolution . getAssign ( ) [ a ] - qapSolution . getAssign (", "gt": ") [ b ] ;", "prediction": ") [ b ] ;\n", "label": 1}
{"id": 7326, "input": "<s> package org . davidsingleton . nnrccar ; import java . io . DataInputStream ; import java . io . IOException ; import java . net . ServerSocket ; import java . net . Socket ; public class FeatureServer { class ServingThread extends Thread { private Socket sock ; public ServingThread ( Socket s ) { sock = s ; } @ Override public void run ( ) { try { DataInputStream dis = new DataInputStream ( sock . getInputStream ( ) ) ; while ( true ) { int width = dis . readInt ( ) ; int height = dis . readInt ( ) ; int accelerometerFeatureCount = dis . readInt ( ) ; int len = width * height ; byte [ ] features = new byte [ width * height ] ; float [ ] accelerometerFeatures = new float [ accelerometerFeatureCount ] ; int read = 0 ; while ( read < len ) { read += dis . read ( features , read , len - read ) ; } for ( int i = 0 ; i < accelerometerFeatureCount ; i ++ ) { accelerometerFeatures [ i ] = dis . readFloat ( ) ; } listener . features ( features , width , height , accelerometerFeatures ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } ; ServerSocket ss ; private FeatureCallback listener ; FeatureServer ( FeatureCallback cb ) {", "gt": "this . listener = cb ;", "prediction": "this . listener = cb ;\n", "label": 0}
{"id": 14575, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . structure . PersistentObject ; import de . uos . igf . db3d . dbms . api . SRID ; public class SpaceDefinition implements PersistentObject { private ScalarOperator sop ; private int srid ; public SpaceDefinition ( double epsilon , int srid ) { this . sop = new ScalarOperator ( epsilon ) ; this . srid = srid ; } public ScalarOperator getScalarOperator ( ) { return this . sop ; } public int getSRID ( ) { return this . srid ; } public String getSridDescription ( ) { return SRID", "gt": ". getSridDescription ( this . srid ) ;", "prediction": ";\n", "label": 1}
{"id": 9431, "input": "<s> package com . quirijngrootbluemink . iptools ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import android . app . Activity ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . IntentFilter ; import android . graphics . Color ; import android . graphics . Paint ; import android . net . wifi . ScanResult ; import android . net . wifi . WifiManager ; import android . os . Bundle ; import android . os . Handler ; import android . view . View ; import android . view . View . OnClickListener ; import android . widget . ListView ; import com . androidplot . Plot ; import com . androidplot . series . XYSeries ; import com . androidplot . ui . AnchorPosition ; import com . androidplot . ui . SizeLayoutType ; import com . androidplot . xy . BoundaryMode ; import com . androidplot . xy . LineAndPointFormatter ; import com . androidplot . xy . LineAndPointRenderer ; import com . androidplot . xy . SimpleXYSeries ; import com . androidplot . xy . XLayoutStyle ; import com . androidplot . xy . XYPlot ; import com . androidplot . xy . XYStepMode ; import com . androidplot . xy . YLayoutStyle ; import com . markupartist . android . widget . ActionBar ; public class WifiChannelChart extends Activity { private XYPlot channelChart ; private List < ScanResult > scanResults ; private List < XYSeries > currentSeries ; BroadcastReceiver receiver ; ListView wifiNetworksList ; WifiManager wifi ; Handler handlr ; Runnable mUpdateScanTask ; private void setActionBar ( ) { ActionBar actionBar = ( ActionBar ) findViewById ( R . id . actionBar ) ; actionBar . setTitle ( getString ( R . string . app_name ) ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setOnTitleClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { goUp ( ) ; } } ) ; } private void goUp ( ) { this . finish ( ) ; } private double calculateY ( double x , double strength , double channel ) { double v = 100 - strength ; double vertical = 100 - v ; double stretch = ( 0.25 ) * v ; double formula = - ( Math . pow ( ( x - channel ) , 2 ) ) ; return ( ( stretch ) * ( formula ) - ( vertical ) ) ; } private List < List < Double > > getCoordinates ( double channel , double strength ) { List < List < Double > > coords = new ArrayList < List < Double > > ( ) ; List < Double > x2 = new ArrayList < Double > ( ) ; double chan = channel ; double step = 0.1 ; double startpoint = chan - 2 ; double endpoint = chan + 2.1 ; double counter = startpoint ; while ( counter <= endpoint ) { x2 . add ( counter ) ; counter += step ; } counter = startpoint ; List < Double > y2 = new ArrayList < Double > ( ) ; while ( counter <= ( endpoint ) ) { double v = calculateY ( counter , Math . abs ( strength ) , chan ) ; y2 . add ( v ) ; counter += step ; } coords . add ( x2 ) ; coords . add ( y2 ) ; return coords ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . wifi_channel_graph ) ; setActionBar ( ) ; currentSeries = new ArrayList < XYSeries > ( ) ; handlr = new Handler ( ) ; mUpdateScanTask = new Runnable ( ) { public void run ( ) { wifi . startScan ( ) ; updateNetworks ( ) ; handlr . postDelayed ( this , 10000 ) ; } } ; handlr . removeCallbacks ( mUpdateScanTask ) ; handlr . postDelayed ( mUpdateScanTask , 1000 ) ; wifi = ( WifiManager ) getSystemService ( Context . WIFI_SERVICE ) ; wifiNetworksList = ( ListView ) findViewById ( R . id . wifiNetworksList ) ; scanResults = wifi . getScanResults ( ) ; setupChart ( ) ; addChartSeries ( ) ; } public void addChartSeries ( ) { for ( XYSeries series : currentSeries ) { channelChart . removeSeries ( series ) ; } currentSeries . clear ( ) ; channelChart . invalidate ( ) ; int i = 0 ; for ( ScanResult scanResult : scanResults ) { List < List < Double > > opdenbierg = getCoordinates ( calculateChannel ( scanResult . frequency ) , scanResult . level ) ; SimpleXYSeries series2 = new SimpleXYSeries ( opdenbierg . get ( 0 ) , opdenbierg . get (", "gt": "1 ) , scanResult . SSID ) ;", "prediction": "1 ) ) ;\n", "label": 0}
{"id": 14595, "input": "<s> package org . fuzzydb . attrs . converters ; import static org . junit . Assert . * ; import org . fuzzydb . attrs . converters . StringToEcefVectorConverter ; import org . fuzzydb . attrs . location . EcefVector ; import org . fuzzydb . dto . dimensions . IPoint3D ; import org . junit . Test ; import org . springframework . core . convert . converter . Converter ; public class StringToEcefVectorConverterTest { private final Converter < String , IPoint3D > converter = new StringToEcefVectorConverter ( null ) ; @ Test public void testConvertTupleWithWhitespace ( ) { EcefVector result = ( EcefVector ) converter . convert ( \"{ 53.02 , -0.103 }\" ) ; assertEquals ( 53.02 , result . getLatDegs ( ) , 0.0001 ) ; assertEquals ( - 0.103", "gt": ", result . getLonDegs ( ) , 0.0001 ) ;", "prediction": ", result . getLongDegs ( ) , 0.0001 ) ;\n", "label": 1}
{"id": 9871, "input": "<s> package com . midtro . platform . modules . assets . types ; import java . awt . Image ; import java . io . File ; import java . net . URL ; import java . util . Map ; import javax . imageio . ImageIO ; import com . midtro . platform . modules . assets . Assembler ; import com . midtro . platform . modules . assets . Asset ; import com . midtro . platform . modules . assets . AssetConfig ; public class ImageAssembler implements Assembler { @ Override public void assemble ( String assetName , String fileName , AssetConfig config , Map < String , Asset < ? > > store ) throws Exception { Image img = null ; switch ( config . getMountType ( ) ) { case FILE : img = ImageIO . read ( new File ( config . getFileLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ; break ; case CACHE : img = ImageIO . read ( new File ( config . getCacheLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ; break ; case URL : img = ImageIO . read ( new URL ( config . getUrlLocation ( ) + fileName ) ) ; break ; default : throw new IllegalStateException (", "gt": "\"Unknown mount type\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14599, "input": "<s> package org . eclipse . core . tests . harness ; import org . eclipse . core . runtime . IProgressMonitor ; public abstract class TestProgressMonitor implements IProgressMonitor { public void beginTask ( String name , int totalWork ) { } public void done ( ) { } public void internalWorked ( double work ) { } public boolean isCanceled ( ) { return false ; } public void setCanceled ( boolean b ) { }", "gt": "public void setTaskName ( String name )", "prediction": "}\n", "label": 1}
{"id": 6653, "input": "<s> import java . util . * ; import com . sun . source . tree . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; public class CheckMethod extends Checker { public static void main ( String ... args ) throws Exception { Checker chk = new CheckMethod ( ) ; chk . check ( \"TestMethod.java\" ) ; } @ Override protected boolean checkLocal ( Scope s , String ref ) { ExecutableElement ee =", "gt": "s . getEnclosingMethod ( ) ;", "prediction": "null ;\n", "label": 0}
{"id": 14617, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import org . restlet . example . book . restlet .", "gt": "ch09 . client . MailList . SelectionStyle ;", "prediction": "ch10 . client ;\n", "label": 1}
{"id": 6706, "input": "<s> public class Attach { public static void main ( String [ ] args ) { Attach . class . getClassLoader ( ) . setClassAssertionStatus ( \"Attach\" , false ) ; if ( V . assertsEnabled ( ) ) throw new Error ( \"failed 4478095.1\" ) ; if ( ! U . correct ) throw new Error ( \"failed 4478095.2\" ) ; } static class U { static boolean correct = V . assertsEnabled ( ) ; }", "gt": "static class V extends U", "prediction": "}\n", "label": 0}
{"id": 14623, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . restHandler ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . util . List ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . Provider ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . DefaultMarshaler ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . interfaces . PublishingMarshalingException ; import org . nuxeo . ecm . webengine . WebEngine ; @ Provider public class RemotePubMessageReader implements MessageBodyReader < RemotePubParam > { public boolean isReadable ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType mt ) { return mt . equals ( RemotePubParam . mediaType ) ; } public RemotePubParam readFrom ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType arg3 , MultivaluedMap arg4 , InputStream is ) throws IOException , WebApplicationException { DefaultMarshaler marshaler = new DefaultMarshaler ( WebEngine . getActiveContext ( ) . getCoreSession ( ) ) ; InputStreamReader isr = new InputStreamReader ( is , \"UTF-8\" ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuffer sb", "gt": "= new StringBuffer ( ) ;", "prediction": "= new StringBuffer ( ) ;\n", "label": 1}
{"id": 7716, "input": "<s> package com . midtro . platform . io ; import java . util . UUID ; public interface IDataSource { byte readByte ( ) ; boolean readBoolean ( ) ; byte [ ] readBytes ( int length ) ; short readShort ( ) ; int readInt ( ) ; long readLong ( ) ;", "gt": "String readString ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14626, "input": "<s> package org . eclipse . ui . handlers ; import java . util . Hashtable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExecutableExtension ; import org . eclipse . jface . commands . RadioState ; public final class RegistryRadioState extends RadioState implements IExecutableExtension { private final void readDefault ( final String defaultString ) { if ( \"true\" . equalsIgnoreCase ( defaultString ) ) { setValue ( Boolean . TRUE ) ; } } private final void readPersisted ( final String persistedString ) { if ( \"false\" . equalsIgnoreCase ( persistedString ) ) { setShouldPersist ( false ) ; } setShouldPersist ( true ) ; } public final void setInitializationData ( final IConfigurationElement configurationElement , final String propertyName , final Object data ) { if ( data instanceof String ) { setRadioGroupIdentifier ( ( String ) data ) ; setValue ( Boolean . FALSE ) ; setShouldPersist ( true ) ; } else if ( data instanceof Hashtable ) { final Hashtable parameters = ( Hashtable ) data ; final Object defaultObject = parameters . get ( \"default\" ) ; if ( defaultObject instanceof String ) { readDefault ( ( String ) defaultObject ) ; } final Object persistedObject = parameters . get ( \"persisted\" ) ; if ( persistedObject instanceof String ) {", "gt": "readPersisted ( ( String ) persistedObject ) ;", "prediction": "readPersisted ( ( String ) persistedObject ) ;\n", "label": 1}
{"id": 2064, "input": "<s> package org . ofbiz . entity . serialize ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . Serializable ; import java . lang . ref . WeakReference ; import java . math . BigDecimal ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import java . util . Stack ; import java . util . TreeMap ; import java . util . TreeSet ; import java . util . Vector ; import java . util . WeakHashMap ; import javax . xml . bind . DatatypeConverter ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . SAXException ; public class XmlSerializer { public static final String module = XmlSerializer . class . getName ( ) ; private static WeakReference < DateFormat > simpleDateFormatter ; public static String serialize ( Object object ) throws SerializeException , FileNotFoundException , IOException { Document document = UtilXml . makeEmptyXmlDocument ( \"ofbiz-ser\" ) ; Element rootElement = document . getDocumentElement ( ) ; rootElement . appendChild ( serializeSingle ( object , document ) ) ; return UtilXml . writeXmlDocument ( document ) ; } public static Object deserialize ( String content , Delegator delegator ) throws SerializeException , SAXException , ParserConfigurationException , IOException { Document document = UtilXml . readXmlDocument ( content , false ) ; if ( document != null ) { if ( ! \"ofbiz-ser\" . equals ( document . getDocumentElement ( ) . getTagName ( ) ) ) { return UtilXml . fromXml ( content ) ; } return deserialize ( document , delegator ) ; } else { Debug . logWarning ( \"Serialized document came back null\" , module ) ; return null ; } } public static Object deserialize ( Document document , Delegator delegator ) throws SerializeException { Element rootElement = document . getDocumentElement ( ) ; Node curChild = rootElement . getFirstChild ( ) ; while ( curChild != null && curChild . getNodeType ( ) != Node . ELEMENT_NODE ) { curChild = curChild . getNextSibling ( ) ; } if ( curChild == null ) { return null ; } return deserializeSingle ( ( Element ) curChild , delegator ) ; } public static Element serializeSingle ( Object", "gt": "object , Document document ) throws SerializeException", "prediction": "object ) throws SerializeException , SAXException , ParserConfigurationException , IOException\n", "label": 0}
{"id": 14631, "input": "<s> package org . fuzzydb . util ; import java . io . IOException ; import java . util . Map ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; public class CsvReaderBkgnd extends CsvReader implements Runnable { private Thread thread ; private BlockingQueue < Object > queue = new ArrayBlockingQueue < Object > ( 10 ) ; private Object [ ] packet ; private int next = 0 ; public CsvReaderBkgnd ( String file , boolean stripQuotes ) throws IOException { super ( file , stripQuotes , false ) ; } public CsvReaderBkgnd ( String file , boolean stripQuotes , boolean hasHeader ) throws IOException { super ( file , stripQuotes , hasHeader , false ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public Map < String , Object > readLine ( ) throws IOException , UnsupportedTypeException , GarbageLineException { start ( ) ; Object o = null ; try { if ( packet == null ) { packet = ( Object [ ] ) queue . take ( ) ; next = 0 ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } o = packet [ next ++ ] ; if ( next == packet . length ) { packet = null ; } if ( o instanceof UnsupportedTypeException ) { throw ( UnsupportedTypeException ) o ; } if ( o instanceof GarbageLineException ) { throw ( GarbageLineException ) o ; } if ( o instanceof IOException ) { throw ( IOException ) o ; } return ( Map < String , Object > ) o ; } private void start ( ) { if ( thread == null ) { thread = new Thread ( this ) ; thread . start ( ) ; } } public void run ( ) { int size = 100 ; Map < String , Object > map ; Object [ ] stuff = new Object [ size ] ; int i = 0 ; for ( ; ; ) { try {", "gt": "map = super . readLine ( ) ;", "prediction": "map = new HashMap < String , Object > ( ) ;\n", "label": 1}
{"id": 1504, "input": "<s> package org . ofbiz . content . openoffice ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import com . sun . star . io . XSeekable ; import com . sun . star . io . XInputStream ; import com . sun . star . io . BufferSizeExceededException ; import com . sun . star . io . NotConnectedException ; public class OpenOfficeByteArrayInputStream extends ByteArrayInputStream implements XInputStream , XSeekable { public static final String module = OpenOfficeByteArrayInputStream . class . getName ( ) ; public OpenOfficeByteArrayInputStream ( byte [ ] bytes ) { super ( bytes ) ; } public long getPosition ( ) throws com . sun . star . io . IOException { return this . pos ; } public long getLength ( ) throws com . sun . star . io . IOException { return this . count ; } public void seek ( long pos1 ) throws com . sun . star . io . IOException , IllegalArgumentException { this . pos = ( int ) pos1 ; } public void skipBytes ( int pos1 ) throws BufferSizeExceededException , NotConnectedException , com . sun . star . io . IOException { skip ( pos1 ) ; } public void closeInput ( ) throws NotConnectedException , com . sun . star . io . IOException { try { close ( ) ; } catch ( IOException e ) { String errMsg =", "gt": "e . getMessage ( ) ;", "prediction": "e . getMessage ( ) ;\n", "label": 0}
{"id": 14636, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . safehtml . client . SafeHtmlTemplates ; import com . google . gwt . safehtml . shared . SafeHtml ; import com . google . gwt . safehtml . shared . SafeHtmlUtils ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiBinderUtil ; import com . google . gwt . user . client . ui . Widget ; public class AboutDialog_BinderImpl implements UiBinder < com . google . gwt . user . client . ui . Widget , org . restlet . example . book . restlet . ch09 . client . AboutDialog > , org . restlet . example . book . restlet . ch09 . client . AboutDialog . Binder { interface Template extends SafeHtmlTemplates { @ Template ( \"<div class='{0}'></div> <div class='{1}'> This sample application demonstrates the construction of a complex user interface using GWT's built-in widgets. Have a look at the code to see how easy it is to build your own apps! </div> <div class='{2}'> <span id='{3}'></span> </div>\" ) SafeHtml html1 ( String arg0 , String arg1 , String arg2 , String arg3 ) ; } Template template = GWT . create ( Template . class ) ; public com . google . gwt . user . client . ui . Widget createAndBindUi ( final org . restlet . example . book . restlet . ch09 . client . AboutDialog owner ) { org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay = ( org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle ) GWT . create ( org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenBundle . class ) ; com . google . gwt . resources . client . ImageResource logo = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay . logo ( ) ; org . restlet . example . book . restlet . ch09 . client . AboutDialog_BinderImpl_GenCss_style style = clientBundleFieldNameUnlikelyToCollideWithUserSpecifiedFieldOkay . style ( ) ; java . lang . String domId0 = com . google . gwt . dom . client . Document . get ( ) . createUniqueId ( ) ; com . google . gwt . user . client . ui . Button closeButton = ( com . google . gwt . user . client . ui . Button ) GWT . create ( com . google . gwt . user . client . ui . Button . class ) ; com . google . gwt . user . client . ui . HTMLPanel f_HTMLPanel1 = new com . google . gwt . user . client . ui . HTMLPanel ( template . html1 ( \"\" + style . logo ( ) + \"\" , \"\" + style . aboutText ( ) + \"\" , \"\" + style . buttons ( ) + \"\" ,", "gt": "domId0 ) . asString ( ) ) ;", "prediction": "\"\" ) ) ;\n", "label": 1}
{"id": 2382, "input": "<s> package org . ofbiz . base . conversion ; import java . util . Locale ; import java . util . TimeZone ; public abstract class AbstractLocalizedConverter < S , T > extends AbstractConverter < S , T > implements LocalizedConverter < S , T > { protected AbstractLocalizedConverter ( Class < ? super S > sourceClass , Class < ? super T > targetClass ) { super ( sourceClass , targetClass ) ; } public T convert ( Class < ? extends T > targetClass , S obj , Locale locale , TimeZone timeZone ) throws ConversionException { return convert ( obj , locale , timeZone ) ; } public T convert ( Class < ? extends T > targetClass , S obj , Locale", "gt": "locale , TimeZone timeZone , String formatString ) throws ConversionException", "prediction": "locale , TimeZone timeZone ) throws ConversionException\n", "label": 0}
{"id": 14637, "input": "<s> package it . unina . jdbc . oracle ; import java . sql . * ; import oracle . jdbc . * ; import oracle . jdbc . pool . OracleDataSource ; class SendBatch { public static void main ( String args [ ] ) throws SQLException { String url = \"jdbc:oracle:oci8:@\" ; try { String url1 = System . getProperty ( \"JDBC_URL\" ) ; if ( url1 != null ) url = url1 ; } catch ( Exception e ) { } OracleDataSource ods = new OracleDataSource ( ) ; ods . setUser ( \"hr\" ) ; ods . setPassword ( \"hr\" ) ; ods . setURL ( url ) ; Connection conn = ods . getConnection ( ) ; Statement stmt = conn . createStatement ( ) ; stmt . execute ( \"delete from departments where department_id > 2000\" ) ; ( ( OracleConnection ) conn ) . setDefaultExecuteBatch ( 50 ) ; PreparedStatement ps = conn . prepareStatement ( \"insert into departments values (?, ?, ?, ?)\" ) ; ps . setInt ( 1 , 2010 ) ; ps . setString ( 2 , \"Import\" ) ; ps . setInt ( 3 , 114 ) ;", "gt": "ps . setInt ( 4 , 1700 ) ;", "prediction": "}\n", "label": 1}
{"id": 7479, "input": "<s> package de . javawi . jstun . header ; public class MessageHeaderParsingException extends MessageHeaderException { private static final", "gt": "long serialVersionUID = 3544393617029607478L ;", "prediction": "long serialVersionUID = 1L ;\n", "label": 0}
{"id": 14640, "input": "<s> package org . seage . grammar . iif ; import org . seage . data . DataNode ; import org . seage . grammar . Symbol ; import org . seage . grammar . GrammarRule ; import org . seage . grammar . NonterminalSymbol ; import java . util . * ; public class FVariableGrammarRule extends GrammarRule { private static final long serialVersionUID = - 4347619039586359678L ; public FVariableGrammarRule ( int uniqueId ) { super ( new NonterminalSymbol ( \"F\" ) , new Vector < Symbol > ( ) , uniqueId ) ; right . add ( new NonterminalSymbol ( \"VAR\" ) ) ; } public", "gt": "Object eval ( DataNode symbolTable , NonterminalSymbol treePos ) throws Exception", "prediction": "FVariableGrammarRule ( int uniqueId )\n", "label": 1}
{"id": 4149, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface NewArrayTree extends ExpressionTree { Tree getType ( ) ; List < ? extends ExpressionTree > getDimensions ( ) ; List", "gt": "< ? extends ExpressionTree > getInitializers ( ) ;", "prediction": "< ? extends ExpressionTree > getChildren ( ) ;\n", "label": 0}
{"id": 14641, "input": "<s> package agents ; import sim . util . Bag ; public class BattleHistories { private boolean isAttacker = false ; private Bag battles = new Bag ( ) ; public long [ ] attacks = new long [ 43 ] ; public long [ ] lastPeriod = new long [ 43 ] ; public long [ ] wins = new long [ 43 ] ; public double [ ] avgAttackers = new double [ 43 ] ; public double [ ] minAttackers = new double [ 43 ] ; public double [ ] maxAttackers = new double [ 43 ] ; public double [ ] avgDefenders = new double [ 43 ] ; public double [ ] minDefenders = new double [ 43 ] ; public double [ ] maxDefenders = new double [ 43 ] ; public double [ ] attackRatio = new double [ 43 ] ; public BattleHistories ( boolean isAttacker ) { this . isAttacker = isAttacker ; } public void add ( BattleHistory battle ) { battles . add ( battle ) ; int territoryID ; if ( isAttacker ) { territoryID = battle . getAttackerID ( ) ; } else { territoryID = battle . getDefenderID ( ) ; } attacks [ territoryID ] ++ ; lastPeriod [ territoryID ] = battle . getPeriod ( ) ; if ( battle . isYouWon ( ) ) { wins [ territoryID ] ++ ; } if ( attacks [ territoryID ] <= 1 ) { avgAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; minAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; maxAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; avgDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; minDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; maxDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; if ( battle . getSoldiersDefending ( ) != 0 ) { attackRatio [ territoryID ] = battle . getSoldiersAttacking ( ) / battle . getSoldiersDefending ( ) ; } } else { avgAttackers [ territoryID ] = ( ( avgAttackers [ territoryID ] * ( attacks [ territoryID ] - 1 ) ) + battle . getSoldiersAttacking ( ) ) / attacks [ territoryID ] ; if ( battle . getSoldiersAttacking ( ) < minAttackers [ territoryID ] ) { minAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; } if ( battle . getSoldiersAttacking ( ) > maxAttackers [ territoryID ] ) { maxAttackers [ territoryID ] = battle . getSoldiersAttacking ( ) ; } avgDefenders [ territoryID ] = ( ( avgDefenders [ territoryID ] * ( attacks [ territoryID ] - 1 ) ) + battle . getSoldiersDefending ( ) ) / attacks [ territoryID ] ; if ( battle . getSoldiersDefending ( ) < minDefenders [ territoryID ] ) { minDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; } if ( battle . getSoldiersDefending ( ) > maxDefenders [ territoryID ] ) { maxDefenders [ territoryID ] = battle . getSoldiersDefending ( ) ; } if ( battle . getSoldiersDefending ( ) != 0 ) { attackRatio [ territoryID ] = battle . getSoldiersAttacking", "gt": "( ) / battle . getSoldiersDefending ( ) ;", "prediction": "( ) / battle . getSoldiersDefending ( ) ;\n", "label": 1}
{"id": 6197, "input": "<s> package com . midtro . platform . modules ; import com . midtro . platform . Application ; public interface Module { void", "gt": "onRegister ( final Application application ) ;", "prediction": "setUp ( ) ;\n", "label": 0}
{"id": 14644, "input": "<s> package br . org . archimedes . extend ; import static org . junit . Assert . assertEquals ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . dimension . Dimension ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . extend . interfaces . Extender ; import br . org . archimedes . infiniteline . InfiniteLine ; import br . org . archimedes . leader . Leader ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; import br . org . archimedes . semiline . Semiline ; import br . org . archimedes . stub . StubElement ; import br . org . archimedes . text . Text ; public class ExtendManagerTest extends Tester { private static final Map < Class < ? extends Element > , Extender > EMPTY_MAP = Collections . emptyMap ( ) ; private static final Collection < Element > EMPTY_LIST = Collections . emptyList ( ) ; private ExtendManager manager ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; manager = new ExtendManager ( ) ; } @ Test public void dontModifyElementWithNoExtender ( ) throws Exception { MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( EMPTY_MAP ) ; ExtendManager manager = new ExtendManager ( extenderEPLoader ) ; Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; manager . extend ( line , EMPTY_LIST , new Point ( 0.0 , 0.0 ) ) ; assertEquals ( line , new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ) ; } @ Test ( expected = NullArgumentException . class ) public void callMockedExtenderForExistentExtender ( ) throws Exception { final Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; final Collection < Element > reference = EMPTY_LIST ; final Point point = new Point ( 0.0 , 0.0 ) ; Extender extenderMockado = new Extender ( ) { public Element extend ( Element element , Collection < Element > references , Point click ) throws NullArgumentException { assertEquals ( line , element ) ; assertEquals ( reference , references ) ; assertEquals ( point , click ) ; throw new NullArgumentException ( ) ; } public Collection < Element > getInfiniteExtensionElements ( Element element ) throws IllegalArgumentException { return null ; } } ; HashMap < Class < ? extends Element > , Extender > extenderMap = new HashMap < Class < ? extends Element > , Extender > ( ) ; extenderMap . put ( Line . class , extenderMockado ) ; MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( extenderMap ) ; ExtendManager manager = new ExtendManager ( extenderEPLoader ) ; manager . extend ( line , reference , point ) ; } @ Test public void testExtensionElementsArc ( ) throws Exception { Arc arc = new Arc ( new Point ( - 1 , 0 ) , new Point ( 0 , 1 ) , new Point ( 1 , 0 ) ) ; Circle circle = new Circle ( new Point ( 0 , 0 ) , 1.0 ) ; Collection < Element > expected = new ArrayList < Element", "gt": "> ( 1 ) ;", "prediction": "> ( ) ;\n", "label": 1}
{"id": 7592, "input": "<s> package org . parboiled . buffers ; import org . parboiled . common . IntArrayStack ; import org . parboiled . support . Chars ; import org . parboiled . support . IndexRange ; import org . parboiled . support . Position ; import java . util . Arrays ; import static org . parboiled . common . Preconditions . checkArgNotNull ; import static org . parboiled . common . Preconditions . checkArgument ; public class DefaultInputBuffer implements InputBuffer { private final int length ; private final char [ ] buffer ; private int [ ] newlines ; public DefaultInputBuffer ( char [ ] buffer ) { checkArgNotNull ( buffer , \"buffer\" ) ; this . buffer = buffer ; this . length = buffer . length ; } public char charAt ( int index ) { return 0 <= index && index < length ? buffer [ index ] : Chars . EOI ; } public boolean test ( int index , char [ ] characters ) { int len = characters . length ; if ( index < 0 || index > length - len ) { return false ; } for ( int i = 0 ; i < len ; i ++ ) { if ( buffer [ index + i ] != characters [ i ] ) return false ; } return true ; } public String extract ( int start , int end ) { if ( start < 0 ) start = 0 ; if ( end >= length ) end = length ; if ( end <= start ) return \"\" ; return new String ( buffer , start , end - start ) ; } public String extract ( IndexRange range ) { return new String ( buffer , range . start , Math . min ( range . end , length ) - range . start ) ; } public Position getPosition ( int index ) { buildNewlines ( ) ; int line = getLine0 ( newlines , index ) ; int column = index - ( line > 0 ? newlines [ line - 1 ] : - 1 ) ; return new Position ( line + 1 , column ) ; } public int", "gt": "getOriginalIndex ( int index )", "prediction": "getLength ( )\n", "label": 0}
{"id": 14649, "input": "<s> package org . restlet . test . ext . jaxrs . services . tests ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import javax . ws . rs . core . Application ; import org . restlet . Response ; import org . restlet . data . Status ; import org . restlet . test . ext . jaxrs . services . resources . QueryParamTestService ; public class QueryParamTest extends JaxRsTestCase { public void checkBothGiven ( String subPath ) throws IOException { Response response = get ( subPath + \"?firstname=Angela&lastname=Merkel\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Angela Merkel\" , response . getEntity ( ) . getText ( ) ) ; response = get ( subPath + \"?lastname=Merkel&firstname=Angela\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Angela Merkel\" , response . getEntity ( ) . getText ( ) ) ; } private void checkMult ( String relPath , String res0 , String res1 , String res2 ) throws IOException { Response response = get ( relPath ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res0 , response . getEntity ( ) . getText ( ) ) ; response = get ( relPath + \"?qp=1\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res1 , response . getEntity ( ) . getText ( ) ) ; response = get ( relPath + \"?qp=1&qp=2\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( res2 , response . getEntity ( ) . getText ( ) ) ; } public void checkOneGiven ( String subPath ) throws IOException { Response response = get ( subPath + \"?firstname=Goofy\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"Goofy null\" , response . getEntity ( ) . getText ( ) ) ; response = get ( subPath + \"?lastname=Goofy\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"null Goofy\" , response . getEntity ( ) . getText ( ) ) ; } @ Override protected Application getApplication ( ) { final Application appConfig = new Application ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public Set < Class < ? > > getClasses ( ) { return ( Set ) Collections . singleton ( QueryParamTestService . class ) ; } } ; return appConfig ; } public void testA ( ) throws IOException { checkBothGiven ( \"a\" ) ; checkOneGiven ( \"a\" ) ; } public void testCheckUnmodifiable ( ) { final Response response = get ( \"checkUnmodifiable\" ) ; assertTrue ( \"The List annotated with @QueryParam must not be modifiable\" , response . getStatus ( ) . isSuccess ( ) ) ; } public void testDecoded ( ) throws IOException { final Response response = get ( \"qpDecoded?firstname=George%20U.&lastname=Bush\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"George U. Bush\" , response . getEntity ( ) . getText ( ) ) ; } public void testEncodedA ( ) throws IOException { final Response response = get ( \"encodedA?firstname=George%20U.&lastname=Bush\" ) ; sysOutEntityIfError ( response ) ; assertEquals ( Status . SUCCESS_OK , response . getStatus ( ) ) ; assertEquals ( \"George%20U. Bush\" , response . getEntity ( ) . getText ( ) ) ; } public void testFieldDecoded ( ) throws Exception { final Response response1 = get ( \"decoded?decoded=abc\" ) ; sysOutEntityIfError ( response1 ) ; assertEquals ( Status . SUCCESS_OK , response1 . getStatus ( ) ) ; assertEquals ( \"abc\" , response1 . getEntity ( ) . getText ( ) ) ; final Response response2 = get ( \"decoded?decoded=%20\" ) ; sysOutEntityIfError ( response2 ) ; assertEquals ( Status . SUCCESS_OK , response2 . getStatus ( ) ) ; assertEquals ( \" \" , response2 . getEntity ( ) . getText ( ) ) ; } public void testFieldEncoded ( ) throws Exception { final Response response1 = get ( \"encoded?encoded=abc\" ) ; sysOutEntityIfError ( response1 ) ; assertEquals ( Status . SUCCESS_OK , response1 . getStatus ( ) ) ; assertEquals ( \"abc\" , response1 . getEntity ( ) . getText ( ) ) ; final Response response2 = get ( \"encoded?encoded=%20\" ) ; sysOutEntityIfError ( response2 ) ; assertEquals ( Status . SUCCESS_OK , response2 . getStatus ( ) ) ; assertEquals ( \"%20\" , response2 . getEntity ( ) . getText ( ) ) ; } public void testInt ( ) throws Exception { final Response response1 = get ( \"int?n1=1&n2=2&n3=3\" ) ; sysOutEntityIfError ( response1 ) ; assertEquals ( Status . SUCCESS_OK , response1 . getStatus ( ) ) ; assertEquals ( \"1 2 3\" , response1 . getEntity ( ) . getText ( ) ) ; final Response response2 = get ( \"int?n1=1&n2=2\" ) ; sysOutEntityIfError ( response2 ) ; assertEquals ( Status . SUCCESS_OK , response2 . getStatus ( ) ) ; assertEquals ( \"1 2 99\" , response2 . getEntity ( ) . getText ( ) ) ; final Response response5 = get ( \"int?n2=2&n3=3\" ) ; sysOutEntityIfError ( response5 ) ; assertEquals ( Status . SUCCESS_OK , response5 . getStatus ( ) ) ; assertEquals ( \"0 2 3\" , response5 . getEntity ( ) . getText ( ) ) ; final Response response4 = get ( \"int?n1=1&n2=2&n3=\" ) ; sysOutEntityIfError ( response4 ) ; assertEquals ( Status . SUCCESS_OK , response4 . getStatus ( ) ) ; assertEquals ( \"1 2 99\" , response4 . getEntity ( ) . getText ( ) ) ; final Response response6 = get ( \"int?n1=1&n3=3\" ) ; assertEquals ( Status . CLIENT_ERROR_NOT_FOUND ,", "gt": "response6 . getStatus ( ) ) ;", "prediction": "response6 . getStatus ( ) ) ;\n", "label": 1}
{"id": 5360, "input": "<s> package org . jjflyboy . tjpeditor . project ;", "gt": "public interface Prolog extends ReportAttribute", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 14674, "input": "<s> package org . apache . lucene . search . vectorhighlight ; import java . util . ArrayList ; import java . util . List ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo ; import org . apache . lucene . search . vectorhighlight . FieldPhraseList . WeightedPhraseInfo . Toffs ; public class FieldFragList { private final int fragCharSize ; List < WeightedFragInfo > fragInfos = new ArrayList < WeightedFragInfo > ( ) ; public FieldFragList ( int fragCharSize ) { this . fragCharSize = fragCharSize ; } public void add ( int startOffset , int endOffset , List < WeightedPhraseInfo > phraseInfoList ) { fragInfos . add ( new WeightedFragInfo ( startOffset , endOffset , phraseInfoList ) ) ; } public static class WeightedFragInfo { List < SubInfo > subInfos ; float totalBoost ; int startOffset ; int endOffset ; public WeightedFragInfo ( int startOffset , int endOffset , List < WeightedPhraseInfo > phraseInfoList ) { this . startOffset = startOffset ; this . endOffset = endOffset ; subInfos = new ArrayList < SubInfo > ( ) ; for ( WeightedPhraseInfo phraseInfo : phraseInfoList ) { SubInfo subInfo = new SubInfo ( phraseInfo . text , phraseInfo . termsOffsets , phraseInfo . seqnum ) ; subInfos . add ( subInfo ) ; totalBoost += phraseInfo . boost ; } } public String toString ( ) { StringBuilder", "gt": "sb = new StringBuilder ( ) ;", "prediction": "sb = new StringBuilder ( ) ;\n", "label": 1}
{"id": 4259, "input": "<s> package org . ofbiz . widget . tree ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . List ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . webapp . control . RequestHandler ; import org . ofbiz . webapp . taglib . ContentUrlTag ; import org . ofbiz . widget . ModelWidget ; import org . ofbiz . widget . WidgetWorker ; import org . ofbiz . widget . screen . ScreenRenderer ; import org . ofbiz . widget . screen . ScreenStringRenderer ; import org . ofbiz . widget . tree . ModelTree ; import org . ofbiz . widget . tree . TreeStringRenderer ; import freemarker . core . Environment ; import freemarker . template . Template ; import freemarker . template . TemplateException ; public class MacroTreeRenderer implements TreeStringRenderer { public static final String module = MacroTreeRenderer . class . getName ( ) ; ScreenStringRenderer screenStringRenderer = null ; private Template macroLibrary ; private Environment environment ; protected boolean widgetCommentsEnabled = false ; public MacroTreeRenderer ( String macroLibraryPath , Appendable writer ) throws TemplateException , IOException { this . macroLibrary = FreeMarkerWorker . getTemplate ( macroLibraryPath ) ; Map < String , Object > input = UtilMisc . toMap ( \"key\" , null ) ; this . environment = FreeMarkerWorker . renderTemplate ( this . macroLibrary , input , writer ) ; } private void executeMacro ( Appendable writer , String macro ) throws IOException { try { Reader templateReader = new StringReader ( macro ) ; Template template = new Template ( ( new java . util . Date ( ) ) . toString ( ) , templateReader , FreeMarkerWorker . getDefaultOfbizConfig ( ) ) ; templateReader . close ( ) ; if ( writer != null ) { Map < String , Object > input = UtilMisc . toMap ( \"key\" , null ) ; Environment tmpEnvironment = FreeMarkerWorker . renderTemplate ( this . macroLibrary , input , writer ) ; tmpEnvironment . include ( template ) ; } else { this . environment . include ( template ) ; } } catch ( TemplateException e ) { Debug . logError ( e , \"Error rendering screen thru ftl\" , module ) ; } catch ( IOException e ) { Debug . logError ( e , \"Error rendering screen thru ftl\" , module ) ; } } private void executeMacro ( String macro ) throws IOException { executeMacro ( null , macro ) ; } public void renderBeginningBoundaryComment ( Appendable writer , String widgetType , ModelWidget modelWidget ) throws IOException { if ( this . widgetCommentsEnabled ) { StringWriter sr = new StringWriter ( ) ; sr . append ( \"<@formatBoundaryComment \" ) ; sr . append ( \" boundaryType=\\\"\" ) ; sr . append ( \"Begin\" ) ; sr . append ( \"\\\" widgetType=\\\"\" ) ; sr . append ( widgetType ) ; sr . append ( \"\\\" widgetName=\\\"\" ) ; sr . append ( modelWidget . getBoundaryCommentName ( ) ) ; sr . append ( \"\\\" />\" ) ; executeMacro ( sr . toString ( ) ) ; } } public void renderEndingBoundaryComment ( Appendable writer , String widgetType , ModelWidget modelWidget ) throws IOException { if", "gt": "( this . widgetCommentsEnabled )", "prediction": "( this . widgetCommentsEnabled )\n", "label": 0}
{"id": 14676, "input": "<s> package tk . blackwolf12333 . grieflog . utils . config ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . bukkit . configuration . InvalidConfigurationException ; import org . bukkit . configuration . file . FileConfiguration ; import org . bukkit . configuration . file . YamlConfiguration ; import org . bukkit . entity . Player ; import tk . blackwolf12333 . grieflog . GriefLog ; public class ConfigHandler { public static GriefLog plugin ; public static File configFile ; public static File friendsFile ; public static FileConfiguration config ; public static FileConfiguration friendsConfig ; public static ConfigValues values ; public ConfigHandler ( GriefLog plugin ) { ConfigHandler . plugin = plugin ; } public static void setupGriefLogConfig ( ) { configFile = new File ( plugin . getDataFolder ( ) , \"config.yml\" ) ; config = new YamlConfiguration ( ) ; if ( ! configFile . exists ( ) ) { configFile . getParentFile ( ) . mkdirs ( ) ; try { configFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } copy ( plugin . getResource ( \"config.yml\" ) , configFile ) ; loadConfig ( ) ; } else { checkForChangesAndLoad ( ) ; } } public static void setupFriendsConfig ( ) { friendsFile = new File ( plugin . getDataFolder ( ) , \"friends.yml\" ) ; friendsConfig = new YamlConfiguration ( ) ; if ( ! friendsFile . exists ( ) ) { friendsFile . getParentFile ( ) . mkdirs ( ) ; copy ( plugin . getResource ( \"friends.yml\" ) , friendsFile ) ; loadFriendsConfig ( ) ; } else { loadFriendsConfig ( ) ; } } private static void copy ( InputStream in , File file ) { try { OutputStream out = new FileOutputStream ( file ) ; byte [ ] buf = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buf ) ) > 0 ) { out . write ( buf , 0 , len ) ; } out . close ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void saveConfig ( ) { try { GriefLog . log . info ( \"Saving configuration file.\" ) ; config . save ( configFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void saveFriendsConfig ( ) { try { friendsConfig . save ( friendsFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static void loadConfig ( ) { try { config . load ( configFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InvalidConfigurationException e ) { } } public static void loadFriendsConfig ( ) { try { friendsConfig . load ( friendsFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void reloadConfig ( ) { loadConfig ( ) ; } public static void reloadFriendsConfig ( ) { loadFriendsConfig ( ) ; } private static void checkForChangesAndLoad ( ) { try { loadConfig ( ) ; Map < String , Object > oldConf = config . getValues ( true ) ; FileConfiguration newconfig = new YamlConfiguration ( ) ; newconfig . load ( plugin . getResource ( \"config.yml\" ) ) ; Map < String , Object > newConf = newconfig . getValues ( true ) ; if ( newConf . size ( ) > oldConf . size ( ) ) { configFile . delete ( ) ; createNewConfigFileAndLoad ( ) ; List < String > contents = readFileAndPutContentsInList ( ) ; for ( Iterator < String > it = oldConf . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String next = it . next ( ) ; String newNode = next + \": \" + oldConf . get ( next ) ; for ( int i = 0 ; i < contents . size ( ) ; i ++ ) { String line = contents . get ( i ) ; if ( line . contains ( next ) ) { contents .", "gt": "set ( i , newNode ) ;", "prediction": "add ( line ) ;\n", "label": 1}
{"id": 3156, "input": "<s> package exceptions ; public class NoUsernameOrPasswordException extends Exception { private static final long serialVersionUID = 3996381168010389844L ;", "gt": "public NoUsernameOrPasswordException ( String message )", "prediction": "public NoUsernameOrPasswordException ( )\n", "label": 0}
{"id": 14677, "input": "<s> package org . eclipse . jface . internal . databinding . swt ; import org . eclipse . jface . databinding . swt . WidgetValueProperty ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Control ; public class ControlForegroundProperty extends WidgetValueProperty { public Object getValueType ( ) { return Color . class ; } protected Object doGetValue ( Object source ) { return ( ( Control ) source ) . getForeground ( ) ; } protected void doSetValue", "gt": "( Object source , Object value )", "prediction": "( Object source )\n", "label": 1}
{"id": 9673, "input": "<s> class CovariantCompat1 { static class A { public A foo ( ) { return this ; } }", "gt": "static class B extends A", "prediction": ";\n", "label": 0}
{"id": 14680, "input": "<s> package org . apache . lucene . store ; public class AlreadyClosedException extends IllegalStateException {", "gt": "public AlreadyClosedException ( String message )", "prediction": "public AlreadyClosedException ( )\n", "label": 1}
{"id": 4583, "input": "<s> package com . caseystella . math ; import org . apache . commons . math . linear . RealVector ; import com . caseystella . interfaces . IDistanceMetric ; public class L2DistanceMetric implements IDistanceMetric { @ Override public double apply ( RealVector v1 , RealVector v2 ) { return", "gt": "v1 . getDistance ( v2 ) ;", "prediction": "apply ( v1 , v2 ) ;\n", "label": 0}
{"id": 14685, "input": "<s> package com . talis . hbase . rdf . examples . benchmarks . lubm ; import org . mindswap . pellet . jena . PelletReasonerFactory ; import com . hp . hpl . jena . ontology . OntModel ; import com . hp . hpl . jena . query . Query ; import com . hp . hpl . jena . query . QueryExecution ; import com . hp . hpl . jena . query . QueryExecutionFactory ; import com . hp . hpl . jena . query . QueryFactory ; import com . hp . hpl . jena . query . ResultSet ; import com . hp . hpl . jena . rdf . model . Model ; import com . hp . hpl . jena . rdf . model . ModelFactory ; import com . talis . hbase . rdf . HBaseRdfFactory ; import com . talis . hbase . rdf . Store ; public class LubmQ4 { public static void main ( String [ ] args ) { Store store = HBaseRdfFactory . connectStore ( args [ 0 ] ) ; Model schema = HBaseRdfFactory . connectNamedModel ( store , \"http://cs.utdallas.edu/hbase-rdf/bm#LUBM\" ) ; try { long count = 0L ; OntModel m = ModelFactory . createOntologyModel ( PelletReasonerFactory . THE_SPEC , schema ) ; String queryString = \" PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> \" + \" PREFIX ub: <http://www.lehigh.edu/~zhp2/2004/0401/univ-bench.owl#> \" + \" SELECT ?X ?Y1 ?Y2 ?Y3 \" + \" WHERE \" + \" { \" + \"\t\t?X rdf:type ub:Professor . \" + \"\t\t?X ub:worksFor <http://www.Department0.University0.edu> . \" + \"\t\t?X ub:name ?Y1 . \" + \"\t\t?X ub:emailAddress ?Y2 . \" + \"\t\t?X ub:telephone ?Y3 \" + \" } \" ; Query query", "gt": "= QueryFactory . create ( queryString ) ;", "prediction": "= null ;\n", "label": 1}
{"id": 4811, "input": "<s> package pkg1 ; public class SubClass extends BaseClass { public void publicMethod ( ) { } public void packagePrivateMethod ( ) { }", "gt": "public void privateMethod ( )", "prediction": "}\n", "label": 0}
{"id": 14687, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . BranchConstraint ; import org . fuzzydb . attrs . util . Point2D ; import org . fuzzydb . attrs . util . Range2D ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; public abstract class Point2DRangeConstraint extends BranchConstraint implements IRange2D { private Range2D range2d ; public Point2D getMax ( ) { return range2d . getMax ( ) ; } public Point2D getMin ( ) { return range2d . getMin ( ) ; } public Point2DRangeConstraint ( int attrId , Point2D min , Point2D max ) { super ( attrId ) ; range2d = new Range2D ( min , max ) ; } public boolean contains ( Point2D point ) { return range2d . contains ( point ) ; } @ Override public boolean consistent ( IAttribute val ) { if ( val == null ) { return isIncludesNotSpecified ( ) ; } return range2d . contains ( ( ( Value2D )", "gt": "val ) . getValue ( ) ) ;", "prediction": "val ) ) ;\n", "label": 1}
{"id": 9512, "input": "<s> package overrideNo ; abstract class A { } class B extends A { @", "gt": "Override void f ( )", "prediction": "Override public void setUp ( ) throws Exception\n", "label": 0}
{"id": 14690, "input": "<s> package com . google . code . microlog4android . config ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Properties ; import java . util . StringTokenizer ; import android . content . Context ; import android . content . res . AssetManager ; import android . content . res . Resources ; import android . content . res . Resources . NotFoundException ; import android . util . Log ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . appender . Appender ; import com . google . code . microlog4android . format . Formatter ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; import com . google . code . microlog4android . repository . LoggerRepository ; public class PropertyConfigurator { private static final String TAG = \"Microlog.PropertyConfiguration\" ; public static String DEFAULT_PROPERTIES_FILENAME = \"microlog.properties\" ; public static final String ROOT_LOGGER_KEY = \"microlog.rootLogger\" ; public static final String MICROLOG_PREFIX = \"microlog\" ; public static final String LOGGER_PREFIX_KEY = \"microlog.logger\" ; public static final String FORMATTER_PREFIX_KEY = \"microlog.formatter\" ; public static final String PATTERN_LAYOUT_PREFIX_KEY = \"microlog.formatter.PatternFormatter.pattern\" ; public static final String APPENDER_PREFIX_KEY = \"microlog.appender\" ; public static final String FILE_APPENDER_FILE_NAME_KEY = \"microlog.appender.FileAppender.File\" ; public static final String FILE_APPENDER_APPEND_KEY = \"microlog.appender.FileAppender.Append\" ; public static final String LOG_LEVEL_PREFIX_KEY = \"microlog.level\" ; public static final String TAG_PREFIX_KEY = \"microlog.tag\" ; public static final String [ ] APPENDER_ALIASES = { \"LogCatAppender\" , \"FileAppender\" } ; public static final String [ ] APPENDER_CLASS_NAMES = { \"com.google.code.microlog4android.appender.LogCatAppender\" , \"com.google.code.microlog4android.appender.FileAppender\" } ; public static final String [ ] FORMATTER_ALIASES = { \"SimpleFormatter\" , \"PatternFormatter\" } ; public static final String [ ] FORMATTER_CLASS_NAMES = { \"com.google.code.microlog4android.format.SimpleFormatter\" , \"com.google.code.microlog4android.format.PatternFormatter\" } ; private static final HashMap < String , String > appenderAliases = new HashMap < String , String > ( 43 ) ; private static final HashMap < String , String > formatterAliases = new HashMap < String , String > ( 21 ) ; private Context context ; private LoggerRepository loggerRepository ; { for ( int index = 0 ; index < APPENDER_ALIASES . length ; index ++ ) { appenderAliases . put ( APPENDER_ALIASES [ index ] , APPENDER_CLASS_NAMES [ index ] ) ; } for ( int index = 0 ; index < FORMATTER_ALIASES . length ; index ++ ) { formatterAliases . put ( FORMATTER_ALIASES [ index ] , FORMATTER_CLASS_NAMES [ index ] ) ; } } ; private PropertyConfigurator ( Context context ) { this . context = context ; loggerRepository = DefaultLoggerRepository . INSTANCE ; } public static PropertyConfigurator getConfigurator ( Context context ) { if ( context == null ) { throw new IllegalArgumentException ( \"The context must not be null\" ) ; } return new PropertyConfigurator ( context ) ; } public void configure ( ) { configure ( DEFAULT_PROPERTIES_FILENAME ) ; } public void configure ( String filename ) { Resources resources = context . getResources ( ) ; AssetManager assetManager = resources . getAssets ( ) ; try { InputStream inputStream = assetManager . open ( filename ) ; Properties properties = loadProperties ( inputStream ) ; startConfiguration ( properties ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to open the microlog properties file. Hint: the file should be in the /assets directory \" + filename + \" \" + e ) ; } } public void configure ( int resId ) { Resources resources = context . getResources ( ) ; try { InputStream rawResource = resources . openRawResource ( resId ) ; Properties properties = loadProperties ( rawResource ) ; startConfiguration ( properties ) ; } catch ( NotFoundException e ) { Log . e ( TAG , \"Did not find the microlog properties resource. Hint: this should be in the /res/raw directory \" + e ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to read the microlog properties resource.\" + e ) ; } } private Properties loadProperties ( InputStream inputStream ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( inputStream ) ; return properties ; } private void startConfiguration ( Properties properties ) { if ( properties . containsKey ( PropertyConfigurator . ROOT_LOGGER_KEY ) ) { Log . i ( TAG , \"Modern configuration not yet supported\" ) ; } else { Log . i ( TAG , \"Configure using the simple style (aka classic style)\" ) ; configureSimpleStyle ( properties ) ; } } private void configureSimpleStyle ( Properties properties ) { setLevel ( properties ) ; String appenderString = properties . getProperty ( PropertyConfigurator . APPENDER_PREFIX_KEY , \"LogCatAppender\" ) ; List < String > appenderList = parseAppenderString ( appenderString ) ; setAppenders ( appenderList , properties ) ; setFormatter ( properties ) ; } private void setLevel ( Properties properties ) { String levelString = ( String ) properties . get ( PropertyConfigurator . LOG_LEVEL_PREFIX_KEY ) ; Level level = stringToLevel ( levelString ) ; if ( level != null ) { loggerRepository . getRootLogger ( ) . setLevel ( level ) ; Log . i ( TAG , \"Root level: \" + loggerRepository . getRootLogger ( ) . getLevel ( ) ) ; } } private List < String > parseAppenderString ( String appenderString ) { StringTokenizer tokenizer = new StringTokenizer ( appenderString , \";,\" ) ; List < String > appenderList = new ArrayList < String > ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String appender = ( String ) tokenizer . nextElement ( ) ; appenderList . add ( appender ) ; } return appenderList ; } private void setAppenders ( List < String > appenderList , Properties properties ) { for ( String string : appenderList ) { addAppender ( string , properties ) ; } } private void addAppender ( String string , Properties properties ) { Logger rootLogger = loggerRepository . getRootLogger ( ) ; String className = appenderAliases . get ( string ) ; if ( className == null ) { className = string ; } try { Class appenderClass = Class . forName ( className ) ; Appender appender = ( Appender ) appenderClass . newInstance ( ) ; if ( appender != null ) { if ( appender instanceof FileAppender ) setPropertiesForFileAppender ( appender , properties ) ; Log . i ( TAG , \"Adding appender \" + appender . getClass ( ) . getName ( ) ) ; rootLogger . addAppender ( appender ) ; } } catch ( ClassNotFoundException e ) { Log . e ( TAG , \"Failed", "gt": "to find appender class: \" + e ) ;", "prediction": "to add appender \" + appender . getClass ( ) . getName ( ) ) ;\n", "label": 1}
{"id": 5753, "input": "<s> package org . msl . simple . gmf . bridge . transform ; import org . eclipse . emf . common . util . Diagnostic ; class GMFGenModelDiagnosticPage extends ModelDiagnosticPage { GMFGenModelDiagnosticPage ( String pageName ) { super ( pageName ) ; setTitle ( Messages . TransformToGenModelWizard_title_gmfgendiagnostic ) ; setDescription ( Messages . TransformToGenModelWizard_descr_gmfgendiagnostic ) ; } @ Override protected boolean getIgnoreOption ( ) { return getOperation ( ) . getOptions ( ) . getIgnoreGMFGenValidation ( ) ; } @ Override protected Diagnostic getValidationResult ( ) { return getOperation ( ) . getGMFGenValidationResult ( ) ; } @ Override protected void setIgnoreOption ( boolean ignore ) { getOperation (", "gt": ") . getOptions ( ) . setIgnoreGMFGenValidation ( ignore ) ;", "prediction": ") . setIgnore ( ignore ) ;\n", "label": 0}
{"id": 14693, "input": "<s> package com . hoccer . api . android ; import java . io . IOException ; import java . util . List ; import org . apache . http . client . ClientProtocolException ; import android . content . Context ; import android . location . Address ; import android . location . Geocoder ; import android . location . Location ; import android . location . LocationListener ; import android . location . LocationManager ; import android . net . wifi . WifiManager ; import android . os . Bundle ; import android . util . Log ; import com . hoccer . api . UpdateException ; public class LinccLocationManager implements LocationListener { private static final String UNKNOWN_LOCATION_TEXT = \"You can not hoc without a location\" ; private final LocationManager mLocationManager ; private final WifiManager mWifiManager ; private final Context mContext ; private final AsyncLinccer mLinccer ; private final Updateable mUpdater ; private final boolean mNetworkProviderAvailable ; public LinccLocationManager ( Context pContext , AsyncLinccer linccer , Updateable updater ) { mContext = pContext ; mLinccer = linccer ; mUpdater = updater ; mLocationManager = ( LocationManager ) pContext . getSystemService ( Context . LOCATION_SERVICE ) ; mWifiManager = ( WifiManager ) pContext . getSystemService ( Context . WIFI_SERVICE ) ; mNetworkProviderAvailable = mLocationManager . getAllProviders ( ) . contains ( LocationManager . NETWORK_PROVIDER ) ; } public Context getContext ( ) { return mContext ; } public AsyncLinccer getLinccer ( ) { return mLinccer ; } public void refreshLocation ( ) throws UpdateException , ClientProtocolException , IOException { mLinccer . autoSubmitEnvironmentChanges ( false ) ; mLinccer . onWifiScanResults ( mWifiManager . getScanResults ( ) ) ; Location location ; if ( mNetworkProviderAvailable ) { location = mLocationManager . getLastKnownLocation ( LocationManager . NETWORK_PROVIDER ) ; if ( location != null ) mLinccer . onNetworkChanged ( location ) ; } location = mLocationManager . getLastKnownLocation ( LocationManager . GPS_PROVIDER ) ; if ( location != null ) mLinccer . onGpsChanged ( location ) ; mLinccer . submitEnvironment ( ) ; } public void deactivate ( ) { mLocationManager . removeUpdates ( this ) ; } public void activate ( ) { mLocationManager . requestLocationUpdates ( LocationManager . GPS_PROVIDER , 1000 , 1 , this ) ; if ( mNetworkProviderAvailable ) { mLocationManager . requestLocationUpdates ( LocationManager . NETWORK_PROVIDER , 1000 , 1 , this ) ; } } @ Override public void onLocationChanged ( Location location ) { Log . v ( \"LinccLocationManager\" , location . toString ( ) ) ; if ( mUpdater != null ) { mUpdater . updateNow ( ) ; } } @ Override public void onProviderDisabled ( String provider ) { } @ Override public void onProviderEnabled ( String provider ) { } @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { } public Address getAddress ( Location location ) throws IOException { if ( location == null ) { return new Address ( null ) ; } Geocoder gc = new Geocoder ( mContext ) ; Address address = null ; List < Address > addresses = gc . getFromLocation ( location . getLatitude ( ) , location . getLongitude ( ) , 1 ) ; if ( addresses . size ( ) > 0 ) { address = addresses", "gt": ". get ( 0 ) ;", "prediction": ". get ( 0 ) ;\n", "label": 1}
{"id": 7232, "input": "<s> package com . sun . tools . apt . mirror . type ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . TypeVisitor ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . javac . code . Type ; @ SuppressWarnings ( \"deprecation\" ) public class EnumTypeImpl extends ClassTypeImpl implements EnumType { EnumTypeImpl ( AptEnv env , Type . ClassType type ) { super ( env , type ) ; } public EnumDeclaration getDeclaration ( ) { return ( EnumDeclaration", "gt": ") super . getDeclaration ( ) ;", "prediction": ") env ;\n", "label": 0}
{"id": 14698, "input": "<s> package org . nuxeo . ecm . automation . client ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class AdapterManager { protected Map < Class < ? > , List < AdapterFactory < ? > > > adapters ; @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Object objToAdapt , Class < T > adapterType ) { Class < ? > cls = objToAdapt . getClass ( ) ; List < AdapterFactory < ? > > factories = adapters . get ( adapterType ) ; if ( factories != null ) { for ( AdapterFactory < ? > f : factories ) { if ( f . getAcceptType ( ) . isAssignableFrom ( cls ) ) { return ( T )", "gt": "f . getAdapter ( objToAdapt ) ;", "prediction": "f ;\n", "label": 1}
{"id": 6969, "input": "<s> package com . sun . tools . doclets . formats . html ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . builders . SerializedFormBuilder ; import com . sun . tools . doclets . internal . toolkit . taglets . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class TagletWriterImpl extends TagletWriter { private HtmlDocletWriter htmlWriter ; public TagletWriterImpl ( HtmlDocletWriter htmlWriter , boolean isFirstSentence ) { this . htmlWriter = htmlWriter ; this . isFirstSentence = isFirstSentence ; } public TagletOutput getOutputInstance ( ) { return new TagletOutputImpl ( \"\" ) ; } public TagletOutput getDocRootOutput ( ) { if ( htmlWriter . configuration . docrootparent . length ( ) > 0 ) return new TagletOutputImpl ( htmlWriter . configuration . docrootparent ) ; else return new TagletOutputImpl ( htmlWriter . relativepathNoSlash ) ; } public TagletOutput deprecatedTagOutput ( Doc doc ) { StringBuffer output = new StringBuffer ( ) ; Tag [ ] deprs = doc . tags ( \"deprecated\" ) ; if ( doc instanceof ClassDoc ) { if ( Util . isDeprecated ( ( ProgramElementDoc ) doc ) ) { output . append ( \"<span class=\\\"strong\\\">\" + ConfigurationImpl . getInstance ( ) . getText ( \"doclet.Deprecated\" ) + \"</span>&nbsp;\" ) ; if ( deprs . length > 0 ) { Tag [ ] commentTags = deprs [ 0 ] . inlineTags ( ) ; if ( commentTags . length > 0 ) { output . append ( commentTagsToOutput ( null , doc , deprs [ 0 ] . inlineTags ( ) , false ) . toString ( ) ) ; } } } } else { MemberDoc member = ( MemberDoc ) doc ; if ( Util . isDeprecated ( ( ProgramElementDoc ) doc ) ) { output . append ( \"<span class=\\\"strong\\\">\" + ConfigurationImpl . getInstance ( ) . getText ( \"doclet.Deprecated\" ) + \"</span>&nbsp;\" ) ; if ( deprs . length > 0 ) { output . append ( \"<i>\" ) ; output . append ( commentTagsToOutput ( null , doc , deprs [ 0 ] . inlineTags ( ) , false ) . toString ( ) ) ; output . append ( \"</i>\" ) ; } } else { if ( Util . isDeprecated ( member", "gt": ". containingClass ( ) ) )", "prediction": ") )\n", "label": 0}
{"id": 14699, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . core . runtime . Assert ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . swt . widgets . Widget ; public class TableViewer extends AbstractTableViewer { private Table table ; private TableViewerRow cachedRow ; public TableViewer ( Composite parent ) { this ( parent , SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; } public TableViewer ( Composite parent , int style ) { this ( new Table ( parent , style ) ) ; } public TableViewer ( Table table ) { this . table = table ; hookControl ( table ) ; } public Control getControl ( ) { return table ; } public Table getTable ( ) { return table ; } protected ColumnViewerEditor createViewerEditor ( ) { return new TableViewerEditor ( this , null , new ColumnViewerEditorActivationStrategy ( this ) , ColumnViewerEditor . DEFAULT ) ; } public void setSelection ( ISelection selection , boolean reveal ) { super . setSelection ( selection , reveal ) ; } protected ViewerRow getViewerRowFromItem ( Widget item ) { if ( cachedRow == null ) { cachedRow = new TableViewerRow ( ( TableItem ) item ) ; } else { cachedRow . setItem ( ( TableItem ) item ) ; } return cachedRow ; } protected ViewerRow internalCreateNewRowPart ( int style , int rowIndex ) { TableItem item ; if ( rowIndex >= 0 ) { item = new TableItem ( table , style , rowIndex ) ; } else { item = new TableItem ( table , style ) ; } return getViewerRowFromItem ( item ) ; } protected Item getItemAt ( Point p ) { TableItem [ ] selection = table . getSelection ( ) ; if ( selection . length == 1 ) { int columnCount = table . getColumnCount ( ) ; for ( int i = 0 ; i < columnCount ; i ++ ) { if ( selection [ 0 ] . getBounds ( i ) . contains ( p ) ) { return selection [ 0 ] ; } } } return table . getItem ( p ) ; } protected int doGetItemCount ( ) { return table . getItemCount ( ) ; } protected int doIndexOf ( Item item ) { return table . indexOf ( ( TableItem ) item ) ; } protected void doSetItemCount ( int count ) { table . setItemCount ( count ) ; }", "gt": "protected Item [ ] doGetItems ( )", "prediction": "}\n", "label": 1}
{"id": 3638, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface RollupResource extends ReportAttribute , IcalReportAttribute , ExportAttribute {", "gt": "LogicalExpression getExpression ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14704, "input": "<s> package org . nuxeo . ecm . platform . comment . api ; public final class CommentEvents { public static final String COMMENT_ADDED = \"commentAdded\" ; public", "gt": "static final String COMMENT_REMOVED = \"commentRemoved\" ;", "prediction": "static final String COMMENT_CLOSE = \"commentCLOSE\" ;\n", "label": 1}
{"id": 3765, "input": "<s> import java . util . List ; class T6985719a { interface A { void f ( List < String > ls ) ; } interface B { void f ( List <", "gt": "Integer > ls ) ;", "prediction": "String > lsb ) ;\n", "label": 0}
{"id": 14714, "input": "<s> package io . beancounter . commons . tagdef ; public class TagDefException extends Exception { public TagDefException ( String", "gt": "message , Exception e )", "prediction": "message )\n", "label": 1}
{"id": 6001, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Limit extends DailyMax , DailyMin , Maximum , Minimum , MonthlyMax , MonthlyMin , WeeklyMax , WeeklyMin { DurationQuantity getDuration ( ) ; void", "gt": "setDuration ( DurationQuantity value ) ;", "prediction": "setDuration ( ) ;\n", "label": 0}
{"id": 14718, "input": "<s> package org . elasticsearch . memcached . netty ; import org . elasticsearch . ElasticSearchException ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . netty . OpenChannelsHandler ; import org . elasticsearch . common . netty . bootstrap . ServerBootstrap ; import org . elasticsearch . common . netty . channel . Channel ; import org . elasticsearch . common . netty . channel . ChannelPipeline ; import org . elasticsearch . common . netty . channel . ChannelPipelineFactory ; import org . elasticsearch . common . netty . channel . Channels ; import org . elasticsearch . common . netty . channel . socket . nio . NioServerSocketChannelFactory ; import org . elasticsearch . common . netty . channel . socket . oio . OioServerSocketChannelFactory ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . PortsRange ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . http . BindHttpException ; import org . elasticsearch . memcached . MemcachedServerTransport ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . transport . BindTransportException ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . * ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; public class NettyMemcachedServerTransport extends AbstractLifecycleComponent < MemcachedServerTransport > implements MemcachedServerTransport { private final RestController restController ; private final NetworkService networkService ; private final int workerCount ; private final boolean blockingServer ; private final String port ; private final String bindHost ; private final String publishHost ; private final Boolean tcpNoDelay ; private final Boolean tcpKeepAlive ; private final Boolean reuseAddress ; private final ByteSizeValue tcpSendBufferSize ; private final ByteSizeValue tcpReceiveBufferSize ; private volatile ServerBootstrap serverBootstrap ; private volatile BoundTransportAddress boundAddress ; private volatile Channel serverChannel ; private volatile OpenChannelsHandler serverOpenChannels ; @ Inject public NettyMemcachedServerTransport ( Settings settings , RestController restController , NetworkService networkService ) { super ( settings ) ; this . restController = restController ; this . networkService = networkService ; this . workerCount = componentSettings . getAsInt ( \"worker_count\" , Runtime . getRuntime ( ) . availableProcessors ( ) * 2 ) ; this . blockingServer = componentSettings . getAsBoolean ( \"memcached.blocking_server\" , settings . getAsBoolean ( TCP_BLOCKING_SERVER , settings . getAsBoolean ( TCP_BLOCKING , false ) ) ) ; this . port = componentSettings . get ( \"port\" , settings . get ( \"memcached.port\" , \"11211-11311\" ) ) ; this . bindHost = componentSettings . get ( \"bind_host\" ) ; this . publishHost = componentSettings . get ( \"publish_host\" ) ; this . tcpNoDelay = componentSettings . getAsBoolean ( \"tcp_no_delay\" , settings . getAsBoolean ( TCP_NO_DELAY , true ) ) ; this . tcpKeepAlive = componentSettings . getAsBoolean ( \"tcp_keep_alive\" , settings . getAsBoolean ( TCP_KEEP_ALIVE , true ) ) ; this . reuseAddress = componentSettings . getAsBoolean ( \"reuse_address\" , settings . getAsBoolean ( TCP_REUSE_ADDRESS , NetworkUtils . defaultReuseAddress ( ) ) ) ; this . tcpSendBufferSize = componentSettings . getAsBytesSize ( \"tcp_send_buffer_size\" , settings . getAsBytesSize ( TCP_SEND_BUFFER_SIZE , TCP_DEFAULT_SEND_BUFFER_SIZE ) ) ; this . tcpReceiveBufferSize = componentSettings . getAsBytesSize ( \"tcp_receive_buffer_size\" , settings . getAsBytesSize ( TCP_RECEIVE_BUFFER_SIZE , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ) ; } @ Override public BoundTransportAddress boundAddress ( ) { return boundAddress ; } @ Override protected void doStart ( ) throws ElasticSearchException { this . serverOpenChannels = new OpenChannelsHandler ( logger ) ; if ( blockingServer ) { serverBootstrap = new ServerBootstrap ( new OioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_boss\" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_worker\" ) ) ) ) ; } else { serverBootstrap = new ServerBootstrap ( new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_boss\" ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , \"memcached_server_worker\" ) ) , workerCount ) ) ; } ChannelPipelineFactory pipelineFactory = new ChannelPipelineFactory ( ) { @ Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline pipeline = Channels . pipeline ( ) ; pipeline . addLast ( \"openChannels\" , serverOpenChannels ) ; pipeline . addLast ( \"decoder\" , new MemcachedDecoder ( logger ) ) ; pipeline . addLast ( \"dispatcher\" , new MemcachedDispatcher ( restController ) ) ; return pipeline ; } } ; serverBootstrap . setPipelineFactory ( pipelineFactory ) ; if ( tcpNoDelay != null ) { serverBootstrap . setOption ( \"child.tcpNoDelay\" , tcpNoDelay ) ; } if ( tcpKeepAlive != null ) { serverBootstrap . setOption ( \"child.keepAlive\" , tcpKeepAlive ) ; } if ( tcpSendBufferSize != null ) { serverBootstrap . setOption ( \"child.sendBufferSize\" , tcpSendBufferSize . bytes ( ) ) ; } if ( tcpReceiveBufferSize != null ) { serverBootstrap . setOption ( \"child.receiveBufferSize\" , tcpReceiveBufferSize . bytes ( ) ) ; } if ( reuseAddress != null ) { serverBootstrap . setOption ( \"reuseAddress\" , reuseAddress ) ; serverBootstrap . setOption ( \"child.reuseAddress\" , reuseAddress ) ; } InetAddress hostAddressX ; try { hostAddressX = networkService . resolveBindHostAddress ( bindHost ) ; } catch ( IOException e ) { throw new BindHttpException ( \"Failed to resolve host [\" + bindHost + \"]\" , e ) ; } final InetAddress hostAddress = hostAddressX ; PortsRange portsRange = new PortsRange ( port ) ; final AtomicReference < Exception > lastException = new AtomicReference < Exception > ( ) ; boolean success = portsRange . iterate ( new PortsRange . PortCallback ( ) { @ Override public boolean onPortNumber ( int portNumber ) { try { serverChannel = serverBootstrap . bind ( new InetSocketAddress ( hostAddress , portNumber ) ) ; } catch ( Exception e ) { lastException . set ( e ) ; return false ; } return true ; } } ) ; if ( ! success ) { throw new BindHttpException ( \"Failed to bind to [\" + port + \"]\" , lastException .", "gt": "get ( ) ) ;", "prediction": "toString ( ) ) ;\n", "label": 1}
{"id": 6995, "input": "<s> package p1 ; public class A1 < T > { int", "gt": "f ( T t )", "prediction": "i ;\n", "label": 0}
{"id": 14723, "input": "<s> package com . emf4sw . owl . resource ; abstract public interface OWLWriter { Object write ( OWLResource", "gt": "resource , OWLFormats format ) ;", "prediction": "resource ) ;\n", "label": 1}
{"id": 1752, "input": "<s> package org . ofbiz . product . config ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceContainer ; @ SuppressWarnings ( \"serial\" ) public class ProductConfigItemContentWrapper implements java . io . Serializable { public static final String module = ProductConfigItemContentWrapper . class . getName ( ) ; protected transient LocalDispatcher dispatcher ; protected String dispatcherName ; protected transient Delegator delegator ; protected String delegatorName ; protected GenericValue productConfigItem ; protected Locale locale ; protected String mimeTypeId ; public static ProductConfigItemContentWrapper makeProductConfigItemContentWrapper ( GenericValue productConfigItem , HttpServletRequest request ) { return new ProductConfigItemContentWrapper ( productConfigItem , request ) ; } public ProductConfigItemContentWrapper ( LocalDispatcher dispatcher , GenericValue productConfigItem , Locale locale , String mimeTypeId ) { this . dispatcher = dispatcher ; this . dispatcherName = dispatcher . getName ( ) ; this . delegator = productConfigItem . getDelegator ( ) ; this . delegatorName = delegator . getDelegatorName ( ) ; this . productConfigItem = productConfigItem ; this . locale = locale ; this . mimeTypeId = mimeTypeId ; } public ProductConfigItemContentWrapper ( GenericValue productConfigItem , HttpServletRequest request ) { this . dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; this . dispatcherName = dispatcher . getName ( ) ; this . delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; this . delegatorName = delegator . getDelegatorName ( ) ; this . productConfigItem = productConfigItem ; this . locale = UtilHttp . getLocale ( request ) ; this . mimeTypeId = \"text/html\" ; } public String get ( String confItemContentTypeId ) { return getProductConfigItemContentAsText ( productConfigItem , confItemContentTypeId , locale , mimeTypeId , getDelegator ( ) , getDispatcher ( ) ) ; } public Delegator getDelegator ( ) { if ( delegator == null ) { delegator = DelegatorFactory . getDelegator ( delegatorName ) ; } return delegator ; } public LocalDispatcher getDispatcher ( ) { if ( dispatcher == null ) { dispatcher = ServiceContainer . getLocalDispatcher ( dispatcherName , this . getDelegator ( ) ) ; } return dispatcher ; } public static String getProductConfigItemContentAsText ( GenericValue productConfigItem , String confItemContentTypeId , HttpServletRequest request ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; return getProductConfigItemContentAsText ( productConfigItem , confItemContentTypeId , UtilHttp . getLocale ( request ) , \"text/html\" , productConfigItem . getDelegator ( ) , dispatcher ) ; } public static String getProductConfigItemContentAsText ( GenericValue productConfigItem , String confItemContentTypeId , Locale locale , LocalDispatcher dispatcher ) { return getProductConfigItemContentAsText ( productConfigItem , confItemContentTypeId , locale , null , null , dispatcher ) ; } public static String getProductConfigItemContentAsText ( GenericValue productConfigItem , String confItemContentTypeId , Locale locale , String mimeTypeId , Delegator delegator , LocalDispatcher dispatcher ) { String candidateFieldName = ModelUtil . dbNameToVarName ( confItemContentTypeId ) ; try { Writer outWriter = new StringWriter ( ) ; getProductConfigItemContentAsText ( null , productConfigItem , confItemContentTypeId , locale , mimeTypeId , delegator , dispatcher , outWriter ) ; String outString = outWriter . toString ( ) ; if ( outString . length ( ) > 0 ) { return outString ; } else { return null ; } } catch ( GeneralException e ) { Debug . logError ( e , \"Error rendering ProdConfItemContent, inserting empty String\" , module ) ;", "gt": "return productConfigItem . getString ( candidateFieldName ) ;", "prediction": "}\n", "label": 0}
{"id": 14724, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . Collection ; import java . util . HashSet ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; public class PreferenceNodeFilter extends ViewerFilter { Collection ids = new HashSet ( ) ; public PreferenceNodeFilter ( String [ ] filteredIds ) { super ( ) ; for ( int i = 0 ; i < filteredIds . length ; i ++ ) { ids . add ( filteredIds [ i ] ) ; } } public boolean select ( Viewer viewer , Object parentElement , Object element ) {", "gt": "return checkNodeAndChildren ( ( IPreferenceNode ) element ) ;", "prediction": "return true ;\n", "label": 1}
{"id": 3371, "input": "<s> class VarMightAlreadyBeAssigned { void m ( boolean b ) { final int i ;", "gt": "if ( b ) i = 3 ;", "prediction": "}\n", "label": 0}
{"id": 14727, "input": "<s> package org . eclipse . ui . tests . menus ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . ui . menus . ExtensionContributionFactory ; import org . eclipse . ui . menus . IContributionRoot ; import org . eclipse . ui . services . IServiceLocator ; public class DeclaredProgrammaticFactory extends ExtensionContributionFactory { public DeclaredProgrammaticFactory ( ) { super ( ) ; } static class MyItem extends ActionContributionItem { public MyItem ( ) { super ( new Action ( \"MyItem\" ) { public String getId ( ) { return \"myitem\" ; } } ) ; } } public void createContributionItems ( IServiceLocator serviceLocator , IContributionRoot additions ) { additions", "gt": ". addContributionItem ( new MyItem ( ) , null ) ;", "prediction": ". add ( MyItem ) ;\n", "label": 1}
{"id": 2459, "input": "<s> package org . ofbiz . webapp . view ; public abstract class AbstractViewHandler implements ViewHandler { protected String name = null ; public String getName ( ) { return name ; } public void setName ( String name ) {", "gt": "this . name = name ;", "prediction": "this . name = name ;\n", "label": 0}
{"id": 14728, "input": "<s> package com . cloudera . sqoop . lib ; public interface FieldMappable", "gt": "extends org . apache . sqoop . lib . FieldMappable", "prediction": "\n", "label": 1}
{"id": 2825, "input": "<s> package com . redhat . ceylon . compiler . java . loader . model ; import java . util . List ; import com . redhat . ceylon . compiler . java . loader . CeylonEnter ; import com . redhat . ceylon . compiler . java . loader . CeylonModelLoader ; import com . redhat . ceylon . compiler . loader . AbstractModelLoader ; import com . redhat . ceylon . compiler . loader . model . LazyModuleManager ; import com . redhat . ceylon . compiler . typechecker . context . Context ; import com . redhat . ceylon . compiler . typechecker . model . Module ; public class CompilerModuleManager extends LazyModuleManager { private com . sun . tools . javac . util . Context context ; private CeylonEnter ceylonEnter ; private AbstractModelLoader modelLoader ; public CompilerModuleManager ( Context ceylonContext , com . sun . tools . javac . util . Context context ) { super ( ceylonContext ) ; this . context = context ; } @ Override protected Module createModule ( List < String > moduleName , String version ) { CompilerModule module = new CompilerModule ( context ) ; module . setName ( moduleName ) ; module . setVersion ( version ) ; setupIfJDKModule ( module ) ; return module ; } private void setupIfJDKModule ( CompilerModule module ) { String nameAsString = module . getNameAsString ( ) ; String version = module . getVersion ( ) ; if ( version != null && version . equals ( AbstractModelLoader . JDK_MODULE_VERSION ) && AbstractModelLoader . isJDKModule ( nameAsString ) ) { module . setAvailable ( true ) ; module . setJava ( true ) ; } } public CeylonEnter getCeylonEnter ( ) { if ( ceylonEnter == null ) { ceylonEnter", "gt": "= CeylonEnter . instance ( context ) ;", "prediction": "= null ;\n", "label": 0}
{"id": 14734, "input": "<s> package org . eclipse . rap . rwt . internal . client ; import javax . servlet . http . HttpServletRequest ; import org . eclipse . rap . rwt . client . Client ; public interface ClientProvider { boolean accept", "gt": "( HttpServletRequest request ) ;", "prediction": ";\n", "label": 1}
{"id": 2454, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NSECRecord extends Record { private static final long serialVersionUID = - 5165065768816265385L ; private Name next ; private TypeBitmap types ; NSECRecord ( ) { } Record getObject ( ) { return new NSECRecord ( ) ; } public NSECRecord ( Name name , int dclass , long ttl , Name next , int [ ] types ) { super ( name , Type . NSEC , dclass , ttl ) ; this . next = checkName ( \"next\" , next ) ; for ( int i = 0 ; i < types . length ; i ++ ) { Type . check ( types [ i ] ) ; } this . types = new TypeBitmap ( types ) ; } void rrFromWire ( DNSInput in ) throws IOException { next = new Name ( in ) ; types = new TypeBitmap ( in ) ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) { next . toWire ( out , null , false ) ; types . toWire ( out ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { next = st . getName ( origin ) ; types = new TypeBitmap ( st ) ; } String rrToString ( ) { StringBuilder sb =", "gt": "new StringBuilder ( ) ;", "prediction": "new StringBuilder ( ) ;\n", "label": 0}
{"id": 14736, "input": "<s> package nehsics . test ; import nehsics . world . * ; import nehsics . ui . * ; import nehsics . force . * ; import nehsics . bodies . * ; import java . awt . * ; import static nehsics . math . Util . * ; import java . util . * ; public class TestOneD extends UserControlledScene { public final static String NAME = \"Rotating Triangle\" ; private Bonder bonder ; public static void main ( String [ ] args ) { new Starter ( \"nehsics.test.TestOneD\" ) ; } public TestOneD ( Canvas c ) { super ( c ) ; } protected void setup ( ) { FieldManager f = new FieldManager ( ) ; Walls walls = new Walls ( 250 , .9 ) ; world . addListener ( walls ) ; Stats s = new Stats ( ) ; world . addListener ( s ) ; world . addListener ( f ) ; world . addListener ( new Gravitation ( f ) ) ; world . addListener ( new Collider ( s ) ) ; bonder = new Bonder ( ) ; world . addListener ( bonder ) ; Circle c1 ; Circle c2 ; Circle c3 ; world . addBody ( c1 = new Circle ( 10 , 10 ) ) ; c1 . setPosition ( v ( 20 , 00 ) ) ; world . addBody ( c2 = new Circle ( 10 , 10 ) ) ; c2 . setColor ( Color . green ) ; c2 . setPosition ( v ( 0 , - 10 ) ) ; world . addBody ( c3 = new Circle ( 10 , 10 ) ) ; c3 . setColor ( Color . red ) ; c3 . setPosition ( v ( 0 , - 30 ) ) ; BindingForce b2 = new BindingForce ( c1 , c2 ) ; BindingForce b1 = new BindingForce ( c2 , c1 ) ; BindingForce b3 = new BindingForce ( c2 , c3 ) ; BindingForce b4 = new BindingForce ( c3 , c2 ) ; BindingForce b5 = new BindingForce ( c1 , c3 ) ; BindingForce b6 = new BindingForce ( c3 , c1 ) ; c1 . addBond ( b6 , c3 ) ; c3 . addBond ( b5 , c1 ) ; bonder . addBond ( b6 ) ; bonder . addBond ( b5 ) ; c2 . addBond ( b2 , c1 ) ; c3 . addBond ( b3 , c2 ) ; bonder . addBond ( b2 ) ; bonder . addBond ( b3 ) ; bonder . addBond ( b4 ) ; c2 . addBond ( b4 , c3 ) ; c1 . addBond ( b1 , c2 ) ; bonder . addBond ( b1 ) ; double temp = 100 ; Circle c ; for ( int i = 0 ; i < 9 ; i ++ ) for ( int j = 0 ; j < 9 ; j ++ ) { world . addBody ( c = new Circle ( 5 , 5 ) ) ; c . setPosition ( v ( 50 + 15 * i - 150 , 50 + 15 * j - 150 ) ) ; c . setVelocity ( v ( temp * ( Math . random ( ) - .5 ) , temp * ( Math . random ( ) - .5 ) ) ) ; } } public void createFilament ( ) { ArrayList < Circle > circles = new ArrayList < Circle > ( ) ; Circle c ; for ( int i = 0 ; i < 10 ; i ++ ) { world . addBody ( c = new Circle", "gt": "( 10 , 10 ) ) ;", "prediction": "( 5 , 5 ) ) ;\n", "label": 1}
{"id": 6748, "input": "<s> class Neg03 < U > { class Foo < V extends Number > { Foo ( V x ) { } < Z > Foo ( V x , Z z ) { } } void testSimple ( ) { Foo < String > f1 = new Foo < > ( \"\" ) ; Foo < ? extends String > f2 = new Foo < > ( \"\" ) ; Foo < ? > f3 = new Foo < > ( \"\" ) ; Foo < ? super String > f4 = new Foo < > ( \"\" ) ; Foo < String > f5 = new Foo < > ( \"\" , \"\" ) ; Foo < ? extends String > f6 = new Foo < > ( \"\" , \"\" ) ; Foo < ? > f7 = new Foo < > ( \"\" , \"\" ) ; Foo < ? super String > f8 = new Foo < > ( \"\" , \"\" ) ; } void testQualified_1 ( ) { Foo < String > f1 = new Neg03 < U > . Foo < > ( \"\" ) ; Foo < ? extends String > f2 = new Neg03 < U > . Foo < > ( \"\" ) ; Foo < ? > f3 = new Neg03 < U > . Foo < > ( \"\" ) ; Foo < ? super String > f4 = new Neg03 < U > . Foo < > ( \"\" ) ; Foo < String > f5 = new Neg03 < U > . Foo < > ( \"\" , \"\" ) ; Foo < ? extends String > f6 = new Neg03 < U > . Foo < > ( \"\" , \"\" ) ; Foo < ? > f7 = new Neg03 < U > . Foo < > ( \"\" , \"\" ) ; Foo < ? super String > f8 = new Neg03 < U > . Foo < > ( \"\" , \"\" ) ; } void testQualified_2 ( Neg03 < U > n ) { Foo < String > f1 = n . new Foo < > ( \"\" ) ; Foo < ? extends String > f2 = n . new Foo < > ( \"\" ) ; Foo < ? > f3 = n . new Foo < > ( \"\" ) ; Foo < ? super String > f4 = n . new Foo < > ( \"\" ) ; Foo < String > f5 = n . new Foo", "gt": "< > ( \"\" , \"\" ) ;", "prediction": "< > ( \"\" , \"\" ) ;\n", "label": 0}
{"id": 14737, "input": "<s> package org . powerbot . game . api . wrappers . widget ; import java . awt . Graphics ; import java . awt . Point ; import java . awt . Polygon ; import java . awt . Rectangle ; import org . powerbot . game . api . methods . Widgets ; import org . powerbot . game . api . methods . input . Mouse ; import org . powerbot . game . api . methods . node . Menu ; import org . powerbot . game . api . util . Filter ; import org . powerbot . game . api . util . Random ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . util . node . HashTable ; import org . powerbot . game . api . wrappers . Entity ; import org . powerbot . game . api . wrappers . Identifiable ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSInterface ; import org . powerbot . game . client . RSInterfaceNode ; public class WidgetChild implements Entity , Identifiable { private final int index ; private final Widget parentWidget ; private final WidgetChild parent ; public WidgetChild ( final Widget parent , final int index ) { parentWidget = parent ; this . index = index ; this . parent = null ; } public WidgetChild ( final Widget parentWidget , final WidgetChild parentComponent , final int index ) { this . parentWidget = parentWidget ; this . parent = parentComponent ; this . index = index ; } public Widget getWidget ( ) { return parentWidget ; } public WidgetChild getParent ( ) { return parent ; } public int getIndex ( ) { return index ; } public int getAbsoluteX ( ) { return getAbsoluteLocation ( ) . x ; } public int getAbsoluteY ( ) { return getAbsoluteLocation ( ) . y ; } public Point getAbsoluteLocation ( ) { if ( getInternal ( ) == null ) { return new Point ( - 1 , - 1 ) ; } final Client client = Context . client ( ) ; final int parentId = getParentId ( ) ; int x = 0 , y = 0 ; if ( parentId != - 1 ) { final Point point = Widgets . get ( parentId > > 0x10 , parentId & 0xffff ) . getAbsoluteLocation ( ) ; x = point . x ; y = point . y ; } else { final Rectangle [ ] bounds = client . getRSInterfaceBoundsArray ( ) ; final int index = getBoundsArrayIndex ( ) ; if ( bounds != null && index > 0 && index < bounds . length && bounds [ index ] != null ) { return new Point ( bounds [ index ] . x , bounds [ index ] . y ) ; } } if ( parentId != - 1 ) { final WidgetChild child = Widgets . getChild ( parentId ) ; final int horizontalScrollSize = child . getScrollableContentWidth ( ) , verticalScrollSize = child . getScrollableContentHeight ( ) ; if ( horizontalScrollSize > 0 || verticalScrollSize > 0 ) { x -= child . getHorizontalScrollPosition ( ) ; y -= child . getVerticalScrollPosition ( ) ; } } x += getRelativeX ( ) ; y += getRelativeY ( ) ; return new Point ( x , y ) ; } public int getRelativeX ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getX ( ) * Context . multipliers ( ) . INTERFACE_X : - 1 ; } public int getRelativeY ( ) { final RSInterface widget = getInternal ( ) ; return widget != null ? widget . getY ( ) * Context . multipliers ( ) . INTERFACE_Y : - 1 ; }", "gt": "public Point getRelativeLocation ( )", "prediction": "public int getRelativeY ( )\n", "label": 1}
{"id": 850, "input": "<s> package org . ofbiz . entity ; import java . util . concurrent . ConcurrentHashMap ; import org . ofbiz . base . lang . Factory ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilObject ; public abstract class DelegatorFactory implements Factory < Delegator , String > { public static final String module = DelegatorFactoryImpl . class . getName ( ) ; private static final ConcurrentHashMap < String , Delegator > delegatorCache = new ConcurrentHashMap < String , Delegator > ( ) ; public static Delegator getDelegator ( String delegatorName ) { if ( delegatorName == null ) { delegatorName = \"default\" ; } do { Delegator delegator = delegatorCache .", "gt": "get ( delegatorName ) ;", "prediction": "getDelegator ( ) ;\n", "label": 0}
{"id": 14750, "input": "<s> package com . yahoo . ycsb . measurements ; import java . io . IOException ; import java . io . Serializable ; import java . util . HashMap ; import com . yahoo . ycsb . measurements . exporter . MeasurementsExporter ; public abstract class OneMeasurement implements Serializable { private static final long serialVersionUID = 7807865821392650553L ; String _name ; public String getName ( ) { return _name ; } public OneMeasurement ( String _name ) { this . _name = _name ; } public abstract void reportReturnCode ( int code ) ; public abstract void measure ( int latency ) ; public abstract void add ( OneMeasurement m ) ; public abstract long getOperations ( ) ; public abstract HashMap < Integer , int [ ] > getReturnCodes ( ) ; public abstract String getSummary ( ) ; public abstract void exportMeasurements ( MeasurementsExporter exporter ) throws IOException ; public String computeTime ( double time ) { int i ; for ( i = 0 ; time > 1024 && i < 2 ; i ++ ) time = time / 1024 ; time = Math . round ( time * 100 ) / 100.0 ; if ( i == 0 ) return String . format ( \"%-6s\" , ( Double . toString ( time ) + \"us\" ) ) ; else if ( i == 1 ) return String . format ( \"%-6s\" , ( Double .", "gt": "toString ( time ) + \"ms\" ) ) ;", "prediction": "toString ( time ) + \"us\" ) ) ;\n", "label": 1}
{"id": 1582, "input": "<s> class ThrowNull { void foo ( ) throws Throwable { throw ( Throwable ) null ; } void bar ( ) { Object x", "gt": "= new Object ( )", "prediction": "= null ;\n", "label": 0}
{"id": 14757, "input": "<s> package com . emf4sw . rdf ; import org . eclipse . emf . ecore . EObject ; public interface URIElement extends EObject { String getURI ( ) ; void setURI ( String value ) ; Namespace getNamespace ( ) ; void setNamespace", "gt": "( Namespace value ) ;", "prediction": "( Namespace namespace ) ;\n", "label": 1}
{"id": 4616, "input": "<s> package org . ofbiz . webapp . event ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public interface EventHandler {", "gt": "public void init ( ServletContext context ) throws EventHandlerException ;", "prediction": "}\n", "label": 0}
{"id": 14758, "input": "<s> package org . eclipse . xtext . xdoc . parser . antlr . internal ; import org . eclipse . xtext . parser . antlr . Lexer ; import org . antlr . runtime . * ; import java . util . Stack ; import java . util . List ; import java . util . ArrayList ; @ SuppressWarnings ( \"all\" ) public class InternalXdocLexer extends Lexer { public static final int T__42 = 42 ; public static final int T__12 = 12 ; public static final int T__28 = 28 ; public static final int T__23 = 23 ; public static final int T__51 = 51 ; public static final int T__13 = 13 ; public static final int T__47 = 47 ; public static final int T__50 = 50 ; public static final int T__21 = 21 ; public static final int T__19 = 19 ; public static final int T__39 = 39 ; public static final int T__30 = 30 ; public static final int T__46 = 46 ; public static final int T__52 = 52 ; public static final int T__17 = 17 ; public static final int RULE_MULTI_NL = 5 ; public static final int T__27 = 27 ; public static final int T__24 = 24 ; public static final int T__49 = 49 ; public static final int T__10 = 10 ; public static final int T__48 = 48 ; public static final int T__34 = 34 ; public static final int T__15 = 15 ; public static final int T__35 = 35 ; public static final int RULE_ID = 6 ; public static final int T__36 = 36 ; public static final int T__20 = 20 ; public static final int T__44 = 44 ; public static final int T__14 = 14 ; public static final int T__33 = 33 ; public static final int T__22 = 22 ; public static final int T__11 = 11 ; public static final int T__29 = 29 ; public static final int T__45 = 45 ; public static final int RULE_WS = 4 ; public static final int T__43 = 43 ; public static final int T__31 = 31 ; public static final int T__40 = 40 ; public static final int EOF = - 1 ; public static final int T__53 = 53 ; public static final int T__32 = 32 ; public static final int T__16 = 16 ; public static final int RULE_SINGLE_NL = 7 ; public static final int T__38 = 38 ; public static final int T__37 = 37 ; public static final int T__26 = 26 ; public static final int RULE_ANY_OTHER = 8 ; public static final int T__25 = 25 ; public static final int RULE_SL_COMMENT = 9 ; public static final int T__41 = 41 ; public static final int T__18 = 18 ; public InternalXdocLexer ( ) { ; } public InternalXdocLexer ( CharStream input ) { this ( input , new RecognizerSharedState ( ) ) ; } public InternalXdocLexer ( CharStream input , RecognizerSharedState state ) { super ( input , state ) ; } public String getGrammarFileName ( ) { return \"../org.eclipse.xtext.xdoc/src-gen/org/eclipse/xtext/xdoc/parser/antlr/internal/InternalXdoc.g\" ; } public final void mT__10 ( ) throws RecognitionException { try { int _type = T__10 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"document[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__11 ( ) throws RecognitionException { try { int _type = T__11 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( ']' ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__12 ( ) throws RecognitionException { try { int _type = T__12 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"subtitle[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__13 ( ) throws RecognitionException { try { int _type = T__13 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"authors[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__14 ( ) throws RecognitionException { try { int _type = T__14 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"part:\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__15 ( ) throws RecognitionException { try { int _type = T__15 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( '[' ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__16 ( ) throws RecognitionException { try { int _type = T__16 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"part[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__17 ( ) throws RecognitionException { try { int _type = T__17 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"part-ref[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__18 ( ) throws RecognitionException { try { int _type = T__18 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"gloss-entry[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__19 ( ) throws RecognitionException { try { int _type = T__19 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( ',' ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__20 ( ) throws RecognitionException { try { int _type = T__20 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"chapter:\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__21 ( ) throws RecognitionException { try { int _type = T__21 ; int _channel = DEFAULT_TOKEN_CHANNEL ; { match ( \"chapter[\" ) ; } state . type = _type ; state . channel = _channel ; } finally { } } public final void mT__22 ( ) throws RecognitionException { try { int _type = T__22 ;", "gt": "int _channel = DEFAULT_TOKEN_CHANNEL ;", "prediction": "int _channel = DEFAULT_TOKEN_CHANNEL ;\n", "label": 1}
{"id": 6479, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import org . eclipse . emf . ecore . EAnnotation ; import org . eclipse . gef . commands . Command ; import org . eclipse . gmf . runtime . diagram . core . commands . DeleteCommand ; import org . eclipse . gmf . runtime . emf . commands . core . command . CompositeTransactionalCommand ; import org . eclipse . gmf . runtime . emf . type . core . commands . DestroyElementCommand ; import org . eclipse . gmf . runtime . emf . type . core . requests . DestroyElementRequest ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . diagram . providers . SimplemapElementTypes ; public class SimpleLabelNodeItemSemanticEditPolicy extends SimplemapBaseItemSemanticEditPolicy { public SimpleLabelNodeItemSemanticEditPolicy ( ) { super ( SimplemapElementTypes . SimpleLabelNode_2001 ) ; } protected Command getDestroyElementCommand ( DestroyElementRequest req ) { View view = ( View ) getHost ( ) . getModel ( ) ; CompositeTransactionalCommand cmd = new CompositeTransactionalCommand ( getEditingDomain ( ) , null ) ; cmd . setTransactionNestingEnabled ( false ) ; EAnnotation annotation = view . getEAnnotation ( \"Shortcut\" ) ; if ( annotation == null ) {", "gt": "addDestroyShortcutsCommand ( cmd , view ) ;", "prediction": "return null ;\n", "label": 0}
{"id": 14760, "input": "<s> package org . eclipse . swt . custom ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . * ; public class SashForm_Test extends TestCase { private Display display ; private Shell shell ; public void testIsSerializable ( ) throws Exception { SashForm sashForm = new SashForm ( shell , SWT . HORIZONTAL ) ; new Label ( sashForm , SWT . NONE ) ; new Label ( sashForm , SWT . NONE ) ; sashForm . setWeights ( new int [ ] { 30 , 70 } ) ; SashForm deserializedSashForm = Fixture . serializeAndDeserialize ( sashForm ) ; assertEquals ( sashForm . getWeights ( ) [ 0 ] , deserializedSashForm . getWeights ( ) [ 0 ] ) ; assertEquals ( sashForm . getWeights ( ) [ 1 ] , deserializedSashForm . getWeights ( ) [ 1 ] ) ; } protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display =", "gt": "new Display ( ) ;", "prediction": "new Display ( ) ;\n", "label": 1}
{"id": 7985, "input": "<s> public class UnreachableVar { static String result = \"\" ; public static void main ( String [ ] args ) { switch ( args . length ) { case 20000 : if ( true ) break ; int i = 1 ; default : i = 2 ; result += i + \" \" ; } result += args . getClass ( ) . getName ( ) ; if ( ! result . equals ( \"2 [Ljava.lang.String;\"", "gt": ") ) throw new Error ( result ) ;", "prediction": ") )\n", "label": 0}
{"id": 14779, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . server ; import org . nuxeo . common . utils . Path ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . platform . publisher . api . PublishedDocument ; import org . nuxeo . ecm . platform . publisher . helper . VersioningHelper ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . ExtendedDocumentLocation ; public class ExternalCorePublishedDocument implements PublishedDocument { private static final long serialVersionUID = 1L ; protected String sourceServer ; protected String repositoryName ; protected DocumentRef ref ; protected String versionLabel ; protected String path ; protected String parentPath ; protected boolean isPending ; public ExternalCorePublishedDocument ( DocumentModel doc ) throws ClientException { ExtendedDocumentLocation xLoc = ExtendedDocumentLocation . extractFromDoc ( doc ) ; this . sourceServer = xLoc . getOriginalServer ( ) ; this . repositoryName = xLoc . getServerName ( ) ; this . ref", "gt": "= xLoc . getDocRef ( ) ;", "prediction": "= xLoc . getRef ( ) ;\n", "label": 1}
{"id": 2185, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . matchervisitors . MatcherVisitor ; import java . util . List ; public class ProxyMatcher implements Matcher , Cloneable { private Matcher target ; private String label ; private boolean nodeSuppressed ; private boolean subnodesSuppressed ; private boolean nodeSkipped ; private boolean memoMismatches ; private boolean dirty ; public List < Matcher > getChildren ( ) { if ( dirty ) apply ( ) ; return target . getChildren ( ) ; } public void setLabel ( String label ) { this . label = label ; updateDirtyFlag ( ) ; } private void setNodeSuppressed ( boolean nodeSuppressed ) { this . nodeSuppressed = nodeSuppressed ; updateDirtyFlag ( ) ; } private void setSubnodesSuppressed ( boolean subnodesSuppressed ) { this . subnodesSuppressed = subnodesSuppressed ; updateDirtyFlag ( ) ; } private void setNodeSkipped ( boolean nodeSkipped ) { this . nodeSkipped = nodeSkipped ; updateDirtyFlag ( ) ; } private void setMemoMismatches ( boolean memoMismatches ) { this . memoMismatches = memoMismatches ; updateDirtyFlag ( ) ; } private void updateDirtyFlag ( ) { dirty = label != null || nodeSuppressed || subnodesSuppressed || nodeSkipped || memoMismatches ; } public < V > boolean match ( MatcherContext < V > context ) { if ( dirty ) apply ( ) ; return target . match ( context ) ; } public String getLabel ( ) { if ( dirty ) apply ( ) ; return target . getLabel ( ) ; } public boolean hasCustomLabel ( ) { if ( dirty ) apply ( ) ; return target . hasCustomLabel ( ) ; } public boolean isNodeSuppressed ( ) { if ( dirty ) apply ( ) ; return target . isNodeSuppressed ( ) ; } public boolean areSubnodesSuppressed ( ) { if ( dirty ) apply ( ) ; return target . areSubnodesSuppressed ( ) ; } public boolean isNodeSkipped ( ) { if ( dirty ) apply ( ) ; return target . isNodeSkipped ( ) ; } public boolean areMismatchesMemoed ( ) { if ( dirty ) apply ( ) ; return target . areMismatchesMemoed ( ) ; } public void setTag ( Object tagObject ) { if ( dirty ) apply ( ) ; target . setTag ( tagObject ) ; } public Object getTag ( ) { if ( dirty ) apply ( ) ; return target . getTag ( ) ; } public < R > R accept ( MatcherVisitor < R > visitor ) { checkArgNotNull ( visitor , \"visitor\" ) ; if ( dirty ) apply ( ) ; return target", "gt": ". accept ( visitor ) ;", "prediction": ". accept ( visitor ) ;\n", "label": 0}
{"id": 14787, "input": "<s> package litil . lexer ; public class LexingException extends RuntimeException { public final String line ; public final int row ; public final int col ; public LexingException ( String error , String line , int row , int col ) { super ( error + \" @ \" + row + \":\" + col + \"\\n\" + line + \"\\n\" + nspaces ( col ) + \"^\" ) ; this", "gt": ". line = line ;", "prediction": ". line = line ;\n", "label": 1}
{"id": 2062, "input": "<s> package com . shopzilla . api . client . model ; import com . shopzilla . services . catalog . CategoriesType ; import com . shopzilla . services . catalog . CategoryType ; import com . shopzilla . services . catalog . TaxonomyResponse ; import org . apache . commons . collections . CollectionUtils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class CategoryModelAdapter { protected CategoryModelAdapter ( ) { } public static List < Category > fromCatalogAPI ( TaxonomyResponse response ) { if ( response == null || response . getTaxonomy ( ) == null ) { return null ; } return convertChildren ( response . getTaxonomy ( ) . getCategories ( ) ) ; } private static List < Category > convertChildren ( CategoriesType children ) { if ( children == null || CollectionUtils . isEmpty ( children . getCategory ( ) ) ) { return Collections . emptyList ( ) ; } List < Category > toReturn = new ArrayList < Category > ( ) ; for ( CategoryType child : children . getCategory ( ) ) { toReturn . add ( convertCategory ( child ) ) ; } return toReturn ; } private static Category convertCategory ( CategoryType categoryType ) { Category category = new Category ( ) ; category", "gt": ". setId ( categoryType . getId ( ) ) ;", "prediction": ". setType ( categoryType ) ;\n", "label": 0}
{"id": 14796, "input": "<s> package org . eclipse . ui ; public interface IPageService { public void addPageListener ( IPageListener listener ) ; public void addPerspectiveListener ( IPerspectiveListener listener ) ; public IWorkbenchPage getActivePage ( ) ; public void removePageListener ( IPageListener listener ) ;", "gt": "public void removePerspectiveListener ( IPerspectiveListener listener ) ;", "prediction": "}\n", "label": 1}
{"id": 9709, "input": "<s> package com . gisgraphy . client . impl . parser ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . junit . Assert . assertThat ; import java . io . IOException ; import java . util . Iterator ; import java . util . NoSuchElementException ; import javax . xml . stream . XMLStreamException ; import org . junit . Assert ; import org . junit . Ignore ; import org . junit . Test ; import org . springframework . core . io . InputStreamSource ; import com . gisgraphy . client . impl . FullTextSearchResultsObjectMother ; import com . gisgraphy . client . impl . GeolocalisationQueryResultsObjectMother ; import com . gisgraphy . client . impl . resultparser . FullTextQueryResult ; import com . gisgraphy . client . impl . resultparser . FullTextQueryResultParser ; import com . gisgraphy . client . impl . resultparser . GeolocalisationResult ; import com . gisgraphy . client . impl . resultparser . GeolocalizationQueryResultParser ; import com . gisgraphy . client . impl . resultparser . StaxFullTextQueryResultParser ; import com . gisgraphy . client . impl . resultparser . StaxGeolocalizationQueryResultParser ; import com . google . common . collect . Iterables ; public class StaxGeolocalizationQueryResultParserTest { private GeolocalizationQueryResultParser staxParser = new StaxGeolocalizationQueryResultParser ( ) ; @ Test public void shouldParseGeolocalisationQueryForParis ( ) throws IOException , XMLStreamException { InputStreamSource iss = GeolocalisationQueryResultsObjectMother . paris ( ) ; Iterable < GeolocalisationResult > results = staxParser . parse ( iss ) ; GeolocalisationResult firstResult = Iterables . get ( results , 0 ) ; assertThat ( firstResult . getDistance ( ) , equalTo ( 0.0 ) ) ; assertThat ( firstResult . getAdm1Code ( ) , equalTo ( \"A8\" ) ) ; assertThat ( firstResult . getAdm2Code ( ) , equalTo ( \"75\" ) ) ; assertThat ( firstResult . getAdm3Code ( ) , equalTo ( \"751\" ) ) ; assertThat ( firstResult . getAdm4Code ( ) , equalTo ( \"75056\" ) ) ; assertThat ( firstResult . getAdm1Name ( ) , equalTo ( \"R\u00e9gion \u00cele-de-France\" ) ) ; assertThat ( firstResult . getAdm2Name ( ) , equalTo ( \"D\u00e9partement de Ville-de-Paris\" ) ) ; assertThat ( firstResult . getAdm3Name ( ) , equalTo ( \"Arrondissement de Paris\" ) ) ; assertThat ( firstResult . getAdm4Name ( ) , equalTo ( \"Paris\" ) ) ; assertThat ( firstResult . getAsciiName ( ) , equalTo ( \"Paris\" ) ) ; assertThat ( firstResult", "gt": ". getName ( ) , equalTo ( \"Paris\" ) ) ;", "prediction": ". getAsciiName ( ) , equalTo ( \"Paris\" ) ) ;\n", "label": 0}
{"id": 14797, "input": "<s> package org . spliffy . server . apps . admin . users ; import com . bradmcevoy . http . CollectionResource ; import com . bradmcevoy . http . Resource ; import org . spliffy . server . web . templating . MenuItem ; import java . util . List ; import org . spliffy . server . apps . AppConfig ; import org . spliffy . server . apps . Application ; import org . spliffy . server . db . Profile ; import org . spliffy . server . apps . orgs . OrganisationFolder ; import org . spliffy . server . web . RootFolder ; import org . spliffy . server . web . SpliffyCollectionResource ; import org . spliffy . server . web . SpliffyResourceFactory ; public class UserAdminApp implements Application { private SpliffyResourceFactory resourceFactory ; @ Override public String getInstanceId ( ) { return \"manageUsers\" ; } @ Override public void init ( SpliffyResourceFactory resourceFactory , AppConfig config ) throws Exception { this . resourceFactory = resourceFactory ; } @ Override public Resource getPage ( Resource parent , String requestedName ) { if ( parent instanceof OrganisationFolder ) { if ( requestedName . equals ( \"manageUsers\" ) ) { OrganisationFolder orgFolder = ( OrganisationFolder ) parent ; return new UserAdminPage ( requestedName , orgFolder . getOrganisation ( ) , ( SpliffyCollectionResource ) parent , resourceFactory . getServices ( ) ) ; } } return null ; } @ Override public void addBrowseablePages ( CollectionResource", "gt": "parent , List < Resource > children )", "prediction": "resource )\n", "label": 1}
{"id": 3892, "input": "<s> package javax . lang . model . element ; public enum NestingKind { TOP_LEVEL , MEMBER , LOCAL , ANONYMOUS ; public boolean isNested ( ) {", "gt": "return this != TOP_LEVEL ;", "prediction": "return true ;\n", "label": 0}
{"id": 14799, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . Version ; public class TestMatchAllDocsQuery extends LuceneTestCase { private Analyzer analyzer = new StandardAnalyzer ( Version . LUCENE_CURRENT ) ; public void testQuery ( ) throws Exception { RAMDirectory dir = new RAMDirectory ( ) ; IndexWriter iw = new IndexWriter ( dir , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; iw . setMaxBufferedDocs ( 2 ) ; addDoc ( \"one\" , iw , 1f ) ; addDoc ( \"two\" , iw , 20f ) ; addDoc ( \"three four\" , iw , 300f ) ; iw . close ( ) ; IndexReader ir = IndexReader . open ( dir ) ; IndexSearcher is = new IndexSearcher ( ir ) ; ScoreDoc [ ] hits ; hits = is . search ( new MatchAllDocsQuery ( ) , null , 1000 ) . scoreDocs ; assertEquals ( 3 , hits . length ) ; assertEquals ( \"one\" , ir . document ( hits [ 0 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"two\" , ir . document ( hits [ 1 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"three four\" , ir . document ( hits [ 2 ] . doc ) . get ( \"key\" ) ) ; MatchAllDocsQuery normsQuery = new MatchAllDocsQuery ( \"key\" ) ; hits = is . search ( normsQuery , null , 1000 ) . scoreDocs ; assertEquals ( 3 , hits . length ) ; assertEquals ( \"three four\" , ir . document ( hits [ 0 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"two\" , ir . document ( hits [ 1 ] . doc ) . get ( \"key\" ) ) ; assertEquals ( \"one\" , ir . document ( hits [ 2 ] . doc ) . get ( \"key\" ) ) ; ir", "gt": ". setNorm ( 0 , \"key\" , 400f ) ;", "prediction": ". close ( ) ;\n", "label": 1}
{"id": 4467, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . gmf . gmfgraph . Canvas ; import org . eclipse . gmf . mappings . Mapping ; import org . eclipse . gmf . tooldef . Palette ; public interface SimpleMapping extends SimpleParentNode { Canvas getCanvas ( ) ; void setCanvas ( Canvas value ) ; Palette getPalette ( ) ; void setPalette ( Palette value ) ; Mapping getMapping ( ) ;", "gt": "void setMapping ( Mapping value ) ;", "prediction": "void setMapping ( Mapping value ) ;\n", "label": 0}
{"id": 14800, "input": "<s> package org . restlet . test . service ; import junit . framework . Test ; import junit . framework . TestSuite ; public class ServiceTestSuite { public static Test suite ( ) { TestSuite", "gt": "suite = new TestSuite ( \"Service package\" ) ;", "prediction": "suite = new TestSuite ( ) ;\n", "label": 1}
{"id": 9753, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Villager ; public interface LizaVillager extends Villager { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities ( double", "gt": "x , double y , double z ) ;", "prediction": "distance ) ;\n", "label": 0}
{"id": 14804, "input": "<s> package org . eclipse . swt . internal . widgets . listkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . util . Arrays ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . * ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . IListAdapter ; import org . eclipse . swt . internal . widgets . Props ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . widgets . * ; import org . json . JSONArray ; import org . json . JSONException ; import org . mockito . ArgumentCaptor ; public class ListLCA_Test extends TestCase { private Display display ; private Shell shell ; private ListLCA lca ; private List list ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; list = new List ( shell , SWT . NONE ) ; lca = new ListLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testControlListeners ( ) throws IOException { ControlLCATestUtil . testActivateListener ( list ) ; ControlLCATestUtil . testFocusListener ( list ) ; ControlLCATestUtil . testMouseListener ( list ) ; ControlLCATestUtil . testKeyListener ( list ) ; ControlLCATestUtil . testTraverseListener ( list ) ; ControlLCATestUtil . testMenuDetectListener ( list ) ; ControlLCATestUtil . testHelpListener ( list ) ; } public void testPreserveValues ( ) { Fixture . markInitialized ( display ) ; Fixture . preserveWidgets ( ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . TRUE , adapter . getPreserved ( Props . ENABLED ) ) ; Fixture . clearPreserved ( ) ; list . setEnabled ( false ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . FALSE , adapter . getPreserved ( Props . ENABLED ) ) ; Fixture . clearPreserved ( ) ; list . setEnabled ( true ) ; list . setSize ( 10 , 10 ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . TRUE , adapter . getPreserved ( Props . VISIBLE ) ) ; Fixture . clearPreserved ( ) ; list . setVisible ( false ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( Boolean . FALSE , adapter . getPreserved ( Props . VISIBLE ) ) ; Fixture . clearPreserved ( ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( null , adapter . getPreserved ( Props . MENU ) ) ; Fixture . clearPreserved ( ) ; Menu menu = new Menu ( list ) ; MenuItem item = new MenuItem ( menu , SWT . NONE ) ; item . setText ( \"1 Item\" ) ; list . setMenu ( menu ) ; Fixture . preserveWidgets ( ) ; adapter = WidgetUtil . getAdapter ( list ) ; assertEquals ( menu , adapter . getPreserved ( Props . MENU ) ) ; Fixture . clearPreserved ( ) ; list . getFocusIndex ( ) ; Rectangle rectangle = new Rectangle (", "gt": "10 , 10 , 30 , 50 ) ;", "prediction": "10 , 10 ) ;\n", "label": 1}
{"id": 6466, "input": "<s> package org . ofbiz . humanres ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import javolution . util . FastMap ; import net . sf . json . JSONObject ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; public class HumanResEvents { public static final String module = HumanResEvents . class . getName ( ) ; public static final String resourceError = \"ProductErrorUiLabels\" ; @ SuppressWarnings ( \"unchecked\" ) public static void getChildHRCategoryTree ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String partyId = request . getParameter ( \"partyId\" ) ; String onclickFunction = request . getParameter ( \"onclickFunction\" ) ; String additionParam = request . getParameter ( \"additionParam\" ) ; String hrefString = request . getParameter ( \"hrefString\" ) ; String hrefString2 = request . getParameter ( \"hrefString2\" ) ; List categoryList = FastList . newInstance ( ) ; List < GenericValue > childOfComs ; try { List < GenericValue > isEmpl = delegator . findByAnd ( \"EmplPosition\" , UtilMisc . toMap ( \"emplPositionId\" , partyId ) , null , false ) ; if ( UtilValidate . isNotEmpty ( isEmpl ) ) { String emplId = partyId ; List < GenericValue > emlpfillCtxs = EntityUtil . filterByDate ( delegator . findByAnd ( \"EmplPositionFulfillment\" , UtilMisc . toMap ( \"emplPositionId\" , emplId ) , null , false ) ) ; if ( UtilValidate . isNotEmpty ( emlpfillCtxs ) ) { for ( GenericValue emlpfillCtx : emlpfillCtxs ) { String memberId = emlpfillCtx . getString ( \"partyId\" ) ; GenericValue memCtx = delegator . findOne ( \"Person\" , UtilMisc . toMap ( \"partyId\" , memberId ) , false ) ; String title = null ; if ( UtilValidate . isNotEmpty ( memCtx ) ) { String firstname = ( String ) memCtx . get ( \"firstName\" ) ; String lastname = ( String ) memCtx . get ( \"lastName\" ) ; if ( UtilValidate . isEmpty ( lastname ) ) { lastname = \"\" ; } if ( UtilValidate . isEmpty ( firstname ) ) { firstname = \"\" ; } title = firstname + \" \" + lastname ; } GenericValue memGroupCtx = delegator . findOne ( \"PartyGroup\" , UtilMisc . toMap ( \"partyId\" , memberId ) , false ) ; if ( UtilValidate . isNotEmpty ( memGroupCtx ) ) { title = memGroupCtx . getString ( \"groupName\" ) ; } Map josonMap = FastMap . newInstance ( ) ; Map dataMap = FastMap . newInstance ( ) ; Map dataAttrMap = FastMap . newInstance ( ) ; Map attrMap = FastMap . newInstance ( ) ; dataAttrMap . put ( \"onClick\" , onclickFunction + \"('\" + memberId + additionParam + \"')\" ) ; String hrefStr = hrefString + memberId ; if ( UtilValidate . isNotEmpty ( hrefString2 ) ) { hrefStr = hrefStr + hrefString2 ; } dataAttrMap . put ( \"href\" , hrefStr ) ; attrMap . put ( \"rel\" , \"P\" ) ; dataMap . put ( \"attr\" , dataAttrMap ) ; attrMap . put ( \"id\" , memberId ) ; josonMap . put ( \"attr\" , attrMap ) ; dataMap . put ( \"title\" , title ) ; josonMap . put ( \"data\" , dataMap ) ; categoryList . add ( josonMap ) ; } toJsonObjectList ( categoryList , response ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } try { GenericValue partyGroup = delegator . findOne ( \"PartyGroup\" , UtilMisc . toMap ( \"partyId\" , partyId ) , false ) ; if ( UtilValidate . isNotEmpty ( partyGroup ) ) { childOfComs = EntityUtil . filterByDate ( delegator . findByAnd ( \"PartyRelationship\" , UtilMisc . toMap ( \"partyIdFrom\" , partyGroup . get ( \"partyId\" ) , \"partyRelationshipTypeId\" , \"GROUP_ROLLUP\" ) , null , false ) ) ; if ( UtilValidate . isNotEmpty ( childOfComs ) ) { for ( GenericValue childOfCom : childOfComs ) { Object catId = null ; String catNameField = null ; String title = null ; Map josonMap = FastMap . newInstance ( ) ; Map dataMap = FastMap . newInstance ( ) ; Map dataAttrMap = FastMap . newInstance ( ) ; Map attrMap = FastMap . newInstance ( ) ; catId = childOfCom . get ( \"partyIdTo\" ) ; GenericValue childContext = delegator . findOne ( \"PartyGroup\" , UtilMisc . toMap ( \"partyId\" , catId ) , false ) ; if ( UtilValidate . isNotEmpty ( childContext ) ) { catNameField = ( String ) childContext . get ( \"groupName\" ) ; title = catNameField ; josonMap . put ( \"title\" , title ) ; } List < GenericValue > childOfSubComs = EntityUtil . filterByDate ( delegator . findByAnd ( \"PartyRelationship\" , UtilMisc . toMap ( \"partyIdFrom\" , catId , \"partyRelationshipTypeId\" , \"GROUP_ROLLUP\" ) , null , false ) ) ; List < GenericValue > isPosition = delegator . findByAnd ( \"EmplPosition\" , UtilMisc . toMap ( \"partyId\" , catId ) , null , false ) ; if ( UtilValidate . isNotEmpty ( childOfSubComs ) || UtilValidate . isNotEmpty ( isPosition ) ) { josonMap . put ( \"state\" , \"closed\" ) ; } GenericValue emContext = delegator . findOne ( \"Person\" , UtilMisc . toMap ( \"partyId\" , catId ) , false ) ; if ( UtilValidate . isNotEmpty ( emContext ) ) { String firstname = ( String ) emContext . get ( \"firstName\" ) ; String lastname = ( String ) emContext . get ( \"lastName\" ) ; if ( UtilValidate . isEmpty ( lastname ) ) { lastname = \"\" ; } if ( UtilValidate . isEmpty ( firstname ) ) { firstname = \"\" ; } title = firstname +", "gt": "\" \" + lastname ;", "prediction": "\"\" ;\n", "label": 0}
{"id": 14820, "input": "<s> package br . org . archimedes . trimmers ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . trimmers . LineTrimmer ; import br . org . archimedes . trims . interfaces . Trimmer ; import org . junit . Assert ; import org . junit . Test ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; public class LineTrimTest extends Tester { Trimmer trimmer = new LineTrimmer ( ) ; Collection < Point > cutPoints = new ArrayList < Point > ( ) ; public void setUp ( ) throws NullArgumentException , InvalidArgumentException { } @ Test public void testNullLineArgument ( ) { try { trimmer . trim ( null , cutPoints , new Point ( 0.0 , 0.0 ) ) ; } catch ( NullArgumentException e ) { Assert . assertTrue ( \"Should throw null argument exception\" , true ) ; return ; } Assert . assertFalse ( \"Should throw null argument exception\" , true ) ; } @ Test public void testNullcutPointsArgument ( ) throws InvalidArgumentException , NullArgumentException { Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ; try { trimmer . trim ( line , null , new Point ( 0.0 , 0.0 ) ) ; } catch ( NullArgumentException e ) { Assert . assertTrue ( \"Should throw null argument exception\" , true ) ; return ; } Assert . assertFalse ( \"Should throw null argument exception\" , true ) ; } @ Test public void lineTrimsCenter ( ) throws NullArgumentException , InvalidArgumentException { cutPoints . add ( new Point ( 0.0 , 2.0 ) ) ; cutPoints . add ( new Point ( 2.0 , 2.0 ) ) ; Line line = new Line ( new Point ( - 1.0 , 2.0 ) , new Point ( 3.0 , 2.0 ) ) ; Collection < Element > collection = trimmer . trim ( line , cutPoints , new Point", "gt": "( 1.0 , 2.0 ) ) ;", "prediction": "( 0.0 , 2.0 ) ) ;\n", "label": 1}
{"id": 2560, "input": "<s> package jns . util ; import jns . element . IPPacket ; import jns . trace . Event ; public class EventGenerator { public static Event makePacketEvent ( String name , IPPacket packet ) { Event event = new Event ( name ) ; event . addParameter ( \"Source Address\" , packet . source ) ; event . addParameter ( \"Destination Address\" , packet . destination ) ; event . addParameter (", "gt": "\"Source Hop\" , packet . source_hop ) ;", "prediction": "\"Port\" , packet . port ) ;\n", "label": 0}
{"id": 14824, "input": "<s> package org . eclipse . ui . internal . forms . widgets ; import java . util . Hashtable ; import java . util . Vector ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . ui . forms . internal . widgets . IAggregateHyperlinkSegmentAdapter ; public class AggregateHyperlinkSegment extends ParagraphSegment implements IHyperlinkSegment , Adaptable { private String href ; private Vector segments = new Vector ( ) ; private IAggregateHyperlinkSegmentAdapter aggregateHyperlinkSegmentAdapter ; public AggregateHyperlinkSegment ( ) { } public Object getAdapter ( Class adapter ) { Object result = null ; if ( adapter == IAggregateHyperlinkSegmentAdapter . class ) { if ( aggregateHyperlinkSegmentAdapter == null ) { aggregateHyperlinkSegmentAdapter = new IAggregateHyperlinkSegmentAdapter ( ) { public Object [ ] getHyperlinkSegments ( ) { return segments . toArray ( ) ; } } ; } result = aggregateHyperlinkSegmentAdapter ; } return result ; } public void add ( TextHyperlinkSegment segment ) { segments . add ( segment ) ; } public void add ( ImageHyperlinkSegment segment ) { segments . add ( segment ) ; } public boolean advanceLocator ( GC gc , int wHint , Locator loc , Hashtable objectTable , boolean computeHeightOnly ) { boolean newLine = false ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { ParagraphSegment segment = ( ParagraphSegment ) segments . get ( i ) ; if ( segment . advanceLocator ( gc , wHint , loc , objectTable , computeHeightOnly ) ) newLine = true ; } return newLine ; } public String getHref ( ) { return href ; } public void setHref ( String href ) { this . href = href ; } public String getText ( ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; buf . append ( segment . getText ( ) ) ; } return buf . toString ( ) ; } public Rectangle getBounds ( ) { Rectangle bounds = new Rectangle ( Integer . MAX_VALUE , Integer . MAX_VALUE , 0 , 0 ) ; for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; Rectangle sbounds = segment . getBounds ( ) ; bounds . x = Math . min ( bounds . x , sbounds . x ) ; bounds . y = Math . min ( bounds . y , sbounds . y ) ; bounds . width = Math . max ( bounds . width , sbounds . width ) ; bounds . height = Math . max ( bounds . height , sbounds . height ) ; } return bounds ; } public boolean contains ( int x , int y ) { for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; if ( segment . contains ( x , y ) ) return true ; } return false ; } public boolean intersects ( Rectangle rect ) { for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { IHyperlinkSegment segment = ( IHyperlinkSegment ) segments . get ( i ) ; if ( segment . intersects ( rect ) ) return true ; } return false ; } public void layout ( GC gc , int width , Locator locator , Hashtable resourceTable , boolean selected ) { for ( int i = 0 ; i < segments . size ( ) ; i ++ ) { ParagraphSegment segment = ( ParagraphSegment ) segments . get ( i ) ; segment . layout ( gc , width , locator , resourceTable , selected ) ; } } public void computeSelection ( GC gc , Hashtable resourceTable , SelectionData selData ) { for (", "gt": "int i = 0 ;", "prediction": "int i = 0 ;\n", "label": 1}
{"id": 7835, "input": "<s> package org . remast . baralga . gui . panels . table ; import java . util . List ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . model . ProjectActivity ; import ca . odell . glazedlists . TextFilterator ; public class ProjectActivityTextFilterator implements TextFilterator < ProjectActivity > { @ Override public void getFilterStrings ( List < String > baseList , ProjectActivity activity ) { if ( baseList == null || activity == null ) { return ; } baseList . add ( activity . getProject ( ) . getTitle ( ) ) ; baseList . add ( FormatUtils . formatDay ( activity . getStart ( ) ) ) ; baseList . add ( activity . getDescription ( ) ) ; baseList . add ( FormatUtils . formatTime ( activity . getStart ( ) ) ) ; baseList . add ( FormatUtils . formatTime ( activity . getEnd ( ) ) ) ; baseList . add ( FormatUtils . DURATION_FORMAT .", "gt": "format ( activity . getDuration ( ) ) ) ;", "prediction": "DEFAULT ) ;\n", "label": 0}
{"id": 14825, "input": "<s> package org . apache . lucene . search . payloads ; import java . io . Serializable ; public abstract class PayloadFunction implements Serializable { public abstract float currentScore ( int docId , String field , int start , int end , int numPayloadsSeen , float currentScore , float currentPayloadScore ) ; public abstract float docScore ( int docId , String field , int numPayloadsSeen", "gt": ", float payloadScore ) ;", "prediction": ", float currentScore , float currentPayloadScore ) ;\n", "label": 1}
{"id": 1821, "input": "<s> public class T6413682 { public static void main ( String ... args ) { Object [ ] text = new < Wow , thanks . Mr < List > , and . thanks . Mr < Javac >", "gt": ". Vince > Object [ 5 ] ;", "prediction": "> ( ) ;\n", "label": 0}
{"id": 14826, "input": "<s> package org . restlet . ext . xml ; import java . io . IOException ; import java . util . List ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . converter . ConverterHelper ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; import org . w3c . dom . Document ; public class XmlConverter extends ConverterHelper { private static final VariantInfo VARIANT_APPLICATION_ALL_XML = new VariantInfo ( MediaType . APPLICATION_ALL_XML ) ; private static final VariantInfo VARIANT_APPLICATION_XML = new VariantInfo ( MediaType . APPLICATION_XML ) ; private static final VariantInfo VARIANT_TEXT_XML = new VariantInfo ( MediaType . TEXT_XML ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; if ( VARIANT_APPLICATION_ALL_XML . isCompatible ( source ) || VARIANT_APPLICATION_XML . isCompatible ( source ) || VARIANT_TEXT_XML . isCompatible ( source ) ) { result = addObjectClass ( result , Document . class ) ; result = addObjectClass ( result , DomRepresentation . class ) ; result = addObjectClass ( result , SaxRepresentation . class ) ; } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( Document . class . isAssignableFrom ( source ) || DomRepresentation . class . isAssignableFrom ( source ) || SaxRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_APPLICATION_ALL_XML ) ; result = addVariant ( result , VARIANT_APPLICATION_XML ) ; result = addVariant ( result , VARIANT_TEXT_XML ) ; } return result ; } @ Override public float score ( Object source , Variant target , Resource resource ) { float result = - 1.0F ; if ( source instanceof Document ) { if ( target == null ) { result = 0.5F ; } else if ( MediaType . APPLICATION_ALL_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.8F ; } else if ( MediaType . APPLICATION_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.9F ; } else if ( MediaType . TEXT_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.9F ; } else { result = 0.5F ; } } return result ; } @ Override public < T > float score ( Representation source , Class < T > target , Resource resource ) { float result = - 1.0F ; if ( ( target != null ) && ( Document . class . isAssignableFrom ( target ) || DomRepresentation . class . isAssignableFrom ( target ) || SaxRepresentation . class . isAssignableFrom ( target ) ) ) { if ( MediaType . APPLICATION_ALL_XML .", "gt": "isCompatible ( source . getMediaType ( ) ) )", "prediction": "isCompatible ( target . getMediaType ( ) ) )\n", "label": 1}
{"id": 7144, "input": "<s> package com . matburt . mobileorg . test . OrgData ; import java . util . ArrayList ; import android . database . Cursor ; import android . test . ProviderTestCase2 ; import android . test . mock . MockContentResolver ; import com . matburt . mobileorg . OrgData . OrgEdit ; import com . matburt . mobileorg . OrgData . OrgFile ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProvider ; import com . matburt . mobileorg . OrgData . OrgContract . Edits ; import com . matburt . mobileorg . OrgData . OrgContract . OrgData ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import com . matburt . mobileorg . test . util . OrgTestUtils ; import com . matburt . mobileorg . util . OrgFileNotFoundException ; import com . matburt . mobileorg . util . OrgNodeNotFoundException ; public class OrgNodeTest extends ProviderTestCase2 < OrgProvider > { private MockContentResolver resolver ; public OrgNodeTest ( ) { super ( OrgProvider . class , OrgProvider . class . getName ( ) ) ; } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; this . resolver = getMockContentResolver ( ) ; } @ Override protected void tearDown ( ) throws Exception { } public void testNodeToStringSimple ( ) { OrgNode node = new OrgNode ( ) ; node . name = \"my simple test\" ; node . todo = \"TODO\" ; node . level = 3 ; assertEquals ( \"*** TODO my simple test\" , node . toString ( ) ) ; } public void testAddNodeSimple ( ) throws OrgNodeNotFoundException { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; Cursor cursor = resolver . query ( OrgData . buildIdUri ( node . id ) , OrgData . DEFAULT_COLUMNS , null , null , null ) ; assertNotNull ( cursor ) ; assertEquals ( 1 , cursor . getCount ( ) ) ; OrgNode insertedNode = new OrgNode ( cursor ) ; cursor . close ( ) ; assertTrue ( node . equals ( insertedNode ) ) ; } public void testAddAndUpdateNode ( ) throws OrgNodeNotFoundException { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; node . todo = \"DONE\" ; node . write ( resolver ) ; Cursor orgDataCursor = resolver . query ( OrgData . CONTENT_URI , null , null , null , null ) ; assertEquals ( 1 , orgDataCursor . getCount ( ) ) ; orgDataCursor . close ( ) ; Cursor cursor = resolver . query ( OrgData . buildIdUri ( node . id ) , OrgData . DEFAULT_COLUMNS , null , null , null ) ; assertNotNull ( cursor ) ; assertEquals ( 1 , cursor . getCount ( ) ) ; OrgNode insertedNode = new OrgNode ( cursor ) ; cursor . close ( ) ; assertTrue ( node . equals ( insertedNode ) ) ; } public void testGetParentSimple ( ) throws OrgNodeNotFoundException { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; OrgNode childNode = OrgTestUtils . getDefaultOrgNode ( ) ; childNode . parentId = node . id ; childNode . write ( resolver ) ; OrgNode parent = childNode . getParent ( resolver ) ; assertEquals ( node . id , parent . id ) ; } public void testGetParentFileNode ( ) throws OrgNodeNotFoundException { OrgFile file = OrgTestUtils . getDefaultOrgFile ( ) ; file . write ( resolver ) ; OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . parentId = file . nodeId ; node . write ( resolver ) ; OrgNode parent = node . getParent ( resolver ) ; assertEquals ( file . nodeId , parent . id ) ; } public void testGetParentWithTopLevel ( ) throws OrgNodeNotFoundException { OrgFile file = OrgTestUtils . getDefaultOrgFile ( ) ; file . write ( resolver ) ; OrgNode node = new OrgNode ( file . nodeId , resolver ) ; try { node . getParent ( resolver ) ; fail ( \"File shouldn't exist\" ) ; } catch ( OrgNodeNotFoundException e ) { } } public void testGetChildrenSimple ( ) { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; OrgNode child1 = OrgTestUtils . getDefaultOrgNode ( ) ; child1 . parentId = node . id ; child1 . write ( resolver ) ; OrgNode child2 = OrgTestUtils . getDefaultOrgNode ( ) ; child2 . parentId = node . id ; child2 . write ( resolver ) ; ArrayList < OrgNode > children = node . getChildren ( resolver ) ; assertEquals ( 2 , children . size ( ) ) ; } public void testArchiveNode ( ) { OrgNode childNode = OrgTestUtils . setupParentScenario ( resolver ) ; childNode . archiveNode ( resolver ) ; try { new OrgNode ( childNode . id , resolver ) ; fail ( \"Node should not exist\" ) ; } catch ( OrgNodeNotFoundException e ) { } OrgTestUtils . cleanupParentScenario ( resolver ) ; } public void testArchiveNodeGeneratesEdit ( ) { OrgNode node = OrgTestUtils . getDefaultOrgNode ( ) ; node . write ( resolver ) ; Cursor editCursor = resolver . query ( Edits . CONTENT_URI , Edits . DEFAULT_COLUMNS , null , null , null ) ; int baseOfEdits = editCursor . getCount ( ) ; editCursor . close ( ) ; OrgEdit edit = node . archiveNode ( resolver ) ; edit . type . equals ( OrgEdit . TYPE . ARCHIVE ) ; Cursor editCursor2 = resolver . query ( Edits . CONTENT_URI , Edits . DEFAULT_COLUMNS , null , null , null ) ; int numberOfEdits = editCursor2 . getCount ( ) ; editCursor2 . close ( ) ; assertEquals ( baseOfEdits + 1 , numberOfEdits ) ; } public void testArchiveNodeToSibling ( ) throws OrgNodeNotFoundException { OrgNode childNode = OrgTestUtils . setupParentScenario ( resolver ) ; OrgNode parent = childNode . getParent ( resolver ) ; childNode . archiveNodeToSibling ( resolver ) ; OrgNode archiveNode = parent . getChild ( OrgNode . ARCHIVE_NODE , resolver ) ; assertNotNull ( archiveNode ) ; assertEquals ( archiveNode . id , childNode . parentId ) ; assertEquals ( archiveNode . fileId , childNode . fileId ) ; } public void testArchiveNodeToSiblingGeneratesEdit ( ) { OrgNode node = OrgTestUtils . setupParentScenario ( resolver ) ; node . write ( resolver ) ; Cursor editCursor = resolver . query ( Edits . CONTENT_URI , Edits . DEFAULT_COLUMNS , null , null , null ) ; int baseOfEdits = editCursor . getCount ( ) ; editCursor . close ( ) ; OrgEdit edit = node . archiveNodeToSibling ( resolver ) ; edit .", "gt": "type . equals ( OrgEdit . TYPE . ARCHIVE_SIBLING ) ;", "prediction": "type . equals ( OrgEdit . TYPE . ARCHIVE ) ;\n", "label": 0}
{"id": 14827, "input": "<s> package com . cloudera . sqoop . mapreduce ; import org . apache . avro . Schema ; import org . apache . hadoop . conf . Configuration ; public final class AvroJob { public static final String MAP_OUTPUT_SCHEMA = org . apache . sqoop . mapreduce . AvroJob . MAP_OUTPUT_SCHEMA ; private AvroJob ( ) { } public static void setMapOutputSchema ( Configuration job , Schema s ) { org . apache . sqoop . mapreduce . AvroJob . setMapOutputSchema (", "gt": "job , s ) ;", "prediction": "job , s ) ;\n", "label": 1}
{"id": 451, "input": "<s> package javax . tools ; import java . io . File ; import java . lang . ref . Reference ; import java . lang . ref . WeakReference ; import java . net . URL ; import java . net . URLClassLoader ; import java . net . MalformedURLException ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . logging . Logger ; import java . util . logging . Level ; import static java . util . logging . Level . * ; public class ToolProvider { private static final String propertyName = \"sun.tools.ToolProvider\" ; private static final String loggerName = \"javax.tools\" ; static < T > T trace ( Level level , Object reason ) { try { if ( System . getProperty ( propertyName ) != null ) { StackTraceElement [ ] st = Thread . currentThread ( ) . getStackTrace ( ) ; String method = \"???\" ; String cls = ToolProvider . class . getName ( ) ; if ( st . length > 2 ) { StackTraceElement frame = st [ 2 ] ; method = String . format ( ( Locale ) null , \"%s(%s:%s)\" , frame . getMethodName ( ) , frame . getFileName ( ) , frame . getLineNumber ( ) ) ; cls = frame . getClassName ( ) ; } Logger logger = Logger . getLogger ( loggerName ) ; if ( reason instanceof Throwable ) { logger . logp ( level , cls , method , reason . getClass ( ) . getName ( ) , ( Throwable ) reason ) ; } else { logger . logp ( level , cls , method , String . valueOf ( reason ) ) ; } } } catch ( SecurityException ex ) { System . err . format ( ( Locale ) null , \"%s: %s; %s%n\" , ToolProvider . class . getName ( ) , reason , ex . getLocalizedMessage ( ) ) ; } return null ; } private static final String defaultJavaCompilerName = \"com.sun.tools.javac.api.JavacTool\" ; public static JavaCompiler getSystemJavaCompiler ( ) { return instance ( ) . getSystemTool ( JavaCompiler . class , defaultJavaCompilerName ) ; } public static ClassLoader getSystemToolClassLoader ( ) { try { Class < ? extends JavaCompiler > c = instance ( ) . getSystemToolClass ( JavaCompiler . class , defaultJavaCompilerName ) ; return c . getClassLoader ( ) ; } catch ( Throwable e ) { return trace ( WARNING , e ) ; } } private static ToolProvider instance ; private static synchronized ToolProvider instance ( ) { if ( instance == null ) instance = new ToolProvider ( ) ; return instance ; } private Map < String , Reference < Class < ? > > > toolClasses = new HashMap < String , Reference < Class < ? > > > ( ) ; private Reference < ClassLoader > refToolClassLoader = null ; private ToolProvider ( ) { } private < T > T getSystemTool ( Class < T > clazz , String name ) { Class < ? extends T > c = getSystemToolClass ( clazz , name ) ; try { return c . asSubclass ( clazz ) . newInstance ( ) ; } catch ( Throwable e ) { trace ( WARNING , e ) ; return null ; } } private < T > Class < ? extends T > getSystemToolClass ( Class < T > clazz , String name ) { Reference < Class < ? > > refClass = toolClasses . get ( name ) ; Class < ? > c = ( refClass == null ? null : refClass . get ( ) ) ; if ( c == null ) { try { c = findSystemToolClass ( name ) ; } catch ( Throwable e ) { return trace ( WARNING , e ) ; } toolClasses . put ( name , new WeakReference < Class < ? > > ( c ) ) ; } return c . asSubclass ( clazz ) ; } private static final String [ ] defaultToolsLocation = { \"lib\" , \"tools.jar\" } ; private Class < ? > findSystemToolClass ( String toolClassName ) throws MalformedURLException , ClassNotFoundException { try { return Class . forName ( toolClassName , false , null ) ; } catch ( ClassNotFoundException e ) { trace ( FINE , e ) ; ClassLoader cl = ( refToolClassLoader == null ? null : refToolClassLoader . get ( ) ) ; if ( cl == null ) { File file = new File ( System . getProperty ( \"java.home\" ) ) ; if ( file . getName ( ) . equalsIgnoreCase ( \"jre\" ) ) file = file . getParentFile ( ) ; for ( String name : defaultToolsLocation ) file = new File ( file , name ) ; if ( ! file . exists ( ) ) throw e ; URL [ ] urls = { file . toURI ( )", "gt": ". toURL ( ) }", "prediction": "}\n", "label": 0}
{"id": 14836, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . benchmark . byTask . PerfRunData ; public class SetPropTask extends PerfTask { public SetPropTask ( PerfRunData runData ) { super ( runData ) ; } private String name ; private String value ; public int doLogic ( ) throws Exception { if ( name == null || value == null ) { throw new Exception ( getName ( ) + \" - undefined name or value: name=\" + name + \" value=\" + value ) ; } getRunData ( ) . getConfig ( ) . set ( name , value ) ; return 0 ; } public void setParams ( String params ) { super . setParams ( params ) ;", "gt": "int k = params . indexOf ( \",\" ) ;", "prediction": "}\n", "label": 1}
{"id": 2512, "input": "<s> package org . ofbiz . shipment . packing ; import java . math . BigDecimal ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . Debug ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; @ SuppressWarnings ( \"serial\" ) public class PackingSessionLine implements java . io . Serializable { public final String module = PackingSessionLine . class . getName ( ) ; protected String orderId = null ; protected String orderItemSeqId = null ; protected String shipGroupSeqId = null ; protected String productId = null ; protected String inventoryItemId = null ; protected String shipmentItemSeqId = null ; protected BigDecimal quantity = BigDecimal . ZERO ; protected BigDecimal weight = BigDecimal . ZERO ; protected BigDecimal height = null ; protected BigDecimal width = null ; protected BigDecimal length = null ; protected String shipmentBoxTypeId = null ; protected String weightPackageSeqId = null ; protected int packageSeq = 0 ; public PackingSessionLine ( String orderId , String orderItemSeqId , String shipGroupSeqId , String productId , String inventoryItemId , BigDecimal quantity , BigDecimal weight , int packageSeq ) { this . orderId = orderId ; this . orderItemSeqId = orderItemSeqId ; this . shipGroupSeqId = shipGroupSeqId ; this . inventoryItemId = inventoryItemId ; this . productId = productId ; this . quantity = quantity ; this . weight = weight ; this . height = null ; this . width = null ; this . length = null ; this . shipmentBoxTypeId = null ; this . weightPackageSeqId = null ; this . packageSeq = packageSeq ; } public String getOrderId ( ) { return this . orderId ; } public String getOrderItemSeqId ( ) { return this . orderItemSeqId ; } public String getShipGroupSeqId ( ) { return this . shipGroupSeqId ; } public String getInventoryItemId ( ) { return this . inventoryItemId ; } public String getProductId ( ) { return this . productId ; } public String getShipmentItemSeqId ( ) { return this . shipmentItemSeqId ; } public void setShipmentItemSeqId ( String shipmentItemSeqId ) { this . shipmentItemSeqId = shipmentItemSeqId ; } public BigDecimal getQuantity ( ) { return this . quantity ; } public void setQuantity ( BigDecimal quantity ) { this . quantity = quantity ; } public void addQuantity ( BigDecimal quantity ) { this . quantity = this . quantity . add ( quantity ) ; } public BigDecimal getWeight ( ) { return weight ; } public void setWeight ( BigDecimal weight ) { this . weight = weight ; } public void addWeight ( BigDecimal weight ) { this . weight = this . weight .", "gt": "add ( weight ) ;", "prediction": "add ( weight ) ;\n", "label": 0}
{"id": 14839, "input": "<s> package org . jscsi", "gt": ". parser . tmf ;", "prediction": ". scsi . protocol ;\n", "label": 1}
{"id": 9574, "input": "<s> import java . util . List ; class T6369605b { static < T extends List < X > , X > List < T > m1 ( ) { return null ; } static < T extends List < U > , U extends List < X > , X > List < T > m2 ( ) { return null ; } static < T extends List < U > , U extends List < V > , V extends List < X > , X > List < T > m3 ( ) { return null ; } List < ? > l1 = m1 ( ) ; List < ? > l2 = m2 ( ) ; List <", "gt": "? > l3 = m3 ( ) ;", "prediction": "? > l3 = m3 ( ) ;\n", "label": 0}
{"id": 14842, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . Parameter ; public class BooleanClause implements java . io . Serializable { public static final class Occur extends Parameter implements java . io . Serializable { private Occur ( String name ) { super ( name ) ; } public String toString ( ) { if ( this == MUST ) return \"+\" ; if ( this == MUST_NOT ) return \"-\" ; return \"\" ; } public static final Occur MUST = new Occur ( \"MUST\" ) ; public static final Occur SHOULD = new Occur ( \"SHOULD\" ) ; public static final Occur MUST_NOT = new Occur ( \"MUST_NOT\" ) ; } private Query query ; private Occur occur ; public BooleanClause ( Query query , Occur occur ) { this . query = query ; this . occur = occur ; } public Occur getOccur ( ) { return occur ; } public void setOccur ( Occur occur ) { this . occur = occur ; } public Query getQuery ( ) { return query ; } public void setQuery ( Query query ) { this . query = query ; } public boolean isProhibited ( ) { return Occur . MUST_NOT . equals ( occur ) ; } public boolean isRequired ( ) { return Occur . MUST . equals ( occur ) ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof BooleanClause", "gt": ") ) return false ;", "prediction": ") )\n", "label": 1}
{"id": 6908, "input": "<s> package fr . telecom . scrapbook . filters ; import android . graphics . Color ; import android . graphics . Paint ; public class NeonFilter implements IImageFilter { public Image process ( Image imageIn ) { int width = imageIn . getWidth ( ) ; int height = imageIn . getHeight ( ) ; boolean [ ] [ ] mask = null ; Paint grayMatrix [ ] = new Paint [ 256 ] ; int outlineCase = 1 ; double rand = Math . random ( ) ; if ( rand > 0.33 && rand < 0.66 ) { outlineCase = 2 ; } else if ( rand > 0.66 ) { outlineCase = 3 ; } for ( int i = 255 ; i >= 0 ; i -- ) { Paint p = new Paint ( ) ; int red = i , green = i , blue = i ; if ( i > 127 ) { switch ( outlineCase ) { case 1 : red = 255 - i ; break ; case 2 : green = 255 - i ; break ; case 3 : blue = 255 - i ; break ; } } p . setColor ( Color . rgb ( red , green , blue ) ) ; grayMatrix [ 255 - i ] = p ; } int [ ] [ ] luminance = new int [ width ] [ height ] ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { if ( mask != null && ! mask [ x ] [ y ] ) { continue ; } luminance [ x ] [ y ] = ( int ) luminance ( imageIn . getRComponent ( x , y ) , imageIn . getGComponent ( x , y ) , imageIn . getBComponent ( x , y ) ) ; } } int grayX , grayY ; int magnitude ; for ( int y = 1 ; y < height - 1 ; y ++ ) { for ( int x = 1 ; x < width - 1 ; x ++ ) { if ( mask != null && ! mask [ x ] [ y ] ) { continue ; } grayX = - luminance [ x - 1 ] [ y - 1 ] + luminance [ x - 1 ] [ y - 1 + 2 ] - 2 * luminance [ x - 1 + 1 ] [ y - 1 ] + 2 * luminance [ x - 1 + 1 ] [ y - 1 + 2 ] - luminance [ x - 1 + 2 ] [ y - 1 ] + luminance [ x - 1 + 2 ] [ y - 1 + 2 ] ; grayY = luminance [ x - 1 ] [ y - 1 ] + 2 * luminance [ x - 1 ] [ y - 1 + 1 ] + luminance [ x - 1 ] [ y - 1 + 2 ] - luminance [ x - 1 + 2 ] [ y - 1 ] - 2 * luminance [ x - 1 + 2 ] [ y - 1 + 1 ] - luminance [ x - 1 + 2 ] [ y - 1 + 2 ] ; magnitude = 255 - truncate ( Math . abs ( grayX ) + Math . abs ( grayY ) ) ; Paint grayscaleColor = grayMatrix [ magnitude ] ; imageIn . setPixelColor ( x , y , grayscaleColor . getColor ( ) ) ; } } return imageIn ; } private int truncate ( int a ) { if ( a < 0 ) return 0 ; else if ( a > 255 ) return 255 ; else return a ; } private int luminance ( int r , int g , int b ) { return ( int ) ( ( 0.299 * r ) + ( 0.58 * g ) + (", "gt": "0.11 * b ) ) ;", "prediction": "0.58 * b ) ) ;\n", "label": 0}
{"id": 14854, "input": "<s> package org . restlet . engine . io ; import java . io . IOException ; import java . nio . channels . Channel ; public class WrapperChannel < T extends Channel > implements Channel { private T wrappedChannel ; public WrapperChannel ( T wrappedChannel ) { this . wrappedChannel = wrappedChannel ; } public void close ( ) throws IOException {", "gt": "getWrappedChannel ( ) . close ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8938, "input": "<s> public class MWCRand { public static void init ( int x ) { int i ; Q [ 0 ] = x ; Q [ 1 ] = x + phi ; Q [ 2 ] = x + phi + phi ; for ( i = 3 ; i < 4096 ; i ++ ) { Q [ i ] = Q [ i - 3 ] ^ Q [ i - 2 ] ^ phi ^ i ; } } public static void init ( int x , int c , int phi ) { MWCRand . c = c ; MWCRand . phi = phi ; int i ; Q [ 0 ] = x ; Q [ 1 ] = x + phi ; Q [ 2 ] = x + phi + phi ; for ( i = 3 ; i < 4096 ; i ++ ) { Q [ i ] = Q [ i - 3 ] ^ Q [ i - 2 ] ^ phi ^ i ; } } public static int rand ( ) { long t , a = 18782L ; int i = 4095 ; int x , r = 0xfffffffe ; i = ( i + 1 ) & 4095 ;", "gt": "t = a * Q [ i ] + c ;", "prediction": "for ( i = 0 ;\n", "label": 0}
{"id": 14857, "input": "<s> package org . apache . lucene . search . similar ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . similar . MoreLikeThis ; public class MoreLikeThisQuery extends Query { private String likeText ; private String [ ] moreLikeFields ; private Analyzer analyzer ; float percentTermsToMatch = 0.3f ; int minTermFrequency = 1 ; int maxQueryTerms = 5 ; Set stopWords = null ; int minDocFreq = - 1 ; public MoreLikeThisQuery ( String likeText , String [ ] moreLikeFields , Analyzer analyzer ) { this . likeText = likeText ; this . moreLikeFields = moreLikeFields ; this . analyzer = analyzer ; } public Query rewrite ( IndexReader reader ) throws IOException { MoreLikeThis mlt = new MoreLikeThis ( reader ) ; mlt . setFieldNames ( moreLikeFields ) ; mlt . setAnalyzer ( analyzer ) ; mlt . setMinTermFreq ( minTermFrequency ) ; if ( minDocFreq >= 0 ) { mlt . setMinDocFreq ( minDocFreq ) ; } mlt . setMaxQueryTerms ( maxQueryTerms ) ; mlt . setStopWords ( stopWords ) ; BooleanQuery bq = ( BooleanQuery ) mlt . like ( new ByteArrayInputStream ( likeText . getBytes ( ) ) ) ; BooleanClause [ ] clauses = bq . getClauses ( ) ; bq . setMinimumNumberShouldMatch ( ( int ) ( clauses . length * percentTermsToMatch ) ) ; return bq ; } public String toString ( String field ) { return \"like:\" + likeText ; } public float getPercentTermsToMatch ( ) { return percentTermsToMatch ; } public void setPercentTermsToMatch ( float percentTermsToMatch ) { this . percentTermsToMatch = percentTermsToMatch ; } public Analyzer getAnalyzer ( ) { return analyzer ; } public void setAnalyzer ( Analyzer analyzer ) {", "gt": "this . analyzer = analyzer ;", "prediction": "this . analyzer = analyzer ;\n", "label": 1}
{"id": 1028, "input": "<s> package org . dawnsci . rcp . functions . classes ; import org . dawnsci . rcp . functions . ITransferFunctionArrayProvider ; public class LinearTransferFunction implements ITransferFunctionArrayProvider { public LinearTransferFunction ( ) { } @ Override public int [ ] getArray ( ) { int [ ] result = new int [ 256 ] ; for ( int i = 0 ;", "gt": "i < result . length ;", "prediction": "i < 256 ;\n", "label": 0}
{"id": 14862, "input": "<s> package fr . inria . zvtm . lens ; import java . awt . image . DataBuffer ; import java . awt . image . SinglePixelPackedSampleModel ; import java . awt . image . WritableRaster ; public class XLinearLens extends BLinearLens { int [ ] tmPixelsI , toPixelsI ; short [ ] tmPixelsS , toPixelsS ; byte [ ] tmPixelsB , toPixelsB ; protected double a = 0 ; protected double b = 0 ; double dd = 0 ; public XLinearLens ( ) { this ( 2.0f , 0 , 1 , 100 , 50 , 0 , 0 ) ; } public XLinearLens ( float mm ) { this ( mm , 0 , 1 , 100 , 50 , 0 , 0 ) ; } public XLinearLens ( float mm , float tc , float tf , int outerRadius , int innerRadius ) { this ( mm , tc , tf , outerRadius , innerRadius , 0 , 0 ) ; } public XLinearLens ( float mm , float tc , float tf , int outerRadius , int innerRadius , int x , int y ) { super ( mm , tc , tf , outerRadius , innerRadius , x , y ) ; a = ( 1 - MM ) / ( float ) ( LR1 - LR2 ) ; b = ( MM * LR1 - LR2 ) / ( float ) ( LR1 - LR2 ) ; } void initBuffers ( int mainBufferSize , int magBufferSize ) { switch ( transferType ) { case DataBuffer . TYPE_INT : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; tmPixelsI = new int [ mainBufferSize ] ; toPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_USHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; tmPixelsS = new short [ mainBufferSize ] ; toPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_BYTE : { oPixelsB = new byte [ mainBufferSize ] ; mPixelsB = new byte [ magBufferSize ] ; tPixelsB = new byte [ mainBufferSize ] ; tmPixelsB = new byte [ mainBufferSize ] ; toPixelsB = new byte [ mainBufferSize ] ; initialized = true ; break ; } case DataBuffer . TYPE_SHORT : { oPixelsS = new short [ mainBufferSize ] ; mPixelsS = new short [ magBufferSize ] ; tPixelsS = new short [ mainBufferSize ] ; tmPixelsS = new short [ mainBufferSize ] ; toPixelsS = new short [ mainBufferSize ] ; initialized = true ; break ; } default : { oPixelsI = new int [ mainBufferSize ] ; mPixelsI = new int [ magBufferSize ] ; tPixelsI = new int [ mainBufferSize ] ; tmPixelsI = new int [ mainBufferSize ] ; toPixelsI = new int [ mainBufferSize ] ; initialized = true ; break ; } } } public void gf ( float x , float y , float [ ] g ) { dd = Math . sqrt ( Math . pow ( x - sw - lx , 2 ) + Math . pow ( y - sh - ly , 2 ) ) ; if ( dd <= LR2 ) g [ 0 ] = g [ 1 ] = MM ; else if ( dd <= LR1 ) g [ 0 ] = g [ 1 ] = ( float ) ( a * ( float ) dd + b ) ; else g [ 0 ] = g [ 1 ] = 1 ; } void computeDropoffFactors ( ) { aT = ( MMTc - MMTf ) / ( ( float ) ( LR1 - LR2 ) ) ; bT = ( MMTf * LR1 - MMTc * LR2 ) / ( ( float ) ( LR1 - LR2 ) ) ; a = ( 1 - MM ) / ( float ) ( LR1 - LR2 ) ; b = ( MM * LR1 - LR2 ) / ( float ) ( LR1 - LR2 ) ; } int ti ; synchronized void transformI ( WritableRaster iwr , WritableRaster ewr ) { synchronized ( this ) { if ( BMl == null ) { SinglePixelPackedSampleModel SMl = ( SinglePixelPackedSampleModel ) ewr . getSampleModel ( ) ; SinglePixelPackedSampleModel SMm = ( SinglePixelPackedSampleModel ) iwr . getSampleModel ( ) ; BMl = SMl . getBitMasks ( ) ; BMm = SMm . getBitMasks ( ) ; BOl = SMl . getBitOffsets ( ) ; BOm = SMm . getBitOffsets ( ) ; } iwr . getDataElements ( lurd [ 0 ] , lurd [ 1 ] , lensWidth , lensHeight , oPixelsI ) ; ewr . getDataElements ( 0 , 0 , mbw , mbh , mPixelsI ) ; if ( BMl . length == 4 ) { for ( int x = lurd [ 0 ] ; x < lurd [ 2 ] ; x ++ ) { for ( int y = lurd [ 1 ] ; y < lurd [ 3 ] ; y ++ ) { this . gf ( x , y , gain ) ; ti = ( y - lurd [ 1 ] ) * ( lensWidth ) + ( x - lurd [ 0 ] ) ; tmPixelsI [ ti ] = mPixelsI [ Math . round ( ( ( y - lurd [ 1 ] ) * MM - hmbh ) / gain [ 1 ] + hmbh ) * mbw + Math . round ( ( ( x - lurd [ 0 ] ) * MM - hmbw ) / gain [ 0 ] + hmbw ) ] ; toPixelsI [ ti ] = oPixelsI [ ( Math . round ( ( ( ( float ) y - sh - ly ) / gain [ 1 ] ) + sh + ly ) - lurd [ 1 ] ) * ( lensWidth ) + ( Math . round ( ( ( ( float ) x - sw - lx ) / gain [ 0 ] ) + sw + lx ) - lurd [ 0 ] ) ] ; Pl = tmPixelsI [ ti ] ; Rl = ( Pl & BMl [ 0 ] ) > > > BOl [ 0 ] ; Gl = ( Pl & BMl [ 1 ] ) > > > BOl [ 1 ] ; Bl = ( Pl & BMl [ 2 ] ) > > > BOl [ 2 ] ; Pm = toPixelsI [ ti ] ; Rm = ( Pm & BMm [ 0", "gt": "] ) > > > BOm [ 0 ] ;", "prediction": "] ) > > > BOm [ 0 ] ;\n", "label": 1}
{"id": 6496, "input": "<s> class A { public static final int i = 42 ; public static final boolean b = true ; public static final float f = 1.0f ; public static final double d = 1.0d ; public static final short s = 1 ; public static final long l = 1l ; public static final char cA = 'A' ; public static final char c0 = '\u0000' ; public", "gt": "static final char cn = '\\n' ;", "prediction": "static final char c1 = 'A' ;\n", "label": 0}
{"id": 14869, "input": "<s> package com . cloudera . sqoop . mapreduce ; import java . io . IOException ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . mapreduce . InputFormat ; import org . apache . hadoop . mapreduce . Mapper ; import org . apache . hadoop . mapreduce . OutputFormat ; import com . cloudera . sqoop . manager . ExportJobContext ; public class ExportJobBase extends org . apache . sqoop . mapreduce . ExportJobBase { public static final String SQOOP_EXPORT_TABLE_CLASS_KEY = org . apache . sqoop . mapreduce . ExportJobBase . SQOOP_EXPORT_TABLE_CLASS_KEY ; public static final String SQOOP_EXPORT_UPDATE_COL_KEY = org . apache . sqoop . mapreduce . ExportJobBase . SQOOP_EXPORT_UPDATE_COL_KEY ; public static final String EXPORT_MAP_TASKS_KEY = org . apache . sqoop . mapreduce . ExportJobBase . EXPORT_MAP_TASKS_KEY ;", "gt": "public ExportJobBase ( final ExportJobContext ctxt )", "prediction": "}\n", "label": 1}
{"id": 6115, "input": "<s> package com . farpost . ldt ; import java . util . Arrays ; import static java . lang . Math . pow ; import static java . lang . Math . sqrt ; import static java . util . Arrays . sort ; public class Utils { public static double calculateStdDev ( long [ ] [ ] numbers ) { long sum = 0 ; long mean = 0 ; int count = 0 ; for ( long [ ] row : numbers ) { count += row . length ; for ( long number : row ) { sum += number ; mean += pow ( number , 2 ) ; } } double avarage = sum / count ; return sqrt ( mean / count - pow ( avarage , 2 ) ) ; } public static long percentile ( long [", "gt": "] vector , double fraction )", "prediction": "] rows )\n", "label": 0}
{"id": 14870, "input": "<s> package org . restlet . ext . jaxrs . internal . wrappers . provider ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Type ; import java . util . Collections ; import java . util . List ; import javax . ws . rs . Consumes ; import javax . ws . rs . Produces ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . ext . ExceptionMapper ; import javax . ws . rs . ext . Providers ; import org . restlet . data . MediaType ; import org . restlet . ext . jaxrs . internal . core . ThreadLocalizedContext ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalBeanSetterTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalFieldTypeException ; import org . restlet . ext . jaxrs . internal . exceptions . InjectException ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . Util ; import org . restlet . ext . jaxrs . internal . wrappers . WrapperUtil ; import org . restlet . ext . jaxrs . internal . wrappers . params . ContextInjector ; abstract class AbstractProviderWrapper implements ProviderWrapper { private final List < org . restlet . data . MediaType > consumedMimes ; private final List < org . restlet . data . MediaType > producedMimes ; private final Class < ? > genericMbrType ; private final Class < ? > genericMbwType ; AbstractProviderWrapper ( Class < ? > jaxRsProviderClass ) throws IllegalArgumentException , WebApplicationException { final Consumes pm = jaxRsProviderClass . getAnnotation ( Consumes . class ) ; if ( pm != null ) { this . consumedMimes = WrapperUtil . convertToMediaTypes ( pm . value ( ) ) ; } else { this . consumedMimes = Collections . singletonList ( MediaType . ALL ) ; } final Produces cm = jaxRsProviderClass . getAnnotation ( Produces . class ) ; if ( cm != null ) { this . producedMimes = WrapperUtil . convertToMediaTypes ( cm . value ( ) ) ; } else { this . producedMimes = Collections . singletonList ( MediaType . ALL ) ; } this . genericMbrType = Util . getGenericClass ( jaxRsProviderClass , javax . ws . rs . ext . MessageBodyReader . class ) ; this . genericMbwType = Util . getGenericClass ( jaxRsProviderClass , javax . ws . rs . ext . MessageBodyWriter . class ) ; } @ Override public abstract boolean equals ( Object otherProvider ) ; public abstract String getClassName ( ) ; public List < MediaType > getConsumedMimes ( ) { return this . consumedMimes ; } public List < MediaType > getProducedMimes ( ) { return this . producedMimes ; } @ Override public abstract int hashCode ( ) ; void initProvider ( Object jaxRsProvider , ThreadLocalizedContext tlContext , Providers allProviders , ExtensionBackwardMapping", "gt": "extensionBackwardMapping ) throws IllegalFieldTypeException , IllegalBeanSetterTypeException , InjectException , InvocationTargetException", "prediction": "extensionBackwardMapping )\n", "label": 1}
{"id": 1102, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . Arrow ; public interface LizaArrow extends Arrow { List < LizaEntity > getNearbyLizaEntities ( double", "gt": "x , double y , double z ) ;", "prediction": "distance ) ;\n", "label": 0}
{"id": 14875, "input": "<s> package org . apache . lucene . demo . html ; public class ParseException extends Exception { public ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( \"\" ) ; specialConstructor = true ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; } public ParseException ( ) { super ( ) ; specialConstructor = false ; } public ParseException ( String message ) { super ( message ) ; specialConstructor = false ; } protected boolean specialConstructor ; public Token currentToken ; public int [ ] [ ] expectedTokenSequences ; public String [ ] tokenImage ; public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } StringBuffer expected = new StringBuffer ( ) ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( \" \" ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( \"...\" ) ; } expected . append ( eol ) . append ( \"    \" ) ; } String retval = \"Encountered \\\"\" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += \" \" ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += \"\\\" at line \" + currentToken . next . beginLine + \", column \" + currentToken . next . beginColumn ; retval += \".\" + eol ; if ( expectedTokenSequences . length == 1 ) { retval += \"Was expecting:\" + eol + \"    \" ; } else { retval += \"Was expecting one of:\" + eol + \"    \" ; } retval += expected . toString ( ) ; return retval ; } protected String eol = System . getProperty ( \"line.separator\" , \"\\n\" ) ; protected String", "gt": "add_escapes ( String str )", "prediction": "tok = currentToken . next ;\n", "label": 1}
{"id": 7696, "input": "<s> import java . util . Iterator ; class Test { < T > void test ( ) { new Iterable < T > ( ) { public Iterator <", "gt": "T > iterator ( )", "prediction": "T > ( )\n", "label": 0}
{"id": 14876, "input": "<s> package org . restlet . ext . sip . internal ; public final class SipConstants { public static final String HEADER_ALERT_INFO = \"Alert-Info\" ; public static final String HEADER_ALLOW_EVENTS = \"Allow-Events\" ; public static final String HEADER_CALL_ID = \"Call-ID\" ; public static final String HEADER_CALL_INFO = \"Call-Info\" ; public static final String HEADER_CALL_SEQ = \"CSeq\" ; public static final String HEADER_CONTACT = \"Contact\" ; public static final String HEADER_ENCRYPTION = \"Encryption\" ; public static final String HEADER_ERROR_INFO = \"Error-Info\" ; public static final String HEADER_EVENT = \"Event\" ; public static final String HEADER_IN_REPLY_TO = \"In-Reply-To\" ; public static final String HEADER_MIME_VERSION = \"MIME-Version\" ; public static final String HEADER_MIN_EXPIRES = \"Min-Expires\" ; public static final String HEADER_ORGANIZATION = \"Organization\" ; public static final String HEADER_PRIORITY = \"Priority\" ; public static final String HEADER_PROXY_REQUIRE = \"Proxy-Require\" ; public static final String HEADER_RECORD_ROUTE = \"Record-Route\" ; public static final String HEADER_REFER_TO = \"Refer-To\" ; public static final String HEADER_REPLY_TO = \"Reply-To\" ; public static final String HEADER_REQUIRE = \"Require\" ; public static final String HEADER_RETRY_AFTER = \"Retry-After\" ; public static final String HEADER_ROUTE = \"Route\" ; public static final String HEADER_RSEQ = \"RSeq\" ; public static final String HEADER_SERVER = \"Server\" ; public static final", "gt": "String HEADER_SIP_ETAG = \"SIP-ETag\" ;", "prediction": "String HEADER_SERVER_REQUEST = \"Request\" ;\n", "label": 1}
{"id": 3598, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . LimitsAttribute ; import org . jjflyboy", "gt": ". tjpeditor . project . ProjectPackage ;", "prediction": ". tjpeditor . project . Test ;\n", "label": 0}
{"id": 14878, "input": "<s> package org . apache . batik . svggen . font . table ; public interface Table { public static final int BASE = 0x42415345 ; public static final int CFF = 0x43464620 ; public static final int DSIG = 0x44534947 ; public static final int EBDT = 0x45424454 ; public static final int EBLC = 0x45424c43 ; public static final int EBSC = 0x45425343 ; public static final int GDEF = 0x47444546 ; public static final int GPOS = 0x47504f53 ; public static final int GSUB = 0x47535542 ; public static final int JSTF = 0x4a535446 ; public static final int LTSH = 0x4c545348 ; public static final int MMFX = 0x4d4d4658 ; public static final int MMSD = 0x4d4d5344 ; public static final int OS_2 = 0x4f532f32 ; public static final int PCLT = 0x50434c54 ; public static final int VDMX = 0x56444d58 ; public static final int cmap = 0x636d6170 ; public static final int cvt = 0x63767420 ; public static final int fpgm = 0x6670676d ; public static final int fvar = 0x66766172 ; public static final int gasp = 0x67617370 ; public static final int glyf = 0x676c7966 ; public static final int hdmx = 0x68646d78 ; public static final int head = 0x68656164 ; public static final int hhea = 0x68686561 ; public static final int hmtx = 0x686d7478 ; public static final int kern = 0x6b65726e ; public static final int loca = 0x6c6f6361 ; public static final int maxp = 0x6d617870 ; public static final int name = 0x6e616d65 ; public static final int prep = 0x70726570 ; public static final int post = 0x706f7374 ; public static final int vhea = 0x76686561 ; public static final int vmtx = 0x766d7478 ; public static final short platformAppleUnicode = 0 ; public static final short platformMacintosh = 1 ; public static final short platformISO = 2 ; public static final short platformMicrosoft = 3 ; public static final short encodingUndefined = 0 ; public static final short encodingUGL = 1 ; public static final short encodingRoman = 0 ; public static final short encodingJapanese = 1 ; public static final short encodingChinese = 2 ; public static final short encodingKorean = 3 ; public static final short encodingArabic = 4 ; public static final short encodingHebrew = 5 ; public static final short encodingGreek = 6 ; public static final short encodingRussian = 7 ; public static final short encodingRSymbol = 8 ; public static final short encodingDevanagari = 9 ; public static final short encodingGurmukhi = 10 ; public static final short encodingGujarati = 11 ; public static final short encodingOriya = 12 ; public static final short encodingBengali = 13 ; public static final short encodingTamil = 14 ; public static final short encodingTelugu = 15 ; public static final short encodingKannada = 16 ; public static final short encodingMalayalam = 17 ; public static final short encodingSinhalese = 18 ; public static final short encodingBurmese = 19 ; public static final", "gt": "short encodingKhmer = 20 ;", "prediction": "short encodingTamil = 20 ;\n", "label": 1}
{"id": 9964, "input": "<s> package org . ofbiz . entity . transaction ; import java . sql . Connection ; import java . sql . SQLException ; import javax . transaction . TransactionManager ; import javax . transaction . UserTransaction ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . config . EntityConfigUtil ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . CursorConnection ; public class TransactionFactory { public static final String module = TransactionFactory . class . getName ( ) ; public static TransactionFactoryInterface transactionFactory = null ; public static TransactionFactoryInterface getTransactionFactory ( ) { if ( transactionFactory == null ) { synchronized ( TransactionFactory . class ) { if ( transactionFactory == null ) { try { String className = EntityConfigUtil . getTxFactoryClass ( ) ; if ( className == null ) { throw new IllegalStateException ( \"Could not find transaction factory class name definition\" ) ; } Class < ? > tfClass = null ; if ( UtilValidate . isNotEmpty ( className ) ) { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; tfClass = loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } } try { transactionFactory = ( TransactionFactoryInterface ) tfClass . newInstance ( ) ; } catch ( IllegalAccessException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } catch ( InstantiationException e ) { Debug . logWarning ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class \\\"\" + className + \"\\\": \" + e . getMessage ( ) ) ; } } catch ( SecurityException e ) { Debug . logError ( e , module ) ; throw new IllegalStateException ( \"Error loading TransactionFactory class: \" + e . getMessage ( ) ) ; } } } } return transactionFactory ; } public static TransactionManager getTransactionManager ( ) { return getTransactionFactory ( ) . getTransactionManager ( ) ; } public static UserTransaction getUserTransaction ( ) { return getTransactionFactory ( ) . getUserTransaction ( ) ; } public static String getTxMgrName ( ) { return getTransactionFactory ( ) . getTxMgrName ( ) ; } public static Connection", "gt": "getConnection ( GenericHelperInfo helperInfo ) throws SQLException , GenericEntityException", "prediction": "getConnection ( )\n", "label": 0}
{"id": 14880, "input": "<s> package org . apache . lucene . spatial . tier ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . apache . lucene . search . Filter ; import org . apache . lucene . spatial . geometry . shape . Rectangle ; import org . apache . lucene . spatial . tier . projections . CartesianTierPlotter ; import org . apache . lucene . spatial . tier . projections . IProjector ; import org . apache . lucene . spatial . tier . projections . SinusoidalProjector ; public class CartesianPolyFilterBuilder { public static final double MILES_FLOOR = 1.0 ; private IProjector projector = new SinusoidalProjector ( ) ; private Logger log = Logger . getLogger ( getClass ( ) . getName ( ) ) ; private final String tierPrefix ; public CartesianPolyFilterBuilder ( String tierPrefix ) { this . tierPrefix = tierPrefix ; } public Shape getBoxShape ( double latitude , double longitude , double miles ) { if ( miles < MILES_FLOOR ) { miles = MILES_FLOOR ; } Rectangle box = DistanceUtils . getInstance ( ) . getBoundary ( latitude , longitude , miles ) ; double latY = box . getMaxPoint ( ) . getY ( ) ; double latX = box . getMinPoint ( ) . getY ( ) ; double longY = box . getMaxPoint ( ) . getX ( ) ; double longX = box . getMinPoint ( ) . getX ( ) ; CartesianTierPlotter ctp = new CartesianTierPlotter ( 2 , projector , tierPrefix ) ; int bestFit = ctp . bestFit ( miles ) ; log . info ( \"Best Fit is : \" + bestFit ) ; ctp = new CartesianTierPlotter ( bestFit , projector , tierPrefix ) ; Shape shape = new Shape ( ctp . getTierFieldName ( ) ) ; double beginAt = ctp . getTierBoxId ( latX , longX ) ; double endAt = ctp . getTierBoxId ( latY , longY ) ; double tierVert = ctp . getTierVerticalPosDivider ( ) ; log . fine ( \" | \" + beginAt + \" | \" + endAt ) ; double startX = beginAt - ( beginAt % 1 ) ; double startY = beginAt - startX ; double endX = endAt - ( endAt % 1 ) ; double endY = endAt - endX ; int scale = ( int ) Math . log10 ( tierVert ) ; endY = new BigDecimal ( endY ) . setScale ( scale , RoundingMode . HALF_EVEN ) . doubleValue ( ) ; startY = new BigDecimal ( startY ) . setScale ( scale , RoundingMode . HALF_EVEN ) . doubleValue ( ) ; if ( log . isLoggable ( Level . FINE ) ) { log . fine ( \"scale \" + scale + \" startX \" + startX + \" endX \" + endX + \" startY \" + startY + \" endY \" + endY + \" tierVert \" + tierVert ) ; }", "gt": "double xInc = 1.0d / tierVert ;", "prediction": "else\n", "label": 1}
{"id": 2342, "input": "<s> package org . meqantt . message ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class RetryableMessage extends Message { private int messageId ; public RetryableMessage ( Header header ) throws IOException { super ( header ) ; } public RetryableMessage ( Type type ) { super ( type ) ; } @ Override protected int messageLength ( ) { return 2 ; } @ Override protected void writeMessage ( OutputStream out ) throws IOException { int id = getMessageId ( ) ; int lsb = id & 0xFF ; int msb = ( id & 0xFF00 ) > > 8 ; out . write ( msb ) ; out . write ( lsb ) ; } @ Override protected void readMessage ( InputStream in , int msgLength ) throws IOException { int msgId = in . read", "gt": "( ) * 0xFF + in . read ( ) ;", "prediction": "( msgLength ) ;\n", "label": 0}
{"id": 14883, "input": "<s> package org . restlet . ext . sip . internal ; import java . util . logging . Level ; import org . restlet . Response ; import org . restlet . engine . connector . ClientOutboundWay ; import org . restlet . engine . connector . Connection ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . TagWriter ; import org . restlet . engine . io . IoState ; import org . restlet . ext . sip . SipRecipientInfo ; import org . restlet . ext . sip . SipRequest ; import org . restlet . ext . sip . SipResponse ; import org . restlet . util . Series ; public class SipClientOutboundWay extends ClientOutboundWay { public SipClientOutboundWay ( Connection < ? > connection , int bufferSize ) { super ( connection , bufferSize ) ; } @ Override protected void addGeneralHeaders ( Series < Header > headers ) { if ( getMessage ( ) . getRequest ( ) instanceof SipRequest ) { SipRequest sipRequest = ( SipRequest ) getMessage ( ) . getRequest ( ) ; if ( ! sipRequest . getSipRecipientsInfo ( ) . isEmpty ( ) ) { for ( SipRecipientInfo recipient : sipRequest . getSipRecipientsInfo ( ) ) { headers . add ( HeaderConstants . HEADER_VIA , SipRecipientInfoWriter . write ( recipient ) ) ; } } } super . addGeneralHeaders ( headers ) ; } @ Override protected void addRequestHeaders ( Series < Header > headers ) { SipRequest sipRequest = null ; if ( getMessage ( ) . getRequest ( ) instanceof SipRequest ) { sipRequest = ( SipRequest ) getMessage ( ) . getRequest ( ) ; if ( sipRequest . getCallId ( ) != null ) { headers . add ( SipConstants . HEADER_CALL_ID , sipRequest . getCallId ( ) ) ; } if ( sipRequest . getCommandSequence ( ) != null ) { headers . add ( SipConstants . HEADER_CALL_SEQ , sipRequest . getCommandSequence ( ) ) ; } if ( sipRequest . getFrom ( ) != null ) { headers . add ( HeaderConstants . HEADER_FROM , AddressWriter . write ( sipRequest . getFrom ( ) ) ) ; } if ( sipRequest . getTo ( ) != null ) { headers . add ( SipConstants . HEADER_TO , AddressWriter . write ( sipRequest . getTo ( ) ) ) ; } if ( sipRequest . getAlertInfo ( ) != null ) { headers . add ( SipConstants . HEADER_ALERT_INFO , AddressWriter . write ( sipRequest . getAlertInfo ( ) ) ) ; } if ( ! sipRequest . getAllowedEventTypes ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_ALLOW_EVENTS , EventTypeWriter . write ( sipRequest . getAllowedEventTypes ( ) ) ) ; } if ( ! sipRequest . getCallerInfo ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_CALL_INFO , AddressWriter . write ( sipRequest . getCallerInfo ( ) ) ) ; } if ( ! sipRequest . getContacts ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_CONTACT , ContactInfoWriter . write ( sipRequest . getContacts ( ) ) ) ; } if ( sipRequest . getEvent ( ) != null ) { headers . add ( SipConstants . HEADER_EVENT , EventWriter . write ( sipRequest . getEvent ( ) ) ) ; } if ( sipRequest . getMimeVersion ( ) != null ) { headers . add ( SipConstants . HEADER_MIME_VERSION , sipRequest . getMimeVersion ( ) ) ; } if ( sipRequest . getOrganization ( ) != null ) { headers . add ( SipConstants . HEADER_ORGANIZATION , sipRequest . getOrganization ( ) ) ; } if ( ! sipRequest . getRecordedRoutes ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_RECORD_ROUTE , AddressWriter . write ( sipRequest . getRecordedRoutes ( ) ) ) ; } if ( sipRequest . getReplyTo ( ) != null ) { headers . add ( SipConstants . HEADER_REPLY_TO , AddressWriter . write ( sipRequest . getReplyTo ( ) ) ) ; } if ( ! sipRequest . getSupported ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_SUPPORTED , OptionTagWriter . write ( sipRequest . getSupported ( ) ) ) ; } if ( ! sipRequest . getInReplyTo ( ) . isEmpty ( ) ) { StringBuilder sb = new StringBuilder ( sipRequest . getInReplyTo ( ) . get ( 0 ) ) ; for ( int i = 1 ; i < sipRequest . getInReplyTo ( ) . size ( ) ; i ++ ) { sb . append ( \",\" ) . append ( sipRequest . getInReplyTo ( ) . get ( i ) ) ; } headers . add ( SipConstants . HEADER_IN_REPLY_TO , sb . toString ( ) ) ; } if ( sipRequest . getPriority ( ) != null ) { headers . add ( SipConstants . HEADER_PRIORITY , sipRequest . getPriority ( ) . getValue ( ) ) ; } if ( ! sipRequest . getProxyRequires ( ) . isEmpty ( ) ) { headers . add ( SipConstants . HEADER_PROXY_REQUIRE , OptionTagWriter . write ( sipRequest . getProxyRequires ( ) ) ) ; } if ( sipRequest . getReferTo ( ) != null ) { headers . add ( SipConstants . HEADER_REFER_TO , AddressWriter . write ( sipRequest . getReferTo ( ) ) ) ; } if ( ! sipRequest .", "gt": "getRequires ( ) . isEmpty ( ) )", "prediction": "getInReplyTo ( ) . isEmpty ( ) )\n", "label": 1}
{"id": 135, "input": "<s> package com . gisgraphy . client . nameformatters ; import com . gisgraphy . client . commons . NamePart ; import com . gisgraphy . client . commons . NameProvider ; import com . gisgraphy . client . gisfeature . AlternateGisFeatureName ; import com . gisgraphy . client . language . Iso639Language ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; public class FakeFullyQualifiedNameProvider implements NameProvider { private ImmutableList < NamePart > fullyQualifiedNameParts ; public FakeFullyQualifiedNameProvider ( ImmutableList < NamePart > fullyQualifiedNameParts ) { super ( ) ; this . fullyQualifiedNameParts = fullyQualifiedNameParts ; } public String getFriendlyCode ( ) { return null ; }", "gt": "public ImmutableList < NamePart > getFullyQualifiedNameParts ( )", "prediction": "public void setFriendlyCode ( String code )\n", "label": 0}
{"id": 14891, "input": "<s> package br . org . archimedes ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.i18n.messages\" ; public static String Constant_defaultFontFileName ; public static String NeverSaved ; public static String NewDrawingName ; public static String LayerComboContributionItem_LayerLocked ; public static String LayerComboContributionItem_NoDrawing ; static { NLS . initializeMessages ( BUNDLE_NAME", "gt": ", Messages . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2236, "input": "<s> package org . bombusim . lime ; import java . util . ArrayList ; import org . acra . * ; import org . acra . annotation . * ; import org . bombusim . lime . activity . Smilify ; import org . bombusim . lime . data . AccountsFactory ; import org . bombusim . lime . data . ChatFactory ; import org . bombusim . lime . data . Roster ; import org . bombusim . lime . data . VcardResolver ; import org . bombusim . lime . logger . LoggerData ; import org . bombusim . lime . service . XmppServiceBinding ; import org . bombusim . xmpp . XmppAccount ; import android . app . Application ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager . NameNotFoundException ; import android . content . res . Configuration ; @ ReportsCrashes ( formKey = \"\" , mailTo = \"crashreports@bombus-im.org\" , mode = ReportingInteractionMode . TOAST , resToastText = R . string . crash_toast_text_email ) public class Lime extends Application { private static Lime instance ; public static Lime getInstance ( ) { return instance ; } public int avatarSize ; private Roster roster ; private LoggerData log ; private ChatFactory chatFactory ; private Smilify smilify ; public Preferences prefs ; private ArrayList < XmppAccount > accounts ; private int activeAccountIndex ; public Roster getRoster ( ) { return roster ; } public LoggerData getLog ( ) { return log ; } public VcardResolver vcardResolver ; private XmppServiceBinding sb ; @ Deprecated public XmppServiceBinding getServiceBinding ( ) { return sb ; } @ Deprecated public void saveBinding ( XmppServiceBinding sb ) { this . sb = sb ; } @ Override public final void onCreate ( ) { ACRA . init ( this ) ; ErrorReporter . getInstance ( ) . putCustomData ( \"GIT\" , gitVersion ( ) ) ; super . onCreate ( ) ; instance = this ; loadPreferences ( ) ; log = new LoggerData ( ) ; vcardResolver = new VcardResolver ( this ) ; loadAccounts ( ) ; avatarSize = getResources ( ) . getDimensionPixelSize ( R . dimen . avatarSize ) ; } public void loadAccounts ( ) { accounts = AccountsFactory . loadAccounts ( getApplicationContext ( ) ) ; activeAccountIndex = AccountsFactory . getActiveAccountIndex ( getApplicationContext ( ) ) ; if ( activeAccountIndex >= accounts . size ( ) ) activeAccountIndex = 0 ; roster = new Roster ( ) ; } public void loadPreferences ( ) { prefs = new Preferences ( getApplicationContext ( ) ) ; } @ Override public final void onTerminate ( ) { super . onTerminate ( ) ; } @ Override public final void onLowMemory ( ) { smilify = null ; chatFactory = null ; roster . dropCachedAvatars ( ) ; super . onLowMemory ( ) ; } private String version ; public long lastMessageId = - 1 ; private String gitVersion ( ) { return getResources ( ) . getString ( R . string . git_count ) + \" (\" + getResources ( ) . getString ( R . string . git_short ) + \")\" ; } public String getVersion ( ) { if ( version == null ) { try { PackageInfo pinfo = getPackageManager ( ) . getPackageInfo ( getPackageName ( ) , 0 ) ; version = pinfo . versionName + \".\" + gitVersion ( ) ; } catch ( NameNotFoundException e ) { version = \"unknown\" ; } } return version ; } public String getOsId ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( android . os . Build .", "gt": "MANUFACTURER ) . append ( ' ' ) ;", "prediction": "VERSION ) ;\n", "label": 0}
{"id": 14894, "input": "<s> package org . nuxeo . ecm . webengine . management ; import org . nuxeo . ecm . webengine .", "gt": "model . impl . DefaultObject ;", "prediction": "model . DocumentModel ;\n", "label": 1}
{"id": 8715, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import java . awt . * ; public class PgsTextAreaUI extends BasicTextAreaUI { public static ComponentUI createUI ( JComponent c ) { return new PgsTextAreaUI ( ) ; } public final void paintSafely ( Graphics g ) { PgsUtils . installAntialiasing ( g ) ; super . paintSafely ( g ) ; PgsUtils . uninstallAntialiasing ( g ) ; }", "gt": "protected void uninstallListeners ( )", "prediction": "}\n", "label": 0}
{"id": 14898, "input": "<s> package org . eclipse . ui . tests . commands ; import org . eclipse . core . commands . Category ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . CommandManager ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . IExecutionListener ; import org . eclipse . core . commands . NotHandledException ; import org . eclipse . ui . tests . harness . util . UITestCase ; public final class CommandManagerTest extends UITestCase { private final class ExecutionListener implements IExecutionListener { private String notHandledId = null ; private String preExecuteId = null ; private NotHandledException notHandledException = null ; private ExecutionEvent preExecuteEvent = null ; public final void notHandled ( final String commandId , final NotHandledException exception ) { notHandledId = commandId ; notHandledException = exception ; } public final void postExecuteFailure ( final String commandId , final ExecutionException exception ) { } public final void postExecuteSuccess ( final String commandId , final Object returnValue ) { } public final void preExecute ( final String commandId , final ExecutionEvent event ) { preExecuteId = commandId ; preExecuteEvent = event ; } } public CommandManagerTest ( String testName ) { super ( testName ) ; } public final void testExecutionListener ( ) { final String commandId = \"myCommand\" ; final CommandManager commandManager = new CommandManager ( ) ; final Category category = commandManager . getCategory ( commandId ) ; category . define ( \"name\" , null ) ; final Command command = commandManager . getCommand ( commandId ) ; command . define ( \"name\" , null", "gt": ", category , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 948, "input": "<s> package com . farpost . ldt ; import org . testng . annotations . Test ; import static com . farpost . ldt . Utils . calculateStdDev ; import static org . hamcrest . MatcherAssert . assertThat ; import static org . hamcrest . Matchers . equalTo ; public class UtilsTest { @ Test public void testRunnerCanCalculateStandardDeviation ( ) { long [ ] [ ] numbers = new long [ ] [ ] { { 2 , 4 , 4 , 4 , 5 , 5 , 7 , 9 } } ; assertThat ( calculateStdDev ( numbers ) , equalTo ( 2d ) ) ; } @ Test public void utilsCanCalculatePercentaileStatistic ( ) { long [ ] vector = new long [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; assertThat ( Utils . percentile ( vector , 0.9 ) , equalTo ( 9L ) ) ; assertThat ( Utils . percentile ( vector , 0.99 ) , equalTo ( 9L ) ) ; assertThat ( Utils . percentile ( vector ,", "gt": "0.01 ) , equalTo ( 1L ) ) ;", "prediction": "0.99 ) , equalTo ( 9L ) ) ;\n", "label": 0}
{"id": 14903, "input": "<s> package org . vaadin . addon . vodatime . demoandtestapp ; import org . joda . time . DateTime ; import org . joda . time . LocalDate ; public class SampleBean { private DateTime dateTime ; private LocalDate localDate ; private String text ; public DateTime getDateTime ( ) { return dateTime ; } public void setDateTime ( DateTime dateTime ) { this . dateTime = dateTime ; } public LocalDate getLocalDate ( ) { return localDate ; } public void setLocalDate ( LocalDate localDate ) { this . localDate = localDate ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } @ Override public String toString ( ) { return \"Text: \" + text + \" , DateTime: \" + dateTime", "gt": "+ \", LocalDate: \" + localDate ;", "prediction": ";\n", "label": 1}
{"id": 1498, "input": "<s> import com . sun . source . util . JavacTask ; import java . net . URI ; import java . util . Arrays ; import javax . tools . Diagnostic ; import javax . tools . JavaCompiler ; import javax . tools . JavaFileObject ; import javax . tools . SimpleJavaFileObject ; import javax . tools . StandardJavaFileManager ; import javax . tools . ToolProvider ; public class GenericConstructorAndDiamondTest { enum BoundKind { NO_BOUND ( \"\" ) , STRING_BOUND ( \"extends String\" ) , INTEGER_BOUND ( \"extends Integer\" ) ; String boundStr ; private BoundKind ( String boundStr ) { this . boundStr = boundStr ; } boolean matches ( TypeArgumentKind tak ) { switch ( tak ) { case NONE : return true ; case STRING : return this != INTEGER_BOUND ; case INTEGER : return this != STRING_BOUND ; default : return false ; } } } enum ConstructorKind { NON_GENERIC ( \"Foo(Object o) {}\" ) , GENERIC_NO_BOUND ( \"<T> Foo(T t) {}\" ) , GENERIC_STRING_BOUND ( \"<T extends String> Foo(T t) {}\" ) , GENERIC_INTEGER_BOUND ( \"<T extends Integer> Foo(T t) {}\" ) ; String constrStr ; private ConstructorKind ( String constrStr ) { this . constrStr = constrStr ; } boolean matches ( ArgumentKind ak ) { switch ( ak ) { case STRING : return this != GENERIC_INTEGER_BOUND ; case INTEGER : return this != GENERIC_STRING_BOUND ; default : return false ; } } } enum TypeArgArity { ONE ( 1 ) , TWO ( 2 ) , THREE ( 3 ) ; int n ; private TypeArgArity ( int n ) { this . n = n ; } } enum TypeArgumentKind { NONE ( \"\" ) , STRING ( \"String\" ) , INTEGER ( \"Integer\" ) ; String typeargStr ; private TypeArgumentKind ( String typeargStr ) { this . typeargStr = typeargStr ; } String getArgs ( TypeArgArity arity ) { if ( this == NONE ) return \"\" ; else { StringBuilder buf = new StringBuilder ( ) ; String sep = \"\" ; for ( int i = 0 ; i < arity . n ; i ++ ) { buf . append ( sep ) ; buf . append ( typeargStr ) ; sep = \",\" ; } return \"<\" + buf . toString ( ) + \">\" ; } } boolean matches ( ArgumentKind ak ) { switch ( ak ) { case STRING : return this != INTEGER ; case INTEGER : return this != STRING ; default : return false ; } } boolean matches ( TypeArgumentKind other ) { switch ( other ) { case STRING : return this != INTEGER ; case INTEGER : return this != STRING ; default : return true ; } } } enum ArgumentKind { STRING ( \"\\\"\\\"\" ) , INTEGER ( \"1\" ) ; String argStr ; private ArgumentKind ( String argStr ) { this . argStr = argStr ; } } public static void main ( String ... args ) throws Exception { JavaCompiler comp = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = comp . getStandardFileManager ( null , null , null ) ; for ( BoundKind boundKind : BoundKind . values ( ) ) { for ( ConstructorKind constructorKind : ConstructorKind . values ( ) ) { for ( TypeArgumentKind declArgKind : TypeArgumentKind . values ( ) ) { for ( TypeArgArity arity : TypeArgArity . values ( ) ) { for ( TypeArgumentKind useArgKind : TypeArgumentKind . values ( ) ) { for ( TypeArgumentKind diamondArgKind : TypeArgumentKind . values ( ) ) { for ( ArgumentKind argKind : ArgumentKind . values ( ) ) { new GenericConstructorAndDiamondTest ( boundKind , constructorKind , declArgKind , arity , useArgKind , diamondArgKind , argKind ) . run ( comp , fm ) ; } } } } } } } } BoundKind boundKind ; ConstructorKind constructorKind ; TypeArgumentKind declTypeArgumentKind ; TypeArgArity useTypeArgArity ; TypeArgumentKind useTypeArgumentKind ; TypeArgumentKind diamondTypeArgumentKind ; ArgumentKind argumentKind ; JavaSource source ; DiagnosticChecker diagChecker ; GenericConstructorAndDiamondTest ( BoundKind boundKind , ConstructorKind constructorKind , TypeArgumentKind declTypeArgumentKind , TypeArgArity useTypeArgArity , TypeArgumentKind useTypeArgumentKind , TypeArgumentKind diamondTypeArgumentKind , ArgumentKind argumentKind ) { this . boundKind = boundKind ; this . constructorKind = constructorKind ; this . declTypeArgumentKind = declTypeArgumentKind ; this . useTypeArgArity = useTypeArgArity ; this . useTypeArgumentKind = useTypeArgumentKind ; this . diamondTypeArgumentKind = diamondTypeArgumentKind ; this . argumentKind = argumentKind ; this . source = new JavaSource ( ) ; this . diagChecker = new DiagnosticChecker ( ) ; } class JavaSource extends SimpleJavaFileObject { String template = \"class Foo<X #BK> {\\n\" + \"#CK\\n\" + \"}\\n\" + \"class Test {\\n\" + \"void test() {\\n\" + \"Foo#TA1 f = new #TA2 Foo<#TA3>(#A);\\n\" + \"}\\n\" + \"}\\n\" ; String source ; public JavaSource ( ) { super ( URI . create ( \"myfo:/Test.java\" ) , JavaFileObject . Kind . SOURCE ) ; source = template . replace ( \"#BK\" , boundKind . boundStr ) . replace ( \"#CK\" , constructorKind . constrStr ) . replace ( \"#TA1\" , declTypeArgumentKind . getArgs ( TypeArgArity . ONE ) ) . replace ( \"#TA2\" , useTypeArgumentKind . getArgs ( useTypeArgArity ) ) . replace ( \"#TA3\" , diamondTypeArgumentKind . typeargStr ) . replace ( \"#A\" , argumentKind . argStr ) ; } @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) { return source ; } } void run ( JavaCompiler tool , StandardJavaFileManager fm ) throws Exception { JavacTask ct = ( JavacTask ) tool . getTask ( null , fm , diagChecker , null , null , Arrays . asList ( source ) ) ; ct . analyze ( ) ; check ( ) ; } void check ( ) { boolean badActual = ! constructorKind . matches ( argumentKind ) ; boolean badArity = constructorKind != ConstructorKind . NON_GENERIC && useTypeArgumentKind != TypeArgumentKind . NONE && useTypeArgArity != TypeArgArity . ONE ; boolean badMethodTypeArg = constructorKind != ConstructorKind . NON_GENERIC && ! useTypeArgumentKind . matches ( argumentKind ) ; boolean badExplicitParams = ( useTypeArgumentKind != TypeArgumentKind . NONE && diamondTypeArgumentKind == TypeArgumentKind . NONE ) || !", "gt": "boundKind . matches ( diamondTypeArgumentKind ) ;", "prediction": "useTypeArgumentKind . matches ( argumentKind ) ;\n", "label": 0}
{"id": 14912, "input": "<s> package com . orange . place . helper ; import org . json . JSONObject ; import android . content . Context ; import android . content . SharedPreferences ; import android . content . SharedPreferences . Editor ; import android . util . Log ; import com . orange . place . constant . DBConstants ; import com . orange . place . constant . ServiceConstant ; import com . orange . place . constants . Constants ; import com . orange . utils . JsonUtil ; public class PrefHelper { public static String getUserLoginId ( Context context ) { return getPreference ( context ) . getString ( DBConstants . F_LOGINID , null ) ; } public static String getUserId ( Context context ) { return getPreference ( context ) . getString ( DBConstants . F_USERID , null ) ; } public static SharedPreferences getPreference ( Context context ) { return context . getSharedPreferences ( Constants . PREF_NAME , Context . MODE_PRIVATE ) ; } public static void storeUserInfo ( Context context , JSONObject data ) { Log . d ( Constants . LOG_TAG , \"Set user info in JSON into preference.\" ) ; if ( data == null ) { Log . e ( Constants . LOG_TAG , \"Data is null, nothing stored!\" ) ; return ; } Editor editor = getPreference ( context ) . edit ( ) ; editor . putString ( DBConstants . F_USERID , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_USERID ) ) ; editor . putString ( DBConstants . F_NICKNAME , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_NICKNAME ) ) ; editor . putString ( DBConstants . F_LOGINID , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_LOGINID ) ) ; editor . putString ( DBConstants . F_SINA_ACCESS_TOKEN , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_SINA_ACCESS_TOKEN ) ) ; editor . putString ( DBConstants . F_SINA_ACCESS_TOKEN_SECRET , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_SINA_ACCESS_TOKEN_SECRET ) ) ; editor . putString ( DBConstants . F_QQ_ACCESS_TOKEN , JsonUtil . getStringOrNull ( data , ServiceConstant . PARA_QQ_ACCESS_TOKEN ) ) ; editor . putString ( DBConstants . F_QQ_ACCESS_TOKEN_SECRET , JsonUtil . getStringOrNull (", "gt": "data , ServiceConstant . PARA_QQ_ACCESS_TOKEN_SECRET ) ) ;", "prediction": "data , ServiceConstant . PARA_QQ_ACCESS_TOKEN_SECRET ) ) ;\n", "label": 1}
{"id": 5985, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . CaveSpider ; public interface LizaCaveSpider extends CaveSpider { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet <", "gt": "Byte > transparent , int maxDistance ) ;", "prediction": "Byte > transparent , int maxDistance ) ;\n", "label": 0}
{"id": 14916, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . api . DB3DException ; import de . uos . igf . db3d . dbms . geom . Line3D ; import de . uos . igf . db3d . dbms . geom . MBB3D ; import de . uos . igf . db3d . dbms . geom . Plane3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; public interface Spatial3D { public static final byte SAMPLE_3D = 1 ; public static final byte CURVE_3D = 2 ; public static final byte SURFACE_3D = 3 ; public static final byte HULL_3D = 4 ; public static final byte SOLID_3D = 5 ; public static final byte GRID_3D = 6 ; public ScalarOperator getScalarOperator ( ) ; public MBB3D getMBB ( ) ; public Object3D getObject3D ( ) ; public boolean intersects ( Plane3D plane ) throws DB3DException ; public boolean intersects ( Line3D line ) ; public boolean intersects", "gt": "( MBB3D mbb ) ;", "prediction": "( Plane3D line2 ) throws DB3DException ;\n", "label": 1}
{"id": 5064, "input": "<s> public class DeadCode5 { int fld ; static public void main ( String args [ ] ) { DeadCode5 t = null ; try { int dummy = t . fld ; throw new RuntimeException (", "gt": "\"accidental removal of live code\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14919, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import org . restlet . test .", "gt": "ext . jaxrs . services . tests . ThrowWebAppExcProviderTest ;", "prediction": "ext . jaxrs . services . resources . JaxRsResource ;\n", "label": 1}
{"id": 5624, "input": "<s> package org . ofbiz . entity . condition ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericModelException ; import org . ofbiz . entity . config . DatasourceInfo ; import org . ofbiz . entity . model . ModelEntity ; @ SuppressWarnings ( \"serial\" ) public class EntityJoinOperator extends EntityOperator < EntityCondition , EntityCondition , Boolean > { protected boolean shortCircuitValue ; protected EntityJoinOperator ( int id , String code , boolean shortCircuitValue ) { super ( id , code ) ; this . shortCircuitValue = shortCircuitValue ; } @ Override public void addSqlValue ( StringBuilder sql , ModelEntity modelEntity , List < EntityConditionParam > entityConditionParams , boolean compat , EntityCondition lhs , EntityCondition rhs , DatasourceInfo datasourceInfo ) { List < EntityCondition > conditions = FastList . newInstance ( ) ; conditions . add ( lhs ) ; conditions . add ( rhs ) ; addSqlValue ( sql , modelEntity , entityConditionParams , conditions , datasourceInfo ) ; } public void addSqlValue ( StringBuilder sql , ModelEntity modelEntity , List < EntityConditionParam > entityConditionParams , List < ? extends EntityCondition > conditionList , DatasourceInfo datasourceInfo ) { if ( UtilValidate . isNotEmpty ( conditionList ) ) { boolean hadSomething = false ; Iterator < ? extends EntityCondition > conditionIter = conditionList . iterator ( ) ; while ( conditionIter . hasNext ( ) ) { EntityCondition condition = conditionIter . next ( ) ; if ( condition . isEmpty ( ) ) { continue ; } if ( hadSomething ) { sql . append ( ' ' ) ; sql . append ( getCode ( ) ) ; sql . append ( ' ' ) ; } else { hadSomething = true ; sql . append ( '(' ) ; } sql . append ( condition . makeWhereString ( modelEntity , entityConditionParams , datasourceInfo ) ) ; } if ( hadSomething ) { sql . append ( ')' ) ; } } } protected EntityCondition freeze ( Object item ) { return ( ( EntityCondition ) item ) . freeze ( ) ; } @ Override public EntityCondition freeze ( EntityCondition lhs , EntityCondition rhs ) { return EntityCondition . makeCondition ( freeze ( lhs ) , this , freeze ( rhs ) ) ; } public EntityCondition freeze ( List < ? extends EntityCondition > conditionList ) { List < EntityCondition > newList = new ArrayList < EntityCondition > ( conditionList . size ( ) ) ; for ( EntityCondition condition : conditionList ) { newList . add ( condition . freeze ( ) ) ; } return EntityCondition . makeCondition ( newList , this ) ; } public void visit ( EntityConditionVisitor visitor , List < ? extends EntityCondition > conditionList ) { if ( UtilValidate . isNotEmpty ( conditionList ) ) { for ( EntityCondition condition : conditionList ) { visitor . visit ( condition ) ; } } } @ Override public void visit ( EntityConditionVisitor visitor , EntityCondition lhs , EntityCondition rhs ) { lhs . visit ( visitor ) ; visitor . visit ( rhs ) ; } public Boolean eval ( GenericEntity entity , EntityCondition lhs , EntityCondition rhs ) { return entityMatches ( entity , lhs , rhs ) ? Boolean . TRUE : Boolean . FALSE ; } @ Override public boolean isEmpty ( EntityCondition lhs , EntityCondition rhs ) { return lhs . isEmpty ( ) && rhs . isEmpty ( ) ; } public boolean isEmpty ( List < ? extends EntityCondition > conditionList ) { for ( EntityCondition condition : conditionList ) { if ( ! condition . isEmpty ( ) ) { return false ; } } return true ; } @ Override public boolean entityMatches ( GenericEntity entity , EntityCondition lhs , EntityCondition rhs ) { if ( lhs . entityMatches ( entity ) == shortCircuitValue ) return shortCircuitValue ; if ( rhs . entityMatches ( entity ) == shortCircuitValue ) return shortCircuitValue ; return ! shortCircuitValue ; } public boolean entityMatches ( GenericEntity entity , List < ? extends EntityCondition > conditionList ) { return mapMatches ( entity . getDelegator ( ) , entity , conditionList ) ; } public Boolean eval ( Delegator delegator , Map < String , ? extends Object > map , EntityCondition lhs , EntityCondition rhs ) { return castBoolean ( mapMatches ( delegator ,", "gt": "map , lhs , rhs ) ) ;", "prediction": "lhs , rhs ) ? Boolean . TRUE : Boolean . FALSE ) ;\n", "label": 0}
{"id": 14923, "input": "<s> package com . onarandombox . MultiversePortals . utils ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . command . CommandSender ; import org . bukkit . configuration . file . FileConfiguration ; import org . bukkit . entity . Player ; import org . bukkit . permissions . Permission ; import org . bukkit . util . Vector ; import com . onarandombox . MultiverseCore . api . MultiverseWorld ; import com . onarandombox . MultiversePortals . MVPortal ; import com . onarandombox . MultiversePortals . MultiversePortals ; import com . onarandombox . MultiversePortals . PortalLocation ; public class PortalManager { private MultiversePortals plugin ; private Map < String , MVPortal > portals ; private Map < MultiverseWorld , Map < Integer , Collection < MVPortal > > > worldChunkPortals ; private static final Collection < MVPortal > emptyPortalSet = new ArrayList < MVPortal > ( ) ; public PortalManager ( MultiversePortals plugin ) { this . plugin = plugin ; this . portals = new HashMap < String , MVPortal > ( ) ; this . worldChunkPortals = new HashMap < MultiverseWorld , Map < Integer , Collection < MVPortal > > > ( ) ; } public MVPortal getPortal ( Player sender , Location l ) { if ( ! this . plugin . getCore ( ) . getMVWorldManager ( ) . isMVWorld ( l . getWorld ( ) . getName ( ) ) ) { return null ; } MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( l . getWorld ( ) . getName ( ) ) ; for ( MVPortal portal : getNearbyPortals ( world , l ) ) { if ( ! MultiversePortals . EnforcePortalAccess || portal . playerCanEnterPortal ( ( Player ) sender ) ) { PortalLocation portalLoc = portal . getLocation ( ) ; if ( portalLoc . isValidLocation ( ) && portalLoc . getRegion ( ) . containsVector ( l ) ) { return portal ; } } } return null ; } @ Deprecated public MVPortal isPortal ( Player sender , Location l ) { return this . getPortal ( sender , l ) ; } public boolean isPortal ( Location l ) { return this . getPortal ( l ) != null ; } public MVPortal getPortal ( Location l ) { MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( l . getWorld ( ) . getName ( ) ) ; for ( MVPortal portal : getNearbyPortals ( world , l ) ) { MultiverseRegion r = portal . getLocation ( ) . getRegion ( ) ; if ( r != null && r . containsVector ( l ) ) { return portal ; } } return null ; } public boolean addPortal ( MVPortal portal ) { if ( ! this . portals . containsKey ( portal . getName ( ) ) ) { MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( portal . getWorld ( ) ) ; addUniquePortal ( world , portal . getName ( ) , portal ) ; return true ; } return false ; } public boolean addPortal ( MultiverseWorld world , String name , String owner , PortalLocation location ) { if ( ! this . portals . containsKey ( name ) ) { addUniquePortal ( world , name , new MVPortal ( this . plugin , name , owner , location ) ) ; return true ; } return false ; } private void addUniquePortal ( MultiverseWorld world , String name , MVPortal portal ) { this . portals . put ( name , portal ) ; addToWorldChunkPortals ( world , portal ) ; } public MVPortal removePortal ( String portalName , boolean removeFromConfigs ) { if ( ! isPortal ( portalName ) ) { return null ; } if ( removeFromConfigs ) { FileConfiguration config = this . plugin . getPortalsConfig ( ) ; config . set ( \"portals.\" + portalName , null ) ; this . plugin . savePortalsConfig ( ) ; } MVPortal removed = this . portals . remove ( portalName ) ; MultiverseWorld world = this . plugin . getCore ( ) . getMVWorldManager ( ) . getMVWorld ( removed . getWorld ( ) ) ; removeFromWorldChunkPortals ( world , removed ) ; removed . removePermission ( ) ; Permission portalAccess = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.access.*\" ) ; Permission exemptAccess = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.exempt.*\" ) ; Permission portalFill = this . plugin . getServer ( ) . getPluginManager ( ) . getPermission ( \"multiverse.portal.fill.*\" ) ; if", "gt": "( exemptAccess != null )", "prediction": "( portalFill != null )\n", "label": 1}
{"id": 947, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . vorstellungswaehler ; import de . uni_hamburg . informatik . swt . se2 . kino . materialien . Vorstellung ; class VorstellungFormatierer { private Vorstellung _vorstellung ; public VorstellungFormatierer ( Vorstellung vorstellung ) { _vorstellung = vorstellung ; } Vorstellung getVorstellung ( ) { return _vorstellung ; } @ Override public String toString ( ) { return _vorstellung . getAnfangszeit ( ) . getFormatiertenString ( ) + \" - \" + _vorstellung . getFilm ( ) . getFormatiertenString ( ) + \", \" + _vorstellung . getKinosaal ( )", "gt": ". getName ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14925, "input": "<s> package com . codeslap . test . persistence ; import android . app . Activity ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . SQLException ; import android . net . Uri ; import com . codeslap . persistence . BaseContentProvider ; import com . codeslap . persistence . PersistenceConfig ; import org . junit . Test ; import static org . easymock . EasyMock . createMockBuilder ; import static org . easymock . EasyMock . expect ; import static org . easymock . EasyMock . replay ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class ContentProviderTest extends SqliteTest { private TestProvider mProvider ; @ Override public void configure ( ) { super . configure ( ) ; mProvider = createMockBuilder ( TestProvider . class ) . addMockedMethod ( \"getContext\" ) . createMock ( ) ; expect ( mProvider . getContext ( ) ) . andReturn ( new Activity ( ) ) . anyTimes ( ) ; replay ( mProvider ) ; mProvider . onCreate ( ) ; } @ Test public void contentProviderTest ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ExampleAutoincrement . class ) ; ContentValues values = new ContentValues ( ) ; values . put ( \"name\" , \"Foo Bar\" ) ; values . put ( \"number\" , 111 ) ; values . put ( \"decimal\" , 222f ) ; values . put ( \"bool\" , true ) ; values . put ( \"blob\" , \"Foo bar baz\" . getBytes ( ) ) ; Uri insert = mProvider . insert ( uri , values ) ; assertNotNull ( insert ) ; values . put ( \"number\" , 333 ) ; int update = mProvider . update ( uri , values , \"name LIKE ?\" , new String [ ] { \"Foo Bar\" } ) ; assertEquals ( 1 , update ) ; Cursor query = mProvider . query ( uri , new String [ ] { \"name\" } , \"name LIKE ?\" , new String [ ] { \"Foo Bar\" } , null ) ; assertNotNull ( query ) ; assertEquals ( 1 , query . getCount ( ) ) ; assertEquals ( 1 , query . getColumnCount ( ) ) ; assertTrue ( query . moveToNext ( ) ) ; assertEquals ( \"Foo Bar\" , query . getString ( 0 ) ) ; int deleted = mProvider . delete ( uri , \"number = ?\" , new String [ ] { \"333\" } ) ; assertEquals ( 1 , deleted ) ; } @ Test ( expected = SQLException . class ) public void shouldFailWithEmptyValuesTest ( ) throws NoSuchFieldException , IllegalAccessException { Uri uri = BaseContentProvider . buildBaseUri ( \"com.codeslap.test\" , ExampleAutoincrement . class ) ; ContentValues values = new ContentValues ( ) ; mProvider . insert ( uri , values ) ; } @ Test ( expected = SQLException .", "gt": "class ) public void shouldFailWithNullValuesTest ( ) throws NoSuchFieldException , IllegalAccessException", "prediction": "class ) public void shouldFailWithEmptyValuesTest ( ) throws NoSuchFieldException , IllegalAccessException\n", "label": 1}
{"id": 1116, "input": "<s> import java . util . * ; class UncheckedFilename2 { List < String > list =", "gt": "new ArrayList ( ) ;", "prediction": "new ArrayList < String > ( ) ;\n", "label": 0}
{"id": 14927, "input": "<s> package org . apache . sqoop . manager ; import java . io . IOException ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . manager . ExportJobContext ; import com . cloudera . sqoop . util . ExportException ; import org . apache . hadoop . mapreduce . lib . output . NullOutputFormat ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . sqoop . mapreduce . ExportInputFormat ; import org . apache . sqoop . mapreduce . PGBulkloadExportJob ; public class PGBulkloadManager extends PostgresqlManager { public static final Log LOG = LogFactory . getLog ( PGBulkloadManager . class . getName ( ) ) ;", "gt": "public PGBulkloadManager ( final SqoopOptions opts )", "prediction": "public static final Log LOG = LogFactory . getLog ( PGBulkloadManager . class . getName ( ) ) ;\n", "label": 1}
{"id": 8407, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface CellColor extends ColumnAttribute { LogicalExpression getExpression ( ) ; void setExpression ( LogicalExpression value ) ; RGB getColor ( ) ; void setColor", "gt": "( RGB value ) ;", "prediction": "( RGB value ) ;\n", "label": 0}
{"id": 14936, "input": "<s> package org . nuxeo . ecm . platform . syndication . vocabularies ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . dom4j . dom . DOMDocument ; import org . dom4j . dom . DOMDocumentFactory ; import org . w3c . dom . Element ; public final class Tree { public static final class Builder { private final Map < String , List < SimpleVocabulary > > pendingVocabularies = new HashMap < String , List < SimpleVocabulary > > ( ) ; private final Map < String , HierarchicalVocabulary > mapVocabularies = new HashMap < String , HierarchicalVocabulary > ( ) ; public void addElement ( String parent , HierarchicalVocabulary parentVoca1 , SimpleVocabulary voca ) { if ( null == parent ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( null , voca ) ; addNewVocabulary ( newVoca ) ; } else { HierarchicalVocabulary parentVoca = mapVocabularies . get ( parent . toLowerCase ( ) ) ; if ( null != parentVoca ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( parentVoca , voca ) ; parentVoca . addChild ( newVoca ) ; addNewVocabulary ( newVoca ) ; } else { mapVocabularies . put ( parent , parentVoca1 ) ; addPendingVocabulary ( parent , voca ) ; } } } private void addNewVocabulary ( HierarchicalVocabulary voca ) { String id = voca . getVocabulary ( ) . getId ( ) . toLowerCase ( ) ; mapVocabularies . put ( id , voca ) ; addWaitingChildren ( voca ) ; } private void addWaitingChildren ( HierarchicalVocabulary voca ) { String id = voca . getVocabulary ( ) . getId ( ) . toLowerCase ( ) ; List < SimpleVocabulary > children = pendingVocabularies . remove ( id ) ; if ( null != children ) { for ( SimpleVocabulary child : children ) { HierarchicalVocabulary newVoca = new HierarchicalVocabulary ( voca , child ) ; voca . addChild ( newVoca ) ; } } } private void addPendingVocabulary ( String parent , SimpleVocabulary dir ) { List < SimpleVocabulary > dirs = pendingVocabularies . get ( parent . toLowerCase ( ) ) ; if ( null == dirs ) { dirs = new ArrayList < SimpleVocabulary > ( ) ; } dirs . add ( dir ) ; pendingVocabularies . put ( parent . toLowerCase ( ) , dirs ) ; } public Tree build ( ) { List < HierarchicalVocabulary > rootNodes = new ArrayList < HierarchicalVocabulary > ( ) ; Map < String , HierarchicalVocabulary > mV = new HashMap < String , HierarchicalVocabulary > ( ) ; mV . putAll ( mapVocabularies ) ; for ( String key : mV . keySet ( ) ) { addWaitingChildren ( mapVocabularies . get ( key ) ) ; } for ( HierarchicalVocabulary voca : mapVocabularies . values ( ) ) { HierarchicalVocabulary vp = getNode ( voca ) ; if ( ! rootNodes . contains ( vp ) ) { rootNodes . add ( vp ) ; } } Collections . sort ( rootNodes , HierarchicalVocabulary . ORDER_BY_ID ) ; return new Tree ( rootNodes ) ; } public HierarchicalVocabulary getNode ( HierarchicalVocabulary hv ) { if ( hv . getParent ( ) == null ) { return hv ; } else { return getNode ( hv . getParent ( ) ) ; } } } private final List < HierarchicalVocabulary > rootNodes = new ArrayList < HierarchicalVocabulary > ( ) ; private Tree ( List < HierarchicalVocabulary > rootNodes ) { this . rootNodes . addAll ( rootNodes ) ; } public String asXML ( ) { DOMDocumentFactory domfactory = new DOMDocumentFactory ( ) ; DOMDocument document = ( DOMDocument ) domfactory . createDocument ( ) ; Element", "gt": "current = document . createElement ( \"entries\" ) ;", "prediction": "element = document . getElement ( ) ;\n", "label": 1}
{"id": 3972, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . swing . ColorUtils ; import javax . swing . * ; import javax . swing . plaf . UIResource ; import java . awt . * ; import java . io . Serializable ; public class PgsIconFactory { private static Icon emptyIcon ; public static Icon getEmptyIcon ( ) { if ( emptyIcon == null ) { emptyIcon = new EmptyIcon ( PlafOptions . getDefaultMenuItemIconSize ( ) ) ; } return emptyIcon ; } private static class EmptyIcon implements Icon , UIResource , Serializable { private Dimension size ; public EmptyIcon ( Dimension dim ) { size = dim ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { return ; } public int getIconWidth ( ) { return size . width ; } public int getIconHeight ( ) { return size . height ; } } protected static void drawCheck ( Component c , Graphics g , int x , int y ) { g . translate ( x , y ) ; g . drawLine ( 3 , 5 , 3 , 5 ) ; g . fillRect ( 3 , 6 , 2 , 2 ) ; g . drawLine ( 4 , 8 , 9 , 3 ) ; g . drawLine ( 5 , 8 , 9 , 4 ) ; g . drawLine ( 5 , 9 , 9 , 5 ) ; g . translate ( - x , - y ) ; } private static Icon checkBoxIcon ; public static Icon getCheckBoxIcon ( ) { if ( checkBoxIcon == null ) { checkBoxIcon = new CheckBoxIcon ( ) ; } return checkBoxIcon ; } private static class CheckBoxIcon implements Icon , UIResource , Serializable { protected int getControlSize ( ) { return 13 ; } public void paintIcon ( Component c , Graphics g , int x , int y ) { JCheckBox cb = ( JCheckBox ) c ; ButtonModel model = cb . getModel ( ) ; int controlSize = getControlSize ( ) ; boolean drawCheck = model . isSelected ( ) ; if ( model . isEnabled ( ) ) { g . setColor ( PgsLookAndFeel . getControlHighlight ( ) ) ; g . fillRect ( x , y , controlSize , controlSize ) ; PgsUtils . drawGradient ( g , x , y , controlSize , controlSize , ColorUtils . getTranslucentColor ( PgsLookAndFeel . getControlShadow ( ) , 0 ) , ColorUtils . getTranslucentColor ( PgsLookAndFeel . getControlShadow ( ) , 50 ) ) ; if ( model . isRollover ( ) ) { g . setColor ( PgsLookAndFeel . getGlow ( ) ) ; g . drawRect ( x + 1 , y + 1 , controlSize - 3 , controlSize - 3 ) ; } g . setColor ( PgsLookAndFeel .", "gt": "getControlDarkShadow ( ) ) ;", "prediction": "getGlow ( ) ) ;\n", "label": 0}
{"id": 14937, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . Directory ; import java . io . IOException ; import java . util . List ; import java . util . ArrayList ; import java . util . Set ; public abstract class MergePolicy { public static class OneMerge { SegmentInfo info ; boolean mergeDocStores ; boolean optimize ; boolean increfDone ; boolean registerDone ; long mergeGen ; boolean isExternal ; int maxNumSegmentsOptimize ; SegmentReader [ ] readers ; SegmentReader [ ] readersClone ; List mergeFiles ; final SegmentInfos segments ; final boolean useCompoundFile ; boolean aborted ; Throwable error ; public OneMerge ( SegmentInfos segments , boolean useCompoundFile ) { if ( 0 == segments . size ( ) ) throw new RuntimeException ( \"segments must include at least one segment\" ) ; this . segments = segments ; this . useCompoundFile = useCompoundFile ; } synchronized void setException ( Throwable error ) { this . error = error ; } synchronized Throwable getException ( ) { return error ; } synchronized void abort ( ) { aborted = true ; } synchronized boolean isAborted ( ) { return aborted ; } synchronized void checkAborted ( Directory dir ) throws MergeAbortedException { if ( aborted ) throw new MergeAbortedException ( \"merge is aborted: \" + segString ( dir ) ) ; } String segString ( Directory dir ) { StringBuffer b = new StringBuffer ( ) ; final int numSegments = segments . size ( ) ; for ( int i = 0 ; i < numSegments ; i ++ ) { if ( i > 0 ) b . append ( ' ' ) ; b . append ( segments . info ( i ) . segString ( dir ) ) ; } if ( info != null ) b . append ( \" into \" ) . append ( info . name ) ; if ( optimize ) b . append ( \" [optimize]\" ) ; if ( mergeDocStores ) { b . append ( \" [mergeDocStores]\" ) ; } return b . toString ( ) ; } } public static class MergeSpecification { public List merges = new ArrayList ( ) ; public void add ( OneMerge merge ) { merges . add ( merge ) ; } public String segString ( Directory dir ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \"MergeSpec:\\n\" ) ; final int count = merges . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) b . append ( \"  \" ) . append ( 1 + i ) . append ( \": \" ) . append ( ( ( OneMerge ) merges . get ( i ) ) . segString ( dir ) ) ; return b . toString ( ) ; } } public static class MergeException extends RuntimeException { private Directory dir ; public MergeException ( String message ) { super ( message ) ; } public MergeException ( String message , Directory dir ) { super ( message ) ; this . dir = dir ; } public MergeException ( Throwable exc ) { super ( exc ) ; } public MergeException ( Throwable exc , Directory dir ) { super ( exc ) ; this . dir = dir ; } public Directory getDirectory ( ) { return dir ; } } public static class MergeAbortedException extends IOException { public MergeAbortedException ( ) { super ( \"merge is aborted\" ) ; } public MergeAbortedException ( String message ) { super ( message ) ; } } final protected IndexWriter writer ; public MergePolicy ( IndexWriter writer ) { this", "gt": ". writer = writer ;", "prediction": ". writer = writer ;\n", "label": 1}
{"id": 4870, "input": "<s> interface I1 { int f ( ) ; } interface I2 { void f ( ) ; }", "gt": "interface InconsistentReturn extends I1 , I2", "prediction": "interface I3\n", "label": 0}
{"id": 14946, "input": "<s> package org . eclipse . ui ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . viewers . ISelectionProvider ; public interface IWorkbenchPartSite extends IWorkbenchSite { public String getId ( ) ; public String getPluginId ( ) ; public String getRegisteredName ( ) ; public void registerContextMenu ( String menuId", "gt": ", MenuManager menuManager , ISelectionProvider selectionProvider ) ;", "prediction": ") ;\n", "label": 1}
{"id": 1405, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . MinimalEObjectImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . TaskTimesheetAttribute ; public class TaskTimesheetAttributeImpl extends MinimalEObjectImpl . Container implements TaskTimesheetAttribute { protected TaskTimesheetAttributeImpl ( ) { super ( ) ; } @", "gt": "Override protected EClass eStaticClass ( )", "prediction": "Override protected void setUp ( ) throws Exception\n", "label": 0}
{"id": 14951, "input": "<s> package org . restlet . test . resource ; public class LightContact { private String email1 ; private String firstName ; private String lastName ; public LightContact ( String email , String firstName , String lastName ) { super ( ) ; this . email1 = email ; this . firstName = firstName ; this . lastName = lastName ; } public String getEmail1 ( ) { return email1 ; } public String getFirstName ( ) { return firstName ; } public String getLastName ( ) { return lastName ; } public void setEmail1 ( String email ) { this . email1 = email ; } public void setFirstName ( String firstName ) {", "gt": "this . firstName = firstName ;", "prediction": "this . firstName = firstName ;\n", "label": 1}
{"id": 9267, "input": "<s> package org . ofbiz . widget . screen ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . control . ConfigXMLReader ; import org . ofbiz . widget . ModelWidget ; import org . ofbiz . widget . ModelWidgetAction ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class ModelScreen extends ModelWidget { public static final String module = ModelScreen . class . getName ( ) ; protected String sourceLocation ; protected FlexibleStringExpander transactionTimeoutExdr ; protected Map < String , ModelScreen > modelScreenMap ; protected boolean useTransaction ; protected boolean useCache ; protected ModelScreenWidget . Section section ; protected ModelScreen ( ) { } public ModelScreen ( Element screenElement , Map < String , ModelScreen > modelScreenMap , String sourceLocation ) { super ( screenElement ) ; this . sourceLocation = sourceLocation ; this . transactionTimeoutExdr = FlexibleStringExpander . getInstance ( screenElement . getAttribute ( \"transaction-timeout\" ) ) ; this . modelScreenMap = modelScreenMap ; this . useTransaction = \"true\" . equals ( screenElement . getAttribute ( \"use-transaction\" ) ) ; this . useCache = \"true\" . equals ( screenElement . getAttribute ( \"use-cache\" ) ) ; Element sectionElement = UtilXml . firstChildElement ( screenElement , \"section\" ) ; if ( sectionElement == null ) { throw new IllegalArgumentException ( \"No section found for the screen definition with name: \" + this . name ) ; } this . section = new ModelScreenWidget . Section ( this , sectionElement ) ; this . section . isMainSection = true ; } public String getSourceLocation ( ) { return sourceLocation ; } public Set < String > getAllServiceNamesUsed ( ) { Set < String > allServiceNamesUsed = FastSet . newInstance ( ) ; findServiceNamesUsedInWidget ( this . section , allServiceNamesUsed ) ; return allServiceNamesUsed ; } protected static void findServiceNamesUsedInWidget ( ModelScreenWidget currentWidget , Set < String > allServiceNamesUsed ) { if ( currentWidget instanceof ModelScreenWidget . Section ) { List < ModelWidgetAction > actions = ( ( ModelScreenWidget . Section ) currentWidget ) . actions ; List < ModelScreenWidget > subWidgets = ( ( ModelScreenWidget . Section ) currentWidget ) . subWidgets ; List < ModelScreenWidget > failWidgets = ( ( ModelScreenWidget . Section ) currentWidget ) . failWidgets ; if ( actions != null ) { for ( ModelWidgetAction screenOperation : actions ) { if ( screenOperation instanceof ModelWidgetAction . Service ) { String serviceName = ( ( ModelWidgetAction . Service ) screenOperation ) . getServiceNameExdr ( ) . getOriginal ( ) ; if ( UtilValidate . isNotEmpty ( serviceName ) ) allServiceNamesUsed . add ( serviceName ) ; } } } if ( subWidgets != null ) { for ( ModelScreenWidget widget : subWidgets ) { findServiceNamesUsedInWidget ( widget , allServiceNamesUsed ) ; } } if ( failWidgets != null ) { for ( ModelScreenWidget widget : failWidgets ) { findServiceNamesUsedInWidget ( widget , allServiceNamesUsed ) ; } } } else if ( currentWidget instanceof ModelScreenWidget . DecoratorSection ) { ModelScreenWidget . DecoratorSection decoratorSection = ( ModelScreenWidget . DecoratorSection ) currentWidget ; if ( decoratorSection . subWidgets != null ) { for ( ModelScreenWidget widget : decoratorSection . subWidgets ) { findServiceNamesUsedInWidget ( widget , allServiceNamesUsed ) ; } } } else if ( currentWidget instanceof ModelScreenWidget . DecoratorScreen ) { ModelScreenWidget . DecoratorScreen decoratorScreen = ( ModelScreenWidget . DecoratorScreen ) currentWidget ; if ( decoratorScreen . sectionMap != null ) { Collection < ModelScreenWidget . DecoratorSection > sections = decoratorScreen . sectionMap . values ( ) ; for ( ModelScreenWidget section : sections ) {", "gt": "findServiceNamesUsedInWidget ( section , allServiceNamesUsed ) ;", "prediction": "if ( section != null )\n", "label": 0}
{"id": 14954, "input": "<s> package org . jscsi . initiator . connection . phase ; import java . nio . ByteBuffer ; import org . jscsi . initiator . connection . Connection ; import org . jscsi . initiator . connection . ITask ; import org . jscsi . initiator . connection . Session ; import org . jscsi . initiator . connection . TargetCapacityInformations ; import org . jscsi . initiator . connection . state . CapacityRequestState ; import org . jscsi . initiator . connection . state . GetConnectionsRequestState ; import org . jscsi . initiator . connection . state . LogoutRequestState ; import org . jscsi . initiator . connection . state . ReadRequestState ; import org . jscsi . initiator . connection . state . WriteRequestState ; import org . jscsi . parser . login . LoginStage ; import org . jscsi . parser . logout . LogoutRequestParser . LogoutReasonCode ; import org . jscsi . parser . scsi . SCSICommandParser . TaskAttributes ; public final class FullFeaturePhase extends AbstractPhase { private static final int READ_FIRST_STAGE_BLOCKS = 64 ; private static final int READ_SECOND_STAGE_BLOCKS = 128 ; private static final int READ_THIRD_STAGE_BLOCKS = 256 ; private static final int WRITE_FIRST_STAGE_BLOCKS = 1024 ; private static final int WRITE_SECOND_STAGE_BLOCKS = 2048 ; private static final int WRITE_THIRD_STAGE_BLOCKS = 4096 ; @ Override public final boolean login ( final Session session ) throws Exception { final Connection connection = session . getNextFreeConnection ( ) ; connection . nextState ( new GetConnectionsRequestState ( connection ) ) ; session . releaseUsedConnection ( connection ) ; return true ; } @ Override public final boolean logoutSession ( final ITask task , final Session session ) throws Exception { final Connection connection = session . getNextFreeConnection ( ) ; connection . getSession ( ) . addOutstandingTask ( connection , task ) ; connection . nextState ( new LogoutRequestState ( connection , LogoutReasonCode . CLOSE_SESSION ) ) ; return true ; } @ Override public final boolean read ( final ITask task , final Session session , final ByteBuffer dst , final int logicalBlockAddress , final long length ) throws Exception { if ( dst . remaining ( ) < length ) { throw new IllegalArgumentException ( \"Destination buffer is too small.\" ) ; } int startAddress = logicalBlockAddress ; final long blockSize = session . getBlockSize ( ) ; long totalBlocks = ( long ) Math . ceil ( length / ( double ) blockSize ) ; long bytes2Process = length ; final Connection connection = session . getNextFreeConnection ( ) ; connection . getSession ( ) . addOutstandingTask ( connection , task ) ; short blocks = ( short ) Math . min ( READ_FIRST_STAGE_BLOCKS , totalBlocks ) ; if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; bytes2Process -= blocks * blockSize ; blocks = ( short ) Math . min ( READ_SECOND_STAGE_BLOCKS , totalBlocks ) ; if ( blocks > 0 ) { if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; bytes2Process -= blocks * blockSize ; } blocks = ( short ) Math . min ( READ_THIRD_STAGE_BLOCKS , totalBlocks ) ; while ( blocks > 0 ) { if ( LOGGER . isInfoEnabled ( ) ) { LOGGER . info ( \"Now reading sequences of length \" + blocks + \" blocks.\" ) ; } connection . nextState ( new ReadRequestState ( connection , dst , TaskAttributes . SIMPLE , ( int ) Math . min ( bytes2Process , blocks * blockSize ) , startAddress , blocks ) ) ; startAddress += blocks ; totalBlocks -= blocks ; blocks = ( short ) Math . min ( READ_THIRD_STAGE_BLOCKS , totalBlocks ) ; } return true ; } @ Override public final boolean write ( final ITask task , final Session session , final ByteBuffer src , final int logicalBlockAddress , final long length ) throws Exception { if ( src . remaining ( ) < length ) { throw new IllegalArgumentException ( \"Source buffer is too small. Buffer size: \" + src . remaining ( ) + \" Expected: \" + length ) ; } int startAddress = logicalBlockAddress ; final long blockSize = session . getBlockSize ( ) ; int totalBlocks = ( int ) Math . ceil ( length / ( double ) blockSize ) ; long bytes2Process = length ; int bufferPosition = 0 ; final Connection connection = session . getNextFreeConnection ( ) ; connection . getSession ( ) . addOutstandingTask ( connection , task ) ; short blocks = ( short ) Math", "gt": ". min ( WRITE_FIRST_STAGE_BLOCKS , totalBlocks ) ;", "prediction": ". min ( READ_FIRST_STAGE_BLOCKS , totalBlocks ) ;\n", "label": 1}
{"id": 4478, "input": "<s> package org . ofbiz . entity . connection ; import org . apache . commons . dbcp . ConnectionFactory ; import org . apache . commons . dbcp . DriverConnectionFactory ; import org . apache . commons . dbcp . PoolableConnectionFactory ; import org . apache . commons . dbcp . managed . LocalXAConnectionFactory ; import org . apache . commons . dbcp . managed . ManagedDataSource ; import org . apache . commons . dbcp . managed . XAConnectionFactory ; import org . apache . commons . pool . impl . GenericObjectPool ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . transaction . TransactionFactory ; import org . w3c . dom . Element ; import javax . transaction . TransactionManager ; import java . sql . Connection ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import javolution . util . FastMap ; public class DBCPConnectionFactory implements ConnectionFactoryInterface { public static final String module = DBCPConnectionFactory . class . getName ( ) ; protected static Map < String , ManagedDataSource > dsCache = FastMap . newInstance ( ) ; public Connection getConnection ( GenericHelperInfo helperInfo , Element jdbcElement ) throws SQLException , GenericEntityException { ManagedDataSource mds = dsCache . get ( helperInfo . getHelperFullName ( ) ) ; if ( mds != null ) { return TransactionFactory . getCursorConnection ( helperInfo , mds . getConnection ( ) ) ; } synchronized ( DBCPConnectionFactory . class ) { mds = dsCache . get ( helperInfo . getHelperFullName ( ) ) ; if ( mds != null ) { return TransactionFactory . getCursorConnection ( helperInfo , mds . getConnection ( ) ) ; } TransactionManager txMgr = TransactionFactory . getTransactionManager ( ) ; String driverName = jdbcElement . getAttribute ( \"jdbc-driver\" ) ; String jdbcUri = UtilValidate . isNotEmpty ( helperInfo . getOverrideJdbcUri ( ) ) ? helperInfo . getOverrideJdbcUri ( ) : jdbcElement . getAttribute ( \"jdbc-uri\" ) ; String jdbcUsername = UtilValidate . isNotEmpty ( helperInfo . getOverrideUsername ( ) ) ? helperInfo . getOverrideUsername ( ) : jdbcElement . getAttribute ( \"jdbc-username\" ) ; String jdbcPassword = UtilValidate . isNotEmpty ( helperInfo . getOverridePassword ( ) ) ? helperInfo . getOverridePassword ( ) : jdbcElement . getAttribute ( \"jdbc-password\" ) ; int maxSize , minSize , timeBetweenEvictionRunsMillis ; try { maxSize = Integer . parseInt ( jdbcElement . getAttribute ( \"pool-maxsize\" ) ) ; } catch ( NumberFormatException nfe ) { Debug . logError ( \"Problems with pool settings [pool-maxsize=\" + jdbcElement . getAttribute ( \"pool-maxsize\" ) + \"]; the values MUST be numbers, using default of 20.\" , module ) ; maxSize = 20 ; } catch ( Exception e ) { Debug . logError ( \"Problems with pool settings [pool-maxsize], using default of 20.\" , module ) ; maxSize = 20 ; } try { minSize = Integer . parseInt ( jdbcElement . getAttribute ( \"pool-minsize\" ) ) ; } catch ( NumberFormatException nfe ) { Debug . logError ( \"Problems with pool settings [pool-minsize=\" + jdbcElement . getAttribute ( \"pool-minsize\" ) + \"]; the values MUST be numbers, using default of 2.\" , module ) ; minSize = 2 ; } catch ( Exception e ) { Debug . logError ( \"Problems with pool settings [pool-minsize], using default of 2.\" , module ) ; minSize = 2 ; } int maxIdle = maxSize / 2 ; if ( jdbcElement . hasAttribute ( \"idle-maxsize\" ) ) { try { maxIdle = Integer . parseInt ( jdbcElement . getAttribute ( \"idle-maxsize\" ) ) ; } catch ( NumberFormatException nfe ) { Debug . logError ( \"Problems with pool settings [idle-maxsize=\" + jdbcElement . getAttribute ( \"idle-maxsize\" ) + \"]; the values MUST be numbers, using calculated default of\" + ( maxIdle > minSize ? maxIdle : minSize ) + \".\" , module ) ; } catch ( Exception e ) { Debug . logError ( \"Problems with pool settings [idle-maxsize], using calculated default of\" + ( maxIdle > minSize ? maxIdle : minSize ) + \".\" , module ) ; } } maxIdle = maxIdle > minSize ? maxIdle : minSize ; try { timeBetweenEvictionRunsMillis = Integer", "gt": ". parseInt ( jdbcElement . getAttribute ( \"time-between-eviction-runs-millis\" ) ) ;", "prediction": ". parseInt ( jdbcElement . getAttribute ( \"timeBetweenEvictionRunsMillis\" ) ) ;\n", "label": 0}
{"id": 14959, "input": "<s> package org . modelgoon . packages . figures ; import org . eclipse . draw2d . AbstractBorder ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . geometry . Insets ; public class RoundedBorder extends AbstractBorder { public Insets getInsets ( final IFigure figure ) { return new Insets ( 3 ,", "gt": "5 , 3 , 10 ) ;", "prediction": "3 ) ;\n", "label": 1}
{"id": 4740, "input": "<s> package org . gk . engine . client . build . grid . field ; import org . gk . engine . client . build . grid . XGridField ; import org . gk . ui . client . com . form . gkYMField ; import org . gk . ui . client . com . grid . column . gkYMColumnConfig ; import org . gk . ui . client . com . utils . DateTimeUtils ; import com . extjs . gxt . ui . client . widget . form . Field ; import com . extjs . gxt . ui . client . widget . grid . ColumnConfig ; public class GYMFiledBuilder extends GridFieldBuilder { public GYMFiledBuilder ( String ym ) { super ( ym ) ; } @ Override public ColumnConfig create ( ) { final XGridField x = ( XGridField ) getField ( ) . clone ( ) ; ColumnConfig cc = new gkYMColumnConfig ( x ) { @ Override public void onField ( Field field ) { setAttribute ( field , x ) ; String value = x . getValue ( ) ; String format = x . getFormat ( ) ; if ( field instanceof gkYMField ) { gkYMField ym = ( gkYMField ) field ; if ( ! format . equals ( \"\" ) ) { ym . setFormat ( format ) ; } if ( ! value .", "gt": "equals ( \"\" ) )", "prediction": "equals ( \"\" ) )\n", "label": 0}
{"id": 14961, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . * ; public class TableItem extends Item { private class TableItemAdapter implements ITableItemAdapter , IWidgetFontAdapter , IWidgetColorAdapter { public Color getUserBackground ( ) { return background ; } public Color getUserForeground ( ) { return foreground ; } public Font getUserFont ( ) { return font ; } public Color [ ] getCellBackgrounds ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Color [ ] result = new Color [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . background ; } } } return result ; } public Color [ ] getCellForegrounds ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Color [ ] result = new Color [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . foreground ; } } } return result ; } public Font [ ] getCellFonts ( ) { int columnCount = Math . max ( 1 , getParent ( ) . getColumnCount ( ) ) ; Font [ ] result = new Font [ columnCount ] ; if ( data != null ) { for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] != null ) { result [ i ] = data [ i ] . font ; } } } return result ; } public boolean isParentDisposed ( ) { return TableItem . this . parent . isDisposed ( ) ; } } private static final class Data implements SerializableCompatibility { static final int UNKNOWN_WIDTH = - 1 ; String text = \"\" ; int textWidth = UNKNOWN_WIDTH ; Image image ; Font font ; Color background ; Color foreground ; } private transient TableItemAdapter tableItemAdapter ; final Table parent ; boolean cached ; int index ; private Data [ ] data ; private boolean checked ; private boolean grayed ; private Color background ; private Color foreground ; private Font font ; public TableItem ( Table parent , int style ) { this ( parent , style , checkNull ( parent ) . getItemCount ( ) ) ; } public TableItem ( Table parent , int style , int index ) { this ( parent , style , index , true ) ; } TableItem ( Table parent , int style , int index , boolean create ) { super ( parent , style ) ; this . parent = parent ; this . index = index ; if ( create ) { this . parent . createItem ( this , index ) ; } } @ Override @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Class < T > adapter ) { T result ; if ( adapter == IWidgetFontAdapter . class || adapter == IWidgetColorAdapter . class || adapter == ITableItemAdapter . class ) { if ( tableItemAdapter == null ) { tableItemAdapter =", "gt": "new TableItemAdapter ( ) ;", "prediction": "new TableItemAdapter ( ) ;\n", "label": 1}
{"id": 9618, "input": "<s> package com . redhat . ceylon . ceylondoc ; import java . util . ResourceBundle ; import com . redhat . ceylon . common . Messages ; public class CeylondMessages extends Messages { private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle . getBundle ( \"com.redhat.ceylon.ceylondoc.resources.messages\" ) ; public", "gt": "static String msg ( String msgKey , Object ... msgArgs )", "prediction": "static void main ( String [ ] args ) throws Exception\n", "label": 0}
{"id": 14962, "input": "<s> package knowevo . myvizster . render ; import java . awt . BasicStroke ; import java . awt . Image ; import knowevo . myvizster . Vizster ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . focus . FocusSet ; import edu . berkeley . guir . prefuse . graph . Entity ; import edu . berkeley . guir . prefuse . render . ImageFactory ; import edu . berkeley . guir . prefuse . render . TextImageItemRenderer ; public class VizsterImageRenderer extends TextImageItemRenderer { private static final String PHOTO_FIELD = \"photo\" ; private static final String NAME_FIELD = \"name\" ; private BasicStroke stroke1 = new BasicStroke ( 1 ) ; private BasicStroke stroke2 = new BasicStroke ( 2 ) ; private ImageFactory m_bwimages ; public VizsterImageRenderer ( ) { this . setImageAttributeName ( PHOTO_FIELD ) ; this . setTextAttributeName ( NAME_FIELD ) ; m_bwimages = new ImageFactory ( ) ; this . setRoundedCorner ( 8 , 8 ) ; this . setHorizontalPadding ( 4 ) ; this . setVerticalPadding ( 1 ) ; } public ImageFactory getBlackAndWhiteImageFactory ( ) { return m_bwimages ; } public int getRenderType ( VisualItem item ) { ItemRegistry registry = item . getItemRegistry ( ) ; FocusManager fm = registry . getFocusManager ( ) ; FocusSet focusSet = fm . getDefaultFocusSet ( ) ; FocusSet clickSet = fm . getFocusSet ( Vizster . CLICK_KEY ) ; FocusSet mouseSet = fm . getFocusSet ( Vizster . MOUSE_KEY ) ; FocusSet searchSet = fm . getFocusSet ( Vizster . SEARCH_KEY ) ; Entity entity = item . getEntity ( ) ; boolean fs = focusSet . contains ( entity ) ; boolean cs = clickSet . contains ( entity ) ; boolean ms = mouseSet . contains ( entity ) ; if ( ms || item . isHighlighted ( ) ) { return RENDER_TYPE_DRAW_AND_FILL ; } else if ( ( fs || cs ) && searchSet != null && searchSet . size ( ) > 0 ) { return RENDER_TYPE_DRAW ; } else if ( fs || cs ) { return RENDER_TYPE_DRAW_AND_FILL ; } else if ( item . isHighlighted ( ) ) return RENDER_TYPE_FILL ; else return RENDER_TYPE_NONE ; } protected Image getImage ( VisualItem item ) { if ( ! m_showImages ) return null ; String imageLoc = getImageLocation ( item ) ; int [ ] hvalue = ( int [ ] ) item . getVizAttribute ( \"highlightValue\" ) ; int val = ( hvalue == null ? 0 : hvalue [ 0 ] ) ; ImageFactory ifact = ( val >= 0 ? m_images : m_bwimages ) ; return ( imageLoc == null ? null : ifact . getImage ( imageLoc ) ) ; } public BasicStroke getStroke ( VisualItem item ) { if ( item . isHighlighted ( ) && ! item . isFocus ( ) && VizsterLib . getHighlightValue ( item ) > 1 ) { return stroke1 ; } else if ( item . getSize ( ) > 1.0 ) { return new BasicStroke ( ( int ) Math . ceil ( 2 * item . getSize ( ) ) ) ; } else { return stroke2 ; } } public void setDrawImages ( boolean s ) { super . setShowImages ( s ) ; } public void setMaxImageDimensions ( int width , int height ) { m_bwimages . setMaxImageDimensions ( width , height ) ;", "gt": "super . setMaxImageDimensions ( width , height ) ;", "prediction": "}\n", "label": 1}
{"id": 4001, "input": "<s> package org . ofbiz . minilang . method . callops ; import org . ofbiz . base . util . ScriptUtil ; import org . ofbiz . base . util . Scriptlet ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangUtil ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class CallScript extends MethodOperation { public static final String module = CallScript . class . getName ( ) ; private static boolean autoCorrect ( Element element ) { String errorListAttr = element . getAttribute ( \"error-list-name\" ) ; if ( errorListAttr . length ( ) > 0 ) { element . removeAttribute ( \"error-list-name\" ) ; return true ; } return false ; } private final String location ; private final String method ; private final Scriptlet scriptlet ; public CallScript ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"location\" , \"script\" ) ; MiniLangValidate . requireAnyAttribute ( simpleMethod , element , \"location\" , \"script\" ) ; MiniLangValidate . constantAttributes ( simpleMethod , element , \"location\" ) ; MiniLangValidate . scriptAttributes ( simpleMethod , element , \"script\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } boolean elementModified = autoCorrect ( element ) ; if ( elementModified && MiniLangUtil . autoCorrectOn ( ) ) { MiniLangUtil . flagDocumentAsCorrected ( element ) ; } String scriptLocation = element . getAttribute ( \"location\" ) ; if ( scriptLocation . isEmpty ( ) ) { this . location = null ; this . method = null ; } else { int pos = scriptLocation . lastIndexOf ( \"#\" ) ; if ( pos == - 1 ) { this . location = scriptLocation ; this . method = null ; } else { this . location = scriptLocation . substring ( 0 , pos ) ; this . method = scriptLocation . substring ( pos + 1 ) ; } } String inlineScript = element . getAttribute ( \"script\" ) ; if ( inlineScript . isEmpty ( ) ) { inlineScript = UtilXml . elementValue ( element ) ; } if ( inlineScript != null && MiniLangUtil . containsScript ( inlineScript ) ) { this . scriptlet = new Scriptlet ( StringUtil . convertOperatorSubstitutions ( inlineScript ) ) ; } else { this . scriptlet = null ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { if ( this . location != null ) { if ( location . endsWith ( \".xml\" ) ) { SimpleMethod . runSimpleMethod ( location , method , methodContext ) ; } else { ScriptUtil . executeScript ( this . location , this . method , methodContext . getEnvMap ( ) ) ; } } if ( this . scriptlet != null ) { try { this . scriptlet . executeScript ( methodContext . getEnvMap ( ) ) ; } catch ( Exception e ) { throw new MiniLangRuntimeException ( e . getMessage ( ) , this ) ; } } return true ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( \"<script \" ) ; if ( this . location != null ) { sb . append ( \"location=\\\"\" ) . append ( this . location ) ; if ( this . method != null ) { sb . append ( \"#\" ) . append ( this . method ) ; } sb . append ( \"\\\" \" ) ; } if ( this . scriptlet != null ) { sb . append ( \"script=\\\"\" ) . append ( this . scriptlet ) . append ( \"\\\" \" ) ; } sb . append ( \"/>\" ) ; return sb . toString ( ) ; } public static final class CallScriptFactory implements Factory < CallScript > { @ Override public CallScript createMethodOperation ( Element", "gt": "element , SimpleMethod simpleMethod ) throws MiniLangException", "prediction": "element )\n", "label": 0}
{"id": 14971, "input": "<s> package br . org . archimedes . text . edittext ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . SelectorFactory ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . model . Element ; import br . org . archimedes . text . Text ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; public class EditTextFactory extends SelectorFactory { private UndoableCommand command ; public EditTextFactory ( ) { super ( ) ; } protected String getCancelMessage ( ) { return Messages . Factory_Cancel ; } public String getName ( ) { return \"edittext\" ; } public List < Command > getCommands ( ) { List < Command > cmds = null ; if ( command != null ) { cmds = new ArrayList < Command > ( ) ; cmds . add ( command ) ; command = null ; } return cmds ; } @ Override protected String finishFactory ( Set < Element > selection ) throws InvalidParameterException { String message = null ; try { Text text = tryGetText ( selection ) ; command = new EditTextCommand ( text ) ; message = Messages . Factory_Edited ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } return message ; } private Text tryGetText ( Set < Element > selection ) throws InvalidParameterException { if ( selection ==", "gt": "null || selection . isEmpty ( ) )", "prediction": "null )\n", "label": 1}
{"id": 4759, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . plaf . metal . * ; import java . awt . * ; import java . util . HashMap ; public class PlafOptions { private static boolean vistaStyle ; private PlafOptions ( ) { } public static void setAsLookAndFeel ( ) { try { Class . forName ( \"com.jidesoft.utils.Lm\" ) ; enableJideFastGradient ( ) ; } catch ( ClassNotFoundException e ) { } PgsLookAndFeel . setAsLookAndFeel ( ) ; } public static void setCurrentTheme ( MetalTheme t ) { PgsLookAndFeel . setCurrentTheme ( t ) ; } public static void updateAllUIs ( ) { PgsLookAndFeel . updateAllUIs ( ) ; } private static Dimension defIconSize = new Dimension ( 10 , 10 ) ; public static void setDefaultMenuItemIconSize ( Dimension dim ) { defIconSize = dim ; } public static Dimension getDefaultMenuItemIconSize ( ) { return defIconSize ; } private static boolean useExtraMargin = true ; public static boolean useExtraMargin ( ) { return useExtraMargin ; } public static void useExtraMargin ( boolean use ) { useExtraMargin = use ; } private static boolean useBoldFonts = false ; private static boolean useBoldMenuFonts = false ; public static boolean useBoldFonts ( ) { return useBoldFonts ; } public static void useBoldFonts ( boolean use ) { useBoldFonts = use ; UIManager . put ( \"swing.boldMetal\" , Boolean . valueOf ( use ) ) ; } public static boolean useBoldMenuFonts ( ) { return useBoldMenuFonts ; } public static void useBoldMenuFonts ( boolean use ) { useBoldMenuFonts = use ; } private static boolean useShadowBorder = false ; public static void useShadowBorder ( boolean use ) { useShadowBorder = use ; } public static boolean isShadowBorderUsed ( ) { return useShadowBorder ; } private static boolean useToolBarIcon = true ; public static void useToolBarIcon ( boolean use ) { useToolBarIcon = use ; } public static boolean isToolBarIconUsed ( ) { return useToolBarIcon ; } private static boolean useDisabledIcon = true ; public static void useDisabledIcon ( boolean use ) { useDisabledIcon = use ; } public static boolean isDisabledIconUsed ( ) { return useDisabledIcon ; } private static boolean aaText = false ; public static void setAntialiasingEnabled ( boolean use ) { aaText = use ; } public static boolean isAntialiasingEnabled ( ) { return aaText ; } private static boolean isClearBorderEnabled = false ; public", "gt": "static void setClearBorderEnabled ( boolean enabled )", "prediction": "static boolean isClearBorderEnabled ( )\n", "label": 0}
{"id": 14972, "input": "<s> package com . corundumstudio . socketio . transport ; import java . io . IOException ; import java . util . Collection ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . TimeUnit ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelFuture ; import org . jboss . netty . channel . ChannelFutureListener ; import org . jboss . netty . channel . ChannelHandler . Sharable ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . Channels ; import org . jboss . netty . channel . MessageEvent ; import org . jboss . netty . handler . codec . http . HttpHeaders ; import org . jboss . netty . handler . codec . http . HttpMethod ; import org . jboss . netty . handler . codec . http . HttpRequest ; import org . jboss . netty . handler . codec . http . QueryStringDecoder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . corundumstudio . socketio . Configuration ; import com . corundumstudio . socketio . DisconnectableHub ; import com . corundumstudio . socketio . SocketIOClient ; import com . corundumstudio . socketio . ack . AckManager ; import com . corundumstudio . socketio . handler . AuthorizeHandler ; import com . corundumstudio . socketio . messages . PacketsMessage ; import com . corundumstudio . socketio . messages . XHRErrorMessage ; import com . corundumstudio . socketio . messages . XHRPostMessage ; import com . corundumstudio . socketio . parser . ErrorAdvice ; import com . corundumstudio . socketio . parser . ErrorReason ; import com . corundumstudio . socketio . parser . Packet ; import com . corundumstudio . socketio . parser . PacketType ; import com . corundumstudio . socketio . scheduler . CancelableScheduler ; import com . corundumstudio . socketio . scheduler . SchedulerKey ; import com . corundumstudio . socketio . scheduler . SchedulerKey . Type ; @ Sharable public class XHRPollingTransport extends BaseTransport { public static final String NAME = \"xhr-polling\" ; private final Logger log = LoggerFactory . getLogger ( getClass ( ) ) ; private final Map < UUID , XHRPollingClient > sessionId2Client = new ConcurrentHashMap < UUID , XHRPollingClient > ( ) ; private final CancelableScheduler scheduler ; private final AckManager ackManager ; private final AuthorizeHandler authorizeHandler ; private final DisconnectableHub disconnectable ; private final Configuration configuration ; private final String path ; public XHRPollingTransport ( String connectPath , AckManager ackManager , DisconnectableHub disconnectable , CancelableScheduler scheduler , AuthorizeHandler authorizeHandler , Configuration configuration ) { this . path = connectPath + NAME + \"/\" ; this . ackManager = ackManager ; this . authorizeHandler = authorizeHandler ; this . configuration = configuration ; this . disconnectable = disconnectable ; this . scheduler = scheduler ; } public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { Object msg = e . getMessage ( ) ; if ( msg instanceof HttpRequest ) { HttpRequest req = ( HttpRequest ) msg ; QueryStringDecoder queryDecoder = new QueryStringDecoder ( req . getUri ( ) ) ; Channel channel = ctx . getChannel ( ) ; if ( queryDecoder . getPath ( ) . startsWith ( path ) ) { handleMessage ( req , queryDecoder , channel ) ; return ; } } ctx . sendUpstream ( e ) ; } private void handleMessage ( HttpRequest req , QueryStringDecoder queryDecoder , Channel channel ) throws IOException { String [ ] parts = queryDecoder . getPath ( ) . split ( \"/\" ) ; if ( parts . length > 3 ) { UUID sessionId = UUID . fromString ( parts [ 4 ] ) ; String origin = req . getHeader ( HttpHeaders . Names . ORIGIN ) ; if ( HttpMethod . POST . equals ( req . getMethod ( ) ) ) { onPost ( sessionId , channel , origin , req . getContent ( ) ) ; } else if ( HttpMethod . GET . equals ( req . getMethod ( ) ) ) { onGet ( sessionId , channel , origin ) ; } if ( queryDecoder . getParameters ( ) . containsKey ( \"disconnect\" ) ) { BaseClient client = sessionId2Client . get ( sessionId ) ; disconnectable . onDisconnect ( client ) ; } } else { log . warn ( \"Wrong {} method request path: {}, from ip: {}. Channel closed!\" , new Object [ ] { req . getMethod ( ) , path , channel . getRemoteAddress ( ) } ) ; channel . close ( ) ; } } private void scheduleNoop ( Channel channel , final UUID sessionId ) { SchedulerKey key = new SchedulerKey ( Type . POLLING , sessionId ) ; scheduler . cancel ( key ) ; scheduler . schedule ( key , new Runnable ( ) { @ Override public void run ( ) { XHRPollingClient client = sessionId2Client . get ( sessionId ) ; if ( client != null ) { client . send ( new Packet ( PacketType . NOOP ) ) ; } } } , configuration . getPollingDuration ( ) , TimeUnit . SECONDS ) ; } private void scheduleDisconnect ( Channel channel , final UUID sessionId ) { final SchedulerKey key = new SchedulerKey ( Type . CLOSE_TIMEOUT , sessionId ) ; scheduler . cancel ( key ) ; ChannelFuture future = channel . getCloseFuture ( ) ; future . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { scheduler . schedule ( key , new Runnable ( ) { @ Override public void run ( ) { XHRPollingClient client = sessionId2Client . get ( sessionId ) ; if ( client != null ) { disconnectable .", "gt": "onDisconnect ( client ) ;", "prediction": "onDisconnect ( client ) ;\n", "label": 1}
{"id": 2802, "input": "<s> package com . pagosoft . plaf ; import javax . swing . * ; import javax . swing . event . * ; import javax . swing . plaf . * ; import javax . swing . plaf . basic . * ; import java . awt . * ; import java . awt . event . * ; import java . beans . PropertyChangeEvent ; import java . beans . PropertyChangeListener ; import java . util . logging . Logger ; public class PgsTabbedPaneUI extends BasicTabbedPaneUI { private boolean paintFocus ; private int rolloverTabIndex ; private TabRolloverHandler tabHandler ; private MyPropertyChangeHandler propHandler ; private TabbedPaneMouseWheelScroller tabScrollHandler ; private TabSelectionMouseHandler tabSelectionHandler ; private static Logger logger = Logger . getLogger ( \"PgsTabbedPaneUI\" ) ; public static final String IS_SUB_TAB = \"pgs.isSubTab\" ; public static final String IS_BUTTON_STYLE = \"pgs.isButtonStyle\" ; public static final String NO_BORDER = \"pgs.noBorder\" ; public static ComponentUI createUI ( JComponent c ) { return new PgsTabbedPaneUI ( ) ; } protected void installDefaults ( ) { super . installDefaults ( ) ; updateBackgroundOpacity ( ) ; paintFocus = UIManager . getBoolean ( \"TabbedPane.focusPainted\" ) ; } protected void installListeners ( ) { super . installListeners ( ) ; if ( tabHandler == null ) { tabHandler = new TabRolloverHandler ( ) ; } tabPane . addMouseListener ( tabHandler ) ; tabPane . addMouseMotionListener ( tabHandler ) ; if ( propHandler == null ) { propHandler = new MyPropertyChangeHandler ( ) ; } tabPane . addPropertyChangeListener ( propHandler ) ; if ( PlafOptions . isWheelTabbedPaneEnabled ( ) ) { if ( tabScrollHandler == null ) { tabScrollHandler = new TabbedPaneMouseWheelScroller ( ) ; } tabPane . addMouseWheelListener ( tabScrollHandler ) ; } if ( PlafOptions . isTabbedPaneRightClickSelectionEnabled ( ) ) { if ( tabSelectionHandler == null ) { tabSelectionHandler = new TabSelectionMouseHandler ( ) ; } tabPane . addMouseListener ( tabSelectionHandler ) ; } if ( PlafOptions . isTabReorderingEnabled ( ) ) { enableReordering ( ) ; } } protected void uninstallListeners ( ) { super . uninstallListeners ( ) ; tabPane . removeMouseListener ( tabHandler ) ; tabPane . removeMouseMotionListener ( tabHandler ) ; tabPane . removePropertyChangeListener ( propHandler ) ; if ( tabScrollHandler != null ) { tabPane . removeMouseWheelListener ( tabScrollHandler ) ; } if ( tabSelectionHandler != null ) { tabPane . removeMouseListener ( tabSelectionHandler ) ; } disableReordering ( ) ; } private void updateBackgroundOpacity ( ) { if ( isSubTab ( ) || isButtonStyle ( ) ) { tabPane . setOpaque ( true ) ; if ( isSubTab ( ) ) { tabPane . setBackground ( UIManager . getColor ( \"TabbedPane.background\" ) ) ; } else if ( isButtonStyle ( ) ) { tabPane . setBackground ( UIManager . getColor ( \"TabbedPane.buttonStyle.background\" ) ) ; } } else { tabPane . setOpaque ( false ) ; } } private boolean checkBooleanClientProperty ( Object key ) { Object o = tabPane . getClientProperty ( key ) ; if ( o == null ) { return false ; } if ( o instanceof Boolean ) { return ( ( Boolean ) o ) . booleanValue ( ) ; } if ( o instanceof Integer ) { return ( ( Integer ) o ) . intValue ( ) != 0 ; } logger . warning ( \"It seems like you've used a wrong type for '\" + key + \"'. It should be a boolean, but is a \" + o . getClass ( ) . getName ( ) ) ; return true ; } private boolean isSubTab ( ) { return checkBooleanClientProperty ( IS_SUB_TAB ) ; } private boolean isButtonStyle ( ) { return checkBooleanClientProperty ( IS_BUTTON_STYLE ) ; } private void mySetRolloverTab ( int x , int y ) { mySetRolloverTab ( myTabForCoordinate ( tabPane , x , y ) ) ; } private int myTabForCoordinate ( JTabbedPane pane , int x , int y ) { Point p = new Point ( x , y ) ; int tabCount = tabPane . getTabCount ( ) ; for ( int i = 0 ; i < tabCount ; i ++ ) { if ( rects [ i ] . contains ( p . x , p . y ) ) { return i ; } } return - 1 ; } protected void mySetRolloverTab ( int index ) { if ( index >= 0 ) { if ( rolloverTabIndex != - 1 ) { tabPane . repaint ( rects [ rolloverTabIndex ] ) ; } tabPane . repaint ( rects [ index ] ) ; } else if ( rolloverTabIndex != - 1 ) { tabPane . repaint ( rects [ rolloverTabIndex ] ) ; } rolloverTabIndex = index ; } protected int getRolloverTab ( ) { return rolloverTabIndex ; } protected void paintTabBackground ( Graphics g , int tabPlacement , int tabIndex , int x , int y , int w , int h , boolean isSelected ) { if ( isButtonStyle ( ) ) { if ( isSelected ) { g . setColor ( UIManager . getColor ( \"TabbedPane.buttonStyle.selectedBackground\" ) ) ; g . fillRect ( x + 2 , y + 2 , w - 4 , h - 4 ) ; } if ( tabIndex == getRolloverTab ( ) && tabPane . isEnabledAt ( tabIndex ) ) { g . setColor ( UIManager . getColor ( \"TabbedPane.buttonStyle.rolloverBackground\" ) ) ; if ( isSelected ) { g . fillRect ( x + 2 , y + 2 , w - 4 , h - 4 ) ; } else { g . fillRect ( x , y , w , h ) ; } } return ; } if ( isSubTab ( ) && ! isSelected ) { return ; } Graphics2D gfx = ( Graphics2D ) g ; if ( isSelected ) { gfx . setColor ( UIManager . getColor ( \"TabbedPane.selected\" ) ) ; } else { Color a = UIManager . getColor ( \"TabbedPane.tabGradientStart\" ) ; Color b = UIManager . getColor ( \"TabbedPane.tabGradientEnd\" ) ; gfx . setPaint ( new GradientPaint ( 0 , y + 1 , a , 0 , y + 1 + h , b ) ) ; } switch ( tabPlacement ) { case LEFT : gfx . fill ( new Rectangle ( x , y , w + 2 , h ) ) ; break ; case RIGHT : gfx . fill ( new Rectangle ( x - 2 , y , w + 2 , h ) ) ; break ; case BOTTOM : gfx . fill ( new Rectangle ( x , y - 2 , w , h + 2 ) ) ; break ; case TOP : default : gfx . fill ( new Rectangle ( x , y , w - 2 , h + 2 ) ) ; break ; } if ( ! isSelected && tabIndex ==", "gt": "getRolloverTab ( ) && tabPane . isEnabledAt ( tabIndex ) )", "prediction": "getRolloverTab ( ) )\n", "label": 0}
{"id": 14976, "input": "<s> package org . nuxeo . ecm . platform . comment . web ; import java . util . List ; import javax . faces . event . ActionEvent ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . actions . Action ; public interface CommentManagerActions { String CHILDREN_COMMENT_LIST = \"CHILDREN_COMMENT_LIST\" ; List < Action > getActionsForComment ( ) ; List < Action > getActionsForComment ( String category ) ; void initialize ( ) throws Exception ; void documentChanged ( ) ; void initComments ( ) throws ClientException ; void initComments ( DocumentModel commentedDoc ) throws ClientException ; List < ThreadEntry > getCommentsAsThread ( ) throws ClientException ; List < ThreadEntry > getCommentsAsThread ( DocumentModel commentedDoc ) throws ClientException ; List < ThreadEntry > getCommentsAsThreadOnDoc ( DocumentModel doc ) throws ClientException ; String beginComment ( ) ; String cancelComment ( ) ; String addComment ( ) throws ClientException ; String createComment ( DocumentModel docToComment ) throws ClientException ; DocumentModel addComment ( DocumentModel comment ) throws ClientException ; String deleteComment ( ) throws ClientException ; String deleteComment", "gt": "( String commentId ) throws ClientException ;", "prediction": "( DocumentModel comment ) throws ClientException ;\n", "label": 1}
{"id": 247, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . Type ; import org . objectweb . asm . tree . * ; import static org . objectweb . asm . Opcodes . * ; import static org . parboiled . transform . AsmUtils . getLoadingOpcode ; class RuleMethodRewriter implements RuleMethodProcessor { private RuleMethod method ; private InstructionGroup group ; private int actionNr ; private int varInitNr ; public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( classNode , \"classNode\" ) ; checkArgNotNull ( method , \"method\" ) ; return method . containsExplicitActions ( ) || method . containsVars ( ) ; } public void process ( ParserClassNode classNode , RuleMethod method ) throws Exception { this . method = checkArgNotNull ( method , \"method\" ) ; actionNr = 0 ; varInitNr = 0 ; for ( InstructionGroup group : method . getGroups ( ) ) { this . group = group ; createNewGroupClassInstance ( ) ; initializeFields ( ) ; InstructionGraphNode root = group . getRoot ( ) ; if ( root . isActionRoot ( ) ) { removeGroupRootInstruction ( ) ; } else { ( ( MethodInsnNode ) root . getInstruction ( ) ) . desc = \"(Lorg/parboiled/common/Factory;)V\" ; } } method . setBodyRewritten ( ) ; } private void createNewGroupClassInstance ( ) { String internalName = group . getGroupClassType ( ) . getInternalName ( ) ; InstructionGraphNode root = group . getRoot ( ) ; insert ( new TypeInsnNode ( NEW , internalName ) ) ; insert ( new InsnNode ( DUP ) ) ; insert ( new LdcInsnNode ( method . name + ( root . isActionRoot ( ) ? \"_Action\" + ++ actionNr : \"_VarInit\" + ++ varInitNr ) ) ) ; insert ( new MethodInsnNode ( INVOKESPECIAL , internalName , \"<init>\" , \"(Ljava/lang/String;)V\" ) ) ; if ( root . isActionRoot ( ) && method . hasSkipActionsInPredicatesAnnotation ( ) ) { insert ( new InsnNode ( DUP ) ) ; insert ( new MethodInsnNode ( INVOKEVIRTUAL , internalName , \"setSkipInPredicates\" , \"()V\" ) ) ; } } private void initializeFields ( ) { String internalName = group . getGroupClassType ( ) . getInternalName ( ) ; for ( FieldNode field : group . getFields ( ) ) { insert ( new InsnNode ( DUP ) ) ; insert ( new VarInsnNode ( getLoadingOpcode ( ( Type ) field . value ) , field . access ) ) ; insert ( new FieldInsnNode ( PUTFIELD , internalName , field . name , field . desc ) ) ; } } private", "gt": "void insert ( AbstractInsnNode insn )", "prediction": "void createNewGroupClassInstance ( )\n", "label": 0}
{"id": 14978, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . textsize . MeasurementItem ; import org . eclipse . rap . rwt . internal . textsize . MeasurementOperator ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeResultStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeEstimation ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorageUtil ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . widgets . Display ; public class TextSizeUtil_Test extends TestCase { private static final String TEST_STRING = \"test\" ; private static final FontData FONT_DATA = new FontData ( \"arial\" , 10 , SWT . NORMAL ) ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; new Display ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testStringExtentAssignsUnknownStringsToTextSizeMeasuring ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getMeasurementItems ( ) . length ) ; assertEquals ( TEST_STRING , getMeasurementItems ( ) [ 0 ] . getTextToMeasure ( ) ) ; assertEquals ( FONT_DATA , getMeasurementItems ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentUsesEstimationForUnknownStrings ( ) { Point determined = TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; Point estimated = TextSizeEstimation . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( estimated , determined ) ; } public void testStringExtentUsesStoreageForKnowStrings ( ) { Point storedSize = new Point ( 100 , 10 ) ; fakeMeasurement ( TEST_STRING , SWT . DEFAULT , TextSizeUtil . STRING_EXTENT , storedSize ) ; Point determinedSize = TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( storedSize , determinedSize ) ; } public void testStringExtentForEmptyString ( ) { Point emptyStringSize = TextSizeUtil . stringExtent ( getFont ( ) , \"\" ) ; assertEquals ( new Point ( 0 , 10 ) , emptyStringSize ) ; } public void testStringExtentMustNotExpandLineBreaks ( ) { Point singleLine = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\" ) ; Point multiLine = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\\nSecond Line\" ) ; assertEquals ( singleLine . y , multiLine . y ) ; } public void testStringExtentConsideresLeadingAndTrailingSpaces ( ) { Point str = TextSizeUtil . stringExtent ( getFont ( ) , \"  First Line    \" ) ; Point trimStr = TextSizeUtil . stringExtent ( getFont ( ) , \"First Line\" ) ; assertTrue ( str . x > trimStr . x ) ; } public void testTextExtentExpandLineBreaks ( ) { Point singleLine = TextSizeUtil . textExtent ( getFont ( ) , \"First Line\" , 0 ) ; Point multiLine = TextSizeUtil . textExtent ( getFont ( ) , \"First Line\\nSecond Line\" , 0 ) ; assertTrue ( singleLine . y < multiLine . y ) ; } public void testGetCharHeightAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . getCharHeight ( getFont ( ) ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testGetCharHeightUsesEstimationForUnknownStrings ( ) { int determined = TextSizeUtil . getCharHeight ( getFont ( ) ) ; int estimated = TextSizeEstimation . getCharHeight ( getFont ( ) ) ; assertEquals ( estimated , determined , 0 ) ; } public void testGetCharHeightUsesStorageForUnknownStrings ( ) { int charHeight = 13 ; ProbeResultStore probeResultStore = ProbeResultStore . getInstance ( ) ; probeResultStore . createProbeResult ( new Probe ( FONT_DATA ) , new Point ( 10 , charHeight ) ) ; int determined = TextSizeUtil . getCharHeight ( getFont ( ) ) ; assertEquals ( charHeight , determined ) ; } public void testGetAvgCharWidthAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testGetAvgCharWidthUsesEstimationForUnknownStrings ( ) { float determined = TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; float estimated = TextSizeEstimation . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( estimated , determined , 0 ) ; } public void testGetAvgCharWidthUsesStorageForKnownStrings ( ) { ProbeResultStore probeStore = ProbeResultStore . getInstance ( ) ; Point probeSize = new Point ( Probe . DEFAULT_PROBE_STRING . length ( ) * 4 , 10 ) ; probeStore . createProbeResult ( new Probe ( FONT_DATA ) , probeSize ) ; float determined = TextSizeUtil . getAvgCharWidth ( getFont ( ) ) ; assertEquals ( 4 , determined , 0 ) ; } public void testHeightAdjustmentInCaseOfWhitespaceText ( ) { fakeMeasurement ( \" \" , SWT . DEFAULT , TextSizeUtil . TEXT_EXTENT , new Point ( 2 , 0 ) ) ; Point size = TextSizeUtil . textExtent ( getFont ( ) , \" \" , 0 ) ; assertEquals ( 10 , size . y ) ; } public void testHeightAdjustmentInCaseOfMultiLineLengthGreaterThanWrapWidth ( ) { String textToMeasure = \"multi\\nline\\ntext\" ; fakeMeasurement ( textToMeasure , 2 , TextSizeUtil . TEXT_EXTENT , new Point ( 6 , 10 ) ) ; Point size = TextSizeUtil . textExtent ( Graphics . getFont ( FONT_DATA ) , textToMeasure , 2 ) ; assertEquals ( 40 , size . y ) ; } private void fakeMeasurement ( String text , int wrapWidth , int mode , Point size ) { ProbeResultStore . getInstance ( ) . createProbeResult ( new Probe ( FONT_DATA ) , new Point ( 10 , 10 ) ) ; RWTFactory . getTextSizeStorage ( ) . storeFont ( FONT_DATA ) ; TextSizeStorageUtil . store ( FONT_DATA , text , wrapWidth , mode , size ) ; } private MeasurementItem [ ] getMeasurementItems ( ) { return MeasurementOperator . getInstance ( ) . getItems ( ) ; } private Probe [ ] getProbes ( ) { return MeasurementOperator . getInstance ( ) . getProbes ( ) ; } private Font getFont ( ) { return Graphics", "gt": ". getFont ( FONT_DATA ) ;", "prediction": ". getFont ( FONT_DATA ) ;\n", "label": 1}
{"id": 277, "input": "<s> package mage . tracker . domain ; import java . io . Serializable ; import javax . persistence . * ; @ NamedQueries ( { @ NamedQuery ( name = \"CardEdition.findByNameAndExpansion\" , query = \"select c from CardEdition c where c.card.name = :cardName and c.expansion.name = :expansionName\" ) , @ NamedQuery ( name = \"CardEdition.findByNameAndExpansionCode\" , query = \"select c from CardEdition c where c.card.name = :cardName and c.expansion.code = :expansionCode\" ) , @ NamedQuery ( name = \"CardEdition.findByCardId\" , query = \"select c from CardEdition c where c.card.id = :cardId\" ) , @ NamedQuery ( name = \"CardEdition.findByCardNumberAndExpansionId\" , query = \"select c from CardEdition c where c.cardNumber = :cardNumber and c.expansion.id = :expansionId\" ) } ) @ Entity public class CardEdition implements Serializable { public static final String FIND_BY_NAME_AND_EXPANSION = \"CardEdition.findByNameAndExpansion\" ; public static final String FIND_BY_NAME_AND_EXPANSION_CODE = \"CardEdition.findByNameAndExpansionCode\" ; public static final String FIND_BY_CARD_NUMBER_AND_EXPANSION_ID = \"CardEdition.findByCardNumberAndExpansionId\" ; public static final String FIND_BY_CARD_ID = \"CardEdition.findByCardId\" ; @ Id @ GeneratedValue ( strategy = GenerationType . AUTO ) private Long id ; @ ManyToOne private Card card ; @ ManyToOne ( fetch = FetchType . EAGER ) private Expansion expansion ; @ Column ( length = 64 ) private String gathererId ; @ Column ( length = 64 ) private String cardNumber ; @ Column ( length = 64 ) private String mtgoImageId ; @ Enumerated ( EnumType . ORDINAL ) @ Column ( nullable = false ) private CardRarity rarity ; public Card getCard ( ) { return card ; } public void setCard ( Card card ) { this . card = card ; } public String getCardNumber ( ) { return cardNumber ; } public void setCardNumber ( String cardNumber ) { this . cardNumber = cardNumber ; } public Expansion getExpansion ( ) { return expansion ; } public", "gt": "void setExpansion ( Expansion expansion )", "prediction": "void setExpansion ( Expansion expansion )\n", "label": 0}
{"id": 14984, "input": "<s> package org . apache . lucene . queryParser . standard . config ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . standard . processors . ParametricRangeQueryNodeProcessor ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . MultiTermQuery . RewriteMethod ; import org . apache . lucene . util . AttributeImpl ; public class MultiTermRewriteMethodAttributeImpl extends AttributeImpl implements MultiTermRewriteMethodAttribute { private static final long serialVersionUID = - 2104763012723049527L ; private MultiTermQuery . RewriteMethod multiTermRewriteMethod = MultiTermQuery . CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ; public MultiTermRewriteMethodAttributeImpl ( ) { } public void setMultiTermRewriteMethod ( MultiTermQuery . RewriteMethod method ) { multiTermRewriteMethod = method ; }", "gt": "public MultiTermQuery . RewriteMethod getMultiTermRewriteMethod ( )", "prediction": "}\n", "label": 1}
{"id": 6708, "input": "<s> public class TestThrowsTagInheritence extends JavadocTester { private static final String BUG_ID = \"4684827-4633969\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"Foo.html\" , \"Test 1 passes.\" } } ; private static final String [ ] [ ] NEGATED_TEST = { { BUG_ID + FS + \"C.html\" , \"Test 1 fails.\" } } ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , SRC_DIR + FS + \"C.java\" , SRC_DIR + FS + \"I.java\" , SRC_DIR + FS + \"Foo.java\" , SRC_DIR + FS + \"Iface.java\" } ; public static void main ( String [ ] args ) { TestThrowsTagInheritence tester = new TestThrowsTagInheritence ( ) ; run ( tester , ARGS ,", "gt": "TEST , NEGATED_TEST ) ;", "prediction": "TEST ) ;\n", "label": 0}
{"id": 14985, "input": "<s> package org . nuxeo . ecm . automation . core . operations . document ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . collectors . DocumentModelCollector ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; @ Operation ( id = DeleteDocument . ID , category = Constants . CAT_DOCUMENT , label = \"Delete\" , description = \"Delete the input document. The previous context input will be restored for the next operation.\" ) public class DeleteDocument { public static final String ID = \"Document.Delete\" ; @ Context protected CoreSession session ; @ OperationMethod ( collector = DocumentModelCollector . class )", "gt": "public DocumentModel run ( DocumentRef doc ) throws Exception", "prediction": "protected DocumentModel collectDocument ;\n", "label": 1}
{"id": 4666, "input": "<s> package org . meqantt . message ; import java . io . IOException ; public class PingReqMessage extends Message { public PingReqMessage ( ) { super ( Type . PINGREQ ) ; } public PingReqMessage ( Header header ) throws IOException { super ( header ) ; } @ Override public void setDup ( boolean dup ) { throw new UnsupportedOperationException ( \"PINGREQ message does not support the DUP flag\" ) ; } @ Override public void setQos ( QoS qos ) { throw new UnsupportedOperationException ( \"PINGREQ message", "gt": "does not support the QoS flag\" ) ;", "prediction": "does not support the QOS flag\" ) ;\n", "label": 0}
{"id": 14995, "input": "<s> package org . nuxeo . ecm . platform . annotations ; import java . io . InputStream ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . annotations . api . Annotation ; import org . nuxeo . ecm . platform . annotations . api . AnnotationException ; import org . nuxeo . ecm . platform . annotations . api . AnnotationManager ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; import org . nuxeo . ecm . platform . annotations . service . DefaultUriResolver ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . runtime . test . NXRuntimeTestCase ; public class AnnotationManagerTest extends NXRuntimeTestCase { private final AnnotationManager manager = new AnnotationManager ( ) ; @ Before public void setUp ( ) throws Exception { super . setUp ( ) ; deployBundle ( \"org.nuxeo.ecm.relations\" ) ; deployBundle ( \"org.nuxeo.ecm.relations.jena\" ) ; } @ Test public void testGetPostNewAnnotation ( ) throws AnnotationException { assertNotNull ( manager ) ; InputStream is = getClass ( ) . getResourceAsStream ( \"/post-rdf.xml\" ) ; assertNotNull ( is ) ; Annotation annotation = manager . getAnnotation ( is ) ; assertNotNull ( annotation ) ; assertEquals ( \"http://www.w3.org/2005/Incubator/\" , annotation . getAnnotates ( ) . toString ( ) ) ; annotation . setSubject ( new ResourceImpl ( \"http://foo/1\" ) ) ; assertEquals ( \"http://www.w3.org/2005/Incubator/\" , annotation . getAnnotates ( ) . toString ( ) ) ; } @", "gt": "Test public void testReadAnnoteaSpecPost ( ) throws AnnotationException", "prediction": "Test public void testGetPostNewAnnotation ( ) throws AnnotationException\n", "label": 1}
{"id": 2136, "input": "<s> package com . sap . prd . mobile . ios . mios ; public enum PackagingType { APP ( \"xcode-app\" ) , LIB ( \"xcode-lib\" ) , FRAMEWORK ( \"xcode-framework\" ) ; private final String packagingName ; private PackagingType ( String mavenPackaging ) { this . packagingName = mavenPackaging ; } public String getMavenPackaging ( ) { return packagingName ; } public static PackagingType getByMavenType ( String mavenPackaging ) { for ( PackagingType type : PackagingType . values ( ) ) { if ( type . getMavenPackaging ( ) . equals ( mavenPackaging ) ) { return type ; } } throw new IllegalArgumentException ( \"Maven Packaging", "gt": "type '\" + mavenPackaging + \"' does not exist\" ) ;", "prediction": "\" ) ;\n", "label": 0}
{"id": 14999, "input": "<s> package org . gatein . common . http ; import java . io . Serializable ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; @ SuppressWarnings ( \"serial\" ) public class HttpRequest implements Serializable { public abstract static class Body implements Serializable { } public static class Raw extends Body { private byte [ ] bytes ; public byte [ ] getBytes ( ) { return bytes ; } public void setBytes ( byte [ ] bytes ) { this . bytes = bytes ; } } public static class Form extends Body { private Map < String , String [ ] > parameters = new HashMap < String , String [ ] > ( ) ; public void addParameter ( String name , String [ ] values ) { if ( name == null ) { throw new IllegalStateException ( ) ; } if ( values == null ) { throw new IllegalStateException ( ) ; } for ( int i = 0 ; i < values . length ; i ++ ) { String value = values [ i ] ; if ( value == null ) { throw new IllegalStateException ( ) ; } } parameters . put ( name , values . clone ( ) ) ; } public void removeParameter ( String name ) { if ( name == null ) { throw new IllegalStateException ( ) ; } parameters . remove ( name ) ; } public Set < String > getParameterNames ( ) { return Collections . unmodifiableSet ( parameters . keySet ( ) ) ; } public String [ ] getParameterValues ( String name ) { if ( name == null ) { throw new IllegalStateException ( ) ; } String [ ] values = ( String [ ]", "gt": ") parameters . get ( name ) ;", "prediction": ") values ;\n", "label": 1}
{"id": 6805, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Task ; import org . jjflyboy . tjpeditor . project . TaskTimesheet ; import org . jjflyboy . tjpeditor . project . TaskTimesheetAttribute ; public class TaskTimesheetImpl extends TimesheetAttributeImpl implements TaskTimesheet { protected Task task ; protected EList < TaskTimesheetAttribute > attributes ; protected TaskTimesheetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getTaskTimesheet ( ) ; } public Task getTask ( ) { if ( task != null && task . eIsProxy ( ) ) { InternalEObject oldTask = ( InternalEObject ) task ; task = ( Task ) eResolveProxy ( oldTask ) ; if ( task != oldTask ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . TASK_TIMESHEET__TASK , oldTask , task ) ) ; } } return task ; } public Task basicGetTask ( ) { return task ; } public void setTask ( Task newTask ) { Task oldTask = task ; task = newTask ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . TASK_TIMESHEET__TASK , oldTask , task ) ) ; } public EList < TaskTimesheetAttribute > getAttributes ( ) { if ( attributes == null ) { attributes = new EObjectContainmentEList < TaskTimesheetAttribute > ( TaskTimesheetAttribute . class , this , ProjectPackage . TASK_TIMESHEET__ATTRIBUTES ) ; } return attributes ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . TASK_TIMESHEET__ATTRIBUTES : return ( ( InternalEList < ? > ) getAttributes ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . TASK_TIMESHEET__TASK : if ( resolve ) return getTask ( ) ; return basicGetTask ( ) ; case ProjectPackage . TASK_TIMESHEET__ATTRIBUTES : return getAttributes ( ) ; } return super", "gt": ". eGet ( featureID , resolve , coreType ) ;", "prediction": ". eGet ( featureID , resolve , coreType ) ;\n", "label": 0}
{"id": 15004, "input": "<s> package com . talis . hbase . rdf . test ; import junit . framework . TestSuite ; import org . junit . runners . AllTests ; import org . junit . runner . RunWith ; import com . talis . hbase . rdf . test . graph . TestHBaseRdfGraph ; import com . talis . hbase . rdf . test . graph . TestHBaseRdfReifier ; import com . talis . hbase . rdf . test . model . TestHBaseRdfModel ; @ RunWith ( AllTests . class ) public class HBaseRdfModelGraphTestSuite extends TestSuite { static boolean includeSimple = true ; static boolean includeVertPart = true ; static boolean includeIndexed = true ; static boolean includeVPIndexed = true ; static boolean includeHybrid = true ; static boolean includeHash = true ; public static junit . framework . Test suite ( ) { TestSuite ts = new TestSuite ( ) ; if ( includeSimple ) { ts . addTestSuite ( TestHBaseRdfModel . TestHBaseRdfSimpleModel . class ) ; ts . addTestSuite ( TestHBaseRdfGraph . TestHBaseRdfSimpleGraph . class ) ; ts . addTestSuite ( TestHBaseRdfReifier . TestHBaseRdfSimpleReifier . class ) ; } if ( includeVertPart ) { ts . addTestSuite ( TestHBaseRdfModel . TestHBaseRdfVertPartModel . class ) ; ts", "gt": ". addTestSuite ( TestHBaseRdfGraph . TestHBaseRdfVertPartGraph . class ) ;", "prediction": ". addTestSuite ( TestHBaseRdfReifier . TestHBaseRdfVertPartModel . class ) ;\n", "label": 1}
{"id": 10092, "input": "<s> package org . dawb . workbench . plotting . system . swtxy . util ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . Shape ; import org . eclipse . draw2d . geometry . Point ; import org . eclipse . draw2d . geometry . PointList ; import org . eclipse . draw2d . geometry . PrecisionPoint ; import org . eclipse . swt . SWT ; public class RotatableEllipse extends Shape { private static PrecisionPoint centre = new PrecisionPoint ( 0.5 , 0.5 ) ; private AffineTransform affine ; private PointList box ; private boolean outlineOnly = false ; private boolean showMajorAxis = false ; public RotatableEllipse ( ) { affine = new AffineTransform ( ) ; } public RotatableEllipse ( double cx , double cy , double major , double minor , double angle ) { affine = new AffineTransform ( ) ; affine . setTranslation ( cx - 0.5 * major , cy - 0.5 * minor ) ; affine . setScale ( major , minor ) ; setAngle ( angle ) ; } public void setCentre ( double cx , double cy ) { Point oc = affine . getTransformed ( centre ) ; affine . setTranslation ( affine . getTranslationX ( ) + cx - oc . preciseX ( ) , affine . getTranslationY ( ) + cy - oc . preciseY ( ) ) ; calcBox ( ) ; } public void setAngle ( double degrees ) { Point oc = affine . getTransformed ( centre ) ; affine . setRotationDegrees ( - degrees ) ; Point nc = affine . getTransformed ( centre ) ; affine . setTranslation ( affine . getTranslationX ( ) + oc . preciseX ( ) - nc . preciseX ( ) , affine . getTranslationY ( ) + oc . preciseY ( ) - nc . preciseY ( ) ) ; calcBox ( ) ; } public double getAngleDegrees ( ) { return - affine . getRotationDegrees ( ) ; } public Point getCentre ( ) { return affine . getTransformed ( centre ) ; } public double [ ] getAxes ( ) { return new double [ ] { affine . getScaleX ( ) , affine . getScaleY ( ) } ; } public Point getPoint ( double degrees ) { double angle = - Math . toRadians ( degrees ) ; double c = Math . cos ( angle ) ; double s = Math . sin ( angle ) ; PrecisionPoint p = new PrecisionPoint ( 0.5 * ( c + 1 ) , 0.5 * ( s + 1 ) ) ; return affine . getTransformed ( p ) ; } public void showMajorAxis ( boolean show ) { showMajorAxis = show ; } public AffineTransform getAffineTransform ( ) { return affine . clone ( ) ; } public void setAxes ( double major , double minor ) { Point oc = affine . getTransformed ( centre ) ; affine . setScale ( major , minor ) ; Point nc = affine . getTransformed ( centre ) ; affine . setTranslation ( affine . getTranslationX ( ) + oc . preciseX ( ) - nc . preciseX ( ) , affine . getTranslationY ( ) + oc . preciseY ( ) - nc . preciseY ( ) ) ; calcBox ( ) ; } private void calcBox ( ) { box = affine . getTransformedUnitSquare ( ) ; setBounds ( box . getBounds ( ) ) ; } @ Override public void setLocation ( Point p ) { affine . setTranslation ( p . preciseX ( ) , p . preciseY ( ) ) ; calcBox ( ) ; } @ Override public boolean containsPoint ( int x , int y ) { if ( outlineOnly ) { double d = affine . getInverseTransformed ( new PrecisionPoint ( x , y ) ) . getDistance ( centre ) ; return Math . abs ( d - 0.5 ) < 2. / Math . max ( affine . getScaleX ( ) , affine . getScaleY ( ) ) ; } if ( ! super . containsPoint ( x , y ) || ! box . polygonContainsPoint ( x , y ) ) return false ; Point p = affine . getInverseTransformed ( new PrecisionPoint ( x , y ) ) ; return p . getDistance ( centre ) <= 0.5 ; } @ Override public void setFill ( boolean b ) { super . setFill ( b ) ; outlineOnly = ! b ; } @ Override protected void fillShape ( Graphics graphics ) { graphics . pushState ( ) ; graphics . setAdvanced ( true ) ; graphics . setAntialias (", "gt": "SWT . ON ) ;", "prediction": "true ) ;\n", "label": 0}
{"id": 15012, "input": "<s> package org . fuzzydb . server . internal . index ; import org . fuzzydb . client . exceptions . KeyCollisionException ; import org . fuzzydb . client . internal . RefImpl ; public interface Index < T > { void initialise ( ) ; public void testInsert ( RefImpl < T >", "gt": "ref , T o ) throws KeyCollisionException ;", "prediction": "impl ) ;\n", "label": 1}
{"id": 1800, "input": "<s> public abstract class AbstractElement < E extends Element < E , P , V > , P extends PlainForm < E , P , V > , V extends VariableForm < E , P , V > >", "gt": "implements Element < E , P , V >", "prediction": "\n", "label": 0}
{"id": 15016, "input": "<s> package org . eclipse . core . tests . session . samples ; import junit . framework . Test ; import junit . framework . TestCase ; import org . eclipse . core . tests . harness . CoreTest ; import org . eclipse . core . tests . session . SessionTestSuite ; public class SampleCrashTest extends TestCase { public SampleCrashTest ( String methodName ) { super ( methodName ) ; } public void test1 ( ) { System . out . println ( getName ( ) ) ; } public void test2 ( ) { System . out . println ( getName ( ) ) ; System . exit ( 2 ) ; }", "gt": "public void test3 ( )", "prediction": "public void test3 ( )\n", "label": 1}
{"id": 5572, "input": "<s> package org . xbill . DNS ; public class NSRecord extends SingleCompressedNameBase { private static final long serialVersionUID = 487170758138268838L ; NSRecord ( ) { } Record getObject ( ) { return new NSRecord ( ) ; } public NSRecord ( Name name , int dclass , long ttl , Name target ) { super ( name , Type . NS", "gt": ", dclass , ttl , target , \"target\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15019, "input": "<s> package org . restlet . ext . oauth ; import java . util . List ; import org . restlet . ext . oauth . internal . Token ; import org . restlet . security . Role ; public abstract class AuthenticatedUser { public abstract void addRole ( Role r , String owner ) ; public abstract void clearCode ( ) ; public abstract Client getClient ( ) ; public abstract String getCode ( ) ; public abstract List < Role > getGrantedRoles ( ) ; public abstract String getId ( ) ; public abstract String getPassword ( ) ; public abstract Token getToken ( ) ; public abstract long getTokenExpire ( ) ; public abstract boolean isGrantedRole ( Role role , String owner ) ; public boolean persist ( ) { return true ; } public abstract void revokeRole ( Role role , String owner ) ; public abstract void revokeRoles ( ) ; public abstract void setCode ( String code ) ; public abstract void", "gt": "setPassword ( String password ) ;", "prediction": "setPassword ( String password ) ;\n", "label": 1}
{"id": 9981, "input": "<s> package com . deliciousdroid . util ; import com . deliciousdroid . Constants ; import com . deliciousdroid . syncadapter . PeriodicSyncReceiver ; import android . accounts . Account ; import android . accounts . AccountManager ; import android . app . AlarmManager ; import android . app . PendingIntent ; import android . content . ContentResolver ; import android . content . Context ; import android . os . Bundle ; import android . os . SystemClock ; public class SyncUtils { public static void addPeriodicSync ( String authority , Bundle extras , long frequency , Context context ) { long pollFrequencyMsec = frequency * 60000 ; if ( android . os . Build . VERSION . SDK_INT < 8 ) { AlarmManager manager = ( AlarmManager ) context . getSystemService ( Context . ALARM_SERVICE ) ; int type = AlarmManager . ELAPSED_REALTIME_WAKEUP ; long triggerAtTime = SystemClock . elapsedRealtime ( ) + pollFrequencyMsec ; long interval = pollFrequencyMsec ; PendingIntent operation = PeriodicSyncReceiver . createPendingIntent ( context , authority , extras ) ; manager . setInexactRepeating ( type , triggerAtTime , interval , operation ) ; } else { AccountManager am = AccountManager . get ( context ) ; Account [ ] accounts = am . getAccountsByType ( Constants . ACCOUNT_TYPE ) ; for ( Account a : accounts ) { ContentResolver . addPeriodicSync ( a , authority , extras , frequency * 60 ) ; } } } public static void removePeriodicSync ( String authority , Bundle extras , Context context ) { if ( android .", "gt": "os . Build . VERSION . SDK_INT >= 8 )", "prediction": "os . Build . VERSION . SDK_INT < 8 )\n", "label": 0}
{"id": 15037, "input": "<s> package org . jscsi . target . scsi . modeSense ; import org . jscsi . target . scsi . cdb . ModeSense6Cdb ; public enum PageControl { CURRENT_VALUES ( 0x00 ) , CHANGEABLE_VALUES ( 0x01 ) , DEFAULT_VALUES ( 0x02 ) , SAVED_VALUES ( 0x03 ) ; private final int value ; private PageControl ( final int value ) { this . value = value ; } public static PageControl getPageControl ( final int value ) {", "gt": "final PageControl [ ] vals = values ( ) ;", "prediction": "return pageControl ;\n", "label": 1}
{"id": 2391, "input": "<s> package ar . com . fdvs . dj . domain ; import ar . com . fdvs . dj . domain . constants . LabelPosition ; import ar . com . fdvs . dj . domain . entities . Entity ; public class DJLabel extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; protected boolean isJasperExpression = false ; protected String text ; protected CustomExpression labelExpression ; protected Style style ; protected int height = 15 ; public DJLabel ( ) { } ; public DJLabel ( String text , Style labelStyle ) { super ( ) ; this . text = text ; this . style = labelStyle ; } public DJLabel ( String text , Style labelStyle , boolean isJasperExpression ) { super ( ) ; this . text = text ; this . style = labelStyle ; this . isJasperExpression = isJasperExpression ; } public DJLabel ( String text , Style labelStyle , LabelPosition labelPosition ) { super ( ) ; this . text = text ; this . style = labelStyle ; } public DJLabel ( CustomExpression labelExpression , Style labelStyle ) { super ( ) ; this . labelExpression = labelExpression ; this . style = labelStyle ; } public CustomExpression getLabelExpression ( ) { return labelExpression ; } public void setLabelExpression ( CustomExpression labelExpression ) { this . labelExpression = labelExpression ; } public String getText ( ) { return text ; } public void setText ( String text ) { this . text = text ; } public Style getStyle ( ) { return style ; } public void setStyle ( Style style ) { this . style = style ; }", "gt": "public int getHeight ( )", "prediction": "}\n", "label": 0}
{"id": 15039, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui . editor . outline ; import org . eclipse . jface . text . BadPositionCategoryException ; import org . eclipse . jface . text . DefaultPositionUpdater ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IPositionUpdater ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import com . googlecode . veloeclipse . editor . VelocityEditor ; import com . googlecode . veloeclipse . vaulttec . ui . model . ITreeNode ; public class VelocityOutlineContentProvider implements ITreeContentProvider { public static final String VELOCITY_TEMPLATE = \"__velocity_template\" ; private VelocityEditor fEditor ; private IPositionUpdater fPositionUpdater ; public VelocityOutlineContentProvider ( VelocityEditor anEditor ) { fEditor = anEditor ; fPositionUpdater = new DefaultPositionUpdater ( VELOCITY_TEMPLATE ) ; } public void inputChanged ( Viewer aViewer , Object anOldInput , Object aNewInput ) { if ( anOldInput != aNewInput ) { if ( anOldInput != null ) { IDocument document = fEditor . getDocumentProvider ( ) . getDocument ( anOldInput ) ; if ( document != null ) { try { document . removePositionCategory ( VELOCITY_TEMPLATE ) ; } catch ( BadPositionCategoryException e ) { } document . removePositionUpdater ( fPositionUpdater ) ; } } if ( aNewInput != null ) { IDocument document = fEditor . getDocumentProvider ( ) . getDocument ( aNewInput ) ; if ( document != null ) { document . addPositionCategory ( VELOCITY_TEMPLATE ) ; document . addPositionUpdater ( fPositionUpdater ) ; } } } } public void dispose ( ) { } public Object", "gt": "[ ] getElements ( Object inputElement )", "prediction": "dispose ( )\n", "label": 1}
{"id": 2027, "input": "<s> package com . mapr . stats ; import org . apache . mahout . math . jet . random . AbstractContinousDistribution ; import java . util . Arrays ; import static org . junit . Assert . assertEquals ; public class DistributionTest { protected void checkDistribution ( AbstractContinousDistribution d , String test , double epsilon ) { int n = 40001 ; double [ ] s = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = d . nextDouble ( ) ; } Arrays . sort ( s ) ; for ( int q = 0 ; q <= 4 ; q ++ ) { assertEquals ( test + \", q = \" + q , d . cdf ( s [ ( n - 1 ) * q / 4 ] ) , q / 4.0 , epsilon ) ; } } protected void cdfCheck ( double [ ] expected , double [ ] cdf , AbstractContinousDistribution d ) { for ( int i = 0 ; i < expected . length ; i ++ ) { assertEquals ( expected [ i ] , d . cdf", "gt": "( cdf [ i ] ) , 1e-10 ) ;", "prediction": "( expected [ i ] ) ) ;\n", "label": 0}
{"id": 15047, "input": "<s> package org . restlet . representation ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . Writer ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; import org . restlet . engine . io . BioUtils ; public abstract class CharacterRepresentation extends Representation { public CharacterRepresentation ( MediaType mediaType ) { super ( mediaType ) ; setCharacterSet ( CharacterSet . UTF_8 ) ; } @ Override public java . nio . channels . ReadableByteChannel getChannel ( ) throws IOException { return org . restlet . engine . io . NioUtils . getChannel ( getStream ( ) ) ; } @ Override public InputStream getStream ( ) throws IOException { return BioUtils . getInputStream ( getReader ( ) , getCharacterSet ( ) ) ; } @ Override public void write ( OutputStream outputStream ) throws IOException { Writer writer = BioUtils . getWriter ( outputStream , getCharacterSet ( ) ) ; write ( writer ) ;", "gt": "writer . flush ( ) ;", "prediction": "}\n", "label": 1}
{"id": 1818, "input": "<s> package com . mobeelizer . mobile . android . search ; import static org . junit . Assert . assertEquals ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . when ; import java . util . ArrayList ; import java . util . List ; import org . junit . Test ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerNotRestritionImplTest { @ Test public void shouldAddToQuery ( ) throws Exception { MobeelizerInternalCriterion criterion = mock ( MobeelizerInternalCriterion . class ) ; MobeelizerNotRestritionImpl restrition = new MobeelizerNotRestritionImpl ( criterion ) ; List < String > selectionArgs = new", "gt": "ArrayList < String > ( ) ;", "prediction": "ArrayList < String > ( ) ;\n", "label": 0}
{"id": 15048, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . rap . rwt . internal . protocol . ProtocolMessageWriter ; import org . eclipse . rap . rwt . internal . protocol . ProtocolUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . internal . graphics . FontUtil ; public class MeasurementUtil { public static void appendStartupTextSizeProbe ( ProtocolMessageWriter writer ) { MeasurementOperator . getInstance ( ) . appendStartupTextSizeProbe ( writer ) ; } static Object createItemParamObject ( MeasurementItem item ) { Object [ ] result = new Object [ 8 ] ; FontData fontData = item . getFontData ( ) ; result [ 0 ] = getId ( item ) ; result [ 1 ] = item . getTextToMeasure ( ) ; result [ 2 ] = ProtocolUtil . parseFontName ( fontData . getName ( ) ) ; result [ 3 ] = Integer . valueOf ( fontData . getHeight ( ) ) ; result [ 4 ] = Boolean . valueOf ( ( fontData . getStyle ( ) & SWT . BOLD ) != 0 ) ; result [ 5 ] = Boolean . valueOf ( ( fontData . getStyle ( ) & SWT . ITALIC ) != 0 ) ; result [ 6 ] = Integer . valueOf ( item . getWrapWidth ( ) ) ; result [ 7 ] = Boolean . valueOf ( isMarkup ( item . getMode ( ) ) ) ; return result ; } static Object createProbeParamObject ( Probe probe ) { Object [ ] result = new Object [ 8 ] ; FontData fontData = probe", "gt": ". getFontData ( ) ;", "prediction": ". getFontData ( ) ;\n", "label": 1}
{"id": 5014, "input": "<s> package ar . com . fdvs . dj . core ; import java . awt . image . BufferedImage ; import net . sourceforge . barbecue . Barcode ; import net . sourceforge . barbecue . BarcodeFactory ; import net . sourceforge . barbecue . BarcodeImageHandler ; import net . sourceforge . barbecue . linear . code39 . Code39Barcode ; import net . sourceforge . barbecue . linear . ean . UCCEAN128Barcode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public class BarcodeHelper implements BarcodeTypes { private static final Log logger = LogFactory . getLog ( BarcodeHelper . class ) ; private static Barcode bc = null ; public static BufferedImage getBarcodeImage ( int type , Object aText , boolean showText , boolean checkSum ) { return getBarcodeImage ( type , aText , showText , checkSum , \"\" , 0 , 0 ) ; } public static BufferedImage getBarcodeImage ( int type , Object aText , boolean showText , boolean checkSum , Object applicationIdentifier , int width , int height ) { String text = null ; if ( aText instanceof String ) text = ( ( String ) ( aText ) ) ; else text = aText . toString ( ) ; try { switch ( type ) { case _2_OF_7 : bc = BarcodeFactory . create2of7 ( text ) ; break ; case _3_OF_9 : bc = BarcodeFactory . create3of9 ( text , checkSum ) ; break ; case BOOKLAND : bc = BarcodeFactory . createBookland ( text ) ; break ; case CODABAR : bc = BarcodeFactory . createCodabar ( text ) ; break ; case CODE_128 : bc = BarcodeFactory . createCode128 ( text ) ; break ; case CODE_128A : bc = BarcodeFactory . createCode128A ( text ) ; break ; case CODE_128B : bc = BarcodeFactory . createCode128B ( text ) ; break ; case CODE_128C : bc = BarcodeFactory . createCode128B ( text ) ; break ; case CODE_39 : bc = BarcodeFactory . createCode39 ( text , checkSum ) ; break ; case EAN128 : bc = BarcodeFactory . createEAN128 ( text ) ; break ; case EAN13 : bc = BarcodeFactory . createEAN13 ( text ) ; break ; case GLOBAL_TRADE_IT_NUMBER : bc = BarcodeFactory . createGlobalTradeItemNumber ( text ) ; break ; case INT_2_OF_5 : bc = BarcodeFactory . createInt2of5 ( text , checkSum ) ; break ; case MONARCH : bc = BarcodeFactory . createMonarch ( text ) ; break ; case NW7 : bc = BarcodeFactory . createNW7 ( text ) ; break ; case PDF417 : bc = BarcodeFactory . createPDF417 ( text ) ; break ; case SCC14_SHIPPING_CODE : bc = BarcodeFactory . createSCC14ShippingCode ( text ) ; break ; case SHIPMENT_IDENTIFICATION_NUMBER : bc = BarcodeFactory . createShipmentIdentificationNumber ( text ) ; break ; case UCCEAN128_00 : bc = new UCCEAN128Barcode ( \"00\" , text , checkSum ) ; break ; case STD_2_OF_5 : bc = BarcodeFactory . createStd2of5 ( text , checkSum ) ; break ; case UCCEAN128 : if ( applicationIdentifier == null ) applicationIdentifier = \"\" ; bc = new UCCEAN128Barcode ( applicationIdentifier . toString ( ) , text , checkSum ) ; break ; case UPCA : bc = BarcodeFactory . createUPCA ( text ) ; break ; case USD3 : bc = BarcodeFactory . createUSD3 ( text , checkSum ) ; break ; case USD4 : bc = BarcodeFactory . createUSD4 ( text ) ; break ; case USPS : bc", "gt": "= BarcodeFactory . createUSPS ( text ) ;", "prediction": "= new UCCEAN128Barcode ( \"01\" , text , checkSum ) ;\n", "label": 0}
{"id": 15049, "input": "<s> package org . apache . lucene . benchmark . byTask . tasks ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . benchmark . byTask . PerfRunData ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class NewAnalyzerTask extends PerfTask { private List analyzerClassNames ; private int current ; public NewAnalyzerTask ( PerfRunData runData ) { super ( runData ) ; analyzerClassNames = new ArrayList ( ) ; } public int doLogic ( ) throws IOException { String className = null ; try { if ( current >= analyzerClassNames . size ( ) ) { current = 0 ; } className = ( String ) analyzerClassNames . get ( current ++ ) ; if ( className == null || className . equals ( \"\" ) ) { className = \"org.apache.lucene.analysis.standard.StandardAnalyzer\" ; } if ( className . indexOf ( \".\" ) == - 1 || className . startsWith ( \"standard.\" ) ) { className = \"org.apache.lucene.analysis.\" + className ; } getRunData ( ) . setAnalyzer ( ( Analyzer ) Class . forName ( className ) . newInstance ( ) ) ; System . out . println ( \"Changed Analyzer to: \" + className ) ; } catch ( Exception e ) { throw new RuntimeException ( \"Error creating Analyzer: \" + className , e ) ; } return 1 ; } public void setParams ( String params ) { super . setParams ( params ) ; for ( StringTokenizer tokenizer = new StringTokenizer ( params , \",\" ) ; tokenizer . hasMoreTokens ( ) ; ) {", "gt": "String s = tokenizer . nextToken ( ) ;", "prediction": "try\n", "label": 1}
{"id": 3619, "input": "<s> package org . ofbiz . order . shoppingcart ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . * ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericPK ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . entity . util . EntityUtilProperties ; import org . ofbiz . order . finaccount . FinAccountHelper ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . shoppingcart . product . ProductPromoWorker ; import org . ofbiz . order . shoppingcart . shipping . ShippingEstimateWrapper ; import org . ofbiz . order . shoppinglist . ShoppingListEvents ; import org . ofbiz . party . contact . ContactHelper ; import org . ofbiz . party . contact . ContactMechWorker ; import org . ofbiz . product . category . CategoryWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import java . io . Serializable ; import java . math . BigDecimal ; import java . math . MathContext ; import java . sql . Timestamp ; import java . util . * ; import java . util . Map . Entry ; @ SuppressWarnings ( \"serial\" ) public class ShoppingCart implements Iterable < ShoppingCartItem > , Serializable { public static final String module = ShoppingCart . class . getName ( ) ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static final int ALL = 1 ; public static final int EMPTY_ONLY = 2 ; public static final int FILLED_ONLY = 3 ; public static final int scale = UtilNumber . getBigDecimalScale ( \"order.decimals\" ) ; public static final int rounding = UtilNumber . getBigDecimalRoundingMode ( \"order.rounding\" ) ; public static final int taxCalcScale = UtilNumber . getBigDecimalScale ( \"salestax.calc.decimals\" ) ; public static final int taxFinalScale = UtilNumber . getBigDecimalScale ( \"salestax.final.decimals\" ) ; public static final int taxRounding = UtilNumber . getBigDecimalRoundingMode ( \"salestax.rounding\" ) ; public static final BigDecimal ZERO = BigDecimal . ZERO ; public static final BigDecimal percentage = new BigDecimal ( \"0.01\" ) ; public static final MathContext generalRounding = new MathContext ( 10 ) ; private String orderType = \"SALES_ORDER\" ; private String channel = \"UNKNWN_SALES_CHANNEL\" ; private String poNumber = null ; private String orderId = null ; private String orderName = null ; private String orderStatusId = null ; private String orderStatusString = null ; private String firstAttemptOrderId = null ; private String externalId = null ; private String internalCode = null ; private String billingAccountId = null ; private BigDecimal billingAccountAmt = BigDecimal . ZERO ; private String agreementId = null ; private String quoteId = null ; private String workEffortId = null ; private long nextItemSeq = 1 ; private String defaultItemDeliveryDate = null ; private String defaultItemComment = null ; private String orderAdditionalEmails = null ; private boolean viewCartOnAdd = false ; private boolean readOnlyCart = false ; private Timestamp lastListRestore = null ; private String autoSaveListId = null ; private List < GenericValue > adjustments = FastList . newInstance ( ) ; private boolean orderTermSet = false ; private List < GenericValue > orderTerms = new LinkedList < GenericValue > ( ) ; private List < ShoppingCartItem > cartLines = FastList . newInstance ( ) ; private Map < String , ShoppingCartItemGroup > itemGroupByNumberMap = FastMap . newInstance ( ) ; protected long nextGroupNumber = 1 ; private List < CartPaymentInfo > paymentInfo = FastList . newInstance ( ) ; private List < CartShipInfo > shipInfo = FastList . < CartShipInfo > newInstance ( ) ; private Map < String , String > contactMechIdsMap = new HashMap < String , String > ( ) ; private Map < String , String > orderAttributes = FastMap . newInstance ( ) ; private Map < String , Object > attributes = FastMap . newInstance ( ) ; private List < String > internalOrderNotes = FastList . newInstance ( ) ; private List < String > orderNotes = FastList . newInstance ( ) ; private Map < String , List < String > > additionalPartyRole = new HashMap < String , List < String > > ( ) ; private Timestamp defaultShipAfterDate = null ; private Timestamp defaultShipBeforeDate = null ; private List < ProductPromoUseInfo > productPromoUseInfoList = FastList . newInstance ( ) ; private Set < String > productPromoCodes = new HashSet < String > ( ) ; private List < GenericValue > freeShippingProductPromoActions = new ArrayList < GenericValue > ( ) ; private Map < GenericPK , String > desiredAlternateGiftByAction = new HashMap < GenericPK , String > ( ) ; private Timestamp cartCreatedTs = UtilDateTime . nowTimestamp ( ) ; private transient Delegator delegator = null ; private String delegatorName = null ; protected String productStoreId = null ; protected boolean doPromotions = true ; protected String transactionId = null ; protected String facilityId = null ; protected String webSiteId = null ; protected String terminalId = null ; protected String autoOrderShoppingListId = null ; protected String orderPartyId = null ; protected String placingCustomerPartyId = null ; protected String billToCustomerPartyId = null ; protected String shipToCustomerPartyId = null ; protected String endUserCustomerPartyId = null ; protected String billFromVendorPartyId = null ; protected String shipFromVendorPartyId = null ; protected String supplierAgentPartyId = null ; protected GenericValue userLogin = null ; protected GenericValue autoUserLogin = null ; protected Locale locale ; protected String currencyUom = null ; protected boolean holdOrder = false ; protected Timestamp orderDate = null ; protected Timestamp cancelBackOrderDate = null ; protected ShoppingCart ( ) { } public ShoppingCart ( ShoppingCart cart ) { this . delegator = cart . getDelegator ( ) ; this . delegatorName = delegator . getDelegatorName ( ) ; this . productStoreId = cart . getProductStoreId ( ) ; this . doPromotions = cart . getDoPromotions ( ) ; this . poNumber = cart . getPoNumber ( ) ; this . orderId = cart . getOrderId ( ) ; this . orderName = \"Copy of \" + cart . getOrderName ( ) ; this . workEffortId = cart . getWorkEffortId ( ) ; this . firstAttemptOrderId = cart . getFirstAttemptOrderId ( ) ; this . billingAccountId = cart . getBillingAccountId ( ) ; this . agreementId = cart . getAgreementId ( ) ; this . quoteId = cart . getQuoteId ( ) ; this . orderAdditionalEmails = cart . getOrderAdditionalEmails ( ) ; this . adjustments . addAll (", "gt": "cart . getAdjustments ( ) ) ;", "prediction": "this ) ;\n", "label": 0}
{"id": 15055, "input": "<s> package io . beancounter . commons . nlp ; import java . net . URI ; import java . net . URISyntaxException ; public class Category extends Feature { public static Category build ( URI baseuri , String id , String label ) { try { return new Category ( new URI ( baseuri + \"/\" + id ) , label ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( \"[\" + baseuri + \"/\" + id + \"] is not a well formed URI\" , e ) ; } } public static Category build ( String uri , String label ) { try { return new Category ( new URI ( uri ) , label ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( \"[\" + uri + \"] is not a well", "gt": "formed URI\" , e ) ;", "prediction": "formed URI\" , e ) ;\n", "label": 1}
{"id": 6770, "input": "<s> package javax . lang . model . type ; public enum TypeKind { BOOLEAN , BYTE , SHORT , INT , LONG , CHAR , FLOAT , DOUBLE , VOID , NONE , NULL , ARRAY , DECLARED , ERROR , TYPEVAR , WILDCARD , PACKAGE , EXECUTABLE , OTHER , UNION ; public boolean isPrimitive ( ) { switch ( this ) { case BOOLEAN : case BYTE : case SHORT : case INT : case LONG : case CHAR :", "gt": "case FLOAT : case DOUBLE : return true ;", "prediction": "}\n", "label": 0}
{"id": 15064, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import java . io . IOException ; import java . io . InputStream ; import java . text . MessageFormat ; import java . util . Map ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . rap . rwt . application . Application ; import org . eclipse . rap . rwt . application . ApplicationConfiguration ; import org . eclipse . rap . rwt . internal . client . ClientProvider ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . theme . Theme ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . internal . theme . css . CssFileReader ; import org . eclipse . rap . rwt . internal . theme . css . StyleSheet ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . IEntryPointFactory ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . ResourceLoader ; import org . eclipse . rap . rwt . service . IServiceHandler ; import org . eclipse . rap . rwt . service . ISettingStoreFactory ; import org . eclipse . swt . widgets . Widget ; public class ApplicationImpl implements Application , Adaptable { private final ApplicationContext applicationContext ; private final ApplicationConfiguration configuration ; static class ResourceLoaderImpl implements ResourceLoader { private final ClassLoader loader ; private ResourceLoaderImpl ( ClassLoader loader ) { this . loader = loader ; } public InputStream getResourceAsStream ( String resourceName ) throws IOException { return loader . getResourceAsStream ( resourceName ) ; } } public ApplicationImpl ( ApplicationContext applicationContext , ApplicationConfiguration configuration ) { this . applicationContext = applicationContext ; this . configuration = configuration ; } public void setOperationMode ( OperationMode operationMode ) { ParamCheck . notNull ( operationMode , \"operationMode\" ) ; switch ( operationMode ) { case JEE_COMPATIBILITY : break ; case SWT_COMPATIBILITY : applicationContext . getLifeCycleFactory ( ) . configure ( RWTLifeCycle . class ) ; break ; case SESSION_FAILOVER : new SessionFailoverConfigurator ( applicationContext ) . configure ( ) ; break ; default : throw new IllegalArgumentException ( \"Unsupported operation mode: \" + operationMode ) ; } } public void addPhaseListener ( PhaseListener phaseListener ) { ParamCheck . notNull ( phaseListener , \"phaseListener\" ) ; applicationContext . getPhaseListenerRegistry ( ) . add ( phaseListener ) ; } public void setSettingStoreFactory ( ISettingStoreFactory settingStoreFactory ) { ParamCheck . notNull ( settingStoreFactory , \"settingStoreFactory\" ) ; applicationContext . getSettingStoreManager ( ) . register ( settingStoreFactory ) ; } public void addEntryPoint ( String path , Class < ? extends IEntryPoint > entryPointType , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointType , \"entryPointType\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointType , properties ) ; } public void addEntryPoint ( String path , IEntryPointFactory entryPointFactory , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointFactory , properties ) ; } public void addEntryPointByParameter ( String parameter , Class < ? extends IEntryPoint > type ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( type , \"type\" ) ; applicationContext . getEntryPointManager ( ) . registerByName ( parameter , type ) ; } public void addEntryPointByParameter ( String parameter , IEntryPointFactory entryPointFactory ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByName ( parameter , entryPointFactory ) ; } public void addResource ( IResource resource ) { ParamCheck . notNull ( resource , \"resource\" ) ; applicationContext . getResourceRegistry ( ) . add ( resource ) ; } public void addServiceHandler ( String serviceHandlerId , IServiceHandler serviceHandler ) { ParamCheck . notNull ( serviceHandlerId , \"serviceHandlerId\" ) ; ParamCheck . notNull ( serviceHandler , \"serviceHandler\" ) ; ServiceManager serviceManager = applicationContext . getServiceManager ( ) ; serviceManager . registerServiceHandler ( serviceHandlerId , serviceHandler ) ; } public void addStyleSheet ( String themeId , String styleSheetLocation ) { addStyleSheet ( themeId , styleSheetLocation , new ResourceLoaderImpl ( getClassLoader ( ) ) ) ; } public void addStyleSheet ( String themeId , String styleSheetLocation , ResourceLoader resourceLoader ) { ParamCheck . notNull ( themeId , \"themeId\" ) ; ParamCheck . notNull ( styleSheetLocation , \"styleSheetLocation\" ) ; ParamCheck . notNull ( resourceLoader , \"resourceLoader\" ) ; StyleSheet styleSheet = readStyleSheet ( styleSheetLocation , resourceLoader ) ; ThemeManager themeManager = applicationContext . getThemeManager ( ) ; Theme theme = themeManager . getTheme ( themeId ) ; if ( theme != null ) { theme . addStyleSheet ( styleSheet ) ; } else { themeManager . registerTheme ( new Theme ( themeId , \"unknown\" , styleSheet ) ) ; } } public void addThemableWidget", "gt": "( Class < ? extends Widget > widget )", "prediction": "( IWidget widget )\n", "label": 1}
{"id": 7279, "input": "<s> package com . shopzilla . api . service ; import com . shopzilla . services . catalog . ProductResponse ; import org . springframework . oxm . Marshaller ; import org . springframework . oxm . Unmarshaller ; import org . springframework . oxm . XmlMappingException ; import javax . xml . bind . JAXBException ; import javax . xml . transform . stream . StreamSource ; import java . io . IOException ; import java . io . InputStream ; public class ProductService { private Marshaller marshaller ; private Unmarshaller unmarshaller ; public ProductResponse xmlInputStreamToJava ( InputStream in ) throws IOException , JAXBException { try { ProductResponse productResponse = ( ProductResponse ) unmarshaller . unmarshal ( new StreamSource ( in ) ) ; System . out . println ( \"productResponse = \" + productResponse ) ; return productResponse ; } catch ( XmlMappingException xme ) { xme . printStackTrace ( ) ; } return null ; } public void setMarshaller ( Marshaller marshaller ) { this . marshaller = marshaller ; } public void setUnmarshaller ( Unmarshaller unmarshaller ) { this", "gt": ". unmarshaller = unmarshaller ;", "prediction": ". unmarshaller = unmarshaller ;\n", "label": 0}
{"id": 15066, "input": "<s> package com . poetry . dao ; import java . util . List ; import org . springframework . stereotype . Repository ; import com . poetry . model . Bookmark ; import com . poetry . model . Poetry ; @ Repository public class BookmarkDao extends AbstractDao { public boolean exists ( final String poetryId , final String poetId ) { return exists ( new Bookmark ( poetryId , poetId ) ) ; } public boolean exists ( final Bookmark bookmark ) { getSession ( ) . flush ( ) ; return exists ( Bookmark . class , bookmark ) ; } public void addBookmark ( final Bookmark bookmark ) { insert ( bookmark ) ; } public void removeBookmark ( final Bookmark bookmark ) { delete ( bookmark ) ; } public int getTheNumberOfBookmarks ( final String username ) { logger . trace ( \"trying the number of {}'s bookmark\" , username ) ; return ( ( Long ) findOne ( \"select count( bookmark.poetId ) \" + \"from Bookmark bookmark \" + \"where bookmark.poetId = ?\" , username ) ) . intValue ( ) ; } @ SuppressWarnings ( \"unchecked\"", "gt": ") public List < Poetry > getBookmarksOf ( String poetId )", "prediction": ") public void addBookmark ( final Bookmark bookmark )\n", "label": 1}
{"id": 427, "input": "<s> package com . redhat . ceylon . compiler . java . test . runtime ; import org . junit . runner . RunWith ; import com . redhat . ceylon . compiler . java . test . CeylonModuleRunner ; import com . redhat .", "gt": "ceylon . compiler . java . test . TestModule ;", "prediction": "ceylon . core . api . DocumentModel ;\n", "label": 0}
{"id": 15074, "input": "<s> package org . w3c . css . sac ; public interface DocumentHandler { public void startDocument ( InputSource source ) throws CSSException ; public void endDocument ( InputSource source ) throws CSSException ; public void comment ( String text ) throws CSSException ; public void ignorableAtRule ( String atRule ) throws CSSException ; public void namespaceDeclaration ( String prefix , String uri ) throws CSSException ; public void importStyle ( String uri , SACMediaList media , String defaultNamespaceURI ) throws CSSException ; public void startMedia ( SACMediaList media ) throws CSSException ; public void endMedia ( SACMediaList media ) throws CSSException ; public void startPage ( String name , String pseudo_page ) throws CSSException ; public void endPage ( String name , String pseudo_page ) throws CSSException ; public void startFontFace ( ) throws CSSException ; public void endFontFace ( ) throws CSSException ; public void startSelector ( SelectorList", "gt": "selectors ) throws CSSException ;", "prediction": "selectors ) throws CSSException ;\n", "label": 1}
{"id": 3182, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; import com . sun . source . util . * ; import com . sun . tools . javac . api . * ; public class T6430209 { public static void main ( String ... args ) throws IOException { File dir1 = new File ( \"dir1\" ) ; dir1 . mkdir ( ) ; BufferedWriter fout = new BufferedWriter ( new FileWriter ( new File ( dir1 , \"test0.java\" ) ) ) ; fout . write ( \"public class test0 { }\" ) ; fout . close ( ) ; String testSrc = System . getProperty ( \"test.src\" , \".\" ) ; String testClasses = System . getProperty ( \"test.classes\" ) + System . getProperty ( \"path.separator\" ) + \"../../lib\" ; JavacTool tool = JavacTool . create ( ) ; MyDiagListener dl = new MyDiagListener ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( dl , null , null ) ; fm . setLocation ( StandardLocation . CLASS_PATH , Arrays . asList ( new File ( \".\" ) ) ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( new File ( testSrc , \"test0.java\" ) , new File ( testSrc , \"test1.java\" ) ) ) ; Iterable < String > opts = Arrays . asList ( \"-proc:only\" , \"-processor\" , \"b6341534\" , \"-processorpath\" , testClasses ) ; StringWriter out =", "gt": "new StringWriter ( ) ;", "prediction": "new StringWriter ( opts ) ;\n", "label": 0}
{"id": 15075, "input": "<s> package com . emf4sw . rdf . examples ; import java . io . IOException ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . xmi . impl . XMIResourceFactoryImpl ; import com . atl . common . models . Models ; import com . emf4sw . rdf . resource . impl . TTLResourceFactory ; import com . emf4sw . rdf . transform . RDF2Model ; public class Rdf2EcoreModel { public static void main ( String [ ] args ) { Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"xmi\" , new XMIResourceFactoryImpl ( ) ) ; Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"ecore\" , new XMIResourceFactoryImpl ( ) ) ; Resource . Factory . Registry . INSTANCE . getExtensionToFactoryMap ( ) . put ( \"ttl\" , new TTLResourceFactory ( ) ) ; Models . register ( Models . resource ( \"src/person.ecore\" , true ) ) ; RDF2Model r2m = new RDF2Model ( Models . resource ( \"src/person.ecore\" , true ) ) ; Resource model = r2m . transform (", "gt": "Models . resource ( \"src/person.model.ttl\" , true ) ) ;", "prediction": "model ) ;\n", "label": 1}
{"id": 3917, "input": "<s> package com . gisgraphy . client . administrativedivision ; import org . apache . commons . lang . Validate ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . builder . ToStringStyle ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import com . gisgraphy . client . commons . NamePart ; import com . gisgraphy . client . gisfeature . AdministrativeEntity ; import com . gisgraphy . client . gisfeature . AlternateGisFeatureName ; import com . gisgraphy . client . gisfeature . EfficientGisFeatureProvider ; import com . gisgraphy . client . gisfeature . GeonamesGisFeature ; import com . gisgraphy . client . gisfeature . GisFeature ; import com . gisgraphy . client . gisfeature . GisFeatureProvider ; import com . gisgraphy . client . gisfeature . GisFeatureType ; import com . gisgraphy . client . gisfeature . InMemoryGeonamesGisFeatureProvider ; import com . gisgraphy . client . language . Iso639Language ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . ibm . icu . util . Currency ; import com . vividsolutions . jts . geom . Point ; public final class AdministrativeDivision implements AdministrativeEntity , GisFeature , CurrencyProvider { public static class AdministrativeDivisionBuilder { private String name ; private String code ; private GisFeatureProvider gisFeatureProvider ; public AdministrativeDivisionBuilder ( String name ) { this . name = name ; } public AdministrativeDivisionBuilder withCode ( String code ) { this . code = code ; return this ; } public AdministrativeDivision andGisFeature ( GeonamesGisFeature gisFeature ) { this . gisFeatureProvider = new InMemoryGeonamesGisFeatureProvider ( gisFeature ) ; return build ( ) ; } public AdministrativeDivision andGisFeatureProvider ( GisFeatureProvider gisFeatureProvider ) { this . gisFeatureProvider = gisFeatureProvider ; return build ( ) ; } private AdministrativeDivision build ( ) { return new AdministrativeDivision ( this . name , this . code , this . gisFeatureProvider ) ; } } public static AdministrativeDivisionBuilder administrativeDivision ( String name ) { return new AdministrativeDivisionBuilder ( name ) ; } private String name ; private String code ; private GisFeatureProvider gisFeatureProvider ; private AdministrativeDivision ( String name , String code , GisFeatureProvider gisFeatureProvider ) { super ( ) ; Validate . notEmpty ( name ) ; Validate . notEmpty ( code ) ; Validate . notNull ( gisFeatureProvider . getGisFeatureId ( ) ) ; if ( EfficientGisFeatureProvider . class . isAssignableFrom ( gisFeatureProvider . getClass ( ) ) ) { Validate . notNull ( gisFeatureProvider . getGisFeature ( ) . getParentAdministrativeEntity ( ) ) ; } this . name = name ; this . code = code ; this . gisFeatureProvider = gisFeatureProvider ; } public String getName ( ) { return name ; } public String getCode ( ) { return code ; } public GisFeature getGisFeature ( ) { return gisFeature ( ) ; } private GisFeature gisFeature ( ) { return gisFeatureProvider . getGisFeature ( ) ; } public AdministrativeEntity getParentEntity ( ) { return gisFeature ( ) . getParentAdministrativeEntity ( ) ; } @ Override public String toString ( ) { return new ToStringBuilder ( this , ToStringStyle . SHORT_PREFIX_STYLE ) . append ( \"code\" , code ) . append ( \"name\" , name ) . append ( \"gisFeature\" , gisFeatureProvider ) . toString ( ) ; } @ Override public int hashCode ( ) { return gisFeatureProvider . gisFeatureHashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; AdministrativeDivision other = ( AdministrativeDivision ) obj ; return gisFeatureProvider . gisFeatureEquals ( other . gisFeatureProvider ) ; } private AdministrativeEntityHierarchy administrativeEntityLevelProvider ( ) { return new AdministrativeEntityHierarchy ( new AdministrativeEntityHierarchy . AdministrativeEntityProvider ( ) { public AdministrativeEntity getParentAdministrativeEntity ( ) { return AdministrativeDivision . this . getParentAdministrativeEntity ( ) ; } public AdministrativeEntity getCurrentAdministrativeEntity ( ) { return AdministrativeDivision . this ; } } ) ; } public int getAdminitrativeDivisionLevel ( ) { return administrativeEntityLevelProvider ( ) . getAdminitrativeDivisionLevel ( ) ; } public AdministrativeEntity getParentAdministrativeEntity ( ) { return gisFeature ( ) . getParentAdministrativeEntity ( ) ; } public AdministrativeEntity getAdministrativeEntity ( int level ) { return administrativeEntityLevelProvider ( ) . getAdministrativeEntity ( level ) ; } public Long getGeonamesId ( ) { return gisFeature ( ) . getGeonamesId ( ) ; } public ImmutableSet < AlternateGisFeatureName > getGisFeatureAlternateNames ( ) { return gisFeature ( ) . getGisFeatureAlternateNames ( ) ; } public String getGisFeatureDefaultName ( ) { return gisFeature ( ) . getGisFeatureDefaultName ( ) ; } public String getGisFeaturePreferredName ( Iso639Language language ) { return gisFeature ( ) . getGisFeaturePreferredName ( language ) ; } public String getGisFeatureShortName ( Iso639Language language ) { return gisFeature ( ) . getGisFeatureShortName ( language ) ; } public Country getCountry ( ) { return getParentAdministrativeEntity ( ) . getCountry ( ) ; } public Long getElevation ( ) { return", "gt": "gisFeature ( ) . getElevation ( ) ;", "prediction": "getParentAdministrativeEntity ( ) . getElevation ( ) ;\n", "label": 0}
{"id": 15084, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . jboss . seam . core . Events ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . webapp . helpers . EventNames ; @ Operation ( id = RefreshUI . ID , category = Constants . CAT_UI , requires = Constants . SEAM_CONTEXT , label = \"Refresh\" , description = \"Refresh the UI cache. This is a void operation - the input object is returned back as the oputput\" ) public class RefreshUI { public static final String ID = \"Seam.Refresh\" ; @ Param ( name = \"additional list of seam events to raise\" , required = false ) protected StringList additionalSeamEvents ; @ OperationMethod public void run ( ) { OperationHelper . getContentViewActions ( ) . resetAllContent ( ) ; NavigationContext context = OperationHelper . getNavigationContext ( ) ; DocumentModel dm = context . getCurrentDocument ( ) ; if ( dm != null ) { Events . instance ( ) . raiseEvent ( EventNames . DOCUMENT_CHANGED , dm ) ; Events . instance (", "gt": ") . raiseEvent ( EventNames . DOCUMENT_CHILDREN_CHANGED , dm ) ;", "prediction": ") . raiseEvent ( OperationMethod . DOCUMENT_CHANGED , dm ) ;\n", "label": 1}
{"id": 9710, "input": "<s> import p1 . * ; class T6313164 { { B b = new B ( ) ; b . foo1 ( new B ( ) , new B ( ) ) ; b . foo2 ( new B ( ) , new B ( ) ) ; b . foo3", "gt": "( null , null ) ;", "prediction": "( new B ( ) , new B ( ) ) ;\n", "label": 0}
{"id": 15085, "input": "<s> package org . eclipse . ui . internal . progress ; interface IJobProgressManagerListener { void addJob ( final JobInfo info ) ; void addGroup ( final GroupInfo info ) ; public void refreshJobInfo ( JobInfo info ) ; public void refreshGroup ( GroupInfo info ) ; void refreshAll ( ) ; void removeJob (", "gt": "final JobInfo info ) ;", "prediction": "final JobInfo info ) ;\n", "label": 1}
{"id": 2397, "input": "<s> import java . util . * ; public class T6273455 < T extends Comparable < ? super T > > { abstract class Group < E extends Comparable < ? super E > > extends ArrayList < E > implements Comparable < Group < ? extends E > > { } abstract class Sequence < E extends Comparable < ? super E > > extends TreeSet < E > implements Comparable < Sequence <", "gt": "? extends E > >", "prediction": "E > > >\n", "label": 0}
{"id": 15086, "input": "<s> package org . nuxeo . ecm . platform . forms . layout . export ; import java . util . ArrayList ; import org . nuxeo . ecm . platform . forms . layout", "gt": ". api . WidgetTypeDefinition ;", "prediction": ". export . Form ;\n", "label": 1}
{"id": 8639, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; public class TestCaseRun { public static final int IDLE = 1 ; public static final int PASSED = 2 ; public static final int FAILED = 3 ; public static final int RUNNING = 4 ; public static final int PAUSED = 5 ; public static final int BLOCKED = 6 ; public static final int ERROR = 7 ; public static final int WAIVED = 8 ; public Integer case_run_status_id ; public String case_run_status ; public String running_date ; public Integer case_run_id ; public String tested_by_id ; public Integer case_text_version ; public String assignee ; public String close_date ; public String build ; public String run ; public String tested_by ; public Integer run_id ; public Integer assignee_id ; public String cortkey ; public Integer case_id ; public Integer build_id ; public String caseVar ; public Integer environment_id ; public Boolean is_current ; public String notes ; public static class add_comment extends TcmsArrayCommand { @ RequiredField public String caserun_ids ; @ RequiredField public String comment ; } public static class attach_bug extends TcmsHashCommand { public Integer case_run_id ; public Integer bug_id ; public Integer bug_system_id ; public String summary ; public String description ; } public static class check_case_run_status extends TcmsArrayCommand { @ RequiredField public String name ; } public static class create extends TcmsHashCommand { @ RequiredField public Integer run ; @ RequiredField public Integer caseVar ; @ RequiredField public Integer build ; @ RequiredField public String asignee ; public Integer case_run_status ; public Integer case_text_version ; public String notes ; public Integer sortkey ; } public static class detach_bug extends TcmsArrayCommand { public Integer case_run_id ; public Integer object_pks ; } public static class filter extends TcmsHashCommand { public Integer build ; public Integer run ; public Integer caseVar ; public Integer category ; public Integer case_run_status ; } public static class get extends TcmsArrayCommand { @ RequiredField public Integer case_run_id ; } public static class get_bugs extends TestCaseRun . get { } public static class get_case_run_status extends TestCaseRun . get { } public", "gt": "static class get_completion_time extends TestCaseRun . get", "prediction": "static class get_comment extends TcmsHashCommand\n", "label": 0}
{"id": 15087, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeResult ; import org . eclipse . rap . rwt . internal . textsize . ProbeResultStore ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Point ; public class ProbeResultStore_Test extends TestCase { private static final FontData FONT_DATA_2 = new FontData ( \"helvetia\" , 22 , SWT . BOLD ) ; private static final FontData FONT_DATA_1 = new FontData ( \"arial\" , 23 , SWT . ITALIC ) ; private static final Probe PROBE_OF_FONT_DATA_1 = new Probe ( FONT_DATA_1 ) ; private static final Point SIZE = new Point ( 23 , 45 ) ; private ProbeResultStore probeResultStore ; public void testCreateAndGetProbeResult ( ) { ProbeResult created = probeResultStore . createProbeResult ( PROBE_OF_FONT_DATA_1 , SIZE ) ; ProbeResult found = probeResultStore . getProbeResult ( FONT_DATA_1 ) ; assertNotNull ( created ) ; assertSame ( created , found ) ; assertNull ( probeResultStore . getProbeResult ( FONT_DATA_2 ) ) ; } public void testContains ( ) { probeResultStore . createProbeResult ( PROBE_OF_FONT_DATA_1 , SIZE ) ; assertTrue ( probeResultStore . containsProbeResult ( FONT_DATA_1 ) ) ; } public void testIsSerializable ( ) throws Exception { probeResultStore . createProbeResult ( PROBE_OF_FONT_DATA_1 , SIZE ) ; ProbeResultStore deserialized =", "gt": "Fixture . serializeAndDeserialize ( probeResultStore ) ;", "prediction": "probeResultStore . getProbeResult ( FONT_DATA_1 ) ;\n", "label": 1}
{"id": 6138, "input": "<s> class NumArgs3 { void NumArgs3 ( int x2 , int x3 , int x4 , int x5 , int x6 , int x7 , int x8 , int x9 , int x10 , int x11 , int x12 , int x13 , int x14 , int x15 , int x16 , int x17 , int x18 , int x19 , int x20 , int x21 , int x22 , int x23 , int x24 , int x25 , int x26 , int x27 , int x28 , int x29 , int x30 , int x31 , int x32 , int x33 , int x34 , int x35 , int x36 , int x37 , int x38 , int x39 , int x40 , int x41 , int x42 , int x43 , int x44 , int x45 , int x46 , int x47 , int x48 , int x49 , int x50 , int x51 , int x52 , int x53 , int x54 , int x55 , int x56 , int x57 , int x58 , int x59 , int x60 , int x61 , int x62 , int x63 , int x64 , int x65 , int x66 , int x67 , int x68 , int x69 , int x70 , int x71 , int x72 , int x73 , int x74 , int x75 , int x76 , int x77 , int x78 , int x79 , int x80 , int x81 , int x82 , int x83 , int x84 , int x85 , int x86 , int x87 , int x88 , int x89 , int x90 , int x91 , int x92 , int x93 , int x94 , int x95 , int x96 , int x97 , int x98 , int x99 , int x100 , int x101 , int x102 , int x103 , int x104 , int x105 , int x106 , int x107 , int x108 , int x109 , int x110 , int x111 , int x112 , int x113 , int x114 , int x115 , int x116 , int x117 , int x118 , int x119 , int x120 , int x121 , int x122 , int x123 , int x124 , int x125 , int x126 , int x127 , int x128 , int x129 , int x130 , int x131 , int x132 , int x133 , int x134 , int x135 , int x136 , int x137 , int x138 , int x139 , int x140 , int x141 , int x142 , int x143 , int x144 , int x145 , int x146 , int x147 , int x148 , int x149 , int x150 , int x151 , int x152 , int x153 , int x154 , int x155 , int x156 , int x157 , int x158 , int x159 , int x160 , int x161 , int x162 , int x163 , int x164 , int x165 , int x166 , int x167 , int x168 , int x169 , int x170 , int x171 , int x172 , int x173 , int x174 , int x175 , int x176 , int x177 , int x178 , int x179 , int x180 , int x181 , int x182 , int x183 , int x184 , int x185 , int x186 , int x187 , int x188 , int x189 , int x190 , int x191 , int x192 , int x193 , int x194 , int x195 , int x196 , int x197 , int x198 , int x199 , int x200 , int x201 , int x202 , int x203 , int x204 , int x205 , int x206 , int x207 , int x208 , int x209 , int x210 , int x211 , int x212 , int x213 , int x214 , int x215 , int x216 , int x217 , int x218 , int x219 , int x220 , int x221 , int x222 , int x223 , int x224 , int x225 , int x226 , int x227 , int x228 , int x229 , int x230 , int x231 , int x232 , int x233 , int x234 , int x235 , int x236 , int x237 , int x238 , int x239 , int x240 , int x241 , int x242 , int x243 , int x244 , int x245 , int x246 , int x247 , int x248 , int x249 , int x250 , int x251 , int x252 , int x253 , int x254", "gt": ", int x255 , int x256 )", "prediction": ", int x255 ) ;\n", "label": 0}
{"id": 15088, "input": "<s> package org . nuxeo . ecm . platform . publisher . api ; import org . nuxeo . ecm . core . api . ClientException ; public class PublisherException extends ClientException { private static final long serialVersionUID = 1L ; public PublisherException ( ) { } public PublisherException ( String message , Throwable cause ) { super ( message , cause ) ; }", "gt": "public PublisherException ( String message )", "prediction": "}\n", "label": 1}
{"id": 1713, "input": "<s> package org . papaours . yama ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; import java . io . FileNotFoundException ; import java . util . List ; import javax . xml . bind . JAXBException ; import org . junit . Before ; import org . junit . Test ; import org . papaours . yama . model . AbstractYamaQuestion ; import org . papaours . yama . model . YamaCalculatedQuestion ; import org . papaours . yama . model . YamaCategoryQuestion ; import org . papaours . yama . model . YamaImportedQuiz ; import org . papaours . yama . services . ImportQuizService ; import org . papaours . yama . services . impl . ImportQuizServiceImpl ; import universite . toulouse . moodlexmlapi . core . data . Question ; public class TestImportYamaQuiz { @ Before public void testConfiguration ( ) { } @ Test public void importEmptyQuizFile ( ) { ImportQuizService importService = new ImportQuizServiceImpl ( ) ; try { YamaImportedQuiz quiz = importService . importQuiz ( \"./xml-samples/test_emptyQuiz.xml\" ) ; assertEquals ( quiz . getQuestionList ( ) . size ( ) , 0 ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( JAXBException e ) { e . printStackTrace ( ) ; fail ( ) ; } } @ Test public void importSimpleQuizFile ( ) { ImportQuizService importService = new ImportQuizServiceImpl ( ) ; YamaImportedQuiz quiz ; try { quiz = importService . importQuiz ( \"./xml-samples/test_simpleQuiz.xml\" ) ; assertEquals ( 1 , quiz . getQuestionList ( ) . size ( ) ) ; List < Question > questionsList = quiz . getQuestionList ( ) ; assertEquals ( \"Consigne dispositif \u00e9lectronique\" , questionsList . get ( 0 ) . getName ( ) ) ; assertEquals ( false , questionsList . get ( 0 ) . isHidden ( ) ) ; assertEquals ( false , ( ( AbstractYamaQuestion ) ( questionsList . get ( 0 ) ) ) . isShuffled ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( ) ; } } @ Test public void importMultipleQuestionsQuizFile ( ) { final int nb = 3 ; ImportQuizService importService = new ImportQuizServiceImpl ( ) ; YamaImportedQuiz quiz ; try { quiz = importService . importQuiz ( \"./xml-samples/test_manyQuestionsQuiz.xml\" ) ; assertEquals ( nb , quiz . getQuestionList ( ) . size ( ) ) ; List < Question > questionsList = quiz . getQuestionList ( ) ; assertEquals ( \"D\u00e9faut pour 1SA3GL1\" , ( ( YamaCategoryQuestion ) questionsList . get ( 0 ) ) . getCategory ( ) ) ; assertEquals ( \"Consigne dispositif \u00e9lectronique\" , questionsList . get ( 1 ) . getName ( ) ) ; assertEquals ( false , questionsList . get ( 1 ) . isHidden ( ) ) ; assertEquals ( false , ( ( AbstractYamaQuestion ) ( questionsList . get ( 1 ) ) ) . isShuffled ( ) ) ; assertEquals ( \"m2\" , ( ( YamaCalculatedQuestion ) questionsList . get ( 2 ) ) . getQuestionUnits ( ) . get ( 0 ) . getUnitName ( ) ) ; assertEquals ( \"uniform\" , ( ( YamaCalculatedQuestion ) questionsList . get ( 2 ) ) . getQuestionDatasets ( ) . get ( 0 ) . getDistribution ( ) . getContent ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( ) ; } } @ Test public void importFullSampleQuizFile ( ) { final int nb = 12 ; final Float penalty = new Float ( 1 ) ; ImportQuizService importService = new ImportQuizServiceImpl ( ) ; YamaImportedQuiz quiz ; try { quiz = importService . importQuiz ( \"./xml-samples/quiz-exemple-20120229-0812.xml\" ) ; assertEquals ( nb , quiz . getQuestionList ( ) . size ( ) ) ; List < Question > questionsList = quiz . getQuestionList ( ) ; assertEquals ( \"D\u00e9faut pour 1SA3GL1\" , ( ( YamaCategoryQuestion ) questionsList . get ( 0 ) ) . getCategory ( ) ) ; assertEquals ( \"Consigne dispositif \u00e9lectronique\" , questionsList . get ( 2 ) . getName ( ) ) ; assertEquals ( false , questionsList . get ( 2 ) . isHidden ( ) ) ; assertEquals ( false , ( ( AbstractYamaQuestion ) ( questionsList . get ( 2 ) ) ) . isShuffled ( ) ) ; assertEquals ( \"m2\" , ( ( YamaCalculatedQuestion ) questionsList . get ( 1 ) ) . getQuestionUnits ( ) . get ( 0 ) . getUnitName ( ) ) ; assertEquals ( \"uniform\" , ( ( YamaCalculatedQuestion ) questionsList . get ( 1 ) ) . getQuestionDatasets ( ) . get ( 0 ) . getDistribution", "gt": "( ) . getContent ( ) ) ;", "prediction": "( ) . getContent ( ) ) ;\n", "label": 0}
{"id": 15096, "input": "<s> package org . apache . lucene . collation ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . KeywordTokenizer ; import java . text . Collator ; import java . util . Locale ; import java . io . Reader ; public class TestCollationKeyFilter extends CollationTestBase { private Collator collator = Collator . getInstance ( new Locale ( \"ar\" ) ) ; private Analyzer analyzer = new TestAnalyzer ( collator ) ; private String firstRangeBeginning = encodeCollationKey ( collator . getCollationKey ( firstRangeBeginningOriginal ) . toByteArray ( ) ) ; private String firstRangeEnd = encodeCollationKey ( collator . getCollationKey ( firstRangeEndOriginal ) . toByteArray ( ) ) ; private String secondRangeBeginning = encodeCollationKey ( collator . getCollationKey ( secondRangeBeginningOriginal ) . toByteArray ( ) ) ; private String secondRangeEnd = encodeCollationKey ( collator . getCollationKey ( secondRangeEndOriginal ) . toByteArray ( ) ) ; public class TestAnalyzer extends Analyzer { private Collator collator ; TestAnalyzer ( Collator collator ) { this . collator = collator ; } public TokenStream tokenStream ( String fieldName , Reader reader ) { TokenStream result = new KeywordTokenizer ( reader ) ; result = new CollationKeyFilter ( result , collator ) ; return result ; } } public void testFarsiQueryParserCollating ( ) throws Exception { testFarsiQueryParserCollating ( analyzer ) ; } public void testFarsiRangeFilterCollating ( ) throws Exception { testFarsiRangeFilterCollating ( analyzer , firstRangeBeginning , firstRangeEnd , secondRangeBeginning , secondRangeEnd ) ; } public void testFarsiRangeQueryCollating ( ) throws Exception { testFarsiRangeQueryCollating ( analyzer ,", "gt": "firstRangeBeginning , firstRangeEnd , secondRangeBeginning , secondRangeEnd ) ;", "prediction": "secondRangeBeginning , secondRangeEnd , secondRangeEnd ) ;\n", "label": 1}
{"id": 7613, "input": "<s> package org . remast . baralga . model ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . WeakHashMap ; import org . apache . commons . lang . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . h2 . tools . RunScript ; import org . joda . time . DateTime ; import org . joda . time . Duration ; import org . joda . time . format . PeriodFormat ; import org . remast . baralga . gui . settings . ApplicationSettings ; import org . remast . baralga . model . filter . Filter ; import org . remast . util . TextResourceBundle ; public class BaralgaDAO { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaDAO . class ) ; private static final Logger log = LoggerFactory . getLogger ( BaralgaDAO . class ) ; public static final int LATEST_DATABASE_VERSION = 1 ; private Connection connection ; private Map < String , PreparedStatement > preparedStatementCache = Collections . synchronizedMap ( new WeakHashMap < String , PreparedStatement > ( ) ) ; private int databaseVersion ; public void init ( ) throws SQLException { final String dataDirName = ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) . getAbsolutePath ( ) ; connection = DriverManager . getConnection ( \"jdbc:h2:\" + dataDirName + \"/baralga;DB_CLOSE_ON_EXIT=FALSE\" , \"baralga-user\" , \"\" ) ; updateDatabase ( ) ; } public void close ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { connection . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; } } private void updateDatabase ( ) throws SQLException { boolean databaseExists = false ; final Statement statement = connection . createStatement ( ) ; ResultSet resultSet = statement . executeQuery ( \"SHOW TABLES\" ) ; while ( resultSet . next ( ) ) { if ( \"db_version\" . equalsIgnoreCase ( resultSet . getString ( \"TABLE_NAME\" ) ) ) { databaseExists = true ; break ; } } if ( ! databaseExists ) { log . info ( \"Creating Baralga DB.\" ) ; executeScript ( \"setup_database.sql\" ) ; log . info ( \"Baralga DB successfully created.\" ) ; } connection . commit ( ) ; databaseVersion = - 1 ; resultSet = statement . executeQuery ( \"select max(version) as version,", "gt": "description from db_version\" ) ;", "prediction": "\" + version ) ;\n", "label": 0}
{"id": 15097, "input": "<s> package org . eclipse . ui ; public interface IContainmentAdapter { public static final int CHECK_CONTEXT = 1 ; public static final int CHECK_IF_CHILD = 2 ; public static final int CHECK_IF_ANCESTOR = 4 ; public static final int CHECK_IF_DESCENDANT = 8 ; public boolean contains ( Object", "gt": "containmentContext , Object element , int flags ) ;", "prediction": "object ) ;\n", "label": 1}
{"id": 966, "input": "<s> package org . jjflyboy . tjpeditor . ui . contentassist . antlr . internal ; import java . io . InputStream ; import org . eclipse . xtext . * ; import org . eclipse . xtext . parser . * ; import org . eclipse . xtext . parser . impl . * ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . xtext . parser . antlr . XtextTokenStream ; import org . eclipse . xtext . parser . antlr . XtextTokenStream . HiddenTokens ; import org . eclipse . xtext . ui . editor . contentassist . antlr . internal . AbstractInternalContentAssistParser ; import org . eclipse . xtext . ui . editor . contentassist . antlr . internal . DFA ; import org . jjflyboy . tjpeditor . services . ProjectGrammarAccess ; import org . antlr . runtime . * ; import java . util . Stack ; import java . util . List ; import java . util . ArrayList ; import java . util . Map ; import java . util . HashMap ; @ SuppressWarnings ( \"all\" ) public class InternalProjectParser extends AbstractInternalContentAssistParser { public static final String [ ] tokenNames = new String [ ] { \"<invalid>\" , \"<EOR>\" , \"<DOWN>\" , \"<UP>\" , \"RULE_STRING\" , \"RULE_ID\" , \"RULE_FLOAT\" , \"RULE_INT\" , \"RULE_ISODATE\" , \"RULE_TIME\" , \"RULE_SL_COMMENT\" , \"RULE_ML_COMMENT\" , \"RULE_WS\" , \"RULE_ANY_OTHER\" , \"'|'\" , \"'&'\" , \"'='\" , \"'+='\" , \"'||'\" , \"'&&'\" , \"'reference'\" , \"'date'\" , \"'richtext'\" , \"'text'\" , \"'hasalert'\" , \"'hasalert_'\" , \"'isactive'\" , \"'isactive_'\" , \"'ischildof'\" , \"'ischildof_'\" , \"'isdependencyof'\" , \"'isdependencyof_'\" , \"'isdutyof'\" , \"'isdutyof_'\" , \"'isfeatureof'\" , \"'isfeatureof_'\" , \"'isleaf'\" , \"'isleaf_'\" , \"'ismilestone'\" , \"'ismilestone_'\" , \"'isongoing'\" , \"'isongoing_'\" , \"'isresource'\" , \"'isresource_'\" , \"'isresponsbilityof'\" , \"'isresponsbilityof_'\" , \"'istask'\" , \"'istask_'\" , \"'treelevel'\" , \"'treelevel_'\" , \"'!='\" , \"'false'\" , \"'hour'\" , \"'day'\" , \"'week'\" , \"'month'\" , \"'quarter'\" , \"'year'\" , \"'=='\" , \"'>='\" , \"'<='\" , \"'>'\" , \"'<'\" , \"'->'\" , \"'..'\" , \"'+'\" , \"'-'\" , \"'*'\" , \"'**'\" , \"'/'\" , \"'%'\" , \"'!'\" , \"'.'\" , \"'val'\" , \"'super'\" , \"'columns'\" , \"'definitions'\" , \"'flags'\" , \"'formats'\" , \"'journalAttributes'\" , \"'scenarios'\" , \"'sortaccounts'\" , \"'sortjournalentries'\" , \"'sortresources'\" , \"'sorttasks'\" , \"'fail'\" , \"'managers'\" , \"'reports'\" , \"'vacations'\" , \"'warn'\" , \"'booking'\" , \"'charge'\" , \"'chargeset'\" , \"'depends'\" , \"'precedes'\" , \"'onstart'\" , \"'onend'\" , \"'perhour'\" , \"'perday'\" , \"'perweek'\" , \"'left'\" , \"'center'\" , \"'right'\" , \"'journal'\" , \"'journal_sub'\" , \"'status_down'\" , \"'status_up'\" , \"'alerts_down'\" , \"'bullets'\" , \"'comma'\" , \"'numbered'\" , \"'up'\" , \"'down'\" , \"'yes'\" , \"'no'\" , \"'csv'\" , \"'html'\" , \"'niku'\" , \"'days'\" , \"'hours'\" , \"'longauto'\" , \"'minutes'\" , \"'months'\" , \"'shortauto'\" , \"'weeks'\" , \"'years'\" , \"'maxloaded'\" , \"'minloaded'\" , \"'minallocated'\" , \"'order'\" , \"'random'\" , \"'alert'\" , \"'alertmessage'\" , \"'alertsummar'\" , \"'alerttrend'\" , \"'chart'\" , \"'complete'\" , \"'completed'\" , \"'criticalness'\" , \"'cost'\" , \"'daily'\" , \"'duration'\" , \"'duties'\" , \"'efficiency'\" , \"'effort'\" , \"'effortdone'\" , \"'effortleft'\" , \"'email'\" , \"'end'\" , \"'followers'\" , \"'freetime'\" , \"'freework'\" , \"'fte'\" , \"'headcount'\" , \"'hierarchindex'\" , \"'hourly'\" , \"'id'\" , \"'index'\" , \"'line'\" , \"'maxend'\" , \"'maxstart'\" , \"'minend'\" , \"'minstart'\" , \"'monthly'\" , \"'name'\" , \"'note'\" , \"'pathcriticalness'\" , \"'precursor'\" , \"'priority'\" , \"'quarterly'\" , \"'rate'\" , \"'resources'\" , \"'responsible'\" , \"'revenue'\" , \"'scenario'\" , \"'seqno'\" , \"'start'\" , \"'status'\" , \"'targets'\" , \"'wbs'\" , \"'weekly'\" , \"'yearly'\" , \"'red'\" , \"'yellow'\" , \"'green'\" , \"'alap'\" , \"'asap'\" , \"'min'\" , \"'h'\" , \"'d'\" , \"'w'\" , \"'m'\" , \"'y'\" , \"'mon'\" , \"'tue'\" , \"'wed'\" , \"'thu'\" , \"'fri'\" , \"'sat'\" , \"'sun'\" , \"'account'\" , \"'{'\" , \"'}'\" , \"'accountprefix'\" , \"'accountreport'\" , \"'accountroot'\" , \"'project'\" , \"'task'\" , \"'icalreport'\" , \"'export'\" , \"'resource'\" , \"'allocate'\" , \"','\" , \"'navigator'\" , \"'newtask'\" , \"'nikureport'\" , \"'author'\" , \"'balance'\" , \"'overtime'\" , \"'sloppy'\" , \"'caption'\" , \"'cellcolor'\" , \"'celltext'\" , \"'copyright'\" , \"'credit'\" , \"'currency'\" , \"'currencyformat'\" , \"'dailymax'\" , \"'dailymin'\" , \"'dailyworkinghours'\" , \"'details'\" , \"'endcredit'\" , \"'epilog'\" , \"'extend'\" , \"'fontcolor'\" , \"'footer'\" , \"'('\" , \"')'\" , \"'gapduration'\" , \"'gaplength'\" , \"'header'\" , \"'headline'\" , \"'hideaccount'\" , \"'hidejournalentry'\" , \"'hidereport'\" , \"'hideresource'\" , \"'hidetask'\" , \"'include'\" , \"'journalattributes'\" , \"'journalentry'\" , \"'journalmode'\" , \"'length'\" , \"'limits'\" , \"'listitem'\" , \"'listtype'\" , \"'loadunit'\" , \"'macro'\" , \"'maximum'\" , \"'minimum'\" , \"'monthlymax'\" , \"'monthlymin'\" , \"'now'\" , \"'numberformat'\" , \"'period'\" , \"'projectid'\" , \"'projectids'\" , \"'prolog'\" , \"'purge'\" , \"'remaining'\" , \"'reportprefix'\" , \"'resourceattributes'\" , \"'resourceprefix'\" , \"'resourcereport'\" , \"'resourceroot'\" , \"'rollupaccount'\" , \"'rollupresource'\" , \"'rolluptask'\" , \"'scale'\" , \"'active'\" , \"'scheduling'\" , \"'select'\" , \"'selfcontained'\" , \"'shift'\" , \"'timezone'\" , \"'vacation'\" , \"'workinghours'\" , \"'shifts'\" , \"'shorttimeformat'\" , \"'statussheet'\" , \"'statussheetreport'\" , \"'summary'\" , \"'supplement'\" , \"'report'\" , \"'tagfile'\" , \"'taskattributes'\" , \"'taskprefix'\" , \"'taskreport'\" , \"'taskroot'\" , \"'textreport'\" , \"'timeformat'\" , \"'timeoff'\" , \"'timesheet'\" , \"'timesheetreport'\" , \"'timingresolution'\" , \"'title'\" , \"'tooltip'\" , \"'trackingscenario'\" , \"'weeklymax'\" , \"'weeklymin'\" , \"'width'\" , \"'work'\" , \"'yearlyworkingdays'\" , \"'instanceof'\" , \"'as'\" , \"'['\" , \"']'\" , \"';'\" , \"'if'\" , \"'else'\" , \"'switch'\" , \"':'\" , \"'default'\" , \"'case'\" , \"'for'\" , \"'while'\" , \"'do'\" , \"'::'\" , \"'new'\" , \"'null'\" , \"'typeof'\" , \"'throw'\" , \"'return'\" , \"'try'\" , \"'finally'\" , \"'catch'\" , \"'=>'\" , \"'?'\" , \"'extends'\" , \"'tasks'\" , \"'inherit'\" , \"'scenariospecific'\" , \"'property'\" , \"'propertyid'\" , \"'true'\" , \"'mandatory'\" , \"'milestone'\" , \"'persistent'\" , \"'scheduled'\" , \"'replace'\" , \"'tree'\" , \"'weekstartssunday'\" , \"'weekstartsmonday'\" , \"'off'\" , \"'?.'\" , \"'*.'\" , \"'var'\" } ; public static final int RULE_ID = 5 ; public static final int T__159 = 159 ;", "gt": "public static final int T__158 = 158 ;", "prediction": "public static final int T__160 = 160 ;\n", "label": 0}
{"id": 15098, "input": "<s> package org . eclipse . ui . preferences ; import org . eclipse . core . runtime . jobs . Job ; public interface IWorkbenchPreferenceContainer { public boolean openPage ( String preferencePageId , Object data ) ; public IWorkingCopyManager getWorkingCopyManager ( ) ; public void", "gt": "registerUpdateJob ( Job job ) ;", "prediction": "setWorkingCopyManager ( IWorkingCopyManager workingCopyManager ) ;\n", "label": 1}
{"id": 7410, "input": "<s> package com . sap . prd . mobile . ios . mios ; public class XCodeProjectNotFoundException extends XCodeValidationException { public XCodeProjectNotFoundException ( ) { super ( ) ; } public XCodeProjectNotFoundException ( String message , Throwable cause ) { super ( message , cause ) ; } public XCodeProjectNotFoundException ( String message ) { super ( message ) ; } public XCodeProjectNotFoundException ( Throwable cause ) {", "gt": "super ( cause ) ;", "prediction": "super ( cause ) ;\n", "label": 0}
{"id": 15101, "input": "<s> package org . apache . lucene . xmlparser ; import java . io . IOException ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import junit . framework . TestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . search . Hits ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . store . RAMDirectory ; import org . w3c . dom . Document ; import org . xml . sax . SAXException ; public class TestQueryTemplateManager extends TestCase { CoreParser builder ; Analyzer analyzer = new StandardAnalyzer ( ) ; private IndexSearcher searcher ; String docFieldValues [ ] = { \"artist=Jeff Buckley \\talbum=Grace \\treleaseDate=1999 \\tgenre=rock\" , \"artist=Fugazi \\talbum=Repeater \\treleaseDate=1990 \\tgenre=alternative\" , \"artist=Fugazi \\talbum=Red Medicine \\treleaseDate=1995 \\tgenre=alternative\" , \"artist=Peeping Tom \\talbum=Peeping Tom \\treleaseDate=2006 \\tgenre=rock\" , \"artist=Red Snapper \\talbum=Prince Blimey \\treleaseDate=1996 \\tgenre=electronic\" } ; String queryForms [ ] = { \"artist=Fugazi \\texpectedMatches=2 \\ttemplate=albumBooleanQuery\" , \"artist=Fugazi \\treleaseDate=1990 \\texpectedMatches=1 \\ttemplate=albumBooleanQuery\" , \"artist=Buckley \\tgenre=rock \\texpectedMatches=1 \\ttemplate=albumFilteredQuery\" , \"artist=Buckley \\tgenre=electronic \\texpectedMatches=0 \\ttemplate=albumFilteredQuery\" , \"queryString=artist:buckly~ NOT genre:electronic \\texpectedMatches=1 \\ttemplate=albumLuceneClassicQuery\" } ; public void testFormTransforms ( ) throws SAXException , IOException , ParserConfigurationException , TransformerException , ParserException { QueryTemplateManager qtm = new QueryTemplateManager ( ) ; qtm . addQueryTemplate ( \"albumBooleanQuery\" , getClass ( ) . getResourceAsStream ( \"albumBooleanQuery.xsl\" ) ) ; qtm . addQueryTemplate ( \"albumFilteredQuery\" , getClass ( ) . getResourceAsStream ( \"albumFilteredQuery.xsl\" ) ) ; qtm . addQueryTemplate ( \"albumLuceneClassicQuery\" , getClass ( ) . getResourceAsStream ( \"albumLuceneClassicQuery.xsl\" ) ) ; for ( int i = 0 ; i < queryForms . length ; i ++ ) { Properties queryFormProperties = getPropsFromString ( queryForms [ i ] ) ; Document doc = qtm . getQueryAsDOM ( queryFormProperties , queryFormProperties . getProperty ( \"template\" ) ) ; Query q = builder . getQuery ( doc . getDocumentElement ( ) ) ; Hits h = searcher . search ( q ) ; int expectedHits = Integer . parseInt ( queryFormProperties . getProperty ( \"expectedMatches\" ) ) ; assertEquals ( \"Number of results should match for query \" + queryForms [ i ] , expectedHits , h . length ( ) ) ; } } Properties getPropsFromString ( String nameValuePairs ) { Properties result =", "gt": "new Properties ( ) ;", "prediction": "null ;\n", "label": 1}
{"id": 4872, "input": "<s> package org . remast . baralga . gui . actions ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import javax . swing . ImageIcon ; import org . remast . baralga . gui . dialogs . AboutDialog ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public class AboutAction extends AbstractBaralgaAction { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( AboutAction . class ) ; public AboutAction ( final Frame owner ) { super ( owner ) ; putValue ( NAME , textBundle . textFor ( \"AboutAction.Name\" ) ) ; putValue ( SMALL_ICON , new ImageIcon ( getClass ( ) . getResource ( \"/icons/gtk-about.png\" ) ) ) ; putValue ( SHORT_DESCRIPTION , textBundle . textFor ( \"AboutAction.ShortDescription\" ) ) ; } @ Override public final void actionPerformed ( final ActionEvent event ) { final AboutDialog aboutDialog = new AboutDialog (", "gt": "getOwner ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15104, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . swt . graphics . Rectangle ; public abstract class AbstractTabItem { public abstract Rectangle getBounds ( ) ; public abstract void setInfo ( PartInfo info ) ; public abstract void dispose ( ) ; public void setBusy ( boolean busy ) { } public void setBold ( boolean bold ) { } public abstract Object getData ( ) ; public abstract void setData ( Object data ) ;", "gt": "public boolean isShowing ( )", "prediction": "}\n", "label": 1}
{"id": 9888, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignLinePlot ; import net . sf . jasperreports . charts . design . JRDesignXyDataset ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJXYLineChartBuilder ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class XYLineChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnCode ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; drb . setUseFullPageWidth ( true ) ; DJAxisFormat categoryAxisFormat = new DJAxisFormat ( \"x\" ) ; categoryAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelMask ( \"#,###.#\" ) ; categoryAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJAxisFormat valueAxisFormat = new DJAxisFormat ( \"value\" ) ; valueAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelMask ( \"#,##0.0\" ) ; valueAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJChart djChart = new DJXYLineChartBuilder ( ) . setX ( 20 ) . setY ( 10 ) . setWidth ( 500 ) . setHeight ( 250 ) . setCentered ( false ) . setBackColor ( Color . LIGHT_GRAY ) . setShowLegend ( true ) . setPosition ( DJChartOptions . POSITION_FOOTER ) . setTitle ( \"title\" ) . setTitleColor ( Color . DARK_GRAY ) . setTitleFont ( Font . ARIAL_BIG_BOLD ) . setSubtitle ( \"subtitle\" ) . setSubtitleColor ( Color . DARK_GRAY ) . setSubtitleFont ( Font . COURIER_NEW_BIG_BOLD ) . setLegendColor ( Color . DARK_GRAY ) . setLegendFont ( Font . COURIER_NEW_MEDIUM_BOLD ) . setLegendBackgroundColor ( Color . WHITE ) . setLegendPosition ( DJChartOptions . EDGE_BOTTOM ) . setTitlePosition ( DJChartOptions . EDGE_TOP ) . setLineStyle ( DJChartOptions . LINE_STYLE_DOTTED ) . setLineWidth ( 1 ) . setLineColor ( Color . DARK_GRAY ) . setPadding ( 5 ) . setXValue ( ( PropertyColumn ) columnCode ) . addSerie ( columnaQuantity , \"quant.\" ) . addSerie ( columnAmount ) . setShowShapes ( true ) . setShowLines ( true ) . setCategoryAxisFormat ( categoryAxisFormat ) . setValueAxisFormat ( valueAxisFormat ) . build ( ) ; drb . addChart ( djChart ) ; DJHyperLink djlink = new DJHyperLink ( ) ; djlink . setExpression ( new StringExpression ( ) { public Object evaluate ( Map fields , Map variables , Map parameters ) { return \"http://thisIsAURL?count=\" + variables . get ( \"REPORT_COUNT\" ) ; } } ) ; djlink . setTooltip ( new LiteralExpression ( \"I'm a literal tootltip\" ) ) ; djChart . setLink ( djlink ) ; HashMap vars = new HashMap ( ) ; vars . put ( columnaQuantity , new JRDesignVariable ( ) ) ; vars .", "gt": "put ( columnAmount , new JRDesignVariable ( ) ) ;", "prediction": "put ( columnaQuantity , new JRDesignVariable ( ) ) ;\n", "label": 0}
{"id": 15108, "input": "<s> package org . seage . metaheuristic . tabusearch ; public class BestEverAspirationCriteria implements AspirationCriteria { private static final long serialVersionUID = 8050033847751573251L ; public boolean overrideTabu ( final Solution solution , final Move proposedMove , final double [ ] proposedValue , final ITabuSearch tabuSearch ) { return TabuSearch . isFirstBetterThanSecond ( proposedValue , tabuSearch . getBestSolution ( ) . getObjectiveValue ( ) , tabuSearch . isMaximizing ( )", "gt": ") ? true : false ;", "prediction": ") ;\n", "label": 1}
{"id": 5385, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . fachwerte ; public final class Platz { private final int _reihe ; private final int _sitz ; public Platz ( int reihe , int sitz ) { assert reihe >= 0 : \"Vorbedingung verletzt: reihe <=0\" ; assert sitz >= 0 : \"Vorbedingung verletzt: sitz <=0\" ; _reihe = reihe ; _sitz = sitz ; } public int getReihe ( ) { return _reihe ; } public int getSitz ( ) { return _sitz ; } @ Override public boolean equals ( Object o ) { boolean ergebnis = false ; if ( o instanceof Platz ) { Platz platz = ( Platz ) o ; ergebnis = ( ( platz . getReihe ( ) == this . getReihe ( ) ) && ( platz . getSitz ( ) == this . getSitz ( ) ) ) ; } return ergebnis ; } @ Override public int hashCode ( ) { return 1000 * getReihe ( )", "gt": "+ getSitz ( ) ;", "prediction": ";\n", "label": 0}
{"id": 15122, "input": "<s> package org . apache . lucene . analysis . fr ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import java . io . IOException ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public final class FrenchStemFilter extends TokenFilter { private FrenchStemmer stemmer = null ; private Set exclusions = null ; private TermAttribute termAtt ; public FrenchStemFilter ( TokenStream in ) { super ( in ) ; stemmer = new FrenchStemmer ( ) ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; } public FrenchStemFilter ( TokenStream in , Set exclusiontable ) { this ( in ) ; exclusions = exclusiontable ; } public boolean incrementToken ( ) throws IOException { if ( input . incrementToken ( ) ) { String term = termAtt . term ( ) ; if ( exclusions == null || ! exclusions . contains ( term ) ) { String s = stemmer . stem ( term ) ; if ( ( s != null ) && ! s . equals ( term ) ) termAtt", "gt": ". setTermBuffer ( s ) ;", "prediction": ". term ( ) ;\n", "label": 1}
{"id": 8362, "input": "<s> package com . sun . tools . classfile ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import static com . sun . tools . classfile . AccessFlags . * ; public class ClassFile { public static ClassFile read ( File file ) throws IOException , ConstantPoolException { return read ( file , new Attribute . Factory ( ) ) ; } public static ClassFile read ( File file , Attribute . Factory attributeFactory ) throws IOException , ConstantPoolException { FileInputStream in = new FileInputStream ( file ) ; try { return new ClassFile ( in , attributeFactory ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } } } public static ClassFile read ( InputStream in ) throws IOException , ConstantPoolException { return new ClassFile ( in , new Attribute . Factory ( ) ) ; } public static ClassFile read ( InputStream in , Attribute . Factory attributeFactory ) throws IOException , ConstantPoolException { return new ClassFile ( in , attributeFactory ) ; } ClassFile ( InputStream in , Attribute . Factory attributeFactory ) throws IOException , ConstantPoolException { ClassReader cr = new ClassReader ( this , in , attributeFactory ) ; magic = cr . readInt ( ) ; minor_version = cr . readUnsignedShort ( ) ; major_version = cr . readUnsignedShort ( ) ; constant_pool = new ConstantPool ( cr ) ; access_flags = new AccessFlags ( cr ) ; this_class = cr . readUnsignedShort ( ) ; super_class = cr . readUnsignedShort ( ) ; int interfaces_count = cr . readUnsignedShort ( ) ; interfaces = new int [ interfaces_count ] ; for ( int i = 0 ; i < interfaces_count ; i ++ ) interfaces [ i ] = cr . readUnsignedShort ( ) ; int fields_count = cr . readUnsignedShort ( ) ; fields = new Field [ fields_count ] ; for ( int i = 0 ; i < fields_count ; i ++ ) fields [ i ] = new Field ( cr ) ; int methods_count = cr . readUnsignedShort ( ) ; methods = new Method [ methods_count ] ; for ( int i = 0 ; i < methods_count ; i ++ ) methods [ i ] = new Method ( cr ) ; attributes = new Attributes ( cr ) ; } public ClassFile ( int magic , int minor_version , int major_version , ConstantPool constant_pool , AccessFlags access_flags , int this_class , int super_class , int [ ] interfaces , Field [ ] fields , Method [ ] methods , Attributes attributes ) { this . magic = magic ; this . minor_version = minor_version ; this . major_version = major_version ; this . constant_pool = constant_pool ; this . access_flags = access_flags ; this . this_class = this_class ; this . super_class = super_class ; this . interfaces = interfaces ; this . fields = fields ; this . methods = methods ; this . attributes = attributes ; } public String getName ( ) throws ConstantPoolException { return constant_pool . getClassInfo ( this_class ) . getName ( ) ; } public String getSuperclassName ( ) throws ConstantPoolException { return constant_pool . getClassInfo ( super_class ) . getName ( ) ; } public String getInterfaceName ( int i ) throws ConstantPoolException { return constant_pool . getClassInfo ( interfaces [ i ] ) . getName ( ) ; } public Attribute getAttribute ( String name ) { return attributes . get ( name ) ; } public boolean isClass ( ) { return ! isInterface ( ) ; } public boolean isInterface ( ) { return access_flags . is ( ACC_INTERFACE ) ; } public int byteLength ( ) { return 4 + 2 + 2 + constant_pool . byteLength ( ) + 2 + 2 + 2 + byteLength ( interfaces ) + byteLength ( fields ) + byteLength ( methods ) + attributes . byteLength ( ) ; } private int byteLength ( int [ ] indices ) { return 2 + 2 * indices . length ; } private int byteLength ( Field [ ] fields ) { int length = 2 ; for ( Field f : fields ) length += f . byteLength ( ) ; return length ; } private int byteLength ( Method [ ] methods ) { int length = 2 ; for ( Method m : methods ) length += m . byteLength ( ) ; return length ; } public final int magic ; public final int minor_version ; public final int major_version ; public final ConstantPool constant_pool ; public final AccessFlags access_flags ;", "gt": "public final int this_class ;", "prediction": "public final boolean isClass ( )\n", "label": 0}
{"id": 15124, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import java . util . Set ; import java . util . SortedSet ; import javax . ws . rs . CookieParam ; import javax . ws . rs . DefaultValue ; import javax . ws . rs . Encoded ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Cookie ; import javax . ws . rs . core . MediaType ; import org . restlet . test . ext . jaxrs . services . tests . CookieParamTest ; @ Path ( \"cookieParamTest\" ) public class CookieParamTestService { @ GET @ Produces ( MediaType . TEXT_PLAIN ) @ Path ( \"array\" ) public String array ( @ CookieParam ( \"c\" ) Cookie [ ] cc ) { String result = \"[\" ; for ( final Cookie c : cc ) { result += c . getValue ( ) + \", \" ; } return result . substring ( 0 , result . length ( ) - 2 ) + \"]\" ; } @ GET @ Produces ( \"text/plain\" ) public String get ( @ CookieParam ( \"c\" ) String cookieValue ) { return cookieValue ; } @ GET @ Produces ( MediaType . TEXT_PLAIN ) @ Path ( \"Set\" ) public String set ( @ CookieParam ( \"c\" ) Set < Cookie > cc ) {", "gt": "String result = \"{\" ;", "prediction": "String result = \"[\" ;\n", "label": 1}
{"id": 9623, "input": "<s> package org . ofbiz . entity . testtools ; import junit . framework . TestCase ; import org . ofbiz . entity . Delegator ; public class EntityTestCase extends TestCase { protected Delegator delegator = null ; public EntityTestCase ( String name ) { super ( name ) ; } public void setDelegator ( Delegator delegator ) { this . delegator = delegator ; }", "gt": "public Delegator getDelegator ( )", "prediction": "}\n", "label": 0}
{"id": 15125, "input": "<s> package org . eclipse . ui . dynamic . markerSupport ; import org . eclipse . core . resources . IMarker ; import org . eclipse . ui .", "gt": "views . markers . ISubCategoryProvider ;", "prediction": "IResourceManager ;\n", "label": 1}
{"id": 8655, "input": "<s> package org . msl . simple . gmfmap . simplemappings ;", "gt": "public interface SimpleLabelNode extends SimpleNode", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 15135, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec4 . server ; import org . restlet . example . book . restlet . ch02 . sec5 . sub5 . common . RootResource ; import org . restlet . resource . ServerResource ; public class RootServerResource extends ServerResource implements RootResource { public String represent ( ) { return \"Welcome to the \" + getApplication", "gt": "( ) . getName ( ) + \" !\" ;", "prediction": "( ) . toString ( ) ;\n", "label": 1}
{"id": 3641, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class TreeWriter extends AbstractTreeWriter { private PackageDoc [ ] packages ; private boolean classesonly ; public TreeWriter ( ConfigurationImpl configuration , String filename , ClassTree classtree ) throws IOException { super ( configuration , filename , classtree ) ; packages = configuration . packages ; classesonly = packages . length == 0 ; } public static void generate ( ConfigurationImpl configuration , ClassTree classtree ) { TreeWriter treegen ; String filename = \"overview-tree.html\" ; try { treegen = new TreeWriter ( configuration , filename , classtree ) ; treegen . generateTreeFile ( ) ; treegen . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } public void generateTreeFile ( ) throws IOException { Content body = getTreeHeader ( ) ; Content headContent = getResource ( \"doclet.Hierarchy_For_All_Packages\" ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . TITLE_HEADING , false , HtmlStyle . title , headContent ) ; Content div = HtmlTree . DIV ( HtmlStyle . header , heading ) ; addPackageTreeLinks ( div ) ; body . addContent ( div ) ; HtmlTree divTree = new HtmlTree ( HtmlTag . DIV ) ; divTree . addStyle ( HtmlStyle . contentContainer ) ; addTree ( classtree . baseclasses ( ) , \"doclet.Class_Hierarchy\" , divTree ) ; addTree ( classtree . baseinterfaces ( ) , \"doclet.Interface_Hierarchy\" , divTree ) ; addTree ( classtree . baseAnnotationTypes ( ) , \"doclet.Annotation_Type_Hierarchy\" , divTree ) ; addTree ( classtree . baseEnums ( ) , \"doclet.Enum_Hierarchy\" , divTree ) ; body . addContent ( divTree ) ; addNavLinks ( false , body ) ; addBottom ( body ) ; printHtmlDocument ( null , true , body ) ; } protected void addPackageTreeLinks ( Content contentTree ) { if ( packages . length == 1 && packages [ 0 ] . name ( ) . length ( ) == 0 ) { return ; } if ( ! classesonly ) { Content span = HtmlTree . SPAN ( HtmlStyle . strong , getResource ( \"doclet.Package_Hierarchies\" ) ) ; contentTree . addContent ( span ) ;", "gt": "HtmlTree ul = new HtmlTree ( HtmlTag . UL ) ;", "prediction": "}\n", "label": 0}
{"id": 15137, "input": "<s> package org . eclipse . ui . internal . registry ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . dynamichelpers . ExtensionTracker ; import org . eclipse . core . runtime . dynamichelpers . IExtensionChangeHandler ; import org . eclipse . core . runtime . dynamichelpers . IExtensionTracker ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . IWorkingSetPage ; public class WorkingSetRegistry implements IExtensionChangeHandler { private static final String DEFAULT_PAGE_ID = \"org.eclipse.ui.resourceWorkingSetPage\" ; private HashMap workingSetDescriptors = new HashMap ( ) ; public WorkingSetRegistry ( ) { IExtensionTracker tracker = PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) ; tracker . registerHandler ( this , ExtensionTracker . createExtensionPointFilter ( getExtensionPointFilter ( ) ) ) ; } private IExtensionPoint getExtensionPointFilter ( ) { return Platform . getExtensionRegistry ( ) . getExtensionPoint ( PlatformUI . PLUGIN_EXTENSION_NAME_SPACE , IWorkbenchRegistryConstants . PL_WORKINGSETS ) ; } public void addWorkingSetDescriptor ( WorkingSetDescriptor descriptor ) { Assert . isTrue ( ! workingSetDescriptors . containsValue ( descriptor ) , \"working set descriptor already registered\" ) ; IExtensionTracker tracker = PlatformUI . getWorkbench ( ) . getExtensionTracker ( ) ; tracker . registerObject ( descriptor . getConfigurationElement ( ) . getDeclaringExtension ( ) , descriptor , IExtensionTracker . REF_WEAK ) ; workingSetDescriptors . put ( descriptor . getId ( ) , descriptor ) ; } public IWorkingSetPage getDefaultWorkingSetPage ( ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) workingSetDescriptors . get ( DEFAULT_PAGE_ID ) ; if ( descriptor != null ) { return descriptor . createWorkingSetPage ( ) ; } return null ; } public WorkingSetDescriptor getWorkingSetDescriptor ( String pageId ) { return ( WorkingSetDescriptor ) workingSetDescriptors . get ( pageId ) ; } public WorkingSetDescriptor [ ] getWorkingSetDescriptors ( ) { return ( WorkingSetDescriptor [ ] ) workingSetDescriptors . values ( ) . toArray ( new WorkingSetDescriptor [ workingSetDescriptors . size ( ) ] ) ; } public WorkingSetDescriptor [ ] getNewPageWorkingSetDescriptors ( ) { Collection descriptors = workingSetDescriptors . values ( ) ; List result = new ArrayList ( descriptors . size ( ) ) ; for ( Iterator iter = descriptors . iterator ( ) ; iter . hasNext ( ) ; ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) iter . next ( ) ; if ( descriptor . getPageClassName ( ) != null ) { result . add ( descriptor ) ; } } return ( WorkingSetDescriptor [ ] ) result . toArray ( new WorkingSetDescriptor [ result . size ( ) ] ) ; } public boolean hasNewPageWorkingSetDescriptor ( ) { Collection descriptors = workingSetDescriptors . values ( ) ; for ( Iterator iter = descriptors . iterator ( ) ; iter . hasNext ( ) ; ) { WorkingSetDescriptor descriptor = ( WorkingSetDescriptor ) iter . next ( ) ; if ( descriptor . getPageClassName ( ) != null ) { return true ; } } return false ; } public WorkingSetDescriptor [ ] getUpdaterDescriptorsForNamespace ( String namespace ) { if ( namespace == null ) return new WorkingSetDescriptor [ 0 ] ; Collection descriptors", "gt": "= workingSetDescriptors . values ( ) ;", "prediction": "= workingSetDescriptors . values ( ) ;\n", "label": 1}
{"id": 4808, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import org . eclipse . core . runtime . Platform ; import org . eclipse . emf . ecore . EAnnotation ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . gmf . runtime . notation . Diagram ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleChildReferenceEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleCompartmentNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLabelNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLinkMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleLinkMappingNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleMappingEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleSubNodeNameEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleTopNodeEditPart ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleTopNodeNameEditPart ; public class SimplemapVisualIDRegistry { private static final String DEBUG_KEY = \"org.msl.simple.gmfmap.diagram/debug/visualID\" ; public static int getVisualID ( View view ) { if ( view instanceof Diagram ) { if ( SimpleMappingEditPart . MODEL_ID . equals ( view . getType ( ) ) ) { return SimpleMappingEditPart . VISUAL_ID ; } else { return - 1 ; } } return org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry . getVisualID ( view . getType ( ) ) ; } public static String getModelID ( View view ) { View diagram = view . getDiagram ( ) ; while ( view != diagram ) { EAnnotation annotation = view . getEAnnotation ( \"Shortcut\" ) ; if ( annotation != null ) { return ( String ) annotation . getDetails ( ) . get ( \"modelID\" ) ; } view = ( View ) view . eContainer ( ) ; } return diagram != null ? diagram . getType ( ) : null ; } public static int getVisualID ( String type ) { try { return Integer . parseInt ( type ) ; } catch ( NumberFormatException e ) { if ( Boolean . TRUE . toString ( ) . equalsIgnoreCase ( Platform . getDebugOption ( DEBUG_KEY ) ) ) { SimplemapDiagramEditorPlugin . getInstance ( ) . logError ( \"Unable to parse view type as a visualID number: \" + type ) ; } } return - 1 ; } public static String getType ( int visualID ) { return Integer . toString ( visualID ) ; } public static int getDiagramVisualID ( EObject domainElement ) { if ( domainElement == null ) { return - 1 ; } if ( SimplemappingsPackage . eINSTANCE . getSimpleMapping ( ) . isSuperTypeOf ( domainElement . eClass ( ) ) && isDiagram ( ( SimpleMapping ) domainElement ) ) { return SimpleMappingEditPart . VISUAL_ID ; } return - 1 ; } public static int getNodeVisualID ( View containerView , EObject domainElement ) { if ( domainElement == null ) { return - 1 ; } String containerModelID = org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry . getModelID ( containerView ) ; if ( ! SimpleMappingEditPart . MODEL_ID . equals ( containerModelID ) ) { return - 1 ; } int containerVisualID ; if ( SimpleMappingEditPart . MODEL_ID . equals ( containerModelID ) ) { containerVisualID = org . msl . simple . gmfmap . simplemappings . diagram . part . SimplemapVisualIDRegistry . getVisualID ( containerView ) ; } else { if ( containerView instanceof Diagram ) { containerVisualID = SimpleMappingEditPart . VISUAL_ID ; } else { return - 1 ; } } switch ( containerVisualID ) { case SimpleMappingEditPart . VISUAL_ID : if ( SimplemappingsPackage . eINSTANCE . getSimpleTopNode ( ) . isSuperTypeOf ( domainElement . eClass ( ) ) ) { return SimpleTopNodeEditPart . VISUAL_ID ; } if ( SimplemappingsPackage . eINSTANCE . getSimpleLinkMapping ( ) . isSuperTypeOf ( domainElement . eClass ( ) ) ) { return SimpleLinkMappingEditPart . VISUAL_ID ; } break ; case SimpleTopNodeEditPart . VISUAL_ID : if ( SimplemappingsPackage . eINSTANCE . getSimpleLabelNode ( ) . isSuperTypeOf ( domainElement . eClass ( ) ) ) { return SimpleLabelNodeEditPart . VISUAL_ID ; } if ( SimplemappingsPackage . eINSTANCE . getSimpleCompartment ( ) . isSuperTypeOf ( domainElement . eClass ( ) ) ) { return SimpleCompartmentEditPart . VISUAL_ID ; } if ( SimplemappingsPackage . eINSTANCE . getSimpleChildReference ( ) .", "gt": "isSuperTypeOf ( domainElement . eClass ( ) ) )", "prediction": "isSuperTypeOf ( domainElement . eClass ( ) ) )\n", "label": 0}
{"id": 15143, "input": "<s> package net . claribole . zgrviewer ; import java . util . Vector ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . DPath ; import fr . inria . zvtm . glyphs . VPolygon ; import fr . inria . zvtm . glyphs . VShape ; import fr . inria . zvtm . glyphs . ClosedShape ; import fr . inria . zvtm . svg . Metadata ; public class LEdge extends LElem { static final short UNDIRECTED = 0 ; static final short INCOMING = 1 ; static final short OUTGOING = 2 ; static final String UNDIRECTED_STR = \"--\" ; static final String DIRECTED_STR = \"->\" ; boolean directed = false ; LNode tail ; LNode head ; LEdge ( String title , Vector < Glyph > glyphs ) { this . title = title ; this . glyphs = new Glyph [ glyphs . size ( ) ] ; this . URLs = new String [ glyphs . size ( ) ] ; this . tooltips = new String [ glyphs . size ( ) ] ; for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] = glyphs . elementAt ( i ) ; if ( this . glyphs [ i ] . getOwner ( ) != null ) { URLs [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURL ( ) ; tooltips [ i ] = ( ( Metadata ) this . glyphs [ i ] . getOwner ( ) ) . getURLTitle ( ) ; } } if ( this . glyphs . length > 0 ) { this . groupID = ( ( Metadata ) this . glyphs [ 0 ] . getOwner ( ) ) . getClosestAncestorGroupID ( ) ; } else { this . groupID = Messages . EMPTY_STRING ; } for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] . setOwner ( this ) ; } } LEdge ( Vector < Glyph > glyphs ) { this . title = \"\" ; this . glyphs = new Glyph [ glyphs . size ( ) ] ; this . URLs = new String [ glyphs . size ( ) ] ; this . tooltips = new String [ glyphs . size ( ) ] ; for ( int i = 0 ; i < this . glyphs . length ; i ++ ) { this . glyphs [ i ] = glyphs . elementAt ( i ) ; this . glyphs [ i ] . setOwner ( this ) ; this . URLs [ i ] = \"\" ; this . tooltips [ i ] = \"\" ; } this . groupID = Messages . EMPTY_STRING ; }", "gt": "public String getURL ( Glyph g )", "prediction": "}\n", "label": 1}
{"id": 3637, "input": "<s> package org . jjflyboy . tjpeditor . serializer ;", "gt": "public class ProjectSyntacticSequencer extends AbstractProjectSyntacticSequencer", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 15146, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . nodes . MatchAllDocsQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . standard . parser . EscapeQuerySyntaxImpl ; import org . apache", "gt": ". lucene . search . MatchAllDocsQuery ;", "prediction": ". lucene . queryParser . standard . parser . TermQueryParser ;\n", "label": 1}
{"id": 2285, "input": "<s> package org . bombusim . sasl ; import java . io . UnsupportedEncodingException ; import org . bombusim . lime . logger . LimeLog ; import org . bombusim . util . strconv ; import org . bombusim . xmpp . XmppJid ; import org . bombusim . xmpp . XmppObject ; public class SASL_Plain implements SaslAuthMechanism { @ Override public String getName ( ) { return \"PLAIN\" ; } @ Override public String init ( XmppJid jid , String password ) { LimeLog . i ( \"SASL\" , \"Authentication: PLAIN\" , null ) ; String bareJid = jid . getBareJid ( ) ; String username =", "gt": "jid . getUser ( ) ;", "prediction": "jid . getPassword ( ) ;\n", "label": 0}
{"id": 15153, "input": "<s> package br . org . archimedes . io . svg . elements ; import static org . junit . Assert . assertEquals ; import java . io . ByteArrayOutputStream ; import java . util . ArrayList ; import java . util . List ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; public class PolylineExporterTest extends Tester { private Polyline polyline ; private PolylineExporter exporter ; private ByteArrayOutputStream stream ; @ Before public void setUp ( ) throws Exception { List < Point > list = new ArrayList < Point > ( ) ; list . add ( new Point ( 0 , 0 ) ) ; list . add ( new Point ( 0 , 100 ) ) ; list . add ( new Point ( 100 , 0 ) ) ; list . add ( new Point ( 100 , 100 ) ) ; polyline = new Polyline ( list ) ; exporter", "gt": "= new PolylineExporter ( ) ;", "prediction": "= new PolylineExporter ( ) ;\n", "label": 1}
{"id": 4325, "input": "<s> class A { void m1 ( ) { System . err . println ( \"hello\" ) ; 0 System . err", "gt": ". println ( \"world\" ) ;", "prediction": ". println ( \"world\" ) ;\n", "label": 0}
{"id": 15167, "input": "<s> package io . beancounter . commons . tests . model ; import io . beancounter . commons . tests . annotations . Random ; import java . util . UUID ; public class FakePoint { private UUID id ; private double x ; private double y ; @ Random ( names = { \"id\" , \"x\" , \"y\" } ) public FakePoint ( UUID id , Double x , Double y ) { this . id = id ; this . x = x ; this . y = y ; } public UUID getId ( ) { return id ; } public double getX ( ) { return x ; } public double getY ( ) { return y ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; FakePoint fakePoint = ( FakePoint ) o ; if ( Double . compare ( fakePoint . x , x ) != 0 ) return false ; if ( Double . compare ( fakePoint . y , y ) != 0 ) return false ; if ( id != null ? ! id . equals ( fakePoint . id ) : fakePoint . id != null ) return false ; return true ; } @ Override public int hashCode ( ) { int result ; long temp ; result = id != null ? id . hashCode ( ) : 0 ; temp = x != + 0.0d ? Double . doubleToLongBits ( x ) : 0L ; result = 31 * result + ( int ) ( temp ^ ( temp > > > 32 ) ) ; temp = y != + 0.0d ? Double .", "gt": "doubleToLongBits ( y ) : 0L ;", "prediction": "doubleToLongBits ( y ) : 0L ;\n", "label": 1}
{"id": 6707, "input": "<s> package org . jboss . arquillian . android . enricher ; import java . lang . annotation . Annotation ; import java . util . logging . Logger ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . core . api . Instance ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . test . api . ArquillianResource ; import org . jboss . arquillian . test . spi . enricher . resource . ResourceProvider ; public class AndroidDeviceResourceProvider implements ResourceProvider { private static final Logger log = Logger . getLogger ( AndroidDeviceResourceProvider . class . getName ( ) ) ; @ Inject Instance < AndroidDevice > androidDevice ; @ Override public boolean canProvide ( Class < ? > type ) { return AndroidDevice . class . isAssignableFrom ( type ) ; } @ Override public Object lookup ( ArquillianResource resource , Annotation ... qualifiers ) { AndroidDevice device = androidDevice . get ( ) ; if ( device == null ) { log . severe ( \"Unable to Inject Android", "gt": "Device controller into test\" ) ;", "prediction": "device\" ) ;\n", "label": 0}
{"id": 15171, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import java . util . Iterator ; import de . uos . igf . db3d . dbms . geom . Line3D ; import de . uos . igf . db3d . dbms . geom . MBB3D ; import de . uos . igf . db3d . dbms . geom . Plane3D ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . geom . Segment3D ; import de . uos . igf . db3d . dbms . geom . SimpleGeoObj ; import de . uos . igf . db3d . dbms . geom . Tetrahedron3D ; import de . uos . igf . db3d . dbms . geom . Triangle3D ; import de . uos . igf . db3d . dbms . util . SAM ; public class TetrahedronNet3D extends SpatialObject3D implements Solid3D , ComplexGeoObj { protected TetrahedronNet3DComp [ ] components ; public TetrahedronNet3D ( ScalarOperator sop ) { super ( ) ; this . components = null ; this . setScalarOperator ( sop ) ; this . setMBB ( null ) ; } protected TetrahedronNet3D ( TetrahedronNet3DComp [ ] components , ScalarOperator sop ) { super ( ) ; this . components = components ; this . setScalarOperator ( sop ) ; updateMBB ( ) ; } public TetrahedronNet3D ( TetrahedronNet3D net ) { super ( ) ; TetrahedronNet3DComp [ ] comps = net . getComponents ( ) ; this . components = new TetrahedronNet3DComp [ comps . length ] ; for ( int i = 0 ; i < comps . length ; i ++ ) { this . components [ i ] = comps [ i ] . serializationCopy ( ) ; this . components [ i ] . setNet ( this ) ; } this . setScalarOperator ( net . getScalarOperator ( ) . copy ( ) ) ; updateMBB ( ) ; } public int countComponents ( ) { return getComponents ( ) . length ; } public int countElements ( ) { int sum = 0 ; for ( int i = 0 ; i < countComponents ( ) ; i ++ ) sum = sum + getComponent ( i ) . countElements ( ) ; return sum ; } public TetrahedronNet3DComp [ ] getComponents ( ) { if ( components != null ) return components ; else return new TetrahedronNet3DComp [ 0 ] ; } public TetrahedronNet3DComp getComponent ( int index ) { return this . components [ index ] ; } public void addComponent ( TetrahedronNet3DComp comp ) { Iterator it = comp . getElementsViaRecursion ( ) . iterator ( ) ; while ( it . hasNext ( ) ) ( ( TetrahedronElt3D ) it . next ( ) )", "gt": ". setID ( this . nextElementID ( ) ) ;", "prediction": ". add ( comp ) ;\n", "label": 1}
{"id": 9959, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . List ; import com . mobeelizer . mobile . android . api . MobeelizerCriterion ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerNotRestritionImpl implements MobeelizerInternalCriterion { private final MobeelizerCriterion criterion ; public MobeelizerNotRestritionImpl ( final MobeelizerCriterion criterion ) { this . criterion = criterion ; } @ Override public String addToQuery ( final", "gt": "List < String > selectionArgs , final MobeelizerAndroidModel model )", "prediction": "String query )\n", "label": 0}
{"id": 15185, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . FieldSelector ; import org . apache . lucene . document . FieldSelectorResult ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . search . FieldCache ; import java . io . IOException ; import java . util . * ; public class ParallelReader extends IndexReader { private List readers = new ArrayList ( ) ; private List decrefOnClose = new ArrayList ( ) ; boolean incRefReaders = false ; private SortedMap fieldToReader = new TreeMap ( ) ; private Map readerToFields = new HashMap ( ) ; private List storedFieldReaders = new ArrayList ( ) ; private int maxDoc ; private int numDocs ; private boolean hasDeletions ; public ParallelReader ( ) throws IOException { this ( true ) ; } public ParallelReader ( boolean closeSubReaders ) throws IOException { super ( ) ; this . incRefReaders = ! closeSubReaders ; } public void add ( IndexReader reader ) throws IOException { ensureOpen ( ) ; add ( reader , false ) ; } public void add ( IndexReader reader , boolean ignoreStoredFields ) throws IOException { ensureOpen ( ) ; if ( readers . size ( ) == 0 ) { this . maxDoc = reader . maxDoc ( ) ; this . numDocs = reader . numDocs ( ) ; this . hasDeletions = reader . hasDeletions ( ) ; } if ( reader . maxDoc ( ) != maxDoc ) throw new IllegalArgumentException ( \"All readers must have same maxDoc: \" + maxDoc + \"!=\" + reader . maxDoc ( ) ) ; if ( reader . numDocs ( ) != numDocs ) throw new IllegalArgumentException ( \"All readers must have same numDocs: \" + numDocs + \"!=\" + reader . numDocs ( ) ) ; Collection fields = reader . getFieldNames ( IndexReader . FieldOption . ALL ) ; readerToFields . put ( reader , fields ) ; Iterator i = fields . iterator ( ) ; while ( i . hasNext ( ) ) { String field = ( String ) i . next ( ) ; if ( fieldToReader . get ( field ) == null ) fieldToReader . put ( field , reader ) ; } if ( ! ignoreStoredFields ) storedFieldReaders . add ( reader ) ; readers . add ( reader ) ; if ( incRefReaders ) { reader . incRef ( ) ; } decrefOnClose . add ( Boolean . valueOf ( incRefReaders ) ) ; } public synchronized Object clone ( ) { try { return doReopen ( true ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } public synchronized IndexReader reopen ( ) throws CorruptIndexException , IOException { return doReopen ( false ) ; } protected IndexReader doReopen ( boolean doClone ) throws CorruptIndexException , IOException { ensureOpen ( ) ; boolean reopened = false ; List newReaders = new ArrayList ( ) ; boolean success = false ; try { for ( int i = 0 ; i < readers . size ( ) ; i ++ ) { IndexReader oldReader = ( IndexReader ) readers . get ( i ) ; IndexReader newReader = null ; if ( doClone ) { newReader = ( IndexReader ) oldReader . clone ( ) ; } else { newReader = oldReader . reopen ( ) ; } newReaders . add ( newReader ) ; if ( newReader != oldReader ) { reopened = true ; } } success = true ; } finally { if ( ! success && reopened ) { for ( int i = 0 ; i < newReaders . size ( ) ; i ++ ) { IndexReader r = ( IndexReader ) newReaders . get ( i ) ; if ( r != readers . get ( i ) ) { try { r . close ( ) ; } catch ( IOException ignore ) { } } } } } if ( reopened ) { List newDecrefOnClose = new ArrayList ( ) ; ParallelReader pr = new ParallelReader ( ) ; for ( int i = 0 ; i < readers . size ( ) ; i ++ ) { IndexReader oldReader = ( IndexReader ) readers . get ( i ) ; IndexReader newReader = ( IndexReader ) newReaders . get ( i ) ; if ( newReader == oldReader ) { newDecrefOnClose . add ( Boolean . TRUE ) ; newReader . incRef ( ) ; } else { newDecrefOnClose . add ( Boolean . FALSE ) ; } pr . add ( newReader , ! storedFieldReaders . contains ( oldReader ) ) ; } pr . decrefOnClose = newDecrefOnClose ; pr . incRefReaders = incRefReaders ; return pr ; } else { return this ; } } public int numDocs ( ) { return numDocs ; } public int maxDoc ( ) { return maxDoc ; } public boolean hasDeletions ( ) { return hasDeletions ; } public", "gt": "boolean isDeleted ( int n )", "prediction": "boolean hasDeletions ( )\n", "label": 1}
{"id": 4911, "input": "<s> class DABlock { void foo ( ) { try { String y = \"yyy\" ; } finally { } String a = String . valueOf ( a ) ; System . out . println (", "gt": "\"a=\" + a ) ;", "prediction": "a ) ;\n", "label": 0}
{"id": 15189, "input": "<s> package org . apache . lucene . ant ; import org . apache . lucene . document . Document ; import java . io . File ; public class FileExtensionDocumentHandler implements DocumentHandler { public Document getDocument ( File file ) throws DocumentHandlerException { Document doc = null ; String name = file . getName ( ) ; try { if ( name . endsWith ( \".txt\" ) ) { doc = TextDocument . Document ( file ) ; } if ( name .", "gt": "endsWith ( \".html\" ) )", "prediction": "endsWith ( \".txt\" ) )\n", "label": 1}
{"id": 8897, "input": "<s> package org . jjflyboy . tjpeditor . project ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . Enumerator ; public enum YesNo implements Enumerator { YES ( 0 , \"YES\" , \"yes\" ) , NO ( 1 , \"NO\" , \"no\" ) ; public static final int YES_VALUE = 0 ; public static final int NO_VALUE = 1 ; private static final YesNo [ ] VALUES_ARRAY = new YesNo [ ] { YES , NO , } ; public static final List < YesNo > VALUES = Collections . unmodifiableList ( Arrays . asList ( VALUES_ARRAY ) ) ; public static YesNo get ( String literal ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { YesNo result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( literal ) ) { return result ; } } return null ; } public static YesNo getByName ( String name ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { YesNo result = VALUES_ARRAY [ i ] ; if ( result . getName ( ) . equals ( name ) ) { return result ; } } return null ; } public static YesNo get ( int value ) { switch ( value ) { case YES_VALUE : return YES ; case NO_VALUE : return NO ; } return null ; } private final int value ; private final String name ; private final String literal ; private YesNo ( int value , String name , String literal ) { this . value = value ; this . name = name ; this . literal = literal ; } public int getValue ( ) { return value ; }", "gt": "public String getName ( )", "prediction": "public void setValue ( int value )\n", "label": 0}
{"id": 15213, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . ISerializable ; public abstract class SenseDataDescriptor implements ISerializable { private static final int COMMON_FIELDS_LENGTH = 2 ; private final SenseDataDescriptorType descriptorType ; private final int additionalLength ; public SenseDataDescriptor ( final SenseDataDescriptorType descriptorType , final int additionalLength ) { this . descriptorType = descriptorType ; this . additionalLength = additionalLength ; } private final void serializeCommonFields ( final ByteBuffer byteBuffer , final int index ) { byteBuffer . position ( index ) ; byteBuffer . put ( descriptorType . getValue ( ) ) ; byteBuffer . put ( ( byte ) additionalLength ) ; } protected abstract void serializeSpecificFields ( ByteBuffer byteBuffer , final int index ) ; private final int getAdditionalLength ( ) { return additionalLength ; } public void serialize", "gt": "( ByteBuffer byteBuffer , int index )", "prediction": "SpecificFields ( final ByteBuffer byteBuffer , final int index )\n", "label": 1}
{"id": 5892, "input": "<s> package org . dawb . workbench . plotting . views ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . SubActionBars ; import org . eclipse . ui . internal . PartSite ; import org . eclipse . ui . internal . PopupMenuExtender ; import org . eclipse . ui . internal . part . IPageSiteHolder ; import org . eclipse . ui . internal . services . INestable ; import org . eclipse . ui . internal . services . IServiceLocatorCreator ; import org . eclipse . ui . internal . services . IWorkbenchLocationService ; import org . eclipse . ui . internal . services . ServiceLocator ; import org . eclipse . ui . internal . services . WorkbenchLocationService ; import org . eclipse . ui . part . IPageSite ; import org . eclipse . ui . services . IDisposable ; import org . eclipse . ui . services . IServiceScopes ; public class ToolPageSite implements IPageSite , INestable { private ArrayList menuExtenders ; private IViewSite parentSite ; private ISelectionProvider selectionProvider ; private final ServiceLocator serviceLocator ; private SubActionBars subActionBars ; public ToolPageSite ( final IViewSite parentViewSite ) { Assert . isNotNull ( parentViewSite ) ; parentSite = parentViewSite ; subActionBars = new SubActionBars ( parentViewSite . getActionBars ( ) , this ) ; IServiceLocatorCreator slc = ( IServiceLocatorCreator ) parentSite . getService ( IServiceLocatorCreator . class ) ; this . serviceLocator = ( ServiceLocator ) slc . createServiceLocator ( parentViewSite , null , new IDisposable ( ) { public void dispose ( ) { final Control control = ( ( PartSite ) parentViewSite ) . getPane ( ) . getControl ( ) ; if ( control != null && ! control . isDisposed ( ) ) { ( ( PartSite ) parentViewSite ) . getPane ( ) . doHide ( ) ; } } } ) ; initializeDefaultServices ( ) ; } private void initializeDefaultServices ( ) { serviceLocator . registerService ( IWorkbenchLocationService . class , new WorkbenchLocationService ( IServiceScopes . PAGESITE_SCOPE , getWorkbenchWindow ( ) . getWorkbench ( ) , getWorkbenchWindow ( ) , parentSite , null , this , 3 ) ) ; serviceLocator . registerService ( IPageSiteHolder . class , new IPageSiteHolder ( ) { public IPageSite getSite ( ) { return ToolPageSite . this ; } } ) ; } protected void dispose ( ) { if ( menuExtenders != null ) { HashSet managers = new HashSet ( menuExtenders . size ( ) ) ; for ( int i = 0 ; i < menuExtenders . size ( ) ; i ++ ) { PopupMenuExtender ext = ( PopupMenuExtender ) menuExtenders . get ( i ) ; managers . add ( ext . getManager ( ) ) ; ext . dispose ( ) ; } if ( managers . size ( ) > 0 ) { for ( Iterator iterator = managers . iterator ( ) ; iterator . hasNext ( ) ; ) { MenuManager mgr = ( MenuManager ) iterator . next ( ) ; mgr . dispose ( ) ; } } menuExtenders = null ; } subActionBars . dispose ( ) ; serviceLocator . dispose ( ) ; } public IActionBars getActionBars ( ) { return subActionBars ; } public Object getAdapter ( Class adapter ) { return Platform . getAdapterManager ( ) . getAdapter ( this , adapter ) ; } public IWorkbenchPage getPage ( ) { return parentSite . getPage ( ) ; } public ISelectionProvider getSelectionProvider ( ) { return selectionProvider ; } public final Object getService ( final Class key ) { return serviceLocator . getService ( key ) ; }", "gt": "public Shell getShell ( )", "prediction": "}\n", "label": 0}
{"id": 15224, "input": "<s> package org . apache . lucene . queryParser . surround . query ; import java . util . List ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . BooleanClause ; public class AndQuery extends ComposedQuery { public AndQuery ( List queries , boolean", "gt": "inf , String opName )", "prediction": "Clause )\n", "label": 1}
{"id": 8815, "input": "<s> abstract class BaseClass { protected BaseClass ( ) { x ( ) ; } protected abstract void x ( ) ; } public class Closure3 { public static void main ( String [ ] args ) { callingMethod ( \"12345678\" ) ; } protected static void callingMethod ( final String parameter ) { String t = \"12345\" ; final String local_var = t ; BaseClass enum_ = new BaseClass ( ) { public void x ( ) { int i = parameter . length ( ) + local_var . length ( ) ; if", "gt": "( i != 13 ) throw new Error ( ) ;", "prediction": "( i > 0 )\n", "label": 0}
{"id": 15225, "input": "<s> package org . nuxeo . ecm . platform . annotations . service ; import java . net . URI ; import org . junit . Test ; import static org . junit . Assert . * ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; public class DefaultUriResolverTest { private static final String baseUrl = \"http://myexemple.com/nuxeo/Annotations/\" ; private static final String annId = \"3ACF6D754\" ; private static final String annotationUrl = baseUrl + annId ; private static final String annotationUrn = \"urn:annotation:\" + annId ; private final UriResolver resolver = new DefaultUriResolver ( ) ; @ Test public void testTranslateToGraphUri ( ) throws Exception { URI result = resolver .", "gt": "translateToGraphURI ( new URI ( annotationUrl ) ) ;", "prediction": "getURI ( ) ;\n", "label": 1}
{"id": 7451, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . OS ; import javax . swing . * ; import javax . swing . text . * ; import java . awt . * ; import java . awt . datatransfer . * ; import java . awt . event . * ; import java . util . ResourceBundle ; public class TextComponentPopupHandler extends MouseAdapter { private static TextComponentPopupHandler INSTANCE ; public static TextComponentPopupHandler getInstance ( ) { if ( INSTANCE == null ) { INSTANCE = new TextComponentPopupHandler ( ) ; } return INSTANCE ; } private ResourceBundle bundle ; private Action cutAction ; private Action copyAction ; private Action pasteAction ; private Action deleteAction ; private Action selectAllAction ; private JPopupMenu popupMenu ; private JTextComponent comp ; private TextComponentPopupHandler ( ) { bundle = ResourceBundle . getBundle ( \"com.pagosoft.plaf.Bundle\" ) ; cutAction = new CutAction ( ) ; copyAction = new CopyAction ( ) ; pasteAction = new PasteAction ( ) ; deleteAction = new DeleteAction ( ) ; selectAllAction = new SelectAllAction ( ) ; } public ImageIcon getIcon ( String name ) { try { return new ImageIcon ( TextComponentPopupHandler . class . getResource ( \"/com/pagosoft/plaf/icons/\" + name ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public void mousePressed ( MouseEvent e ) { if ( ( ! e . isPopupTrigger ( ) && ! ( ! OS . isMacOsX ( ) && e . getButton ( ) == MouseEvent . BUTTON3 ) ) || MenuSelectionManager . defaultManager ( ) . getSelectedPath ( ) . length > 0 ) { return ; } if ( ! ( e . getComponent ( ) instanceof JTextComponent ) ) { return ; } comp = ( JTextComponent ) e . getComponent ( ) ; popupMenu = new JPopupMenu ( ) ; popupMenu . add ( cutAction ) ; popupMenu . add ( copyAction ) ; popupMenu . add ( pasteAction ) ; popupMenu . add ( deleteAction ) ; popupMenu . addSeparator ( ) ; popupMenu . add ( selectAllAction ) ; popupMenu . show ( comp , e . getX ( ) , e . getY ( ) ) ; } private class CutAction extends AbstractAction { public CutAction ( ) { super ( bundle . getString ( \"textcomponent.cut\" ) , getIcon ( \"editcut.png\" ) ) ; putValue ( Action . ACCELERATOR_KEY , KeyStroke . getKeyStroke ( \"control X\" ) ) ; } public void actionPerformed ( ActionEvent e ) { comp . cut ( ) ; } public boolean isEnabled ( ) { return comp . isEditable ( ) && comp . isEnabled ( ) && comp . getSelectedText ( ) != null ; } } private class CopyAction extends AbstractAction { public CopyAction ( ) { super ( bundle . getString ( \"textcomponent.copy\" ) , getIcon ( \"editcopy.png\" ) ) ; putValue ( Action . ACCELERATOR_KEY , KeyStroke . getKeyStroke ( \"control C\" ) ) ; } public void actionPerformed ( ActionEvent e ) { comp . copy ( ) ; } public boolean isEnabled ( ) { return comp . isEnabled ( ) && comp . getSelectedText ( ) != null ; } } private class PasteAction extends AbstractAction { public PasteAction ( ) { super ( bundle . getString", "gt": "( \"textcomponent.paste\" ) , getIcon ( \"editpaste.png\" ) ) ;", "prediction": "( \"textcomponent.paste\" ) , getIcon ( \"paste.png\" ) ) ;\n", "label": 0}
{"id": 15228, "input": "<s> package org . seage . metaheuristic . tabusearch ; public class ComplexTabuList implements TabuList { private static final long serialVersionUID = - 1144625207822991616L ; public final static int DEFAULT_TENURE = 10 ; public final static int DEFAULT_NUM_ATTR = 2 ; private int tenure ; private int [ ] [ ] tabuList ; private int currentPos ; private int listLength ; private int numAttr ; private final static double LIST_GROW_FACTOR = 2.0 ; public ComplexTabuList ( ) { this ( DEFAULT_TENURE , DEFAULT_NUM_ATTR ) ; } public ComplexTabuList ( int tenure , int numAttr ) { super ( ) ; this . tenure = tenure ; this . numAttr = numAttr ; this . listLength = ( int ) ( tenure * LIST_GROW_FACTOR ) ; this . tabuList = new int [ listLength ] [ numAttr ] ; this . currentPos = 0 ; for ( int i = 0 ; i < listLength ; i ++ ) for ( int j = 0 ; j < numAttr ; j ++ ) this . tabuList [ i ] [ j ] = Integer . MIN_VALUE ; } public boolean isTabu ( Solution fromSolution , Move move ) { if ( ! ( move instanceof ComplexMove ) ) throw new IllegalArgumentException ( \"Move is not of type ComplexMove\" ) ; ComplexMove cMove = ( ComplexMove ) move ; int [ ] attrs = cMove . attributes ( ) ; if ( attrs . length != this . numAttr ) throw new IllegalArgumentException ( \"Wrong number of attributes (\" + attrs . length + \"). Should be \" + this . numAttr + \".\" ) ; for ( int i = 1 ; i <= tenure ; i ++ ) if ( currentPos - i < 0 ) return false ; else for ( int j = 0 ; j < this . numAttr ; j ++ ) if ( attrs [ j ] == tabuList [ ( currentPos - i ) % listLength ] [ j ] ) return true ; return false ; } public void setTabu ( Solution fromSolution , Move move ) { if ( ! ( move instanceof ComplexMove ) ) throw new IllegalArgumentException ( \"Move is not of type ComplexMove\" ) ; ComplexMove cMove = ( ComplexMove ) move ; int [ ] attrs = cMove . attributes ( ) ; if ( attrs . length != this . numAttr ) throw new IllegalArgumentException ( \"Wrong number of attributes (\" + attrs . length + \"). Should be \" + this . numAttr + \".\" ) ; for ( int j = 0 ; j < this . numAttr ; j ++ ) tabuList [ ( currentPos ) % listLength ] [ j ] = attrs [ j ] ; currentPos ++ ; } public int getNumberOfAttributes ( ) { return numAttr ; } public int getTenure ( ) { return tenure ; } public void setTenure ( int tenure ) { if ( tenure < 0 ) return ; if ( tenure > this . tenure && tenure > tabuList . length ) { listLength = ( int ) ( tenure * LIST_GROW_FACTOR ) ; int [ ] [ ] newTabuList = new int [ listLength ] [ this . numAttr ] ; for ( int i = 0 ; i < tabuList . length ; i ++ )", "gt": "newTabuList [ i ] = tabuList [ i ] ;", "prediction": "for ( int j = 0 ;\n", "label": 1}
{"id": 8828, "input": "<s> package com . mobeelizer . mobile . android ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; import java . util . UUID ; import android . os . Environment ; import android . util . Log ; import com . mobeelizer . java . sync . MobeelizerInputData ; class MobeelizerFileService { private static final String TAG = \"mobeelizer:fileservice\" ; private final MobeelizerApplication application ; MobeelizerFileService ( final MobeelizerApplication application ) { this . application = application ; } String addFile ( final InputStream stream ) { String guid = UUID . randomUUID ( ) . toString ( ) ; String path = savaFile ( guid , stream ) ; application . getDatabase ( ) . addFile ( guid , path ) ; return guid ; } void deleteFilesFromSync ( final List < String > files ) { for ( String guid : files ) { Log . i ( TAG , \"Delete file from sync: \" + guid ) ; String path = application . getDatabase ( ) . getFilePath ( guid ) ; if ( path == null ) { continue ; } File file = new File ( path ) ; if ( ! file . delete ( ) ) { Log . w ( TAG , \"Cannot remove file \" + file . getAbsolutePath ( ) ) ; } application . getDatabase ( ) . deleteFileFromSync ( guid ) ; } } void addFilesFromSync ( final List < String > files , final MobeelizerInputData inputData ) { for ( String guid : files ) { if ( application . getDatabase ( ) . isFileExists ( guid ) ) { Log . i ( TAG , \"Skip existing file from sync: \" + guid ) ; continue ; } Log . i ( TAG , \"Add file from sync: \" + guid ) ; String path = null ; try { path = savaFile ( guid , inputData . getFile ( guid ) ) ; } catch ( IOException e ) { Log . w ( TAG , e . getMessage ( ) , e ) ; path = \"/unknown\" ; } application . getDatabase ( ) . addFileFromSync ( guid , path ) ; } } private String savaFile ( final String guid , final InputStream stream ) { File dir = getStorageDirectory ( ) ; File file", "gt": "= new File ( dir , guid ) ;", "prediction": "= new File ( dir ) ;\n", "label": 0}
{"id": 15235, "input": "<s> package org . nuxeo . ecm . platform . annotations . service ; import java . util . List ; import org . nuxeo . ecm . platform . annotations . api . AnnotationException ; import org . nuxeo . ecm . platform . annotations . api . UriResolver ; import org . nuxeo . ecm . platform . annotations . descriptors . PermissionMapperDescriptor ; public interface AnnotationConfigurationService { void setUriResolver ( UriResolver resolver ) ; UriResolver getUriResolver ( ) ; void setFilter ( URLPatternFilter filter ) ; URLPatternFilter getUrlPatternFilter ( ) ; void setMetadataMapper ( MetadataMapper mapper ) ; MetadataMapper getMetadataMapper ( ) ; void setPermissionManager ( PermissionManager manager ) ; PermissionManager getPermissionManager ( ) ; void setAnnotabilityManager ( AnnotabilityManager annotabilityManager ) ; AnnotabilityManager getAnnotabilityManager ( ) ; void addListener ( EventListener listener ) ; List < EventListener > getListeners ( ) ; void setIDGenerator ( AnnotationIDGenerator generator ) ; AnnotationIDGenerator getIDGenerator ( ) ; void", "gt": "setPermissionMapper ( PermissionMapperDescriptor contribution ) ;", "prediction": "addListener ( EventListener listener ) ;\n", "label": 1}
{"id": 7601, "input": "<s> package org . ofbiz . common . email ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . Writer ; import java . net . MalformedURLException ; import java . net . URL ; import java . security . Security ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Properties ; import javax . activation . DataHandler ; import javax . activation . DataSource ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . SendFailedException ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeMultipart ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . stream . StreamSource ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . apache . fop . apps . Fop ; import org . apache . fop . apps . MimeConstants ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . HttpClient ; import org . ofbiz . base . util . HttpClientException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtilProperties ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . mail . MimeMessageWrapper ; import org . ofbiz . webapp . view . ApacheFopWorker ; import org . ofbiz . widget . fo . FoScreenRenderer ; import org . ofbiz . widget . html . HtmlScreenRenderer ; import org . ofbiz . widget . screen . ScreenRenderer ; import org . xml . sax . SAXException ; import com . sun . mail . smtp . SMTPAddressFailedException ; public class EmailServices { public final static String module = EmailServices . class . getName ( ) ; protected static final HtmlScreenRenderer htmlScreenRenderer = new HtmlScreenRenderer ( ) ; protected static final FoScreenRenderer foScreenRenderer = new FoScreenRenderer ( ) ; public static final String resource = \"CommonUiLabels\" ; public static Map < String , Object > sendMail ( DispatchContext ctx , Map < String , ? extends Object > context ) { Delegator delegator = ctx . getDelegator ( ) ; String communicationEventId = ( String ) context . get ( \"communicationEventId\" ) ; String orderId = ( String ) context . get ( \"orderId\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( communicationEventId != null ) { Debug . logInfo ( \"SendMail Running, for communicationEventId : \" + communicationEventId , module ) ; } Map < String , Object > results = ServiceUtil . returnSuccess ( ) ; String subject = ( String ) context . get ( \"subject\" ) ; subject = FlexibleStringExpander . expandString ( subject , context ) ; String partyId = ( String ) context . get ( \"partyId\" ) ; String body = ( String ) context . get ( \"body\" ) ; List < Map < String , Object > > bodyParts = UtilGenerics . checkList ( context . get ( \"bodyParts\" ) ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; results . put ( \"communicationEventId\" , communicationEventId ) ; results . put ( \"partyId\" , partyId ) ; results . put ( \"subject\" , subject ) ; if ( UtilValidate . isNotEmpty ( orderId ) ) { results . put ( \"orderId\" , orderId ) ; } if ( UtilValidate . isNotEmpty ( body ) ) { body = FlexibleStringExpander . expandString ( body , context ) ; results . put ( \"body\" , body ) ; } if ( UtilValidate . isNotEmpty ( bodyParts ) ) { results . put ( \"bodyParts\" , bodyParts ) ; } results . put ( \"userLogin\" , userLogin ) ; String sendTo = ( String ) context . get ( \"sendTo\" ) ; String sendCc = ( String ) context . get ( \"sendCc\" ) ; String sendBcc = ( String ) context . get ( \"sendBcc\" ) ; String redirectAddress = UtilProperties .", "gt": "getPropertyValue ( \"general.properties\" , \"mail.notifications.redirectTo\" ) ;", "prediction": "get ( \"redirectAddress\" ) ;\n", "label": 0}
{"id": 15243, "input": "<s> package br . org . archimedes . ellipse . tests ; import static org . junit . Assert . * ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import org . junit . Before ; import org . junit . Test ; import br . org . archimedes . Constant ; import br . org . archimedes . ellipse . Ellipse ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . InvalidParameterException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . ReferencePoint ; import br . org . archimedes . model . Vector ; public class EllipseTest { private Point widthPoint1 ; private Point heightPoint1 ; private Point center1 ; private Ellipse ellipse1 ; private Point widthPoint2 ; private Point heightPoint2 ; private Point center2 ; private Ellipse ellipse2 ; @ Before public void setUp ( ) throws Exception { this . center1 = new Point ( 0 , 0 ) ; this . widthPoint1 = new Point ( 0 , 10 ) ; this . heightPoint1 = new Point ( 5 , 0 ) ; this . ellipse1 = new Ellipse ( center1 , widthPoint1 , heightPoint1 ) ; this . center2 = new Point ( 1 , 1 ) ; this . widthPoint2 = new Point ( 6 , 1 ) ; this . heightPoint2 = new Point ( 1 , 11 ) ; this . ellipse2 = new Ellipse ( center2 , widthPoint2 , heightPoint2 ) ; } @ Test ( expected = NullArgumentException . class ) public void shouldNotCreateEllipseIfCenterIsNotPassed ( ) throws Exception { new Ellipse ( null , widthPoint1 , heightPoint1 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void shouldNotCreateEllipseIfPointsAreTooCloseOfCenter ( ) throws Exception { new Ellipse ( center1 , center1 , heightPoint1 ) ; } @ Test ( expected = InvalidArgumentException . class ) public void shouldNotCreateEllipseIfColinearPointsArePassed ( ) throws Exception { new Ellipse ( center1 , new Point ( - 5 , 0 ) , new Point ( 5 , 0 ) ) ; } @ Test public void shouldEqualsToAnotherEllipseIfAllPointsAreEquals ( ) throws Exception { Ellipse ellipse = new Ellipse ( center1 , widthPoint1 , heightPoint1 ) ; assertTrue ( ellipse1 . equals ( ellipse ) ) ; } @ Test public void shouldGetEqualSemiMajorAxis ( ) { assertEquals ( ellipse1 . getSemiMajorAxis ( ) , new Vector ( center1 , widthPoint1 ) ) ; Vector expected = new Vector ( new Point ( 1 , 1 ) , new Point ( 1 , 11 ) ) ; assertEquals ( expected , ellipse2 . getSemiMajorAxis ( ) ) ; } @ Test public void getFiTest ( ) { assertEquals ( Math . PI / 2 , ellipse1 . getFi ( ) , Constant . EPSILON ) ; assertEquals ( 0 , ellipse2 . getFi ( ) , Constant . EPSILON ) ; } @ Test public void getSemiMinorAxisTest ( ) { Vector expected = new Vector ( new Point ( 0 , 0 ) , new Point ( - 5 , 0 ) ) ; assertEquals ( expected , ellipse1 . getSemiMinorAxis ( ) ) ; expected = new Vector ( new Point ( 1 , 1 ) , new Point ( 6 , 1 ) ) ; assertEquals ( expected , ellipse2 . getSemiMinorAxis ( ) ) ; } @ Test public void cloneTest ( ) { Ellipse ellipseClone = ( Ellipse ) ellipse1 . clone ( ) ; assertEquals ( ellipseClone , ellipse1 ) ; assertNotSame ( ellipseClone , ellipse1 ) ; } @ Test public void testHashCodeEllipse ( ) throws Exception { int hash1 = ellipse1 . hashCode ( ) ; int hash2 = ellipse2 . hashCode ( ) ; assertEquals ( hash1 , ellipse1 . hashCode ( ) ) ; assertNotSame ( hash1 , hash2 ) ; Ellipse e1 = new Ellipse ( ellipse1 . getCenter ( ) , ellipse1 . getWidthPoint ( ) , ellipse1 . getHeightPoint ( ) ) ; int hash_e1 = e1 . hashCode ( ) ; assertEquals ( hash1 , hash_e1 ) ; e1 . move ( 5 , 0 ) ; assertNotSame ( hash_e1 , e1 . hashCode ( ) ) ; } @ Test public void boundaryRectangleTest ( ) { Rectangle r1 = new Rectangle ( - 5 , 10 , 5 , - 10 ) ; assertEquals ( r1 , ellipse1 . getBoundaryRectangle ( ) ) ; Rectangle r2 = new Rectangle ( - 4 , 11 , 6 , - 9 ) ; assertEquals ( r2 , ellipse2 . getBoundaryRectangle ( ) ) ; } @ Test public void rotateTest ( ) throws NullArgumentException { Ellipse e1 = ( Ellipse ) ellipse1 . clone ( ) ; e1 . rotate ( new Point ( 0 , 0 ) ,", "gt": "Math . PI / 2 ) ;", "prediction": "new Point ( - 5 , 0 ) ) ;\n", "label": 1}
{"id": 2298, "input": "<s> package com . example . tutorial . jobflow ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . example . tutorial . flowpart . TutorialFlowFactory ; import com . example . tutorial . flowpart . TutorialFlowFactory . TutorialFlow ; import com . example . tutorial . modelgen . table . model . ItemInfo ; import com . example . tutorial . modelgen . table . model . OrderAmount ; import com . example . tutorial . modelgen . table . model . OrderDetail ; @ JobFlow ( name = \"order\" ) public class TutorialJob extends FlowDescription { private In < OrderDetail > orderIn ; private In < ItemInfo > itemIn ; private Out < OrderDetail > orderOut ; private Out", "gt": "< OrderAmount > resultOut ;", "prediction": "< ItemInfo > itemOut ;\n", "label": 0}
{"id": 15258, "input": "<s> package org . eclipse . jface . viewers ; import java . util . Arrays ; import java . util . Comparator ; public class TreePathViewerSorter extends ViewerSorter { public int category ( TreePath parentPath , Object element ) { return category ( element ) ; } public int compare ( Viewer viewer , TreePath parentPath , Object e1 , Object e2 ) { return compare ( viewer , e1 , e2 ) ; } public boolean isSorterProperty ( TreePath parentPath , Object element , String property ) { return isSorterProperty ( element , property ) ; } public void sort ( final Viewer viewer , final TreePath parentPath , Object [ ] elements ) { Arrays . sort ( elements", "gt": ", new Comparator ( )", "prediction": ") ;\n", "label": 1}
{"id": 4554, "input": "<s> class T7034511b { static class MyList < E > { E toArray ( E [ ] e ) { return null ; } } void test ( MyList < ? > ml , Object o [ ] ) {", "gt": "ml . toArray ( o ) ;", "prediction": "List < E > list = new ArrayList < E > ( ) ;\n", "label": 0}
{"id": 15260, "input": "<s> package org . restlet . ext . jaxrs . internal . exceptions ; import java . util . Collection ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Variant ; import javax . ws . rs . core . Response . Status ; public class NotAcceptableWebAppException extends WebApplicationException { private static final long serialVersionUID = 6895779829973209211L ; private final Collection < Variant > supported ; public NotAcceptableWebAppException ( Collection < Variant > supported ) { super ( Status . NOT_ACCEPTABLE ) ; if ( supported == null ) { throw new IllegalArgumentException (", "gt": "\"The allowed variants must not be null\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2067, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface TaskRoot extends ReportAttribute { Task getTask ( ) ;", "gt": "void setTask ( Task value ) ;", "prediction": "}\n", "label": 0}
{"id": 15273, "input": "<s> package org . fuzzydb . client . userobjects ; import java . io . Serializable ; import org . fuzzydb . core . annotations . Key ; public class SampleUniqueKeyedObject implements Serializable { private static final long serialVersionUID = 1L ; @ Key ( unique = true ) private Integer key ; private int id ; public SampleUniqueKeyedObject ( int key , int id ) { this . key = new Integer ( key ) ; this . id = id ; } public int getKey ( ) { return key . intValue ( ) ; } public void setKey ( int key ) { this . key = new Integer ( key ) ; } public int getId ( ) { return id ; } public void", "gt": "setId ( int id )", "prediction": "setId ( int id )\n", "label": 1}
{"id": 5846, "input": "<s> package pkg ; public class C { public C field = null ; public C method ( ) { return null ; }", "gt": "public C multipleLineTest ( )", "prediction": "}\n", "label": 0}
{"id": 15274, "input": "<s> package org . apache . batik . svggen . font . table ; import java . io . IOException ; import java . io . RandomAccessFile ; public class CmapFormat2 extends CmapFormat { protected CmapFormat2 ( RandomAccessFile raf ) throws IOException { super ( raf ) ; format = 2 ; }", "gt": "public int getFirst ( )", "prediction": "}\n", "label": 1}
{"id": 2309, "input": "<s> import java . lang . annotation . * ; public class Pos04 { enum ExceptionKind { A ( 1 ) , B ( 2 ) , C ( 1 ) ; int expectedValue ; ExceptionKind ( int expectedValue ) { this . expectedValue = expectedValue ; } } @ Retention ( RetentionPolicy . RUNTIME ) @ interface CatchNumber { int value ( ) ; } @ CatchNumber ( 1 ) static class A extends Exception { } @ CatchNumber ( 2 ) static class B extends Exception { } @ CatchNumber ( 1 ) static class C extends Exception { } static int sum = 0 ; public static void main ( String [ ] args ) { for ( ExceptionKind ekind : ExceptionKind . values ( ) ) { test ( ekind ) ; } if ( sum != 4 ) { throw new Error ( \"bad checksum - expected:4, found:\" + sum ) ; } } public static void test ( ExceptionKind ekind ) { try { switch ( ekind ) { case A : throw new A ( ) ; case B : throw new B ( ) ; case C : throw new C ( ) ; } } catch ( final A | C ex ) { CatchNumber catchNumber = ex . getClass ( ) . getAnnotation ( CatchNumber . class ) ; if ( catchNumber == null || catchNumber . value ( ) != ekind . expectedValue ) { throw new Error", "gt": "( \"was expecting 1 - got \" + catchNumber ) ;", "prediction": "( \"bad checksum - expected:4, found:\" + catchNumber ) ;\n", "label": 0}
{"id": 15275, "input": "<s> package org . apache . lucene . queryParser . standard . config ; import java . util . HashMap ; import java . util . Map ; import org . apache . lucene . document . DateTools ; import org . apache . lucene . document . DateTools . Resolution ; import org . apache . lucene . util . AttributeImpl ; public class FieldDateResolutionMapAttributeImpl extends AttributeImpl implements FieldDateResolutionMapAttribute { private static final long serialVersionUID = - 2104763012523049527L ; private Map < CharSequence , DateTools . Resolution > dateRes = new HashMap < CharSequence , DateTools . Resolution > ( ) ; public FieldDateResolutionMapAttributeImpl ( ) { } public void setFieldDateResolutionMap ( Map < CharSequence , DateTools . Resolution > dateRes ) { this . dateRes = dateRes ; } public Map < CharSequence , Resolution > getFieldDateResolutionMap ( ) { return this . dateRes ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public void copyTo ( AttributeImpl target ) { throw new UnsupportedOperationException ( ) ; } public boolean equals ( Object other ) { if ( other instanceof FieldDateResolutionMapAttributeImpl && other != null && ( ( FieldDateResolutionMapAttributeImpl ) other ) . dateRes . equals ( this . dateRes ) ) { return true ; } return false ; } public int hashCode ( ) { final int prime = 97 ; if ( this . dateRes != null ) return this . dateRes . hashCode ( ) * prime ; else return Float . valueOf ( prime ) . hashCode ( ) ; } public String toString ( ) { return \"<fieldDateResolutionMapAttribute map=\"", "gt": "+ this . dateRes + \"/>\" ;", "prediction": "+ this . dateRes + \">\" ;\n", "label": 1}
{"id": 7894, "input": "<s> package fr . telecom . scrapbook . filters ; public class GradientFilter implements IImageFilter { private Palette palette = null ; public Gradient Gradient ; public float OriginAngleDegree ; public GradientFilter ( ) { this . OriginAngleDegree = 0f ; this . Gradient = new Gradient ( ) ; } public void ClearCache ( ) { this . palette = null ; } public Image process ( Image imageIn ) { int width = imageIn . getWidth ( ) ; int height = imageIn . getHeight ( ) ; double d = this . OriginAngleDegree * 0.0174532925 ; float cos = ( float ) Math . cos ( d ) ; float sin = ( float ) Math . sin ( d ) ; float radio = ( cos * width ) + ( sin * height ) ; float dcos = cos * radio ; float dsin = sin * radio ; int dist = ( int ) Math . sqrt ( ( double ) ( ( dcos * dcos ) + ( dsin * dsin ) ) ) ; dist = Math . max ( Math . max ( dist , width ) , height ) ; if ( ( this . palette == null ) || ( dist != this . palette . Length ) ) { this . palette = this . Gradient . CreatePalette ( dist ) ; } int [ ]", "gt": "red = this . palette . Red ;", "prediction": "filters = new int [ ]\n", "label": 0}
{"id": 15301, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import java . io . Serializable ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . core . api . Blob ; public class PictureViewImpl implements PictureView { int width ; int height ; String title ; String description ; String tag ; String filename ; Object content ; Blob blob ; public PictureViewImpl ( ) { } public PictureViewImpl ( Map < String , Serializable > m ) { title = ( String ) m . get ( PictureView . FIELD_TITLE ) ; description = ( String ) m . get ( PictureView . FIELD_DESCRIPTION ) ; tag = ( String ) m . get ( PictureView . FIELD_TAG ) ; filename = ( String ) m . get ( PictureView . FIELD_FILENAME ) ; blob = ( Blob ) m . get ( PictureView . FIELD_CONTENT ) ; Integer w = ( Integer ) m . get ( PictureView . FIELD_WIDTH ) ; if ( w != null ) { width = w ; } Integer h = ( Integer ) m . get ( PictureView . FIELD_HEIGHT ) ; if ( h != null ) { height = h ; } } @ Override public int getWidth ( ) { return width ; } @ Override public void setWidth ( int width ) { this . width = width ; } @ Override public String getTitle ( ) { return title ; } @ Override public void setTitle ( String title ) { this . title = title ; } @ Override public String getDescription ( ) { return description ; } @ Override public void setDescription ( String description ) { this . description = description ; } @ Override public String getTag ( ) { return tag ; } @ Override public void setTag ( String tag ) { this . tag = tag ; } @ Override public String getFilename ( ) { return filename ; } @ Override public void setFilename ( String filename ) { this . filename = filename ; } @ Override public Object getContent ( ) { return content ; } @ Override public void setContent ( Object content ) { this . content = content ; } @ Override public int getHeight ( ) { return height ; } @ Override public void setHeight ( int height ) { this . height = height ; } @ Override public Blob getBlob ( ) { return blob ; } @ Override public void setBlob ( Blob blob ) { this . blob = blob ; } @ Override public Map < String , Serializable > asMap ( ) { Map < String , Serializable > m = new HashMap < String , Serializable > ( ) ; m . put ( PictureView . FIELD_TITLE , getTitle ( ) ) ; m . put ( PictureView . FIELD_DESCRIPTION , getDescription ( ) ) ; m . put ( PictureView . FIELD_TAG , getTag ( ) ) ; m . put (", "gt": "PictureView . FIELD_HEIGHT , getHeight ( ) ) ;", "prediction": "PictureView . FIELD_CONTENT , getFilename ( ) ) ;\n", "label": 1}
{"id": 6534, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . kasse ; import java . awt . BorderLayout ; import java . awt . Color ; import java . awt . FlowLayout ; import java . awt . Font ; import javax . swing . BorderFactory ; import javax . swing . JButton ; import javax . swing . JComponent ; import javax . swing . JFrame ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JSplitPane ; import javax . swing . SwingConstants ; class KassenWerkzeugUI { private JFrame _frame ; private JButton _beendenButton ; public KassenWerkzeugUI ( JPanel platzVerkaufsPanel , JPanel datumAuswaehlPanel , JPanel vorstellungAuswaehlPanel ) { _frame = new JFrame ( \"SE2-Kinokartenverkauf\" ) ; _frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; _frame . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; JComponent topPanel = erstelleUeberschriftPanel ( ) ; JComponent leftPanel = erstelleVorstellungsauswahlPanel ( datumAuswaehlPanel , vorstellungAuswaehlPanel ) ; JComponent rightPanel = platzVerkaufsPanel ; JComponent bottomPanel = erstelleBeendenPanel ( ) ; JSplitPane splitter = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT , leftPanel , rightPanel ) ; _frame . getContentPane ( ) . add ( splitter , BorderLayout . CENTER ) ; _frame . getContentPane ( ) . add ( topPanel , BorderLayout . NORTH ) ; _frame . getContentPane ( ) . add ( bottomPanel , BorderLayout . SOUTH ) ; } public void zeigeFenster ( ) { _frame . setSize ( 1200 , 900 ) ; _frame . setVisible ( true ) ; } public void schliesseFenster ( ) { _frame . dispose ( ) ; } private JPanel erstelleVorstellungsauswahlPanel ( JPanel datumAuswaehlPanel , JPanel vorstellungAuswaehlPanel ) { JPanel leftPanel = new JPanel ( ) ; leftPanel . setLayout ( new", "gt": "BorderLayout ( ) ) ;", "prediction": "BorderLayout ( ) ) ;\n", "label": 0}
{"id": 15304, "input": "<s> package com . corundumstudio . socketio . parser ; import java . io . IOException ; import org . junit . Assert ; import org . junit . Test ; public class DecoderConnectionPacketTest extends DecoderBaseTest { @ Test public void testDecodeHeartbeat ( ) throws IOException { Packet packet = decoder . decodePacket ( \"2:::\" , null ) ; Assert . assertEquals ( PacketType . HEARTBEAT , packet . getType ( ) ) ; } @ Test public void testDecode ( ) throws IOException { Packet packet = decoder . decodePacket ( \"1::/tobi\" , null ) ; Assert . assertEquals ( PacketType . CONNECT , packet . getType ( ) ) ; Assert . assertEquals ( \"/tobi\" , packet . getEndpoint ( ) ) ; } @ Test public void testDecodeWithQueryString ( ) throws IOException { Packet packet = decoder . decodePacket ( \"1::/test:?test=1\" , null ) ; Assert . assertEquals ( PacketType . CONNECT , packet . getType ( ) ) ; Assert . assertEquals ( \"/test\" , packet . getEndpoint ( ) ) ; Assert . assertEquals ( \"?test=1\" ,", "gt": "packet . getQs ( ) ) ;", "prediction": "packet . getEndpoint ( ) ) ;\n", "label": 1}
{"id": 8070, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class LocalVariableTable_attribute extends Attribute { LocalVariableTable_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; local_variable_table_length = cr . readUnsignedShort ( ) ; local_variable_table = new Entry [ local_variable_table_length ] ; for ( int i = 0 ; i < local_variable_table_length ; i ++ ) local_variable_table [ i ] = new Entry ( cr ) ; } public LocalVariableTable_attribute ( ConstantPool constant_pool , Entry [ ] local_variable_table ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . LocalVariableTable ) , local_variable_table ) ; } public LocalVariableTable_attribute ( int name_index , Entry [ ] local_variable_table ) { super ( name_index , 2 + local_variable_table . length * Entry . length ( ) ) ; this . local_variable_table_length = local_variable_table . length ; this . local_variable_table = local_variable_table ; } public < R , D > R accept ( Visitor < R , D > visitor , D data ) { return visitor . visitLocalVariableTable ( this , data ) ; } public final int local_variable_table_length ; public final Entry [ ] local_variable_table ; public static class Entry { Entry ( ClassReader cr ) throws IOException { start_pc = cr . readUnsignedShort ( ) ;", "gt": "length = cr . readUnsignedShort ( ) ;", "prediction": "end_pc = cr . readUnsignedShort ( ) ;\n", "label": 0}
{"id": 15307, "input": "<s> import java . util . * ; public class C { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numPlayers = in . nextInt ( ) ; in . skip ( \" \" ) ; while ( numPlayers != 0 ) { String rolls = in . nextLine ( ) ; ArrayList < Integer > players = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < numPlayers ; i ++ ) { players . add ( 3 ) ; } int currPlayer = 1 ; int middle = 0 ; int i = 0 ; while ( i < rolls . length ) { char roll1 = rolls . charAt ( i ) ; i ++ ; char roll2 = rolls . charAt ( i ) ; i ++ ; char roll3 = rolls . charAt ( i ) ; i ++ ; } numPlayers = in . nextInt ( ) ; in . skip ( \" \" ) ; } } public static action ( ArrayList < Integer > players , char roll ) { if ( roll == \"L\" ) { giveLeft ( players , currPlayer ) ; } else if ( roll == \"R\" ) { giveRight ( players , currPlayer ) ; } else { players . set ( currPlayer - 1 , players . get ( currPlayer - 1 ) - 1 ) ; } } public static class Game { public ArrayList < Integer > players ; public int middle ; public int currPlayer ; public Game ( int numPlayers ) { this . players = new ArrayList < Integer > ( numPlayers ) ; for ( int i = 0 ; i < numPlayers ; i ++ ) { this . players . add ( 3 ) ; } this . middle = 0 ; this . currPlayer = 0 ; } public void simulate ( String rolls , int gameNumber ) { int i = 0 ; System . out . printf ( \"Game %d:\\n\" , gameNumber ) ; while ( i < rolls . length ) { ArrayList < Character > playerRolls = new ArrayList < Character > ( 3 ) ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; playerRolls . add ( rolls . charAt ( i ) ) ; i ++ ; this . processRolls ( playerRolls ) ; this . nextPlayer ( ) ; if ( this . winCondition ( ) ) this . displayWin ( ) ; break ; } this . displayEnd ( ) ; } private void displayWin ( ) { for ( int i = 0 ; i < this . players", "gt": ". size ( ) ;", "prediction": ". length ;\n", "label": 1}
{"id": 2784, "input": "<s> package pkg ; import java . lang . annotation . * ; @ Documented public @ interface AnnotationType {", "gt": "String optional ( ) default \"unknown\" ;", "prediction": "}\n", "label": 0}
{"id": 15308, "input": "<s> package org . eclipse . ui . tests . commands ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . ui . handlers . HandlerUtil ; import org . eclipse . ui . handlers . RadioState ; public class RadioStateHandler extends AbstractHandler { public Object execute ( ExecutionEvent event ) throws ExecutionException { if ( HandlerUtil . matchesRadioState", "gt": "( event ) ) return null ;", "prediction": "( event ) )\n", "label": 1}
{"id": 3055, "input": "<s> package org . parboiled . examples . calculators ; import org . parboiled . Rule ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . examples . calculators . CalculatorParser3 . CalcNode ; import org . parboiled . support . Var ; import org . parboiled . trees . ImmutableBinaryTreeNode ; @ BuildParseTree public class CalculatorParser3 extends CalculatorParser < CalcNode > { @ Override public Rule InputLine ( ) { return Sequence ( Expression ( ) , EOI ) ; } Rule Expression ( ) { Var < Character > op = new Var < Character > ( ) ; return Sequence ( Term ( ) , ZeroOrMore ( FirstOf ( \"+ \" , \"- \" ) , op . set ( matchedChar ( ) ) , Term ( ) , push ( new CalcNode ( op . get ( ) , pop ( 1 ) , pop ( ) ) ) ) ) ; } Rule Term ( ) { Var < Character > op = new Var < Character > ( ) ; return Sequence ( Factor ( ) , ZeroOrMore ( FirstOf ( \"* \" , \"/ \" ) , op . set ( matchedChar ( ) ) , Factor ( ) , push ( new CalcNode ( op . get ( ) , pop ( 1 ) , pop ( ) ) ) ) ) ; } Rule Factor ( ) { return Sequence ( Atom ( ) , ZeroOrMore ( \"^ \" , Atom ( ) , push ( new CalcNode ( '^' , pop ( 1 ) , pop ( ) ) ) ) ) ; } Rule Atom ( ) { return FirstOf ( Number ( ) , SquareRoot ( ) , Parens ( ) ) ; } Rule SquareRoot ( ) { return Sequence ( \"SQRT \" , Parens ( ) , push ( new CalcNode ( 'R' , pop ( ) , null ) ) ) ; } Rule Parens ( ) { return Sequence ( \"( \" , Expression ( ) , \") \" ) ; } Rule Number ( ) { return Sequence ( Sequence ( Optional ( '-' ) , OneOrMore ( Digit ( ) ) , Optional ( '.' , OneOrMore ( Digit ( ) ) ) ) , push ( new CalcNode ( Double . parseDouble ( matchOrDefault ( \"0\" ) ) ) ) , WhiteSpace ( ) ) ; } Rule Digit ( ) { return CharRange ( '0' , '9' ) ; } Rule WhiteSpace ( ) { return ZeroOrMore ( AnyOf ( \" \\t\\f\" ) ) ; } @ Override protected Rule fromStringLiteral ( String string ) { return string . endsWith ( \" \" ) ? Sequence ( String ( string . substring ( 0 , string . length ( ) - 1 ) ) , WhiteSpace ( ) ) : String ( string ) ; } public static class CalcNode extends ImmutableBinaryTreeNode < CalcNode > { private double value ; private Character operator ; public CalcNode ( double value ) { super ( null , null ) ; this . value = value ; } public CalcNode ( Character operator , CalcNode left , CalcNode right ) { super ( left , right ) ; this . operator = operator ; } public double getValue ( ) { if ( operator == null ) return value ; switch ( operator ) { case '+' : return left ( ) . getValue ( ) + right ( ) . getValue ( ) ; case '-' : return left ( ) . getValue ( ) - right ( ) . getValue ( ) ; case '*' : return left ( ) . getValue ( ) * right ( ) . getValue ( ) ; case '/' : return left ( ) . getValue ( ) / right ( ) . getValue ( ) ; case '^' : return Math . pow ( left ( ) . getValue ( )", "gt": ", right ( ) . getValue ( ) ) ;", "prediction": ", right ( ) . getValue ( ) ) ;\n", "label": 0}
{"id": 15310, "input": "<s> package org . eclipse . jface . bindings . keys . formatting ; import java . util . HashMap ; import java . util . ResourceBundle ; import org . eclipse . jface . bindings . keys . IKeyLookup ; import org . eclipse . jface . bindings . keys . KeyLookupFactory ; import org . eclipse . jface . bindings . keys . KeySequence ; import org . eclipse . jface . bindings . keys . KeyStroke ; import org . eclipse . jface . util . Util ; public final class NativeKeyFormatter extends AbstractKeyFormatter { private final static String CARBON_KEY_DELIMITER_KEY = \"CARBON_KEY_DELIMITER\" ; private final static HashMap CARBON_KEY_LOOK_UP = new HashMap ( ) ; private final static ResourceBundle RESOURCE_BUNDLE ; private final static String WIN32_KEY_STROKE_DELIMITER_KEY = \"WIN32_KEY_STROKE_DELIMITER\" ; static { RESOURCE_BUNDLE = ResourceBundle . getBundle ( NativeKeyFormatter . class . getName ( ) ) ; final String carbonBackspace = \"\u232b\" ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . BS_NAME , carbonBackspace ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . BACKSPACE_NAME , carbonBackspace ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . CR_NAME , \"\u21a9\" ) ; final String carbonDelete = \"\u2326\" ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . DEL_NAME , carbonDelete ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . DELETE_NAME , carbonDelete ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ALT_NAME , \"\u2325\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . COMMAND_NAME , \"\u2318\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . CTRL_NAME , \"\u2303\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . SHIFT_NAME , \"\u21e7\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_DOWN_NAME , \"\u2193\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_LEFT_NAME , \"\u2190\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_RIGHT_NAME , \"\u2192\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . ARROW_UP_NAME , \"\u2191\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . END_NAME , \"\u2198\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . NUMPAD_ENTER_NAME , \"\u2324\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . HOME_NAME , \"\u2196\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . PAGE_DOWN_NAME , \"\u21df\" ) ; CARBON_KEY_LOOK_UP . put ( IKeyLookup . PAGE_UP_NAME , \"\u21de\" ) ; } public final String format ( final int key ) { final IKeyLookup lookup = KeyLookupFactory . getDefault ( ) ; final String name = lookup . formalNameLookup ( key ) ; if ( Util . isMac ( ) ) { String formattedName = ( String ) CARBON_KEY_LOOK_UP . get ( name ) ; if ( formattedName != null ) { return formattedName ; } } return super . format ( key ) ; } protected String getKeyDelimiter ( ) { if ( Util . isMac ( ) ) { return Util . translateString ( RESOURCE_BUNDLE , CARBON_KEY_DELIMITER_KEY , Util . ZERO_LENGTH_STRING ) ; } return Util . translateString ( RESOURCE_BUNDLE , KEY_DELIMITER_KEY , KeyStroke . KEY_DELIMITER ) ; } protected String getKeyStrokeDelimiter ( ) { if ( Util . isWindows ( ) ) { return Util . translateString ( RESOURCE_BUNDLE , WIN32_KEY_STROKE_DELIMITER_KEY , KeySequence . KEY_STROKE_DELIMITER ) ; } return Util . translateString ( RESOURCE_BUNDLE ,", "gt": "KEY_STROKE_DELIMITER_KEY , KeySequence . KEY_STROKE_DELIMITER ) ;", "prediction": "KEY_DELIMITER_KEY , KeyStroke . KEY_DELIMITER ) ;\n", "label": 1}
{"id": 1155, "input": "<s> public class TestSummaryHeading extends JavadocTester { private static final String BUG_ID = \"4904036\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , SRC_DIR + FS + \"C.java\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"C.html\" , \"<h3>Method Summary</h3>\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; public", "gt": "static void main ( String [ ] args )", "prediction": "TestSummaryHeading ( )\n", "label": 0}
{"id": 15323, "input": "<s> package org . nlogo . extensions . sound ; public class Dump implements org . nlogo . api . Reporter { public String getAgentClassString ( ) { return \"OTP\" ; } public org . nlogo . api . Syntax getSyntax ( ) { return org . nlogo . api . Syntax . reporterSyntax ( org . nlogo . api . Syntax . StringType ( ) ) ; }", "gt": "public boolean getSwitchesBoolean ( )", "prediction": "}\n", "label": 1}
{"id": 2641, "input": "<s> package org . ofbiz . order . shoppinglist ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Date ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityTypeUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . shoppingcart . CartItemModifyException ; import org . ofbiz . order . shoppingcart . CheckOutHelper ; import org . ofbiz . order . shoppingcart . ItemNotFoundException ; import org . ofbiz . order . shoppingcart . ShoppingCart ; import org . ofbiz . product . config . ProductConfigWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . calendar . RecurrenceInfo ; import org . ofbiz . service . calendar . RecurrenceInfoException ; import com . ibm . icu . util . Calendar ; public class ShoppingListServices { public static final String module = ShoppingListServices . class . getName ( ) ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static Map < String , Object > setShoppingListRecurrence ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; Timestamp startDate = ( Timestamp ) context . get ( \"startDateTime\" ) ; Timestamp endDate = ( Timestamp ) context . get ( \"endDateTime\" ) ; Integer frequency = ( Integer ) context . get ( \"frequency\" ) ; Integer interval = ( Integer ) context . get ( \"intervalNumber\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( frequency == null || interval == null ) { Debug . logWarning ( UtilProperties . getMessage ( resource_error , \"OrderFrequencyOrIntervalWasNotSpecified\" , locale ) , module ) ; return ServiceUtil . returnSuccess ( ) ; } if ( startDate == null ) { switch ( frequency . intValue ( ) ) { case 5 : startDate = UtilDateTime . getWeekStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; case 6 : startDate = UtilDateTime . getMonthStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; case 7 : startDate = UtilDateTime . getYearStart ( UtilDateTime . nowTimestamp ( ) , 0 , interval . intValue ( ) ) ; break ; default : return ServiceUtil . returnError ( UtilProperties . getMessage ( resource_error , \"OrderInvalidFrequencyForShoppingListRecurrence\" , locale ) ) ; } } long startTime = startDate . getTime ( ) ; long endTime = 0 ; if ( endDate != null ) { endTime = endDate . getTime ( ) ; } RecurrenceInfo recInfo = null ; try { recInfo = RecurrenceInfo . makeInfo ( delegator , startTime , frequency . intValue ( ) , interval . intValue ( ) , - 1 , endTime ) ; } catch ( RecurrenceInfoException e ) { Debug . logError ( e , module ) ; return ServiceUtil . returnError ( UtilProperties . getMessage ( resource_error , \"OrderUnableToCreateShoppingListRecurrenceInformation\" , locale ) ) ; } Debug . logInfo ( \"Next Recurrence - \" + UtilDateTime . getTimestamp ( recInfo . next ( ) ) , module ) ; Map < String , Object > result = ServiceUtil . returnSuccess ( ) ; result . put ( \"recurrenceInfoId\" , recInfo . getID ( ) ) ; return result ; } public static Map < String , Object > createListReorders ( DispatchContext dctx , Map < String , ? extends Object > context ) { LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; GenericValue userLogin = ( GenericValue ) context . get ( \"userLogin\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; boolean beganTransaction = false ; try { beganTransaction = TransactionUtil . begin ( ) ; List < EntityExpr > exprs = UtilMisc . toList ( EntityCondition . makeCondition ( \"shoppingListTypeId\" , EntityOperator . EQUALS , \"SLT_AUTO_REODR\" ) , EntityCondition . makeCondition ( \"isActive\" , EntityOperator . EQUALS , \"Y\" ) ) ; EntityCondition cond = EntityCondition . makeCondition ( exprs , EntityOperator . AND ) ; List < String > order = UtilMisc . toList ( \"-lastOrderedDate\" ) ; EntityListIterator eli = null ; eli = delegator . find ( \"ShoppingList\" , cond , null , null , order , null ) ; if ( eli != null ) { GenericValue shoppingList ; while ( ( ( shoppingList = eli . next ( ) ) != null ) ) { Timestamp lastOrder = shoppingList . getTimestamp ( \"lastOrderedDate\" ) ; GenericValue recurrenceInfo = null ; recurrenceInfo = shoppingList . getRelatedOne ( \"RecurrenceInfo\" , false ) ; Timestamp startDateTime = recurrenceInfo . getTimestamp ( \"startDateTime\" ) ; RecurrenceInfo recurrence = null ; if", "gt": "( recurrenceInfo != null )", "prediction": "( startDateTime == null )\n", "label": 0}
{"id": 15324, "input": "<s> package org . eclipse . ui . internal . activities . ws ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . ui . activities . ITriggerPointAdvisor ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . internal . registry . RegistryReader ; public final class TriggerPointAdvisorDescriptor { private String id ; private IConfigurationElement element ; public TriggerPointAdvisorDescriptor ( IConfigurationElement element ) throws IllegalArgumentException { id = element . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ; if ( id == null || RegistryReader . getClassValue ( element , IWorkbenchRegistryConstants . ATT_CLASS ) == null ) { throw new IllegalArgumentException ( ) ; } this . element = element ; } public String getId ( ) { return id ; } public ITriggerPointAdvisor", "gt": "createAdvisor ( ) throws CoreException", "prediction": "Descriptor ( IConfigurationElement element )\n", "label": 1}
{"id": 1200, "input": "<s> package LizaCraft ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . PrintStream ; import org . bukkit . craftbukkit . Main ; public class LizaServerThread extends Thread { private PrintStream out ; private final String args [ ] = { \"-h\" , \"localhost\" , \"-p\" , \"25565\" } ; public LizaServerThread ( String name ) { super ( name ) ; try { out = new PrintStream ( new FileOutputStream ( new File ( \"liza-out.txt\" ) , false ) ) ; } catch ( FileNotFoundException e ) { } } public void run ( ) { System . setOut (", "gt": "this . out ) ;", "prediction": "out ) ;\n", "label": 0}
{"id": 15325, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . Segment3D ; import de . uos . igf . db3d . dbms . geom . Tetrahedron3D ; import de . uos . igf . db3d . dbms . geom . Triangle3D ; public interface Volume3D extends Spatial3D { public double getVolume ( ) ; public double getArea ( ) ; public int countVertices ( ) ; public int countEdges ( ) ; public", "gt": "int countFaces ( ) ;", "prediction": "Triangle3D triangle ;\n", "label": 1}
{"id": 4778, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; public enum HtmlTag { A ( BlockType . INLINE , EndTag . END ) , BLOCKQUOTE , BODY ( BlockType . OTHER , EndTag . END ) , BR ( BlockType . INLINE , EndTag . NOEND ) , CAPTION , CENTER , CODE ( BlockType . INLINE , EndTag . END ) , DD , DIV , DL , DT , EM ( BlockType . INLINE , EndTag . END ) , FONT ( BlockType . INLINE , EndTag . END ) , FRAME ( BlockType . OTHER , EndTag . NOEND ) , FRAMESET ( BlockType . OTHER , EndTag . END ) , H1 , H2 , H3 , H4 , H5 , H6 , HEAD ( BlockType . OTHER , EndTag . END ) , HR ( BlockType . BLOCK , EndTag . NOEND ) , HTML ( BlockType . OTHER , EndTag . END ) , I ( BlockType . INLINE , EndTag . END ) , IMG ( BlockType . INLINE , EndTag . NOEND ) , LI , LINK ( BlockType . OTHER , EndTag . NOEND ) , MENU , META ( BlockType . OTHER , EndTag . NOEND ) , NOFRAMES ( BlockType . OTHER , EndTag . END ) , NOSCRIPT ( BlockType . OTHER , EndTag . END ) , OL , P , PRE , SCRIPT ( BlockType . OTHER , EndTag . END ) , SMALL ( BlockType . INLINE , EndTag . END ) , SPAN ( BlockType . INLINE , EndTag . END ) , STRONG ( BlockType . INLINE , EndTag . END ) , TABLE , TBODY , TD , TH , TITLE ( BlockType . OTHER , EndTag . END ) , TR , TT ( BlockType . INLINE , EndTag . END ) , UL ; protected final BlockType blockType ; protected final EndTag endTag ; private final String value ; protected static enum BlockType { BLOCK , INLINE , OTHER ; } protected static enum EndTag { END , NOEND ; } HtmlTag ( ) { this ( BlockType . BLOCK , EndTag . END ) ; } HtmlTag ( BlockType blockType , EndTag endTag ) { this . blockType = blockType ; this . endTag = endTag ; this . value = name ( ) . toLowerCase ( ) ; } public boolean endTagRequired ( ) { return ( endTag", "gt": "== EndTag . END ) ;", "prediction": "!= null ) ;\n", "label": 0}
{"id": 15338, "input": "<s> package org . fuzzydb . server . internal . pager ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . Semaphore ; import org . fuzzydb . server . internal . server . WorkerThread ; public class ExclusiveWrite { private static final int MAX_PERMITS = Integer . MAX_VALUE ; private final Semaphore lock = new Semaphore ( MAX_PERMITS ) ; private final Set < Thread > readLocks = Collections . synchronizedSet ( new HashSet < Thread > ( ) ) ; private volatile Thread writeLock = null ; public ExclusiveWrite ( ) { } public void acquireRead ( ) { assert ( ! readLocks . contains ( Thread . currentThread ( ) ) ) ; if ( ! lock . tryAcquire ( ) ) { WorkerThread . beginIO ( ) ; lock . acquireUninterruptibly ( ) ; WorkerThread . endIO ( ) ; } readLocks . add ( Thread . currentThread ( ) ) ; } public synchronized void releaseRead ( ) { assert ( readLocks . contains ( Thread . currentThread ( ) ) ) ; lock . release ( ) ; readLocks . remove ( Thread . currentThread ( ) ) ; } public void acquireWrite ( ) { assert ( ! readLocks . contains ( Thread . currentThread ( ) ) ) ; if ( ! lock . tryAcquire ( MAX_PERMITS ) ) { WorkerThread . beginIO ( ) ; lock . acquireUninterruptibly ( MAX_PERMITS ) ; WorkerThread . endIO ( ) ; } synchronized ( this ) { assert ( writeLock == null ) ; writeLock = Thread . currentThread ( ) ; } } public boolean tryAcquireWrite ( ) { if ( ! readLocks . isEmpty ( ) ) { return false ; } if ( writeLock != null ) { return false ; } if ( ! lock . tryAcquire ( MAX_PERMITS ) ) { return false ; } synchronized ( this ) { assert ( writeLock == null ) ; writeLock =", "gt": "Thread . currentThread ( ) ;", "prediction": "Thread . currentThread ( ) ;\n", "label": 1}
{"id": 3628, "input": "<s> package org . ofbiz . widget ; public interface WidgetLoader {", "gt": "void loadWidgets ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15361, "input": "<s> package org . spliffy . server . web . calc ; import java . math . BigDecimal ; import org . spliffy . server . web . SpliffyResource ; import org . spliffy . server . web . templating . Formatter ; class Sumor implements Accumulator { private final int decimals ; private final Formatter formatter ; public Sumor ( int decimals , Formatter formatter ) { super ( ) ; this . decimals = decimals ; this . formatter = formatter ; }", "gt": "BigDecimal value = new BigDecimal ( 0 ) ;", "prediction": "public Formatter getFormatter ( )\n", "label": 1}
{"id": 2291, "input": "<s> package org . dawb . workbench . ui . editors . util ; import org . eclipse . draw2d . Button ; import org . eclipse . draw2d . ButtonBorder ; import org . eclipse . draw2d . ButtonBorder . ButtonScheme ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . ToggleButton ; public class FigureUtils { public static void setButtonBorder ( final IFigure toolbar , ButtonScheme scheme ) { for ( Object child : toolbar . getChildren ( ) ) { if ( child instanceof Button ) { final Button button = ( Button ) child ; button . setBorder ( new ButtonBorder ( scheme ) ) ; } else if ( child instanceof ToggleButton ) { final ToggleButton button = ( ToggleButton ) child ; button . setBorder ( new ButtonBorder", "gt": "( scheme ) ) ;", "prediction": "( scheme ) ) ;\n", "label": 0}
{"id": 15364, "input": "<s> package com . datastruct ; import com . math . CompPoint ; import java . util . Random ; import java . util . Vector ; import processing . core . PApplet ; import com . math . Geom ; public class DoublyConnectedEdgeList { public Vector < DCFace > faces = new Vector < DCFace > ( ) ; public Vector < DCHalfEdge > edges = new Vector < DCHalfEdge > ( ) ; public Vector < CompPoint > verticies = new Vector < CompPoint > ( ) ; public CompPoint centroid ; public DoublyConnectedEdgeList ( ) { } public void addVertex ( CompPoint p ) { verticies . addElement ( p ) ; } public DCHalfEdge addHalfEdge ( DCHalfEdge newEdge ) { edges . addElement ( newEdge ) ; return newEdge ; } public DCHalfEdge addEdgeWithPartner ( DCHalfEdge newEdge ) { if ( edges . size ( ) > 0 ) { setPartners ( newEdge , edges . get ( edges . size ( ) - 1 ) ) ; } edges . addElement ( newEdge ) ; return newEdge ; } public void addEdgeAt ( DCHalfEdge newEdge , int addPosition ) { edges . add ( addPosition , newEdge ) ; } public void addFace ( DCFace face ) { faces . add ( face ) ; } public DCFace getFaceByFocus ( CompPoint focus ) { for ( int i = 0 ; i < faces . size ( ) ; i ++ ) { DCFace checkFace = faces . get ( i ) ; if ( checkFace . getFocus ( ) . compareTo ( focus ) == 0 ) { return checkFace ; } } return null ; } public void drawFaces ( PApplet parent ) { for ( int i = 0 ; i < faces . size ( ) ; i ++ ) { DCFace checkFace = faces . get ( i ) ; checkFace . draw ( parent ) ; } } public boolean deleteEdge ( DCHalfEdge edge ) { return edges . removeElement ( edge ) ; } public double [ ] getBorderPoints ( CompPoint start ) { double [ ] thetas = new double [ edges . size ( ) ] ; for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { CompPoint point = edges . get ( i ) . start ; double theta = start . angle ( point ) ; thetas [ i ] = theta ; } return thetas ; } public void translate ( double x , double y , CompPoint focus ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { DCHalfEdge currentEdge = edges . get ( i ) ; currentEdge . translate ( x , y , focus ) ; } } public void rotate ( double theta , CompPoint _focus ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { DCHalfEdge currentEdge = edges . get ( i ) ; currentEdge . rotate ( theta , _focus ) ; } } private void setPartners ( DCHalfEdge currentEdge , DCHalfEdge prevEdge ) { int color = new Random", "gt": "( ) . nextInt ( ) * 0xFFFFFF ;", "prediction": "( ) ;\n", "label": 1}
{"id": 5749, "input": "<s> package org . ofbiz . content . content ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . content . content . ContentSearch . ResultSortOrder ; import org . ofbiz . content . content . ContentSearch . SortKeywordRelevancy ; import org . ofbiz . content . content . ContentSearch . ContentSearchConstraint ; public class ContentSearchSession { public static final String module = ContentSearchSession . class . getName ( ) ; @ SuppressWarnings ( \"serial\" ) public static class ContentSearchOptions implements java . io . Serializable { protected List < ContentSearchConstraint > constraintList = null ; protected ResultSortOrder resultSortOrder = null ; protected Integer viewIndex = null ; protected Integer viewSize = null ; protected boolean changed = false ; public ContentSearchOptions ( ) { } public ContentSearchOptions ( ContentSearchOptions contentSearchOptions ) { this . constraintList = UtilMisc . makeListWritable ( contentSearchOptions . constraintList ) ; this . resultSortOrder = contentSearchOptions . resultSortOrder ; this . viewIndex = contentSearchOptions . viewIndex ; this . viewSize = contentSearchOptions . viewSize ; this . changed = contentSearchOptions . changed ; } public List < ContentSearchConstraint > getConstraintList ( ) { return this . constraintList ; } public static List < ContentSearchConstraint > getConstraintList ( HttpSession session ) { return getContentSearchOptions ( session ) . constraintList ; } public static void addConstraint ( ContentSearchConstraint contentSearchConstraint , HttpSession session ) { ContentSearchOptions contentSearchOptions = getContentSearchOptions ( session ) ; if ( contentSearchOptions . constraintList == null ) { contentSearchOptions . constraintList = FastList . newInstance ( ) ; } if ( ! contentSearchOptions . constraintList . contains ( contentSearchConstraint ) ) { contentSearchOptions . constraintList . add ( contentSearchConstraint ) ; contentSearchOptions . changed = true ; } } public ResultSortOrder getResultSortOrder ( ) { if ( this . resultSortOrder == null ) { this . resultSortOrder = new SortKeywordRelevancy ( ) ; this . changed = true ; } return this . resultSortOrder ; } public static ResultSortOrder getResultSortOrder ( HttpServletRequest request ) { ContentSearchOptions contentSearchOptions = getContentSearchOptions ( request . getSession ( ) ) ; return contentSearchOptions . getResultSortOrder ( ) ; } public static void setResultSortOrder ( ResultSortOrder resultSortOrder , HttpSession session ) { ContentSearchOptions contentSearchOptions = getContentSearchOptions ( session ) ; contentSearchOptions . resultSortOrder = resultSortOrder ; contentSearchOptions . changed = true ; } public static void clearSearchOptions ( HttpSession session ) { ContentSearchOptions contentSearchOptions = getContentSearchOptions ( session ) ; contentSearchOptions . constraintList = null ; contentSearchOptions . resultSortOrder = null ; } public void clearViewInfo ( ) { this . viewIndex = null ; this . viewSize = null ; } public Integer getViewIndex ( ) { return viewIndex ; } public void setViewIndex ( Integer viewIndex ) { this . viewIndex = viewIndex ; } public Integer getViewSize ( ) { return viewSize ; } public void setViewSize ( Integer viewSize ) { this . viewSize = viewSize ; } public List < String > searchGetConstraintStrings ( boolean detailed , Delegator delegator , Locale locale ) { List < ContentSearchConstraint > contentSearchConstraintList = this . getConstraintList ( ) ; List < String > constraintStrings = FastList . newInstance ( ) ; if ( contentSearchConstraintList == null ) { return constraintStrings ; } for ( ContentSearchConstraint contentSearchConstraint : contentSearchConstraintList ) { if ( contentSearchConstraint == null ) continue ; String constraintString = contentSearchConstraint . prettyPrintConstraint ( delegator , detailed , locale ) ; if ( UtilValidate . isNotEmpty ( constraintString ) ) { constraintStrings . add ( constraintString ) ; } else { constraintStrings . add ( \"Description not available\" ) ; } } return constraintStrings ; } } public static ContentSearchOptions getContentSearchOptions ( HttpSession session ) { ContentSearchOptions contentSearchOptions = ( ContentSearchOptions ) session . getAttribute ( \"_CONTENT_SEARCH_OPTIONS_CURRENT_\" ) ; if ( contentSearchOptions == null ) { contentSearchOptions = new ContentSearchOptions ( ) ; session . setAttribute ( \"_CONTENT_SEARCH_OPTIONS_CURRENT_\" , contentSearchOptions ) ; } return contentSearchOptions ; } public static void processSearchParameters ( Map < String , Object > parameters , HttpServletRequest request ) { Boolean alreadyRun = ( Boolean ) request . getAttribute ( \"processSearchParametersAlreadyRun\" ) ; if ( Boolean . TRUE . equals ( alreadyRun ) ) { return ; } else { request . setAttribute ( \"processSearchParametersAlreadyRun\" , Boolean . TRUE ) ; } HttpSession session = request . getSession ( ) ; boolean constraintsChanged = false ; String clearSearchString = ( String ) parameters . get ( \"clearSearch\" ) ; if ( ! \"N\" . equals ( clearSearchString ) ) { searchClear ( session ) ; constraintsChanged = true ; } else { String removeConstraint = ( String ) parameters . get ( \"removeConstraint\" ) ; if ( UtilValidate . isNotEmpty ( removeConstraint ) ) { try { searchRemoveConstraint ( Integer . parseInt ( removeConstraint ) , session ) ; constraintsChanged = true ; } catch ( Exception e ) { Debug . logError ( e , \"Error removing constraint [\" + removeConstraint + \"]\" , module ) ; } } } if ( UtilValidate . isNotEmpty ( parameters . get ( \"SEARCH_CONTENT_ID\" ) ) ) { String contentId = ( String ) parameters . get ( \"SEARCH_CONTENT_ID\" ) ; String contentAssocTypeId = ( String ) parameters .", "gt": "get ( \"contentAssocTypeId\" ) ;", "prediction": "get ( \"SEARCH_CONTENT_ID\" ) ;\n", "label": 0}
{"id": 15376, "input": "<s> package org . restlet . engine ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . Connector ; import org . restlet . Context ; import org . restlet . data . Protocol ; public abstract class ConnectorHelper < T extends Connector > extends RestletHelper < T > { public static org . restlet . service . ConnectorService getConnectorService ( ) { org . restlet . service . ConnectorService result = null ; org . restlet . Application application = org . restlet . Application . getCurrent ( ) ; if ( application != null ) { result = application . getConnectorService ( ) ; } else { result = new org . restlet . service . ConnectorService ( ) ; } return result ; } private final List < Protocol > protocols ; public ConnectorHelper ( T connector ) { super ( connector ) ; this . protocols = new CopyOnWriteArrayList < Protocol > ( ) ; } @ Override public Context getContext ( ) { if ( Edition . CURRENT == Edition . GWT ) { return null ; } return super . getContext ( ) ; } public List < Protocol > getProtocols ( ) { return this . protocols ; } @ Override public void start ( ) throws Exception { } @ Override public", "gt": "void stop ( ) throws Exception", "prediction": "void stop ( ) throws Exception\n", "label": 1}
{"id": 378, "input": "<s> class T6557954 < T > { class Foo < U extends T > { } T6557954", "gt": "< Number > . Foo < Integer > f ;", "prediction": ";\n", "label": 0}
{"id": 15377, "input": "<s> package knowevo . myvizster . controls ; import java . awt . event . MouseEvent ; import java . util . TimerTask ; import knowevo . myvizster . VizsterLib ; import edu . berkeley . guir . prefuse . FocusManager ; import edu . berkeley . guir . prefuse . ItemRegistry ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . activity . Activity ; import edu . berkeley . guir . prefuse . event . ControlAdapter ; import edu . berkeley . guir . prefuse . focus . FocusSet ; public class HighlightControl extends ControlAdapter { private Object focusKey ; private Activity activity ; private TimerTask task ; private long delay = 500 ; public HighlightControl ( Activity act , Object key ) { this . activity = act ; this . focusKey = key ; } public void itemEntered ( VisualItem vi , MouseEvent e ) { if ( ! shouldProcess ( vi ) ) return ; if ( task != null ) task . cancel ( ) ; ItemRegistry registry = vi . getItemRegistry ( ) ; synchronized ( registry ) { FocusManager fman = registry . getFocusManager ( ) ; FocusSet fset = fman . getFocusSet ( focusKey ) ; fset . set ( vi . getEntity ( ) ) ; registry . touch ( vi . getItemClass ( ) ) ; } runActivity ( ) ; } public void itemExited ( VisualItem vi , MouseEvent e ) { if ( ! shouldProcess ( vi ) ) return ; ItemRegistry registry = vi . getItemRegistry ( ) ;", "gt": "if ( registry != null )", "prediction": "synchronized ( registry )\n", "label": 1}
{"id": 7379, "input": "<s> package org . gk . engine . client . event . attrib ; import java . util . Map ; import org . gk . engine . client . Engine ; import org . gk . ui . client . com . grid . gkGridIC ; import org . gk . ui . client . com . tree . dir . gkTreeDirPanelIC ; import org . gk . ui . client . com . tree . xml . gkXMLTreePanelIC ; import com . extjs . gxt . ui . client . data . ModelData ; import com . extjs . gxt . ui . client . store . TreeStore ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . TabPanel ; import com . extjs . gxt . ui . client . widget . form . ComboBox ; import com . google . gwt . xml . client . Node ; public class DelAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { if ( com instanceof gkGridIC ) { ( ( gkGridIC ) com ) . removeRow ( ) ; } else if ( com instanceof gkTreeDirPanelIC ) { gkTreeDirPanelIC tree = ( gkTreeDirPanelIC ) com ; ModelData md = null ; if ( value instanceof Map ) { Map info = ( Map ) value ; assert info . containsKey ( gkTreeDirPanelIC . ID ) : \"nodeId not Found \" + info ; md = tree . getStore ( ) . findModel ( ( String ) info . get ( gkTreeDirPanelIC . ID ) ) ; } assert md != null : \"can't found TreeNode \" + md ; tree . getStore ( ) . remove ( md ) ; } else if ( com instanceof gkXMLTreePanelIC ) { gkXMLTreePanelIC tree = ( gkXMLTreePanelIC ) com ; TreeStore store = tree . getTree ( ) . getStore ( ) ; ModelData md = null ; if ( value instanceof Map ) { Map info = ( Map ) value ; assert info . containsKey ( gkXMLTreePanelIC . ID ) : \"nodeId not Found \" + info ; md = store . findModel ( ( String ) info . get ( gkXMLTreePanelIC . ID ) ) ; } else { md = tree . getTree ( ) . getSelectionModel ( ) . getSelectedItem ( ) ; } assert md != null : \"can't found TreeNode \" + md ; Node node = ( Node ) md . get ( gkXMLTreePanelIC . NODE ) ; node . getParentNode ( ) . removeChild ( node ) ; store . remove ( md ) ; } else if ( com instanceof TabPanel ) { if ( value instanceof String ) { TabPanel tabPanel = ( TabPanel ) com ; tabPanel . remove ( tabPanel . findItem ( ( String ) value , false ) ) ; Engine . get ( ) . removeComponent ( ( String ) value ) ; } } else if ( com instanceof ComboBox ) { ComboBox combo = ( ComboBox ) com ; if ( value instanceof String ) { ModelData md = combo . getPropertyEditor ( ) . convertStringValue ( ( String ) value ) ; combo", "gt": ". getStore ( ) . remove ( md ) ;", "prediction": ". setValue ( md ) ;\n", "label": 0}
{"id": 15379, "input": "<s> package com . inepex . classtemplater . plugin . logic ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . jdt . core . ICompilationUnit ; import org . eclipse . jdt . core . IField ; import org . eclipse . jdt . core . IMethod ; import org . eclipse . jdt . core . IType ; public class Class { static final Pattern getterPattern = Pattern . compile ( \"(get|is)([A-Z])(.*)\" ) ; static final Pattern setterSetter = Pattern . compile ( \"(set)([A-Z])(.*)\" ) ; String name ; String packageName ; List < Attribute > attributes = new ArrayList < Attribute > ( ) ; List < Method > methods = new ArrayList < Method > ( ) ; List < Property > properthies ; Map < String , Annotation > annotations = new HashMap < String , Annotation > ( ) ; String workspaceRelativePath ; public Class ( String name , String packageName ) { super ( ) ; this . name = name ; this . packageName = packageName ; } public Class ( List < IField > jdtFields ) throws Exception { this . name = jdtFields . get ( 0 ) . getDeclaringType ( ) . getTypeQualifiedName ( ) ; this . packageName = ( ( ICompilationUnit ) jdtFields . get ( 0 ) . getParent ( ) . getParent ( ) ) . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; for ( IField field : jdtFields ) { this . attributes . add ( new Attribute ( field ) ) ; } this . annotations = Annotation . getAnnotationsOf ( jdtFields . get ( 0 ) . getDeclaringType ( ) , jdtFields . get ( 0 ) . getCompilationUnit ( ) ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( ( ICompilationUnit ) jdtFields . get ( 0 ) . getParent ( ) . getParent ( ) ) ; } public Class ( List < IMethod > jdtMethods , boolean isMethods ) throws Exception { this . name = jdtMethods . get ( 0 ) . getDeclaringType ( ) . getTypeQualifiedName ( ) ; this . packageName = ( ( ICompilationUnit ) jdtMethods . get ( 0 ) . getParent ( ) . getParent ( ) ) . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; for ( IMethod method : jdtMethods ) { this . methods . add ( new Method ( method ) ) ; } this . annotations = Annotation . getAnnotationsOf ( jdtMethods . get ( 0 ) . getDeclaringType ( ) , jdtMethods . get ( 0 ) . getCompilationUnit ( ) ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( ( ICompilationUnit ) jdtMethods . get ( 0 ) . getParent ( ) . getParent ( ) ) ; } public Class ( ICompilationUnit compunit ) throws Exception { this . name = compunit . findPrimaryType ( ) . getTypeQualifiedName ( ) ; this . packageName = compunit . getPackageDeclarations ( ) [ 0 ] . getElementName ( ) ; this . attributes = getAttrs ( compunit ) ; this . methods = getMethods ( compunit ) ; this . annotations = Annotation . getAnnotationsOf ( compunit . getAllTypes ( ) [ 0 ] , compunit ) ; this . workspaceRelativePath = ResourceUtil . getWorkspaceRelativePath ( compunit ) ; } private void buildProperthies ( ) { Map < String , Property > props = new HashMap < String , Property > ( ) ; for ( Method method : this . methods ) { Matcher matcher = getterPattern . matcher ( method . name ) ; if ( matcher . matches ( ) ) { if ( ! method . getReturnType ( ) . equals ( \"void\" ) ) { Property prop = getOrCreateProperty ( matcher , props ) ; prop . setGetter ( method ) ; } } else { matcher = setterSetter . matcher ( method . name ) ; if ( matcher . matches ( ) && method . getParameters ( ) . size ( ) == 1 ) { Property prop = getOrCreateProperty ( matcher , props ) ; prop . setSetter ( method ) ; } } } this . properthies = new ArrayList < Property > ( props . values ( ) ) ; } private Property getOrCreateProperty ( Matcher matcher , Map < String , Property > props ) { String propertyName = matcher . group ( 2 ) . toLowerCase ( ) . concat ( matcher . group ( 3 ) ) ; Property prop = props . get ( propertyName ) ; if ( prop == null ) { props . put ( propertyName , prop = new Property ( propertyName ) ) ; } return prop ; } private ArrayList < Attribute > getAttrs ( ICompilationUnit unit ) throws Exception { ArrayList < Attribute > attrs = new ArrayList < Attribute > ( ) ; IType [ ] allTypes = unit . getAllTypes ( ) ; for ( IType type : allTypes ) { for ( IField field", "gt": ": type . getFields ( ) )", "prediction": ": allTypes )\n", "label": 1}
{"id": 4279, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface LogicalDateLiteral extends LogicalExpression { String getValue ( ) ; void setValue", "gt": "( String value ) ;", "prediction": "( String value ) ;\n", "label": 0}
{"id": 15380, "input": "<s> package org . apache . lucene . queryParser . core ; import org . apache . lucene . messages . Message ; import org . apache . lucene . messages . NLSException ; public class QueryNodeError extends Error implements NLSException { private static final long serialVersionUID = 1804855832182710327L ; private Message message ; public QueryNodeError ( Message message ) { super ( message . getKey ( ) ) ; this . message = message ; } public QueryNodeError ( Throwable throwable ) { super ( throwable ) ; } public QueryNodeError ( Message message , Throwable throwable ) { super ( message . getKey (", "gt": ") , throwable ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 1559, "input": "<s> package com . sun . tools . doclets . internal . toolkit ; import com . sun . tools . doclets . internal . toolkit . builders . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public abstract class AbstractDoclet { public Configuration configuration ; private static final String TOOLKIT_DOCLET_NAME = new com . sun . tools . doclets . formats . html . HtmlDoclet ( ) . getClass ( ) . getName ( ) ; private boolean isValidDoclet ( AbstractDoclet doclet ) { if ( ! doclet . getClass ( ) . getName ( ) . equals ( TOOLKIT_DOCLET_NAME ) ) { configuration . message . error ( \"doclet.Toolkit_Usage_Violation\" , TOOLKIT_DOCLET_NAME ) ; return false ; } return true ; } public boolean start ( AbstractDoclet doclet , RootDoc root ) { configuration = configuration ( ) ; configuration . root = root ; if ( ! isValidDoclet ( doclet ) ) { return false ; } try { doclet . startGeneration ( root ) ; } catch ( Exception exc ) { exc . printStackTrace ( ) ; return false ; } return true ; } public static LanguageVersion languageVersion ( ) { return LanguageVersion . JAVA_1_5 ; } public abstract Configuration configuration ( ) ; private void startGeneration ( RootDoc root ) throws Exception { if ( root . classes ( ) . length == 0 ) { configuration . message . error ( \"doclet.No_Public_Classes_To_Document\" ) ; return ; } configuration . setOptions ( ) ; configuration . getDocletSpecificMsg ( ) . notice ( \"doclet.build_version\" , configuration . getDocletSpecificBuildDate ( ) ) ; ClassTree classtree = new ClassTree ( configuration , configuration . nodeprecated ) ; generateClassFiles ( root , classtree ) ; if ( configuration . sourcepath != null && configuration . sourcepath . length ( ) > 0 ) { StringTokenizer pathTokens = new StringTokenizer ( configuration . sourcepath , String . valueOf ( File . pathSeparatorChar ) ) ; boolean first = true ; while ( pathTokens", "gt": ". hasMoreTokens ( ) )", "prediction": ". length ( ) > 0 )\n", "label": 0}
{"id": 15383, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . settings ; import com . digitalsanctum . idea . plugins . buildr . Buildr ; import com . digitalsanctum . idea . plugins . buildr . BuildrBundle ; import com . digitalsanctum . idea . plugins . buildr . BuildrComponents ; import com . intellij . openapi . components . ApplicationComponent ; import com . intellij . openapi . options . Configurable ; import com . intellij . openapi . options . ConfigurationException ; import org . jetbrains . annotations . Nls ; import org . jetbrains . annotations . NotNull ; import javax . swing . * ; public class BuildrSettings implements ApplicationComponent , Configurable { private BuildrSettingsPane form ; @ NotNull public String getComponentName ( ) { return BuildrComponents . BUILDR_SETTINGS ; } public void initComponent ( ) { loadRegisteredData ( ) ; } public void disposeComponent ( ) { } @ Nls public String getDisplayName ( ) { return BuildrBundle . message ( \"settings.title\" ) ; } public Icon getIcon ( ) { return Buildr . BUILDR_32 ; } public String getHelpTopic ( ) { return null ; } public JComponent createComponent ( ) { if ( form == null ) { form = new BuildrSettingsPane ( ) ; } return form", "gt": ". getPanel ( ) ;", "prediction": ";\n", "label": 1}
{"id": 6288, "input": "<s> package fr . telecom . scrapbook . filters ; public class LUTFilter implements IImageFilter { protected int [ ] m_LUT = new int [ 256 ] ; protected int InitLUTtable ( int nLUTIndex ) { return nLUTIndex ; } public Image process ( Image imageIn ) { for ( int i = 0 ; i <= 0xFF ; i ++ ) m_LUT [ i ] = InitLUTtable ( i ) ; int r , g , b ; for ( int x = 0 ; x < ( imageIn . getWidth ( ) - 1 ) ; x ++ ) { for ( int y = 0 ; y < ( imageIn . getHeight (", "gt": ") - 1 ) ;", "prediction": ") - 1 ) ;\n", "label": 0}
{"id": 15389, "input": "<s> package org . apache . lucene . index ; import java . util . List ; import java . io . IOException ; public interface IndexDeletionPolicy { public void onInit (", "gt": "List commits ) throws IOException ;", "prediction": ") ;\n", "label": 1}
{"id": 5342, "input": "<s> package org . ofbiz . base . lang ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Documented @ Retention ( RetentionPolicy . SOURCE ) @ Target ( { ElementType .", "gt": "FIELD , ElementType . LOCAL_VARIABLE }", "prediction": "TYPE }\n", "label": 0}
{"id": 15394, "input": "<s> package org . eclipse . ui . forms . widgets ; import org . eclipse . swt . widgets . Composite ; public interface ILayoutExtension { public int computeMinimumWidth", "gt": "( Composite parent , boolean changed ) ;", "prediction": "( Composite parent ) ;\n", "label": 1}
{"id": 5303, "input": "<s> import java . io . IOException ; import java . util . * ; class Main { static Object mut = new Object ( ) ; static int pecaCount ; static Vector set = new Vector ( ) ; static Peca ignoravel ; static int maiorSoma ; static boolean encontrado ; static int somaAbsoluta ; static int somaAbsolutaCorrente ; static Peca menorPecaIgnoravel ; static int maximos [ ] = new int [ 1001 ] ; static Hashtable mapas [ ] = new Hashtable [ 1000 ] ; public static void main ( String args [ ] ) throws NumberFormatException , IOException { int temp ; while ( true ) { pecaCount = Integer . parseInt ( readLine ( 10 ) . trim ( ) ) ; if ( pecaCount == 0 ) { break ; } set . removeAllElements ( ) ; menorPecaIgnoravel = null ; maiorSoma = - 1 ; ignoravel = null ; for ( int i = 0 ; i != pecaCount ; i ++ ) { String [ ] linha = split ( readLine ( 30 ) ) ; Peca p = new Peca ( ) ; p . cima = Integer . parseInt ( linha [ 0 ] ) ; p . baixo = Integer . parseInt ( linha [ 1 ] ) ; if ( p . cima < p . baixo ) { temp = p . cima ; p . cima = p . baixo ; p . baixo = temp ; } p . abs = Math . abs ( p . cima - p . baixo ) ; set . addElement ( p ) ; } int somaMaxima = 0 ; somaAbsoluta = 0 ; for ( int i = pecaCount - 1 ; i != - 1 ; i -- ) { somaAbsoluta += getPeca ( i ) . cima + getPeca ( i ) . baixo ; somaMaxima += getPeca ( i ) . abs ; maximos [ i ] = somaMaxima ; getPeca ( i ) . level = i ; if ( mapas [ i ] == null ) { mapas [ i ] = new Hashtable ( ) ; } else { mapas [ i ] . clear ( ) ; } } encontrado = false ; if ( pecaCount == 1 ) { if ( getPeca ( 0 ) . abs != 0 ) { System . out . println ( \"impossible\" ) ; continue ; } else { System . out . println ( getPeca ( 0 ) . cima + \" discard none\" ) ; continue ; } } if ( pecaCount == 2 ) { if ( getPeca ( 0 ) . abs == 0 ) { printDiscard ( getPeca ( 0 ) . cima , getPeca ( 1 ) ) ; continue ; } if ( getPeca ( 1 ) . abs == 0 ) { printDiscard ( getPeca ( 1 ) . cima , getPeca ( 0 ) ) ; continue ; } System . out . println ( \"impossible\" ) ; continue ; } if ( somaAbsoluta % 2 == 0 ) { somaAbsolutaCorrente = somaAbsoluta / 2 ; tenta ( 0 , 0 , 0 ) ; if ( encontrado ) { continue ; } } menorPecaIgnoravel = null ; maiorSoma = - 1 ; for ( int i = 0 ; i != pecaCount ; i ++ ) { if ( getPeca ( i ) . abs == 0 ) { continue ; } for ( int i2 = 0 ; i2 != pecaCount ; i2 ++ ) { mapas [ i2 ] . clear ( ) ; } ignoravel = getPeca ( i ) ; if ( ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) % 2 == 0 ) { if ( encontrado ) { if ( menorPecaIgnoravel . cima + menorPecaIgnoravel . baixo < ignoravel . cima + ignoravel . baixo ) { continue ; } } somaAbsolutaCorrente = ( somaAbsoluta - ignoravel . cima - ignoravel . baixo ) / 2 ; tenta ( 0", "gt": ", 0 , 0 ) ;", "prediction": ", 0 , 0 ) ;\n", "label": 0}
{"id": 15400, "input": "<s> package org . eclipse . ui . statushandlers ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . application . WorkbenchAdvisor ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . statushandlers . IStatusDialogConstants ; import org . eclipse . ui . statushandlers . StatusManager . INotificationTypes ; public class WorkbenchErrorHandler extends AbstractStatusHandler { public boolean supportsNotification ( int type ) { if ( type == INotificationTypes . HANDLED ) { return true ; } return super . supportsNotification ( type ) ; } private WorkbenchStatusDialogManager statusDialogManager ; public void handle ( final StatusAdapter statusAdapter , int style ) { statusAdapter . setProperty ( WorkbenchStatusDialogManager . HINT , new Integer ( style ) ) ; if ( ( ( style & StatusManager . SHOW ) == StatusManager . SHOW ) || ( ( style & StatusManager . BLOCK ) == StatusManager . BLOCK ) ) { final boolean block = ( ( style & StatusManager . BLOCK ) == StatusManager . BLOCK ) ; if ( Display . getCurrent ( ) != null ) { showStatusAdapter ( statusAdapter , block ) ; } else { if ( block ) { Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { showStatusAdapter ( statusAdapter , true ) ; } } ) ; } else { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { showStatusAdapter ( statusAdapter , false ) ; } } ) ; } } } if ( ( style & StatusManager . LOG ) == StatusManager . LOG ) { StatusManager . getManager ( ) . addLoggedStatus ( statusAdapter . getStatus ( ) ) ; WorkbenchPlugin . getDefault ( ) . getLog ( ) . log ( statusAdapter . getStatus ( ) ) ; } } private void showStatusAdapter ( StatusAdapter statusAdapter , boolean block ) { if ( ! PlatformUI . isWorkbenchRunning ( ) ) { WorkbenchPlugin . log ( statusAdapter . getStatus ( ) ) ; return ; } getStatusDialogManager ( ) . addStatusAdapter ( statusAdapter , block ) ; if ( block ) { Shell shell ; while ( ( shell = getStatusDialogShell ( ) ) != null && ! shell . isDisposed ( ) ) { if ( ! shell . getDisplay ( ) . readAndDispatch ( ) ) { Display . getDefault ( ) . sleep ( ) ; } } } } private Shell getStatusDialogShell ( ) { return ( Shell ) getStatusDialogManager (", "gt": ") . getProperty ( IStatusDialogConstants . SHELL ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3545, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . util . Set ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; import org . apache . maven . project . MavenProject ; import org . apache . maven . project . MavenProjectHelper ; public class XCodeIpaPackageMojo extends AbstractXCodeMojo { private MavenProjectHelper projectHelper ; private String productName ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { final Set < String > sdks = getSDKs ( ) ; final Set < String > configurations = getConfigurations ( ) ; getLog ( ) . info ( \"Configurations are:\" + configurations ) ; getLog ( ) . info ( \"SDKs are: \" + sdks ) ; if ( configurations == null || configurations . size ( ) == 0 ) throw new MojoExecutionException ( \"Invalid configuration: \\\"\" + configurations + \"\\\".\" ) ; if ( sdks == null || sdks . size ( ) == 0 ) throw new MojoExecutionException ( \"Invalid sdks: \\\"\" + sdks + \"\\\".\" ) ; for ( final String configuration : configurations ) { for ( final String sdk : sdks ) { if ( configuration == null || configuration . isEmpty ( ) ) throw new IllegalStateException ( \"Invalid configuration: '\" + configuration + \"'.\" ) ; final String productName ; if ( this . productName != null ) { productName = this . productName ; getLog ( ) . info ( \"Production name obtained from pom file\" ) ; } else { productName = EffectiveBuildSettings . getProductName ( this . project , configuration , sdk ) ; getLog ( ) . info ( \"Product name obtained from effective build settings file\" ) ; } final String fixedProductName = getFixedProductName ( productName ) ; getLog ( ) . info ( \"Using product name '\" + productName + \" (fixed product name '\" + fixedProductName + \"')\" + \"' for configuration '\" + configuration + \"' and sdk '\" + sdk + \"'.\" ) ; File rootDir = XCodeBuildLayout . getAppFolder ( getXCodeCompileDirectory ( ) , configuration , sdk ) ; final File ipaFile = zipSubfolder ( rootDir , productName + \".app\" , fixedProductName + \".ipa\" , \"Payload/\" ) ; prepareIpaFileForDeployment ( project , configuration", "gt": ", sdk , ipaFile ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15402, "input": "<s> package org . eclipse . ui . dynamic . handlers ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; public final class DynamicHandler extends AbstractHandler {", "gt": "public final Object execute ( final ExecutionEvent event )", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 6910, "input": "<s> package Liza ; import org . bukkit . entity . Squid ;", "gt": "public interface LizaSquid extends Squid", "prediction": "import org . bukkit . entity . Splitter ;\n", "label": 0}
{"id": 15404, "input": "<s> package org . eclipse . ui . tests . harness . tests ; import java . lang . reflect . UndeclaredThrowableException ; import junit . framework . TestCase ; import org . eclipse . ui . tests . harness . util . Mocks ; public class MocksTest extends TestCase { private IPrimitive primitiveMock ; private static boolean uninitializedBoolean ; private static byte unitializedByte ; private static char unitializedChar ; private static short unitializedShort ; private static int unitializedInt ; private static long unitializedLong ; private static float unitializedFloat ; private static double unitializedDouble ; protected void setUp ( ) throws Exception { primitiveMock = ( IPrimitive ) Mocks . createRelaxedMock ( IPrimitive . class ) ; } public void testPrimitiveBooleanReturnType ( ) throws Exception { try { boolean value = primitiveMock . getBoolean ( ) ; assertEquals ( uninitializedBoolean , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveBooleanSetLastReturnValue ( ) throws Exception { Boolean value = Boolean . TRUE ; primitiveMock . getBoolean ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . booleanValue ( ) , primitiveMock . getBoolean ( ) ) ; } public void testPrimitiveByteReturnType ( ) throws Exception { try { byte value = primitiveMock . getByte ( ) ; assertEquals ( unitializedByte , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveByteSetLastReturnValue ( ) throws Exception { Byte value = new Byte ( ( byte ) 1 ) ; primitiveMock . getByte ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . byteValue ( ) , primitiveMock . getByte ( ) ) ; } public void testPrimitiveCharReturnType ( ) throws Exception { try { char value = primitiveMock . getChar ( ) ; assertEquals ( unitializedChar , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveCharSetLastReturnValue ( ) throws Exception { Character value = new Character ( 'a' ) ; primitiveMock . getChar ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . charValue ( ) , primitiveMock . getChar ( ) ) ; } public void testPrimitiveShortReturnType ( ) throws Exception { try { short value = primitiveMock . getShort ( ) ; assertEquals ( unitializedShort , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveShortSetLastReturnValue ( ) throws Exception { Short value = new Short ( ( short ) 1 ) ; primitiveMock . getShort ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . shortValue ( ) , primitiveMock . getShort ( ) ) ; } public void testPrimitiveIntReturnType ( ) throws Exception { try { int value = primitiveMock . getInt ( ) ; assertEquals ( unitializedInt , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveIntSetLastReturnValue ( ) throws Exception { Integer value = new Integer ( 1 ) ; primitiveMock . getInt ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . intValue ( ) , primitiveMock . getInt ( ) ) ; } public void testPrimitiveLongReturnType ( ) throws Exception { try { long value = primitiveMock . getLong ( ) ; assertEquals ( unitializedLong , value ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void testPrimitiveLongSetLastReturnValue ( ) throws Exception { Long value = new Long ( 1 ) ; primitiveMock . getLong ( ) ; Mocks . setLastReturnValue ( primitiveMock , value ) ; Mocks . startChecking ( primitiveMock ) ; assertEquals ( value . longValue ( ) , primitiveMock . getLong ( ) ) ; } public void testPrimitiveFloatReturnType ( ) throws Exception { try { float value = primitiveMock . getFloat ( ) ; assertEquals ( unitializedFloat , value , 0 ) ; } catch ( UndeclaredThrowableException e ) { fail ( \"exception should not have been thrown\" ) ; } } public void", "gt": "testPrimitiveFloatSetLastReturnValue ( ) throws Exception", "prediction": "testPrimitiveIntSetLastReturnValue ( ) throws Exception\n", "label": 1}
{"id": 5620, "input": "<s> package org . parboiled . matchers ; import static org . parboiled . common . Preconditions . * ; import org . parboiled . MatcherContext ; import org . parboiled . Rule ; import org . parboiled . errors . GrammarException ; import org . parboiled . matchervisitors . MatcherVisitor ; public class ZeroOrMoreMatcher extends CustomDefaultLabelMatcher < ZeroOrMoreMatcher > { public final Matcher subMatcher ; public ZeroOrMoreMatcher ( Rule subRule ) { super ( checkArgNotNull ( subRule , \"subRule\" ) , \"ZeroOrMore\" ) ; this . subMatcher = getChildren ( ) . get ( 0 ) ; } public boolean match ( MatcherContext context ) { checkArgNotNull ( context , \"context\" ) ; int lastIndex = context . getCurrentIndex ( ) ; while ( subMatcher . getSubContext ( context ) . runMatcher ( ) ) { int currentLocation = context . getCurrentIndex ( ) ; if ( currentLocation == lastIndex ) { throw new GrammarException ( \"The inner rule of ZeroOrMore rule '%s' must not allow empty matches\" , context . getPath ( ) ) ; } lastIndex = currentLocation ; } context . createNode ( ) ; return true ; } public < R > R accept ( MatcherVisitor", "gt": "< R > visitor )", "prediction": "visitor )\n", "label": 0}
{"id": 15417, "input": "<s> package org . nuxeo . webengine . sites . models ; import org . nuxeo . theme", "gt": ". models . AbstractModel ;", "prediction": ". Context ;\n", "label": 1}
{"id": 4528, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SupportedAnnotationTypes ( \"*\" ) public class AnnoProc extends AbstractProcessor { public boolean process ( Set < ? extends TypeElement > elems , RoundEnvironment renv ) { if ( first ) { Filer filer = processingEnv . getFiler ( ) ; Messager messager = processingEnv . getMessager ( ) ; try { JavaFileObject fo =", "gt": "filer . createSourceFile ( \"Gen\" ) ;", "prediction": "null ;\n", "label": 0}
{"id": 15422, "input": "<s> package org . nuxeo . ecm . platform . picture . api ; import java . io . File ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; import org . nuxeo . ecm . core . storage . sql . coremodel . SQLBlob ; import org . nuxeo . runtime . services . streaming . FileSource ; import org . nuxeo . runtime . services . streaming . StreamSource ; public class BlobHelper { private BlobHelper ( ) { } public static File getFileFromBlob ( Blob blob ) { if ( blob instanceof FileBlob ) { return ( ( FileBlob ) blob ) . getFile ( ) ; }", "gt": "else if ( blob instanceof SQLBlob )", "prediction": "return blob ;\n", "label": 1}
{"id": 7776, "input": "<s> import java . util . * ; class X < T , U , V", "gt": "extends T & U >", "prediction": ">\n", "label": 0}
{"id": 15433, "input": "<s> package com . codeslap . persistence ; import java . util . ArrayList ; import java . util . List ; class Node { private final Class < ? > mContent ; private List < Node > children ; private Node mParent ; Node ( Class < ? > content ) { mContent = content ; } boolean addChild ( final Node child ) { if ( child . mContent == mContent ) { return false ; } List < Node > allButMe = allButMe ( ) ; if ( allButMe . contains ( child ) ) { return false ; } if ( children == null ) { children = new ArrayList < Node > ( ) ; } children . add ( child ) ; child . setParent ( this ) ; return true ; } List < Node > allButMe ( ) { Node root = this ; do { Node parent = root . getParent ( ) ; if ( parent == null ) { break ; } root = parent ; } while ( true ) ; List < Node > allButMe = new ArrayList < Node > ( ) { @ Override public boolean add ( Node node ) { if ( contains ( node ) ) { return false ; } return super . add ( node ) ; } } ; if ( root . mContent != mContent ) { allButMe . add ( root ) ; } allButMe ( root , allButMe , this ) ; return allButMe ; } private void allButMe ( Node node , List < Node > list , Node me ) { if ( node . children == null || node . children . size ( ) == 0 ) { return ; } for ( Node child : node . children ) { if ( child . mContent != me . mContent ) { list . add ( child ) ; } allButMe ( child , list , me ) ; } } public Node getParent ( ) { return mParent ; } void setParent ( Node parent ) { mParent = parent ; } @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Node ) ) return false ; Node node = ( Node ) o ; if ( mContent == null || node == null ) { return false ; }", "gt": "return mContent . equals ( node . mContent ) ;", "prediction": "return true ;\n", "label": 1}
{"id": 2635, "input": "<s> package ar . com . fdvs . dj . domain . chart . plot ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . entities . Entity ; import net . sf . jasperreports . charts . design . JRDesignPiePlot ; import net . sf . jasperreports . engine . JRChartPlot ; public class PiePlot extends AbstractPiePlot { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public void transform ( DynamicJasperDesign design , JRChartPlot plot , String name ) { super . transform ( design , plot , name ) ; JRDesignPiePlot piePlot = ( JRDesignPiePlot ) plot ; if ( getCircular ( ) != null ) piePlot . setCircular ( getCircular ( ) ) ; if ( getLabelFormat ( ) != null ) piePlot . setLabelFormat ( getLabelFormat ( ) ) ; if ( getLegendLabelFormat ( ) != null ) piePlot . setLegendLabelFormat", "gt": "( getLegendLabelFormat ( ) ) ;", "prediction": "( getLegendLabelFormat ( ) ) ;\n", "label": 0}
{"id": 15435, "input": "<s> package org . eclipse . rap . rwt . internal . theme ; import java . util . Arrays ; public class QxAnimation implements QxType { public Animation [ ] animations ; public QxAnimation ( ) { animations = new Animation [ 0 ] ; } public void addAnimation ( String name , int duration , String timingFunction ) { Animation animation = new Animation ( name , duration , timingFunction ) ; Animation [ ] newAnimations = new Animation [ animations . length + 1 ] ; System . arraycopy ( animations , 0 , newAnimations , 0 , animations . length ) ; newAnimations [ animations . length ] = animation ; animations = newAnimations ; } public String toDefaultString ( ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < animations . length ; i ++ ) { if ( result . length ( ) != 0 ) { result . append ( \", \" ) ; } result . append ( animations [ i ] . name ) ; result . append ( \" \" ) ; result . append ( animations [ i ] . duration ) ; result . append ( \"ms \" ) ; result . append ( animations [ i ] . timingFunction ) ; } return result . toString ( ) ; } @ Override public String toString ( ) { return \"QxAnimation{ \" + toDefaultString ( ) + \" }\" ; } @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( animations ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } QxAnimation other = ( QxAnimation ) obj ; if ( ! Arrays . equals ( animations , other . animations ) ) { return false ; } return true ; } public static String toCamelCaseString ( String string ) { StringBuilder result = new StringBuilder ( ) ; boolean toUpperCase = false ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { char ch = string . charAt ( i ) ; if ( ch == '-' ) { toUpperCase = true ; } else if ( toUpperCase ) { result . append ( Character . toUpperCase ( ch ) ) ; toUpperCase = false ; } else { result . append ( ch ) ; } } return result . toString ( ) ; } public static final class Animation { private static final String [ ] PREDEFINED_NAMES = new String [ ] { \"hoverIn\" , \"hoverOut\" , \"fadeIn\" , \"fadeOut\" , \"slideIn\" , \"slideOut\" , \"flyInLeft\" , \"flyInTop\" , \"flyInRight\" , \"flyInBottom\" , \"flyOutLeft\" , \"flyOutTop\" , \"flyOutRight\" , \"flyOutBottom\" } ; private static final String [ ] PREDEFINED_TIMING_FUNCTIONS = new String [ ] { \"ease\" , \"linear\" , \"ease-in\" , \"ease-out\" , \"ease-in-out\" } ; public final String name ; public final int duration ; public final String timingFunction ; private Animation ( String name , int duration , String timingFunction ) { checkName ( name ) ; checkTimingFunction ( timingFunction ) ; this . name = name ; this . duration = duration ; this . timingFunction = timingFunction ; } private void checkName ( String name ) { boolean result = false ; if ( name == null ) { throw new NullPointerException ( \"null argument\" ) ; } for ( int i = 0 ; i < PREDEFINED_NAMES . length && ! result ; i ++ ) { if ( name . equals ( PREDEFINED_NAMES [ i ] ) ) { result = true ; } } if ( ! result ) { String msg = \"Invalid value for animation name: \" + name ; throw new IllegalArgumentException ( msg ) ; } } private void checkTimingFunction ( String timingFunction ) { boolean result = false ; if ( timingFunction == null ) { throw new NullPointerException ( \"null argument\" ) ; } for ( int i = 0 ; i < PREDEFINED_TIMING_FUNCTIONS . length && ! result ; i ++ ) { if ( timingFunction . equals ( PREDEFINED_TIMING_FUNCTIONS [ i ] ) ) { result = true ; } } if ( ! result ) { String msg = \"Invalid value for animation timing function: \" + timingFunction ; throw new", "gt": "IllegalArgumentException ( msg ) ;", "prediction": "IllegalArgumentException ( msg ) ;\n", "label": 1}
{"id": 3853, "input": "<s> package com . redhat . ceylon . compiler . java . test ; import org . junit . runners . Suite ; import org . junit . runners . model . InitializationError ; import org . junit . runners . model . RunnerBuilder ; public class ConcurrentSuite extends Suite { public ConcurrentSuite ( Class < ? >", "gt": "clase , RunnerBuilder builder ) throws InitializationError", "prediction": "clazz )\n", "label": 0}
{"id": 15436, "input": "<s> package br . org . archimedes . interfaces ; import java . util . Collection ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; public interface IntersectionManager { Collection < Point > getIntersectionsBetween ( Element element , Element otherElement ) throws NullArgumentException ; Collection < Point > getIntersectionsBetween ( Element element , Collection < Element > otherElements ) throws NullArgumentException ; boolean intersects ( Rectangle rect", "gt": ", Element element ) throws NullArgumentException ;", "prediction": "angle ) throws NullArgumentException ;\n", "label": 1}
{"id": 1469, "input": "<s> package org . ofbiz . ecommerce . janrain ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . UnsupportedEncodingException ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . xpath . XPath ; import javax . xml . xpath . XPathConstants ; import javax . xml . xpath . XPathExpressionException ; import javax . xml . xpath . XPathFactory ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . webapp . control . LoginWorker ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; public class JanrainHelper { public static final String module = JanrainHelper . class . getName ( ) ; private static String apiKey = UtilProperties . getPropertyValue ( \"ecommerce.properties\" , \"janrain.apiKey\" ) ; private static String baseUrl = UtilProperties . getPropertyValue ( \"ecommerce.properties\" , \"janrain.baseUrl\" ) ; public JanrainHelper ( String apiKey , String baseUrl ) { while ( baseUrl . endsWith ( \"/\" ) ) baseUrl = baseUrl . substring ( 0 , baseUrl . length ( ) - 1 ) ; this . apiKey = apiKey ; this . baseUrl = baseUrl ; } public String getApiKey ( ) { return apiKey ; } public String getBaseUrl ( ) { return baseUrl ; } public static Element authInfo ( String token ) { Map < String , Object > query = new HashMap < String , Object > ( ) ; query . put ( \"token\" , token ) ; return apiCall ( \"auth_info\" , query ) ; } public HashMap < String , List < String > > allMappings ( ) { Element rsp = apiCall ( \"all_mappings\" , null ) ; Element mappings_node = ( Element ) rsp . getFirstChild ( ) ; HashMap < String , List < String > > result = new HashMap < String , List < String > > ( ) ; NodeList mappings = getNodeList ( \"/rsp/mappings/mapping\" , rsp ) ; for ( int i = 0 ; i < mappings . getLength ( ) ; i ++ ) { Element mapping = ( Element ) mappings . item ( i ) ; List < String > identifiers = new ArrayList < String > ( ) ; NodeList rk_list = getNodeList ( \"primaryKey\" , mapping ) ; NodeList id_list = getNodeList ( \"identifiers/identifier\" , mapping ) ; String remote_key = ( ( Element ) rk_list . item ( 0 ) ) . getTextContent ( ) ; for ( int j = 0 ; j < id_list . getLength ( ) ; j ++ ) { Element ident = ( Element ) id_list . item ( j ) ; identifiers . add ( ident . getTextContent ( ) ) ; } result . put ( remote_key , identifiers ) ; } return result ; } private NodeList getNodeList ( String xpath_expr , Element root ) { XPathFactory factory = XPathFactory . newInstance ( ) ; XPath xpath = factory . newXPath ( ) ; try { return ( NodeList ) xpath . evaluate ( xpath_expr , root , XPathConstants . NODESET ) ; } catch ( XPathExpressionException e ) { return null ; } } public List < String > mappings ( Object primaryKey ) { Map < String , Object > query = new HashMap < String , Object > ( ) ; query . put ( \"primaryKey\" , primaryKey ) ; Element rsp = apiCall ( \"mappings\" , query ) ; Element oids = ( Element ) rsp . getFirstChild ( ) ; List < String > result = new ArrayList < String > ( ) ; NodeList nl = oids . getChildNodes ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Element e = ( Element ) nl .", "gt": "item ( i ) ;", "prediction": "getTextContent ( ) ;\n", "label": 0}
{"id": 15438, "input": "<s> package org . apache . lucene . analysis . sinks ; import org . apache . lucene . analysis . SinkTokenizer ; import org . apache . lucene . analysis . TeeSinkTokenFilter ; import org . apache . lucene . analysis . Token ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . List ; import java . util . Date ; public class DateRecognizerSinkTokenizer extends SinkTokenizer { public static final String DATE_TYPE = \"date\" ; protected DateFormat dateFormat ; public DateRecognizerSinkTokenizer ( ) { this ( null , SimpleDateFormat . getDateInstance ( ) ) ; } public DateRecognizerSinkTokenizer ( DateFormat dateFormat ) { this ( null , dateFormat ) ; } public DateRecognizerSinkTokenizer ( List input ) { this ( input , SimpleDateFormat . getDateInstance ( ) ) ; } public DateRecognizerSinkTokenizer ( List input , DateFormat dateFormat ) { super ( input ) ; this", "gt": ". dateFormat = dateFormat ;", "prediction": ". dateFormat = dateFormat ;\n", "label": 1}
{"id": 1654, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class AnnotationTypeRequiredMemberWriterImpl extends AbstractMemberWriter implements AnnotationTypeRequiredMemberWriter , MemberSummaryWriter { public AnnotationTypeRequiredMemberWriterImpl ( SubWriterHolderWriter writer , AnnotationTypeDoc annotationType ) { super ( writer , annotationType ) ; } public Content getMemberSummaryHeader ( ClassDoc classDoc , Content memberSummaryTree ) { memberSummaryTree . addContent ( HtmlConstants . START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY ) ; Content memberTree = writer . getMemberTreeHeader ( ) ; writer . addSummaryHeader ( this , classDoc , memberTree ) ; return memberTree ; } public void addAnnotationDetailsTreeHeader ( ClassDoc classDoc , Content memberDetailsTree ) { if ( ! writer . printedAnnotationHeading ) { memberDetailsTree . addContent ( writer . getMarkerAnchor ( \"annotation_type_element_detail\" ) ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . DETAILS_HEADING , writer . annotationTypeDetailsLabel ) ; memberDetailsTree . addContent ( heading ) ; writer . printedAnnotationHeading = true ; } } public Content getAnnotationDocTreeHeader ( MemberDoc member , Content annotationDetailsTree ) { annotationDetailsTree . addContent ( writer . getMarkerAnchor ( member . name ( ) + ( ( ExecutableMemberDoc ) member ) . signature ( ) ) ) ; Content annotationDocTree = writer . getMemberTreeHeader ( ) ; Content heading = new HtmlTree ( HtmlConstants . MEMBER_HEADING ) ; heading . addContent ( member . name ( ) ) ; annotationDocTree . addContent ( heading ) ; return annotationDocTree ; } public Content getSignature ( MemberDoc member ) { Content pre = new HtmlTree ( HtmlTag . PRE ) ; writer . addAnnotationInfo ( member , pre ) ; addModifiers ( member , pre ) ; Content link = new RawHtml ( writer . getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_MEMBER , getType ( member ) ) ) ) ; pre . addContent ( link ) ; pre . addContent ( writer . getSpace ( ) ) ; if ( configuration ( ) . linksource ) { Content memberName = new StringContent ( member . name ( ) ) ; writer . addSrcLink ( member , memberName , pre ) ; } else { addName ( member . name ( ) , pre ) ; } return pre ; } public void addDeprecated ( MemberDoc member , Content annotationDocTree ) { addDeprecatedInfo ( member , annotationDocTree ) ; } public void addComments ( MemberDoc member , Content annotationDocTree ) { addComment ( member , annotationDocTree ) ; } public void addTags ( MemberDoc member , Content annotationDocTree ) { writer . addTagsInfo ( member , annotationDocTree ) ; } public Content getAnnotationDetails ( Content annotationDetailsTree ) { return getMemberTree ( annotationDetailsTree ) ; } public Content getAnnotationDoc ( Content annotationDocTree , boolean isLastContent ) { return getMemberTree ( annotationDocTree , isLastContent ) ; } public void close ( ) throws IOException { writer . close ( ) ; } public void addSummaryLabel ( Content memberTree ) { Content label = HtmlTree . HEADING ( HtmlConstants . SUMMARY_HEADING , writer . getResource ( \"doclet.Annotation_Type_Required_Member_Summary\" ) ) ; memberTree . addContent ( label ) ; } public String getTableSummary ( ) { return configuration ( ) . getText ( \"doclet.Member_Table_Summary\" , configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Member_Summary\" ) , configuration ( ) . getText ( \"doclet.annotation_type_required_members\" ) ) ; } public String getCaption ( ) { return configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Members\" ) ; } public String [ ] getSummaryTableHeader ( ProgramElementDoc member ) { String [ ] header = new String [ ] { writer . getModifierTypeHeader ( ) , configuration ( ) . getText ( \"doclet.0_and_1\" , configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Member\" ) , configuration ( ) . getText ( \"doclet.Description\" ) ) } ; return header ; } public void addSummaryAnchor ( ClassDoc cd , Content memberTree ) { memberTree . addContent ( writer . getMarkerAnchor ( \"annotation_type_required_element_summary\" ) ) ; } public void addInheritedSummaryAnchor ( ClassDoc cd , Content inheritedTree ) { } public void addInheritedSummaryLabel ( ClassDoc cd , Content inheritedTree ) { } protected void addSummaryLink ( int context , ClassDoc cd , ProgramElementDoc member , Content tdSummary ) { Content strong = HtmlTree . STRONG ( new RawHtml ( writer . getDocLink ( context , ( MemberDoc ) member , member . name ( ) , false ) ) ) ; Content code = HtmlTree . CODE ( strong ) ; tdSummary . addContent ( code ) ; } protected void addInheritedSummaryLink ( ClassDoc cd , ProgramElementDoc member , Content linksTree ) { } protected void addSummaryType ( ProgramElementDoc member , Content tdSummaryType ) { MemberDoc m = ( MemberDoc ) member ; addModifierAndType ( m , getType ( m ) , tdSummaryType ) ; } protected Content getDeprecatedLink ( ProgramElementDoc member ) { return writer . getDocLink ( LinkInfoImpl . CONTEXT_MEMBER , ( MemberDoc ) member , ( ( MemberDoc ) member ) . qualifiedName ( ) ) ; } protected Content getNavSummaryLink ( ClassDoc cd , boolean link ) { if ( link ) { return writer . getHyperLink ( \"\" , \"annotation_type_required_element_summary\" , writer . getResource ( \"doclet.navAnnotationTypeRequiredMember\" ) ) ; } else { return writer . getResource ( \"doclet.navAnnotationTypeRequiredMember\" ) ; } } protected void addNavDetailLink ( boolean link , Content liNav ) { if ( link ) { liNav . addContent ( writer . getHyperLink ( \"\" , \"annotation_type_element_detail\" , writer .", "gt": "getResource ( \"doclet.navAnnotationTypeMember\" ) ) ) ;", "prediction": "getResource ( \"doclet.navAnnotationTypeRequiredMember\" ) ) ) ;\n", "label": 0}
{"id": 15440, "input": "<s> package com . puppycrawl . tools . checkstyle . bcel . classfile ; import java . util . Set ; import org . apache . bcel . classfile . FieldOrMethod ; import com . puppycrawl . tools . checkstyle . api . Scope ; public class Utils { public static boolean inScope ( FieldOrMethod aFieldOrMethod , Set aScopes ) { if ( aFieldOrMethod . isPrivate ( ) ) { return ( aScopes . contains ( Scope . PRIVATE ) ) ; } else if ( aFieldOrMethod . isProtected ( ) ) { return ( aScopes . contains ( Scope . PROTECTED ) ) ; } else if ( aFieldOrMethod . isPublic ( ) ) { return ( aScopes . contains ( Scope . PUBLIC ) ) ; } else { return (", "gt": "aScopes . contains ( Scope . PACKAGE ) ) ;", "prediction": "aFieldOrMethod . isPrivate ( ) ) ;\n", "label": 1}
{"id": 7879, "input": "<s> package com . extjs . gxt . ui . client . widget . form ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . util . Format ; import com . extjs . gxt . ui . client . util . Size ; import com . google . gwt . core . client . GWT ; import com . google . gwt . user . client . DOM ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; import com . google . gwt . user . client . ui . Accessibility ; import com . google . gwt . user . client . ui . impl . TextBoxImpl ; public class TextField < D > extends Field < D > { public class TextFieldMessages extends FieldMessages { private String blankText = GXT . MESSAGES . textField_blankText ( ) ; private String maxLengthText ; private String minLengthText ; private String regexText = \"\" ; public String getBlankText ( ) { return blankText ; } public String getMaxLengthText ( ) { return maxLengthText ; } public String getMinLengthText ( ) { return minLengthText ; } public String getRegexText ( ) { return regexText ; } public void setBlankText ( String blankText ) { this . blankText = blankText ; } public void setMaxLengthText ( String maxLengthText ) { this . maxLengthText = maxLengthText ; } public void setMinLengthText ( String minLengthText ) { this . minLengthText = minLengthText ; } public void setRegexText ( String regexText ) { this . regexText = regexText ; } } protected static TextBoxImpl impl = ( TextBoxImpl ) GWT . create ( TextBoxImpl . class ) ; protected String emptyStyle = \"x-form-empty-field\" ; protected El input ; protected Validator validator ; private boolean allowBlank = true ; private int maxLength = Integer . MAX_VALUE ; private int minLength = 0 ; private boolean needsPreventDefaultMouseUp ; private boolean password ; private String regex ; private boolean selectOnFocus ; public TextField ( ) { messages = new TextFieldMessages ( ) ; setWidth ( 150 ) ; } public boolean getAllowBlank ( ) { return allowBlank ; } public int getCursorPos ( ) { return impl . getCursorPos ( getInputEl ( ) . dom ) ; } public int getMaxLength ( ) { return maxLength ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public TextFieldMessages getMessages ( ) { return ( TextFieldMessages ) messages ; } public int getMinLength ( ) { return minLength ; } public String getRegex ( ) { return regex ; } public String getSelectedText ( ) { int start = getCursorPos ( ) , length = getSelectionLength ( ) ; if ( start == - 1 ) { return \"\" ; } return getRawValue ( ) . substring ( start , start + length ) ; } public int getSelectionLength ( ) { return impl . getSelectionLength ( getInputEl ( ) . dom ) ; } public boolean getSelectOnFocus ( ) { return selectOnFocus ; } public Validator getValidator ( ) { return validator ; } public boolean isPassword ( ) { return password ; } @ Override public void onComponentEvent ( ComponentEvent ce ) { super . onComponentEvent ( ce ) ; switch ( ce . getEventTypeInt ( ) ) { case Event . ONMOUSEDOWN : if ( ! hasFocus ) { needsPreventDefaultMouseUp = true ; } break ; case Event . ONMOUSEUP : if ( needsPreventDefaultMouseUp ) { needsPreventDefaultMouseUp = false ; ce . preventDefault ( ) ; } break ; } } public void select ( int start , int length ) { impl . setSelectionRange ( getInputEl ( ) . dom , start , length ) ; }", "gt": "public void selectAll ( )", "prediction": "}\n", "label": 0}
{"id": 15441, "input": "<s> package org . mitre . jwt . signer . impl ; import java . io . UnsupportedEncodingException ; import java . nio . charset . Charset ; import java . security . GeneralSecurityException ; import java . security . NoSuchAlgorithmException ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import org . apache . commons . codec . binary . Base64 ; import org . mitre . jwt . signer . AbstractJwtSigner ; import org . mitre . jwt . signer . JwsAlgorithm ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . util . Assert ; public class HmacSigner extends AbstractJwtSigner implements InitializingBean { public static final String DEFAULT_PASSPHRASE = \"changeit\" ; public static final JwsAlgorithm DEFAULT_ALGORITHM = JwsAlgorithm . HS256 ; private static Logger logger = LoggerFactory . getLogger ( HmacSigner . class ) ; private Mac mac ; private String passphrase = DEFAULT_PASSPHRASE ; public HmacSigner ( ) { super ( DEFAULT_ALGORITHM ) ; } public HmacSigner ( byte [ ] passphraseAsRawBytes ) throws NoSuchAlgorithmException { this ( DEFAULT_ALGORITHM . getJwaName ( ) , new String ( passphraseAsRawBytes , Charset . forName ( \"UTF-8\" ) ) ) ; } public HmacSigner ( String passphrase ) throws NoSuchAlgorithmException { this ( DEFAULT_ALGORITHM . getJwaName ( ) , passphrase ) ; } public HmacSigner ( String algorithmName , byte [ ] passphraseAsRawBytes ) throws NoSuchAlgorithmException { this ( algorithmName , new String ( passphraseAsRawBytes , Charset . forName ( \"UTF-8\" ) ) ) ; } public HmacSigner ( String algorithmName , String passphrase ) { super ( JwsAlgorithm . getByJwaName ( algorithmName ) ) ; Assert . notNull ( passphrase ,", "gt": "\"A passphrase must be supplied\" ) ;", "prediction": "algorithmName ) ;\n", "label": 1}
{"id": 2377, "input": "<s> class T5017953 { int f = 0 ; void test ( int i ) { } { test ( NonExistentClass . f ++ ) ; test ( 1 + NonExistentClass . f ) ; test ( NonExistentClass . f + 1 ) ; test ( NonExistentClass . f + NonExistentClass . f ) ;", "gt": "test ( NonExistentClass . f += 1 ) ;", "prediction": "}\n", "label": 0}
{"id": 15442, "input": "<s> package org . seage . grammar ; import org . seage . data . DataNode ; import java . util . * ; public class NonterminalSymbol implements Symbol { private static final long serialVersionUID = - 1930442234125327450L ; public NonterminalSymbol ( String name ) { this . name = name ; children = new Vector < Symbol > ( ) ; rule = null ; } public NonterminalSymbol ( NonterminalSymbol other ) { this ( other . name ) ; } public Object eval ( DataNode symbolTable ) { try { return rule . eval ( symbolTable , this ) ; } catch ( Exception e ) { System . err . println ( \"GOT ERROR: \" + e ) ; e . printStackTrace ( ) ; return null ; } } public Symbol optimize ( ) { try { return rule . optimize ( this ) ; } catch ( Exception e ) { System . err . println ( \"GOT ERROR: \" + e ) ; return null ; } } public void expand ( Stack < NonterminalSymbol > stack , GrammarRule rule ) { this . rule = rule ; Vector < Symbol > right = rule . getRight ( ) ; Iterator < Symbol > it = right . iterator ( ) ; int i = stack . size ( ) ; while ( it . hasNext ( ) ) { Symbol s = ( Symbol ) it . next ( ) ; if ( s . getType ( ) == Symbol . Type . NONTERMINAL ) { NonterminalSymbol sn = new NonterminalSymbol ( ( NonterminalSymbol ) s ) ; children . add ( sn ) ; stack . add ( i , sn ) ; } else { TerminalSymbol ts = ( TerminalSymbol ) s . copy ( ) ; ts . pick ( ) ; children . add ( ts ) ; } } } public Vector < Symbol > getChildren ( ) { return children ; } public String toString ( ) { return name ; } public String getStringTree ( ) { String ret = new String ( ) ; for ( Symbol s : children ) { if ( s . getType ( ) == Symbol . Type . TERMINAL ) ret += s . toString ( ) ; else { ret += ( ( NonterminalSymbol ) ( s ) ) . getStringTree ( ) ; } } return ret ; } public String getSymbolTree ( ) { Iterator < Symbol > it = children . iterator ( ) ; Iterator < ? > rit = rule . getRight ( ) . iterator ( ) ; String ret = new String ( ) ; while ( rit . hasNext ( ) ) { Symbol s = ( Symbol ) rit . next ( ) ; if ( s . getType ( ) == Symbol . Type . TERMINAL ) ret += s . toString ( ) ; else { ret += ( ( NonterminalSymbol ) ( it . next ( ) ) ) . getStringTree ( ) ; } } return ret ; }", "gt": "public Symbol copy ( )", "prediction": "}\n", "label": 1}
{"id": 763, "input": "<s> package org . remast . baralga . gui ; import java . awt . AWTException ; import java . awt . Image ; import java . awt . SystemTray ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . AbstractAction ; import javax . swing . ImageIcon ; import javax . swing . JFrame ; import javax . swing . JPopupMenu ; import javax . swing . JSeparator ; import org . jdesktop . swinghelper . tray . JXTrayIcon ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . actions . ChangeProjectAction ; import org . remast . baralga . gui . actions . ExitAction ; import org . remast . baralga . gui . actions . StartAction ; import org . remast . baralga . gui . actions . StopAction ; import org . remast . baralga . gui . events . BaralgaEvent ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . model . Project ; import org . remast . util . TextResourceBundle ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . google . common . eventbus . Subscribe ; public class TrayIcon { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( TrayIcon . class ) ; private static final Logger log = LoggerFactory . getLogger ( TrayIcon . class ) ; private static final Image NORMAL_ICON = new ImageIcon ( BaralgaMain . class . getResource ( \"/icons/Baralga-Tray.gif\" ) ) . getImage ( ) ; private static final Image ACTIVE_ICON = new ImageIcon ( BaralgaMain . class . getResource ( \"/icons/Baralga-Tray-Green.png\" ) ) . getImage ( ) ; private final PresentationModel model ; private JXTrayIcon trayIcon ; private JPopupMenu menu = new JPopupMenu ( ) ; public TrayIcon ( final PresentationModel model , final MainFrame mainFrame ) { this . model = model ; this . model . getEventBus ( ) . register ( this ) ; buildMenu ( ) ; trayIcon = new JXTrayIcon ( NORMAL_ICON ) ; trayIcon . setToolTip ( textBundle . textFor ( \"Global.Title\" ) ) ; trayIcon . setJPopupMenu ( menu ) ; trayIcon . setImageAutoSize ( true ) ; trayIcon . addActionListener ( new ActionListener ( ) { public void actionPerformed ( final ActionEvent event ) { if ( ! mainFrame . isVisible ( ) ) { mainFrame . setVisible ( true ) ; } mainFrame . setState ( JFrame . NORMAL ) ; mainFrame . requestFocus ( ) ; } } ) ; if ( model . isActive ( ) ) { trayIcon . setImage ( ACTIVE_ICON ) ; trayIcon . setToolTip ( textBundle . textFor ( \"Global.Title\" ) + \" - \" + model . getSelectedProject ( ) + textBundle . textFor ( \"MainFrame.9\" ) + FormatUtils . formatTime ( model . getStart ( ) ) ) ; } } private void buildMenu ( ) { menu . removeAll ( ) ; final ExitAction exitAction = new ExitAction ( null , model ) ; exitAction . putValue ( AbstractAction . SMALL_ICON , null ) ; menu . add ( exitAction ) ; menu . add (", "gt": "new JSeparator ( ) ) ;", "prediction": "exitAction ) ;\n", "label": 0}
{"id": 15443, "input": "<s> package org . fuzzydb . server . internal . index . btree . node ; import java . io . Serializable ; import org . fuzzydb . client . Ref ; import org . fuzzydb . server . internal . index . btree . NodeW ; public class RootSentinel extends Node implements Serializable , Cloneable { private static final long serialVersionUID = 1L ; final Ref < NodeW > root ; public RootSentinel", "gt": "( Ref < NodeW > root )", "prediction": "( )\n", "label": 1}
{"id": 6070, "input": "<s> package org . jjflyboy . tjpeditor . formatting ; import org . eclipse . xtext . formatting . impl . AbstractDeclarativeFormatter ; import org . eclipse . xtext . formatting . impl . FormattingConfig ;", "gt": "public class ProjectFormatter extends AbstractDeclarativeFormatter", "prediction": "import org . eclipse . xtext . formatting . impl . Formatter ;\n", "label": 0}
{"id": 15444, "input": "<s> package org . restlet . example . misc ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . MediaType ; import org . restlet . data . Protocol ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . util . Series ; public class HeadersTest { public static void main ( String [ ] args ) throws Exception { final Restlet restlet = new Restlet ( ) { @ SuppressWarnings ( \"unchecked\" ) @ Override public void handle ( Request request , Response response ) { Series < Header > headers = ( Series < Header > ) request . getAttributes ( ) . get ( HeaderConstants . ATTRIBUTE_HEADERS ) ; response . setEntity ( \"Accept header: \" + headers . getFirstValue ( \"accept\" , true ) , MediaType . TEXT_PLAIN ) ; headers = new Series < Header > ( Header . class ) ; headers . add ( \"X-Test\" , \"Test value\" ) ; headers . add ( \"Location\" , \"http://www.restlet.org\" ) ; response . getAttributes ( ) . put ( HeaderConstants . ATTRIBUTE_HEADERS , headers ) ; } } ; final Server server = new Server ( Protocol", "gt": ". HTTP , 8111 , restlet ) ;", "prediction": ". HTTP ) ;\n", "label": 1}
{"id": 2055, "input": "<s> import pkg . SuperClass ; class ProtectedMemberAccess3 { pkg . SuperClass x = new pkg . SuperClass ( ) ; static pkg . SuperClass sx = new pkg . SuperClass ( ) ; class Inner { int i = x . pi ; int j = x . spi ; int n = sx . pi ; int m = sx . spi ; int w = x . pm ( ) ; int y = x . spm ( ) ; int u = sx . pm ( ) ; int v = sx . spm ( ) ; pkg . SuperClass . pC obj1 ; pkg . SuperClass . spC obj2 ; pkg . SuperClass . pI obj3 ; pkg . SuperClass . spI obj4 ; Object o1 = ( pkg . SuperClass . pC ) null ; Object o2 = ( pkg . SuperClass . spC ) null ; Object o3 = ( pkg . SuperClass . pI ) null ; Object o4 = ( pkg . SuperClass . spI ) null ; class C1 extends pkg . SuperClass . pC { } class C2 extends pkg . SuperClass . spC { } void m ( ) { pkg . SuperClass lx = new pkg . SuperClass ( ) ; x . pi = 1 ; x . spi = 2 ; sx . pi = 1 ; sx . spi = 2 ; lx . pi = 1 ; lx . spi = 2 ; int t = x . pm ( ) ; int y = x . spm ( ) ; int u = sx . pm ( ) ; int v = sx . spm ( ) ; int w = lx . pm ( ) ; int z = lx . spm ( ) ; int i = x . pi ; int j = x . spi ; int n = sx . pi ; int m = sx . spi ; int k = lx . pi ; int l = lx . spi ; pkg . SuperClass . pC obj1 ; pkg . SuperClass . spC obj2 ; pkg . SuperClass . pI obj3 ; pkg . SuperClass . spI obj4 ; Object o1 = ( pkg . SuperClass . pC ) null ; Object", "gt": "o2 = ( pkg . SuperClass . spC ) null ;", "prediction": "o2 = ( pkg . SuperClass . spC ) null ;\n", "label": 0}
{"id": 15460, "input": "<s> package org . eclipse . ui . tests . autotests ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . ui . IMemento ; public class TestResults { private Map results = new HashMap ( ) ; private final static String ATT_NAME = \"name\" ; private final static String ATT_TEST = \"test\" ; public TestResults ( ) { } public TestResults ( IMemento toLoad ) { IMemento [ ] tests = toLoad . getChildren ( ATT_TEST ) ; for ( int i = 0 ; i < tests . length ; i ++ ) { IMemento memento = tests [ i ] ; String name = memento . getString ( ATT_NAME ) ; if ( name == null ) { continue ; } results . put ( name , new TestResultFilter ( memento ) ) ; } } public String [ ] getTestNames ( ) { Collection ids = results . keySet ( ) ; return ( String [ ] ) ids . toArray ( new String [ ids . size ( ) ] ) ; } public TestResultFilter get ( String testName ) { return ( TestResultFilter ) results . get ( testName ) ; } public void put ( String", "gt": "testName , TestResultFilter filter )", "prediction": "testName )\n", "label": 1}
{"id": 367, "input": "<s> package Liza ; import org . bukkit . entity . ComplexEntityPart ;", "gt": "public interface LizaComplexEntityPart extends ComplexEntityPart", "prediction": "import org . bukkit . entity . Part ;\n", "label": 0}
{"id": 15461, "input": "<s> package org . restlet . example . book . restlet . ch05 . sec2 . verifier . jaas ; import org . restlet . resource . Get ; import org .", "gt": "restlet . resource . Put ;", "prediction": "restlet . resource . Response ;\n", "label": 1}
{"id": 9822, "input": "<s> package org . ofbiz . base . util ; import java . io . BufferedInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . Serializable ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . URL ; import java . text . MessageFormat ; import java . util . Enumeration ; import java . util . InvalidPropertiesFormatException ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . Properties ; import java . util . ResourceBundle ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastSet ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . base . util . collections . ResourceBundleMapWrapper ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; @ SuppressWarnings ( \"serial\" ) public class UtilProperties implements Serializable { public static final String module = UtilProperties . class . getName ( ) ; private static final UtilCache < String , Properties > resourceCache = UtilCache . createUtilCache ( \"properties.UtilPropertiesResourceCache\" ) ; private static final UtilCache < String , Properties > urlCache = UtilCache . createUtilCache ( \"properties.UtilPropertiesUrlCache\" ) ; protected static Locale fallbackLocale = null ; protected static Set < Locale > defaultCandidateLocales = null ; protected static Set < String > propertiesNotFound = FastSet . newInstance ( ) ; public static boolean propertyValueEquals ( String resource , String name , String compareString ) { String value = getPropertyValue ( resource , name ) ; if ( value == null ) return false ; return value . trim ( ) . equals ( compareString ) ; } public static boolean propertyValueEqualsIgnoreCase ( String resource , String name , String compareString ) { String value = getPropertyValue ( resource , name ) ; if ( value == null ) return false ; return value . trim ( ) . equalsIgnoreCase ( compareString ) ; } public static String getPropertyValue ( String resource , String name , String defaultValue ) { String value = getPropertyValue ( resource , name ) ; if ( UtilValidate . isEmpty ( value ) ) return defaultValue ; else return value ; } public static double getPropertyNumber ( String resource , String name , double defaultValue ) { String str = getPropertyValue ( resource , name ) ; if ( str == null ) { return defaultValue ; } try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; } } public static double getPropertyNumber ( String resource , String name ) { return getPropertyNumber ( resource , name , 0.00000 ) ; } private static Number getPropertyNumber ( String resource , String name , Number defaultNumber , String type ) { String str = getPropertyValue ( resource , name ) ; if ( UtilValidate . isEmpty ( str ) ) { Debug . logWarning ( \"Error converting String \\\"\" + str + \"\\\" to \" + type + \"; using defaultNumber \" + defaultNumber + \".\" , module ) ; return defaultNumber ; } else try { return ( Number ) ( ObjectType . simpleTypeConvert ( str , type , null , null ) ) ; } catch ( GeneralException e ) { Debug . logWarning ( \"Error converting String \\\"\" + str + \"\\\" to \" + type + \"; using defaultNumber \" + defaultNumber + \".\" , module ) ; } return defaultNumber ; } public static Boolean getPropertyAsBoolean ( String resource , String name , boolean defaultValue ) { String str = getPropertyValue ( resource , name ) ; if ( \"true\" . equalsIgnoreCase ( str ) ) return Boolean . TRUE ; else if ( \"false\" . equalsIgnoreCase ( str ) ) return Boolean . FALSE ; else return defaultValue ; } public static Integer getPropertyAsInteger ( String resource , String name , int defaultNumber ) { return ( Integer ) getPropertyNumber ( resource , name , defaultNumber , \"Integer\" ) ; } public static Long getPropertyAsLong ( String", "gt": "resource , String name , long defaultNumber )", "prediction": "resource , String name )\n", "label": 0}
{"id": 15477, "input": "<s> package org . nuxeo . ecm . platform . io . api . util ; import java . io . IOException ; import java . util . Collection ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentLocation ; import org . nuxeo . ecm . core . api . impl . DocumentLocationImpl ; public class IOHelper { private IOHelper ( ) { } public static void copy ( IOConfiguration src , IOConfiguration dest , Collection < String > ioAdapters ) throws IOException , ClientException { String uri = exportAsStream ( src , ioAdapters ) ; try { importFromStream ( dest , uri ) ; } finally { if ( uri != null ) { } } } public static String exportAsStream ( IOConfiguration location , Collection < String > ioAdapters ) throws ClientException { return location . getManager ( ) . externalizeExport ( location . getRepositoryName ( ) , location . getDocuments ( ) , ( String ) location . getProperty ( IOConfiguration . DOC_READER_FACTORY ) , location . getProperties ( ) , ioAdapters ) ; } public static void importFromStream ( IOConfiguration location , String streamUri ) throws ClientException { String docWriterFactoryName = ( String ) location . getProperty ( IOConfiguration . DOC_WRITER_FACTORY ) ; DocumentLocation targetLocation = new DocumentLocationImpl ( location . getRepositoryName ( ) , location . getFirstDocument ( ) ) ; if ( docWriterFactoryName == null ) { location . getManager ( ) . importExportedFile", "gt": "( streamUri , targetLocation ) ;", "prediction": "( docWriterFactoryName ) ;\n", "label": 1}
{"id": 750, "input": "<s> package com . sap . prd . mobile . ios . mios ; abstract class XCodeConstants { private XCodeConstants ( ) { throw new UnsupportedOperationException ( \"To prevent getting instances\" ) ; } final static String XCODE_PROJECT_EXTENTION = \".xcodeproj\" ; final static String XCODE_CONFIGURATION_FILE_NAME = \"project.pbxproj\" ; @ Override public Object clone ( ) { throw new UnsupportedOperationException (", "gt": "\"To prevent getting instances.\" ) ;", "prediction": "\"To prevent getting instances\" ) ;\n", "label": 0}
{"id": 15503, "input": "<s> package org . eclipse . swt . internal . image ; import org . eclipse . swt . * ; import org . eclipse . swt . graphics . * ; class PngPlteChunk extends PngChunk { int paletteSize ; PngPlteChunk ( PaletteData palette ) { super ( palette . getRGBs ( ) . length * 3 ) ; paletteSize = length / 3 ; setType ( TYPE_PLTE ) ; setPaletteData ( palette ) ; setCRC ( computeCRC ( ) ) ; } PngPlteChunk ( byte [ ] reference ) { super ( reference ) ; paletteSize = length / 3 ; } int getChunkType ( ) { return CHUNK_PLTE ; } int getPaletteSize ( ) { return paletteSize ; } PaletteData getPaletteData ( ) { RGB [ ] rgbs = new RGB [ paletteSize ] ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { int offset = DATA_OFFSET + ( i * 3 ) ; int red = reference [ offset ] & 0xFF ; int green = reference [ offset + 1 ] & 0xFF ; int blue = reference [ offset + 2 ] & 0xFF ; rgbs [ i ] = new RGB ( red , green , blue ) ; } return new PaletteData ( rgbs ) ; } void setPaletteData ( PaletteData palette ) { RGB [ ] rgbs = palette . getRGBs ( ) ; for ( int i = 0 ; i < rgbs . length ; i ++ ) { int offset = DATA_OFFSET + ( i * 3 ) ; reference [ offset ] = ( byte ) rgbs [ i ] . red ; reference [ offset + 1 ] = ( byte ) rgbs [ i ] . green ; reference [ offset + 2 ] = ( byte", "gt": ") rgbs [ i ] . blue ;", "prediction": ") rgbs [ i ] . blue ;\n", "label": 1}
{"id": 8868, "input": "<s> package com . sun . mirror . apt ; import java . util . Collection ; import java . util . Set ; import com . sun . mirror . declaration . AnnotationTypeDeclaration ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface AnnotationProcessorFactory {", "gt": "Collection < String > supportedOptions ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15505, "input": "<s> package org . agoncal . book . javaee7 . chapter19 . ex02 ; import org . agoncal . book . javaee7 . chapter19 . OrderLine ; import org . junit . Test ; import org . xml . sax . SAXParseException ; import java . util . List ; import static org . junit . Assert . assertEquals ; public class DomParsingWithValidationTest { @ Test ( expected = SAXParseException . class ) public void shouldParseOrderLines ( ) throws Exception { List < OrderLine > parseOrderLines = new DomParsingWithValidation ( ) . parseOrderLines ( ) ; assertEquals ( 2 , parseOrderLines . size ( ) ) ; OrderLine orderLine =", "gt": "parseOrderLines . get ( 0 ) ;", "prediction": "new OrderLine ( ) ;\n", "label": 1}
{"id": 9264, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Arrays ; import static java . util . Collections . * ; import static com . sun . mirror . util . DeclarationVisitors . * ; public class MemberOrderApf implements AnnotationProcessorFactory { private static final Collection < String > supportedAnnotations = unmodifiableCollection ( Arrays . asList ( \"*\" ) ) ; private static final Collection < String > supportedOptions = emptySet ( ) ; public Collection < String > supportedAnnotationTypes ( ) { return supportedAnnotations ; } public Collection < String > supportedOptions ( ) { return supportedOptions ; } public AnnotationProcessor getProcessorFor ( Set < AnnotationTypeDeclaration > atds , AnnotationProcessorEnvironment env ) { return new", "gt": "MemberOrderAp ( env ) ;", "prediction": "AnnotationProcessor ( atds , env ) ;\n", "label": 0}
{"id": 15514, "input": "<s> package io . beancounter . activities ; public class ActivityStoreException extends Exception { public ActivityStoreException ( String message ) { super ( message ) ; } public ActivityStoreException ( String message , Exception e ) {", "gt": "super ( message , e ) ;", "prediction": "super ( message , e ) ;\n", "label": 1}
{"id": 7267, "input": "<s> package org . ofbiz . crowd . user ; import java . util . List ; import java . util . Properties ; import java . util . Arrays ; import java . util . Set ; import org . ofbiz . base . util . UtilProperties ; import javolution . util . FastSet ; public class UserGroupMapper { protected List < String > groups ; public UserGroupMapper ( String [ ] groups ) { this . groups = Arrays . asList ( groups ) ; } public Set < String > getSecurityGroups ( ) { Properties props = UtilProperties . getProperties ( \"crowd.properties\" ) ; Set < String > secGroups = FastSet . newInstance ( ) ; boolean running = true ; int index = 1 ; while ( running ) { String groupStr = ( String ) props . get ( \"crowd.group.map.\" + index ) ; if ( groupStr == null ) { running = false ; } else { String [ ] groupSplit = groupStr . split ( \"=\" ) ; if ( groupSplit . length == 2 ) { if ( groups . contains ( groupSplit [ 0 ] ) ) { secGroups .", "gt": "add ( groupSplit [ 1 ] ) ;", "prediction": "add ( groupSplit [ 0 ] ) ;\n", "label": 0}
{"id": 15517, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"updateContentTypeXmlDocumentResult\" } ) @ XmlRootElement ( name = \"UpdateContentTypeXmlDocumentResponse\" ) public class UpdateContentTypeXmlDocumentResponse { @ XmlElement ( name = \"UpdateContentTypeXmlDocumentResult\" ) protected UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult updateContentTypeXmlDocumentResult ; public UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult getUpdateContentTypeXmlDocumentResult ( ) { return updateContentTypeXmlDocumentResult ; } public", "gt": "void setUpdateContentTypeXmlDocumentResult ( UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult value )", "prediction": "UpdateContentTypeXmlDocumentResponse . UpdateContentTypeXmlDocumentResult getUpdateContentTypeXmlDocumentResult ( )\n", "label": 1}
{"id": 6566, "input": "<s> package org . ofbiz . webapp . view ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . JREmptyDataSource ; import net . sf . jasperreports . engine . JasperCompileManager ; import net . sf . jasperreports . engine . JasperExportManager ; import net . sf . jasperreports . engine . JasperFillManager ; import net . sf . jasperreports . engine . JasperPrint ; import net . sf . jasperreports . engine . JasperReport ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . webapp . control . ContextFilter ; import org . ofbiz . webapp . view . AbstractViewHandler ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . jdbc . ConnectionFactory ; public class JasperReportsPdfViewHandler extends AbstractViewHandler { public static final String module = JasperReportsPdfViewHandler . class . getName ( ) ; protected ServletContext context ; public static UtilCache jasperReportsCompiledCache = UtilCache . createUtilCache ( \"webapp.JasperReportsCompiled\" ) ; public void init ( ServletContext context ) throws ViewHandlerException { this . context = context ; } public void render ( String name , String page , String info , String contentType , String encoding , HttpServletRequest request , HttpServletResponse response ) throws ViewHandlerException { if ( request == null ) { throw new ViewHandlerException ( \"The HttpServletRequest object was null, how did that happen?\" ) ; } if ( UtilValidate . isEmpty ( page ) ) { throw new ViewHandlerException ( \"View page was null or empty, but must be specified\" ) ; } if ( UtilValidate . isEmpty ( info ) ) { Debug . logInfo ( \"View info string was null or empty, (optionally used to specify an Entity that is mapped to the Entity Engine datasource that the report will use).\" , module ) ; } request . setAttribute ( ContextFilter . FORWARDED_FROM_SERVLET , Boolean . valueOf ( true ) ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; if ( delegator == null ) { throw new ViewHandlerException ( \"The delegator object was null, how did that happen?\" ) ; } try { JasperReport report = ( JasperReport ) jasperReportsCompiledCache . get ( page ) ; if ( report == null ) { synchronized ( this ) { report = ( JasperReport ) jasperReportsCompiledCache . get ( page ) ; if ( report == null ) { InputStream is = context . getResourceAsStream ( page ) ; report = JasperCompileManager . compileReport ( is ) ; jasperReportsCompiledCache . put ( page , report ) ; } } } response . setContentType ( \"application/pdf\" ) ; Map parameters = ( Map ) request . getAttribute ( \"jrParameters\" ) ; if ( parameters == null ) { parameters = UtilHttp . getParameterMap ( request ) ; } JRDataSource jrDataSource = ( JRDataSource ) request . getAttribute ( \"jrDataSource\" ) ; JasperPrint jp = null ; if ( jrDataSource == null ) { String datasourceName = delegator . getEntityHelperName ( info ) ; if ( UtilValidate . isNotEmpty ( datasourceName ) ) { Debug . logInfo ( \"Filling report with connection from datasource: \" + datasourceName , module ) ; jp = JasperFillManager . fillReport ( report , parameters , ConnectionFactory . getConnection ( datasourceName ) ) ; } else { Debug . logInfo ( \"Filling report with an empty JR datasource\" , module ) ; jp = JasperFillManager . fillReport ( report , parameters , new JREmptyDataSource ( ) ) ; } } else { Debug . logInfo ( \"Filling report with a passed in jrDataSource\" , module ) ; jp = JasperFillManager . fillReport ( report , parameters , jrDataSource ) ; } if ( jp . getPages ( ) . size ( ) < 1 ) { throw new ViewHandlerException ( \"Report is Empty (no results?)\" ) ; } else { Debug . logInfo ( \"Got report, there are \" + jp . getPages ( ) . size ( ) + \" pages.\" , module ) ; } JasperExportManager . exportReportToPdfStream ( jp , response . getOutputStream ( ) ) ; } catch ( IOException ie ) { throw", "gt": "new ViewHandlerException ( \"IO Error in report\" , ie ) ;", "prediction": "new ViewHandlerException ( \"Report is Empty (no results?)\" ) ;\n", "label": 0}
{"id": 15542, "input": "<s> package io . beancounter . platform ; public class ServiceException extends Exception { public ServiceException ( Exception e ) { super ( e ) ; } public ServiceException ( String message ) { super ( message ) ; } public ServiceException ( String", "gt": "message , Exception e )", "prediction": "message )\n", "label": 1}
{"id": 103, "input": "<s> package com . mobeelizer . mobile . android . search ; import java . util . List ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; public class MobeelizerBelongsToRestritionImpl implements MobeelizerInternalCriterion { private final String field ; private final String guid ; public MobeelizerBelongsToRestritionImpl ( final String field , final Class < ? > clazz , final String guid ) { this . field = field ;", "gt": "this . guid = guid ;", "prediction": "this . guid = guid ;\n", "label": 0}
{"id": 15543, "input": "<s> package org . restlet . ext . jaxrs . internal . spi ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . ext . RuntimeDelegate ; import javax . ws . rs . ext . RuntimeDelegate . HeaderDelegate ; import org . restlet . engine . header . ContentType ; import org . restlet . ext . jaxrs . internal . util . Converter ; public class MediaTypeHeaderDelegate implements HeaderDelegate < MediaType > { public MediaTypeHeaderDelegate ( ) { } public", "gt": "MediaType fromString ( String contentType ) throws IllegalArgumentException", "prediction": "MediaType getMediaType ( )\n", "label": 1}
{"id": 5577, "input": "<s> package FRC2115 . subsystems ; import edu . wpi . first . wpilibj . Joystick ; import edu . wpi . first . wpilibj . RobotDrive ; import edu . wpi . first . wpilibj . command . Subsystem ; import FRC2115 . RobotMap ; import FRC2115 . commands . DriveWithJoystick ; public class Chassis extends Subsystem { private final double SPEED_MULTIPLIER = 0.9 ; public RobotDrive drive ; public Chassis ( ) { drive = new RobotDrive ( RobotMap . leftDriveMotor , RobotMap . rightDriveMotor ) ; drive . setSafetyEnabled ( false ) ; }", "gt": "public void driveStraight ( double speed )", "prediction": "}\n", "label": 0}
{"id": 15544, "input": "<s> package org . restlet . data ; import java . io . File ; public final class LocalReference extends Reference { public static final int CLAP_DEFAULT = 0 ; public static final int CLAP_CLASS = 1 ; public static final int CLAP_SYSTEM = 2 ; public static final int CLAP_THREAD = 3 ; public static final int RIAP_APPLICATION = 4 ; public static final int RIAP_COMPONENT = 5 ; public static final int RIAP_HOST = 6 ; public static LocalReference createClapReference ( Package pkg ) { return createClapReference ( CLAP_DEFAULT , pkg ) ; } public static LocalReference createClapReference ( int authorityType , Package pkg ) { String pkgPath = pkg . getName ( ) . replaceAll ( \"\\\\.\" , \"/\" ) ; return new LocalReference ( \"clap://\" + getAuthorityName ( authorityType ) + \"/\" + pkgPath ) ; } public static LocalReference createClapReference ( String path ) { return createClapReference ( CLAP_DEFAULT , path ) ; } public static LocalReference createClapReference ( int authorityType , String path ) { return new LocalReference ( \"clap://\" + getAuthorityName ( authorityType ) + path ) ; } public static LocalReference createFileReference ( File file ) { return createFileReference ( file . getAbsolutePath ( ) ) ; } public static LocalReference createFileReference ( String filePath ) { return createFileReference ( \"\" , filePath ) ; } public static LocalReference createFileReference ( String hostName , String filePath ) { return new LocalReference ( \"file://\" + hostName + \"/\" + normalizePath ( filePath ) ) ; } public static LocalReference createJarReference ( Reference jarFile , String entryPath ) { return new LocalReference ( \"jar:\" + jarFile . getTargetRef ( ) . toString ( ) + \"!/\" + entryPath ) ; } public static LocalReference createRiapReference ( int authorityType , String path ) { return new LocalReference ( \"riap://\" + getAuthorityName ( authorityType ) + path ) ; } public static LocalReference createZipReference ( Reference zipFile , String entryPath ) { return new LocalReference ( \"zip:\" + zipFile . getTargetRef ( ) . toString ( ) + \"!/\" + entryPath ) ; } public static String getAuthorityName ( int authority ) { String result = null ; switch ( authority ) { case CLAP_DEFAULT : result = \"\" ; break ; case CLAP_CLASS : result = \"class\" ; break ; case CLAP_SYSTEM : result = \"system\" ; break ; case CLAP_THREAD : result = \"thread\" ; break ; case RIAP_APPLICATION : result = \"application\" ; break ; case RIAP_COMPONENT : result = \"component\" ; break ; case RIAP_HOST : result = \"host\" ; break ; } return result ; } public static String localizePath ( String path ) { final StringBuilder result = new StringBuilder ( ) ; char nextChar ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { nextChar = path . charAt ( i ) ; if ( nextChar == '/' ) { result . append ( File . separatorChar ) ; } else { result . append ( nextChar ) ; } } return result . toString ( ) ; } public static String normalizePath ( String path ) { final StringBuilder result = new StringBuilder ( ) ; char nextChar ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { nextChar = path . charAt ( i ) ; if ( ( nextChar == File . separatorChar ) ) { result . append ( '/' ) ; } else if ( ! isUnreserved ( nextChar ) ) { result . append ( Reference . encode ( \"\" + nextChar ) ) ; } else { result . append ( nextChar ) ; } } return result . toString ( ) ; } public LocalReference ( Reference localRef ) { super ( localRef . getTargetRef ( ) . toString ( ) ) ; } public LocalReference ( String localUri ) { super ( localUri ) ; } public int getClapAuthorityType ( ) { int result = 0 ; if ( Protocol . CLAP . equals ( getSchemeProtocol ( ) ) ) { final String authority = getAuthority ( ) ; if ( authority != null ) { if ( authority . equalsIgnoreCase ( getAuthorityName ( CLAP_CLASS ) ) ) { result = CLAP_CLASS ; } else if ( authority . equalsIgnoreCase ( getAuthorityName ( CLAP_SYSTEM ) ) ) { result = CLAP_SYSTEM ; } else if ( authority . equalsIgnoreCase ( getAuthorityName ( CLAP_THREAD ) ) ) { result = CLAP_THREAD ; } else { result = CLAP_DEFAULT ; } } } return result ; } public File getFile ( ) { File result = null ; if ( Protocol . FILE . equals ( getSchemeProtocol ( ) ) ) { final String hostName = getAuthority ( ) ; if ( ( hostName == null ) || hostName . equals ( \"\" ) || hostName . equalsIgnoreCase ( \"localhost\" ) ) { final String filePath = Reference . decode ( getPath ( ) ) ; result = new File ( filePath ) ; } else { throw new RuntimeException ( \"Can't resolve files on remote host machines\" ) ; } } return result ; } public String getJarEntryPath ( ) { String result = null ; if ( Protocol . JAR . equals ( getSchemeProtocol ( ) ) ) { final String ssp = getSchemeSpecificPart ( ) ; if ( ssp != null ) { final int separatorIndex = ssp . indexOf ( \"!/\" ) ; if ( separatorIndex != - 1 ) { result = ssp . substring ( separatorIndex + 2 ) ; } } } return result ; } public Reference getJarFileRef ( ) { Reference result = null ; if ( Protocol . JAR . equals ( getSchemeProtocol ( ) ) ) { final String ssp = getSchemeSpecificPart ( ) ;", "gt": "if ( ssp != null )", "prediction": "if ( ssp != null )\n", "label": 1}
{"id": 9928, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram", "gt": ". edit . helpers ;", "prediction": ";\n", "label": 0}
{"id": 15566, "input": "<s> package org . restlet . test . resource ; import java . util . Date ; public class FullContact extends Contact { private String address1 ; private String address2 ; private String address3 ; public FullContact ( String email , String firstName , String lastName , Date birthDate , String email2 , String address1 , String address2 , String address3 , String fax , String phone ) { super ( email , firstName , lastName , birthDate , email2 ) ; this . address1 = address1 ; this . address2 = address2 ; this . address3 = address3 ; this . fax = fax ; this . phone = phone ; } private String fax ; private String phone ; public String getAddress1 ( ) { return address1 ; } public String getAddress2 ( ) { return address2 ; } public String getAddress3 ( ) { return address3 ; } public String getFax ( ) { return fax ; } public String getPhone ( ) { return phone ; } public void setAddress1 ( String address1 ) { this . address1 = address1 ; } public void setAddress2 ( String address2 ) { this . address2 = address2 ; } public void setAddress3 ( String address3 ) { this . address3 = address3 ; } public void setFax ( String fax ) { this . fax = fax ; } public", "gt": "void setPhone ( String phone )", "prediction": "void setPhone ( String phone )\n", "label": 1}
{"id": 9254, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class PackageUseWriter extends SubWriterHolderWriter { final PackageDoc pkgdoc ; final SortedMap < String , Set < ClassDoc > > usingPackageToUsedClasses = new TreeMap < String , Set < ClassDoc > > ( ) ; public PackageUseWriter ( ConfigurationImpl configuration , ClassUseMapper mapper , String filename , PackageDoc pkgdoc ) throws IOException { super ( configuration , DirectoryManager . getDirectoryPath ( pkgdoc ) , filename , DirectoryManager . getRelativePath ( pkgdoc . name ( ) ) ) ; this . pkgdoc = pkgdoc ; ClassDoc [ ] content = pkgdoc . allClasses ( ) ; for ( int i = 0 ; i < content . length ; ++ i ) { ClassDoc usedClass = content [ i ] ; Set < ClassDoc > usingClasses = mapper . classToClass . get ( usedClass . qualifiedName ( ) ) ; if ( usingClasses != null ) { for ( Iterator < ClassDoc > it = usingClasses . iterator ( ) ; it . hasNext ( ) ; ) { ClassDoc usingClass = it . next ( ) ; PackageDoc usingPackage = usingClass . containingPackage ( ) ; Set < ClassDoc > usedClasses = usingPackageToUsedClasses . get ( usingPackage . name ( ) ) ; if ( usedClasses == null ) { usedClasses = new TreeSet < ClassDoc > ( ) ; usingPackageToUsedClasses . put ( Util . getPackageName ( usingPackage ) , usedClasses ) ; } usedClasses . add ( usedClass ) ; } } } } public static void generate ( ConfigurationImpl configuration , ClassUseMapper mapper , PackageDoc pkgdoc ) { PackageUseWriter pkgusegen ; String filename = \"package-use.html\" ; try { pkgusegen = new PackageUseWriter ( configuration , mapper , filename , pkgdoc ) ; pkgusegen . generatePackageUseFile ( ) ; pkgusegen . close ( ) ; } catch ( IOException exc ) { configuration . standardmessage . error ( \"doclet.exception_encountered\" , exc . toString ( ) , filename ) ; throw new DocletAbortException ( ) ; } } protected void generatePackageUseFile ( ) throws IOException { Content body = getPackageUseHeader ( ) ; HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . contentContainer ) ; if ( usingPackageToUsedClasses . isEmpty ( ) ) { div . addContent ( getResource ( \"doclet.ClassUse_No.usage.of.0\" , pkgdoc . name ( ) ) ) ; } else { addPackageUse ( div ) ; } body . addContent ( div ) ; addNavLinks ( false , body ) ; addBottom ( body ) ;", "gt": "printHtmlDocument ( null , true , body ) ;", "prediction": "}\n", "label": 0}
{"id": 15571, "input": "<s> package org . nuxeo . ecm . automation . core . util ; import java . io . InputStream ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . common . utils . StringUtils ; import org . nuxeo . ecm . automation . OperationException ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . model . Property ; import org . nuxeo . ecm . core . api . model . PropertyException ; import org . nuxeo . ecm . core . api . model . impl . ListProperty ; import org . nuxeo . ecm . core . api . security . ACE ; import org . nuxeo . ecm . core . api . security . ACL ; import org . nuxeo . ecm . core . api . security . impl . ACLImpl ; import org . nuxeo . ecm . core . api . security . impl . ACPImpl ; import org . nuxeo . ecm . core . schema . types . ComplexType ; import org . nuxeo . ecm . core . schema . types . ListType ; import org . nuxeo . ecm . core . schema . types . SimpleType ; import org . nuxeo . ecm . core . schema . types . Type ; import org . nuxeo . ecm . core . schema . types . primitives . BinaryType ; import org . nuxeo . ecm . core . schema . types . primitives . BooleanType ; import org . nuxeo . ecm . core . schema . types . primitives . DateType ; import org . nuxeo . ecm . core . schema . types . primitives . DoubleType ; import org . nuxeo . ecm . core . schema . types . primitives . IntegerType ; import org . nuxeo . ecm . core . schema . types . primitives . LongType ; import org . nuxeo . ecm . core . schema . types . primitives . StringType ; public class DocumentHelper { private DocumentHelper ( ) { } public static DocumentModel saveDocument ( CoreSession session , DocumentModel doc ) throws ClientException { doc = session . saveDocument ( doc ) ; return session . getDocument ( doc . getRef ( ) ) ; } public static void removeProperty ( DocumentModel doc , String xpath ) throws ClientException { Property p = doc . getProperty ( xpath ) ; if ( p . isList ( ) ) { ( ( ListProperty ) p ) . clear ( ) ; } else { Property pp = p . getParent ( ) ; if ( pp != null && pp . isList ( ) ) { ( ( ListProperty ) pp ) . remove ( p ) ; } else { p . remove ( ) ; } } } public static void addBlob ( Property p , Blob blob ) throws PropertyException { if ( p . isList ( ) ) { Type ft = ( ( ListProperty ) p ) . getType ( ) . getFieldType ( ) ; if ( ft . isComplexType ( ) && ( ( ComplexType ) ft ) . getFieldsCount ( ) == 2 ) { p . addValue ( createBlobHolderMap ( blob ) ) ; } else { p . addValue ( blob ) ; } } else { p . setValue ( blob ) ; } } public static HashMap < String , Serializable > createBlobHolderMap ( Blob blob ) { HashMap < String , Serializable > map = new HashMap < String , Serializable > ( ) ; map . put ( \"file\" , ( Serializable ) blob ) ; map . put ( \"filename\" , blob . getFilename ( ) ) ; return map ; } public static void setProperties ( CoreSession session , DocumentModel doc , Map < String , String > values ) throws Exception { for ( Map . Entry < String , String > entry : values . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; setProperty ( session , doc , key , value ) ; } } public static void setProperty ( CoreSession session , DocumentModel doc , String key , String value ) throws Exception { if ( \"ecm:acl\" . equals ( key ) ) { setLocalAcl ( session , doc , value ) ; } Property p = doc . getProperty ( key ) ; if ( value == null || value . length ( ) == 0 ) { p . setValue ( null ) ; return ; } Type type = p . getField ( ) . getType ( ) ; if ( ! type . isSimpleType ( ) ) { if ( type . isListType ( ) ) { ListType ltype = ( ListType ) type ; if ( ltype . isScalarList ( ) ) { p . setValue ( readStringList ( value , ( SimpleType ) ltype . getFieldType ( ) ) ) ; return ; } else if ( ltype . getFieldType ( ) . isComplexType ( ) ) { Object val = ComplexTypeJSONDecoder . decodeList ( ltype , value ) ; p . setValue ( val ) ; return ; } } else if ( type . isComplexType ( ) ) { Object val = ComplexTypeJSONDecoder . decode ( ( ComplexType ) type , value ) ; p . setValue ( val ) ; return ; } throw new OperationException ( \"Property type is not supported by this operation\" ) ; } else { p . setValue ( ( ( SimpleType ) type ) . getPrimitiveType ( ) . decode ( value ) ) ; } } protected static void setLocalAcl ( CoreSession session , DocumentModel doc , String value ) throws ClientException { ACPImpl acp = new ACPImpl ( ) ; ACLImpl acl = new ACLImpl ( ACL . LOCAL_ACL ) ; acp . addACL ( acl ) ; String [ ] entries = StringUtils .", "gt": "split ( value , ',' , true ) ;", "prediction": "parse ( acp ) ;\n", "label": 1}
{"id": 463, "input": "<s> package org . apache . giraph . examples ; import org . apache . hadoop . io . DoubleWritable ; import org . apache . giraph . graph . Aggregator ; public class DoubleSumAggregator implements Aggregator < DoubleWritable > { private double sum = 0 ; public void aggregate ( double value ) { sum += value ; } @ Override public void aggregate ( DoubleWritable value ) { sum += value . get ( ) ; } @ Override public void setAggregatedValue ( DoubleWritable value ) { sum = value . get ( ) ; } @ Override public DoubleWritable getAggregatedValue ( ) {", "gt": "return new DoubleWritable ( sum ) ;", "prediction": "return sum ;\n", "label": 0}
{"id": 15583, "input": "<s> package org . eclipse . ui . commands ; public final class NotDefinedException extends CommandException { private static final long serialVersionUID = 3257572788998124596L ; public NotDefinedException ( String s ) { super ( s ) ; } public NotDefinedException ( final org . eclipse . core . commands . common . NotDefinedException e ) { super ( e . getMessage (", "gt": ") , e ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 5706, "input": "<s> package com . example . tutorial . operator ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . junit . Assert . assertThat ; import org . junit . Test ; import com . example . tutorial . modelgen . table . model . ItemInfo ; import com . example . tutorial . modelgen . table . model . OrderDetail ; import com . example . tutorial . modelgen . view . model . JoinOrder ; import com . example . tutorial . modelgen . view . model . SumOrder ; public class TutorialOpTest { @ Test ( expected = UnsupportedOperationException . class ) public void testJoin ( ) { TutorialOpImpl operator = new TutorialOpImpl ( ) ; OrderDetail order = new OrderDetail ( ) ; ItemInfo info = new ItemInfo ( ) ; JoinOrder actual = operator . join ( info , order ) ; assertThat ( actual , is ( not ( nullValue ( ) ) ) ) ; } @ Test ( expected =", "gt": "UnsupportedOperationException . class ) public void testSum ( )", "prediction": "UnsupportedOperationException . class ) public void testOrder ( )\n", "label": 0}
{"id": 15594, "input": "<s> package org . eclipse . swt . internal . widgets . displaykit ; import static org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil . getId ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . IDisplayLifeCycleAdapter ; import org . eclipse . rap . rwt . internal . lifecycle . IRenderRunnable ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . lifecycle . UITestUtil ; import org . eclipse . rap . rwt . internal . theme . ThemeUtil ; import org . eclipse . rap . rwt . internal . uicallback . UICallBackManager ; import org . eclipse . rap . rwt . lifecycle . AbstractWidgetLCA ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseEvent ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . DestroyOperation ; import org . eclipse . rap . rwt . testfixture . Message . SetOperation ; import org .", "gt": "eclipse . swt . SWT ;", "prediction": "eclipse . swt . SWT ;\n", "label": 1}
{"id": 5714, "input": "<s> public class TestThrowsHead extends JavadocTester { private static final String BUG_ID = \"4530727\" ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"C.html\" , \"<dt><span class=\\\"strong\\\">Throws:</span>\" } } ; private static final String [ ] [ ] NEGATED_TEST = NO_TEST ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , SRC_DIR + FS + \"C.java\" } ; public static void main ( String [ ] args ) { TestThrowsHead tester = new TestThrowsHead ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return getClass", "gt": "( ) . getName ( ) ;", "prediction": "( ) . getName ( ) ;\n", "label": 0}
{"id": 15605, "input": "<s> package org . nuxeo . connect . download . tests ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class SlowDownloaderServlet extends HttpServlet { private static final long serialVersionUID = 1L ; @ Override public void init ( ) throws ServletException { System . out . println ( \"Init slow downloader\" ) ; } @ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp", "gt": ") throws ServletException , IOException", "prediction": ") throws ServletException\n", "label": 1}
{"id": 5009, "input": "<s> package org . jboss . arquillian . android . enricher ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import org . jboss . arquillian . android . api . AndroidDevice ; import org . jboss . arquillian . config . descriptor . api . ArquillianDescriptor ; import org . jboss . arquillian . core . api . Injector ; import org . jboss . arquillian . core . api . Instance ; import org . jboss . arquillian . core . api . annotation . ApplicationScoped ; import org . jboss . arquillian . core . api . annotation . Inject ; import org . jboss . arquillian . core . spi . ServiceLoader ; import org . jboss . arquillian . test . api . ArquillianResource ; import org . jboss . arquillian . test . impl . TestInstanceEnricher ; import org . jboss . arquillian . test . impl . enricher . resource . ArquillianResourceTestEnricher ; import org . jboss . arquillian . test . spi . TestEnricher ; import org . jboss . arquillian . test . spi . annotation . SuiteScoped ; import org . jboss . arquillian . test . spi . context . ClassContext ; import org . jboss . arquillian . test . spi . context . SuiteContext ; import org . jboss . arquillian . test . spi . context . TestContext ; import org . jboss . arquillian . test . spi . enricher . resource . ResourceProvider ; import org . jboss . arquillian . test . spi . event . suite . After ; import org . jboss . arquillian . test . spi . event . suite . AfterClass ; import org . jboss . arquillian . test . spi . event . suite . AfterSuite ; import org . jboss . arquillian . test . spi . event . suite . Before ; import org . jboss . arquillian . test . spi . event . suite . BeforeClass ; import org . jboss . arquillian . test . spi . event . suite . BeforeSuite ; import org . jboss . arquillian . test . test . AbstractTestTestBase ; import org . jboss . shrinkwrap . descriptor . api . Descriptors ; import org . junit . Assert ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . mockito . Mock ; import org . mockito . Mockito ; import org . mockito . runners . MockitoJUnitRunner ; @ RunWith ( MockitoJUnitRunner . class ) public class AndroidDeviceEnricherTestCase extends AbstractTestTestBase { @ Mock private ServiceLoader serviceLoader ; @ Mock private AndroidDevice runningDevice ; @ Inject Instance < Injector > injector ; @ Override protected void addExtensions ( List < Class < ? > > extensions ) { extensions . add ( TestInstanceEnricher . class ) ; extensions . add ( ArquillianResourceTestEnricher . class ) ; extensions . add ( AndroidDeviceResourceProvider . class ) ; } @ org . junit . Before public void setMocks ( ) { ArquillianDescriptor desc = Descriptors . create ( ArquillianDescriptor . class ) ; TestEnricher enricher = new ArquillianResourceTestEnricher ( ) ; enricher = injector . get ( ) . inject ( enricher ) ; ResourceProvider provider = new AndroidDeviceResourceProvider ( ) ; provider = injector . get ( ) . inject ( provider ) ; Mockito . when ( serviceLoader . all ( TestEnricher . class ) ) . thenReturn ( Arrays . asList ( enricher ) ) ; Mockito . when ( serviceLoader . all ( ResourceProvider . class ) ) . thenReturn ( Arrays . asList ( provider ) ) ; Mockito . when ( runningDevice . getAvdName ( ) ) . thenReturn ( \"mockedAndroid\" ) ; bind ( ApplicationScoped . class , ServiceLoader . class , serviceLoader ) ; bind ( ApplicationScoped . class , ArquillianDescriptor . class , desc ) ; bind ( SuiteScoped . class , AndroidDevice . class , runningDevice ) ; } @ Test public void deviceFoobarWasCreated ( ) throws Exception { DummyClass instance = new DummyClass ( ) ; getManager ( ) . getContext ( ClassContext . class ) . activate ( DummyClass . class ) ; Method testMethod = DummyClass . class . getMethod ( \"testMe\" ) ; getManager ( ) . getContext ( TestContext . class ) . activate ( instance ) ; fire ( new BeforeSuite ( ) ) ; AndroidDevice device = getManager ( ) . getContext ( SuiteContext . class ) . getObjectStore ( ) . get ( AndroidDevice . class ) ; Assert . assertNotNull ( \"Device", "gt": "was created\" , device ) ;", "prediction": "was created\" , device ) ;\n", "label": 0}
{"id": 15612, "input": "<s> package org . restlet . test . ext . oauth ; import java . util . HashSet ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import org . restlet . ext . oauth . AuthenticatedUser ; import org . restlet . ext . oauth . internal . AuthenticatedUserImpl ; import org . restlet . ext . oauth . internal . ExpireToken ; import org . restlet . ext . oauth . internal . MemTokenGenerator ; import org . restlet . ext . oauth . internal . Token ; import org . restlet . ext . oauth . internal . TokenGenerator ; import org . restlet . ext . oauth . internal . UnlimitedToken ; import org . restlet . test . RestletTestCase ; public class TokenGeneratorTestCase extends RestletTestCase { public void testCodeGeneratorSequence ( ) throws Exception { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor ( 5 ) ; TokenGenerator generator = new MemTokenGenerator ( pool ) ; AuthenticatedUser user = new AuthenticatedUserImpl ( \"1234567890\" , null ) ; Set < String > codes = new HashSet < String > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { codes . add ( generator . generateCode ( user ) ) ; } assertEquals ( 100 , codes . size ( ) ) ; } public void testTokenGenerator ( ) throws Exception { ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor ( 5 ) ; TokenGenerator generator = new MemTokenGenerator ( pool ) ; AuthenticatedUser user = new AuthenticatedUserImpl ( \"1234567890\" , null ) ; Token token = generator . generateToken ( user , Token . UNLIMITED ) ; assertEquals ( \"1234567890\" ,", "gt": "token . getUser ( ) . getId ( ) ) ;", "prediction": "token . toString ( ) ) ;\n", "label": 1}
{"id": 1043, "input": "<s> package org . dawb . workbench . ui . editors ; import java . io . File ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . EventListener ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . regex . Pattern ; import org . dawb . common . ui . DawbUtils ; import org . dawb . common . ui . monitor . ProgressMonitorWrapper ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . IPlottingSystemData ; import org . dawb . common . ui . plot . IPlottingSystemSelection ; import org . dawb . common . ui . plot . PlotType ; import org . dawb . common . ui . plot . axis . IAxis ; import org . dawb . common . ui . plot . tool . IDataReductionToolPage ; import org . dawb . common . ui . plot . tool . IToolChangeListener ; import org . dawb . common . ui . plot . tool . IToolPage ; import org . dawb . common . ui . plot . tool . IToolPage . ToolPageRole ; import org . dawb . common . ui . plot . tool . ToolChangeEvent ; import org . dawb . common . ui . plot . trace . ITraceListener ; import org . dawb . common . ui . plot . trace . ITraceListener . Stub ; import org . dawb . common . ui . plot . trace . TraceEvent ; import org . dawb . common . ui . slicing . DimsDataList ; import org . dawb . common . ui . slicing . ISlicablePlottingPart ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . common . ui . widgets . DoubleClickModifier ; import org . dawb . common . util . io . FileUtils ; import org . dawb . common . util . io . PropUtils ; import org . dawb . common . util . io . SortingUtils ; import org . dawb . common . util . list . SortNatural ; import org . dawb . gda . extensions . loaders . H5Loader ; import org . dawb . gda . extensions . util . DatasetTitleUtils ; import org . dawb . workbench . plotting . tools . reduction . DataReductionWizard ; import org . dawb . workbench . ui . Activator ; import org . dawb . workbench . ui . editors . preference . EditorConstants ; import org . dawb . workbench . ui . editors . preference . EditorPreferencePage ; import org . dawb . workbench . ui . editors . slicing . ExpressionObject ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IContributionManager ; import org . eclipse . jface . action . IMenuListener ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . ColumnLabelProvider ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . TextCellEditor ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . window . ToolTip ; import org . eclipse . jface . wizard . WizardDialog ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . KeyListener ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ;", "gt": "import org . eclipse . swt . widgets . Composite ;", "prediction": "import org . eclipse . swt . widgets . Composite ;\n", "label": 0}
{"id": 15624, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import org . eclipse . rap . rwt . internal . branding . BrandingManager ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointManager ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleAdapterFactory ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleFactory ; import org . eclipse . rap . rwt . internal . lifecycle . PhaseListenerRegistry ; import org . eclipse . rap . rwt . internal . resources . JSLibraryConcatenator ; import org . eclipse . rap . rwt . internal . resources . ResourceDirectory ; import org . eclipse . rap . rwt . internal . resources . ResourceRegistry ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . service . SettingStoreManager ; import org . eclipse . rap . rwt . internal . service . StartupPage ; import org . eclipse . rap . rwt . internal . textsize . ProbeStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorage ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . resources . IResourceManager ; import org . eclipse . rap . rwt . service . IApplicationStore ; import org . eclipse . swt . internal . graphics . FontDataFactory ; import org . eclipse . swt . internal . graphics . ImageDataFactory ; import org . eclipse . swt . internal . graphics . ImageFactory ; import org . eclipse . swt . internal . graphics . InternalImageFactory ; import org . eclipse . swt . internal . graphics . ResourceFactory ; import org . eclipse . swt . internal . widgets . DisplaysHolder ; public class RWTFactory { public static IApplicationStore getApplicationStore ( ) { return ApplicationContextUtil . getInstance ( ) . getApplicationStore ( ) ; } public static LifeCycleFactory getLifeCycleFactory ( ) { return ApplicationContextUtil . getInstance ( ) . getLifeCycleFactory ( ) ; } public static BrandingManager getBrandingManager ( ) { return ApplicationContextUtil . getInstance ( ) . getBrandingManager ( ) ; } public static EntryPointManager getEntryPointManager ( ) { return ApplicationContextUtil . getInstance ( ) . getEntryPointManager ( ) ; } public static ServiceManager getServiceManager ( ) { return ApplicationContextUtil . getInstance ( ) . getServiceManager ( ) ; } public static StartupPage getStartupPage ( ) { return ApplicationContextUtil . getInstance ( ) . getStartupPage ( ) ; } public static SettingStoreManager getSettingStoreManager ( ) { return ApplicationContextUtil . getInstance ( ) . getSettingStoreManager ( ) ; } public static ResourceDirectory getResourceDirectory ( ) { return ApplicationContextUtil . getInstance ( ) . getResourceDirectory ( ) ; } public static PhaseListenerRegistry getPhaseListenerRegistry ( ) { return ApplicationContextUtil . getInstance ( ) . getPhaseListenerRegistry ( ) ; } public static ThemeManager getThemeManager ( ) { return ApplicationContextUtil . getInstance ( ) . getThemeManager ( ) ; } public static TextSizeStorage getTextSizeStorage ( ) { return ApplicationContextUtil . getInstance ( ) . getTextSizeStorage ( ) ; } public static ProbeStore getProbeStore ( ) { return ApplicationContextUtil . getInstance ( ) . getProbeStore ( ) ; } public static ImageFactory getImageFactory ( ) { return ApplicationContextUtil . getInstance ( ) . getImageFactory ( ) ; } public static FontDataFactory getFontDataFactory ( ) { return ApplicationContextUtil . getInstance ( ) . getFontDataFactory ( ) ; } public static ImageDataFactory getImageDataFactory ( ) { return ApplicationContextUtil . getInstance ( ) . getImageDataFactory ( ) ; } public static ResourceFactory getResourceFactory ( ) { return ApplicationContextUtil . getInstance", "gt": "( ) . getResourceFactory ( ) ;", "prediction": "( ) . getResourceFactory ( ) ;\n", "label": 1}
{"id": 5130, "input": "<s> import java . util . * ; class CastTest { private class AA < T > { } private class AB < T > extends AA < T > { } private class AC < T > extends AA < Vector < T > > { } private class AD < T > extends AA < Vector < ? extends T > > { } private class AE < T > extends AA < Vector < ? super T > > { } private class AF < T > extends AA < T [ ] > { }", "gt": "private class AG < T > extends AA < String >", "prediction": "}\n", "label": 0}
{"id": 15628, "input": "<s> package org . fuzzydb . core . marker ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org", "gt": ". fuzzydb . core . whirlwind . internal . IAttributeMap ;", "prediction": ". fuzzydb . core . whirlwind . internal . IAttributeMap ;\n", "label": 1}
{"id": 8728, "input": "<s> package org . ofbiz . minilang . method . envops ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class ListToList extends MethodOperation { private final FlexibleMapAccessor < List < Object > > listFma ; private final FlexibleMapAccessor < List < Object > > toListFma ; public ListToList ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"to-list\" , \"list\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"to-list\" , \"list\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"to-list\" , \"list\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } toListFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"to-list\" ) ) ; listFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"list\" ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { List < Object > fromList = listFma . get ( methodContext . getEnvMap ( ) ) ; if ( fromList != null ) { List < Object > toList = toListFma . get ( methodContext . getEnvMap ( ) ) ; if", "gt": "( toList == null )", "prediction": "( toList != null )\n", "label": 0}
{"id": 15634, "input": "<s> package org . nuxeo . ecm . platform . mail . action ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . mail . Address ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . Part ; import javax . mail . internet . MimeMessage ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeUtility ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . impl . blob . FileBlob ; public class TransformMessageAction implements MessageAction { private static final Log log = LogFactory . getLog ( TransformMessageAction . class ) ; protected final Map < String , Map < String , Object > > schemas = new HashMap < String , Map < String , Object > > ( ) ; protected final Map < String , Object > mailSchema = new HashMap < String , Object > ( ) ; protected final Map < String , Object > dcSchema = new HashMap < String , Object > ( ) ; protected final Map < String , Object > filesSchema = new HashMap < String , Object > ( ) ; protected final List < Map < String , Object > > files = new ArrayList < Map < String , Object > > ( ) ; protected StringBuilder text = new StringBuilder ( ) ; private final HashMap < String , List < Part > > messageBodyParts = new HashMap < String , List < Part > > ( ) ; public TransformMessageAction ( ) { messageBodyParts . put ( \"text\" , new ArrayList < Part > ( ) ) ; messageBodyParts . put ( \"html\" , new ArrayList < Part > ( ) ) ; schemas . put ( \"mail\" , mailSchema ) ; schemas . put ( \"dublincore\" , dcSchema ) ; filesSchema . put ( \"files\" , files ) ; schemas . put ( \"files\" , filesSchema ) ; } public boolean execute ( ExecutionContext context ) throws Exception { Message message = context . getMessage ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Transforming message\" + message . getSubject ( ) ) ; } if ( message . getFrom ( ) != null && message . getFrom ( ) . length != 0 ) { List < String > contributors = new ArrayList < String > ( ) ; for ( Address ad : message . getFrom ( ) ) { contributors . add ( safelyDecodeText ( ad . toString ( ) ) ) ; } dcSchema . put ( \"contributors\" , contributors ) ; dcSchema . put ( \"creator\" , contributors . get ( 0 ) ) ; dcSchema . put ( \"created\" , message . getReceivedDate ( ) ) ; } if ( message . getAllRecipients ( ) != null && message . getAllRecipients ( ) . length != 0 ) { List < String > recipients = new ArrayList < String > ( ) ; for ( Address address : message . getAllRecipients ( ) ) { recipients . add ( safelyDecodeText ( address . toString ( ) ) ) ; } mailSchema . put ( \"recipients\" , recipients ) ; } if ( message instanceof MimeMessage ) { processMimeMessage ( ( MimeMessage ) message ) ; } mailSchema . put ( \"text\" , text . toString ( ) ) ; dcSchema . put ( \"title\" , message . getSubject ( ) ) ; context . put ( \"transformed\" , schemas ) ; return true ; } private void processMimeMessage ( MimeMessage message ) throws MessagingException , IOException { Object object = message . getContent ( ) ; if ( object instanceof String ) { addToTextMessage ( message . getContent ( ) . toString ( ) , true ) ; } else if ( object instanceof MimeMultipart ) { processMultipartMessage ( ( MimeMultipart ) object ) ; processSavedTextMessageBody ( ) ; } } private void processMultipartMessage ( MimeMultipart parts ) throws MessagingException , IOException { log . debug ( \"processing multipart message.\" ) ; for ( int i = 0 ; i < parts . getCount ( ) ; i ++ ) { Part part = parts . getBodyPart ( i ) ; if ( part . getDataHandler ( ) . getContent ( ) instanceof MimeMultipart ) { log . debug ( \"** found embedded multipart message\" ) ; processMultipartMessage ( ( MimeMultipart ) part . getDataHandler ( ) . getContent ( ) ) ; continue ; } log . debug ( \"processing single part message: \" + part . getClass ( ) ) ; processSingleMessagePart ( part ) ; } } private void processSingleMessagePart ( Part part ) throws MessagingException , IOException { String partContentType = part . getContentType ( ) ; String partFileName =", "gt": "getFileName ( part ) ;", "prediction": "part . getFileName ( ) ;\n", "label": 1}
{"id": 2265, "input": "<s> package com . toedter . gwt . demo . contacts . client . ui ; import java . util . List ; import com . google . gwt . place . shared . Place ; import com . google . gwt . user . client . ui . AcceptsOneWidget ; import com . google . gwt . user . client . ui . IsWidget ; import com . toedter . gwt . demo . contacts . shared . Contact ; public interface IContactListView extends IsWidget , AcceptsOneWidget { public interface Presenter { void goTo ( Place place ) ; void select ( int index ) ; void select", "gt": "( Contact contact ) ;", "prediction": "( int index ) ;\n", "label": 0}
{"id": 15635, "input": "<s> package org . fuzzydb . postcode ; import java . io . UnsupportedEncodingException ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . dto . attributes . NonIndexStringAttribute ; import org . fuzzydb . dto . attributes . RandomGenerator ; import org . fuzzydb . util . MTRandom ; import org . slf4j . Logger ; public class RandomUKShortPostcode implements RandomGenerator < NonIndexStringAttribute > { private static Logger log = LogFactory . getLogger ( RandomUKShortPostcode . class ) ; public RandomUKShortPostcode ( ) { } @ Override public NonIndexStringAttribute next ( String attrName ) { return new NonIndexStringAttribute ( attrName , nextShortPostcode ( ) ) ; } public String nextShortPostcode ( ) { byte [ ] shortData = JibbleConvertor . getInstance ( ) . getPrefixData ( ) ; if ( shortData == null || shortData . length < 4 ) { throw new RuntimeException ( \"Random Postcodes short data did not load\" ) ; } int numCodes = shortData . length / 4 ; int index = 4 * MTRandom . getInstance ( ) . nextInt ( numCodes ) ; String result ; try { result = new String ( shortData , index , 4 , \"UTF8\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( \"Internal", "gt": "error: \" , e ) ;", "prediction": "error\" , e ) ;\n", "label": 1}
{"id": 3050, "input": "<s> package org . msl . simple . gmfmap . simplemappings . provider ; import java . util . Collection ; import java . util . List ; import org . eclipse . emf . common . notify . AdapterFactory ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . util . ResourceLocator ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . edit . provider . ComposedAdapterFactory ; import org . eclipse . emf . edit . provider . IEditingDomainItemProvider ; import org . eclipse . emf . edit . provider . IItemLabelProvider ; import org . eclipse . emf . edit . provider . IItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . IItemPropertySource ; import org . eclipse . emf . edit . provider . IStructuredItemContentProvider ; import org . eclipse . emf . edit . provider . ITreeItemContentProvider ; import org . eclipse . emf . edit . provider . ItemPropertyDescriptor ; import org . eclipse . emf . edit . provider . ViewerNotification ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . SimpleTopNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsFactory ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleTopNodeItemProvider extends SimpleNodeItemProvider implements IEditingDomainItemProvider , IStructuredItemContentProvider , ITreeItemContentProvider , IItemLabelProvider , IItemPropertySource { public SimpleTopNodeItemProvider ( AdapterFactory adapterFactory ) { super ( adapterFactory ) ; } @ Override public List < IItemPropertyDescriptor > getPropertyDescriptors ( Object object ) { if ( itemPropertyDescriptors == null ) { super . getPropertyDescriptors ( object ) ; } return itemPropertyDescriptors ; } @ Override public Collection < ? extends EStructuralFeature > getChildrenFeatures ( Object object ) { if ( childrenFeatures == null ) { super . getChildrenFeatures ( object ) ; childrenFeatures . add ( SimplemappingsPackage . Literals . SIMPLE_TOP_NODE__LINKS ) ; } return childrenFeatures ; } @ Override protected EStructuralFeature getChildFeature ( Object object , Object child ) { return super . getChildFeature ( object , child ) ; } @ Override public Object getImage ( Object object ) { return overlayImage ( object , getResourceLocator ( ) . getImage ( \"full/obj16/SimpleTopNode\" ) ) ; } @ Override public String getText ( Object object ) { String label = ( ( SimpleTopNode ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( \"_UI_SimpleTopNode_type\" ) : label ; } @ Override public void notifyChanged ( Notification notification ) { updateChildren ( notification ) ; switch ( notification . getFeatureID ( SimpleTopNode . class ) ) { case SimplemappingsPackage . SIMPLE_TOP_NODE__CHILDREN : fireNotifyChanged ( new ViewerNotification ( notification , notification . getNotifier ( ) , false , true ) ) ; return ; case SimplemappingsPackage . SIMPLE_TOP_NODE__LINKS : fireNotifyChanged ( new ViewerNotification ( notification , notification . getNotifier ( ) , true , false ) ) ; return ; } super . notifyChanged ( notification ) ; } @ Override protected void collectNewChildDescriptors ( Collection < Object > newChildDescriptors , Object object ) { super . collectNewChildDescriptors ( newChildDescriptors , object ) ; newChildDescriptors . add ( createChildParameter ( SimplemappingsPackage . Literals . SIMPLE_TOP_NODE__LINKS , SimplemappingsFactory . eINSTANCE . createSimpleLinkMapping ( ) ) ) ; } protected ItemPropertyDescriptor createItemPropertyDescriptor ( AdapterFactory adapterFactory , ResourceLocator resourceLocator , String displayName , String description , EStructuralFeature feature , boolean isSettable , boolean multiLine , boolean sortChoices , Object staticImage , String category ,", "gt": "String [ ] filterFlags )", "prediction": "Object property )\n", "label": 0}
{"id": 15637, "input": "<s> package org . eclipse . ui . internal . commands ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . jface . bindings . BindingManager ; import org . eclipse . ui . commands . ExecutionException ; import org . eclipse . ui . commands . ICommand ; import org . eclipse . ui . commands . ICommandListener ; import org . eclipse . ui . commands . NotDefinedException ; import org . eclipse . ui . commands . NotHandledException ; final class CommandLegacyWrapper implements ICommand { private final BindingManager bindingManager ; private final Command command ; CommandLegacyWrapper ( final Command command , final BindingManager bindingManager ) { if ( command == null ) { throw new NullPointerException ( \"The wrapped command cannot be <code>null</code>.\" ) ; } if ( bindingManager == null ) { throw new NullPointerException ( \"A binding manager is required to wrap a command\" ) ; } this . command = command ; this . bindingManager = bindingManager ; } public final void addCommandListener ( final ICommandListener commandListener ) { command . addCommandListener ( new LegacyCommandListenerWrapper ( commandListener , bindingManager ) ) ; } public final Object execute ( Map parameterValuesByName ) throws ExecutionException , NotHandledException { try { return command . execute ( new ExecutionEvent ( command , ( parameterValuesByName == null ) ? Collections . EMPTY_MAP : parameterValuesByName , null , null ) ) ; } catch ( final org . eclipse . core . commands . ExecutionException e ) { throw new ExecutionException ( e ) ; } catch ( final org . eclipse . core . commands . NotHandledException e ) { throw new NotHandledException ( e ) ; } } public final Map getAttributeValuesByName ( ) { final Map attributeValues = new HashMap ( ) ; attributeValues . put ( ILegacyAttributeNames . ENABLED , command . isEnabled ( ) ? Boolean . TRUE : Boolean . FALSE ) ; attributeValues . put ( ILegacyAttributeNames . HANDLED , command . isHandled ( ) ?", "gt": "Boolean . TRUE : Boolean . FALSE ) ;", "prediction": "Boolean . TRUE : Boolean . FALSE ) ;\n", "label": 1}
{"id": 234, "input": "<s> package org . xbill . DNS ; public class CNAMERecord extends SingleCompressedNameBase { private static final long serialVersionUID = - 4020373886892538580L ; CNAMERecord ( ) { } Record getObject ( ) { return new CNAMERecord ( ) ; } public CNAMERecord ( Name name , int dclass , long ttl , Name alias ) { super ( name , Type . CNAME", "gt": ", dclass , ttl , alias , \"alias\" ) ;", "prediction": ", alias ) ;\n", "label": 0}
{"id": 15638, "input": "<s> package org . eclipse . swt . graphics ; import org . eclipse . swt . * ; import org . eclipse . swt . internal . SerializableCompatibility ; @ SuppressWarnings ( \"all\" ) public final class PaletteData implements SerializableCompatibility { public boolean isDirect ; public RGB [ ] colors ; public int redMask ; public int greenMask ; public int blueMask ; public int redShift ; public int greenShift ; public int blueShift ; public PaletteData ( RGB [ ] colors ) { if ( colors == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; this . colors = colors ; this . isDirect = false ; } public PaletteData ( int redMask , int greenMask , int blueMask ) { this . redMask = redMask ; this . greenMask = greenMask ; this . blueMask = blueMask ; this . isDirect = true ; this . redShift = shiftForMask ( redMask ) ; this . greenShift = shiftForMask ( greenMask ) ; this . blueShift = shiftForMask ( blueMask ) ; } public int getPixel ( RGB rgb ) { if ( rgb == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( isDirect ) { int pixel = 0 ; pixel |= ( redShift < 0 ? rgb . red << - redShift : rgb . red > > > redShift ) & redMask ; pixel |= ( greenShift < 0 ? rgb . green << - greenShift : rgb . green > > > greenShift ) & greenMask ; pixel |= ( blueShift < 0 ? rgb . blue << - blueShift : rgb . blue > > > blueShift ) & blueMask ; return pixel ; } else { for ( int i = 0 ; i < colors . length ; i ++ ) { if ( colors [ i ] . equals ( rgb ) ) return i ; } SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; return 0 ; } } public RGB getRGB ( int pixel ) { if ( isDirect ) { int r = pixel & redMask ; r = ( redShift < 0 ) ? r > > > - redShift : r << redShift ; int g = pixel & greenMask ; g = ( greenShift < 0 ) ? g > > > - greenShift : g << greenShift ; int b = pixel & blueMask ; b = ( blueShift < 0 ) ? b > > > - blueShift : b << blueShift ; return new RGB ( r , g , b ) ; } else { if ( pixel < 0 || pixel >= colors . length ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } return colors [ pixel ] ; } } public RGB", "gt": "[ ] getRGBs ( )", "prediction": "getRGB ( int pixel )\n", "label": 1}
{"id": 204, "input": "<s> package com . mcbans . mcbans . api ; public interface FlagHandler { public String getPermission ( ) ; public void run ( String playerName , String adminName , String reason ,", "gt": "String flags , String [ ] rawArgs ) ;", "prediction": "String flags ) ;\n", "label": 0}
{"id": 15639, "input": "<s> package org . eclipse . jface . dialogs ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Shell ; public class MessageDialogWithToggle extends MessageDialog { public static final String ALWAYS = \"always\" ; public static final String NEVER = \"never\" ; public static final String PROMPT = \"prompt\" ; public static MessageDialogWithToggle open ( int kind , Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key , int style ) { MessageDialogWithToggle dialog = new MessageDialogWithToggle ( parent , title , null , message , kind , getButtonLabels ( kind ) , 0 , toggleMessage , toggleState ) ; style &= SWT . SHEET ; dialog . setShellStyle ( dialog . getShellStyle ( ) | style ) ; dialog . prefStore = store ; dialog . prefKey = key ; dialog . open ( ) ; return dialog ; } public static MessageDialogWithToggle openError ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( ERROR , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openInformation ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( INFORMATION , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openOkCancelConfirm ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( CONFIRM , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openWarning ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( WARNING , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openYesNoCancelQuestion ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( QUESTION_WITH_CANCEL , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } public static MessageDialogWithToggle openYesNoQuestion ( Shell parent , String title , String message , String toggleMessage , boolean toggleState , IPreferenceStore store , String key ) { return open ( QUESTION , parent , title , message , toggleMessage , toggleState , store , key , SWT . NONE ) ; } private String prefKey = null ; private IPreferenceStore prefStore = null ; private Button toggleButton = null ; private String toggleMessage ; private boolean toggleState ; public MessageDialogWithToggle ( Shell parentShell , String dialogTitle , Image image , String message , int dialogImageType , String [ ] dialogButtonLabels , int defaultIndex , String toggleMessage , boolean toggleState ) { super ( parentShell , dialogTitle , image , message , dialogImageType , dialogButtonLabels , defaultIndex ) ; this . toggleMessage = toggleMessage ; this . toggleState = toggleState ; setButtonLabels ( dialogButtonLabels ) ; } protected void buttonPressed ( int buttonId ) { super . buttonPressed ( buttonId ) ; if ( buttonId != IDialogConstants . CANCEL_ID && toggleState && prefStore != null && prefKey != null ) { switch ( buttonId ) { case IDialogConstants . YES_ID : case IDialogConstants . YES_TO_ALL_ID : case IDialogConstants . PROCEED_ID : case IDialogConstants . OK_ID : prefStore . setValue ( prefKey , ALWAYS ) ; break ; case IDialogConstants . NO_ID : case IDialogConstants . NO_TO_ALL_ID : prefStore . setValue ( prefKey , NEVER ) ; break ; } } } protected void createButtonsForButtonBar ( Composite parent ) { final String [ ] buttonLabels = getButtonLabels ( ) ; final Button [ ] buttons = new Button [ buttonLabels . length ] ; final int defaultButtonIndex = getDefaultButtonIndex ( ) ; int suggestedId = IDialogConstants . INTERNAL_ID ; for ( int i = 0 ; i < buttonLabels . length ; i ++ ) { String label = buttonLabels [ i ] ; int id = mapButtonLabelToButtonID ( label , suggestedId ) ; if ( id == suggestedId ) { suggestedId ++ ; } Button button = createButton ( parent , id , label , defaultButtonIndex == i ) ; buttons [ i ] = button ; } setButtons ( buttons ) ; } protected Control createDialogArea ( Composite parent ) { Composite dialogAreaComposite = ( Composite ) super . createDialogArea ( parent ) ; setToggleButton ( createToggleButton ( dialogAreaComposite ) ) ; return dialogAreaComposite ; } protected Button createToggleButton ( Composite parent ) { final Button button = new Button ( parent , SWT . CHECK | SWT . LEFT ) ; GridData data = new GridData ( SWT . NONE ) ; data . horizontalSpan = 2 ; button . setLayoutData ( data ) ; button . setFont ( parent . getFont ( ) ) ; button . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { toggleState = button . getSelection ( ) ; } } ) ; return button ; } protected Button getToggleButton ( ) { return toggleButton ; } public IPreferenceStore getPrefStore ( ) { return prefStore ; } public String getPrefKey ( ) { return prefKey ; } public boolean getToggleState ( ) { return toggleState ; } public void setPrefKey ( String prefKey ) { this . prefKey = prefKey ; } public void setPrefStore ( IPreferenceStore prefStore ) { this . prefStore = prefStore ; } protected void setToggleButton ( Button button ) { if ( button == null ) { throw new NullPointerException ( \"A message dialog with", "gt": "toggle may not have a null toggle button.\" ) ;", "prediction": "no preference\" ) ;\n", "label": 1}
{"id": 2364, "input": "<s> package org . ofbiz . minilang . operation ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . ofbiz . base . util . MessageString ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . w3c . dom . Element ; public abstract class SimpleMapOperation { String fieldName ; boolean isProperty = false ; String message = null ; String propertyResource = null ; SimpleMapProcess simpleMapProcess ; public SimpleMapOperation ( Element element , SimpleMapProcess simpleMapProcess ) { Element failMessage = UtilXml . firstChildElement ( element , \"fail-message\" ) ; Element failProperty = UtilXml . firstChildElement ( element , \"fail-property\" ) ; if ( failMessage != null ) { this . message = failMessage . getAttribute ( \"message\" ) ; this . isProperty = false ; } else if ( failProperty != null ) { this . propertyResource = failProperty . getAttribute ( \"resource\" ) ; this . message = failProperty . getAttribute ( \"property\" ) ; this . isProperty = true ; } this . simpleMapProcess = simpleMapProcess ; this . fieldName = simpleMapProcess . getFieldName ( ) ; } public void addMessage ( List < Object > messages , ClassLoader loader , Locale locale ) { if ( ! isProperty && message != null ) { messages . add ( new MessageString ( message , fieldName , true ) ) ; } else if ( isProperty && propertyResource != null && message != null ) { String propMsg = UtilProperties . getMessage ( propertyResource , message , locale ) ; if ( UtilValidate . isEmpty ( propMsg ) ) { messages . add ( new MessageString ( \"Simple Map Processing error occurred, but no message was found, sorry.\" , fieldName , propertyResource , message , locale", "gt": ", true ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 15643, "input": "<s> package org . nuxeo . webengine . sites . models ; import org . nuxeo . theme . models . AbstractModel ; public class SearchModel extends AbstractModel { private String name ; private String description ; private String path ; private String author ; private String created ; private String modified ; public SearchModel ( String name , String description , String path , String author , String created , String modified ) { this . name = name ; this . description = description ; this . path = path ; this . author = author ; this . created = created ; this . modified = modified ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getPath ( ) { return path ; } public void setPath ( String path ) { this . path = path ; } public String getAuthor ( ) { return author ; } public void setAuthor ( String author ) {", "gt": "this . author = author ;", "prediction": "this . author = author ;\n", "label": 1}
{"id": 1619, "input": "<s> package com . sun . javadoc ; public interface MethodDoc extends ExecutableMemberDoc { boolean isAbstract ( ) ; Type returnType ( ) ; ClassDoc overriddenClass ( ) ; Type overriddenType ( ) ; MethodDoc overriddenMethod ( ) ;", "gt": "boolean overrides ( MethodDoc meth ) ;", "prediction": "}\n", "label": 0}
{"id": 15652, "input": "<s> package org . nuxeo . ecm . platform . localconfiguration . simple . operations ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationChain ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . operations . document . FetchDocument ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . test . CoreFeature ; import org . nuxeo . ecm . core . test . annotations . BackendType ; import org . nuxeo . ecm . core . test . annotations . Granularity ; import org . nuxeo . ecm . core . test . annotations . RepositoryConfig ; import org . nuxeo . ecm . platform . localconfiguration . simple . AbstractSimpleConfigurationTest ; import org . nuxeo . ecm . platform . localconfiguration . simple . LocalConfigurationRepositoryInit ; import org . nuxeo . runtime . test . runner . Deploy ; import org . nuxeo . runtime . test . runner . Features ; import org . nuxeo . runtime . test . runner . FeaturesRunner ; import com . google . inject . Inject ; @ RunWith ( FeaturesRunner . class ) @ Features ( CoreFeature . class ) @ RepositoryConfig ( type = BackendType . H2 , init = LocalConfigurationRepositoryInit . class , user = \"Administrator\" , cleanup = Granularity . METHOD ) @ Deploy ( { \"org.nuxeo.ecm.automation.core\" , \"org.nuxeo.ecm.platform.localconfiguration.simple\" } ) public class TestSimpleConfigurationSetOperations extends AbstractSimpleConfigurationTest { @ Inject AutomationService service ; @ Test public void shouldSetContextVariableFromSimpleConfiguration ( ) throws Exception { DocumentModel workspace = session . getDocument ( PARENT_WORKSPACE_REF ) ; Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( \"key1\" , \"value1\" ) ; parameters . put ( \"key2\" , \"value2\" ) ; initializeSimpleConfiguration ( workspace , parameters ) ; OperationContext ctx = new OperationContext ( session ) ; assertNotNull ( ctx ) ; OperationChain chain = new OperationChain ( \"testSimpleConfigurationChain\" ) ; chain . add ( FetchDocument . ID ) . set ( \"value\" , PARENT_WORKSPACE_REF ) ; chain . add ( SetSimpleConfigurationParameterAsVar . ID ) . set ( \"name\" , \"simpleConfigurationParameter\" ) . set ( \"parameterName\" , \"key2\" ) ; service . run ( ctx , chain ) ; String contextVariable = ( String ) ctx . get ( \"simpleConfigurationParameter\" ) ; assertNotNull ( contextVariable ) ; assertEquals ( \"value2\" , contextVariable ) ; } @ Test public void shouldNotUseDefaultValueIfParameterExists ( ) throws Exception { DocumentModel workspace = session . getDocument ( PARENT_WORKSPACE_REF ) ; Map < String , String > parameters = new HashMap < String , String > ( ) ; parameters . put ( \"key1\" , \"value1\" ) ; initializeSimpleConfiguration ( workspace , parameters ) ; OperationContext ctx = new OperationContext ( session ) ; assertNotNull ( ctx ) ; OperationChain chain = new OperationChain ( \"testSimpleConfigurationChain\" ) ; chain . add ( FetchDocument . ID", "gt": ") . set ( \"value\" , PARENT_WORKSPACE_REF ) ;", "prediction": ") . set ( \"value\" , PARENT_WORKSPACE_REF ) ;\n", "label": 1}
{"id": 93, "input": "<s> package p1 ; public abstract class U1 {", "gt": "abstract void f ( ) ;", "prediction": "public U1 ( )\n", "label": 0}
{"id": 15654, "input": "<s> package nehsics . math ; public class Average { private double a ; private int n ; public void add ( double x ) { n ++ ; a -= a / n - x / n ; } public double getAvg ( ) { return a ; } public double getNum ( ) { return n ; } public void clear ( ) { a", "gt": "= n = 0 ;", "prediction": "= 0 ;\n", "label": 1}
{"id": 2278, "input": "<s> package org . ofbiz . base . conversion ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . text . DecimalFormat ; import java . text . NumberFormat ; import java . text . ParseException ; import java . util . Locale ; import java . util . TimeZone ; import org . ofbiz . base . util . StringUtil ; public class NumberConverters implements ConverterLoader { protected static Number fromString ( String str , Locale locale ) throws ConversionException { NumberFormat nf = NumberFormat . getNumberInstance ( locale ) ; if ( nf instanceof DecimalFormat ) { ( ( DecimalFormat ) nf ) . setParseBigDecimal ( true ) ; } try { return nf . parse ( str ) ; } catch ( ParseException e ) { throw new ConversionException ( e ) ; } } public static abstract class AbstractStringToNumberConverter < N extends Number > extends AbstractNumberConverter < String , N > { public AbstractStringToNumberConverter ( Class < N > targetClass ) { super ( String . class , targetClass ) ; } public N convert ( String obj , Locale locale , TimeZone timeZone ) throws ConversionException { String trimStr = StringUtil . removeSpaces ( obj ) ; if ( trimStr . length ( ) == 0 ) { return null ; } return convert ( fromString ( trimStr , locale ) ) ; } protected abstract N convert ( Number number ) throws ConversionException ; } public static abstract class AbstractNumberConverter < S , T > extends AbstractLocalizedConverter < S , T > { protected AbstractNumberConverter ( Class < S > sourceClass , Class < T > targetClass ) { super ( sourceClass , targetClass ) ; } public T convert ( S obj , Locale locale , TimeZone timeZone , String formatString ) throws ConversionException { return convert ( obj , locale , null ) ; } } public static abstract class AbstractNumberToStringConverter < N extends Number > extends AbstractNumberConverter < N , String > { public AbstractNumberToStringConverter ( Class < N > sourceClass ) { super ( sourceClass , String . class ) ; } public String convert ( N obj ) throws ConversionException { return obj . toString ( ) ; } public String convert ( N obj , Locale locale , TimeZone timeZone ) throws ConversionException { return format ( obj , NumberFormat . getNumberInstance ( locale ) ) ; } protected abstract String format ( N obj , NumberFormat nf ) throws ConversionException ; } public static class GenericNumberToDouble < N extends Number > extends AbstractConverter < N , Double > { public GenericNumberToDouble ( Class < N > sourceClass ) { super ( sourceClass , Double . class ) ; } public Double convert ( N obj ) throws ConversionException { return obj . doubleValue ( ) ; } } public static class GenericNumberToFloat < N extends Number > extends AbstractConverter < N , Float > { public GenericNumberToFloat ( Class < N > sourceClass ) { super ( sourceClass , Float . class ) ; } public Float convert ( N obj ) throws ConversionException { return obj . floatValue ( ) ; } } public static class GenericNumberToInteger < N extends Number >", "gt": "extends AbstractConverter < N , Integer >", "prediction": "extends AbstractConverter < N , Integer >\n", "label": 0}
{"id": 15662, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . Attribute ; import org . fuzzydb . attrs . util . Point2D ; import org . fuzzydb . attrs . util . Range2D ; public abstract class RangePreference2D extends Attribute implements IRange2D { public Point2D getMax ( ) { return range2d . getMax ( ) ; } public Point2D getMin ( ) { return range2d . getMin ( ) ; } public RangePreference2D ( int", "gt": "attrId , Point2D min , Point2D max )", "prediction": "min )\n", "label": 1}
{"id": 1870, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; import static com . sun . tools . javac . code . Flags . ABSTRACT ; import static com . sun . tools . javac . code . Flags . FINAL ; import static com . sun . tools . javac . code . Flags . PUBLIC ; import static com . sun . tools . javac . code . Flags . STATIC ; import static com . sun . tools . javac . code . TypeTags . VOID ; import com . redhat . ceylon . compiler . java . util . Util ; import com . redhat . ceylon . compiler . typechecker . model . Annotation ; import com . redhat . ceylon . compiler . typechecker . model . FunctionalParameter ; import com . redhat . ceylon . compiler . typechecker . model . Method ; import com . redhat . ceylon . compiler . typechecker . model . MethodOrValue ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . ParameterList ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . ProducedTypedReference ; import com . redhat . ceylon . compiler . typechecker . model . TypeDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . TypeParameter ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . Value ; import com . redhat . ceylon . compiler . typechecker . tree . Tree ; import com . sun . tools . javac . code . Flags ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCAnnotation ; import com . sun . tools . javac . tree . JCTree . JCBlock ; import com . sun . tools . javac . tree . JCTree . JCExpression ; import com . sun . tools . javac . tree . JCTree . JCStatement ; import com . sun . tools . javac . tree . JCTree . JCTypeParameter ; import com . sun . tools . javac . tree . JCTree . JCVariableDecl ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . util . ListBuffer ; import com . sun . tools . javac . util . Name ; public class MethodDefinitionBuilder { private final AbstractTransformer gen ; private final String name ; private long modifiers ; private boolean isOverride ; private boolean isAbstract ; private JCExpression resultTypeExpr ; private List < JCAnnotation > resultTypeAnnos ; private final ListBuffer < JCAnnotation > annotations = ListBuffer . lb ( ) ; private final ListBuffer < JCTypeParameter > typeParams = ListBuffer . lb ( ) ; private final ListBuffer <", "gt": "JCExpression > typeParamAnnotations = ListBuffer . lb ( ) ;", "prediction": "JCTreeExpression > annotations = ListBuffer . lb ( ) ;\n", "label": 0}
{"id": 15669, "input": "<s> package org . restlet . ext . webdav ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import org . restlet . engine . Method ; import org .", "gt": "restlet . service . MetadataService ;", "prediction": "restlet . engine . Request ;\n", "label": 1}
{"id": 181, "input": "<s> package org . ofbiz . base . util ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Locale ; import com . ibm . icu . text . RuleBasedNumberFormat ; public class UtilNumber { public static String module = UtilNumber . class . getName ( ) ; private static final String arithmeticPropertiesFile = \"arithmetic.properties\" ; private static final int DEFAULT_BD_SCALE = 2 ; private static final int DEFAULT_BD_ROUNDING_MODE = BigDecimal . ROUND_HALF_UP ; public static int getBigDecimalScale ( String file , String property ) { if ( UtilValidate . isEmpty ( file ) ) return DEFAULT_BD_SCALE ; if ( UtilValidate . isEmpty ( property ) ) return DEFAULT_BD_SCALE ; int scale = - 1 ; String value = UtilProperties . getPropertyValue ( file , property ) ; if ( value != null ) { try { scale = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { } } if ( scale == - 1 ) { Debug . logWarning ( \"Could not set decimal precision from \" + property + \"=\" + value + \". Using default scale of \" + DEFAULT_BD_SCALE + \".\" , module ) ; scale = DEFAULT_BD_SCALE ; } return scale ; } public static int getBigDecimalScale ( String property ) { return getBigDecimalScale ( arithmeticPropertiesFile , property ) ; } public static int getBigDecimalRoundingMode ( String file , String property ) { if ( UtilValidate . isEmpty ( file ) ) return DEFAULT_BD_SCALE ; if ( UtilValidate . isEmpty ( property ) ) return DEFAULT_BD_ROUNDING_MODE ; String value = UtilProperties . getPropertyValue ( file , property ) ; int mode = roundingModeFromString ( value ) ; if ( mode == - 1 ) { Debug . logWarning ( \"Could not set decimal rounding mode from \" + property + \"=\" + value + \". Using default mode of \" + DEFAULT_BD_SCALE + \".\" , module ) ; return DEFAULT_BD_ROUNDING_MODE ; } return mode ; } public static int getBigDecimalRoundingMode ( String property ) { return getBigDecimalRoundingMode ( arithmeticPropertiesFile , property ) ; } public static int roundingModeFromString ( String value ) { if ( value == null ) return - 1 ; value = value . trim ( ) ; if ( \"ROUND_HALF_UP\" . equals ( value ) ) return BigDecimal . ROUND_HALF_UP ; else if ( \"ROUND_HALF_DOWN\" . equals ( value ) ) return BigDecimal . ROUND_HALF_DOWN ; else if ( \"ROUND_HALF_EVEN\" . equals ( value ) ) return BigDecimal . ROUND_HALF_EVEN ; else if ( \"ROUND_UP\" . equals ( value ) ) return BigDecimal . ROUND_UP ; else if ( \"ROUND_DOWN\" . equals ( value ) ) return BigDecimal . ROUND_DOWN ; else if ( \"ROUND_CEILING\" . equals ( value ) ) return BigDecimal . ROUND_CEILING ; else if ( \"ROUND_FLOOR\" . equals ( value ) ) return BigDecimal . ROUND_FLOOR ; else if ( \"ROUND_UNNECCESSARY\" . equals ( value ) ) return BigDecimal . ROUND_UNNECESSARY ; return - 1 ; } public static final String ruleSet_en_US = \"%dollars-and-cents:\\n\" + \"    x.0: << [and >%%cents>];\\n\" + \"    0.x: >%%cents>;\\n\" + \"    0: zero dollars; one dollar; =%%main= dollars;\\n\" + \"%%main:\\n\" + \"    zero; one; two; three; four; five; six; seven; eight; nine;\\n\" + \"    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;\\n\" + \"        seventeen; eighteen; nineteen;\\n\" + \"    20: twenty[->>];\\n\" + \"    30: thirty[->>];\\n\" + \"    40: forty[->>];\\n\" + \"    50: fifty[->>];\\n\" + \"    60: sixty[->>];\\n\" + \"    70: seventy[->>];\\n\" + \"    80: eighty[->>];\\n\" + \"    90: ninety[->>];\\n\" + \"    100: << hundred[ >>];\\n\" + \"    1000: << thousand[ >>];\\n\" + \"    1,000,000: << million[ >>];\\n\" + \"    1,000,000,000: << billion[ >>];\\n\" + \"    1,000,000,000,000: << trillion[ >>];\\n\" + \"    1,000,000,000,000,000: =#,##0=;\\n\" + \"%%cents:\\n\" + \"    100: <%%main< cent[s];\\n\" + \"%dollars-and-hundredths:\\n\" + \"    x.0: <%%main< and >%%hundredths>/100;\\n\" + \"%%hundredths:\\n\" + \"    100: <00<;\\n\" ; public static final String ruleSet_th_TH = \"%bahts-and-stangs:\\n\" + \"    x.0: << [and >%%stangs>];\\n\" + \"    0.x: >%%stangs>;\\n\" + \"    0: zero bahts; one baht; =%%main= bahts;\\n\" + \"%%main:\\n\" + \"    zero; one; two; three; four; five; six; seven; eight; nine;\\n\" + \"    ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;\\n\" + \"        seventeen; eighteen; nineteen;\\n\" + \"    20: twenty[->>];\\n\" + \"    30: thirty[->>];\\n\" + \"    40: forty[->>];\\n\" + \"    50: fifty[->>];\\n\" + \"    60: sixty[->>];\\n\" + \"    70: seventy[->>];\\n\" + \"    80: eighty[->>];\\n\" + \"    90: ninety[->>];\\n\" + \"    100: << hundred[ >>];\\n\" + \"    1000: << thousand[ >>];\\n\" + \"    1,000,000: << million[ >>];\\n\" + \"    1,000,000,000: << billion[ >>];\\n\" + \"    1,000,000,000,000: << trillion[ >>];\\n\" + \"    1,000,000,000,000,000: =#,##0=;\\n\" + \"%%stangs:\\n\" + \"    100: <%%main< stang[s];\\n\" + \"%bahts-and-hundredths:\\n\" + \"    x.0: <%%main< and >%%hundredths>/100;\\n\" + \"%%hundredths:\\n\" + \"    100: <00<;\\n\" ; public static HashMap < Locale , String > rbnfRuleSets ; static { rbnfRuleSets", "gt": "= new HashMap < Locale , String > ( ) ;", "prediction": "= new HashMap < Locale , String > ( ) ;\n", "label": 0}
{"id": 15671, "input": "<s> package org . eclipse . rap . demo . controls ; import java . util . Iterator ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Spinner ; import org . eclipse . swt . widgets . Text ; public class CTabFolderTab extends ExampleTab { protected static final int MAX_ITEMS = 3 ; private static final String PROP_CONTEXT_MENU = \"contextMenu\" ; private static final String CTAB_IMAGE_PATH = \"resources/newfolder_wiz.gif\" ; private Image ctabImage ; private CTabFolder folder ; private boolean showClose ; private boolean unselectedCloseVisible ; private boolean setImage ; private boolean unselectedImageVisible ; private boolean showTopRightControl ; private boolean minVisible ; private boolean maxVisible ; private int selFgIndex ; private int selBgIndex ; private int tabHeight = - 1 ; private boolean showSelectionBgGradient = false ; private boolean showSelectionBgImage = false ; private boolean customFontOnItem ; private static Font customFont = Graphics . getFont ( \"Courier\" , 12 , SWT . ITALIC ) ; private Button [ ] tabRadios ; public CTabFolderTab ( ) { super ( \"CTabFolder\" ) ; } @ Override protected void createStyleControls ( Composite parent ) { createStyleButton ( \"FLAT\" , SWT . FLAT ) ; createStyleButton ( \"BORDER\" , SWT . BORDER ) ; createStyleButton ( \"TOP\" , SWT . TOP ) ; createStyleButton ( \"BOTTOM\" , SWT . BOTTOM ) ; createStyleButton ( \"CLOSE\" , SWT . CLOSE ) ; createStyleButton ( \"SINGLE\" , SWT . SINGLE ) ; createStyleButton ( \"MULTI\" , SWT . MULTI ) ; createVisibilityButton ( ) ; createEnablementButton ( ) ; createFontChooser ( ) ; createFgColorButton ( ) ; createBgColorButton ( ) ; createSelectionFgColorButton ( ) ; createSelectionBgColorButton ( ) ; createSelectionBgGradientButton ( ) ; createSelectionBgImageButton ( ) ; createBgImageButton ( ) ; createTabHeightControl ( styleComp ) ; createTopRightControl ( styleComp ) ; final Button cbMin = createPropertyButton ( \"Minimize visible\" , SWT . CHECK ) ; cbMin . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { minVisible = cbMin . getSelection ( ) ; updateProperties ( ) ; } } ) ; final Button cbMax = createPropertyButton ( \"Maximize visible\" , SWT . CHECK ) ; cbMax . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { maxVisible = cbMax . getSelection ( ) ; updateProperties ( ) ; } } ) ; tabRadios = new Button [ MAX_ITEMS ] ; for ( int i = 0 ; i < MAX_ITEMS ; i ++ ) { final int index = i ; String rbText = \"Select \" + folder . getItem ( index ) . getText ( ) ; tabRadios [ i", "gt": "] = createPropertyButton ( rbText , SWT . RADIO ) ;", "prediction": "] = rbText ;\n", "label": 1}
{"id": 2273, "input": "<s> package org . ofbiz . sql ; import org . ofbiz . base . lang . SourceMonitored ; @ SourceMonitored public final class CountAllFunction extends StaticValue { private final String tableName ; public CountAllFunction ( String tableName ) { this . tableName = tableName ; } @ Override public void accept ( Visitor visitor ) { visitor . visit ( this ) ; } @ Override public String getDefaultName ( ) { return \"COUNT\" ; } public String getTableName ( ) { return tableName ; } @ Override public boolean equals ( Object o ) { if ( o instanceof CountAllFunction ) { CountAllFunction other = ( CountAllFunction ) o ; return equalsHelper ( tableName , other . tableName ) ; } else { return false ; } } public StringBuilder appendTo ( StringBuilder sb ) { sb . append ( \"COUNT(\" ) ; if ( tableName != null ) { sb . append ( tableName ) . append ( '.' ) ; } sb .", "gt": "append ( \"*)\" ) ;", "prediction": "append ( ':' ) ;\n", "label": 0}
{"id": 15674, "input": "<s> package org . eclipse . ui . forms ; import java . util . Vector ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . forms . widgets . FormToolkit ; import org . eclipse . ui . forms . widgets . ScrolledForm ; public class ManagedForm implements IManagedForm { private Object input ; private ScrolledForm form ; private FormToolkit toolkit ; private Object container ; private boolean ownsToolkit ; private boolean initialized ; private Vector parts = new Vector ( ) ; public ManagedForm ( Composite parent ) { toolkit = new FormToolkit ( parent . getDisplay ( ) ) ; ownsToolkit = true ; form = toolkit . createScrolledForm ( parent ) ; } public ManagedForm ( FormToolkit toolkit , ScrolledForm form ) { this . form = form ; this . toolkit = toolkit ; } public void addPart ( IFormPart part ) { parts . add ( part ) ; part . initialize ( this ) ; } public void removePart ( IFormPart part ) { parts . remove ( part ) ; } public IFormPart [ ] getParts ( ) { return ( IFormPart [ ] ) parts . toArray ( new IFormPart [ parts . size ( ) ] ) ; } public FormToolkit getToolkit ( ) { return toolkit ; } public ScrolledForm getForm ( ) { return form ; } public void reflow ( boolean changed ) { form . reflow ( changed ) ; } public void fireSelectionChanged ( IFormPart part , ISelection selection ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart cpart = ( IFormPart ) parts . get ( i ) ; if ( part . equals ( cpart ) ) continue ; if ( cpart instanceof IPartSelectionListener ) { ( ( IPartSelectionListener ) cpart ) . selectionChanged ( part , selection ) ; } } } public void initialize ( ) { if ( initialized ) return ; for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; part . initialize ( this ) ; } initialized = true ; } public void dispose ( ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; part . dispose ( ) ; } if ( ownsToolkit ) { toolkit . dispose ( ) ; } } public void refresh ( ) { Thread t = Thread . currentThread ( ) ; Thread dt = toolkit . getColors ( ) . getDisplay ( ) . getThread ( ) ; if ( t . equals ( dt ) ) doRefresh ( ) ; else { toolkit . getColors ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { public void run ( ) { doRefresh ( ) ; } } ) ; } } private void doRefresh ( ) { int nrefreshed = 0 ; for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isStale ( ) ) { part . refresh ( ) ; nrefreshed ++ ; } } if ( nrefreshed > 0 ) form . reflow ( true ) ; } public void commit ( boolean onSave ) { for ( int i = 0 ; i < parts . size ( ) ; i ++ ) { IFormPart part = ( IFormPart ) parts . get ( i ) ; if ( part . isDirty ( ) ) part . commit ( onSave ) ; } } public boolean setInput ( Object input ) { boolean pageResult = false ; this . input = input ; for ( int i = 0 ;", "gt": "i < parts . size ( ) ;", "prediction": "i < parts . size ( ) ;\n", "label": 1}
{"id": 7331, "input": "<s> package org . ofbiz . minilang . method . envops ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class ClearField extends MethodOperation { private final FlexibleMapAccessor < Object > fieldFma ; public ClearField ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"field\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"field\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } this . fieldFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"field\" ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { fieldFma . put ( methodContext . getEnvMap ( ) , null ) ; return true ; }", "gt": "@ Override public String toString ( )", "prediction": "}\n", "label": 0}
{"id": 15678, "input": "<s> package org . jscsi . target . scsi . sense . senseDataDescriptor . senseKeySpecific ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . sense . SenseData ; import org . jscsi . target . scsi . sense . SenseKey ; import org . jscsi . target . scsi . sense . senseDataDescriptor . CommandSpecificSenseDataDescriptor ; import org . jscsi . target . util . BitManip ; import org . jscsi . target . util . ReadWrite ; public class SegmentPointerSenseKeySpecificData extends SenseKeySpecificData { private final boolean segmentDescriptor ; private final boolean bitPointerValid ; private final short fieldPointer ; private final int bitPointer ; public SegmentPointerSenseKeySpecificData ( final boolean senseKeySpecificDataValid , final boolean segmentDescriptor , final boolean bitPointerValid , final int bitPointer , final int fieldPointer ) { super ( senseKeySpecificDataValid ) ; this . segmentDescriptor = segmentDescriptor ; this . bitPointerValid = bitPointerValid ; this . bitPointer = bitPointer ; this . fieldPointer = ( short ) fieldPointer ; } @ Override protected void serializeSpecificFields ( final ByteBuffer byteBuffer , final int index ) { byte b = byteBuffer . get ( index ) ; b = BitManip . getByteWithBitSet ( b , 5 , segmentDescriptor ) ; b = BitManip . getByteWithBitSet ( b , 3 , bitPointerValid ) ; b &= ( bitPointer & 7 ) ; byteBuffer . put ( index , b ) ; ReadWrite . writeTwoByteInt ( byteBuffer , fieldPointer , byteBuffer .", "gt": "position ( ) ) ;", "prediction": "get ( index ) ) ;\n", "label": 1}
{"id": 6767, "input": "<s> package org . ofbiz . minilang ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . ServiceLoader ; import java . util . Set ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Assert ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . ofbiz . minilang . method . MethodOperation . DeprecatedOperation ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ModelService ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public final class SimpleMethod extends MiniLangElement { public static final String module = SimpleMethod . class . getName ( ) ; private static final String err_resource = \"MiniLangErrorUiLabels\" ; private static final String [ ] DEPRECATED_ATTRIBUTES = { \"parameter-map-name\" , \"locale-name\" , \"delegator-name\" , \"security-name\" , \"dispatcher-name\" , \"user-login-name\" } ; private static final Map < String , MethodOperation . Factory < MethodOperation > > methodOperationFactories ; private static final UtilCache < String , Map < String , SimpleMethod > > simpleMethodsDirectCache = UtilCache . createUtilCache ( \"minilang.SimpleMethodsDirect\" , 0 , 0 ) ; private static final UtilCache < String , Map < String , SimpleMethod > > simpleMethodsResourceCache = UtilCache . createUtilCache ( \"minilang.SimpleMethodsResource\" , 0 , 0 ) ; static { Map < String , MethodOperation . Factory < MethodOperation > > mapFactories = new HashMap < String , MethodOperation . Factory < MethodOperation > > ( ) ; Iterator < MethodOperation . Factory < MethodOperation > > it = UtilGenerics . cast ( ServiceLoader . load ( MethodOperation . Factory . class , SimpleMethod . class . getClassLoader ( ) ) . iterator ( ) ) ; while ( it . hasNext ( ) ) { MethodOperation . Factory < MethodOperation > factory = it . next ( ) ; mapFactories . put ( factory . getName ( ) , factory ) ; } methodOperationFactories = Collections . unmodifiableMap ( mapFactories ) ; } private static boolean autoCorrect ( Element element ) { boolean elementModified = false ; for ( int i = 0 ; i < DEPRECATED_ATTRIBUTES . length ; i ++ ) { if ( ! element . getAttribute ( DEPRECATED_ATTRIBUTES [ i ] ) . isEmpty ( ) ) { element . removeAttribute ( DEPRECATED_ATTRIBUTES [ i ] ) ; elementModified = true ; } } return elementModified ; } private static void compileAllSimpleMethods ( Element rootElement , Map < String , SimpleMethod > simpleMethods , String location ) throws MiniLangException { for ( Element simpleMethodElement : UtilXml . childElementList ( rootElement , \"simple-method\" ) ) { SimpleMethod simpleMethod = new SimpleMethod ( simpleMethodElement , location ) ; if ( simpleMethods . containsKey ( simpleMethod . getMethodName ( ) ) ) { MiniLangValidate . handleError ( \"Duplicate method name found\" , simpleMethod , simpleMethodElement ) ; } simpleMethods . put ( simpleMethod . getMethodName ( ) , simpleMethod ) ; } } private static Map < String , SimpleMethod > getAllDirectSimpleMethods ( String name , String content , String fromLocation ) throws MiniLangException { if ( UtilValidate . isEmpty ( fromLocation ) ) { fromLocation = \"<location not known>\" ; } Map < String , SimpleMethod > simpleMethods = FastMap . newInstance ( ) ; Document document = null ; try { document = UtilXml . readXmlDocument ( content , true , true ) ; } catch ( Exception e ) { throw new MiniLangException ( \"Could not read SimpleMethod XML document [\" + name + \"]: \" , e ) ; } compileAllSimpleMethods ( document . getDocumentElement ( ) , simpleMethods , fromLocation ) ; return simpleMethods ; } private static Map < String , SimpleMethod > getAllSimpleMethods ( URL xmlURL ) throws MiniLangException { Map < String , SimpleMethod > simpleMethods = FastMap . newInstance ( ) ; Document document = null ; try { document = UtilXml . readXmlDocument ( xmlURL , true , true ) ; } catch ( Exception e ) { throw new MiniLangException ( \"Could not read SimpleMethod XML document", "gt": "[\" + xmlURL + \"]: \" , e ) ;", "prediction": "[\" + name + \"]: \" , e ) ;\n", "label": 0}
{"id": 15686, "input": "<s> package org . eclipse . jface . tests . fieldassist ; import org . eclipse . jface . fieldassist . ControlDecoration ; import org . eclipse . jface . fieldassist . FieldDecorationRegistry ; import org . eclipse . swt . SWT ; public abstract class FieldAssistTestCase extends AbstractFieldAssistTestCase { static final String SAMPLE_CONTENT = \"s\" ; static final char ACTIVATE_CHAR = 'i' ; static final char EXTRA_CHAR = 'b' ; public void testDecorationIsVisible ( ) { AbstractFieldAssistWindow window = getFieldAssistWindow ( ) ; window . setPropagateKeys ( false ) ; window . setAutoActivationCharacters ( new char [ ] { ACTIVATE_CHAR } ) ; window . open ( ) ; assertOneShellUp ( ) ; ControlDecoration decoration = new ControlDecoration ( getFieldAssistWindow ( ) . getFieldAssistControl ( ) , SWT . RIGHT ) ; decoration . setImage ( FieldDecorationRegistry . getDefault ( ) . getFieldDecoration ( FieldDecorationRegistry . DEC_INFORMATION ) . getImage ( ) ) ; decoration . setDescriptionText ( \"foo\" ) ; spinEventLoop ( ) ; assertTrue ( \"1.0\" , decoration . isVisible ( ) ) ; decoration . hide ( ) ; assertFalse ( \"1.1\" , decoration . isVisible ( ) ) ; decoration . setShowOnlyOnFocus ( true ) ; sendFocusElsewhere ( ) ; sendFocusInToControl ( ) ; spinEventLoop ( ) ; assertFalse ( \"1.2\" , decoration . isVisible ( ) ) ; decoration . show ( ) ; assertTrue ( \"1.3\" , decoration . isVisible ( ) ) ; sendFocusElsewhere ( ) ; spinEventLoop ( ) ; assertFalse ( \"1.4\" ,", "gt": "decoration . isVisible ( ) ) ;", "prediction": "decoration . isVisible ( ) ) ;\n", "label": 1}
{"id": 8158, "input": "<s> package org . ofbiz . base . conversion . test ; import org . ofbiz . base . conversion . Converter ; import org . ofbiz . base . conversion . DateTimeConverters ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . test . GenericTestCaseBase ; @ SourceMonitored public class DateTimeTests extends GenericTestCaseBase { public DateTimeTests ( String name ) { super ( name ) ; } public static < S , T > void assertConversion ( String label , Converter < S , T > converter , S source , T target ) throws Exception { assertTrue ( label + \" can convert\" , converter . canConvert ( source . getClass ( ) , target . getClass ( ) ) ) ; assertEquals ( label + \" converted\" , target , converter . convert ( source ) ) ; } public void testDateTimeConverters ( ) throws Exception { long currentTime = System . currentTimeMillis ( ) ; java . util . Date utilDate = new java . util . Date ( currentTime ) ; assertConversion ( \"DateToLong\" , new DateTimeConverters . DateToLong ( ) , utilDate , currentTime ) ; assertConversion ( \"DateToSqlDate\" , new DateTimeConverters . DateToSqlDate ( ) , utilDate , new java . sql . Date ( currentTime ) ) ; assertConversion ( \"DateToString\" , new DateTimeConverters . DateToString ( ) , utilDate , utilDate . toString ( ) ) ; assertConversion ( \"DateToTimestamp\" , new DateTimeConverters . DateToTimestamp ( ) , utilDate , new java . sql . Timestamp ( currentTime ) ) ; java . sql . Date sqlDate = new java .", "gt": "sql . Date ( currentTime ) ;", "prediction": "sql . Date ( currentTime ) ;\n", "label": 0}
{"id": 15692, "input": "<s> package br . org . archimedes . intersectors ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . util . Collection ; import java . util . Collections ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . exceptions . InvalidArgumentException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Point ; public class LineLineIntersectorTest extends Tester { @ Test public void simpleLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( - 1 , 3 , 10 , 3 ) ; Point p0 = new Point ( 3 , 3 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertCollectionTheSame ( Collections . singleton ( p0 ) , intersections ) ; } @ Test public void paralelsLinesIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 1 , 1 , 10 , 10 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void sameLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 2 , 2 , 12 , 12 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void subLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 3 , 3 , 10 , 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void interLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 10 , 10 , 15 , 15 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void noLineIntersectionWouldIfOneExtended ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 4 , 3 , 3 , - 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void noLineIntersectionWouldIfTwoExtended ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 12 , 12 ) ; Line line2 = new Line ( 0 , 0 , 3 , - 10 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertTrue ( intersections . isEmpty ( ) ) ; } @ Test public void onePointParallelLineIntersection ( ) throws InvalidArgumentException , NullArgumentException { LineLineIntersector lli = new LineLineIntersector ( ) ; Line line1 = new Line ( 2 , 2 , 3 , 3 ) ; Line line2 = new Line ( 3 , 3 , 4 , 4 ) ; Point p0 = new Point ( 3 , 3 ) ; Collection < Point > intersections = lli . getIntersections ( line1 , line2 ) ; assertCollectionTheSame ( Collections . singleton ( p0 ) , intersections ) ; }", "gt": "@ Test public void onePointOrthogonalLineIntersection ( ) throws InvalidArgumentException , NullArgumentException", "prediction": "@ Test public void onePointParallelLineIntersection ( ) throws InvalidArgumentException , NullArgumentException\n", "label": 1}
{"id": 3099, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . Content ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class HtmlDocument extends Content { private List < Content > docContent = Collections . < Content > emptyList ( ) ; public HtmlDocument ( Content docType , Content docComment , Content htmlTree ) { docContent = new ArrayList < Content > ( ) ; addContent ( nullCheck ( docType ) ) ; addContent ( nullCheck ( docComment ) ) ; addContent ( nullCheck ( htmlTree ) ) ; } public HtmlDocument ( Content docType , Content htmlTree ) { docContent = new ArrayList < Content > ( ) ; addContent ( nullCheck ( docType ) ) ; addContent ( nullCheck ( htmlTree ) ) ; } public void addContent ( Content htmlContent ) { if ( htmlContent . isValid ( ) ) docContent . add ( htmlContent ) ; }", "gt": "public void addContent ( String stringContent )", "prediction": "}\n", "label": 0}
{"id": 15694, "input": "<s> package org . eclipse . ui . tests . dialogs ; import java . util . Iterator ; import junit . framework . TestCase ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . help . WorkbenchHelp ; import org . eclipse . ui . internal . IWorkbenchHelpContextIds ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . tests . harness . util . DialogCheck ; public class UIPreferencesAuto extends TestCase { public UIPreferencesAuto ( String name ) { super ( name ) ; } protected Shell getShell ( ) { return DialogCheck . getShell ( ) ; } private PreferenceDialog getPreferenceDialog ( String id ) { PreferenceDialogWrapper dialog = null ; PreferenceManager manager = WorkbenchPlugin . getDefault ( ) . getPreferenceManager ( ) ; if ( manager != null ) { dialog = new PreferenceDialogWrapper ( getShell ( ) , manager ) ; dialog . create ( ) ; WorkbenchHelp . setHelp ( dialog . getShell ( ) , IWorkbenchHelpContextIds . PREFERENCE_DIALOG ) ; for ( Iterator iterator = manager . getElements ( PreferenceManager . PRE_ORDER ) . iterator ( ) ; iterator . hasNext ( ) ; ) { IPreferenceNode node = ( IPreferenceNode ) iterator . next ( ) ; if ( node . getId ( ) . equals ( id ) ) { dialog . showPage ( node ) ; break ; } } } return dialog ; } public void testWorkbenchPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.Workbench\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testAppearancePref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.Views\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testDefaultTextEditorPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.TextEditor\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testFileEditorsPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.FileEditors\" ) ; DialogCheck . assertDialogTexts ( dialog , this ) ; } public void testLocalHistoryPref ( ) { Dialog dialog = getPreferenceDialog ( \"org.eclipse.ui.preferencePages.FileStates\" ) ;", "gt": "DialogCheck . assertDialogTexts ( dialog , this ) ;", "prediction": "DialogCheck . assertDialogTexts ( dialog , this ) ;\n", "label": 1}
{"id": 4796, "input": "<s> package com . redhat . ceylon . ceylondoc ; import java . io . IOException ; import java . io . Writer ; import com . redhat . ceylon . compiler . typechecker . model . Module ; public class Search extends CeylonDoc { public Search ( Module module , CeylonDocTool tool , Writer writer ) { super ( module , tool , writer ) ; } public void generate ( ) throws IOException { htmlHead ( \"Search\" ) ; writeNav ( module , null , DocType . SEARCH ) ; include ( \"resources/search.html\" ) ; close ( \"body\" , \"html\" ) ; }", "gt": "@ Override protected Object getFromObject ( )", "prediction": "}\n", "label": 0}
{"id": 15705, "input": "<s> package org . eclipse . ui . part ; import java . util . Arrays ; import java . util . List ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IMenuManager ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . WorkbenchImages ; import org . eclipse . ui . internal . WorkbenchMessages ; public class DrillDownAdapter implements ISelectionChangedListener { private TreeViewer fChildTree ; private DrillStack fDrillStack ; private Action homeAction ; private Action backAction ; private Action forwardAction ; public DrillDownAdapter ( TreeViewer tree ) { fDrillStack = new DrillStack ( ) ; fChildTree = tree ; } public void addNavigationActions ( IMenuManager manager ) { createActions ( ) ; manager . add ( homeAction ) ; manager . add ( backAction ) ; manager . add ( forwardAction ) ; updateNavigationButtons ( ) ; } public void addNavigationActions ( IToolBarManager toolBar ) { createActions ( ) ; toolBar . add ( homeAction ) ; toolBar . add ( backAction ) ; toolBar . add ( forwardAction ) ; updateNavigationButtons ( ) ; } public boolean canExpand ( Object element ) { return fChildTree . isExpandable ( element ) ; } public boolean canGoBack ( ) { return fDrillStack . canGoBack ( ) ; } public boolean canGoHome ( ) { return fDrillStack . canGoHome ( ) ; } public boolean canGoInto ( ) { IStructuredSelection oSelection = ( IStructuredSelection ) fChildTree . getSelection ( ) ; if ( oSelection == null || oSelection . size ( ) != 1 ) { return false ; } Object anElement = oSelection . getFirstElement ( ) ; return canExpand ( anElement ) ; } private void createActions ( ) { if ( homeAction != null ) { return ; } homeAction = new Action ( WorkbenchMessages . get ( ) . GoHome_text ) { public void run ( ) { goHome ( ) ; } } ; homeAction . setToolTipText ( WorkbenchMessages . get ( ) . GoHome_toolTip ) ; homeAction . setImageDescriptor ( WorkbenchImages . getImageDescriptor ( ISharedImages . IMG_ETOOL_HOME_NAV ) ) ; ISharedImages images = PlatformUI . getWorkbench ( ) . getSharedImages ( ) ; backAction = new Action ( WorkbenchMessages . get ( ) . GoBack_text ) { public void run ( ) { goBack ( ) ; } } ; backAction . setToolTipText ( WorkbenchMessages . get ( ) . GoBack_toolTip ) ; backAction . setImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_BACK ) ) ; backAction . setDisabledImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_BACK_DISABLED ) ) ; forwardAction = new Action ( WorkbenchMessages . get ( ) . GoInto_text ) { public void run ( ) { goInto ( ) ; } } ; forwardAction . setToolTipText ( WorkbenchMessages . get ( ) . GoInto_toolTip ) ; forwardAction . setImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_FORWARD ) ) ; forwardAction . setDisabledImageDescriptor ( images . getImageDescriptor ( ISharedImages . IMG_TOOL_FORWARD_DISABLED ) ) ; fChildTree . addSelectionChangedListener ( this ) ; updateNavigationButtons ( ) ; } private void expand ( List items ) { fChildTree . setExpandedElements ( items . toArray ( ) ) ; } private List getExpanded ( ) { return Arrays . asList ( fChildTree . getExpandedElements ( ) ) ; } public void goBack ( ) { Object currentInput = fChildTree . getInput ( ) ; DrillFrame oFrame = fDrillStack . goBack ( ) ; Object input = oFrame . getElement ( ) ; fChildTree", "gt": ". setInput ( input ) ;", "prediction": ". addSelectionChangedListener ( this ) ;\n", "label": 1}
{"id": 2158, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Sheep ; public interface LizaSheep extends Sheep { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities", "gt": "( double x , double y , double z ) ;", "prediction": "( HashSet < Byte > transparent , int maxDistance ) ;\n", "label": 0}
{"id": 15708, "input": "<s> package org . apache . lucene . store . db ; import com . sleepycat . db . EnvironmentConfig ; import com . sleepycat . db . Environment ; public class SanityLoadLibrary { public static void main ( String [ ] ignored ) throws Exception { EnvironmentConfig envConfig = EnvironmentConfig . DEFAULT ; envConfig . setAllowCreate ( false ) ; Environment env =", "gt": "new Environment ( null , envConfig ) ;", "prediction": "new Environment ( ) ;\n", "label": 1}
{"id": 3686, "input": "<s> package org . gk . ui . client . com . form ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . widget . form . ImageField ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; public class gkImageField extends ImageField { public gkImageField ( ) { super ( ) ; } public gkImageField ( String text ) { super ( text ) ; } @ Override protected void onRender ( Element parent , int index ) { super . onRender ( parent , index ) ; sinkEvents ( Event . ONCLICK | Event . ONMOUSEOVER | Event . ONMOUSEOUT ) ; } @ Override public void onComponentEvent ( ComponentEvent ce ) { super . onComponentEvent ( ce ) ; FieldEvent fe = ( FieldEvent ) ce ; fe . setEvent ( ce . getEvent ( ) ) ; switch ( ce . getEventTypeInt ( ) ) { case Event . ONMOUSEOVER : onMouseOver ( ce ) ; break ; case Event . ONMOUSEOUT : onMouseOut ( ce ) ; break ; } } protected void onMouseOver ( ComponentEvent ce ) { setStyleAttribute ( \"cursor\" , \"pointer\" ) ; }", "gt": "protected void onMouseOut ( ComponentEvent ce )", "prediction": "}\n", "label": 0}
{"id": 15709, "input": "<s> package org . jscsi . target . settings . entry ; import org . jscsi . target . TargetServer ; import org . jscsi . target . settings . BooleanResultFunction ; import org . jscsi . target . settings . KeySet ; import org . jscsi . target . settings . NegotiationStatus ; import org . jscsi . target . settings . NegotiationType ; import org . jscsi . target . settings . TextParameter ; public final class BooleanEntry extends Entry { private final boolean negotiationValue ; private final BooleanResultFunction resultFunction ; public BooleanEntry ( final KeySet keySet , final Use use , final NegotiationStatus negotiationStatus , final boolean negotiationValue , final BooleanResultFunction resultFunction , final Boolean defaultValue ) { super ( keySet , NegotiationType . NEGOTIATED , use , negotiationStatus , defaultValue ) ; this . negotiationValue = negotiationValue ; this . resultFunction = resultFunction ; } @ Override protected Object parseOffer ( TargetServer target , final String values ) { return TextParameter . parseBooleanValue ( values ) ; } @ Override protected boolean inProtocolValueRange ( final Object values ) { if ( values instanceof Boolean ) return true ; return false ; } @ Override protected void processDeclaration ( final Object values ) { } @ Override protected String processNegotiation ( final Object values ) { final boolean request = ( Boolean ) values ; final boolean result = resultFunction . getResult ( request , negotiationValue ) ; value = result ; return TextParameter . booleanToTextValue ( result ) ; } @ Override public Boolean getBooleanValue ( ) { return ( Boolean ) value ; } @ Override public Entry copy ( ) { final BooleanEntry e = new BooleanEntry ( keySet , use , negotiationStatus", "gt": ", negotiationValue , resultFunction , ( Boolean ) value ) ;", "prediction": ", defaultValue ) ;\n", "label": 1}
{"id": 9082, "input": "<s> package com . redhat . ceylon . compiler . loader . mirror ; import java . util . List ; public interface MethodMirror extends AnnotatedMirror { boolean isStatic ( ) ; boolean isPublic ( ) ; boolean isProtected ( ) ; boolean isDefaultAccess ( ) ; boolean isConstructor ( ) ; boolean isAbstract ( ) ; boolean isFinal ( ) ; boolean isStaticInit ( ) ; boolean isVariadic ( ) ; List <", "gt": "VariableMirror > getParameters ( ) ;", "prediction": "MethodMirror > methods = new ArrayList < MethodMirror > ( ) ;\n", "label": 0}
{"id": 15714, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import org . eclipse . swt . custom . ScrolledComposite ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . internal . widgets . WidgetTreeVisitor . AllWidgetTreeVisitor ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; class BufferScrolledCompositeOriginsVisitor extends AllWidgetTreeVisitor { public boolean doVisit ( Widget widget ) { if ( widget instanceof ScrolledComposite ) { bufferOrigin ( ( ScrolledComposite ) widget ) ; bufferContentSize ( ( ScrolledComposite ) widget ) ; } return true ; } private void bufferOrigin ( ScrolledComposite composite ) { Point origin = composite . getOrigin ( ) ; composite . setData (", "gt": "TextSizeRecalculation . KEY_SCROLLED_COMPOSITE_ORIGIN , origin ) ;", "prediction": "origin ) ;\n", "label": 1}
{"id": 4966, "input": "<s> package org . parboiled . annotations ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy", "gt": ". RUNTIME ) @ Target (", "prediction": ". RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target . RUNTIME ) @ RetentionPolicy ( Target\n", "label": 0}
{"id": 15722, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . internal . dnd . SwtUtil ; public abstract class PartSashContainer extends LayoutPart implements ILayoutContainer { protected Composite parent ; protected ControlListener resizeListener ; protected LayoutTree root ; private Composite parentWidget ; private LayoutPart zoomedPart ; protected WorkbenchPage page ; boolean active = false ; boolean layoutDirty = false ; protected ArrayList children = new ArrayList ( ) ; protected static class RelationshipInfo { protected LayoutPart part ; protected LayoutPart relative ; protected int relationship ; protected int left ; protected int right ; public float getRatio ( ) { int total = left + right ; if ( total > 0 ) { return ( float ) left / ( float ) total ; } return 0.5f ; } } public PartSashContainer ( String id , final WorkbenchPage page , Composite parentWidget ) { super ( id ) ; this . page = page ; this . parentWidget = parentWidget ; resizeListener = new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { resizeSashes ( ) ; } } ; } public boolean childObscuredByZoom ( LayoutPart toTest ) { LayoutPart zoomPart = getZoomedPart ( ) ; if ( zoomPart != null && toTest != zoomPart ) { return true ; } return isObscuredByZoom ( ) ; } public void findSashes ( LayoutPart pane , PartPane . Sashes sashes ) { if ( root == null ) { return ; } LayoutTree part = root . find ( pane ) ; if ( part == null ) { return ; } part . findSashes ( sashes ) ; } public void add ( LayoutPart child ) { if ( child == null ) { return ; } addEnhanced ( child , SWT . RIGHT , 0.5f , findBottomRight ( ) ) ; } void addEnhanced ( LayoutPart child , int swtDirectionConstant , float ratioForNewPart , LayoutPart relative ) { int relativePosition = PageLayout . swtConstantToLayoutPosition ( swtDirectionConstant ) ; float ratioForUpperLeftPart ; if ( relativePosition == IPageLayout", "gt": ". RIGHT || relativePosition == IPageLayout . BOTTOM )", "prediction": ". swtConstantToLayoutPosition ( relative ) )\n", "label": 1}
{"id": 5132, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . File ; import java . io . IOException ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; import org . apache . maven . project . MavenProject ; import org . apache . maven . project . MavenProjectHelper ; import org . codehaus . plexus . archiver . Archiver ; import org . codehaus . plexus . archiver . ArchiverException ; import org . codehaus . plexus . archiver . manager . ArchiverManager ; import org . codehaus . plexus . archiver . manager . NoSuchArchiverException ; public class XCodePackageDSymMojo extends AbstractXCodeMojo { private ArchiverManager archiverManager ; private MavenProjectHelper projectHelper ; private String productName ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { for ( final String sdk : getSDKs ( ) ) { for ( final String config : getConfigurations ( ) ) { try { packageAndAttachDSym ( sdk , config ) ; } catch ( IOException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( NoSuchArchiverException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } catch ( ArchiverException e ) { throw new MojoExecutionException ( e . getMessage ( ) , e ) ; } } } } private void packageAndAttachDSym ( String sdk , String config ) throws IOException , NoSuchArchiverException , ArchiverException { final String productName ; if ( this . productName != null ) { productName = this . productName . trim ( ) ; if ( productName . isEmpty ( ) ) throw new IllegalStateException ( \"ProductName from pom file was empty.\" ) ; } else { productName = EffectiveBuildSettings . getProductName ( this . project , config , sdk ) ; if ( productName == null || productName . isEmpty ( ) ) throw new IllegalStateException ( \"Product Name not found in effective build settings file\" ) ; } final String fixedProductName = getFixedProductName ( productName ) ; String generateDSym = new EffectiveBuildSettings ( this . project , config , sdk ) . getBuildSetting ( EffectiveBuildSettings . GCC_GENERATE_DEBUGGING_SYMBOLS ) ; if ( generateDSym == null || generateDSym . equalsIgnoreCase ( \"YES\" ) ) { final File root = new File ( XCodeBuildLayout . getAppFolder ( getXCodeCompileDirectory ( )", "gt": ", config , sdk ) , productName + \".app.dSYM\" ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 15723, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . model ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . ui . internal . provisional . cheatsheets . ICompositeCheatSheetTask ; import org . eclipse . ui . internal . provisional . cheatsheets . ITaskGroup ; public class SuccesorTaskFinder { private AbstractTask currentTask ; ICompositeCheatSheetTask bestLaterTask ; ICompositeCheatSheetTask bestEarlierTask ; private boolean seenThisTask ; public SuccesorTaskFinder ( ICompositeCheatSheetTask task ) { currentTask = ( AbstractTask ) task ; } public ICompositeCheatSheetTask [ ] getRecommendedSuccessors ( ) { if ( ITaskGroup . CHOICE . equals ( currentTask . getKind ( ) ) ) { List runnableChoices = findRunnableChoices ( ) ; if ( runnableChoices . size ( ) != 0 ) { return ( ICompositeCheatSheetTask [ ] ) runnableChoices . toArray ( new ICompositeCheatSheetTask [ runnableChoices . size ( ) ] ) ; } } return getBestSuccessor ( ) ; } private List findRunnableChoices ( ) { List result ; result = new ArrayList ( ) ; if ( isStartable ( currentTask ) ) { ICompositeCheatSheetTask [ ] subtasks = currentTask . getSubtasks ( ) ; for ( int i = 0 ; i < subtasks . length ; i ++ ) { if ( isStartable ( subtasks [ i ] ) ) { result . add ( subtasks [ i ] ) ; } } } return result ; } private boolean isStartable ( ICompositeCheatSheetTask task ) { int state = task . getState ( ) ; return ( state != ICompositeCheatSheetTask . COMPLETED && state != ICompositeCheatSheetTask . SKIPPED && task . requiredTasksCompleted ( ) ) ; } private ICompositeCheatSheetTask [ ] getBestSuccessor ( ) { bestLaterTask = null ; bestEarlierTask = null ; seenThisTask = false ; searchRunnableChildren ( currentTask . getCompositeCheatSheet ( ) . getRootTask ( ) ) ; if ( bestLaterTask != null ) { return new ICompositeCheatSheetTask [ ] { bestLaterTask } ; } if ( bestEarlierTask != null ) { return new ICompositeCheatSheetTask [ ] { bestEarlierTask } ; } return new ICompositeCheatSheetTask [ 0 ] ; } private void searchRunnableChildren ( ICompositeCheatSheetTask task ) { if ( bestLaterTask != null ) { return ; } if ( task == currentTask ) { seenThisTask = true ; } if ( task . getState ( ) == ICompositeCheatSheetTask . COMPLETED || task . getState ( ) == ICompositeCheatSheetTask . SKIPPED ) { if ( isTaskAncestor ( task , currentTask ) ) { seenThisTask = true ; } return ; } if ( isStartable ( task", "gt": ") && task != currentTask )", "prediction": ") )\n", "label": 1}
{"id": 7152, "input": "<s> package com . gisgraphy . client . impl . gisgraphyserver ; import static com . sirika . httpclienthelpers . template . AbstractHttpErrorHandler . statusCodeEquals ; import static com . sirika . httpclienthelpers . template . AbstractHttpErrorHandler . statusCodeGreaterOrEquals ; import java . io . IOException ; import java . io . InputStream ; import org . apache . http . HttpEntity ; import org . apache . http . HttpResponse ; import org . apache . http . HttpStatus ; import org . apache . http . client . HttpClient ; import org . apache . http . client . HttpResponseException ; import org . apache . http . client . methods . HttpGet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . InputStreamSource ; import com . google . common . collect . ImmutableList ; import com . sirika . httpclienthelpers . template . AbstractHttpErrorHandler ; import com . sirika . httpclienthelpers . template . HttpClientTemplate ; import com . sirika . httpclienthelpers . template . HttpErrorHandler ; import com . sirika . httpclienthelpers . template . HttpResponseCallback ; class HttpGisgraphyQueryInputStreamSource implements InputStreamSource { private final static Logger logger = LoggerFactory . getLogger ( HttpGisgraphyQueryInputStreamSource . class ) ; private HttpClientTemplate httpClientTemplate ; private HttpGet httpGet ; private GisgraphyQuery query ; public HttpGisgraphyQueryInputStreamSource ( HttpClient httpClient , UrlGenerator urlGenerator , GisgraphyQuery query ) { super ( ) ; this . httpClientTemplate = new HttpClientTemplate ( httpClient ) ; this . query = query ; this . httpGet = new HttpGet ( urlGenerator . generateUrl ( query ) ) ; } public InputStream getInputStream ( ) throws IOException , ResourceNotExistingException { logger . debug ( \"Generating InputStream for {}\" , query ) ; return ( InputStream ) this . httpClientTemplate . execute ( this . httpGet , new HttpResponseCallback ( ) { public Object doWithHttpResponse ( HttpResponse httpResponse ) throws Exception { return generateInputStream ( httpResponse . getEntity ( ) ) ; } } , httpErrorHandlers ( ) ) ; } private Iterable < HttpErrorHandler > httpErrorHandlers ( ) { return ImmutableList . of ( notFoundHandler ( ) , defaultHandler ( ) ) ; } private HttpErrorHandler notFoundHandler ( ) { return new AbstractHttpErrorHandler ( statusCodeEquals ( HttpStatus . SC_NOT_FOUND ) ) { public void handle ( HttpResponse response ) throws Exception { throw new ResourceNotExistingException ( query ) ; } } ; } private HttpErrorHandler defaultHandler ( ) { return new AbstractHttpErrorHandler (", "gt": "statusCodeGreaterOrEquals ( 300 ) )", "prediction": "statusCodeEquals ( HttpStatus . SC_NOT_FOUND ) )\n", "label": 0}
{"id": 15729, "input": "<s> package org . eclipse . ui . tests . dynamicplugins ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; import org . eclipse . ui . wizards . IWizardRegistry ; import org . eclipse . ui . wizards . IWizardDescriptor ; public class NewWizardTests extends DynamicTestCase { private static final String WIZARD_ID = \"org.eclipse.newNewWizard1.newNewWizard1\" ; public NewWizardTests ( String testName ) { super ( testName ) ; } public void testNewWizardProperties ( ) { IWizardRegistry registry = WorkbenchPlugin . getDefault ( ) . getNewWizardRegistry ( ) ; assertNull ( registry . findWizard ( WIZARD_ID ) ) ; getBundle ( ) ; IWizardDescriptor wizard = registry . findWizard ( WIZARD_ID ) ; assertNotNull ( wizard ) ; testNewWizardProperties ( wizard ) ; removeBundle ( ) ; assertNull ( registry . findWizard ( WIZARD_ID ) ) ; try { testNewWizardProperties ( wizard ) ; fail ( ) ; } catch ( RuntimeException e ) { } } private void testNewWizardProperties ( IWizardDescriptor wizard ) { assertNotNull (", "gt": "wizard . getId ( ) ) ;", "prediction": "wizard ) ;\n", "label": 1}
{"id": 6781, "input": "<s> package model ; import static org . junit . Assert . * ; import java . util . ArrayList ; import org . junit . Test ; public class UserJUnit { @ Test public void testUserConstructor ( ) { Cart shopping = new Cart ( ) ; ArrayList < Book > rental = new ArrayList < Book > ( ) ; PaymentInfo testInfo = new PaymentInfo ( ) ; User test = new User ( \"Test\" , false , \"myemail@stupid\" , rental , testInfo , shopping ) ; assertTrue ( test . username . equals ( \"Test\" ) && test . email . equals ( \"myemail@stupid\" ) && test . isAdmin == false ) ; } @ Test public void testUserGetters ( ) { Cart shopping = new Cart ( ) ; ArrayList < Book > rental = new ArrayList < Book > ( ) ; PaymentInfo testInfo = new PaymentInfo ( ) ; User test = new User ( \"Test\" , false , \"myemail@stupid\" , rental , testInfo , shopping ) ; assertTrue ( test . getUserName ( ) . equals ( \"Test\" ) ) ; assertTrue ( test . getCart ( ) != null ) ; assertTrue ( test . getEmail ( ) . equals ( \"myemail@stupid\" ) ) ; assertTrue ( test . getPaymentInfo ( ) != null ) ; assertTrue ( test .", "gt": "getRentals ( ) != null ) ;", "prediction": "getUserName ( ) . equals ( \"Test\" ) ) ;\n", "label": 0}
{"id": 15735, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import java . io . IOException ; public final class FuzzyTermEnum extends FilteredTermEnum { private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19 ; private int [ ] [ ] d ; private float similarity ; private boolean endEnum = false ; private Term searchTerm = null ; private final String field ; private final String text ; private final String prefix ; private final float minimumSimilarity ; private final float scale_factor ; private final int [ ] maxDistances = new int [ TYPICAL_LONGEST_WORD_IN_INDEX ] ; public FuzzyTermEnum ( IndexReader reader , Term term ) throws IOException { this ( reader , term , FuzzyQuery . defaultMinSimilarity , FuzzyQuery . defaultPrefixLength ) ; } public FuzzyTermEnum ( IndexReader reader , Term term , float minSimilarity ) throws IOException { this ( reader , term , minSimilarity , FuzzyQuery . defaultPrefixLength ) ; } public FuzzyTermEnum ( IndexReader reader , Term term , final float minSimilarity , final int prefixLength ) throws IOException { super ( ) ; if ( minSimilarity >= 1.0f ) throw new IllegalArgumentException ( \"minimumSimilarity cannot be greater than or equal to 1\" ) ; else if ( minSimilarity < 0.0f ) throw new IllegalArgumentException ( \"minimumSimilarity cannot be less than 0\" ) ; if ( prefixLength < 0 ) throw new IllegalArgumentException ( \"prefixLength cannot be less than 0\" ) ; this . minimumSimilarity = minSimilarity ; this . scale_factor = 1.0f / ( 1.0f - minimumSimilarity ) ; this . searchTerm = term ; this . field = searchTerm . field ( ) ; final int fullSearchTermLength = searchTerm . text ( ) . length ( ) ; final int realPrefixLength = prefixLength > fullSearchTermLength ? fullSearchTermLength : prefixLength ; this . text = searchTerm . text ( ) . substring ( realPrefixLength ) ; this . prefix = searchTerm . text ( ) . substring ( 0 , realPrefixLength ) ; initializeMaxDistances ( ) ; this . d = initDistanceArray ( ) ; setEnum ( reader . terms ( new Term ( searchTerm . field ( ) , prefix ) ) ) ; } protected final boolean termCompare ( Term term ) { if ( field == term . field ( ) && term . text ( ) . startsWith ( prefix ) ) { final String target = term . text ( ) . substring ( prefix . length ( ) ) ; this . similarity = similarity ( target ) ; return ( similarity > minimumSimilarity ) ; } endEnum = true ; return false ; } public final float difference ( ) { return ( float ) ( ( similarity - minimumSimilarity ) * scale_factor ) ; } public final boolean endEnum ( ) { return endEnum ; } private static final int min ( int a , int b , int c ) { final int t = ( a < b ) ? a : b ; return ( t < c ) ? t : c ; } private final int [ ] [ ] initDistanceArray ( ) { return new int [ this . text . length ( ) + 1 ] [ TYPICAL_LONGEST_WORD_IN_INDEX ] ; } private float similarity ( final String target ) { final int m = target . length ( ) ; final int n = text . length ( ) ; if ( n == 0 ) { return prefix . length ( ) == 0 ? 0.0f : 1.0f - ( ( float ) m / prefix . length ( ) ) ; } if ( m == 0 ) { return prefix . length ( ) == 0 ? 0.0f : 1.0f - ( ( float ) n / prefix . length ( ) ) ; } final int maxDistance = getMaxDistance ( m ) ; if ( maxDistance < Math . abs ( m - n ) ) { return 0.0f ; } if ( d [ 0 ] . length <= m ) {", "gt": "growDistanceArray ( m ) ;", "prediction": "return maxDistance ;\n", "label": 1}
{"id": 3128, "input": "<s> package api . util ; public class Quadruple < A , B , C , D > { private A a ; private B b ; private C c ; private D d ; public Quadruple ( A a , B b , C c , D d ) { this . a = a ; this . b = b ; this . c = c ; this . d = d ; } public A getA ( ) { return a ; } public B getB ( ) { return b ; } public C getC ( ) { return c ; } public D getD ( ) { return d ; } public void setA ( A a ) { this . a = a ; } public void", "gt": "setB ( B b )", "prediction": "setB ( B b )\n", "label": 0}
{"id": 15745, "input": "<s> package de . uos . igf . db3d . dbms . structure ; import de . uos . igf . db3d . dbms . geom . MBB3D ; public interface GeoObj { public", "gt": "byte getType ( ) ;", "prediction": "static void main ( String [ ] args ) throws Exception\n", "label": 1}
{"id": 7110, "input": "<s> package javax . annotation . processing ; import java . lang . annotation . * ; import static java . lang . annotation . RetentionPolicy . * ; import static java . lang . annotation . ElementType . * ;", "gt": "import javax . lang . model . SourceVersion ;", "prediction": "import static java . lang . annotation . * ;\n", "label": 0}
{"id": 15757, "input": "<s> package org . eclipse . jface . viewers ; import java . io . Serializable ; import org . eclipse . jface . util . Policy ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; public abstract class ViewerRow implements Cloneable , Serializable { public static final int ABOVE = 1 ; public static final int BELOW = 2 ; private static final String KEY_TEXT_LAYOUT = Policy . JFACE + \"styled_label_key_\" ; private static final String KEY_TEXT_LAYOUT_0 = Policy . JFACE + \"styled_label_key_0\" ; private static String [ ] cachedDataKeys ; public abstract Rectangle getBounds ( int columnIndex ) ; public abstract Rectangle getBounds ( ) ; public abstract Widget getItem ( ) ; public abstract int getColumnCount ( ) ; public abstract Image getImage ( int columnIndex ) ; public abstract void setImage ( int columnIndex , Image image ) ; public abstract String getText ( int columnIndex ) ; public abstract void setText ( int columnIndex , String text ) ; public abstract Color getBackground ( int columnIndex ) ; public abstract void setBackground ( int columnIndex , Color color ) ; public abstract Color getForeground ( int columnIndex ) ; public abstract void setForeground ( int columnIndex , Color color ) ; public abstract Font getFont ( int columnIndex ) ; public abstract void setFont ( int columnIndex , Font font ) ; public ViewerCell getCell ( Point point ) { int index = getColumnIndex ( point ) ; return getCell ( index ) ; } public int getColumnIndex ( Point point ) { int count = getColumnCount ( ) ; if ( count == 0 ) { return 0 ; } for ( int i = 0 ; i < count ; i ++ ) { if ( getBounds ( i ) . contains ( point ) ) { return i ; } } return - 1 ; } public ViewerCell getCell ( int column ) { if ( column >= 0 ) return new ViewerCell ( ( ViewerRow ) clone ( ) , column , getElement ( ) ) ; return null ; } public abstract Control getControl ( ) ; public abstract ViewerRow getNeighbor ( int direction , boolean sameLevel ) ; public abstract TreePath getTreePath ( ) ; public abstract Object clone ( ) ; public abstract Object getElement ( ) ; public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( getItem ( ) == null ) ? 0 : getItem ( ) . hashCode ( ) ) ; return result ; } public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final ViewerRow other = ( ViewerRow ) obj ; if ( getItem ( ) == null ) { if ( other . getItem ( ) != null ) return false ; } else if ( ! getItem ( ) . equals ( other . getItem ( ) ) ) return false ; return true ; } ViewerCell getCellAtVisualIndex ( int visualIndex ) { return getCell ( getCreationIndex ( visualIndex ) ) ; }", "gt": "protected int getVisualIndex ( int creationIndex )", "prediction": "}\n", "label": 1}
{"id": 2833, "input": "<s> package org . ofbiz . base . location ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . Map . Entry ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; public final class FlexibleLocation { public static final String module = FlexibleLocation . class . getName ( ) ; private static final Map < String , LocationResolver > locationResolvers ; static { Map < String , LocationResolver > resolverMap = new HashMap < String , LocationResolver > ( 8 ) ; LocationResolver standardUrlResolver = new StandardUrlLocationResolver ( ) ; resolverMap . put ( \"http\" , standardUrlResolver ) ; resolverMap . put ( \"https\" , standardUrlResolver ) ; resolverMap . put ( \"ftp\" , standardUrlResolver ) ; resolverMap . put ( \"jar\" , standardUrlResolver ) ; resolverMap . put ( \"file\" , standardUrlResolver ) ; resolverMap . put ( \"classpath\" , new ClasspathLocationResolver ( ) ) ; resolverMap . put ( \"ofbizhome\" , new OFBizHomeLocationResolver ( ) ) ; resolverMap . put ( \"component\" , new ComponentLocationResolver ( ) ) ; try { Properties properties = UtilProperties . getProperties ( \"locationresolvers.properties\" ) ; if ( properties != null ) { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( Entry < Object , Object > entry : properties . entrySet ( ) ) { String locationType = ( String ) entry . getKey ( ) ; String locationResolverName = ( String ) entry . getValue ( ) ; Class < ? > lClass = classLoader . loadClass ( locationResolverName ) ; resolverMap . put ( locationType , ( LocationResolver ) lClass . newInstance ( ) ) ; } } } catch ( Throwable e ) { Debug . logWarning ( e , \"Error while loading resolvers from locationresolvers.properties: \" , module ) ; } locationResolvers = Collections . unmodifiableMap ( resolverMap ) ; } private static String getLocationType ( String location ) { int colonIndex = location . indexOf ( \":\" ) ; if ( colonIndex > 0 ) { return location . substring ( 0 , colonIndex ) ; } else { return \"classpath\" ; } } public static URL resolveLocation ( String location ) throws MalformedURLException { return resolveLocation (", "gt": "location , null ) ;", "prediction": "location ) ;\n", "label": 0}
{"id": 15758, "input": "<s> package br . org . archimedes ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Platform ; import org . osgi . framework . Bundle ; public class FileLoader { private static final String TESTS_PLUGIN_ID = \"br.org.archimedes.tests\" ; public static InputStream getReaderForFile ( String filePath ) throws FileNotFoundException { InputStream fileInput ; try { Bundle bundle = Platform . getBundle ( TESTS_PLUGIN_ID ) ; IPath file =", "gt": "new Path ( filePath ) ;", "prediction": "new IPath ( filePath ) ;\n", "label": 1}
{"id": 7520, "input": "<s> package org . json ; import java . io . IOException ; import java . io . StringWriter ; import java . io . Writer ; import java . lang . reflect . Array ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; public class JSONArray { private final ArrayList myArrayList ; public JSONArray ( ) { this . myArrayList = new ArrayList ( ) ; } public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != '[' ) { throw x . syntaxError ( \"A JSONArray text must start with '['\" ) ; } if ( x . nextClean ( ) != ']' ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) == ',' ) { x . back ( ) ; this . myArrayList . add ( JSONObject . NULL ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case ';' : case ',' : if ( x . nextClean ( ) == ']' ) { return ; } x . back ( ) ; break ; case ']' : return ; default : throw x . syntaxError ( \"Expected a ',' or ']'\" ) ; } } } } public JSONArray ( String source ) throws JSONException { this ( new JSONTokener ( source ) ) ; } public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } } public JSONArray ( Object array ) throws JSONException { this ( ) ; if ( array . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i += 1 ) { this . put ( JSONObject . wrap ( Array . get ( array , i ) ) ) ; } } else { throw new JSONException ( \"JSONArray initial value should be a string or collection or array.\" ) ; } } public Object get ( int index ) throws JSONException { Object object = this . opt ( index ) ; if ( object == null ) { throw new JSONException ( \"JSONArray[\" + index + \"] not found.\" ) ; } return object ; } public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( \"false\" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( \"true\" ) ) ) { return true ; } throw new JSONException ( \"JSONArray[\" + index + \"] is not a boolean.\" ) ; } public double getDouble (", "gt": "int index ) throws JSONException", "prediction": "int index ) throws JSONException\n", "label": 0}
{"id": 15759, "input": "<s> package spell ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . prefs . Preferences ; import org . ini4j . Ini ; import org . ini4j . IniPreferences ; import org . ini4j . InvalidFileFormatException ; import actors . Actor ; public class Spell { private static HashMap < String , Spell > spellCache = new HashMap < String , Spell > ( ) ; public static Spell getSpell ( String name , boolean forceLoad ) { Spell s = null ; try { if ( spellCache . containsKey ( name ) && ! forceLoad ) s = spellCache . get ( name ) ; else { s = new Spell ( name ) ; spellCache . put ( name , s ) ; } } catch ( Exception e ) { System . err . println ( \"can not read or find file: \" + \"data/spells/\" + name + \"/spell.ini\" ) ; } return s ; } public static Spell getSpell ( String name ) { return getSpell ( name , false ) ; } private boolean fire = false ; private boolean frez = false ; private boolean elec = false ; private boolean lght = false ; private boolean dark = false ; private int lvl = 1 ; private String value = \"0\" ; private boolean valueType = false ; private boolean targetAlly = false ; private int targetRange = 0 ; private String name ; private Spell ( String name ) throws Exception { this . name = name ; Preferences p = null ; p = new IniPreferences ( new Ini ( new File ( \"data/spells/\" + name + \".ini\" ) ) ) . node ( \"spell\" ) ; lvl = p . getInt ( \"level\" , 1 ) ; fire = p . getBoolean ( \"fire\" , false ) ; frez = p . getBoolean ( \"frez\" , false ) ; elec = p . getBoolean ( \"elec\" , false ) ; lght = p . getBoolean ( \"lght\" , false ) ; dark = p . getBoolean ( \"dark\" , false ) ; targetAlly = p . getBoolean ( \"targetAlly\" , false ) ; targetRange = p . getInt ( \"targetRange\" , 0 ) ; value = p . get ( \"value\" , \"0\" ) ; valueType = p . get ( \"type\" , \"constant\" ) . equals ( \"variable\" ) ? true : false ; } public String getValue ( ) { return value ; } public boolean getValueType ( ) { return valueType ; } public int getLevel ( ) { return lvl ; } public int getElementalEffectiveness ( Actor a ) { int sum = 0 ; int elem = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) if ( getElementalAlignment ( i ) ) { elem ++ ; sum += a . getElementalResistance ( i ) ; } if ( sum <= elem - 1 ) return 0 ; else", "gt": "if ( sum >= elem + 1 ) return 2 ;", "prediction": "return 1 ;\n", "label": 1}
{"id": 2256, "input": "<s> class ResourceTypeVar < X extends AutoCloseable > { public void test ( ) { try ( X armflow = getX ( ) ) { } catch ( Exception e ) { throw new AssertionError (", "gt": "\"Shouldn't reach here\" , e ) ;", "prediction": "e ) ;\n", "label": 0}
{"id": 15764, "input": "<s> package org . eclipse . jface . tests . layout ; import junit . framework . Test ; import junit . framework . TestSuite ; public class AllTests extends TestSuite { public static void main ( String [ ] args ) { junit . textui . TestRunner . run ( suite ( ) ) ; } public", "gt": "static Test suite ( )", "prediction": "static void main ( String [ ] args )\n", "label": 1}
{"id": 7626, "input": "<s> import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import javax . tools . * ; import com . sun . source . tree . Tree ; import com . sun . source . util . TreeScanner ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . JCCompilationUnit ; import com . sun . tools . javac . tree . JCTree . TypeBoundKind ; import com . sun . tools . javac . util . List ; public class SourceTreeScannerTest extends AbstractTreeScannerTest { public static void main ( String ... args ) { String testSrc = System . getProperty ( \"test.src\" ) ; File baseDir = ( testSrc == null ) ? null : new File ( testSrc ) ; boolean ok = new SourceTreeScannerTest ( ) . run ( baseDir , args ) ; if ( ! ok ) { if ( testSrc != null ) throw new Error ( \"failed\" ) ; else System . exit ( 1 ) ; } } int test ( JCCompilationUnit tree ) { return new ScanTester ( ) . test ( tree ) ; } private class ScanTester extends TreeScanner < Void , Void > { int test ( JCCompilationUnit tree ) { sourcefile = tree . sourcefile ; found = new HashSet < Tree > ( ) ; scan ( tree , null ) ; expect = new HashSet < Tree > ( ) ; reflectiveScan ( tree ) ; if ( found . equals ( expect ) ) { return found . size ( ) ; } error ( sourcefile . getName ( ) + \": differences found\" ) ; if ( found . size ( ) != expect . size ( ) ) error ( \"Size mismatch; found: \" + found . size ( ) + \", expected: \" + expect . size ( ) ) ; Set < Tree > missing = new HashSet < Tree > ( ) ; missing . addAll ( expect ) ; missing . removeAll ( found ) ; for ( Tree t : missing ) error ( sourcefile , t , \"missing\" ) ; Set < Tree > excess = new HashSet < Tree > ( ) ; excess . addAll ( found ) ; excess . removeAll ( expect ) ; for ( Tree t : excess ) error ( sourcefile , t , \"unexpected\" ) ; return 0 ; } @ Override public Void scan ( Tree tree , Void ignore ) { if ( tree == null ) return null ; found . add ( tree ) ; return super . scan ( tree , ignore ) ; } public void reflectiveScan ( Object o ) { if ( o == null ) return ; if ( o instanceof JCTree ) { JCTree tree", "gt": "= ( JCTree ) o ;", "prediction": "= ( JCTree ) o ;\n", "label": 0}
{"id": 15765, "input": "<s> package com . emf4sw . rdf . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EcoreUtil ; import com . emf4sw . rdf . Datatype ; import com . emf4sw . rdf . Literal ; import com . emf4sw . rdf . RDFGraph ; import com . emf4sw . rdf . RDFPackage ; public class LiteralImpl extends NodeImpl implements Literal { protected static final String LEXICAL_FORM_EDEFAULT = null ; protected String lexicalForm = LEXICAL_FORM_EDEFAULT ; protected static final String LANG_EDEFAULT = null ; protected String lang = LANG_EDEFAULT ; protected Datatype datatype ; protected LiteralImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return RDFPackage . Literals . LITERAL ; } public String getLexicalForm ( ) { return lexicalForm ; } public void setLexicalForm ( String newLexicalForm ) { String oldLexicalForm = lexicalForm ; lexicalForm = newLexicalForm ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LEXICAL_FORM , oldLexicalForm , lexicalForm ) ) ; } public String getLang ( ) { return lang ; } public void setLang ( String newLang ) { String oldLang = lang ; lang = newLang ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LANG , oldLang , lang ) ) ; } public Datatype getDatatype ( ) { if ( datatype != null && datatype . eIsProxy ( ) ) { InternalEObject oldDatatype = ( InternalEObject ) datatype ; datatype = ( Datatype ) eResolveProxy ( oldDatatype ) ; if ( datatype != oldDatatype ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ; } } return datatype ; } public Datatype basicGetDatatype ( ) { return datatype ; } public void setDatatype ( Datatype newDatatype ) { Datatype oldDatatype = datatype ; datatype = newDatatype ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ; } public RDFGraph getGraph ( ) { if ( eContainerFeatureID ( ) != RDFPackage . LITERAL__GRAPH ) return null ; return ( RDFGraph ) eContainer ( ) ; } public NotificationChain basicSetGraph ( RDFGraph newGraph , NotificationChain msgs ) { msgs = eBasicSetContainer ( ( InternalEObject ) newGraph , RDFPackage . LITERAL__GRAPH , msgs ) ; return msgs ; } public void setGraph ( RDFGraph newGraph ) { if ( newGraph != eInternalContainer ( ) || ( eContainerFeatureID ( ) != RDFPackage . LITERAL__GRAPH && newGraph != null ) ) { if ( EcoreUtil . isAncestor ( this , newGraph ) ) throw new IllegalArgumentException ( \"Recursive containment not allowed for \" + toString ( ) ) ; NotificationChain msgs = null ; if ( eInternalContainer ( ) != null ) msgs = eBasicRemoveFromContainer ( msgs ) ; if ( newGraph != null ) msgs = ( ( InternalEObject ) newGraph ) . eInverseAdd ( this , RDFPackage . RDF_GRAPH__LITERALS , RDFGraph . class , msgs ) ; msgs = basicSetGraph ( newGraph , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__GRAPH ,", "gt": "newGraph , newGraph ) ) ;", "prediction": "msgs ) ) ;\n", "label": 1}
{"id": 7607, "input": "<s> package org . remast . baralga . model . io ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilenameFilter ; import java . io . OutputStream ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . List ; import java . util . SortedMap ; import java . util . TreeMap ; import org . apache . commons . lang . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . remast . baralga . gui . model . PresentationModel ; import org . remast . baralga . gui . settings . ApplicationSettings ; import org . remast . baralga . gui . settings . UserSettings ; import org . remast . baralga . model . ProjectActivity ; import org . remast . baralga . model . export . Exporter ; import org . remast . baralga . model . export . XmlExporter ; public class DataBackup { private static final Logger log = LoggerFactory . getLogger ( DataBackup . class ) ; private static final SimpleDateFormat BACKUP_DATE_FORMAT = new SimpleDateFormat ( \"yyyyMMdd_HHmmss\" ) ; private static final String ERROR_FILE_NAME = UserSettings . DEFAULT_FILE_NAME + \".Error\" ; private static final int NUMBER_OF_BACKUPS = 3 ; public static void createBackup ( final PresentationModel model ) { OutputStream outputStream = null ; final File backupFile = new File ( UserSettings . instance ( ) . getDataFileLocation ( ) + \".\" + BACKUP_DATE_FORMAT . format ( new Date ( ) ) ) ; try { outputStream = new FileOutputStream ( backupFile ) ; final Exporter exporter = new XmlExporter ( ) ; Collection < ProjectActivity > activitiesForExport = null ; if ( exporter . isFullExport ( ) ) { activitiesForExport = model . getAllActivitiesList ( ) ; } else { activitiesForExport = model . getActivitiesList ( ) ; } synchronized ( activitiesForExport ) { exporter . export ( activitiesForExport , model . getFilter ( ) , outputStream ) ; } outputStream . flush ( ) ; } catch ( Throwable t ) { log . error ( t . getLocalizedMessage ( ) , t ) ; } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( Throwable t ) { } } cleanupBackupFiles ( ) ; } } private static void cleanupBackupFiles ( ) { final List < File > backupFiles = getBackupFiles ( ) ; if ( backupFiles != null && backupFiles . size ( ) > NUMBER_OF_BACKUPS ) { final int numberOfFilesToDelete = backupFiles . size ( ) - NUMBER_OF_BACKUPS ; for ( int i = 1 ; i <= numberOfFilesToDelete ; i ++ ) { final File toDelete = backupFiles . get ( backupFiles . size ( ) - i ) ; final boolean successfull = toDelete . delete ( ) ; if ( ! successfull ) { log . error ( \"Could not delete file \" + toDelete . getAbsolutePath ( ) + \".\" ) ; } } } } public static List < File > getBackupFiles ( ) { final SortedMap < Date , File > sortedBackupFiles = new TreeMap < Date , File > ( ) ; final File dir = ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) ; final String [ ] backupFiles = dir . list ( new FilenameFilter ( ) { public boolean accept ( final File dir , final String name ) { if ( ! StringUtils . equals ( ERROR_FILE_NAME , name ) && ! StringUtils . equals ( UserSettings . DEFAULT_FILE_NAME , name ) && name . startsWith ( UserSettings . DEFAULT_FILE_NAME ) ) { return true ; } return false ; } } ) ; if ( backupFiles == null ) { return Collections . emptyList ( ) ; } for ( String backupFile : backupFiles ) { try { final Date backupDate = BACKUP_DATE_FORMAT . parse ( backupFile . substring ( UserSettings . DEFAULT_FILE_NAME . length ( ) + 1 ) ) ; sortedBackupFiles . put ( backupDate , new File ( ApplicationSettings . instance ( ) . getApplicationDataDirectory ( ) + File . separator + backupFile ) ) ; } catch ( ParseException e ) { log . error ( e . getLocalizedMessage ( ) , e ) ; } } final List < File > backupFileList = new ArrayList < File > ( sortedBackupFiles . size ( ) ) ; final int numberOfBackups = sortedBackupFiles . size ( ) ;", "gt": "for ( int i = 0 ;", "prediction": "for ( int i = 1 ;\n", "label": 0}
{"id": 15766, "input": "<s> package org . apache . lucene . ant ; import java . io . IOException ; import org . apache . lucene . ant . DocumentTestCase ; import org . apache . lucene . ant . TextDocument ; public class TextDocumentTest extends DocumentTestCase { public TextDocumentTest ( String name ) { super ( name ) ; } TextDocument doc ; public", "gt": "void setUp ( ) throws IOException", "prediction": "TextDocument ( String name )\n", "label": 1}
{"id": 8932, "input": "<s> package com . sun . tools . doclets . formats . html . markup ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . Content ; import com . sun . tools . doclets . internal . toolkit . util . * ; public class HtmlTree extends Content { private HtmlTag htmlTag ; private Map < HtmlAttr , String > attrs = Collections . < HtmlAttr , String > emptyMap ( ) ; private List < Content > content = Collections . < Content > emptyList ( ) ; public static final Content EMPTY = new StringContent ( \"\" ) ; public HtmlTree ( HtmlTag tag ) { htmlTag = nullCheck ( tag ) ; } public HtmlTree ( HtmlTag tag , Content ... contents ) { this ( tag ) ; for ( Content content : contents ) addContent ( content ) ; } public void addAttr ( HtmlAttr attrName , String attrValue ) { if ( attrs . isEmpty ( ) ) attrs = new LinkedHashMap < HtmlAttr , String > ( ) ; attrs . put ( nullCheck ( attrName ) , nullCheck ( attrValue ) ) ; } public void addStyle ( HtmlStyle style ) { addAttr ( HtmlAttr . CLASS , style . toString ( ) ) ; } public void addContent ( Content tagContent ) { if ( tagContent == HtmlTree . EMPTY || tagContent . isValid ( ) ) { if ( content . isEmpty ( ) ) content = new ArrayList < Content > ( ) ; content . add ( tagContent ) ; } } public void addContent ( String stringContent ) { if ( ! content . isEmpty ( ) ) { Content lastContent = content . get ( content . size ( ) - 1 ) ; if ( lastContent instanceof StringContent ) lastContent . addContent ( stringContent ) ; else addContent ( new StringContent ( stringContent ) ) ; } else addContent ( new StringContent ( stringContent ) ) ; } public static HtmlTree A ( String ref , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . A , nullCheck ( body ) ) ; htmltree . addAttr ( HtmlAttr . HREF , nullCheck ( ref ) ) ; return htmltree ; } public static HtmlTree A_NAME ( String name , Content body ) { HtmlTree htmltree = HtmlTree . A_NAME ( name ) ; htmltree . addContent ( nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree A_NAME ( String name ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . A ) ; htmltree . addAttr ( HtmlAttr . NAME , nullCheck ( name ) ) ; return htmltree ; } public static HtmlTree CAPTION ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . CAPTION , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree CODE ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . CODE , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DD ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DD , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DL ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DL , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree DIV ( HtmlStyle styleClass , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DIV , nullCheck ( body ) ) ; if ( styleClass != null ) htmltree . addStyle ( styleClass ) ; return htmltree ; } public static HtmlTree DIV ( Content body ) { return DIV ( null , body ) ; } public static HtmlTree DT ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . DT , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree EM ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . EM , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree FRAME ( String src , String name , String title , String scrolling ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . FRAME ) ; htmltree . addAttr ( HtmlAttr . SRC , nullCheck ( src ) ) ; htmltree . addAttr ( HtmlAttr . NAME , nullCheck ( name ) ) ; htmltree . addAttr ( HtmlAttr . TITLE , nullCheck ( title ) ) ; if ( scrolling != null ) htmltree . addAttr ( HtmlAttr . SCROLLING , scrolling ) ; return htmltree ; } public static HtmlTree FRAME ( String src , String name , String title ) { return FRAME ( src , name , title , null ) ; } public static HtmlTree FRAMESET ( String cols , String rows , String title , String onload ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . FRAMESET ) ; if ( cols != null ) htmltree . addAttr ( HtmlAttr . COLS , cols ) ; if ( rows != null ) htmltree . addAttr ( HtmlAttr . ROWS , rows ) ; htmltree . addAttr ( HtmlAttr . TITLE , nullCheck ( title ) ) ; htmltree . addAttr ( HtmlAttr . ONLOAD , nullCheck ( onload ) ) ; return htmltree ; } public static HtmlTree HEADING ( HtmlTag headingTag , boolean printTitle , HtmlStyle styleClass , Content body ) { HtmlTree htmltree = new HtmlTree ( headingTag , nullCheck ( body ) ) ; if ( printTitle ) htmltree . addAttr ( HtmlAttr . TITLE , Util . stripHtml ( body . toString ( ) ) ) ; if ( styleClass != null ) htmltree . addStyle ( styleClass ) ; return htmltree ; } public static HtmlTree HEADING ( HtmlTag headingTag , HtmlStyle styleClass , Content body ) { return HEADING ( headingTag , false , styleClass , body ) ; } public static HtmlTree HEADING ( HtmlTag headingTag , boolean printTitle , Content body ) { return HEADING ( headingTag , printTitle , null , body ) ; } public static HtmlTree HEADING ( HtmlTag headingTag , Content body ) { return HEADING ( headingTag , false , null , body ) ; } public static HtmlTree HTML ( String lang , Content head , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . HTML , nullCheck ( head ) , nullCheck ( body ) ) ; htmltree . addAttr ( HtmlAttr . LANG , nullCheck ( lang ) ) ; return htmltree ; } public static HtmlTree I ( Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag . I , nullCheck ( body ) ) ; return htmltree ; } public static HtmlTree LI ( Content body ) { return LI ( null , body ) ; } public static HtmlTree LI ( HtmlStyle styleClass , Content body ) { HtmlTree htmltree = new HtmlTree ( HtmlTag", "gt": ". LI , nullCheck ( body ) ) ;", "prediction": ". LI , nullCheck ( body ) ) ;\n", "label": 0}
{"id": 15768, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . ControlHolder ; import org . eclipse . swt . internal . widgets . ICompositeAdapter ; import org . eclipse . swt . internal . widgets . IControlHolderAdapter ; public class Composite extends Scrollable { private final ICompositeAdapter compositeAdapter ; private Layout layout ; int layoutCount ; private final ControlHolder controlHolder ; private Control [ ] tabList ; int backgroundMode ; Composite ( Composite parent ) { super ( parent ) ; controlHolder = new ControlHolder ( ) ; compositeAdapter = new CompositeAdapter ( ) ; } public Composite ( Composite parent , int style ) { super ( parent , style ) ; controlHolder = new ControlHolder ( ) ; compositeAdapter = new CompositeAdapter ( ) ; } @ Override void initState ( ) { if ( ( style & ( SWT . H_SCROLL | SWT . V_SCROLL ) ) == 0 ) { state |= THEME_BACKGROUND ; } } public Control [ ] getChildren ( ) { checkWidget ( ) ; return controlHolder . getControls ( ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public < T > T getAdapter ( Class < T > adapter ) { T result ; if ( adapter == IControlHolderAdapter . class ) { result = ( T ) controlHolder ; } else if ( adapter == ICompositeAdapter . class ) { result = ( T ) compositeAdapter ; } else { result = super . getAdapter ( adapter ) ; } return result ; } public void setLayout ( Layout layout ) { checkWidget ( ) ; this . layout = layout ; } public Layout getLayout ( ) { checkWidget ( ) ; return layout ; } public void setLayoutDeferred ( boolean defer ) { checkWidget ( ) ; if ( ! defer ) { if ( -- layoutCount == 0 ) { if ( ( state & LAYOUT_CHILD ) != 0 || ( state & LAYOUT_NEEDED ) != 0 ) { updateLayout ( true , true ) ; } } } else { layoutCount ++ ; } } public boolean getLayoutDeferred ( ) { checkWidget ( ) ; return layoutCount > 0 ; } public boolean isLayoutDeferred ( ) { checkWidget ( ) ; return findDeferredControl ( ) != null ; } public void layout ( ) { checkWidget ( ) ; layout ( true ) ; } public void layout ( boolean changed ) { checkWidget ( ) ; if ( layout != null ) { layout ( changed , false ) ; } } public void layout ( boolean changed , boolean all ) { checkWidget ( ) ; if ( layout != null || all ) { markLayout ( changed , all ) ; updateLayout ( true , all ) ; } } public void layout ( Control [ ] changed ) { checkWidget ( ) ; if ( changed == null ) { error ( SWT . ERROR_INVALID_ARGUMENT ) ; } layout ( changed , SWT . NONE ) ; } public void layout ( Control [ ] changed , int flags ) { checkWidget ( ) ; if ( changed != null ) { for ( int i = 0 ;", "gt": "i < changed . length ;", "prediction": "i < changed . length ;\n", "label": 1}
{"id": 6439, "input": "<s> package org . ofbiz . content . webapp . ftl ; import java . io . IOException ; import java . io . Writer ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . webapp . control . RequestHandler ; import freemarker . core . Environment ; import freemarker . template . TemplateTransformModel ; public class RenderContentAsText implements TemplateTransformModel { public static final String module = RenderContentAsText . class . getName ( ) ; public static final String [ ] upSaveKeyNames = { \"globalNodeTrail\" } ; public static final String [ ] saveKeyNames = { \"contentId\" , \"subContentId\" , \"subDataResourceTypeId\" , \"mimeTypeId\" , \"whenMap\" , \"locale\" , \"wrapTemplateId\" , \"encloseWrapText\" , \"nullThruDatesOnly\" , \"globalNodeTrail\" } ; @ SuppressWarnings ( \"unchecked\" ) public Writer getWriter ( final Writer out , Map args ) { final Environment env = Environment . getCurrentEnvironment ( ) ; final LocalDispatcher dispatcher = FreeMarkerWorker . getWrappedObject ( \"dispatcher\" , env ) ; final Delegator delegator = FreeMarkerWorker . getWrappedObject ( \"delegator\" , env ) ; final HttpServletRequest request = FreeMarkerWorker . getWrappedObject ( \"request\" , env ) ; final HttpServletResponse response = FreeMarkerWorker . getWrappedObject ( \"response\" , env ) ; final Map < String , Object > templateRoot = FreeMarkerWorker . createEnvironmentMap ( env ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"in RenderSubContent, contentId(0):\" + templateRoot . get ( \"contentId\" ) , module ) ; } FreeMarkerWorker . getSiteParameters ( request , templateRoot ) ; final Map < String , Object > savedValuesUp = FastMap . newInstance ( ) ; FreeMarkerWorker . saveContextValues ( templateRoot , upSaveKeyNames , savedValuesUp ) ; FreeMarkerWorker . overrideWithArgs ( templateRoot , args ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"in RenderSubContent, contentId(2):\" + templateRoot . get ( \"contentId\" ) , module ) ; } final String thisContentId = ( String ) templateRoot . get ( \"contentId\" ) ; final String xmlEscape = ( String ) templateRoot . get ( \"xmlEscape\" ) ; final boolean directAssocMode = UtilValidate . isNotEmpty ( thisContentId ) ? true : false ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"in Render(0), directAssocMode .\" + directAssocMode , module ) ; } final Map < String , Object > savedValues = FastMap . newInstance ( ) ; return new Writer ( out ) { @ Override public void write ( char cbuf [ ] , int off , int len ) { } @ Override public void flush ( ) throws IOException { out . flush ( ) ; } @ Override public void close ( ) throws IOException { List < Map < String , ? extends Object > > globalNodeTrail = UtilGenerics . checkList ( templateRoot . get ( \"globalNodeTrail\" ) ) ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"Render close, globalNodeTrail(2a):\" + ContentWorker . nodeTrailToCsv ( globalNodeTrail ) , \"\" ) ; } renderSubContent ( ) ; } public void renderSubContent ( ) throws IOException { String mimeTypeId = ( String ) templateRoot . get ( \"mimeTypeId\" ) ;", "gt": "Object localeObject = templateRoot . get ( \"locale\" ) ;", "prediction": "if ( debug . verboseOn ( ) )\n", "label": 0}
{"id": 15771, "input": "<s> package org . spliffy . server . web ; import com . bradmcevoy . http . Resource ; import com . bradmcevoy . http . exceptions . BadRequestException ; import com . bradmcevoy . http . exceptions . NotAuthorizedException ; import java . util . Date ; import org . spliffy . server . db . Organisation ; public abstract class AbstractCollectionResource extends AbstractResource implements SpliffyCollectionResource { private Date modDate ; private Date createdDate ; public AbstractCollectionResource ( Services services ) { super ( services ) ; } public AbstractCollectionResource ( Services services , Date createDate , Date modDate ) { super ( services ) ; this . createdDate = createDate ; this . modDate = modDate ; } @ Override public boolean isDir ( ) { return true ; } @ Override public Date getModifiedDate ( ) { return modDate ; } @ Override public Date getCreateDate ( ) { return createdDate ; } @ Override public Resource", "gt": "child ( String childName ) throws NotAuthorizedException , BadRequestException", "prediction": "getCreatedDate ( )\n", "label": 1}
{"id": 3924, "input": "<s> package com . sun . tools . javac . processing ; import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . MalformedURLException ; import java . net . URL ; class ServiceProxy { static class ServiceConfigurationError extends Error { static final long serialVersionUID = 7732091036771098303L ; ServiceConfigurationError ( String msg ) { super ( msg ) ; } } private static final String prefix = \"META-INF/services/\" ; private static void fail ( Class < ? > service , String msg ) throws ServiceConfigurationError { throw new ServiceConfigurationError ( service . getName ( ) + \": \" + msg ) ; } private static void fail ( Class < ? > service , URL u , int line , String msg ) throws ServiceConfigurationError { fail ( service , u + \":\" + line + \": \" + msg ) ; } private static boolean parse ( Class < ? > service , URL u ) throws ServiceConfigurationError { InputStream in = null ; BufferedReader r = null ; try { in = u . openStream ( ) ; r = new BufferedReader ( new InputStreamReader ( in , \"utf-8\" ) ) ; int lc = 1 ; String ln ; while ( ( ln = r . readLine ( ) ) != null ) { int ci = ln . indexOf ( '#' ) ; if ( ci >= 0 ) ln = ln . substring ( 0 , ci ) ; ln = ln . trim ( ) ; int n = ln . length ( ) ; if ( n != 0 ) { if ( ( ln . indexOf ( ' ' ) >= 0 ) || ( ln . indexOf ( '\\t' ) >= 0 ) ) fail ( service , u , lc , \"Illegal configuration-file syntax\" ) ; int cp = ln . codePointAt ( 0 ) ; if ( ! Character . isJavaIdentifierStart ( cp ) ) fail ( service , u , lc , \"Illegal provider-class name: \" + ln ) ; for ( int i = Character . charCount ( cp ) ; i < n ; i += Character . charCount ( cp ) ) { cp = ln . codePointAt ( i ) ; if ( ! Character . isJavaIdentifierPart ( cp ) && ( cp != '.' ) ) fail ( service , u , lc , \"Illegal provider-class name: \" + ln ) ; } return true ; } } }", "gt": "catch ( FileNotFoundException x )", "prediction": "}\n", "label": 0}
{"id": 15773, "input": "<s> package monbulk . client ; import arc . mf . client . RemoteServer ; import arc . mf . session . DefaultLoginDialog ; import arc . mf . session . ErrorDialog ; import arc . mf . session . LoginDialog ; import arc . mf . session . Session ; import arc . mf . session . SessionHandler ; import arc . gui . gwt . widget . ContainerWidget ; import com . google . gwt . core . client . EntryPoint ; import com . google . gwt . user . client . Window ; import com . google . gwt . user . client . ui . RootPanel ; import monbulk . MediaFlux . Services . MediaFluxServices ; import monbulk . client . desktop . * ; import monbulk . client . desktop . Apps . DarisInterface ; import monbulk . shared . util . GWTLogger ; import monbulk . MetadataEditor . MetadataEditor ; import monbulk . MetadataEditor . MetadataSelectWindow ; import monbulk . MethodBuilder . client . MethodBuilder ; import monbulk . MethodBuilder . client . PreviewWindow ; import monbulk . shared . Services . User ; import monbulk . shared . Services . UserService ; public class Monbulk implements EntryPoint { private static User s_user = null ; private static Settings s_settings = null ; public static Settings getSettings ( ) { return s_settings ; } public static User getUser ( ) { return s_user ; } public void onModuleLoad ( ) { String hostName = Window . Location . getHostName ( ) ; if ( hostName . equals ( \"127.0.0.1\" ) || hostName . equals ( \"localhost\" ) ) { debugLogon ( ) ; String user = Window . Location . getParameter ( \"user\" ) ; GWTLogger . isDebug = user == null || ! user . equals ( \"izzo\" ) ; } else { showLogin ( ) ; GWTLogger . isDebug = false ; } } private void showLogin ( ) { Session . setLoginTitle ( \"Monbulk Logon\" ) ; LoginDialog dlg = new DefaultLoginDialog ( ) ; dlg . setVersion ( Version . VERSION ) ; dlg . setTitle ( \"Monbulk\" ) ; Session . setLoginDialog ( dlg ) ; initialise ( ) ; } private void debugLogon ( ) { String user = Window . Location . getParameter ( \"user\" ) ; if ( user != null && user . equals ( \"izzo\" ) ) { RemoteServer . SVC_URL = \"http://medimage.versi.edu.au:443\" + RemoteServer . SVC_URL ; } else { RemoteServer . SVC_URL = \"http://localhost:81\" + RemoteServer . SVC_URL ; } Session . setAutoLogonCredentials ( \"system\" , \"manager\" , \"change_me\" ) ; initialise ( ) ; } private void initDesktop ( ) { try { Desktop d = new Desktop ( RootPanel . get ( ) ) ; if ( s_user . hasRole ( Roles . MetadataEditor . READONLY ) || s_user . hasRole ( Roles . MetadataEditor . ADMIN ) || s_user . hasRole ( Roles . MetadataEditor . CREATE ) ) { MetadataEditor me = new MetadataEditor ( ) ; d . registerWindow ( me ) ; } MetadataSelectWindow ms = new MetadataSelectWindow ( ) ; d . registerWindow ( ms ) ; if ( s_user . hasRole ( Roles . MetadataEditor . READONLY ) || s_user . hasRole ( Roles . MetadataEditor . ADMIN ) || s_user . hasRole ( Roles . MetadataEditor . CREATE ) ) { MethodBuilder mb = new MethodBuilder ( d . getEventBus ( ) ) ; d . registerWindow ( mb ) ; } PreviewWindow mp = new PreviewWindow ( d . getEventBus ( ) ) ; d . registerWindow ( mp ) ; DarisInterface di = new DarisInterface ( ) ; d . registerWindow ( di ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String msg = e . toString ( ) ; if", "gt": "( e . getCause ( ) != null )", "prediction": "( msg != null )\n", "label": 1}
{"id": 1526, "input": "<s> package org . ofbiz . product . product ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . lang . NullPointerException ; import java . lang . SecurityException ; import java . math . BigDecimal ; import java . nio . ByteBuffer ; import java . sql . Timestamp ; import java . util . Arrays ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import javolution . util . FastSet ; import org . jdom . JDOMException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityJoinOperator ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . category . CategoryWorker ; import org . ofbiz . product . image . ScaleImage ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class ProductServices { public static final String module = ProductServices . class . getName ( ) ; public static final String resource = \"ProductUiLabels\" ; public static final String resourceError = \"ProductErrorUiLabels\" ; public static Map < String , Object > prodFindAllVariants ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > subContext =", "gt": "UtilMisc . makeMapWritable ( context ) ;", "prediction": "new HashMap < String , Object > ( ) ;\n", "label": 0}
{"id": 15781, "input": "<s> package tk . blackwolf12333 . grieflog . data . block ; import org . bukkit . Bukkit ; import org . bukkit . Location ; import org . bukkit . Material ; import org . bukkit . World ; import org . bukkit . block . Block ; import org . bukkit . block . BlockFace ; import tk . blackwolf12333 . grieflog . PlayerSession ; import tk . blackwolf12333 . grieflog . utils . Events ; public class BlockBreakData extends BaseBlockData { public BlockBreakData ( Block block , String playerName , Integer gamemode ) { putBlock ( block ) ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; } public BlockBreakData ( Integer x , Integer y , Integer z , String world , String blockType , byte blockData , String playerName , Integer gamemode ) { this . blockX = x ; this . blockY = y ; this . blockZ = z ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; } public BlockBreakData ( String time , Integer x , Integer y , Integer z , String world , String blockType , byte blockData , String playerName , Integer gamemode ) { this . time = time ; this . blockX = x ; this . blockY = y ; this . blockZ = z ; this . blockType = blockType ; this . blockData = blockData ; this . worldName = world ; this . playerName = playerName ; this . gamemode = gamemode ; this . event = Events . BREAK ; this . xyz = blockX + \", \" + blockY + \", \" + blockZ ; } @ Override public void rollback ( ) { try { World w = Bukkit . getWorld ( worldName ) ; Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; w . getBlockAt ( loc ) . setTypeIdAndData ( Material . getMaterial ( blockType ) . getId ( ) , blockData , true ) ; if ( blockType . contains ( \"DOOR\" ) ) { w . getBlockAt ( getOtherDoorBlock ( w . getBlockAt ( loc ) ) ) . setTypeIdAndData ( Material . getMaterial ( blockType ) . getId ( ) , blockData , true ) ; } } catch ( Exception e ) { } } @ Override public String getMinimal ( ) { return time + \" \" + playerName + \" broke \" + blockType . toLowerCase ( ) + \".\" ; } @ Override public boolean isInWorldEditSelectionOf ( PlayerSession player ) { Location loc = new Location ( Bukkit . getWorld ( worldName ) , blockX , blockY , blockZ ) ; return player . getWorldEditSelection ( ) . contains ( loc ) ; } @ Override public String toString ( ) { if ( time != null ) { return time + \" \" + event + \" By: \" + playerName + \" GM: \" + gamemode + \" What: \" + blockType + \":\" + blockData + \" on Pos: \" + xyz + \" in: \" + worldName ; } return \" \" + event + \" By: \" + playerName + \" GM: \" + gamemode + \" What: \" + blockType + \":\" + blockData + \" on Pos: \" + blockX . toString ( ) + \", \" + blockY . toString ( ) + \", \" + blockZ . toString ( ) + \" in: \" + worldName ; } private Location getOtherDoorBlock ( Block door ) { BlockFace [ ] faces = new BlockFace [ ] { BlockFace . DOWN , BlockFace . UP } ; for ( BlockFace face : faces ) { if ( door . getRelative ( face ) . getType ( ) . equals", "gt": "( Material . AIR ) )", "prediction": "( \"DOOR\" ) )\n", "label": 1}
{"id": 9516, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Warn extends TaskAttribute , ResourceAttribute { LogicalExpression getExpression ( ) ;", "gt": "void setExpression ( LogicalExpression value ) ;", "prediction": "}\n", "label": 0}
{"id": 15783, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . constants ; public final class UserWorkspaceConstants { public static final String USERS_PERSONAL_WORKSPACES_ROOT = \"UserWorkspaces\" ; public static final String PERSONAL_WORKSPACE_LABEL = \"command.user.personal.workspace\" ; public static", "gt": "final String REPOSITORY_WORKSPACE_LABEL = \"command.user.return.to.repository\" ;", "prediction": "final String PERSONAL_WORKSPACE_LABEL_KEY = \"user.personal.workspace.key\" ;\n", "label": 1}
{"id": 525, "input": "<s> package api . better ; public class Artist { private Number aliasId ; private Number id ; private String name ; public Number getAliasId ( ) { return this . aliasId ; } public Number getId ( ) { return this . id ; } public String getName ( ) { return this . name ; } @ Override public String toString ( ) { return \"Artist [getAliasId=\" + getAliasId ( ) + \", getId=\" + getId ( )", "gt": "+ \", getName=\" + getName ( ) + \"]\" ;", "prediction": ") ;\n", "label": 0}
{"id": 15788, "input": "<s> package org . eclipse . ui . internal ; public class DirtyPerspectiveMarker { public DirtyPerspectiveMarker ( String id ) { perspectiveId = id ; } public String perspectiveId ; public int hashCode ( ) { return perspectiveId . hashCode ( ) ; } public boolean equals ( Object o ) { if ( o instanceof DirtyPerspectiveMarker ) { return perspectiveId . equals ( ( ( DirtyPerspectiveMarker ) o", "gt": ") . perspectiveId ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 6400, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram", "gt": ". edit . helpers ;", "prediction": ";\n", "label": 0}
{"id": 15790, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; public interface ChapterRef extends Chapter { Chapter getChapter ( ) ;", "gt": "void setChapter ( Chapter value ) ;", "prediction": "}\n", "label": 1}
{"id": 1760, "input": "<s> package a ; public class A { protected void foo ( ) {", "gt": "throw new InternalError ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15796, "input": "<s> package org . gatein . common . util ; public class ConversionException extends Exception { private static final long serialVersionUID = 4647584036804084315L ; public ConversionException ( ) { } public ConversionException ( String message ) { super ( message ) ; } public", "gt": "ConversionException ( String message , Throwable cause )", "prediction": "ConversionException ( String message )\n", "label": 1}
{"id": 4729, "input": "<s> enum T6509042 { A , B ; Class < T6509042 > cl = T6509042 . class ; T6509042 ( ) { Class < T6509042", "gt": "> cl2 = T6509042 . class ;", "prediction": "> result = cl . getClass ( ) ;\n", "label": 0}
{"id": 15797, "input": "<s> package localServices ; public class StatusException extends Exception { private static final long serialVersionUID = 1L ; private Status status ; public StatusException ( Status status ) { this . status = status ; } public StatusException ( Status status , String message ) { super ( message ) ;", "gt": "this . status = status ;", "prediction": "}\n", "label": 1}
{"id": 1013, "input": "<s> package pkg ; public class TestException extends Exception { public int field ; public TestException ( ) { }", "gt": "public void method ( )", "prediction": "}\n", "label": 0}
{"id": 15803, "input": "<s> package com . poetry . controller ; import java . io . IOException ; import java . io . PrintWriter ; import javax . servlet . http . Cookie ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . beans . factory . annotation . Qualifier ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . ResponseBody ; import com . poetry . model . Poet ; import com . poetry . model . SignStatus ; import com . poetry . service . PoetService ; import com . poetry . util . SignUtils ; @ Controller public class SignController extends AbstractController { @ Autowired @ Qualifier ( \"authenticationManager\" ) protected AuthenticationManager authenticationManager ; @ Autowired protected PoetService poetService ; @ RequestMapping ( value = \"/service/signstatus\" , method = RequestMethod . GET ) @ ResponseBody public SignStatus getStatus ( ) { if ( SignUtils . isSignIn ( ) ) { return new SignStatus ( SignUtils . getSignedInUsername ( ) , \"success\" ) ; } else { return new SignStatus ( null , \"fail\" ) ; } } @ RequestMapping ( value = \"/service/signin\" , method = RequestMethod . POST ) @ ResponseBody public SignStatus login ( @ RequestParam ( \"j_username\" ) String username , @ RequestParam ( \"j_password\" ) String password , HttpServletResponse response ) { final UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; final Poet details = new Poet ( ) ; details . setUsername ( username ) ; token . setDetails ( details ) ; try { final Authentication auth = authenticationManager . authenticate ( token ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; final Cookie cookie = new Cookie ( \"username\" , username ) ; cookie . setMaxAge ( 0 ) ; response . addCookie ( cookie ) ; return new SignStatus ( auth . getName ( ) , \"success\" ) ; } catch ( BadCredentialsException e ) { return new SignStatus ( null , \"fail\" ) ; } } @ RequestMapping ( value = \"/service/signout\" ) public void logout ( final HttpServletResponse response ) { final Cookie cookie = new Cookie ( \"username\" , null ) ; cookie . setMaxAge ( 0 ) ; response . addCookie ( cookie ) ; } @ RequestMapping ( value = \"/service/signup\" ) @ ResponseBody public SignStatus signup ( final Poet poet , final HttpServletResponse response ) { poetService . addNewPoet ( poet ) ; return login ( poet . getUsername ( )", "gt": ", poet . getPassword ( ) , response ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9865, "input": "<s> package objects ; import java . awt . Color ; import javax . swing . JScrollPane ; import javax . swing . JTable ; import javax . swing . border . MatteBorder ; public class MyScrollPane extends JScrollPane { public MyScrollPane ( JTable table ) { super ( table ) ; MatteBorder border = new MatteBorder ( 0 , 0 , 0 , 1 , new Color ( 34 , 34", "gt": ", 34 ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 15806, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . analysis . * ; import org . apache . lucene . document . * ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . queryParser . QueryParser ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; import java . io . IOException ; import java . io . Reader ; public class TestPhraseQuery extends LuceneTestCase { public static final float SCORE_COMP_THRESH = 1e-6f ; private IndexSearcher searcher ; private PhraseQuery query ; private RAMDirectory directory ; public void setUp ( ) throws Exception { super . setUp ( ) ; directory = new RAMDirectory ( ) ; Analyzer analyzer = new Analyzer ( ) { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new WhitespaceTokenizer ( reader ) ; } public int getPositionIncrementGap ( String fieldName ) { return 100 ; } } ; IndexWriter writer = new IndexWriter ( directory , analyzer , true , IndexWriter . MaxFieldLength . LIMITED ) ; Document doc = new Document ( ) ; doc . add ( new Field ( \"field\" , \"one two three four five\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; doc . add ( new Field ( \"repeated\" , \"this is a repeated field - first part\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; Fieldable repeatedField = new Field ( \"repeated\" , \"second part of a repeated field\" , Field . Store . YES , Field . Index . ANALYZED ) ; doc . add ( repeatedField ) ; doc . add ( new Field ( \"palindrome\" , \"one two three two one\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new Field ( \"nonexist\" , \"phrase exist notexist exist found\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new Field ( \"nonexist\" , \"phrase exist notexist exist found\" , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; writer . optimize ( ) ; writer . close ( ) ; searcher = new IndexSearcher ( directory ) ; query = new PhraseQuery ( ) ; } public void tearDown ( ) throws Exception { super . tearDown ( ) ; searcher . close ( ) ; directory . close ( ) ; } public", "gt": "void testNotCloseEnough ( ) throws Exception", "prediction": "void tearDown ( ) throws Exception\n", "label": 1}
{"id": 8889, "input": "<s> import java . util . * ; @ interface ExpectInterfaces { String value ( ) ; } @ interface ExpectSupertype { String value ( ) ; } interface OK { void m ( ) ; } class InvalidSource { @ ExpectSupertype ( \"!:empty clss A!\" ) class TestClassMissingClassA extends A { } @ ExpectSupertype ( \"!:empty clss (pkg A).B!\" ) class TestClassMissingClassAB extends A . B { } @ ExpectSupertype ( \"!:empty clss (pkg java.util).A!\" ) class TestClassMissingClass_juA extends java . util . A { } @ ExpectSupertype ( \"!:empty clss A!<tvar T>\" ) class TestClassTMissingClassAT < T > extends A < T > { } @ ExpectInterfaces ( \"!:empty intf A!\" ) class TestClassMissingIntfA implements A { } @ ExpectInterfaces ( \"!:empty intf (pkg A).B!\" ) class TestClassMissingIntfAB implements A . B { } @ ExpectInterfaces ( \"!:empty intf A!, intf OK\" ) abstract class TestClassMissingIntfAOK implements A , OK { } @ ExpectInterfaces ( \"intf OK, !:empty intf A!\" ) abstract class TestClassOKMissingIntfA implements OK , A { } @ ExpectInterfaces ( \"!:empty intf A!, !:empty intf B!\" ) class TestClassMissingIntfA_B implements A , B { } @ ExpectInterfaces ( \"!:empty intf A!\" ) interface TestIntfMissingIntfA extends A { } @ ExpectInterfaces ( \"!:empty intf A!, intf OK\" ) interface TestIntfMissingIntfAOK extends A , OK { } @ ExpectInterfaces ( \"intf OK, !:empty intf A!\"", "gt": ") interface TestIntfOKMissingIntfA extends OK , A", "prediction": ") interface TestIntfMissingIntfA_B extends A , B\n", "label": 0}
{"id": 15812, "input": "<s> package monbulk . shared . Services ; import com . google . gwt . core . client . GWT ; import monbulk . shared . util . MonbulkEnums . * ; public abstract class UserService implements iService { public static UserService get ( ) { try { UserService service = ( UserService ) ServiceRegistry . getService ( ServiceNames . User ) ; return service ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT .", "gt": "log ( e . toString ( ) ) ;", "prediction": "error ( e . getMessage ( ) ) ;\n", "label": 1}
{"id": 9602, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . javadoc . * ; public class CommentedMethodFinder extends MethodFinder { public boolean isCorrectMethod ( MethodDoc method ) { return method . inlineTags", "gt": "( ) . length > 0 ;", "prediction": ";\n", "label": 0}
{"id": 15832, "input": "<s> package com . yahoo . ycsb ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import com . yahoo . ycsb . client . MasterClient ; public class LoadGenerator { @ SuppressWarnings ( \"rawtypes\" ) public static void main ( String [ ] args ) { Config config = Config . getConfig ( ) ; Properties props = new Properties ( ) ; Properties fileprops = new Properties ( ) ; boolean dotransactions = true ; int threadcount = 1 ; int target = 0 ; String label = \"\" ; int argindex = 0 ; if ( args . length == 0 ) { usageMessage ( ) ; System . exit ( 0 ) ; } while ( args [ argindex ] . startsWith ( \"-\" ) ) { if ( args [ argindex ] . compareTo ( \"-threads\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; int tcount = Integer . parseInt ( args [ argindex ] ) ; config . thread_count = tcount ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-target\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; int ttarget = Integer . parseInt ( args [ argindex ] ) ; config . target = ttarget ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-load\" ) == 0 ) { config . do_transactions = false ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-t\" ) == 0 ) { config . do_transactions = true ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-db\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; config . db = args [ argindex ] ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-l\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; label = args [ argindex ] ; argindex ++ ; } else if ( args [ argindex ] . compareTo ( \"-P\" ) == 0 ) { argindex ++ ; checkMoreArgs ( argindex , args . length ) ; String propfile = args [ argindex ] ; argindex ++ ; Properties myfileprops = new Properties ( ) ; try { myfileprops . load ( new FileInputStream ( propfile ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; System . exit ( 0 ) ; } for ( Enumeration e = myfileprops . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String prop = ( String ) e . nextElement ( ) ; fileprops . setProperty ( prop , myfileprops . getProperty ( prop ) ) ; config . setProperty ( prop , myfileprops . getProperty ( prop ) ) ; } } else if ( args", "gt": "[ argindex ] . compareTo ( \"-p\" ) == 0 )", "prediction": ". length == 0 )\n", "label": 1}
{"id": 439, "input": "<s> package com . redhat . ceylon . importjar ; import java . io . IOException ; public class ImportJarMain { private static final String CEYLOND_VERSION = \"0.4 'Ratatouille'\" ; private static final int SC_OK = 0 ; private static final int SC_ARGS = 1 ; private static final int SC_ERROR = 2 ; public static void main ( String [ ] args ) throws IOException { String destDir = null ; String user = null , pass = null ; String moduleSpec = null ; String jarFile = null ; boolean verbose = false ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; int argsLeft = args . length - 1 - i ; if ( \"-h\" . equals ( arg ) || \"-help\" . equals ( arg ) || \"--help\" . equals ( arg ) ) { printUsage ( SC_OK ) ; } else if ( \"-v\" . equals ( arg ) || \"-version\" . equals ( arg ) || \"--version\" . equals ( arg ) ) { printVersion ( ) ; } else if ( \"-d\" . equals ( arg ) ) { System . err . println ( ImportJarMessages . msg ( \"error.optionDnotSupported\" ) ) ; exit ( SC_ARGS ) ; } else if ( \"-debug\" . equals ( arg ) ) { verbose = true ; } else if ( \"-out\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } destDir = args [ ++ i ] ; } else if ( \"-user\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } user = args [ ++ i ] ; } else if ( \"-pass\" . equals ( arg ) ) { if ( argsLeft <= 0 ) { optionMissingArgument ( arg ) ; } pass = args [ ++ i ] ; } else if ( arg . startsWith ( \"-\" ) ) { System . err . println ( ImportJarMessages . msg ( \"error.optionUnknown\" , arg ) ) ; exit ( SC_ARGS ) ; } else if ( moduleSpec == null ) { moduleSpec = arg ; } else if ( jarFile == null ) { jarFile = arg ; } else { System . err . println ( ImportJarMessages . msg ( \"error.tooManyArguments\" , arg ) ) ; exit ( SC_ARGS ) ; } } if ( moduleSpec == null || moduleSpec . isEmpty ( ) ) { System . err . println ( ImportJarMessages . msg ( \"error.noModuleSpecified\" ) ) ; printUsage ( SC_ARGS ) ; } if ( jarFile == null || jarFile . isEmpty ( ) ) { System . err . println ( ImportJarMessages . msg ( \"error.noJarFileSpecified\" ) ) ; printUsage ( SC_ARGS ) ; } if ( destDir == null ) { destDir = \"modules\" ; } try { CeylonImportJarTool importJar = new CeylonImportJarTool ( moduleSpec , destDir , user , pass , jarFile , verbose ) ; importJar . publish ( ) ; } catch ( ImportJarException x ) { System . err . println ( ImportJarMessages . msg ( \"error\" , x . getLocalizedMessage ( ) ) ) ; exit ( SC_ERROR ) ; } catch ( Exception x ) { System . err . println ( ImportJarMessages . msg ( \"error\" , x . getLocalizedMessage ( ) ) ) ; x . printStackTrace ( ) ; exit ( SC_ERROR ) ; } } private static void exit ( int statusCode ) { System . exit ( statusCode ) ; } private static void optionMissingArgument ( String arg ) { System . err . println ( ImportJarMessages . msg ( \"error.optionMissing\" , arg ) ) ; exit ( SC_ARGS ) ; } private static void printVersion ( ) { System . out . println ( ImportJarMessages . msg ( \"info.version\" , CEYLOND_VERSION ) ) ;", "gt": "exit ( SC_OK ) ;", "prediction": "exit ( SC_ARGS ) ;\n", "label": 0}
{"id": 15834, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . compatible . controllers ; import android . support . v4 . app . FragmentActivity ; public class BlandBubbleController extends AbstractBubbleController { public BlandBubbleController ( FragmentActivity activity ) { super ( activity ) ; } @", "gt": "Override public void onBubbleAttachedToWindow ( )", "prediction": "Override protected void setUp ( ) throws Exception\n", "label": 1}
{"id": 2202, "input": "<s> class T6910550d { < X > void m ( X x ) { } < Y >", "gt": "void m ( Y y )", "prediction": "void m ( Y y )\n", "label": 0}
{"id": 15835, "input": "<s> package org . gatein . common . i18n ; import junit . framework . TestCase ; import org . gatein . common . i18n . BundleName ; public class BundleNameParserTestCase extends TestCase { private final BundleName . Parser parser = new BundleName . Parser ( ) ; private static final Test [ ] tests = { new Test ( \"_\" , null ) , new Test ( \"__\" , null ) , new Test ( \"___\" , null ) , new Test ( \"a\" , new BundleName ( \"a\" ) ) , new Test ( \"a_b\" , new BundleName ( \"a\" , \"b\" ) ) , new Test ( \"a_b_c\" , new BundleName ( \"a\" , \"b\" , \"c\" ) ) , new Test ( \"a__b\" , new BundleName ( \"a\" , \"\" , \"b\" ) ) , new Test ( \"a___b\" , new BundleName ( \"a\" , \"\" , \"\" , \"b\" ) ) , new Test ( \"a__b_c\" , new BundleName ( \"a\" , \"\" , \"b\" , \"c\" ) ) , new Test ( \"a_b__c\" , new BundleName ( \"a\" , \"b\" , \"\" , \"c\" ) ) , new Test ( \"a_b_c_d\" , new BundleName ( \"a\" , \"b\" , \"c\" , \"d\" ) ) , new Test ( \"\" , new BundleName ( \"\" ) ) , new Test ( \"_b\" , new BundleName ( \"\" , \"b\" ) ) , new Test ( \"_b_c\" , new BundleName ( \"\" , \"b\" , \"c\" ) ) , new Test ( \"__b\" , new BundleName ( \"\" , \"\" , \"b\" ) ) , new Test ( \"___b\" , new BundleName ( \"\" , \"\" , \"\" , \"b\" ) ) , new Test ( \"__b_c\" , new BundleName ( \"\" , \"\" , \"b\" , \"c\" ) ) , new Test ( \"_b__c\" , new BundleName ( \"\" , \"b\" , \"\" , \"c\" ) ) , new Test ( \"_b_c_d\" , new BundleName ( \"\" , \"b\" , \"c\" , \"d\" ) ) , } ; public void testA ( ) { for ( int i = 0 ; i < tests . length ; i ++ ) { Test test = tests [ i ] ; BundleName name = parser . parse ( test . input , 0 , test . input . length ( ) ) ; if ( name == null ) { assertNull ( test . input , test . expectedName ) ; } else { assertNotNull ( test . input , test . expectedName ) ; assertEquals ( test . input , test . expectedName . getBaseName ( ) , name .", "gt": "getBaseName ( ) ) ;", "prediction": "getBaseName ( ) ) ;\n", "label": 1}
{"id": 922, "input": "<s> import java . util . * ; class G3 { G3 ( Enumeration < Object > e ) { } static void g ( ) { new G3 ( new Enumeration ( ) { public boolean hasMoreElements ( ) { return false ; }", "gt": "public Object nextElement ( )", "prediction": "}\n", "label": 0}
{"id": 15851, "input": "<s> package org . eclipse . rap . demo ; import java . net . URL ; import java . util . Dictionary ; import org . eclipse . core . runtime . Platform ; import org . eclipse . jface . action . * ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . wizard . WizardDialog ; import org . eclipse . rap . demo . editor . FooEditorInput ; import org . eclipse . rap . demo . wizard . SurveyWizard ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . * ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . actions . ContributionItemFactory ; import org . eclipse . ui . actions . ActionFactory . IWorkbenchAction ; import org . eclipse . ui . application . ActionBarAdvisor ; import org . eclipse . ui . application . IActionBarConfigurer ; import org . eclipse . ui . browser . IWebBrowser ; import org . eclipse . ui . browser . IWorkbenchBrowserSupport ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . * ; public class DemoActionBarAdvisor extends ActionBarAdvisor { private IWebBrowser browser ; private IWorkbenchAction exitAction ; private IWorkbenchAction importAction ; private IWorkbenchAction exportAction ; private Action aboutAction ; private Action rapWebSiteAction ; private MenuManager showViewMenuMgr ; private IWorkbenchAction preferencesAction ; private Action wizardAction ; private Action browserAction ; public IWorkbenchAction saveAction ; private IWorkbenchAction saveAllAction ; private Action newEditorAction ; private static int browserIndex ; public DemoActionBarAdvisor ( final IActionBarConfigurer configurer ) { super ( configurer ) ; } protected void makeActions ( final IWorkbenchWindow window ) { ImageDescriptor quitActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/ttt.gif\" ) ; ImageDescriptor helpActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/help.gif\" ) ; ImageDescriptor wizardActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/login.gif\" ) ; ImageDescriptor browserActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/internal_browser.gif\" ) ; ImageDescriptor rapWebSiteActionImage = AbstractUIPlugin . imageDescriptorFromPlugin ( \"org.eclipse.rap.demo\" , \"icons/browser.gif\" ) ; exitAction = ActionFactory . QUIT . create ( window ) ; exitAction . setImageDescriptor ( quitActionImage ) ; register ( exitAction ) ; importAction = ActionFactory . IMPORT . create ( window ) ; register ( importAction ) ; exportAction = ActionFactory . EXPORT . create ( window ) ; register ( exportAction ) ; saveAction = ActionFactory . SAVE . create ( window ) ; register ( saveAction ) ; saveAllAction = ActionFactory . SAVE_ALL . create ( window ) ; register ( saveAllAction ) ; preferencesAction = ActionFactory . PREFERENCES . create ( window ) ; register ( preferencesAction ) ; newEditorAction = new Action ( ) { public void run ( ) { try { window . getActivePage ( ) . openEditor ( new FooEditorInput ( DemoActionBarAdvisor . this ) , \"org.eclipse.rap.demo.editor\" , true ) ; } catch ( PartInitException e ) { e . printStackTrace ( ) ; } } } ; newEditorAction . setText ( \"Open new editor\" ) ; newEditorAction . setId ( \"org.eclipse.rap.demo.neweditor\" ) ; newEditorAction . setImageDescriptor ( window . getWorkbench ( ) . getSharedImages ( ) . getImageDescriptor ( ISharedImages . IMG_TOOL_NEW_WIZARD ) ) ; register ( newEditorAction ) ; aboutAction = new Action ( ) { public void run ( ) { Shell shell = window . getShell ( ) ; Bundle bundle = Platform . getBundle ( PlatformUI . PLUGIN_ID ) ; Dictionary headers = bundle . getHeaders ( ) ; Object version = headers . get ( Constants . BUNDLE_VERSION ) ; MessageDialog . openInformation ( shell , \"RAP Workbench Demo\" , \"Running on RAP version \" + version ) ; } } ; aboutAction . setText ( \"About\" ) ; aboutAction . setId ( \"org.eclipse.rap.demo.about\" ) ; aboutAction . setImageDescriptor ( helpActionImage ) ; register ( aboutAction ) ; rapWebSiteAction = new Action ( ) { public void run ( ) { IWorkbenchBrowserSupport browserSupport ; browserSupport = PlatformUI . getWorkbench ( ) . getBrowserSupport ( ) ; try { int style = IWorkbenchBrowserSupport . AS_EXTERNAL ; browser = browserSupport . createBrowser ( style , rapWebSiteAction . getId ( ) , \"\" , \"\" ) ; browser . openURL ( new URL ( \"http://eclipse.org/rap\" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ; rapWebSiteAction . setText ( \"RAP Home Page\" ) ; rapWebSiteAction . setId ( \"org.eclipse.rap.demo.rapWebSite\" ) ; rapWebSiteAction . setImageDescriptor ( rapWebSiteActionImage ) ; register ( rapWebSiteAction ) ; showViewMenuMgr = new MenuManager ( \"Show View\" , \"showView\" ) ; IContributionItem showViewMenu = ContributionItemFactory . VIEWS_SHORTLIST . create ( window ) ; showViewMenuMgr . add ( showViewMenu ) ; wizardAction = new Action ( ) { public void run ( ) { SurveyWizard wizard = new SurveyWizard ( ) ; WizardDialog dlg = new WizardDialog ( window . getShell ( ) , wizard ) ; dlg . open ( ) ; } } ; wizardAction . setText ( \"Open wizard\" ) ; wizardAction . setId ( \"org.eclipse.rap.demo.wizard\" ) ; wizardAction . setImageDescriptor ( wizardActionImage ) ; register ( wizardAction ) ; browserAction = new Action ( ) { public void run ( ) { browserIndex ++ ; try { window . getActivePage ( ) . showView ( \"org.eclipse.rap.demo.DemoBrowserViewPart\" , String . valueOf", "gt": "( browserIndex ) , IWorkbenchPage . VIEW_ACTIVATE ) ;", "prediction": "( browserIndex ) ) ;\n", "label": 1}
{"id": 800, "input": "<s> package org . ofbiz . base . util . collections ; import java . io . Serializable ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . Set ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . string . FlexibleStringExpander ; @ SuppressWarnings ( \"serial\" ) public class ResourceBundleMapWrapper implements Map < String , Object > , Serializable { protected MapStack < String > rbmwStack ; protected ResourceBundle initialResourceBundle ; protected Map < String , Object > context ; protected ResourceBundleMapWrapper ( ) { rbmwStack = MapStack . create ( ) ; } public ResourceBundleMapWrapper ( InternalRbmWrapper initialInternalRbmWrapper ) { this . initialResourceBundle = initialInternalRbmWrapper . getResourceBundle ( ) ; this . rbmwStack = MapStack . create ( initialInternalRbmWrapper ) ; } public ResourceBundleMapWrapper ( ResourceBundle initialResourceBundle ) { if ( initialResourceBundle == null ) { throw new IllegalArgumentException ( \"Cannot create ResourceBundleMapWrapper with a null initial ResourceBundle.\" ) ; } this . initialResourceBundle = initialResourceBundle ; this . rbmwStack = MapStack . create ( new InternalRbmWrapper ( initialResourceBundle ) ) ; } public ResourceBundleMapWrapper ( ResourceBundle initialResourceBundle , Map < String , Object > context ) { if ( initialResourceBundle == null ) { throw new IllegalArgumentException ( \"Cannot create ResourceBundleMapWrapper with a null initial ResourceBundle.\" ) ; } this . initialResourceBundle = initialResourceBundle ; this . rbmwStack = MapStack . create ( new InternalRbmWrapper ( initialResourceBundle ) ) ; this . context = context ; } public void addBottomResourceBundle ( ResourceBundle topResourceBundle ) { this . rbmwStack . addToBottom ( new InternalRbmWrapper ( topResourceBundle ) ) ; } public void addBottomResourceBundle ( InternalRbmWrapper topInternalRbmWrapper ) { this . rbmwStack . addToBottom ( topInternalRbmWrapper ) ; } public void addBottomResourceBundle ( String resource ) { if ( this . initialResourceBundle == null ) { throw new IllegalArgumentException ( \"Cannot add bottom resource bundle, this wrapper was not properly initialized (there is no base/initial ResourceBundle).\" ) ; } this . addBottomResourceBundle ( new InternalRbmWrapper ( UtilProperties . getResourceBundle ( resource , this . initialResourceBundle . getLocale ( ) ) ) ) ; } public void pushResourceBundle ( ResourceBundle topResourceBundle ) { this . rbmwStack . push ( new InternalRbmWrapper ( topResourceBundle ) ) ; } public ResourceBundle getInitialResourceBundle ( ) { return this . initialResourceBundle ; } public void clear ( ) { this . rbmwStack . clear ( ) ; } public boolean containsKey ( Object arg0 ) { return this . rbmwStack . containsKey ( arg0 ) ; } public boolean containsValue ( Object arg0 ) { return this . rbmwStack . containsValue ( arg0 ) ; } public Set < Map . Entry < String , Object > > entrySet ( ) { return this . rbmwStack . entrySet ( ) ; } public Object get ( Object arg0 ) { Object value = this . rbmwStack . get ( arg0 ) ; if ( value == null ) { value = arg0 ; } else if ( context != null ) { try { String str = ( String ) value ; return FlexibleStringExpander . expandString ( str , context ) ; } catch ( Exception e ) { } } return value ; } public boolean isEmpty ( ) { return this . rbmwStack . isEmpty ( ) ; } public Set < String > keySet ( ) { return this . rbmwStack . keySet ( ) ; } public Object put ( String key , Object value ) { return this . rbmwStack . put ( key , value ) ; } public void putAll ( Map < ? extends String , ? extends Object > arg0 ) { this . rbmwStack . putAll ( arg0 ) ; } public Object remove ( Object arg0 ) { return this . rbmwStack . remove ( arg0 ) ; } public int size ( ) { return this . rbmwStack . size ( ) ; }", "gt": "public Collection < Object > values ( )", "prediction": "}\n", "label": 0}
{"id": 15856, "input": "<s> package org . restlet . ext . jdbc ; import java . io . Serializable ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; public class JdbcResult implements Serializable { private static final long serialVersionUID = 1L ; private volatile transient Statement statement ; public JdbcResult ( Statement statement ) { this . statement = statement ; } public ResultSet getGeneratedKeys ( ) throws SQLException { return this . statement . getGeneratedKeys ( ) ; } public ResultSet getResultSet ( ) throws SQLException { return this . statement . getResultSet ( ) ; } public int getUpdateCount ( ) throws SQLException { return this . statement . getUpdateCount ( ) ; }", "gt": "public void release ( ) throws SQLException", "prediction": "}\n", "label": 1}
{"id": 1983, "input": "<s> package com . midtro . platform . modules . assets ; public class IndexEntry { private final long CRC ; private final String type ; private final String name ; private final String fileName ; public IndexEntry ( long CRC , String type , String name , String fileName ) { this . CRC = CRC ; this . type = type ; this . name = name ; this . fileName = fileName ; } public long getCRC ( ) { return CRC ; }", "gt": "public String getType ( )", "prediction": "public String getFileName ( )\n", "label": 0}
{"id": 15860, "input": "<s> package br . org . archimedes . controller . commands ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . UndoableCommand ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Point ; public abstract class ZoomCommand implements UndoableCommand { private double previousZoom ; private Point previousViewport ; private double newZoom ; private Point newViewport ; public ZoomCommand ( ) { previousZoom = - 1 ; previousViewport = null ; } public void doIt ( Drawing drawing ) throws IllegalActionException , NullArgumentException { if ( drawing == null ) { throw new NullArgumentException ( ) ; } if ( previousZoom < 0 ) { previousZoom = drawing . getZoom ( ) ; previousViewport = drawing . getViewportPosition ( ) ; newZoom = calculateZoom ( drawing ) ; newViewport = getNewViewport ( drawing ) ; } if ( newZoom > Constant . ZOOM_SUPERIOR_LIMIT ) { newZoom = previousZoom ; newViewport = previousViewport ; throw new IllegalActionException ( Messages . Zoom_reachedMax ) ; } if", "gt": "( newViewport != null )", "prediction": "( previousViewport == null )\n", "label": 1}
{"id": 10013, "input": "<s> package com . pagosoft . swing ; import java . awt . * ; import java . util . Map ; import java . util . TreeMap ; public class ColorUtils { public static Color toColor ( String str ) { switch ( str . charAt ( 0 ) ) { case '(' : int red , green , blue ; int index ; red = nextColorInt ( str , 1 ) ; index = str . indexOf ( ',' ) ; green = nextColorInt ( str , index + 1 ) ; index = str . indexOf ( ',' , index + 1 ) ; blue = nextColorInt ( str , index + 1 ) ; return new Color ( red , green , blue ) ; case '#' : if ( str . length ( ) == 4 ) { return new Color ( getShorthandValue ( str . charAt ( 1 ) ) , getShorthandValue ( str . charAt ( 2 ) ) , getShorthandValue ( str . charAt ( 3 ) ) ) ; } else { return new Color ( Integer . parseInt ( str . substring ( 1 ) , 16 ) ) ; } default : if ( Character . isDigit ( str . charAt ( 0 ) ) ) { red = nextColorInt ( str , 0 ) ; index = str . indexOf ( ',' ) ; green = nextColorInt ( str , index + 1 ) ; index = str . indexOf ( ',' , index + 1 ) ; blue = nextColorInt ( str , index + 1 ) ; return new Color ( red , green , blue ) ; } return ( Color ) colorNamesMap . get ( str ) ; } } private static int nextColorInt ( String str , int index ) { while ( index < str . length ( ) ) { char c = str . charAt ( index ) ; if ( '0' <= c && c <= '9' ) { break ; } else { index ++ ; } } int colorLength = index ; for ( ; colorLength < index + 3 ; colorLength ++ ) { char c = str . charAt ( colorLength ) ; if ( c < '0' || '9' < c ) { break ; } } return Integer . parseInt ( str . substring ( index , colorLength ) ) ; } private static int getShorthandValue ( char c ) { c = Character . toUpperCase ( c ) ; if ( 'A' <= c && c <= 'F' ) { return colorShorthandTable [ c - 'A' + 10 ] ; } return colorShorthandTable [ c - '0' ] ; } private static int [ ] colorShorthandTable = { 0x00 , 0x11 , 0x22 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xAA , 0xBB , 0xCC , 0xDD , 0xEE , 0xFF } ; private static Map colorNamesMap ; static { colorNamesMap = new TreeMap ( ) ; colorNamesMap . put ( \"white\" , new Color ( 0xFFFFFF ) ) ; colorNamesMap . put ( \"lightGray\" , new Color ( 0xC0C0C0 ) ) ; colorNamesMap . put ( \"gray\" , new Color ( 0x808080 ) ) ; colorNamesMap . put ( \"darkGray\" , new Color ( 0x404040 ) ) ; colorNamesMap . put ( \"black\" , new Color ( 0x000000 ) ) ; colorNamesMap . put ( \"red\" , new Color ( 0xFF0000 ) ) ; colorNamesMap . put ( \"pink\" , new Color ( 0xFFAFAF ) ) ; colorNamesMap . put ( \"orange\" , new Color ( 0xFFC800 ) ) ; colorNamesMap . put ( \"yellow\" , new Color ( 0xFFFF00 ) ) ; colorNamesMap . put ( \"green\" , new Color ( 0x00FF00 ) ) ; colorNamesMap .", "gt": "put ( \"magenta\" , new Color ( 0xFF00FF ) ) ;", "prediction": "put ( \"blue\" , new Color ( 0xFFFFFF ) ) ;\n", "label": 0}
{"id": 15871, "input": "<s> package org . eclipse . ui . internal . wizards ; import org . eclipse . rap . rwt . SingletonUtil ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class ImportWizardRegistry extends AbstractExtensionWizardRegistry { public static synchronized ImportWizardRegistry getInstance ( ) { return SingletonUtil . getSessionInstance ( ImportWizardRegistry . class ) ; } public ImportWizardRegistry ( ) { super ( ) ; } protected String getExtensionPoint ( ) {", "gt": "return IWorkbenchRegistryConstants . PL_IMPORT ;", "prediction": "return SingletonUtil . getSessionInstance ( ImportWizardRegistry . class ) ;\n", "label": 1}
{"id": 6816, "input": "<s> import java . util . ArrayList ; import java . util . List ; class Unchecked { void m ( ) { List l = new ArrayList < String > ( ) ; l . add ( \"abc\" ) ; } } @ SuppressWarnings ( \"unchecked\" ) class Unchecked2 { void m ( ) { List l = new ArrayList < String > ( ) ; l . add ( \"abc\" ) ; } } class Unchecked3 { @ SuppressWarnings ( \"unchecked\" ) void m ( ) { List l = new ArrayList < String > ( ) ; l . add ( \"abc\" ) ; } } class Unchecked4 { void m ( ) { @ SuppressWarnings", "gt": "( \"unchecked\" ) class Inner", "prediction": "( \"unchecked\" ) List l = new ArrayList < String > ( ) ;\n", "label": 0}
{"id": 15872, "input": "<s> package org . eclipse . ui . model ; import org . eclipse . jface . resource . ColorDescriptor ; import org . eclipse . jface . resource . FontDescriptor ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . resource . LocalResourceManager ; import org . eclipse . jface . resource . ResourceManager ; import org . eclipse . jface . viewers . DecoratingLabelProvider ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . LabelProviderChangedEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . ui . IEditorRegistry ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . util . Util ; public class WorkbenchLabelProvider extends LabelProvider implements IColorProvider , IFontProvider { public static ILabelProvider getDecoratingWorkbenchLabelProvider ( ) { return new DecoratingLabelProvider ( new WorkbenchLabelProvider ( ) , PlatformUI . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ; } private IPropertyListener editorRegistryListener = new IPropertyListener ( ) { public void propertyChanged ( Object source , int propId ) { if ( propId == IEditorRegistry . PROP_CONTENTS ) { fireLabelProviderChanged ( new LabelProviderChangedEvent ( WorkbenchLabelProvider . this ) ) ; } } } ; private ResourceManager resourceManager ; public WorkbenchLabelProvider ( ) { PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . addPropertyListener ( editorRegistryListener ) ; } protected ImageDescriptor decorateImage ( ImageDescriptor input , Object element ) { return input ; } protected String decorateText ( String input , Object element ) { return input ; } public void dispose ( ) { PlatformUI . getWorkbench ( ) . getEditorRegistry ( ) . removePropertyListener ( editorRegistryListener ) ; if ( resourceManager != null ) resourceManager . dispose ( ) ; resourceManager = null ; super . dispose ( ) ; } protected final IWorkbenchAdapter getAdapter ( Object o ) { return ( IWorkbenchAdapter ) Util . getAdapter ( o , IWorkbenchAdapter . class ) ; } protected final IWorkbenchAdapter2 getAdapter2 ( Object o ) { return ( IWorkbenchAdapter2 ) Util . getAdapter ( o , IWorkbenchAdapter2 . class ) ; } private ResourceManager getResourceManager ( ) { if ( resourceManager == null ) { resourceManager = new LocalResourceManager ( JFaceResources .", "gt": "getResources ( ) ) ;", "prediction": "class ) ;\n", "label": 1}
{"id": 5770, "input": "<s> public class T6541876b { enum ENUM { ENUM_CONST { public AbstractClass method ( ) { return new AbstractClass ( ) { public boolean method ( ) { return true ; } } ; } } ; public abstract AbstractClass method ( ) ; private abstract class AbstractClass { public abstract boolean method ( ) ; } } public static void main ( String [ ] args ) { ENUM . ENUM_CONST", "gt": ". method ( ) ;", "prediction": "= args ;\n", "label": 0}
{"id": 15874, "input": "<s> package org . gatein . common . io ; import org . gatein . common . logging . Logger ; import org . gatein . common . logging . LoggerFactory ; import org . gatein . common . util . Tools ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . ObjectStreamClass ; import java . io . OutputStream ; import java . io . Reader ; import java . io . Serializable ; import java . io . Writer ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; public class IOTools { public static final Logger log = LoggerFactory . getLogger ( IOTools . class ) ; private static final Object [ ] EMPTY_ARGS = new Object [ 0 ] ; private static final Class < ? > [ ] EMPTY_PARAMETER_TYPES = new Class [ 0 ] ; public static void safeClose ( Object closable ) { if ( closable != null ) { try { Method m = closable . getClass ( ) . getMethod ( \"close\" , EMPTY_PARAMETER_TYPES ) ; if ( Modifier . isStatic ( m . getModifiers ( ) ) ) { log . warn ( \"close() method on closable object is static\" ) ; return ; } m . invoke ( closable , EMPTY_ARGS ) ; } catch ( NoSuchMethodException e ) { log . warn ( \"The closable object does not have a close() method\" , e ) ; } catch ( IllegalAccessException e ) { log . warn ( \"Cannot access close() method on closable object\" , e ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getCause ( ) ; if ( t instanceof RuntimeException ) { log . error ( \"The close() method threw a runtime exception\" , t ) ; throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { log . error ( \"The close() method threw an error\" , t ) ; throw ( Error ) t ; } else if ( t instanceof Exception ) { log . error ( \"The close() method threw an exception\" , t ) ; } else { log . error ( \"The close() method threw an unexpected throwable\" , t ) ; } } } } public static void safeClose ( Closeable out ) { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( \"Error while closing closeable \" + out , e ) ; } } } public static byte [ ] getBytes ( InputStream in ) throws IOException , IllegalArgumentException { return getBytes ( in , Tools . DEFAULT_BUFFER_SIZE ) ; } public static byte [ ] getBytes ( InputStream in , int bufferSize ) throws IOException , IllegalArgumentException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; copy ( in , out , bufferSize ) ; return out . toByteArray ( ) ; } public static byte [ ] safeGetBytes ( InputStream is ) { byte [ ] bytes ; if ( is == null ) { return null ; } try { bytes = getBytes ( is ) ; return bytes ; } catch ( IOException ignore ) { return null ; } finally { IOTools . safeClose ( is ) ; } } public static void copy ( InputStream in , OutputStream out ) throws IOException { copy ( in , out , Tools . DEFAULT_BUFFER_SIZE ) ; } public static void copy ( InputStream in , OutputStream out , int bufferSize ) throws IOException { if ( in == null ) { throw new IllegalArgumentException ( \"null in\" ) ; } if ( out == null ) { throw new IllegalArgumentException ( \"null out\" ) ; } if ( bufferSize < 1 ) { throw new IllegalArgumentException ( \"Buffer size is too small\" ) ; } byte [ ] buffer = new byte [ bufferSize ] ; while ( true ) { int i = in . read ( buffer ) ; if ( i == 0 ) { continue ; } if ( i == - 1 ) { break ; } out . write ( buffer , 0 , i ) ; } } public static void copy ( Reader reader , Writer writer ) throws IOException { copy ( reader , writer , Tools . DEFAULT_BUFFER_SIZE ) ; } public static void copy ( Reader reader , Writer writer ,", "gt": "int bufferSize ) throws IOException", "prediction": "OutputStream out ) throws IOException\n", "label": 1}
{"id": 5172, "input": "<s> package fr . telecom . scrapbook . filters ; public class SaturationModifyFilter implements IImageFilter { public float SaturationFactor = 0.5f ; public Image process ( Image imageIn ) { float saturation = this . SaturationFactor + 1f ; float negosaturation = 1f - saturation ; int r , g , b ; for ( int x = 0 ; x < imageIn . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < imageIn . getHeight ( ) ; y ++ ) { r = imageIn . getRComponent ( x , y ) ; g = imageIn . getGComponent ( x , y ) ; b = imageIn . getBComponent ( x , y ) ; float nego1 = negosaturation * 0.2126f ; float ngeo2 = nego1 + saturation ; float ngeo3 = negosaturation * 0.7152f ; float nego4 = ngeo3 + saturation ; float nego5 = negosaturation * 0.0722f ; float nego6 = nego5 + saturation ; float nego7 = ( ( r * ngeo2 ) + ( g", "gt": "* ngeo3 ) ) + ( b * nego5 ) ;", "prediction": "* ngeo3 ) + ( b * ngeo4 ) ) ;\n", "label": 0}
{"id": 15875, "input": "<s> package org . eclipse . swt . dnd ; import java . io . UnsupportedEncodingException ; import org . eclipse . rap . rwt . SingletonUtil ; public class TextTransfer extends ByteArrayTransfer { private static final String TYPE_NAME = \"text\" ; private static final int TYPE_ID = registerType ( TYPE_NAME ) ; private TextTransfer ( ) { } public static TextTransfer getInstance ( ) { return SingletonUtil . getSessionInstance ( TextTransfer . class ) ; } public void javaToNative ( Object object , TransferData transferData ) { if ( ! checkText ( object ) || ! isSupportedType ( transferData ) ) { DND . error ( DND . ERROR_INVALID_DATA ) ; } transferData . data = object ; transferData . result = 1 ; } public Object nativeToJava ( TransferData transferData ) { if ( ! isSupportedType ( transferData ) || transferData . data == null ) { return null ; } if ( transferData . result != 1 ) return null ; return transferData . data ; } protected int [ ] getTypeIds ( ) { return new int [ ] { TYPE_ID } ; } protected String [ ] getTypeNames ( ) { return new String [ ] { TYPE_NAME } ; } boolean checkText ( Object object ) { return ( object != null && object instanceof String && ( ( String ) object ) . length ( ) > 0 ) ; } protected boolean validate ( Object object ) { return checkText ( object ) ; } static byte [ ] stringToBytes ( String string ) { byte", "gt": "[ ] bytes = null ;", "prediction": "[ ] result = new byte [ string . length ( ) ] ;\n", "label": 1}
{"id": 9103, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface TimesheetReport extends Property {", "gt": "String getFilename ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15883, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . server ; import javax . servlet . http . HttpSession ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class DelegatingServletEngine implements IServletEngine { private final IServletEngine delegate ; private boolean running ; public DelegatingServletEngine ( IServletEngine delegate ) { this . delegate = delegate ; } public IServletEngine getDelegate ( ) { return delegate ; } public void start ( Class < ? extends IEntryPoint > entryPointClass ) throws Exception { checkNotNull ( entryPointClass ) ; checkNotRunning ( ) ; delegate . start ( entryPointClass ) ; running = true ; } public void stop ( ) throws Exception { stop ( 0 ) ; } public void stop ( int timeout ) throws Exception { if ( running ) { delegate . stop ( timeout ) ; running = false ; } } public int getPort ( ) { return delegate . getPort ( ) ; } public HttpSession [ ] getSessions ( ) { if ( ! running ) { String msg = \"Sessions can only be accessed while the servlet engine is running.\" ; throw new IllegalStateException ( msg ) ; } return delegate . getSessions ( ) ; } private void checkNotNull ( Class < ? extends IEntryPoint > entryPointClass ) { if ( entryPointClass == null ) { throw new NullPointerException ( \"entryPointClass\" ) ; } }", "gt": "private void checkNotRunning ( )", "prediction": "private void checkNotRunning ( )\n", "label": 1}
{"id": 9868, "input": "<s> public class T5065215 { static < T , U extends T > T [ ] cast ( U [ ] a ) { return (", "gt": "T [ ] ) a ;", "prediction": "T ) a ;\n", "label": 0}
{"id": 15885, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec1 . sub1 ; public class Mail { private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public void setContent ( String content ) { this . content = content ; } public void setStatus ( String status ) { this . status = status ; } public void setSubject ( String subject ) { this", "gt": ". subject = subject ;", "prediction": ". subject = subject ;\n", "label": 1}
{"id": 4287, "input": "<s> package com . midtro . platform . modules . assets . types ; import java . awt . Font ; import java . io . File ; import java . net . URL ; import java . util . Map ; import com . midtro . platform . modules . assets . Assembler ; import com . midtro . platform . modules . assets . Asset ; import com . midtro . platform . modules . assets . AssetConfig ; public class FontAssembler implements Assembler { @ Override public void assemble ( String assetName , String fileName , AssetConfig config , Map < String , Asset < ? > > store ) throws Exception { Font font = null ; switch ( config . getMountType ( ) ) { case FILE : font = Font . createFont ( Font . TRUETYPE_FONT , new File ( config . getFileLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ; break ; case CACHE : font = Font . createFont ( Font . TRUETYPE_FONT , new File ( config . getCacheLocation ( ) + fileName . replace ( '/' , File . separatorChar ) ) ) ; break ; case URL : font = Font . createFont ( Font . TRUETYPE_FONT , new URL ( config . getUrlLocation ( ) + fileName ) . openStream ( ) ) ; break ; default : throw", "gt": "new IllegalStateException ( \"Unknown mount type\" ) ;", "prediction": "new IllegalArgumentException ( ) ;\n", "label": 0}
{"id": 15888, "input": "<s> package vanilla . java . affinity ; public interface AffinityStrategy { public", "gt": "boolean matches ( int cpuId , int cpuId2 ) ;", "prediction": "AffinityStrategy ( ) ;\n", "label": 1}
{"id": 1975, "input": "<s> package com . redhat . ceylon . compiler . loader . impl . reflect . model ; import java . util . List ; import com . redhat . ceylon . compiler . java . util . Util ; import com . redhat . ceylon . compiler . loader . AbstractModelLoader ; import com . redhat . ceylon . compiler . loader . impl . reflect . ReflectionModelLoader ; import com . redhat . ceylon . compiler . loader . model . LazyModuleManager ; import com . redhat . ceylon . compiler . typechecker . TypeChecker ; import com . redhat . ceylon . compiler . typechecker . context . Context ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . Modules ; public class ReflectionModuleManager extends LazyModuleManager { private AbstractModelLoader modelLoader ; public ReflectionModuleManager ( Context context ) { super ( context ) ; } @ Override public void initCoreModules ( ) { super . initCoreModules ( ) ; Modules modules = getContext ( ) . getModules ( ) ; Module languageModule = modules . getLanguageModule ( ) ; languageModule", "gt": ". setVersion ( TypeChecker . LANGUAGE_MODULE_VERSION ) ;", "prediction": ". init ( ) ;\n", "label": 0}
{"id": 15893, "input": "<s> package org . restlet . util ; import org . restlet . engine . util . SystemUtils ; @ Deprecated public class Couple < T , U > { private volatile T first ; private volatile U second ; public Couple ( T first , U second ) { this . first = first ; this . second = second ; } @ Override public boolean equals ( Object other ) { boolean result = ( this == other ) ; if ( ! result && ( other instanceof Couple ) ) { Couple < ? , ? > couple = ( Couple < ? , ? > ) other ; if ( ( ( couple . getFirst ( ) == null ) && ( getFirst ( ) == null ) ) || ( ( getFirst ( ) != null ) && getFirst ( ) . equals ( couple . getFirst ( ) ) ) ) { result = ( ( ( couple . getSecond ( ) == null ) && ( getSecond ( ) == null ) ) || ( ( getSecond ( ) != null ) && getSecond ( ) . equals", "gt": "( couple . getSecond ( ) ) ) ) ;", "prediction": "( couple . getSecond ( ) ) ) ) ) ;\n", "label": 1}
{"id": 8437, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . matchers . Matcher ; import org . parboiled . support . Var ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; import java . util . ArrayList ; import java . util . List ; public class ActionVarTest extends TestNgParboiledTest < Integer > { @ BuildParseTree static class Parser extends BaseParser < Integer > { @ SuppressWarnings ( { \"InfiniteRecursion\" } ) public Rule A ( ) { Var < List < String > > list = new Var < List < String > > ( new ArrayList < String > ( ) ) ; return Sequence ( 'a' , Optional ( A ( ) , list . get ( ) . add ( \"Text\" ) , push ( list . get ( ) . size ( ) ) ) ) ; } } @ Test public void test ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; Matcher rule = ( Matcher ) parser . A ( ) ; assertEquals ( rule . getClass ( ) . getName ( ) , \"org.parboiled.matchers.VarFramingMatcher\" ) ; test ( rule , \"aaaa\" ) . hasNoErrors ( ) . hasParseTree ( \"\" + \"[A, {1}] 'aaaa'\\n\" + \"  ['a'] 'a'\\n\" + \"  [Optional, {1}] 'aaa'\\n\" + \"    [Sequence, {1}] 'aaa'\\n\" + \"      [A, {1}] 'aaa'\\n\" + \"        ['a'] 'a'\\n\" + \"        [Optional, {1}] 'aa'\\n\" + \"          [Sequence, {1}] 'aa'\\n\" + \"            [A, {1}] 'aa'\\n\" + \"              ['a'] 'a'\\n\" + \"              [Optional, {1}] 'a'\\n\" + \"                [Sequence, {1}] 'a'\\n\" + \"                  [A] 'a'\\n\" + \"                    ['a'] 'a'\\n\" + \"                ", "gt": "   [Optional]\\n\" ) ;", "prediction": "[Optional,\n", "label": 0}
{"id": 15894, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import java . util . List ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . nodes . BooleanQueryNode ; import org . apache . lucene . queryParser . core . nodes . ModifierQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . queryParser . standard . parser . EscapeQuerySyntaxImpl ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . BooleanQuery . TooManyClauses ; public class BooleanQueryNodeBuilder implements StandardQueryBuilder { public BooleanQueryNodeBuilder ( ) { } public BooleanQuery build ( QueryNode queryNode ) throws QueryNodeException { BooleanQueryNode booleanNode = ( BooleanQueryNode ) queryNode ; BooleanQuery bQuery = new BooleanQuery ( ) ; List < QueryNode > children = booleanNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { Object obj = child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . add ( query , getModifierValue ( child ) ) ; } catch ( TooManyClauses ex ) { throw new QueryNodeException ( new MessageImpl ( QueryParserMessages . TOO_MANY_BOOLEAN_CLAUSES , new Object [ ] { BooleanQuery . getMaxClauseCount ( ) , queryNode . toQueryString ( new EscapeQuerySyntaxImpl ( ) ) } ) , ex ) ; } } } } return bQuery ; } private static BooleanClause . Occur getModifierValue ( QueryNode node ) throws QueryNodeException { if ( node instanceof ModifierQueryNode ) { ModifierQueryNode mNode = ( ( ModifierQueryNode ) node ) ; switch ( mNode . getModifier ( ) ) { case MOD_REQ", "gt": ": return BooleanClause . Occur . MUST ;", "prediction": ":\n", "label": 1}
{"id": 1775, "input": "<s> package org . gk . engine . client . build . page ; import java . util . List ; import org . gk . engine . client . build . panel . XPanel ; import org . gk . engine . client . gen . UIGen ; import com . extjs . gxt . ui . client . widget . Component ; import com . extjs . gxt . ui . client . widget . LayoutContainer ; import com", "gt": ". google . gwt . xml . client . Node ;", "prediction": ". extjs . gxt . ui . client . widget . Widget ;\n", "label": 0}
{"id": 15897, "input": "<s> package io . beancounter . resolver ; public class ResolverMappingNotFoundException extends ResolverException { public ResolverMappingNotFoundException ( String message , Exception e ) { super ( message , e ) ; }", "gt": "public ResolverMappingNotFoundException ( String message )", "prediction": "}\n", "label": 1}
{"id": 1706, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Blaze ; public interface LizaBlaze extends Blaze { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte", "gt": "> transparent , int maxDistance ) ;", "prediction": "> block ) ;\n", "label": 0}
{"id": 15910, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . store . FSDirectory ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . document . AbstractField ; import org . apache . lucene . document . Document ; import java . text . NumberFormat ; import java . io . PrintStream ; import java . io . IOException ; import java . io . File ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . ArrayList ; import java . util . Map ; public class CheckIndex { public static PrintStream out = null ; private PrintStream infoStream ; private Directory dir ; public static class Status { public boolean clean ; public boolean missingSegments ; public boolean cantOpenSegments ; public boolean missingSegmentVersion ; public String segmentsFileName ; public int numSegments ; public String segmentFormat ; public List segmentsChecked = new ArrayList ( ) ; public boolean toolOutOfDate ; public List segmentInfos = new ArrayList ( ) ; public Directory dir ; SegmentInfos newSegments ; public int totLoseDocCount ; public int numBadSegments ; public boolean partial ; public Map userData ; public static class SegmentInfoStatus { public String name ; public int docCount ; public boolean compound ; public int numFiles ; public double sizeMB ; public int docStoreOffset = - 1 ; public String docStoreSegment ; public boolean docStoreCompoundFile ; public boolean hasDeletions ; public String deletionsFileName ; public int numDeleted ; public boolean openReaderPassed ; int numFields ; public boolean hasProx ; public Map diagnostics ; public FieldNormStatus fieldNormStatus ; public TermIndexStatus termIndexStatus ; public StoredFieldStatus storedFieldStatus ; public TermVectorStatus termVectorStatus ; } public static final class FieldNormStatus { public long totFields = 0L ; public Throwable error = null ; } public static final class TermIndexStatus { public long termCount = 0L ; public long totFreq = 0L ; public long totPos = 0L ; public Throwable error = null ; } public static final class StoredFieldStatus { public int docCount = 0 ; public long totFields = 0 ; public Throwable error = null ; } public static final class TermVectorStatus { public int docCount = 0 ; public long totVectors = 0 ; public Throwable error = null ; } } public CheckIndex ( Directory dir ) { this . dir = dir ; infoStream = out ; } public void setInfoStream ( PrintStream out ) { infoStream = out ; } private void msg ( String msg ) { if ( infoStream != null ) infoStream . println ( msg ) ; } private static class MySegmentTermDocs extends SegmentTermDocs { int delCount ; MySegmentTermDocs ( SegmentReader p ) { super ( p ) ; } public void seek ( Term term ) throws IOException { super . seek ( term ) ; delCount = 0 ; } protected void skippingDoc ( ) throws IOException { delCount ++ ; } } public static boolean check ( Directory dir , boolean doFix ) throws IOException { return check ( dir , doFix , null ) ; } public static boolean check ( Directory dir , boolean doFix , List onlySegments ) throws IOException { CheckIndex checker = new CheckIndex ( dir ) ; Status status = checker . checkIndex ( onlySegments ) ; if ( doFix && ! status . clean ) checker . fixIndex ( status ) ; return status . clean ; } public Status checkIndex ( ) throws IOException { return checkIndex ( null ) ; } public Status checkIndex ( List onlySegments ) throws IOException { NumberFormat nf = NumberFormat . getInstance ( ) ; SegmentInfos sis = new SegmentInfos ( ) ; Status result = new Status ( ) ; result . dir = dir ; try { sis . read ( dir ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not read any segments file in directory\" ) ; result . missingSegments = true ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; return result ; } final int numSegments = sis . size ( ) ; final String segmentsFileName = sis . getCurrentSegmentFileName ( ) ; IndexInput input = null ; try { input = dir . openInput ( segmentsFileName ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not open segments file in directory\" ) ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; result . cantOpenSegments = true ; return result ; } int format = 0 ; try { format = input . readInt ( ) ; } catch ( Throwable t ) { msg ( \"ERROR: could not read segment file version in directory\" ) ; if ( infoStream != null ) t . printStackTrace ( infoStream ) ; result . missingSegmentVersion = true ; return result ; } finally { if ( input != null ) input . close ( ) ; } String sFormat = \"\" ; boolean skip = false ; if ( format == SegmentInfos . FORMAT ) sFormat = \"FORMAT [Lucene Pre-2.1]\" ; if ( format == SegmentInfos . FORMAT_LOCKLESS ) sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\" ; else if ( format == SegmentInfos . FORMAT_SINGLE_NORM_FILE ) sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\" ; else if ( format == SegmentInfos . FORMAT_SHARED_DOC_STORE ) sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\" ; else { if ( format == SegmentInfos . FORMAT_CHECKSUM ) sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\" ; else if ( format == SegmentInfos . FORMAT_DEL_COUNT ) sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\" ; else if ( format == SegmentInfos . FORMAT_HAS_PROX ) sFormat", "gt": "= \"FORMAT_HAS_PROX [Lucene 2.4]\" ;", "prediction": "= \"FORMAT_HAS_PROX [Lucene 2.4]\" ;\n", "label": 1}
{"id": 2670, "input": "<s> @ Deprecated class A1 { } class A2 { @ Deprecated static class A21 { } } public class T6241723 { A1 a1 ; A2 a2 ; A2 . A21 a21 ; Z1 z1 ; Z2 z2 ; Z2 . Z21 z21 ; } @ Deprecated class Z1 { } class Z2 {", "gt": "@ Deprecated static class Z21", "prediction": "@ Deprecated static class Z1\n", "label": 0}
{"id": 15919, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . ColumnLayoutData ; import org . eclipse . jface . viewers . ColumnWeightData ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TableLayout ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; public class TableViewerComparatorTest extends ViewerComparatorTest { public TableViewerComparatorTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { TableViewer viewer = new TableViewer ( parent ) ; viewer . setContentProvider ( new TeamModelContentProvider ( ) ) ; viewer . setLabelProvider ( new TeamModelLabelProvider ( ) ) ; viewer . getTable ( ) . setLinesVisible ( true ) ; TableLayout layout = new TableLayout ( ) ; viewer . getTable ( ) . setLayout ( layout ) ; viewer . getTable ( ) . setHeaderVisible ( true ) ; String headers [ ] = { \"column 1 header\" , \"column 2 header\" } ; ColumnLayoutData layouts [ ] = { new ColumnWeightData ( 100 ) , new ColumnWeightData ( 100 ) } ; final TableColumn columns [ ] = new TableColumn [ headers . length ] ; for ( int i = 0 ; i < headers . length ; i ++ ) { layout . addColumnData ( layouts [ i ] ) ; TableColumn tc = new TableColumn ( viewer . getTable ( ) , SWT . NONE , i ) ; tc . setResizable ( layouts [ i ] . resizable ) ; tc . setText ( headers [ i ] ) ; columns [ i ] = tc ; } return viewer ; } public void testViewerSorter ( ) { fViewer . setSorter ( new ViewerSorter ( ) ) ; assertSortedResult ( TEAM1_SORTED ) ; } public void testViewerSorterInsertElement ( ) { fViewer . setSorter (", "gt": "new ViewerSorter ( ) ) ;", "prediction": "new ViewerSorter ( ) ) ;\n", "label": 1}
{"id": 348, "input": "<s> package org . jjflyboy . tjpeditor . project ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . eclipse . emf . common . util . Enumerator ; public enum TimeUnit implements Enumerator { MINUTE ( 0 , \"MINUTE\" , \"min\" ) , HOUR ( 1 , \"HOUR\" , \"h\" ) , DAY ( 2 , \"DAY\" , \"d\" ) , WEEK ( 3 , \"WEEK\" , \"w\" ) , MONTH ( 4 , \"MONTH\" , \"m\" ) , YEAR ( 5 , \"YEAR\" , \"y\" ) ; public static final int MINUTE_VALUE = 0 ; public static final int HOUR_VALUE = 1 ; public static final int DAY_VALUE = 2 ; public static final int WEEK_VALUE = 3 ; public static final int MONTH_VALUE = 4 ; public static final int YEAR_VALUE = 5 ; private static final TimeUnit [ ] VALUES_ARRAY = new TimeUnit [ ] { MINUTE , HOUR , DAY , WEEK , MONTH , YEAR , } ; public static final List < TimeUnit > VALUES = Collections . unmodifiableList ( Arrays . asList ( VALUES_ARRAY ) ) ; public static TimeUnit get ( String literal ) { for ( int i = 0 ; i < VALUES_ARRAY . length ; ++ i ) { TimeUnit result = VALUES_ARRAY [ i ] ; if ( result . toString ( ) . equals ( literal ) ) { return result ; } } return null ; } public static TimeUnit getByName ( String name ) { for (", "gt": "int i = 0 ;", "prediction": "int i = 0 ;\n", "label": 0}
{"id": 15928, "input": "<s> package org . eclipse . xtext . xdoc . ui . autoedit ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DocumentCommand ; import org . eclipse . jface . text . IAutoEditStrategy ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentExtension4 ; import org . eclipse . jface . text . IRegion ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . events . VerifyEvent ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . xtext . ui . editor . autoedit . AbstractEditStrategy ; import org . eclipse . xtext . ui . editor . autoedit . DefaultAutoEditStrategyProvider ; public class AutoEditProvider extends DefaultAutoEditStrategyProvider { protected static class LineBreakInserter extends AbstractEditStrategy { private Widget widget ; private final IAutoEditStrategy defaultStrategy ; protected LineBreakInserter ( IAutoEditStrategy defaultStrategy ) { this . defaultStrategy = defaultStrategy ; } @ Override public void verifyKey ( VerifyEvent event ) { super . verifyKey ( event ) ; widget = event . widget ; } @ Override protected void internalCustomizeDocumentCommand ( IDocument document , DocumentCommand command ) throws BadLocationException { if ( command . text . equals ( \" \" ) && command . length == 0 ) { if ( widget instanceof StyledText ) { StyledText text = ( StyledText ) widget ; IRegion region = document . getLineInformationOfOffset ( command . offset ) ; String line = document . get ( region . getOffset ( ) , region . getLength ( ) ) ; String subLine = line . substring ( 0 , command . offset - region . getOffset ( ) ) ; int tabCount = count ( \"\\t\" , subLine ) ; int spacesForTabs = text . getTabs ( ) * tabCount ; int visibleOffset = subLine . length", "gt": "( ) - tabCount + spacesForTabs ;", "prediction": "( ) ;\n", "label": 1}
{"id": 2667, "input": "<s> package pkg1 ; public class C2 { public static", "gt": "final int I = 1 ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 15931, "input": "<s> package org . seage . metaheuristic . antcolony ; import java . util . * ; public class Ant { protected Graph _graph ; protected Node _startPosition ; protected Node _currentPosition ; protected double _distanceTravelled ; protected Vector < Node > _visited ; protected Vector < Edge > _path ; protected AntBrain _brain ; private double _qantumPheromone ; public Ant ( AntBrain brain , Graph graph , double qantumPheromone ) { _brain = brain ; _graph = graph ; _qantumPheromone = qantumPheromone ; } protected Vector < Edge > explore ( Node startingNode ) { _visited = new Vector < Node > ( ) ; _path = new Vector < Edge > ( ) ; _brain . _startingNode = startingNode ; _currentPosition = startingNode ; _visited . add ( startingNode ) ; List < Edge > edges = _brain . getAvailableEdges ( _currentPosition , _visited ) ; while ( edges != null && edges . size ( ) > 0 ) { Edge nextEdge = _brain . selectNextEdge ( edges , _visited ) ; updatePosition ( nextEdge ) ; edges = _brain . getAvailableEdges ( _currentPosition , _visited ) ; } leavePheromone ( ) ; return _path ; } protected void updatePosition ( Edge arcChoice ) { Node choiceNode ; if ( arcChoice . getNode1 ( ) . equals ( _currentPosition ) ) { choiceNode = ( arcChoice . getNode2 ( ) ) ; } else { choiceNode = (", "gt": "arcChoice . getNode1 ( ) ) ;", "prediction": "arcChoice . getNode3 ( ) ) ;\n", "label": 1}
{"id": 4769, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface Mandatory extends AllocateResourceAttribute { boolean isMandatory ( ) ; void", "gt": "setMandatory ( boolean value ) ;", "prediction": "setMandatory ( boolean isMandatory ) ;\n", "label": 0}
{"id": 15936, "input": "<s> package org . eclipse . ui . contexts ; public abstract class ContextException extends Exception { private static final long serialVersionUID = - 5143404124388080211L ; private Throwable cause ; public ContextException ( String message ) { super ( message ) ; } public ContextException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; }", "gt": "public Throwable getCause ( )", "prediction": "}\n", "label": 1}
{"id": 2538, "input": "<s> package com . extjs . gxt . ui . client . widget . form ; import com . extjs . gxt . ui . client . GXT ; import com . extjs . gxt . ui . client . Style . HideMode ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . core . XDOM ; import com . extjs . gxt . ui . client . event . BaseEvent ; import com . extjs . gxt . ui . client . event . ComponentEvent ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . event . FieldEvent ; import com . extjs . gxt . ui . client . event . KeyListener ; import com . extjs . gxt . ui . client . event . Listener ; import com . extjs . gxt . ui . client . util . DelayedTask ; import com . extjs . gxt . ui . client . util . Format ; import com . extjs . gxt . ui . client . util . KeyNav ; import com . extjs . gxt . ui . client . util . Util ; import com . extjs . gxt . ui . client . widget . BoxComponent ; import com . extjs . gxt . ui . client . widget . ComponentHelper ; import com . extjs . gxt . ui . client . widget . WidgetComponent ; import com . extjs . gxt . ui . client . widget . layout . FormLayout ; import com . google . gwt . dom . client . InputElement ; import com . google . gwt . user . client . Command ; import com . google . gwt . user . client . DeferredCommand ; import com . google . gwt . user . client . Element ; import com . google . gwt . user . client . Event ; import com . google . gwt . user . client . ui . AbstractImagePrototype ; @ SuppressWarnings ( \"deprecation\" ) public abstract class Field < D > extends BoxComponent { public class FieldImages { private AbstractImagePrototype invalid = GXT . IMAGES . field_invalid ( ) ; public AbstractImagePrototype getInvalid ( ) { return invalid ; } public void setInvalid ( AbstractImagePrototype invalid ) { this . invalid = invalid ; } } public class FieldMessages { private String invalidText = GXT . MESSAGES . field_invalidText ( ) ; public String getInvalidText ( ) { return invalidText ; } public void setInvalidText ( String invalidText ) { this . invalidText = invalidText ; } } protected boolean autoValidate ; protected String emptyText ; protected WidgetComponent errorIcon ; protected String fieldStyle = \"x-form-field\" ; protected String focusStyle = \"x-form-focus\" ; protected Object focusValue ; protected String forceInvalidText ; protected boolean hasFocus ; protected FieldImages images ; protected String invalidStyle = \"x-form-invalid\" ; protected FieldMessages messages ; protected String name ; protected D originalValue ; protected boolean preventMark ; protected PropertyEditor < D > propertyEditor ; protected boolean readOnly ; protected String readOnlyFieldStyle = \"x-form-readonly\" ; protected int validationDelay = 250 ; protected DelayedTask validationTask ; protected D value ; private String activeErrorMessage ; private String fieldLabel = \"\" ; private boolean fireChangeEventOnSetValue ; private boolean hideLabel ; private boolean inEditor ; private String inputStyle ; private String inputStyles = \"\" ; private String labelSeparator ; private String labelStyle = \"\" ; private String messageTarget = \"side\" ; private int tabIndex = 0 ; private boolean validateOnBlur = true ; @ SuppressWarnings ( \"unchecked\" ) protected Field ( ) { propertyEditor = ( PropertyEditor < D > ) PropertyEditor . DEFAULT ; messages = new FieldMessages ( ) ; } public void addInputStyleName ( String style ) { if ( rendered ) { El inputEl = getInputEl ( ) ; if ( inputEl != null ) { inputEl . addStyleName ( style ) ; } } else { inputStyle = inputStyle == null ? style : inputStyle + \" \" + style ; } } public void addKeyListener ( KeyListener listener ) { addListener ( Events . KeyPress , listener ) ; addListener ( Events . KeyUp , listener ) ; addListener ( Events . KeyDown , listener ) ; } public void clear ( ) { boolean restore = preventMark ; preventMark = true ; setValue ( null ) ; preventMark = restore ; clearInvalid ( ) ; } public void clearInvalid ( ) { if ( ! rendered ) { return ; } getInputEl ( ) . removeStyleName ( invalidStyle ) ; if ( forceInvalidText != null ) { forceInvalidText = null ; } if ( \"side\" . equals ( messageTarget ) ) { if ( errorIcon != null && errorIcon . isAttached ( ) ) { ComponentHelper . doDetach ( errorIcon ) ; errorIcon . setVisible ( false ) ; setAriaState ( \"aria-describedby\" , \"\" ) ; } } else if ( \"title\" . equals ( messageTarget ) ) { setTitle ( \"\" ) ; } else if ( \"tooltip\" . equals ( messageTarget ) ) { hideToolTip ( ) ; if ( toolTip != null ) { toolTip . disable ( ) ; } } else { Element elem = XDOM . getElementById ( messageTarget ) ; if ( elem != null ) { elem . setInnerHTML ( \"\" ) ; } } if ( GXT . isAriaEnabled ( ) ) { getAriaSupport ( ) . setState ( \"aria-invalid\" , \"false\" ) ; } fireEvent ( Events . Valid", "gt": ", new FieldEvent ( this ) ) ;", "prediction": "atorEvent ) ;\n", "label": 0}
{"id": 15945, "input": "<s> package org . eclipse . rap . internal . design . example . managers ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . IContributionManagerOverrides ; import org . eclipse . jface . internal . provisional . action . ToolBarManager2 ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . ToolBar ; public class ToolBarManager extends ToolBarManager2 { public ToolBarManager ( ) { super ( ) ; } public void addPropertyChangeListener ( IPropertyChangeListener listener ) { } public ToolBar createControl ( Composite parent ) { return super . createControl ( parent ) ; } public Control createControl2 ( Composite parent ) { return createControl ( parent ) ; } public void dispose ( ) { super . dispose ( ) ; } public ToolBar getControl ( ) { return super . getControl ( ) ; } public Control getControl2 ( ) { return super . getControl2 ( ) ; } public int getItemCount ( ) { return super . getItems ( ) . length ; } public void removePropertyChangeListener ( IPropertyChangeListener listener ) { } public void setOverrides ( IContributionManagerOverrides newOverrides ) { super . setOverrides ( newOverrides ) ; } public void add ( IAction action ) { super . add ( action ) ; } public void add ( IContributionItem item ) { super . add ( item ) ; } public void appendToGroup ( String groupName , IAction action ) { super . appendToGroup ( groupName , action ) ; } public void appendToGroup ( String groupName , IContributionItem item ) { super . appendToGroup ( groupName , item ) ; } public IContributionItem find ( String id ) { return super . find ( id ) ; } public IContributionItem [ ] getItems ( ) { return super . getItems ( ) ; } public IContributionManagerOverrides getOverrides ( ) { return super . getOverrides ( ) ; } public void insertAfter ( String id , IAction action ) { super . insertAfter ( id , action ) ; } public void insertAfter ( String id , IContributionItem item ) { super", "gt": ". insertAfter ( id , item ) ;", "prediction": ". insertAfter ( id , item ) ;\n", "label": 1}
{"id": 9944, "input": "<s> package org . ofbiz . base . util ; import org . ofbiz . base . config . GenericConfigException ; import org . ofbiz . base . component . ComponentConfig ; import java . io . IOException ; import java . security . GeneralSecurityException ; import java . security . KeyStore ; import java . security . SecureRandom ; import java . security . Principal ; import java . security . cert . X509Certificate ; import java . security . cert . CertificateException ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import javax . net . ssl . KeyManager ; import javax . net . ssl . KeyManagerFactory ; import javax . net . ssl . HostnameVerifier ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . net . ssl . SSLServerSocketFactory ; import javax . net . ssl . SSLSession ; import javax . net . ssl . SSLSocketFactory ; import javax . net . ssl . TrustManager ; import javax . net . ssl . X509KeyManager ; import javax . net . ssl . X509TrustManager ; import javolution . util . FastList ; public class SSLUtil { public static final String module = SSLUtil . class . getName ( ) ; public static final int HOSTCERT_NO_CHECK = 0 ; public static final int HOSTCERT_MIN_CHECK = 1 ; public static final int HOSTCERT_NORMAL_CHECK = 2 ; private static boolean loadedProps = false ; static { SSLUtil . loadJsseProperties ( ) ; } public static boolean isClientTrusted ( X509Certificate [ ] chain , String authType ) { TrustManager [ ] mgrs = new TrustManager [ 0 ] ; try { mgrs = SSLUtil . getTrustManagers ( ) ; } catch ( IOException e ) { Debug . logError ( e , module ) ; } catch ( GeneralSecurityException e ) { Debug . logError ( e , module ) ; } catch ( GenericConfigException e ) { Debug . logError ( e , module ) ; } if ( mgrs != null ) { for ( TrustManager mgr : mgrs ) { if ( mgr instanceof X509TrustManager ) { try { ( ( X509TrustManager ) mgr ) . checkClientTrusted ( chain , authType ) ; return true ; } catch ( CertificateException e ) { } } } } return false ; } public static KeyManager [ ] getKeyManagers ( String alias ) throws IOException , GeneralSecurityException , GenericConfigException { List < KeyManager > keyMgrs", "gt": "= FastList . newInstance ( ) ;", "prediction": "= new ArrayList < KeyManager > ( ) ;\n", "label": 0}
{"id": 15959, "input": "<s> package actors ; import graphics . Sprite ; import java . io . File ; import java . util . ArrayList ; import java . util . prefs . Preferences ; import org . ini4j . Ini ; import org . ini4j . IniPreferences ; public class Enemy extends Actor { public static final String [ ] AVAILABLEENEMIES = new ArrayList < String > ( ) { { for ( String s : new File ( \"data/actors/enemies/info\" ) . list ( ) ) if ( s . endsWith ( \".ini\" ) ) this . add ( s . substring ( 0 , s . length ( ) - 4 ) ) ; } } . toArray ( new String [ ] { } ) ; public static final int SMALL = 33 ; public static final int MEDIUM = 49 ; public static final int LARGE = 64 ; public static final int FULL = 106 ; int goldReward = 0 ; int size = MEDIUM ; String displayName ; String spriteName ; public Enemy ( String n ) { try { name = n ; Preferences p = new IniPreferences ( new Ini ( new File ( \"data/actors/enemies/info/\" + name + \".ini\" ) ) ) ; Preferences dist = p . node ( \"distribution\" ) ; Preferences elem = p . node ( \"elemental\" ) ; Preferences main = p . node ( \"enemy\" ) ; maxhp = dist . getInt ( \"hp\" , 1 ) ; hp = maxhp ; String [ ] m = dist . get ( \"mp\" , \"0/0/0/0/0/0/0/0\" ) . split ( \"/\" ) ; for ( int i = 0 ; i < m . length && i < mp . length ; i ++ ) { mp [ i ] [ 0 ] = Integer . parseInt ( m [ i ] ) ; mp [ i ] [ 1 ] = Integer . parseInt ( m [ i ] ) ; } str = dist . getInt ( \"str\" , 1 ) ; def = dist . getInt ( \"def\" , 1 ) ; itl = dist . getInt ( \"int\" , 1 ) ; spd = dist . getInt ( \"spd\" , 1 ) ; evd = dist . getInt ( \"evd\" , 1 ) ; acc = dist . getInt ( \"acc\" , 1 ) ; vit = dist . getInt ( \"vit\" , 1 ) ; fire = elem . getInt ( \"fire\" , 1 ) ; frez = elem . getInt ( \"frez\" , 1 ) ; elec = elem . getInt (", "gt": "\"elec\" , 1 ) ;", "prediction": "\"elec\" , 1 ) ;\n", "label": 1}
{"id": 4179, "input": "<s> package fake . net ; import java . io . IOException ; import java . net . DatagramPacket ; import java . net . InetAddress ; public class Test_UnicastSocket implements Runnable { private MulticastSocket m_socket = null ; private boolean m_initiator = false ; public Test_UnicastSocket ( String addr , boolean initiator ) throws Exception { m_socket = new MulticastSocket ( 3778 , addr ) ; m_socket . setInterface ( InetAddress . getByName ( addr ) ) ; m_initiator = initiator ; } public void run ( ) { try { if ( m_initiator ) { byte [ ] data = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 } ; DatagramPacket toBeSent = new DatagramPacket ( data , data . length , InetAddress . getByName ( \"192.168.0.2\" ) , 3778 ) ; m_socket . send ( toBeSent ) ; System . out . println ( \"Sent1\" ) ; byte [ ] buf = new byte [ 8192 ] ; DatagramPacket received = new DatagramPacket ( buf , 8192 ) ; m_socket . receive ( received ) ; System . out . println ( \"Received1\" ) ; DatagramPacket toBeSent2 = new DatagramPacket ( received . getData ( ) , received . getData ( ) . length , InetAddress . getByName ( \"192.168.0.3\" ) , 3778 ) ; m_socket . send ( toBeSent2 ) ; System . out . println ( \"Sent2\" ) ; byte [ ] buf2 = new byte [ 8192 ] ; DatagramPacket received2 = new DatagramPacket ( buf2 , 8192 ) ; m_socket . receive ( received2 ) ; System . out . println ( \"Received2\" ) ; DatagramPacket toBeSent3 = new DatagramPacket ( received2 . getData ( ) , received2 . getData ( ) . length , InetAddress . getByName ( \"192.168.0.4\" ) , 3778 ) ; m_socket . send ( toBeSent3 ) ; System . out . println ( \"Sent3\" ) ; byte [ ] buf3 = new byte [ 8192 ] ; DatagramPacket received3 = new DatagramPacket ( buf3 , 8192 ) ; m_socket . receive ( received3 ) ; System . out . println ( \"Received3\" ) ; System . out . println ( \"data: \" + data [ 0 ] + \"-\" + data [ 1 ] + \"-\" + data [ 2 ] + \"-\" + data [ 3 ] + \"-\" + data [ 4 ] + \"-\" + data [ 5 ] + \"-\" + data [ 6 ] + \"-\" + data [ 7 ] + \"-\" + data [ 8 ] + \"-\" + data [ 9 ] + \"-\" + data", "gt": "[ 10 ] ) ;", "prediction": "[ 10 ] ) ;\n", "label": 0}
{"id": 15962, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . jface . viewers . ISelectionProvider ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IActionBars ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . internal . intro . IntroDescriptor ; import org . eclipse . ui . intro . IIntroSite ; final class ViewIntroAdapterSite implements IIntroSite { private IntroDescriptor descriptor ; private IViewSite viewSite ; public ViewIntroAdapterSite ( IViewSite viewSite , IntroDescriptor descriptor ) { this . viewSite = viewSite ; this . descriptor = descriptor ; } public IActionBars getActionBars ( ) { return viewSite . getActionBars ( ) ; } public Object getAdapter ( Class adapter ) { return viewSite . getAdapter ( adapter ) ; } public String getId ( ) { return descriptor . getId ( ) ; } public IWorkbenchPage getPage ( ) { return viewSite . getPage ( ) ; } public String getPluginId ( ) { return descriptor . getPluginId ( ) ; } public ISelectionProvider getSelectionProvider ( ) { return viewSite . getSelectionProvider ( ) ; } public final Object getService ( final Class key ) { return viewSite . getService ( key ) ; } public Shell getShell ( ) { return viewSite . getShell ( ) ; } public IWorkbenchWindow getWorkbenchWindow ( ) { return viewSite . getWorkbenchWindow ( ) ; } public final boolean", "gt": "hasService ( final Class key )", "prediction": "isActive ( )\n", "label": 1}
{"id": 9367, "input": "<s> public class AssignmentDifferentTypes5 { public static void main ( String [ ] args ) { Ref < Der > derexact = null ; Ref < Base > baseexact = null ; Ref < ? extends Der > derext = null ; Ref < ? extends Base > baseext = null ; Ref < ? super Der > dersuper = null ; Ref < ? super Base", "gt": "> basesuper = null ;", "prediction": "> baseext = null ;\n", "label": 0}
{"id": 15965, "input": "<s> package org . restlet . test . data ; import java . io . File ; import org . restlet . data . LocalReference ; import org . restlet . test . RestletTestCase ; public class FileReferenceTestCase extends RestletTestCase { public void testCreation ( ) { String path = \"D:\\\\Restlet\\\\build.xml\" ; LocalReference fr = LocalReference . createFileReference ( path ) ; fr . getFile ( ) ; assertEquals ( \"file\" , fr . getScheme ( ) ) ; assertEquals (", "gt": "\"\" , fr . getAuthority ( ) ) ;", "prediction": "\"dir\" , fr . getScheme ( ) ) ;\n", "label": 1}
{"id": 2111, "input": "<s> package gui ; import java . awt . FlowLayout ; import java . awt . Font ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . * ; import exceptions . GUINoSuchPanelException ; public class CheckoutProgressPanel extends JPanel { private static final long serialVersionUID = - 3123058109859174542L ; private JButton [ ] buttonArray ; public CheckoutProgressPanel ( ) { super ( ) ; this . setLayout ( new FlowLayout ( FlowLayout . CENTER , 0 , 5 ) ) ; prepareElements ( ) ; renderElements ( ) ; this . loadCartProgress ( ) ; } private void prepareElements ( ) { buttonArray = new JButton [ 9 ] ; for ( int ii = 0 ; ii < buttonArray . length ; ii ++ ) { buttonArray [ ii ] = new JButton ( ) ; } this . setDefaultStyle ( ) ; buttonArray [ 0 ] . setText ( \"<--\" ) ; buttonArray [ 1 ] . setText ( \"Cart\" ) ; buttonArray [ 1 ] . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { CheckoutPanel . jumpToPaymentStep ( CheckoutPanel . CART ) ; } catch ( GUINoSuchPanelException e1 ) { JOptionPane . showMessageDialog ( null , \"Could not load \" + \"shopping cart.  \\nPlease contact technical \" + \"support.\" , \"GUINoSuchPanelException\" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; buttonArray [ 2 ] . setText ( \"---\" ) ; buttonArray [ 3 ] . setText ( \"Payment\" ) ; buttonArray [ 3 ] . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { CheckoutPanel . jumpToPaymentStep ( CheckoutPanel . PAYMENT ) ; } catch ( GUINoSuchPanelException e1 ) { JOptionPane . showMessageDialog ( null , \"Could not load \" + \"payment step.  \\nPlease contact technical \" + \"support.\" , \"GUINoSuchPanelException\" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; buttonArray [ 4 ] . setText ( \"---\" ) ; buttonArray [ 5 ] . setText ( \"Verify Cart/Payment\" ) ; buttonArray [ 5 ] . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { CheckoutPanel . jumpToPaymentStep ( CheckoutPanel . VERIFY ) ; } catch ( GUINoSuchPanelException e1 ) { JOptionPane . showMessageDialog ( null , \"Could not load \" + \"verification.  \\nPlease contact technical \" + \"support.\" , \"GUINoSuchPanelException\" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; buttonArray [ 6 ] . setText ( \"---\" ) ; buttonArray [ 7 ] . setText ( \"Thankyou\" ) ; buttonArray [ 7 ] . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { try { CheckoutPanel . jumpToPaymentStep ( CheckoutPanel . THANKYOU ) ; } catch ( GUINoSuchPanelException e1 ) { JOptionPane . showMessageDialog ( null , \"Could not load \" + \"thank you dialog.  \\nPlease contact technical \" + \"support.\" , \"GUINoSuchPanelException\" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; buttonArray [ 8 ] . setText ( \"-->\" ) ; } private void renderElements ( ) { for ( int ii = 0 ; ii < buttonArray . length ; ii ++ ) { this . add ( buttonArray [ ii ] ) ; } } private void setDefaultStyle ( ) { for ( int ii = 0 ; ii < buttonArray . length ; ii ++ ) { setStyleFor ( buttonArray [ ii ] , Font . ITALIC ) ; } for ( int ii = 0 ; ii < buttonArray . length ; ii += 2 ) { buttonArray [ ii ] . setEnabled ( false ) ; setStyleFor ( buttonArray [", "gt": "ii ] , Font . PLAIN ) ;", "prediction": "i ] , Font . ITALIC ) ;\n", "label": 0}
{"id": 15966, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; public class ReadDispose_Test extends TestCase { @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakeResponseWriter ( ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testWidgetDisposal ( ) throws Exception { Fixture . fakeNewRequest ( ) ; RWTFactory . getEntryPointManager ( ) . registerByName ( EntryPointUtil . DEFAULT , WidgetDisposalEntryPoint . class ) ; RWTLifeCycle lifeCycle = ( RWTLifeCycle ) RWTFactory . getLifeCycleFactory ( ) . getLifeCycle ( ) ; lifeCycle . execute ( ) ; Fixture . fakeNewRequest ( ) ; lifeCycle . execute ( ) ; Fixture . fakeNewRequest ( ) ; String buttonId = WidgetDisposalEntryPoint . buttonId ; Fixture .", "gt": "fakeNotifyOperation ( buttonId , ClientMessageConst . EVENT_WIDGET_SELECTED , null ) ;", "prediction": "fakeNewRequest ( ) ;\n", "label": 1}
{"id": 7900, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . ComplexEntityPart ; import org . bukkit . entity . ComplexLivingEntity ; import Liza . LizaComplexEntityPart ; public class LizaCraftComplexEntityPart extends LizaCraftEntity implements LizaComplexEntityPart { public LizaCraftComplexEntityPart ( ComplexEntityPart part ) { super ( part ) ; } @ Override public ComplexEntityPart getBukkitHandle ( ) { return", "gt": "( ComplexEntityPart ) this . entity ;", "prediction": "getBukkitHandle ( ) ;\n", "label": 0}
{"id": 15977, "input": "<s> package org . eclipse . rap . rwt . internal . resources ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . resources . JSLibraryConcatenator ; import org . eclipse . rap . rwt . resources . IResourceManager ; import org . eclipse . rap . rwt . testfixture . Fixture ; import junit . framework . TestCase ; public class JSLibraryConcatenator_Test extends TestCase { private static final byte [ ] CONTENT = new byte [ ] { ( byte ) 'a' } ; private JSLibraryConcatenator jsConcatenator ; private IResourceManager resourceManager ; protected void setUp ( ) { Fixture . setUp ( ) ; Fixture . useDefaultResourceManager ( ) ; resourceManager = RWTFactory . getResourceManager ( ) ; jsConcatenator = new JSLibraryConcatenator ( resourceManager ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testConcatenation ( ) throws IOException { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; String location = jsConcatenator . getLocation ( ) ; assertEquals ( \"rwt-resources/resources.js\" , location ) ; assertTrue ( resourceManager . isRegistered ( \"resources.js\" ) ) ; assertEquals ( \"a\\n\" , getRegisteredContent ( \"resources.js\" ) ) ; } public void testActivate ( ) { jsConcatenator . startJSConcatenation ( ) ; jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; jsConcatenator . deactivate ( ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } public void testIgnoreConcatenation ( ) { jsConcatenator . appendJSLibrary ( CONTENT ) ; jsConcatenator . activate ( ) ; assertNull ( jsConcatenator . getLocation ( ) ) ; assertFalse ( resourceManager . isRegistered ( \"resources.js\" ) ) ; } public void testEmptyFileContent ( ) { jsConcatenator", "gt": ". startJSConcatenation ( ) ;", "prediction": ". startJSConcatenation ( ) ;\n", "label": 1}
{"id": 8445, "input": "<s> package org . kares . jruby ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . ThreadFactory ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . jruby . Ruby ; import org . jruby . javasupport . JavaEmbedUtils ; public abstract class WorkerManager { public static final String WORKER_KEY = \"jruby.worker\" ; public static final String SCRIPT_KEY = \"jruby.worker.script\" ; public static final String SCRIPT_PATH_KEY = \"jruby.worker.script.path\" ; public static final String THREAD_COUNT_KEY = \"jruby.worker.thread.count\" ; public static final String THREAD_PRIORITY_KEY = \"jruby.worker.thread.priority\" ; protected static final String EXPORTED_NAME = \"worker_manager\" ; private static final String GLOBAL_VAR_NAME = '$' + EXPORTED_NAME ; private boolean exported = true ; protected final Map < RubyWorker , Thread > workers = new HashMap < RubyWorker , Thread > ( 4 ) ; public void startup ( ) { final String [ ] workerScript = getWorkerScript ( ) ; if ( workerScript == null ) { final String message = \"no worker script to execute - configure one using '\" + SCRIPT_KEY + \"' \" + \"or '\" + SCRIPT_PATH_KEY + \"' parameter (or see previous errors if already configured) \" ; log ( \"[\" + getClass ( ) . getName ( ) + \"] \" + message + \" !\" ) ; return ; } final int workersCount = getThreadCount ( ) ; final ThreadFactory threadFactory = newThreadFactory ( ) ; for ( int i = 0 ; i < workersCount ; i ++ ) { final Ruby runtime = getRuntime ( ) ; if ( isExported ( ) ) { runtime . getGlobalVariables ( ) . set ( GLOBAL_VAR_NAME , JavaEmbedUtils . javaToRuby ( runtime , this ) ) ; } try { final RubyWorker worker = newRubyWorker ( runtime , workerScript [ 0 ] , workerScript [ 1 ] ) ; final Thread workerThread = threadFactory . newThread ( worker ) ; workers . put ( worker , workerThread ) ; workerThread . start ( ) ; } catch ( Exception e ) { log ( \"[\" + getClass ( ) . getName ( ) + \"] worker startup failed\" , e ) ; break ; } } log ( \"[\" + getClass ( ) . getName ( ) + \"] started \" + workers . size ( ) + \" worker(s)\" ) ; } public void shutdown ( ) { final Map < RubyWorker , Thread > workers = new HashMap < RubyWorker , Thread > ( this . workers ) ; this . workers . clear ( ) ; for ( final RubyWorker worker : workers . keySet ( ) ) { if ( isExported ( ) ) { worker . runtime . getGlobalVariables ( ) . clear ( GLOBAL_VAR_NAME ) ; } final Thread workerThread = workers . get ( worker ) ; try { worker . stop ( ) ; workerThread . interrupt ( ) ; workerThread . join ( 1000 ) ; } catch ( InterruptedException e ) { log ( \"[\" + getClass ( ) . getName ( ) + \"] interrupted\" ) ; Thread . currentThread ( ) . interrupt ( ) ; } catch ( Exception e ) { log ( \"[\" + getClass ( ) . getName ( ) + \"] ignoring exception \" + e ) ; } } log ( \"[\" + getClass ( ) . getName ( ) + \"] stopped \" + workers . size ( ) + \" worker(s)\" ) ; } protected abstract Ruby getRuntime ( ) ; private String threadPrefix ; public String getThreadPrefix ( ) { return threadPrefix ; } public void setThreadPrefix ( String threadPrefix ) { this . threadPrefix = threadPrefix ; } private Integer threadCount ; public Integer getThreadCount ( ) { if ( threadCount == null ) { String count = getParameter ( THREAD_COUNT_KEY ) ; try { if ( count != null ) { return threadCount = Integer . parseInt ( count ) ; } } catch ( NumberFormatException e ) { log ( \"[\" + getClass ( ) . getName ( ) + \"] \" + \"could not parse \" + THREAD_COUNT_KEY + \" parameter value = \" + count , e ) ; } threadCount = 1 ; } return threadCount ; } public void setThreadCount ( Integer threadCount ) { this . threadCount = threadCount ; } private Integer threadPriority ; public Integer getThreadPriority ( ) { if ( threadPriority == null ) { String priority = getParameter ( THREAD_PRIORITY_KEY ) ; try { if ( priority != null ) { if ( \"NORM\" . equalsIgnoreCase ( priority ) ) return threadPriority = Thread . NORM_PRIORITY ; else if ( \"MIN\" . equalsIgnoreCase ( priority ) ) return threadPriority = Thread . MIN_PRIORITY ; else if ( \"MAX\" . equalsIgnoreCase", "gt": "( priority ) ) return threadPriority = Thread . MAX_PRIORITY ;", "prediction": "( priority ) ) return threadPriority = Thread . MAX_PRIORITY ;\n", "label": 0}
{"id": 15984, "input": "<s> package org . apache . lucene . search . spell ; import junit . framework . TestCase ; public class TestNGramDistance extends TestCase { public void testGetDistance1 ( ) { StringDistance nsd = new NGramDistance ( 1 ) ; float d = nsd . getDistance ( \"al\" , \"al\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = nsd . getDistance ( \"a\" , \"a\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = nsd . getDistance ( \"b\" , \"a\" ) ; assertEquals ( d , 0.0f , 0.001 ) ; d = nsd . getDistance ( \"martha\" , \"marhta\" ) ; assertEquals ( d , 0.6666 , 0.001 ) ; d = nsd . getDistance ( \"jones\" , \"johnson\" ) ; assertEquals ( d , 0.4285 , 0.001 ) ; d = nsd . getDistance ( \"natural\" , \"contrary\" ) ; assertEquals ( d , 0.25 , 0.001 ) ; d = nsd . getDistance ( \"abcvwxyz\" , \"cabvwxyz\" ) ; assertEquals ( d , 0.75 , 0.001 ) ; d = nsd . getDistance ( \"dwayne\" , \"duane\" ) ; assertEquals ( d , 0.666 , 0.001 ) ; d = nsd . getDistance ( \"dixon\" , \"dicksonx\" ) ; assertEquals ( d , 0.5 , 0.001 ) ; d = nsd . getDistance ( \"six\" , \"ten\" ) ; assertEquals ( d , 0 , 0.001 ) ; float d1 = nsd . getDistance ( \"zac ephron\" , \"zac efron\" ) ; float d2 = nsd . getDistance ( \"zac ephron\" , \"kai ephron\" ) ; assertEquals ( d1 , d2 , 0.001 ) ; d1 = nsd . getDistance ( \"brittney spears\" , \"britney spears\" ) ; d2 = nsd . getDistance ( \"brittney spears\" , \"brittney startzman\" ) ; assertTrue ( d1 > d2 ) ; d1 = nsd . getDistance ( \"12345678\" , \"12890678\" ) ; d2 = nsd . getDistance ( \"12345678\" , \"72385698\" ) ; assertEquals ( d1 , d2 , 001 ) ; } public void testGetDistance2 ( ) { StringDistance sd = new NGramDistance ( 2 ) ; float d = sd . getDistance ( \"al\" , \"al\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"a\" , \"a\" ) ; assertEquals ( d , 1.0f , 0.001 ) ; d = sd . getDistance ( \"b\" , \"a\" ) ; assertEquals ( d , 0.0f , 0.001 ) ; d = sd . getDistance ( \"a\" , \"aa\" ) ; assertEquals ( d , 0.5f , 0.001 ) ; d = sd . getDistance ( \"martha\" , \"marhta\" ) ; assertEquals ( d , 0.6666 , 0.001 ) ; d = sd . getDistance ( \"jones\" , \"johnson\" ) ; assertEquals ( d , 0.4285 , 0.001 ) ; d = sd . getDistance ( \"natural\" , \"contrary\" ) ; assertEquals ( d , 0.25 , 0.001 ) ; d = sd .", "gt": "getDistance ( \"abcvwxyz\" , \"cabvwxyz\" ) ;", "prediction": "getDistance ( \"abcvwxyz\" , \"cabvwxyz\" ) ;\n", "label": 1}
{"id": 8892, "input": "<s> class AnonClassInterfaceNoArgs { Runnable r = new Runnable ( 3 ) {", "gt": "public void run ( )", "prediction": "public void run ( )\n", "label": 0}
{"id": 15993, "input": "<s> package org . gatein . common . text ; import org . gatein . common . util . ParameterValidation ; public class TextTools { public static boolean isAlphaNumeric ( char c ) { return ( c >= '0' && c <= '9' ) || ( c >= 'A' && c <= 'Z' ) || ( c >= 'a' && c <= 'z' ) ; } public static char toHex ( int z ) throws IllegalArgumentException { if ( z >= 0 && z < 10 ) { return ( char ) ( '0' + z ) ; } else if ( z >= 10 && z < 16 ) { return ( char ) ( 'A' - 10 + z ) ; } else { throw new IllegalArgumentException ( \"Wrong character\" ) ; } } public static String replace ( String string , String pattern , String replacement ) { StringBuffer buffer = new StringBuffer ( string . length ( ) ) ; int previous = 0 ; int current = string . indexOf ( pattern ) ; while ( current != - 1 ) { buffer . append ( string . substring ( previous , current ) ) ; buffer . append ( replacement ) ; previous = current + pattern . length ( ) ; current = string . indexOf ( pattern , previous ) ; } buffer . append ( string . substring ( previous ) ) ; return buffer . toString ( ) ; } public static String replaceAllInstancesOfBoundedString ( String initial , String prefix , String suffix , String replacement ) { return replaceBoundedString ( initial , prefix , suffix , replacement , true , false , false ) ; } public static String replaceAllInstancesOfBoundedString ( String initial , String prefix , String suffix , StringReplacementGenerator generator ) { return replaceBoundedString ( initial , prefix , suffix , generator , true , false , false ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , String replacement , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries ) { ParameterValidation . throwIllegalArgExceptionIfNull ( replacement , \"replacement\" ) ; return replaceBoundedString ( initial , prefix , suffix , new ConstantStringReplacementGenerator ( replacement ) , replaceIfBoundedStringEmpty , keepBoundaries , false ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , String replacement , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries , boolean suffixIsOptional ) { ParameterValidation . throwIllegalArgExceptionIfNull ( replacement , \"replacement\" ) ; return replaceBoundedString ( initial , prefix , suffix , new ConstantStringReplacementGenerator ( replacement ) , replaceIfBoundedStringEmpty , keepBoundaries , suffixIsOptional ) ; } public static String replaceBoundedString ( String initial , String prefix , String suffix , StringReplacementGenerator generator , boolean replaceIfBoundedStringEmpty , boolean keepBoundaries ) { return replaceBoundedString ( initial , prefix , suffix , generator , replaceIfBoundedStringEmpty , keepBoundaries , false ) ; } public static String replaceBoundedString ( final String initial , final String prefix , final String suffix , final StringReplacementGenerator generator , final boolean replaceIfBoundedStringEmpty , final boolean keepBoundaries , final boolean suffixIsOptional ) { if ( ParameterValidation . isNullOrEmpty ( initial ) ) { return initial ; } ParameterValidation . throwIllegalArgExceptionIfNull ( generator , \"StringReplacementGenerator\" ) ; ParameterValidation . throwIllegalArgExceptionIfNullOrEmpty ( prefix , \"prefix\" , \"TextTools.replaceBoundedString\" ) ; StringBuilder tmp = new StringBuilder ( initial ) ; int prefixIndex = tmp . indexOf ( prefix ) ; final int prefixLength = prefix . length ( ) ; boolean suffixAbsent = suffix == null ; int suffixLength = suffixAbsent ? 0 : suffix . length ( ) ; if ( ! suffixIsOptional && suffix != null && tmp . indexOf ( suffix ) == - 1 ) { return initial ; } while ( prefixIndex != - 1 ) { int suffixIndex ; if ( suffixAbsent ) { String match =", "gt": "tmp . substring ( prefixIndex + prefixLength ) ;", "prediction": "\"\" ;\n", "label": 1}
{"id": 4311, "input": "<s> class Unchecked < T > { void f ( Unchecked u ) { Unchecked < String", "gt": "> us = u ;", "prediction": "> s = new Unchecked < String > ( ) ;\n", "label": 0}
{"id": 15995, "input": "<s> package io . beancounter . profiles ; public class ProfilesException extends Exception { public ProfilesException ( String message , Exception e ) { super (", "gt": "message , e ) ;", "prediction": "message , e ) ;\n", "label": 1}
{"id": 6148, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Prolog ; public class PrologImpl extends ReportAttributeImpl implements Prolog { protected PrologImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return", "gt": "ProjectPackage . eINSTANCE . getProlog ( ) ;", "prediction": "null ;\n", "label": 0}
{"id": 15996, "input": "<s> package org . nuxeo . webengine . sites . fragments ; import java . text . SimpleDateFormat ; import org . nuxeo . ecm . core . api . CoreSession ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . webengine . WebEngine ; import org . nuxeo . ecm . webengine . model . WebContext ; import org . nuxeo . theme . fragments . AbstractFragment ; import org . nuxeo . theme . models . Model ; import org . nuxeo . theme . models . ModelException ; import org . nuxeo . webengine . sites . JsonAdapter ; import org . nuxeo . webengine . sites . models . WebpageCommentListModel ; import org . nuxeo . webengine . sites . models . WebpageCommentModel ; import org . nuxeo . webengine . sites . utils . SiteQueriesCollection ; import org . nuxeo . webengine . sites . utils . SiteUtils ; public class MinisiteLastCommentsFragment extends AbstractFragment { private int noComments = 5 ; private int noWordsFromContent = 50 ; @ Override public Model getModel ( ) throws ModelException { WebpageCommentListModel model = new WebpageCommentListModel ( ) ; if ( WebEngine . getActiveContext ( ) != null ) { WebContext ctx = WebEngine . getActiveContext ( ) ; CoreSession session = ctx . getCoreSession ( ) ; DocumentModel documentModel = ctx . getTargetObject ( ) . getAdapter ( DocumentModel . class ) ; try { DocumentModel ws = SiteUtils . getFirstWebSiteParent ( session , documentModel ) ; DocumentModelList comments = SiteQueriesCollection . queryLastComments ( session , ws . getPathAsString ( ) , noComments , SiteUtils . isCurrentModerated ( session , ws ) ) ; String pageTitle = null ; String pagePath = null ; for ( DocumentModel comment : comments ) { DocumentModel parentPage = SiteUtils . getPageForComment ( comment ) ; String author = SiteUtils . getUserDetails ( SiteUtils . getString ( comment , \"comment:author\" ) ) ; if ( parentPage != null ) { pageTitle = parentPage . getTitle ( ) ; pagePath = JsonAdapter . getRelativePath ( ws , parentPage ) . toString ( ) ; } String content = SiteUtils . getFistNWordsFromString ( SiteUtils . getString ( comment , \"comment:text\" ) , noWordsFromContent ) ; SimpleDateFormat simpleDateFormat = new SimpleDateFormat ( \"dd MMMM\" , WebEngine .", "gt": "getActiveContext ( ) . getLocale ( ) ) ;", "prediction": "getActiveContext ( ) ) ;\n", "label": 1}
{"id": 2007, "input": "<s> public class T6746184 { public static void main ( String [ ] args ) { A . m ( new Object ( ) ) ; } } class A {", "gt": "public static void m ( final Object ... varargs )", "prediction": "public static void main ( String [ ] args )\n", "label": 0}
{"id": 15997, "input": "<s> package org . nuxeo . ecm . platform . userworkspace . core . service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . platform . userworkspace . api . UserWorkspaceService ; import org . nuxeo . runtime . api . Framework ; import org . nuxeo . runtime . model . ComponentContext ; import org . nuxeo . runtime . model . ComponentInstance ; import org . nuxeo . runtime . model . DefaultComponent ; public class UserWorkspaceServiceImplComponent extends DefaultComponent { public static final String NAME = \"org.nuxeo.ecm.platform.userworkspace.UserWorkspaceService\" ; private static final Log log = LogFactory . getLog ( UserWorkspaceService . class ) ; protected UserWorkspaceDescriptor descriptor ; protected UserWorkspaceService userWorkspaceService ; @ Override public void activate ( ComponentContext context ) { log . info ( \"UserWorkspaceService activated\" ) ; } @ Override public void deactivate ( ComponentContext context ) { log . info ( \"UserWorkspaceService deactivated\" ) ; } @ Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter == UserWorkspaceService . class ) { try { return adapter . cast ( getUserWorkspaceService ( ) ) ; } catch ( Exception e ) { log . error ( \"error fetching UserWorkspaceManager: \" , e ) ; } } return null ; } private UserWorkspaceService getUserWorkspaceService ( ) throws ClientException { if ( userWorkspaceService == null ) { Class < ? > klass = descriptor . getUserWorkspaceClass ( ) ; if ( klass == null ) { throw new ClientException ( \"No class specified for the userWorkspace\" ) ; } try { userWorkspaceService = ( UserWorkspaceService ) klass . newInstance ( ) ; } catch ( InstantiationException e ) { throw new ClientException ( \"Failed to instantiate class \" + klass , e ) ; } catch ( IllegalAccessException e ) { throw new ClientException ( \"Failed to instantiate class \" + klass , e ) ; } } return userWorkspaceService ; } @ Override public void registerContribution ( Object contribution , String", "gt": "extensionPoint , ComponentInstance contributor ) throws ClientException", "prediction": "contributionName )\n", "label": 1}
{"id": 742, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class SourceID_attribute extends Attribute { SourceID_attribute ( ClassReader cr , int name_index , int length ) throws IOException { super ( name_index , length ) ; sourceID_index = cr . readUnsignedShort ( ) ; } public SourceID_attribute ( ConstantPool constant_pool , int sourceID_index ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . SourceID ) , sourceID_index ) ; } public SourceID_attribute ( int name_index , int sourceID_index ) { super ( name_index , 2 ) ; this . sourceID_index = sourceID_index ; } String getSourceID ( ConstantPool constant_pool ) throws ConstantPoolException { return constant_pool", "gt": ". getUTF8Value ( sourceID_index ) ;", "prediction": ";\n", "label": 0}
{"id": 16000, "input": "<s> package org . eclipse . ui . tests . session ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . part . ViewPart ; public class ViewWithState extends ViewPart { private static final String STATE = \"state\" ; public int fState = 0 ; public void createPartControl ( Composite parent ) { Label l = new Label ( parent , SWT . NONE ) ; l . setText ( \"This view should have some saved state: \" + fState ) ; } public void setFocus ( ) { } public void init ( IViewSite site , IMemento memento ) throws PartInitException { super .", "gt": "init ( site , memento ) ;", "prediction": "init ( site , memento ) ;\n", "label": 1}
{"id": 8701, "input": "<s> package org . ofbiz . accounting . thirdparty . valuelink ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . security . InvalidAlgorithmParameterException ; import java . security . InvalidKeyException ; import java . security . KeyFactory ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . PrivateKey ; import java . security . PublicKey ; import java . security . spec . InvalidKeySpecException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Random ; import javax . crypto . BadPaddingException ; import javax . crypto . Cipher ; import javax . crypto . IllegalBlockSizeException ; import javax . crypto . KeyAgreement ; import javax . crypto . KeyGenerator ; import javax . crypto . NoSuchPaddingException ; import javax . crypto . SecretKey ; import javax . crypto . SecretKeyFactory ; import javax . crypto . interfaces . DHPrivateKey ; import javax . crypto . interfaces . DHPublicKey ; import javax . crypto . spec . DESKeySpec ; import javax . crypto . spec . DESedeKeySpec ; import javax . crypto . spec . DHParameterSpec ; import javax . crypto . spec . DHPrivateKeySpec ; import javax . crypto . spec . DHPublicKeySpec ; import javax . crypto . spec . IvParameterSpec ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . HttpClient ; import org . ofbiz . base . util . HttpClientException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class ValueLinkApi { public static final String module = ValueLinkApi . class . getName ( ) ; private static Map < String , Object > objectCache = FastMap . newInstance ( ) ; protected Delegator delegator = null ; protected Properties props = null ; protected SecretKey kek = null ; protected SecretKey mwk = null ; protected String merchantId = null ; protected String terminalId = null ; protected Long mwkIndex = null ; protected boolean debug = false ; protected ValueLinkApi ( ) { } protected ValueLinkApi ( Delegator delegator , Properties props ) { String mId = ( String ) props . get ( \"payment.valuelink.merchantId\" ) ; String tId = ( String ) props .", "gt": "get ( \"payment.valuelink.terminalId\" ) ;", "prediction": "get ( \"payment.valuelink.tid\" ) ;\n", "label": 0}
{"id": 16005, "input": "<s> package org . eclipse . jface . resource ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; final class ArrayFontDescriptor extends FontDescriptor { private FontData [ ] data ; private Font originalFont = null ; public ArrayFontDescriptor ( FontData [ ] data ) { this . data = data ; } public ArrayFontDescriptor ( Font originalFont ) { this ( originalFont . getFontData ( ) ) ; this . originalFont = originalFont ; } public FontData [ ] getFontData ( ) { return copy ( data ) ; } public Font createFont ( Device device ) { if ( originalFont != null ) { if ( originalFont . getDevice ( ) == device ) { return originalFont ; } } return new Font ( device , data ) ; } public boolean equals ( Object obj ) { if ( ( obj . getClass ( ) == ArrayFontDescriptor . class ) ) { ArrayFontDescriptor descr = ( ArrayFontDescriptor ) obj ; if ( descr . originalFont != originalFont ) { return false ; } if ( originalFont != null ) { return true ; } if ( data . length != descr . data . length ) { return false ; } for ( int i = 0 ; i < data . length ; i ++ ) { FontData fd = data [ i ] ; FontData fd2 = descr . data [ i ] ; if ( ! fd .", "gt": "equals ( fd2 ) )", "prediction": "equals ( fd2 ) )\n", "label": 1}
{"id": 7443, "input": "<s> package javax . lang", "gt": ". model . util ;", "prediction": ". test ;\n", "label": 0}
{"id": 16010, "input": "<s> package org . nuxeo . connect . update . task . live . commands ; import java . io . File ; import java . util . Map ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . connect . update . PackageException ; import org . nuxeo . connect . update . task . Command ; import org . nuxeo . connect . update . task . Task ; import org . nuxeo . connect . update . task .", "gt": "standalone . commands . LoadJarPlaceholder ;", "prediction": "WorkbenchMessages ;\n", "label": 1}
{"id": 8124, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import com . sun . tools . doclets . formats . html . markup . * ; public class PackageWriterImpl extends HtmlDocletWriter implements PackageSummaryWriter { protected PackageDoc prev ; protected PackageDoc next ; protected PackageDoc packageDoc ; private static final String OUTPUT_FILE_NAME = \"package-summary.html\" ; public PackageWriterImpl ( ConfigurationImpl configuration , PackageDoc packageDoc , PackageDoc prev , PackageDoc next ) throws IOException { super ( configuration , DirectoryManager . getDirectoryPath ( packageDoc ) , OUTPUT_FILE_NAME , DirectoryManager . getRelativePath ( packageDoc . name ( ) ) ) ; this . prev = prev ; this . next = next ; this . packageDoc = packageDoc ; } public String getOutputFileName ( ) { return OUTPUT_FILE_NAME ; } public Content getPackageHeader ( String heading ) { String pkgName = packageDoc . name ( ) ; Content bodyTree = getBody ( true , getWindowTitle ( pkgName ) ) ; addTop ( bodyTree ) ; addNavLinks ( true , bodyTree ) ; HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . header ) ; Content annotationContent = new HtmlTree ( HtmlTag . P ) ; addAnnotationInfo ( packageDoc , annotationContent ) ; div . addContent ( annotationContent ) ; Content tHeading = HtmlTree . HEADING ( HtmlConstants . TITLE_HEADING , true , HtmlStyle . title , packageLabel ) ; tHeading . addContent ( getSpace ( ) ) ; Content packageHead = new RawHtml ( heading ) ; tHeading . addContent ( packageHead ) ; div . addContent ( tHeading ) ; addDeprecationInfo ( div ) ; if ( packageDoc . inlineTags ( ) . length > 0 && ! configuration . nocomment ) { HtmlTree docSummaryDiv = new HtmlTree ( HtmlTag . DIV ) ; docSummaryDiv . addStyle ( HtmlStyle . docSummary ) ; addSummaryComment ( packageDoc , docSummaryDiv ) ; div . addContent ( docSummaryDiv ) ; Content space = getSpace ( ) ; Content descLink = getHyperLink ( \"\" , \"package_description\" , descriptionLabel , \"\" , \"\" ) ; Content descPara = new HtmlTree ( HtmlTag . P , seeLabel , space , descLink ) ; div . addContent ( descPara ) ; } bodyTree . addContent ( div ) ; return bodyTree ; } public Content getContentHeader ( ) { HtmlTree div = new HtmlTree ( HtmlTag . DIV ) ; div . addStyle ( HtmlStyle . contentContainer ) ; return div ; } public void addDeprecationInfo ( Content div ) { Tag [ ] deprs = packageDoc . tags ( \"deprecated\" ) ; if ( Util . isDeprecated ( packageDoc ) ) { HtmlTree deprDiv = new HtmlTree ( HtmlTag . DIV ) ; deprDiv . addStyle ( HtmlStyle . deprecatedContent ) ; Content deprPhrase = HtmlTree . SPAN ( HtmlStyle . strong , deprecatedPhrase ) ; deprDiv . addContent ( deprPhrase ) ; if ( deprs . length > 0 ) { Tag [ ] commentTags = deprs [ 0 ] . inlineTags ( ) ; if ( commentTags . length > 0 ) { addInlineDeprecatedComment ( packageDoc , deprs [ 0 ] , deprDiv ) ; } } div . addContent ( deprDiv ) ; } } public Content getSummaryHeader ( ) { HtmlTree ul = new HtmlTree ( HtmlTag . UL ) ; ul . addStyle ( HtmlStyle . blockList ) ; return ul ; } public void addClassesSummary ( ClassDoc [ ] classes , String label , String tableSummary , String [ ] tableHeader , Content summaryContentTree ) { if ( classes . length > 0 ) { Arrays . sort ( classes ) ; Content caption = getTableCaption ( label ) ; Content table = HtmlTree . TABLE ( HtmlStyle . packageSummary , 0 , 3 , 0 , tableSummary , caption ) ; table . addContent ( getSummaryTableHeader ( tableHeader , \"col\" ) ) ; Content tbody = new HtmlTree ( HtmlTag . TBODY ) ; for ( int i = 0 ; i < classes . length ; i ++ ) { if ( ! Util . isCoreClass ( classes [ i ] ) || ! configuration . isGeneratedDoc ( classes [ i ] ) ) { continue ; } Content classContent = new RawHtml ( getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_PACKAGE , classes", "gt": "[ i ] , false ) ) ) ;", "prediction": "[ i ] ) ) ) ;\n", "label": 0}
{"id": 16018, "input": "<s> package org . nlogo . extensions . sound ; import java . net . URL ; public class PlaySoundAndWait implements org . nlogo . api . Command { public String getAgentClassString ( ) { return \"OTP\" ; } public org . nlogo . api . Syntax getSyntax ( ) { int [ ] right = { org . nlogo . api . Syntax . StringType ( ) , } ; return org . nlogo . api . Syntax . commandSyntax ( right ) ; } public boolean getSwitchesBoolean ( ) { return false ; } public org . nlogo . api . Command newInstance ( String name ) { return new PlaySoundAndWait ( ) ; } public void perform ( org . nlogo . api . Argument args [ ] , org . nlogo . api . Context context ) throws org . nlogo . api . ExtensionException , org . nlogo . api . LogoException { try { String soundpath = args [ 0 ] . getString ( ) ; URL soundurl ; soundpath = context . attachCurrentDirectory ( soundpath ) ; try { soundurl = new URL ( context . attachCurrentDirectory ( soundpath ) ) ; } catch ( java . net . MalformedURLException ex ) { soundurl = new URL ( \"file\" , \"\" , soundpath ) ; } SoundExtension . playSoundAndWait ( soundurl ) ; } catch ( java . net . MalformedURLException ex ) { throw new org . nlogo . api . ExtensionException ( \"Unable to open sound sample: \" +", "gt": "ex . getMessage ( ) ) ;", "prediction": "soundurl ) ;\n", "label": 1}
{"id": 2827, "input": "<s> package org . osgi . framework . resource ; import java . util . Map ; import org . osgi . framework . Constants ; public interface Requirement { String getNamespace ( ) ; Map < String , String > getDirectives ( ) ; Map < String , Object", "gt": "> getAttributes ( ) ;", "prediction": "> getDirectives ( ) ;\n", "label": 0}
{"id": 16019, "input": "<s> package org . restlet ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . Protocol ; public abstract class Connector extends Restlet { private final List < Protocol > protocols ; public Connector ( Context context ) { this ( context , null ) ; } public Connector ( Context context , List < Protocol > protocols ) { super ( context ) ; if ( protocols == null ) { this . protocols = new CopyOnWriteArrayList < Protocol > ( ) ; } else { this . protocols = new CopyOnWriteArrayList < Protocol > ( protocols ) ; } } public List < Protocol > getProtocols ( ) { return this . protocols ; }", "gt": "public abstract boolean isAvailable ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8322, "input": "<s> public enum EnumSwitch4 { foo , bar , baz ; public static void main ( String [ ] args ) { EnumSwitch4 e = null ; try { switch ( e ) { default : break ; } throw new Error ( \"failed to throw NullPointerException\" ) ; } catch ( NullPointerException ex ) { System", "gt": ". out . println ( \"passed\" ) ;", "prediction": ". err . println ( ex ) ;\n", "label": 0}
{"id": 16040, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . server . configuration ; import java . util . Map ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; public interface UserInfoMapper { Map < String , String > getUserInfo", "gt": "( NuxeoPrincipal principal ) ;", "prediction": "Mappings ( ) ;\n", "label": 1}
{"id": 8067, "input": "<s> package LizaCraft . Events ; import java . lang . reflect . Field ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . bukkit . plugin . Plugin ; import org . bukkit . plugin . PluginDescriptionFile ; import org . bukkit . plugin . PluginLoader ; import org . bukkit . plugin . PluginManager ; import org . bukkit . plugin . SimplePluginManager ; import org . bukkit . plugin . java . JavaPlugin ; import Liza . LizaServer ; public class EventEnabler { private static final String PLUGIN_MANAGER_LIST_NAME = \"plugins\" ; private static final String PLUGIN_MANAGER_FILE_ASSOCIATION_MAP = \"fileAssociations\" ; private static final String PLUGIN_ENABLED_FIELD_NAME = \"isEnabled\" ; private static final String PLUGIN_SERVER_FIELD_NAME = \"server\" ; private static final String PLUGIN_LOADER_FIELD_NAME = \"loader\" ; private static final String PLUGIN_DESCRIPTION_FIELD_NAME = \"description\" ; private static final String PLUGIN_LOOKUP_FIELD_NAME = \"lookupNames\" ; private static final String PLUGIN_EXTENSION = \".jar\" ; public void enableEvents ( LizaServer server , LizaPlugin eventListener ) { Class < ? extends PluginManager > pluginManager = ( ( SimplePluginManager ) server . getPluginManager ( ) ) . getClass ( ) ; PluginLoader pluginLoader = getPluginLoader ( server , pluginManager ) ; PluginDescriptionFile desc = new PluginDescriptionFile ( LizaPlugin . PLUGIN_NAME , null , null ) ; initializePlugin ( server , eventListener , pluginLoader , desc ) ; addPlugin ( server , eventListener , pluginManager ) ; eventListener . onEnable ( ) ; } @ SuppressWarnings ( \"unchecked\" ) private void addPlugin ( LizaServer server , LizaPlugin eventListener , Class < ? extends PluginManager > pluginManager ) { Field pluginList , lookupMap ; List < Plugin > plugins ; try { pluginList = pluginManager . getDeclaredField ( PLUGIN_MANAGER_LIST_NAME ) ; pluginList . setAccessible ( true ) ; plugins = ( List < Plugin > ) pluginList . get ( server . getPluginManager ( ) ) ; plugins . add ( eventListener ) ; pluginList . set ( server . getPluginManager ( ) , plugins ) ; pluginList . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } Map < String , Plugin > lookupNames ; try { lookupMap = pluginManager . getDeclaredField ( PLUGIN_LOOKUP_FIELD_NAME ) ; lookupMap . setAccessible ( true ) ; lookupNames = ( HashMap < String , Plugin > ) lookupMap . get ( server . getPluginManager ( ) ) ; lookupNames . put ( LizaPlugin . PLUGIN_NAME , eventListener ) ; lookupMap . set ( server . getPluginManager ( ) , lookupNames ) ; lookupMap . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void initializePlugin ( LizaServer server , LizaPlugin eventListener , PluginLoader pluginLoader , PluginDescriptionFile desc ) { Field isEnabled , loaderField , serverField , descriptionField ; Class < ? extends JavaPlugin > plugin = eventListener . getClass ( ) ; try { isEnabled = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_ENABLED_FIELD_NAME ) ; isEnabled . setAccessible ( true ) ; isEnabled . set ( eventListener , true ) ; isEnabled . setAccessible ( false ) ; loaderField = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_LOADER_FIELD_NAME ) ; loaderField . setAccessible ( true ) ; loaderField . set ( eventListener , pluginLoader ) ; loaderField . setAccessible ( false ) ; serverField = plugin . getSuperclass ( ) . getDeclaredField ( PLUGIN_SERVER_FIELD_NAME ) ; serverField . setAccessible ( true ) ; serverField . set ( eventListener , server ) ; serverField . setAccessible ( false ) ; descriptionField = plugin . getSuperclass ( )", "gt": ". getDeclaredField ( PLUGIN_DESCRIPTION_FIELD_NAME ) ;", "prediction": ". getDeclaredField ( PLUGIN_DESCRIPTION_FIELD_NAME ) ;\n", "label": 0}
{"id": 16043, "input": "<s> package org . eclipse . swt . custom ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; import org . eclipse . swt . widgets . * ; public class TreeEditor_Test extends TestCase { private Display display ; private Shell shell ; public void testIsSerializable ( ) throws Exception { String itemText = \"item0\" ; Tree tree = new Tree ( shell , SWT . NONE ) ; new TreeColumn ( tree , SWT . NONE ) ; new TreeColumn ( tree , SWT . NONE ) ; TreeItem item = new TreeItem ( tree , SWT . NONE ) ; item . setText ( itemText ) ; TreeEditor treeEditor = new TreeEditor ( tree ) ; treeEditor", "gt": ". setColumn ( 1 ) ;", "prediction": ". setDisplay ( display ) ;\n", "label": 1}
{"id": 954, "input": "<s> package com . sensor ; import android . os . Handler ; class SensorDelayThread extends Thread { private Boolean threadAlive = true ; public Handler mHandler ; public int delayTime = 1000 ; public SensorDelayThread ( SensorDelayHandler myHandler , int delayTime ) { this . mHandler = myHandler ; this . delayTime = delayTime ; } public void stopThread ( ) { synchronized ( this ) { threadAlive = false ; } } public void run ( ) { do { mHandler . sendEmptyMessage ( 0 ) ; try { Thread . sleep ( delayTime ) ; } catch ( InterruptedException e ) {", "gt": "e . printStackTrace ( ) ;", "prediction": "}\n", "label": 0}
{"id": 16050, "input": "<s> package org . restlet . test . ext . jaxrs . services . car ; import javax . ws . rs . GET ; import javax . ws . rs . Produces ; public class EngineResource { public static String getPlainRepr ( int carId ) { return \"This is the engine of car with id \" + carId + \".\" ; } private final CarResource car ; public EngineResource ( CarResource car ) { this . car = car ; } @ GET @ Produces ( \"text/plain\" ) public String getText ( ) { final int carId = this . car", "gt": ". getId ( ) ;", "prediction": ". getId ( ) ;\n", "label": 1}
{"id": 6840, "input": "<s> package com . pagosoft . plaf . themes ; import com . pagosoft . plaf . PgsTheme ; import com . pagosoft . swing . ColorUtils ; import javax . swing . plaf . * ; import java . awt . * ; public class ElegantGrayTheme extends PgsTheme { private static ElegantGrayTheme INSTANCE ; private ElegantGrayTheme ( String themeName , Color p1 , Color p2 , Color p3 , Color s1 , Color s2 , Color s3 , Color bl , Color wh , Object [ ] d ) { super ( themeName , p1 , p2 , p3 , s1 , s2 , s3 , bl , wh , d ) ; } public static PgsTheme getInstance ( ) { if ( INSTANCE == null ) { Color s1 = new Color ( 0x636363 ) ; Color s2 = new Color ( 0x999999 ) ; Color s3 = new Color ( 0xd4d0c8 ) ; Color p1 = new Color ( 0x8795a1 ) ; Color p2 = new Color ( 0x92bad9 ) ; Color p3 = new Color ( 0xc1d6e6 ) ; ColorUIResource menuBg = new ColorUIResource ( ColorUtils . getSimiliarColor ( s3 , 1.125f ) ) ; Object [ ] d = new Object [ ] { \"PopupMenu.background\" , menuBg , \"Menu.background\" , menuBg , \"MenuItem.background\" , menuBg , \"RadioButtonMenuItem.background\" , menuBg , \"CheckBoxMenuItem.background\" , menuBg , \"Button.rolloverVistaStyle\" , Boolean . TRUE , \"glow\" , new ColorUIResource ( ColorUtils . getSimiliarColor ( p1 , 1.0f ) ) , \"ToolBar.gradientStart\" , s3 , \"ToolBar.gradientEnd\" , s2 , \"ToolBarButton.rolloverBackground\" , s2 , \"ToolBarButton.rolloverBorderColor\" , s1 , \"ToolBarButton.isFlat\" , Boolean . FALSE , \"ToolBarButton.rolloverGradientStart\" , s2 , \"ToolBarButton.rolloverGradientEnd\" , s2 , \"ToolBarButton.selectedGradientStart\"", "gt": ", s2 , \"ToolBarButton.selectedGradientEnd\" , s3 }", "prediction": "}\n", "label": 0}
{"id": 16052, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getAttachmentCollectionResult\" } ) @ XmlRootElement ( name = \"GetAttachmentCollectionResponse\" ) public class GetAttachmentCollectionResponse { @ XmlElement ( name = \"GetAttachmentCollectionResult\" ) protected GetAttachmentCollectionResponse . GetAttachmentCollectionResult getAttachmentCollectionResult ; public GetAttachmentCollectionResponse . GetAttachmentCollectionResult getGetAttachmentCollectionResult ( ) { return getAttachmentCollectionResult ; } public void setGetAttachmentCollectionResult", "gt": "( GetAttachmentCollectionResponse . GetAttachmentCollectionResult value )", "prediction": "( GetAttachmentCollectionResult result )\n", "label": 1}
{"id": 3529, "input": "<s> package opens . components . http . core ; import java . net . URLEncoder ; import java . util . Map ; import java . util . TreeMap ; public class HttpRequestParams { private Map < String , String > params ; public HttpRequestParams ( ) { params = new TreeMap < String , String > ( ) ; } public HttpRequestParams param ( String key , Object param ) { if ( param != null ) { return this . stringParam ( key , param . toString ( ) ) ; } return this ; } public HttpRequestParams stringParam ( String key , String val ) { if ( val == null ) { params . put ( key , val ) ; } return this ; } public void clear ( ) { params . clear ( ) ; } public String toURLParametersString ( ) { StringBuilder out = new StringBuilder ( ) ; boolean firstEntry = true ; for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { if ( firstEntry ) { firstEntry = false ; out", "gt": ". append ( '?' ) ;", "prediction": ". append ( entry ) ;\n", "label": 0}
{"id": 16055, "input": "<s> package org . eclipse . ui . internal . cheatsheets . data ; import java . util . ArrayList ; import java . util . Collection ; public class CheatSheet implements ICheatSheet { protected String title ; private Item introItem ; private ArrayList items ; private boolean containsCommandOrAction ; public CheatSheet ( ) { } public void setTitle ( String title ) { this . title = title ; } public String getTitle ( ) { return title ; } public Item getIntroItem ( ) { return introItem ; } public ArrayList getItems ( ) { return items ; } public void setIntroItem ( Item intro ) { introItem = intro ; } public", "gt": "void addItem ( Item item )", "prediction": "boolean containsCommandOrAction ( )\n", "label": 1}
{"id": 6265, "input": "<s> package org . json ; public class CDL { private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c == ' ' || c == '\\t' ) ; switch ( c ) { case 0 : return null ; case '\"' : case '\\'' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '\\n' || c == '\\r' ) { throw x . syntaxError ( \"Missing close quote '\" + q + \"'.\" ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case ',' : x . back ( ) ; return \"\" ; default : x . back ( ) ; return x . nextTo ( ',' ) ; } } public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c != ',' ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c == ',' ) { break ; } if ( c != ' ' ) { if ( c == '\\n' || c == '\\r' || c == 0 ) { return ja ; } throw x . syntaxError ( \"Bad character '\" + c + \"' (\" + ( int ) c + \").\" ) ; } c = x . next ( ) ; } } } public static JSONObject rowToJSONObject ( JSONArray names , JSONTokener x ) throws JSONException { JSONArray ja = rowToJSONArray ( x ) ; return ja != null ? ja . toJSONObject ( names ) : null ; } public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf ( ',' ) >= 0 || string . indexOf ( '\\n' ) >= 0 || string . indexOf ( '\\r' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == '\"' ) ) { sb . append ( '\"' ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >= ' ' && c != '\"' ) { sb . append ( c ) ; } } sb . append ( '\"' ) ; } else { sb . append ( string ) ; } } } sb . append ( '\\n' ) ; return sb . toString ( ) ; } public static JSONArray toJSONArray ( String string ) throws JSONException { return toJSONArray ( new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONTokener x ) throws JSONException { return toJSONArray ( rowToJSONArray ( x ) , x ) ; } public static JSONArray toJSONArray ( JSONArray names , String string ) throws JSONException { return toJSONArray ( names , new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; } public static String toString ( JSONArray ja ) throws JSONException { JSONObject jo", "gt": "= ja . optJSONObject ( 0 ) ;", "prediction": "= rowToJSONObject ( ja ) ;\n", "label": 0}
{"id": 16059, "input": "<s> package org . gatein . common . text ; import junit . framework . TestCase ; import org . gatein . common . text . CharToByteEncoder ; public class CharToByteEncoderTestCase extends TestCase { public void testCorrectness ( ) { CharToByteEncoder encoder = new CharToByteEncoder . Generic ( \"UTF8\" ) ; for ( int i = 0 ; i <= 0x10FFFD ; i ++ ) { char c = ( char ) i ; int type = Character . getType ( c ) ; byte [ ] r = encoder . encode ( c ) ; if ( type == Character . SURROGATE || type == Character . PRIVATE_USE ) { if ( r . length != 0 ) { fail ( \"Char \" + i + \" has length \" + r . length ) ; } } else { if ( r . length < 1 ) { fail ( \"Char \" + i + \" has", "gt": "length \" + r . length ) ;", "prediction": "length \" + r . length ) ;\n", "label": 1}
{"id": 5369, "input": "<s> package com . sun . source . tree ; public interface InstanceOfTree extends ExpressionTree { ExpressionTree getExpression ( ) ;", "gt": "Tree getType ( ) ;", "prediction": "}\n", "label": 0}
{"id": 16075, "input": "<s> package org . tartarus . snowball . ext ; import org . tartarus . snowball . SnowballProgram ; import org . tartarus . snowball . Among ; public class German2Stemmer extends SnowballProgram { private Among a_0 [ ] = { new Among ( \"\" , - 1 , 6 , \"\" , this ) , new Among ( \"ae\" , 0 , 2 , \"\" , this ) , new Among ( \"oe\" , 0 , 3 , \"\" , this ) , new Among ( \"qu\" , 0 , 5 , \"\" , this ) , new Among ( \"ue\" , 0 , 4 , \"\" , this ) , new Among ( \"\u00df\" , 0 , 1 , \"\" , this ) } ; private Among a_1 [ ] = { new Among ( \"\" , - 1 , 6 , \"\" , this ) , new Among ( \"U\" , 0 , 2 , \"\" , this ) , new Among ( \"Y\" , 0 , 1 , \"\" , this ) , new Among ( \"\u00e4\" , 0 , 3 , \"\" , this ) , new Among ( \"\u00f6\" , 0 , 4 , \"\" , this ) , new Among ( \"\u00fc\" , 0 , 5 , \"\" , this ) } ; private Among a_2 [ ] = { new Among ( \"e\" , - 1 , 1 , \"\" , this ) , new Among ( \"em\" , - 1 , 1 , \"\" , this ) , new Among ( \"en\" , - 1 , 1 , \"\" , this ) , new Among ( \"ern\" , - 1 , 1 , \"\" , this ) , new Among ( \"er\" , - 1 , 1 , \"\" , this ) , new Among ( \"s\" , - 1 , 2 , \"\" , this ) , new Among ( \"es\" , 5 , 1 , \"\" , this ) } ; private Among a_3 [ ] = { new Among ( \"en\" , - 1 , 1 , \"\" , this ) , new Among ( \"er\" , - 1 , 1 , \"\" , this ) , new Among ( \"st\" , - 1 , 2 , \"\" , this ) , new Among ( \"est\" , 2 , 1 , \"\" , this ) } ; private Among a_4 [ ] = { new Among ( \"ig\" , - 1 , 1 , \"\" , this ) , new Among ( \"lich\" , - 1 , 1 , \"\" , this ) } ; private Among a_5 [ ] = { new Among ( \"end\" , - 1 , 1 , \"\" , this ) , new Among ( \"ig\" , - 1 , 2 , \"\" , this ) , new Among ( \"ung\" , - 1 , 1 , \"\" , this ) , new Among ( \"lich\" , - 1 , 3 , \"\" , this ) , new Among ( \"isch\" , - 1 , 2 , \"\" , this ) , new Among ( \"ik\" , - 1 , 2 , \"\" , this ) , new Among ( \"heit\" , - 1 , 3 , \"\" , this ) , new Among ( \"keit\" , - 1 , 4 , \"\" , this ) } ; private static final char g_v [ ] = { 17 , 65 , 16 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 8 , 0 , 32 , 8 } ; private static final char g_s_ending [ ] = { 117 , 30 , 5 } ; private static final char g_st_ending [ ] = { 117 , 30 , 4 } ; private int I_x ; private int I_p2 ; private int I_p1 ; private void copy_from ( German2Stemmer other ) { I_x = other . I_x ; I_p2 = other . I_p2 ; I_p1 = other . I_p1 ; super . copy_from ( other ) ; } private boolean r_prelude ( ) { int among_var ; int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; v_1 = cursor ; replab0 : while ( true ) { v_2 = cursor ; lab1 : do { golab2 : while ( true ) { v_3 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v ,", "gt": "97 , 252 ) ) )", "prediction": "v_3 ) ) )\n", "label": 1}
{"id": 2327, "input": "<s> package org . parboiled . examples . calculators ; import org . parboiled . Parboiled ; import org . parboiled . Rule ; import org . parboiled . examples . TestNgParboiledTest ; import org . parboiled . support . ParsingResult ; import org . parboiled . test . ParboiledTest ; import org . parboiled . parserunners . ReportingParseRunner ; import org . testng . annotations . Test ; import static org . parboiled . errors . ErrorUtils . printParseErrors ; import static org . testng . Assert . assertEquals ; public class ReportingParseRunnerTest extends TestNgParboiledTest < Integer > { private CalculatorParser1 parser = Parboiled . createParser ( CalculatorParser1 . class ) ; @ Test public void testSimpleReporting ( ) { test ( \"X1+2\" , \"Invalid input 'X', expected InputLine (line 1, pos 1):\\nX1+2\\n^\\n\" ) ; test ( \"1X+2\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 2):\\n1X+2\\n ^\\n\" ) ; test ( \"1+X2\" , \"Invalid input 'X', expected Term (line 1, pos 3):\\n1+X2\\n  ^\\n\" ) ; test ( \"1+2X\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 4):\\n1+2X\\n   ^\\n\" ) ; test ( \"1+2X*(3-4)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or EOI (line 1, pos 4):\\n1+2X*(3-4)-5\\n   ^\\n\" ) ; test ( \"1+2*X(3-4)-5\" , \"Invalid input 'X', expected Factor (line 1, pos 5):\\n1+2*X(3-4)-5\\n    ^\\n\" ) ; test ( \"1+2*(X3-4)-5\" , \"Invalid input 'X', expected Expression (line 1, pos 6):\\n1+2*(X3-4)-5\\n     ^\\n\" ) ; test ( \"1+2*(3X-4)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or ')' (line 1, pos 7):\\n1+2*(3X-4)-5\\n      ^\\n\" ) ; test ( \"1+2*(3-X4)-5\" , \"Invalid input 'X', expected Term (line 1, pos 8):\\n1+2*(3-X4)-5\\n       ^\\n\" ) ; test ( \"1+2*(3-4X)-5\" , \"Invalid input 'X', expected Digit, '*', '/', '+', '-' or ')' (line 1, pos 9):\\n1+2*(3-4X)-5\\n   ", "gt": "    ^\\n\" ) ;", "prediction": "^\\n\" ) ;\n", "label": 0}
{"id": 16076, "input": "<s> package org . apache . lucene . xmlparser . builders ; import org . apache . lucene . search . ConstantScoreQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . xmlparser . DOMUtils ; import org . apache . lucene . xmlparser . FilterBuilderFactory ; import org . apache . lucene . xmlparser . ParserException ; import org . apache . lucene . xmlparser . QueryBuilder ; import org . w3c . dom . Element ; public class ConstantScoreQueryBuilder implements QueryBuilder { private FilterBuilderFactory filterFactory ; public ConstantScoreQueryBuilder ( FilterBuilderFactory filterFactory ) { this . filterFactory = filterFactory ; } public Query getQuery ( Element e ) throws ParserException { Element filterElem = DOMUtils .", "gt": "getFirstChildOrFail ( e ) ;", "prediction": "getFilterElem ( e ) ;\n", "label": 1}
{"id": 3806, "input": "<s> package org . bombusim . lime . data ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; import android . database . sqlite . SQLiteStatement ; public class ChatHistoryDbAdapter { protected final static String DATABASE_TABLE = \"messages\" ; protected final static String DATABASE_NAME = \"messages.db\" ; protected final static int DATABASE_VERSION = 2 ; public final static String KEY_ID = \"_id\" ; public final static String KEY_RJID = \"rjid\" ; public final static String KEY_TYPE = \"type\" ; public final static String KEY_JID = \"jid\" ; public final static String KEY_SUBJ = \"subj\" ; public final static String KEY_BODY = \"body\" ; public final static String KEY_TIME = \"time\" ; public final static String KEY_UNREAD = \"unread\" ; private HistoryDbHelper dbHelper ; private SQLiteDatabase db ; private String rJid ; public ChatHistoryDbAdapter ( Context context , String rJid ) { dbHelper = new HistoryDbHelper ( context ) ; this . rJid = rJid ; } public void open ( boolean readOnly ) { try { if ( readOnly ) { db = dbHelper . getReadableDatabase ( ) ; } else { db = dbHelper . getWritableDatabase ( ) ; } } catch ( SQLException ex ) { db = dbHelper . getReadableDatabase ( ) ; } } public void close ( ) { db . close ( ) ; } public long putMessage ( Message msg , long position ) { ContentValues v = new ContentValues ( ) ; v . put ( KEY_RJID , rJid ) ; v . put ( KEY_TIME , msg . timestamp ) ; v . put ( KEY_TYPE , msg . type ) ; v . put ( KEY_JID , msg . fromJid ) ; v . put ( KEY_SUBJ , msg . subj ) ; v . put ( KEY_BODY , msg . messageBody ) ; v . put ( KEY_UNREAD , msg . unread ? 1 : 0 ) ; long id = - 1 ; if ( position < 0 ) { id = db . insert ( DATABASE_TABLE , null , v ) ; } else { id = db . update ( DATABASE_TABLE , v , KEY_ID + \"=\" + position , null ) ; } msg . setId ( id ) ; return id ; } public long removeMessage ( long position ) { return db . delete ( DATABASE_TABLE , KEY_ID + \"=\" + position , null ) ; } public long [ ] getMessageIndexes ( String jid , int limit ) { Cursor ind = getMessageCursor ( jid , limit ) ; int count = ind . getCount ( ) ; if ( count == 0 || ! ind . moveToFirst ( ) ) { ind . close ( ) ; return null ; } long [ ] result = new long [ count ] ; int id = ind . getColumnIndex ( KEY_ID ) ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ind . getLong ( id ) ; ind . moveToNext ( ) ; } ind . close ( ) ; return result ; } public Cursor getMessageCursor ( String jid , int limit ) { String select = KEY_RJID + \"='\" + rJid + \"'\" + \" AND \" + KEY_JID + \"='\" + jid + \"'\" ; String orderBy = KEY_TIME + \" ASC\" ; String sLimit = ( limit > 0 ) ? String . valueOf ( limit ) : null ; Cursor ind = db . query ( DATABASE_TABLE , null , select , null , null", "gt": ", null , orderBy , sLimit ) ;", "prediction": ") ;\n", "label": 0}
{"id": 16084, "input": "<s> package org . nuxeo . ecm . platform . notification . api ; import java . io . Serializable ; import java . util . List ; import java . util . Set ; public interface NotificationRegistry extends Serializable { void clear ( ) ; void registerNotification ( Notification notif , List < String > events ) ; void unregisterNotification ( Notification notif , List < String > events ) ; Set < String > getNotificationEventNames ( ) ; List < Notification > getNotificationsForEvent ( String eventId ) ; List < Notification > getNotifications ( ) ; List < Notification", "gt": "> getNotificationsForSubscriptions ( String parentType ) ;", "prediction": "> getNotifications ( ) ;\n", "label": 1}
{"id": 6118, "input": "<s> package org . dawb . workbench . plotting . preference ; public class FittingConstants { public static final String PEAK_NUMBER = \"org.dawb.workbench.plotting.tools.peakNumber\" ; public static final String PEAK_NUMBER_CHOICES = \"org.dawb.workbench.plotting.tools.peakNumberChoices\" ; public static final String FIT_SMOOTH_FACTOR = \"org.dawb.workbench.plotting.tools.fitSmoothFactor\" ; public static final String SHOW_FWHM_SELECTIONS = \"org.dawb.workbench.plotting.tools.showFWHMSelection\" ; public static final String SHOW_PEAK_SELECTIONS = \"org.dawb.workbench.plotting.tools.showPeakSelection\" ; public static final String SHOW_FITTING_TRACE = \"org.dawb.workbench.plotting.tools.showFittingTrace\" ; public static final String SHOW_ANNOTATION_AT_PEAK = \"org.dawb.workbench.plotting.tools.showAnnoationsAtPeak\" ; public static final String PEAK_TYPE = \"org.dawb.workbench.plotting.tools.peakType\" ;", "gt": "public static final String SMOOTHING = \"org.dawb.workbench.plotting.tools.smoothing\" ;", "prediction": "}\n", "label": 0}
{"id": 16093, "input": "<s> package org . fuzzydb . attrs . dimensions ; import org . fuzzydb . attrs . internal . Attribute ; import org . fuzzydb . attrs . util . Range3D ; import org . fuzzydb . dto . dimensions . IPoint3D ; import org . fuzzydb . dto . dimensions . IRange3D ; public abstract class RangePreference3D extends Attribute implements IRange3D { public IPoint3D getMax ( ) { return range3d . getMax ( ) ; } public IPoint3D getMin ( ) { return range3d . getMin ( ) ; } public RangePreference3D ( int attrId , IPoint3D min , IPoint3D max ) { super ( attrId ) ; range3d =", "gt": "new Range3D ( min , max ) ;", "prediction": "null ;\n", "label": 1}
{"id": 1758, "input": "<s> package org . bombusim . lime . fragments ; import java . security . InvalidParameterException ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import org . bombusim . lime . activity . ActiveChats ; import org . bombusim . lime . activity . ContactResourceSwitcher ; import org . bombusim . lime . data . Chat ; import org . bombusim . lime . data . ChatHistoryDbAdapter ; import org . bombusim . lime . data . Contact ; import org . bombusim . lime . data . Message ; import org . bombusim . lime . data . Roster ; import org . bombusim . lime . data . SimpleCursorLoader ; import org . bombusim . lime . service . XmppService ; import org . bombusim . lime . service . XmppServiceBinding ; import org . bombusim . lime . widgets . ChatEditText ; import org . bombusim . lime . widgets . ContactBar ; import org . bombusim . xmpp . handlers . ChatStates ; import org . bombusim . xmpp . handlers . MessageDispatcher ; import org . bombusim . xmpp . stanza . XmppPresence ; import org . bombusim . xmpp . stanza . XmppMessage ; import com . actionbarsherlock . app . SherlockFragment ; import android . app . Activity ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . res . Configuration ; import android . content . res . TypedArray ; import android . database . Cursor ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . support . v4 . app . Fragment ; import android . support . v4 . app . LoaderManager . LoaderCallbacks ; import android . support . v4 . content . Loader ; import android . support . v4 . widget . CursorAdapter ; import android . text . ClipboardManager ; import android . text . Editable ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . SpannableStringBuilder ; import android . text . TextWatcher ; import android . text . format . Time ; import android . text . method . LinkMovementMethod ; import android . text . style . ForegroundColorSpan ; import android . text . util . Linkify ; import android . view . ContextMenu ; import android . view . KeyEvent ; import android . view . LayoutInflater ; import android . view . Menu ; import android . view . MenuInflater ; import android . view . MenuItem ; import android . view . View ; import android . view . View . OnCreateContextMenuListener ; import android . view . ViewGroup ; import android . view . ContextMenu . ContextMenuInfo ; import android . view . View . OnClickListener ; import android . view . View . OnKeyListener ; import android . view . ViewGroup . LayoutParams ; import android . view . Window ; import android . view . inputmethod . EditorInfo ; import android . widget . AdapterView . AdapterContextMenuInfo ; import android . widget . BaseAdapter ; import android . widget . EditText ; import android . widget . ImageButton ; import android . widget . ImageView ; import android . widget . ListView ; import android . widget . TextView ; import android . widget . TextView . OnEditorActionListener ; import android . widget . Toast ; public class ChatFragment extends SherlockFragment implements LoaderCallbacks < Cursor > { private static final int CHAT_LOADER_ID = 0 ; private String jid ; private String rJid ; private ChatEditText mMessageBox ; private ImageButton mSendButton ; private ImageButton mSmileButton ; private ListView chatListView ; private ContactBar contactBar ; private View mChatActive ; private View mChatInactive ; private XmppServiceBinding serviceBinding ; Contact visavis ; private static Chat mChat ; String sentChatState ; private CursorAdapter mCursorAdapter ; protected String visavisNick ; protected String myNick ; public interface ChatFragmentListener { public void closeChatFragment ( ) ; public boolean isTabMode ( ) ; } @ Override public void onAttach ( Activity activity ) { super . onAttach ( activity ) ; if ( ! ( activity instanceof ChatFragmentListener ) ) throw new ClassCastException ( activity . toString ( ) + \" must implement ChatFragmentListener\" ) ; serviceBinding = new XmppServiceBinding ( activity ) ; } @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( ! getChatFragmentListener ( ) . isTabMode ( ) ) setHasOptionsMenu ( true ) ; } @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View v = inflater . inflate ( R . layout . chat , container , false ) ; contactBar = ( ContactBar ) v . findViewById ( R . id . contact_head ) ; mMessageBox = ( ChatEditText ) v . findViewById ( R . id . messageBox ) ; mSendButton = ( ImageButton ) v . findViewById ( R . id . sendButton ) ; mSmileButton = ( ImageButton ) v . findViewById (", "gt": "R . id . smileButton ) ;", "prediction": "R . id . smileButton ) ;\n", "label": 0}
{"id": 16094, "input": "<s> package org . eclipse . rap . ui . internal . servlet ; import java . util . * ; public final class EntryPointParameters { private static final Map < String , String > parametersById = new HashMap < String , String > ( ) ; public static void register ( String id , String parameter ) { parametersById . put ( id , parameter ) ; } public static void clear ( ) { parametersById . clear ( ) ; } public static String getById ( String id ) { return parametersById .", "gt": "get ( id ) ;", "prediction": "get ( id ) ;\n", "label": 1}
{"id": 2487, "input": "<s> class A { void foo ( ) { } } class B { void bar ( A a ) { a", "gt": ". foo ( ) ;", "prediction": ". foo ( ) ;\n", "label": 0}
{"id": 16098, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . jboss . seam . contexts . Contexts ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm", "gt": ". core . api . DocumentModel ;", "prediction": ". automation . core . annotations . ParamFactory ;\n", "label": 1}
{"id": 299, "input": "<s> package org . jboss . arquillian . android . api ; import java . util . List ; public interface AndroidBridge { List < AndroidDevice > getDevices ( ) ; void connect ( ) throws AndroidExecutionException ; boolean isConnected ( ) ; void", "gt": "disconnect ( ) throws AndroidExecutionException ;", "prediction": "disconnect ( ) ;\n", "label": 0}
{"id": 16099, "input": "<s> package org . json ; public class CDL { private static String getValue ( JSONTokener x ) throws JSONException { char c ; char q ; StringBuffer sb ; do { c = x . next ( ) ; } while ( c == ' ' || c == '\\t' ) ; switch ( c ) { case 0 : return null ; case '\"' : case '\\'' : q = c ; sb = new StringBuffer ( ) ; for ( ; ; ) { c = x . next ( ) ; if ( c == q ) { break ; } if ( c == 0 || c == '\\n' || c == '\\r' ) { throw x . syntaxError ( \"Missing close quote '\" + q + \"'.\" ) ; } sb . append ( c ) ; } return sb . toString ( ) ; case ',' : x . back ( ) ; return \"\" ; default : x . back ( ) ; return x . nextTo ( ',' ) ; } } public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { char c = x . next ( ) ; if ( c == ',' ) { break ; } if ( c != ' ' ) { if ( c == '\\n' || c == '\\r' || c == 0 ) { return ja ; } throw x . syntaxError ( \"Bad character '\" + c + \"' (\" + ( int ) c + \").\" ) ; } } } } public static JSONObject rowToJSONObject ( JSONArray names , JSONTokener x ) throws JSONException { JSONArray ja = rowToJSONArray ( x ) ; return ja != null ? ja . toJSONObject ( names ) : null ; } public static JSONArray toJSONArray ( String string ) throws JSONException { return toJSONArray ( new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONTokener x ) throws JSONException { return toJSONArray ( rowToJSONArray ( x ) , x ) ; } public static JSONArray toJSONArray ( JSONArray names , String string ) throws JSONException { return toJSONArray ( names , new JSONTokener ( string ) ) ; } public static JSONArray toJSONArray ( JSONArray names , JSONTokener x ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { JSONObject jo = rowToJSONObject ( names , x ) ; if ( jo == null ) { break ; } ja . put ( jo ) ; } if ( ja . length ( ) == 0 ) { return null ; } return ja ; } public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . indexOf ( ',' ) >= 0 || s . indexOf ( '\\n' ) >= 0 || s . indexOf ( '\\r' ) >= 0 || s . indexOf ( 0 ) >= 0 || s . charAt ( 0 ) == '\"' ) { sb . append ( '\"' ) ; int length = s . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = s . charAt ( j ) ; if ( c >=", "gt": "' ' && c != '\"' )", "prediction": "0 )\n", "label": 1}
{"id": 319, "input": "<s> package ar . com . fdvs . dj . domain . builders ; import java . util . Iterator ; import java . util . List ; import net . sf . jasperreports . charts . design . JRDesignCategoryDataset ; import net . sf . jasperreports . charts . design . JRDesignCategorySeries ; import net . sf . jasperreports . charts . design . JRDesignPieDataset ; import net . sf . jasperreports . engine . JRExpression ; import net . sf . jasperreports . engine . design . JRDesignChartDataset ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import ar . com . fdvs . dj . core . DJException ; import ar . com . fdvs . dj . domain . DJChart ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; public class DataSetFactory { public static JRDesignChartDataset getDataset ( DJChart djchart , JRDesignGroup group , JRDesignGroup parentGroup , List vars ) { JRDesignChartDataset dataSet = null ; byte chartType = djchart . getType ( ) ; if ( chartType == DJChart . PIE_CHART ) { dataSet = createPieDataset ( group , parentGroup , vars , djchart ) ; } else if ( chartType == DJChart . BAR_CHART ) { dataSet = createBarDataset ( group , parentGroup , vars , djchart ) ; } if ( dataSet == null ) { throw new DJException ( \"Error creating dataset for chart, no valid dataset type.\" ) ; } return dataSet ; } protected static JRDesignChartDataset createLineDataset ( JRDesignGroup group , JRDesignGroup parentGroup , List vars , DJChart djchart ) { JRDesignCategoryDataset data = new JRDesignCategoryDataset ( null ) ; JRDesignCategorySeries serie = new JRDesignCategorySeries ( ) ; JRDesignVariable var = ( JRDesignVariable ) vars . get ( 0 ) ; JRDesignVariable var1 = ( JRDesignVariable ) vars . get ( 0 ) ; if ( vars . size ( ) > 1 ) var1 = ( JRDesignVariable ) vars . get ( 1 ) ; JRDesignExpression varExp = getExpressionFromVariable ( var ) ; JRExpression varExp1 = var1 . getExpression ( ) ; serie . setValueExpression ( varExp ) ; JRExpression exp2 = group . getExpression ( ) ; JRDesignExpression exp3 = new JRDesignExpression ( ) ; int index = vars . indexOf ( var ) ; AbstractColumn col = ( AbstractColumn ) djchart . getColumns ( ) . get ( index ) ; exp3 . setText ( \"\\\"\" + col . getTitle ( ) + \"\\\"\" ) ; exp3 . setValueClass ( String . class ) ; serie . setCategoryExpression ( exp2 ) ; serie . setLabelExpression ( exp2 ) ; serie . setSeriesExpression ( varExp1 ) ; data . addCategorySeries ( serie ) ; setResetStyle ( data , group , parentGroup ) ; return data ; } protected static JRDesignChartDataset createBarDataset ( JRDesignGroup group", "gt": ", JRDesignGroup parentGroup , List vars , DJChart djchart )", "prediction": ", JRDesignGroup parentGroup , List vars )\n", "label": 0}
{"id": 16103, "input": "<s> package org . fuzzydb . attrs . decorators ; import org . fuzzydb . attrs . enums . EnumMultipleValue ; import org . fuzzydb . attrs . internal . BaseAttribute ; public class EnumMultiAttributeDecorator extends EnumAttributeDecorator { private static final long serialVersionUID = 1L ; public EnumMultiAttributeDecorator ( String name , String [ ] strings ) { super ( name , strings ) ; } @ Override public String getValueString ( BaseAttribute attr ) { EnumMultipleValue val = ( EnumMultipleValue ) attr ; StringBuilder str = new StringBuilder ( ) ; for ( short index : val . getValues ( ) ) { str . append ( getStringFor ( index ) ) . append ( \", \" ) ; } return str . substring ( 0 , str . length", "gt": "( ) - 2 ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 6100, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . part ; import java . io . IOException ; import java . util . LinkedList ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . operations . OperationHistoryFactory ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Path ; import org . eclipse . emf . common . util . URI ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . emf . ecore . resource . ResourceSet ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . runtime . common . core . command . CommandResult ; import org . eclipse . gmf . runtime . diagram . core . services . ViewService ; import org . eclipse . gmf . runtime . diagram . core . services . view . CreateDiagramViewOperation ; import org . eclipse . gmf . runtime . emf . commands . core . command . AbstractTransactionalCommand ; import org . eclipse . gmf . runtime . emf . core . util . EObjectAdapter ; import org . eclipse . gmf . runtime . notation . Diagram ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . wizard . Wizard ; import org . eclipse . osgi . util . NLS ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . dialogs . WizardNewFileCreationPage ; import org . msl . simple . gmfmap . simplemappings . diagram . edit . parts . SimpleMappingEditPart ; public class SimplemapNewDiagramFileWizard extends Wizard { private WizardNewFileCreationPage myFileCreationPage ; private ModelElementSelectionPage diagramRootElementSelectionPage ; private TransactionalEditingDomain myEditingDomain ; public SimplemapNewDiagramFileWizard ( URI domainModelURI , EObject diagramRoot , TransactionalEditingDomain editingDomain ) { assert domainModelURI != null : \"Domain model uri must be specified\" ; assert diagramRoot != null : \"Doagram root element must be specified\" ; assert editingDomain != null : \"Editing domain must be specified\" ; myFileCreationPage = new WizardNewFileCreationPage ( Messages . SimplemapNewDiagramFileWizard_CreationPageName , StructuredSelection . EMPTY ) ; myFileCreationPage . setTitle ( Messages . SimplemapNewDiagramFileWizard_CreationPageTitle ) ; myFileCreationPage . setDescription ( NLS . bind ( Messages . SimplemapNewDiagramFileWizard_CreationPageDescription , SimpleMappingEditPart . MODEL_ID ) ) ; IPath filePath ; String fileName = URI . decode ( domainModelURI . trimFileExtension ( ) . lastSegment ( ) ) ; if ( domainModelURI . isPlatformResource ( ) ) { filePath = new Path ( domainModelURI . trimSegments ( 1 ) . toPlatformString ( true ) ) ; } else if ( domainModelURI . isFile ( ) ) { filePath = new Path ( domainModelURI . trimSegments ( 1 ) . toFileString ( ) ) ; } else { throw new IllegalArgumentException ( \"Unsupported URI: \" + domainModelURI ) ; } myFileCreationPage . setContainerFullPath ( filePath ) ; myFileCreationPage . setFileName ( SimplemapDiagramEditorUtil . getUniqueFileName ( filePath , fileName , \"simplemappings\" ) ) ; diagramRootElementSelectionPage = new DiagramRootElementSelectionPage ( Messages . SimplemapNewDiagramFileWizard_RootSelectionPageName ) ; diagramRootElementSelectionPage . setTitle ( Messages . SimplemapNewDiagramFileWizard_RootSelectionPageTitle ) ; diagramRootElementSelectionPage . setDescription ( Messages . SimplemapNewDiagramFileWizard_RootSelectionPageDescription ) ; diagramRootElementSelectionPage . setModelElement ( diagramRoot ) ; myEditingDomain = editingDomain ; } public void addPages ( ) { addPage ( myFileCreationPage ) ; addPage ( diagramRootElementSelectionPage ) ; } public boolean performFinish ( ) { LinkedList < IFile > affectedFiles = new LinkedList < IFile > ( ) ; IFile diagramFile = myFileCreationPage . createNewFile ( ) ; SimplemapDiagramEditorUtil . setCharset ( diagramFile ) ; affectedFiles . add ( diagramFile ) ; URI diagramModelURI = URI . createPlatformResourceURI ( diagramFile . getFullPath ( ) . toString ( ) , true ) ; ResourceSet resourceSet = myEditingDomain . getResourceSet ( ) ; final Resource diagramResource = resourceSet . createResource ( diagramModelURI ) ; AbstractTransactionalCommand command = new AbstractTransactionalCommand ( myEditingDomain , Messages . SimplemapNewDiagramFileWizard_InitDiagramCommand , affectedFiles ) { protected CommandResult doExecuteWithResult ( IProgressMonitor monitor , IAdaptable info ) throws ExecutionException { int diagramVID = SimplemapVisualIDRegistry . getDiagramVisualID ( diagramRootElementSelectionPage . getModelElement ( ) ) ; if ( diagramVID != SimpleMappingEditPart . VISUAL_ID ) { return CommandResult . newErrorCommandResult ( Messages . SimplemapNewDiagramFileWizard_IncorrectRootError ) ; } Diagram diagram = ViewService . createDiagram ( diagramRootElementSelectionPage . getModelElement ( ) , SimpleMappingEditPart . MODEL_ID , SimplemapDiagramEditorPlugin . DIAGRAM_PREFERENCES_HINT ) ; diagramResource . getContents ( ) . add ( diagram ) ; diagramResource . getContents ( ) . add ( diagram . getElement ( ) ) ; return CommandResult . newOKCommandResult ( ) ; } } ; try { OperationHistoryFactory . getOperationHistory ( ) . execute ( command , new NullProgressMonitor ( ) , null ) ; diagramResource . save ( SimplemapDiagramEditorUtil . getSaveOptions ( ) ) ; SimplemapDiagramEditorUtil . openDiagram ( diagramResource ) ; } catch ( ExecutionException e ) { SimplemapDiagramEditorPlugin . getInstance ( ) . logError ( \"Unable to create model and diagram\" , e ) ; } catch ( IOException ex ) { SimplemapDiagramEditorPlugin . getInstance ( ) . logError ( \"Save operation failed for: \" + diagramModelURI , ex ) ; } catch ( PartInitException ex ) { SimplemapDiagramEditorPlugin . getInstance ( ) . logError ( \"Unable to open", "gt": "editor\" , ex ) ;", "prediction": "model and diagram\" , ex ) ;\n", "label": 0}
{"id": 16107, "input": "<s> package org . powerbot . game . api . methods ; import java . awt . Canvas ; import java . awt . Point ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . methods . widget . WidgetComposite ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . RegionOffset ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . interactive . Player ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSGroundByts ; import org . powerbot . game . client . RSGroundInfo ; import org . powerbot . game . client . RSInfo ; import org . powerbot . game . client . TileData ; public class Calculations { public static class Toolkit { public float absoluteX , absoluteY ; public float xMultiplier , yMultiplier ; } public static class Viewport { public float xOff , xX , xY , xZ ; public float yOff , yX , yY , yZ ; public float zOff , zX , zY , zZ ; } public static final int [ ] SIN_TABLE = new int [ 0x4000 ] ; public static final int [ ] COS_TABLE = new int [ 0x4000 ] ; static { final double d = 0.00038349519697141029D ; for ( int i = 0 ; i < 0x4000 ; i ++ ) { Calculations . SIN_TABLE [ i ] = ( int ) ( 32768D * Math . sin ( i * d ) ) ; Calculations . COS_TABLE [ i ] = ( int ) ( 32768D * Math . cos ( i * d ) ) ; } } public static int calculateTileHeight ( final int x , final int y , int plane ) { final Client client = Context . client ( ) ; final int x1 = x > > 9 ; final int y1 = y > > 9 ; try { final byte [ ] [ ] [ ] settings = ( byte [ ] [ ] [ ] ) ( ( RSGroundByts ) ( ( RSInfo ) client . getRSGroundInfo ( ) ) . getGroundBytes ( ) ) . getBytes ( ) ; if ( settings != null && x1 >= 0 && x1", "gt": "< 104 && y1 >= 0 && y1 < 104 )", "prediction": "<= 0 )\n", "label": 1}
{"id": 9679, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; public class BooleanConst extends Doclet { public static void main ( String [ ] args ) { if ( com . sun . tools . javadoc . Main . execute ( \"javadoc\" , \"BooleanConst\" , BooleanConst . class . getClassLoader ( ) , new String [ ] { System . getProperty ( \"test.src\" , \".\" ) + java . io . File . separatorChar + \"BooleanConst.java\" } ) != 0 ) throw new Error ( ) ; } public static final boolean b1 = false ; public static final boolean b2 = true ; public static boolean start ( com . sun . javadoc . RootDoc root ) { ClassDoc [ ] classes = root . classes ( ) ; if ( classes . length != 1 ) throw new Error ( \"1 \" + Arrays . asList ( classes ) ) ; ClassDoc self = classes [ 0 ] ; FieldDoc [ ] fields = self . fields ( ) ; if ( fields . length != 2 ) throw new Error ( \"2 \" + Arrays . asList ( fields ) ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { FieldDoc f = fields [ i ] ; if ( f . name ( ) . equals ( \"b1\" ) ) { Object value", "gt": "= f . constantValue ( ) ;", "prediction": "= f . getValue ( ) ;\n", "label": 0}
{"id": 16112, "input": "<s> package org . eclipse . ui ; public class MultiPartInitException extends WorkbenchException { private IWorkbenchPartReference [ ] references ; private PartInitException [ ] exceptions ; public MultiPartInitException ( IWorkbenchPartReference [ ] references , PartInitException [ ] exceptions ) { super ( exceptions [ findSingleException ( exceptions ) ] . getStatus ( ) ) ; this . references = references ; this . exceptions = exceptions ; } public IWorkbenchPartReference [ ] getReferences ( ) { return references ; } public PartInitException [ ] getExceptions ( ) { return exceptions ; } private static int findSingleException ( PartInitException [ ] exceptions ) { int index = - 1 ; for ( int i = 0 ; i < exceptions . length ; i ++ ) { if ( exceptions [ i ] != null ) { if ( index == - 1 ) { index = i ; } else throw new IllegalArgumentException ( ) ; } } if ( index == - 1 ) { throw new IllegalArgumentException ( ) ; } return index ; } private static final long", "gt": "serialVersionUID = - 9138185942975165490L ;", "prediction": "serialVersionUID = 1L ;\n", "label": 1}
{"id": 9432, "input": "<s> package org . parboiled . trees ; import org . parboiled . common . ImmutableLinkedList ; import org . parboiled . common . ImmutableList ; import java . util . List ; public class ImmutableGraphNode < T extends GraphNode < T > > implements GraphNode < T > { private final List < T > children ; public ImmutableGraphNode ( ) { this ( null ) ; } public", "gt": "ImmutableGraphNode ( List < T > children )", "prediction": "ImmutableGraphNode ( List < T > children )\n", "label": 0}
{"id": 16132, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . dom . client . Element ; import com . google . gwt . dom . client . Style . Visibility ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . uibinder . client . UiBinder ; import com . google . gwt . uibinder . client . UiField ; import com . google . gwt . uibinder . client . UiHandler ; import com . google . gwt . uibinder . client . UiTemplate ; import com . google . gwt . user . client . ui . Anchor ; import com . google . gwt . user . client . ui . Composite ; import com . google . gwt . user . client . ui . Widget ; class NavBar extends Composite { @ UiTemplate ( \"NavBar.ui.xml\" ) interface Binder extends UiBinder < Widget , NavBar > { } private static final Binder binder = GWT . create ( Binder . class ) ; @ UiField Element countLabel ; @ UiField Anchor newerButton ; @ UiField Anchor olderButton ; private final MailList outer ; public NavBar ( MailList outer ) { initWidget ( binder . createAndBindUi ( this ) ) ; this . outer = outer ; } public void update ( int startIndex , int count , int max ) { setVisibility ( newerButton , startIndex != 0 ) ; setVisibility ( olderButton , startIndex + MailList . VISIBLE_EMAIL_COUNT < count ) ; countLabel . setInnerText ( \"\" + ( startIndex + 1 ) + \" - \" + max + \" of \" + count ) ; } @ UiHandler ( \"newerButton\" ) void onNewerClicked ( ClickEvent event ) { outer . newer ( ) ; } @ UiHandler ( \"olderButton\" ) void onOlderClicked ( ClickEvent event ) { outer . older ( ) ; } private void setVisibility ( Widget widget , boolean visible ) { widget . getElement ( ) . getStyle ( ) . setVisibility ( visible ? Visibility", "gt": ". VISIBLE : Visibility . HIDDEN ) ;", "prediction": ". VISIBLE : Visibility . VISIBLE ) ;\n", "label": 1}
{"id": 7759, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface ResourceRoot extends ReportAttribute { Resource getResource ( ) ;", "gt": "void setResource ( Resource value ) ;", "prediction": "}\n", "label": 0}
{"id": 16139, "input": "<s> import com . sun . tools . doclets . Taglet ; import com . sun . javadoc . * ; import java . util . Map ; import java . io . * ; public class ExampleTaglet implements Taglet { private static final String NAME = \"example\" ; private static final String HEADER = \"example To Do:\" ; public String getName ( ) { return NAME ; } public boolean inField ( ) { return true ; } public boolean inConstructor ( ) { return true ; } public boolean inMethod ( ) { return true ; } public boolean inOverview ( ) { return true ; } public boolean inPackage ( ) { return true ; } public boolean inType ( ) { return true ; } public boolean isInlineTag ( ) { return false ; } public static void register ( Map tagletMap ) { ExampleTaglet tag = new ExampleTaglet ( ) ; Taglet t = ( Taglet ) tagletMap . get ( tag . getName ( ) ) ; if ( t != null ) { tagletMap . remove ( tag . getName ( ) ) ; } tagletMap . put ( tag . getName ( ) , tag ) ; } public String toString ( Tag tag ) { return createHTML ( readFile ( tag . text ( ) ) ) ; } public String toString ( Tag [ ] tags ) { if ( tags . length == 0 ) { return null ; } return createHTML ( readFile ( tags [ 0 ] . text ( ) ) ) ; } String createHTML ( String theString ) { if ( theString != null ) { String dd = \"<script type=\\\"text/javascript\\\">\\n\" + \"<!--\\n\" + \"document.getElementsByTagName('html')[0].className = 'isjs';\" + \"function toggle(dt) { var display, dd=dt; do{ dd = dd.nextSibling } while(dd.tagName!='DD'); toOpen =!dd.style.display;\" + \"dd.style.display = toOpen? 'block':''; dt.getElementsByTagName('span')[0].innerHTML  = toOpen? '-':'+' ; }\\n\" + \"-->\\n</script>\" ; return dd + \"\\n<div id=\\\"test\\\" class=\\\"toggleList\\\">\" + \"<dl><dt onclick=\\\"toggle(this);\\\"><span>+</span>Example</dt>\" + \"<dd><pre>\" + theString + \"</pre>\" + \"</dd></dl></div>\" ; } return \"\" ; } String readFile ( String theExample ) { String record = \"\" ; String myResult = \"\" ; int recCount = 0 ; String myDir = \"../examples\" ; File file = new File ( myDir ) ; if ( file . exists ( ) == false ) { myDir = \"./examples\" ; } try { FileReader fr = new FileReader ( myDir + \"/\" + theExample + \"/\" + theExample + \".pde\" ) ; BufferedReader br = new BufferedReader ( fr ) ; record = new String ( ) ; while ( ( record = br . readLine ( ) ) != null ) { myResult += record + \"\\n\" ; } } catch ( IOException e ) { System", "gt": ". out . println ( e ) ;", "prediction": ". err . println ( e ) ;\n", "label": 1}
{"id": 8791, "input": "<s> package de . javawi . jstun . attribute ; import de . javawi . jstun . util . * ; public class ChangeRequest extends MessageAttribute { boolean changeIP = false ; boolean changePort = false ; public ChangeRequest ( ) { super ( MessageAttribute . MessageAttributeType . ChangeRequest ) ; } public boolean isChangeIP ( ) { return changeIP ; } public boolean isChangePort ( ) { return changePort ; } public void setChangeIP ( ) { changeIP = true ; } public void setChangePort ( ) { changePort = true ; } public byte [ ] getBytes ( ) throws UtilityException { byte [ ] result = new byte [ 8 ] ; System . arraycopy ( Utility . integerToTwoBytes ( typeToInteger ( type ) ) , 0 , result , 0 , 2 ) ; System . arraycopy ( Utility . integerToTwoBytes ( 4 ) , 0 , result , 2 , 2 ) ; if ( changeIP ) result [ 7 ] = Utility . integerToOneByte ( 4 ) ; if ( changePort ) result [ 7 ] = Utility . integerToOneByte ( 2 ) ; if ( changeIP && changePort ) result [ 7 ] = Utility . integerToOneByte ( 6 ) ; return result ; } public static ChangeRequest parse ( byte [ ] data ) throws MessageAttributeParsingException { try { if ( data . length < 4 ) { throw new MessageAttributeParsingException ( \"Data array too short\" ) ; } ChangeRequest cr = new ChangeRequest ( ) ; int status = Utility . oneByteToInteger ( data [ 3 ] ) ; switch ( status ) { case 0 : break ; case 2 : cr . setChangePort ( ) ; break ; case 4 : cr . setChangeIP ( ) ; break ; case 6 : cr . setChangeIP ( ) ; cr . setChangePort ( ) ; break ; default : throw new MessageAttributeParsingException", "gt": "( \"Status parsing error\" ) ;", "prediction": "( \"Data array too short\" ) ;\n", "label": 0}
{"id": 16141, "input": "<s> package org . eclipse . ui . tests . session ; import junit . framework . TestCase ; import org . eclipse . core . resources . IProject ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . tests . harness . util . FileUtil ; public class Bug95357Test extends TestCase { private static final String BUG95357PROJECT = \"Bug95357project\" ; private static final int FILE_MAX = 8 ; private IWorkbenchWindow fWin ; private IWorkbenchPage fActivePage ; private IProject fProject ; private IWorkbench fWorkbench ; private String [ ] itsFilename ; public Bug95357Test ( String testName ) { super ( testName ) ; fWorkbench = PlatformUI . getWorkbench ( ) ; fProject = null ; } private void setupFilenames ( String ext ) { itsFilename = new String [ Bug95357Test . FILE_MAX ] ; for ( int i = 0 ; i < Bug95357Test . FILE_MAX ; ++ i ) { itsFilename [ i ] = \"test\" + i + ext ; } } protected void setUp ( ) throws Exception { fWin = fWorkbench . getActiveWorkbenchWindow ( ) ; fActivePage = fWin . getActivePage ( ) ; fProject = FileUtil . createProject ( Bug95357Test . BUG95357PROJECT ) ; } private void multipleEditorsOpen ( ) { IEditorReference [ ] editors = fActivePage . getEditorReferences ( ) ; assertEquals ( Bug95357Test . FILE_MAX , editors . length ) ; for ( int i = 0 ; i < editors . length - 1 ; i ++ ) { assertNull ( \"Editor \" + i + \" \" + editors [ i ] . getName ( ) + \" should not be active\" , editors [ i ] . getEditor ( false ) ) ; } assertNotNull ( editors [ editors . length - 1 ] . getEditor ( false ) ) ; assertNotNull ( editors [ 0 ] . getEditor ( true ) ) ; } private void multipleStacksOnStartup ( ) { IEditorReference lastFile = null ; IEditorReference secondLastFile = null ; IEditorReference [ ] editors = fActivePage . getEditorReferences ( ) ; assertEquals ( Bug95357Test . FILE_MAX , editors . length ) ; for ( int i = 0 ; i < editors . length ; i ++ ) { if ( itsFilename [ itsFilename . length - 1 ] . equals", "gt": "( editors [ i ] . getName ( ) ) )", "prediction": "( \"test\" ) )\n", "label": 1}
{"id": 8601, "input": "<s> class Base { static class Inner { } int _field ;", "gt": "public int m1 ( )", "prediction": "}\n", "label": 0}
{"id": 16142, "input": "<s> package org . restlet . example . ext . rdf . foaf . resources ; import java . util . Map ; import java . util . TreeMap ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . example . ext . rdf . foaf . objects . Contact ; import org . restlet . example . ext . rdf . foaf . objects . User ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . Delete ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; import org . restlet . resource . ResourceException ; public class ContactResource extends BaseResource { private Contact contact ; private User user ; @ Override public void doInit ( ) { final String userId = ( String ) getRequestAttributes ( ) . get ( \"userId\" ) ; this . user = getObjectsFacade ( ) . getUserById ( userId ) ; if ( user != null ) { final String contactId = ( String ) getRequestAttributes ( ) . get ( \"contactId\" ) ; this . contact = getObjectsFacade ( ) . getContactById ( contactId ) ; } setExisting ( this . contact != null ) ; } @ Delete public void removeContact ( ) throws ResourceException { getObjectsFacade ( ) . deleteContact ( this . user , this . contact ) ; getResponse ( ) . redirectSeeOther ( getRequest ( ) . getResourceRef ( ) . getParentRef ( ) ) ; } @ Put public void storeContact ( Representation entity ) throws ResourceException { final Form form = new Form ( entity ) ; this . contact . setFirstName ( form . getFirstValue ( \"firstName\" ) ) ; this . contact . setLastName ( form . getFirstValue ( \"lastName\" ) ) ; this . contact . setImage ( form . getFirstValue ( \"image\" ) ) ; this . contact . setNickname ( form . getFirstValue ( \"nickname\" ) ) ; this . contact . setFoafUri ( form . getFirstValue ( \"foafUri\" ) ) ; getObjectsFacade ( ) . updateContact ( this . user , this . contact ) ; getResponse ( ) . redirectSeeOther ( getRequest ( ) . getResourceRef ( ) ) ; } @ Get ( \"html\" ) public Representation toHtml ( Variant variant ) throws ResourceException { final Map < String , Object > dataModel = new TreeMap < String , Object > ( ) ; dataModel . put ( \"user\" , this . user ) ; dataModel .", "gt": "put ( \"contact\" , this . contact ) ;", "prediction": "put ( \"userId\" , this . userId ) ;\n", "label": 1}
{"id": 3002, "input": "<s> package com . gisgraphy . client . nameformatters ; import static com . gisgraphy . client . commons . NameProviderObjectMother . losAngelesNameProvider ; import junit . framework . Assert ; import org . junit . Before ; import org . junit . Test ; import com . gisgraphy . client . commons . NameFormatter ; public class ConcatenatingNameFormatterTest { private NameFormatter reverseNameFormatter ; private NameFormatter forwardNameFormatter ; @ Before public void setup ( ) { reverseNameFormatter = new ConcatenatingNameFormatter ( \",\" ) ; forwardNameFormatter = new ConcatenatingNameFormatter ( \",\" , false , new FullyQualifiedNamesExtractor ( ) ) ; } @ Test public void shouldConcatenateAllNamesInReverseOrder ( ) { Assert . assertEquals ( \"Los Angeles,Los Angeles county,California,United States\" , reverseNameFormatter . format", "gt": "( losAngelesNameProvider ( ) ) . toString ( ) ) ;", "prediction": "( ) ) ;\n", "label": 0}
{"id": 16143, "input": "<s> package org . seage . metaheuristic . fireflies ; public abstract class FireflyOperator { abstract public double getDistance ( Solution s1 , Solution s2 ) ; abstract public void attract ( Solution s0 , Solution s1 , int iter ) ; public abstract Solution randomSolution ( ) ; public abstract void randomSolution ( Solution solution ) ; public abstract", "gt": "void modifySolution ( Solution solution ) ;", "prediction": "void firefly ( Solution solution ) ;\n", "label": 1}
{"id": 7661, "input": "<s> package ar . com . fdvs . dj . test ; import java . awt . Color ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class GroupsReportTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( \"detail\" ) ; Style headerStyle = new Style ( \"header\" ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorderBottom ( Border . PEN_1_POINT ) ; headerStyle . setBackgroundColor ( Color . gray ) ; headerStyle . setTextColor ( Color . white ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; headerStyle . setTransparency ( Transparency . OPAQUE ) ; Style headerVariables = new Style ( \"headerVariables\" ) ; headerVariables . setFont ( Font . ARIAL_BIG_BOLD ) ; headerVariables . setBorderBottom ( Border . THIN ) ; headerVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; headerVariables . setVerticalAlign ( VerticalAlign . TOP ) ; Style groupVariables = new Style ( \"groupVariables\" ) ; groupVariables . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; groupVariables . setTextColor ( Color . BLUE ) ; groupVariables . setBorderBottom ( Border . THIN ) ; groupVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; groupVariables . setVerticalAlign ( VerticalAlign . BOTTOM ) ; Style titleStyle = new Style ( \"titleStyle\" ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitleStyle ( titleStyle ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( true ) . setGrandTotalLegend ( \"Grand Total\" ) . setGrandTotalLegendStyle ( headerVariables ) . setOddRowBackgroundStyle ( oddRowStyle ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( titleStyle ) . setHeaderStyle ( titleStyle ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaProductLine = ColumnBuilder . getNew ( ) . setColumnProperty ( \"productLine\" , String . class . getName ( ) ) . setTitle ( \"Product Line\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"Item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnCode = ColumnBuilder . getNew ( ) . setColumnProperty ( \"id\" , Long . class . getName ( ) ) . setTitle ( \"ID\" ) . setWidth ( new Integer ( 40 ) ) . setStyle ( importeStyle", "gt": ") . setHeaderStyle ( headerStyle ) . build ( ) ;", "prediction": ") . build ( ) ;\n", "label": 0}
{"id": 16144, "input": "<s> package org . apache . lucene . search . spans ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Set ; public class SpanNotQuery extends SpanQuery implements Cloneable { private SpanQuery include ; private SpanQuery exclude ; public SpanNotQuery ( SpanQuery include , SpanQuery exclude ) { this . include = include ; this . exclude = exclude ; if ( ! include . getField ( ) . equals ( exclude . getField ( ) ) ) throw new IllegalArgumentException ( \"Clauses must have same field.\" ) ; } public SpanQuery getInclude ( ) { return include ; } public SpanQuery getExclude ( ) { return exclude ; } public String getField ( ) { return include . getField ( ) ; } public Collection getTerms ( ) { return include . getTerms ( ) ; } public void extractTerms ( Set terms ) { include . extractTerms ( terms ) ; } public String toString ( String field ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( \"spanNot(\" ) ; buffer . append ( include . toString ( field ) ) ; buffer . append ( \", \" ) ; buffer . append ( exclude . toString ( field ) ) ; buffer . append ( \")\" ) ; buffer . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return buffer . toString ( ) ; } public Object clone ( ) { SpanNotQuery spanNotQuery = new SpanNotQuery ( ( SpanQuery ) include . clone ( ) , ( SpanQuery ) exclude . clone ( ) ) ; spanNotQuery . setBoost ( getBoost ( ) ) ; return spanNotQuery ; } public Spans getSpans ( final IndexReader reader ) throws IOException { return new Spans ( ) { private Spans includeSpans = include . getSpans ( reader ) ; private boolean moreInclude = true ; private Spans excludeSpans = exclude . getSpans ( reader ) ; private boolean moreExclude = excludeSpans . next ( ) ; public boolean next ( ) throws IOException { if ( moreInclude ) moreInclude = includeSpans . next ( ) ; while ( moreInclude && moreExclude ) { if ( includeSpans . doc ( ) > excludeSpans . doc ( ) ) moreExclude = excludeSpans . skipTo ( includeSpans . doc ( ) ) ; while ( moreExclude && includeSpans . doc ( ) == excludeSpans . doc ( ) && excludeSpans", "gt": ". end ( ) <= includeSpans . start ( ) )", "prediction": ". doc ( ) != excludeSpans . doc ( ) )\n", "label": 1}
{"id": 1833, "input": "<s> package com . matburt . mobileorg . Synchronizers ; import java . io . BufferedReader ; import java . io . IOException ; import java . security . cert . CertificateException ; import javax . net . ssl . SSLHandshakeException ; public interface SynchronizerInterface { public boolean isConfigured ( ) ; public void putRemoteFile", "gt": "( String filename , String contents ) throws IOException ;", "prediction": "( File file ) ;\n", "label": 0}
{"id": 16145, "input": "<s> package org . restlet . ext . jaxrs ; import static org . restlet . ext . jaxrs . internal . util . Util . append ; import static org . restlet . ext . jaxrs . internal . util . Util . getPathTemplateWithoutRegExps ; import static org . restlet . ext . jaxrs . internal . util . Util . indexBeginMatrixOfLastSegment ; import static org . restlet . ext . jaxrs . internal . util . Util . notEndsWith ; import static org . restlet . ext . jaxrs . internal . util . Util . notStartsWith ; import java . io . IOException ; import java . lang . reflect . Method ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . ws . rs . Path ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriBuilderException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnClassException ; import org . restlet . ext . jaxrs . internal . exceptions . IllegalPathOnMethodException ; import org . restlet . ext . jaxrs . internal . exceptions . MissingAnnotationException ; import org . restlet . ext . jaxrs . internal . todo . NotYetImplementedException ; import org . restlet . ext . jaxrs . internal . util . EncodeOrCheck ; import org . restlet . routing . Template ; import org . restlet . util . Resolver ; public abstract class AbstractUriBuilder extends UriBuilder { private class ArrayVariableResolver extends Resolver < String > { private final boolean encoding ; private int i = 0 ; private final Map < String , String > retrievedValues = new HashMap < String , String > ( ) ; private final Object [ ] values ; ArrayVariableResolver ( Object [ ] values , boolean encoding ) { this . values = values ; this . encoding = encoding ; } @ Override public String resolve ( String variableName ) { String varValue = this . retrievedValues . get ( variableName ) ; if ( varValue == null ) { if ( this . i >= this . values . length ) { throw new IllegalArgumentException ( \"The value given array contains not enough elements (contains \" + this . values . length + \", but need at least \" + ( this . i + 1 ) + \")\" ) ; } final Object value = this . values [ this . i ] ; if ( value == null ) { throw new IllegalArgumentException ( \"The given array contains null value at position (\" + this . i + \")\" ) ; } varValue = value . toString ( ) ; varValue = EncodeOrCheck . all ( varValue , this . encoding ) ; this . i ++ ; this . retrievedValues . put ( variableName , varValue ) ; } return varValue ; } } private CharSequence fragment ; private String host ; private CharSequence path ; private String port = null ; private CharSequence query ; private String scheme ; private CharSequence userInfo ; protected AbstractUriBuilder ( ) { } private void addValidPathSegment ( CharSequence newPathSegment ) { final StringBuilder path = getPath ( ) ; if ( ( this . host != null ) && notEndsWith ( path , '/' ) && notStartsWith ( newPathSegment , '/' ) ) { path . append ( '/' ) ; } path . append ( newPathSegment ) ; } private void addValidPathSegments ( List < CharSequence > newPathSegments ) { for ( final CharSequence newPathSegment : newPathSegments ) { addValidPathSegment ( newPathSegment ) ; } } @ Override public URI build ( Object ... values ) throws IllegalArgumentException , UriBuilderException { final Template template = new Template ( toStringWithCheck ( false ) ) ; return buildUri ( template . format ( new ArrayVariableResolver ( values , true ) ) ) ; } @ Override public URI buildFromEncoded ( Object ... values ) throws IllegalArgumentException , UriBuilderException { final Template template = new Template ( toStringWithCheck ( false ) ) ; return buildUri ( template . format ( new ArrayVariableResolver ( values , false ) ) ) ; } @ Override public URI buildFromEncodedMap ( Map < String , ? extends Object > values ) throws IllegalArgumentException , UriBuilderException { return this . buildFromMap ( values , false ) ; } @ Override public URI buildFromMap ( Map < String , ? extends Object > values ) throws IllegalArgumentException , UriBuilderException { return this . buildFromMap ( values , true ) ; } private URI buildFromMap ( final Map < String , ? extends Object > values , final boolean encode ) throws IllegalArgumentException , UriBuilderException { final Template template = new Template ( toStringWithCheck ( false ) ) ; return buildUri ( template . format ( new Resolver < String > ( ) { @ Override public String resolve ( String variableName ) { final Object varValue = values . get ( variableName ) ; if ( varValue == null ) { throw new IllegalArgumentException ( \"The value Map must contain a value for all given Templet variables. The value for variable \" + variableName + \" is missing\" ) ; } return EncodeOrCheck . all ( varValue . toString ( ) , encode ) ; } } ) ) ; } private URI buildUri ( String refAsString ) throws UriBuilderException { try { return new URI ( refAsString ) ; } catch ( URISyntaxException e ) { throw new UriBuilderException ( \"Could not build the URI from String \" + refAsString , e ) ; } } protected void copyInto ( AbstractUriBuilder uriBuilder ) { if ( this . fragment != null ) { uriBuilder . fragment = this . fragment ; this . fragment", "gt": "= this . fragment . toString ( ) ;", "prediction": "= uriBuilder ;\n", "label": 1}
{"id": 9445, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . Interval4 ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Resource ; import org . jjflyboy . tjpeditor . project . StatusSheet ; import org . jjflyboy . tjpeditor . project . StatusSheetAttribute ; public class StatusSheetImpl extends PropertyImpl implements StatusSheet { protected Resource resource ; protected Interval4 interval ; protected EList < StatusSheetAttribute > attributes ; protected StatusSheetImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getStatusSheet ( ) ; } public Resource getResource ( ) { if ( resource != null && resource . eIsProxy ( ) ) { InternalEObject oldResource = ( InternalEObject ) resource ; resource = ( Resource ) eResolveProxy ( oldResource ) ; if ( resource != oldResource ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . STATUS_SHEET__RESOURCE , oldResource , resource ) ) ; } } return resource ; } public Resource basicGetResource ( ) { return resource ; } public void setResource ( Resource newResource ) { Resource oldResource = resource ; resource = newResource ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_SHEET__RESOURCE , oldResource , resource ) ) ; } public Interval4 getInterval ( ) { return interval ; } public NotificationChain basicSetInterval ( Interval4 newInterval , NotificationChain msgs ) { Interval4 oldInterval = interval ; interval = newInterval ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . STATUS_SHEET__INTERVAL , oldInterval , newInterval ) ; if (", "gt": "msgs == null ) msgs = notification ;", "prediction": "eNotificationRequired ( ) )\n", "label": 0}
{"id": 16153, "input": "<s> package org . fuzzydb . attrs ; import org . fuzzydb . attrs . internal . BaseAttribute ; public interface IDecorator { public abstract String getAttrName ( ) ; public abstract String", "gt": "getValueString ( BaseAttribute attr ) ;", "prediction": "getAttrValue ( ) ;\n", "label": 1}
{"id": 2162, "input": "<s> public class T6294779a { interface A { A m ( ) ; } interface B extends A { B m ( ) ; } interface C extends A { C m ( ) ; } interface D extends B , C {", "gt": "D m ( ) ;", "prediction": "D m ( ) ;\n", "label": 0}
{"id": 16155, "input": "<s> package org . apache . lucene . store ; import java . io . IOException ; import org . apache . lucene . util . LuceneTestCase ; public class TestLock extends LuceneTestCase { public void testObtain ( ) { LockMock lock = new LockMock ( ) ; Lock . LOCK_POLL_INTERVAL = 10 ; try { lock . obtain ( Lock . LOCK_POLL_INTERVAL ) ; fail ( \"Should have failed to obtain lock\" ) ; } catch ( IOException e ) { assertEquals ( \"should attempt to lock more than once\" , lock . lockAttempts , 2 ) ; } } private class LockMock extends Lock { public int lockAttempts ; public boolean obtain ( ) { lockAttempts ++ ; return false ; } public void release ( ) { }", "gt": "public boolean isLocked ( )", "prediction": "}\n", "label": 1}
{"id": 6601, "input": "<s> package de . javawi . jstun . header ; public interface MessageHeaderInterface { public enum MessageHeaderType { BindingRequest , BindingResponse , BindingErrorResponse , SharedSecretRequest , SharedSecretResponse , SharedSecretErrorResponse } ; final static int BINDINGREQUEST = 0x0001 ; final static int BINDINGRESPONSE = 0x0101 ; final static int BINDINGERRORRESPONSE = 0x0111 ; final static int SHAREDSECRETREQUEST = 0x0002 ; final static int SHAREDSECRETRESPONSE = 0x0102 ;", "gt": "final static int SHAREDSECRETERRORRESPONSE = 0x0112 ;", "prediction": "}\n", "label": 0}
{"id": 16157, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Sash ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . internal . dnd . SwtUtil ; import org . eclipse . ui . internal . misc . StatusUtil ; import org . eclipse . ui . part . MultiEditor ; import org . eclipse . ui . presentations . IPresentablePart ; import org . eclipse . ui . statushandlers . StatusManager ; public abstract class PartPane extends LayoutPart implements IPropertyListener , Listener , IPropertyChangeListener { public static final String PROP_ZOOMED = \"zoomed\" ; private boolean isZoomed = false ; private MenuManager paneMenuManager ; private ListenerList listeners = new ListenerList ( ) ; private ListenerList partListeners = new ListenerList ( ) ; protected IWorkbenchPartReference partReference ; protected WorkbenchPage page ; protected Composite control ; private boolean inLayout = true ; private boolean busy ; public static class Sashes { public Sash left ; public Sash right ; public Sash top ; public Sash bottom ; } public PartPane ( IWorkbenchPartReference partReference , WorkbenchPage workbenchPage ) { super ( partReference . getId ( ) ) ; this . partReference = partReference ; this . page = workbenchPage ; } public void addSizeMenuItem ( Menu menu , int index ) { MenuItem item = new MenuItem ( menu , SWT . CASCADE , index ) ; item . setText ( WorkbenchMessages . get ( ) . PartPane_size ) ; Menu sizeMenu = new Menu ( menu ) ; item . setMenu ( sizeMenu ) ; addSizeItems ( sizeMenu ) ; } public void createControl ( Composite parent ) { if ( getControl ( ) != null ) { return ; } partReference . addPropertyListener ( this ) ; partReference . addPartPropertyListener ( this ) ; control = new Composite ( parent , SWT . NONE ) ; control . setLayout ( new FillLayout ( ) ) ; control . setVisible ( false ) ; control . moveAbove ( null ) ; createTitleBar ( ) ; control . addListener ( SWT . Activate , this ) ; } protected abstract void createTitleBar ( ) ; public void dispose ( ) { super . dispose ( ) ; if ( ( control != null ) && (", "gt": "! control . isDisposed ( ) ) )", "prediction": "partReference != null ) )\n", "label": 1}
{"id": 5355, "input": "<s> package org . ofbiz . pos . device . impl ; import jpos . JposConst ; import jpos . JposException ; import org . ofbiz . pos . device . GenericDevice ; public class CheckScanner extends GenericDevice { public static final String module = CheckScanner . class . getName ( ) ; public CheckScanner", "gt": "( String deviceName , int timeout )", "prediction": "( )\n", "label": 0}
{"id": 16160, "input": "<s> package org . mitre . oauth2 . service . impl ; import org . mitre . oauth2 . model . AuthorizationCodeEntity ; import org . mitre . oauth2 . repository . AuthorizationCodeRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . oauth2 . common . exceptions . InvalidGrantException ; import org . springframework . security . oauth2 . common . util . RandomValueStringGenerator ; import org . springframework . security . oauth2 . provider . code . AuthorizationCodeServices ; import org . springframework . security . oauth2 . provider . code . AuthorizationRequestHolder ; import org . springframework . stereotype . Service ; @ Service public class DefaultOAuth2AuthorizationCodeService implements AuthorizationCodeServices { @ Autowired private AuthorizationCodeRepository repository ; private RandomValueStringGenerator generator = new RandomValueStringGenerator ( ) ; @ Override public String createAuthorizationCode ( AuthorizationRequestHolder authentication ) { String code = generator . generate ( ) ; AuthorizationCodeEntity entity = new AuthorizationCodeEntity", "gt": "( code , authentication ) ;", "prediction": "( code ) ;\n", "label": 1}
{"id": 3676, "input": "<s> package ar . com . fdvs . dj . domain ; import java . util . Map ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . util . customexpression . PageNumberCustomExpression ; import ar . com . fdvs . dj . util . customexpression . RecordsInPageCustomExpression ; import ar . com . fdvs . dj . util . customexpression . RecordsInReportCustomExpression ; public class ExpressionHelper { private static final BooleanExpression printInFirstPage = new PrintInFirstPage ( ) ; private static final BooleanExpression printNotInFirstPage = new PrintNotInFirstPage ( ) ; private static final CustomExpression pageNumber = new PageNumberCustomExpression ( ) ; private static final CustomExpression recordsInPage = new RecordsInPageCustomExpression ( ) ; private static final CustomExpression recordsInReport = new RecordsInReportCustomExpression ( ) ; public static BooleanExpression printInFirstPage ( ) { return printInFirstPage ; } public static BooleanExpression printNotInFirstPage ( ) { return printNotInFirstPage ; } public static CustomExpression getPageNumber ( ) { return pageNumber ; } public static CustomExpression getRecordsInPage ( ) { return recordsInPage ; } public static CustomExpression getRecordsInReport ( ) { return recordsInReport ; } public static BooleanExpression printWhenGroupHasMoreThanOneRecord ( final String groupName ) { return new BooleanExpression ( ) { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public Object evaluate ( Map fields , Map variables , Map parameters ) { return new Boolean ( getGroupCount ( groupName , variables ) > 1 ) ; } } ; } public static int getPageNumber ( Map variables ) { return ( ( Integer ) variables . get ( \"PAGE_NUMBER\" ) ) . intValue ( ) ; } public static int getGroupCount ( String groupName , Map variables ) { return ( ( Integer ) variables . get ( groupName + \"_COUNT\" ) ) . intValue ( ) ; } private static class PrintInFirstPage extends BooleanExpression { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public Object evaluate ( Map fields , Map variables , Map parameters ) { return new Boolean ( getPageNumber ( variables ) == 1 ) ; } } private static class PrintNotInFirstPage extends BooleanExpression { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; public Object evaluate ( Map", "gt": "fields , Map variables , Map parameters )", "prediction": "fields , Map variables , Map parameters )\n", "label": 0}
{"id": 16162, "input": "<s> package com . emf4sw . owl . transform . owl2ecore ; import static com . atl . common . models . Models . register ; import static com . atl . common . trans . Transformations . transform ; import static com . atl . common . utils . Preconditions . checkNotNull ; import java . util . Map ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . m2m . atl . core . emf . EMFModel ; import com . atl . common . models . Models ; import com . atl . common . trans . Transformation ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . transform . OWLTransformations ; public class OWL2Ecore implements Transformation < Resource , Resource > { static { register ( OWLPackage . eINSTANCE . eResource ( ) ) ; } public OWL2Ecore ( ) { } public OWL2Ecore ( Map < String , Object > options ) { } static { register ( OWLPackage . eINSTANCE . eResource ( ) ) ; } public Resource apply ( Resource arg ) { checkNotNull ( arg , \"Cannot execute", "gt": "transformation \" + this + \", cause input null.\" ) ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 1352, "input": "<s> package com . mobeelizer . mobile . android . types ; import static junit . framework . Assert . assertTrue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . powermock . api . mockito . PowerMockito ; import org . powermock . core . classloader . annotations . PrepareForTest ; import org . powermock . modules . junit4 . PowerMockRunner ; import android . content . ContentValues ; import android . database . Cursor ; import android . database . DatabaseUtils ; import com . mobeelizer . java . api . MobeelizerErrorsBuilder ; import com . mobeelizer . java . model . MobeelizerFieldAccessor ; import com . mobeelizer . java . model . MobeelizerReflectionUtil ; import com . mobeelizer . java . model . ReflectionMobeelizerFieldAccessor ; import com . mobeelizer . mobile . android . Mobeelizer ; import com . mobeelizer . mobile . android . MobeelizerDatabaseImpl ; import com . mobeelizer . mobile . android . TestEntity ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; @ RunWith ( PowerMockRunner . class ) @ PrepareForTest ( { BelongsToFieldTypeHelper . class , ContentValues . class , DatabaseUtils . class , Mobeelizer . class } ) public class BelongsToFieldTypeHelperTest { private MobeelizerFieldAccessor fieldString ; private MobeelizerDatabaseImpl database ; @ Before public void init ( ) { PowerMockito . mockStatic ( Mobeelizer . class ) ; database = mock ( MobeelizerDatabaseImpl . class ) ; PowerMockito . when ( Mobeelizer . getDatabase ( ) ) . thenReturn ( database ) ; fieldString = new ReflectionMobeelizerFieldAccessor ( MobeelizerReflectionUtil . getField ( TestEntity . class , \"string\" , new HashSet < Class < ? > > ( Arrays . asList ( new Class < ? > [ ] { String . class } ) ) ) ) ; } @ Test public void shouldInsertIntoEnum ( ) throws Exception { Field helperField = FieldType . BELONGS_TO . getClass ( ) . getDeclaredField ( \"helper\" ) ; helperField . setAccessible ( true ) ; Object helper = helperField . get ( FieldType . BELONGS_TO ) ; assertTrue ( helper instanceof BelongsToFieldTypeHelper ) ; } @ Test public void shouldGetAccessibleTypes ( ) throws Exception { Set < Class < ? > > types = FieldType . BELONGS_TO . getType ( ) . getAccessibleTypes ( ) ; assertEquals ( 1 , types . size ( ) ) ; assertTrue ( types . contains ( String . class ) ) ; } @ Test @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public void shouldSetValueFromEntityToDatabase ( ) throws Exception { Map < String , String > options = new HashMap < String , String > ( ) ; options . put ( \"model\" , \"modelName\" ) ; ContentValues values = mock ( ContentValues . class ) ; MobeelizerErrorsBuilder errors = mock ( MobeelizerErrorsBuilder . class ) ; when ( errors . hasNoErrors ( ) ) . thenReturn ( true ) ; String uuid = UUID . randomUUID ( ) . toString ( ) ; MobeelizerAndroidModel modelDefinition = mock ( MobeelizerAndroidModel . class ) ; Class clazz = TmpClass . class ; when ( modelDefinition . getMappingClass ( ) ) . thenReturn ( clazz ) ; when ( database . getModel ( \"modelName\" ) ) . thenReturn ( modelDefinition ) ; when ( database . exists ( clazz , uuid ) ) . thenReturn ( true ) ; TestEntity entity = new TestEntity ( ) ; entity . setString ( uuid ) ; FieldType . BELONGS_TO . setValueFromEntityToDatabase ( values , entity , fieldString , true , options , errors ) ; verify ( values ) . put ( \"string\" , uuid ) ; } private static class TmpClass { } ; @ Test @ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public void shouldSetErrorWhileSetNotExistingReferenceValueFromEntityToDatabase ( ) throws Exception { Map < String , String > options = new HashMap < String , String > ( ) ; options . put ( \"model\" , \"modelName\" ) ; ContentValues values = mock ( ContentValues . class ) ; MobeelizerErrorsBuilder errors = mock ( MobeelizerErrorsBuilder . class ) ; when ( errors . hasNoErrors ( ) ) . thenReturn ( true ) ; String uuid = UUID . randomUUID ( ) . toString ( ) ; MobeelizerAndroidModel modelDefinition = mock ( MobeelizerAndroidModel . class ) ; Class clazz = TmpClass . class ; when ( modelDefinition . getMappingClass ( ) ) . thenReturn ( clazz ) ; when ( database . getModel ( \"modelName\" ) ) . thenReturn ( modelDefinition ) ; when ( database . exists ( clazz , uuid ) ) . thenReturn ( false ) ; TestEntity entity = new TestEntity ( ) ; entity . setString ( uuid ) ; FieldType . BELONGS_TO . setValueFromEntityToDatabase ( values , entity , fieldString , true , options , errors ) ; verify ( values , never ( ) ) . put ( \"string\" , uuid ) ; verify ( errors ) . addFieldMissingReferenceError ( \"string\" , uuid ) ; } @ Test public void shouldSetErrorWhileSetNullValueFromEntityToDatabase ( ) throws Exception { Map < String , String > options = new HashMap < String , String > ( ) ; ContentValues values = mock ( ContentValues . class ) ; MobeelizerErrorsBuilder errors = mock ( MobeelizerErrorsBuilder . class ) ; TestEntity entity = new TestEntity ( ) ; FieldType . BELONGS_TO . setValueFromEntityToDatabase ( values , entity , fieldString , true , options , errors ) ; verify ( values , never ( ) ) . put ( eq ( \"string\" ) , anyInt ( ) ) ; verify ( errors ) . addFieldCanNotBeEmpty ( \"string\" ) ; } @ Test public void shouldSetValueFromDatabaseToEntity ( ) throws Exception { Map < String , String > options = new HashMap < String , String > ( ) ; TestEntity entity = new TestEntity ( ) ; String uuid =", "gt": "UUID . randomUUID ( ) . toString ( ) ;", "prediction": "UUID . randomUUID ( ) . toString ( ) ;\n", "label": 0}
{"id": 16163, "input": "<s> package models ; import play . db . jpa . Model ; import javax . persistence . Entity ; @ Entity public class Article extends Model { public String name ; public Article ( String name ) {", "gt": "this . name = name ;", "prediction": "this . name = name ;\n", "label": 1}
{"id": 4891, "input": "<s> public class AssignmentDifferentTypes9 { public static void main ( String [ ] args ) { Ref < Der > derexact = null ; Ref < Base > baseexact = null ; Ref < ? extends Der > derext = null ; Ref < ? extends Base > baseext = null ; Ref < ?", "gt": "super Der > dersuper = null ;", "prediction": "extends Base > baseext = null ;\n", "label": 0}
{"id": 16165, "input": "<s> package org . apache . sqoop . hbase ; import java . io . Closeable ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import org . apache . hadoop . conf . Configurable ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hbase . client . HTable ; import org . apache . hadoop . hbase . client . Put ; import org . apache . hadoop . util . ReflectionUtils ; import com . cloudera . sqoop . lib . FieldMappable ; import com . cloudera . sqoop . lib . FieldMapProcessor ; import com . cloudera . sqoop . lib . ProcessingException ; public class HBasePutProcessor implements Closeable , Configurable , FieldMapProcessor { public static final String TABLE_NAME_KEY = \"sqoop.hbase.insert.table\" ; public static final String COL_FAMILY_KEY = \"sqoop.hbase.insert.column.family\" ; public static final String ROW_KEY_COLUMN_KEY = \"sqoop.hbase.insert.row.key.column\" ; public static final String TRANSFORMER_CLASS_KEY = \"sqoop.hbase.insert.put.transformer.class\" ; private Configuration conf ; private PutTransformer putTransformer ; private String tableName ; private HTable table ; public HBasePutProcessor ( ) { } @ Override @ SuppressWarnings ( \"unchecked\" ) public void setConf ( Configuration config ) { this . conf = config ; Class < ? extends PutTransformer > xformerClass = ( Class < ? extends PutTransformer > ) this . conf . getClass ( TRANSFORMER_CLASS_KEY , ToStringPutTransformer . class ) ; this . putTransformer = ( PutTransformer ) ReflectionUtils . newInstance ( xformerClass , this . conf ) ; if ( null == putTransformer ) { throw new RuntimeException ( \"Could not instantiate PutTransformer.\" ) ; } this . putTransformer . setColumnFamily ( conf . get ( COL_FAMILY_KEY , null ) ) ; this . putTransformer . setRowKeyColumn ( conf . get ( ROW_KEY_COLUMN_KEY , null ) ) ; this . tableName = conf . get ( TABLE_NAME_KEY , null ) ; try { this . table = new HTable ( conf , this . tableName ) ; } catch ( IOException ioe ) { throw new RuntimeException ( \"Could not access HBase table \" + tableName , ioe ) ; } this . table . setAutoFlush ( false ) ; } @ Override public Configuration getConf ( ) { return this . conf ; } @ Override public void accept ( FieldMappable record ) throws IOException , ProcessingException { Map < String", "gt": ", Object > fields = record . getFieldMap ( ) ;", "prediction": ", String > fields = new HashMap < String , String > ( ) ;\n", "label": 1}
{"id": 8830, "input": "<s> class ResourceInterface { public void test1 ( ) { try ( Resource1 r1 = null ) { } } public void test2 ( ) { try ( Resource2 r2 = null ) { } } static class E1 extends Exception { } static class E2 extends Exception { } interface C1 extends AutoCloseable { void close ( ) throws E1 ; } interface C2 extends AutoCloseable {", "gt": "void close ( ) throws E2 ;", "prediction": "void close ( ) throws E2 ;\n", "label": 0}
{"id": 16167, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . util . Date ; import java . util . Properties ; import org . apache . lucene . document . DateTools ; public class DocData { private String name ; private String body ; private String title ; private String date ; private Properties props ; public void clear ( ) { name = null ; body = null ; title = null ; date = null ; props = null ; } public String getBody ( ) { return body ; } public String getDate ( ) { return date ; } public String getName ( ) { return name ; } public Properties getProps ( ) { return props ; } public String getTitle ( ) { return title ; } public void setBody ( String body ) { this . body = body ; } public void setDate ( Date date ) { if ( date != null ) { setDate ( DateTools . dateToString ( date , DateTools . Resolution . SECOND ) ) ; } else { this . date = null ; } } public void setDate ( String date ) {", "gt": "this . date = date ;", "prediction": "if ( date != null )\n", "label": 1}
{"id": 2599, "input": "<s> package com . pagosoft . plaf ; import com . pagosoft . swing . ColorUtils ; import javax . swing . * ; import javax . swing . plaf . ColorUIResource ; import javax . swing . plaf . InsetsUIResource ; import javax . swing . plaf . metal . MetalLookAndFeel ; import javax . swing . plaf . metal . MetalTheme ; import java . awt . Color ; import java . awt . Frame ; import java . awt . Insets ; import java . io . * ; import java . util . * ; import java . util . logging . * ; public class PgsLookAndFeel extends MetalLookAndFeel { private static MetalTheme currentTheme ; private static Logger logger = Logger . getLogger ( \"PgsLookAndFeel\" ) ; static { loadUserSettings ( ) ; } protected static void loadUserSettings ( ) { InputStream in = PgsLookAndFeel . class . getResourceAsStream ( \"/pgs.properties\" ) ; if ( in != null ) { try { logger . finest ( \"Found a pgs.properties! Going to setup from pgs.properties!\" ) ; Properties props = new Properties ( ) ; props . load ( in ) ; PlafOptions . useShadowBorder ( getPropertyBoolValue ( props , \"pgs.shadowBorder\" , \"false\" ) ) ; PlafOptions . useBoldFonts ( getPropertyBoolValue ( props , \"swing.boldMetal\" , \"false\" ) ) ; PlafOptions . useBoldMenuFonts ( getPropertyBoolValue ( props , \"pgs.boldMenuFonts\" , \"false\" ) ) ; PlafOptions . useExtraMargin ( getPropertyBoolValue ( props , \"pgs.extraMargin\" , \"true\" ) ) ; PlafOptions . useDisabledIcon ( getPropertyBoolValue ( props , \"pgs.useDisabledIcon\" , \"true\" ) ) ; PlafOptions . useToolBarIcon ( getPropertyBoolValue ( props , \"pgs.useToolBarIcon\" , \"true\" ) ) ; PlafOptions . setAntialiasingEnabled ( getPropertyBoolValue ( props , \"pgs.aaEnabled\" , \"false\" ) ) ; PlafOptions . setClearBorderEnabled ( getPropertyBoolValue ( props , \"pgs.clearBorderEnabled\" , \"false\" ) ) ; PlafOptions . setFixHtmlDisplayEnabled ( getPropertyBoolValue ( props , \"pgs.fixHtmlDisplayEnabled\" , \"true\" ) ) ; PlafOptions . setWheelTabbedPaneEnabled ( getPropertyBoolValue ( props , \"pgs.wheelTabEnabled\" , \"true\" ) ) ; PlafOptions . setTabbedPaneRightClickSelectionEnabled ( getPropertyBoolValue ( props , \"pgs.tabbedPaneRightClickSelectionEnabled\" , \"false\" ) ) ; PlafOptions . setTabReorderingEnabled ( getPropertyBoolValue ( props , \"pgs.tabReorderingEnabled\" , \"false\" ) ) ; PlafOptions . setPaintRolloverButtonBorder ( getPropertyBoolValue ( props , \"pgs.paintRolloverButtonBorder\" , \"true\" ) ) ; PlafOptions . setOfficeScrollBarEnabled ( getPropertyBoolValue ( props , \"pgs.officeScrollBarEnabled\" , \"false\" ) ) ; PlafOptions . setVistaStyle ( getPropertyBoolValue ( props , \"pgs.vistaStyle\" , \"false\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENUBAR , getPropertyStyleValue ( props , \"pgs.style.menuBar\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENU_ITEM , getPropertyStyleValue ( props , \"pgs.style.menuitem\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . MENUBARMENU , getPropertyStyleValue ( props , \"pgs.style.menuBarMenu\" , \"flat\" ) ) ; PlafOptions . setStyle ( PlafOptions . TOOLBAR , getPropertyStyleValue ( props , \"pgs.style.toolBar\" , \"gradient\" ) ) ; PlafOptions . setStyle ( PlafOptions . TOOLBARBUTTON , getPropertyStyleValue ( props , \"pgs.style.toolBarButton\" , \"gradient\" ) ) ; PlafOptions . setStyle ( PlafOptions . BUTTON , getPropertyStyleValue ( props , \"pgs.style.button\" , \"gradient\" ) ) ; PgsTheme theme = null ; String themeProperty = props . getProperty ( \"theme\" ) ; if ( themeProperty != null ) { theme = ThemeFactory . getTheme ( themeProperty ) ; } else { theme = ThemeFactory . createTheme ( props ) ; } if ( theme != null ) { setCurrentTheme ( theme ) ; } else { logger . warning ( \"Could not create theme from pgs.properties\" ) ; } logger . finest ( \"pgs.properties have been loaded.\" ) ; } catch ( IOException ex ) { logger . warning ( \"Unexpected exception happened while loading properties: \" + ex . toString ( ) ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { logger . warning ( \"Unexpected exception happened while closing the stream: \" + e . toString ( ) ) ; } } } } private static boolean getPropertyBoolValue ( Properties props , String key , String def ) { return \"true\" . equals ( props . getProperty ( key , def ) . trim ( ) . toLowerCase ( ) ) ; } private static int getPropertyStyleValue ( Properties props , String key , String def ) { return \"flat\" . equals ( props . getProperty ( key , def ) . trim ( ) . toLowerCase ( ) ) ? PlafOptions . FLAT_STYLE : PlafOptions . GRADIENT_STYLE ; } public PgsLookAndFeel ( ) { super ( ) ; UIManager . put ( \"swing.boldMetal\" , PlafOptions . useBoldFonts ( ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void initialize ( ) { super . initialize ( ) ; MetalLookAndFeel . setCurrentTheme ( getCurrentTheme ( ) ) ; } public void uninitialize ( ) { super . uninitialize ( ) ; } public static void setAsLookAndFeel ( ) { try { UIManager . setLookAndFeel ( \"com.pagosoft.plaf.PgsLookAndFeel\" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void updateAllUIs ( ) { Frame [ ] frames = Frame . getFrames ( ) ; for ( int i = 0 ; i < frames . length ; i ++ ) { if ( frames [ i ] instanceof JFrame ) { SwingUtilities . updateComponentTreeUI ( frames [ i ] ) ; } } } public static void setCurrentTheme ( MetalTheme theme ) { if ( theme == null ) { throw new IllegalArgumentException ( \"theme must not be null!\" ) ; } currentTheme = theme ; MetalLookAndFeel . setCurrentTheme ( theme ) ; } public static MetalTheme getCurrentTheme ( ) { if ( currentTheme == null ) { String theme = null ; try { theme = System . getProperty ( \"pgs.theme\" ) ; } catch ( Exception e ) { logger . warning ( \"Could", "gt": "not read system property 'pgs.theme'\" ) ;", "prediction": "not create theme from pgs.properties\" ) ;\n", "label": 0}
{"id": 16179, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . jface . preference . IPreferencePageContainer ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; public class DynamicPreferencePage implements IWorkbenchPreferencePage { public DynamicPreferencePage ( ) { super ( ) ; } public void init ( IWorkbench workbench ) { } public Point computeSize ( ) { return null ; } public boolean isValid ( ) { return false ; } public boolean okToLeave ( ) { return false ; } public boolean performCancel ( ) { return false ; } public boolean performOk ( ) { return false ; } public void setContainer ( IPreferencePageContainer preferencePageContainer ) { } public void setSize ( Point size ) { } public void createControl ( Composite parent ) { } public void dispose ( ) { } public Control getControl ( ) { return null ; } public String getDescription ( ) { return null ; } public String getErrorMessage ( ) { return null ; }", "gt": "public Image getImage ( )", "prediction": "}\n", "label": 1}
{"id": 6290, "input": "<s> package com . sun . tools . javadoc ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . code . Kinds ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . comp . Enter ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . * ; import javax . tools . JavaFileObject ; public class JavadocEnter extends Enter { public static JavadocEnter instance0 ( Context context ) { Enter instance = context . get ( enterKey ) ; if ( instance == null ) instance = new JavadocEnter ( context ) ; return ( JavadocEnter ) instance ; } public static void preRegister ( Context context ) { context . put ( enterKey , new Context . Factory < Enter > ( ) { public Enter make ( Context c ) { return new JavadocEnter ( c ) ; } } ) ; } protected JavadocEnter ( Context context ) { super ( context ) ; messager = Messager . instance0 ( context ) ; docenv = DocEnv . instance ( context ) ; } final Messager messager ; final DocEnv docenv ; public void main ( List < JCCompilationUnit > trees ) { int nerrors = messager . nerrors ; super . main ( trees ) ; messager . nwarnings += ( messager . nerrors - nerrors ) ; messager . nerrors = nerrors ; } public void visitTopLevel ( JCCompilationUnit tree ) { super . visitTopLevel ( tree ) ; if ( tree . sourcefile . isNameCompatible ( \"package-info\" , JavaFileObject . Kind . SOURCE ) ) { String comment = tree", "gt": ". docComments . get ( tree ) ;", "prediction": ". sourcefile . getComment ( ) ;\n", "label": 0}
{"id": 16182, "input": "<s> package com . xtremelabs . androidtohackui . bubbles . fragments ; import com . xtremelabs . androidtohackui . bubbles . models . BubbleTitleBarElements ; public interface IBubbleFragment {", "gt": "BubbleTitleBarElements getBubbleActionBarElements ( ) ;", "prediction": "}\n", "label": 1}
{"id": 1960, "input": "<s> package ar . com . fdvs . dj . test ; import java . util . Iterator ; import java . util . List ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . query . JRHibernateQueryExecuterFactory ; import net . sf . jasperreports . view . JasperViewer ; import org . hibernate . Session ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . StyleBuilder ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . test . domain . db . Customer ; import ar . com . fdvs . dj . test . hibernate . HibernateUtil ; import ar . com . fdvs . dj . test . hibernate . TestSchema ; public class HQLReportTest extends BaseDjReportTest { private Session hsession ; public DynamicReport buildReport ( ) throws Exception { Style groupStyle = new StyleBuilder ( false ) . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) . build ( ) ; FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"City\" , \"city\" , String . class . getName ( ) , 50 , groupStyle ) . addColumn ( \"Last Name\" , \"lastName\" , String . class . getName ( ) , 50 ) . addColumn ( \"First Name\" , \"firstName\" , String . class . getName ( ) , 30 ) . addColumn ( \"Id\" , \"id\" , Long . class . getName ( ) , 30 ) . addColumn ( \"Street\" , \"street\" , String . class . getName ( ) , 50 ) . addGroups ( 1 , GroupLayout . VALUE_IN_HEADER ) . setTitle ( \"Customers\" ) . setSubtitle ( \"Order by city and last name\" ) . setQuery ( \"from Customer order by city, lastName\" , DJConstants . QUERY_LANGUAGE_HQL ) . setTemplateFile ( \"templates/TemplateReportTest.jrxml\" ) . setUseFullPageWidth ( true ) ; DynamicReport dr = drb . build ( ) ; this . hsession = HibernateUtil . getSession ( ) ; params . put ( JRHibernateQueryExecuterFactory . PARAMETER_HIBERNATE_SESSION , hsession ) ; return dr ; } protected JRDataSource getDataSource ( ) { return null ; } public static void main ( String", "gt": "[ ] args ) throws Exception", "prediction": "[ ] args ) throws Exception\n", "label": 0}
{"id": 16183, "input": "<s> package org . eclipse . ui . browser ; import org . eclipse . ui . PartInitException ; public interface IWorkbenchBrowserSupport { int LOCATION_BAR = 1 << 1 ; int NAVIGATION_BAR = 1 << 2 ; int STATUS = 1 << 3 ; int PERSISTENT = 1 << 4 ; int AS_EDITOR = 1 << 5 ; int AS_VIEW = 1 << 6 ; int AS_EXTERNAL = 1 << 7 ; IWebBrowser createBrowser ( int style , String browserId , String name , String tooltip ) throws PartInitException ; IWebBrowser createBrowser ( String browserId ) throws PartInitException ; IWebBrowser getExternalBrowser ( ) throws PartInitException ;", "gt": "boolean isInternalWebBrowserAvailable ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6741, "input": "<s> package org . ofbiz . product . spreadsheetimport ; import java . math . BigDecimal ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; public class ImportProductHelper { static String module = ImportProductHelper . class . getName ( ) ; public static Map < String , Object > prepareProduct ( String productId ) { Map < String , Object > fields = FastMap . newInstance ( ) ; fields . put ( \"productId\" , productId ) ; fields . put ( \"productTypeId\" , \"FINISHED_GOOD\" ) ; fields . put ( \"internalName\" , \"Product_\" + productId ) ; fields . put ( \"isVirtual\" , \"N\" ) ; fields . put ( \"isVariant\" , \"N\" ) ; return fields ; } public static Map < String , Object > prepareInventoryItem ( String productId , BigDecimal quantityOnHand , String inventoryItemId ) { Map < String , Object > fields = FastMap . newInstance ( ) ; fields . put ( \"inventoryItemId\" , inventoryItemId ) ; fields . put ( \"inventoryItemTypeId\" , \"NON_SERIAL_INV_ITEM\" ) ; fields . put ( \"productId\" , productId ) ; fields . put ( \"ownerPartyId\" , \"Company\" ) ; fields . put ( \"facilityId\" , \"WebStoreWarehouse\" ) ; fields . put ( \"quantityOnHandTotal\" , quantityOnHand ) ; fields . put ( \"availableToPromiseTotal\" , quantityOnHand ) ; return fields ; } public static boolean checkProductExists ( String productId , Delegator delegator ) { GenericValue tmpProductGV ; boolean productExists = false ; try { tmpProductGV = delegator . findOne ( \"Product\" , UtilMisc . toMap ( \"productId\" , productId ) , false ) ; if ( tmpProductGV != null && productId . equals ( tmpProductGV . getString ( \"productId\" ) ) ) productExists = true ; } catch ( GenericEntityException e ) { Debug . logError ( \"Problem in reading data", "gt": "of product\" , module ) ;", "prediction": ": \" + e . getMessage ( ) ) ;\n", "label": 0}
{"id": 16186, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . ecore . EObject ; public interface DatatypeDefinition extends EObject { DataRange getDataRange ( ) ; void setDataRange ( DataRange value ) ; OWLDatatype getDatatype ( ) ;", "gt": "void setDatatype ( OWLDatatype value ) ;", "prediction": "}\n", "label": 1}
{"id": 2144, "input": "<s> package org . ofbiz . pos . event ; import java . util . Locale ; import org . ofbiz . pos . screen . PosScreen ; import org . ofbiz . pos . component . InputWithPassword ; import org . ofbiz . pos . component . Output ; import org . ofbiz . pos . PosTransaction ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . Debug ; import org . ofbiz . guiapp . xui . XuiSession ; import org . ofbiz . entity . GenericValue ; public class SecurityEvents { public static final String module = SecurityEvents . class . getName ( ) ; public static synchronized void login ( PosScreen pos ) { pos . setWaitCursor ( ) ; String [ ] func = pos . getInput ( ) . getFunction ( \"LOGIN\" ) ; if ( func == null ) { pos . getInput ( ) . setFunction ( \"LOGIN\" , \"\" ) ; } baseLogin ( pos , false ) ; pos . setNormalCursor ( ) ; } public static synchronized void logout ( PosScreen pos ) { pos . setWaitCursor ( ) ; PosTransaction trans = PosTransaction . getCurrentTx ( pos . getSession ( ) ) ; XuiSession session = pos . getSession ( ) ; trans . closeTx ( ) ; session . logout ( ) ; pos . showPage ( \"pospanel\" ) ; PosScreen . currentScreen . setLock ( true ) ; pos . setNormalCursor ( ) ; } public static synchronized void mgrLogin ( PosScreen pos ) { pos . setWaitCursor ( ) ; XuiSession session = pos . getSession ( ) ; if ( session . hasRole ( session . getUserLogin ( ) , \"MANAGER\" ) ) { ManagerEvents . mgrLoggedIn = true ; pos . showPage ( \"mgrpanel\" ) ; PosScreen . currentScreen . getInput ( ) . clear ( ) ; } else { String [ ] func = pos . getInput ( ) . getFunction ( \"MGRLOGIN\" ) ; if ( func == null ) { pos . getInput ( ) . setFunction ( \"MGRLOGIN\" , \"\" ) ; } baseLogin ( pos , true ) ; } pos . setNormalCursor ( ) ; } public static synchronized void lock ( PosScreen pos ) { pos . setLock ( true ) ; } private static synchronized void baseLogin ( PosScreen pos , boolean mgr ) { XuiSession session = pos . getSession ( ) ; Output output = pos . getOutput ( ) ; InputWithPassword input = pos . getInput ( ) ; String loginFunc = mgr ? \"MGRLOGIN\" : \"LOGIN\" ; String [ ] func = input . getLastFunction ( ) ; String text = input . value ( ) ; if ( func != null && func [ 0 ] . equals ( loginFunc ) ) { if ( UtilValidate . isEmpty ( func [ 1 ] ) && UtilValidate . isEmpty ( text ) ) { output . print ( UtilProperties . getMessage ( PosTransaction . resource , \"PosULogin\" , Locale . getDefault ( ) ) ) ; input . setFunction ( loginFunc ) ; input . setPasswordInput ( false ) ; } else if ( UtilValidate . isEmpty ( func [ 1 ] ) ) { output . print ( UtilProperties . getMessage ( PosTransaction . resource , \"PosUPassw\" , Locale . getDefault ( ) ) ) ; input . setFunction ( loginFunc ) ; input . setPasswordInput ( true ) ; } else { input . setPasswordInput ( false ) ; String username = func [ 1 ] ; String password = text ; if ( ! mgr ) { boolean passed = false ; try { session . login ( username , password ) ; passed = true ; } catch ( XuiSession . UserLoginFailure e ) { input . clear ( ) ; input . setFunction ( loginFunc ) ; output . print ( e . getMessage ( ) + \" \" + UtilProperties . getMessage ( PosTransaction . resource , \"PosULogin\" , Locale . getDefault ( ) ) ) ; } if ( passed ) { input . clear ( ) ; pos . setLock ( false ) ; pos . refresh ( ) ; return ; } } else { GenericValue mgrUl = null ; try { mgrUl = session . checkLogin ( username , password ) ; }", "gt": "catch ( XuiSession . UserLoginFailure e )", "prediction": "catch ( XuiSession . UserLoginFailure e )\n", "label": 0}
{"id": 16193, "input": "<s> package org . apache . lucene . swing . models ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import javax . swing . AbstractListModel ; public class BaseListModel extends AbstractListModel { private List data = new ArrayList ( ) ; public BaseListModel ( Iterator iterator ) { while ( iterator . hasNext ( ) ) { data . add ( iterator . next ( ) ) ; } } public int getSize ( ) {", "gt": "return data . size ( ) ;", "prediction": "return data . size ( ) ;\n", "label": 1}
{"id": 8726, "input": "<s> package org . msl . simple . gmf . bridge . ui ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { public static final String PLUGIN_ID = \"org.msl.simple.gmf.bridge.ui\" ; private static Activator plugin ; public Activator ( ) { } public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; } public void stop ( BundleContext context ) throws Exception { plugin = null ; super . stop ( context ) ; } public", "gt": "static Activator getDefault ( )", "prediction": "void update ( BundleContext context ) throws Exception\n", "label": 0}
{"id": 16198, "input": "<s> package org . restlet ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . data . CacheDirective ; import org . restlet . data . MediaType ; import org . restlet . data . RecipientInfo ; import org . restlet . data . Warning ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; public abstract class Message { private volatile ConcurrentMap < String , Object > attributes ; private volatile List < CacheDirective > cacheDirectives ; private volatile Date date ; private volatile Representation entity ; private volatile String entityText ; private volatile Uniform onError ; private volatile Uniform onSent ; private volatile List < RecipientInfo > recipientsInfo ; private volatile List < Warning > warnings ; public Message ( ) { this ( ( Representation ) null ) ; } public Message ( Representation entity ) { this . attributes = null ; this . cacheDirectives = null ; this . date = null ; this . entity = entity ; this . entityText = null ; this . onSent = null ; this . recipientsInfo = null ; this . warnings = null ; } public ConcurrentMap < String , Object > getAttributes ( ) { ConcurrentMap < String , Object > r = this . attributes ; if ( r == null ) { synchronized ( this ) { r = this . attributes ; if ( r == null ) { this . attributes = r = new ConcurrentHashMap < String , Object > ( ) ; } } } return this . attributes ; } public List < CacheDirective > getCacheDirectives ( ) { List < CacheDirective > r = this . cacheDirectives ; if ( r == null ) { synchronized ( this ) { r = this . cacheDirectives ; if ( r == null ) { this . cacheDirectives = r = new CopyOnWriteArrayList < CacheDirective > ( ) ; } } } return r ; } public Date getDate ( ) { return date ; } public Representation getEntity ( ) { return this . entity ; } public String getEntityAsText ( ) { if ( this . entityText == null ) { try { this . entityText = ( getEntity ( ) == null ) ? null : getEntity ( ) . getText ( ) ; } catch ( java . io . IOException e ) { Context . getCurrentLogger ( ) . log ( java . util . logging . Level . FINE , \"Unable to get the entity text.\" , e ) ; } } return this . entityText ; } public Uniform getOnError ( ) { return onError ; } public Uniform getOnSent ( ) { return onSent ; } public List < RecipientInfo > getRecipientsInfo ( ) { List < RecipientInfo >", "gt": "r = this . recipientsInfo ;", "prediction": "r = this . recipientsInfo ;\n", "label": 1}
{"id": 1176, "input": "<s> package pkg1 ; import java . io . IOException ; import java . io . Serializable ; public class C1 implements Serializable { @ Deprecated public boolean undecorated = false ; private String title ; public static enum ModalExclusionType { NO_EXCLUDE , APPLICATION_EXCLUDE } ; public", "gt": "C1 ( String title , boolean test )", "prediction": "static enum ModalExclusionType\n", "label": 0}
{"id": 16199, "input": "<s> package org . eclipse . jface . tests . labelProviders ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . tests . viewers . TestElement ; import org . eclipse . jface . tests . viewers . ViewerTestCase ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . widgets . Control ; public abstract class CompositeLabelProviderTest extends ViewerTestCase { class LabelTableContentProvider implements IStructuredContentProvider { public Object [ ] getElements ( Object inputElement ) { return fRootElement . getChildren ( ) ; } public void dispose ( ) { } public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } } Color background ; Color foreground ; Font font ; public CompositeLabelProviderTest ( String name ) { super ( name ) ; } void initializeColors ( Control parent ) { background = parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_RED ) ; foreground = parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_BLUE ) ; font = JFaceResources . getBannerFont ( ) ; } class TestTreeContentProvider implements ITreeContentProvider { public Object [ ] getChildren ( Object parentElement ) { return ( ( TestElement ) parentElement ) . getChildren ( ) ; } public Object getParent ( Object element ) { return ( ( TestElement ) element ) . getContainer ( ) ; } public boolean hasChildren ( Object element ) { return getChildren ( element", "gt": ") . length > 0 ;", "prediction": ") != null ;\n", "label": 1}
{"id": 4114, "input": "<s> package org . ofbiz . minilang . method . envops ; import java . text . MessageFormat ; import java . util . List ; import javolution . util . FastList ; import org . ofbiz . base . util . MessageString ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class StringToList extends MethodOperation { private final FlexibleMapAccessor < List < ? extends Object > > argListFma ; private final FlexibleMapAccessor < List < Object > > listFma ; private final String messageFieldName ; private final FlexibleStringExpander stringFse ; public StringToList ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . handleError ( \"<string-to-list> element is deprecated (use <set>)\" , simpleMethod , element ) ; MiniLangValidate . attributeNames ( simpleMethod , element , \"list\" , \"arg-list\" , \"string\" , \"message-field\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"list\" , \"string\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"list\" , \"arg-list\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } stringFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"string\" ) ) ; listFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"list\" ) ) ; argListFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"arg-list\" ) ) ; messageFieldName = element . getAttribute ( \"message-field\" ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { String valueStr = stringFse . expandString ( methodContext . getEnvMap ( ) ) ; List < ? extends Object > argList = argListFma . get ( methodContext . getEnvMap ( ) ) ; if ( argList != null ) { try { valueStr = MessageFormat . format ( valueStr , argList . toArray ( ) ) ; } catch ( IllegalArgumentException e ) { throw new MiniLangRuntimeException ( \"Exception thrown while formatting the string attribute: \" + e . getMessage ( ) , this ) ; } } Object value ; if ( UtilValidate . isNotEmpty ( this . messageFieldName ) ) { value = new MessageString ( valueStr , this . messageFieldName , true ) ; } else { value = valueStr ; } List < Object > toList = listFma . get ( methodContext . getEnvMap ( ) ) ; if ( toList == null ) { toList", "gt": "= FastList . newInstance ( ) ;", "prediction": "= new ArrayList < Object > ( ) ;\n", "label": 0}
{"id": 16200, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . model ; public class BuildrTask { private String name ; private String description ; public BuildrTask ( String name , String description ) { this . name = name ; this . description = description ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } @ Override public String toString ( ) { return \"BuildrTask{\" + \"name='\" + name + '\\''", "gt": "+ \", description='\" + description + '\\'' + '}' ;", "prediction": "+ description + '}' ;\n", "label": 1}
{"id": 7621, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . impl . EObjectImpl ; import org . eclipse . gmf . mappings . NodeReference ; import org . msl . simple . gmfmap . simplemappings . SimpleNodeReference ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleNodeReferenceImpl extends EObjectImpl implements SimpleNodeReference { protected SimpleNodeReferenceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE ; } @ Override protected int eStaticFeatureCount ( ) { return 0 ; } public NodeReference getNodeReference ( ) { return ( NodeReference ) eGet ( SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__NODE_REFERENCE , true ) ; } public void setNodeReference ( NodeReference newNodeReference ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__NODE_REFERENCE , newNodeReference ) ; } public EReference getContainmentFeature ( ) { return ( EReference ) eGet ( SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__CONTAINMENT_FEATURE , true ) ; } public void setContainmentFeature ( EReference newContainmentFeature ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__CONTAINMENT_FEATURE , newContainmentFeature ) ; } public String getName ( ) { return ( String ) eGet ( SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE__NAME , true ) ; } public void", "gt": "setName ( String newName )", "prediction": "setName ( String name )\n", "label": 0}
{"id": 16204, "input": "<s> package tk . blackwolf12333 . grieflog . commands ; import java . util . Arrays ; import java . util . List ; import org . bukkit . ChatColor ; import org . bukkit . command . CommandSender ; import tk . blackwolf12333 . grieflog . utils . config . ConfigHandler ; public class GLogBp { String [ ] helpTxt = { ChatColor . RED + \"++++++++++ [GriefLog-BlockProtection] +++++++++++++\" , \"Commands:\" , ChatColor . GOLD + \"/glog bp help\" + ChatColor . DARK_GRAY + \"Gives this help text.\" , ChatColor . GOLD + \"/glog bp listfriends: \" + ChatColor . DARK_GRAY + \"This lists the friends on your friendslist.\" , ChatColor . GOLD + \"/glog bp addfriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This adds a friend to your friendslist so that he can break your blocks.\" , ChatColor . GOLD + \"/glog bp removefriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This removes a friend from your friendslist.\" } ; public boolean onCommand ( CommandSender sender , String cmdLabel , String [ ] args ) { if ( args [ 1 ] . equalsIgnoreCase ( \"listfriends\" ) ) { List < String > friends = ConfigHandler . getFriends ( sender . getName ( ) ) ; sender . sendMessage ( ChatColor . AQUA + \"This are your current friends: \" ) ; for ( int i = 0 ; i < friends . size ( ) ; i ++ ) { sender . sendMessage ( ChatColor . AQUA + friends . get ( i ) ) ; } return true ; } if ( args [ 1 ] . equalsIgnoreCase ( \"addfriend\" ) ) { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . size ( ) == 0 ) { String [ ] list = new String [ ] { args [ 2 ] } ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , Arrays . asList ( list ) ) ; } else { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . contains ( args [ 2 ] ) ) { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Player \" + args [ 2 ] + \" is allready on your friends list.\" ) ; } else { List < String > friends = ConfigHandler . friendsConfig . getStringList ( sender . getName ( ) ) ; friends . add ( args [ 0 ] ) ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , friends ) ; sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Friend \" + args [ 2 ] + \" added to friends list.\" ) ; } } ConfigHandler . saveFriendsConfig ( ) ; return true ; } if ( args [ 1 ] . equalsIgnoreCase ( \"removefriend\" ) ) { if ( ConfigHandler . getFriends ( sender . getName ( ) ) == null ) { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] You don't have any friends added yet.\" ) ; return true ; } else { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . contains ( args [ 2 ] ) ) { List < String > friends = ConfigHandler . friendsConfig . getStringList ( sender . getName ( ) ) ; friends . remove ( args [ 2 ] ) ; ConfigHandler . friendsConfig . set (", "gt": "sender . getName ( ) , friends ) ;", "prediction": "sender . getName ( ) , friends ) ;\n", "label": 1}
{"id": 8485, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . policies ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Figure ; import org . eclipse . draw2d . FigureListener ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . Label ; import org . eclipse . draw2d . RectangleFigure ; import org . eclipse . draw2d . geometry . Rectangle ; import org . eclipse . gef . editpolicies . SelectionEditPolicy ; import org . eclipse . gmf . runtime . draw2d . ui . figures . WrappingLabel ; public class SimplemapTextSelectionEditPolicy extends SelectionEditPolicy { private IFigure selectionFeedbackFigure ; private IFigure focusFeedbackFigure ; private FigureListener hostPositionListener ; protected void showPrimarySelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { showSelection ( ) ; showFocus ( ) ; } } protected void showSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( true ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { hideSelection ( ) ; addFeedback ( selectionFeedbackFigure = createSelectionFeedbackFigure ( ) ) ; getHostFigure ( ) . addFigureListener ( getHostPositionListener ( ) ) ; refreshSelectionFeedback ( ) ; hideFocus ( ) ; } } protected void hideSelection ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setSelected ( false ) ; ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( selectionFeedbackFigure != null ) { removeFeedback ( selectionFeedbackFigure ) ; getHostFigure ( ) . removeFigureListener ( getHostPositionListener ( ) ) ; selectionFeedbackFigure = null ; } hideFocus ( ) ; } } protected void showFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( true ) ; } else { hideFocus ( ) ; addFeedback ( focusFeedbackFigure = createFocusFeedbackFigure ( ) ) ; refreshFocusFeedback ( ) ; } } protected void hideFocus ( ) { if ( getHostFigure ( ) instanceof WrappingLabel ) { ( ( WrappingLabel ) getHostFigure ( ) ) . setFocus ( false ) ; } else { if ( focusFeedbackFigure != null ) { removeFeedback ( focusFeedbackFigure ) ; focusFeedbackFigure = null ; } } } protected Rectangle getFeedbackBounds ( ) { Rectangle bounds ; if ( getHostFigure ( ) instanceof Label ) { bounds = ( ( Label ) getHostFigure ( ) ) . getTextBounds ( ) ; bounds . intersect ( getHostFigure ( ) . getBounds ( ) ) ; } else { bounds = getHostFigure ( ) . getBounds ( ) . getCopy ( ) ; } getHostFigure ( ) . getParent", "gt": "( ) . translateToAbsolute ( bounds ) ;", "prediction": "( ) . setTextBounds ( bounds ) ;\n", "label": 0}
{"id": 16206, "input": "<s> package org . eclipse . swt . graphics ; import java . io . * ; import org . eclipse . swt . * ; import org . eclipse . swt . widgets . Control ; public class GC extends Resource { private final GCDelegate delegate ; private boolean advanced ; private int antialias ; private int textAntialias ; public GC ( Drawable drawable ) { this ( drawable , SWT . NONE ) ; } public GC ( Drawable drawable , int style ) { super ( determineDevice ( drawable ) ) ; if ( drawable == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } delegate = determineDelegate ( drawable ) ; antialias = SWT . DEFAULT ; textAntialias = SWT . DEFAULT ; } public void setFont ( Font font ) { checkDisposed ( ) ; if ( font != null && font . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } Font newFont = font != null ? font : delegate . getDefaultFont ( ) ; delegate . setFont ( newFont ) ; } public Font getFont ( ) { checkDisposed ( ) ; return delegate . getFont ( ) ; } public int getCharWidth ( char ch ) { checkDisposed ( ) ; return delegate . stringExtent ( Character . toString ( ch ) ) . x ; } public Point stringExtent ( String string ) { checkDisposed ( ) ; if ( string == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } return delegate . stringExtent ( string ) ; } public Point textExtent ( String string ) { checkDisposed ( ) ; if ( string == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } return delegate . textExtent ( string , 0 ) ; } public FontMetrics getFontMetrics ( ) { checkDisposed ( ) ; return new FontMetrics ( delegate . getFont ( ) ) ; } public void setBackground ( Color color ) { checkDisposed ( ) ; if ( color == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( color . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setBackground ( color ) ; } public Color getBackground ( ) { checkDisposed ( ) ; return delegate . getBackground ( ) ; } public void setForeground ( Color color ) { checkDisposed ( ) ; if ( color == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( color . isDisposed ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setForeground ( color ) ; } public Color getForeground ( ) { checkDisposed ( ) ; return delegate . getForeground ( ) ; } public Rectangle getClipping ( ) { checkDisposed ( ) ; return delegate . getClipping ( ) ; } public void setAlpha ( int alpha ) { checkDisposed ( ) ; if ( alpha >= 0 && alpha <= 255 && delegate . getAlpha ( ) != alpha ) { delegate . setAlpha ( alpha ) ; advanced = true ; } } public int getAlpha ( ) { checkDisposed ( ) ; return delegate . getAlpha ( ) ; } public void setLineWidth ( int lineWidth ) { checkDisposed ( ) ; if ( delegate . getLineWidth ( ) != lineWidth ) { delegate . setLineWidth ( lineWidth ) ; } } public int getLineWidth ( ) { checkDisposed ( ) ; return delegate . getLineWidth ( ) ; } public void setLineCap ( int lineCap ) { checkDisposed ( ) ; if ( delegate . getLineCap ( ) != lineCap ) { switch ( lineCap ) { case SWT . CAP_ROUND : case SWT . CAP_FLAT : case SWT . CAP_SQUARE : break ; default : SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setLineCap ( lineCap ) ; } } public int getLineCap ( ) { checkDisposed ( ) ; return delegate . getLineCap ( ) ; } public void setLineJoin ( int lineJoin ) { checkDisposed ( ) ; if ( delegate . getLineJoin ( ) != lineJoin ) { switch ( lineJoin ) { case SWT . JOIN_MITER : case SWT . JOIN_ROUND : case SWT . JOIN_BEVEL : break ; default : SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } delegate . setLineJoin ( lineJoin ) ; } } public int getLineJoin ( ) { checkDisposed ( ) ; return delegate . getLineJoin ( ) ; } public void setLineAttributes ( LineAttributes attributes ) { checkDisposed ( ) ; if ( attributes == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } setLineWidth ( ( int ) attributes . width ) ; setLineCap ( attributes . cap ) ; setLineJoin ( attributes . join ) ; advanced = true ; } public LineAttributes getLineAttributes ( ) { checkDisposed ( ) ; int lineWidth = delegate . getLineWidth ( ) ; int lineCap = delegate . getLineCap ( ) ; int lineJoin = delegate . getLineJoin ( ) ; return new LineAttributes ( lineWidth , lineCap , lineJoin ) ; } public void setAdvanced ( boolean advanced ) { checkDisposed ( ) ; this . advanced = advanced ; if ( ! advanced ) { delegate . setAlpha ( 255 ) ; antialias = SWT . DEFAULT ; textAntialias = SWT . DEFAULT ; } } public void setAntialias ( int antialias ) { if ( antialias != SWT . DEFAULT && antialias != SWT . ON && antialias != SWT . OFF ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } this . antialias = antialias ; advanced = true ; } public int getAntialias ( ) { return antialias ; } public", "gt": "void setTextAntialias ( int antialias )", "prediction": "int getLineWidth ( )\n", "label": 1}
{"id": 7077, "input": "<s> import annot . * ; import annot . annot2 . * ; public class StaticMethodAnnotations { static double d ; public void foo ( ) { return ; } @ MySimple ( \"value\" ) @ MyMarker @ AnnotMarker @ AnnotSimple ( \"foo\" ) @ AnnotMarker2 @ AnnotSimple2", "gt": "( \"bar\" ) public static void baz ( )", "prediction": "\n", "label": 0}
{"id": 16219, "input": "<s> package org . nuxeo . ecm . automation . features ; import org . nuxeo . ecm . automation . core . scripting . Functions ; import org . osgi . framework . BundleActivator ; import org . osgi . framework . BundleContext ; public class Activator implements BundleActivator { @ Override public void start ( BundleContext context ) throws Exception { Functions . setInstance ( new", "gt": "PlatformFunctions ( ) ) ;", "prediction": "Functions ( ) ) ;\n", "label": 1}
{"id": 10104, "input": "<s> class T7030606 { class E1 extends Exception { } class E2 extends E1 { } void e1 ( ) throws E1 { } void e2 ( ) throws E2 { } void m1 ( ) { try { e1 ( ) ; e2 ( ) ; } catch ( NonExistentType | E2 | E1 e ) { } } void m2 ( ) { try { e1 ( ) ; e2 ( ) ; } catch ( NonExistentType | E1 | E2 e ) { } } void m3 ( ) { try { e1 ( ) ; e2 ( ) ; } catch ( E2 | NonExistentType | E1 e ) { } } void m4 ( ) { try { e1 ( ) ; e2 ( ) ; }", "gt": "catch ( E1 | NonExistentType | E2 e )", "prediction": "catch ( E2 | NonExistentType | E1 e )\n", "label": 0}
{"id": 16221, "input": "<s> package com . corundumstudio . socketio . messages ; import java . io . IOException ; import org . jboss . netty . channel . Channel ; import com . corundumstudio . socketio . MessageHandler ; public abstract class BaseMessage { public abstract void handleMessage ( MessageHandler handler ,", "gt": "Channel channel ) throws IOException ;", "prediction": "Channel channel )\n", "label": 1}
{"id": 5554, "input": "<s> class Base { Base ( int i ) { } } class CantRefBeforeConstr extends Base { int i ; CantRefBeforeConstr ( ) {", "gt": "super ( i ) ;", "prediction": "this . i = i ;\n", "label": 0}
{"id": 16230, "input": "<s> package org . restlet . example . book . restlet . ch08", "gt": ". gae . common ;", "prediction": ";\n", "label": 1}
{"id": 9240, "input": "<s> package com . sun . tools . javah ; import java . util . * ; import javax . lang . model . element . Name ; import javax . lang . model . element . TypeElement ; import javax . lang . model . type . ArrayType ; import javax . lang . model . type . DeclaredType ; import javax . lang . model . type . NoType ; import javax . lang . model . type . PrimitiveType ; import javax . lang . model . type . TypeKind ; import javax . lang . model . type . TypeMirror ; import javax . lang . model . type . TypeVariable ; import javax . lang . model . type . TypeVisitor ; import javax . lang . model . util . Elements ; import javax . lang . model . util . SimpleTypeVisitor7 ; public class TypeSignature { static class SignatureException extends Exception { private static final long serialVersionUID = 1L ; SignatureException ( String reason ) { super ( reason ) ; } } Elements elems ; private static final String SIG_VOID = \"V\" ; private static final String SIG_BOOLEAN = \"Z\" ; private static final String SIG_BYTE = \"B\" ; private static final String SIG_CHAR = \"C\" ; private static final String SIG_SHORT = \"S\" ; private static final String SIG_INT = \"I\" ; private static final String SIG_LONG = \"J\" ; private static final String SIG_FLOAT = \"F\" ; private static final String SIG_DOUBLE = \"D\" ; private static final String SIG_ARRAY = \"[\" ; private static final String SIG_CLASS = \"L\" ; public TypeSignature ( Elements elems ) { this . elems = elems ; } public String getTypeSignature ( String javasignature ) throws SignatureException { return getParamJVMSignature ( javasignature ) ; } public String getTypeSignature ( String javasignature , TypeMirror returnType ) throws SignatureException { String signature = null ; String typeSignature = null ; List < String > params = new ArrayList < String > ( ) ; String paramsig = null ; String paramJVMSig = null ; String returnSig = null ; String returnJVMType = null ; int dimensions = 0 ; int startIndex = - 1 ; int endIndex = - 1 ; StringTokenizer st = null ; int i = 0 ; if ( javasignature != null ) { startIndex = javasignature . indexOf ( \"(\" ) ; endIndex = javasignature . indexOf ( \")\" ) ; } if ( ( ( startIndex != - 1 ) && ( endIndex != - 1 ) ) && ( startIndex + 1 < javasignature . length ( ) ) && ( endIndex < javasignature . length ( ) ) ) { signature = javasignature . substring ( startIndex + 1 , endIndex ) ; } if ( signature != null ) { if ( signature . indexOf ( \",\" ) != - 1 ) { st = new StringTokenizer ( signature , \",\" ) ; if ( st != null ) { while ( st . hasMoreTokens ( ) ) { params . add ( st . nextToken ( ) ) ; } } } else { params . add ( signature ) ; } } typeSignature = \"(\" ; while ( params . isEmpty ( ) != true ) { paramsig = params . remove ( i ) . trim ( ) ; paramJVMSig = getParamJVMSignature ( paramsig ) ; if ( paramJVMSig != null ) { typeSignature += paramJVMSig ; } } typeSignature += \")\" ; returnJVMType = \"\" ; if ( returnType != null ) { dimensions = dimensions ( returnType ) ; } while ( dimensions -- > 0 ) { returnJVMType += \"[\" ; } if ( returnType != null ) { returnSig = qualifiedTypeName ( returnType ) ; returnJVMType += getComponentType ( returnSig ) ; } else { System . out . println ( \"Invalid return type.\" ) ; } typeSignature += returnJVMType ; return typeSignature ; } private String getParamJVMSignature ( String paramsig ) throws SignatureException { String paramJVMSig = \"\" ; String componentType = \"\" ; if", "gt": "( paramsig != null )", "prediction": "( paramJVMSig != null )\n", "label": 0}
{"id": 16231, "input": "<s> package org . springframework . tenancy . web ; import java . io . IOException ; import java . util . List ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import org . springframework . tenancy . context . TenancyContext ; import org . springframework . tenancy . context . TenancyContextHolder ; import org . springframework . tenancy . core . Tenant ; import org . springframework . tenancy . provider . DefaultTenantProvider ; import org . springframework . tenancy . provider . TenantProvider ; import org . springframework . web . filter . GenericFilterBean ; public class TenancyContextIntegrationFilter extends GenericFilterBean { private List < TenantIdentificationStrategy > tenantIdentificationStrategyChain ; private TenantProvider tenantProvider = new DefaultTenantProvider ( ) ; @ Override public void doFilter ( ServletRequest req , ServletResponse res , FilterChain chain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) req ; TenancyContext contextBeforeChainExecution = determineTenancyContext ( request ) ; try { TenancyContextHolder . setContext ( contextBeforeChainExecution ) ; chain . doFilter ( req , res ) ; } finally { TenancyContextHolder", "gt": ". clearContext ( ) ;", "prediction": ". close ( ) ;\n", "label": 1}
{"id": 10130, "input": "<s> package ar . com . fdvs . dj . core . registration ; import java . util . Iterator ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignField ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import ar . com . fdvs . dj . core . layout . LayoutManager ; import ar . com . fdvs . dj . domain . ColumnProperty ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . DJGroupVariableDef ; import ar . com . fdvs . dj . domain . entities . Entity ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . ExpressionColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . util . ExpressionUtils ; public class DJGroupVariableDefRegistrationManager extends AbstractEntityRegistrationManager { private static final Log log = LogFactory . getLog ( DJGroupVariableDefRegistrationManager . class ) ; JRDesignGroup group = null ; public DJGroupVariableDefRegistrationManager ( DynamicJasperDesign jd , DynamicReport dr , LayoutManager layoutManager , JRDesignGroup group ) { super ( jd , dr , layoutManager ) ; this . group = group ; } protected void registerEntity ( Entity entity ) { log . debug ( \"registering group variable...\" ) ; try { JRDesignVariable jrVariable = ( JRDesignVariable ) transformEntity ( entity ) ; getDjd ( ) . addVariable ( jrVariable ) ; } catch ( JRException e ) { throw new EntitiesRegistrationException ( e . getMessage ( ) , e ) ; } } protected Object transformEntity ( Entity entity ) { log . debug ( \"transforming group variable...\" ) ; DJGroupVariableDef columnsGroupVariable = ( DJGroupVariableDef ) entity ; DJCalculation op = columnsGroupVariable . getOperation ( ) ; JRDesignExpression expression = new JRDesignExpression ( ) ; String valueClassName = null ; String initialExpression = null ; if ( columnsGroupVariable . getColumnProperty ( ) != null ) { ColumnProperty prop = columnsGroupVariable . getColumnProperty ( ) ; expression . setText ( \"$F{\" + prop . getProperty ( ) + \"}\" ) ; expression . setValueClassName ( prop . getValueClassName ( ) ) ; registerField ( prop ) ; valueClassName = ExpressionUtils . getValueClassNameForOperation ( op , prop ) ; initialExpression = ExpressionUtils . getInitialValueExpressionForOperation ( op , prop ) ; } else { AbstractColumn col = columnsGroupVariable . getColumnToApplyOperation ( ) ; if ( col instanceof ExpressionColumn && ( ( ExpressionColumn ) col ) . getExpressionForCalculation ( ) != null ) { ExpressionColumn expcol = ( ExpressionColumn ) col ; expression . setText ( expcol . getTextForExpressionForCalculartion ( ) ) ; expression . setValueClassName ( expcol . getExpressionForCalculation ( ) . getClassName ( ) ) ; } else { expression . setText ( col . getTextForExpression ( ) ) ; expression . setValueClassName ( col . getValueClassNameForExpression ( ) ) ; } valueClassName = col . getVariableClassName ( op ) ; initialExpression = col . getInitialExpression ( op ) ; } JRDesignVariable variable = new JRDesignVariable ( ) ; variable . setExpression ( expression ) ; variable . setCalculation ( columnsGroupVariable . getOperation ( ) . getValue ( ) ) ; variable . setName ( columnsGroupVariable . getName ( ) ) ; if ( group != null ) { variable . setResetType ( JRDesignVariable . RESET_TYPE_GROUP ) ; variable . setResetGroup ( group ) ; } variable . setValueClassName ( valueClassName ) ; JRDesignExpression initialExp = new JRDesignExpression ( ) ; initialExp . setText ( initialExpression ) ; initialExp . setValueClassName ( valueClassName ) ; variable . setInitialValueExpression ( initialExp ) ; return variable ; } protected void registerField ( ColumnProperty columnProperty ) { JRDesignField field = new JRDesignField ( ) ; field . setName ( columnProperty", "gt": ". getProperty ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 16235, "input": "<s> package org . restlet . example . firstResource ; public class Item { private String description ; private String name ; public Item ( String name ) { super ( ) ; setName ( name ) ; } public Item ( String name , String description ) { super ( ) ; setName ( name ) ; setDescription ( description ) ; }", "gt": "public String getDescription ( )", "prediction": "}\n", "label": 1}
{"id": 9166, "input": "<s> package org . gk . ui . client . com . form ; import com . extjs . gxt . ui . client . core . El ; import com . extjs . gxt . ui . client . event . Events ; import com . extjs . gxt . ui . client . widget . form . LabelField ; import com . google . gwt . user . client . Element ; public class gkLabelField extends LabelField { private String inputStyle ; private String inputStyles = \"\" ; @ Override public void setInputStyleAttribute ( String attr , String value ) { if ( rendered ) { getInputEl ( ) . setStyleAttribute ( attr , value ) ; } else { inputStyles += attr + \":\" + value + \";\" ; } } @ Override public void addInputStyleName ( String style ) { if ( rendered ) { El inputEl = getInputEl ( ) ; if ( inputEl != null ) { inputEl . addStyleName ( style ) ; } } else { inputStyle = inputStyle == null ? style : inputStyle + \" \" + style ; } } @ Override public void removeInputStyleName ( String style ) { if ( rendered ) { El inputEl = getInputEl ( ) ; if ( inputEl != null ) { inputEl . removeStyleName ( style ) ; } } else if ( inputStyle != null && style != null ) { String [ ] s = inputStyle . split ( \" \" ) ; inputStyle = \"\" ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! s [ i ] . equals ( style ) ) { inputStyle += \" \" + s [ i ] ; } } } } @ Override protected void onRender (", "gt": "Element parent , int index )", "prediction": ")\n", "label": 0}
{"id": 16238, "input": "<s> package org . apache . lucene . queryParser . standard ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; final public class QueryParserUtil { public static Query parse ( String [ ] queries , String [ ] fields , Analyzer analyzer ) throws QueryNodeException { if ( queries . length != fields . length ) throw new IllegalArgumentException ( \"queries.length != fields.length\" ) ; BooleanQuery bQuery = new BooleanQuery ( ) ; StandardQueryParser qp = new StandardQueryParser ( ) ; qp . setAnalyzer ( analyzer ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Query q = qp . parse ( queries [ i ] , fields [ i ] ) ; if ( q != null && ( ! ( q instanceof BooleanQuery ) || ( ( BooleanQuery ) q ) . getClauses ( ) . length > 0 ) ) { bQuery . add ( q , BooleanClause . Occur . SHOULD ) ; } } return bQuery ; } public static Query parse ( String query , String [ ] fields , BooleanClause . Occur [ ] flags , Analyzer analyzer ) throws QueryNodeException { if ( fields . length != flags . length ) throw new IllegalArgumentException ( \"fields.length != flags.length\" ) ; BooleanQuery bQuery = new BooleanQuery ( ) ; StandardQueryParser qp = new StandardQueryParser ( ) ; qp . setAnalyzer ( analyzer ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Query q = qp . parse ( query , fields [ i ] ) ; if ( q != null && ( ! ( q instanceof BooleanQuery ) || ( ( BooleanQuery ) q ) . getClauses ( ) . length > 0 ) ) { bQuery . add ( q , flags [ i ] ) ; } } return bQuery ; } public static Query parse ( String [ ] queries , String [ ] fields , BooleanClause . Occur [ ] flags , Analyzer analyzer ) throws QueryNodeException { if ( ! ( queries . length == fields . length && queries . length == flags . length ) ) throw new IllegalArgumentException ( \"queries, fields, and flags array", "gt": "have have different length\" ) ;", "prediction": "\" ) ;\n", "label": 1}
{"id": 1640, "input": "<s> package org . ofbiz . securityext . cert ; import java . io . IOException ; import java . security . KeyStore ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; import java . util . Map ; import org . ofbiz . base . util . KeyStoreUtil ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; public class CertificateServices { public static final String module = CertificateServices . class . getName ( ) ; public static Map < String , Object > importIssuerCertificate ( DispatchContext dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . getDelegator ( ) ; String certString = ( String ) context . get ( \"certString\" ) ; String componentName = ( String ) context . get ( \"componentName\" ) ; String keystoreName = ( String ) context . get ( \"keystoreName\" ) ; String alias = ( String ) context . get ( \"alias\" ) ; String importIssuer = ( String ) context . get ( \"importIssuer\" ) ; KeyStore ks ; try { ks = KeyStoreUtil . getComponentKeyStore ( componentName , keystoreName ) ; } catch ( Exception e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } X509Certificate cert ; try { cert = ( X509Certificate ) KeyStoreUtil . pemToCert ( certString ) ; } catch ( CertificateException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } catch ( IOException e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } try { ks . setCertificateEntry ( alias , cert ) ; } catch ( Exception e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } try { KeyStoreUtil . storeComponentKeyStore ( componentName , keystoreName , ks ) ; } catch ( Exception e ) { return ServiceUtil . returnError ( e . getMessage ( ) ) ; } Map < String , String > x500Map = KeyStoreUtil . getCertX500Map ( cert ) ; if ( importIssuer != null && \"Y\" . equalsIgnoreCase ( importIssuer ) ) {", "gt": "GenericValue provision = delegator . makeValue ( \"X509IssuerProvision\" ) ;", "prediction": "x500Map . add ( importIssuer ) ;\n", "label": 0}
{"id": 16243, "input": "<s> package org . fuzzydb . expressions ; import org . fuzzydb . core . exceptions . ArchException ; public class SubExpr extends BinaryExpr { private static final long serialVersionUID = 3257571689419257908L ; public SubExpr ( ComparableExpr < Scalar > left , ComparableExpr < Scalar > right ) { super ( left , right ) ; } @ Override public Scalar evaluate ( ExprContext context ) {", "gt": "Scalar l = left . evaluate ( context ) ;", "prediction": "return left . evaluate ( context ) ;\n", "label": 1}
{"id": 2584, "input": "<s> public class JCrypt { private JCrypt ( ) { } private static final int ITERATIONS = 16 ; private static final int con_salt [ ] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F , 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 , 0x18 , 0x19 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 , 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F , 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x3E , 0x3F , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , } ; private static final boolean shifts2 [ ] = { false , false , true , true , true , true , true , true , false , true , true , true , true , true , true , false } ; private static final int skb [ ] [ ] = { { 0x00000000 , 0x00000010 , 0x20000000 , 0x20000010 , 0x00010000 , 0x00010010 , 0x20010000 , 0x20010010 , 0x00000800 , 0x00000810 , 0x20000800 , 0x20000810 , 0x00010800 , 0x00010810 , 0x20010800 , 0x20010810 , 0x00000020 , 0x00000030 , 0x20000020 , 0x20000030 , 0x00010020 , 0x00010030 , 0x20010020 , 0x20010030 , 0x00000820 , 0x00000830 , 0x20000820 , 0x20000830 , 0x00010820 , 0x00010830 , 0x20010820 , 0x20010830 , 0x00080000 , 0x00080010 , 0x20080000 , 0x20080010 , 0x00090000 , 0x00090010 , 0x20090000 , 0x20090010 , 0x00080800 , 0x00080810 , 0x20080800 , 0x20080810 , 0x00090800 , 0x00090810 , 0x20090800 , 0x20090810 , 0x00080020 , 0x00080030 , 0x20080020 , 0x20080030 , 0x00090020 , 0x00090030 , 0x20090020 , 0x20090030 , 0x00080820 , 0x00080830 , 0x20080820 , 0x20080830 , 0x00090820 , 0x00090830 , 0x20090820 , 0x20090830 , } , { 0x00000000 , 0x02000000 , 0x00002000 , 0x02002000 , 0x00200000 , 0x02200000 , 0x00202000 , 0x02202000 , 0x00000004 , 0x02000004 , 0x00002004 , 0x02002004 , 0x00200004 , 0x02200004 , 0x00202004 , 0x02202004 , 0x00000400 , 0x02000400 , 0x00002400 , 0x02002400 , 0x00200400 , 0x02200400 , 0x00202400 , 0x02202400 , 0x00000404 , 0x02000404 , 0x00002404 , 0x02002404 , 0x00200404 , 0x02200404 , 0x00202404 , 0x02202404 , 0x10000000 , 0x12000000 , 0x10002000 , 0x12002000 , 0x10200000 , 0x12200000 , 0x10202000 , 0x12202000 , 0x10000004 , 0x12000004 , 0x10002004 , 0x12002004 , 0x10200004 , 0x12200004 , 0x10202004 , 0x12202004 , 0x10000400 , 0x12000400 , 0x10002400 , 0x12002400 , 0x10200400 , 0x12200400 , 0x10202400 , 0x12202400 , 0x10000404 , 0x12000404 , 0x10002404 , 0x12002404 , 0x10200404 , 0x12200404 , 0x10202404 , 0x12202404 , } , { 0x00000000 , 0x00000001 , 0x00040000 , 0x00040001 , 0x01000000 , 0x01000001 , 0x01040000 , 0x01040001 , 0x00000002 , 0x00000003 , 0x00040002 , 0x00040003 , 0x01000002 , 0x01000003 , 0x01040002 , 0x01040003 , 0x00000200 , 0x00000201 , 0x00040200 , 0x00040201 , 0x01000200 , 0x01000201 , 0x01040200 , 0x01040201 , 0x00000202 , 0x00000203 , 0x00040202 , 0x00040203 , 0x01000202 , 0x01000203 , 0x01040202 , 0x01040203 , 0x08000000 , 0x08000001 , 0x08040000 , 0x08040001 , 0x09000000 , 0x09000001 , 0x09040000 , 0x09040001 , 0x08000002 , 0x08000003 , 0x08040002 , 0x08040003 , 0x09000002 , 0x09000003 , 0x09040002 , 0x09040003 , 0x08000200 , 0x08000201 , 0x08040200 , 0x08040201 , 0x09000200 , 0x09000201 , 0x09040200 , 0x09040201 , 0x08000202 , 0x08000203 , 0x08040202 , 0x08040203 , 0x09000202 , 0x09000203 , 0x09040202 , 0x09040203 , } , { 0x00000000 , 0x00100000 , 0x00000100 , 0x00100100 , 0x00000008 , 0x00100008 , 0x00000108 , 0x00100108 , 0x00001000 , 0x00101000 , 0x00001100 , 0x00101100 , 0x00001008 , 0x00101008 , 0x00001108 , 0x00101108 , 0x04000000 , 0x04100000 , 0x04000100 , 0x04100100 , 0x04000008 , 0x04100008 , 0x04000108 , 0x04100108 , 0x04001000 , 0x04101000 , 0x04001100 , 0x04101100 , 0x04001008 , 0x04101008 , 0x04001108 , 0x04101108 , 0x00020000 , 0x00120000 , 0x00020100 , 0x00120100 , 0x00020008 , 0x00120008 , 0x00020108 , 0x00120108 , 0x00021000 , 0x00121000 , 0x00021100 , 0x00121100 , 0x00021008 , 0x00121008 , 0x00021108 , 0x00121108 , 0x04020000 , 0x04120000 , 0x04020100 , 0x04120100 , 0x04020008 , 0x04120008 , 0x04020108 , 0x04120108 , 0x04021000 , 0x04121000 , 0x04021100 , 0x04121100 , 0x04021008", "gt": ", 0x04121008 , 0x04021108 , 0x04121108 , }", "prediction": ", }\n", "label": 0}
{"id": 16256, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . dialogs . IWorkingSetEditWizard ; import org . eclipse . ui . dialogs . IWorkingSetNewWizard ; import org . eclipse . ui . dialogs . IWorkingSetSelectionDialog ; public interface IWorkingSetManager { public static final String CHANGE_WORKING_SET_ADD = \"workingSetAdd\" ; public static final String CHANGE_WORKING_SET_REMOVE = \"workingSetRemove\" ; public static final String CHANGE_WORKING_SET_CONTENT_CHANGE = \"workingSetContentChange\" ; public static final String CHANGE_WORKING_SET_NAME_CHANGE = \"workingSetNameChange\" ; public static final String CHANGE_WORKING_SET_LABEL_CHANGE = \"workingSetLabelChange\" ; public static final String CHANGE_WORKING_SET_UPDATER_INSTALLED = \"workingSetUpdaterInstalled\" ; public static final String CHANGE_WORKING_SET_UPDATER_UNINSTALLED = \"workingSetUpdaterUninstalled\" ; public void addPropertyChangeListener ( IPropertyChangeListener listener ) ; public void addRecentWorkingSet ( IWorkingSet workingSet ) ; public void addWorkingSet ( IWorkingSet workingSet ) ; public IWorkingSet createWorkingSet ( String name , IAdaptable [ ] elements ) ; public IWorkingSet createAggregateWorkingSet ( String name , String label , IWorkingSet [ ] components ) ; public IWorkingSet createWorkingSet ( IMemento memento ) ; public IWorkingSetEditWizard createWorkingSetEditWizard ( IWorkingSet workingSet ) ; public IWorkingSetNewWizard createWorkingSetNewWizard ( String [ ] workingSetIds ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parent ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parentShell , boolean multi ) ; public IWorkingSetSelectionDialog createWorkingSetSelectionDialog ( Shell parentShell , boolean multi , String [ ] workingsSetIds ) ; public IWorkingSet [ ] getRecentWorkingSets ( ) ; public", "gt": "IWorkingSet getWorkingSet ( String name ) ;", "prediction": "void addWorkingSet ( IWorkingSet workingSet ) ;\n", "label": 1}
{"id": 7016, "input": "<s> package ar . com . fdvs . dj . test . groups ; import java . awt . Color ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . AutoText ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . ImageBanner ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . constants . Border ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . constants . HorizontalAlign ; import ar . com . fdvs . dj . domain . constants . Transparency ; import ar . com . fdvs . dj . domain . constants . VerticalAlign ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class GroupsReportTestG1T2 extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { Style detailStyle = new Style ( ) ; Style headerStyle = new Style ( ) ; headerStyle . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerStyle . setBorderBottom ( Border . PEN_1_POINT ) ; headerStyle . setBackgroundColor ( Color . gray ) ; headerStyle . setTextColor ( Color . white ) ; headerStyle . setHorizontalAlign ( HorizontalAlign . CENTER ) ; headerStyle . setVerticalAlign ( VerticalAlign . MIDDLE ) ; headerStyle . setTransparency ( Transparency . OPAQUE ) ; Style headerVariables = new Style ( ) ; headerVariables . setFont ( Font . ARIAL_MEDIUM_BOLD ) ; headerVariables . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; headerVariables . setVerticalAlign ( VerticalAlign . MIDDLE ) ; Style titleStyle = new Style ( ) ; titleStyle . setFont ( new Font ( 18 , Font . _FONT_VERDANA , true ) ) ; Style importeStyle = new Style ( ) ; importeStyle . setHorizontalAlign ( HorizontalAlign . RIGHT ) ; Style oddRowStyle = new Style ( ) ; oddRowStyle . setBorder ( Border . NO_BORDER ) ; oddRowStyle . setBackgroundColor ( Color . LIGHT_GRAY ) ; oddRowStyle . setTransparency ( Transparency . OPAQUE ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; Integer margin = new Integer ( 20 ) ; drb . setTitleStyle ( titleStyle ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"The items in this report correspond \" + \"to the main products: DVDs, Books, Foods and Magazines\" ) . setDetailHeight ( new Integer ( 15 ) ) . setLeftMargin ( margin ) . setRightMargin ( margin ) . setTopMargin ( margin ) . setBottomMargin ( margin ) . setPrintBackgroundOnOddRows ( false ) . setGrandTotalLegend ( \"Grand Total\" ) . setGrandTotalLegendStyle ( headerVariables ) . setDefaultStyles ( titleStyle , null , headerStyle , detailStyle ) . setPrintColumnNames ( false ) . addImageBanner ( System . getProperty ( \"user.dir\" ) + \"/target/test-classes/images/logo_fdv_solutions_60.jpg\" , new Integer ( 100 ) , new Integer ( 30 ) , ImageBanner . ALIGN_RIGHT ) . setOddRowBackgroundStyle ( oddRowStyle ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaProductLine = ColumnBuilder . getNew ( ) . setColumnProperty ( \"productLine\" , String . class . getName ( ) ) . setTitle ( \"Product Line\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle ( headerStyle ) . build ( ) ; AbstractColumn columnaItem = ColumnBuilder . getNew ( ) . setColumnProperty ( \"item\" , String . class . getName ( ) ) . setTitle ( \"Item\" ) . setWidth ( new Integer ( 85 ) ) . setStyle ( detailStyle ) . setHeaderStyle", "gt": "( headerStyle ) . build ( ) ;", "prediction": "( headerStyle ) . build ( ) ;\n", "label": 0}
{"id": 16262, "input": "<s> package org . eclipse . rap . demo . controls ; import java . util . ArrayList ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ArrayContentProvider ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . ListViewer ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . MenuAdapter ; import org . eclipse . swt . events . MenuEvent ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Link ; import org . eclipse . swt . widgets . List ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; public class ListTab extends ExampleTab { private static final java . util . List < String > ELEMENTS ; static { ELEMENTS = new ArrayList < String > ( ) ; String text = \"A very long item that demonstrates horizontal scrolling in a List\" ; ELEMENTS . add ( text ) ; text = \"An item with a linebreak\\n(converted to a whitespace)\" ; ELEMENTS . add ( text ) ; text = \"...and other control chars: \u0003 \\t \u0004 \u000f\" ; ELEMENTS . add ( text ) ; for ( int i = 1 ; i <= 25 ; i ++ ) { ELEMENTS . add ( \"Item \" + i ) ; } } private List list ; private List list2 ; private ListViewer listViewer ; public ListTab ( ) { super ( \"List\" ) ; } @ Override protected void createStyleControls ( final Composite parent ) { createStyleButton ( \"BORDER\" , SWT . BORDER ) ; createStyleButton ( \"SINGLE\" , SWT . SINGLE ) ; createStyleButton ( \"MULTI\" , SWT . MULTI ) ; createStyleButton ( \"H_SCROLL\" , SWT . H_SCROLL ) ; createStyleButton ( \"V_SCROLL\" , SWT . V_SCROLL ) ; createVisibilityButton ( ) ; createEnablementButton ( ) ; createFgColorButton ( ) ; createBgColorButton ( ) ; createBgImageButton ( ) ; createFontChooser ( ) ; createCursorCombo ( ) ; createSelectionButton ( ) ; Group group = new Group ( parent , SWT . NONE ) ; group . setText ( \"Manipulate Right List\" ) ; group . setLayout ( new GridLayout ( ) ) ; createAddItemsControls ( group ) ; createSetTopIndexControls ( group ) ; createGetTopIndexControls ( group ) ; createShowSelectionControls ( group ) ; createSelectAllButton ( group ) ; createDeselectAllButton ( group ) ; createSelectButton ( group ) ; createDeselectButton ( group ) ; createSetSelectionButton ( group ) ; } @ Override protected void createExampleControls ( final Composite parent ) { parent . setLayout ( new GridLayout ( 2 , true ) ) ; int style = getStyle ( ) ; list = new List ( parent , style ) ; list . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Menu menu = new Menu ( list ) ; MenuItem menuItem = new MenuItem ( menu , SWT . PUSH ) ; menuItem . setText ( \"Context menu item\" ) ; list . setMenu ( menu ) ; listViewer = new ListViewer ( list ) ; listViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; listViewer . setLabelProvider ( new LabelProvider ( ) ) ; listViewer . setInput ( ELEMENTS ) ; list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetDefaultSelected ( SelectionEvent event ) { String item = list . getItem ( list . getSelectionIndex ( ) ) ; String message = \"Selected Item: \" + item ; MessageDialog . openInformation ( getShell ( ) , \"Selection\" , message ) ; } } ) ; registerControl ( list ) ; list2 = new List ( parent , style ) ; list2 . add ( \"Item 0\" ) ; list2 . add ( \"Item 1\" ) ; list2 . add ( \"Item 2\" ) ; list2 . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; registerControl ( list2 ) ; createPopupMenu ( parent . getShell ( ) , list2 ) ; int separatorStyle = SWT . SEPARATOR | SWT . HORIZONTAL | SWT . SHADOW_OUT ; Label separator = new Label ( parent , separatorStyle ) ; separator . setLayoutData ( createGridDataWithSpan ( ) ) ; Label codeLabel = new Label ( parent , SWT . WRAP ) ; String codeLabelText = \"Please note that the content of the left List is provided by a \" + \"ListViewer with JFace API.\" ; codeLabel . setText ( codeLabelText ) ; codeLabel . setLayoutData ( createGridDataWithSpan ( ) ) ; Link link = new Link ( parent , SWT . NONE ) ; link . setText ( \"See <a>example code</a>\" ) ; link . setLayoutData ( createGridDataWithSpan ( ) ) ; link . addSelectionListener ( new SelectionAdapter ( ) { private final String code = getExampleCode ( ) ; @ Override public void widgetSelected ( final SelectionEvent event ) { String title = \"ListViewer Example Code\" ; HtmlDialog dialog = new HtmlDialog ( parent . getShell ( ) , title , code ) ; dialog . setSize ( 550 , 400 ) ; dialog . open ( ) ; } } ) ; } private GridData createGridDataWithSpan ( ) { GridData gridData = new GridData ( GridData . FILL_HORIZONTAL ) ; gridData . horizontalSpan = 2 ; return gridData ; } private void", "gt": "createPopupMenu ( final Shell parent , final List list )", "prediction": "registerControl ( Composite parent )\n", "label": 1}
{"id": 3720, "input": "<s> package org . ofbiz . widget . menu ; import java . io . IOException ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class MenuFactory { public static final String module = MenuFactory . class . getName ( ) ; public static final UtilCache < String , Map < String , ModelMenu > > menuWebappCache = UtilCache . createUtilCache ( \"widget.menu.webappResource\" , 0 , 0 , false ) ; public static final UtilCache < String , Map < String , ModelMenu > > menuLocationCache = UtilCache . createUtilCache ( \"widget.menu.locationResource\" , 0 , 0 , false ) ; public static ModelMenu getMenuFromWebappContext ( String resourceName , String menuName , HttpServletRequest request ) throws IOException , SAXException , ParserConfigurationException { String webappName = UtilHttp . getApplicationName ( request ) ; String cacheKey = webappName + \"::\" + resourceName ; Map < String , ModelMenu > modelMenuMap = menuWebappCache . get ( cacheKey ) ; if ( modelMenuMap == null ) { synchronized ( MenuFactory . class ) { modelMenuMap = menuWebappCache . get ( cacheKey ) ; if ( modelMenuMap == null ) { ServletContext servletContext = ( ServletContext ) request . getAttribute ( \"servletContext\" ) ; URL menuFileUrl = servletContext . getResource ( resourceName ) ; Document menuFileDoc = UtilXml . readXmlDocument ( menuFileUrl , true , true ) ; modelMenuMap = readMenuDocument ( menuFileDoc , cacheKey ) ; menuWebappCache . put ( cacheKey , modelMenuMap ) ; } } } if ( UtilValidate . isEmpty ( modelMenuMap ) ) { throw new IllegalArgumentException ( \"Could not find menu file in webapp resource [\" + resourceName + \"] in the webapp [\" + webappName + \"]\" ) ; } ModelMenu modelMenu = modelMenuMap . get ( menuName ) ; if ( modelMenu == null ) { throw new IllegalArgumentException ( \"Could not find menu with name [\" + menuName + \"] in webapp resource [\" + resourceName + \"] in the webapp [\" + webappName + \"]\" ) ; } return modelMenu ; } public static Map < String , ModelMenu > readMenuDocument ( Document menuFileDoc , String menuLocation ) { Map < String , ModelMenu > modelMenuMap = new HashMap < String , ModelMenu > ( ) ; if ( menuFileDoc != null ) { Element rootElement = menuFileDoc . getDocumentElement ( ) ; for ( Element menuElement : UtilXml . childElementList ( rootElement , \"menu\" ) ) { ModelMenu modelMenu = new ModelMenu ( menuElement ) ; modelMenu . setMenuLocation ( menuLocation ) ; modelMenuMap . put ( modelMenu . getName ( ) , modelMenu ) ; } } return modelMenuMap ; } @ Deprecated public static Map < String , ModelMenu > readMenuDocument ( Document menuFileDoc , Delegator delegator , LocalDispatcher dispatcher , String menuLocation ) { return readMenuDocument ( menuFileDoc , menuLocation ) ; } public static ModelMenu getMenuFromLocation ( String resourceName , String menuName ) throws IOException , SAXException , ParserConfigurationException { Map < String , ModelMenu > modelMenuMap = menuLocationCache . get ( resourceName ) ; if ( modelMenuMap == null ) { synchronized ( MenuFactory . class ) { modelMenuMap = menuLocationCache . get ( resourceName ) ; if ( modelMenuMap == null ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader == null ) { loader = MenuFactory . class . getClassLoader ( ) ; } URL menuFileUrl = null ; menuFileUrl = FlexibleLocation . resolveLocation ( resourceName ) ; Document menuFileDoc = UtilXml . readXmlDocument ( menuFileUrl , true , true ) ; modelMenuMap = readMenuDocument ( menuFileDoc , resourceName ) ; menuLocationCache", "gt": ". put ( resourceName , modelMenuMap ) ;", "prediction": ". put ( loader , modelMenuMap ) ;\n", "label": 0}
{"id": 16266, "input": "<s> package org . eclipse . jface . viewers ; public interface ITreeContentProvider extends IStructuredContentProvider { public Object [ ] getElements ( Object inputElement ) ; public", "gt": "Object [ ] getChildren ( Object parentElement ) ;", "prediction": "Object [ ] getChildren ( Object inputElement ) ;\n", "label": 1}
{"id": 8266, "input": "<s> package javax . annotation . processing ; import java . lang . annotation . * ; import static java . lang . annotation . RetentionPolicy . * ; import static java . lang . annotation . ElementType . * ; @ Documented @ Target ( TYPE )", "gt": "@ Retention ( RUNTIME ) public @ interface SupportedAnnotationTypes", "prediction": "@ SuppressWarnings ( \"unchecked\" ) public class RetentionPolicy extends RetentionPolicy\n", "label": 0}
{"id": 16279, "input": "<s> package org . restlet . example . book . restlet . ch02 . sec4 . sub2 ; import org . restlet . Application ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . Protocol ; import org . restlet . routing . Router ; public class MailServerApplication extends Application { public static void main ( String [ ] args ) throws Exception { Server mailServer = new Server ( Protocol . HTTP , 8111 ) ; mailServer . setNext ( new MailServerApplication ( ) ) ; mailServer . start ( ) ; } public MailServerApplication ( ) { setName ( \"RESTful Mail Server\" ) ; setDescription ( \"Example for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; } @ Override public Restlet createInboundRoot ( ) { Tracer tracer", "gt": "= new Tracer ( getContext ( ) ) ;", "prediction": "= new Tracer ( ) ;\n", "label": 1}
{"id": 4968, "input": "<s> package com . asakusafw . example . direct . seqfile . jobflow ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . CategorySummary ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . ErrorRecord ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . ItemInfo ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . SalesDetail ; import com . asakusafw . example . direct . seqfile . modelgen . dmdl . model . StoreInfo ; import com . asakusafw . example . direct . seqfile . operator . CategorySummaryOperatorFactory ; import com . asakusafw . example . direct . seqfile . operator . CategorySummaryOperatorFactory . CheckStore ; import com . asakusafw . example . direct . seqfile . operator . CategorySummaryOperatorFactory . JoinItemInfo ; import com . asakusafw . example . direct . seqfile . operator . CategorySummaryOperatorFactory . SetErrorMessage ; import com . asakusafw . example . direct . seqfile . operator . CategorySummaryOperatorFactory . SummarizeByCategory ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . asakusafw . vocabulary . flow . util . CoreOperatorFactory ; @ JobFlow ( name = \"byCategory\" ) public class CategorySummaryJob extends FlowDescription { final In < SalesDetail > salesDetail ; final In < StoreInfo > storeInfo ; final In < ItemInfo > itemInfo ; final Out < CategorySummary > categorySummary ; final Out < ErrorRecord > errorRecord ; public CategorySummaryJob ( @ Import ( name = \"salesDetail\" , description = SalesDetailFromSeqFile . class ) In < SalesDetail > salesDetail , @ Import ( name = \"storeInfo\" , description = StoreInfoFromSeqFile . class ) In < StoreInfo > storeInfo , @ Import ( name = \"itemInfo\" , description = ItemInfoFromSeqFile . class ) In < ItemInfo > itemInfo , @ Export ( name = \"categorySummary\" , description = CategorySummaryToSeqFile . class ) Out < CategorySummary > categorySummary , @ Export ( name = \"errorRecord\" , description = ErrorRecordToCsv . class", "gt": ") Out < ErrorRecord > errorRecord )", "prediction": ") }\n", "label": 0}
{"id": 16288, "input": "<s> package com . rusticisoftware . cheddargetter . client ; import java . util . Date ; import org . w3c . dom . Element ; public class CGItem { protected String id ; protected String code ; protected String name ; protected int quantity ; protected int quantityIncluded ; protected boolean isPeriodic ; protected float overageAmount ; protected Date createdDatetime ; protected Date modifiedDatetime ; public String getId ( ) { return id ; } public String getCode ( ) { return code ; } public String getName ( ) { return name ; } public int getQuantity ( ) { return quantity ; } public int getQuantityIncluded ( ) { return quantityIncluded ; } public boolean isPeriodic ( ) { return isPeriodic ; } public float getOverageAmount ( ) { return overageAmount ; } public Date getCreatedDatetime ( ) { return createdDatetime ; } public Date getModifiedDatetime ( ) { return modifiedDatetime ; } public CGItem ( Element elem ) { this . id = elem . getAttribute ( \"id\" ) ; this . code = elem . getAttribute ( \"code\" ) ; this . name = XmlUtils . getNamedElemValue ( elem , \"name\" ) ; this . quantity = ( Integer ) XmlUtils . getNamedElemValue ( elem , \"quantity\" , Integer . class , 0 ) ; this . quantityIncluded = ( Integer ) XmlUtils . getNamedElemValue ( elem , \"quantityIncluded\" , Integer . class , 0 ) ; this . isPeriodic = ( Boolean ) XmlUtils . getNamedElemValue (", "gt": "elem , \"isPeriodic\" , Boolean . class , false ) ;", "prediction": "elem , \"isPeriodic\" , Integer . class , 0 ) ;\n", "label": 1}
{"id": 9582, "input": "<s> package com . sun . tools . javac . code ; import java . util . LinkedHashMap ; import java . util . Map ; import javax . lang . model . element . AnnotationMirror ; import javax . lang . model . element . AnnotationValue ; import javax . lang . model . element . AnnotationValueVisitor ; import javax . lang . model . type . DeclaredType ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . util . * ; import static com . sun . tools . javac . code . TypeTags . * ; public abstract class Attribute implements AnnotationValue { public Type type ; public Attribute ( Type type ) { this . type = type ; } public abstract void accept ( Visitor v ) ; public Object getValue ( ) { throw new UnsupportedOperationException ( ) ; } public < R , P > R accept ( AnnotationValueVisitor < R , P > v , P p ) { throw new UnsupportedOperationException ( ) ; } public static class Constant extends Attribute { public final Object value ; public void accept ( Visitor v ) { v . visitConstant ( this ) ; } public Constant ( Type type , Object value ) { super ( type ) ; this . value = value ; } public String toString ( ) { return Constants . format ( value , type ) ; } public Object getValue ( ) { return Constants . decode ( value , type ) ; } public < R , P > R accept ( AnnotationValueVisitor < R , P > v , P p ) { if ( value instanceof String ) return v . visitString ( ( String ) value , p ) ; if ( value instanceof Integer ) { int i = ( Integer ) value ; switch ( type . tag ) { case BOOLEAN : return v . visitBoolean ( i != 0 , p ) ; case CHAR : return v . visitChar ( ( char ) i , p ) ; case BYTE : return v . visitByte ( ( byte ) i , p ) ; case SHORT : return v . visitShort ( ( short ) i , p ) ; case INT : return v . visitInt ( i , p ) ; } } switch ( type . tag ) { case LONG : return v . visitLong ( ( Long ) value , p ) ; case FLOAT : return v . visitFloat ( ( Float ) value , p ) ; case DOUBLE : return v . visitDouble ( ( Double ) value , p ) ; } throw new AssertionError ( \"Bad annotation element value: \" + value ) ; } } public static class Class extends Attribute { public final Type type ; public void accept ( Visitor v ) { v . visitClass ( this ) ; } public Class ( Types types , Type type ) { super ( makeClassType ( types , type ) ) ; this . type = type ; } static Type makeClassType ( Types types , Type type ) { Type arg = type . isPrimitive ( ) ? types . boxedClass ( type ) . type : types . erasure ( type ) ; return new Type . ClassType ( types . syms . classType . getEnclosingType ( ) , List . of ( arg ) , types . syms . classType . tsym ) ; } public String toString ( ) { return type + \".class\" ; } public Type getValue ( ) { return type ; } public < R , P > R accept ( AnnotationValueVisitor < R , P > v , P p ) { return v . visitType ( type , p ) ; } } public static class Compound extends Attribute implements AnnotationMirror { public final List < Pair < MethodSymbol , Attribute > > values ; public Compound ( Type type , List < Pair < MethodSymbol , Attribute > > values ) { super ( type ) ; this . values = values ; } public void accept ( Visitor v ) { v . visitCompound ( this ) ; } public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( \"@\" ) ; buf . append ( type ) ; int len = values . length ( ) ; if ( len > 0 ) { buf . append ( '(' ) ; boolean first = true ; for ( Pair < MethodSymbol , Attribute > value : values ) { if ( ! first )", "gt": "buf . append ( \", \" ) ;", "prediction": "\n", "label": 0}
{"id": 16294, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . core . HashOperations ; import org . springframework . data . redis . core . RedisTemplate ; import static org . mockito . Matchers . anyCollection ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisHashTest extends RedisTestSupport { private RedisTemplate redisTemplate ; private HashOperations hashOperations ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { when ( redisTemplate . opsForHash ( ) ) . thenReturn ( hashOperations ) ; JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; hashOperations = mock ( HashOperations . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteHDEL ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"HDEL\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" ) ; verify ( hashOperations ) . delete ( \"key\" , \"field\" ) ; } @ Test public void shouldExecuteHEXISTS ( ) throws Exception { when ( hashOperations . hasKey ( anyString ( ) , anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HEXISTS\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" ) ; verify ( hashOperations ) . hasKey ( \"key\" , \"field\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteHINCRBY ( ) throws Exception { when ( hashOperations . increment ( anyString ( ) , anyString ( ) , anyLong ( ) ) ) . thenReturn ( 1L ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HINCRBY\" , RedisConstants . KEY , \"key\" , RedisConstants . FIELD , \"field\" , RedisConstants . VALUE , \"1\" ) ; verify ( hashOperations ) . increment ( \"key\" , \"field\" , 1L ) ; assertEquals ( 1L , result ) ; } @ Test public void shouldExecuteHKEYS ( ) throws Exception { Set < String > fields = new HashSet < String > ( Arrays . asList ( new String [ ] { \"field1, field2\" } ) ) ; when ( hashOperations . keys ( anyString ( ) ) ) . thenReturn ( fields ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HKEYS\" , RedisConstants . KEY , \"key\" ) ; verify ( hashOperations ) . keys ( \"key\" ) ; assertEquals ( fields , result ) ; } @ Test public void shouldExecuteHMSET ( ) throws Exception { HashMap < String , String > values = new HashMap < String , String > ( ) ; values . put ( \"field1\" , \"value1\" ) ; values . put ( \"field2\" , \"value\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HMSET\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUES , values ) ; verify ( hashOperations ) . putAll ( \"key\" , values ) ; } @ Test public void shouldExecuteHVALS ( ) throws Exception { List < String > values = new ArrayList < String > ( ) ; values . add ( \"val1\" ) ; values . add ( \"val2\" ) ; when ( hashOperations . values ( anyString ( ) ) ) . thenReturn ( values ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HVALS\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUES , values ) ; verify ( hashOperations ) . values ( \"key\" ) ; assertEquals ( values , result ) ; } @ Test public void shouldExecuteHLEN ( ) throws Exception { when ( hashOperations . size ( anyString ( ) ) ) . thenReturn ( 2L ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"HLEN\" , RedisConstants . KEY , \"key\" ) ; verify ( hashOperations ) . size ( \"key\" ) ; assertEquals ( 2L , result ) ; }", "gt": "@ Test public void shouldSetHashValue ( ) throws Exception", "prediction": "@ Test public void shouldExecuteHLW ( ) throws Exception\n", "label": 1}
{"id": 4375, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Shifts ; import org . jjflyboy . tjpeditor . project . ShiftsLimit ; public class ShiftsImpl extends ShiftsResourceImpl implements Shifts { protected EList < ShiftsLimit > limits ; protected ShiftsImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getShifts ( ) ; } public EList < ShiftsLimit > getLimits ( ) { if ( limits == null ) { limits = new EObjectContainmentEList < ShiftsLimit > ( ShiftsLimit . class , this , ProjectPackage . SHIFTS__LIMITS ) ; } return limits ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage . SHIFTS__LIMITS : return ( ( InternalEList < ? > ) getLimits ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SHIFTS__LIMITS : return getLimits ( ) ; } return super . eGet", "gt": "( featureID , resolve , coreType ) ;", "prediction": "( featureID , resolve , coreType ) ;\n", "label": 0}
{"id": 16309, "input": "<s> package org . restlet . example . book . restlet . ch04 . sec5 . sub2 ; import java . io . IOException ; import org . restlet . data . MediaType ; import org . restlet . data . Reference ; import org . restlet . ext . jackson . JacksonRepresentation ; import org . restlet . ext . xstream . XstreamRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . Variant ; import org . restlet . resource . ResourceException ; import org . restlet . resource . ServerResource ; public class MailServerResource extends ServerResource { @ Override protected void doInit ( ) throws ResourceException { getVariants ( ) . add ( new Variant ( MediaType . APPLICATION_XML ) ) ; getVariants ( ) . add ( new Variant ( MediaType . APPLICATION_JSON ) ) ; } @ Override protected Representation get ( Variant variant ) throws ResourceException { Representation result = null ; Mail mail = new Mail ( ) ; mail . setStatus ( \"received\" ) ; mail . setSubject ( \"Message to self\" ) ; mail . setContent ( \"Doh!\" ) ; mail . setAccountRef ( new Reference ( getReference ( ) , \"..\" ) . getTargetRef ( ) . toString ( ) ) ; if ( MediaType . APPLICATION_XML . isCompatible ( variant . getMediaType ( ) ) ) { result = new XstreamRepresentation < Mail > ( mail ) ; } else if ( MediaType . APPLICATION_JSON . isCompatible ( variant . getMediaType ( ) ) ) { result = new JacksonRepresentation <", "gt": "Mail > ( mail ) ;", "prediction": "Mail > ( mail ) ;\n", "label": 1}
