{"id": 7751, "input": "<s> package org . ofbiz . base . config ; import java . io . InputStream ; import java . io . Serializable ; import java . net . URL ; import org . w3c . dom . Document ; public interface ResourceHandler extends Serializable { public String getLoaderName ( ) ; public String getLocation ( ) ; public Document", "gt": "getDocument ( ) throws GenericConfigException ;", "prediction": "getDocument ( ) ;\n", "label": 0}
{"id": 12964, "input": "<s> package fr . inria . zvtm . glyphs . projection ; public class RProjectedCoords extends ProjectedCoords { public int cw , ch ; public", "gt": "int lcw , lch ;", "prediction": "int dw , ch ;\n", "label": 1}
{"id": 5648, "input": "<s> package org . ofbiz . pos . jpos . service ; import java . util . List ; import javolution . util . FastList ; import jpos . services . EventCallbacks ; import jpos . JposException ; import jpos . JposConst ; import jpos . events . DataEvent ; import jpos . events . ErrorEvent ; import jpos . events . DirectIOEvent ; import jpos . events . OutputCompleteEvent ; import jpos . events . StatusUpdateEvent ; import jpos . config . JposEntry ; public class BaseService implements jpos . services . BaseService , jpos . loader . JposServiceInstance { public static final String module = BaseService . class . getName ( ) ; protected static boolean claimed = false ; protected List < Object > eventQueue = FastList . newInstance ( ) ; protected JposEntry entry = null ; protected boolean freezeEvents = false ; protected boolean deviceEnabled = false ; protected boolean eventsEnabled = true ; protected String deviceName = null ; protected String healthText = null ; protected String physicalName = null ; protected String physicalDesc = null ; protected String serviceDesc = null ; protected int serviceVer = 1007000 ; protected int state = JposConst . JPOS_S_CLOSED ; private EventCallbacks ecb = null ; public void open ( String deviceName , EventCallbacks ecb ) throws JposException { this . deviceName = deviceName ; this . ecb = ecb ; this . healthText = \"OK\" ; this . state = JposConst . JPOS_S_IDLE ; this . serviceDesc = entry . getProp ( JposEntry . DEVICE_CATEGORY_PROP_NAME ) . getValueAsString ( ) ; this . physicalDesc = entry . getProp ( JposEntry . PRODUCT_DESCRIPTION_PROP_NAME ) . getValueAsString ( ) ; this . physicalName = entry . getProp ( JposEntry . PRODUCT_NAME_PROP_NAME ) . getValueAsString ( ) ; } public void claim ( int i ) throws JposException { BaseService . claimed = true ; } public void release ( ) throws JposException { BaseService . claimed = false ; } public void close ( ) throws JposException { BaseService . claimed = false ; this . freezeEvents = false ; this . deviceEnabled = false ; this . ecb = null ; this . healthText = \"CLOSED\" ; this . state = JposConst . JPOS_S_CLOSED ; } public String getCheckHealthText ( ) throws JposException { return this . healthText ; } public boolean getClaimed ( ) throws JposException { return BaseService . claimed ; } public int getDataCount ( ) throws JposException { return this . eventQueue . size ( ) ; } public boolean getDataEventEnabled ( ) throws JposException { return this . eventsEnabled ; } public void setDataEventEnabled ( boolean b ) throws JposException { boolean fireEvents = false ; if ( ! this . eventsEnabled && b ) { fireEvents = true ; } this . eventsEnabled = b ; if ( fireEvents ) { this . fireQueuedEvents ( ) ; } } public boolean getDeviceEnabled ( ) throws JposException { return this . deviceEnabled ; } public void setDeviceEnabled ( boolean b ) throws JposException { this . deviceEnabled = b ; } public String getDeviceServiceDescription ( ) throws JposException { return this . serviceDesc ; } public int getDeviceServiceVersion ( ) throws JposException { return this . serviceVer ; } public boolean getFreezeEvents ( ) throws JposException { return this . freezeEvents ; } public void setFreezeEvents ( boolean b ) throws JposException { this . freezeEvents = b ; } public String getPhysicalDeviceDescription ( ) throws JposException { return this . physicalDesc ; } public String getPhysicalDeviceName ( ) throws JposException { return this . physicalName ; } public int getState ( ) throws JposException { return this . state ; } public void checkHealth ( int i ) throws JposException { } public void directIO ( int i , int [ ] ints , Object o ) throws JposException { } public void setEntry ( JposEntry entry ) { this . entry = entry ; } public void deleteInstance ( ) throws JposException { } protected void fireEvent ( Object ev ) { if ( this . eventsEnabled && this . ecb != null ) { if ( ev instanceof DataEvent ) { this . ecb . fireDataEvent ( ( DataEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireDirectIOEvent ( ( DirectIOEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireErrorEvent ( ( ErrorEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireOutputCompleteEvent ( ( OutputCompleteEvent ) ev ) ; } else if ( ev instanceof DirectIOEvent ) { this . ecb . fireStatusUpdateEvent ( ( StatusUpdateEvent ) ev ) ; } } else { this . eventQueue . add ( ev ) ; } } private void fireQueuedEvents ( ) { List < Object > queuedList = new FastList < Object > ( eventQueue ) ; this . eventQueue = FastList", "gt": ". newInstance ( ) ;", "prediction": ";\n", "label": 0}
{"id": 12978, "input": "<s> package org . eclipse . rap . rwt . cluster . test . entrypoints ; import java . io . Serializable ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . service . ISessionStore ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . DND ; import org . eclipse . swt . dnd . DragSource ; import org . eclipse . swt . dnd . DragSourceAdapter ; import org . eclipse . swt . dnd . DragSourceEvent ; import org . eclipse . swt . dnd . DropTarget ; import org . eclipse . swt . dnd . DropTargetAdapter ; import org . eclipse . swt . dnd . DropTargetEvent ; import org . eclipse . swt . dnd . TextTransfer ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Widget ; public class DNDEntryPoint implements IEntryPoint { public static final String ID_SOURCE_LABEL = \"sourceLabel\" ; public static final String ID_TARGET_LABEL = \"targetLabel\" ; private static final String TRANSFER_DATA = \"transfer data\" ; private static final String ATTR_DRAG_FINISHED = \"dragFinished\" ; private static final String ATTR_DROP_FINISHED = \"dropFinished\" ; public static boolean isDragFinished ( ISessionStore sessionStore ) { return Boolean . TRUE . equals ( sessionStore . getAttribute ( ATTR_DRAG_FINISHED ) ) ; } public static boolean isDropFinished ( ISessionStore sessionStore ) { return Boolean . TRUE . equals ( sessionStore . getAttribute ( ATTR_DROP_FINISHED ) ) ; } public int createUI ( ) { Display display = new Display ( ) ; Shell shell = new Shell ( display ) ; Label sourceLabel = new Label ( shell , SWT . NONE ) ; sourceLabel . setText ( \"source label\" ) ; assignWidgetId ( sourceLabel , ID_SOURCE_LABEL ) ; DragSource dragSource = new DragSource ( sourceLabel , DND . DROP_MOVE ) ; dragSource . setTransfer ( new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; dragSource . addDragListener ( new LabelDragSourceListener ( ) ) ; Label targetLabel = new Label ( shell , SWT . NONE ) ; targetLabel . setText ( \"target label\" ) ; assignWidgetId ( targetLabel , ID_TARGET_LABEL ) ; DropTarget dropTarget = new DropTarget ( targetLabel , DND . DROP_MOVE ) ; dropTarget . setTransfer ( new Transfer [ ] { TextTransfer . getInstance ( ) } ) ; dropTarget . addDropListener ( new LabelDropTargetListener ( ) ) ; shell . open ( ) ; return 0 ; } private static void assignWidgetId ( Widget widget , String id ) { widget . setData ( WidgetUtil . CUSTOM_WIDGET_ID , id ) ; } private static class LabelDragSourceListener extends DragSourceAdapter implements Serializable { public void dragSetData ( DragSourceEvent event ) { event . data = TRANSFER_DATA ; } public void dragFinished ( DragSourceEvent event ) { RWT . getSessionStore ( ) . setAttribute ( ATTR_DRAG_FINISHED , Boolean . TRUE ) ; } } private static class LabelDropTargetListener extends DropTargetAdapter implements Serializable { public void drop ( DropTargetEvent event ) { if ( TRANSFER_DATA . equals ( event . data ) ) { RWT . getSessionStore ( )", "gt": ". setAttribute ( ATTR_DROP_FINISHED , Boolean . TRUE ) ;", "prediction": ". setAttribute ( ATTR_DROP_FINISHED , Boolean . TRUE ) ;\n", "label": 1}
{"id": 4847, "input": "<s> package da3 ; enum T3 { ; static int N = 12 ; T3 ( ) {", "gt": "int M = N ;", "prediction": "}\n", "label": 0}
{"id": 12989, "input": "<s> package org . eclipse . ui . internal . cheatsheets . dialogs ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . Dialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . dialogs . TrayDialog ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . IDoubleClickListener ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . LabelProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . SashForm ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Combo ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Text ; import org . eclipse . ui . ISharedImages ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . ITriggerPoint ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . cheatsheets . OpenCheatSheetAction ; import org . eclipse . ui . internal . cheatsheets . CheatSheetPlugin ; import org . eclipse . ui . internal . cheatsheets . ICheatSheetResource ; import org . eclipse . ui . internal . cheatsheets . Messages ; import org . eclipse . ui . internal . cheatsheets . data . ParserStatusUtility ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetCollectionElement ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetCollectionSorter ; import org . eclipse . ui . internal . cheatsheets . registry . CheatSheetElement ; import org . eclipse . ui . internal . cheatsheets . state . DefaultStateManager ; import org . eclipse . ui . internal . cheatsheets . views . CheatSheetView ; import org . eclipse . ui . internal . cheatsheets . views . ViewUtilities ; import org", "gt": ". eclipse . ui . model . BaseWorkbenchContentProvider ;", "prediction": ". eclipse . ui . internal . cheatsheets . widgets . Widget ;\n", "label": 1}
{"id": 9552, "input": "<s> package org . ofbiz . order . shoppingcart ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilNumber ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityFunction ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . util . EntityTypeUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . order . finaccount . FinAccountHelper ; import org . ofbiz . order . order . OrderChangeHelper ; import org . ofbiz . order . order . OrderReadHelper ; import org . ofbiz . order . shoppingcart . product . ProductPromoWorker ; import org . ofbiz . order . shoppingcart . shipping . ShippingEvents ; import org . ofbiz . order . thirdparty . paypal . ExpressCheckoutEvents ; import org . ofbiz . party . contact . ContactHelper ; import org . ofbiz . party . contact . ContactMechWorker ; import org . ofbiz . product . store . ProductStoreWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceUtil ; public class CheckOutHelper { public static final String module = CheckOutHelper . class . getName ( ) ; public static final String resource = \"OrderUiLabels\" ; public static final String resource_error = \"OrderErrorUiLabels\" ; public static final int scale = UtilNumber . getBigDecimalScale ( \"order.decimals\" ) ; public static final int rounding = UtilNumber . getBigDecimalRoundingMode ( \"order.rounding\" ) ; protected LocalDispatcher dispatcher = null ; protected Delegator delegator = null ; protected ShoppingCart cart = null ; public CheckOutHelper ( LocalDispatcher dispatcher , Delegator delegator , ShoppingCart cart ) { this . delegator = delegator ; this . dispatcher = dispatcher ; this . cart = cart ; } public Map < String , Object > setCheckOutShippingAddress ( String shippingContactMechId ) { List < String > errorMessages = new ArrayList < String > ( ) ; Map < String , Object > result ; String errMsg = null ; if ( UtilValidate . isNotEmpty ( this . cart ) ) { errorMessages . addAll ( setCheckOutShippingAddressInternal ( shippingContactMechId ) ) ; } else { errMsg = UtilProperties . getMessage ( resource_error , \"checkhelper.no_items_in_cart\" , ( cart != null ? cart . getLocale ( ) : Locale . getDefault ( ) ) ) ; errorMessages . add ( errMsg ) ; } if ( errorMessages .", "gt": "size ( ) == 1 )", "prediction": "size ( ) > 0 )\n", "label": 0}
{"id": 12997, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . jface . viewers . ILazyContentProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; public class Bug256889TableViewerTest extends ViewerTestCase { private static final int ADD_ENTRIES = 100 ; private static final int PREFETCH_TRESHOLD = 50 ; private static final int MAX_ENTRIES = 205 ; private int rowcounter = 0 ; private List model = new ArrayList ( ) ; private Table table ; private TableViewer tableViewer ; public Bug256889TableViewerTest ( String name ) { super ( name ) ; initModel ( ) ; } protected StructuredViewer createViewer ( Composite parent ) { tableViewer = new TableViewer ( parent , SWT . VIRTUAL | SWT . BORDER | SWT . MULTI ) ; tableViewer . setContentProvider ( new ILazyContentProvider ( ) { public void updateElement ( int index ) { if ( index >= 0 && index < tableViewer . getTable ( ) . getItemCount ( ) ) { if ( index > getModel ( ) . size ( ) - PREFETCH_TRESHOLD && ( getModel ( ) . size ( ) < MAX_ENTRIES ) ) { int approxRecordCount = addElementsToModel ( ) ; System . out . println ( \"approx. record count: \" + approxRecordCount ) ; tableViewer . setItemCount ( approxRecordCount ) ; } if ( index < getModel ( ) . size ( ) ) { tableViewer . replace ( getModel ( ) . get ( index ) , index ) ; } else { System . out . println ( \"invalid index \" + index + \" model count \" + getModel ( ) . size ( ) ) ; } } else { System . out . println ( \"invalid index \" + index + \" tableItemCount \" + tableViewer . getTable ( ) . getItemCount ( ) ) ; } } public void dispose ( ) { } public void inputChanged ( Viewer arg0 , Object arg1 , Object arg2 ) { } } ) ; String [ ] columnProperties = new String [ ] { \"Spalte 1\" , \"Virtual Tables rock\" } ; tableViewer . setColumnProperties ( columnProperties ) ; table = tableViewer . getTable ( ) ; TableColumn col = new TableColumn ( table , SWT . NONE ) ; col . setText ( columnProperties [ 0 ] ) ; col . setWidth ( 200 ) ; col = new TableColumn ( table , SWT . NONE ) ; col . setText ( columnProperties [ 1 ] ) ; col . setWidth ( 400 ) ; table . setHeaderVisible ( true ) ; table . setLinesVisible ( true ) ; tableViewer . setItemCount ( getModel", "gt": "( ) . size ( ) ) ;", "prediction": "( ) . size ( ) ) ;\n", "label": 1}
{"id": 3027, "input": "<s> public class BoundClassError < T extends String &", "gt": "Comparable < BoundClassError > >", "prediction": ">\n", "label": 0}
{"id": 13001, "input": "<s> package org . nuxeo . ecm . platform . preview . adapter . base ; import java . io . IOException ; import java . nio . charset . UnsupportedCharsetException ; import java . util . List ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . impl . blob . ByteArrayBlob ; import org . nuxeo . ecm . platform . preview . api . PreviewException ; public class NoteHtmlPreviewAdapter extends PreprocessedHtmlPreviewAdapter { public NoteHtmlPreviewAdapter ( List < String > fieldsPaths ) { super ( fieldsPaths ) ; } @ Override public List < Blob > getPreviewBlobs ( ) throws PreviewException { List < Blob > blobs = super . getPreviewBlobs ( ) ; if ( ! blobs . isEmpty ( ) ) { Blob blob = blobs . remove ( 0 ) ; Blob newBlob = processNoteBlob ( blob ) ; blobs . add ( 0 , newBlob ) ; } return blobs ; } protected Blob processNoteBlob ( Blob blob ) throws PreviewException { try { String note = blob . getString ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<html><body>\" ) ; sb . append ( note ) ; sb . append ( \"</body></html>\" ) ; byte [ ] bytes = blob . getEncoding ( ) == null ? sb . toString ( ) . getBytes ( ) : sb . toString ( ) . getBytes ( blob . getEncoding ( ) ) ; String", "gt": "mimeType = blob . getMimeType ( ) ;", "prediction": "Builder sb = new StringBuilder ( ) ;\n", "label": 1}
{"id": 4367, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util . links ; import com . sun . javadoc . * ; public abstract class LinkFactory { protected abstract LinkOutput getOutputInstance ( ) ; public LinkOutput getLinkOutput ( LinkInfo linkInfo ) { if ( linkInfo . type != null ) { Type type = linkInfo . type ; LinkOutput linkOutput = getOutputInstance ( ) ; if ( type . isPrimitive ( ) ) { linkInfo . displayLength += type . typeName ( ) . length ( ) ; linkOutput . append ( type . typeName ( ) ) ; } else if ( type . asWildcardType ( ) != null ) { linkInfo . isTypeBound = true ; linkInfo . displayLength += 1 ; linkOutput . append ( \"?\" ) ; WildcardType wildcardType = type . asWildcardType ( ) ; Type [ ] extendsBounds = wildcardType . extendsBounds ( ) ; for ( int i = 0 ; i < extendsBounds . length ; i ++ ) { linkInfo . displayLength += i > 0 ? 2 : 9 ; linkOutput . append ( i > 0 ? \", \" : \" extends \" ) ; setBoundsLinkInfo ( linkInfo , extendsBounds [ i ] ) ; linkOutput . append ( getLinkOutput ( linkInfo ) ) ; } Type [ ] superBounds = wildcardType . superBounds ( ) ; for ( int i = 0 ; i < superBounds . length ; i ++ ) { linkInfo . displayLength += i > 0 ? 2 : 7 ; linkOutput . append ( i > 0 ? \", \" : \" super \" ) ; setBoundsLinkInfo ( linkInfo , superBounds [ i ] ) ; linkOutput . append ( getLinkOutput ( linkInfo ) ) ; } } else if ( type . asTypeVariable ( ) != null ) { linkInfo . isTypeBound = true ; Doc owner = type . asTypeVariable ( ) . owner ( ) ; if ( ( ! linkInfo . excludeTypeParameterLinks ) && owner instanceof ClassDoc ) { linkInfo . classDoc = ( ClassDoc ) owner ; linkInfo . label = type . typeName ( ) ; linkOutput . append ( getClassLink ( linkInfo ) ) ; } else { linkInfo . displayLength += type . typeName ( ) . length ( ) ; linkOutput . append ( type . typeName ( ) ) ; } Type [ ] bounds = type . asTypeVariable ( ) . bounds ( ) ; if ( ! linkInfo . excludeTypeBounds ) { linkInfo . excludeTypeBounds = true ; for ( int i = 0 ; i < bounds . length ; i ++ ) { linkInfo . displayLength += i > 0 ? 2 : 9 ; linkOutput . append ( i > 0 ? \" & \" : \" extends \" ) ; setBoundsLinkInfo ( linkInfo , bounds [ i ] ) ; linkOutput . append ( getLinkOutput ( linkInfo ) ) ; } } } else if ( type . asClassDoc ( ) != null ) { if ( linkInfo . isTypeBound && linkInfo . excludeTypeBoundsLinks ) { linkInfo . displayLength += type . typeName ( ) . length ( ) ; linkOutput . append ( type . typeName ( ) ) ; linkOutput . append ( getTypeParameterLinks ( linkInfo ) ) ; return linkOutput ; } else { linkInfo . classDoc = type . asClassDoc ( ) ; linkOutput = getClassLink ( linkInfo ) ; if ( linkInfo . includeTypeAsSepLink ) { linkOutput . append ( getTypeParameterLinks ( linkInfo , false ) ) ; } } } if ( linkInfo . isVarArg ) { if ( type . dimension ( ) . length ( ) > 2 ) { linkInfo . displayLength += type . dimension ( ) . length ( ) - 2 ; linkOutput . append ( type . dimension ( ) . substring ( 2 ) ) ; } linkInfo . displayLength += 3 ; linkOutput . append ( \"...\" ) ; } else { linkInfo . displayLength += type . dimension ( ) . length ( ) ; linkOutput", "gt": ". append ( type . dimension ( ) ) ;", "prediction": ". append ( getTypeParameterLinks ( linkInfo ) ) ;\n", "label": 0}
{"id": 13008, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . parser ; import org . eclipse . ui . internal . cheatsheets . composite . model . AbstractTask ; import org . w3c . dom . Node ; public interface ITaskParseStrategy { public void init ( ) ; public boolean parseElementNode ( Node childNode , Node parentNode , AbstractTask parentTask , IStatusContainer status ) ; public void parsingComplete ( AbstractTask", "gt": "parentTask , IStatusContainer status ) ;", "prediction": "task ) ;\n", "label": 1}
{"id": 9495, "input": "<s> package org . ofbiz . entityext . eca ; import org . w3c . dom . Element ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . model . ModelUtil ; import java . util . Map ; public class EntityEcaSetField { public static final String module = EntityEcaSetField . class . getName ( ) ; protected String fieldName = null ; protected String envName = null ; protected String value = null ; protected String format = null ; public EntityEcaSetField ( Element set ) { this . fieldName = set . getAttribute ( \"field-name\" ) ; this . envName = set . getAttribute ( \"env-name\" ) ; this . value = set . getAttribute ( \"value\" ) ; this . format = set . getAttribute ( \"format\" ) ; } public void eval ( Map < String , Object > context ) { if ( fieldName != null ) { if ( UtilValidate . isEmpty ( value ) ) { if ( UtilValidate . isNotEmpty ( envName ) && envName . startsWith ( \"${\" ) ) { FlexibleStringExpander exp = FlexibleStringExpander . getInstance ( envName ) ; String s = exp . expandString ( context ) ; if ( UtilValidate . isNotEmpty ( s ) ) { value = s ; } Debug . logInfo ( \"Expanded String: \" + s , module ) ; } } if ( UtilValidate . isNotEmpty ( value ) ) { context . put ( fieldName , this . format ( value , context ) ) ; } else if ( UtilValidate . isNotEmpty ( envName ) && context . get ( envName ) != null ) { context . put ( fieldName , this . format ( ( String ) context . get ( envName ) , context ) ) ; } } } protected Object format ( String s , Map < String , ? extends Object > c ) { if ( UtilValidate . isEmpty ( s ) || UtilValidate . isEmpty ( format ) ) { return s ; } if ( \"append\" . equalsIgnoreCase ( format ) && envName != null ) { StringBuilder newStr = new StringBuilder ( ) ; if ( c . get ( envName ) != null ) { newStr . append ( c . get ( envName ) ) ; } newStr . append ( s ) ; return newStr . toString ( ) ; } if ( \"to-upper\" . equalsIgnoreCase ( format ) ) { return s . toUpperCase ( ) ; } if ( \"to-lower\" . equalsIgnoreCase ( format ) ) { return s . toLowerCase ( ) ; } if ( \"hash-code\" . equalsIgnoreCase ( format ) ) { return", "gt": "Integer . valueOf ( s . hashCode ( ) ) ;", "prediction": "s . toHashCode ( ) ;\n", "label": 0}
{"id": 13011, "input": "<s> package org . eclipse . swt . internal . widgets . menukit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderListener ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; final class MenuLCAUtil { private static final String TYPE = \"rwt.widgets.Menu\" ; private static final String [ ] ALLOWED_STYLES = new String [ ] { \"BAR\" , \"DROP_DOWN\" , \"POP_UP\" , \"NO_RADIO_GROUP\" } ; private static final String PROP_ENABLED = \"enabled\" ; private static final String PROP_MENU_LISTENER = \"menu\" ; private static final String METHOD_UNHIDE_ITEMS = \"unhideItems\" ; static void preserveValues ( Menu menu ) { WidgetLCAUtil . preserveCustomVariant ( menu ) ; preserveProperty ( menu , PROP_ENABLED , menu . getEnabled ( ) ) ; preserveListener ( menu , PROP_MENU_LISTENER , hasMenuListener ( menu ) ) ; WidgetLCAUtil . preserveHelpListener ( menu ) ; } static void renderInitialization ( Menu menu ) { IClientObject clientObject = ClientObjectFactory . getClientObject ( menu ) ; clientObject . create ( TYPE ) ; clientObject . set ( \"style\" , WidgetLCAUtil . getStyles ( menu , ALLOWED_STYLES ) ) ; } static void renderChanges ( Menu menu ) { WidgetLCAUtil . renderCustomVariant ( menu ) ; renderProperty ( menu , PROP_ENABLED , menu . getEnabled ( ) , true ) ; renderListener ( menu , PROP_MENU_LISTENER , hasMenuListener ( menu ) , false ) ; WidgetLCAUtil . renderListenHelp ( menu ) ; } public static void readMenuEvent ( Menu menu ) { if ( WidgetLCAUtil . wasEventSent ( menu , ClientMessageConst . EVENT_MENU_SHOWN ) ) { menu . notifyListeners ( SWT . Show , new Event ( ) ) ; } if ( WidgetLCAUtil . wasEventSent ( menu , ClientMessageConst . EVENT_MENU_HIDDEN ) ) { menu . notifyListeners ( SWT . Hide , new Event ( ) ) ; } } static void renderUnhideItems ( Menu menu ) { if ( WidgetLCAUtil . wasEventSent ( menu , ClientMessageConst . EVENT_MENU_SHOWN ) ) { Boolean reveal = Boolean . valueOf ( menu . getItemCount ( ) > 0 ) ; IClientObject clientObject = ClientObjectFactory . getClientObject ( menu ) ; Map < String , Object > args = new HashMap < String , Object > ( ) ; args . put ( \"reveal\" , reveal ) ; clientObject . call ( METHOD_UNHIDE_ITEMS , args ) ; } } private static boolean hasMenuListener ( Menu menu ) { boolean result = menu . isListening ( SWT . Show ) || menu . isListening ( SWT . Hide ) ; if ( ! result ) { MenuItem [ ] items = menu . getItems ( ) ; for ( int i = 0 ; ! result && i < items . length && ! result ; i ++ ) { result = items [", "gt": "i ] . isListening ( SWT . Arm ) ;", "prediction": "i ] ;\n", "label": 1}
{"id": 2224, "input": "<s> class T6224167 { void printf ( String s , Object [ ] args ) { } void printf ( String s", "gt": ", Object ... args )", "prediction": ", Object [ ] args )\n", "label": 0}
{"id": 13020, "input": "<s> package com . emf4sw . owl . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import com . emf4sw . owl . AnnotatedElement ; import com . emf4sw . owl . Annotation ; import com . emf4sw . owl . AnnotationProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . OWLDatatype ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . rdf . impl . DatatypeImpl ; public class OWLDatatypeImpl extends DatatypeImpl implements OWLDatatype { protected EList < Annotation > annotations ; protected OWLDatatypeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . OWL_DATATYPE ; } public EList < Annotation > getAnnotations ( ) { if ( annotations == null ) { annotations = new EObjectContainmentEList < Annotation > ( Annotation . class , this , OWLPackage . OWL_DATATYPE__ANNOTATIONS ) ; } return annotations ; } public void addAnnotation ( AnnotationProperty property , Object value ) { throw new UnsupportedOperationException ( ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : return ( ( InternalEList < ? > ) getAnnotations ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : return getAnnotations ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ SuppressWarnings ( \"unchecked\" ) @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : getAnnotations ( ) . clear ( ) ; getAnnotations ( ) . addAll ( ( Collection < ? extends Annotation > ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : getAnnotations ( ) . clear ( ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : return annotations != null && ! annotations . isEmpty ( ) ; } return super . eIsSet ( featureID ) ; } @ Override public int eBaseStructuralFeatureID ( int derivedFeatureID , Class < ? > baseClass ) { if ( baseClass == AnnotatedElement . class ) { switch ( derivedFeatureID ) { case OWLPackage . OWL_DATATYPE__ANNOTATIONS : return OWLPackage . ANNOTATED_ELEMENT__ANNOTATIONS ; default : return - 1 ; } } if ( baseClass == DataRange . class ) { switch ( derivedFeatureID ) { default : return - 1 ; } } return super . eBaseStructuralFeatureID ( derivedFeatureID , baseClass ) ; } @ Override public int eDerivedStructuralFeatureID ( int baseFeatureID , Class < ? > baseClass ) { if ( baseClass == AnnotatedElement . class ) { switch ( baseFeatureID ) { case OWLPackage . ANNOTATED_ELEMENT__ANNOTATIONS : return OWLPackage . OWL_DATATYPE__ANNOTATIONS ; default : return - 1 ; } } if ( baseClass == DataRange . class ) { switch ( baseFeatureID ) { default : return - 1 ; } } return super .", "gt": "eDerivedStructuralFeatureID ( baseFeatureID , baseClass ) ;", "prediction": "eDerivedStructuralFeatureID ( baseFeatureID , baseClass ) ;\n", "label": 1}
{"id": 9432, "input": "<s> package org . parboiled . trees ; import org . parboiled . common . ImmutableLinkedList ; import org . parboiled . common . ImmutableList ; import java . util . List ; public class ImmutableGraphNode < T extends GraphNode < T > > implements GraphNode < T > { private final List < T > children ; public ImmutableGraphNode ( ) { this ( null ) ; } public ImmutableGraphNode ( List < T > children ) { this . children = children == null ? ImmutableList . < T > of ( ) : children instanceof ImmutableList ? children : children instanceof ImmutableLinkedList ? children : ImmutableList . copyOf ( children ) ; } public List", "gt": "< T > getChildren ( )", "prediction": "< T > getChildren ( )\n", "label": 0}
{"id": 13022, "input": "<s> package org . puredata . android . io ; import java . io . IOException ; import java . util . Arrays ; import org . puredata . core . PdBase ; import android . content . Context ; public class PdAudio { private static AudioWrapper audioWrapper = null ; private PdAudio ( ) { } public synchronized static void initAudio ( int sampleRate , int inChannels , int outChannels , final int ticksPerBuffer , boolean restart ) throws IOException { if ( isRunning ( ) && ! restart ) return ; if ( ! AudioParameters . checkParameters ( sampleRate , inChannels , outChannels ) || ticksPerBuffer <= 0 ) { throw new IOException ( \"bad audio parameters: \" + sampleRate + \", \" + inChannels + \", \" + outChannels + \", \" + ticksPerBuffer ) ; } stopAudio ( ) ; PdBase . openAudio ( inChannels , outChannels , sampleRate ) ; int bufferSizePerChannel = ticksPerBuffer * PdBase . blockSize ( ) ; audioWrapper = new AudioWrapper ( sampleRate , inChannels , outChannels , bufferSizePerChannel ) { @ Override protected int process ( short [ ] inBuffer , short [ ] outBuffer ) { Arrays . fill ( outBuffer , ( short ) 0 ) ; return PdBase . process ( ticksPerBuffer , inBuffer , outBuffer ) ; } } ; } public synchronized static void startAudio ( Context context ) { if ( audioWrapper == null ) { throw new IllegalStateException ( \"audio not initialized\" ) ; } PdBase . computeAudio ( true ) ; audioWrapper", "gt": ". start ( context ) ;", "prediction": "= null ;\n", "label": 1}
{"id": 2575, "input": "<s> package com . mcbans . mcbans . api ; import com . mcbans . mcbans . BanType ; import org . bukkit . event . Event ; import org . bukkit . event . HandlerList ; import org . bukkit . command . CommandSender ; public class BanEvent extends Event { private static final HandlerList handlers = new HandlerList ( ) ; private String banAdmin ; private String bannedPlayer ; private String bannedPlayerIP ; private String banReason ; private String duration ; private String measure ; private BanType banType ; public BanEvent ( String banAdmin , String bannedPlayer , String playerIP , String banReason , String duration , String measure , BanType banType ) { this . banAdmin = banAdmin ; this . bannedPlayer = bannedPlayer ; this . bannedPlayerIP = playerIP ; this . banReason = banReason ; this . duration = duration ; this . measure = measure ; this . banType = banType ; } @ Override public HandlerList getHandlers ( ) { return handlers ; } public static HandlerList getHandlerList ( ) { return handlers ; } public String getBanAdmin ( ) { return banAdmin ; } public String getBannedPlayer ( ) { return bannedPlayer ; } public String getBannedPlayerIP ( ) { return bannedPlayerIP ; } public String getBanReason ( ) { return banReason ; }", "gt": "public String getTimeDuration ( )", "prediction": "public String getMeasure ( )\n", "label": 0}
{"id": 13024, "input": "<s> package org . restlet . ext . osgi ; import org . osgi . framework . Bundle ; import org . osgi . service . log . LogService ; import org . restlet . resource . Finder ; import org . restlet . resource . ServerResource ; public class DynamicFinder extends Finder { private Bundle bundle ; private String className ; private LogService logService ; private Class < ? extends ServerResource > targetClass ; public DynamicFinder ( Bundle bundle , String className ) { this ( bundle , className , null ) ; } public DynamicFinder ( Bundle bundle , String className , LogService logService ) { if ( bundle == null ) throw new IllegalArgumentException ( \"bundle must not be null\" ) ; if ( className == null ) throw new IllegalArgumentException ( \"className must not be null\" ) ;", "gt": "this . bundle = bundle ;", "prediction": "}\n", "label": 1}
{"id": 10123, "input": "<s> package org . ofbiz . minilang . method . entityops ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class CloneValue extends MethodOperation { private final FlexibleMapAccessor < GenericValue > newValueFma ; private final FlexibleMapAccessor < GenericValue > valueFma ; public CloneValue ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"value-field\" , \"new-value-field\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"value-field\" , \"new-value-field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"value-field\" , \"new-value-field\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } valueFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"value-field\" ) ) ; newValueFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"new-value-field\" ) ) ; }", "gt": "@ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException", "prediction": "return valueFma ;\n", "label": 0}
{"id": 13028, "input": "<s> package org . eclipse . xtext . xdoc . ui . contentassist ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . xtext . * ; import org . eclipse . xtext . ui . editor . contentassist . AbstractJavaBasedContentProposalProvider ; import org . eclipse . xtext . ui . editor . contentassist . ICompletionProposalAcceptor ; import org . eclipse . xtext . ui . editor . contentassist . ContentAssistContext ; @ SuppressWarnings ( \"all\" ) public class AbstractXdocProposalProvider extends AbstractJavaBasedContentProposalProvider { public void completeXdocFile_MainSection ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) ( ( Alternatives ) assignment . getTerminal ( ) ) . getElements ( ) . get ( 0 ) ) , context , acceptor ) ; completeRuleCall ( ( ( RuleCall ) ( ( Alternatives ) assignment . getTerminal ( ) ) . getElements ( ) . get ( 1 ) ) , context , acceptor ) ; completeRuleCall ( ( ( RuleCall ) ( ( Alternatives ) assignment . getTerminal ( ) ) . getElements ( ) . get ( 2 ) ) , context , acceptor ) ; completeRuleCall ( ( ( RuleCall ) ( ( Alternatives ) assignment . getTerminal ( ) ) . getElements ( ) . get ( 3 ) ) , context , acceptor ) ; completeRuleCall ( ( ( RuleCall ) ( ( Alternatives ) assignment . getTerminal ( ) ) . getElements ( ) . get ( 4 ) ) , context , acceptor ) ; } public void completeDocument_Title ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_Subtitle ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_Authors ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_LangDefs ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_Glossary ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_Chapters ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeDocument_Parts ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeGlossary_GlossaryEntry ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completePart_Name ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completePart_Title ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completePart_Chapters ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completePartRef_Part ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { lookupCrossReference ( ( ( CrossReference ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeGlossaryEntry_Name ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeGlossaryEntry_Alias ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeGlossaryEntry_Description ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeChapter_Name ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeChapter_Title ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeChapter_Contents ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeChapter_SubSections ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeChapterRef_Chapter ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { lookupCrossReference ( ( ( CrossReference ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeSection_Name ( EObject model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor ) { completeRuleCall ( ( ( RuleCall ) assignment . getTerminal ( ) ) , context , acceptor ) ; } public void completeSection_Title ( EObject", "gt": "model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor )", "prediction": "model , Assignment assignment , ContentAssistContext context , ICompletionProposalAcceptor acceptor )\n", "label": 1}
{"id": 2454, "input": "<s> package org . xbill . DNS ; import java . io . * ; public class NSECRecord extends Record { private static final long serialVersionUID = - 5165065768816265385L ; private Name next ; private TypeBitmap types ; NSECRecord ( ) { } Record getObject ( ) { return new NSECRecord ( ) ; } public NSECRecord ( Name name , int dclass , long ttl , Name next , int [ ] types ) { super ( name , Type . NSEC , dclass , ttl ) ; this . next = checkName ( \"next\" , next ) ; for ( int i = 0 ; i < types . length ; i ++ ) { Type . check ( types [ i ] ) ; } this . types = new TypeBitmap ( types ) ; } void rrFromWire ( DNSInput in ) throws IOException { next = new Name ( in ) ; types = new TypeBitmap ( in ) ; } void rrToWire ( DNSOutput out , Compression c , boolean canonical ) { next . toWire ( out , null , false ) ; types . toWire ( out ) ; } void rdataFromString ( Tokenizer st , Name origin ) throws IOException { next = st . getName ( origin ) ; types = new TypeBitmap ( st ) ; } String rrToString ( ) { StringBuilder sb = new StringBuilder ( ) ;", "gt": "sb . append ( next ) ;", "prediction": "for ( int i = 0 ;\n", "label": 0}
{"id": 13035, "input": "<s> package org . apache . lucene . search ; public class TopFieldDocs extends TopDocs { public SortField [ ] fields ; public TopFieldDocs ( int totalHits , ScoreDoc [ ] scoreDocs , SortField [ ] fields , float maxScore ) {", "gt": "super ( totalHits , scoreDocs , maxScore ) ;", "prediction": "this . totalHits = totalHits ;\n", "label": 1}
{"id": 9513, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . ecore . EClass ; import org . jjflyboy . tjpeditor . project . Center ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class CenterImpl extends ReportAttributeImpl implements Center { protected CenterImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) {", "gt": "return ProjectPackage . eINSTANCE . getCenter ( ) ;", "prediction": "super ( ) ;\n", "label": 0}
{"id": 13038, "input": "<s> package org . eclipse . rap . examples . pages ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import org . eclipse . jface . viewers . CellLabelProvider ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerCell ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . rap . examples . ExampleUtil ; import org . eclipse . rap . examples . IExamplePage ; import org . eclipse . rap . examples . pages . Elements . Element ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . KeyAdapter ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . ModifyEvent ; import org . eclipse . swt . events . ModifyListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . Text ; public class TableViewerExample implements IExamplePage { private static final int NUMBER = 0 ; private static final int SYMBOL = 1 ; private static final int NAME = 2 ; private static final int SERIES = 3 ; private static final int GROUP = 4 ; private static final int PERIOD = 5 ; private TableViewer viewer ; private Label lblSelection ; private final ElementsFilter viewerFilter ; private final ElementsLabelProvider labelProvider ; private List elements ; private Text txtFilter ; private Label lblHelp ; private TableViewerColumn nrColumn ; private TableViewerColumn symColumn ; private TableViewerColumn nameColumn ; private TableViewerColumn seriesColumn ; private TableViewerColumn groupColumn ; private TableViewerColumn periodColumn ; private static Color [ ] SERIES_COLORS = new Color [ ] { null , Graphics . getColor ( 239 , 41 , 41 ) , Graphics . getColor ( 233 , 185 , 110 ) , Graphics . getColor ( 252 , 233 , 79 ) , Graphics . getColor ( 114 , 159 , 207 ) , Graphics . getColor ( 173 , 127 , 168 ) , Graphics . getColor ( 173 , 127 , 168 ) , Graphics . getColor ( 252 , 175 , 62 ) , Graphics . getColor ( 238 , 238 , 236 ) , Graphics . getColor ( 156 , 159 , 153 ) , Graphics . getColor ( 138 , 226 , 52 ) , } ; public TableViewerExample ( ) { viewerFilter = new ElementsFilter ( ) ; labelProvider = new ElementsLabelProvider ( ) ; } public void createControl ( Composite parent ) { parent . setLayout ( ExampleUtil . createMainLayout ( 1 ) ) ; parent . setLayout ( ExampleUtil . createGridLayout ( 1 , true , true , true ) ) ; parent . setLayoutData ( ExampleUtil . createFillData ( ) ) ; createTextFilter ( parent ) ; createViewer ( parent ) ; createLabelSelection ( parent ) ; createLabelHelp ( parent ) ; viewer . getTable ( ) . forceFocus ( ) ; handleSelection ( true ) ; } private void createTextFilter ( Composite parent ) { txtFilter = new Text ( parent , SWT . BORDER ) ; GridData gridData = ExampleUtil . createHorzFillData ( ) ; txtFilter . setLayoutData ( gridData ) ; txtFilter . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent event ) { Text text = ( Text ) event . widget ; viewerFilter . setText ( text . getText ( ) ) ; viewer . refresh ( ) ; updateLabel ( ) ; } } ) ; txtFilter . addKeyListener ( new KeyAdapter ( ) { @ Override public void keyPressed ( KeyEvent e ) { if ( e . keyCode == 13 || e . keyCode == SWT . ESC || e . keyCode == SWT . ARROW_DOWN ) { handleSelection ( e . keyCode == SWT . ARROW_DOWN ) ; viewer . getTable ( ) . forceFocus ( ) ; } } } ) ; txtFilter . setData ( RWT . ACTIVE_KEYS , new String [ ] { \"ENTER\" , \"ESCAPE\" , \"ARROW_DOWN\" } ) ; } private void createViewer ( Composite parent ) { viewer = new TableViewer ( parent , SWT . BORDER ) ; GridData tableLayoutData = ExampleUtil . createFillData ( ) ; viewer", "gt": ". getTable ( ) . setLayoutData ( tableLayoutData ) ;", "prediction": ". setLayoutData ( tableLayoutData ) ;\n", "label": 1}
{"id": 6883, "input": "<s> package com . matburt . mobileorg . Gui ; import java . util . ArrayList ; import android . app . SearchManager ; import android . content . Intent ; import android . database . Cursor ; import android . os . Bundle ; import com . actionbarsherlock . app . SherlockActivity ; import com . matburt . mobileorg . R ; import com . matburt . mobileorg . Gui . Outline . OutlineAdapter ; import com . matburt . mobileorg . Gui . Outline . OutlineListView ; import com . matburt . mobileorg . OrgData . OrgNode ; import com . matburt . mobileorg . OrgData . OrgProviderUtils ; import com . matburt . mobileorg . util . OrgUtils ; public class SearchActivity extends SherlockActivity { private OutlineListView listView ; private OutlineAdapter listAdapter ; @ Override public void onCreate ( Bundle savedInstanceState ) { OrgUtils . setTheme ( this ) ; super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . search ) ; this . listView = ( OutlineListView ) findViewById ( R . id . search_list ) ; this . listAdapter = ( OutlineAdapter ) listView . getAdapter ( ) ; listAdapter . clear ( ) ; listView . setActivity ( this ) ; Intent intent = getIntent ( ) ; handleIntent ( intent ) ; } @ Override protected void onNewIntent ( Intent intent ) { handleIntent ( intent ) ; } private void handleIntent ( Intent intent ) { if ( Intent . ACTION_VIEW . equals ( intent . getAction ( ) ) ) { } else if ( Intent . ACTION_SEARCH . equals ( intent . getAction ( ) ) ) { String query = intent . getStringExtra ( SearchManager . QUERY ) ; doSearch ( query ) ; } } private void doSearch ( String query ) { Cursor result = OrgProviderUtils . search ( \"%\" + query .", "gt": "trim ( ) + \"%\" , getContentResolver ( ) ) ;", "prediction": "getCursor ( ) ) ;\n", "label": 0}
{"id": 13054, "input": "<s> package org . spliffy . sync . app ; import java . awt . Desktop ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import javax . swing . JOptionPane ; import org . openide . windows . WindowManager ; public class WindowController { private final Desktop desktop ; private final String url ; public WindowController ( String url ) { if ( Desktop . isDesktopSupported ( ) ) { desktop = Desktop . getDesktop ( ) ; } else { desktop = null ; } this . url = url ; } public void hideMain ( ) { WindowManager . getDefault ( ) . getMainWindow ( ) . setVisible ( false ) ; } public void showMain ( ) { WindowManager . getDefault ( ) . getMainWindow ( ) . setVisible ( true ) ; } public void openMediaLounge ( ) { if ( desktop . isSupported ( Desktop . Action . BROWSE ) ) { URI uri = null ; try { uri = new URI ( url ) ; } catch ( URISyntaxException use ) { showError ( \"Sorry, I can't open this web address: \" + url ) ; return ; } try { desktop . browse ( uri ) ; } catch ( IOException ex ) { showError ( \"Can't open: \" + url ) ; } } else { showError (", "gt": "\"Can't open: \" + url ) ;", "prediction": "\"Can't open: \" + url ) ;\n", "label": 1}
{"id": 5380, "input": "<s> import com . sun . mirror . apt . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import com . sun . mirror . util . * ; import java . util . Collection ; import java . util . Set ; import java . util . Arrays ; import java . util . Collections ; public class Dee implements AnnotationProcessorFactory { static class DeeProc implements AnnotationProcessor { DeeProc ( AnnotationProcessorEnvironment ape ) { } public void process ( ) { return ; } } static Collection < String > supportedTypes ; static { String types [ ] = { \"dum\" } ; supportedTypes = Collections . unmodifiableCollection ( Arrays .", "gt": "asList ( types ) ) ;", "prediction": "asList ( types ) ) ;\n", "label": 0}
{"id": 13056, "input": "<s> package org . restlet . ext . oauth ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . restlet . Context ; import org . restlet . ext . oauth . internal . MemClientStore ; public abstract class ClientStoreFactory { private static volatile Class < ? extends ClientStore < ? > > defaultImpl = MemClientStore . class ; private static volatile Object [ ] params = { } ; private static volatile ClientStore < ? > store ; private static volatile Logger log ; private ClientStoreFactory ( ) { } public synchronized static ClientStore < ? > getInstance ( ) { if ( log == null ) { log = Context . getCurrentLogger ( ) ; } if ( store == null ) { Class < ? > [ ] classTypes = new Class [ params . length ] ; int i = 0 ; for ( Object o : params ) { classTypes [ i ++ ] = o . getClass ( ) ; } try { Constructor < ? extends ClientStore < ? > > c = defaultImpl . getConstructor ( classTypes ) ; store = c . newInstance ( params ) ; } catch ( SecurityException e ) { log . log ( Level . SEVERE , \"Failed to", "gt": "initialize OAuth Data backend!\" , e ) ;", "prediction": "initialize ClientStoreFactory\" ) ;\n", "label": 1}
{"id": 8338, "input": "<s> package com . midtro . platform . modules . loader ; public interface LoadTask { void execute ( LoaderCallback callback ) throws Exception ;", "gt": "String getDescription ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13085, "input": "<s> package org . restlet . data ; public class RecipientInfo { private volatile Protocol protocol ; private volatile String comment ; private volatile String name ; public RecipientInfo ( ) { } public RecipientInfo ( Protocol protocol , String name , String agent ) { this . protocol = protocol ; this . name = name ; this . comment = agent ; } public String getComment ( ) { return comment ; } public String getName ( ) { return name ; } public Protocol getProtocol ( ) { return protocol ; } public void setComment ( String comment ) { this . comment = comment ; } public void", "gt": "setName ( String name )", "prediction": "setName ( String name )\n", "label": 1}
{"id": 5383, "input": "<s> package com . deliciousdroid . providers ; import java . text . ParseException ; import java . util . ArrayList ; import org . json . JSONArray ; import org . json . JSONObject ; import com . deliciousdroid . providers . TagContent . Tag ; import com . deliciousdroid . util . DateParser ; import android . net . Uri ; import android . provider . BaseColumns ; import android . util . Log ; public class BookmarkContent { public static class Bookmark implements BaseColumns { public static final Uri CONTENT_URI = Uri . parse ( \"content://\" + BookmarkContentProvider . AUTHORITY + \"/bookmark\" ) ; public static final String CONTENT_TYPE = \"vnd.android.cursor.dir/vnd.deliciousdroid.bookmarks\" ; public static final String Account = \"ACCOUNT\" ; public static final String Description = \"DESCRIPTION\" ; public static final String Url = \"URL\" ; public static final String Notes = \"NOTES\" ; public static final String Tags = \"TAGS\" ; public static final String Hash = \"HASH\" ; public static final String Meta = \"META\" ; public static final String Time = \"TIME\" ; public static final String LastUpdate = \"LASTUPDATE\" ; private int mId = 0 ; private String mAccount = null ; private String mUrl = null ; private String mDescription = null ; private String mNotes = null ; private String mTags = null ; private String mHash = null ; private String mMeta = null ; private Boolean mPrivate = false ; private long mTime = 0 ; private long mLastUpdate = 0 ; public int getId ( ) { return mId ; } public void setId ( int id ) { mId = id ; } public String getUrl ( ) { return mUrl ; } public void setUrl ( String url ) { mUrl = url ; } public String getDescription ( ) { return mDescription ; } public void setDescription ( String desc ) { mDescription = desc ; } public String getNotes ( ) { return mNotes ; } public void setNotes ( String notes ) { mNotes = notes ; } public String getTagString ( ) { return mTags ; } public void setTagString ( String tags ) { mTags = tags ; } public ArrayList < Tag > getTags ( ) { ArrayList < Tag > result = new ArrayList < Tag > ( ) ; for ( String s : this . getTagString ( )", "gt": ". split ( \" \" ) )", "prediction": ")\n", "label": 0}
{"id": 13099, "input": "<s> package org . eclipse . ui . internal . intro ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . intro . IIntroPart ; public interface IIntroDescriptor { IIntroPart createIntro ( ) throws CoreException ;", "gt": "public String getId ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6890, "input": "<s> package pkg ; public interface TestInterfaceForAbstractClass extends TestSuperSuperInterface {", "gt": "public void methodInTestInterfaceForAbstractClass ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13126, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . Weight ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . Similarity ; public class SpanScorer extends Scorer { protected Spans spans ; protected Weight weight ; protected byte [ ] norms ; protected float value ; protected boolean firstTime = true ; protected boolean more = true ; protected int doc ; protected int [ ] sorts = new int [ Scorer . numSort ] ; protected float freq ; protected SpanScorer ( Spans spans , Weight weight , Similarity similarity , byte [ ] norms ) throws IOException { super ( similarity ) ; this . spans = spans ; this . norms = norms ; this . weight = weight ; this . value = weight . getValue ( ) ; if ( this . spans . next ( ) ) { doc = - 1 ; } else { doc = NO_MORE_DOCS ; more = false ; } } public boolean next ( ) throws IOException { return nextDoc ( ) != NO_MORE_DOCS ; } public int nextDoc ( ) throws IOException { if ( ! setFreqCurrentDoc ( ) ) { doc = NO_MORE_DOCS ; } return doc ; } public boolean skipTo ( int target ) throws IOException { return advance ( target ) != NO_MORE_DOCS ; } public int advance ( int target ) throws IOException { if ( ! more ) { return doc = NO_MORE_DOCS ; } if ( spans . doc ( ) < target ) { more = spans . skipTo ( target ) ; } if ( ! setFreqCurrentDoc ( ) ) { doc = NO_MORE_DOCS ; } return doc ; } protected boolean setFreqCurrentDoc ( ) throws IOException { if ( ! more ) { return false ; } doc = spans . doc ( ) ; freq = 0.0f ; do { int matchLength = spans . end ( ) - spans . start ( ) ; freq += getSimilarity ( ) . sloppyFreq ( matchLength ) ; more = spans . next ( ) ; } while ( more && ( doc == spans . doc ( ) ) ) ; return true ; } public int doc ( ) { return doc ; } public int docID ( ) { return doc ; } public float score ( ) throws IOException { float raw = getSimilarity ( ) . tf ( freq ) * value ; return norms == null ? raw : raw * Similarity . decodeNorm ( norms [ doc ] ) ; } public Explanation explain ( final int doc ) throws IOException { Explanation tfExplanation = new Explanation ( ) ; int expDoc = advance ( doc ) ; float phraseFreq", "gt": "= ( expDoc == doc ) ? freq : 0.0f ;", "prediction": "= 0.0f ;\n", "label": 1}
{"id": 10042, "input": "<s> package com . midtro . platform . modules . transition ; import java . awt . AlphaComposite ; import java . awt . Color ; import java . awt . Composite ; import com . midtro . platform . AppGraphics ; import com . midtro . platform . Application ; public class FadeOutTransition implements Transition { private final Color color ; private final float speed ; private float value = 0.0f ; public FadeOutTransition ( Color color , float speed ) { this . color = color ; this . speed = speed / 100 ; } @ Override public void draw ( AppGraphics graphics , Application app ) { final Composite composite = graphics . getComposite ( ) ; graphics . setColor ( color ) ; graphics . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , value ) ) ; graphics . fillRect ( 0 , 0 , app . getSettings ( ) . getWidth ( ) , app . getSettings ( ) . getHeight ( ) ) ; graphics . setComposite ( composite ) ; } @ Override public boolean isComplete ( ) { return value == 1.0f ; } @ Override public void", "gt": "update ( float delta )", "prediction": "draw ( AppGraphics graphics , Application app )\n", "label": 0}
{"id": 13128, "input": "<s> package org . jscsi . target . scsi . inquiry ; import org . jscsi . target", "gt": ". scsi . ISerializable ;", "prediction": ". scsi . query ;\n", "label": 1}
{"id": 3487, "input": "<s> package org . gk . engine . client . logging ; public class SystemLogging implements ILogging { @ Override public void printLog ( Throwable thrown ) { thrown . printStackTrace ( ) ; } @ Override public void pringLog ( String msg ) {", "gt": "System . out . println ( msg ) ;", "prediction": "}\n", "label": 0}
{"id": 13130, "input": "<s> package org . gatein . common . text ; import junit . framework . TestCase ; import org . gatein . common . text . TextTools ; public class TextToolsTestCase extends TestCase { public void testIsAlphaNumeric ( ) { assertForChar ( false , 0 , '0' ) ; assertForChar ( true , '0' , '9' + 1 ) ; assertForChar ( false , '9' + 1 , 'A' ) ; assertForChar ( true , 'A' , 'Z' + 1 ) ; assertForChar ( false , 'Z' + 1 , 'a' ) ; assertForChar ( true , 'a' , 'z' + 1 ) ; assertForChar ( false , 'z' + 1 , 512 ) ; } private void assertForChar ( boolean result , int from , int to ) { while ( from < to ) { assertEquals ( result , TextTools . isAlphaNumeric ( ( char ) ( from ++ ) ) ) ; } } public void testToHex ( ) { assertEquals ( '0' , TextTools . toHex ( 0 ) ) ; assertEquals ( '1' , TextTools . toHex ( 1 ) ) ; assertEquals ( '2' , TextTools . toHex ( 2 ) ) ; assertEquals ( '3' , TextTools . toHex ( 3 ) ) ; assertEquals ( '4' , TextTools . toHex ( 4 ) ) ; assertEquals ( '5' , TextTools . toHex ( 5 ) ) ; assertEquals ( '6' , TextTools . toHex ( 6 ) ) ; assertEquals ( '7' , TextTools . toHex ( 7 ) ) ; assertEquals ( '8' , TextTools . toHex ( 8 ) ) ; assertEquals ( '9' , TextTools . toHex ( 9 ) ) ; assertEquals ( 'A' , TextTools . toHex ( 10 ) ) ; assertEquals ( 'B' , TextTools . toHex ( 11 ) ) ; assertEquals ( 'C' , TextTools . toHex ( 12 ) ) ; assertEquals ( 'D' , TextTools . toHex ( 13 ) ) ; assertEquals ( 'E' , TextTools . toHex ( 14 ) ) ; assertEquals ( 'F' , TextTools . toHex ( 15 ) ) ; for ( int i = 16 ; i < 512 ; i ++ ) { try { TextTools . toHex ( i ) ; fail ( \"Was expecting an IAE at", "gt": "index=\" + i ) ;", "prediction": "0\" ) ;\n", "label": 1}
{"id": 6225, "input": "<s> package org . meqantt . message ; import java . io . IOException ; public class PingRespMessage extends Message { public PingRespMessage ( Header header ) throws IOException { super ( header ) ; } public PingRespMessage ( ) {", "gt": "super ( Type . PINGRESP ) ;", "prediction": "}\n", "label": 0}
{"id": 13149, "input": "<s> package org . eclipse . rap . rwt . osgi . internal ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import java . io . File ; import java . net . URL ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . osgi . service . http . HttpContext ; public class HttpContextWrapper_Test extends TestCase { private HttpContext httpContext ; private HttpContextWrapper contextWrapper ; private File directory ; @ Override protected void setUp ( ) { httpContext = mock ( HttpContext . class ) ; contextWrapper = new HttpContextWrapper ( httpContext ) ; directory = new File ( Fixture . TEMP_DIR , \"directory\" ) ; directory . mkdirs ( ) ; } @ Override protected void tearDown ( ) { Fixture . delete ( directory ) ; } public void testGetResource ( ) throws Exception { File file = new File ( directory , \"test.txt\" ) ; file . createNewFile ( ) ; String fileName = file . getPath ( ) ; URL result = contextWrapper .", "gt": "getResource ( fileName ) ;", "prediction": "getUrl ( fileName ) ;\n", "label": 1}
{"id": 1853, "input": "<s> package com . midtro . platform ; import java . util . concurrent . atomic . AtomicLong ; public class Statistics { private final AtomicLong secondsRunning = new AtomicLong ( 0L ) ; private double averageFrameRate ; private double averageUpdateRate ; private int lastFrameCount ; public double getAverageFrameRate ( ) { return averageFrameRate ; } public void setAverageFrameRate ( final double averageFrameRate ) { this . averageFrameRate = averageFrameRate ; } public double getAverageUpdateRate ( ) { return averageUpdateRate ; } public void setAverageUpdateRate ( final double averageUpdateRate ) { this . averageUpdateRate = averageUpdateRate ; } public AtomicLong getSecondsRunning ( ) { return secondsRunning ; } public int getLastFrameCount ( ) { return lastFrameCount ; } public void", "gt": "setLastFrameCount ( int lastFrameCount )", "prediction": "setLastFrameCount ( final AtomicLong lastFrameCount )\n", "label": 0}
{"id": 13159, "input": "<s> package com . google . code . microlog4android . integration . tests . microlog ; import junit . framework . TestCase ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . LoggerFactory ; import com . google . code . microlog4android . appender . LogCatAppender ; import com . google . code . microlog4android . integration . tests . appender . JunitTestAppender ; import com . google . code . microlog4android . integration . tests . slf4j . Slf4jIntegrationTest ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; public class MicrologIntegrationTest extends TestCase { private JunitTestAppender testAppender ; public void setUp ( ) { testAppender = new JunitTestAppender ( ) ; } public void tearDown ( ) { DefaultLoggerRepository . INSTANCE . reset ( ) ; } private void setTestAppenders ( final Logger logger ) { logger . addAppender ( testAppender ) ; logger . addAppender ( new LogCatAppender ( ) ) ; } public void testGetLogger ( ) { Logger stdLogger = LoggerFactory . getLogger ( Slf4jIntegrationTest . class ) ; setTestAppenders ( stdLogger ) ; stdLogger . debug ( \"microlog integration test logging\" ) ; assertEquals ( 1 , testAppender . getLoggerList ( ) . size ( ) ) ; } public void testDefaultLogLevel ( ) { Logger logger = LoggerFactory . getLogger ( Slf4jIntegrationTest . class ) ; assertTrue ( logger . isDebugEnabled ( ) ) ; assertTrue ( logger", "gt": ". isInfoEnabled ( ) ) ;", "prediction": ". isDebugEnabled ( ) ) ;\n", "label": 1}
{"id": 5982, "input": "<s> package com . deliciousdroid . ui ; import android . text . style . ClickableSpan ; import android . view . View ; public class TagSpan extends ClickableSpan { public interface OnTagClickListener { public void onTagClick ( String tag ) ; } private final String mTag ; private OnTagClickListener mOnTagClickListener ; public TagSpan ( String tag ) { super ( ) ; if ( tag == null ) {", "gt": "throw new NullPointerException ( ) ;", "prediction": "return ;\n", "label": 0}
{"id": 13160, "input": "<s> package org . apache . lucene . search . spans ; import java . io . IOException ; import java . util . Collection ; public abstract class Spans { public abstract boolean next ( ) throws IOException ; public abstract boolean skipTo ( int", "gt": "target ) throws IOException ;", "prediction": "index ) throws IOException ;\n", "label": 1}
{"id": 173, "input": "<s> package org . dawb . workbench . plotting . preference ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . jface . preference . PreferencePage ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Group ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Spinner ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; import uk . ac . diamond . scisoft . analysis . rcp . util . FloatSpinner ; public class FittingPreferencePage extends PreferencePage implements IWorkbenchPreferencePage { public static final String ID = \"org.dawb.workbench.plotting.fittingPreferencePage\" ; private FloatSpinner accuracy ; private Spinner smoothing ; public FittingPreferencePage ( ) { } public FittingPreferencePage ( String title ) { super ( title ) ; } public FittingPreferencePage ( String title , ImageDescriptor image ) { super ( title , image ) ; } @ Override public void init ( IWorkbench workbench ) { setPreferenceStore ( Activator . getDefault ( ) . getPreferenceStore ( ) ) ; } @ Override protected Control createContents ( Composite parent ) { Composite comp = new Composite ( parent , SWT . NONE ) ; comp . setLayout ( new GridLayout ( 1 , false ) ) ; GridData gdc = new GridData ( SWT . FILL , SWT . FILL , true , true ) ; comp . setLayoutData ( gdc ) ; Group algGroup = new Group ( comp , SWT . NONE ) ; algGroup . setLayoutData ( new GridData ( SWT . FILL , SWT . TOP , true , false ) ) ; algGroup . setLayout ( new GridLayout ( 2 , false ) ) ; algGroup . setText ( \"Algorithm Controls\" ) ; Label accuractlab = new Label ( algGroup , SWT . NONE ) ; accuractlab . setText ( \"Accuracy\" ) ; accuractlab . setToolTipText ( \"This sets the accuracy of the optomisation. \" + \"The lower the number to more accurate the calculation\" ) ; accuracy = new FloatSpinner ( algGroup , SWT . NONE , 6 , 5 ) ; accuracy . setLayoutData ( new GridData ( SWT . FILL , SWT . LEFT , true , false ) ) ; Label smoothingLab = new Label ( algGroup , SWT . NONE ) ; smoothingLab . setText ( \"Smoothing\" ) ; smoothingLab . setToolTipText ( \"Smoothing over that many data points will be applied by the peak searching algorithm\" ) ; smoothing = new Spinner ( algGroup , SWT . NONE ) ; smoothing . setLayoutData ( new GridData ( SWT . FILL , SWT . LEFT , true , false ) ) ; smoothing . setDigits ( 0 ) ; smoothing . setMinimum ( 0 ) ; smoothing . setMaximum ( 10000 ) ; initializePage ( ) ; return comp ; } private void initializePage ( ) { accuracy . setDouble ( getAccuracy ( ) ) ; smoothing . setSelection ( getSmoothing ( ) ) ; } @ Override public boolean performOk ( ) { storePreferences ( ) ; return true ; } @ Override protected void performDefaults ( ) { accuracy . setDouble ( getDefaultAccuracy ( ) ) ; smoothing . setSelection ( getDefaultSmoothing ( ) ) ; } private void storePreferences ( ) { setAccuracy ( accuracy . getDouble ( ) ) ; setSmoothing ( smoothing . getSelection ( ) ) ; } private int getDefaultSmoothing ( ) { return getPreferenceStore", "gt": "( ) . getDefaultInt ( FittingConstants . SMOOTHING ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 13168, "input": "<s> package com . cloudera . sqoop . orm ; import java . io . IOException ; import java . util . ArrayList ; import com . cloudera . sqoop . testutil . * ; import org . apache . commons . cli . ParseException ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . NullWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapred . FileInputFormat ; import org . apache . hadoop . mapred . FileOutputFormat ; import org . apache . hadoop . mapred . JobClient ; import org . apache . hadoop . mapred . JobConf ; import com . cloudera . sqoop . SqoopOptions ; import com . cloudera . sqoop . SqoopOptions . InvalidOptionsException ; import com . cloudera . sqoop . config . ConfigurationHelper ; import com . cloudera . sqoop . testutil . ExplicitSetMapper ; import com . cloudera . sqoop . tool . ImportTool ; import com . cloudera . sqoop . util . ClassLoaderStack ; public class TestParseMethods extends ImportJobTestCase { private String [ ] getArgv ( boolean includeHadoopFlags , String fieldTerminator , String lineTerminator , String encloser , String escape , boolean encloserRequired ) { ArrayList < String > args = new ArrayList < String > ( ) ; if ( includeHadoopFlags ) { CommonArgs . addHadoopFlags ( args ) ; } args . add ( \"--table\" ) ; args . add ( getTableName ( ) ) ; args . add ( \"--warehouse-dir\" ) ; args . add ( getWarehouseDir ( ) ) ; args . add ( \"--connect\" ) ; args . add ( HsqldbTestServer . getUrl ( ) ) ; args . add ( \"--as-textfile\" ) ; args . add ( \"--split-by\" ) ; args . add ( \"DATA_COL0\" ) ; args . add ( \"--fields-terminated-by\" ) ; args . add ( fieldTerminator ) ; args . add ( \"--lines-terminated-by\" ) ; args . add ( lineTerminator ) ; args . add ( \"--escaped-by\" ) ; args . add ( escape ) ; if ( encloserRequired ) { args . add ( \"--enclosed-by\" ) ; } else { args . add ( \"--optionally-enclosed-by\" ) ; } args . add ( encloser ) ; args . add ( \"--num-mappers\" ) ; args . add ( \"1\" ) ; return args . toArray ( new String [ 0 ] ) ; } public void runParseTest ( String fieldTerminator , String lineTerminator , String encloser , String escape , boolean encloseRequired ) throws IOException { ClassLoader prevClassLoader = null ; String [ ] argv = getArgv ( true , fieldTerminator , lineTerminator , encloser , escape , encloseRequired ) ; runImport ( argv ) ; try { String tableClassName = getTableName ( ) ; argv = getArgv ( false , fieldTerminator , lineTerminator , encloser , escape , encloseRequired ) ; SqoopOptions opts = new ImportTool ( ) . parseArguments ( argv , null , null , true ) ; CompilationManager compileMgr = new CompilationManager ( opts ) ; String jarFileName = compileMgr . getJarFilename ( ) ; prevClassLoader = ClassLoaderStack . addJarFile ( jarFileName , tableClassName ) ; JobConf job = new JobConf ( ) ; job . setJar ( jarFileName ) ; job . set ( ReparseMapper . USER_TYPE_NAME_KEY , tableClassName ) ; ConfigurationHelper . setJobtrackerAddr ( job , \"local\" ) ; if ( ! BaseSqoopTestCase . isOnPhysicalCluster ( ) ) { job . set ( CommonArgs . FS_DEFAULT_NAME , CommonArgs . LOCAL_FS ) ; } String warehouseDir = getWarehouseDir ( ) ; Path warehousePath = new Path ( warehouseDir ) ; Path inputPath = new Path ( warehousePath , getTableName ( ) ) ; Path outputPath = new Path ( warehousePath , getTableName ( ) + \"-out\" ) ; job . setMapperClass ( ReparseMapper . class ) ; job . setNumReduceTasks ( 0 ) ; FileInputFormat . addInputPath ( job , inputPath ) ; FileOutputFormat . setOutputPath ( job , outputPath ) ; job . setOutputKeyClass ( Text . class ) ; job . setOutputValueClass ( NullWritable . class ) ; JobClient . runJob ( job ) ; } catch ( InvalidOptionsException ioe ) { fail ( ioe . toString ( ) ) ; } catch ( ParseException pe ) { fail ( pe . toString ( ) ) ; } finally { if ( null != prevClassLoader ) { ClassLoaderStack . setCurrentClassLoader ( prevClassLoader ) ; } } } public void testDefaults ( ) throws IOException { String [ ] types = { \"INTEGER\" , \"VARCHAR(32)\" , \"INTEGER\" } ; String [ ] vals = { \"64\" , \"'foo'\" , \"128\" } ; createTableWithColTypes ( types , vals ) ; runParseTest ( \",\" , \"\\\\n\" , \"\\\\\\\"\" , \"\\\\\" , false ) ; } public void testRequiredEnclose ( ) throws IOException { String [ ] types = { \"INTEGER\" , \"VARCHAR(32)\" , \"INTEGER\" } ; String [ ] vals = { \"64\" , \"'foo'\" , \"128\" } ; createTableWithColTypes ( types , vals ) ; runParseTest ( \",\" , \"\\\\n\" , \"\\\\\\\"\" , \"\\\\\" , true ) ; } public void testStringEscapes ( ) throws IOException { String [ ] types = { \"VARCHAR(32)\" , \"VARCHAR(32)\" , \"VARCHAR(32)\" , \"VARCHAR(32)\" , \"VARCHAR(32)\" , } ; String [ ] vals = { \"'foo'\" , \"'foo,bar'\" , \"'foo''bar'\" , \"'foo\\\\bar'\" , \"'foo,bar''baz'\" , } ; createTableWithColTypes ( types , vals ) ; runParseTest ( \",\" , \"\\\\n\" , \"\\\\\\'\" , \"\\\\\" , false ) ; } public void testNumericTypes ( ) throws IOException { String [ ] types = { \"INTEGER\" , \"REAL\" , \"FLOAT\" , \"DATE\" , \"TIME\" , \"TIMESTAMP\" , \"NUMERIC\" , \"BOOLEAN\" , } ; String [ ] vals = { \"42\" , \"36.0\" , \"127.1\" , \"'2009-07-02'\" , \"'11:24:00'\" , \"'2009-08-13", "gt": "20:32:00.1234567'\" , \"92104916282869291837672829102857271948687.287475322\" , \"true\" , }", "prediction": "T00:00:00Z'\" , }\n", "label": 1}
{"id": 4670, "input": "<s> import java . io . * ; import java . util . * ; import javax . lang . model . util . * ; import javax . tools . * ; import com . sun . tools . javac . api . * ; import com . sun . source . tree . * ; import com . sun . source . util . * ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . * ; import com . sun . tools . javac . util . Position ; abstract class Checker { void check ( String ... fileNames ) throws IOException { File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; DiagnosticListener < JavaFileObject > dl = new DiagnosticListener < JavaFileObject > ( ) { public void report ( Diagnostic d ) { System . err . println ( d ) ; if ( d . getKind ( ) == Diagnostic . Kind . ERROR ) errors = true ; new Exception ( ) . printStackTrace ( ) ; } } ; JavacTool tool = JavacTool . create ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( dl , null , null ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( getFiles ( testSrc , fileNames ) ) ; task = tool . getTask ( null , fm , dl , null , null , files ) ; Iterable < ? extends CompilationUnitTree > units = task . parse ( ) ; if ( errors ) throw new AssertionError ( \"errors occurred creating trees\" ) ; ScopeScanner s = new ScopeScanner ( ) ; for ( CompilationUnitTree unit : units ) { TreePath p = new TreePath ( unit ) ; s . scan ( p , getTrees ( ) ) ; } task = null ; if ( errors ) throw new AssertionError ( \"errors occurred checking scopes\" ) ; } protected boolean check ( Scope s , String ref ) { if ( s == null && ( ref == null || ref . trim ( ) . length ( ) == 0 ) ) return true ; if ( s == null ) { error ( s , ref , \"scope missing\" ) ; return false ; } if ( ref == null ) { error ( s , ref , \"scope unexpected\" ) ; return false ; } String local ; String encl ; int semi = ref . indexOf ( ';' ) ; if ( semi == - 1 ) { local = ref ; encl = null ; } else { local = ref . substring ( 0 , semi ) ; encl = ref . substring ( semi + 1 ) ; } return checkLocal ( s , local . trim ( ) ) & check ( s . getEnclosingScope ( ) , encl ) ; } boolean checkLocal (", "gt": "Scope s , String ref )", "prediction": "Scope s , String ref )\n", "label": 0}
{"id": 13181, "input": "<s> package org . restlet . ext . jaxrs . internal . core ; import java . net . URI ; import java . net . URISyntaxException ; import java . security . Principal ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . ws . rs . MatrixParam ; import javax . ws . rs . PathParam ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . Cookie ; import javax . ws . rs . core . EntityTag ; import javax . ws . rs . core . HttpHeaders ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . core . PathSegment ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . Response . ResponseBuilder ; import javax . ws . rs . core . SecurityContext ; import javax . ws . rs . core . UriBuilder ; import javax . ws . rs . core . UriInfo ; import javax . ws . rs . core . Variant ; import org . restlet . Application ; import org . restlet . Request ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . CharacterSet ; import org . restlet . data . Dimension ; import org . restlet . data . Form ; import org . restlet . data . Language ; import org . restlet . data . Reference ; import org . restlet . data . Status ; import org . restlet . data . Tag ; import org . restlet . ext . jaxrs . ExtendedUriBuilder ; import org . restlet . ext . jaxrs . internal . todo . NotYetImplementedException ; import org . restlet . ext . jaxrs . internal . util . Converter ; import org . restlet . ext . jaxrs . internal . util . EmptyIterator ; import org . restlet . ext . jaxrs . internal . util . SecurityUtil ; import org . restlet . ext . jaxrs . internal . util . SortedMetadata ; import org . restlet .", "gt": "ext . jaxrs . internal . util . Util ;", "prediction": "ext . jaxrs . internal . util . Set ;\n", "label": 1}
{"id": 9464, "input": "<s> package org . dawnsci . rcp . functions . classes ; public class Cos720TransferFunction extends AbstractTransferFunction { @ Override public double getPoint ( double value ) { return Math . abs ( Math . cos ( value * Math", "gt": ". PI * 4 ) ) ;", "prediction": ". abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value * Math . abs ( value\n", "label": 0}
{"id": 13187, "input": "<s> package org . eclipse . ui . tests . api ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . tests . TestPlugin ; public class MockAction extends Action { private boolean hasRun = false ; protected MockAction ( String text ) { super ( text ) ; TestPlugin plugin = TestPlugin . getDefault ( ) ; setImageDescriptor ( plugin . getImageDescriptor ( \"anything.gif\" ) ) ; setToolTipText ( text ) ; } protected MockAction ( String text , ImageDescriptor image ) { super ( text , image ) ; setToolTipText ( text ) ; } public void run ( ) { hasRun = true ; } public void clearRun ( ) { hasRun = false ; }", "gt": "public boolean getRun ( )", "prediction": "}\n", "label": 1}
{"id": 6290, "input": "<s> package com . sun . tools . javadoc ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . code . Kinds ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . comp . Enter ; import com . sun . tools . javac . tree . JCTree ; import com . sun . tools . javac . tree . JCTree . * ; import javax . tools . JavaFileObject ; public class JavadocEnter extends Enter { public static JavadocEnter instance0 ( Context context ) { Enter instance = context . get ( enterKey ) ; if ( instance == null ) instance = new JavadocEnter ( context ) ; return ( JavadocEnter ) instance ; } public static void preRegister ( Context context ) { context . put ( enterKey , new Context . Factory < Enter > ( ) { public Enter make ( Context c ) { return new JavadocEnter ( c ) ; } } ) ; } protected JavadocEnter ( Context context ) { super ( context ) ; messager = Messager . instance0 ( context ) ; docenv = DocEnv . instance ( context ) ; } final Messager messager ; final DocEnv docenv ; public void main ( List < JCCompilationUnit > trees ) { int nerrors = messager . nerrors ; super . main ( trees ) ; messager . nwarnings += ( messager . nerrors - nerrors ) ; messager . nerrors = nerrors ; } public void visitTopLevel ( JCCompilationUnit tree ) { super . visitTopLevel ( tree ) ; if ( tree . sourcefile . isNameCompatible ( \"package-info\" , JavaFileObject . Kind . SOURCE ) ) { String comment = tree . docComments . get ( tree ) ; docenv . makePackageDoc ( tree . packge , comment , tree ) ; } } public void visitClassDef ( JCClassDecl tree ) { super . visitClassDef ( tree ) ; if ( tree . sym != null && tree . sym . kind == Kinds . TYP ) { if ( tree . sym == null ) return ; String comment = env . toplevel . docComments . get ( tree ) ; ClassSymbol c = tree . sym ; docenv . makeClassDoc ( c , comment", "gt": ", tree , env . toplevel . lineMap ) ;", "prediction": ", tree ) ;\n", "label": 0}
{"id": 13196, "input": "<s> package org . fuzzydb . server ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import org . fuzzydb . core . LogFactory ; import org . fuzzydb . core . Settings ; import org . fuzzydb . io . packet . layer1 . SocketListeningServer ; import org . fuzzydb . server . internal . server . Database ; import org . fuzzydb . server . internal . server . DatabaseFactory ; import org . fuzzydb . server . services . IndexImplementationsService ; import org . osgi . framework . BundleActivator ; import org . osgi . framework . BundleContext ; import org . osgi . framework . ServiceRegistration ; public class Activator implements BundleActivator { private Database db ; private ServiceRegistration registration ; public void start ( BundleContext context ) throws Exception { Settings config = Settings . getInstance ( ) ; String host = \"127.0.0.1\" ; int port = config . getListenPort ( ) ; try { db = DatabaseFactory . createDatabase ( new SocketListeningServer ( new InetSocketAddress ( host , port ) ) , true ) ; IndexImplementationsService service = db . getIndexImplementationsService ( ) ; registration = context . registerService ( IndexImplementationsService . class . getName ( ) , service , null ) ; db . startServer ( ) ; }", "gt": "catch ( Throwable e )", "prediction": "catch ( Exception e )\n", "label": 1}
{"id": 6656, "input": "<s> package api . son ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; import api . soup . MySoup ; import api . util . CouldNotLoadException ; import com . google . gson . Gson ; import com . google . gson . GsonBuilder ; public class MySon { private final static Gson gson = new GsonBuilder ( ) . registerTypeAdapter ( String . class , new MyStringDeserializer ( ) ) . serializeNulls ( ) . create ( ) ; private static boolean isDebugEnabled = false ; private static String debugString ; public static Object toObject ( String url , Type t ) { long startTime = 0 , endTime = 0 ; if ( isDebugEnabled ) { startTime = System . currentTimeMillis ( ) ; } try { String string = MySoup . scrape ( url ) ; Object o = gson . fromJson ( string , t ) ; if ( isDebugEnabled ) { endTime = System . currentTimeMillis ( ) ; float totalTime = ( endTime - startTime ) / 1000f ; debugString = \"Load Time: \" + String . valueOf ( totalTime ) + \"\\n\\n\" + o . toString ( ) ; } return o ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( \"Couldn't create json object \" + t . toString ( ) ) ; return null ; } } public static Object toObjectFromString ( String string , Type t ) { long startTime = 0 , endTime = 0 ; if ( isDebugEnabled ) { startTime = System . currentTimeMillis ( ) ; } try { Object o = gson . fromJson ( string , t ) ; if ( isDebugEnabled ) { endTime = System . currentTimeMillis ( ) ; float totalTime = ( endTime - startTime ) / 1000f ; debugString = \"Load Time: \" + String . valueOf ( totalTime ) + \"\\n\\n\" + o . toString ( ) ; } return o ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( \"Couldn't create json object \" + t . toString ( ) ) ; return null ; } } public static Object toObjectOther ( String url , Type t ) { String json = null ; try { json = MySoup . scrapeOther ( url ) ; Object o = gson . fromJson ( json , t ) ; return o ; } catch ( CouldNotLoadException e ) {", "gt": "e . printStackTrace ( ) ;", "prediction": "e . printStackTrace ( ) ;\n", "label": 0}
{"id": 13207, "input": "<s> package org . mitre . oauth2 . exception ; public class PermissionDeniedException extends RuntimeException { private static final long serialVersionUID = 1L ; public PermissionDeniedException ( ) { } public PermissionDeniedException ( String message ) { super ( message ) ; }", "gt": "public PermissionDeniedException ( Throwable cause )", "prediction": "}\n", "label": 1}
{"id": 9770, "input": "<s> package org . ofbiz . content . data ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class DataEvents { public static final String module = DataEvents . class . getName ( ) ; public static final String err_resource = \"ContentErrorUiLabels\" ; public static String uploadImage ( HttpServletRequest request , HttpServletResponse response ) { return DataResourceWorker . uploadAndStoreImage ( request , \"dataResourceId\" , \"imageData\" ) ; } public static String serveObjectData ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; HttpSession session = request . getSession ( ) ; GenericValue userLogin = ( GenericValue ) session . getAttribute ( \"userLogin\" ) ; String userAgent = request . getHeader ( \"User-Agent\" ) ; Map < String , Object > httpParams = UtilHttp . getParameterMap ( request ) ; String contentId = ( String ) httpParams . get ( \"contentId\" ) ; if ( UtilValidate . isEmpty ( contentId ) ) { String errorMsg = \"Required parameter contentId not found!\" ; Debug . logError ( errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } String permissionService = UtilProperties . getPropertyValue ( \"content.properties\" , \"stream.permission.service\" , \"genericContentPermission\" ) ; GenericValue content ; try { content = delegator . findOne ( \"Content\" , UtilMisc . toMap ( \"contentId\" , contentId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , e . getMessage ( ) ) ; return \"error\" ; } if ( content == null ) { String errorMsg = \"No content found for Content ID: \" + contentId ; Debug . logError ( errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } String dataResourceId = content . getString ( \"dataResourceId\" ) ; if ( UtilValidate . isEmpty ( dataResourceId ) ) { String errorMsg = \"No Data Resource found for Content ID: \" + contentId ; Debug . logError ( errorMsg , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , errorMsg ) ; return \"error\" ; } GenericValue dataResource ; try { dataResource = delegator . findOne ( \"DataResource\" , UtilMisc . toMap ( \"dataResourceId\" , dataResourceId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; request . setAttribute ( \"_ERROR_MESSAGE_\" , e . getMessage ( ) ) ; return \"error\" ; }", "gt": "if ( dataResource == null )", "prediction": "if ( dataResource == null )\n", "label": 0}
{"id": 13212, "input": "<s> public class Or extends Gate { public Or ( int numInputs , int delay ) { super ( numInputs , delay ) ; } public boolean logic ( ) { boolean result = false ; for ( Signal s : inputSignals ) { result = result", "gt": "|| s . getValue ( ) ;", "prediction": ";\n", "label": 1}
{"id": 780, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . annotations . SuppressNode ; import org . parboiled . support . Var ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class VarFramingTest extends TestNgParboiledTest < Integer > { @ BuildParseTree static class Parser extends BaseParser < Integer > { int count = 1 ; @ SuppressWarnings ( { \"InfiniteRecursion\" } ) public Rule Clause ( ) { Var < Integer > a = new Var < Integer > ( - 1 ) ; return Sequence ( Digits ( ) , a . set ( peek ( ) ) , SomeRule ( a ) , Optional ( '+' , Clause ( ) , push ( a . get ( ) ) ) ) ; } @ SuppressNode public Rule Digits ( ) { return Sequence ( OneOrMore ( CharRange ( '0' , '9' ) ) , push ( Integer . parseInt ( match ( ) ) ) ) ; } public Rule SomeRule ( Var < Integer > var ) { return toRule ( var . get ( ) == count ++ ) ; } } @ Test public void test ( ) { Parser parser = Parboiled . createParser ( Parser . class ) ; Rule rule = parser . Clause ( ) ; ParserStatistics stats = ParserStatistics . generateFor ( rule ) ; assertEquals ( stats . toString ( ) , \"\" + \"Parser statistics for rule 'Clause':\\n\" + \"    Total rules       : 11\\n\" + \"        Actions       : 4\\n\" + \"        Any           : 0\\n\" + \"        CharIgnoreCase: 0\\n\" + \"        Char          : 1\\n\" + \"        Custom        : 0\\n\" + \"        CharRange     : 1\\n\" + \"        AnyOf         : 0\\n\" + \"        Empty         : 0\\n\" + \"        FirstOf       : 0\\n\" + \"        FirstOfStrings: 0\\n\" + \"        Nothing       : 0\\n\" + \"        OneOrMore     : 1\\n\" + \"        Optional      : 1\\n\" + \"        Sequence      : 3\\n\" + \"        String        : 0\\n\" + \"        Test          : 0\\n\" + \"        TestNot       : 0\\n\" + \"        ZeroOrMore    : 0\\n\" + \"\\n\" + \"    Action Classes    : 4\\n\" + \"    ProxyMatchers     : 1\\n\" + \"   ", "gt": "VarFramingMatchers: 1\\n\" + \"MemoMismatchesMatchers: 0\\n\" ) ;", "prediction": "String : 0\\n\" + \"\\n\" + \" Optional : 1\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\n\" + \"\\\n", "label": 0}
{"id": 13221, "input": "<s> package graphics ; import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . FileInputStream ; import java . util . ArrayList ; import java . util . HashMap ; import engine . Engine ; public class SFont { public static final int LEFT = 0 ; public static final int CENTER = 1 ; public static final int RIGHT = 2 ; public static final int NONE = 0 ; public static final int CROP = 1 ; public static final int WRAP = 2 ; private static final Color DEFAULT_COLOR = Color . WHITE ; private static HashMap < String , SFont > cache = new HashMap < String , SFont > ( ) ; Font f ; FontMetrics fm ; public static SFont loadFont ( String fontName ) { return loadFont ( fontName , 24.0f , true ) ; } public static SFont loadFont ( String fontName , float size ) { return loadFont ( fontName , size , true ) ; } public static SFont loadFont ( String fontName , float size , boolean doCache ) { SFont s ; if ( doCache ) { if ( cache . containsKey ( fontName ) ) s = cache . get ( fontName ) ; else { s = new SFont ( fontName , size ) ; cache . put ( fontName , s ) ; } } else s = new SFont ( fontName , size ) ; return s ; } public String [ ] formatIntoLines ( Object s , int wrap , int width ) { String [ ] processed ; processed = s . toString ( ) . split ( \"\\n\" ) ; if ( width < 0 ) return processed ; if ( wrap == 1 ) { for ( int i = 0 ; i < processed . length ; i ++ ) { String line = processed [ i ] . trim ( ) ; int r = line . length ( ) ; String cropped = line . substring ( 0 , r ) ; while ( fm . stringWidth ( cropped ) > width && r > 1 ) { r -- ; cropped = line . substring ( 0 , r ) ; } if ( r < line . length ( ) && r > 1 ) { r -= 3 ; while ( fm . stringWidth ( cropped + \"...\" ) > width && r > 1 ) { r -- ; cropped = line . substring ( 0 , r ) ; } cropped = cropped + \"...\" ; } processed [ i ] = cropped ; } } else if ( wrap == 2 ) { ArrayList < String > lines = new ArrayList < String > ( ) ; int curX = 0 ; String [ ] words = s . toString ( ) . split ( \"\\\\s+\" ) ; String line = \"\" ; for ( String word : words ) { int wordWidth = fm . stringWidth ( word + \" \" ) ; if ( curX + wordWidth >= width ) { lines . add ( line ) ; line = word + \" \" ; curX = wordWidth ; } else { line += word + \" \" ; curX += wordWidth ; } } lines . add ( line ) ; processed = lines . toArray ( new String [ ] { } ) ; } return processed ; } private SFont ( String fontName ) { this ( fontName , 24.0f ) ; } private SFont ( String fontName , float size ) { try { f = Font . createFont ( Font . TRUETYPE_FONT , ( Engine . isRscLoading ) ? getClass ( ) . getResourceAsStream ( \"data/font/\" + fontName + \".ttf\" ) : new FileInputStream ( new File ( \"data/font/\" + fontName + \".ttf\" ) ) ) . deriveFont ( size ) ; fm = new BufferedImage ( 1 , 1 , BufferedImage . TYPE_4BYTE_ABGR ) . getGraphics ( ) . getFontMetrics ( f ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void drawString ( Graphics g , Object text , int x , int y , int alignment , Color c ) { if ( g == null || f == null || text == null ) return ; String s = text . toString ( ) ; if ( alignment == 2 ) x -= fm . stringWidth ( s ) ; else if ( alignment == 1 ) x -= fm . stringWidth ( s ) / 2 ; Color c2 = g . getColor ( ) ; Font fn = g . getFont ( ) ; if ( c != null ) g . setColor ( c ) ; else g . setColor ( DEFAULT_COLOR ) ; g . setFont ( f ) ; g . drawString ( s , x , y ) ; g . setFont ( fn ) ; g . setColor ( c2 ) ; } public void drawString ( Graphics g , Object text , int x , int y ) { drawString ( g , text , x , y , 0 , ( Sprite ) null ) ; } public void drawString ( Graphics g , Object text , int x , int y , int alignment ) { drawString ( g , text , x , y , alignment , ( Color ) null ) ; } public void drawString ( Graphics g , Object text , int x , int y , Sprite anchor ) { drawString ( g , text , x , y , 0 , null , anchor ) ; } public void drawString ( Graphics g , Object text , int x , int y , int alignment , Sprite anchor ) { drawString ( g , text , x , y , alignment , null , anchor ) ; } public void drawString ( Graphics g , Object text , int x , int y , int alignment , Color c , Sprite anchor ) { if ( anchor != null ) { if ( alignment == 2 ) x = ( int ) ( anchor . getX ( ) + anchor . getWidth ( ) - 10 - x ) ; else if ( alignment == 1 ) x = ( int ) ( anchor . getX ( ) + anchor . getWidth ( ) / 2 - x ) ; else x = ( int ) ( anchor .", "gt": "getX ( ) + 10 + x ) ;", "prediction": "getX ( ) + anchor . getWidth ( ) / 2 ) ;\n", "label": 1}
{"id": 1807, "input": "<s> class Pos03 { static class A extends Exception { public void m ( ) { } ; public Object f ; } static class B1 extends A { } static class B2 extends A { } void m ( ) { try { if ( true ) { throw new B1 ( ) ; } else { throw new B2 ( ) ; } } catch ( final B1 | B2 ex ) { ex . m ( ) ;", "gt": "System . out . println ( ex . f ) ;", "prediction": "}\n", "label": 0}
{"id": 13226, "input": "<s> package org . jscsi . parser . datasegment ; public final class SettingEntry { private String scope ; private IResultFunction result ; private String value ; public SettingEntry ( ) { } public final void setResult ( final IResultFunction newResult ) { result = newResult ; } public void setScope ( final String newScope ) { scope = newScope ; } public void setValue ( final String newValue ) { value = newValue ; }", "gt": "public String getScope ( )", "prediction": "}\n", "label": 1}
{"id": 4570, "input": "<s> package org . gk . engine . client . build . layout ; import java . util . List ; import org . gk . engine . client . utils . IRegExpUtils ; import com . extjs . gxt . ui . client . Style . LayoutRegion ; import com . extjs . gxt . ui . client . util . Margins ; import com . extjs . gxt . ui . client . widget . layout . BorderLayoutData ; import com . extjs . gxt . ui . client . widget . layout . LayoutData ; import com . google . gwt . xml . client . Node ; public class XBorderLayoutData extends XLayoutData { private final static String REGION = \"east|west|north|south|center\" ; protected String region ; protected String size , maxSize , minSize ; protected String floatable ; protected String collapsible ; protected String split ; protected String margins ; public XBorderLayoutData ( Node node , List subNodes ) { super ( node , subNodes ) ; region = super . getAttribute ( \"region\" , \"\" ) ; size = super . getAttribute ( \"size\" , \"\" ) ; maxSize = super . getAttribute ( \"maxSize\" , \"\" ) ; minSize = super . getAttribute ( \"minSize\" , \"\" ) ; floatable = super . getAttribute ( \"floatable\" , \"true\" ) ; collapsible = super . getAttribute ( \"collapsible\" , \"false\" ) ; split = super . getAttribute ( \"split\" , \"false\" ) ; margins = super . getAttribute ( \"margins\" , \"\" ) ; } public String getRegion ( ) { return region ; } public String getSize ( ) { return size ; } public String getMaxSize ( ) { return maxSize ; } public String getMinSize ( ) { return minSize ; } public String getFloatable ( ) { return floatable ; } public String getCollapsible ( ) { return collapsible ; } public String getSplit ( ) { return split ; } public String getMargins ( ) { return margins ; } @ Override public LayoutData getLayoutData ( ) { BorderLayoutData bd ; if ( region . matches ( REGION ) ) { bd = new BorderLayoutData ( LayoutRegion . valueOf ( region . toUpperCase ( ) ) ) ; } else { bd = new BorderLayoutData ( LayoutRegion . CENTER ) ; } if ( size . matches ( IRegExpUtils .", "gt": "POSITIVE_FLOAT + \"%?\" ) )", "prediction": "CENTER ) )\n", "label": 0}
{"id": 13227, "input": "<s> package org . eclipse . ui . tests . dynamicplugins ; import org . eclipse . jface . preference . PreferenceManager ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . internal . dialogs . WorkbenchPreferenceNode ; import org . eclipse . ui . internal . registry . IWorkbenchRegistryConstants ; public class PreferencePageTests extends DynamicTestCase { public PreferencePageTests ( String testName ) { super ( testName ) ; } public void testPreferences ( ) { PreferenceManager preferenceManager = PlatformUI . getWorkbench ( ) . getPreferenceManager ( ) ; assertNull ( preferenceManager . find ( \"dynamic.parentPage\" ) ) ; assertNull ( preferenceManager . find ( \"dynamic.parentPage/dynamic.childPage\" ) ) ; getBundle ( ) ; WorkbenchPreferenceNode node = ( WorkbenchPreferenceNode ) preferenceManager . find ( \"dynamic.parentPage\" ) ; assertNotNull ( node ) ; node . createPage ( ) ; node", "gt": "= ( WorkbenchPreferenceNode ) preferenceManager . find ( \"dynamic.parentPage/dynamic.childPage\" ) ;", "prediction": ". setPreferenceManager ( preferenceManager ) ;\n", "label": 1}
{"id": 6217, "input": "<s> package org . ofbiz . service . engine ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . Map ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . serialize . SerializeException ; import org . ofbiz . entity . serialize . XmlSerializer ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; import org . ofbiz . service . config . ServiceConfigUtil ; import org . ofbiz . service . job . GenericServiceJob ; import org . ofbiz . service . job . Job ; import org . ofbiz . service . job . JobManager ; import org . ofbiz . service . job . JobManagerException ; public abstract class GenericAsyncEngine extends AbstractEngine { public static final String module = GenericAsyncEngine . class . getName ( ) ; protected GenericAsyncEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } public abstract Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException ; public abstract void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException ; public void runAsync ( String localName , ModelService modelService , Map < String , Object > context , boolean persist ) throws GenericServiceException { runAsync ( localName , modelService , context , null , persist ) ; } public void runAsync ( String localName , ModelService modelService , Map < String , Object > context , GenericRequester requester , boolean persist ) throws GenericServiceException { DispatchContext dctx = dispatcher . getLocalContext ( localName ) ; Job job = null ; if ( persist ) { if ( dispatcher . getDelegator ( ) == null ) { throw new GenericServiceException ( \"No reference to delegator; cannot run persisted services.\" ) ; } GenericValue jobV = null ; try { String dataId = dispatcher . getDelegator ( ) . getNextSeqId ( \"RuntimeData\" ) ; GenericValue runtimeData = dispatcher . getDelegator ( ) . makeValue ( \"RuntimeData\" , \"runtimeDataId\" , dataId ) ; runtimeData . set ( \"runtimeInfo\" , XmlSerializer . serialize ( context ) ) ; runtimeData . create ( ) ; String authUserLoginId = null ; if ( context . get ( \"userLogin\" ) != null ) { GenericValue userLogin = ( GenericValue )", "gt": "context . get ( \"userLogin\" ) ;", "prediction": "context . get ( \"userLogin\" ) ;\n", "label": 0}
{"id": 13229, "input": "<s> package io . beancounter . commons . cogito . model ; import java . util . ArrayList ; import java . util . Collection ; public class Response { private Collection < Entities > entities = new ArrayList < Entities > ( ) ; private Collection < Relevants > relevants = new ArrayList < Relevants > ( ) ; public Collection < Relevants > getRelevants ( ) { return relevants ; } public void setRelevants ( Collection < Relevants > relevants ) { this . relevants = relevants ; } public Collection < Entities > getEntities ( ) { return entities ; } public void setEntities ( Collection < Entities > entities ) { this . entities = entities ; } public void", "gt": "addEntities ( Entities entities )", "prediction": "setEntities ( Collection < Entities > entities )\n", "label": 1}
{"id": 397, "input": "<s> class TwrOnNonResource { public static void main ( String ... args ) { try ( TwrOnNonResource aonr = new TwrOnNonResource ( ) ) { System . out . println ( aonr . toString ( ) ) ; } try ( TwrOnNonResource aonr = new TwrOnNonResource ( ) ) { System . out . println ( aonr . toString ( ) ) ; } finally { ; } try ( TwrOnNonResource aonr = new TwrOnNonResource ( ) ) { System . out . println ( aonr . toString ( ) ) ; } catch ( Exception e ) { ; } } public void close ( ) { throw new AssertionError (", "gt": "\"I'm not Closable!\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13231, "input": "<s> package fr . inria . zvtm . lens ; public class FSScramblingLens extends FixedSizeLens { protected double a = 0 ; protected double c = 0 ; protected double e = 0 ; double d = 0 ; public FSScramblingLens ( ) { this ( 2.0f , DEFAULT_LR1 , DEFAULT_LR2 , 0 , 0 ) ; } public FSScramblingLens ( float mm , int outerRadius , int innerRadius , int x , int y ) { this . MM = mm ; this . LR1 = outerRadius ; this . LR2 = innerRadius ; updateMagBufferWorkingDimensions ( ) ; a = ( LR1 - LR2 ) / Math . PI ; c = ( MM - 1 ) / 2 ; e = ( 1 + MM ) / 2 ; lx = x ; ly = y ; } public void setOuterRadius ( int r ) { super . setOuterRadius ( r ) ; a = ( LR1 - LR2 ) / Math . PI ; } public void setInnerRadius ( int r ) { super . setInnerRadius ( r ) ; a = ( LR1 - LR2 ) / Math . PI ; } public void setRadii ( int outerRadius , int innerRadius ) { this . setRadii ( outerRadius , innerRadius , true ) ; } public void setRadii ( int outerRadius , int innerRadius , boolean forceRaster ) { super . setRadii ( outerRadius , innerRadius , forceRaster ) ; a = ( LR1 - LR2 ) / Math . PI ; } public void setMMandRadii ( float mm , int outerRadius , int innerRadius ) { this . setMMandRadii ( mm , outerRadius , innerRadius , true ) ; } public void setMMandRadii ( float mm , int outerRadius , int innerRadius , boolean forceRaster ) { super . setMMandRadii ( mm , outerRadius , innerRadius , forceRaster ) ; a = ( LR1 - LR2 ) / Math . PI ; c = ( MM - 1 ) / 2 ; e = ( 1 + MM ) / 2 ; } public void setMaximumMagnification ( float mm ) { this . setMaximumMagnification ( mm , true ) ; } public void setMaximumMagnification (", "gt": "float mm , boolean forceRaster )", "prediction": "float mm )\n", "label": 1}
{"id": 7990, "input": "<s> import java . util . ArrayList ; import java . util . List ; public class MovieStore { private static List < Movie > movies ; public MovieStore ( ) { movies = new ArrayList < Movie > ( 15 ) ; addMovies ( ) ; } private void addMovies ( ) { movies . add ( new Movie ( \"Harry Potter\" , \"Mike Newell\" , 9 ) ) ; movies . add ( new Movie ( \"Tangled\" , \"Byron Howard\" , 8 ) ) ; movies . add ( new Movie ( \"Rio\" , \"Carlos", "gt": "Saldanha\" , 8 ) ) ;", "prediction": "\" , 9 ) ) ;\n", "label": 0}
{"id": 13239, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import com . emf4sw . owl . DataMinCardinality ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataRange ; import com . emf4sw . owl . OWLPackage ; public class DataMinCardinalityImpl extends DataPropertyRestrictionImpl implements DataMinCardinality { protected static final int CARDINALITY_EDEFAULT = 0 ; protected int cardinality = CARDINALITY_EDEFAULT ; protected DataRange dataRange ; protected DataProperty property ; protected DataMinCardinalityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . DATA_MIN_CARDINALITY ; } public int getCardinality ( ) { return cardinality ; } public void setCardinality ( int newCardinality ) { int oldCardinality = cardinality ; cardinality = newCardinality ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY , oldCardinality , cardinality ) ) ; } public DataRange getDataRange ( ) { if ( dataRange != null && dataRange . eIsProxy ( ) ) { InternalEObject oldDataRange = ( InternalEObject ) dataRange ; dataRange = ( DataRange ) eResolveProxy ( oldDataRange ) ; if ( dataRange != oldDataRange ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } } return dataRange ; } public DataRange basicGetDataRange ( ) { return dataRange ; } public void setDataRange ( DataRange newDataRange ) { DataRange oldDataRange = dataRange ; dataRange = newDataRange ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE , oldDataRange , dataRange ) ) ; } public DataProperty getProperty ( ) { if ( property != null && property . eIsProxy ( ) ) { InternalEObject oldProperty = ( InternalEObject ) property ; property = ( DataProperty ) eResolveProxy ( oldProperty ) ; if ( property != oldProperty ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } } return property ; } public DataProperty basicGetProperty ( ) { return property ; } public void setProperty ( DataProperty newProperty ) { DataProperty oldProperty = property ; property = newProperty ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . DATA_MIN_CARDINALITY__PROPERTY , oldProperty , property ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : return getCardinality ( ) ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : if ( resolve ) return getDataRange ( ) ; return basicGetDataRange ( ) ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : if ( resolve ) return getProperty ( ) ; return basicGetProperty ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : setCardinality ( ( Integer ) newValue ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : setDataRange ( ( DataRange ) newValue ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : setProperty ( ( DataProperty ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : setCardinality ( CARDINALITY_EDEFAULT ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : setDataRange ( ( DataRange ) null ) ; return ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : setProperty ( ( DataProperty ) null ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case OWLPackage . DATA_MIN_CARDINALITY__CARDINALITY : return cardinality != CARDINALITY_EDEFAULT ; case OWLPackage . DATA_MIN_CARDINALITY__DATA_RANGE : return dataRange != null ; case OWLPackage . DATA_MIN_CARDINALITY__PROPERTY : return property != null ; } return super . eIsSet ( featureID ) ; } @", "gt": "Override public String toString ( )", "prediction": "Override public boolean eUnset ( int featureID )\n", "label": 1}
{"id": 5934, "input": "<s> package org . remast . swing . dialog ; import java . awt . Frame ; import java . awt . event . ActionEvent ; import javax . swing . AbstractAction ; import javax . swing . Action ; import javax . swing . InputMap ; import javax . swing . JComponent ; import javax . swing . JDialog ; import javax . swing . JRootPane ; import javax . swing . KeyStroke ; @ SuppressWarnings ( \"serial\" ) public class EscapeDialog extends JDialog { public EscapeDialog ( final Frame owner ) { super ( owner , true ) ; } protected JRootPane createRootPane ( ) { final", "gt": "JRootPane rootPane = new JRootPane ( ) ;", "prediction": "JRootPane rootPane = new JRootPane ( ) ;\n", "label": 0}
{"id": 13245, "input": "<s> package org . tinyradius . dictionary ; public interface WritableDictionary extends Dictionary { public void addVendor ( int", "gt": "vendorId , String vendorName ) ;", "prediction": "vendor ) ;\n", "label": 1}
{"id": 1631, "input": "<s> package org . dawb . workbench . plotting . tools ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . dawb . common . ui . plot . region . IROIListener ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . ROIEvent ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . tool . AbstractToolPage ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . workbench . plotting . Activator ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . window . ToolTip ; import org . eclipse . swt . SWT ; import org . eclipse . swt . dnd . Clipboard ; import org . eclipse . swt . dnd . TextTransfer ; import org . eclipse . swt . dnd . Transfer ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . progress . UIJob ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import uk . ac . diamond . scisoft . analysis . rcp . plotting . roi . LinearROIData ; import uk . ac . diamond . scisoft . analysis . rcp . plotting . roi . ROIData ; import uk . ac . diamond . scisoft . analysis . rcp . plotting . roi . RectangularROIData ; import uk . ac . diamond . scisoft . analysis . roi . LinearROI ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import uk . ac . diamond . scisoft . analysis . roi . RectangularROI ; public class MeasurementTool extends AbstractToolPage implements IRegionListener , IROIListener { public class RegionColorListener implements ISelectionChangedListener { private IRegion previousRegion ; private Color previousColor ; @ Override public void selectionChanged ( SelectionChangedEvent event ) { resetSelectionColor ( ) ; final IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( ! ( sel . getFirstElement ( ) instanceof IRegion ) ) return ; final IRegion region = ( IRegion ) sel . getFirstElement ( ) ; previousRegion = region ; previousColor = region != null ? region . getRegionColor ( ) : null ; if ( region != null ) region . setRegionColor ( ColorConstants . red ) ; } private void resetSelectionColor ( ) { if ( previousRegion != null ) previousRegion . setRegionColor ( previousColor ) ; previousRegion = null ; previousColor = null ; } } private static final Logger logger = LoggerFactory . getLogger ( MeasurementTool . class ) ; private Composite composite ; private TableViewer viewer ; private RegionColorListener viewUpdateListener ; private Map < String , ROIBase > dragBounds ; public MeasurementTool ( ) { super ( ) ; dragBounds = new HashMap < String , ROIBase > ( 7 ) ; } @ Override public void createControl ( Composite parent ) { this . composite = new Composite ( parent , SWT . NONE ) ; composite . setLayout ( new FillLayout ( ) ) ; viewer = new TableViewer ( composite , SWT . FULL_SELECTION | SWT . SINGLE | SWT . H_SCROLL | SWT . V_SCROLL | SWT . BORDER ) ; createColumns ( viewer ) ; viewer . getTable ( ) . setLinesVisible ( true ) ; viewer . getTable ( ) . setHeaderVisible ( true ) ; createActions ( ) ; getSite ( ) . setSelectionProvider ( viewer ) ; viewer . setContentProvider ( new IStructuredContentProvider ( ) { @ Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } @ Override public void dispose ( ) { } @ Override public Object [ ] getElements ( Object inputElement ) { final Collection < IRegion > regions = getPlottingSystem ( ) . getRegions ( ) ; if ( regions == null || regions . isEmpty ( ) ) return new Object [ ] { \"-\" } ; final List < IRegion > visible = new ArrayList < IRegion > ( regions . size ( ) ) ; for ( IRegion iRegion : regions ) { if ( iRegion . isVisible ( ) && iRegion . isUserRegion ( ) ) visible . add ( iRegion ) ; } return visible . toArray ( new IRegion [", "gt": "visible . size ( ) ] ) ;", "prediction": "visible . size ( ) ] ) ;\n", "label": 0}
{"id": 13246, "input": "<s> package org . eclipse . ui . internal . contexts ; import org . eclipse . core . expressions . Expression ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . internal . expressions . ActivePartExpression ; import org . eclipse . ui . internal . expressions . WorkbenchWindowExpression ; import org . eclipse . ui . internal . services . IWorkbenchLocationService ; import org . eclipse . ui . services . AbstractServiceFactory ; import org . eclipse . ui . services . IServiceLocator ; public class ContextServiceFactory extends AbstractServiceFactory { public Object create ( Class serviceInterface , IServiceLocator parentLocator , IServiceLocator locator ) { if ( ! IContextService . class . equals ( serviceInterface ) ) { return null ; } IWorkbenchLocationService wls = ( IWorkbenchLocationService ) locator . getService ( IWorkbenchLocationService . class ) ; final IWorkbench wb = wls . getWorkbench ( ) ; if ( wb == null ) { return null ; } Object parent = parentLocator . getService ( serviceInterface ) ; if ( parent == null ) { return null ; } final IWorkbenchWindow window = wls . getWorkbenchWindow ( ) ; final IWorkbenchPartSite site = wls . getPartSite ( ) ; if ( site == null ) { Expression exp = new WorkbenchWindowExpression ( window ) ; return new SlaveContextService ( ( IContextService ) parent , exp ) ; } if ( parent instanceof SlaveContextService ) { Expression exp = ( ( SlaveContextService ) parent ) . fDefaultExpression ; if ( exp instanceof ActivePartExpression ) { return new NestableContextService ( ( IContextService ) parent , exp ) ; } } Expression exp = new ActivePartExpression ( site . getPart ( ) ) ; return new SlaveContextService ( (", "gt": "IContextService ) parent , exp ) ;", "prediction": "IContextService ) parent , exp ) ;\n", "label": 1}
{"id": 1654, "input": "<s> package com . sun . tools . doclets . formats . html ; import java . io . * ; import com . sun . javadoc . * ; import com . sun . tools . doclets . formats . html . markup . * ; import com . sun . tools . doclets . internal . toolkit . * ; public class AnnotationTypeRequiredMemberWriterImpl extends AbstractMemberWriter implements AnnotationTypeRequiredMemberWriter , MemberSummaryWriter { public AnnotationTypeRequiredMemberWriterImpl ( SubWriterHolderWriter writer , AnnotationTypeDoc annotationType ) { super ( writer , annotationType ) ; } public Content getMemberSummaryHeader ( ClassDoc classDoc , Content memberSummaryTree ) { memberSummaryTree . addContent ( HtmlConstants . START_OF_ANNOTATION_TYPE_REQUIRED_MEMBER_SUMMARY ) ; Content memberTree = writer . getMemberTreeHeader ( ) ; writer . addSummaryHeader ( this , classDoc , memberTree ) ; return memberTree ; } public void addAnnotationDetailsTreeHeader ( ClassDoc classDoc , Content memberDetailsTree ) { if ( ! writer . printedAnnotationHeading ) { memberDetailsTree . addContent ( writer . getMarkerAnchor ( \"annotation_type_element_detail\" ) ) ; Content heading = HtmlTree . HEADING ( HtmlConstants . DETAILS_HEADING , writer . annotationTypeDetailsLabel ) ; memberDetailsTree . addContent ( heading ) ; writer . printedAnnotationHeading = true ; } } public Content getAnnotationDocTreeHeader ( MemberDoc member , Content annotationDetailsTree ) { annotationDetailsTree . addContent ( writer . getMarkerAnchor ( member . name ( ) + ( ( ExecutableMemberDoc ) member ) . signature ( ) ) ) ; Content annotationDocTree = writer . getMemberTreeHeader ( ) ; Content heading = new HtmlTree ( HtmlConstants . MEMBER_HEADING ) ; heading . addContent ( member . name ( ) ) ; annotationDocTree . addContent ( heading ) ; return annotationDocTree ; } public Content getSignature ( MemberDoc member ) { Content pre = new HtmlTree ( HtmlTag . PRE ) ; writer . addAnnotationInfo ( member , pre ) ; addModifiers ( member , pre ) ; Content link = new RawHtml ( writer . getLink ( new LinkInfoImpl ( LinkInfoImpl . CONTEXT_MEMBER , getType ( member ) ) ) ) ; pre . addContent ( link ) ; pre . addContent ( writer . getSpace ( ) ) ; if ( configuration ( ) . linksource ) { Content memberName = new StringContent ( member . name ( ) ) ; writer . addSrcLink ( member , memberName , pre ) ; } else { addName ( member . name ( ) , pre ) ; } return pre ; } public void addDeprecated ( MemberDoc member , Content annotationDocTree ) { addDeprecatedInfo ( member , annotationDocTree ) ; } public void addComments ( MemberDoc member , Content annotationDocTree ) { addComment ( member , annotationDocTree ) ; } public void addTags ( MemberDoc member , Content annotationDocTree ) { writer . addTagsInfo ( member , annotationDocTree ) ; } public Content getAnnotationDetails ( Content annotationDetailsTree ) { return getMemberTree ( annotationDetailsTree ) ; } public Content getAnnotationDoc ( Content annotationDocTree , boolean isLastContent ) { return getMemberTree ( annotationDocTree , isLastContent ) ; } public void close ( ) throws IOException { writer . close ( ) ; } public void addSummaryLabel ( Content memberTree ) { Content label = HtmlTree . HEADING ( HtmlConstants . SUMMARY_HEADING , writer . getResource ( \"doclet.Annotation_Type_Required_Member_Summary\" ) ) ; memberTree . addContent ( label ) ; } public String getTableSummary ( ) { return configuration ( ) . getText ( \"doclet.Member_Table_Summary\" , configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Member_Summary\" ) , configuration ( ) . getText ( \"doclet.annotation_type_required_members\" ) ) ; } public String getCaption ( ) { return configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Members\" ) ; } public String [ ] getSummaryTableHeader ( ProgramElementDoc member ) { String [ ] header = new String [ ] { writer . getModifierTypeHeader ( ) , configuration ( ) . getText ( \"doclet.0_and_1\" , configuration ( ) . getText ( \"doclet.Annotation_Type_Required_Member\" ) , configuration ( ) . getText ( \"doclet.Description\" ) ) } ; return header ; } public void addSummaryAnchor ( ClassDoc cd , Content memberTree ) { memberTree . addContent ( writer . getMarkerAnchor ( \"annotation_type_required_element_summary\" ) ) ; } public void addInheritedSummaryAnchor ( ClassDoc cd , Content inheritedTree ) { } public void addInheritedSummaryLabel ( ClassDoc cd , Content inheritedTree ) { } protected void addSummaryLink ( int context , ClassDoc cd , ProgramElementDoc member , Content tdSummary ) { Content strong = HtmlTree . STRONG ( new RawHtml ( writer . getDocLink ( context , ( MemberDoc ) member , member . name ( ) , false ) ) ) ; Content code = HtmlTree . CODE ( strong ) ; tdSummary . addContent ( code ) ; } protected void addInheritedSummaryLink", "gt": "( ClassDoc cd , ProgramElementDoc member , Content linksTree )", "prediction": "( int context , ClassDoc cd , ProgramElementDoc member , Content tdSummary )\n", "label": 0}
{"id": 13249, "input": "<s> package org . eclipse . ui . contexts ; public interface IContextListener {", "gt": "void contextChanged ( ContextEvent contextEvent ) ;", "prediction": "}\n", "label": 1}
{"id": 4180, "input": "<s> import org . junit . * ; import java . util . * ; import play . test . * ; import models . * ; public class BasicTest extends UnitTest { @ Before public void setup ( ) { Fixtures . deleteAll ( ) ; } @ Test public void createAndRetrieveUser ( ) { new User ( \"bob@gmail.com\" , \"secret\" , \"Bob\" ) . save ( ) ; User bob = User . find ( \"byEmail\" , \"bob@gmail.com\" ) . first ( ) ; assertNotNull ( bob ) ; assertEquals ( \"Bob\" , bob . fullname ) ; } @ Test public void tryConnectAsUser ( ) { new User ( \"bob@gmail.com\" , \"secret\" , \"Bob\" ) . save ( ) ; assertNotNull ( User . connect ( \"bob@gmail.com\" , \"secret\" ) ) ; assertNull ( User . connect ( \"bob@gmail.com\" , \"badpassword\" ) ) ; assertNull ( User . connect ( \"tom@gmail.com\" , \"secret\" ) ) ; } @ Test public void createPost ( ) { User bob = new User ( \"bob@gmail.com\" , \"secret\" , \"Bob\" ) . save ( ) ; new Post ( bob , \"My first post\" , \"Hello world\" ) . save ( ) ; assertEquals ( 1 , Post . count ( ) ) ; List < Post > bobPosts = Post . find ( \"byAuthor\" , bob ) . fetch ( ) ; assertEquals ( 1 , bobPosts . size ( ) ) ; Post firstPost = bobPosts . get ( 0 ) ; assertNotNull ( firstPost ) ; assertEquals ( bob , firstPost . author ) ; assertEquals ( \"My first post\" , firstPost . title ) ; assertEquals ( \"Hello world\" , firstPost . content ) ; assertNotNull ( firstPost . postedAt ) ; } @ Test public void postComments ( ) { User bob = new User ( \"bob@gmail.com\" , \"secret\" , \"Bob\" ) . save ( ) ; Post bobPost = new Post ( bob , \"My first post\" , \"Hello world\" ) . save ( ) ; new Comment ( bobPost , \"Jeff\" , \"Nice post\" ) . save ( ) ; new Comment ( bobPost , \"Tom\" , \"I knew that !\" ) . save ( ) ; List < Comment > bobPostComments = Comment . find ( \"byPost\" , bobPost ) . fetch ( ) ; assertEquals ( 2 , bobPostComments . size ( ) ) ; Comment firstComment = bobPostComments . get ( 0 ) ; assertNotNull ( firstComment ) ; assertEquals ( \"Jeff\" , firstComment . author ) ; assertEquals ( \"Nice post\" , firstComment . content ) ; assertNotNull ( firstComment . postedAt ) ; Comment secondComment = bobPostComments . get ( 1 ) ; assertNotNull ( secondComment ) ; assertEquals ( \"Tom\" , secondComment . author ) ; assertEquals ( \"I knew that !\" , secondComment . content ) ; assertNotNull ( secondComment . postedAt ) ; } @ Test public void useTheCommentsRelation ( ) { User bob = new User ( \"bob@gmail.com\" , \"secret\" , \"Bob\" ) . save ( ) ; Post bobPost = new Post ( bob , \"My first post\" , \"Hello world\" ) . save ( ) ; bobPost . addComment ( \"Jeff\" , \"Nice post\" ) ; bobPost . addComment ( \"Tom\" , \"I knew that !\" ) ; assertEquals ( 1 , User . count ( ) ) ; assertEquals ( 1 , Post . count ( ) ) ; assertEquals ( 2 , Comment . count ( ) ) ; bobPost = Post . find ( \"byAuthor\" , bob ) . first ( ) ; assertNotNull ( bobPost ) ; assertEquals ( 2 , bobPost . comments . size ( ) ) ; assertEquals ( \"Jeff\" , bobPost . comments . get ( 0 ) . author ) ; bobPost . delete ( ) ; assertEquals ( 1 , User . count ( ) ) ; assertEquals ( 0 , Post . count ( ) ) ; assertEquals ( 0 , Comment . count ( ) ) ; } @ Test public void fullTest ( ) { Fixtures . load ( \"data.yml\" ) ; assertEquals ( 2 , User . count ( ) ) ; assertEquals ( 3 , Post . count ( ) ) ; assertEquals ( 3 , Comment . count ( ) ) ; assertNotNull ( User . connect ( \"bob@gmail.com\" , \"secret\" ) ) ; assertNotNull ( User . connect ( \"jeff@gmail.com\" , \"secret\" ) ) ; assertNull ( User . connect ( \"jeff@gmail.com\" , \"badpassword\" ) ) ; assertNull ( User . connect ( \"tom@gmail.com\" , \"secret\" ) ) ; List < Post > bobPosts = Post . find ( \"author.email\" , \"bob@gmail.com\" ) . fetch ( ) ; assertEquals ( 2", "gt": ", bobPosts . size ( ) ) ;", "prediction": ", User . count ( ) ) ;\n", "label": 0}
{"id": 13250, "input": "<s> package org . gatein . common . logging ; class SimpleLogger extends Logger { private final org . slf4j . Logger delegate ; public SimpleLogger ( org . slf4j . Logger delegate ) { this . delegate = delegate ; } @ Override protected void doLog ( LogLevel level , Object msg , Object [ ] argArray , Throwable throwable ) { level . log", "gt": "( delegate , msg , throwable ) ;", "prediction": "( level , msg , argArray , throwable ) ;\n", "label": 1}
{"id": 2253, "input": "<s> package LizaCraft ; import java . lang . reflect . Field ; import net . minecraft . server . MinecraftServer ; import net . minecraft . server . ThreadServerApplication ; import org . bukkit . craftbukkit . CraftServer ; public class ServerGrabber { private static final String MINECRAFT_SERVER_THREAD_NAME = \"Server thread\" ; private static final String MINECRAFT_SERVER_FIELD_NAME = \"a\" ; protected CraftServer searchThreads ( ) { Thread [ ] threads ; ThreadServerApplication tsa = null ; while ( tsa == null ) { threads = this . getThreads ( ) ; tsa = getThreadServerApplication ( threads ) ; } MinecraftServer minecraftServer = getMinecraftServer ( tsa ) ; return minecraftServer . server ; } private MinecraftServer getMinecraftServer ( ThreadServerApplication serverThread ) { Class < ? extends ThreadServerApplication > serverThreadClass = serverThread . getClass ( ) ; Field minecraftServerField ; MinecraftServer minecraftServer = null ; try { minecraftServerField = serverThreadClass . getDeclaredField ( MINECRAFT_SERVER_FIELD_NAME ) ; minecraftServerField . setAccessible ( true ) ; minecraftServer = ( MinecraftServer ) minecraftServerField . get ( serverThread ) ; minecraftServerField . setAccessible ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return minecraftServer ; } private ThreadServerApplication getThreadServerApplication ( Thread [ ] threads ) { ThreadServerApplication serverThread = null ; for ( Thread t : threads ) { if ( t != null && t . getName ( ) != null && t . getName ( ) . equals ( MINECRAFT_SERVER_THREAD_NAME ) ) { serverThread = ( ThreadServerApplication ) t ; break ; } } return serverThread ; } private Thread [ ] getThreads ( ) { ThreadGroup rootGroup = Thread . currentThread ( ) . getThreadGroup ( ) ; while ( rootGroup . getParent ( ) != null ) { rootGroup = rootGroup . getParent ( ) ; } Thread threads [ ] = new Thread [ rootGroup . activeCount ( ) ] ; while ( rootGroup . enumerate", "gt": "( threads , true ) >= threads . length )", "prediction": "( ) )\n", "label": 0}
{"id": 13257, "input": "<s> package org . restlet . ext . rdf ; import org . restlet . data . Reference ; public class GraphBuilder extends GraphHandler { private Graph linkSet ; public GraphBuilder ( Graph linkSet ) { super ( ) ; this . linkSet = linkSet ; } @ Override public void link ( Graph source , Reference typeRef , Literal target ) { if ( source != null && typeRef != null && target != null ) { this . linkSet . add ( source , typeRef , target ) ; } } @ Override public void link ( Graph source , Reference typeRef , Reference target ) { if ( source != null && typeRef != null && target != null ) { this . linkSet . add ( source", "gt": ", typeRef , target ) ;", "prediction": ", typeRef , target ) ;\n", "label": 1}
{"id": 1180, "input": "<s> import java . util . * ; class T6638712a { < T > Comparator < T > compound ( Iterable < ? extends Comparator < ? super T > > it ) { return null ; } public void test ( List < Comparator < ? > > x ) {", "gt": "Comparator < String > c3 = compound ( x ) ;", "prediction": "Comparator < ? extends Comparator < ? super T > > it = new Comparator < ? super T > ( ) ;\n", "label": 0}
{"id": 13263, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import com . google . gwt . core . client . GWT ; import com . google . gwt . resources . client . ResourcePrototype ; public class TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator implements org . restlet . example . book . restlet . ch09 . client . TopPanel_BinderImpl_GenBundle { private static TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator _instance0 = new TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator ( ) ; private void logoInitializer ( ) { logo = new com . google . gwt . resources . client . impl . ImageResourcePrototype ( \"logo\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( externalImage ) , 0 , 0 , 140 , 75 , false , false ) ; } private static class logoInitializer { static { _instance0 . logoInitializer ( ) ; } static com . google . gwt . resources . client . ImageResource get ( ) { return logo ; } } public com . google . gwt . resources . client . ImageResource logo ( ) { return logoInitializer . get ( ) ; } private void logoIe6DataInitializer ( ) { logoIe6Data = new com . google . gwt . resources . client . impl . DataResourcePrototype ( \"logoIe6Data\" , com . google . gwt . safehtml . shared . UriUtils . fromTrustedString ( \"data:image/gif;base64,R0lGODlhjABLAPf/AMRwk5QOSco+RNCVrMLCwsgzOrg9QsbGxunp6dRdZOzs7GiOoN7e3uHh4dbW1vTX2PVIfBtgedDQ0PHx8K9MdtnZ2dFWWvfIuK1phOKWep2dndiHlOrq6s9OVIuLi+e9xf3i1+7u7srKyr29vZSUlPR+QRFphbm5uS0tLZoAPPT09K2urs3Nzfj5+fQya4KCgriFmaMLO/vZyZdGbOvGx/b29nMrOPLy8vFVg+KXmKqqqsM8Q+R3PaGhof7+/i91jX19fVlZWdp0Oeoyaeq1uPPNy/eBQ/vx8ZgvUbW1teSlpWJiYtmmuqdOOvItZ81ARoM4O3JycqgyZlR/lNe2w9aIbURFRf/z69svZKamprGxseuqmrB3aezS2rU5Pss/Rf39/dQ9S+QuZNfGzZdea7IyP6knP9l1edUyZPPc36w8QaUYVdRiZLBQUck5QPR7PM9HS6IHR8IZVcZUWff7+siqt2tra8o8QthrcTiJnePEz77Fy6gVP9zi4tnh3sxDSUFNbMe2uPiKUdlkbvqvkffg4fzr7NNsO45mg6MmWrgyWrw2PbwVUshVPPj//c1rZ/3//s0kW/vn5NVlafigdcQ2Q5g6Y7k4P+y6sa4jQMTM0aA5PrlbgtFkO7AsQLe/xvr6+uiMYIYIOL+Uof35+u3z8MU6R8TBy/jv8fm7oP/r4cE3SvU+ds7V0nlYXuitr9ZobrMJSOjk5bAsN46hrcdCT/D18vfx8+GojuXp58s/bvP69/Hj6PXt79PT0+Xg4dXe2viRWuXl5ebm5ufn5+Tk5PmTsZIYSss5TPTBzk9RUnV2d39ieNzQ1KCoreEqX9x/gM1JUL9bhre/vv3299XT09nd39zc3O3t7evr69A+RM53bfZtlMHKxtDDzJiYmPfz9PHz89HZ1UxgdcvP0HJHbfX19a+qrPPz88Slpt+4surn6NzO07Wgp5N8fvPt5evs6/r9/KOjo9okW9p3TePl47czOLqxs///+b4/Q8JJUMbKyfz8/Pv7+////////yH5BAEAAP8ALAAAAACMAEsAAAj/AP8JHEiwoMGDCBMq/OdLwcKHECNKnEixosV/Dg70G/GvRoUWF0OKHElS5Al/CK4RIADmwD8FFcCUnEmz5j8VLEBS1NGAGIIbIbKxICCixbV/xRrYXMo0IgsrdrRkmyhMQrZiWItlQ4cN24EDFa71Qzqhqdmz/0LIs6NsCRANIhAslECAmDAEE7AhKCasLzYVChCMGBGCgMBr6NAqplmDgIclypRF8aBDAgJzMgkSQDmshg8w/WpMyIbAbt8JNxQ0IDCihWF+DcYunh3S4wkNUZbojkKAxDcdB3x9k1ChQQ0w/pIrbzEBgTCswoihQ6fAgYjWLG46pM29YotsvkYk/3EwggSJFz3sLMltB8gLEj20HLhWIzk/FSGc8x22dUKIAyIcUIxDCmzX3YEV9ROeCPskIY8OGnhAggfLBOGBBic00II/PogWmE97hSDaBCOIQJxMHNSAoGL8jEAMRS2CwQEHyinHTw2+rHZCD29xgJwPoIiGwDDFDIPAT/4hQJSSAoWwYlMTBGHhAeZEZE4WxBgJCj/99MPPl8glB0aL3xTjgAMhJOdDPy3gpwAHwxhJTAh0XnPACBO49NKTNIHhCwmQ8cbAiwv5UgEC2HDZ5aKMfqlcBSbuIwE//oz5pWjYwCnMMHehNsE+4U3gyz8t3MBnSTilZ0cUJ0ggTJX/ZP8mEAsH5NfCZ4oyqmuXn4FBQBAkELDhml9yWcMN2AxDTJZaKRDCDQTQ1UBZLfBz6kigMMDaCFpU4EAPK2RzAAsKrCDBCDmqoAIoYa7pZa6M+uCPAwTgNoIKHC7Kz5gtmBMCB8TsJww2E/iHrgT7CHSDtdeKZM4NCDCATjHXSWCeBisAccALhDngCwLFVqqrD/61AIoK8gRhxwH12fguly1wxcFzm+IVwgTCBKetQCo2TNMBRmYjYjEMmDkCCyr0Y04FE+TqTwOfRP3JHpo4U2EU8pBjDTb56vtlaMgOSQwHpYWAzQ3X+EIAAiIIJGvDJ4wACkUiEKBAMeb4Q2mlHPL/s+UEOlTgrg/Z0DLFD4hPMcUCC0wxjhXKLL7CBKDtWiwo5kygQMDCkB2CsyoQUMEIRfv8jweSaVFMRBxUUEN01epa4+zJ9bGACSbkgfgPuPceQQQm/EALJJDs6jW/Kuh1JIjZEIONOSP0fC0/FXxjhx06+BKCTggpIE82/H2tqD96DGD+AEyknz4VdSwQwRTJ6CH/GGN4480pp3zyw/vXUJOc8V77Wszyoyy7NGd1pvvHBEQQH/Gs4AYVwEasCkKAzuGLQ6DxRxfikIIOevCDAVjADwAhihTE4YQnXIMKGVGO4FkiEQDghciMB699gSYEWcoGAVYAqwQOZBgMEIEC/wjQAHM0QCZgaEkSglicZTXNHwBIwRzQEIkqWtGKiMgDIJBggzXI4YtyYIQYGSEF3M0gFilYAxPsA0B9dQkMLdgUNk7gw4W0IIn/4FIDHMAAbVXgBMESQQOycIxZyKALOJgHFhbJyGdkcRxiUAQSkKAINIiBkVh4xgxMgIhnRIKDFOiCP4rXpVx9rZT8mICyQjAChtURIsTQwQSKMQF/9KOWYIgHBkTBhQnggwYQcMIQhjlMJ3ACEbpwgguGgAVJIgENxHSCLiLAjEtiQQ4pCMAGbqE3L+lKfPzQS2euUZZrncADDKjICRQgjKbtqx8+6MUaMiGDI1zhHclwgT73yf/PfqKBkkPg5zCXuchIoDERH2DjN78WGGwQQAuu5BMLckMZB7wNIS05QDaEUQMugQIU/hhACrZxBVWY9ArccIJKV8pSlupTmP3kpzU/mQJOpMGWCwVDDYgBPj2ZjgHfWMYyPDC5aiHkGsK4QTEQ0I+PtqAFjuBEDB6RBlVIAgSSMAYOtsrVrkLgq2AN61dZQVayEnSRjEhBInjhLlT2AwzoOBIrI2q6FrBAA984AAEYULByCqQBPFTADSoVJBWUQgp8oAcRVAECEMjgDHiIbGRhAYtHUHYQmM1sAja72UFwdhAWCINokbGKVWQiBWts1BvzQwwF9fCVNzAHNhjQABb/rDMEoEAAB0iwAg0cYB8VKAY2clGBNcyCBzl4gAxkAAI2FMAN0I3uIqbrhTtAtwAF6ABlLXAH7Fr3DgII7xeesAMvlCEFA7AlOLlEGocm4ZULuREYCrOSFawgWEkIzj0CcAkhhIIGy5VBDgoggC8Y+AvhLXA+DHCJJ0CjCJJ4wAMKkQYlTAK6BX6Chp/whUucFwA4RSU/zCEM1bStYX6riATwgyjmDCNtfghECvIhhDdsoQgXkMEHEoxgHmt4EW1Ihx9yYAEER+MMD/BHEZwr3gSXNwXS6Ka+5luMORmmYQzAnlIk4oAkYEO4EauAmP0g0kbw4A2U+MAFLqCOPxQ4/8Hi/UIBLGAIWczBBpvQRngJ/Ap/kGIDboDzF55MASm/rHnD4AcLZHOqCWhAPd9wUURkWYwacMAB3nKAH2CQgk7woASCwAQmLkADfdzhwHA+dZKhUQADbMLABYZuIVABjUAj2MDljYEU3tqoFpQmG+JJII48EIT1JEECEkTIASzTWo+cyRfA4EQKDvFpI6TiFakoQgfu8IR8qMHAei6AEvzxAQLDusd36EAOOlCAA/e4vHxYwy1I+UZzDAMb15AAfCdQAQh5AAiUIYADhqEC/oiATj9JTgh84TFxUCAGQuCBEdCMiS1cIBqnFsC3vZ3uI/hgEu0usLvHC91zh/cOi//wQgqk8M5SgkGVpLkyfAXSgmLsUB4s8MUKXpCE+/aWBBpIwglYI4JWSCETEZ94MFKhhAv8YbwbzgcU7AENfxjiC9GthNYrYYqud70WYAd7NDqgD0+kYAMh9ibZEOAPmc/8IDXQSQ+GoVcd6CALWuDtOdbgBSGUwAigJsQWNrD1SpS2tGVwhTswsIpa6GMOFkgAGyZBeTawIQEWyLzmyc6HONx0yjVQFjaSwJHpMeCiDzEHAciVjRqpgEHtiAONS0B7I1CCEGeAfOQ5awE20CAQrmhDGyDfgQ5EAw5w+MMTTn6H5jd/EectNLzAcIN7S+AoDZvAeliA+oQQoB9XSdT/oubVDU6bmfZ/DwUuoKGN5HM4vG7ogP9eMQso5Ln5cYY1jxHsBbOn9l1egg2dU1umA1jL8AIeQACvhRBDcTcLsyg+oADdgAGd9mm1p34J4AX6B38W4D9EUADL527dhV3P5WPwFgcyVCyKshfC4A+lV1cSoAEAl4ASoADSUxA81BmmxA+tQAHTZoG0FwyEEA1esAObkA87oA1Y1wFHoGRucG5fcAcWAA2QhQeTcGsGdgkqJ30AeCNxggBJ4HY+NAErcQLyAAQ9ED3CEAL8wABHYyQ1sjeHBXESh36CsAWwtgNSBwVJ+ASF4A9HgHEHdgcJQARF8If+AGhN5gVmkAJU/9BNxfJywrUPCPR2NIcAFcAC5hBEf6IDCIiAdscC6EAAxRAP0uZp6PcGwZADtmZg3mYAU9dniRhy4/V0BZAD/pAG4JVhubYGvUBvxSKAEaNvlpgQviJIz9ZvJ5ANPbB6JCAKapB0JYBmgNZjAvAEegYFNkAG4WB17IZqAlAACfWB7uZhUAaJXOI3RzIMLugzvpBOFaEDNYAAYSImyVEDpUABotAEh/AG00gJF/Z+7qZnm+AO00AHRRANz9V82HVTA3Zg5dWIa1QspVQDRTIMYegzWWAhIrCACUEiDqBbAEQpVJACBpB0b5AB0XCN7ydy46UNfzAKjmB1OZAAcNABeP/wCqSQBmxga+TlBTHgi21VLLNUGHLxU1kABMsQacLQfQNxEiECL4wCR1IQA9T2d1Wgh/kwXi7JYVgHB8nlP0fwADRABDkwCU+QcQhmjiBmOdgwNmL2SsLgicsAcHGRbJrhADdADJ5RObviD3UwYxEnCLW2YAZgAAKgDV6JagTWAZnXAX9AgjswmZdQmV5wWgn1TS1gF+z4XjOnAn+UBTrgAUQ1GOPiGCNgGTeADvKiJj7wJT5AB1UpBEIQDGfgBhu2CVCgBompYSJYCdO1CJWphV5QnMVZBp4QlODQVqU0McQAWCdWjKTCAA5AK+LxDRMiIRMCH/ZVDBywIclRZv7/dWEGpmGwuJvhtQPDaZzGWQbImQl8wAcx8EEwoDcU6SUhQEsnEAJOKZ0nERSY4WL5NnSkqQEjIAzwkAh8IARVsG0CMJmU6QVQMKFeoIXu6QnwOZ8flE2JMAMYMApUYAugoYJd4hzgIQzSmRBJcCgcNSZg0JrJ0QKz9RV9YH4ZwGDseZyeYAY2YAOdt6HHIAUU8KF1MAa/UAqOAAlqko6Kwg+buSn+QEcpehAtcAITQAxbQkMw6g/VcAw2wAVeAH0YGp8c5EEBcAyJMKQwUAfeUA+7MJOzYymnNKfOWQzmMqUGIRg90U5vdUqWQylRJAqCWkIdFAAd+qFU0AyyYAtw/6ocY9Io4vMy6eglV3EDJ6ACeGoQSeAPcUIkiHIDNdCnkcol/vALlnAMlkAGzOAKMMAO68CoSko7fkmRTLpecwoKnKIAElCJmSoQPPEvCkAk0WEkIaACLQCApeQPudAAu5AcwOAbFSAmKsgPSZAEe/MZpQSpkrooOsUXxBClvUoQ2dAtPaABdNIVWVFlHCAiW7Iv15pEHPInQOAA0uoPHoACkqEDBFADIGUf0zqnXyOJz6kDDhCuAwEKtAIKvrAPI5AFk3Mzd6MsnXMzoZpE4oMcCJsFCXgrLYACpKcBVvACKKAFPXACDPA//yqp4ZRUWuCRBvsPqqdvGeIghIEN///iE32BACGADsf6qG+VHCJwIT6AAChwDShAAsWGAiIrskFwAHEoYl/ia85zAH71sgcBbNcABjqADlmgAQ4wAQ8zJM8xNuyaRPDqD9nAJZKBAj1gBSGLAkDgDyigARpSISzwmmryRqF3F21ntRDBAEnQACqgA8zYA2t4A6rkqZ9ascgBT9gAHwqAAo+BAhxgtCDFAR4QBVaQHBKgAzfgojiEiToAj34bERJgpQ2QBNfQAzrAAc7yZVjBHztrMntTKddwA0AQt0CwuZRyAlbgAf4gAShgBUvwmvzAAXizAjdYuhLRAnrVAiIAKfKgBX2FvMoiVzy7LzUCBlowAj7gA0v/gAIikBzrEQIoUB+gYBeFUbXMWxGWqhEroABJ0AMsQDAQsylFogBgWy1jwkaP8QI6cALKQADyYAXfS2I+0bftSxLFoAUO0AJZ0AK9VQHZgLicUkDYgA6Muzc6JAIkYAUooAOVokopsQK8usAk4QBaMC0roAI90ANjAxQ+YReIMgH8ayOrZ5/JYg4rMDcozBQ7lA0ZwQDy4GXPI4A0IzTmUC2tuS+bOQwk4rI/zBhCpwKkUwFZcADOEldEYiQcoMFv5QNKJQxpmx1TbBaZUS4jYA46AAY74gscgBqcM7EhwCmXpgOEcsZowTDXoAMiMAFZwA8rkAUNgBc4symcogIrTMA9ejwbmSECgWOnEqwFR5I87TQCjNbI3PEleTQCOiAMOUcM8rCMdFIBmswnXgKz9oUN1OsAOoCXp8wnDCMMWZAEyxvLpwIG7KIYAQEAOw==\" ) ) ; } private static class logoIe6DataInitializer { static { _instance0 . logoIe6DataInitializer ( ) ; } static com . google . gwt . resources . client . DataResource get ( ) { return logoIe6Data ; } } public com . google . gwt . resources . client . DataResource logoIe6Data ( ) { return logoIe6DataInitializer . get ( ) ; } private void styleInitializer ( ) { style = new org . restlet . example . book . restlet . ch09 . client . TopPanel_BinderImpl_GenCss_style ( ) { private boolean injected ; public boolean ensureInjected ( ) { if ( ! injected ) { injected = true ; com . google . gwt . dom . client . StyleInjector . inject ( getText ( ) ) ; return true ; } return false ; } public String getName ( ) { return \"style\" ; } public String getText ( ) { return com . google . gwt . i18n . client . LocaleInfo . getCurrentLocale ( ) . isRTL ( ) ? ( ( \".GL0P3EKCFJ{text-align:\" + ( \"left\" ) + \";margin:\" + ( \"1em\" ) + \";}.GL0P3EKCDJ{text-align:\" + ( \"left\" ) + \";}.GL0P3EKCEJ{height:\" + ( ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getHeight ( ) + \"px\" ) + \";width:\" + ( ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getWidth ( ) + \"px\" ) + \";overflow:\" + ( \"hidden\" ) + \";background:\" + ( \"url(\\\"\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getSafeUri ( ) . asString ( ) + \"\\\") -\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getLeft ( ) + \"px -\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getTop ( ) + \"px  no-repeat\" ) + \";position:\" + ( \"absolute\" ) + \";}\" ) ) : ( ( \".GL0P3EKCFJ{text-align:\" + ( \"right\" ) + \";margin:\" + ( \"1em\" ) + \";}.GL0P3EKCDJ{text-align:\" + ( \"right\" ) + \";}.GL0P3EKCEJ{height:\" + ( ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getHeight ( ) + \"px\" ) + \";width:\" + ( ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getWidth ( ) + \"px\" ) + \";overflow:\" + ( \"hidden\" ) + \";background:\" + ( \"url(\\\"\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getSafeUri ( ) . asString ( ) + \"\\\") -\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getLeft ( ) + \"px -\" + ( TopPanel_BinderImpl_GenBundle_ie9_default_InlineClientBundleGenerator . this . logo ( ) ) . getTop ( ) + \"px  no-repeat\" ) + \";position:\" + ( \"absolute\" ) + \";}\" ) ) ; } public java . lang . String linksDiv ( ) { return \"GL0P3EKCDJ\" ; } public java . lang . String logo ( ) { return \"GL0P3EKCEJ\" ; } public java . lang . String statusDiv ( ) { return \"GL0P3EKCFJ\" ; } } ; } private static class styleInitializer { static { _instance0 . styleInitializer ( ) ; } static org . restlet . example . book . restlet . ch09 . client . TopPanel_BinderImpl_GenCss_style get ( ) { return style ; } } public org . restlet . example . book . restlet . ch09 . client . TopPanel_BinderImpl_GenCss_style style ( ) { return styleInitializer . get ( ) ; } private static java . util . HashMap < java . lang . String , com . google . gwt . resources . client . ResourcePrototype > resourceMap ; private static final java . lang . String externalImage = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIwAAABLCAYAAACiLW8yAAAn4klEQVR42u19B1hUVxctMdEkRn+Nv0aNRqMmxgoKImWAoQqKgooFsSs2sDeUiB2jMXZR7CJ2RSyh2EBUem9SRMTeGwiIhfX2vswhIwETk7z38uOc79vfuXNn5sLcs+7aa+/T1NQqeenRo4e8RYsWX6mpiqq8q2hpaWnu3r3b+9WrV1i1atV6xenP7OzsdKiuprpDqvJW8fT09AWVe/fuIT09/dHs2bNn7dmzx/fNmzfo1atXb/5MgwYN6hED6dJhFdUd+x8qOjo6/+nUqZOxnp7e5//QJT+ytLScee3ataI7d+7g7t27yM3NxePHj/HgwQOcO3cufuzYsWMCAwNDioqKoKGh0Za/9MMPPzTT1NT8TtUi//Kira0tJxdylyyQgDOC6ob/wGW/joqKuscAuXnz5lvG5/Ly8vDo0SPJTpw4cXbSpEljUlNTbxAbXafvfsIXMDIy+v7bb7+trWqhf5/eqEs2lewsWQ5ZJJkXPe2uZKbEQI3f53pyudxw27Ztu4hd3ty6dUtimGfPnkng4GMGDZ8XxuefP3+Ohw8fSi5s6dKlqydMmDCZzueSG9svrmtiYqJRt27dmqoW+/cApzoxTDeq15AFk2UygAg0x8hW0nvjO3bsqEcupJFMJqtZkfY4cuTIedYvDI7bt2+joKAAxcXFYP3CIphfP336VGIaBgi7LWUA8XvswhhAOTk5ec7OzuOmTZs2k9zXyxUrVixV/JmPCcjfCzZSlf/PRV1d/QsChwaBxJ6ZhoDjS8chVIcrzJfOd6dz7nS8gMHUvn1789q1a3ewtbXdmJCQ8CojI4MbXAIIg6Wi8uLFCwkkDB4GjHBdfMxgYvfFxgBKTk6+279//97r16/fRAAqtLKysuT/t169ejXatWtXX9Vy/5LCgpi1DZkOAaUXAWQwh85U29HrZVQvJvNs0aLF+EaNGu0aNGhQ0fTp0zFy5Eg4OTlh3rx5WLBgAdauXYudO3fi6NGjCAsLw+XLlyVAifL69WvJPT158uQtAHHNbCX0DwOMRbSfn9+5YcOG9WUdRCL7Lkde/P9y7keV//n3l08INJ09PDx2k+AtjoiIgL+/P3bv3o2DBw+CdA2WLVsGeh8///wzKNRG3759sXz5cuzYsQMnT57E9evXwZETF3ZjhYWFkv4R+kZEXXzMQGLQCBfHtnr16o02NjbWoaGhCcRGqcJttm7duuHXX39dXdVEf6MYGxt/QizRl6zJP3TJj318fMLY/dy/f1+yigozCYMhJSUFxAwICQnBqVOnJPZxdXXF1q1bpe8LV8bgefnypQQOBhADhhmHQcO1ABFrH36fgcSvXVxcpvbq1as7Ae0eXXOL+EdbtmxZV4WA9yydO3f+L4ElniyRRS2ZlULM/tVS3cHBYTlHR6IRuZEZHCx22fhYWFldw6/5/NmzZ7Fp0ybcuHEDFGpLxgAQhcHD12LtI9wXMxADjP+u+NvMRvw9Nv4MJxA5aTh58uSp9PruwIEDHcQ/rnJff65UIZDoEmCWkF0kyyI7Qm7FlgRvm7/CPNWqVWtPDZPPDcbhsjJY/sgEkJRLZmYmoqOjQSIa7OK4Fp8RABMm3Bf/XQEeoX24Zsbh9wULEaNFm5mZGRKjLSR3dpfCdpn4GXXq1PmPCh5/kO0lkBgRWGaSBRBY/Kg+ToDqR8cGxEbNFOzzkQBb2Wt069bNytfX9zg/zQwYZgARTr8PcJRNfJ/t4sWLGDBggKSBzp8//5bWKcte/JoBxOBgADFomHHYhCtjAc3MxP8vf+7QoUMBlpaWJqS3jpMYv0IRn0gact/XxyqUVFDatGlTTVtbuy2BpQdZb9Y5VA+jcx3ItOn1dALTGI6aCEiW9HnDmjVr1iVxe5MZ4PTp00hKSpK0CbsMNnZNyi5INLJyQ78LOPQF6XuXLl1CyLlzkkieMmUKgoKCpOuXvaa4rgArgys/P18CB7MPA0c5+hIJRCGe+XNz5syZxwxE+uri4cOHD4j707x581oqAP0xiGp06NChNiftCDytCSy1CDTNCT9mxEx2tWrV0rSzs9vKT//27dtx5MgRzJ07Vwqd3d3dcebMGUlLsB5hocvuQZkRhIupiGUkV0PfZ9Zi8D1/nkfRlzcGDxqI8c5OCAsNJUGcX0ZaF5cCsSz7MIBE9wQDqGz4zgwpQneu6b2Xffr06WtoaCgjl5u5fv36NaV9IKro668VEo6mdLOLGQxM9yLk5YbIzs6WamYIFrUxMTESM3Dj8ZPPWoUbpizTcMnOuQ7/4DD4kXEdGBKOoNBoXIxJxM79Ppg4YxYGDR6CqdNnwNvbG9HxSci4chUPCQzlMc8fuS+RoWYWYjApC2h+nz9HoLlvYWEhGz58+FD6XVmcTFTWhpWucTmDy66G3c8/cT3y/dbk+/1ZEzAwGAQifFaOgkQD8nkRQTFQOE/DoFFuXD5+8OAhVu46gp7uW9FhxmqoT1sF/dnrYDHPUzo3ZNUejFq/HwPmr4PVqKnQtewBSzsHOLotx5QV2+B97KTEThWxV3kA4v+L/3/+v/j3KLsvASAGD7/HNQP/6NGjQZwZJ1ZdmJaWFvctlcrWb7SCLI37iQg8I+m4xV+9Vo0aNb6iJ+4Zs4lI5zPlV6RL3qdk3LiF8Su9UH34AtQZ6w750q3QnOuBtrNWo8W0X9Bk0s9oNGEpGk/+BY2mrED9cYvxzaDJaOo4B02c3KFB763YeYicE4lnut77RGvK+odBwezC7MkmWEccM6NyOoE/w2Bbu3btZro1n1WqpB2BRZ2AspCjIjo+TcdOnPrn3uv3HBvz30mTJnnxTRPpe2W6VwYOS9dbFxOQuPYAkj2OIHXzMbLjSPcKQLp3IDL2nETmgTPI8glGzvHzCDsQCOeVO9BgyCyMnLMCTy8k4G5oPG5ciEVOWDwuX4xFemgcki7EIJYsLCSaRHEUAk+HwmD2aqgNcIWV62rkZGbjVUGhQtngvUN95d/DOor1j0gOKkdg/MAwozGIGjZs2LSy9hPV4WEMHP1wNER1T6oHkY1iocvRkbq6upTY6tu3b7nRQZMmTczpZr1hyhZRi3A/wh1wQz28lA2vGt3gqdYZW9T0sVXNUGFG9NoAm9VkZAaSbaX319exxuifPNHOeS4szIdh2ReG8KxqBu+PLLCjahd4VbPCrs+7wfsLa+ytbYv9/+2FA3V7w69BH0y1nAA1xwVoPvVneMjH4mCzvgidsha5N++VuMs/cFNlwV42+hK/iyMqEa7zwxIYGHjZ3t7ejROZH4R4JV/clBN3xDzmBJYGPOSBwueWnIfhEXEK0HykEHdVTE1Ne2zZsuXU1atXERkZCe6l5j4h8dQJMcslYvw6Aosmovv0R5K2E+Ka2iOu5SDEfT8Ysd8PQsx3AxX1IEQ1d0Bck35YNXweNBdugmE/F2xp3R3jWhphxzfWuPB1X1xo2BfnyYIb2OHsV71xpl4vnKnbC+cIPN6aw/GF4zzUnPATVnYZD79qFtikpofdje2QufckipW6Kd4nN6T8eQYNM46Irtgl0cPV54OPgNhFMVAEWBT9UFVr167dNCkp6TFHQWycUGPxyv1C69atk/qIGERXr+Vg3769WFTHCsfVdVB0LQyPEi4hu88cZBJIMtVH4LLGSGR1GEW1o8JG4lqrwVhLLKG7ehd6OszC9fbD4d/BHls69oSHpi2OduyPVI3huKExCtnie3QNvs71dsOx3sIZH49fgiXO7rjWdpgEyIPVLAk4RvCzno778RklghzF72SW8nJF4hy7IOGWmG2WLVv2sypPU3FpsGTJkhOKXIXEJlBoBL6RIjp6+foVjjguxmK19vCbN4ne45C3CPfDYvDYZi4etxuNx5rjyJzwiOpHHcdK9kxjDE73c8OqcUsRK6fvdRiL3I7OeEjvZXYcidOaA7FW0wYeBKBUTUfco+/f03LG3Y7j8ER9NCKNJqDhyAWYO2we7mqUgDGNQBfcsA+2kdvb/p+uiF60A4VPc99im4pYp6w2Y1MOxVn40wPzWClL/L9dyKX0V0RIrf6pa7Zr164fh5hitJxylCHRNumY/EdPsL++PXybGaIgKwKv8ghMuQ+R9+gWXgTF4LnuZOR1dEKepjPytBTWabxUv9AYh9cdnPCi0wTkaU+Qzj2nzxWQFWlNQGKnEdiu1RtnOw3C9U5jUdBpovTd51rjkU+WozsR97XpWHsiAWksLquPJBZyRFLrYThaw5pcpD4OtR2Kaycj3upN/zNCmF/zbxd9Z6RfMvv37z+r0jAM9xcpRsudY+BQ7cwDoSoSs3/UeUnirr+fn99FFnsMGE6AiRvJ+Qw21goJ6w5hA2mXOJcJKH7+AMUPb5PdJBV8A8i7j4IJ6/Gs+TDkth+rsDHIVSeGoTpPOi55nUvgkUxdcU5jLAo7EHDIntP5BxqjiYGckEtAyiWw5GqOp/fH4bl0zlmqnxIL3ewwhtzgSGQS40Q2c8Cej8xIaBvjzKAFeJx5/Z2RlPIDwb+XXZEiQnzVqFEjk0rpR7iviENqAsxhsn0kbFfRa8f27dt/+d13333KGuWPrlG3bt2WBJJiznzyUAQOMZWBwvkLKZVPt/+U/SJ4VdVE7MRhyM+6DNzLxpvbV/DmVibe3LmGonXHkN9/CQoGL0fBoJ9RMGApCun1tb7kSvrMR1HvRSjotRD5PRcg32Y+8nvMQ7713BLr6oZ8qznI7+KKgi4/It+CrAu9NndFvhmZyawSM3ZBvuls5BvOIOaZQG7NGdnq5KbUHZHe3hGn6tkRaPSwr7k9nt24KzHju1wSA4bDazEWh8LsYmdn58mVXr8QOD5TMM9sHp9LALLkyIgjJQ65hZX93meffdbEw8MjhBNVTMsMnFLNQoDhp08ar0Lux0dnPPbV7YxMlx64dSIAuJuF1zmpeHMtFUWpccic7oo0p0nIGD8V6c5TJMsgSxs3GZfGTkTMmIlUT0YG2eUx9LnRk5A+muuJSHecgAxHqoeOQ/rgsUgbOFqqM4Y4IXPY+JKabTDZiAlI7zkUqfo2uGRgi1SyaL3uCOncFed1u+JYSzNiQh2k7wks1WLvipBEzzyzDJ+Li4vL+WDCaS6cd+GORh0dnfqK0PoHApAh1QM4xOakHncncCckfbyeubn5Wh8fH1BYLXU08piV9PR0SQBLwwru3kFWRiZ2fzMQR3/QR85sPeRsWYkXmSl4kxWH15mxeHM1EakjRiOsgw4idA3JjBCpJ0eUvolUR9LrYB1DhNB7Z8n8yaJkJojWN0a4jgFC1TshvJMe4mz7IHWMM1LHjkdCv4GINDBBmIY2wrX0ECkzRoS+HBFURxqZIlJuTmaGKGNzRJtYIIzOBegZUtRlSJpGFwm/7CsFTHlCV7xmVyT0y4kTJ5Lp4RupNATkgy4ilOanp0qtWrW+JHE30N/fP/HChQtg0LCtWbNGCq1J10gASkpNwaljJ7Dxs244SQ2dNUMbD38ZikfhF/A6jcRvykUUZ8fihocHIrQNEGVEDSi3IOuiqC1Kziksil6HGFsikBo8gEAUb2KJ7HmLkBcbjxe37+A5gTPvUhoKrl3H88zLuLP/IC6NcpbAF0GfF9ePoWu8ZXTuDIHzuJaR5JbCp2+skGGEMbOybmN2vXr16vM6deroVqqugH+qo5EL6RxddjciPc5PGOsVkZPIysqShjFk5WQjxj8IHlXMEWxpgIyZMjz70RB3jmxDflwoXiecxeuUc3h27gyiDBkUFqWNyrWyMYi4cePJTmrLcLRnX1zcsxdpOVeRvXUHkvo4UMMT0Og6cd16IWPKTDxPL8mzPI2KQcqIMYjQ0i/3bzAYg4i1ftWRU7itj3MDf6owWhKCl90RM6miJ/vVmDFjnCqbyA3k/iLO2v7d69HT1HbHjh2RDBThfpiaOXnHiTs2zvhmXstG2JbD2EIRSEQ/Ga7PMkC+qwz526bhTvB5vIz0w6toP1wNPI5Is24lTFIOWH5jHgtEdDZA8oAheH3vPu7euInAQcMwu50GvInB4hkwBAgGTUQnmXS9u4d9S7QV6aqrP69ClJ6x4poWCjOXgHZOZopfyf3trGKAAPOZUqRUUbKOTdHhKD0g/Do0NDRDrbJMrGPRSjrkRwJMEGmSUIW47f13ZgxYWFhMY0ZhwHDCivuR0tLSJA3DNY99Sb92BUFzN0n9RfEjDHDDxRAFbnK8WN4bD4MC8OS0L96EHcajsLMItbJFlIFZqTuKLQc0UQam0vt5qZckEFxxnYdo0j5+hqbwNjB+y42x+4pkHaQrR+HVHLx88hSX3RaQLjIuAZX8N6ZhwJwnwPgR6LyqG8BXfTRevnpZbn+T6MEW014YOIcPH47v0aOHU6UTIorpsJ05jCbARClmMZ7gzkY6J2Ox+2f0zNChQweQwM0QN01MgWVWYaDwyLpkckmp2ZnwG7EEOz4yQIqzDDcZMHNNUDDfFIWBW3Hz2FG8CtqFF3EXENejjwSIWGq8M0ZmOEIgYG0RQ43KzMGNG66ph1u79khgeRQUQmJXXzofayQAJoCgMLpeXPfeuL5hExJ62ZMA1i8FVbRxFwl8wiVdILD6k/D1/tIA+xoPQGFu3u+6DER0xPpF9B0Rm+ZWrVpV40PoH6rDg34IMOM4pCbArOdJ+GQbOKHHsweo1uLOSB4krqur+239+vW/atWqlbGYuiHmAonC51m7MGASk5KQmJEKH4vp2F1ThvSpMtyZTU/7PFPk/2iAl14zcc/vCO4d2IoX0UGI6dqLIpsSkESQHSPAMEucJfD4UMQTTRojkRr/FXc5FBcjdbSz5J6UGUU6livcl7FFCeCojqRoKkrfWMEmJQCJYXDx9wyJ1ejvntExIg1jiG2f6OOE4aQS1/Pmdbn6hTPaoneaXPFLe3t7hw+yg5HH6RJgrMnGkk3jkFoxFcWRtM9OEs4DmzVrNmjJkiX3OSriCWc8jpdnNXJkxJ2OHCXxMMyo6CjEJydiX7vR8PlWhiwXGe67EmDmmyF/jiEKVw3Ci1O7kLPbC7khJxFrbk0NaiY1MFu8wk7TOTc9Gfy0dBA3d2EJMikyYTcSqWcqWYSuGcJ0TBHW2QShnU0RqmOOMF0LhLLpdUGoviXCDLoiTG6NMOPuCDe1QbiZLSIseiKyqx2iuvfDOate5IpMsFGN/o679zvzMGLkHRuXo0ePXlQF0m9HWTWUB1U5ODis5icsPDwcHFYfOnQI+/fvx759+3Ds2DEpvD7sewS+Bw9jZ92+pA0IMLP08XiOCQoXmCOfdEzBEhu88v0Fj3y3IXmZJ0K1zHChE5m2Bc53IutshRCdrlR3w7nOPbBf0xKz7R2wYf4iHBo1E2d1bRFqQpGSJbka28GIsR+OuMEjkThyFJJHj0bKGLZRSHEcieThw5A0eDASHQYicYADEvv1R2J/sr79kEwW1as3gqy7Yk89OXbUtMajrGu/6x5Q7g4QvdPskry8vMKJgftUlob+hCOkv9hXVF6p7ujoOJwigjTOPzAlly0cbvOQhrCoSPjt3Ietn1giwMoASdP08dTNBA/czJDHbmmhJV56u+H18dVImemKyN6DEDNgGGIdhiKeIp+EwWxDkTBoCJIGDkLqiBF4GBGC8/7HMYUa/EB3a/j37Y3wPnZIseuN5N69kGhriwTr7kjo2g3xlt0QZ2aJGJMS1xNNrieKhK2yRZJFk3Y51dkQxzQNKJrTw6mebhWG1AwYdsFCv8TExNziLEOlSdZx3xCv9aKYlGb4d4Ejk8lsRIaT+4/Km90o5g9diApH4PJtFCGZIMbBoCSkJqA8cTNF3lxTFBHT5CwfhZz9K5Az50ckkOuJt7BCrBnnW8xLtAY3MhlHOixeUVgyee2Wz1H4aGhjjrYedlAoHEeNzhFWJNeG5mUSgIokoJFyuP5bcjCCPh+gZwSfNkZSz3XaDr+33FHZTC//ZjEgPCcnJ5eiRbNK5U54lBxPPONORgLPFl4wiCep/ZV51I0aNdIjnZItZgfw01YWMDwsk98PjgzF0fHLsI1C6gRHGa7PNCiJkJhdqGbxe3upA67vW4X4gSPgTw0fI0U7Fr9ldhWNHEmCNcHOHq8VsxEeBZxCjLaBFFGJEPk3cHSRoiMWxJw9jiD2YGPQ/T4R2AUXOJym6GhPPSPsrN4dT6/fLs3BlO0KYBMrRzBouHh7e/tX2k5Gck/6nI8h81aMi/HgaIjPK/qK/rDjbM6cObtEWKk8nKHsExl7KQn7bGbA6xMDpDrr4xaH1PNMJLBI5maMohX9UeCzAVHdeuNXAkUoRUReMmMEUR0qhdMWEog4nxLXww6vFAO0cuPipXR/jIIlShmDQ2ViGQZX1txFyJzthvSJ05DmNBmpjk5v5V6Enabr/NrZCFur6OOk7Zy3EnZl2UXoFzHZbceOHReJxbt9EEJW4a6suWdaMU9pmiKsdlEsA1K9Q4cO33KHI2uhWrVqNbexsRlK+uS2uGHlLeMhyoPcJ/DSdMTe2jJkTNXDbQJM4VuAKUngPfJaS41oKTFLJDXmOXJBZ8jm6Rlgtb6RBJxEeh1nbInCnGsl7oKAE2fdqzSRJ7EKg4HYInnoKDzwD8TTyGgUXL1W+v9cXbZC6shUzhyH099kd3T4Bzk2ERNmH7vwu5F3yuNfRKKS3VJwcHAm3cbGah9qUTDQNwSejryyJvda88g8XV1d86ZNm/JU2G0cCS1cuJAXLsSiRYukhYF4EtqBAwcQGxsrjQ/hqIlv6ss3r3FysDu2V9FDymgZcmbKJO0iuSS2OUYoWjMAt9asIJchL026xSiyvMHEMgcJEAEElkUEnpNaenhyyOc3APy8EhGaeiVAUXIxJeG5BcLaaeHmlu3SZwuuZJcIXdZE4u/QZ0PonD8BxruWIfbW74eCx8/KHd+rPBxTrARx5cqVJ126dDFVxdDllyo//PCD1cWLF6/zJHsWtZz+T05OlroCOKzmFaRYDPOiQAya6LhY7PxlHRZXN8ZhQwOkUJR0Y6acxK5ZCWBcZSjaPh7Z7ssIMEalDS9EaSy9TiQQRJD4XUFMM7GjFjZT5PSMQCmxzMNHiLftK+kU5d5tSdOQ8flHwSHSZ+8f9yNw6b/9OXZHesY40YnckZoMQQPdy2UXccxjfETuhRmWy+bNmw9Upm4AXo+u9T95TRcXFy/uAuCbVt5Ch8rn+HOPcp/ioN1srKqqi412uoidKMPDH0n4zmXA6OPFLhckjygZfsA90W9rjBJNwjolid0HmZe2Pla7zEZAcBAKqSFZy8R2tZWYhvuI2EVxtCSJXTJmFi7cNRBBDPXbNYmB6HNSdNRKTtGRDFmHgkoBU1bo8rGYJ67QMMVeXl6hrP8qDWDox0zh1aU41c9zjP7O6lI8Cn7KlCkziFHuMVg4pPwz83ekRYFOh2ODmhwnDQyR5aKHnOmGeDHfBM9+lOGWxyzEdOmJGAptY6WxKV3eYgnlyIcjonj6XKSJFYLXb0CRAphFDx7i+npPJA0ajlhLG8Tb9EHaxKm4R6H3mxdFEmhSho8ujZKka9HfClZER141yR016of8h49/NyxTGTxCv3D3R0BAQArdlq/UKttgKdYgZJPI9irG787jlS9ZzKq9xyoDtra2jmLvAM6/cD/Sn5kAJmVGi15gn+Zo7PpChksT9AkwMjyfa4zCBSaIXzwNFwxJS7BmkUbBESiMfx8ql7CPIgoiNkq0sMaNdRvx/FIa3hSWTIHlPqa8lEt4fP4iHgSews3N23BptDNiTOi7spI+KnHdSLJTFJUd0zSSJreFTlpXbleAMnBYv4gVHVJSUm5T0NC+UosQRcTD86c3kx1QhNa/iNW+xXTY8kqzZs0siF3uc96FbxqHl8rTYN+5GBCV2IMB8KAo5KwxscxMPdyniOnlsm64vdQN4bomksA9RY14gmoeqhBmxPqFdIyxUuJNuSbxKgZDxdv2QfKAoUi2H4KEnn0RY2qFcHJHYeSmQqm+SMDgnuhgfVPSLCY4SUwTQNFSgMwIh1rIsZnY7/qZ6AoBI4YziLnTQr+4ubmt+mAUrGKJMg3FPKWJvDAz1WsVU09GKdbitSPr2rhxY96yxmj8+PHRvOJTYmJi6YYTHBUVFxe/vYwPvRZLerDxccHLF9ir4QjvLwyQPplYZoouitYOIBflgggdueRu2BKISTbJ5HCjqGivgTHCCCAJkgspiYBilASrlKUlzXKRAHCOgBFEdrazIU7pGJWCgpOBPGTBj7SKPwlnrn+liOx4Rzl828ix8zMD7G/igMK85+XOEhCA4d8pRteR6H+9fPnygObNmxt80GEQTy9RjMzT5G4EAlU3YhYbYqaB8+bNi1q3bt3rFStWYOXKlVIPNdtPP/0k1SQAeRARfH19pRvLtM1DNpVL5IZDxDL6CLU1xJVpnfBo7QhcchwnjYBjYRujAAaD5ldikOl6MvxIwPElUIRzut/QQmKKs8QSp3WNcZK+F6Anl8JifwEIXUMpCXdCywjHO8hxtI0xfFoY4+DXxthXxxi7PzPCTjUDaSGADeSKVqtp4/y8Tb8Tu2UFL+sWMbPT29v7PN2uL9VU2/aUX8aNG+cixrpw2MxZXjEJXYwL4TG8zDwcWvPihQwsXrCZhz/wUAem8gcPKeRuORgH6xni8mQtXPllDOJs7KUxMBHkWsIIFOfZdZDe4OGSDIxjxBCrdGRw09XDYl19HCeAnCT7lceuaJNpmeC4ugmOtDDFofqm2FtDjl1VDLGD3N8Winw4+tlAxx5qJthY0xqbv7PHVnMn7Hd2x7kN+xAXGIKnz3NL1oKpYHkP0R0g/Qb6/VFRUZmtW7duqkJGBaVz585D0tLScsVNY/0iFtvhuqxLEvsHsEi8cuWKNAQiNDQUWTdycGrpNqzgUfl2Bsje+CNOGlpKAAggtvDXl5e6Dj5m9gjoROBQN4bXD3I4f6ePmS1k2F5Pjj1V5RJTcP5kEy8LQsdrqpjCo74NdmiNwD7bGTg+cTmCVu1ClM9JpEfG42bONTzOe4oCvIJyQuBNcXG5uRfxmn9LWf0yY8YMdxUyKi6f7t27N5LZhG9c2cWaK/L75QEpNTkZ7g26Yn4bGQ5NHAk/0hOniCX8OxCbtGGmMIFPIzMcrGOCPdUIKCRIt6sZSWOCWZyu/NwcvzTqge1tB2OP5ST4OC7CycWbcGHfcSSER+HGrRvIe1mIlxWsaFVczvq+5S08XZF+oQjx9Zo1a041bNhQSwWLcso333zzNT1Nrjk5OfnKKyyJkPnPLJladtHmM1NWYy1ph1Wf6mNOPR1Mq6WNX4gpdqqZEjgs4PmRBTbV6oEtrQdiW9cJODBhCYI27EW8/zlkJaTg7q3beFqQhxdSEh/lJg8rmh5S3spY5YFHuRabhLHI37ZtWyDdli/UVJPVyi/u7u5buBFED61YFFnM9uObyC6qLIDKu/EixL5FrsFTbyg8G/TAVp2RWD90JuY7TsaCAU7Ys3QdsuKScf/OXTx5/ux37gMVAOTvAONdbMNsKtbx5SEb5F7TeKtBFTIqKFZWVjOuXr36ggUvRz580wRoxAKIoueak3k82o59/rsW4eFy894dZF+7ityiAokl2FKvZGLNxvXYuHkT0jMzf8cYZe3XX3+VdktR7iEvmxt6F9O8eofIFQ+A6A4Qv5XL6NGjZ6qQUXGp6+npGXLp0qWnMpnMlW7WLrHhg9izseyejiIbygDiGy40j/LKlMqCU6wXJxqcOzR59So3Nzepg7MscLhwBEbhPmxsbDBt2jSpx5wHnzPb8d8rO+TiXVYRMykPZ+DfRA/Oy4ULFx5p3LixugoWFZeq1atX79SgQQNjPq5WrZp6SEjIzWPHjqXK5fIZHh4eoXxTGRxiXyPRQSc0D4OHAcbvM4BEY5TVQMo7nHCj83AJHlTOuR4O1TnbyoBiBtPU1JRmKfAy9TxjoWtXEtLz54MiOhw/fhy7du3i/h5u5FLgVOSC3uWexHAGdr0rV648olayMoNKv7xHqV67dm1jXipekezrw4J4586d4b17915CbiKLwcM3WrgxsSmW2NNRsZaKFH0I91VWqCr3evNuJgwaBgYDhr/P7MK7uXXq1ElKHPbr1w8jRoxAq1atJOCoq6tLdevWrWFvby8tDFDeYK+KllctO7uRfw+5v4uqXW7/AZdF7NP1008/5ZHzVUjzzCIgFLu6uvpYWFgsIffyjMNxTvbxUyrWtRVr+wv3JZaZF5tYKFvpCD7F+r/cwLa2tpg6dSratWsnjb8xMjKCpaUllixZgrZt20rujAszDi9Fwqt6MjhdXFzg4OAgsZfovihvwwyhX5S3zuFibW1tr2ryfzJh8+mnzSmK6McROYefc+fOPUgNXTRy5EjPcePG7aKb/5rBweARWWLlyEs5+irrvoRb4Yblz2zYsEECC7tBCv8lFho1ahS+/PJLCYScfWYmEpqGz/EWggw0PT29UqBwhppHEvLfVE5IivV3GSyk4fJIv/jUq1fve1Ur/9/0X9WrdyQA8SQv3jLmG9IWMRkZGc8YQNR4Z0TkJdyYsngWU1H5PeG+hIAuG1YzOLjBmVl4Q1IuXHfr1u2tscbcdcFsxKJZgKVFixbo0qULHB0d3+o05f9N7Jswffp0T7WSpeBV+uX/YalWt25dObFBFz6uWrWqNu/eRtHN9R49eiwmtogX+xWxQBYNJgS0WEtOGUDlbQUoQMQzMHnbHdF7PmzYMMlFRUVFlX6OQcJRFrMes5HY4ZaBKUQ7/z3eeKPSLKX6P1xqtmnTpl/Tpk15IPUnGhoaI4htXnt5eUUOGTJkXWRk5H2x6RWzhxDOypuDMjsJjSQ2xCgbugvdw+5o+PDhkhjmMJyjKDs7Oykc521zZDJZKbjE6lLCJXEhjdRP1WT/rtLo+++/d6DQvS0zED39a5lF1q5dG0zHO5mN2EUp6x8BILFMPQOM2Uc5+1wWQHwNHqTO03lZBxkbG4PcpjTzQbCTWEmLQUrRWKG7u7vP559/3ljVRP+u8pGyRqhRo0Y73iyDDnkoQa0VK1YEciZ5woQJe2fMmHFURFgMICFQxYqWDCQhoLnxK3JffO7cuXNS1KSc5BP7RDLTTJkyhXdfq6rSL/9jAKpfv76poaHhOA7lyVpTQ9+4cuXK80mTJnmT/okVmWduZJFwU96aTwhoZfel3KMuACWGYzJgFAOmjtPf/kLVHP/b5TPSPnakgfpy+F6rVi2L7OzsorS0tKezZ88+EBwcfF3smMYuquzG6Pya2ams+2IAMWMpg4yBpKOjY6K65f/77FNFiYH+q62tPapVq1bdOZrX09ObxADw8fG55OTk5J2UlPSMASIEtPK2fKL7gtmHTWgjPkffe0Lub0f16tUbqm555QPQx0oJxO+6d+8++6uvvuLNy/9Dje7NTOHp6Rm2ePHiwJycnJdi43MGkQCOSCTyMeuloUOHLlIr2bdapV8+EAaSCi+6TGGxCx3ykrONKTo6z0KY6tDt27fHihyP2NtRDBRbtWrVJrXKspSqqrxX+ViJgT7m2RC8bCwdf02mFR8f/5jdlKur61FfX9/LYhtltiZNmrRV3T4V+3yiBKDqcrl8orm5Oe9EUqdly5aDmV1SUlKezpw5cyufU90yVSlP/wid8nXXrl3d1NXVB9Dx5yr9oip/VFj7VFX7F05U+z/5u5GdgQAEIQAAAABJRU5ErkJggg==\" ; private static com . google . gwt . resources . client . ImageResource logo ; private static com . google . gwt . resources . client . DataResource logoIe6Data ; private static org . restlet . example . book . restlet . ch09 . client . TopPanel_BinderImpl_GenCss_style style ; public ResourcePrototype [ ] getResources ( ) { return new ResourcePrototype [ ] { logo ( ) , logoIe6Data ( ) , style ( ) , } ; } public ResourcePrototype getResource ( String name ) { if ( GWT . isScript ( ) ) { return getResourceNative ( name ) ; } else { if ( resourceMap == null ) { resourceMap = new java . util . HashMap < java . lang . String , com . google . gwt . resources . client . ResourcePrototype > ( ) ; resourceMap", "gt": ". put ( \"logo\" , logo ( ) ) ;", "prediction": ". put ( name ) ;\n", "label": 1}
{"id": 362, "input": "<s> import java . io . File ; import java . nio . charset . Charset ; import java . util . Collections ; import javax . tools . * ; public class T6437999 extends ToolTester { static class MyDiagnosticListener implements DiagnosticListener < JavaFileObject > { boolean error = false ; public void report ( Diagnostic < ? extends JavaFileObject > diagnostic ) { error |= diagnostic . getKind ( ) == Diagnostic . Kind . ERROR ; System . out . println ( diagnostic ) ; } } void test ( String ... args ) { Iterable < String > sourceLevel = Collections . singleton ( \"6\" ) ; MyDiagnosticListener dl = new MyDiagnosticListener ( ) ; StandardJavaFileManager fm ; Iterable < ? extends JavaFileObject > files ; dl . error = false ; fm = getFileManager ( tool , dl , Charset . forName ( \"ASCII\" ) ) ; fm . handleOption ( \"-source\" , sourceLevel . iterator ( ) ) ; files = fm . getJavaFileObjects ( new File ( test_src , \"Utf8.java\" ) ) ; tool . getTask ( null , fm , null , null , null , files ) . call ( ) ; if ( ! dl . error ) throw new AssertionError ( \"No error in ASCII mode\" ) ; dl . error = false ; fm = getFileManager ( tool , dl , Charset . forName ( \"UTF-8\" ) ) ; fm . handleOption ( \"-source\" , sourceLevel . iterator ( ) ) ; files = fm . getJavaFileObjects ( new File ( test_src , \"Utf8.java\" ) ) ; task = tool . getTask ( null , fm , null , null , null , files ) ; if ( dl . error ) throw new AssertionError ( \"Error in UTF-8 mode\" ) ; } public static void main ( String ... args ) {", "gt": "new T6437999 ( ) . test ( args ) ;", "prediction": "try\n", "label": 0}
{"id": 13275, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import com . emf4sw . owl . ClassExpression ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . ObjectMinCardinality ; public class ObjectMinCardinalityImpl extends ObjectPropertyRestrictionImpl implements ObjectMinCardinality { protected static final int CARDINALITY_EDEFAULT = 0 ; protected int cardinality = CARDINALITY_EDEFAULT ; protected ClassExpression onClass ; protected ObjectMinCardinalityImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return OWLPackage . Literals . OBJECT_MIN_CARDINALITY ; } public int getCardinality ( ) { return cardinality ; } public void setCardinality ( int newCardinality ) { int oldCardinality = cardinality ; cardinality = newCardinality ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . OBJECT_MIN_CARDINALITY__CARDINALITY , oldCardinality , cardinality ) ) ; } public ClassExpression getOnClass ( ) { if ( onClass != null && onClass . eIsProxy ( ) ) { InternalEObject oldOnClass = ( InternalEObject ) onClass ; onClass = ( ClassExpression ) eResolveProxy ( oldOnClass ) ; if ( onClass != oldOnClass ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS , oldOnClass , onClass ) ) ; } } return onClass ; } public ClassExpression basicGetOnClass ( ) { return onClass ; } public void setOnClass ( ClassExpression newOnClass ) { ClassExpression oldOnClass = onClass ; onClass = newOnClass ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS , oldOnClass , onClass ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case OWLPackage . OBJECT_MIN_CARDINALITY__CARDINALITY : return getCardinality ( ) ; case OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS : if ( resolve ) return getOnClass ( ) ; return basicGetOnClass ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case OWLPackage . OBJECT_MIN_CARDINALITY__CARDINALITY : setCardinality ( ( Integer ) newValue ) ; return ; case OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS : setOnClass ( ( ClassExpression ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case OWLPackage . OBJECT_MIN_CARDINALITY__CARDINALITY : setCardinality ( CARDINALITY_EDEFAULT ) ; return ; case OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS : setOnClass ( ( ClassExpression ) null ) ; return ; } super . eUnset ( featureID ) ; } @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case OWLPackage . OBJECT_MIN_CARDINALITY__CARDINALITY : return cardinality != CARDINALITY_EDEFAULT ; case OWLPackage . OBJECT_MIN_CARDINALITY__ON_CLASS : return onClass != null ; } return super . eIsSet ( featureID ) ; } @", "gt": "Override public String toString ( )", "prediction": "Override public boolean eIsResolve ( int featureID )\n", "label": 1}
{"id": 3445, "input": "<s> import com . sun . javadoc . * ; import java . lang . * ; public class ModifierAbstract { public static boolean start ( RootDoc root ) throws Exception { ClassDoc [ ] classarr = root . classes ( ) ; for ( int i = 0 ; i < classarr . length ; i ++ ) { if ( classarr [ i ]", "gt": ". isInterface ( ) )", "prediction": "== null )\n", "label": 0}
{"id": 13280, "input": "<s> package org . seage . aal . reporter ; import java . io . File ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . seage . data . DataNode ; import org . seage . data . xml . XmlHelper ; public class AlgorithmReport extends DataNode { private static Logger _logger = Logger . getLogger ( AlgorithmReport . class . getName ( ) ) ; private static final long serialVersionUID = - 2598529749932239606L ; private int _id ; public AlgorithmReport ( String name ) { super ( name ) ; } public int getId ( ) { return _id ; } public void setId ( int id ) { _id = id ; putValue ( \"id\" , id ) ; } public void save ( String path ) { File f = new File ( path ) ; if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; try {", "gt": "XmlHelper . writeXml ( this , path ) ;", "prediction": "f . close ( ) ;\n", "label": 1}
{"id": 9640, "input": "<s> package com . sun . tools . doclets . internal . toolkit . taglets ; import com . sun . javadoc . * ; import com . sun . tools . doclets . internal . toolkit . util . * ; import java . io . * ; import java . lang . reflect . * ; import java . net . * ; import java . util . * ; public class TagletManager { public static final char SIMPLE_TAGLET_OPT_SEPERATOR = ':' ; public static final String ALT_SIMPLE_TAGLET_OPT_SEPERATOR = \"-\" ; private LinkedHashMap < String , Taglet > customTags ; private Taglet [ ] packageTags ; private Taglet [ ] typeTags ; private Taglet [ ] fieldTags ; private Taglet [ ] constructorTags ; private Taglet [ ] methodTags ; private Taglet [ ] overviewTags ; private Taglet [ ] inlineTags ; private Taglet [ ] serializedFormTags ; private MessageRetriever message ; private Set < String > standardTags ; private Set < String > standardTagsLowercase ; private Set < String > overridenStandardTags ; private Set < String > potentiallyConflictingTags ; private Set < String > unseenCustomTags ; private boolean nosince ; private boolean showversion ; private boolean showauthor ; public TagletManager ( boolean nosince , boolean showversion , boolean showauthor , MessageRetriever message ) { overridenStandardTags = new HashSet < String > ( ) ; potentiallyConflictingTags = new HashSet < String > ( ) ; standardTags = new HashSet < String > ( ) ; standardTagsLowercase = new HashSet < String > ( ) ; unseenCustomTags = new HashSet < String > ( ) ; customTags = new LinkedHashMap < String , Taglet > ( ) ; this . nosince = nosince ; this . showversion = showversion ; this . showauthor = showauthor ; this . message = message ; initStandardTags ( ) ; initStandardTagsLowercase ( ) ; } public void addCustomTag ( Taglet customTag ) { if ( customTag != null ) { String name = customTag . getName ( ) ; if ( customTags . containsKey ( name ) ) { customTags . remove ( name ) ; } customTags . put ( name , customTag ) ; checkTagName ( name ) ; } } public void addCustomTag ( String classname , String tagletPath ) { try { Class < ? > customTagClass = null ; String cpString = null ; cpString = appendPath ( System . getProperty ( \"env.class.path\" ) , cpString ) ; cpString = appendPath ( System . getProperty ( \"java.class.path\" ) , cpString ) ;", "gt": "cpString = appendPath ( tagletPath , cpString ) ;", "prediction": "cpString = appendPath ( System . getProperty ( \"java.class.path\" ) , cpString ) ;\n", "label": 0}
{"id": 13291, "input": "<s> package org . fuzzydb . client . internal . comms . messages ; import java . util . ArrayList ; public class QueryRsp extends OkRsp { private static final long serialVersionUID = 1L ; private ArrayList < Object > results ; private boolean moreResults ; private QueryRsp ( ) { super ( - 1 , - 1 ) ; } public QueryRsp ( int storeId , int cid , ArrayList < Object > results , boolean moreResults ) { super ( storeId , cid ) ; this . results = results ;", "gt": "this . moreResults = moreResults ;", "prediction": "this . moreResults = moreResults ;\n", "label": 1}
{"id": 9707, "input": "<s> package models ; import javax . persistence . Entity ; import controllers . Security ; import play . Logger ; import play . db . jpa . Model ; import play . mvc . Scope . Session ; @ Entity public class User extends Model { public String email ; public String password ; public String fullname ; public boolean isAdmin ; public String industry ; public String headline ; public String linkedInToken ; public String linkedInId ; public String pictureUrl ; public User ( ) { } public User ( String email , String password , String fullname , boolean isAdmin , String industry , String headline , String linkedInToken , String linkedInId , String pictureUrl ) { super ( ) ; this . email = email ; this . password = password ; this . fullname = fullname ; this . isAdmin = isAdmin ; this . industry = industry ; this . headline = headline ; this . linkedInToken = linkedInToken ; this . linkedInId = linkedInId ; this . pictureUrl = pictureUrl ; } public User ( String email , String password , String fullname ) { this . email = email ; this . password = password ; this . fullname = fullname ; } public static User connect ( String email , String password ) { return find ( \"byEmailAndPassword\" , email , password ) . first ( ) ; } public String toString ( ) { return email ; } public static User findConnectedUser ( String connected ) { String linkedInKey = \"linkedin:\" ; if ( connected != null && connected . startsWith ( linkedInKey ) ) { User user = User . findByLinkedInId ( connected . replaceAll ( linkedInKey , \"\" ) ) ; return user ; } else { User user = User . find ( \"byEmail\" , connected ) . first ( ) ; return user ; } } public static User findByLinkedInId ( String linkedInId ) { return find ( \"byLinkedInId\" , linkedInId ) . first ( ) ; } public static void linkedinOAuthCallback ( play . modules . linkedin . LinkedInProfile profile ) { Logger . info ( \"Handle LinkedIn OAuth Callback: \" + profile ) ; User user = findByLinkedInId ( profile . getId ( ) ) ; String username = \"linkedin:\" + profile . getId ( ) ; if ( user == null || user . linkedInToken == null ) { user = new User ( ) ; user . fullname = ( new StringBuffer ( ) . append ( profile . getFirstName ( ) ) . append ( \" \" ) . append ( profile . getLastName ( ) ) ) . toString ( ) ; user . linkedInId = profile . getId ( ) ; user . industry = profile . getIndustry ( ) ; user . headline = profile . getHeadline ( ) ; user . pictureUrl = profile . getPictureUrl ( ) ; user . linkedInToken = profile . getAccessToken ( ) ; user . isAdmin = true ; user = user . save ( ) ; } else { Logger", "gt": ". info ( \"Found User: \" + user ) ;", "prediction": ". info ( \"Handle OAuth Callback: \" + profile ) ;\n", "label": 0}
{"id": 13307, "input": "<s> package org . eclipse . ui . internal . preferences ; public class Base64 { private static final byte equalSign = ( byte ) '=' ; static char digits [ ] = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public static byte [ ] decode ( byte [ ] data ) { if ( data . length == 0 ) { return data ; } int lastRealDataIndex = data . length - 1 ; while ( data [ lastRealDataIndex ] == equalSign ) { lastRealDataIndex -- ; } int padBytes = data . length - 1 - lastRealDataIndex ; int byteLength = data . length * 6 / 8 - padBytes ; byte [ ] result = new byte [ byteLength ] ; int dataIndex = 0 ; int resultIndex = 0 ; int allBits = 0 ; int resultChunks = ( lastRealDataIndex + 1 ) / 4 ; for ( int i = 0 ; i < resultChunks ; i ++ ) { allBits = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { allBits = ( allBits << 6 ) | decodeDigit ( data [ dataIndex ++ ] ) ; } for ( int j = resultIndex + 2 ; j >= resultIndex ; j -- ) { result [ j ] = ( byte ) ( allBits & 0xff ) ; allBits = allBits > > > 8 ; } resultIndex += 3 ; } switch ( padBytes ) { case 1 : allBits = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { allBits = ( allBits << 6 ) | decodeDigit ( data [ dataIndex ++ ] ) ; } allBits = allBits << 6 ; allBits = allBits > > > 8 ; for ( int j = resultIndex + 1 ; j >= resultIndex ; j -- ) { result [ j ] = ( byte ) ( allBits & 0xff ) ; allBits = allBits > > > 8 ; } break ; case 2 : allBits = 0 ; for ( int j = 0 ; j < 2 ; j ++ ) { allBits = ( allBits << 6 ) | decodeDigit ( data [ dataIndex ++ ] ) ; } allBits = allBits << 6 ; allBits = allBits << 6 ; allBits = allBits > > > 8 ; allBits = allBits > > > 8 ; result [ resultIndex ] = ( byte ) (", "gt": "allBits & 0xff ) ;", "prediction": "allBits & 0xff ) ;\n", "label": 1}
{"id": 1900, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . ecore . EObject ; public interface Interval1 extends EObject { String getStart ( ) ;", "gt": "void setStart ( String value ) ;", "prediction": "String getEnd ( ) ;\n", "label": 0}
{"id": 13316, "input": "<s> package org . eclipse . ui . internal . cheatsheets . composite . parser ; public interface ICompositeCheatsheetTags { public static final String COMPOSITE_CHEATSHEET = \"compositeCheatsheet\" ; public static final String COMPOSITE_CHEATSHEET_STATE = \"compositeCheatSheetState\" ; public static final String TASK = \"task\" ; public static final String TASK_GROUP = \"taskGroup\" ; public static final String EXPLORER = \"explorer\" ; public static final String NAME = \"name\" ; public static final String VALUE = \"value\" ; public static final String KIND = \"kind\" ; public static final String ON_COMPLETION = \"onCompletion\" ; public static final String DEPENDS_ON = \"dependsOn\" ; public static final String STATE = \"state\" ; public static final String TREE = \"tree\" ; public static final String CHEATSHEET_TASK_KIND = \"cheatsheet\" ; public static final String CHEATSHEET_TASK_ID = \"id\" ; public static final String CHEATSHEET_TASK_PATH = \"path\" ; public static final String CHEATSHEET_TASK_SHOW_INTRO = \"showIntro\" ; public static final String TASK_DATA = \"taskData\" ; public static final String CHEAT_SHEET_MANAGER = \"cheatSheetManager\" ;", "gt": "public static final String KEY = \"key\" ;", "prediction": "}\n", "label": 1}
{"id": 6467, "input": "<s> package javax . lang . model . element ; import java . util . List ; import javax . lang . model . type . * ; import javax . lang . model . util . * ; public interface TypeElement extends Element , Parameterizable , QualifiedNameable { List < ? extends Element > getEnclosedElements ( ) ; NestingKind getNestingKind ( ) ; Name getQualifiedName ( ) ; @", "gt": "Override Name getSimpleName ( ) ;", "prediction": "Override public TypeElement ( )\n", "label": 0}
{"id": 13330, "input": "<s> package org . apache . lucene . search ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; public class WildcardQuery extends MultiTermQuery { private boolean termContainsWildcard ; protected Term term ; public WildcardQuery ( Term term ) { super ( term ) ; this . term = term ; this . termContainsWildcard = ( term . text ( ) . indexOf ( '*' ) != - 1 ) || ( term . text ( ) . indexOf ( '?' ) != - 1 ) ; } protected FilteredTermEnum getEnum ( IndexReader reader ) throws IOException { return new WildcardTermEnum ( reader , getTerm ( ) ) ; } public Term getTerm ( ) { return term ; } public Query rewrite ( IndexReader reader ) throws IOException { if ( ! termContainsWildcard ) return new TermQuery ( getTerm ( ) ) ; else return super . rewrite ( reader ) ; } public String toString ( String field ) { StringBuffer buffer = new StringBuffer ( ) ; if ( ! term . field ( ) . equals ( field ) ) { buffer . append ( term . field ( ) ) ; buffer . append ( \":\" ) ; } buffer . append ( term . text ( ) ) ; buffer . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return buffer . toString ( ) ; } public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( term == null ) ? 0 : term . hashCode ( ) ) ; return result ; } public boolean equals ( Object obj ) {", "gt": "if ( this == obj ) return true ;", "prediction": "return true ;\n", "label": 1}
{"id": 5622, "input": "<s> package org . jjflyboy . tjpeditor ; import org . eclipse . xtext . junit4 . InjectWith ; import org . eclipselabs . xtext . utils . unittesting . XtextRunner2 ; import org . eclipselabs . xtext . utils . unittesting . XtextTest ; import org . jjflyboy . tjpeditor . project . NikuReport ; import org . junit . Test ; import org . junit . runner . RunWith ; @ InjectWith ( ProjectInjectorProvider . class ) @ RunWith ( XtextRunner2 . class ) public class NikuReportTest extends XtextTest { public NikuReportTest ( ) { super ( \"NikuReportTest\" ) ; } @ Test public void testAllAttributes ( ) { String text = \"nikureport  \\\"Report One\\\" {\" + \"end 2007-07-07 \" + \"formats csv, html \" + \"headline \\\"headline text\\\" \" + \"hideresource \\\"logical expression\\\" \" + \"hidetask \\\"logical expression\\\" \" + \"numberformat \\\"-\\\" \\\"\\\" \\\".\\\" \\\",\\\" 2\" + \"period 2010-01-16 + 4 m \" + \"start 2007-07-07 \" + \"timeoff \\\"nikutime\\\" \\\"Post Time\\\" \" + \"title \\\"title text\\\" \" + \"}\" ; testParserRule ( text , NikuReport", "gt": ". class . getSimpleName ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 13347, "input": "<s> package bad . robot . refactoring . chapter1 ; import org . junit . Test ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertThat ; public class CustomerTest { private static final Movie THE_HULK = new Movie ( \"The Hulk\" , Movie . CHILDREN ) ; private static final Movie IRON_MAN = new Movie ( \"Iron Man 4\" , Movie . NEW_RELEASE ) ; private static final Movie SPIDER_MAN = new Movie ( \"Spiderman\" , Movie . REGULAR ) ; private final Customer customer = new Customer ( \"fred\" ) ; @ Test public void basicChildrenRental ( ) { customer . addRental ( new Rental ( THE_HULK , 2 ) ) ; assertThat ( customer . statement ( ) , is ( expectedMessageFor ( \"The Hulk\" , 1.5 , 1.5 , 1 ) ) ) ; } @ Test public void shouldDiscountChildrensRentals ( ) { customer . addRental ( new Rental ( THE_HULK , 4 ) ) ; assertThat ( customer . statement ( ) , is ( expectedMessageFor ( \"The Hulk\" , 3.0 , 3.0 , 1 ) ) ) ; } @ Test public void basicNewReleaseRental ( ) { customer . addRental ( new Rental ( IRON_MAN , 1 ) ) ; assertThat ( customer . statement ( ) , is ( expectedMessageFor ( \"Iron Man 4\" , 3.0 , 3.0 , 1 ) ) ) ; } @ Test public void shouldNotDiscountNewReleaseRentalsButBonusFrequentRenterPoints ( ) { customer . addRental ( new Rental ( IRON_MAN , 4 ) ) ; assertThat ( customer . statement ( ) , is ( expectedMessageFor ( \"Iron Man 4\" , 12.0 ,", "gt": "12.0 , 2 ) ) ) ;", "prediction": "12.0 , 1 ) ) ) ;\n", "label": 1}
{"id": 7356, "input": "<s> package org . ofbiz . webapp . taglib ; import java . io . IOException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . jsp . JspException ; import javax . servlet . jsp . tagext . BodyContent ; import javax . servlet . jsp . tagext . BodyTagSupport ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilJ2eeCompat ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . webapp . website . WebSiteWorker ; import org . ofbiz . entity . GenericValue ; @ SuppressWarnings ( \"serial\" ) public class ContentUrlTag extends BodyTagSupport { public static final String module = UrlTag . class . getName ( ) ; @ Deprecated public static void appendContentPrefix ( HttpServletRequest request , StringBuffer urlBuffer ) { try { appendContentPrefix ( request , ( Appendable ) urlBuffer ) ; } catch ( IOException e ) { throw UtilMisc . initCause ( new InternalError ( e . getMessage ( ) ) , e ) ; } } public static void appendContentPrefix ( HttpServletRequest request , StringBuilder urlBuffer ) { try { appendContentPrefix ( request , ( Appendable ) urlBuffer ) ; } catch ( IOException e ) { throw UtilMisc . initCause ( new InternalError ( e . getMessage ( ) ) , e ) ; } } public static void appendContentPrefix ( HttpServletRequest request , Appendable urlBuffer ) throws IOException { if ( request == null ) { Debug . logWarning ( \"WARNING: request was null in appendContentPrefix; this probably means this was used where it shouldn't be, like using ofbizContentUrl in a screen rendered through a service; using best-bet behavior: standard prefix from url.properties (no WebSite or security setting known)\" , module ) ; String prefix = UtilProperties . getPropertyValue ( \"url\" , \"content.url.prefix.standard\" ) ; if ( prefix != null ) { urlBuffer . append ( prefix . trim ( ) ) ; } return ; } GenericValue webSite = WebSiteWorker . getWebSite ( request ) ; String forwardedProto = request . getHeader ( \"X-Forwarded-Proto\" ) ; boolean isForwardedSecure = UtilValidate . isNotEmpty ( forwardedProto ) && \"HTTPS\" . equals ( forwardedProto . toUpperCase ( ) ) ; boolean isSecure = request . isSecure ( ) || isForwardedSecure ; appendContentPrefix", "gt": "( webSite , isSecure , urlBuffer ) ;", "prediction": "( request , ( Appendable ) urlBuffer ) ;\n", "label": 0}
{"id": 13384, "input": "<s> package org . spliffy . server . manager ; import java . util . Date ; public class DefaultCurrentDateService implements CurrentDateService { @ Override public Date getNow ( ) { return", "gt": "new Date ( ) ;", "prediction": "now ;\n", "label": 1}
{"id": 689, "input": "<s> public class Boxing1 { static Boolean _Boolean = true ; static boolean _boolean = _Boolean ; static Byte _Byte = ( byte ) 3 ; static byte _byte = _Byte ; static Character _Character = 'a' ; static char _char = _Character ; static Short _Short = ( short ) 4 ; static short _short = _Short ; static Integer _Integer = 5 ; static int _int = _Integer ; static Long _Long = 12L ; static long _long = _Long ; static Float _Float = 1.2f ; static float _float = _Float ; static Double _Double = 1.34 ; static double _double = _Double ; public static void main ( String [ ] args ) { _Double = _Integer + _Integer + 0.0d ; if ( _Double != 10 ) throw new Error ( ) ; _Integer = 2 ; _float = _Integer ; if ( _float != 2.0f ) throw new Error ( ) ; _int = 12 ; _Float = _int + 0.0f ; if ( _Float != 12.0f ) throw new Error ( ) ; _Integer = 8 ; _float = ( float ) _Integer ; if ( _float != 8.0f ) throw new Error ( ) ; _int = 9 ; _Float = ( Float ) ( _int + 0.0f ) ; if ( _Float != 9.0f ) throw new Error ( ) ; if ( _Boolean ) ; else throw new Error ( ) ; if ( ! _Boolean ) throw new Error ( ) ; if ( _Integer >= _Long ) throw new Error ( ) ; _Character = 'a' ; String s1 = ( \"_\" + _Character + \"_\" ) . intern ( ) ; if ( s1 != \"_a_\" ) throw new Error ( s1 ) ; if ( _Integer ++ != 8 ) throw new Error ( ) ; if ( _Integer ++ != 9 ) throw new Error ( ) ; if ( ++ _Integer != 11 ) throw new Error ( ) ; if ( ( _Integer += 3 ) != 14 ) throw new Error ( ) ; if ( ( _Integer -= 3 ) != 11 ) throw new Error ( ) ; Integer i = 0 ; i = i + 2 ; i += 2 ; if ( i != 4 ) throw new Error ( ) ; int j = 0 ; j += i ; if ( j != 4 ) throw new Error ( ) ;", "gt": "Integer a [ ] = new Integer [ 1 ] ;", "prediction": "if ( j != 5 ) throw new Error ( ) ;\n", "label": 0}
{"id": 13385, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . LinkedList ; import org . apache . lucene . analysis . NumericTokenStream ; import org . apache . lucene . document . NumericField ; import org . apache . lucene . util . NumericUtils ; import org . apache . lucene . util . ToStringUtils ; import org . apache . lucene . util . StringHelper ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; public final class NumericRangeQuery extends MultiTermQuery { private NumericRangeQuery ( final String field , final int precisionStep , final int valSize , Number min , Number max , final boolean minInclusive , final boolean maxInclusive ) { assert ( valSize == 32 || valSize == 64 ) ; if ( precisionStep < 1 ) throw new IllegalArgumentException ( \"precisionStep must be >=1\" ) ; this . field = StringHelper . intern ( field ) ; this . precisionStep = precisionStep ; this . valSize = valSize ; this . min = min ; this . max = max ; this . minInclusive = minInclusive ; this . maxInclusive = maxInclusive ; switch ( valSize ) { case 64 : setRewriteMethod ( ( precisionStep > 6 ) ? CONSTANT_SCORE_FILTER_REWRITE : CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ) ; break ; case 32 : setRewriteMethod ( ( precisionStep > 8 ) ? CONSTANT_SCORE_FILTER_REWRITE : CONSTANT_SCORE_AUTO_REWRITE_DEFAULT ) ; break ; default : throw new IllegalArgumentException ( \"valSize must be 32 or 64\" ) ; } if ( min != null && min . equals ( max ) ) { setRewriteMethod ( CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE ) ; } } public static NumericRangeQuery newLongRange ( final String field , final int precisionStep , Long min , Long max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , precisionStep , 64 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newLongRange ( final String field , Long min , Long max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , NumericUtils . PRECISION_STEP_DEFAULT , 64 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newIntRange ( final String field , final int precisionStep , Integer min , Integer max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , precisionStep , 32 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newIntRange ( final String field , Integer min , Integer max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , NumericUtils . PRECISION_STEP_DEFAULT , 32 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newDoubleRange ( final String field , final int precisionStep , Double min , Double max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , precisionStep , 64 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newDoubleRange ( final String field , Double min , Double max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , NumericUtils . PRECISION_STEP_DEFAULT , 64 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newFloatRange ( final String field , final int precisionStep , Float min , Float max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , precisionStep , 32 , min , max , minInclusive , maxInclusive ) ; } public static NumericRangeQuery newFloatRange ( final String field , Float min , Float max , final boolean minInclusive , final boolean maxInclusive ) { return new NumericRangeQuery ( field , NumericUtils . PRECISION_STEP_DEFAULT , 32 , min , max , minInclusive , maxInclusive ) ; } protected FilteredTermEnum getEnum ( final IndexReader reader ) throws IOException { return new NumericRangeTermEnum ( reader ) ; } public String getField ( ) { return field ; } public boolean includesMin ( ) { return minInclusive ; } public boolean includesMax ( ) { return maxInclusive ; } public Number getMin ( ) { return min ; } public Number getMax ( ) { return max ; } public String toString ( final String field ) { final StringBuffer sb = new StringBuffer ( ) ; if ( ! this . field . equals ( field ) ) sb . append ( this . field ) . append ( ':' ) ; return sb . append ( minInclusive ? '[' : '{' ) . append ( ( min == null ) ? \"*\" : min . toString ( ) ) . append ( \" TO \" ) . append ( ( max == null ) ? \"*\" : max . toString ( ) ) . append ( maxInclusive ? ']' : '}' ) . append ( ToStringUtils . boost ( getBoost ( ) ) ) . toString ( ) ; } public final boolean equals", "gt": "( final Object o )", "prediction": "( final String field )\n", "label": 1}
{"id": 8113, "input": "<s> package org . bombusim . lime . data ; import android . content . ContentValues ; import android . content . Context ; import android . database . Cursor ; import android . database . SQLException ; import android . database . sqlite . SQLiteDatabase ; import android . database . sqlite . SQLiteOpenHelper ; public class RosterDbAdapter { protected final static String DATABASE_TABLE = \"contacts\" ; protected final static String DATABASE_NAME = \"contacts.db\" ; protected final static int DATABASE_VERSION = 3 ; public final static String KEY_ID = \"_id\" ; public final static String KEY_RJID = \"rosterjid\" ; public final static String KEY_JID = \"jid\" ; public final static String KEY_NAME = \"name\" ; public final static String KEY_GROUP = \"groups\" ; public final static String KEY_SUBSCR = \"subscr\" ; public final static String KEY_AVATAR = \"avatar\" ; public final static String KEY_CHAT = \"chat\" ; private ContactDbHelper dbHelper ; private SQLiteDatabase db ; public RosterDbAdapter ( Context context ) { dbHelper = new ContactDbHelper ( context ) ; } public void open ( ) { try { db = dbHelper . getWritableDatabase ( ) ; } catch ( SQLException ex ) { db = dbHelper . getReadableDatabase ( ) ; } } public void close ( ) { db . close ( ) ; } public long putContact ( Contact contact , long position ) { ContentValues v = new ContentValues ( ) ; v . put ( KEY_RJID , contact . getRosterJid ( ) ) ; v . put ( KEY_JID , contact . getJid ( ) ) ; v . put ( KEY_NAME , contact . getName ( ) ) ; v . put ( KEY_GROUP , contact . getAllGroups ( ) ) ; v . put ( KEY_SUBSCR , contact . getSubscription ( ) ) ; v . put ( KEY_AVATAR , contact . getAvatarId ( ) ) ; v . put ( KEY_CHAT , contact . hasActiveChats ( ) ? 1 : 0 ) ; long id = - 1 ; if ( position < 0 ) { id = db . insert ( DATABASE_TABLE , null , v ) ; } else { id = db . update ( DATABASE_TABLE , v , KEY_ID + \"=\" + position , null ) ; } contact . setId ( id ) ; return id ; } public long removeContact ( long position ) { return db . delete ( DATABASE_TABLE , KEY_ID + \"=\" + position , null ) ; } public long [ ] getContactIndexes ( String rosterJid ) { String select = ( rosterJid != null ) ? KEY_RJID + \"='\" + rosterJid + \"'\" : null ; Cursor ind = db . query ( DATABASE_TABLE , new String [ ] { KEY_ID } , select , null , null , null , null ) ; int count = ind . getCount ( ) ; if ( count == 0 || ! ind . moveToFirst ( ) ) { ind . close ( ) ; return null ; } long [ ] result = new long [ count ] ; int id = ind . getColumnIndex ( KEY_ID ) ; for ( int i = 0 ; i < count ; i ++ ) { result [ i ] = ind . getLong ( id ) ; ind . moveToNext ( ) ; } ind . close ( ) ; return result ; } public Contact getContact ( long position ) { Cursor cursor = db . query ( DATABASE_TABLE , null , KEY_ID + \"=\" + position , null , null , null , null ) ; if ( cursor . getCount ( ) == 0 || ! cursor . moveToFirst ( ) ) return null ; Contact c = getContactFromCursor ( cursor ) ; cursor . close ( ) ; return c ; } public Contact getContact ( String jid ) { Cursor cursor = db . query ( DATABASE_TABLE , null , KEY_JID + \"=\" + jid , null , null , null , null ) ; if ( cursor . getCount ( ) == 0 || ! cursor . moveToFirst ( ) ) return null ; Contact c = getContactFromCursor ( cursor ) ; cursor . close ( ) ; return c ; } public Contact getContactFromCursor ( Cursor cursor ) { String jid = cursor . getString ( cursor . getColumnIndex ( KEY_JID ) ) ; String name = cursor . getString ( cursor . getColumnIndex ( KEY_NAME ) ) ; String rJid = cursor . getString ( cursor . getColumnIndex ( KEY_RJID ) ) ; long id = cursor . getLong ( cursor . getColumnIndex ( KEY_ID ) ) ; Contact c = ( jid . equals ( rJid ) ) ? new SelfContact ( jid , name , id ) : new Contact ( jid , name , id ) ; c . setRJid ( rJid ) ; c . setAllGroups ( cursor . getString ( cursor . getColumnIndex ( KEY_GROUP ) ) ) ; c . setSubscription ( cursor . getInt ( cursor . getColumnIndex ( KEY_SUBSCR ) ) ) ; c . setAvatar ( null , cursor . getString ( cursor . getColumnIndex ( KEY_AVATAR ) ) ) ; c . setActiveChats ( cursor . getInt ( cursor . getColumnIndex ( KEY_CHAT ) ) != 0 ) ; c . setUpdate ( Contact . UPDATE_NONE ) ; return c ; } private class ContactDbHelper extends SQLiteOpenHelper { private static final String DATABASE_CREATE = \"CREATE TABLE \" + DATABASE_TABLE + \" (\" + KEY_ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \" + KEY_RJID + \" TEXT NOT NULL, \" + KEY_JID + \" TEXT NOT NULL, \" + KEY_NAME + \" TEXT, \" + KEY_GROUP + \" TEXT, \" + KEY_AVATAR + \" TEXT, \" + KEY_CHAT + \" INTEGER, \" + KEY_SUBSCR + \" INTEGER);\" ; public ContactDbHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; } @ Override public", "gt": "void onCreate ( SQLiteDatabase db )", "prediction": "String toString ( )\n", "label": 0}
{"id": 13397, "input": "<s> package org . nuxeo . ecm . platform . picture . magick . utils ; import org . nuxeo . ecm . platform . commandline . executor . api . CmdParameters ; import org . nuxeo . ecm . platform . picture . magick . MagickExecutor ; public class ImageCropperAndResizer extends MagickExecutor { public static void cropAndResize ( String inputFilePath , String outputFilePath , int tileWidth , int tileHeight , int offsetX , int offsetY , int targetWidth , int targetHeight ) throws Exception { CmdParameters params = new CmdParameters ( ) ; params . addNamedParameter ( \"tileWidth\" , String . valueOf ( tileWidth ) ) ; params . addNamedParameter (", "gt": "\"tileHeight\" , String . valueOf ( tileHeight ) ) ;", "prediction": "\"tileHeight\" , String . valueOf ( tileHeight ) ) ;\n", "label": 1}
{"id": 3980, "input": "<s> class ErrSyntheticNameConflict { static class Outer { ErrSyntheticNameConflict this$0 = null ; }", "gt": "public class Inner extends Outer", "prediction": "}\n", "label": 0}
{"id": 13413, "input": "<s> package com . google . code . microlog4android ; import static org . junit . Assert . assertTrue ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; public class StopWatchTest { private StopWatch stopWatch ; @ Before public void setup ( ) { stopWatch = new StopWatch ( ) ; stopWatch . start ( ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException ie ) { ie . printStackTrace ( ) ; } } @ After public void teardown ( ) { stopWatch", "gt": ". reset ( ) ;", "prediction": ". teardown ( ) ;\n", "label": 1}
{"id": 6855, "input": "<s> package org . ofbiz . entity ; import java . net . URL ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . entity . cache . Cache ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . datasource . GenericHelper ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . eca . EntityEcaHandler ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelFieldType ; import org . ofbiz . entity . model . ModelFieldTypeReader ; import org . ofbiz . entity . model . ModelGroupReader ; import org . ofbiz . entity . model . ModelReader ; import org . ofbiz . entity . util . DistributedCacheClear ; import org . ofbiz . entity . util . EntityCrypto ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . SequenceUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public interface Delegator { public void clearAllCacheLinesByDummyPK ( Collection < GenericPK > dummyPKs ) ; public void clearAllCacheLinesByValue ( Collection < GenericValue > values ) ; public void clearAllCaches ( ) ; public void clearAllCaches ( boolean distribute ) ; public void clearCacheLine ( GenericPK primaryKey ) ; public void clearCacheLine ( GenericPK primaryKey , boolean distribute ) ; public void clearCacheLine ( GenericValue value ) ; public void clearCacheLine ( GenericValue value , boolean distribute ) ; public void clearCacheLine ( String entityName ) ; public void clearCacheLine ( String entityName , Map < String , ? extends Object > fields ) ; public void clearCacheLine ( String entityName , Object ... fields ) ; public void clearCacheLineByCondition ( String entityName , EntityCondition condition ) ; public void clearCacheLineByCondition ( String entityName , EntityCondition condition , boolean distribute ) ; public void clearCacheLineFlexible ( GenericEntity dummyPK ) ; public void clearCacheLineFlexible ( GenericEntity dummyPK , boolean distribute ) ; public GenericDelegator cloneDelegator ( ) ; public GenericDelegator cloneDelegator ( String delegatorName ) ; public GenericValue create ( GenericPK primaryKey ) throws GenericEntityException ; public GenericValue create ( GenericPK primaryKey , boolean doCacheClear ) throws GenericEntityException ; public GenericValue create ( GenericValue value ) throws GenericEntityException ; public GenericValue create ( GenericValue value , boolean doCacheClear ) throws GenericEntityException ; public GenericValue create ( String entityName , Map < String , ? extends Object > fields ) throws GenericEntityException ; public GenericValue create ( String entityName , Object ... fields ) throws GenericEntityException ; public GenericValue createOrStore ( GenericValue value ) throws GenericEntityException ; public GenericValue createOrStore ( GenericValue value , boolean doCacheClear ) throws GenericEntityException ; public GenericValue createSetNextSeqId ( GenericValue value ) throws GenericEntityException ; public GenericValue createSingle ( String entityName , Object singlePkValue ) throws GenericEntityException ; public void decryptFields ( GenericEntity entity ) throws GenericEntityException ; public void decryptFields ( List < ? extends GenericEntity > entities ) throws GenericEntityException ; public void encryptFields ( GenericEntity entity ) throws GenericEntityException ; public void encryptFields ( List < ? extends GenericEntity", "gt": "> entities ) throws GenericEntityException ;", "prediction": "> entities ) throws GenericEntityException ;\n", "label": 0}
{"id": 13414, "input": "<s> package com . yahoo . ycsb . db ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . UnknownHostException ; import java . util . LinkedList ; import java . util . List ; import java . util . Random ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import net . spy . memcached . CASResponse ; import net . spy . memcached . MemcachedClient ; import com . yahoo . ycsb . memcached . Memcached ; public class MembaseClient extends Memcached { MemcachedClient client ; public static final String VERBOSE = \"memcached.verbose\" ; public static final String VERBOSE_DEFAULT = \"true\" ; public static final String SIMULATE_DELAY = \"memcached.simulatedelay\" ; public static final String SIMULATE_DELAY_DEFAULT = \"0\" ; public static final String MEMCACHED_ADDRESS = \"memcached.address\" ; public static final String MEMCACHED_ADDRESS_DEFAULT = \"10.2.1.67\" ; public static final String MEMBASE_BUCKET = \"membase.bucket\" ; public static final String MEMBASE_BUCKET_DEFAULT = \"default\" ; public static final String MEMBASE_PASSWORD = \"membase.password\" ; public static final String MEMBASE_PASSWORD_DEFAULT = \"\" ; public static long endtime ; Random random ; boolean verbose ; int todelay ; public MembaseClient ( ) { random = new Random ( ) ; todelay = 0 ; } public void init ( ) { String address = getProperties ( ) . getProperty ( MEMCACHED_ADDRESS , MEMCACHED_ADDRESS_DEFAULT ) ; String bucketName = getProperties ( ) . getProperty ( MEMBASE_BUCKET , MEMBASE_BUCKET_DEFAULT ) ; String password = getProperties ( ) . getProperty ( MEMBASE_PASSWORD , MEMBASE_PASSWORD_DEFAULT ) ; verbose = Boolean . parseBoolean ( getProperties ( ) . getProperty ( VERBOSE , VERBOSE_DEFAULT ) ) ; todelay = Integer . parseInt ( getProperties ( ) . getProperty ( SIMULATE_DELAY , SIMULATE_DELAY_DEFAULT ) ) ; try { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( new URI ( \"http://\" + address + \":8091/pools\" ) ) ; client = new MemcachedClient ( uris , bucketName , password ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } } public void cleanup ( ) { if ( client . isAlive ( ) ) client . shutdown ( ) ; } @ Override public int add ( String key , Object value ) { try { if ( ! client . add ( key , 0 , value ) . get ( ) . booleanValue", "gt": "( ) ) return - 1 ;", "prediction": "( ) )\n", "label": 1}
{"id": 1361, "input": "<s> package com . sun . tools . apt . util ; import com . sun . tools . javac . util . Context ; import com . sun . tools . javac . util . JCDiagnostic ; import com . sun . tools . javac . util . JCDiagnostic . SimpleDiagnosticPosition ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . JavacMessages ; import com . sun . tools . javac . util . Position ; public class Bark extends Log { protected static final Context . Key < Bark > barkKey = new Context . Key < Bark > ( ) ; public static void preRegister ( Context context ) { context . put ( barkKey , new Context . Factory < Bark > ( ) { public Bark make ( Context c ) { return new Bark ( c ) ; } } ) ; context . put ( Log . logKey , new Context . Factory < Log > ( ) { public Log make ( Context c ) { return Bark . instance ( c ) ; } } ) ; } public static Bark instance ( Context context ) { Bark instance = context . get ( barkKey ) ; if ( instance == null ) instance = new Bark ( context ) ; return instance ; } private boolean ignoreDiagnostics ; private JCDiagnostic . Factory aptDiags ; protected Bark ( Context context ) { super ( context ) ; context . put ( barkKey , this ) ; JavacMessages aptMessages = JavacMessages . instance ( context ) ; aptMessages . add ( \"com.sun.tools.apt.resources.apt\" ) ; aptDiags = new JCDiagnostic . Factory ( aptMessages , \"apt\" ) ; multipleErrors = true ; } public boolean setDiagnosticsIgnored ( boolean b ) { boolean prev = ignoreDiagnostics ; ignoreDiagnostics = b ; return prev ; } @ Override public void", "gt": "report ( JCDiagnostic diagnostic )", "prediction": "setDiagnosticsIgnored ( boolean b )\n", "label": 0}
{"id": 13438, "input": "<s> package org . eclipse . swt . internal . widgets . coolbarkit ; import org . eclipse . swt . internal . widgets . controlkit . ControlThemeAdapter ; import org . eclipse . swt . widgets . Control ; public class CoolBarThemeAdapter extends ControlThemeAdapter {", "gt": "public int getBorderWidth ( Control control )", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 3328, "input": "<s> public class SuperNew4 { void foo ( ) { class One { One ( Object o ) { } One ( ) { this ( new Object ( ) { { new", "gt": "One ( null ) ;", "prediction": "Object ( )\n", "label": 0}
{"id": 13443, "input": "<s> package org . fuzzydb . server . internal . search ; import org . fuzzydb . attrs . Score ; import org . fuzzydb . attrs . Scorer ; public class ResultsQ extends Q < NextItem > { private int resultsQAdded = 0 ; private volatile Score currentScoreThreshold ; private final int targetNumResults ; public ResultsQ ( final int maxNonMatches , final float scoreThreshold , int targetNumResults ) { this . targetNumResults = targetNumResults ; this . currentScoreThreshold = new Score ( ) { private static final long serialVersionUID = 1L ; @ Override public void add ( Scorer s , float score , Direction d ) { throw new UnsupportedOperationException ( ) ; } @ Override protected void update ( ) { this . linear = scoreThreshold ; this", "gt": ". nonMatches = maxNonMatches ;", "prediction": ". targetNumResults = targetNumResults ;\n", "label": 1}
{"id": 4737, "input": "<s> package me . chester . minitruco . core ; public abstract class Jogo implements Runnable { protected static final String letrasOrdenadas = \"4567QJKA23\" ; int numRodadaAtual ; public static int getValorTruco ( Carta c , char letraManilha ) { if ( c . isFechada ( ) ) { return 0 ; } if ( letraManilha == SituacaoJogo . MANILHA_INDETERMINADA ) { if ( c . getLetra ( ) == '7' && c . getNaipe ( ) == Carta . NAIPE_OUROS ) { return 11 ; } else if ( c . getLetra ( ) == 'A' && c . getNaipe ( ) == Carta . NAIPE_ESPADAS ) { return 12 ; } else if ( c . getLetra ( ) == '7' && c . getNaipe ( ) == Carta . NAIPE_COPAS ) { return 13 ; } else if ( c . getLetra ( ) == '4' && c . getNaipe ( ) == Carta . NAIPE_PAUS ) { return 14 ; } } if ( c . getLetra ( ) == letraManilha ) { switch ( c . getNaipe ( ) ) { case Carta . NAIPE_OUROS : return 11 ; case Carta . NAIPE_ESPADAS : return 12 ; case Carta . NAIPE_COPAS : return 13 ; case Carta . NAIPE_PAUS : return 14 ; default : return 0 ; } } else { return letrasOrdenadas . indexOf ( c . getLetra ( ) ) + 1 ; } } protected Jogador [ ] jogadores = new Jogador [ 4 ] ; protected int numJogadores = 0 ; protected Carta [ ] [ ] cartasJogadasPorRodada ; public abstract void run ( ) ; public abstract void jogaCarta ( Jogador j , Carta c ) ; public abstract void decideMao11 ( Jogador j , boolean aceita ) ; public abstract void aumentaAposta ( Jogador j ) ; public abstract void respondeAumento ( Jogador j , boolean aceitou ) ; public Carta [ ] getCartasDaRodada ( int rodada ) { return cartasJogadasPorRodada [ rodada - 1 ] ; } public Carta cartaDaMesa ; public abstract void atualizaSituacao ( SituacaoJogo s , Jogador j ) ; public abstract boolean isBaralhoLimpo ( ) ; public abstract boolean isManilhaVelha ( ) ; protected int getValorTruco ( Carta c ) { return getValorTruco ( c , this . getManilha ( ) ) ; } public synchronized boolean adiciona ( Jogador jogador ) { if ( jogador instanceof Jogador ) { Jogador j = ( Jogador ) jogador ; if ( numJogadores == 4 ) { return false ; } jogadores [ numJogadores ] = j ; numJogadores ++ ; j . setPosicao ( numJogadores ) ; } for ( Jogador j : jogadores ) { if ( j != null ) { j . entrouNoJogo ( jogador , this ) ; } } return true ; } protected Jogador getJogador ( int posicao ) { return jogadores [ posicao - 1 ] ; } private char manilha ; protected int [ ] pontosEquipe = { 0 , 0 } ; public boolean jogoFinalizado = false ; public char getManilha ( ) { return manilha ; } public void setManilha ( Carta c ) { cartaDaMesa = c ; if ( isManilhaVelha ( ) ) { manilha = SituacaoJogo . MANILHA_INDETERMINADA ; return ; } int posManilha = letrasOrdenadas . indexOf ( c . getLetra ( ) ) + 1 ; if ( posManilha == letrasOrdenadas . length ( ) ) { posManilha = 0 ; } manilha = letrasOrdenadas . charAt ( posManilha ) ; if ( isBaralhoLimpo ( ) && c . getLetra ( ) == '3' ) { manilha = 'Q' ; } } public boolean isAlguemTem11Pontos ( ) { return pontosEquipe [ 0 ] == 11", "gt": "|| pontosEquipe [ 1 ] == 11 ;", "prediction": ";\n", "label": 0}
{"id": 13451, "input": "<s> package org . fuzzydb . server . internal . server . txlog ; import java . io . IOException ; import org . fuzzydb . io . core . messages . Command ; public class NullTxLogWriter implements TxLogSink { public void flush ( ) throws IOException { } public void write ( long", "gt": "version , Command command ) throws IOException", "prediction": "serialVersion ) throws IOException\n", "label": 1}
{"id": 9532, "input": "<s> package com . redhat . ceylon . compiler . java . test . structure ; import org . junit . Test ; import com . redhat . ceylon . compiler . java . test . CompilerTest ; public class StructureTest3 extends CompilerTest { @ Override protected String transformDestDir ( String name ) { return name + \"-3\" ; } @ Test public void testMcrInstantiatorDelegates ( ) { compareWithJavaSource ( \"mcr/InstantiatorDelegates\" ) ; } @ Test public void testMcrClassDefaultMemberClass ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClass\" ) ; } @ Test public void testMcrClassDefaultMemberClassWithParams ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassWithParams\" ) ; } @ Test public void testMcrClassDefaultMemberClassWithDefaultedParams ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassWithDefaultedParams\" ) ; } @ Test public void testMcrClassDefaultMemberClassWithSequencedParams ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassWithSequencedParams\" ) ; } @ Test public void testMcrClassDefaultMemberClassWithTypeParams ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassWithTypeParams\" ) ; } @ Test public void testMcrClassMemberClassesWithMemberSubclasses ( ) { compareWithJavaSource ( \"mcr/ClassMemberClassesWithMemberSubclasses\" ) ; } @ Test public void testMcrInterfaceDefaultMemberClass ( ) { compareWithJavaSource ( \"mcr/InterfaceDefaultMemberClass\" ) ; } @ Test public void testMcrInterfaceMemberClassesWithMemberSubclasses ( ) { compareWithJavaSource ( \"mcr/InterfaceMemberClassesWithMemberSubclasses\" ) ; } @ Test public void testMcrClassFormalMemberClass ( ) { compareWithJavaSource ( \"mcr/ClassFormalMemberClass\" ) ; } @ Test public void testMcrClassDefaultMemberClassReference ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassReference\" ) ; } @ Test public void testMcrClassDefaultMemberClassSpecifier ( ) { compareWithJavaSource ( \"mcr/ClassDefaultMemberClassSpecifier\" ) ; }", "gt": "@ Test public void testMcrInterfaceFormalMemberClass_fail ( )", "prediction": "}\n", "label": 0}
{"id": 13460, "input": "<s> package org . fuzzydb . dto . attributes ; import java . io . Serializable ; public abstract class Attribute < V > implements Serializable { private static final long serialVersionUID = 1L ; private String name ; public Attribute ( String name ) { assert name != null ; this . name = name ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; }", "gt": "public abstract V getValueAsObject ( ) ;", "prediction": "}\n", "label": 1}
{"id": 4568, "input": "<s> package models ; import java . sql . Blob ; import java . util . List ; import javax . persistence . Entity ; import javax . persistence . Id ; import javax . persistence . Lob ; import play . db . ebean . Model ; @ Entity public class Picture extends Model { private static final long serialVersionUID = 1L ; @ Id public Long idpicture ; public Long idscrapbook ; public String path ; @ Lob public byte [ ] photo ; public Integer position ; public Float size ; public Float posX ; public Float posY ; public Float degrees ; public static Finder < Long , Picture > find = new Finder < Long , Picture > ( Long . class , Picture . class ) ; public static List < Picture > all ( ) { return find . all ( ) ; } public static Picture get ( Long id ) { return", "gt": "find . byId ( id ) ;", "prediction": "id ;\n", "label": 0}
{"id": 13470, "input": "<s> package com . talis . hbase . rdf . connection ; import java . util . List ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . hbase . HColumnDescriptor ; import org . apache . hadoop . hbase . HTableDescriptor ; import org . apache . hadoop . hbase . client . HBaseAdmin ; import org . apache . hadoop . hbase . client . HTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class HBaseRdfConnection { static private Logger LOG = LoggerFactory . getLogger ( HBaseRdfConnection . class ) ; private Configuration config = null ; private HBaseAdmin admin = null ; private static final long CLIENT_CACHE_SIZE = 20971520 ; public HBaseRdfConnection ( String configFile ) { this . config = HBaseRdfConnectionFactory . createHBaseConfiguration ( configFile ) ; this . config . setQuietMode ( true ) ; this . admin = HBaseRdfConnectionFactory . createHBaseAdmin ( config ) ; } public HBaseRdfConnection ( Configuration config ) { this . config = config ; this . config . setQuietMode ( true ) ; this . admin = HBaseRdfConnectionFactory . createHBaseAdmin ( config ) ; } public Configuration getConfiguration ( ) { return config ; } public static HBaseRdfConnection none ( ) { return new HBaseRdfConnection ( \"none\" ) ; } public boolean hasAdminConnection ( ) { return admin != null ; } public HBaseAdmin getAdmin ( ) { return admin ; } public boolean doesTableExist ( String tableName ) { boolean tableExists = false ; try { tableExists = admin . tableExists ( tableName ) ; } catch ( Exception e ) { exception ( \"tableExists\" , e , tableName ) ; } return tableExists ; } public HTable openTable ( String tableName ) { HTable table = null ; try { admin . disableTable ( tableName ) ; admin . enableTable ( tableName ) ; table = new HTable ( config , tableName ) ; table . setAutoFlush ( false ) ; table . setWriteBufferSize ( CLIENT_CACHE_SIZE ) ; } catch ( Exception e ) { exception", "gt": "( \"openTable\" , e , tableName ) ;", "prediction": "( \"tableExists\" , e , tableName ) ;\n", "label": 1}
{"id": 4813, "input": "<s> package com . redhat . nitrate ;", "gt": "public class TcmsHashCommand extends TcmsCommand", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 13481, "input": "<s> package org . restlet . engine . io ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . channels . Channel ; import java . nio . channels . Channels ; import java . nio . channels . FileChannel ; import java . nio . channels . ReadableByteChannel ; import java . nio . channels . SelectableChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . nio . channels . WritableByteChannel ; import java . util . logging . Level ; import org . restlet . Context ; import org . restlet . engine . Edition ; import org . restlet . representation . Representation ; public class NioUtils { public static int copy ( ByteBuffer sourceBuffer , ByteBuffer targetBuffer , long maxCopied ) { int maxBuffer = Math . min ( sourceBuffer . remaining ( ) , targetBuffer . remaining ( ) ) ; int result = ( maxCopied == 0 ) ? maxBuffer : Math . min ( ( int ) maxCopied , maxBuffer ) ; for ( int i = 0 ; i < result ; i ++ ) { targetBuffer . put ( sourceBuffer . get ( ) ) ; } return result ; } public static void copy ( FileChannel fileChannel , WritableByteChannel writableChannel ) throws IOException { long position = 0 ; long count = fileChannel . size ( ) ; long written = 0 ; SelectableChannel selectableChannel = null ; if ( writableChannel instanceof SelectableChannel ) { selectableChannel = ( SelectableChannel ) writableChannel ; } while ( count > 0 ) { NioUtils . waitForState ( selectableChannel , SelectionKey . OP_WRITE ) ; written = fileChannel . transferTo ( position , count , writableChannel ) ; position += written ; count -= written ; } } public static void copy ( ReadableByteChannel readableChannel , OutputStream outputStream ) throws IOException { if ( ( readableChannel != null ) && ( outputStream != null ) ) { BioUtils . copy ( new NbChannelInputStream ( readableChannel ) , outputStream ) ; } } public static void copy ( ReadableByteChannel readableChannel , WritableByteChannel writableChannel ) throws IOException { if ( ( readableChannel != null ) && ( writableChannel != null ) ) { BioUtils . copy ( new NbChannelInputStream ( readableChannel ) , new NbChannelOutputStream ( writableChannel ) ) ; } } public static ReadableByteChannel getChannel ( InputStream inputStream ) throws IOException { ReadableByteChannel result = null ; if ( inputStream instanceof FileInputStream ) { result = ( ( FileInputStream ) inputStream ) . getChannel ( ) ; } else if ( inputStream != null ) { result = new InputStreamChannel ( inputStream ) ; } return result ; } public static WritableByteChannel", "gt": "getChannel ( OutputStream outputStream )", "prediction": "getChannel ( ReadableByteChannel writableChannel ) throws IOException\n", "label": 1}
{"id": 4522, "input": "<s> package org . jjflyboy . tjpeditor . generator ; import org . eclipse . emf . ecore . resource . Resource ; import org . eclipse . xtext . generator . IFileSystemAccess ; import org . eclipse . xtext . generator . IGenerator ; @ SuppressWarnings ( \"all\"", "gt": ") public class ProjectGenerator implements IGenerator", "prediction": ") public class FileSystemAccess implements IFileSystemAccess\n", "label": 0}
{"id": 13506, "input": "<s> package com . codeslap . test . persistence ; import com . codeslap . persistence . SqlAdapter ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; public class CollectionInsertionTest extends SqliteTest { @ Test public void testCollectionInsertionTest ( ) { List < ExampleAutoincrement > collection = new ArrayList < ExampleAutoincrement > ( ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < 50000 ; i ++ ) { ExampleAutoincrement foo = new ExampleAutoincrement ( ) ; foo . name = \"Foo Bar \" + random . nextInt ( ) ; foo . number = random . nextInt ( ) ; foo . decimal = random . nextFloat ( ) ; foo . bool = random . nextBoolean ( ) ; foo . blob = foo . name . getBytes ( ) ; collection . add ( foo ) ; } getAdapter ( ) . storeCollection ( collection , new SqlAdapter . ProgressListener ( ) { @ Override public void onProgressChange ( int percentage ) { } } ) ; performTesting ( collection ) ; getAdapter ( ) . delete ( ExampleAutoincrement . class , null , null ) ; getAdapter ( ) . storeCollection ( collection , null ) ; performTesting ( collection ) ; } private void performTesting ( List < ExampleAutoincrement > collection ) { assertEquals ( collection . size ( ) , getAdapter ( ) . findAll ( ExampleAutoincrement . class , null , null", "gt": ") . size ( ) ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 2743, "input": "<s> package com . sun . tools . javac . jvm ; public interface ByteCodes { int illegal = - 1 , nop = 0 , aconst_null = 1 , iconst_m1 = 2 , iconst_0 = 3 , iconst_1 = 4 , iconst_2 = 5 , iconst_3 = 6 , iconst_4 = 7 , iconst_5 = 8 , lconst_0 = 9 , lconst_1 = 10 , fconst_0 = 11 , fconst_1 = 12 , fconst_2 = 13 , dconst_0 = 14 , dconst_1 = 15 , bipush = 16 , sipush = 17 , ldc1 = 18 , ldc2 = 19 , ldc2w = 20 , iload = 21 , lload = 22 , fload = 23 , dload = 24 , aload = 25 , iload_0 = 26 , iload_1 = 27 , iload_2 = 28 , iload_3 = 29 , lload_0 = 30 , lload_1 = 31 , lload_2 = 32 , lload_3 = 33 , fload_0 = 34 , fload_1 = 35 , fload_2 = 36 , fload_3 = 37 , dload_0 = 38 , dload_1 = 39 , dload_2 = 40 , dload_3 = 41 , aload_0 = 42 , aload_1 = 43 , aload_2 = 44 , aload_3 = 45 , iaload = 46 , laload = 47 , faload = 48 , daload = 49 , aaload = 50 , baload = 51 , caload = 52 , saload = 53 , istore = 54 , lstore = 55 , fstore = 56 , dstore = 57 , astore = 58 , istore_0 = 59 , istore_1 = 60 , istore_2 = 61 , istore_3 = 62 , lstore_0 = 63 , lstore_1 = 64 , lstore_2 = 65 , lstore_3 = 66 , fstore_0 = 67 , fstore_1 = 68 , fstore_2 = 69 , fstore_3 = 70 , dstore_0 = 71 , dstore_1 = 72 , dstore_2 = 73 , dstore_3 = 74 , astore_0 = 75 , astore_1 = 76 , astore_2 = 77 , astore_3 = 78 , iastore = 79 , lastore = 80 , fastore = 81 , dastore = 82 , aastore = 83 , bastore = 84 , castore = 85 , sastore = 86 , pop = 87 , pop2 = 88 , dup = 89 , dup_x1 = 90 , dup_x2 = 91 , dup2 = 92 , dup2_x1 = 93 , dup2_x2 = 94 , swap = 95 , iadd = 96 , ladd = 97 , fadd = 98 , dadd = 99 , isub = 100 , lsub = 101 , fsub = 102 , dsub = 103 , imul = 104 , lmul = 105 , fmul = 106 , dmul = 107 , idiv = 108 , ldiv = 109 , fdiv = 110 , ddiv = 111 , imod = 112 , lmod = 113 , fmod = 114 , dmod = 115 , ineg = 116 , lneg = 117 , fneg = 118 , dneg = 119 , ishl = 120 , lshl = 121 , ishr = 122 , lshr = 123 , iushr = 124 , lushr = 125 , iand = 126 , land = 127 , ior = 128 , lor = 129 , ixor = 130 , lxor = 131 , iinc = 132 , i2l = 133 , i2f = 134 , i2d = 135 , l2i = 136 , l2f = 137 , l2d = 138 , f2i = 139 , f2l = 140 , f2d = 141 , d2i = 142 , d2l = 143 , d2f = 144 , int2byte = 145 , int2char = 146 , int2short = 147 , lcmp = 148 , fcmpl = 149 , fcmpg = 150 , dcmpl = 151 , dcmpg = 152 , ifeq = 153 , ifne = 154 , iflt = 155 , ifge = 156 , ifgt = 157 , ifle = 158 , if_icmpeq = 159 , if_icmpne = 160 , if_icmplt = 161 , if_icmpge = 162 , if_icmpgt = 163 , if_icmple = 164 , if_acmpeq = 165 , if_acmpne = 166 , goto_ = 167 , jsr = 168 , ret = 169 , tableswitch = 170 , lookupswitch = 171 , ireturn = 172 , lreturn = 173 , freturn = 174 , dreturn = 175 , areturn = 176 , return_ = 177 , getstatic = 178 , putstatic = 179 , getfield = 180 , putfield = 181 , invokevirtual = 182 , invokespecial = 183 , invokestatic = 184 , invokeinterface = 185 , invokedynamic = 186 , new_ = 187 , newarray = 188 , anewarray = 189 , arraylength = 190 , athrow = 191 , checkcast = 192 , instanceof_ = 193 , monitorenter = 194 , monitorexit = 195 , wide = 196 , multianewarray = 197 , if_acmp_null = 198 , if_acmp_nonnull = 199 , goto_w = 200 , jsr_w = 201 , breakpoint = 202 , ByteCodeCount = 203 ; int string_add = 256 , bool_not = 257 , bool_and = 258 , bool_or = 259 ; int ishll = 270 , lshll = 271 , ishrl = 272 , lshrl = 273 , iushrl = 274 , lushrl = 275 ; int nullchk = 276 ; int error = 277 ; int dontgoto = jsr ; int preShift = 9 ; int preMask = ( 1 << preShift ) - 1 ; int INTcode = 0 , LONGcode = 1 , FLOATcode = 2 , DOUBLEcode = 3 , OBJECTcode = 4 , BYTEcode = 5 , CHARcode = 6 , SHORTcode = 7 , VOIDcode = 8 , TypeCodeCount = 9 ; static final", "gt": "String [ ] typecodeNames =", "prediction": "long serialVersionUID = 1L ;\n", "label": 0}
{"id": 13513, "input": "<s> package org . jscsi . parser . nop ; import org . jscsi . exception . InternetSCSIException ; import org . jscsi . parser . Constants ; import org . jscsi . parser . ProtocolDataUnit ; import org . jscsi . parser . TargetMessageParser ; import org . jscsi . parser . datasegment . DataSegmentFactory . DataSegmentFormat ; import org . jscsi . utils . Utils ; public final class NOPInParser extends TargetMessageParser { private int targetTransferTag ; public NOPInParser ( final ProtocolDataUnit initProtocolDataUnit ) { super ( initProtocolDataUnit ) ; } public final int getTargetTransferTag ( ) { return targetTransferTag ; } public final void setTargetTransferTag ( final int targetTransferTag ) { this . targetTransferTag = targetTransferTag ; } @ Override public final String toString ( ) { final StringBuilder sb = new StringBuilder ( Constants . LOG_INITIAL_SIZE ) ; Utils . printField ( sb ,", "gt": "\"LUN\" , logicalUnitNumber , 1 ) ;", "prediction": "sb . toString ( ) ) ;\n", "label": 1}
{"id": 7108, "input": "<s> package com . nesscomputing . hbase ; import static java . lang . String . format ; import com . google . common . base . Preconditions ; import com . google . common . collect . ImmutableMap ; import com . google . inject . AbstractModule ; import com . google . inject . Inject ; import com . google . inject . Injector ; import com . google . inject . Key ; import com . google . inject . Provider ; import com . google . inject . Scopes ; import com . google . inject . name . Named ; import com . google . inject . name . Names ; import org . apache . commons . lang3 . StringUtils ; import org . apache . hadoop . conf . Configuration ; import org . weakref . jmx . guice . MBeanModule ; import com . nesscomputing . config . ConfigProvider ; import com . nesscomputing . hbase . spill . SpillController ; import com . nesscomputing . hbase . spill . SpillReader ; import com . nesscomputing . lifecycle . LifecycleStage ; import com . nesscomputing . lifecycle . guice . AbstractLifecycleProvider ; import com . nesscomputing . lifecycle . guice . LifecycleAction ; public class HBaseWriterModule extends AbstractModule { private final String writerName ; public HBaseWriterModule ( final String writerName ) { Preconditions . checkState ( ! StringUtils . isBlank ( writerName ) , \"Writer name must not be blank!\" ) ; this . writerName = writerName ; } @ Override protected void configure ( ) { final Named named = Names . named ( writerName ) ; bind ( HBaseWriterConfig . class ) . annotatedWith ( named ) . toProvider ( ConfigProvider . of ( HBaseWriterConfig . class , ImmutableMap . of ( \"writername\" , writerName ) ) ) . in ( Scopes . SINGLETON ) ; bind ( HBaseWriter . class ) . annotatedWith ( named ) . toProvider ( new HBaseWriterProvider ( named ) ) . asEagerSingleton ( ) ; bind ( SpillController . class ) . annotatedWith ( named ) . toProvider ( new SpillControllerProvider ( named ) ) . in ( Scopes . SINGLETON ) ; bind ( SpillReader . class ) . annotatedWith ( named ) . toProvider ( new SpillReaderProvider ( named ) ) . asEagerSingleton ( ) ; install ( new MBeanModule ( ) { @ Override public void configureMBeans ( ) { export ( HBaseWriter . class ) . annotatedWith ( named ) . as ( format ( \"ness.hbase.writer:name=%s\" , writerName ) ) ; export ( SpillController . class ) . annotatedWith ( named ) . as ( format ( \"ness.hbase.spill:name=%s\" , writerName ) ) ; } } ) ; } public static class HBaseWriterProvider extends AbstractLifecycleProvider < HBaseWriter > implements Provider < HBaseWriter > { private final Named named ; private HBaseWriterConfig writerConfig = null ; private Configuration hadoopConfig = null ; private SpillController spillController = null ; private HBaseWriterProvider ( final Named named ) { this . named = named ; addAction ( LifecycleStage . START_STAGE , new LifecycleAction < HBaseWriter > ( ) { @ Override public void performAction ( final HBaseWriter hbaseWriter ) { hbaseWriter . start ( ) ; } } ) ; addAction ( LifecycleStage . STOP_STAGE , new LifecycleAction < HBaseWriter > ( ) { @ Override public void performAction ( final HBaseWriter hbaseWriter ) { hbaseWriter . stop ( ) ; } } ) ; } @ Inject void setInjector ( final Injector injector ) { this . hadoopConfig = injector . getInstance ( Configuration . class ) ; this . writerConfig = injector . getInstance ( Key . get ( HBaseWriterConfig . class , named ) ) ; this . spillController = injector . getInstance ( Key .", "gt": "get ( SpillController . class , named ) ) ;", "prediction": "get ( HBaseWriterConfig . class , named ) ) ;\n", "label": 0}
{"id": 13523, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec4 . sub1 ; import org . restlet . resource . ClientResource ; public class DynamicContentClient { public static void main ( String [ ] args ) throws Exception { ClientResource resource = new ClientResource ( \"http://localhost:8111/\" ) ; resource . get (", "gt": ") . write ( System . out ) ;", "prediction": "1 ) ;\n", "label": 1}
{"id": 508, "input": "<s> public interface InterfaceAndInnerClsCtor { public static class Inner { public Inner ( boolean b ) { } Inner ( char c ) { } protected Inner ( int i ) { } private Inner ( ) { } } public final static Inner i0 = new Inner ( true ) ; public final static Inner i1 = new", "gt": "Inner ( 'a' ) ;", "prediction": "Inner ( false ) ;\n", "label": 0}
{"id": 13534, "input": "<s> package org . nuxeo . ecm . platform . picture . listener ; import static org . nuxeo . ecm . platform . picture . api . ImagingDocumentConstants . PICTURE_FACET ; import org . nuxeo . ecm . core . api . Blob ; import org . nuxeo . ecm . core . api . ClientException ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . blobholder . BlobHolder ; import org . nuxeo . ecm . core . api . model . Property ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventContext ; import org . nuxeo . ecm . core . event . EventListener ; import org . nuxeo . ecm . core . event . impl . DocumentEventContext ; import org . nuxeo . ecm . platform . picture . api . adapters . AbstractPictureAdapter ; public class PictureChangedListener implements EventListener { @ Override public void handleEvent ( Event event ) throws ClientException { EventContext ctx = event", "gt": ". getContext ( ) ;", "prediction": ". getContext ( ) ;\n", "label": 1}
{"id": 8099, "input": "<s> package org . ofbiz . widget . tree ; import java . io . IOException ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . xml . parsers . ParserConfigurationException ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class TreeFactory { public static final String module = TreeFactory . class . getName ( ) ; public static final UtilCache < String , Map < String , ModelTree > > treeLocationCache = UtilCache . createUtilCache ( \"widget.tree.locationResource\" , 0 , 0 , false ) ; public static final UtilCache < String , Map < String , ModelTree > > treeWebappCache = UtilCache . createUtilCache ( \"widget.tree.webappResource\" , 0 , 0 , false ) ; public static ModelTree getTreeFromLocation ( String resourceName , String treeName , Delegator delegator , LocalDispatcher dispatcher ) throws IOException , SAXException , ParserConfigurationException { Map < String , ModelTree > modelTreeMap = treeLocationCache . get ( resourceName ) ; if ( modelTreeMap == null ) { synchronized ( TreeFactory . class ) { modelTreeMap = treeLocationCache . get ( resourceName ) ; if ( modelTreeMap == null ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader == null ) { loader = TreeFactory . class . getClassLoader ( ) ; } URL treeFileUrl = null ; treeFileUrl = FlexibleLocation . resolveLocation ( resourceName ) ; Document treeFileDoc = UtilXml . readXmlDocument ( treeFileUrl , true , true ) ; modelTreeMap = readTreeDocument ( treeFileDoc , delegator , dispatcher , resourceName ) ; treeLocationCache . put ( resourceName , modelTreeMap ) ; } } } ModelTree modelTree = modelTreeMap . get ( treeName ) ; if ( modelTree == null ) { throw new IllegalArgumentException ( \"Could not find tree with name [\" + treeName + \"] in class resource [\" + resourceName + \"]\" ) ; } return modelTree ; } public static ModelTree getTreeFromWebappContext ( String resourceName , String treeName , HttpServletRequest request ) throws IOException , SAXException , ParserConfigurationException { String webappName = UtilHttp . getApplicationName ( request ) ; String cacheKey = webappName + \"::\" + resourceName ; Map < String , ModelTree > modelTreeMap = treeWebappCache . get ( cacheKey ) ; if ( modelTreeMap == null ) { synchronized ( TreeFactory . class ) { modelTreeMap = treeWebappCache . get ( cacheKey ) ; if ( modelTreeMap == null ) { ServletContext servletContext = ( ServletContext ) request . getAttribute ( \"servletContext\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; URL treeFileUrl = servletContext . getResource ( resourceName ) ; Document treeFileDoc = UtilXml . readXmlDocument ( treeFileUrl , true , true ) ; modelTreeMap = readTreeDocument ( treeFileDoc , delegator , dispatcher , cacheKey ) ; treeWebappCache . put ( cacheKey , modelTreeMap ) ; } } } ModelTree modelTree = modelTreeMap . get ( treeName ) ; if ( modelTree == null ) { throw new IllegalArgumentException ( \"Could not find tree with name [\" + treeName + \"] in webapp resource [\" + resourceName + \"] in the webapp [\" + webappName + \"]\" ) ; } return modelTree ; } public static Map < String , ModelTree > readTreeDocument ( Document treeFileDoc , Delegator delegator , LocalDispatcher dispatcher , String treeLocation ) { Map < String , ModelTree > modelTreeMap = new HashMap < String , ModelTree > ( ) ; if ( treeFileDoc != null ) { Element rootElement = treeFileDoc . getDocumentElement ( ) ; for ( Element treeElement : UtilXml . childElementList ( rootElement , \"tree\" ) ) { ModelTree modelTree = new ModelTree (", "gt": "treeElement , delegator , dispatcher ) ;", "prediction": "treeElement ) ;\n", "label": 0}
{"id": 13547, "input": "<s> package org . eclipse . ui ; public interface IViewSite extends IWorkbenchPartSite { public", "gt": "IActionBars getActionBars ( ) ;", "prediction": "IViewSite ( )\n", "label": 1}
{"id": 9744, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignAreaPlot ; import net . sf . jasperreports . charts . design . JRDesignCategoryDataset ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJStackedAreaChartBuilder ; import ar . com . fdvs . dj . domain . chart . plot . DJAxisFormat ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class StackedAreaChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnState ) ; drb . addColumn ( columnBranch ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; GroupBuilder gb1 = new GroupBuilder ( ) ; DJGroup g1 = gb1 . setCriteriaColumn ( ( PropertyColumn ) columnState ) . addFooterVariable ( columnAmount , DJCalculation . SUM ) . addFooterVariable ( columnaQuantity , DJCalculation . SUM ) . addVariable ( \"group_state_name\" , columnState , DJCalculation . FIRST ) . setGroupLayout ( GroupLayout . VALUE_IN_HEADER_WITH_HEADERS ) . build ( ) ; drb . addGroup ( g1 ) ; drb . setUseFullPageWidth ( true ) ; DJAxisFormat categoryAxisFormat = new DJAxisFormat ( \"category\" ) ; categoryAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; categoryAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; categoryAxisFormat . setTickLabelMask ( \"\" ) ; categoryAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJAxisFormat valueAxisFormat = new DJAxisFormat ( \"value\" ) ; valueAxisFormat . setLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelFont ( Font . ARIAL_SMALL ) ; valueAxisFormat . setTickLabelColor ( Color . DARK_GRAY ) ; valueAxisFormat . setTickLabelMask ( \"#,##0.0\" ) ; valueAxisFormat . setLineColor ( Color . DARK_GRAY ) ; DJChart djChart = new DJStackedAreaChartBuilder ( ) . setX ( 20 ) . setY ( 10 ) . setWidth ( 500 ) . setHeight ( 250 ) . setCentered ( false ) . setBackColor ( Color . LIGHT_GRAY ) . setShowLegend ( true ) . setPosition ( DJChartOptions . POSITION_FOOTER ) . setTitle ( new StringExpression ( ) { public Object evaluate ( Map fields , Map variables , Map parameters ) { return variables . get ( \"group_state_name\" ) ; } } ) . setTitleColor ( Color . DARK_GRAY ) . setTitleFont ( Font . ARIAL_BIG_BOLD ) . setSubtitle ( \"subtitle\" ) . setSubtitleColor ( Color . DARK_GRAY ) . setSubtitleFont ( Font . COURIER_NEW_BIG_BOLD ) . setLegendColor ( Color . DARK_GRAY ) . setLegendFont ( Font . COURIER_NEW_MEDIUM_BOLD ) . setLegendBackgroundColor ( Color . WHITE ) . setLegendPosition ( DJChartOptions . EDGE_BOTTOM ) . setTitlePosition ( DJChartOptions . EDGE_TOP ) . setLineStyle ( DJChartOptions . LINE_STYLE_DOTTED ) . setLineWidth ( 1 ) . setLineColor ( Color . DARK_GRAY ) . setPadding ( 5 ) . setCategory ( ( PropertyColumn ) columnBranch ) . addSerie ( columnaQuantity , \"quant.\" ) . addSerie ( columnAmount ) . setCategoryAxisFormat ( categoryAxisFormat ) . setValueAxisFormat ( valueAxisFormat ) . build ( ) ; drb . addChart ( djChart ) ; DJHyperLink djlink = new DJHyperLink ( ) ; djlink . setExpression ( new StringExpression ( ) { public Object", "gt": "evaluate ( Map fields , Map variables , Map parameters )", "prediction": "evaluate ( Map fields , Map variables , Map parameters )\n", "label": 0}
{"id": 13579, "input": "<s> package nehsics . test ; import nehsics . world . * ; import nehsics . ui . * ; import nehsics . bodies . * ; import java . awt . * ; import static nehsics . math . Util . * ; public class CollapseTest extends UserControlledScene { public final static String NAME = \"Gravitational Collapse\" ; public static void main ( String [ ] args ) { new Starter ( \"nehsics.test.CollapseTest\" ) ; } public CollapseTest ( Canvas c ) { super ( c ) ; } protected void setup ( ) { FieldManager f = new FieldManager ( ) ; world . addListener ( f ) ; world . addListener ( new Gravitation ( f ) ) ; display . setScale ( 3e-8 ) ; SPEED = .25 ; for ( int i = 0 ; i < 11 ; i ++ ) for ( int j = 0 ; j < 11 ; j ++ ) { Circle tmp = new Circle ( SUN_RADIUS / 2 , SUN_MASS * 1e6 ) ; tmp . setTempColorEnabled ( true , world ) ; tmp . scaleTempColor ( SUN_MASS * 1e20 ) ; tmp . setPosition ( v ( SUN_RADIUS * i - 5 * SUN_RADIUS , SUN_RADIUS * j - 5", "gt": "* SUN_RADIUS ) ) ;", "prediction": "* SUN_RADIUS ) ) ;\n", "label": 1}
{"id": 9646, "input": "<s> package org . gk . server ; public interface SelectTable { interface PROJECT_USER { String TABLENAME = \"_PROJECT_USER\" ; interface COLUMN { String USERID = \"USERID\" ; String PROJECTID = \"PROJECTID\" ; String ROLEID = \"ROLEID\" ; } }", "gt": "String _PROGRAM = \"_PROGRAM\" ;", "prediction": ";\n", "label": 0}
{"id": 13604, "input": "<s> package io . beancounter . resolver ; import java . util . List ; import java . util . UUID ; import com . google . inject . Inject ; import com . google . inject . Singleton ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import redis . clients . jedis . Jedis ; import redis . clients . jedis . JedisPool ; import io . beancounter . commons . helper . jedis . JedisPoolFactory ; import io . beancounter . commons . helper . resolver . Services ; import io . beancounter . commons . model . activity . Activity ; import redis . clients . jedis . exceptions . JedisConnectionException ; @ Singleton public class JedisResolver implements Resolver { private static final Logger LOGGER = LoggerFactory . getLogger ( JedisResolver . class ) ; private JedisPool pool ; private Services services ; @ Inject public JedisResolver ( JedisPoolFactory factory , Services services ) { pool = factory . build ( ) ; this . services = services ; } @ Override public UUID resolve ( Activity activity ) throws ResolverException { String service = activity . getContext ( ) . getService ( ) ; int database ; try { database = services . get ( service ) ; } catch ( NullPointerException e ) { final String errmsg = \"Service [\" + service + \"] not supported\" ; LOGGER . error ( errmsg , e ) ; throw new ResolverException ( errmsg , e ) ; } Jedis jedis = getJedisResource ( database ) ; String userIdentifier = activity . getContext ( ) . getUsername ( ) ; String userId ; boolean isConnectionIssue = false ; try { userId = jedis . hget ( userIdentifier , \"uuid\" ) ; } catch ( JedisConnectionException e ) { isConnectionIssue = true ; final String errMsg = \"Jedis Connection error while getting userId for [\" + userIdentifier + \"] for service [\" + service + \"]\" ; LOGGER . error ( errMsg , e ) ; throw new ResolverException ( errMsg , e ) ; } catch ( Exception e ) { final String errMsg = \"Error while getting userId for [\" + userIdentifier + \"] for service [\" + service + \"]\" ; LOGGER . error ( errMsg , e ) ; throw new ResolverException ( errMsg , e ) ; } finally { if ( isConnectionIssue ) { pool . returnBrokenResource ( jedis ) ; } else { pool . returnResource ( jedis ) ; } } if ( userId == null ) { final String errmsg = \"User [\" + userIdentifier + \"] not found for [\" + service + \"]\" ; LOGGER . error ( errmsg ) ; throw new ResolverException ( errmsg ) ; } try { return UUID . fromString ( userId ) ; } catch ( IllegalArgumentException e ) { final String errmsg = \"Illformed beancounter userId [\" + userId + \"] for userIdentifier [\" + userIdentifier + \"] in service [\" + service + \"]\" ; LOGGER . error ( errmsg , e ) ; throw new ResolverException ( errmsg , e ) ; } } @ Override public UUID resolveId ( String identifier , String service ) throws ResolverException { int database ; try { database = services . get ( service ) ; } catch ( NullPointerException e ) { final String errmsg = \"Service [\" + service + \"] not supported\" ; LOGGER . error ( errmsg , e ) ; throw new ResolverException ( errmsg , e ) ; } Jedis jedis = getJedisResource ( database ) ; String userId ; boolean isConnectionIssue = false ; try { userId = jedis . hget ( identifier , \"uuid\" ) ; } catch ( JedisConnectionException e ) { isConnectionIssue = true ; final String errMsg = \"Jedis Connection error while getting userId for [\" + identifier + \"] for service [\" + service + \"]\" ; LOGGER . error ( errMsg , e ) ; throw new ResolverException (", "gt": "errMsg , e ) ;", "prediction": "errMsg , e ) ;\n", "label": 1}
{"id": 558, "input": "<s> package org . ofbiz . entity . model ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . TreeSet ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; public class ModelEntityChecker { public static final String module = ModelEntityChecker . class . getName ( ) ; public static void checkEntities ( Delegator delegator , List < String > warningList ) throws GenericEntityException { ModelReader reader = delegator . getModelReader ( ) ; TreeSet < String > reservedWords = new TreeSet < String > ( ) ; initReservedWords ( reservedWords ) ; Map < String , TreeSet < String > > packages = FastMap . newInstance ( ) ; TreeSet < String > packageNames = new TreeSet < String > ( ) ; TreeSet < String > tableNames = new TreeSet < String > ( ) ; Collection < String > ec = reader . getEntityNames ( ) ; TreeSet < String > entityNames = new TreeSet < String > ( ec ) ; for ( String eName : ec ) { ModelEntity ent = reader . getModelEntity ( eName ) ; if ( UtilValidate . isNotEmpty ( ent . getPlainTableName ( ) ) ) tableNames . add ( ent . getPlainTableName ( ) ) ; TreeSet < String > entities = packages . get ( ent . getPackageName ( ) ) ; if ( entities == null ) { entities = new TreeSet < String > ( ) ; packages . put ( ent . getPackageName ( ) , entities ) ; packageNames . add ( ent . getPackageName ( ) ) ; } entities . add ( eName ) ; } int numberShowed = 0 ; TreeSet < String > fkNames = new TreeSet < String > ( ) ; TreeSet < String > indexNames = new TreeSet < String > ( ) ; for ( String pName : packageNames ) { TreeSet < String > entities = packages . get ( pName ) ; for ( String entityName : entities ) { String helperName = delegator . getEntityHelperName ( entityName ) ; String groupName = delegator . getEntityGroupName ( entityName ) ; ModelEntity entity = reader . getModelEntity ( entityName ) ; if ( helperName == null ) { if ( UtilValidate . isEmpty ( groupName ) ) { warningList . add ( \"[GroupNotFound] No Group Name found for entity \" + entity . getEntityName ( ) + \".\" ) ; } else { warningList . add ( \"[HelperNotFound] No Helper (DataSource) definition found for entity [\" + entity . getEntityName ( ) + \"] because there is no helper (datasource) configured for the entity group it is in: [\" + groupName + \"]\" ) ; } } if ( entity . getPlainTableName ( ) != null && entity", "gt": ". getPlainTableName ( ) . length ( ) > 30 )", "prediction": ". getPackageName ( ) != null )\n", "label": 0}
{"id": 13625, "input": "<s> package org . eclipse . rap . demo ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . * ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . * ; import org . eclipse . ui . part . ViewPart ; import org . eclipse . ui . views . properties . * ; public class DemoTreeViewPart extends ViewPart implements IDoubleClickListener { private TreeViewer viewer ; private IPropertySheetPage propertyPage ; private static final class ViewLabelProvider extends LabelProvider { @ Override public Image getImage ( Object element ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; ISharedImages sharedImages = workbench . getSharedImages ( ) ; return sharedImages . getImage ( ISharedImages . IMG_OBJ_ELEMENT ) ; } } class TreeObject implements IPropertySource { private static final String PROP_ID_LOCATION = \"location\" ; private static final String PROP_ID_NAME = \"name\" ; private String name ; private String location ; private TreeParent parent ; public TreeObject ( String name ) { this ( name , \"\" ) ; } public TreeObject ( String name , String location ) { this . name = name ; this . location = location ; } public String getName ( ) { return name ; } public String getLocation ( ) { return location ; } public void setParent ( TreeParent parent ) { this . parent = parent ; } public TreeParent getParent ( ) { return parent ; } @ Override public String toString ( ) { return getName ( ) ; } public Object getEditableValue ( ) { return this ; } public IPropertyDescriptor [ ] getPropertyDescriptors ( ) { return new IPropertyDescriptor [ ] { new TextPropertyDescriptor ( PROP_ID_NAME , \"Name\" ) , new TextPropertyDescriptor ( PROP_ID_LOCATION , \"Location\" ) , } ; } public Object getPropertyValue ( Object id ) { Object result = null ; if ( PROP_ID_NAME . equals ( id ) ) { result = name ; } else if ( PROP_ID_LOCATION . equals ( id ) ) { result = location ; } return result ; } public boolean isPropertySet ( Object id ) { boolean result = false ; if ( PROP_ID_NAME . equals ( id ) ) { result = name != null &&", "gt": "! \"\" . equals ( name ) ;", "prediction": "PROP_ID_NAME . equals ( id ) ;\n", "label": 1}
{"id": 7970, "input": "<s> package psi ; import static psi . Foo . * ; class Foo { private static int FOO_VALUE = 55 ; } class Bar {", "gt": "int value = FOO_VALUE ;", "prediction": "private static int FOO_VALUE = 55 ;\n", "label": 0}
{"id": 13627, "input": "<s> package org . apache . lucene . queryParser . standard . builders ; import java . util . List ; import org . apache . lucene . messages . MessageImpl ; import org . apache . lucene . queryParser . core . QueryNodeException ; import org . apache . lucene . queryParser . core . builders . QueryTreeBuilder ; import org . apache . lucene . queryParser . core . messages . QueryParserMessages ; import org . apache . lucene . queryParser . core . nodes . AnyQueryNode ; import org . apache . lucene . queryParser . core . nodes . QueryNode ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . BooleanQuery . TooManyClauses ; public class AnyQueryNodeBuilder implements StandardQueryBuilder { public AnyQueryNodeBuilder ( ) { } public BooleanQuery build ( QueryNode queryNode ) throws QueryNodeException { AnyQueryNode andNode = ( AnyQueryNode ) queryNode ; BooleanQuery bQuery = new BooleanQuery ( ) ; List < QueryNode > children = andNode . getChildren ( ) ; if ( children != null ) { for ( QueryNode child : children ) { Object obj = child . getTag ( QueryTreeBuilder . QUERY_TREE_BUILDER_TAGID ) ; if ( obj != null ) { Query query = ( Query ) obj ; try { bQuery . add", "gt": "( query , BooleanClause . Occur . SHOULD ) ;", "prediction": "( child ) ;\n", "label": 1}
{"id": 3467, "input": "<s> package org . dawnsci . rcp . histogram ; import java . util . ArrayList ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Slider ; import uk . ac . diamond . scisoft . analysis . rcp . util . FloatSpinner ; public class SpinnerSlider { private double max = 100.0 ; private double min = - 100.0 ; private int steps ; private Composite comp ; private Label label ; private Slider slider ; private FloatSpinner spinner ; private SelectionListener listener ; private ArrayList < SelectionListener > listeners = new ArrayList < SelectionListener > ( ) ; public SpinnerSlider ( String name , Composite parent , int sliderSteps ) { comp = new Composite ( parent , SWT . NONE ) ; comp . setLayoutData ( new GridData ( SWT . FILL , SWT . CENTER , true , false ) ) ; comp . setLayout ( new GridLayout ( 3 , false ) ) ; steps = sliderSteps ; GridData gridDataLabel = new GridData ( SWT . NONE , SWT . NONE , false , false ) ; gridDataLabel . minimumWidth = 100 ; label = new Label ( comp , SWT . NONE ) ; label . setText ( name ) ; listener = new SelectionListener ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { if ( event . getSource ( ) == slider ) { updateSpinner ( ) ; } if ( event . getSource ( ) == spinner . getControl ( ) ) { updateSlider ( ) ; } updateListeners ( event ) ; } @ Override public void widgetDefaultSelected ( SelectionEvent event ) { widgetSelected ( event ) ; updateListeners ( event ) ; } } ; GridData gridDataSpinner = new GridData ( SWT . NONE , SWT . NONE , false , false ) ; gridDataSpinner . minimumWidth = 90 ; spinner = new FloatSpinner ( comp , SWT . BORDER ) ; spinner . setLayoutData ( gridDataSpinner ) ;", "gt": "spinner . addSelectionListener ( listener ) ;", "prediction": "}\n", "label": 0}
{"id": 13631, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . IAdaptable ; public interface IWorkingSetElementAdapter { IAdaptable [ ] adaptElements ( IWorkingSet ws , IAdaptable [ ] elements ) ;", "gt": "void dispose ( ) ;", "prediction": "}\n", "label": 1}
{"id": 9927, "input": "<s> package com . redhat . ceylon . ant ; import java . io . File ; import java . io . FileFilter ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . Project ; import com . redhat . ceylon . cmr . api . Logger ; import com . redhat . ceylon . cmr . api . RepositoryManager ; import com . redhat . ceylon . cmr . api . RepositoryManagerBuilder ; import com . redhat . ceylon . compiler . typechecker . analyzer . ModuleManager ; import com . redhat . ceylon . compiler . typechecker . context . Context ; import com . redhat . ceylon . compiler . typechecker . context . PhasedUnit ; import com . redhat . ceylon . compiler . typechecker . context . PhasedUnits ; import com . redhat . ceylon . compiler . typechecker . io . VFS ; abstract class LazyHelper { private final LazyTask task ; public LazyHelper ( LazyTask task ) { this . task = task ; } long newestSourceFile ( long mtime , File file ) { if ( file . isDirectory ( ) ) { for ( File child : file . listFiles ( ) ) { mtime = Math . max ( mtime , newestSourceFile ( mtime , child ) ) ; } } else { long lastModified = file . lastModified ( ) ; task . log ( file + \" last modified \" + new Date ( lastModified ) , Project . MSG_DEBUG ) ; mtime = Math . max ( mtime , lastModified ) ; } return mtime ; } long oldestOutputArtifact ( long mtime , File file ) { if ( file . isDirectory ( ) ) { for ( File child : file . listFiles ( ) ) { mtime = Math . min ( mtime , oldestOutputArtifact ( mtime , child ) ) ; } } else if ( getArtifactFilter ( ) . accept ( file ) ) { long lastModified = file . lastModified ( ) ; task . log ( file + \" last modified \" + new Date ( lastModified ) , Project . MSG_DEBUG ) ; mtime = Math . min ( mtime , lastModified ) ; } return mtime ; } protected < M extends Module > boolean filterModules ( List < M > modules ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return false ; } Iterator < M > iterator = modules . iterator ( ) ; while ( iterator . hasNext ( ) ) { Module module = iterator . next ( ) ; long newest = Long . MIN_VALUE ; String version = null ; for ( File src : task . getSrc ( ) ) { version = version != null ? version : new ModuleDescriptorReader ( module , src ) . getModuleVersion ( ) ; File srcModuleDir = new File ( src , module . toDir ( ) . getPath ( ) ) ; newest = newestSourceFile ( newest , srcModuleDir ) ; task . log ( \"Newest file in \" + srcModuleDir + \" \" + new Date ( newest ) , Project . MSG_DEBUG ) ; } if ( version == null ) { task . log ( \"Unable to determine version (and hence timestamp) of \" + module , Project . MSG_VERBOSE ) ; continue ; } File outModuleDir = getArtifactDir ( version , module ) ; long oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( \"Oldest file in \" + outModuleDir + \" \" + new Date ( oldest ) , Project . MSG_DEBUG ) ; if ( newest != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newest < oldest ) { task . log ( \"No need to compile \" + module + \", it's up to date\" ) ; iterator . remove ( ) ; } } return modules . size ( ) == 0 ; } private boolean isOutputRepositoryURL ( ) { String out = task . getOut ( ) ; if ( out == null || out . isEmpty ( ) ) return false ; try { new URL ( out ) ; return true ; } catch ( MalformedURLException x ) { return false ; } } protected boolean filterFiles ( List < File > files ) { if ( task . getNoMtimeCheck ( ) || isOutputRepositoryURL ( ) ) { return false ; } long newestFile = Long . MIN_VALUE ; String version = null ; Iterator < File > iter = files . iterator ( ) ; while ( iter . hasNext ( ) ) { File file = iter . next ( ) ; Module module = inferModule ( file ) ; if ( module == null ) { task . log ( \"Unable to determine module of \" + file , Project . MSG_VERBOSE ) ; continue ; } for ( File src : task . getSrc ( ) ) { version = version != null ? version : new ModuleDescriptorReader ( module , src ) . getModuleVersion ( ) ; } if ( version == null ) { task . log ( \"Unable to determine version (and hence timestamp) of \" + module , Project . MSG_VERBOSE ) ; continue ; } File outModuleDir = getArtifactDir ( version , module ) ; long oldest = oldestOutputArtifact ( Long . MAX_VALUE , outModuleDir ) ; task . log ( \"Oldest file in \" + outModuleDir + \" \" + new Date ( oldest ) , Project . MSG_DEBUG ) ; newestFile = Math . max ( newestFile , file . lastModified ( ) ) ; task . log ( \"File \" + file + \" last modified \" + new Date ( newestFile ) , Project . MSG_DEBUG ) ; if ( newestFile != Long . MIN_VALUE && oldest != Long . MAX_VALUE && newestFile < oldest ) { task . log ( \"No need to compile \" + file + \", it's up to date\" ) ; iter . remove ( ) ; } } return files . size ( ) == 0 ; } protected abstract File getArtifactDir ( String version , Module module ) ; protected abstract FileFilter getArtifactFilter ( ) ; private Module inferModule ( File file ) { if ( file . exists ( ) ) { for ( File src : task . getSrc ( ) ) { if ( file . getAbsolutePath ( ) . startsWith ( src . getAbsolutePath ( ) ) ) { while ( ! file . equals ( src ) ) { File moduleDescriptor = file . isDirectory ( ) ?", "gt": "new File ( file , \"module.ceylon\" ) : file ;", "prediction": "file . getAbsolutePath ( ) : file . getAbsolutePath ( ) ;\n", "label": 0}
{"id": 13635, "input": "<s> package br . org . archimedes . rcp . extensionpoints ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import br . org . archimedes . interfaces . Exporter ; import br . org . archimedes . interfaces . Importer ; import br . org . archimedes . rcp . ExtensionLoader ; import br . org . archimedes . rcp . ExtensionTagHandler ; public class NativeFormatEPLoader implements ExtensionTagHandler { private static final String NATIVE_FORMAT_EXTENSION_POINT_ID = \"br.org.archimedes.core.nativeFormat\" ; private static final String IMPORTER_ATTRIBUTE_NAME = \"importer\" ; private static final String EXPORTER_ATTRIBUTE_NAME = \"exporter\" ; private static final String EXTENSION_ATTRIBUTE_NAME = \"extension\" ; private static final Map < String , Importer > nativeImporters = new HashMap < String , Importer > ( ) ; private static final Map < String , Exporter > nativeExporters = new HashMap < String , Exporter > ( ) ; public NativeFormatEPLoader ( ) { if ( nativeImporters . isEmpty ( ) ) { ExtensionLoader loader = new ExtensionLoader ( NATIVE_FORMAT_EXTENSION_POINT_ID ) ; loader . loadExtension ( this ) ; } } public String [ ] getExtensionsArray ( ) { Set < String > extensionsSet = nativeImporters . keySet ( ) ; String [ ] result = new String [ extensionsSet .", "gt": "size ( ) ] ;", "prediction": "length ] ;\n", "label": 1}
{"id": 3861, "input": "<s> package dao ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . Query ; import domain . Teacher ; public class TeacherDao { public static List < Teacher > getTeachersByName ( String name ) { EntityManager em = SingletonEntityManager . getInstance ( ) ; Query queryTeachersByName = em . createNamedQuery ( \"getTeachersByName\" ) ; queryTeachersByName . setParameter ( \"pattern\" , name ) ; return CastList . castList ( Teacher . class , queryTeachersByName .", "gt": "getResultList ( ) ) ;", "prediction": "class ) ;\n", "label": 0}
{"id": 13642, "input": "<s> package io . beancounter . commons . nlp ; import java . util . HashSet ; import java . util . Set ; public class NLPEngineResult { private long executedAt = System . currentTimeMillis ( ) ; private Set < Entity > entities = new HashSet < Entity > ( ) ; private Set < Category > categories = new HashSet < Category > ( ) ; public long getExecutedAt ( ) { return executedAt ; } public Set < Entity > getEntities ( ) { return entities ; } public void setEntities ( Set < Entity > entities ) { this . entities = entities ; } public Set", "gt": "< Category > getCategories ( )", "prediction": "< Category > getCategory ( )\n", "label": 1}
{"id": 7884, "input": "<s> package next . interfaces . controller . animation ; import next . i . controller . XController ; import next . i . view . XBarItem . Type ; import next . i . view . CellData ; import next . i . view . TableData ; import next . interfaces . controller . DemoUtils ; import next . interfaces . controller . GitXTableController ; import com . google . gwt . event . dom . client . ClickEvent ; import com . google . gwt . event . dom . client . ClickHandler ; public class SwapController extends GitXTableController { public SwapController ( final XController invokerController ) { setTitle ( \"Swap Example\" ) ; getNavigationBar ( ) . setLeftTitle ( \"Done\" ,", "gt": "Type . BUTTON ) ;", "prediction": "false ) ;\n", "label": 0}
{"id": 13668, "input": "<s> package io . beancounter . listener . facebook . core . model ; import java . util . List ; public class FacebookNotification { private String object ; private List < FacebookChange > entry ; public FacebookNotification ( ) { } public String getObject ( ) { return object ; } public void setObject ( String object ) { this . object = object ; } public List < FacebookChange > getEntry ( ) { return entry ; } public void setEntry ( List < FacebookChange > entry ) { this . entry = entry ; } @ Override", "gt": "public String toString ( )", "prediction": "public String toString ( )\n", "label": 1}
{"id": 7128, "input": "<s> package api . comments ; public class Userinfo { private boolean artist ; private Number authorId ; private String authorName ; private String avatar ; private boolean donor ; private boolean enabled ; private String userTitle ; private boolean warned ; public boolean isArtist ( ) { return this . artist ; } public Number getAuthorId ( ) { return this . authorId ; } public String getAuthorName ( ) { return this . authorName ; } public String getAvatar ( ) { return this . avatar ; } public boolean isDonor ( ) { return this . donor ; } public boolean isEnabled ( ) { return this . enabled ; } public String getUserTitle ( ) { return this . userTitle ; } public boolean isWarned ( ) { return this . warned ; } @ Override public String toString ( ) { return \"Userinfo [isArtist()=\" + isArtist ( ) + \", getAuthorId()=\" + getAuthorId ( ) + \", getAuthorName()=\" + getAuthorName ( ) + \", getAvatar()=\" + getAvatar ( ) + \", isDonor()=\" + isDonor ( ) + \", isEnabled()=\" + isEnabled ( ) + \", getUserTitle()=\" + getUserTitle ( ) + \",", "gt": "isWarned()=\" + isWarned ( ) + \"]\" ;", "prediction": "isWarned()=\" + isWarned ( ) + \", }\n", "label": 0}
{"id": 13670, "input": "<s> package com . poetry . install ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import escode . util . StreamUtils ; public class AbstractInstall { protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; protected byte [ ] load ( final String name ) throws IOException { logger . trace ( \"Trying load image :{}\" , name ) ; final Class < ? > clazz = getClass ( ) ; final Package pack = clazz . getPackage ( ) ; final String packageName = pack . getName ( ) ; final String path = \"/\" + packageName . replace ( '.' , '/' ) + \"/\" + name ; final InputStream in = getClass ( ) . getResourceAsStream ( path ) ; return StreamUtils . getBytes ( in , true ) ; } protected String read ( final String name ) throws IOException { logger . trace ( \"Trying read file :{}\" , name ) ; final Class < ? > clazz = getClass ( ) ; final Package pack = clazz . getPackage ( ) ; final String packageName = pack . getName ( ) ; final String path = \"/\" + packageName . replace ( '.' , '/' ) + \"/\" + name + \".txt\" ; final InputStream in = getClass", "gt": "( ) . getResourceAsStream ( path ) ;", "prediction": "( ) . getResourceAsStream ( path ) ;\n", "label": 1}
{"id": 8999, "input": "<s> enum Color { red , green , blue } @ interface Colored { Color", "gt": "value ( ) default redx ;", "prediction": "red ;\n", "label": 0}
{"id": 13693, "input": "<s> package org . spliffy . server . db ; import org . spliffy . server . db . utils . SessionManager ; import java . io . Serializable ; import java . util . Date ; import java . util . List ; import java . util . UUID ; import javax . persistence . * ; import org . spliffy . server . web . HashCalc ; @ javax . persistence . Entity public class ItemVersion implements Serializable { public static ItemVersion find ( UUID metaId ) { return ( ItemVersion ) SessionManager . session ( ) . get ( ItemVersion . class , metaId ) ; } private long id ; private Item item ; private Date modifiedDate ; private long itemHash ; private List < DirectoryMember > members ; private List < DirectoryMember > linked ; private List < Commit > rootRepoVersions ; public ItemVersion ( ) { } @ ManyToOne ( optional = false ) public Item getItem ( ) { return item ; } public void setItem ( Item item ) { this . item = item ; } @ Id @ GeneratedValue public long getId ( ) { return id ; } public void setId ( long id ) { this . id = id ; } @ Temporal ( javax . persistence . TemporalType . DATE ) @ Column ( nullable = false ) public Date getModifiedDate ( ) { return modifiedDate ; } public void setModifiedDate ( Date modifiedDate ) { this . modifiedDate = modifiedDate ; } @ Column ( nullable = false ) public long getItemHash ( ) { return itemHash ; } public void setItemHash ( long itemHash ) { this . itemHash = itemHash ; } @ OneToMany ( mappedBy = \"parentItem\" ) public List < DirectoryMember > getMembers ( ) { return members ; } public void setMembers ( List < DirectoryMember > members ) { this . members = members ; } @ OneToMany ( mappedBy = \"memberItem\" ) public List < DirectoryMember > getLinked ( ) { return linked ; } public void setLinked ( List < DirectoryMember > linked ) { this . linked = linked ; } @ OneToMany ( mappedBy = \"rootItemVersion\" ) public List < Commit > getRootRepoVersions ( ) { return rootRepoVersions ; } public void setRootRepoVersions ( List < Commit > rootRepoVersions ) { this . rootRepoVersions = rootRepoVersions ; } public void calcHash ( ) { if ( getItem ( ) . getType ( ) . equals ( \"d\" ) ) { long newHash =", "gt": "HashCalc . calcHash ( getMembers ( ) ) ;", "prediction": "getItemHash ( ) ;\n", "label": 1}
{"id": 2009, "input": "<s> package org . remast . baralga . gui . actions ; import javax . swing . AbstractAction ; import org . remast . baralga . gui . model . edit . EditStack ; @ SuppressWarnings ( \"serial\" ) public abstract class AbstractEditAction extends AbstractAction { private EditStack editStack ; public AbstractEditAction ( final EditStack editStack ) {", "gt": "this . editStack = editStack ;", "prediction": "super ( ) ;\n", "label": 0}
{"id": 13704, "input": "<s> package com . primitives2d ; import com . algorithm . KdCluster ; import com . datastruct . DCHalfEdge ; import com . math . CompPoint ; import com . datastruct . DoublyConnectedEdgeList ; import com . math . Geom ; import processing . core . PApplet ; import java . awt . geom . Point2D ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Vector ; import java . util . List ; public class GridSquare extends DoublyConnectedEdgeList { public CompPoint origin ; public double size ; public Vector < Disc > discs ; public Vector < Disc > rejectedDiscs ; public Vector < Disc > keptDiscs ; public Vector < Disc > evalDiscs ; public GridSquare ( double x , double y , double size ) { this . size = size ; this . origin = new CompPoint ( x , y ) ; discs = new Vector < Disc > ( ) ; DCHalfEdge top = new DCHalfEdge ( new CompPoint ( x + size , y ) , origin ) ; DCHalfEdge left = new DCHalfEdge ( top . end , new CompPoint ( x , y + size ) ) ; DCHalfEdge bottom = new DCHalfEdge ( left . end , new CompPoint ( x + size , y + size ) ) ; DCHalfEdge right = new DCHalfEdge ( bottom . end , top . start ) ; addHalfEdge ( top ) ; addHalfEdge ( left ) ; addHalfEdge ( bottom ) ; addHalfEdge ( right ) ; } public void clear ( ) { discs = new Vector < Disc > ( ) ; } public void addDisc ( Disc disc ) { discs . addElement ( disc ) ; } public void optimizedRemoval ( PApplet myParent ) { Vector < Disc > evalDiscs = findAllNonTouchingDiscs ( discs ) [ 0 ] ; if ( evalDiscs . size ( ) > 0 ) { Vector < Vector < Disc > > cleanedThreads = new Vector < Vector < Disc > > ( ) ; Collections . sort ( evalDiscs , new discCmpY ( ) ) ; Vector < Vector < Disc > > discThreads = new KdCluster < Disc > ( ) . buildTree ( evalDiscs ) ; for ( int i = 0 ; i < discThreads . size ( ) ; i ++ ) { Vector < Disc > thread = discThreads . get ( i ) ; System . out . println ( \"\\n touching order for \" + i + \"=\" ) ; System . out . println ( \"size of \" + i + \"=\" + thread . size ( ) ) ; optimizeThread ( thread ) ; } } } private void optimizeThread ( Vector < Disc > thread ) { Vector < Disc > newThread = findAllNonTouchingDiscs ( thread ) [ 0 ] ; if ( newThread . size ( ) == 0 ) { System . out . println ( \"no more are touching in the thread!\" ) ; System . out . println ( \"size=\" + newThread . size ( ) ) ; for ( int i = 0 ; i < newThread . size ( ) ; i ++ ) { newThread . get ( i ) . kept = true ; } return ; } else { Collections . sort ( newThread , new DiscTouch ( ) ) ; if ( newThread . get ( 0 ) . numTouching == 1 ) { Disc maxOffender = newThread . get ( 0 ) . discsTouching . get ( 0 ) ; newThread . get ( 0 ) . removeTouching ( maxOffender ) ; newThread . remove ( maxOffender ) ; optimizeThread ( newThread ) ; } else { Vector < Disc > maxOffenders = new Vector < Disc > ( ) ; int N = newThread . size ( ) - 1 ; while ( N > 0 ) { System . out . println ( \"thread size=\" + newThread . size ( ) ) ; System . out . println ( \"N =\" + N ) ; maxOffenders . add ( newThread . get ( N ) ) ; if ( newThread . get ( N - 1 ) . numTouching >= newThread . get ( N ) . numTouching ) { N -- ; } else { break ; } } Disc maxOffender ; if ( maxOffenders . size ( ) == 1 ) { maxOffender = maxOffenders . get ( 0 ) ; } else { Disc chosenDisc = null ; System . out . println ( \"maxOffender size=\" + maxOffenders . size ( ) ) ; maxOffender = findMaxOffender ( maxOffenders ) ; } for ( int i = 0 ; i < maxOffenders . get ( 0 ) . discsTouching . size ( ) ; i ++ ) { maxOffenders . get ( 0 ) . discsTouching . get ( i ) . removeTouching ( maxOffenders . get ( 0 ) ) ; } newThread . remove ( maxOffender ) ; optimizeThread ( newThread ) ; } } }", "gt": "private Disc findMaxOffender ( Vector < Disc > maxOffenders )", "prediction": "private void optimizeThread ( Vector < Disc > thread )\n", "label": 1}
{"id": 2374, "input": "<s> public class Teste { public static void main ( String args [ ] ) { java . io . FileReader leitor = new java .", "gt": "io . FileReader ( \"arquivo.txt\" ) ;", "prediction": "io . FileReader ( ) ;\n", "label": 0}
{"id": 13711, "input": "<s> package org . eclipse . ui . internal . registry ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Preferences ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . IPluginContribution ; import org . eclipse . ui . internal . PluginActionSet ; import org . eclipse . ui . internal . PluginActionSetReader ; import org . eclipse . ui . internal . WorkbenchPlugin ; import org . eclipse . ui . model . IWorkbenchAdapter ; public class ActionSetDescriptor implements IActionSetDescriptor , IAdaptable , IWorkbenchAdapter , IPluginContribution { private static final Object [ ] NO_CHILDREN = new Object [ 0 ] ; private static final String INITIALLY_HIDDEN_PREF_ID_PREFIX = \"actionSet.initiallyHidden.\" ; private String id ; private String pluginId ; private String label ; private boolean visible ; private String description ; private IConfigurationElement configElement ; public ActionSetDescriptor ( IConfigurationElement configElement ) throws CoreException { super ( ) ; this . configElement = configElement ; id = configElement . getAttribute ( IWorkbenchRegistryConstants . ATT_ID ) ; pluginId = configElement . getNamespace ( ) ; label = configElement . getAttribute ( IWorkbenchRegistryConstants . ATT_LABEL ) ; description = configElement . getAttribute ( IWorkbenchRegistryConstants . TAG_DESCRIPTION ) ; String str = configElement . getAttribute ( IWorkbenchRegistryConstants . ATT_VISIBLE ) ; if ( str != null && str . equals ( \"true\" ) ) { visible = true ; } if ( label == null ) { throw new CoreException ( new Status ( IStatus . ERROR , WorkbenchPlugin . PI_WORKBENCH , 0 , \"Invalid extension (missing label): \" + id , null ) ) ; } } public IActionSet createActionSet ( ) throws CoreException { return new PluginActionSet ( this ) ; } public Object getAdapter ( Class adapter ) { if ( adapter == IWorkbenchAdapter . class ) { return this ; } return null ; } public Object [ ] getChildren ( Object o ) { if ( o == this ) { return ( new PluginActionSetReader ( ) ) . readActionDescriptors ( this ) ; } return NO_CHILDREN ; } public IConfigurationElement getConfigurationElement ( ) { return configElement ; } public String getDescription ( ) { return description ; } public String getId ( ) { return id ; } public String getLabel ( ) { return label ; } public String getLabel ( Object o ) { if ( o == this ) { return getLabel ( ) ; } return \"Unknown Label\" ; } public boolean isInitiallyVisible ( ) { if ( id == null ) { return visible ; } Preferences prefs = WorkbenchPlugin . getDefault ( ) . getPluginPreferences ( ) ; String prefId = INITIALLY_HIDDEN_PREF_ID_PREFIX + getId ( ) ; if ( prefs . getBoolean ( prefId ) ) { return false ; } return visible ; } public void setInitiallyVisible ( boolean newValue ) { if ( id == null ) { return ; } Preferences prefs = WorkbenchPlugin . getDefault ( ) . getPluginPreferences ( ) ; String prefId = INITIALLY_HIDDEN_PREF_ID_PREFIX + getId ( ) ; prefs . setValue ( prefId , ! newValue ) ; } public ImageDescriptor getImageDescriptor ( Object object ) { return null ; } public Object getParent ( Object o ) { return null ; } public String getLocalId ( ) { return id ; } public String getPluginId ( ) { return pluginId ; } public boolean equals ( Object arg0 ) { if ( ! ( arg0 instanceof ActionSetDescriptor ) ) { return false ; }", "gt": "ActionSetDescriptor descr = ( ActionSetDescriptor ) arg0 ;", "prediction": "return true ;\n", "label": 1}
{"id": 3813, "input": "<s> package com . gisgraphy . client . administrativedivision ; import com . gisgraphy . client . gisfeature . AdministrativeEntity ; public class AdministrativeEntityHierarchy { public interface AdministrativeEntityProvider { AdministrativeEntity getCurrentAdministrativeEntity ( ) ; AdministrativeEntity getParentAdministrativeEntity ( ) ; } private AdministrativeEntityProvider administrativeEntityProvider ; public AdministrativeEntityHierarchy ( AdministrativeEntityProvider administrativeEntityProvider ) { super ( ) ; this . administrativeEntityProvider = administrativeEntityProvider ; } public int getAdminitrativeDivisionLevel ( ) { return administrativeEntityProvider . getParentAdministrativeEntity ( ) != null ? administrativeEntityProvider . getParentAdministrativeEntity ( ) . getAdminitrativeDivisionLevel ( ) + 1 : 0 ; } public AdministrativeEntity getAdministrativeEntity ( int level ) { int currentLevel = getAdminitrativeDivisionLevel ( ) ; if ( level > currentLevel ) { throw new IllegalArgumentException ( String . format ( \"Current Level (%s) is lower than requested Level (%s)\" , currentLevel , level ) ) ; } else if ( level < 0 ) { throw new IllegalArgumentException ( String . format ( \"Invalid", "gt": "Level (%s)\" , level ) ) ;", "prediction": "Level (%s)\" , currentLevel , level ) ) ;\n", "label": 0}
{"id": 13712, "input": "<s> package org . fuzzydb . io . core . messages ; import org . fuzzydb . io . core . Message ; @ SuppressWarnings ( \"serial\" ) public class Response extends Message { public Response ( int storeId , int cid ) { super", "gt": "( storeId , cid ) ;", "prediction": "( storeId , cid ) ;\n", "label": 1}
{"id": 4358, "input": "<s> package org . ofbiz . base . util . cache ; public interface CacheListener < K , V > { public void noteKeyRemoval ( UtilCache < K , V > cache , K key , V oldValue ) ; public void noteKeyAddition ( UtilCache < K , V > cache , K key , V newValue ) ; public void noteKeyUpdate ( UtilCache < K , V > cache , K key ,", "gt": "V newValue , V oldValue ) ;", "prediction": "V oldValue ) ;\n", "label": 0}
{"id": 13750, "input": "<s> package org . eclipse . rap . internal . junit . runtime ; import org . eclipse . core . runtime . Platform ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointManager ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . IEntryPointFactory ; import org . eclipse . rap . rwt . lifecycle . UICallBack ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . application . WorkbenchAdvisor ; import org . eclipse . ui . testing . ITestHarness ; import org . eclipse . ui . testing . TestableObject ; @ SuppressWarnings ( \"restriction\" ) public class Application implements IEntryPoint , ITestHarness { private TestableObject fTestableObject ; public int createUI ( ) { UICallBack . activate ( Application . class . getName ( ) ) ; fTestableObject = PlatformUI . getTestableObject ( ) ; fTestableObject . setTestHarness ( this ) ; return createAndRunWorkbench ( ) ; } private int createAndRunWorkbench ( ) { int result ; String entryPointName = getEntryPointName ( ) ; if ( entryPointName != null ) { IEntryPoint entryPoint = getEntryPoint ( entryPointName ) ; result = entryPoint . createUI ( ) ; } else { result = createAndRunEmptyWorkbench ( ) ; } return result ; } private int createAndRunEmptyWorkbench ( ) { Display display = PlatformUI . createDisplay ( ) ; WorkbenchAdvisor workbenchAdvisor = new WorkbenchAdvisor ( ) { @ Override public String getInitialWindowPerspectiveId ( ) { return \"org.eclipse.rap.junit.runtime.emptyPerspective\" ; } } ; return PlatformUI . createAndRunWorkbench ( display , workbenchAdvisor ) ; } private String getEntryPointName ( ) { String parameter = RWT .", "gt": "getRequest ( ) . getParameter ( \"testentrypoint\" ) ;", "prediction": "getEntryPointName ( ) ;\n", "label": 1}
{"id": 675, "input": "<s> package net . minecraft . src ; import java . util . Date ; import net . minecraft . client . Minecraft ; import org . lwjgl . opengl . GL11 ; public class ThxRender extends Render { @ Override public void doRender ( Entity entityArg , double x , double y , double z , float yaw , float pitch ) { ThxEntity entity = null ; try { entity = ( ThxEntity ) entityArg ; } catch ( ClassCastException e ) { return ; } ThxModel model = ( ThxModel ) entity . helper . model ; GL11 . glPushMatrix ( ) ; GL11 . glTranslatef ( ( float ) x , ( float ) y , ( float ) z ) ; model . paused = entity . helper . isPaused ( ) ; if ( entity . prevTime > model . entityPrevTime ) { model . entityPrevTime = entity . prevTime ; model .", "gt": "rotationYaw = entity . rotationYaw ;", "prediction": "prevTime = model . prevTime ;\n", "label": 0}
{"id": 13752, "input": "<s> package org . restlet . example . book . restlet . ch09 . common ; import org . restlet . resource . Delete ; import org . restlet . resource . Get ; import org . restlet . resource . Put ; public interface AccountResource { @ Get public AccountRepresentation represent ( ) ; @ Put public", "gt": "void store ( AccountRepresentation account ) ;", "prediction": "Delete get ( ) ;\n", "label": 1}
{"id": 1305, "input": "<s> public class TestConstantValuesDriver extends JavadocTester { private static final String BUG_ID = \"4504730-4526070-5077317\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , SRC_DIR + FS + \"TestConstantValues.java\" , SRC_DIR + FS + \"TestConstantValues2.java\" , SRC_DIR + FS + \"A.java\" } ; public static void main ( String [ ] args ) { String [ ] [ ] tests = new String [ 5 ] [ 2 ] ; for ( int i = 0 ; i < tests . length - 1 ; i ++ ) { tests [ i ] [ 0 ] = BUG_ID + FS + \"constant-values.html\" ; tests [ i ] [ 1 ] = \"TEST\" + ( i + 1 ) + \"PASSES\" ; } tests [ tests . length - 1 ]", "gt": "[ 0 ] = BUG_ID + FS + \"constant-values.html\" ;", "prediction": "= new String [ 5 ] [ 2 ] ;\n", "label": 0}
{"id": 13796, "input": "<s> package org . eclipse . jface . viewers ; import org . eclipse . swt . graphics . Image ; public class LabelProvider extends BaseLabelProvider implements ILabelProvider { public LabelProvider ( ) { } public Image getImage ( Object element ) { return null ; } public String getText ( Object element ) { return element ==", "gt": "null ? \"\" : element . toString ( ) ;", "prediction": "null ;\n", "label": 1}
{"id": 997, "input": "<s> package org . ofbiz . service . jms ; import javax . jms . JMSException ; import javax . jms . Queue ; import javax . jms . QueueConnection ; import javax . jms . QueueConnectionFactory ; import javax . jms . QueueReceiver ; import javax . jms . QueueSession ; import javax . jms . Session ; import javax . naming . InitialContext ; import javax . naming . NamingException ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . JNDIContextFactory ; import org . ofbiz . entity . Delegator ; public class JmsQueueListener extends AbstractJmsListener { public static final String module = JmsQueueListener . class . getName ( ) ; private QueueConnection con = null ; private QueueSession session = null ; private Queue queue = null ; private String jndiServer , jndiName , queueName , userName , password ; public JmsQueueListener ( Delegator delegator , String jndiServer , String jndiName , String queueName , String userName , String password ) { super ( delegator ) ; this . jndiServer = jndiServer ; this . jndiName = jndiName ; this . queueName = queueName ; this . userName = userName ; this . password = password ; } public void close ( ) throws GenericServiceException { try { session . close ( ) ; con . close ( ) ; } catch ( JMSException e ) { throw new GenericServiceException ( \"Cannot close connection(s).\" , e ) ; } } public synchronized void load ( ) throws GenericServiceException { try { InitialContext jndi = JNDIContextFactory . getInitialContext ( jndiServer ) ; QueueConnectionFactory factory = ( QueueConnectionFactory ) jndi . lookup ( jndiName ) ; if ( factory != null ) { con = factory", "gt": ". createQueueConnection ( userName , password ) ;", "prediction": ". getInstance ( ) ;\n", "label": 0}
{"id": 13808, "input": "<s> package com . cloudera . sqoop . mapreduce ; public class AvroOutputFormat < T > extends org . apache", "gt": ". sqoop . mapreduce . AvroOutputFormat < T >", "prediction": ". sqoop . mapreduce . OutputFormat < T >\n", "label": 1}
{"id": 4176, "input": "<s> package com . redhat . ceylon . compiler . java . codegen ; class Assert { static void fail ( String message ) { throw new RuntimeException ( message ) ; } static void fail ( ) { fail ( null ) ; } static void that ( boolean cond , String message ) { if ( ! cond ) { fail ( message ) ; } } static void that ( boolean cond ) { that ( cond , null ) ; } static void not ( boolean cond , String message ) { if ( cond ) { fail ( message ) ; } }", "gt": "static void not ( boolean cond )", "prediction": "}\n", "label": 0}
{"id": 13843, "input": "<s> package org . restlet . ext . fileupload ; import java . io . IOException ; import java . util . List ; import org . apache . commons . fileupload . FileItem ; import org . apache . commons . fileupload . FileItemFactory ; import org . apache . commons . fileupload . FileItemIterator ; import org . apache . commons . fileupload . FileUpload ; import org . apache . commons . fileupload . FileUploadException ; import org . restlet . Request ; import org . restlet . representation . Representation ; public class RestletFileUpload extends FileUpload { public RestletFileUpload ( ) { super ( ) ; } public RestletFileUpload ( FileItemFactory fileItemFactory ) { super ( fileItemFactory ) ; } public FileItemIterator getItemIterator ( Representation multipartForm ) throws FileUploadException , IOException { return", "gt": "getItemIterator ( new RepresentationContext ( multipartForm ) ) ;", "prediction": "new FileItemIterator ( ) ;\n", "label": 1}
{"id": 8532, "input": "<s> package org . msl . simple . gmfmap . simplemappings . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . emf . ecore . impl . EObjectImpl ; import org . eclipse . gmf . mappings . NodeMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleChildReference ; import org . msl . simple . gmfmap . simplemappings . SimpleMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleChildReferenceImpl extends SimpleNodeReferenceImpl implements SimpleChildReference { protected SimpleChildReferenceImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE ; } public SimpleParentNode getParentNode ( ) { return ( SimpleParentNode ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_NODE , true ) ; } public void setParentNode ( SimpleParentNode newParentNode ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_NODE , newParentNode ) ; } public SimpleMapping getParentMapping ( ) { return ( SimpleMapping ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_MAPPING , true ) ; } public void setParentMapping ( SimpleMapping newParentMapping ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_MAPPING , newParentMapping ) ; } public SimpleNode getParent ( ) { return ( SimpleNode ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT , true ) ; } public void setParent ( SimpleNode newParent ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT , newParent ) ; } public EClass getParentMetaElement ( ) { return ( EClass ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_META_ELEMENT , true ) ; } public void setParentMetaElement ( EClass newParentMetaElement ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_NODE__PARENT_META_ELEMENT , newParentMetaElement ) ; } public NodeMapping getReferencedChild ( ) { return ( NodeMapping ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE__REFERENCED_CHILD , true ) ; } public void setReferencedChild ( NodeMapping newReferencedChild ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE__REFERENCED_CHILD , newReferencedChild ) ; } public SimpleNode getReferencedSimpleNode ( ) { return ( SimpleNode ) eGet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE__REFERENCED_SIMPLE_NODE , true ) ; } public void setReferencedSimpleNode ( SimpleNode newReferencedSimpleNode ) { eSet ( SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE__REFERENCED_SIMPLE_NODE , newReferencedSimpleNode ) ; } @ Override public int eBaseStructuralFeatureID ( int derivedFeatureID , Class < ? > baseClass ) { if ( baseClass == SimpleChildNode . class ) { switch ( derivedFeatureID ) { case SimplemappingsPackage . SIMPLE_CHILD_REFERENCE__PARENT_NODE : return SimplemappingsPackage . SIMPLE_CHILD_NODE__PARENT_NODE ; case SimplemappingsPackage . SIMPLE_CHILD_REFERENCE__PARENT_MAPPING : return SimplemappingsPackage . SIMPLE_CHILD_NODE__PARENT_MAPPING ; case SimplemappingsPackage . SIMPLE_CHILD_REFERENCE__PARENT : return SimplemappingsPackage . SIMPLE_CHILD_NODE__PARENT ; case SimplemappingsPackage . SIMPLE_CHILD_REFERENCE__PARENT_META_ELEMENT : return SimplemappingsPackage . SIMPLE_CHILD_NODE__PARENT_META_ELEMENT ; default : return - 1 ; } } return super . eBaseStructuralFeatureID ( derivedFeatureID , baseClass ) ; } @ Override public int eDerivedStructuralFeatureID (", "gt": "int baseFeatureID , Class < ? > baseClass )", "prediction": "int derivedFeatureID , Class < ? > baseClass )\n", "label": 0}
{"id": 13844, "input": "<s> package br . org . archimedes . intersectors ; import java . util . Collection ; import java . util . LinkedList ; import br . org . archimedes . Constant ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . infiniteline . InfiniteLine ; import br . org . archimedes . intersections . interfaces . Intersector ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; public class InfiniteLineInfiniteLineIntersector implements Intersector { public Collection < Point > getIntersections ( Element element , Element otherElement ) throws NullArgumentException { InfiniteLine infiniteLine = ( InfiniteLine ) element ; InfiniteLine otherInfiniteLine = ( InfiniteLine ) otherElement ; if ( element == null || otherElement == null ) throw new NullArgumentException ( ) ; Collection < Point > intersectionPoints = new LinkedList < Point > ( ) ; if ( isParallelTo ( infiniteLine , otherInfiniteLine ) ) { return intersectionPoints ; } double a1 , b1 , c1 ; double a2 , b2 , c2 ; Point initialPoint = infiniteLine . getInitialPoint ( ) ; Point endingPoint = infiniteLine . getEndingPoint ( ) ; Point secondInitialPoint = otherInfiniteLine . getInitialPoint ( ) ; Point secondEndingPoint = otherInfiniteLine . getEndingPoint ( ) ; a1 = initialPoint . getY ( ) - endingPoint . getY ( ) ; b1 = endingPoint . getX ( ) - initialPoint . getX ( ) ; c1 = ( initialPoint . getX ( ) - endingPoint . getX ( ) ) * initialPoint . getY ( ) + ( endingPoint . getY ( ) - initialPoint . getY ( ) ) * initialPoint . getX ( ) ; a2 = secondInitialPoint . getY ( ) - secondEndingPoint . getY ( ) ; b2 = secondEndingPoint . getX ( ) - secondInitialPoint . getX ( ) ; c2 = ( secondInitialPoint . getX ( ) - secondEndingPoint . getX ( ) ) * secondInitialPoint . getY ( ) + ( secondEndingPoint . getY ( ) - secondInitialPoint . getY ( ) ) * secondInitialPoint . getX ( ) ; if ( ! ( ( Math . abs ( a1 * b2 - b1 * a2 ) <= Constant . EPSILON ) && ( Math . abs ( c1 - c2 ) <= Constant . EPSILON ) ) ) { double yIntersection = 0.0 ; double xIntersection = 0.0 ; if ( Math . abs ( a1 ) <= Constant . EPSILON ) { yIntersection = - ( c1 / b1 ) ; xIntersection = - ( b2 * yIntersection + c2 ) / a2 ; } else if ( Math", "gt": ". abs ( a2 ) <= Constant . EPSILON )", "prediction": ". abs ( a2 ) <= Constant . EPSILON )\n", "label": 1}
{"id": 9518, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import com . sun . source . tree . * ; import com . sun . source . util . * ; import com . sun . tools . javac . api . * ; public class T6431879 { public static void main ( String ... args ) throws IOException { String testSrc = System . getProperty ( \"test.src\" , \".\" ) ; String testClasses = System . getProperty ( \"test.classes\" , \".\" ) ; JavacTool tool = JavacTool . create ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( null , null , null ) ; Iterable < ? extends JavaFileObject > files = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( new File ( testSrc , T6431879 . class . getName ( ) + \".java\" ) ) ) ; JavacTask task = tool . getTask ( null , fm , null , null , null , files ) ; Iterable < ? extends CompilationUnitTree > trees = task . parse ( ) ; TreeScanner < Void , Trees > dependencyScanner = new DependencyScanner ( ) ; Trees", "gt": "treeUtil = Trees . instance ( task ) ;", "prediction": ". add ( testClasses ) ;\n", "label": 0}
{"id": 13859, "input": "<s> package org . apache . lucene . analysis . standard ; import java . io . IOException ; import java . io . Reader ; import org . apache . lucene . analysis . Token ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . analysis . tokenattributes . TypeAttribute ; import org . apache . lucene . util . AttributeSource ; import org . apache . lucene . util . Version ; public class StandardTokenizer extends Tokenizer { private final StandardTokenizerImpl scanner ; public static final int ALPHANUM = 0 ; public static final int APOSTROPHE = 1 ; public static final int ACRONYM = 2 ; public static final int COMPANY = 3 ; public static final int EMAIL = 4 ; public static final int HOST = 5 ; public static final int NUM = 6 ; public static final int CJ = 7 ; public static final int ACRONYM_DEP = 8 ; public static final String [ ] TOKEN_TYPES = new String [ ] { \"<ALPHANUM>\" , \"<APOSTROPHE>\" , \"<ACRONYM>\" , \"<COMPANY>\" , \"<EMAIL>\" , \"<HOST>\" , \"<NUM>\" , \"<CJ>\" , \"<ACRONYM_DEP>\" } ; public static final String [ ] tokenImage = TOKEN_TYPES ; private boolean replaceInvalidAcronym ; private int maxTokenLength = StandardAnalyzer . DEFAULT_MAX_TOKEN_LENGTH ; public void setMaxTokenLength ( int length ) { this . maxTokenLength = length ; } public int getMaxTokenLength ( ) { return maxTokenLength ; } public StandardTokenizer ( Reader input ) { this ( Version . LUCENE_24 , input ) ; } public StandardTokenizer ( Reader input , boolean replaceInvalidAcronym ) { super ( ) ; this . scanner = new StandardTokenizerImpl ( input ) ; init ( input , replaceInvalidAcronym ) ; } public StandardTokenizer ( Version matchVersion , Reader input ) { super ( ) ; this . scanner = new StandardTokenizerImpl ( input ) ; init ( input , matchVersion ) ; } public StandardTokenizer ( AttributeSource source , Reader input , boolean replaceInvalidAcronym ) { super ( source ) ; this . scanner = new StandardTokenizerImpl ( input ) ; init ( input , replaceInvalidAcronym ) ; } public StandardTokenizer ( Version matchVersion , AttributeSource source , Reader input ) { super ( source ) ; this .", "gt": "scanner = new StandardTokenizerImpl ( input ) ;", "prediction": "scanner = new StandardTokenizerImpl ( input ) ;\n", "label": 1}
{"id": 756, "input": "<s> package com . pagosoft . plaf . themes ; import javax . swing . plaf . * ; import java . awt . * ; final class Colors { static final ColorUIResource GRAY_DARKEST = new ColorUIResource ( 64 , 64 , 64 ) ; static final ColorUIResource GRAY_DARKER = new ColorUIResource ( 82 , 82 , 82 ) ; static final ColorUIResource GRAY_DARK = new ColorUIResource ( 90 , 90 , 90 ) ; static final ColorUIResource GRAY_MEDIUMDARK = new ColorUIResource ( 110 , 110 , 110 ) ; static final ColorUIResource GRAY_MEDIUM = new ColorUIResource ( 128 , 128 , 128 ) ; static final ColorUIResource GRAY_MEDIUMLIGHT = new ColorUIResource ( 150 , 150 , 150 ) ; static final ColorUIResource GRAY_LIGHT = new ColorUIResource ( 170 , 170 , 170 ) ; static final ColorUIResource GRAY_LIGHTER = new ColorUIResource ( 220 , 220 , 220 ) ; static final ColorUIResource GRAY_LIGHTER2 = new ColorUIResource ( 230 , 230 , 230 ) ; static final ColorUIResource GRAY_LIGHTEST = new ColorUIResource ( 240 , 240 , 240 ) ; static final ColorUIResource BROWN_LIGHTEST = new ColorUIResource ( 242 , 241 , 238 ) ; static final ColorUIResource BLUE_LOW_MEDIUM = new ColorUIResource ( 166 , 202 , 240 ) ; static final ColorUIResource BLUE_LOW_LIGHTEST = new ColorUIResource ( 195 , 212 , 232 ) ; static final ColorUIResource BLUE_MEDIUM_DARKEST = new ColorUIResource ( 44 , 73 , 135 ) ; static final ColorUIResource BLUE_MEDIUM_DARK = new ColorUIResource ( 49 , 106 , 196 ) ; static final ColorUIResource BLUE_MEDIUM_MEDIUM = new ColorUIResource ( 85 , 115 , 170 ) ; static final ColorUIResource BLUE_MEDIUM_LIGHTEST = new ColorUIResource ( 172 , 210 , 248 ) ; static final ColorUIResource GREEN_LOW_DARK = new ColorUIResource ( 75 , 148 , 75 ) ; static final ColorUIResource GREEN_LOW_MEDIUM =", "gt": "new ColorUIResource ( 112 , 190 , 112 ) ;", "prediction": "new ColorUIResource ( 170 , 170 , 170 ) ;\n", "label": 0}
{"id": 13867, "input": "<s> package litil . parser ; import litil . TypeScope ; import litil . ast . * ; import litil . lexer . * ; import litil . tc . ExplicitTypeChecker ; import litil . tc . HMTypeChecker ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . * ; public class LitilParser extends BaseParser { private static Map < String , Integer > LBP = new HashMap < String , Integer > ( ) ; static { LBP . put ( \"and\" , 5 ) ; LBP . put ( \"or\" , 5 ) ; LBP . put ( \"not\" , 7 ) ; LBP . put ( \"=\" , 7 ) ; LBP . put ( \"<\" , 7 ) ; LBP . put ( \">\" , 7 ) ; LBP . put ( \"::\" , 11 ) ; LBP . put ( \"+\" , 15 ) ; LBP . put ( \"-\" , 15 ) ; LBP . put ( \"%\" , 20 ) ; LBP . put ( \"*\" , 20 ) ; LBP . put ( \"/\" , 20 ) ; LBP . put ( \".\" , 30 ) ; LBP . put ( \"{\" , 90 ) ; LBP . put ( \"}\" , 1 ) ; LBP . put ( \"[\" , 90 ) ; LBP . put ( \"]\" , 1 ) ; LBP . put ( \"(\" , 100 ) ; LBP . put ( \")\" , 1 ) ; } public LitilParser ( LookaheadLexer lexer ) { super . lexer = lexer ; prtDbg = false ; } private static TypeScope trootScope ( ) { TypeScope res = new TypeScope ( ) ; res . define ( \"+\" , Type . Function ( Arrays . asList ( Type . INT , Type . INT ) , Type . INT ) ) ; res . define ( \"add\" , Type . Function ( Arrays . asList ( Type . INT , Type . INT ) , Type . INT ) ) ; res . define ( \"*\" , Type . Function ( Arrays . asList ( Type . INT , Type . INT ) , Type . INT ) ) ; return res ; } public static void main ( String [ ] args ) throws Exception { Reader reader = new InputStreamReader ( LitilParser . class . getResourceAsStream ( \"../eval/emb-list.ltl\" ) ) ; LitilParser p = new LitilParser ( new LookaheadLexerWrapper ( new StructuredLexer ( new BaseLexer ( reader ) , \"  \" ) ) ) ; p . debug = false ; Program ast = p . program ( ) ; System . out . println ( ast . repr ( 1 ) ) ; ExplicitTypeChecker exTc = new ExplicitTypeChecker ( ) ; HMTypeChecker hmTc = new HMTypeChecker ( ) ; TypeScope tenv = trootScope ( ) . child ( ) ; for ( Instruction instr : ast . instructions ) { System . out . println ( instr . repr ( 0 ) ) ; System . out . println ( \":: \" + hmTc . analyze ( instr , tenv ) ) ; System . out . println ( \"--------------\" ) ; } System . out . println ( tenv ) ; } public Program program ( ) { Program p = new Program ( ) ; p . instructions . addAll ( body ( ) ) ; return p ; } private TypeScope rootScope ( ) { TypeScope", "gt": "res = new TypeScope ( ) ;", "prediction": "res = new TypeScope ( ) ;\n", "label": 1}
{"id": 5284, "input": "<s> package com . sap . prd . mobile . ios . mios ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; public class XCodeSkipLibraryBuildMojo extends AbstractXCodeMojo { private boolean forbidLibBuild ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { if ( forbidLibBuild ) throw new MojoExecutionException ( \"xcode-library detected (\" + project . getArtifact ( ) + \"). Libraries must not be built during company builds. They are not released separately. At the time when the company build is triggered we expect all libraries are already", "gt": "contained in the repository.\" ) ;", "prediction": "installed.\" ) ;\n", "label": 0}
{"id": 13877, "input": "<s> package com . rabbitmq . messagepatterns . unicast ; import com . rabbitmq . client . ConnectionFactory ; import com . rabbitmq . client . Channel ; import com . rabbitmq . client . Connection ; import java . util . HashSet ; import java . util . Set ; import java . io . IOException ; public class UnicastClient { public static void main ( String [ ] args ) throws Exception { UnicastClient c = new UnicastClient ( ) ; c . run ( args [ 0 ] , args [ 1 ] , Integer . parseInt ( args [ 2 ] ) ) ; } Set pending = new HashSet ( ) ; int sent ; int recv ; int pend ; int disc ; UnicastClient ( ) { } MessageSentListener listener = new MessageSentListener ( ) { public void messageSent ( Message msg ) { if ( msg . getCorrelationId ( ) == null ) { sent ++ ; pend ++ ; } displayStats ( ) ; } } ; void displayStats ( ) { System . out . printf ( \"\\r\" + \"sent %d, \" + \"recv %d, \" + \"pend %d, \" + \"disc %d\" , sent , recv , pend , disc ) ; } void run ( final String me , final String you , int sleep ) throws Exception { Connector conn = Factory . createConnector ( new ConnectionBuilder ( ) { public Connection createConnection ( ) throws IOException { return new ConnectionFactory ( ) . newConnection ( ) ; } } ) ; Messaging m = Factory . createMessaging ( ) ; m . setConnector ( conn ) ; m . setIdentity ( me ) ; m . addMessageSentListener ( listener ) ; m . addSenderSetupListener ( new ChannelSetupListener ( ) { public void channelSetup ( Channel channel ) throws IOException { channel . queueDeclare ( you , true , false , false , null ) ; } } ) ; m . addReceiverSetupListener ( new ChannelSetupListener ( ) { public void channelSetup ( Channel channel ) throws IOException { channel . queueDeclare ( me", "gt": ", true , false , false , null ) ;", "prediction": ", true , false , false , null ) ;\n", "label": 1}
{"id": 1758, "input": "<s> package org . bombusim . lime . fragments ; import java . security . InvalidParameterException ; import org . bombusim . lime . Lime ; import org . bombusim . lime . R ; import org . bombusim . lime . activity . ActiveChats ; import org . bombusim . lime . activity . ContactResourceSwitcher ; import org . bombusim . lime . data . Chat ; import org . bombusim . lime . data . ChatHistoryDbAdapter ; import org . bombusim . lime . data . Contact ; import org . bombusim . lime . data . Message ; import org . bombusim . lime . data . Roster ; import org . bombusim . lime . data . SimpleCursorLoader ; import org . bombusim . lime . service . XmppService ; import org . bombusim . lime . service . XmppServiceBinding ; import org . bombusim . lime . widgets . ChatEditText ; import org . bombusim . lime . widgets . ContactBar ; import org . bombusim . xmpp . handlers . ChatStates ; import org . bombusim . xmpp . handlers . MessageDispatcher ; import org . bombusim . xmpp . stanza . XmppPresence ; import org . bombusim . xmpp . stanza . XmppMessage ; import com . actionbarsherlock . app . SherlockFragment ; import android . app . Activity ; import android . content . BroadcastReceiver ; import android . content . Context ; import android . content . Intent ; import android . content . IntentFilter ; import android . content . res . Configuration ; import android . content . res . TypedArray ; import android . database . Cursor ; import android . graphics . Bitmap ; import android . graphics . Color ; import android . graphics . drawable . Drawable ; import android . os . Bundle ; import android . support . v4 . app . Fragment ; import android . support . v4 . app . LoaderManager . LoaderCallbacks ; import android . support . v4 . content . Loader ; import android . support . v4 . widget . CursorAdapter ; import android . text . ClipboardManager ; import android . text . Editable ; import android . text . Spannable ; import android . text . SpannableString ; import android . text . SpannableStringBuilder ; import android . text . TextWatcher ; import android . text . format . Time ; import android .", "gt": "text . method . LinkMovementMethod ;", "prediction": "util . ArrayList ;\n", "label": 0}
{"id": 13888, "input": "<s> package org . eclipse . jface . tests . viewers ; import java . util . Vector ; public class TestElement implements Cloneable { TestModel fModel ; TestElement fContainer ; String fSomeName ; String fId ; Vector fChildren = new Vector ( ) ; boolean fIsDeleted = false ; public static final String P_SOMENAME = \"org.eclipse.jface.viewertest.name\" ; public static final String P_COLUMN_1 = \"org.eclipse.jface.viewertest.column1\" ; public TestElement ( TestModel model , TestElement container ) { fModel = model ; fContainer = container ; int p = 0 ; TestElement lastSibling = container . getLastChild ( ) ; if ( lastSibling != null ) { p = lastSibling . childId ( ) + 1 ; } fId = container . getID ( ) + \"-\" + p ; } public TestElement ( TestModel model , TestElement container , int level , int position ) { fModel = model ; fContainer = container ; if ( container != null ) fId = container . getID ( ) + \"-\" + position ; else fId = Integer . toString ( position ) ; fSomeName = \"name-\" + position ; if ( level < model . getNumLevels ( ) ) { for ( int i = 0 ; i < model . getNumChildren ( ) ; i ++ ) { fChildren . add ( new TestElement ( model , this , level + 1 , i ) ) ; } } } public TestElement addChild ( int event ) { TestElement element = new TestElement ( fModel , this ) ; element . fSomeName = \"added\" ; addChild ( element , new TestModelChange ( event , this , element ) ) ; return element ; } public TestElement addChild ( TestElement element , TestModelChange change ) { fChildren . add ( element ) ; fModel . fireModelChanged ( change ) ; return element ; } public void addChildren ( TestElement [ ] elements , TestModelChange change ) { for ( int i = 0 ; i < elements . length ; i ++ ) fChildren . add ( elements [ i ] ) ; fModel . fireModelChanged ( change ) ; } public TestElement [ ] addChildren ( int event ) { TestElement elements [ ] = new TestElement [ ] { new TestElement ( fModel , this ) , new TestElement ( fModel , this ) } ; elements [ 0 ] . fSomeName = \"added1\" ; elements [ 1 ] . fSomeName = \"added2\" ; elements [ 1 ] . fId += \"madeUnique\" ; addChildren ( elements , new TestModelChange ( event , this , elements ) ) ; return elements ; } public TestElement basicAddChild ( ) { TestElement element = new TestElement (", "gt": "fModel , this ) ;", "prediction": "fModel , this ) ;\n", "label": 1}
{"id": 7650, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . materialien ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import org . junit . Test ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . FSK ; public class FilmTest { @ Test public void testeKonstruktoren ( ) { Film f = new Film ( \"Titel\" ,", "gt": "90 , FSK . FSK16 , true ) ;", "prediction": "SWT . NONE ) ;\n", "label": 0}
{"id": 13890, "input": "<s> package org . fuzzydb . attrs . byteencoding ; import org . fuzzydb . attrs . enums . EnumExclusiveValue ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . util . ByteArray ; public class EnumCodec extends CompactAttrCodec { static final byte EXCLUSIVE_ENUM_SIZE = ATTR_ID_SIZE + 2 ; private static final int ENUM_DEF_OFFSET = PAYLOAD_OFFSET ; private static final int ENUM_DEF_LENGTH = 1 ; private static final int ENUM_VALUE_OFFSET = ENUM_DEF_OFFSET + ENUM_DEF_LENGTH ; static private EnumCodec instance ; public static synchronized CompactAttrCodec getInstance ( ) { if ( instance == null ) { instance = new EnumCodec ( ) ; } return instance ; } @ Override public void encodeToByteArray ( ByteArray bytes , int attrId , Object value ) { EnumExclusiveValue enumValue = ( EnumExclusiveValue ) value ; int i = findAttrInBuf ( bytes , attrId ) ; if", "gt": "( i < 0 )", "prediction": "( i == 0 )\n", "label": 1}
{"id": 3226, "input": "<s> package org . ofbiz . common ; import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics2D ; import java . awt . geom . AffineTransform ; import java . awt . image . BufferedImage ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . io . Writer ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import javolution . util . FastMap ; import net . sf . json . JSON ; import net . sf . json . JSONArray ; import net . sf . json . JSONObject ; import net . sf . json . JSONSerializer ; import org . apache . commons . lang . RandomStringUtils ; import org . apache . commons . lang . StringUtils ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . security . Security ; public class CommonEvents { public static final String module = CommonEvents . class . getName ( ) ; private static final UtilCache < String , Map < String , String > > appletSessions = UtilCache . createUtilCache ( \"AppletSessions\" , 0 , 600000 , true ) ; public static String checkAppletRequest ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String sessionId = request . getParameter ( \"sessionId\" ) ; String visitId = request . getParameter ( \"visitId\" ) ; sessionId = sessionId . trim ( ) ; visitId = visitId . trim ( ) ; String responseString = \"\" ; GenericValue visit = null ; try { visit = delegator . findOne ( \"Visit\" , false , \"visitId\" , visitId ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Cannot Visit Object\" , module ) ; } if ( visit != null && visit . getString ( \"sessionId\" ) . equals ( sessionId ) && appletSessions . containsKey ( sessionId ) ) { Map < String , String > sessionMap = appletSessions . get ( sessionId ) ; if ( sessionMap != null && sessionMap . containsKey ( \"followPage\" ) ) responseString = sessionMap . remove ( \"followPage\" ) ; } try { PrintWriter out = response . getWriter ( ) ; response . setContentType ( \"text/plain\" ) ; out . println ( responseString ) ; out . close ( ) ; } catch ( IOException e ) { Debug . logError ( e , \"Problems writing servlet output!\" , module ) ; } return \"success\" ; } public static String receiveAppletRequest ( HttpServletRequest request , HttpServletResponse response ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String sessionId = request . getParameter ( \"sessionId\" ) ; String visitId = request . getParameter ( \"visitId\" ) ; sessionId = sessionId . trim ( ) ; visitId = visitId . trim ( ) ; String responseString = \"ERROR\" ; GenericValue visit = null ; try { visit = delegator . findOne ( \"Visit\" , false , \"visitId\" , visitId ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Cannot Visit Object\" , module ) ; } if ( visit . getString ( \"sessionId\" ) . equals ( sessionId ) ) { String currentPage = request . getParameter ( \"currentPage\" ) ; Map < String , String > sessionMap = appletSessions . get ( sessionId ) ; if ( sessionMap != null ) { String followers = sessionMap . get ( \"followers\" ) ; List < String > folList = StringUtil . split ( followers , \",\" ) ; for ( String follower : folList ) { Map < String , String > folSesMap = UtilMisc . toMap ( \"followPage\" , currentPage ) ; appletSessions . put ( follower , folSesMap ) ; } } responseString = \"OK\" ; } try { PrintWriter out = response . getWriter ( ) ; response . setContentType ( \"text/plain\" ) ; out . println ( responseString ) ; out . close ( ) ; } catch ( IOException e ) { Debug . logError ( e , \"Problems writing servlet output!\" , module ) ; } return \"success\" ; } public static String setAppletFollower ( HttpServletRequest request , HttpServletResponse response ) { Security security = ( Security ) request . getAttribute ( \"security\" ) ; GenericValue userLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"userLogin\" ) ; String visitId = request . getParameter ( \"visitId\" ) ; if ( visitId != null ) request . setAttribute ( \"visitId\" , visitId ) ; if ( security . hasPermission ( \"SEND_CONTROL_APPLET\" , userLogin ) ) { String followerSessionId = request . getParameter ( \"followerSid\" ) ; String followSessionId = request . getParameter ( \"followSid\" ) ; Map < String , String > follow = appletSessions . get ( followSessionId ) ; if ( follow == null ) follow = FastMap . newInstance ( ) ; String followerListStr = follow . get ( \"followers\" ) ; if ( followerListStr == null ) { followerListStr = followerSessionId ; } else { followerListStr = followerListStr + \",\" + followerSessionId ; } appletSessions . put ( followSessionId , follow ) ; appletSessions . put ( followerSessionId , null ) ; } return \"success\" ; } public static String setFollowerPage ( HttpServletRequest request , HttpServletResponse response ) { Security security = ( Security ) request . getAttribute ( \"security\" ) ; GenericValue userLogin = ( GenericValue ) request . getSession ( ) . getAttribute ( \"userLogin\" ) ; String visitId = request . getParameter ( \"visitId\" ) ; if ( visitId != null ) request . setAttribute ( \"visitId\" , visitId ) ; if ( security . hasPermission ( \"SEND_CONTROL_APPLET\" , userLogin ) ) { String followerSessionId = request . getParameter ( \"followerSid\" ) ; String pageUrl = request . getParameter ( \"pageUrl\" ) ; Map < String , String > follow = appletSessions", "gt": ". get ( followerSessionId ) ;", "prediction": ". get ( followerSessionId ) ;\n", "label": 0}
{"id": 13895, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . execution ; import com . digitalsanctum . idea . plugins . buildr . BuildrProjectComponent ; import com . intellij . execution . ExecutionException ; import com . intellij . execution . Executor ; import com . intellij . execution . configurations . * ; import com . intellij . execution . filters . TextConsoleBuilderFactory ; import com . intellij . execution . runners . ExecutionEnvironment ; import com . intellij . execution . runners . ProgramRunner ; import com . intellij . openapi . diagnostic . Logger ; import com . intellij . openapi . module . Module ; import com . intellij . openapi . options . SettingsEditor ; import com . intellij . openapi . project . Project ; import com . intellij . openapi . util . InvalidDataException ; import com . intellij . openapi . util . JDOMExternalizable ; import com . intellij . openapi . util . WriteExternalException ; import org . jdom . Element ; import org . jetbrains . annotations . NotNull ; import java . util . List ; public class BuildrRunConfiguration extends RunConfigurationBase implements ModuleRunConfiguration { public static final Logger LOG = Logger . getInstance ( BuildrRunConfiguration . class . getName ( ) ) ; private List < String > tasks = new java . util . ArrayList < String > ( ) ; private static final String TASKS_PARENT_ELEMENT_NAME = \"tasks\" ; private static final String TASKS_TASK_ELEMENT_NAME = \"value\" ; public BuildrRunConfiguration ( BuildrConfigurationType . MyConfigurationFactory myConfigurationFactory , Project project ) { super ( project , myConfigurationFactory , \"\" ) ; } public BuildrRunConfigSettingEditor getConfigurationEditor ( ) { return new BuildrRunConfigSettingEditor ( getProject ( ) . getComponent ( BuildrProjectComponent . class ) ) ; } public JDOMExternalizable createRunnerSettings ( ConfigurationInfoProvider provider ) { return null ; } @ SuppressWarnings ( \"deprecated\" ) public SettingsEditor <", "gt": "JDOMExternalizable > getRunnerSettingsEditor ( ProgramRunner runner )", "prediction": "String > createRunnerSettings ( ConfigurationInfoProvider provider )\n", "label": 1}
{"id": 8631, "input": "<s> package org . ofbiz . service . rmi ; import java . util . Map ; import java . rmi . Remote ; import java . rmi . RemoteException ; import org . ofbiz . service . GenericRequester ; import org . ofbiz . service . GenericResultWaiter ; import org . ofbiz . service . GenericServiceException ; public interface RemoteDispatcher extends Remote { public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public Map < String , Object > runSync ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context ) throws GenericServiceException , RemoteException ; public void runSyncIgnore ( String serviceName , Map < String , ? extends Object > context , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester , boolean persist ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , GenericRequester requester ) throws GenericServiceException , RemoteException ; public void runAsync ( String serviceName , Map < String , ? extends Object > context , boolean", "gt": "persist ) throws GenericServiceException , RemoteException ;", "prediction": "persist , int transactionTimeout , boolean requireNewTransaction ) throws GenericServiceException , RemoteException ;\n", "label": 0}
{"id": 13899, "input": "<s> package org . eclipse . ui . presentations ; import org . eclipse . jface . action . IStatusLineManager ; import org . eclipse . jface . action . StatusLineManager ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Sash ; public abstract class AbstractPresentationFactory { public static int SASHTYPE_NORMAL = 0 ; public static int SASHTYPE_FLOATING = 1 << 1 ; public static int SASHORIENTATION_HORIZONTAL = SWT . HORIZONTAL ; public static int SASHORIENTATION_VERTICAL = SWT . VERTICAL ; private static final int SASH_SIZE = 3 ; public abstract StackPresentation createEditorPresentation ( Composite parent , IStackPresentationSite site ) ; public abstract StackPresentation createViewPresentation ( Composite parent , IStackPresentationSite site ) ; public abstract StackPresentation createStandaloneViewPresentation ( Composite parent , IStackPresentationSite site , boolean showTitle ) ; public IStatusLineManager createStatusLineManager ( ) { return new StatusLineManager ( ) ; } public Control createStatusLineControl ( IStatusLineManager statusLine , Composite parent ) { return ( ( StatusLineManager ) statusLine ) . createControl ( parent , SWT . NONE ) ; } public String getId ( ) { return", "gt": "this . getClass ( ) . getName ( ) ;", "prediction": "id ;\n", "label": 1}
{"id": 7216, "input": "<s> package org . ofbiz . minilang . method . entityops ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangRuntimeException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class GetRelatedOne extends MethodOperation { public static final String module = GetRelatedOne . class . getName ( ) ; private final FlexibleStringExpander relationNameFse ; private final FlexibleMapAccessor < GenericValue > toValueFma ; private final FlexibleStringExpander useCacheFse ; private final FlexibleMapAccessor < GenericValue > valueFma ; public GetRelatedOne ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . attributeNames ( simpleMethod , element , \"value-field\" , \"relation-name\" , \"to-value-field\" , \"use-cache\" ) ; MiniLangValidate . requiredAttributes ( simpleMethod , element , \"value-field\" , \"relation-name\" , \"to-value-field\" ) ; MiniLangValidate . expressionAttributes ( simpleMethod , element , \"value-field\" , \"to-value-field\" ) ; MiniLangValidate . noChildElements ( simpleMethod , element ) ; } valueFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"value-field\" ) ) ; relationNameFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"relation-name\" ) ) ; toValueFma = FlexibleMapAccessor . getInstance ( element . getAttribute ( \"to-value-field\" ) ) ; useCacheFse = FlexibleStringExpander . getInstance ( element . getAttribute ( \"use-cache\" ) ) ; } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { GenericValue value = valueFma . get ( methodContext . getEnvMap ( ) ) ; if ( value == null ) { throw new MiniLangRuntimeException ( \"Entity value not found with name: \" + valueFma , this ) ; } String relationName = relationNameFse . expandString ( methodContext . getEnvMap ( ) ) ; boolean useCache = \"true\" . equals ( useCacheFse . expandString ( methodContext . getEnvMap ( ) ) ) ; try { toValueFma . put ( methodContext . getEnvMap ( ) , value . getRelatedOne ( relationName , useCache ) ) ; } catch ( GenericEntityException e ) { String errMsg = \"Exception thrown while finding related value: \" + e . getMessage ( ) ; Debug . logWarning ( e , errMsg , module ) ; simpleMethod . addErrorMessage ( methodContext , errMsg ) ; return false ; } return true ; } @ Override public void gatherArtifactInfo ( ArtifactInfoContext aic ) { aic . addEntityName ( relationNameFse .", "gt": "toString ( ) ) ;", "prediction": "toString ( ) ) ;\n", "label": 0}
{"id": 13909, "input": "<s> package org . eclipse . rap . rwt . events ; import org . eclipse . swt . internal . SWTEventObject ; public final class BrowserHistoryEvent extends SWTEventObject { public String entryId ; public BrowserHistoryEvent (", "gt": "Object source , String entryId )", "prediction": ")\n", "label": 1}
{"id": 5993, "input": "<s> package jns . util ; public class Protocols { public static final int TCP = 1 ; public static final int UDP = 2 ; public static final int SGN = 3 ;", "gt": "public static final int DYNAMIC_SCHEDULER = 4 ;", "prediction": "}\n", "label": 0}
{"id": 13912, "input": "<s> package org . fuzzydb . util . geo ; public final class Datum { public static final Ellipsoid airy1830 = new Ellipsoid ( 6377563.396 , 6356256.910 ) ; public static final Ellipsoid airy1830Modified = new Ellipsoid ( 6377340.189 , 6356034.447 ) ; public static final TransverseMercator nationalGrid = new TransverseMercator ( 0.9996012717 , 49.0 , - 2.0", "gt": ", - 100000 , 400000 , airy1830 ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6730, "input": "<s> package inheritDist ; public interface B extends A {", "gt": "void m1 ( ) ;", "prediction": "}\n", "label": 0}
{"id": 13918, "input": "<s> package org . seage . problem . tsp . genetics ; import java . io . FileInputStream ; import org . seage . metaheuristic . genetics . GeneticSearch ; import org . seage . metaheuristic . genetics . GeneticSearchEvent ; import org . seage . metaheuristic . genetics . GeneticSearchListener ; import org . seage . metaheuristic . genetics . Genome ; import org . seage . metaheuristic . genetics . Subject ; import org . seage . problem . tsp . City ; import org . seage . problem . tsp . CityProvider ; import org . seage . problem . tsp . TourProvider ; public class TspGeneticAlgorithmTest implements GeneticSearchListener { public static void main ( String [ ] args ) { try { new TspGeneticAlgorithmTest ( ) . run ( args [ 0 ] ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } public void run ( String path ) throws Exception { City [ ] cities = CityProvider . readCities ( new FileInputStream ( path ) ) ; GeneticSearch gs = new GeneticSearch ( new TspGeneticOperator ( ) , new TspEvaluator ( cities ) ) ; gs . addGeneticSearchListener ( this ) ; gs . setEliteSubjectPct ( 0.05 ) ; gs . setMutateSubjectPct ( 0.25 ) ; gs . setPopulationCount ( 500 ) ; gs . setRandomSubjectPct ( 0.1 ) ; gs . setCrossLengthPct ( 0.40 ) ; gs . setIterationToGo ( 500 ) ; gs . startSearching ( generateInitialSubjects ( cities , 100 ) ) ; } private Subject [ ] generateInitialSubjects ( City [ ] cities , int count ) throws Exception { int numTours = count ; int tourLenght = cities . length ; Integer [ ] [ ] tours = new Integer [ numTours ] [ tourLenght ] ; Subject [ ] result = new Subject [ numTours ] ; for ( int k = 0 ; k < tours . length ; k ++ ) if ( k < tours . length / 20 ) tours [ k ] = TourProvider . createGreedyTour ( cities , 1 ) ; else tours [ k ] = TourProvider . createRandomTour ( cities ) ; for ( int k = 0 ; k < tours . length ; k ++ ) { Subject s = new Subject ( new Genome", "gt": "( 1 , tourLenght ) ) ;", "prediction": "( ) ) ;\n", "label": 1}
{"id": 8625, "input": "<s> package com . albin ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import org . meqantt . MqttListener ; import org . meqantt . NettyClient ; import org . meqantt . util . FormatUtil ; public class NettyMain { private static NettyClient client ; private static String topic ; public static void main ( String [ ] args ) throws InterruptedException , IOException { String id = args . length == 0 ? \"Dummy_\" + System . currentTimeMillis ( ) : args [ 0 ] ; client = new NettyClient ( id ) ; client . setListener ( new PrintingListener ( ) ) ; client . connect ( \"localhost\" , 1883 ) ; beInteractive ( ) ; client . disconnect ( ) ; } private static void beInteractive ( ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; do { line = in . readLine ( ) ; if ( line . startsWith ( \"pub\" ) ) publish ( line . substring ( 4 ) ) ; if ( line . startsWith ( \"sub\" ) ) subscribe ( line . substring ( 4 ) ) ; if ( line . startsWith ( \"unsub\" ) ) unsubscribe ( line . substring ( 6 ) ) ; if ( line . startsWith ( \"topic\" ) ) { topic = line . substring ( 6 ) ; } } while ( ! \"bye\" . equals ( line ) ) ; } private static void unsubscribe ( String topic ) { client", "gt": ". unsubscribe ( topic ) ;", "prediction": ". close ( ) ;\n", "label": 0}
{"id": 13933, "input": "<s> package org . eclipse . ui . internal . cheatsheets . actions ; import org . eclipse . swt . widgets . Menu ; public interface IMenuContributor { public int contributeToViewMenu ( Menu menu", "gt": ", int index ) ;", "prediction": ") ;\n", "label": 1}
{"id": 6835, "input": "<s> @ interface UnionTypeInfo { String [", "gt": "] value ( ) ;", "prediction": "] types ;\n", "label": 0}
{"id": 13948, "input": "<s> package org . restlet . example . book . restlet . ch08 . gae . common ; import java . io . Serializable ; public class MailRepresentation implements Serializable { private static final long serialVersionUID = 1L ; private String status ; private String subject ; private String content ; private String accountRef ; public String getAccountRef ( ) { return accountRef ; } public String getContent ( ) { return content ; } public String getStatus ( ) { return status ; } public String getSubject ( ) { return subject ; } public void setAccountRef ( String accountRef ) { this . accountRef = accountRef ; } public void setContent ( String content ) { this . content = content ; } public void setStatus ( String status ) { this", "gt": ". status = status ;", "prediction": ". status = status ;\n", "label": 1}
{"id": 5288, "input": "<s> class T6932571neg { interface I < T > { } interface I1 extends I < String > { } static class Y implements I < String > { } final static class S implements I < String > { } <", "gt": "G extends I < G > > void test ( )", "prediction": "? extends I >\n", "label": 0}
{"id": 13949, "input": "<s> package org . restlet . engine . local ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import org . restlet . data . MediaType ; import org . restlet . representation . FileRepresentation ; import org . restlet . representation . Representation ; import org . restlet . service . MetadataService ; public class FileEntity extends Entity { private final File file ; public FileEntity ( File file , MetadataService metadataService ) { super ( metadataService ) ; this . file = file ; } @ Override public boolean exists ( ) { return getFile ( ) . exists ( ) ; } @ Override public List < Entity > getChildren ( ) { List < Entity > result = null ; if ( isDirectory ( ) ) { result = new ArrayList < Entity > ( ) ; for ( File f : getFile ( ) . listFiles ( ) ) { result . add ( new FileEntity ( f , getMetadataService ( ) ) ) ; } } return result ; } public File getFile ( ) { return file ; } @ Override", "gt": "public String getName ( )", "prediction": "public File getMetadataService ( )\n", "label": 1}
{"id": 2144, "input": "<s> package org . ofbiz . pos . event ; import java . util . Locale ; import org . ofbiz . pos . screen . PosScreen ; import org . ofbiz . pos . component . InputWithPassword ; import org . ofbiz . pos . component . Output ; import org . ofbiz . pos . PosTransaction ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . Debug ; import org . ofbiz . guiapp . xui . XuiSession ; import org . ofbiz . entity . GenericValue ; public class SecurityEvents { public static final String module = SecurityEvents . class . getName ( ) ; public static synchronized void login ( PosScreen pos ) { pos . setWaitCursor ( ) ; String [ ] func = pos . getInput ( ) . getFunction ( \"LOGIN\" ) ; if ( func == null ) { pos . getInput ( ) . setFunction ( \"LOGIN\" , \"\" ) ; } baseLogin ( pos , false ) ; pos . setNormalCursor ( ) ; } public static synchronized void logout ( PosScreen pos ) { pos . setWaitCursor ( ) ; PosTransaction trans = PosTransaction . getCurrentTx ( pos . getSession ( ) ) ; XuiSession session = pos . getSession ( ) ; trans . closeTx ( ) ; session . logout ( ) ; pos . showPage ( \"pospanel\" ) ; PosScreen . currentScreen . setLock ( true ) ; pos . setNormalCursor ( ) ; } public static synchronized void mgrLogin ( PosScreen pos ) { pos . setWaitCursor ( ) ; XuiSession session = pos . getSession ( ) ; if ( session . hasRole ( session . getUserLogin ( ) , \"MANAGER\" ) ) { ManagerEvents . mgrLoggedIn = true ; pos . showPage ( \"mgrpanel\" ) ; PosScreen . currentScreen . getInput ( ) . clear ( ) ; } else { String [ ] func = pos . getInput ( ) . getFunction ( \"MGRLOGIN\" ) ; if ( func == null ) { pos . getInput ( ) . setFunction ( \"MGRLOGIN\" , \"\" ) ; } baseLogin ( pos , true ) ; } pos . setNormalCursor ( ) ; } public static synchronized void lock ( PosScreen pos ) { pos . setLock ( true ) ; } private static synchronized void baseLogin ( PosScreen pos , boolean mgr ) { XuiSession session = pos . getSession ( ) ; Output output = pos . getOutput ( ) ; InputWithPassword input = pos . getInput ( ) ; String loginFunc = mgr ? \"MGRLOGIN\" : \"LOGIN\" ; String [ ] func", "gt": "= input . getLastFunction ( ) ;", "prediction": "= pos . getInput ( ) . getFunction ( \"MGRLOGIN\" ) ;\n", "label": 0}
{"id": 13953, "input": "<s> package org . eclipse . ui . internal . cheatsheets . data ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . ui . internal . cheatsheets . ICheatSheetResource ; import org . eclipse . ui . internal . cheatsheets . Messages ; public class ParserStatusUtility { public final static int PARSER_ERROR = 1001 ; public static IStatus addStatus ( IStatus status , int severity , String message , Throwable exception ) { Status newStatus = new Status ( severity , ICheatSheetResource . CHEAT_SHEET_PLUGIN_ID , PARSER_ERROR , message , exception ) ; if ( status . isOK ( ) ) { return newStatus ; } else", "gt": "if ( status instanceof MultiStatus )", "prediction": "\n", "label": 1}
{"id": 6921, "input": "<s> package com . sun . tools . javac . comp ; import java . util . * ; import java . util . Set ; import javax . tools . JavaFileObject ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . jvm . * ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . util . * ; import com . sun . tools . javac . util . List ; import com . sun . tools . javac . code . Type . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . tree . JCTree . * ; import static com . sun . tools . javac . code . Flags . * ; import static com . sun . tools . javac . code . Kinds . * ; import static com . sun . tools . javac . code . TypeTags . * ; import com . sun . tools . javac . util . JCDiagnostic . DiagnosticPosition ; public class MemberEnter extends JCTree . Visitor implements Completer { protected static final Context . Key < MemberEnter > memberEnterKey = new Context . Key < MemberEnter > ( ) ; final static boolean checkClash = true ; private final Names names ; private final Enter enter ; private final Log log ; private final Check chk ; private final Attr attr ; private final Symtab syms ; private final TreeMaker make ; private final ClassReader reader ; private final Todo todo ; private final Annotate annotate ; private final Types types ; private final JCDiagnostic . Factory diags ; private final Target target ; private final DeferredLintHandler deferredLintHandler ; private final boolean skipAnnotations ; public static MemberEnter instance ( Context context ) { MemberEnter instance = context . get ( memberEnterKey ) ; if ( instance == null ) instance = new MemberEnter ( context ) ; return instance ; } protected MemberEnter ( Context context ) { context . put ( memberEnterKey , this ) ; names = Names . instance ( context ) ; enter = Enter . instance ( context ) ; log = Log . instance ( context ) ; chk = Check . instance ( context ) ; attr = Attr . instance ( context ) ; syms = Symtab . instance ( context ) ; make = TreeMaker . instance ( context ) ; reader = ClassReader . instance ( context ) ; todo = Todo . instance ( context ) ; annotate = Annotate . instance ( context ) ; types = Types . instance ( context ) ; diags = JCDiagnostic . Factory . instance ( context ) ; target = Target . instance ( context ) ; deferredLintHandler = DeferredLintHandler . instance ( context ) ; Options options = Options . instance ( context ) ; skipAnnotations = options . isSet ( \"skipAnnotations\" ) ; } ListBuffer < Env < AttrContext > > halfcompleted = new ListBuffer < Env < AttrContext > > ( ) ; boolean isFirst = true ; boolean completionEnabled = true ; private void importAll ( int pos , final TypeSymbol tsym , Env < AttrContext > env ) { if ( tsym . kind == PCK && tsym . members ( ) . elems == null && ! tsym . exists ( ) ) { if ( ( ( PackageSymbol ) tsym ) . fullname .", "gt": "equals ( names . java_lang ) )", "prediction": "equals ( tsym ) )\n", "label": 0}
{"id": 13976, "input": "<s> package org . apache . lucene . xmlparser ; import java . io . * ; import junit . framework . TestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . search . Hits ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . RAMDirectory ; public class TestParser extends TestCase { CoreParser builder ; static Directory dir ; Analyzer analyzer = new StandardAnalyzer ( ) ; IndexReader reader ; private IndexSearcher searcher ; boolean printResults = false ; protected void setUp ( ) throws Exception { super . setUp ( ) ; builder = new CorePlusExtensionsParser ( \"contents\" , analyzer ) ; if ( dir == null ) { BufferedReader d = new BufferedReader ( new InputStreamReader ( TestParser . class . getResourceAsStream ( \"reuters21578.txt\" ) ) ) ; dir = new RAMDirectory ( ) ; IndexWriter writer = new IndexWriter ( dir , analyzer , true ) ; String line = d . readLine ( ) ; while ( line != null ) { int endOfDate = line . indexOf ( '\\t' ) ; String date = line . substring ( 0 , endOfDate ) . trim ( ) ; String content = line . substring ( endOfDate ) . trim ( ) ; org . apache . lucene . document . Document doc = new org . apache . lucene . document . Document ( ) ; doc . add ( new Field ( \"date\" , date , Field . Store . YES , Field . Index . ANALYZED ) ) ; doc . add ( new Field ( \"contents\" , content , Field . Store . YES , Field . Index . ANALYZED ) ) ; writer . addDocument ( doc ) ; line = d . readLine ( ) ; } d . close ( ) ; writer . close ( ) ; } reader = IndexReader . open ( dir ) ; searcher = new IndexSearcher ( reader ) ; } protected void tearDown ( ) throws Exception { reader . close ( ) ; searcher . close ( ) ; } public void testSimpleXML ( ) throws ParserException , IOException { Query q = parse ( \"TermQuery.xml\" ) ; dumpResults ( \"TermQuery\" , q , 5 ) ; } public void testSimpleTermsQueryXML ( ) throws ParserException , IOException { Query q = parse ( \"TermsQuery.xml\" ) ; dumpResults ( \"TermsQuery\" , q , 5 ) ; } public void testBooleanQueryXML ( ) throws ParserException , IOException { Query q = parse ( \"BooleanQuery.xml\" ) ; dumpResults ( \"BooleanQuery\" , q , 5 ) ; } public void testRangeFilterQueryXML ( ) throws ParserException , IOException { Query q = parse ( \"RangeFilterQuery.xml\" ) ; dumpResults ( \"RangeFilter\" , q , 5 ) ; } public void testUserQueryXML ( ) throws ParserException , IOException { Query q = parse ( \"UserInputQuery.xml\" ) ; dumpResults ( \"UserInput with Filter\" , q , 5 ) ; } public void testCustomFieldUserQueryXML ( ) throws ParserException , IOException { Query q = parse ( \"UserInputQueryCustomField.xml\" ) ; Hits h = searcher . search ( q ) ; assertEquals ( \"UserInputQueryCustomField should produce 0 result \" , 0 , h . length ( ) ) ; } public void testLikeThisQueryXML ( ) throws Exception { Query q = parse ( \"LikeThisQuery.xml\" ) ; dumpResults ( \"like this\" , q , 5 ) ; } public void testBoostingQueryXML ( ) throws Exception { Query q = parse ( \"BoostingQuery.xml\" ) ; dumpResults ( \"boosting \" , q , 5 ) ; } public void testFuzzyLikeThisQueryXML ( ) throws Exception { Query q = parse ( \"FuzzyLikeThisQuery.xml\" ) ; if ( printResults ) { System . out . println ( q . rewrite ( reader ) ) ; } dumpResults ( \"FuzzyLikeThis\" , q , 5 ) ; } public void testTermsFilterXML ( ) throws Exception { Query q = parse ( \"TermsFilterQuery.xml\" ) ; dumpResults ( \"Terms Filter\" , q , 5 ) ; } public void testBoostingTermQueryXML ( ) throws Exception { Query q = parse ( \"BoostingTermQuery.xml\" ) ; dumpResults ( \"BoostingTermQuery\" , q , 5 ) ; } public void testSpanTermXML ( ) throws Exception { Query q = parse ( \"SpanQuery.xml\" ) ; dumpResults ( \"Span Query\" , q , 5 ) ; } public void testConstantScoreQueryXML ( ) throws Exception { Query q = parse ( \"ConstantScoreQuery.xml\" ) ; dumpResults ( \"ConstantScoreQuery\" , q , 5 ) ; } public void testMatchAllDocsPlusFilterXML ( ) throws ParserException , IOException { Query q = parse ( \"MatchAllDocsQuery.xml\" ) ; dumpResults ( \"MatchAllDocsQuery with range", "gt": "filter\" , q , 5 ) ;", "prediction": "filter\" , q , 5 ) ;\n", "label": 1}
{"id": 8578, "input": "<s> package org . msl . simple . gmfmap . model . triggers . parent ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . mappings . ChildReference ; import org . eclipse . gmf . mappings . CompartmentMapping ; import org . eclipse . gmf . mappings . GMFMapFactory ; import org . msl . simple . gmfmap . simplemappings . SimpleChildReference ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; public class NewChildReferenceTrigger extends NewElementTrigger { private SimpleParentNode parent ; private SimpleChildReference newSimpleChildReference ; public NewChildReferenceTrigger ( TransactionalEditingDomain domain , SimpleParentNode parent , SimpleChildReference newSimpleChildReference ) { super ( domain , newSimpleChildReference ) ; this . newSimpleChildReference = newSimpleChildReference ; this . parent = parent ; } @ Override public void executeTrigger ( ) { if ( parent instanceof SimpleNode ) updateMapping ( ( SimpleNode ) parent ) ; if ( parent instanceof SimpleCompartment ) { SimpleNode parentNode = ( SimpleNode ) ( ( SimpleCompartment ) parent ) . getParent ( ) ; updateMapping ( parentNode , ( ( SimpleCompartment ) parent ) . getCompartmentMapping ( ) ) ; } } private void updateMapping ( SimpleNode parentNode ) { updateMapping ( parentNode , null ) ; } private void updateMapping ( SimpleNode parentNode , CompartmentMapping compartment ) { ChildReference newChildReference = GMFMapFactory .", "gt": "eINSTANCE . createChildReference ( ) ;", "prediction": "getChildReference ( parentNode ) ;\n", "label": 0}
{"id": 13984, "input": "<s> package org . restlet . data ; import java . util . ArrayList ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import org . restlet . engine . util . DateUtils ; import org . restlet . representation . RepresentationInfo ; public final class Conditions { private volatile List < Tag > match ; private volatile Date modifiedSince ; private volatile List < Tag > noneMatch ; private volatile Date rangeDate ; private volatile Tag rangeTag ; private volatile Date unmodifiedSince ; public Conditions ( ) { } public List < Tag > getMatch ( ) { List < Tag > m = this . match ; if ( m == null ) { synchronized ( this ) { m = this . match ; if ( m == null ) { this . match = m = new ArrayList < Tag > ( ) ; } } } return m ; } public Date getModifiedSince ( ) { return this . modifiedSince ; } public List < Tag > getNoneMatch ( ) { List < Tag > n = this . noneMatch ; if ( n == null ) { synchronized ( this ) { n = this . noneMatch ; if ( n == null ) { this . noneMatch = n = new ArrayList < Tag > ( ) ; } } } return n ; } public Date getRangeDate ( ) { return rangeDate ; } public Status getRangeStatus ( RepresentationInfo representationInfo ) { return getRangeStatus ( ( representationInfo == null ) ? null : representationInfo . getTag ( ) , ( representationInfo == null ) ? null : representationInfo . getModificationDate ( ) ) ; } public Status getRangeStatus ( Tag tag , Date modificationDate ) { Status result = Status . CLIENT_ERROR_PRECONDITION_FAILED ; if ( getRangeTag ( ) != null ) { boolean all = getRangeTag ( ) . equals ( Tag . ALL ) ; if ( tag != null ) { if ( all || getRangeTag ( ) . equals ( tag ) ) { result = Status . SUCCESS_OK ; } } } else if ( getRangeDate ( ) != null ) { if ( getRangeDate ( ) . equals ( modificationDate ) ) { result = Status . SUCCESS_OK ; } } return result ; } public Tag getRangeTag ( ) { return rangeTag ; } public Status getStatus ( Method method , boolean entityExists , Tag tag , Date modificationDate ) { Status result = null ; if ( ( this . match != null ) && ! this . match . isEmpty ( ) ) { boolean matched = false ; boolean failed = false ; boolean all = ( getMatch ( ) . size ( ) > 0 ) && getMatch ( ) . get ( 0 ) . equals ( Tag . ALL ) ; String statusMessage = null ; if ( entityExists ) { if ( ! all", "gt": "&& ( tag != null ) )", "prediction": ")\n", "label": 1}
{"id": 547, "input": "<s> public class T6266772 { static class Nested { Nested ( Object o ) { } } class Inner extends Nested { Inner ( ) { super ( new Object ( ) { { s ( ) ; } } ) ; } } void s ( ) { calledS = true ; if ( getClass ( ) != T6266772 . class ) throw new AssertionError ( getClass ( ) ) ; } static boolean calledS = false ; public static void main (", "gt": "String [ ] args )", "prediction": "String [ ] args )\n", "label": 0}
{"id": 13994, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . UriInfo ; import org . restlet . test . ext . jaxrs . services . tests . Issue593Test ; @", "gt": "Path ( \"test\" ) public class Issue593Resource", "prediction": "Test public class Issue593Test extends TestCase\n", "label": 1}
{"id": 3062, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . helpers ;", "gt": "public class SimpleSubNodeEditHelper extends SimplemapBaseEditHelper", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 14033, "input": "<s> package org . json ; import java . io . IOException ; import java . io . Writer ; public class JSONWriter { private static final int maxdepth = 200 ; private boolean comma ; protected char mode ; private final JSONObject stack [ ] ; private int top ; protected Writer writer ; public JSONWriter ( Writer w ) { this . comma = false ; this . mode = 'i' ; this . stack = new JSONObject [ maxdepth ] ; this . top = 0 ; this . writer = w ; } private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( \"Null pointer\" ) ; } if ( this . mode == 'o' || this . mode == 'a' ) { try { if ( this . comma && this . mode == 'a' ) { this . writer . write ( ',' ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == 'o' ) { this . mode = 'k' ; } this . comma = true ; return this ; } throw new JSONException ( \"Value out of sequence.\" ) ; } public JSONWriter array ( ) throws JSONException { if ( this . mode == 'i' || this . mode == 'o' || this . mode == 'a' ) { this . push ( null ) ; this . append ( \"[\" ) ; this . comma = false ; return this ; } throw new JSONException ( \"Misplaced array.\" ) ; } private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == 'a' ? \"Misplaced endArray.\" : \"Misplaced endObject.\" ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . comma = true ; return this ; } public JSONWriter endArray ( ) throws JSONException { return this . end ( 'a' , ']' ) ; } public JSONWriter endObject ( ) throws JSONException { return this . end ( 'k' , '}' ) ; } public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( \"Null key.\" ) ; } if ( this . mode == 'k' ) { try { this . stack [ this . top - 1 ] . putOnce ( string , Boolean . TRUE ) ; if ( this . comma ) { this . writer . write ( ',' ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( ':' ) ; this . comma = false ; this . mode = 'o' ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( \"Misplaced key.\" ) ; } public JSONWriter object ( ) throws JSONException { if ( this . mode == 'i' ) { this . mode = 'o' ; } if ( this . mode == 'o' || this . mode == 'a' ) { this . append ( \"{\" ) ; this . push ( new JSONObject ( ) ) ; this . comma = false ; return this ; } throw new JSONException ( \"Misplaced object.\" ) ; } private void pop ( char c ) throws JSONException { if ( this . top <= 0 ) { throw new JSONException ( \"Nesting error.\" ) ; } char m = this . stack [ this . top - 1 ] == null ? 'a' : 'k' ; if ( m != c ) { throw", "gt": "new JSONException ( \"Nesting error.\" ) ;", "prediction": "new JSONException ( m ) ;\n", "label": 1}
{"id": 7521, "input": "<s> package com . twofortyfouram . locale ; import android . content . pm . PackageInfo ; import android . content . pm . PackageManager ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public final class PackageUtilities { private static final Set < String > COMPATIBLE_PACKAGES = constructPackageSet ( ) ; private static Set < String > constructPackageSet ( ) { final HashSet < String > packages = new HashSet < String > ( ) ; packages . add ( Constants . LOCALE_PACKAGE ) ; packages . add ( \"net.dinglisch.android.taskerm\" ) ; packages . add ( \"net.dinglisch.android.tasker\" ) ; packages . add ( \"net.dinglisch.android.taskercupcake\" ) ; return Collections . unmodifiableSet ( packages ) ; } public static String getCompatiblePackage ( final PackageManager manager , final String packageHint ) { final List < PackageInfo > installedPackages = manager . getInstalledPackages ( 0 ) ; if ( COMPATIBLE_PACKAGES . contains ( packageHint ) ) { for ( final PackageInfo packageInfo : installedPackages ) { final String temp = packageInfo . packageName ; if ( packageHint . equals ( temp ) ) { return temp ; } } } for ( final String compatiblePackageName : COMPATIBLE_PACKAGES ) { if ( compatiblePackageName . equals ( packageHint ) ) { continue ; } for ( final PackageInfo packageInfo : installedPackages ) { final String temp = packageInfo . packageName ; if ( compatiblePackageName", "gt": ". equals ( temp ) )", "prediction": ". equals ( temp ) )\n", "label": 0}
{"id": 14037, "input": "<s> package org . restlet . test . ext . crypto ; import org . junit . Test ; import org . restlet . Application ; import org . restlet . Component ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . Restlet ; import org . restlet . Server ; import org . restlet . data . ChallengeRequest ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . MediaType ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . data . Status ; import org . restlet . ext . crypto . DigestAuthenticator ; import org . restlet . resource . ClientResource ; import org . restlet . resource . ResourceException ; import org . restlet . routing . Router ; import org . restlet . security . MapVerifier ; import org . restlet . test . RestletTestCase ; public class HttpDigestTestCase extends RestletTestCase { private Component component ; private int port ; private static class MyApplication extends Application { @ Override public Restlet createInboundRoot ( ) { Router router = new Router ( getContext ( ) ) ; DigestAuthenticator da = new DigestAuthenticator ( getContext ( ) , \"TestRealm\" , \"mySecretServerKey\" ) ; MapVerifier mapVerifier = new MapVerifier ( ) ; mapVerifier . getLocalSecrets ( ) . put ( \"scott\" , \"tiger\" . toCharArray ( ) ) ; da . setWrappedVerifier ( mapVerifier ) ; Restlet restlet = new Restlet ( getContext ( ) ) { @ Override public void handle ( Request request , Response response ) { response . setEntity ( \"hello, world\" , MediaType . TEXT_PLAIN ) ; } } ; da . setNext ( restlet ) ; router . attach ( \"/\" , da ) ; return router ; } } @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; component = new Component ( ) ; Server server = component . getServers ( ) . add ( Protocol . HTTP , 0 ) ; Application application = new MyApplication ( ) ; component . getDefaultHost ( ) . attach ( application ) ; component . start ( ) ; port = server . getEphemeralPort ( ) ; } @ Override protected void tearDown ( ) throws Exception { component . stop ( ) ; component = null ; super . tearDown ( ) ; } @ Test public void testDigest ( ) throws Exception { ClientResource cr = new ClientResource ( \"http://localhost:\" + port + \"/\" ) ; try { cr . get ( ) ; } catch ( ResourceException re ) { assertEquals ( Status . CLIENT_ERROR_UNAUTHORIZED , cr . getStatus ( ) ) ; ChallengeRequest c1 = null ; for ( ChallengeRequest challengeRequest : cr . getChallengeRequests ( ) ) { if ( ChallengeScheme . HTTP_DIGEST . equals ( challengeRequest . getScheme ( ) ) ) { c1 = challengeRequest ; break ; } } assertEquals ( ChallengeScheme . HTTP_DIGEST , c1 . getScheme ( ) ) ; String realm", "gt": "= c1 . getRealm ( ) ;", "prediction": "= challengeRequest . getChallengeScheme ( ) ;\n", "label": 1}
{"id": 8727, "input": "<s> import java . lang . annotation . * ; import java . util . * ; import com . sun . mirror . declaration . * ; import com . sun . mirror . type . * ; import static java . lang . annotation . RetentionPolicy . * ; public class GetAnno extends Tester { public static void main ( String [ ] args ) { ( new GetAnno ( ) ) . run ( ) ; } @ Retention ( RUNTIME ) @ interface AT1 { long l ( ) ; String s ( ) ; RetentionPolicy e ( ) ; String [ ] sa ( ) ; AT2 a ( ) ; } @ Inherited @ interface AT2 { } @ interface AT3 { Class value ( ) default String . class ; } @ interface AT4 { boolean [ ] bs ( ) ; long [ ] ls ( ) ; String [ ] ss ( ) ; RetentionPolicy [ ] es ( ) ; AT2 [ ] as ( ) ; } @ Test ( result = \"@GetAnno$AT1(l=7, s=sigh, e=CLASS, sa=[in, out], \" + \"a=@GetAnno$AT2())\" ) @ AT1 ( l = 7 , s = \"sigh\" , e = CLASS , sa = { \"in\" , \"out\" } , a = @ AT2 ) public Annotation getAnnotation ( ) { MethodDeclaration m = getMethod ( \"getAnnotation\" ) ; AT1 a = m . getAnnotation ( AT1 . class ) ; if ( a . l ( ) != 7 || ! a . s ( ) . equals ( \"sigh\" ) || a . e ( ) != CLASS ) throw new AssertionError ( ) ; return a ; } @ Test ( result = \"null\" ) public Annotation getAnnotationNotThere ( ) { return thisClassDecl . getAnnotation ( Deprecated . class ) ; } @ Test ( result = \"@GetAnno$AT4(bs=[true, false], \" + \"ls=[9, 8], \" + \"ss=[black, white], \" + \"es=[CLASS, SOURCE], \" + \"as=[@GetAnno$AT2(), @GetAnno$AT2()])\" ) @ AT4 ( bs = { true , false } , ls = { 9 , 8 } , ss = { \"black\" , \"white\" } , es = { CLASS , SOURCE } , as = { @ AT2 , @ AT2 } ) public AT4 getAnnotationArrayValues ( ) { MethodDeclaration m = getMethod ( \"getAnnotationArrayValues\" ) ; return m . getAnnotation ( AT4 . class ) ; } @ Test ( result = \"@GetAnno$AT3(value=java.lang.String)\" ) @ AT3 ( String . class ) public AT3 getAnnotationWithClass1 ( ) { MethodDeclaration m = getMethod ( \"getAnnotationWithClass1\" ) ; return m . getAnnotation ( AT3 . class ) ; } @ Test ( result = \"java.lang.String\" ) public TypeMirror getAnnotationWithClass2 ( ) { AT3 a = getAnnotationWithClass1 ( ) ; try {", "gt": "Class c = a . value ( ) ;", "prediction": "return m . getAnnotation ( AT3 . class ) ;\n", "label": 0}
{"id": 14056, "input": "<s> package org . eclipse . rap . rwt . internal . theme . css ; import org . w3c . css . sac . AttributeCondition ; public class AttributeConditionImpl implements AttributeCondition , ConditionExt { private final String localName ; private final String value ; private final boolean specified ; public AttributeConditionImpl ( String localName , String value , boolean specified ) { this . localName = localName ; this . value = value ; this . specified = specified ; } public String getLocalName ( ) { return localName ; } public String getNamespaceURI ( ) { return null ; } public boolean getSpecified ( ) { return specified ; } public String getValue ( ) { return value ; } public short getConditionType ( ) { return SAC_ATTRIBUTE_CONDITION ; } public int getSpecificity ( ) { return ATTR_SPEC ; } public String [ ] getConstraints ( ) {", "gt": "if ( value != null || localName == null )", "prediction": "return constraints ;\n", "label": 1}
{"id": 2233, "input": "<s> package objects . windows ; import java . awt . event . WindowEvent ; import java . awt . event . WindowStateListener ; import java . util . Timer ; import java . util . TimerTask ; import main . Application ; @ SuppressWarnings ( \"serial\" ) public class SplashDialog extends javax . swing . JDialog { private javax . swing . JLabel label ; public SplashDialog ( java . awt . Frame parent , boolean modal ) { setModal ( modal ) ; initComponents ( ) ; startDieTimer ( ) ; } private void initComponents ( ) { label = new javax . swing . JLabel ( ) ; setUndecorated ( true ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DO_NOTHING_ON_CLOSE ) ; setResizable ( false ) ; setSize ( 530 , 350 ) ; getContentPane ( ) . setLayout ( null ) ; label . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( \"/res/application-splash.png\" ) ) ) ; label . setBounds ( 0 , 0 , 530 , 350 ) ; getContentPane ( ) . add ( label ) ; addWindowStateListener ( new WindowStateListener ( ) { @ Override public void windowStateChanged ( WindowEvent e ) { System . out . println ( e ) ; System . out . println ( \"SplashDialog: Closing splash screen\" ) ; System . exit ( 0 ) ; } } ) ; } private void startDieTimer ( ) { final Timer timer = new Timer ( ) ; timer . scheduleAtFixedRate ( new TimerTask ( ) { @ Override public void run ( ) { if ( Application . mainWindow != null ) { timer . cancel ( ) ; dispose ( ) ; } } } , 1000 , 100 ) ; } public static void main ( String args [ ] ) { java . awt . EventQueue . invokeLater ( new Runnable ( ) {", "gt": "public void run ( )", "prediction": "public void run ( )\n", "label": 0}
{"id": 14060, "input": "<s> package org . eclipse . swt . internal . widgets . treekit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . internal . protocol . ProtocolTestUtil ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . rap . rwt . testfixture . Message . Operation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . CellToolTipUtil ; import org . eclipse . swt . internal . widgets . ICellToolTipAdapter ; import org . eclipse . swt . internal . widgets . ICellToolTipProvider ; import org . eclipse . swt . internal . widgets . ITreeAdapter ; import org . eclipse . swt . internal . widgets . Props ; import org . eclipse . swt . internal . widgets . controlkit . ControlLCATestUtil ; import org . eclipse . swt . internal . widgets . treekit . TreeLCA . ItemMetrics ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse", "gt": ". swt . widgets . Display ;", "prediction": ". swt . layout . GridLayout ;\n", "label": 1}
{"id": 3818, "input": "<s> package api . index ; import api . son . MySon ; public class Index { private Response response ; private String status ; public static Index init ( ) { String url = \"ajax.php?action=index\" ; Index index = ( Index ) MySon . toObject ( url , Index . class ) ; return index ; } public Response getResponse ( ) { return response ; } public boolean getStatus ( ) { if", "gt": "( status . equalsIgnoreCase ( \"success\" ) ) return true ;", "prediction": "( status == null )\n", "label": 0}
{"id": 14065, "input": "<s> package org . apache . camel . component . redis ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Date ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import org . apache . camel . impl . JndiRegistry ; import org . junit . Before ; import org . junit . Test ; import org . springframework . data . redis . connection . DataType ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . query . SortQuery ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyString ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . when ; public class RedisKeyTest extends RedisTestSupport { private RedisTemplate redisTemplate ; @ Override protected JndiRegistry createRegistry ( ) throws Exception { JndiRegistry registry = super . createRegistry ( ) ; registry . bind ( \"redisTemplate\" , redisTemplate ) ; return registry ; } @ Before public void setUp ( ) throws Exception { redisTemplate = mock ( RedisTemplate . class ) ; super . setUp ( ) ; } @ Test public void shouldExecuteDEL ( ) throws Exception { Collection < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"DEL\" , RedisConstants . KEYS , keys ) ; verify ( redisTemplate ) . delete ( keys ) ; } @ Test public void shouldExecuteEXISTS ( ) throws Exception { when ( redisTemplate . hasKey ( anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXISTS\" , RedisConstants . KEY , \"key\" ) ; verify ( redisTemplate ) . hasKey ( \"key\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIRE ( ) throws Exception { when ( redisTemplate . expire ( anyString ( ) , anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIRE\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" ) ; verify ( redisTemplate ) . expire ( \"key\" , 10L , TimeUnit . SECONDS ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteEXPIREAT ( ) throws Exception { when ( redisTemplate . expireAt ( anyString ( ) , any ( Date . class ) ) ) . thenReturn ( true ) ; long unixTime = System . currentTimeMillis ( ) / 1000L ; Object result = sendHeaders ( RedisConstants . COMMAND , \"EXPIREAT\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMESTAMP , unixTime ) ; verify ( redisTemplate ) . expireAt ( \"key\" , new Date ( unixTime * 1000L ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteKEYS ( ) throws Exception { Set < String > keys = new HashSet < String > ( ) ; keys . add ( \"key1\" ) ; keys . add ( \"key2\" ) ; when ( redisTemplate . keys ( anyString ( ) ) ) . thenReturn ( keys ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"KEYS\" , RedisConstants . PATTERN , \"key*\" ) ; verify ( redisTemplate ) . keys ( \"key*\" ) ; assertEquals ( keys , result ) ; } @ Test public void shouldExecuteMOVE ( ) throws Exception { when ( redisTemplate . move ( anyString ( ) , anyInt ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"MOVE\" , RedisConstants . KEY , \"key\" , RedisConstants . DB , \"2\" ) ; verify ( redisTemplate ) . move ( \"key\" , 2 ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePERSIST ( ) throws Exception { when ( redisTemplate . persist ( anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PERSIST\" , RedisConstants . KEY , \"key\" ) ; verify ( redisTemplate ) . persist ( \"key\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePEXPIRE ( ) throws Exception { when ( redisTemplate . expire ( anyString ( ) , anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PEXPIRE\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMEOUT , \"10\" ) ; verify ( redisTemplate ) . expire ( \"key\" , 10L , TimeUnit . MILLISECONDS ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecutePEXPIREAT ( ) throws Exception { when ( redisTemplate . expireAt ( anyString ( ) , any ( Date . class ) ) ) . thenReturn ( true ) ; long millis = System . currentTimeMillis ( ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"PEXPIREAT\" , RedisConstants . KEY , \"key\" , RedisConstants . TIMESTAMP , millis ) ; verify ( redisTemplate ) . expireAt ( \"key\" , new Date ( millis ) ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteRANDOMKEY ( ) throws Exception { when ( redisTemplate . randomKey ( ) ) . thenReturn ( \"key\" ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"RANDOMKEY\" ) ; verify ( redisTemplate ) . randomKey ( ) ; assertEquals ( \"key\" , result ) ; } @ Test public void shouldExecuteRENAME ( ) throws Exception { Object result = sendHeaders ( RedisConstants . COMMAND , \"RENAME\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUE , \"newkey\" ) ; verify ( redisTemplate ) . rename ( \"key\" , \"newkey\" ) ; } @ Test public void shouldExecuteRENAMENX ( ) throws Exception { when ( redisTemplate . renameIfAbsent ( anyString ( ) , anyString ( ) ) ) . thenReturn ( true ) ; Object result = sendHeaders ( RedisConstants . COMMAND , \"RENAMENX\" , RedisConstants . KEY , \"key\" , RedisConstants . VALUE , \"newkey\" ) ; verify ( redisTemplate ) . renameIfAbsent ( \"key\" , \"newkey\" ) ; assertEquals ( true , result ) ; } @ Test public void shouldExecuteSORT ( ) throws Exception { ArrayList < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 5 ) ; when ( redisTemplate . sort ( any ( SortQuery . class ) )", "gt": ") . thenReturn ( list ) ;", "prediction": ") . thenReturn ( true ) ;\n", "label": 1}
{"id": 3207, "input": "<s> package org . ofbiz . base . util . cache ; import java . io . Serializable ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ReferenceCleaner ; @ SuppressWarnings ( \"serial\" ) public abstract class CacheSoftReference < V > extends ReferenceCleaner . Soft < V > implements Serializable { public static final String module = CacheSoftReference . class . getName ( ) ; public CacheSoftReference ( V o ) { super ( o ) ; } @ Override public void clear ( ) { if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( new Exception ( \"UtilCache.CacheSoftRef.clear()\" ) , \"Clearing UtilCache SoftReference - \" + get ( ) , module ) ; } super . clear ( ) ; } @", "gt": "Override public void finalize ( ) throws Throwable", "prediction": "Override public void close ( )\n", "label": 0}
{"id": 14066, "input": "<s> package org . restlet . example . book . rest . ch3 ; import org . restlet . Client ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . ChallengeScheme ; import org . restlet . data . Method ; import org . restlet . data . Protocol ; import org . restlet . representation . Representation ; public class S3Authorized { public final static String ACCESS_KEY_ID = \"<REPLACE WITH YOUR OWN ID>\" ; public final static String SECRET_ACCESS_KEY = \"<REPLACE WITH YOUR OWN KEY>\" ; public final static String HOST = \"https://s3.amazonaws.com/\" ; public static Response authorizedDelete ( String uri ) { return handleAuthorized ( Method . DELETE , uri , null ) ; } public static Response authorizedGet ( String uri ) { return handleAuthorized ( Method . GET , uri , null ) ; } public static Response authorizedHead ( String uri ) { return handleAuthorized ( Method . HEAD ,", "gt": "uri , null ) ;", "prediction": "uri , null ) ;\n", "label": 1}
{"id": 1885, "input": "<s> interface Compar < T > { int compareTo ( T o ) ; } abstract class ErasureClashCrash implements Compar < ErasureClashCrash > { public int", "gt": "compareTo ( Object o )", "prediction": "compareTo ( Compar < T > o ) ;\n", "label": 0}
{"id": 14073, "input": "<s> package org . gatein . common . util ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ SuppressWarnings ( \"serial\" ) public class ListMap < K , V > extends CollectionMap < K , V > { public ListMap ( ) { } public ListMap ( SetMap < K , V > other ) throws IllegalArgumentException { super ( other ) ; } public ListMap ( SetMap < K , V > other , Comparator < V > comparator ) throws IllegalArgumentException { super ( other , comparator ) ; } public ListMap ( Comparator < V > comparator ) { super ( comparator ) ; } public List < V > get ( K key ) { return ( List", "gt": "< V > ) super . get ( key ) ;", "prediction": "< V > ) key ;\n", "label": 1}
{"id": 6873, "input": "<s> package org . gk . engine . client . exception ; public class LibraryNotFoundException extends GKEngineException { private static final long serialVersionUID = 1L ;", "gt": "public LibraryNotFoundException ( String msg )", "prediction": "public LibraryNotFoundException ( )\n", "label": 0}
{"id": 14088, "input": "<s> package com . emf4sw . owl . impl ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . emf . ecore . EPackage ; import org . eclipse . emf . ecore . impl . EFactoryImpl ; import org . eclipse . emf . ecore . plugin . EcorePlugin ; import com . emf4sw . owl . Annotation ; import com . emf4sw . owl . AnnotationProperty ; import com . emf4sw . owl . DataAllValuesFrom ; import com . emf4sw . owl . DataComplementOf ; import com . emf4sw . owl . DataExactCardinality ; import com . emf4sw . owl . DataHasValue ; import com . emf4sw . owl . DataIntersectionOf ; import com . emf4sw . owl . DataMaxCardinality ; import com . emf4sw . owl . DataMinCardinality ; import com . emf4sw . owl . DataOneOf ; import com . emf4sw . owl . DataProperty ; import com . emf4sw . owl . DataSomeValuesFrom ; import com . emf4sw . owl . DataUnionOf ; import com . emf4sw . owl . DatatypeDefinition ; import com . emf4sw . owl . DatatypeRestriction ; import com . emf4sw . owl . FacetRestriction ; import com . emf4sw . owl . Individual ; import com . emf4sw . owl . OWLClass ; import com . emf4sw . owl . OWLDatatype ; import com . emf4sw . owl . OWLFactory ; import com . emf4sw . owl . OWLPackage ; import com . emf4sw . owl . ObjectAllValuesFrom ; import com . emf4sw . owl . ObjectComplementOf ; import com . emf4sw . owl . ObjectExactCardinality ; import com . emf4sw . owl . ObjectHasSelf ; import com . emf4sw . owl . ObjectHasValue ; import com . emf4sw . owl . ObjectIntersectionOf ; import com . emf4sw . owl . ObjectMaxCardinality ; import com . emf4sw . owl . ObjectMinCardinality ; import com . emf4sw . owl . ObjectOneOf ; import com . emf4sw . owl . ObjectProperty ; import com . emf4sw . owl . ObjectPropertyChain ; import com . emf4sw . owl . ObjectSomeValuesFrom ; import com . emf4sw . owl . ObjectUnionOf ; import com . emf4sw . owl . Ontology ; public class OWLFactoryImpl extends EFactoryImpl implements OWLFactory { public static OWLFactory init ( ) { try { OWLFactory theOWLFactory = ( OWLFactory ) EPackage . Registry . INSTANCE . getEFactory ( \"http://www.w3.org/2002/07/owl\" ) ; if ( theOWLFactory != null ) { return theOWLFactory ; } } catch ( Exception exception ) { EcorePlugin . INSTANCE . log ( exception ) ; } return new OWLFactoryImpl ( ) ; } public OWLFactoryImpl ( ) { super ( ) ; } @ Override public EObject create ( EClass eClass ) { switch ( eClass . getClassifierID ( ) ) { case OWLPackage . ONTOLOGY : return createOntology ( ) ; case", "gt": "OWLPackage . OWL_CLASS : return createOWLClass ( ) ;", "prediction": "OWLDatatypeRestriction : return createOntologyRestriction ( ) ;\n", "label": 1}
{"id": 6801, "input": "<s> package org . ofbiz . base . conversion ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . NumberFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . TimeDuration ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilValidate ; import com . ibm . icu . util . Calendar ; public class DateTimeConverters implements ConverterLoader { public static class CalendarToDate extends AbstractConverter < Calendar , Date > { public CalendarToDate ( ) { super ( Calendar . class , Date . class ) ; } @ Override public boolean canConvert ( Class < ? > sourceClass , Class < ? > targetClass ) { return ObjectType . instanceOf ( sourceClass , this . getSourceClass ( ) ) && targetClass == this . getTargetClass ( ) ; } public Date convert ( Calendar obj ) throws ConversionException { return obj . getTime ( ) ; } } public static class CalendarToLong extends AbstractConverter < Calendar , Long > { public CalendarToLong ( ) { super ( Calendar . class , Long . class ) ; } public Long convert ( Calendar obj ) throws ConversionException { return obj . getTimeInMillis ( ) ; } } public static class CalendarToString extends AbstractConverter < Calendar , String > { public CalendarToString ( ) { super ( Calendar . class , String . class ) ; } public String convert ( Calendar obj ) throws ConversionException { Locale locale = obj . getLocale ( com . ibm . icu . util . ULocale . VALID_LOCALE ) . toLocale ( ) ; TimeZone timeZone = UtilDateTime . toTimeZone ( obj . getTimeZone ( ) . getID ( ) ) ; DateFormat df = UtilDateTime . toDateTimeFormat ( UtilDateTime . DATE_TIME_FORMAT , timeZone , locale ) ; return df . format ( obj ) ; } } public static class CalendarToTimestamp extends AbstractConverter < Calendar , Timestamp > { public CalendarToTimestamp ( ) { super ( Calendar . class , Timestamp . class ) ; } @ Override public boolean canConvert ( Class < ? > sourceClass , Class", "gt": "< ? > targetClass )", "prediction": "< ? > targetClass )\n", "label": 0}
{"id": 14090, "input": "<s> package org . eclipse . swt . events ; import static org . mockito . Mockito . mock ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Widget ; import junit . framework . TestCase ; public class ModifyEvent_Test extends TestCase { public void testUntypedEventConstructor ( ) throws Exception { Event event = new Event ( ) ; event . display = mock (", "gt": "Display . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 10062, "input": "<s> class OverrideCheck { static class A { public void f ( ) { } } static class B extends A { @", "gt": "Override public void f ( )", "prediction": "Override public void f ( )\n", "label": 0}
{"id": 14102, "input": "<s> package org . eclipse . rap . rwt . internal . util ; import java . util . Arrays ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . util . ActiveKeysUtil ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . SetOperation ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; public class ActiveKeysUtil_Test extends TestCase { private Display display ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testPreserveKeyBindingsEmpty ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; Fixture . preserveWidgets ( ) ; assertNull ( adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ) ; } public void testPreserveKeyBindings ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testPreserveActiveKeys ( ) { Shell shell = new Shell ( display ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( shell ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( shell ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; shell . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testKeyBindingsSafeCopy ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; keyBindings [ 0 ] = \"CTRL+B\" ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_ACTIVE_KEYS ) ; assertEquals ( \"CTRL+A\" , preserved [ 0 ] ) ; } public void testPreserveCancelKeysEmpty ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; Fixture . preserveWidgets ( ) ; assertNull ( adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ) ; } public void testPreserveCancelKeys ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testPreserveCancelKeysOnWidget ( ) { Shell shell = new Shell ( display ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( shell ) ; IWidgetAdapter adapter = WidgetUtil . getAdapter ( shell ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; shell . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertTrue ( Arrays . equals ( keyBindings , preserved ) ) ; } public void testCancelKeySafeCopy ( ) { Fixture . markInitialized ( display ) ; IWidgetAdapter adapter = DisplayUtil . getAdapter ( display ) ; String [ ] keyBindings = new String [ ] { \"CTRL+A\" } ; display . setData ( RWT . CANCEL_KEYS , keyBindings ) ; Fixture . preserveWidgets ( ) ; keyBindings [ 0 ] = \"CTRL+B\" ; String [ ] preserved = ( String [ ] ) adapter . getPreserved ( ActiveKeysUtil . PROP_CANCEL_KEYS ) ; assertEquals ( \"CTRL+A\" , preserved [ 0 ] ) ; } public void testWriteKeyBindings ( ) throws JSONException { Fixture . fakeNewRequest ( ) ; String [ ] keyBindings = new String [ ] { \"x\" , \"ALT+x\" , \"E\" , \"CTRL+INSERT\" , \"CTRL+E\" , \"SHIFT+CTRL+ALT+1\" , \"CTRL+ALT+E\" , \"F1\" , \"/\" , \"SHIFT+~\" , \"CTRL+ALT+#\" , \".\" , \",\" } ; display . setData ( RWT . ACTIVE_KEYS , keyBindings ) ;", "gt": "ActiveKeysUtil . renderActiveKeys ( display ) ;", "prediction": "Fixture . preserveWidgets ( ) ;\n", "label": 1}
{"id": 3988, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse . emf . common . util . EList ; public interface Shifts extends ShiftsResource , ShiftsTask { EList", "gt": "< ShiftsLimit > getLimits ( ) ;", "prediction": "result ;\n", "label": 0}
{"id": 14107, "input": "<s> package org . jscsi . target . scsi . sense ; import org . jscsi . target . scsi . ISerializable ; public abstract class SenseData implements ISerializable { protected final int responseCode ; protected final ErrorType errorType ; protected final SenseDataFormat senseDataFormat ; protected final SenseKey senseKey ; protected final AdditionalSenseCodeAndQualifier additionalSenseCodeAndQualifier ; public SenseData ( final ErrorType errorType , final SenseDataFormat senseDataFormat , final SenseKey senseKey , final AdditionalSenseCodeAndQualifier additionalSenseCodeAndQualifier ) { this . errorType = errorType ; this . senseDataFormat = senseDataFormat ; responseCode = getReponseCodeFor ( errorType , senseDataFormat ) ; this . senseKey = senseKey ; this . additionalSenseCodeAndQualifier = additionalSenseCodeAndQualifier ; } public static final int getReponseCodeFor ( final ErrorType errorType , final SenseDataFormat senseDataFormat ) { if ( senseDataFormat == SenseDataFormat . FIXED ) { if ( errorType == ErrorType . CURRENT ) return 0x70 ; else return 0x71 ; } else {", "gt": "if ( errorType == ErrorType . CURRENT ) return 0x72 ;", "prediction": "return 0x72 ;\n", "label": 1}
{"id": 9292, "input": "<s> package pkg2 ; import java . util . * ; public class Foo { public void method", "gt": "( Vector < Object > o )", "prediction": "( )\n", "label": 0}
{"id": 14142, "input": "<s> package org . apache . lucene . util ; import java . util . IdentityHashMap ; import java . util . Map ; public class AverageGuessMemoryModel extends MemoryModel { private final Map sizes = new IdentityHashMap ( ) { { put ( boolean . class , new Integer ( 1 ) ) ; put ( byte . class , new Integer ( 1 ) ) ; put ( char . class , new Integer ( 2 ) ) ; put ( short . class , new Integer ( 2 ) ) ; put ( int . class , new Integer ( 4 ) ) ; put ( float . class , new Integer ( 4 ) ) ; put ( double . class , new Integer ( 8 ) ) ; put ( long . class , new Integer ( 8 ) ) ; } } ; public int getArraySize ( ) { return 16 ; }", "gt": "public int getClassSize ( )", "prediction": "}\n", "label": 1}
{"id": 4585, "input": "<s> package org . ofbiz . content . search ; import java . util . Date ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . service . LocalDispatcher ; public class SearchServices { public static final String module = SearchServices . class . getName ( ) ; public static final String resource = \"ContentUiLabels\" ; public static Map < String , Object > indexTree ( DispatchContext dctx , Map < String , ? extends Object > context ) { Date start = new Date ( ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; String siteId = ( String ) context . get ( \"contentId\" ) ; String path = ( String ) context . get ( \"path\" ) ; Locale locale = ( Locale ) context . get ( \"locale\" ) ; if ( path == null ) { path = SearchWorker . getIndexPath ( path ) ; } Map < String , Object > envContext =", "gt": "FastMap . newInstance ( ) ;", "prediction": "dctx . getDelegator ( ) ;\n", "label": 0}
{"id": 14144, "input": "<s> package org . eclipse . ui . actions ; import org . eclipse . jface . action . Action ; import org . eclipse . ui . IPartListener ; import org . eclipse . ui . IWorkbenchPart ; public abstract class PartEventAction extends Action implements IPartListener { private IWorkbenchPart activePart ; protected PartEventAction ( String text ) { super ( text ) ; } protected PartEventAction ( String text , int style ) { super ( text , style ) ; } public IWorkbenchPart getActivePart ( ) { return activePart ; }", "gt": "public void partActivated ( IWorkbenchPart part )", "prediction": "}\n", "label": 1}
{"id": 433, "input": "<s> package LizaCraft . Entity ; import org . bukkit . entity . Skeleton ; import Liza . LizaSkeleton ; public class LizaCraftSkeleton extends LizaCraftMonster implements LizaSkeleton { public LizaCraftSkeleton ( Skeleton skeleton ) { super ( skeleton ) ; } @ Override public Skeleton getBukkitHandle ( ) { return", "gt": "( Skeleton ) this . entity ;", "prediction": "getBukkitHandle ( ) ;\n", "label": 0}
{"id": 14146, "input": "<s> package org . eclipse . xtext . xdoc . xdoc ; import org . eclipse . emf . common . util . EList ; public interface OrderedList extends MarkUp { EList <", "gt": "Item > getItems ( ) ;", "prediction": "OrderedList > orderedList ;\n", "label": 1}
{"id": 2409, "input": "<s> package org . msl . simple . gmfmap . diagram . properties . figure ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Figure ; import org . eclipse . gmf . gmfgraph . FigureDescriptor ; import org . msl . simple . gmfmap . diagram . properties . AbstractSimplemapPropertySection ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; public abstract class ElementWithFigurePropertySection extends AbstractSimplemapPropertySection { protected Figure getFigure ( Object selected ) { Object transformSelection = super . transformSelection ( selected ) ; Figure figure = null ; if ( transformSelection instanceof SimpleNode ) { figure = ( ( SimpleNode ) transformSelection ) . getDiagramNode ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleCompartment ) { figure = ( ( SimpleCompartment ) transformSelection ) . getCompartment ( ) . getAccessor ( ) . getFigure ( ) ; } if ( transformSelection instanceof SimpleLinkMapping ) { FigureDescriptor figDesc = ( ( SimpleLinkMapping ) transformSelection ) . getDiagramLink ( ) . getFigure ( ) ; figure = figDesc != null ? figDesc . getActualFigure ( ) : null ; } return figure ; } protected Figure getLabelFigure ( Object selected ) { Object transformSelection = super . transformSelection ( selected ) ; Figure figure = null ; if ( transformSelection instanceof SimpleNode ) { DiagramLabel diagramLabel = ( ( SimpleNode ) transformSelection ) . getDiagramLabel ( ) ; if ( diagramLabel != null && diagramLabel . getAccessor ( ) != null ) figure = diagramLabel . getAccessor ( ) . getFigure ( ) ; } if ( transformSelection instanceof SimpleLabelNode ) { figure = ( ( SimpleNode ) transformSelection ) . getDiagramLabel ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleCompartment ) { figure = ( ( SimpleCompartment ) transformSelection ) . getCompartment ( ) . getFigure ( ) . getActualFigure ( ) ; } if ( transformSelection instanceof SimpleLinkMapping ) { figure = ( ( SimpleLinkMapping ) transformSelection ) . getDiagramLabel (", "gt": ") . getFigure ( ) . getActualFigure ( ) ;", "prediction": ") . getFigure ( ) . getActualFigure ( ) ;\n", "label": 0}
{"id": 14167, "input": "<s> package org . fuzzydb . io . core ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Collection ; public interface PacketInterface { public Collection < ByteBuffer > read ( ) ; public void write ( ByteBuffer b ) throws IOException ; public void write ( ByteBuffer b [ ] ) throws IOException ; public void write ( Collection < ByteBuffer > b ) throws IOException ;", "gt": "public void close ( ) ;", "prediction": "}\n", "label": 1}
{"id": 760, "input": "<s> package com . redhat . ceylon . compiler . java . tools ; import com . redhat . ceylon . cmr . api . Logger ; import com . sun . tools . javac . main . OptionName ; import com . sun . tools . javac . util . Log ; import com . sun . tools . javac . util . Options ; public class JavacLogger implements Logger { private boolean debugEnabled ; private Log log ; public JavacLogger ( Options options , Log log ) { this . debugEnabled = options . get ( OptionName . VERBOSE ) != null || options . get ( OptionName . VERBOSE + \":cmr\" ) != null ; this . log = log ; } @ Override public void error ( String str ) { log . error ( \"ceylon\" , str ) ; } @ Override public void warning ( String str ) { log . warning ( \"ceylon\" , str ) ; } @ Override public void info ( String str ) { log . note ( \"ceylon\" , str ) ; } @ Override public void debug ( String str ) { if ( debugEnabled ) log . printLines (", "gt": "log . errWriter , \"[\" + str + \"]\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14171, "input": "<s> package org . gatein . common . logging ; import org . slf4j . Marker ; import org . slf4j . spi . LocationAwareLogger ; import java . lang . reflect . Method ; public abstract class Logger { public static final int SLF_1_5 = 0 ; public static final int SLF_1_6 = 1 ; static Method log ; public static final int LOGGER ; static { Method m = getLogMethod ( Marker . class , String . class , int . class , String . class , Throwable . class ) ; if ( m != null ) { LOGGER = SLF_1_5 ; } else { m = getLogMethod ( Marker . class , String . class , int . class , String . class , Object [ ] . class , Throwable . class ) ; if ( m != null ) { LOGGER = SLF_1_6 ; } else { throw new AssertionError ( \"Could not use with the found SLF 4J version \" + LocationAwareLogger . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) ) ; } } log = m ; } private static Method getLogMethod ( Class ... signature ) { try { return LocationAwareLogger . class . getMethod ( \"log\" , signature ) ; } catch ( NoSuchMethodException ignore ) { return null ; } } private static final Object [ ] NO_PARAMETERS = null ; protected abstract void doLog ( LogLevel level , Object msg , Object [ ] argArray , Throwable throwable ) ; protected abstract org . slf4j . Logger getDelegate ( ) ; private void log ( LogLevel level , Object msg , Throwable throwable , Object ... parameters ) { if ( level == null ) { level = LogLevel . INFO ; } if ( parameters != null && parameters . length > 0 ) { throw new UnsupportedOperationException ( \"log interpolation to do, for now it cannot be called\" ) ; } doLog ( level , msg , parameters , throwable ) ; } public final String getName ( ) { return getDelegate ( ) . getName ( ) ; } public final boolean isEnabled ( LogLevel level ) { if ( level == null ) { level = LogLevel . INFO ; } return level . isEnabled ( getDelegate ( ) ) ; } public final void log ( LogLevel level , Object msg ) { log ( level , msg , null , NO_PARAMETERS ) ; } public final void log ( LogLevel level , Object msg , Throwable throwable ) { log ( level , msg , throwable , NO_PARAMETERS ) ; } public final boolean isTraceEnabled ( ) { return isEnabled ( LogLevel . TRACE ) ; } public final void trace ( Object msg ) { log ( LogLevel . TRACE , msg , null , NO_PARAMETERS ) ; } public final void trace ( Object msg , Throwable throwable ) { log ( LogLevel . TRACE , msg , throwable , NO_PARAMETERS ) ; } public final boolean isDebugEnabled ( ) { return isEnabled ( LogLevel . DEBUG ) ; } public final void debug ( Object msg ) { log ( LogLevel . DEBUG , msg , null , NO_PARAMETERS ) ; } public final void debug ( Object msg , Throwable throwable ) { log ( LogLevel . DEBUG , msg , throwable , NO_PARAMETERS ) ; } public final boolean isInfoEnabled ( ) { return isEnabled ( LogLevel . INFO ) ; } public", "gt": "final void info ( Object msg )", "prediction": "final void info ( Object msg )\n", "label": 1}
{"id": 1584, "input": "<s> package Liza ; import org . bukkit . entity . TNTPrimed ;", "gt": "public interface LizaTNTPrimed extends TNTPrimed", "prediction": "import java . io . IOException ;\n", "label": 0}
{"id": 14196, "input": "<s> package org . eclipse . swt . accessibility ; public abstract class AccessibleTextAdapter implements AccessibleTextListener { public void getCaretOffset ( AccessibleTextEvent e ) { } public void", "gt": "getSelectionRange ( AccessibleTextEvent e )", "prediction": "setCaretOffset ( AccessibleTextEvent e )\n", "label": 1}
{"id": 2122, "input": "<s> interface LibInterface { @ Deprecated void m ( ) ; } class LibClass { public void m ( ) { } } class", "gt": "Test3 extends LibClass implements LibInterface", "prediction": "Object\n", "label": 0}
{"id": 14199, "input": "<s> package org . restlet . ext . wadl ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . w3c . dom . Node ; public abstract class DocumentedInfo { private List < DocumentationInfo > documentations ; public DocumentedInfo ( ) { super ( ) ; } public DocumentedInfo ( DocumentationInfo documentation ) { super ( ) ; getDocumentations ( ) . add ( documentation ) ; } public DocumentedInfo ( List < DocumentationInfo > documentations ) { super ( ) ; this . documentations = documentations ; } public DocumentedInfo ( String documentation ) { this ( new DocumentationInfo ( documentation ) ) ; } public List < DocumentationInfo > getDocumentations ( ) { List < DocumentationInfo > d = this . documentations ; if ( d == null ) { synchronized ( this ) { d = this . documentations ; if ( d == null ) { this . documentations = d = new ArrayList < DocumentationInfo > ( ) ; } } } return d ; } public Map < String , String > resolveNamespaces ( ) { Map < String , String > result = new HashMap < String , String > ( ) ; for ( DocumentationInfo documentationInfo : getDocumentations ( ) ) { if ( documentationInfo . getMixedContent ( ) != null ) { resolveNamespaces ( documentationInfo . getMixedContent ( ) , result ) ; } } return result ; } private void resolveNamespaces ( Node node , Map", "gt": "< String , String > namespaces )", "prediction": "< String , String > result )\n", "label": 1}
{"id": 5101, "input": "<s> package com . sun . tools . classfile ; import java . io . IOException ; public class StackMap_attribute extends Attribute { StackMap_attribute ( ClassReader cr , int name_index , int length ) throws IOException , StackMapTable_attribute . InvalidStackMap { super ( name_index , length ) ; number_of_entries = cr . readUnsignedShort ( ) ; entries = new stack_map_frame [ number_of_entries ] ; for ( int i = 0 ; i < number_of_entries ; i ++ ) entries [ i ] = new stack_map_frame ( cr ) ; } public StackMap_attribute ( ConstantPool constant_pool , stack_map_frame [ ] entries ) throws ConstantPoolException { this ( constant_pool . getUTF8Index ( Attribute . StackMap ) , entries ) ; } public StackMap_attribute ( int name_index , stack_map_frame [ ] entries ) { super ( name_index , StackMapTable_attribute . length ( entries ) ) ; this . number_of_entries = entries . length ; this . entries = entries ; } public < R , D > R accept ( Visitor < R , D > visitor , D data ) {", "gt": "return visitor . visitStackMap ( this , data ) ;", "prediction": "return visitor ;\n", "label": 0}
{"id": 14202, "input": "<s> package com . talis . hbase . rdf . layout . verticalpartitioning ; import java . util . Iterator ; import org . apache . hadoop . hbase . client . Get ; import org . apache . hadoop . hbase . client . HTable ; import org . apache . hadoop . hbase . client . Result ; import org . apache . hadoop . hbase . client . Scan ; import org . apache . hadoop . hbase . util . Bytes ; import com . hp . hpl . jena . graph . Node ; import com . hp . hpl . jena . graph . Triple ; import com . hp . hpl . jena . util . iterator . ExtendedIterator ; import com . hp . hpl . jena . util . iterator . NullIterator ; import com . talis . hbase . rdf . HBaseRdfException ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . TableQueryRunnerBase ; import com . talis . hbase . rdf . layout . TableQueryRunnerBasics ; import com . talis . hbase . rdf . util . HBaseUtils ; public class QueryRunnerVerticallyPartitioned extends TableQueryRunnerBase implements TableQueryRunnerBasics { public QueryRunnerVerticallyPartitioned ( String storeName , HBaseRdfConnection connection ) { super ( storeName , connection ) ; } @ Override public ExtendedIterator < Triple > tableFind ( Node sm , Node pm , Node om , String tblPrefix , String tblType ) { ExtendedIterator < Triple > trIter = NullIterator . instance ( ) ; try { if ( tblType . equalsIgnoreCase ( \"sub\" ) ) { Get res = new Get ( Bytes . toBytes ( sm . toString ( ) ) ) ; if ( pm . isConcrete ( ) ) { HTable table = tables ( ) . get ( name ( ) + \"-\" + tblPrefix + \"-\" + HBaseUtils . getNameOfNode ( pm ) + \"-subjects\" ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) trIter = new HBaseRdfSingleRowIterator ( rr , sm , pm , om , pm . toString ( ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ; } else { trIter = new HBaseRdfAllTablesIterator ( ) ; Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while ( iterTblNames . hasNext ( ) ) { String tblName = iterTblNames . next ( ) ; String mapPrefix = processTblName ( tblName , tblPrefix , \"subjects\" , \"objects\" ) ; if ( mapPrefix == null ) continue ; HTable table = tables ( ) . get ( tblName ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) ( ( HBaseRdfAllTablesIterator ) trIter ) . addIter ( new HBaseRdfSingleRowIterator ( rr , sm , pm , om , getPredicateMapping ( tblName ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ) ; tblName = null ; mapPrefix = null ; } ( ( HBaseRdfAllTablesIterator ) trIter ) . closeIter ( ) ; } res = null ; } else if ( tblType . equalsIgnoreCase ( \"obj\" ) ) { Get res = new Get ( Bytes . toBytes ( om . toString ( ) ) ) ; if ( pm . isConcrete ( ) ) { HTable table = tables ( ) . get ( name ( ) + \"-\" + tblPrefix + \"-\" + HBaseUtils . getNameOfNode ( pm ) + \"-objects\" ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) trIter = new HBaseRdfSingleRowIterator ( rr , sm , pm , om , pm . toString ( ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ; } else { trIter = new HBaseRdfAllTablesIterator ( ) ; Iterator < String > iterTblNames = tables ( ) . keySet ( ) . iterator ( ) ; while ( iterTblNames . hasNext ( ) ) { String tblName = iterTblNames . next ( ) ; String mapPrefix = processTblName ( tblName , tblPrefix , \"objects\" , \"subjects\" ) ; if ( mapPrefix == null ) continue ; HTable table = tables ( ) . get ( tblName ) ; Result rr = null ; if ( table != null ) rr = table . get ( res ) ; if ( rr != null && ! rr . isEmpty ( ) ) ( ( HBaseRdfAllTablesIterator ) trIter ) . addIter ( new HBaseRdfSingleRowIterator ( rr , sm , pm , om , getPredicateMapping ( tblName ) , TableDescVPCommon . COL_FAMILY_NAME_STR ) ) ; tblName = null ; mapPrefix = null ; } ( ( HBaseRdfAllTablesIterator ) trIter ) . closeIter ( ) ; } res = null ; } else if ( tblType . equalsIgnoreCase ( \"pred\" ) ) { Scan scanner = new Scan ( ) ; HTable table = tables ( ) . get ( name ( ) + \"-\" + tblPrefix + \"-\" + HBaseUtils . getNameOfNode ( pm ) + \"-subjects\" ) ; if ( table != null ) trIter = new HBaseRdfSingleTableIterator ( table . getScanner ( scanner ) , sm , pm , om , pm . toString ( ) ,", "gt": "TableDescVPCommon . COL_FAMILY_NAME_STR ) ;", "prediction": "TableDescVPCommon . COL_FAMILY_NAME_STR ) ;\n", "label": 1}
{"id": 7796, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . commands ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . gmf . runtime . common . core . command . CommandResult ; import org . eclipse . gmf . runtime . common . core . command . ICommand ; import org . eclipse . gmf . runtime . emf . type . core . IElementType ; import org . eclipse . gmf . runtime . emf . type . core . commands . EditElementCommand ; import org . eclipse . gmf . runtime . emf . type . core . requests . ConfigureRequest ; import org . eclipse . gmf . runtime . emf . type . core . requests . CreateElementRequest ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsFactory ; public class SimpleSubNodeCreateCommand extends EditElementCommand { public SimpleSubNodeCreateCommand ( CreateElementRequest req ) { super ( req . getLabel ( ) , null , req ) ; } protected EObject getElementToEdit ( ) { EObject container = ( ( CreateElementRequest ) getRequest ( ) ) . getContainer ( ) ; if ( container instanceof View ) { container = ( ( View ) container ) . getElement ( ) ; } return container ; } public boolean canExecute ( ) { return true ; } protected CommandResult doExecuteWithResult ( IProgressMonitor monitor , IAdaptable info ) throws ExecutionException { SimpleSubNode newElement = SimplemappingsFactory . eINSTANCE . createSimpleSubNode ( ) ; SimpleParentNode owner = ( SimpleParentNode ) getElementToEdit ( ) ; owner . getChildren ( ) . add ( newElement ) ; doConfigure ( newElement , monitor , info ) ; ( ( CreateElementRequest ) getRequest ( ) ) . setNewElement ( newElement ) ; return CommandResult . newOKCommandResult ( newElement ) ; } protected void doConfigure ( SimpleSubNode newElement , IProgressMonitor monitor , IAdaptable info ) throws ExecutionException { IElementType elementType = ( ( CreateElementRequest ) getRequest ( ) ) . getElementType ( ) ; ConfigureRequest configureRequest = new ConfigureRequest ( getEditingDomain ( ) , newElement , elementType ) ; configureRequest . setClientContext ( ( ( CreateElementRequest ) getRequest ( ) ) . getClientContext ( ) ) ; configureRequest . addParameters ( getRequest ( ) . getParameters ( ) ) ; ICommand configureCommand = elementType . getEditCommand ( configureRequest ) ; if ( configureCommand != null && configureCommand . canExecute ( ) ) { configureCommand . execute (", "gt": "monitor , info ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14205, "input": "<s> package org . apache . lucene . analysis . cn ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . lucene . analysis . BaseTokenStreamTestCase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . Tokenizer ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; public class TestChineseTokenizer extends BaseTokenStreamTestCase { public void testOtherLetterOffset ( ) throws IOException { String s = \"a\u5929b\" ; ChineseTokenizer tokenizer = new ChineseTokenizer ( new StringReader ( s ) ) ; int correctStartOffset = 0 ; int correctEndOffset = 1 ; OffsetAttribute offsetAtt = ( OffsetAttribute ) tokenizer . getAttribute ( OffsetAttribute . class ) ; while ( tokenizer . incrementToken ( ) ) { assertEquals ( correctStartOffset , offsetAtt . startOffset ( ) ) ; assertEquals ( correctEndOffset , offsetAtt . endOffset ( ) ) ; correctStartOffset ++ ; correctEndOffset ++ ; } } public void testReusableTokenStream ( ) throws Exception { Analyzer a = new ChineseAnalyzer ( ) ; assertAnalyzesToReuse ( a , \"\u4e2d\u534e\u4eba\u6c11\u5171\u548c\u56fd\" , new String [ ] { \"\u4e2d\" , \"\u534e\" , \"\u4eba\" , \"\u6c11\" , \"\u5171\" , \"\u548c\" , \"\u56fd\" } , new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 } , new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ) ; assertAnalyzesToReuse ( a , \"\u5317\u4eac\u5e02\" , new String [ ] { \"\u5317\" , \"\u4eac\" , \"\u5e02\" } , new int [ ] { 0 , 1 , 2 } , new int [ ] { 1 , 2 , 3 } ) ; } private class JustChineseTokenizerAnalyzer extends Analyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new ChineseTokenizer ( reader ) ; } } private class JustChineseFilterAnalyzer extends Analyzer { public TokenStream tokenStream ( String fieldName , Reader reader ) { return new ChineseFilter ( new WhitespaceTokenizer ( reader ) ) ; } } public void", "gt": "testNumerics ( ) throws Exception", "prediction": "testReusableTokenStream ( ) throws Exception\n", "label": 1}
{"id": 1699, "input": "<s> package org . openengsb . connector . github . internal ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . openengsb . core . api . AliveState ; import org . openengsb . core . api . DomainMethodNotImplementedException ; import org . openengsb . core . api . ekb . EKBCommit ; import org . openengsb . core . api . ekb . PersistInterface ; import org . openengsb . core . common . AbstractOpenEngSBConnectorService ; import org . openengsb . domain . issue . Field ; import org . openengsb . domain . issue . Issue ; import org . openengsb . domain . issue . IssueAttribute ; import org . openengsb . domain . issue . IssueDomain ; import org . openengsb . domain . issue . Status ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class GithubService extends AbstractOpenEngSBConnectorService implements IssueDomain { private static final Logger LOGGER = LoggerFactory . getLogger ( GithubService . class ) ; private PersistInterface persistInterface ; private AliveState state = AliveState . DISCONNECTED ; private String githubUser ; private String githubPassword ; private String repository ; private String repositoryOwner ; private GitHubAPI ghapi = new GitHubAPI ( ) ; public GithubService ( String id ) { super ( id ) ; } @ Override public AliveState getAliveState ( ) { return state ; } @ Override public void addComment ( String issueNumber , String commentString ) { ghapi . authenticate ( githubUser , githubPassword ) ; Issues service = new Issues ( ghapi ) ; service . add_comment ( repositoryOwner , repository , Integer . valueOf ( issueNumber ) , commentString ) ; LOGGER . info ( \"Commented Issue {} with \\\"{}\\\"\" , issueNumber , commentString ) ; } public Vector < GithubComment > getComments ( int issueId ) { Issues service = new Issues ( ghapi ) ; String [ ] v = service . list_comments ( repositoryOwner , repository , issueId ) . resp . split ( \"\\\"\\\\},\\\\{\\\"gravatar_id\\\":\\\"\" ) ; v [ 0 ] = v [ 0 ] . substring ( 29 ) ; Vector < GithubComment > listOfCommets = new Vector < GithubComment > ( ) ; for ( String i : v ) { String tmp = i ; GithubComment c = new GithubComment ( ) ; int index = tmp . indexOf ( \"\\\",\\\"\" ) ; c . setGravatarId ( tmp . substring ( 0 , index ) ) ; tmp = tmp . substring ( index + \"\\\",\\\"created_at\\\":\\\"\" . length ( ) ) ; index = tmp . indexOf ( \"\\\",\\\"\" ) ; c . setCreatedAt ( tmp . substring ( 0 , index ) ) ; tmp = tmp . substring ( index + \"\\\",\\\"body\\\":\\\"\" . length ( ) ) ; index = tmp . indexOf ( \"\\\",\\\"\" ) ; c . setBody ( tmp . substring ( 0 , index ) ) ; tmp = tmp . substring ( index + \"\\\",\\\"updated_at\\\":\\\"\" . length ( ) ) ; index = tmp . indexOf ( \"\\\",\\\"\" ) ; c . setUpdatedAt ( tmp . substring ( 0 , index ) ) ; tmp = tmp . substring ( index + \"\\\",\\\"id\\\":\\\"\" . length ( ) ) ; index = tmp . indexOf ( \",\\\"\" ) ; c . setId ( Integer . valueOf ( tmp . substring ( 0 , index ) ) ) ; tmp = tmp . substring ( index + \",\\\"user\\\":\\\"\" . length ( ) ) ; c . setUser ( tmp ) ; listOfCommets . add ( c ) ; LOGGER . info ( \"processed comment \\\"{}\\\" for Issue \\\"{}\\\")\" , c . getBody ( ) , issueId ) ; } LOGGER . info ( \"Got list of comments from {}\" , issueId ) ; return listOfCommets ; } Vector < GithubIssue > getIssues ( ) { Issues service = new Issues ( ghapi ) ; String temp = service . list ( repositoryOwner , repository , \"open\" ) . resp ; Vector < GithubIssue > listOfIssues = GithubHelper . processIssueResponse ( temp ) ; LOGGER . info", "gt": "( \"Got list of issues\" ) ;", "prediction": "( \"Commented Issue {} with \\\"{}\\\"\" , listOfIssues ) ;\n", "label": 0}
{"id": 14208, "input": "<s> package org . restlet . example . ext . openid ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; import java . util . logging . Logger ; import org . openid4java . message . DirectError ; import org . openid4java . message . Message ; import org . openid4java . message . ParameterList ; import org . openid4java . server . ServerManager ; import org . restlet . data . Form ; import org . restlet . data . Method ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; import org . restlet . resource . ServerResource ; import org . restlet . util . Series ; public class OpenIdProvider extends ServerResource { public OpenIdProvider ( ) { getLogger ( ) . info ( \"OpenID CREATED NEW PROVIDER\" ) ; } @ Post ( \"form\" ) public Representation represent ( Representation input ) { Form f = new Form ( input ) ; return handle ( new ParameterList ( f . getValuesMap ( ) ) ) ; } @ Get ( \"form\" ) public Representation represent ( ) { return handle ( new ParameterList ( getQuery ( ) . getValuesMap ( ) ) ) ; } private Representation handle ( ParameterList request ) { Logger log = getLogger ( ) ; log . info ( \"Handle on OP\" ) ; ConcurrentMap < String , Object > attribs = getContext ( ) . getAttributes ( ) ; ServerManager manager = ( ServerManager ) attribs . get ( \"openid_manager\" ) ; log . info ( \"OP endpoint = \" + manager . getOPEndpointUrl ( ) ) ; String mode = request . hasParameter ( \"openid.mode\" ) ? request . getParameterValue ( \"openid.mode\" ) : null ; Message response ; String responseText ; if ( \"associate\" . equals ( mode ) ) { response = manager . associationResponse ( request ) ; responseText = response . keyValueFormEncoding ( ) ; } else if ( \"checkid_setup\" . equals ( mode ) || \"checkid_immediate\" . equals ( mode ) ) { List < ? > userData = userInteraction ( request , manager . getOPEndpointUrl ( ) ) ; String userSelectedId = ( String ) userData . get ( 0 ) ; String userSelectedClaimedId = ( String ) userData . get ( 1 ) ; Boolean authenticatedAndApproved = ( Boolean ) userData . get ( 2 ) ; response = manager . authResponse ( request , userSelectedId , userSelectedClaimedId , authenticatedAndApproved . booleanValue ( ) ) ; if ( response instanceof DirectError ) { Form f = new Form ( ) ; @ SuppressWarnings ( \"unchecked\" ) Map < String , String > m = ( Map < String , String > ) response . getParameterMap ( ) ; for ( String key : m . keySet ( ) ) { f . add ( key , m . get ( key ) ) ; } return f . getWebRepresentation ( ) ; } else { redirectSeeOther ( response . getDestinationUrl ( true ) ) ; return new EmptyRepresentation ( ) ; } } else if ( \"check_authentication\" . equals ( mode ) ) { response = manager . verify ( request ) ; log . info ( \"OpenID : \" + response . keyValueFormEncoding ( ) ) ; responseText = response . keyValueFormEncoding ( ) ; } else if ( Method . GET . equals ( getMethod ( ) ) ) { sendXRDSLocation ( ) ; return new StringRepresentation (", "gt": "\"XRDS Discovery Information\" ) ;", "prediction": ") ;\n", "label": 1}
{"id": 9475, "input": "<s> package com . gisgraphy . client . impl . resultparser ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import javax . xml . stream . XMLEventReader ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . events . StartElement ; import javax . xml . stream . events . XMLEvent ; import org . apache . commons . io . IOUtils ; import org . springframework . core . io . InputStreamSource ; import com . google . common . collect . ImmutableList ; public class StaxGeolocalizationQueryResultParser implements GeolocalizationQueryResultParser { public Iterable < GeolocalisationResult > parse ( InputStreamSource iss ) throws ParsingException { try { return parseGeolocalisationResult ( iss ) ; } catch ( IOException e ) { throw new ParsingException ( e ) ; } catch ( XMLStreamException e ) { throw new ParsingException ( e ) ; } } public Iterable < GeolocalisationResult > parseGeolocalisationResult ( InputStreamSource iss ) throws IOException , XMLStreamException { List < GeolocalisationResult > searchResults = new ArrayList < GeolocalisationResult > ( ) ; XMLEventReader eventReader = null ; InputStream is = null ; try { XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; is = iss . getInputStream ( ) ; eventReader = inputFactory . createXMLEventReader ( is ) ; while ( eventReader . hasNext ( ) ) { XMLEvent event = eventReader . nextEvent ( ) ; if ( event . isStartElement ( ) ) { if ( event . asStartElement ( ) . getName ( ) . getLocalPart ( ) . equals ( \"result\" ) ) { Double distance = null ; String name = null ; String adm1Code = null ; String adm2Code = null ; String adm3Code = null ; String adm4Code = null ; String adm1Name = null ; String adm2Name = null ; String adm3Name = null ; String adm4Name = null ; String asciiName = null ; String countryCode = null ; String featureClass = null ; String featureCode = null ; Long featureId = null ; Integer gTopo30 = null ; Integer population = null ; String timezone = null ; Double latitude = null ; Double longitude = null ; String placeType = null ; String zipCode = null ; String googleMapUrl = null ; String yahooMapUrl = null ; String countryFlagUrl = null ; while ( eventReader . hasNext ( ) ) { XMLEvent innerEvent = eventReader . nextEvent ( ) ; if ( innerEvent . isStartElement ( ) ) { StartElement startElement = innerEvent", "gt": ". asStartElement ( ) ;", "prediction": ". asStartElement ( ) ;\n", "label": 0}
{"id": 14220, "input": "<s> package org . eclipse . rap . rwt ; import java . util . concurrent . atomic . AtomicReference ; import javax . servlet . http . HttpSession ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . SingletonManager ; import org . eclipse . rap . rwt . internal . service . ContextProvider ; import org . eclipse . rap . rwt . internal . service . ServiceContext ; import org . eclipse . rap . rwt . internal . service . SessionStoreImpl ; import org . eclipse . rap . rwt . testfixture . Fixture ; public class SingletonUtil_Test extends TestCase { @ Override protected void setUp ( ) throws Exception { Fixture . createServiceContext ( ) ; createSessionStore ( ) ; SingletonManager . install ( ContextProvider . getSessionStore ( ) ) ; } @ Override protected void tearDown ( ) throws Exception { if ( ContextProvider . hasContext ( ) ) { Fixture . disposeOfServiceContext ( ) ; } } public void testGetSessionInstance_failsWithNullArgument ( ) { try { SingletonUtil . getSessionInstance ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testGetSessionInstance_returnsInstanceOfGivenClass ( ) { Object instance = SingletonUtil . getSessionInstance ( TestSingleton . class ) ; assertNotNull ( instance ) ; assertSame ( TestSingleton . class , instance . getClass ( ) ) ; } public void testGetSessionInstance_returnsSameInstanceInSameSession ( ) { Object instance1 = SingletonUtil . getSessionInstance ( TestSingleton . class ) ; Object instance2 = SingletonUtil . getSessionInstance ( TestSingleton . class ) ; assertSame ( instance1 , instance2 ) ; } public void testGetSessionInstance_returnsNewInstanceInAnotherSession ( ) throws Throwable { Object instance1 = SingletonUtil . getSessionInstance ( TestSingleton . class ) ; final AtomicReference < Object > instance2 = new AtomicReference < Object > ( ) ; Fixture . runInThread ( new Runnable ( ) { public void run ( ) { Fixture . createServiceContext ( ) ; instance2 . set ( SingletonUtil . getSessionInstance ( TestSingleton . class ) ) ; } } ) ; assertNotSame ( instance1 , instance2 . get ( ) ) ; } public void testGetSessionInstance_returnsInstanceWithFakeContext ( ) throws Throwable { final ServiceContext serviceContext = ContextProvider . getContext ( ) ; final Object [ ] instance = { null } ; Runnable runnable = new Runnable ( ) { public void run ( ) { ContextProvider . setContext ( serviceContext ) ; instance [ 0 ] = SingletonUtil . getSessionInstance ( TestSingleton . class ) ; } } ; Fixture . runInThread ( runnable ) ; assertNotNull ( instance [ 0 ] ) ; } public void testGetSessionInstance_failsWithoutContext ( ) { ContextProvider . disposeContext ( ) ; try { SingletonUtil . getSessionInstance ( TestSingleton . class ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } }", "gt": "private static void createSessionStore ( )", "prediction": "}\n", "label": 1}
{"id": 6752, "input": "<s> package model ; import static org . junit . Assert . * ; import org . junit . Test ; public class PaymentInfoJUnit { @ Test public void paymentInfoConstructorTest ( ) { PaymentInfo e = new PaymentInfo ( ) ; PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( e != null ) ; assertTrue ( f != null ) ; } @ Test public void paymentInfoGetCardNumberTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getCardNumber ( ) . equals ( \"123456789\" ) ) ; } @ Test public void paymentInfoSetCardNumberTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getCardNumber ( ) . equals ( \"123456789\" ) ) ; f . setCardNumber ( \"987654321\" ) ; assertFalse ( f . getCardNumber ( ) . equals ( \"123456789\" ) ) ; assertTrue ( f . getCardNumber ( ) . equals ( \"987654321\" ) ) ; } @ Test public void paymentInfoGetNameTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getName ( ) . equals ( \"Bob\" ) ) ; } @ Test public void paymentInfoSetNameTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getName ( ) . equals ( \"Bob\" ) ) ; f . setName ( \"Jon\" ) ; assertFalse ( f . getName ( ) . equals ( \"Bob\" ) ) ; assertTrue ( f . getName ( ) . equals ( \"Jon\" ) ) ; } @ Test public void paymentInfoGetCountryTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getCountry ( ) . equals ( \"Canada\" ) ) ; } @ Test public void paymentInfoSetCountryTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getCountry ( ) . equals ( \"Canada\" ) ) ; f . setCountry ( \"US\" ) ; assertFalse ( f . getCountry ( ) . equals ( \"Canada\" ) ) ; assertTrue ( f . getCountry ( ) . equals ( \"US\" ) ) ; } @ Test public void paymentInfoGetAddressTest ( ) { PaymentInfo f = new PaymentInfo ( \"123456789\" , \"Bob\" , \"Canada\" , \"555 12st\" , \"\" , \"03\" , \"12\" , \"123\" , \"Sask\" , \"S6V6N4\" , \"5555555\" ) ; assertTrue ( f . getAddress ( ) . equals", "gt": "( \"555 12st\" ) ) ;", "prediction": "( \"123456789\" ) ) ;\n", "label": 0}
{"id": 14225, "input": "<s> package org . eclipse . swt . internal . widgets . textkit ; import java . io . IOException ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . swt . widgets . Text ; final class MultiTextLCA extends AbstractTextDelegateLCA { void preserveValues ( Text text ) { TextLCAUtil . preserveValues ( text ) ; } void readData ( Text text ) { TextLCAUtil . readTextAndSelection ( text ) ; ControlLCAUtil . processEvents ( text ) ; ControlLCAUtil . processKeyEvents ( text ) ; ControlLCAUtil . processMenuDetect ( text ) ; WidgetLCAUtil . processHelp ( text ) ; } void", "gt": "renderInitialization ( Text text ) throws IOException", "prediction": "setText ( Text text )\n", "label": 1}
{"id": 4528, "input": "<s> import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . tools . * ; @ SupportedAnnotationTypes ( \"*\" ) public class AnnoProc extends AbstractProcessor { public boolean process ( Set < ? extends TypeElement > elems , RoundEnvironment renv ) { if ( first ) { Filer filer = processingEnv . getFiler ( ) ; Messager messager = processingEnv . getMessager ( ) ; try { JavaFileObject fo = filer . createSourceFile ( \"Gen\" ) ; Writer out = fo . openWriter ( ) ; out", "gt": ". write ( \"class Gen", "prediction": ". close ( ) ;\n", "label": 0}
{"id": 14231, "input": "<s> package org . eclipse . ui . tests . session ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . themes . IThemeManager ; import junit . framework . TestCase ; public class ThemeStateTest extends TestCase { public ThemeStateTest ( final String name ) { super ( name ) ; }", "gt": "public void testBadPreference ( )", "prediction": "}\n", "label": 1}
{"id": 4500, "input": "<s> import java . util . List ; class T6369605a { static < T extends List < T > > T m1 ( ) { return null ; } static < T extends List < U > , U extends List < T > > T m2 ( ) { return null ; } static < T extends List < U > , U extends List < V > , V extends List < T > > T m3 ( ) { return null ; } List", "gt": "< ? > l1 = m1 ( ) ;", "prediction": "< T > m4 ( )\n", "label": 0}
{"id": 14232, "input": "<s> package io . beancounter . commons . model ; import io . beancounter . commons . model . auth . Auth ; import io . beancounter . commons . tests . annotations . Random ; import java . io . Serializable ; import java . util . * ; public class User implements Serializable { private static final long serialVersionUID = 324345235L ; private UUID id ; private String name ; private String surname ; private Map < String , Auth > services = new HashMap < String , Auth > ( ) ; private String password ; private String username ; private Map < String , String > metadata = new HashMap < String , String > ( ) ; private UUID userToken ; public User ( ) { id = UUID . randomUUID ( ) ; } @ Random ( names = { \"name\" , \"surname\" , \"username\" , \"password\" } ) public User ( String name , String surname , String username , String password ) { this ( ) ; this . name = name ; this . surname = surname ; this . username = username ; this . password = password ; } public void setId ( UUID id ) { this . id = id ; } public UUID getId ( ) { return id ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getSurname ( ) { return surname ; } public void setSurname ( String surname ) { this . surname = surname ; } public Map < String , Auth > getServices ( ) { return services ; } public void setServices ( Map < String , Auth > services ) { this . services = services ; } public Auth getAuth ( String service ) { return services . get ( service ) ; } public void addService ( String service , Auth auth ) { services . put ( service , auth ) ; } public void removeService ( String service ) {", "gt": "services . remove ( service ) ;", "prediction": "services . remove ( service ) ;\n", "label": 1}
{"id": 9047, "input": "<s> class FallThrough { int x ; void f ( int i ) { switch ( i ) { case 0 : x = 0 ; case 1 : case 2 : x = 2 ; break ; default", "gt": ": x = 3 ;", "prediction": ": break ;\n", "label": 0}
{"id": 14243, "input": "<s> package io . beancounter . platform . alive ; import org . apache . commons . httpclient . HttpClient ; import org . apache . commons . httpclient . methods . GetMethod ; import org . apache . http . HttpStatus ; import org . testng . Assert ; import org . testng . annotations . Test ; import io . beancounter . platform . APIResponse ; import io . beancounter . platform . AbstractJerseyTestCase ; import java . io . IOException ; public class AliveServiceTestCase extends AbstractJerseyTestCase { protected AliveServiceTestCase ( ) { super ( 9995 ) ; } @ Test public void testCheck ( ) throws IOException { HttpClient client = new HttpClient ( ) ; String baseQuery = \"api/check\" ; GetMethod getMethod = new GetMethod ( base_uri + baseQuery ) ; int result = client . executeMethod ( getMethod ) ; Assert . assertEquals ( result , HttpStatus . SC_OK ) ; String responseBody = new String ( getMethod . getResponseBody ( ) ) ; Assert . assertNotNull ( responseBody ) ; Assert . assertNotEquals ( responseBody , \"\" ) ; logger . info ( \"response: \" + responseBody ) ; APIResponse actual = fromJson ( responseBody , APIResponse . class ) ; APIResponse expected = new APIResponse ( actual . getObject ( ) , \"system up and", "gt": "running at\" , \"OK\" ) ;", "prediction": "running\" ) ;\n", "label": 1}
{"id": 9198, "input": "<s> package org . ofbiz . minilang . method . conditional ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . minilang . MiniLangException ; import org . ofbiz . minilang . MiniLangValidate ; import org . ofbiz . minilang . SimpleMethod ; import org . ofbiz . minilang . artifact . ArtifactInfoContext ; import org . ofbiz . minilang . method . MethodContext ; import org . ofbiz . minilang . method . MethodOperation ; import org . w3c . dom . Element ; public final class MasterIf extends MethodOperation { private final Conditional condition ; private final List < ElseIf > elseIfs ; private final List < MethodOperation > elseSubOps ; private final List < MethodOperation > thenSubOps ; public MasterIf ( Element element , SimpleMethod simpleMethod ) throws MiniLangException { super ( element , simpleMethod ) ; if ( MiniLangValidate . validationOn ( ) ) { MiniLangValidate . childElements ( simpleMethod , element , \"condition\" , \"then\" , \"else-if\" , \"else\" ) ; MiniLangValidate . requiredChildElements ( simpleMethod , element , \"condition\" , \"then\" ) ; } Element conditionElement = UtilXml . firstChildElement ( element , \"condition\" ) ; Element conditionChildElement = UtilXml . firstChildElement ( conditionElement ) ; this . condition = ConditionalFactory . makeConditional ( conditionChildElement , simpleMethod ) ; Element thenElement = UtilXml . firstChildElement ( element , \"then\" ) ; this . thenSubOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( thenElement , simpleMethod ) ) ; List < ? extends Element > elseIfElements = UtilXml . childElementList ( element , \"else-if\" ) ; if ( elseIfElements . isEmpty ( ) ) { this . elseIfs = null ; } else { List < ElseIf > elseIfs = new ArrayList < ElseIf > ( elseIfElements . size ( ) ) ; for ( Element elseIfElement : elseIfElements ) { elseIfs . add ( new ElseIf ( elseIfElement , simpleMethod ) ) ; } this . elseIfs = Collections . unmodifiableList ( elseIfs ) ; } Element elseElement = UtilXml . firstChildElement ( element , \"else\" ) ; if ( elseElement == null ) { this . elseSubOps = null ; } else { this . elseSubOps = Collections . unmodifiableList ( SimpleMethod . readOperations ( elseElement , simpleMethod ) ) ; } } @ Override public boolean exec ( MethodContext methodContext ) throws MiniLangException { boolean runSubOps = condition . checkCondition ( methodContext ) ; if ( runSubOps ) { return SimpleMethod . runSubOps ( thenSubOps , methodContext ) ; } else { if ( elseIfs != null ) { for ( ElseIf elseIf : elseIfs ) {", "gt": "if ( elseIf . checkCondition ( methodContext ) )", "prediction": "elseIfs . add ( new ElseIf ( elseIf , simpleMethod ) ) ;\n", "label": 0}
{"id": 14250, "input": "<s> package org . nuxeo . ecm . automation . core . impl . adapters ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . TypeAdaptException ; import org . nuxeo .", "gt": "ecm . automation . TypeAdapter ;", "prediction": "ecm . automation . OperationContext ;\n", "label": 1}
{"id": 3595, "input": "<s> package com . sap . prd . mobile . ios . mios . versioninfo . v_1_2_0 ; import javax . xml . bind . annotation . XmlType ; @ XmlType ( propOrder = { \"groupId\" , \"artifactId\" , \"version\" } ) public class Coordinates { private String groupId ; private String artifactId ; private String version ; public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getArtifactId ( ) { return artifactId ; } public void setArtifactId ( String artifactId ) { this . artifactId = artifactId ; } public String getVersion ( ) { return version ; } public", "gt": "void setVersion ( String version )", "prediction": "void setVersion ( String version )\n", "label": 0}
{"id": 14265, "input": "<s> package org . eclipse . rap . interactiondesign . tests . impl ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IToolBarManager ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . part . ViewPart ; public class ViewPartImpl extends ViewPart { public ViewPartImpl ( ) { } public void createPartControl ( Composite parent ) { IToolBarManager toolBarManager = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; toolBarManager .", "gt": "add ( new Action ( )", "prediction": "setControl ( parent ) ;\n", "label": 1}
{"id": 5283, "input": "<s> package org . xbill . DNS ; public class NSAP_PTRRecord extends SingleNameBase { private static final long serialVersionUID = 2386284746382064904L ; NSAP_PTRRecord ( ) { } Record getObject ( ) { return new NSAP_PTRRecord ( ) ; } public NSAP_PTRRecord ( Name name , int dclass , long ttl , Name target ) { super ( name , Type . NSAP_PTR", "gt": ", dclass , ttl , target , \"target\" ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14274, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import de . uos . igf . db3d . dbms . geom . Point3D ; import de . uos . igf . db3d . dbms . geom . ScalarOperator ; import de . uos . igf . db3d . dbms . structure . Space3D ; import de . uos . igf . db3d . dbms . util . TriangleServices ; public class TriangleNetBuilder { private Space3D space ; private ScalarOperator wsSOP ; protected List < TriangleNet3DComp > components ; protected int counter ; protected int compIDCounter ; public TriangleNetBuilder ( Space3D space ) { this . compIDCounter = 0 ; this . space = space ; this . wsSOP = null ; this . components = new ArrayList ( ) ; this . counter = 1 ; } public TriangleNetBuilder ( ScalarOperator sop ) { this . compIDCounter = 0 ; this . space = null ; this . wsSOP = sop ; this . components = new ArrayList ( ) ; this . counter = 1 ; } public void setComponentIDCounter ( int counter ) { this . compIDCounter = counter ; } public ScalarOperator getScalarOperator ( ) { if ( space != null ) return space . getScalarOperator ( ) . copy ( ) ; else return this . wsSOP . copy ( ) ; } public void addComponent ( TriangleElt3D [ ] elements ) { TriangleNet3DComp comp = new TriangleNet3DComp ( getScalarOperator ( ) , elements ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { elements [ i ] . setID ( counter ++ ) ; elements [ i ] . setNetComponent ( comp ) ; } components . add ( comp ) ; } public void addComponent ( TriangleElt3D [ ] elements , int id ) { TriangleNet3DComp comp = new TriangleNet3DComp ( getScalarOperator ( ) , elements ) ; comp . setComponentID ( id ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { elements [ i ] . setID ( counter ++ ) ; elements [ i ] . setNetComponent ( comp ) ; } components . add ( comp ) ; } public TriangleNet3D getTriangleNet ( ) { if ( components . size ( ) <= 0 ) return null ; TriangleNet3DComp [ ] compnet = new TriangleNet3DComp [ components . size ( ) ] ; for ( int i = 0 ; i < compnet . length ; i ++ ) compnet [ i ] = ( TriangleNet3DComp ) components . get ( i ) ; TriangleNet3D net = new TriangleNet3D ( compnet , getScalarOperator ( ) ) ; net . setComponentID ( this . compIDCounter ) ; for ( int i = 0 ; i < compnet . length ; i ++ ) { compnet [ i ] . setNet ( net ) ; if ( compnet [ i ] . getComponentID ( ) == - 1 ) compnet [ i ] . setComponentID ( net . nextComponentID ( ) ) ; } net", "gt": ". setElementID ( counter ) ;", "prediction": ". setComponentID ( this . compIDCounter ) ;\n", "label": 1}
{"id": 8911, "input": "<s> package com . sun . tools . javadoc ; import java . io . File ; import javax . tools . FileObject ; import com . sun . javadoc . SourcePosition ; import com . sun . tools . javac . util . Position ; public class SourcePositionImpl implements SourcePosition { FileObject filename ; int position ; Position . LineMap lineMap ; public File file ( ) { return ( filename == null ) ? null : new File ( filename . getName ( ) ) ; } public FileObject fileObject ( ) { return filename ; } public int line ( ) { if ( lineMap == null ) { return 0 ; } else { return lineMap . getLineNumber ( position ) ; } } public int column ( ) { if ( lineMap == null ) { return 0 ; } else { return lineMap . getColumnNumber ( position ) ; } } private SourcePositionImpl ( FileObject file , int position , Position . LineMap lineMap ) { super ( ) ; this . filename = file ; this . position = position ; this . lineMap = lineMap ; } public static SourcePosition make ( FileObject file , int pos , Position . LineMap lineMap ) { if ( file == null ) return null ; return new SourcePositionImpl (", "gt": "file , pos , lineMap ) ;", "prediction": "file ) ;\n", "label": 0}
{"id": 14278, "input": "<s> package br . org . archimedes . snap ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . State ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . commands . ICommandService ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import org . eclipse . ui . progress . UIJob ; import org . osgi . framework . BundleContext ; public class Activator extends AbstractUIPlugin { protected static final String PLUGIN_ID = \"br.org.archimedes.snap\" ; public static final String SNAP_COMMAND_ID = \"br.org.archimedes.snap.command\" ; public static final String SNAP_STATE = \"br.org.archimedes.snap.state\" ; @ Override public void start ( BundleContext context ) throws Exception { super . start ( context ) ; earlyStartup ( ) ; } private void earlyStartup ( ) { UIJob job = new UIJob ( \"InitCommandsWorkaround\" ) { public IStatus runInUIThread ( IProgressMonitor monitor ) { ICommandService commandService = ( ICommandService ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getService ( ICommandService . class ) ; Command command = commandService . getCommand ( SNAP_COMMAND_ID ) ; State state =", "gt": "command . getState ( SNAP_STATE ) ;", "prediction": "command . getState ( ) ;\n", "label": 1}
{"id": 3280, "input": "<s> package api . whatstatus ; public class Status { private String irc ; private String site ; private String tracker ; public int getIrc ( ) { if ( ( irc . equalsIgnoreCase ( \"up\" ) ) ) { System . out . println ( \"IRC Up\" ) ; return 0 ; } else if ( ( irc . equalsIgnoreCase ( \"down\" ) ) ) { System . out . println ( \"IRC Down\" ) ; return 1 ; } else { System . out . println ( \"IRC Maintenance\" ) ; return 2 ; } } public int getSite ( ) { if ( ( site . equalsIgnoreCase ( \"up\" ) ) ) { System . out . println ( \"Site Up\" ) ; return 0 ; } else if ( ( site . equalsIgnoreCase ( \"down\" ) ) ) { System . out . println ( \"Site Down\" ) ; return 1 ; } else { System . out . println ( \"Site Maintenance\" ) ; return 2 ; } } public int getTracker ( ) { if ( ( tracker . equalsIgnoreCase ( \"up\" ) ) ) { System . out .", "gt": "println ( \"Tracker Up\" ) ;", "prediction": "println ( \"Tracker Up\" ) ;\n", "label": 0}
{"id": 14302, "input": "<s> package org . seage . grammar . iif ; import org . seage . data . DataNode ; import org . seage . grammar . Symbol ; import org . seage . grammar . GrammarRule ; import org . seage . grammar . NonterminalSymbol ; import org . seage . grammar . TerminalSymbol ; import java . util . * ; public class CondGreaterEqualGrammarRule extends GrammarRule { private static final long serialVersionUID = - 5371425420528293918L ; public CondGreaterEqualGrammarRule ( int uniqueId ) { super ( new NonterminalSymbol ( \"COND\" ) , new Vector < Symbol > ( ) , uniqueId ) ; Vector < Symbol > left = getRight ( ) ; left . add ( new NonterminalSymbol ( \"E\" ) ) ; left . add ( new TerminalSymbol ( \">=\" , null ) ) ; left . add ( new NonterminalSymbol ( \"E\" ) ) ; } public Object eval ( DataNode symbolTable , NonterminalSymbol treePos ) throws Exception { Vector < Symbol > children = treePos . getChildren ( ) ; if ( children . size ( ) != 3 ) throw new Exception ( \"Arity error: expected 3 children, found: \" + children . size ( ) ) ; Integer left = ( Integer ) ( children . get ( 0 ) .", "gt": "eval ( symbolTable ) ) ;", "prediction": "size ( ) ) ;\n", "label": 1}
{"id": 8029, "input": "<s> package exceptions ; public class UserAlreadyExistsException extends Exception { private static final long serialVersionUID = 7146754211447615073L ; public", "gt": "UserAlreadyExistsException ( String message )", "prediction": "UserAlreadyExistsException ( )\n", "label": 0}
{"id": 14304, "input": "<s> package org . eclipse . swt . widgets ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . rap . rwt . lifecycle . ProcessActionRunner ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . events . ShellListener ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; import org . eclipse . swt . internal . widgets . IShellAdapter ; import org . eclipse . swt . internal . widgets . MenuHolder ; import org . eclipse . swt . internal . widgets . shellkit . ShellThemeAdapter ; public class Shell extends Decorations { private static final int MODE_NONE = 0 ; private static final int MODE_MAXIMIZED = 1 ; private static final int MODE_MINIMIZED = 2 ; private static final int MODE_FULLSCREEN = 4 ; private static final int INITIAL_SIZE_PERCENT = 60 ; private static final int MIN_WIDTH_LIMIT = 80 ; private class ShellAdapter implements IShellAdapter { public Control getActiveControl ( ) { return Shell . this . lastActive ; } public void setActiveControl ( Control control ) { Shell . this . setActiveControl ( control ) ; } public Rectangle getMenuBounds ( ) { return Shell . this . getMenuBounds ( ) ; } public void setBounds ( Rectangle bounds ) { Shell . this . setBounds ( bounds , false ) ; } public ToolTip [ ] getToolTips ( ) { return Shell . this . getToolTips ( ) ; } } private Control lastActive ; private transient IShellAdapter shellAdapter ; private String text ; private int alpha ; private Button defaultButton ; private Button saveDefault ; private Control savedFocus ; private Rectangle savedBounds ; private int mode ; private boolean modified ; private int minWidth ; private int minHeight ; private ToolTip [ ] toolTips ; private Shell ( Display display , Shell parent , int style , int handle ) { super ( checkParent ( parent ) ) ; if ( display != null ) { this . display = display ; } else { this . display = Display . getCurrent ( ) ; if ( this . display == null ) { this . display = Display . getDefault ( ) ; } } text = \"\" ; alpha = 0xFF ; mode = MODE_NONE ; this . style = checkStyle ( style ) ; state |= HIDDEN ; minWidth = MIN_WIDTH_LIMIT ; minHeight = getMinHeightLimit ( ) ; this . display . addShell ( this ) ; reskinWidget ( ) ; createWidget ( ) ; setInitialSize ( ) ; } public Shell ( ) { this ( ( Display ) null ) ; } public Shell ( int style ) { this ( ( Display ) null , style ) ; } public Shell ( Display display ) { this ( display , SWT . SHELL_TRIM ) ; } public Shell ( Display display , int style ) { this ( display , null , style , 0 ) ; } public Shell ( Shell parent ) { this ( parent , SWT . DIALOG_TRIM ) ; } public Shell ( Shell parent , int style ) { this ( parent != null ? parent . display : null , parent , style , 0 ) ; } @ Override Shell internalGetShell ( ) { return this ; } public Shell [ ] getShells ( ) { checkWidget ( ) ; return internalGetShells ( ) ; }", "gt": "private Shell [ ] internalGetShells ( )", "prediction": "}\n", "label": 1}
{"id": 6641, "input": "<s> package com . example . business . operator ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . junit . Test ; import com . asakusafw . runtime . core . Result ; import com . asakusafw . runtime . testing . MockResult ; import com . asakusafw . runtime . value . DateTime ; import com . example . business . modelgen . table . model . Shipment ; import com . example . business . modelgen . table . model . Stock ; import com . example . business . operator . StockOp . ShipmentStatus ; import com . example . business . testing . ShipmentFactory ; import com . example . business . testing . StockFactory ; public class StockOpTest { @ Test public void testCheckShipment_notShipped ( ) { StockOpImpl operator = new StockOpImpl ( ) ; Shipment shipment = new Shipment ( ) ; ShipmentStatus actual = operator . checkShipment ( shipment ) ; assertThat ( actual , is ( ShipmentStatus . NOT_SHIPPED ) ) ; } @ Test public void testCheckShipment_costUnKnown ( ) { StockOpImpl operator = new StockOpImpl ( ) ; Shipment shipment = new Shipment ( ) ; shipment . setShippedDate ( new DateTime ( ) ) ; ShipmentStatus actual = operator . checkShipment ( shipment ) ; assertThat ( actual , is ( ShipmentStatus . COST_UNKNOWN ) ) ; } @ Test public void testCheckShipment_shipped ( ) { StockOpImpl operator = new StockOpImpl ( ) ; Shipment shipment = new Shipment ( ) ; shipment . setShippedDate ( new DateTime ( ) ) ; shipment . setCost ( 100 ) ; ShipmentStatus actual = operator . checkShipment ( shipment ) ; assertThat ( actual , is ( ShipmentStatus . COMPLETED ) ) ; } @ Test public void testCutoff ( ) { StockOpImpl operator = new StockOpImpl ( ) ; List < Stock > stocks = new ArrayList < Stock > ( ) ; stocks . add ( StockFactory . create ( new DateTime ( ) , 0 , 100 , 10 ) ) ; List < Shipment > shipments = new ArrayList < Shipment > ( ) ; shipments . add ( ShipmentFactory . create ( new DateTime ( ) , 10 , 100 ) ) ; MockResult < Stock > newStocks = new MockResult < Stock > ( ) ; MockResult < Shipment > newShipments = new MockResult < Shipment > ( ) ; operator . cutoff ( stocks , shipments , newStocks , newShipments ) ; assertThat ( newStocks . getResults ( ) . size ( ) , is ( 1 ) ) ; assertThat ( newShipments . getResults ( ) . size ( ) , is ( 1 ) ) ; } @ Test public void testCutoff_shortage ( ) { StockOpImpl operator = new StockOpImpl ( ) ; List < Stock > stocks = Arrays . asList ( StockFactory . create ( new DateTime ( ) , 0 , 100 , 10 ) ) ; List < Shipment > shipments = Arrays . asList ( ) ; MockResult < Stock > newStocks = new MockResult < Stock > ( ) ; MockResult < Shipment > newShipments = new MockResult <", "gt": "Shipment > ( ) ;", "prediction": "Shipment > ( ) ;\n", "label": 0}
{"id": 14305, "input": "<s> package com . yahoo . ycsb . db ; import com . yahoo . ycsb . * ; import java . util . List ; import java . util . Set ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Vector ; import java . util . Random ; import java . util . Properties ; import org . apache . thrift . transport . TTransport ; import org . apache . thrift . transport . TSocket ; import org . apache . thrift . protocol . TProtocol ; import org . apache . thrift . protocol . TBinaryProtocol ; import org . apache . cassandra . service . * ; public class CassandraClient5 extends DB { static Random random = new Random ( ) ; public static final int Ok = 0 ; public static final int Error = - 1 ; public int ConnectionRetries ; public int OperationRetries ; public static final String CONNECTION_RETRY_PROPERTY = \"cassandra.connectionretries\" ; public static final String CONNECTION_RETRY_PROPERTY_DEFAULT = \"300\" ; public static final String OPERATION_RETRY_PROPERTY = \"cassandra.operationretries\" ; public static final String OPERATION_RETRY_PROPERTY_DEFAULT = \"300\" ; TTransport tr ; Cassandra . Client client ; boolean _debug = false ; public void init ( ) throws DBException { String hosts = getProperties ( ) . getProperty ( \"hosts\" ) ; if ( hosts == null ) { throw new DBException ( \"Required property \\\"hosts\\\" missing for CassandraClient5\" ) ; } ConnectionRetries = Integer . parseInt ( getProperties ( ) . getProperty ( CONNECTION_RETRY_PROPERTY , CONNECTION_RETRY_PROPERTY_DEFAULT ) ) ; OperationRetries = Integer . parseInt ( getProperties ( ) . getProperty ( OPERATION_RETRY_PROPERTY , OPERATION_RETRY_PROPERTY_DEFAULT ) ) ; _debug = Boolean . parseBoolean ( getProperties ( ) . getProperty ( \"debug\" , \"false\" ) ) ; String [ ] allhosts = hosts . split ( \",\" ) ; String myhost = allhosts [ random . nextInt ( allhosts . length ) ] ; Exception connectexception = null ; for ( int retry = 0 ; retry < ConnectionRetries ; retry ++ ) { tr = new TSocket ( myhost , 9160 ) ; TProtocol proto = new TBinaryProtocol ( tr ) ; client = new Cassandra . Client ( proto ) ; try { tr . open ( ) ; connectexception = null ; break ; } catch ( Exception e ) { connectexception = e ; } try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { } } if ( connectexception != null ) { System . err . println ( \"Unable to connect to \" + myhost + \" after \" + ConnectionRetries + \" tries\" ) ; System . out . println ( \"Unable to connect to \" + myhost + \" after \" + ConnectionRetries + \" tries\" ) ; throw new DBException ( connectexception ) ; } } public void cleanup ( ) throws DBException { tr . close ( ) ; } public int read ( String table , String key , Set < String > fields , HashMap < String , String > result ) { Exception errorexception = null ; for ( int i = 0 ; i < OperationRetries ; i ++ ) { try { SlicePredicate predicate ; if ( fields == null ) { predicate = new SlicePredicate ( null , new SliceRange ( new byte [ 0 ] , new byte [ 0 ] , false , 1000000 ) ) ; } else { Vector < byte [ ] > fieldlist = new Vector < byte [ ] > ( ) ; for ( String s : fields ) { fieldlist . add ( s . getBytes ( \"UTF-8\" ) ) ; } predicate = new SlicePredicate ( fieldlist , null ) ; } ColumnParent parent = new ColumnParent ( \"data\" , null ) ; List < ColumnOrSuperColumn > results = client . get_slice ( table , key , parent , predicate , ConsistencyLevel . ONE ) ; if ( _debug ) { System . out . print ( \"READ: \" ) ; } for ( ColumnOrSuperColumn oneresult : results ) { Column column = oneresult . column ; result . put ( new String ( column . name ) , new String ( column . value ) ) ; if ( _debug ) { System . out . print ( \"(\" + new String ( column . name ) + \"=\" + new String ( column . value ) + \")\" ) ; } } if ( _debug ) { System . out . println ( \"\" ) ; } return Ok ; } catch ( Exception e ) { errorexception = e ; } try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } errorexception . printStackTrace ( ) ; errorexception . printStackTrace ( System . out ) ; return Error ; } public int scan ( String table , String startkey , int recordcount , Set < String > fields , Vector < HashMap < String , String > > result ) { Exception errorexception = null ; for ( int i = 0 ; i < OperationRetries ; i ++ ) { try { SlicePredicate predicate ; if ( fields == null ) { predicate = new SlicePredicate ( null , new SliceRange ( new byte [ 0 ] , new byte [ 0 ] , false", "gt": ", 1000000 ) ) ;", "prediction": ", 1000000 ) ) ;\n", "label": 1}
{"id": 6382, "input": "<s> import java . io . * ; import java . util . * ; import com . sun . javadoc . * ; public class Tester { protected final String TEST_SRC = System . getProperty ( \"test.src\" , \".\" ) ; protected final String TEST_CLASSES = System . getProperty ( \"test.classes\" , \".\" ) ; private final String DEFAULT_ARGS [ ] = { \"-sourcepath\" , TEST_SRC , } ; private final File outputFile = new File ( TEST_CLASSES , \"testrun.out\" ) ; private final File expectedOutputFile = new File ( TEST_SRC , \"expected.out\" ) ; private String docletName ; private String [ ] args ; private Writer out = null ; public static abstract class Doclet extends com . sun . javadoc . Doclet { public static LanguageVersion languageVersion ( ) { return LanguageVersion . JAVA_1_5 ; } } public Tester ( String docletName ) { this ( docletName , new String [ 0 ] ) ; } public Tester ( String docletName , String ... additionalArgs ) { this . docletName = docletName ; int len = DEFAULT_ARGS . length + additionalArgs . length ; args = new String [ len ] ; System . arraycopy ( DEFAULT_ARGS , 0 , args , 0 , DEFAULT_ARGS . length ) ; System . arraycopy ( additionalArgs , 0 , args , DEFAULT_ARGS . length , additionalArgs . length ) ; try { out = new BufferedWriter ( new FileWriter ( outputFile ) ) ; } catch ( IOException e ) { throw new Error ( \"Could not open output file \" + outputFile ) ; } } public void run ( ) throws IOException { try { if ( com . sun . tools . javadoc . Main . execute ( \"javadoc\" , docletName , getClass ( ) . getClassLoader ( ) , args ) != 0 ) { throw new Error ( \"Javadoc errors encountered.\" ) ; } System . out . println ( \"--> Output written to \" + outputFile ) ; } finally { out . close ( ) ; } } public void verify ( ) throws IOException { BufferedReader thisRun = new BufferedReader ( new FileReader ( outputFile ) ) ; BufferedReader expected = new BufferedReader ( new FileReader ( expectedOutputFile ) ) ; for ( int lineNum = 1 ; true ; lineNum ++ ) { String line1 = thisRun . readLine ( ) ; String line2 = expected . readLine ( ) ; if ( line1 == null && line2 == null ) { return ; } if ( line1 == null || ! line1 . equals ( line2 ) ) { throw new Error ( outputFile + \":\" + lineNum + \": output doesn't match\" ) ; } } } public void println ( Object o ) throws IOException { prln ( 0 , o ) ; } public void println ( ) throws IOException { prln ( ) ; } public void printPackage ( PackageDoc p ) throws IOException { prPackage ( 0 , p ) ; } public void printClass ( ClassDoc cd ) throws IOException { if ( cd . isAnnotationType ( ) ) printAnnotationType ( ( AnnotationTypeDoc ) cd ) ; else prClass ( 0 , cd ) ; } public void printAnnotationType ( AnnotationTypeDoc at ) throws IOException { prAnnotationType ( 0 , at ) ; } public void printField ( FieldDoc f ) throws IOException { prField ( 0 , f ) ; } public void printParameter ( Parameter p ) throws IOException { prParameter ( 0 , p ) ; } public void printMethod ( MethodDoc m ) throws IOException { prln ( 0 , \"method \" + m ) ; prMethod ( 0 , m ) ; } public void printAnnotationTypeElement ( AnnotationTypeElementDoc e ) throws IOException { prln ( 0 , \"element \" + e ) ; prMethod ( 0 , e ) ; } public void printConstructor ( ConstructorDoc c ) throws IOException { prln ( 0 , \"constructor \" + c ) ; prExecutable ( 0 , c ) ; } private void prPackage ( int off , PackageDoc p ) throws IOException { prln ( off , \"package \" + p ) ; prAnnotations ( off + 2 , p . annotations ( ) ) ; } private void prClass ( int off , ClassDoc cd ) throws IOException { prln ( off , ( cd . isInterface ( ) ? \"interface\" : cd . isEnum ( ) ? \"enum\" : \"class\" ) + \" \" + cd ) ; prln ( off + 2 , \"name: \" + cd . simpleTypeName ( ) + \" / \" + cd . typeName ( ) + \" / \" + cd . qualifiedTypeName ( ) ) ; prAnnotations ( off + 2 , cd . annotations ( ) ) ; prLabel ( off + 2 , \"type parameters\" ) ; for ( Type t : cd . typeParameters ( ) ) prln ( off + 4 , t ) ; prParamTags ( off + 2 , cd . typeParamTags ( ) ) ; prLabel ( off + 2 , \"nested in\" ) ; prln ( off + 4 , cd . containingClass ( ) ) ; prLabel ( off + 2 , \"superclass\" ) ; prln ( off + 4 , cd . superclassType ( ) ) ; prLabel ( off + 2 , \"interfaces\" ) ; Type [ ] ts = cd . interfaceTypes ( ) ; Arrays . sort ( ts ) ; for ( Type t : ts ) prln ( off + 4 , t ) ; prLabel ( off + 2 , \"enum constants\" ) ; for ( FieldDoc f : cd . enumConstants ( ) ) prln ( off + 4 , f . name ( ) ) ; prLabel ( off + 2 , \"fields\" ) ; for ( FieldDoc f : cd . fields ( ) ) prln ( off + 4 , f . type ( ) + \" \" + f . name ( ) ) ; prLabel ( off + 2 , \"constructors\" ) ; for ( ConstructorDoc c : cd . constructors ( ) ) prln ( off + 4 , c .", "gt": "name ( ) + c . flatSignature ( ) ) ;", "prediction": "annotations ( ) ) ;\n", "label": 0}
{"id": 14314, "input": "<s> package org . eclipse . swt . internal . widgets . menukit ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import java . io . IOException ; import java . util . Arrays ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . internal . protocol . ClientMessageConst ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . Message ; import org . eclipse . rap . rwt . testfixture . Message . CallOperation ; import org . eclipse . rap . rwt . testfixture . Message . CreateOperation ; import org . eclipse . rap . rwt . testfixture . Message . DestroyOperation ; import org . eclipse . rap . rwt . testfixture . Message . Operation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ArmEvent ; import org . eclipse . swt . events . ArmListener ; import org . eclipse . swt . events . HelpEvent ; import org . eclipse . swt . events . HelpListener ; import org . eclipse . swt . events . MenuAdapter ; import org . eclipse . swt . events . MenuListener ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . swt . widgets . MenuItem ; import org . eclipse . swt . widgets . Shell ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; public class MenuLCA_Test extends TestCase { private Display display ; private Shell shell ; private MenuLCA lca ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; shell = new Shell ( display , SWT . NONE ) ; lca = new MenuLCA ( ) ; Fixture . fakeNewRequest ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testUnassignedMenuBar ( ) throws IOException { String shellId = WidgetUtil . getId ( shell ) ; Menu menuBar = new Menu ( shell , SWT . BAR ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( menuBar ) ; lca . renderChanges ( menuBar ) ; Message message = Fixture . getProtocolMessage ( ) ; assertNull ( message . findSetOperation ( menuBar , \"parent\" ) ) ; Fixture . fakeNewRequest ( display ) ; Fixture . preserveWidgets ( ) ; shell . setMenuBar ( menuBar ) ; lca . renderChanges ( menuBar ) ; message = Fixture . getProtocolMessage ( ) ; assertEquals ( shellId , message . findSetProperty ( menuBar , \"parent\" ) ) ; Fixture . fakeNewRequest ( display ) ; Fixture . preserveWidgets ( ) ; shell . setMenuBar ( null ) ; lca . renderChanges ( menuBar ) ; message = Fixture . getProtocolMessage ( ) ; assertEquals ( JSONObject . NULL , message . findSetProperty ( menuBar , \"parent\" ) ) ; } public void testRenderBoundsForMenuBar ( ) throws JSONException { Menu menuBar = new Menu ( shell , SWT . BAR ) ; Fixture . markInitialized ( display ) ; Fixture . markInitialized ( shell ) ; Fixture . markInitialized ( menuBar ) ; shell . setMenuBar ( menuBar ) ; Integer [ ] param = new Integer [ ] { Integer . valueOf ( 0 ) , Integer . valueOf ( 0 ) , Integer . valueOf ( 1234 ) , Integer . valueOf ( 4321 ) } ; Fixture . fakeSetParameter ( getId ( shell ) , \"bounds\" , param ) ; Fixture . executeLifeCycleFromServerThread ( ) ; Message message = Fixture . getProtocolMessage ( ) ; JSONArray bounds = ( JSONArray ) message . findSetProperty ( menuBar , \"bounds\" ) ; assertEquals ( 1234 , bounds . getInt ( 2 ) ) ; assertNotNull ( message . findSetOperation ( menuBar , \"bounds\" ) ) ; } public void testRenderCreate ( ) throws IOException { Menu menu = new Menu ( shell , SWT . BAR ) ; lca . renderInitialization ( menu ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation = message . findCreateOperation ( menu ) ; assertEquals ( \"rwt.widgets.Menu\" , operation . getType ( ) ) ; assertTrue ( Arrays . asList ( operation . getStyles ( ) ) . contains ( \"BAR\" ) ) ; } public void testRenderCreatePopUp ( ) throws IOException { Menu menu = new Menu ( shell , SWT . POP_UP ) ; lca . renderInitialization ( menu ) ; Message message = Fixture . getProtocolMessage ( ) ; CreateOperation operation =", "gt": "message . findCreateOperation ( menu ) ;", "prediction": "message . findCreateOperation ( menu ) ;\n", "label": 1}
{"id": 7533, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public class VersionNumber { private static final String BUGID = \"4720849\" ; private static final String BUGNAME = \"VersionNumber\" ; private static final String FS = System . getProperty ( \"file.separator\" ) ; private static final String PS = System . getProperty ( \"path.separator\" ) ; private static final String LS = System . getProperty ( \"line.separator\" ) ; private static final String TMPDEST_DIR1 = \".\" + FS + \"docs1\" + FS ; private static final String TMPDEST_DIR2 = \".\" + FS + \"docs2\" + FS ; public static int subtestNum = 0 ; public static int numSubtestsPassed = 0 ; public static void main ( String [ ] args ) { String srcdir = System . getProperty ( \"test.src\" , \".\" ) ; runJavadoc ( new String [ ] { \"-d\" , TMPDEST_DIR1 , \"p1\" } ) ; runTestsOnHTML ( testArray ) ; printSummary ( ) ; } public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( javadocArgs ) != 0 ) { throw new Error ( \"Javadoc failed to execute\" ) ; } } private static final String [ ] [ ] testArray = { { \"<!-- Generated by javadoc (version\" , TMPDEST_DIR1 + \"p1\" + FS + \"C.html\" } , } ; public static void runTestsOnHTML ( String [ ] [ ] testArray ) { for ( int i = 0 ; i < testArray . length ; i ++ ) { subtestNum += 1 ; String fileString = readFileToString ( testArray [ i ] [ 1 ] ) ; String stringToFind = testArray [ i ] [ 0 ] ; if ( findString ( fileString , stringToFind ) == - 1 ) { System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" for bug \" + BUGID + \" (\" + BUGNAME + \") FAILED\\n\" + \"when searching for:\\n\" + stringToFind ) ; } else { numSubtestsPassed += 1 ; System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" passed:\\n\" + stringToFind ) ; } } } public static void printSummary ( ) { if ( numSubtestsPassed == subtestNum ) { System . out . println ( \"\\nAll \" + numSubtestsPassed + \" subtests passed\" ) ; } else { throw new Error ( \"\\n\" + ( subtestNum - numSubtestsPassed ) + \" of \" + ( subtestNum ) + \" subtests failed for bug \" + BUGID + \" (\" + BUGNAME + \")\\n\" ) ; } } public static String readFileToString ( String filename ) { try { File file = new File ( filename ) ; if ( ! file . exists ( ) ) { System . out . println ( \"\\nFILE DOES NOT EXIST: \" + filename ) ; } BufferedReader in = new BufferedReader ( new FileReader ( file ) ) ; char [ ] allChars = new char [ ( int ) file . length ( ) ] ; in . read ( allChars , 0 , ( int )", "gt": "file . length ( ) ) ;", "prediction": "file . length ( ) ) ;\n", "label": 0}
{"id": 14323, "input": "<s> package org . seage . problem . qap . tabusearch ; import org . seage . metaheuristic . tabusearch . * ; public class QapObjectiveFunction implements ObjectiveFunction { public double [ ] [ ] [ ] _matrix ; public QapObjectiveFunction ( Double [ ] [ ] [ ] facilityLocation ) { int numFacilities = facilityLocation [ 0 ] [ 0 ] . length ; double [ ] [ ] [ ] customers = new double [ 3 ] [ numFacilities ] [ numFacilities ] ; for ( int n = 0 ; n < 3 ; n ++ ) for ( int i = 0 ; i < numFacilities ; i ++ ) { for ( int j = 0 ; j < numFacilities ; j ++ ) { customers [ n ] [ i ] [ j ] = facilityLocation [ n ] [ i ] [ j ] ; } } _matrix = customers ; } @ Override public double [ ] evaluate ( Solution solution , Move move ) throws Exception { try { Integer [ ] assign = ( ( QapSolution ) solution ) . _assign ; int len = assign . length ; if ( move == null ) { double price = 0 ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { double a = _matrix [ 0 ] [ i ] [ j ] ; price += _matrix [ 0 ] [ i ] [ j ] * _matrix [ 1 ] [ assign [ i ] ] [ assign [ j ] ] ; } } double addition = 0 ; for ( int i = 0 ; i < _matrix [ 0 ] [ 0 ] . length ; i ++ ) { addition += _matrix [ 2 ] [ i ] [ assign [ i ] ] ; } return new double [ ] { price + addition } ; } else { QapSwapMove mv = ( QapSwapMove ) move ; int pos1 = - 1 ; int pos2 = - 1 ; for ( int i = 0 ; i < assign . length ; i ++ ) { if ( assign [ i ] == mv . customer ) { pos1 = i ; break ; } } pos2 = pos1 + mv . movement ; double price = solution . getObjectiveValue ( ) [ 0 ] ; double delta = 0 ; delta += _matrix [ 0 ] [ pos1 ] [ pos1 ] * ( _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos2 ] ] - _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos1 ] ] ) ; delta += _matrix [ 0 ] [ pos1 ] [ pos2 ] * ( _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos1 ] ] - _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos2 ] ] ) ; delta += _matrix [ 0 ] [ pos2 ] [ pos1 ] * ( _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos2 ] ] - _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos1 ] ] ) ; delta += _matrix [ 0 ] [ pos2 ] [ pos2 ] * ( _matrix [ 1 ] [ assign [ pos1 ] ] [ assign [ pos1 ] ] - _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ pos2 ] ] ) ; double temp = 0 ; for ( int i = 0 ; i < _matrix [ 0 ] [ 0 ] . length ; i ++ ) { if ( i == pos1 || i == pos2 ) continue ; temp += _matrix [ 0 ] [ i ] [ pos1 ] * ( _matrix [ 1 ] [ assign [ i ] ] [ assign [ pos2 ] ] - _matrix [ 1 ] [ assign [ i ] ] [ assign [ pos1 ] ] ) ; temp += _matrix [ 0 ] [ i ] [ pos2 ] * ( _matrix [ 1 ] [ assign [ i ] ] [ assign [ pos1 ] ] - _matrix [ 1 ] [ assign [ i ] ] [ assign [ pos2 ] ] ) ; temp += _matrix [ 0 ] [ pos1 ] [ i ] * ( _matrix [ 1 ] [ assign [ pos2 ] ] [ assign [ i ] ] - _matrix [ 1 ] [ assign [ pos1 ] ]", "gt": "[ assign [ i ] ] ) ;", "prediction": "[ assign [ pos2 ] ] ) ;\n", "label": 1}
{"id": 9792, "input": "<s> package org . meqantt . netty ; import java . io . ByteArrayInputStream ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . handler . codec . frame . FrameDecoder ; import org . meqantt . message . Message ; import org . meqantt . message . MessageInputStream ; public class MqttMessageDecoder extends FrameDecoder { @ Override protected Object decode ( ChannelHandlerContext ctx , Channel channel , ChannelBuffer buf ) throws Exception { if ( buf . readableBytes ( ) < 2 ) { return null ; } buf . markReaderIndex ( ) ; buf . readByte ( ) ; int msgLength = 0 ; int multiplier = 1 ; int digit ; int lengthSize = 0 ; do { lengthSize ++ ; digit = buf . readByte ( ) ; msgLength += ( digit & 0x7f ) * multiplier ; multiplier *= 128 ; if ( ( digit & 0x80 ) > 0 && ! buf . readable ( ) ) { buf . resetReaderIndex ( ) ; return null ; } } while ( ( digit & 0x80 ) > 0 ) ; if ( buf . readableBytes ( ) < msgLength ) { buf . resetReaderIndex ( ) ; return null ; } byte [ ] data = new byte [ 1 + lengthSize + msgLength ] ; buf . resetReaderIndex ( ) ; buf . readBytes ( data ) ; MessageInputStream mis = new MessageInputStream (", "gt": "new ByteArrayInputStream ( data ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 14328, "input": "<s> package com . emf4sw . owl . jena . utils ; import com . hp . hpl . jena . ontology . AllDifferent ; import com . hp . hpl . jena . ontology . AllValuesFromRestriction ; import com . hp . hpl . jena . ontology . AnnotationProperty ; import com . hp . hpl . jena . ontology . CardinalityQRestriction ; import com . hp . hpl . jena . ontology . CardinalityRestriction ; import com . hp . hpl . jena . ontology . ComplementClass ; import com . hp . hpl . jena . ontology . DataRange ; import com . hp . hpl . jena . ontology . DatatypeProperty ; import com . hp . hpl . jena . ontology . EnumeratedClass ; import com . hp . hpl . jena . ontology . HasValueRestriction ; import com . hp . hpl . jena . ontology . Individual ; import com . hp . hpl . jena . ontology . IntersectionClass ; import com . hp . hpl . jena . ontology . MaxCardinalityQRestriction ; import com . hp . hpl . jena . ontology . MaxCardinalityRestriction ; import com . hp . hpl . jena . ontology . MinCardinalityQRestriction ; import com . hp . hpl . jena . ontology . MinCardinalityRestriction ; import com . hp . hpl . jena . ontology . ObjectProperty ; import com . hp . hpl . jena . ontology . OntClass ; import com . hp . hpl . jena . ontology . OntResource ; import com . hp . hpl . jena . ontology . Ontology ; import com . hp . hpl . jena . ontology . Restriction ; import com . hp . hpl . jena . ontology . SomeValuesFromRestriction ; import com . hp . hpl . jena . ontology . UnionClass ; import com . hp . hpl . jena . rdf . model . RDFNode ; import com . hp . hpl . jena . rdf . model . Resource ; public class OntModelSwitch < T > { public OntModelSwitch ( ) { } public T caseOntology ( Ontology object ) { return null ; } public T caseOntClass ( OntClass object ) { return null ; } public T caseUnionClass ( UnionClass object ) { return null ; } public T caseIntersectionClass ( IntersectionClass object ) { return null ; } public T caseComplementClass ( ComplementClass object ) { return null ; } public T caseEnumeratedClass ( EnumeratedClass object ) { return null ; } public T caseObjectProperty ( ObjectProperty object ) { return null ; } public T caseDatatypeProperty ( DatatypeProperty object ) { return null ; } public T caseIndividual ( Individual object ) { return null ; } public T caseAllValuesFromRestriction ( AllValuesFromRestriction object ) { return null ; } public T caseSomeValuesFromRestriction ( SomeValuesFromRestriction object ) { return null ; } public T caseHasValueRestriction ( HasValueRestriction object ) { return null ; } public T caseMaxCardinalityRestriction ( MaxCardinalityRestriction object ) { return null ; } public T caseCardinalityRestriction ( CardinalityRestriction object ) { return null ; } public T caseCardinalityQRestriction ( CardinalityQRestriction object ) { return null ; } public T caseMaxCardinalityQRestriction ( MaxCardinalityQRestriction object ) { return null ; } public T caseMinCardinalityRestriction ( MinCardinalityRestriction object ) { return null ; } public T caseMinCardinalityQRestriction ( MinCardinalityQRestriction object ) { return null ; } public T caseAllDifferent ( AllDifferent asAllDifferent ) { return null ; } public T caseAnnotationProperty ( AnnotationProperty asAnnotationProperty ) { return null ; } public T caseDatatype ( DataRange dataRange ) { return null ; } public T doSwitch ( Resource res ) { T result = null ; if ( res . canAs ( OntResource . class ) ) { OntResource ontRes = res . as ( OntResource . class ) ; if ( ontRes . isProperty ( ) ) { if ( ontRes . isObjectProperty ( ) ) { result = caseObjectProperty ( ontRes . asObjectProperty ( ) ) ; } else if ( ontRes . isDatatypeProperty ( ) ) { result = caseDatatypeProperty ( ontRes . asDatatypeProperty ( ) ) ; } else if ( ontRes . isAnnotationProperty ( ) ) { result = caseAnnotationProperty ( ontRes . asAnnotationProperty ( ) ) ; } } else if ( ontRes . isClass ( ) ) { OntClass ontClass = res . as ( OntClass . class ) ; if ( ontClass . isAllDifferent ( ) ) { result = caseAllDifferent ( ontClass . asAllDifferent ( ) ) ; } else if ( ontClass . isComplementClass ( ) ) { result = caseComplementClass ( ontClass . asComplementClass ( ) ) ; } else if ( ontClass . isUnionClass ( ) ) { result = caseUnionClass ( ontClass . asUnionClass ( ) ) ; } else if ( ontClass . isIntersectionClass ( ) ) { result = caseIntersectionClass ( ontClass . asIntersectionClass ( ) ) ; } else if ( ontClass . isRestriction ( ) ) { Restriction restriction = ontClass . asRestriction ( ) ; if ( restriction . isAllValuesFromRestriction ( ) ) { result = caseAllValuesFromRestriction ( restriction . asAllValuesFromRestriction ( ) ) ; } else if ( restriction . isSomeValuesFromRestriction ( ) ) { result = caseSomeValuesFromRestriction ( restriction . asSomeValuesFromRestriction ( ) ) ; } else if ( restriction . isHasValueRestriction ( ) ) { result = caseHasValueRestriction ( restriction . asHasValueRestriction ( ) ) ; } } else { result = caseOntClass ( ontClass ) ; } } else if ( ontRes . isOntology ( ) ) { result = caseOntology ( res . as ( Ontology . class ) ) ; } else if ( ontRes . isIndividual ( ) ) { result = caseIndividual ( res . as ( Individual . class ) ) ; } else if ( ontRes . isDataRange ( ) ) { DataRange dataRange = res . as ( DataRange . class ) ; if ( dataRange . isURIResource ( ) ) { result =", "gt": "caseDatatype ( dataRange ) ;", "prediction": "caseURIResource ( dataRange . asURIResource ( ) ) ;\n", "label": 1}
{"id": 3486, "input": "<s> package api . soup ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . UnsupportedEncodingException ; import java . util . ArrayList ; import java . util . List ; import org . apache . http . HttpEntity ; import org . apache . http . HttpResponse ; import org . apache . http . NameValuePair ; import org . apache . http . client . CookieStore ; import org . apache . http . client . entity . UrlEncodedFormEntity ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . conn . ClientConnectionManager ; import org . apache . http . cookie . Cookie ; import org . apache . http . impl . client . BasicCookieStore ; import org . apache . http . impl . client . DefaultHttpClient ; import org . apache . http . impl . conn . tsccm . ThreadSafeClientConnManager ; import org . apache . http . impl . cookie . BasicClientCookie ; import org . apache . http . message . BasicNameValuePair ; import org . apache . http . params . HttpParams ; import org . apache . http . protocol . HTTP ; import org . apache . http . util . EntityUtils ; import org . jsoup . Jsoup ; import org . jsoup . safety . Whitelist ; import api . forum . forumsections . ForumSections ; import api . index . Index ; import api . util . CouldNotLoadException ; import api . util . Tuple ; public class MySoup { private static DefaultHttpClient httpClient = getHttpClient ( ) ; private static String authey ; private static String passkey ; private static List < Cookie > cookies ; private static HttpParams httpParams = httpClient . getParams ( ) ; private static String username ; private static int userId ; private static String SITE ; private static boolean canNotifications = true ; private static ForumSections forumSections ; private static boolean forumSectionsLoaded = false ; private static Index index ; private static HttpGet httpGet ; private static HttpResponse response ; private static HttpEntity entity ; private static HttpPost httpPost ; private static boolean isSSLEnabled = true ; private static String headerName = \"name\" ; private static String headerValue = \"value\" ; public static void setSite ( String url ) { if ( ! url . endsWith ( \"/\" ) ) { url = url + \"/\" ; } if ( isSSLEnabled ) { if ( ! url . startsWith ( \"https://\" ) ) { url = \"https://\" + url ; } } else { if ( ! url . startsWith ( \"http://\" ) ) { url = \"http://\" + url ; } } SITE = url ; } public static void setSite ( String url , boolean ssl ) { isSSLEnabled = ssl ; setSite ( url ) ; } public static String getSite ( ) { return SITE ; } private static DefaultHttpClient getHttpClient ( ) { DefaultHttpClient client = new DefaultHttpClient ( ) ; ClientConnectionManager mgr = client . getConnectionManager ( ) ; HttpParams params = client . getParams ( ) ; client = new DefaultHttpClient ( new ThreadSafeClientConnManager ( params , mgr . getSchemeRegistry ( ) ) , params ) ; return client ; } private static HttpGet getHttpGet ( String url ) { HttpGet hg = new HttpGet ( url ) ; return hg ; } private static void setHeader ( String name , String value ) { headerName = name ; headerValue = value ; } public static ForumSections loadForumSections ( ) { if ( forumSectionsLoaded == false ) { forumSections = ForumSections . init ( ) ; forumSectionsLoaded = true ; } return forumSections ; } public static ForumSections getForumSections ( ) { return forumSections ; } public static void setSSL ( boolean b ) { isSSLEnabled = b ; } public static boolean isSSLEnabled ( ) { return isSSLEnabled ; } public static String getAuthKey ( ) { return authey ; } public static String getPassKey ( ) { return passkey ; } public static String getSessionId ( ) { return cookies . get ( 0 ) . getValue ( ) ; } public static List < Cookie > getCookies ( ) { return cookies ; } public static boolean isLoggedIn ( ) { if ( ( cookies != null ) && ! cookies . isEmpty ( ) ) return true ; else return false ; } public static String toQuotableString ( String html ) { return Jsoup . parse ( html ) . text ( ) ; } public static void login ( String url , String username , String password ) throws CouldNotLoadException { url = SITE + url ; try { httpGet = getHttpGet ( url ) ; response = httpClient . execute ( httpGet ) ; entity = response . getEntity ( ) ; httpPost = new HttpPost ( url ) ; List < NameValuePair", "gt": "> nvps = new ArrayList < NameValuePair > ( ) ;", "prediction": "> names = new ArrayList < NameValuePair > ( ) ;\n", "label": 0}
{"id": 14329, "input": "<s> package org . fuzzydb . util ; import org . fuzzydb . util . CsvTokeniser ; import junit . framework . Assert ; import junit . framework . TestCase ; public class TestCsvTokeniser extends TestCase { public void testOneString ( ) { String test = \"Some String\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"Some String\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testTwoStrings ( ) { String test = \"Some String,Some Other String\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"Some String\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"Some Other String\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testThreeStrings ( ) { String test = \"Some String,Some Other String,A Really Long String At The End\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"Some String\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"Some Other String\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"A Really Long String At The End\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testEmptyString ( ) { String test = \"\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testTwoEmptyFields ( ) { String test = \",\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testStringAndTwoEmptyFields ( ) { String test = \"Hello,,,World\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"Hello\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"World\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testTwoEmptyFieldsAndAString ( ) { String test = \",,Hello\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"\" , rval ) ; rval = ct . next ( ) ; Assert . assertEquals ( \"Hello\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testOneQuotedStringStrippingQuotes ( ) { String test = \"\\\"Some String\\\"\" ; CsvTokeniser ct = new CsvTokeniser ( test ) ; String rval = ct . next ( ) ; Assert . assertEquals ( \"Some String\" , rval ) ; rval = ct . next ( ) ; Assert . assertNull ( rval ) ; } public void testOneQuotedDifficultStringStrippingQuotes ( ) { String test = \"\\\"Some String \\\"\\\"containing\\\"\\\" quotes, and \\\"\\\"commas,\\\"\\\" which is hard\\\",Followed by a regular string\" ; CsvTokeniser ct =", "gt": "new CsvTokeniser ( test ) ;", "prediction": "new CsvTokeniser ( test ) ;\n", "label": 1}
{"id": 1521, "input": "<s> package com . twofortyfouram . locale ; import android . os . Parcelable ; public final class Intent { private Intent ( ) { throw new UnsupportedOperationException ( \"This class is non-instantiable\" ) ; } public static final int RESULT_CONDITION_SATISFIED = 16 ; public static final int RESULT_CONDITION_UNSATISFIED = 17 ; public static final int RESULT_CONDITION_UNKNOWN = 18 ; public static final String ACTION_EDIT_SETTING = \"com.twofortyfouram.locale.intent.action.EDIT_SETTING\" ; public static final String ACTION_FIRE_SETTING = \"com.twofortyfouram.locale.intent.action.FIRE_SETTING\" ; public static final String ACTION_EDIT_CONDITION = \"com.twofortyfouram.locale.intent.action.EDIT_CONDITION\" ; public static final String ACTION_QUERY_CONDITION = \"com.twofortyfouram.locale.intent.action.QUERY_CONDITION\" ; public static", "gt": "final String ACTION_REQUEST_QUERY = \"com.twofortyfouram.locale.intent.action.REQUEST_QUERY\" ;", "prediction": "final String ACTION_REQUEST_CONDITION = \"com.twofortyfouram.locale.intent.action.REQUEST_CONDITION\" ;\n", "label": 0}
{"id": 14343, "input": "<s> package org . tinyradius . dictionary ; import java . io . IOException ; import java . io . InputStream ; public class DefaultDictionary extends MemoryDictionary { public static Dictionary getDefaultDictionary ( ) { return instance ; } private DefaultDictionary ( ) { } private static final String DICTIONARY_RESOURCE = \"org/tinyradius/dictionary/default_dictionary\" ; private static DefaultDictionary instance = null ; static { try { instance = new DefaultDictionary ( ) ; InputStream source = DefaultDictionary . class . getClassLoader ( ) . getResourceAsStream ( DICTIONARY_RESOURCE ) ; DictionaryParser . parseDictionary ( source , instance ) ; } catch ( IOException e ) { throw new RuntimeException ( \"default", "gt": "dictionary unavailable\" , e ) ;", "prediction": "dictionary not found\" ) ;\n", "label": 1}
{"id": 42, "input": "<s> package org . msl . simple . gmfmap . model . edit . properties ; import org . eclipse . emf . common . notify . Adapter ; import org . msl . simple . gmfmap . model . edit . IItemPropertyDescriptorProvider ; import org . msl . simple . gmfmap . simplemappings . util . SimplemappingsAdapterFactory ; public class SimpleMappingPropertiesAdapterFactory extends SimplemappingsAdapterFactory { private static Adapter simpleNodeProvider = new SimpleNodeItemPropertyDescriptorProvider ( ) ; @ Override public Adapter createSimpleTopNodeAdapter ( ) { return simpleNodeProvider ; } @", "gt": "Override public Adapter createSimpleNodeAdapter ( )", "prediction": "Override public Adapter createSimpleBottomNodeAdapter ( )\n", "label": 0}
{"id": 14365, "input": "<s> package org . eclipse . swt . internal . widgets . combokit ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . controlkit . ControlThemeAdapter ; import org . eclipse . swt . widgets . Control ; public", "gt": "final class ComboThemeAdapter extends ControlThemeAdapter", "prediction": "class ControlThemeAdapter extends ControlThemeAdapter\n", "label": 1}
{"id": 7418, "input": "<s> package org . dawb . workbench . ui . editors . test ; import java . io . File ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . dawb . common . ui . plot . AbstractPlottingSystem ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . trace . IImageTrace ; import org . dawb . common . ui . plot . trace . ILineTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . workbench . plotting . system . LightWeightPlottingSystem ; import org . dawb . workbench . ui . editors . AsciiEditor ; import org . dawb . workbench . ui . editors . ImageEditor ; import org . dawb . workbench . ui . editors . PlotDataEditor ; import org . eclipse . core . filesystem . EFS ; import org . eclipse . core . filesystem . IFileStore ; import org . eclipse . core . runtime . Platform ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . ide . FileStoreEditorInput ; import org . junit . Test ; import org . osgi . framework . Bundle ; import uk . ac . diamond . scisoft . analysis . dataset . AbstractDataset ; import uk . ac . diamond . scisoft . analysis . dataset . DoubleDataset ; import uk . ac . diamond . scisoft . analysis . dataset . IntegerDataset ; import uk . ac . diamond . scisoft . analysis . dataset . LongDataset ; import uk . ac . diamond . scisoft . analysis . dataset . Random ; import uk . ac . diamond . scisoft . analysis . roi . ROIBase ; import fable . framework . toolbox . EclipseUtils ; public class SWTXYStressTest { @ Test public void testIfMemoryLeak1D ( ) throws Throwable { final Bundle bun = Platform . getBundle ( \"org.dawb.workbench.ui.test\" ) ; String path = ( bun . getLocation ( ) + \"src/org/dawb/workbench/ui/editors/test/ascii.dat\" ) ; path = path . substring ( \"reference:file:\" . length ( ) ) ; if ( path . startsWith ( \"/C:\" ) ) path = path . substring ( 1 ) ; final IWorkbenchPage page = EclipseUtils . getPage ( ) ; final IFileStore externalFile = EFS . getLocalFileSystem ( ) . fromLocalFile ( new File ( path ) ) ; final IEditorPart part = page . openEditor ( new FileStoreEditorInput ( externalFile ) , AsciiEditor . ID ) ; final AsciiEditor editor = ( AsciiEditor ) part ; final PlotDataEditor plotter = ( PlotDataEditor ) editor . getActiveEditor ( ) ; final AbstractPlottingSystem sys = plotter . getPlottingSystem ( ) ; AbstractDataset data = Random . rand ( new int [ ] { 2048 } ) ; final IRegion region = sys . createRegion ( RegionUtils . getUniqueName ( \"Y Profile\" , sys ) , IRegion . RegionType . XAXIS_LINE ) ; region . setTrackMouse ( true ) ; region . setRegionColor ( ColorConstants . red ) ; region . setUserRegion ( false ) ; sys . addRegion ( region ) ; final ILineTrace trace = sys . createLineTrace ( \"Test line plot\" ) ; trace . setData ( IntegerDataset . arange ( 2048 , AbstractDataset . INT32 ) , data ) ; sys . addTrace ( trace ) ; for ( int i = 0 ; i < 1000000 ; i ++ ) { data = Random . rand ( new int [ ] { 2048 } ) ; Display . getDefault ( ) . syncExec ( new Runnable ( ) { public void run ( ) { AbstractDataset data = Random . rand ( new int [ ] { 2048 } ) ; trace . setData ( IntegerDataset . arange ( 2048 , AbstractDataset . INT32 ) , data ) ; sys . repaint ( ) ; EclipseUtils . delay ( 200 ) ; } } ) ; EclipseUtils . delay ( 20 ) ; } EclipseUtils . delay ( 1000 ) ; } @ Test public void testIfMemoryLeak2D ( ) throws Throwable { final Bundle bun = Platform . getBundle ( \"org.dawb.workbench.ui.test\" ) ; String path = ( bun . getLocation ( ) + \"src/org/dawb/workbench/ui/editors/test/billeA.edf\" ) ; path = path . substring ( \"reference:file:\" . length ( ) ) ; if ( path . startsWith ( \"/C:\" ) ) path = path . substring ( 1 ) ; final IWorkbenchPage page = EclipseUtils . getPage ( ) ; final IFileStore externalFile = EFS . getLocalFileSystem ( ) . fromLocalFile ( new File ( path ) ) ; final IEditorPart part = page . openEditor ( new FileStoreEditorInput ( externalFile ) , ImageEditor . ID ) ; page . setPartState ( EclipseUtils . getPage ( ) . getActivePartReference ( ) , IWorkbenchPage . STATE_MAXIMIZED ) ; EclipseUtils . delay ( 2000 ) ; final ImageEditor editor = ( ImageEditor ) part ; final AbstractPlottingSystem sys = editor . getPlotImageEditor", "gt": "( ) . getPlottingSystem ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 14410, "input": "<s> package org . apache . lucene . queryParser . standard . config ; import org . apache . lucene . document . DateTools ; import org . apache . lucene . document . DateTools . Resolution ; import org . apache . lucene . queryParser . core . config . QueryConfigHandler ; import org . apache . lucene . queryParser . standard . processors . ParametricRangeQueryNodeProcessor ; import org . apache . lucene . util . AttributeImpl ; public class DateResolutionAttributeImpl extends AttributeImpl implements DateResolutionAttribute { private static final long serialVersionUID = - 6804360312723049526L ; private DateTools . Resolution dateResolution = null ; public DateResolutionAttributeImpl ( ) { dateResolution = null ; } public void setDateResolution ( DateTools . Resolution dateResolution ) { this . dateResolution = dateResolution ; } public DateTools . Resolution getDateResolution ( ) { return this . dateResolution ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public void copyTo ( AttributeImpl target ) { throw new UnsupportedOperationException ( ) ; } public boolean equals ( Object other ) { if ( other instanceof DateResolutionAttributeImpl ) { DateResolutionAttributeImpl dateResAttr = ( DateResolutionAttributeImpl ) other ; if ( dateResAttr . getDateResolution ( ) == getDateResolution ( ) || dateResAttr . getDateResolution ( ) . equals ( getDateResolution ( ) ) ) { return true ; } } return false ; } public int hashCode ( ) { return ( this . dateResolution == null ) ? 0 : this .", "gt": "dateResolution . hashCode ( ) ;", "prediction": "dateResolution . hashCode ( ) ;\n", "label": 1}
{"id": 9819, "input": "<s> interface I < T > { public int m ( T t ) ; } interface J < T > { public int m ( T t ) ; } class A implements J <", "gt": "String > , I < String >", "prediction": "T >\n", "label": 0}
{"id": 14417, "input": "<s> package org . eclipse . ui . tests . performance . presentations ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . ToolItem ; import org . eclipse . ui . presentations . AbstractPresentationFactory ; import org . eclipse . ui . tests . performance . BasicPerformanceTest ; import org . eclipse . ui . tests . performance . UIPerformancePlugin ; public class PresentationPerformanceTest extends BasicPerformanceTest { protected Shell theShell ; protected Image img ; protected Image img2 ; protected static final int NAME = 0 ; protected static final int TITLE = 1 ; protected static final int DIRTY = 2 ; protected static final int DESCRIPTION = 3 ; protected static final int TOOLTIP = 4 ; protected static final int IMAGE = 5 ; protected static final int TOOLBAR = 6 ; public PresentationPerformanceTest ( String testName ) { super ( testName ) ; } protected void doSetUp ( ) throws Exception { super . doSetUp ( ) ; theShell = new Shell ( Display . getCurrent ( ) , SWT . NONE ) ; theShell . setBounds ( 0 , 0 , 1024 , 768 ) ; theShell . setVisible ( true ) ; img = UIPerformancePlugin . getImageDescriptor ( \"icons/anything.gif\" ) . createImage ( ) ; img2 = UIPerformancePlugin . getImageDescriptor ( \"icons/view.gif\" ) . createImage ( ) ; } protected void doTearDown ( ) throws Exception { theShell . dispose ( ) ; theShell = null ; super . doTearDown ( ) ; } protected PresentationTestbed createPresentation ( AbstractPresentationFactory factory , int type , int numParts ) { TestPresentablePart selection = null ; PresentationTestbed testBed = new PresentationTestbed ( theShell , factory , type ) ; for ( int partCount = 0 ; partCount < numParts ; partCount ++ ) { TestPresentablePart part = new TestPresentablePart ( theShell , img ) ; part . setName ( \"Some part\" ) ; part . setContentDescription ( \"Description\" ) ; part . setTitle ( \"Some title\" ) ; part . setDirty ( partCount % 2 == 0 ) ; part . setTooltip ( \"This is a tooltip\" ) ; testBed . add ( part ) ; selection = part ; } testBed . setSelection ( selection ) ; Control ctrl = testBed . getControl ( ) ; ctrl . setBounds ( theShell . getClientArea ( ) ) ; return testBed ; } protected void twiddleProperty ( int property , TestPresentablePart part ) { switch ( property ) { case NAME : { String originalName = part . getName ( ) ; part . setName ( \"Some new name\" ) ; processEvents ( ) ; part . setName ( originalName ) ; processEvents ( ) ; break ; } case TITLE : { String originalTitle = part . getTitle ( ) ; part . setTitle ( \"Some new title\" ) ; processEvents ( ) ; part . setTitle ( originalTitle ) ; processEvents ( ) ; break ; } case DIRTY : { boolean originalDirty = part . isDirty ( ) ; part . setDirty ( ! originalDirty ) ; processEvents ( ) ; part . setDirty ( originalDirty ) ; processEvents ( ) ; break ; } case DESCRIPTION : { String originalDescription = part . getTitleStatus ( ) ; part . setContentDescription ( \"Some new description\" ) ; processEvents ( ) ; part . setContentDescription ( originalDescription ) ; processEvents ( ) ; break ; } case TOOLTIP : { String originalTooltip = part . getTitleToolTip ( ) ; part . setTooltip ( \"Some new tooltip\" ) ; processEvents ( ) ; part . setTooltip ( originalTooltip ) ; processEvents ( ) ; break ; } case IMAGE : {", "gt": "Image originalImage = part . getTitleImage ( ) ;", "prediction": "String originalImage = part . getTitleImage ( ) ;\n", "label": 1}
{"id": 3672, "input": "<s> class FallThrough { int m1 ( int i ) { switch ( i ) { case 1 : i ++ ; case 2 : i ++ ; } return i ; } } @ SuppressWarnings ( \"fallthrough\" ) class FallThrough1 { int m1 ( int i ) { switch ( i ) { case 1 : i ++ ; case 2 : i ++ ; } return i ; } } class FallThrough2 { @ SuppressWarnings ( \"fallthrough\" ) class Bar { int m1 ( int i ) { switch ( i ) { case 1 : i ++ ; case 2 : i ++ ; } return i ; } } @ SuppressWarnings ( \"fallthrough\" ) void m2 ( int i ) { switch ( i ) { case 1 : i ++ ; case 2 : i ++ ; } } @ SuppressWarnings ( \"fallthrough\" ) static int x = new FallThrough2 ( ) {", "gt": "int m1 ( int i )", "prediction": "1 , 2 , 3 , 4 }\n", "label": 0}
{"id": 14419, "input": "<s> package org . restlet . example . book . restlet . ch09 . common ; import org . restlet . resource . Get ; import org . restlet . resource . Post ; public interface MailsResource { @ Get public", "gt": "MailsRepresentation retrieve ( ) ;", "prediction": "void setUp ( ) ;\n", "label": 1}
{"id": 2663, "input": "<s> package com . vexsoftware . votifier . crypto ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . spec . RSAKeyGenParameterSpec ; import java . util . logging . Logger ; public class RSAKeygen { private static final Logger LOG = Logger . getLogger ( \"Votifier\" ) ; public static KeyPair generate ( int bits ) throws Exception { LOG . info (", "gt": "\"Votifier is generating an RSA key pair...\" ) ;", "prediction": "bits ) ;\n", "label": 0}
{"id": 14428, "input": "<s> package org . restlet . example . ext . oauth . experimental ; import java . util . ArrayList ; import java . util . List ; import org . json . JSONArray ; import org . json . JSONException ; import org . json . JSONObject ; public class DiscoverableAuthServerInfo { public enum GrantType { authorization_code , password , assertion , refresh_token , none } public enum AuthParam { header , query , form , basic } public enum IdTech { openid , digest , form , basic , saml } private static final String VERSION = \"2.0\" ; private String authorizationUrl ; private String accessTokenUrl ; private List < String > flows ; private List < String > authParams ; private String validationUrl ; private String revocationUrl ; private String clientSignupUrl ; private String userSignupUrl ; private List < String > idTechnologies ; public DiscoverableAuthServerInfo ( String authorizationUrl , String accessTokenUrl , String validationUrl ) { this . authorizationUrl = authorizationUrl ; this . accessTokenUrl = accessTokenUrl ; this . validationUrl = validationUrl ; flows = new ArrayList < String > ( ) ; flows . add ( GrantType . authorization_code . name ( ) ) ; flows . add ( GrantType . refresh_token . name ( ) ) ; flows . add ( GrantType . none . name ( ) ) ; authParams = new ArrayList < String > ( ) ; authParams . add ( AuthParam . header . name ( ) ) ; authParams . add ( AuthParam . query . name ( ) ) ; authParams . add ( AuthParam . form . name ( ) ) ; idTechnologies = new ArrayList < String > ( ) ; idTechnologies . add ( IdTech . openid . name ( ) ) ; } public void setRevocationUrl ( String url ) { revocationUrl = url ; } public void setClientSignupUrl ( String url ) { clientSignupUrl = url ; } public void setUserSignupUrl ( String url ) { userSignupUrl = url ; } public JSONObject toJson ( ) throws JSONException { JSONObject json = new JSONObject ( ) ; json . put ( \"version\" , VERSION ) ; json . put ( \"authorization_url\" , authorizationUrl ) ; json . put ( \"access_token_url\" , accessTokenUrl ) ; JSONArray a = new JSONArray ( ) ; for ( String flow : flows ) { a . put ( flow ) ; } json . put ( \"flows\" , a ) ; a = new JSONArray ( ) ; for ( String param : authParams ) { a . put ( param ) ; } json . put ( \"auth_parameters\" , a ) ; json . put ( \"x_validation_url\" , validationUrl ) ; if ( revocationUrl != null && revocationUrl . length ( ) > 0 ) { json . put ( \"x_revocation_url\" , revocationUrl ) ; } if ( clientSignupUrl", "gt": "!= null && clientSignupUrl . length ( ) > 0 )", "prediction": "!= null && clientSignupUrl . length ( ) > 0 )\n", "label": 1}
{"id": 6383, "input": "<s> package ar . com . fdvs . dj . test . subreport ; import java . util . Collection ; import java . util . Date ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class SubReportRecursiveTest extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addGroups ( 2 ) . setMargins ( 5 , 5 , 20 , 20 ) . addField ( \"statistics\" , Collection . class . getName ( ) ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setUseFullPageWidth ( true ) ; DynamicReport drLevel2 = createLevel2Subreport ( ) ; drb . addSubreportInGroupFooter ( 2 , drLevel2 , new ClassicLayoutManager ( ) , \"statistics\" , DJConstants . DATA_SOURCE_ORIGIN_FIELD , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) ; DynamicReport mainReport = drb . build ( ) ; return mainReport ; } private DynamicReport createLevel2Subreport ( ) throws Exception { FastReportBuilder rb = new FastReportBuilder ( ) ; DynamicReport dr = rb . addColumn ( \"Date\" , \"date\" , Date . class . getName ( ) , 100 ) . addColumn ( \"Average\" , \"average\" , Float . class . getName ( ) , 50 ) . addColumn ( \"%\" , \"percentage\" , Float . class . getName ( ) , 50 ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 50 ) . addGroups ( 1 ) . addField ( \"dummy3\" , Collection . class . getName ( ) ) . setMargins ( 5 , 5 , 20 , 20 ) . setUseFullPageWidth ( true ) . setTitle ( \"Level 2 Subreport\" ) . addSubreportInGroupFooter ( 1 , createLevel3Subreport ( ) , new ClassicLayoutManager ( ) , \"dummy3\" , DJConstants . DATA_SOURCE_ORIGIN_FIELD , DJConstants . DATA_SOURCE_TYPE_COLLECTION ) . build ( ) ; return dr ; } private DynamicReport createLevel3Subreport ( ) throws Exception { FastReportBuilder rb = new FastReportBuilder ( ) ; DynamicReport dr = rb . addColumn ( \"Name\" , \"name\" , String . class . getName ( ) , 100 ) . addColumn ( \"Number\" , \"number\" , Long . class . getName ( ) , 50 ) . setMargins ( 5 , 5 , 20 , 20 ) . setUseFullPageWidth ( false ) . setTitle ( \"Level 3 Subreport\" ) . build ( ) ; return dr ; } public static void main ( String [ ] args ) throws Exception { SubReportRecursiveTest test = new SubReportRecursiveTest ( ) ; test . testReport ( ) ; JasperViewer .", "gt": "viewReport ( test . jp ) ;", "prediction": "start ( ) ;\n", "label": 0}
{"id": 14489, "input": "<s> package de . uos . igf . db3d . dbms . model3d ; public interface Solid3D extends Volume3D { public", "gt": "int countTetras ( ) ;", "prediction": "void setUp ( ) ;\n", "label": 1}
{"id": 1392, "input": "<s> package com . sun . tools . apt . mirror . declaration ; import java . lang . annotation . Annotation ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . Collection ; import java . util . EnumSet ; import javax . tools . JavaFileObject ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . * ; import com . sun . tools . apt . mirror . AptEnv ; import com . sun . tools . apt . mirror . util . SourcePositionImpl ; import com . sun . tools . javac . code . * ; import com . sun . tools . javac . code . Symbol . * ; import com . sun . tools . javac . comp . AttrContext ; import com . sun . tools . javac . comp . Env ; import com . sun . tools . javac . tree . * ; import com . sun . tools . javac . util . Name ; import com . sun . tools . javac . util . Position ; import static com . sun . mirror . declaration . Modifier . * ; import static com . sun . tools . javac . code . Kinds . * ; @ SuppressWarnings ( \"deprecation\" ) public abstract class DeclarationImpl implements Declaration { protected final AptEnv env ; public final Symbol sym ; protected static final DeclarationFilter identityFilter = new DeclarationFilter ( ) ; protected DeclarationImpl ( AptEnv env , Symbol sym ) { this . env = env ; this . sym = sym ; } public boolean equals ( Object obj ) { if ( obj instanceof DeclarationImpl ) { DeclarationImpl that = ( DeclarationImpl ) obj ; return sym == that . sym && env == that . env ; } else { return false ; } } public int hashCode ( ) { return sym . hashCode ( ) + env . hashCode ( ) ; } public String getDocComment ( ) { Env < AttrContext > enterEnv = getEnterEnv ( ) ; if ( enterEnv == null ) return null ; JCTree tree = TreeInfo . declarationFor ( sym , enterEnv . tree ) ; return enterEnv . toplevel . docComments . get ( tree ) ; } public Collection < AnnotationMirror > getAnnotationMirrors ( ) { Collection < AnnotationMirror > res = new ArrayList < AnnotationMirror > ( ) ; for ( Attribute . Compound a : sym . getAnnotationMirrors ( ) ) { res . add ( env . declMaker . getAnnotationMirror ( a , this ) ) ; } return res ; } public < A extends Annotation > A getAnnotation ( Class < A > annoType ) { return getAnnotation ( annoType , sym ) ; } protected < A extends Annotation > A getAnnotation ( Class < A > annoType , Symbol annotated ) { if ( ! annoType . isAnnotation ( ) ) { throw new IllegalArgumentException ( \"Not an annotation type: \" + annoType ) ; } String name = annoType . getName ( ) ; for ( Attribute . Compound attr : annotated . getAnnotationMirrors ( ) ) { if ( name . equals ( attr . type . tsym . flatName ( ) . toString ( ) ) ) { return AnnotationProxyMaker . generateAnnotation ( env , attr , annoType ) ; } } return null ; } private EnumSet < Modifier > modifiers = null ; public Collection < Modifier > getModifiers ( ) { if ( modifiers == null ) { modifiers = EnumSet . noneOf ( Modifier . class ) ; long flags = AptEnv . getFlags ( sym ) ; if ( 0 != ( flags & Flags . PUBLIC ) ) modifiers . add ( PUBLIC ) ; if ( 0 != ( flags & Flags . PROTECTED ) ) modifiers . add ( PROTECTED ) ; if ( 0 != ( flags & Flags . PRIVATE ) ) modifiers . add ( PRIVATE ) ; if ( 0 != ( flags & Flags . ABSTRACT ) ) modifiers . add ( ABSTRACT ) ; if ( 0 != ( flags & Flags . STATIC ) ) modifiers . add ( STATIC ) ; if ( 0 != ( flags & Flags . FINAL ) ) modifiers . add ( FINAL ) ; if ( 0 != ( flags & Flags . TRANSIENT ) ) modifiers . add ( TRANSIENT ) ; if ( 0 != ( flags & Flags . VOLATILE ) ) modifiers . add ( VOLATILE ) ; if ( 0 != ( flags & Flags . SYNCHRONIZED ) ) modifiers . add ( SYNCHRONIZED ) ; if ( 0 != ( flags & Flags . NATIVE ) ) modifiers . add ( NATIVE ) ; if ( 0 != ( flags & Flags . STRICTFP ) ) modifiers . add ( STRICTFP ) ; } return modifiers ; } public String getSimpleName ( ) { return sym . name . toString ( ) ; } public SourcePosition getPosition ( ) { Env < AttrContext > enterEnv = getEnterEnv ( ) ; if ( enterEnv == null ) return null ; JCTree . JCCompilationUnit toplevel = enterEnv . toplevel ; JavaFileObject sourcefile = toplevel . sourcefile ; if ( sourcefile == null ) return null ; int pos = TreeInfo . positionFor ( sym , toplevel ) ; return new SourcePositionImpl ( sourcefile , pos , toplevel . lineMap ) ; } public void accept ( DeclarationVisitor v ) { v . visitDeclaration ( this ) ; } private Collection < Symbol > members = null ; protected Collection < Symbol > getMembers ( boolean cache ) { if ( members != null ) { return members ; } LinkedList < Symbol > res = new LinkedList < Symbol > ( ) ; for ( Scope . Entry e = sym . members ( ) . elems ; e != null ; e = e . sibling ) { if ( e . sym != null && ! unwanted ( e . sym ) ) { res . addFirst ( e . sym ) ; } } return cache ? ( members = res ) : res ; } private static boolean unwanted ( Symbol s ) { return AptEnv . hasFlag ( s , Flags . SYNTHETIC ) || ( s . kind == TYP && ! DeclarationMaker . isJavaIdentifier ( s . name . toString ( ) ) ) ; } private Env < AttrContext > getEnterEnv ( ) { TypeSymbol ts = ( sym . kind != PCK ) ? sym . enclClass ( ) : ( PackageSymbol ) sym ; return ( ts != null ) ? env", "gt": ". enter . getEnv ( ts ) : null ;", "prediction": ". getAnnotation ( ) : ts . getAnnotation ( ) ;\n", "label": 0}
{"id": 14503, "input": "<s> package org . eclipse . ui . commands ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . internal . util . Util ; public final class HandlerSubmission implements Comparable { private final String activePartId ; private final Shell activeShell ; private final IWorkbenchPartSite activeWorkbenchPartSite ; private final String commandId ; private final IHandler handler ; private final Priority priority ; private transient String string ; public HandlerSubmission ( String activePartId , Shell activeShell , IWorkbenchPartSite activeWorkbenchPartSite , String commandId , IHandler handler , Priority priority ) { if ( commandId == null || handler == null || priority == null ) { throw new NullPointerException ( ) ; } this . activePartId = activePartId ; this . activeShell = activeShell ; this . activeWorkbenchPartSite = activeWorkbenchPartSite ; this . commandId = commandId ; this . handler = handler ; this . priority = priority ; } public int compareTo ( Object object ) { HandlerSubmission castedObject = ( HandlerSubmission ) object ; int compareTo = Util . compare ( activeWorkbenchPartSite , castedObject . activeWorkbenchPartSite ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( activePartId , castedObject . activePartId ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( activeShell , castedObject . activeShell ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( priority , castedObject . priority ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( commandId , castedObject . commandId ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( handler , castedObject . handler ) ; } } } } } return compareTo ; } public String getActivePartId ( ) { return activePartId ; } public Shell getActiveShell ( ) { return activeShell ; } public IWorkbenchPartSite getActiveWorkbenchPartSite ( ) { return activeWorkbenchPartSite ; } public String getCommandId ( ) { return commandId ; } public IHandler getHandler ( ) { return handler ; } public Priority getPriority ( ) { return priority ; } public String toString ( ) { if ( string == null ) { final StringBuffer stringBuffer = new StringBuffer ( ) ; stringBuffer .", "gt": "append ( \"[activePartId=\" ) ;", "prediction": "append ( \"\" ) ;\n", "label": 1}
{"id": 1054, "input": "<s> package org . ofbiz . base . config ; import java . net . URL ; import java . io . InputStream ; import java . io . Serializable ; @ SuppressWarnings ( \"serial\" ) public class UrlLoader extends ResourceLoader implements Serializable { @ Override public URL getURL ( String location ) throws GenericConfigException { String fullLocation = fullLocation ( location ) ; URL url = null ; try { url = new URL ( fullLocation ) ; } catch ( java . net . MalformedURLException e ) { throw new GenericConfigException ( \"Error with malformed URL while trying to load URL resource at location [\" + fullLocation + \"]\" , e ) ; } if ( url == null ) { throw new GenericConfigException ( \"URL Resource not found: \" + fullLocation ) ; } return url ; } @ Override public InputStream loadResource ( String location ) throws GenericConfigException { URL url = getURL ( location ) ; try { return url . openStream ( ) ; } catch ( java", "gt": ". io . IOException e )", "prediction": ". net . MalformedURLException e )\n", "label": 0}
{"id": 14532, "input": "<s> package org . eclipse . swt . custom ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . theme . IThemeAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . custom . clabelkit . CLabelThemeAdapter ; import org . eclipse . swt . internal . widgets . IWidgetGraphicsAdapter ; import org . eclipse . swt . internal . widgets . MarkupValidator ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; public class CLabel_Test extends TestCase { private Display display ; private Shell shell ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; display = new Display ( ) ; shell = new Shell ( display ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testSetBackgroundColor ( ) { CLabel label = new CLabel ( shell , SWT . RIGHT ) ; Color red = display . getSystemColor ( SWT . COLOR_RED ) ; label . setBackground ( red ) ; assertEquals ( label . getBackground ( ) , red ) ; } public void testSetToolTipText ( ) { CLabel label = new CLabel ( shell , SWT . RIGHT ) ; label . setToolTipText ( \"foo\" ) ; assertEquals ( label . getToolTipText ( ) , \"foo\" ) ; } public void testSetAlignment ( ) { CLabel label = new CLabel ( shell , SWT . LEFT ) ; assertEquals ( label . getAlignment ( ) , SWT . LEFT ) ; label . setAlignment ( SWT . RIGHT ) ; assertEquals ( label . getAlignment ( ) , SWT . RIGHT ) ; } public void testSetImage ( ) { CLabel label = new CLabel ( shell , SWT . RIGHT ) ; assertEquals ( label . getImage ( ) , null ) ; label . setImage ( Graphics . getImage ( Fixture . IMAGE1 , getClass ( ) . getClassLoader ( ) ) ) ; assertEquals ( label . getImage ( ) , Graphics . getImage ( Fixture . IMAGE1 , getClass ( ) . getClassLoader ( ) ) ) ; } public void testSetText ( ) { CLabel label = new CLabel ( shell , SWT . RIGHT ) ; assertEquals ( null , label . getText ( ) ) ; label . setText ( \"bar\" ) ; assertEquals ( label . getText ( ) , \"bar\" ) ; } @ SuppressWarnings ( \"deprecation\" ) public void testComputeSize ( ) { CLabel label = new CLabel ( shell , SWT . RIGHT ) ; Point expected = new Point ( 12 , 26 ) ; assertEquals ( expected , label . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; label . setText ( \"bar\" ) ; expected = new Point ( 32 , 30 ) ; assertEquals ( expected , label . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; label . setImage ( Graphics . getImage ( Fixture . IMAGE_100x50 ) ) ; expected = new Point ( 137 , 62 ) ; assertEquals ( expected , label . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; label . setMargins ( 1 , 2 , 3 , 4 ) ; expected = new Point ( 129 , 56 ) ; assertEquals ( expected , label . computeSize ( SWT .", "gt": "DEFAULT , SWT . DEFAULT ) ) ;", "prediction": "DEFAULT , SWT . DEFAULT ) ) ;\n", "label": 1}
{"id": 469, "input": "<s> package com . mobeelizer . mobile . android ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . Calendar ; import java . util . Date ; import com . mobeelizer . java . api . MobeelizerFile ; public class TestEntity { private String guid ; private String owner ; private String group ; private boolean conflicted ; private boolean deleted ; private boolean modified ; private String string ; private boolean booleanP ; private Boolean booleanO ; private Integer integerO ; private int integerP ; private Short shortO ; private short shortP ; private Long longO ; private long longP ; private Byte byteO ; private byte byteP ; private Double doubleO ; private double doubleP ; private Float floatO ; private float floatP ; private BigInteger bigInteger ; private BigDecimal bigDecimal ; private Date date ; private Calendar calendar ; private MobeelizerFile file ; public void setGuid ( final String guid ) { this . guid = guid ; } public String getGuid ( ) { return guid ; } public String getOwner ( ) { return owner ; } public boolean isConflicted ( ) { return conflicted ; } public boolean isModified ( ) { return modified ; } public boolean isDeleted ( ) { return deleted ; } public String getString ( ) { return string ; } public void setString ( final String string ) { this . string = string ; } public boolean isBooleanP ( ) { return booleanP ; } public void setBooleanP ( final boolean booleanP ) { this . booleanP = booleanP ; } public Boolean getBooleanO ( ) { return booleanO ; } public void setBooleanO ( final Boolean booleanO ) { this . booleanO = booleanO ; } public Integer getIntegerO ( ) { return integerO ; } public void setIntegerO ( final Integer integerO ) { this . integerO = integerO ; } public int getIntegerP ( ) { return integerP ; } public void setIntegerP ( final int integerP ) { this . integerP = integerP ; } public Short getShortO ( ) { return shortO ; } public void setShortO ( final Short shortO ) { this . shortO = shortO ; } public short getShortP ( ) { return shortP ; } public void setShortP ( final short shortP ) { this . shortP = shortP ; } public Long getLongO ( ) { return longO ; } public void setLongO ( final Long longO ) { this . longO = longO ; } public long getLongP ( ) { return longP ; } public void setLongP ( final long longP ) { this . longP = longP ; } public Byte getByteO ( ) { return byteO ; } public void setByteO ( final Byte byteO ) { this . byteO = byteO ; } public byte getByteP ( ) { return byteP ; } public void setByteP ( final byte byteP ) { this . byteP = byteP ; } public BigInteger getBigInteger ( ) { return bigInteger ; } public void setBigInteger ( final BigInteger bigInteger ) { this . bigInteger = bigInteger ; } public Double getDoubleO ( ) { return doubleO ; } public void setDoubleO ( final Double doubleO ) { this . doubleO = doubleO ; } public double getDoubleP ( ) { return doubleP ; } public void setDoubleP ( final double doubleP ) { this . doubleP = doubleP ; } public Float getFloatO ( ) { return floatO ; } public void setFloatO ( final Float floatO ) { this . floatO = floatO ; } public float getFloatP ( ) { return floatP ; }", "gt": "public void setFloatP ( final float floatP )", "prediction": "public void setFloatP ( final floatP )\n", "label": 0}
{"id": 14539, "input": "<s> package org . eclipse . ui . handlers ; import java . util . Collection ; import org . eclipse . core . commands . Command ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . IHandler ; import org . eclipse . core . commands . IHandler2 ; import org . eclipse . core . commands . NotEnabledException ; import org . eclipse . core . commands . NotHandledException ; import org . eclipse . core . commands . ParameterizedCommand ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . expressions . Expression ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . swt . widgets . Event ; import org . eclipse . ui . services . IServiceWithSources ; public interface IHandlerService extends IServiceWithSources { public IHandlerActivation activateHandler ( IHandlerActivation activation ) ; public IHandlerActivation activateHandler ( String commandId , IHandler handler ) ; public IHandlerActivation activateHandler ( String commandId , IHandler handler , Expression expression ) ; public IHandlerActivation activateHandler ( String commandId", "gt": ", IHandler handler , Expression expression , boolean global ) ;", "prediction": ", IHandler handler , Expression expression ) ;\n", "label": 1}
{"id": 2977, "input": "<s> package Liza ; import org . bukkit . entity . NPC ;", "gt": "public interface LizaNPC extends NPC", "prediction": "import org . bukkit . entity . NPCFactory ;\n", "label": 0}
{"id": 14542, "input": "<s> package com . talis . hbase . rdf . layout . verticalpartitioning ; import com . talis . hbase . rdf . StoreDesc ; import com . talis . hbase . rdf . connection . HBaseRdfConnection ; import com . talis . hbase . rdf . layout . StoreBase ; import com . talis . hbase . rdf . layout . TableDescLayouts ; import com . talis . hbase . rdf . store . StoreFormatter ; import com . talis . hbase . rdf . store . StoreLoader ; import com . talis .", "gt": "hbase . rdf . store . StoreQueryRunner ;", "prediction": "hbase . rdf . store . StoreModel ;\n", "label": 1}
{"id": 300, "input": "<s> class R extends Q { @ Deprecated public void pDep_qDep_rDep ( ) { } public void pDep_qDep_rUnd ( ) { } @ Deprecated public void pDep_qUnd_rDep ( ) { } public void pDep_qUnd_rUnd ( ) { } @ Deprecated public void pDep_qInh_rDep ( ) { } public void pDep_qInh_rUnd ( ) { } @ Deprecated public void pUnd_qDep_rDep ( ) { } public void pUnd_qDep_rUnd ( ) { } @ Deprecated", "gt": "public void pUnd_qUnd_rDep ( )", "prediction": "public void pUnd_qInh_rUnd ( )\n", "label": 0}
{"id": 14562, "input": "<s> package knowevo . myvizster ; import java . awt . Component ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . Timer ; import javax . swing . JOptionPane ; import javax . swing . UIManager ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . graph . Graph ; import edu . berkeley . guir . prefuse . graph . io . XMLGraphReader ; import knowevo . myvizster . ui . LoginDialog ; public class VizsterLib { public static final int DEFAULT_ERROR = 0 ; public static final int PROFILE_ERROR = 1 ; public static final void errexit ( Exception e , Component c , String msg ) { errexit ( DEFAULT_ERROR , e , c , msg ) ; } public static final void errexit ( int type , Exception e , Component c , String msg ) { if ( e != null ) e . printStackTrace ( ) ; switch ( type ) { case PROFILE_ERROR : profileLoadError ( c , msg ) ; break ; default : defaultError ( c , msg ) ; } System . exit ( 1 ) ; } public static final void profileLoadError ( Component c , String uid ) { JOptionPane . showMessageDialog ( c , \"Error loading profile: \" + uid , \"Error Loading Profile\" , JOptionPane . ERROR_MESSAGE ) ; } public static final void defaultError ( Component c , String msg ) { JOptionPane . showMessageDialog ( c , msg ) ; } public static final boolean authenticate ( Vizster owner , int retries ) { LoginDialog ld = new LoginDialog ( owner ) ; ld . setVisible ( true ) ; return ld . isLoggedIn ( ) ; } public static final Graph loadGraph ( String graphfile ) throws FileNotFoundException , IOException { XMLGraphReader gl = new XMLGraphReader ( ) ; return gl . loadGraph ( graphfile ) ; } public static final void setLookAndFeel ( ) { try { String laf = UIManager . getSystemLookAndFeelClassName ( ) ; UIManager . setLookAndFeel ( laf ) ; } catch ( Exception e ) { } } public static final void setHighlightValue ( VisualItem item , int val ) { if ( item == null ) return ; int [ ] value = ( int [ ] ) item . getVizAttribute ( \"highlightValue\" ) ; if ( value == null ) { value = new int [ 1 ] ; item . setVizAttribute ( \"highlightValue\" , value ) ; } value [ 0 ] = val ; } public static final int getHighlightValue ( VisualItem item ) { if ( item == null ) return - 1 ; int [ ] val = ( int [ ] ) item . getVizAttribute ( \"highlightValue\" ) ; return ( val == null ? 0 : val [ 0 ] ) ; } private static Timer s_timer ; public static final Timer getTimer ( ) { if ( s_timer == null ) s_timer = new Timer ( ) {", "gt": "public void cancel ( )", "prediction": "public void run ( )\n", "label": 1}
{"id": 7322, "input": "<s> package com . sun . tools . classfile ; public class DescriptorException extends Exception { private static", "gt": "final long serialVersionUID = 2411890273788901032L ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 14570, "input": "<s> package org . eclipse . swt . events ; import static org . eclipse . rap . rwt . lifecycle . WidgetUtil . getId ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . * ; public class ControlEvent_Test extends TestCase { private Display display ; private Control control ; @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; display = new Display ( ) ; control = new Shell ( display , SWT . NONE ) ; control . setVisible ( true ) ; Fixture . fakeNewRequest ( display ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testUntypedEventConstructor ( ) throws Exception { Event event = new Event ( ) ; event . display = display ; event . widget = mock ( Widget . class ) ; event . time = 1 ; event . data = new Object ( ) ; ControlEvent controlEvent = new ControlEvent ( event ) ; EventTestHelper . assertFieldsEqual ( controlEvent , event ) ; } public void testResized ( ) { ControlListener listener = mock ( ControlListener . class ) ; control . addControlListener ( listener ) ; control . setSize ( 10 , 20 ) ; verify ( listener , times ( 1 ) ) . controlResized ( any ( ControlEvent . class ) ) ; verify ( listener , times ( 0 ) ) . controlMoved ( any ( ControlEvent . class ) ) ; } public void testResized_FromClient ( ) { control . setLocation (", "gt": "50 , 50 ) ;", "prediction": "10 , 20 ) ;\n", "label": 1}
{"id": 7809, "input": "<s> package Liza ; import java . util . HashSet ; import java . util . List ; import org . bukkit . entity . Creeper ; public interface LizaCreeper extends Creeper { List < LizaBlock > getLastTwoTargetLizaBlocks ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaBlock > getLineOfSightLiza ( HashSet < Byte > transparent , int maxDistance ) ; List < LizaEntity > getNearbyLizaEntities (", "gt": "double x , double y , double z ) ;", "prediction": "HashSet < Byte > transparent , int maxDistance ) ;\n", "label": 0}
{"id": 14571, "input": "<s> package com . emf4sw . owl ; import com . emf4sw . rdf . Resource ; public", "gt": "interface OWLClass extends Resource , ClassExpression", "prediction": "class RdfResource extends Resource\n", "label": 1}
{"id": 4369, "input": "<s> package com . sun . tools . javac . util ; public class Pair < A , B > { public final A fst ; public final B snd ; public Pair ( A fst , B snd ) { this . fst = fst ; this . snd = snd ; } public String toString ( ) { return \"Pair[\" + fst + \",\" + snd + \"]\" ; } private static boolean equals ( Object x , Object y ) { return ( x == null && y == null ) || ( x != null && x . equals ( y ) ) ; } public boolean equals ( Object other ) { return other instanceof Pair < ? , ? > && equals ( fst , ( ( Pair < ? , ? > ) other ) . fst ) && equals ( snd , ( ( Pair < ? , ? > ) other ) . snd ) ; } public int hashCode ( ) { if ( fst == null ) return ( snd == null ) ? 0 : snd . hashCode ( ) + 1 ; else if ( snd == null ) return fst . hashCode ( ) + 2 ; else return fst . hashCode ( ) * 17", "gt": "+ snd . hashCode ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14574, "input": "<s> package org . eclipse . ui . internal ;", "gt": "public class CompatibleWorkbenchPage implements ICompatibleWorkbenchPage", "prediction": "import java . util . ArrayList ;\n", "label": 1}
{"id": 2033, "input": "<s> package com . toedter . gwt . demo . contacts . server ; import java . util . List ; import com . google . gwt . user . server . rpc . RemoteServiceServlet ; import com . toedter . gwt . demo . contacts . client . IContactService ; import com . toedter . gwt . demo . contacts . shared . Contact ; @ SuppressWarnings ( \"serial\" ) public class ContactService extends RemoteServiceServlet implements IContactService { private final ContactManager contactManager ; public ContactService ( ) { contactManager = new ContactManager ( ) ; } @ Override public", "gt": "List < Contact > getAllContacts ( ) throws IllegalArgumentException", "prediction": "String toString ( )\n", "label": 0}
{"id": 14587, "input": "<s> package org . eclipse . ui . internal . menus ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . ui . menus . AbstractContributionFactory ; public abstract class AbstractMenuAdditionCacheEntry extends AbstractContributionFactory { private IConfigurationElement additionElement ; public AbstractMenuAdditionCacheEntry ( String location , String namespace , IConfigurationElement element ) { super (", "gt": "location , namespace ) ;", "prediction": "location , element ) ;\n", "label": 1}
{"id": 3071, "input": "<s> package org . ofbiz . widget . screen ; import java . io . IOException ; import java . util . Map ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . base . util . GeneralException ; public interface ScreenStringRenderer { public String getRendererName ( ) ; public void renderScreenBegin ( Appendable writer , Map < String , Object > context ) throws IOException ; public void renderScreenEnd ( Appendable writer , Map < String , Object > context ) throws IOException ; public void renderSectionBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Section section ) throws IOException ; public void renderSectionEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Section section ) throws IOException ; public void renderContainerBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Container container ) throws IOException ; public void renderContainerEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Container container ) throws IOException ; public void renderContentBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderContentBody ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderContentEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderSubContentBegin ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderSubContentBody ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderSubContentEnd ( Appendable writer , Map < String , Object > context , ModelScreenWidget . SubContent content ) throws IOException ; public void renderHorizontalSeparator ( Appendable writer , Map < String , Object > context , ModelScreenWidget . HorizontalSeparator separator ) throws IOException ; public void renderLabel ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Label label ) throws IOException ; public void renderLink ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Link link ) throws IOException ; public void renderImage ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Image image ) throws IOException ; public void renderContentFrame ( Appendable writer , Map < String , Object > context , ModelScreenWidget . Content content ) throws IOException ; public void renderScreenletBegin ( Appendable writer , Map < String , Object > context , boolean collapsed , ModelScreenWidget . Screenlet screenlet ) throws IOException ; public void renderScreenletSubWidget ( Appendable writer , Map < String , Object > context , ModelScreenWidget subWidget , ModelScreenWidget . Screenlet screenlet )", "gt": "throws GeneralException , IOException ;", "prediction": "throws IOException ;\n", "label": 0}
{"id": 14613, "input": "<s> package org . nuxeo . ecm . admin ; import static org . jboss . seam . ScopeType . CONVERSATION ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import javax . faces . model . SelectItem ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . jboss . seam . ScopeType ; import org . jboss . seam . annotations . Factory ; import org . jboss . seam . annotations . Name ; import org . jboss . seam . annotations . Scope ; import org . jboss . seam . contexts . Contexts ; import org . nuxeo . ecm . platform . audit . api . AuditReader ; import org . nuxeo . ecm . platform . audit . api . LogEntry ; import org . nuxeo . ecm . platform . web . common . session . NuxeoHttpSessionMonitor ; import org . nuxeo . ecm . platform . web . common . session . SessionInfo ; import org . nuxeo . runtime . api . Framework ; @ Name ( \"usersActivityInfo\" ) @ Scope ( CONVERSATION ) public class UsersActivityManager implements Serializable { private static final long serialVersionUID = 1L ; protected static final Log log = LogFactory . getLog ( UsersActivityManager . class ) ; protected String selectedAuditTimeRange ; protected String selectedAuditCategory ; protected String selectedHttpSessionsTimeRange ; protected int currentAuditPage = 1 ; protected static int pageSize = 25 ; public List < SelectItem > getAuditTimeRanges ( ) { List < SelectItem > ranges = new ArrayList < SelectItem > ( ) ; for ( int i = 1 ; i < 13 ; i ++ ) { ranges . add ( new SelectItem ( i + \"h\" , \"label.timerange.\" + i + \"h\" ) ) ; } for ( int i = 1 ; i < 8 ; i ++ ) { ranges . add ( new SelectItem ( i * 24 + \"h\" , \"label.timerange.\" + i + \"d\" ) ) ; } for ( int i = 2 ; i < 6 ; i ++ ) { ranges . add ( new SelectItem ( 24 * 7 * i + \"h\" , \"label.timerange.\" + i + \"w\" ) ) ; } return ranges ; } public List < SelectItem > getAuditCategories ( ) { List < SelectItem > ranges = new ArrayList < SelectItem > ( ) ; ranges . add ( new SelectItem ( \"NuxeoAuthentication\" , \"label.audit.auth\" ) ) ; ranges . add ( new SelectItem ( \"eventDocumentCategory\" , \"label.audit.doc\" ) ) ; ranges . add ( new SelectItem ( \"eventLifeCycleCategory\" , \"label.audit.lifecycle\" ) ) ; ranges . add ( new SelectItem ( \"all\" , \"label.audit.all\" ) ) ; return ranges ; } public String getSelectedAuditTimeRange ( ) { if ( selectedAuditTimeRange == null ) { selectedAuditTimeRange = \"1h\" ; } return selectedAuditTimeRange ; } public void setSelectedAuditTimeRange ( String dateRange ) { selectedAuditTimeRange = dateRange ; currentAuditPage = 1 ; Contexts . getEventContext ( ) . remove ( \"userLoginEvents\" ) ; } public String getSelectedAuditCategory ( ) { if ( selectedAuditCategory == null ) { selectedAuditCategory = \"all\" ; } return selectedAuditCategory ; } public void setSelectedAuditCategory ( String category ) { selectedAuditCategory = category ; currentAuditPage = 1 ; Contexts . getEventContext ( ) . remove ( \"userLoginEvents\" ) ; } public int getCurrentAuditPage ( ) { return currentAuditPage ; } public void nextAuditPage ( ) { currentAuditPage += 1 ; Contexts . getEventContext ( ) . remove ( \"userLoginEvents\" ) ; } public void prevAuditPage ( ) { currentAuditPage -= 1 ; if ( currentAuditPage <= 0 ) { currentAuditPage = 1 ; } Contexts . getEventContext ( ) . remove ( \"userLoginEvents\" ) ; } @ Factory ( value = \"userLoginEvents\" , scope = ScopeType . EVENT ) public List < LogEntry > getLoginInfo ( ) throws Exception { AuditReader reader = Framework . getService ( AuditReader . class ) ; String [ ] cat = { getSelectedAuditCategory ( ) } ; if ( getSelectedAuditCategory ( ) . equals ( \"all\" ) ) { cat = new String [ 0 ] ; } return reader . queryLogsByPage ( new String [ 0 ] , selectedAuditTimeRange , cat , null , currentAuditPage , pageSize ) ; } public List < SelectItem > getHttpSessionsTimeRanges ( ) { List < SelectItem > ranges = new ArrayList < SelectItem > ( ) ; ranges . add ( new SelectItem ( 5 * 60 + \"s\" , \"label.timerange.\" + 5 + \"m\" ) ) ; ranges . add ( new SelectItem ( 10 * 60 + \"s\" , \"label.timerange.\" + 10 + \"m\" ) ) ; ranges . add ( new SelectItem ( 20 * 60 + \"s\" , \"label.timerange.\" + 20 + \"m\" ) ) ; ranges . add ( new SelectItem ( 30 * 60 + \"s\" , \"label.timerange.\" + 30 + \"m\" ) ) ; ranges . add ( new SelectItem ( 60 * 60 + \"s\" , \"label.timerange.\" + 1 + \"h\" ) ) ; ranges . add ( new SelectItem ( 2 * 60 * 60 + \"s\" , \"label.timerange.\" + 2 + \"h\" ) ) ; ranges . add ( new SelectItem ( 4 * 60 * 60 + \"s\" , \"label.timerange.\" + 4 + \"h\" ) ) ; ranges . add ( new SelectItem ( \"all\" , \"label.timerange.all\" ) ) ; return ranges ; } public String getSelectedHttpSessionsTimeRange ( ) { if ( selectedHttpSessionsTimeRange == null ) { selectedHttpSessionsTimeRange = \"1800s\" ; } return selectedHttpSessionsTimeRange ; } public", "gt": "void setSelectedHttpSessionsTimeRange ( String dateRange )", "prediction": "void setSelectedHttpSessionsTimeRange ( String dateRange )\n", "label": 1}
{"id": 1790, "input": "<s> package org . hackreduce . models ; import java . io . StringReader ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . hadoop . io . Text ; import org . w3c . dom . CharacterData ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; public class WikipediaRecord { int id ; String title ; int revisionId ; Date revisionDate ; String revisionComment ; String text ; static DateFormat df = new SimpleDateFormat ( \"yyyy-MM-dd'T'HH:mm:ss'Z'\" ) ; static { df . setTimeZone ( TimeZone . getTimeZone ( \"Zulu\" ) ) ; } public WikipediaRecord ( String xml ) throws IllegalArgumentException { try { DocumentBuilder docBuilder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; InputSource is = new InputSource ( ) ; is . setCharacterStream ( new StringReader ( xml ) ) ; Document doc = docBuilder . parse ( is ) ; NodeList pageList = doc . getElementsByTagName ( \"page\" ) ; if ( pageList . getLength ( ) != 1 ) throw new IllegalArgumentException ( ) ; Element page = ( Element ) pageList . item ( 0 ) ; setTitle ( getStringFromTag ( page , \"title\" ) ) ; setId ( Integer . parseInt ( getStringFromTag ( page , \"id\" ) ) ) ; NodeList revisionList = page . getElementsByTagName ( \"revision\" ) ; if ( revisionList . getLength ( ) < 1 ) throw new IllegalArgumentException ( ) ; Element revision = ( Element ) revisionList . item ( 0 ) ; setRevisionId ( Integer . parseInt ( getStringFromTag ( revision , \"id\" ) ) ) ; setRevisionComment ( getStringFromTag ( revision , \"comment\" ) ) ; String revisionDateString = getStringFromTag ( revision , \"timestamp\" ) ; if ( revisionDateString != null ) setRevisionDate ( df . parse ( revisionDateString ) ) ; setText ( getStringFromTag ( revision , \"text\" ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( \"Couldn't create a \" + getClass ( ) . getName ( ) + \" record from the given XML\" ) ; } } private String getStringFromTag ( Element rootElement , String tagname ) { NodeList list = rootElement . getElementsByTagName ( tagname ) ; if ( list . getLength ( ) > 0 ) { Element element = ( Element ) list . item ( 0 ) ; Node child = element . getFirstChild ( ) ; if ( child instanceof CharacterData ) { CharacterData cd = ( CharacterData ) child ; return cd . getData ( ) ; } } return null ; } public WikipediaRecord ( Text xml ) throws IllegalArgumentException { this ( xml . toString ( ) ) ; } public int getId ( ) { return id ; } public void setId ( int id ) { this . id = id ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public int getRevisionId ( ) { return revisionId ; } public void setRevisionId ( int revisionId ) { this . revisionId = revisionId ; } public Date getRevisionDate ( ) { return revisionDate ; } public void setRevisionDate ( Date revisionDate ) { this", "gt": ". revisionDate = revisionDate ;", "prediction": ". revisionDate = revisionDate ;\n", "label": 0}
{"id": 14623, "input": "<s> package org . nuxeo . ecm . platform . publisher . remoting . restHandler ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . util . List ; import javax . ws . rs . WebApplicationException ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . MultivaluedMap ; import javax . ws . rs . ext . MessageBodyReader ; import javax . ws . rs . ext . Provider ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . DefaultMarshaler ; import org . nuxeo . ecm . platform . publisher . remoting . marshaling . interfaces . PublishingMarshalingException ; import org . nuxeo . ecm . webengine . WebEngine ; @ Provider public class RemotePubMessageReader implements MessageBodyReader < RemotePubParam > { public boolean isReadable ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType mt ) { return mt . equals ( RemotePubParam . mediaType ) ; } public RemotePubParam readFrom ( Class arg0 , Type arg1 , Annotation [ ] arg2 , MediaType arg3 , MultivaluedMap arg4 , InputStream is ) throws IOException , WebApplicationException { DefaultMarshaler marshaler = new DefaultMarshaler ( WebEngine . getActiveContext ( ) . getCoreSession ( ) ) ; InputStreamReader isr = new InputStreamReader ( is , \"UTF-8\" ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuffer sb = new StringBuffer ( ) ; int ch ; while ( ( ch = br . read ( ) ) > - 1 ) { sb . append ( ( char ) ch ) ; } br . close ( ) ; String xmlData = sb . toString ( ) ; try { List < Object", "gt": "> params = marshaler . unMarshallParameters ( xmlData ) ;", "prediction": "> objects = new ArrayList < Object > ( ) ;\n", "label": 1}
{"id": 1895, "input": "<s> package org . ofbiz . workeffort . workeffort ; import java . util . List ; import java . util . Set ; import java . util . Stack ; import javolution . util . FastList ; import javolution . util . FastSet ; import net . fortuna . ical4j . model . * ; import net . fortuna . ical4j . model . property . * ; import org . ofbiz . service . calendar . TemporalExpression ; import org . ofbiz . service . calendar . TemporalExpressionVisitor ; import org . ofbiz . service . calendar . TemporalExpressions ; import org . ofbiz . service . calendar . TemporalExpressions . * ; import com . ibm . icu . util . Calendar ; public class ICalRecurConverter implements TemporalExpressionVisitor { protected static final WeekDay dayOfWeekArray [ ] = { WeekDay . SU , WeekDay . MO , WeekDay . TU , WeekDay . WE , WeekDay . TH , WeekDay . FR , WeekDay . SA } ; @ SuppressWarnings ( \"unchecked\" ) public static void convert ( TemporalExpression expr , PropertyList eventProps ) { ICalRecurConverter converter = new ICalRecurConverter ( ) ; expr . accept ( converter ) ; DtStart dateStart = ( DtStart ) eventProps . getProperty ( Property . DTSTART ) ; if ( converter . dateStart != null ) { if ( dateStart != null ) { eventProps . remove ( dateStart ) ; } dateStart = converter . dateStart ; eventProps . add ( dateStart ) ; } if ( dateStart != null && converter . exRuleList . size ( ) > 0 ) { ExDate exdate = new ExDate ( ) ; exdate . getDates ( ) . add ( dateStart . getDate ( ) ) ; converter . exDateList . add ( exdate ) ; } eventProps . addAll ( converter . incDateList ) ; eventProps . addAll ( converter . incRuleList ) ; eventProps . addAll ( converter . exDateList ) ; eventProps . addAll ( converter . exRuleList ) ; } protected DtStart dateStart = null ; protected List < DateListProperty > incDateList = FastList . newInstance ( ) ; protected List < DateListProperty > exDateList = FastList . newInstance ( ) ; protected List < RRule > incRuleList = FastList . newInstance ( ) ; protected List < ExRule > exRuleList = FastList . newInstance ( ) ; protected VisitorState state = new VisitorState ( ) ; protected Stack < VisitorState > stateStack = new Stack < VisitorState > ( ) ; protected ICalRecurConverter ( ) { } @ SuppressWarnings ( \"unchecked\" ) protected Recur consolidateRecurs ( List < Recur > recurList ) { Set < Integer > monthList = FastSet . newInstance ( ) ; Set < Integer > monthDayList = FastSet . newInstance ( ) ; Set < WeekDay > weekDayList = FastSet . newInstance ( ) ; Set < Integer > hourList = FastSet . newInstance ( ) ; Set < Integer > minuteList = FastSet . newInstance ( ) ; String freq = null ; int freqCount = 0 ; for ( Recur recur : recurList ) { monthList . addAll ( recur . getMonthList ( ) ) ; monthDayList . addAll ( recur . getMonthDayList ( ) ) ; weekDayList . addAll ( recur . getDayList ( ) ) ; hourList . addAll ( recur . getHourList ( ) ) ; minuteList . addAll ( recur . getMinuteList ( ) ) ; if ( recur . getInterval ( ) != 0 ) { freq = recur . getFrequency ( ) ; freqCount = recur . getInterval ( ) ; } } if ( freq == null && monthList . size ( ) > 0 ) { freq = Recur . MONTHLY ; } else if ( freq == null && ( monthDayList . size ( ) > 0 || weekDayList . size ( ) > 0 ) ) { freq = Recur . DAILY ; } else if ( freq == null && hourList . size ( ) > 0 ) { freq = Recur . HOURLY ; } else if ( freq == null && minuteList . size ( ) > 0 ) { freq = Recur . MINUTELY ; } if ( freq == null ) { throw new IllegalStateException ( \"Unable to convert intersection\" ) ; } Recur newRecur = new Recur ( freq , 0 ) ; if ( freqCount != 0 ) { newRecur . setInterval ( freqCount ) ; } newRecur . getMonthList ( ) . addAll ( monthList ) ; newRecur . getMonthDayList ( ) . addAll ( monthDayList ) ; newRecur . getDayList ( ) . addAll ( weekDayList ) ; newRecur . getHourList ( ) . addAll ( hourList ) ; newRecur . getMinuteList ( ) . addAll ( minuteList ) ; return newRecur ; } @ Override public void visit ( Difference expr ) { VisitorState newState = new VisitorState ( ) ; newState . isIntersection = this . state . isIntersection ; this . stateStack . push ( this . state ) ; this . state = newState ; expr . getIncluded ( ) . accept ( this ) ; newState . isExcluded = true ; expr . getExcluded ( ) . accept ( this ) ; this . state = this . stateStack . pop ( ) ; if ( this . state . isIntersection ) { this . state . inclRecurList . addAll ( newState . inclRecurList ) ; this . state . exRecurList . addAll ( newState . exRecurList ) ; } } @ SuppressWarnings ( \"unchecked\" ) @ Override public void visit ( HourRange expr ) { NumberList hourList = new NumberList ( ) ; hourList .", "gt": "addAll ( expr . getHourRangeAsSet ( ) ) ;", "prediction": "addAll ( expr . getHourList ( ) ) ;\n", "label": 0}
{"id": 14631, "input": "<s> package org . fuzzydb . util ; import java . io . IOException ; import java . util . Map ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; public class CsvReaderBkgnd extends CsvReader implements Runnable { private Thread thread ; private BlockingQueue < Object > queue = new ArrayBlockingQueue < Object > ( 10 ) ; private Object [ ] packet ; private int next = 0 ; public CsvReaderBkgnd ( String file , boolean stripQuotes ) throws IOException { super ( file , stripQuotes , false ) ; } public CsvReaderBkgnd ( String file , boolean stripQuotes , boolean hasHeader ) throws IOException { super ( file , stripQuotes , hasHeader , false ) ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public Map < String , Object > readLine ( ) throws IOException , UnsupportedTypeException , GarbageLineException { start ( ) ; Object o = null ; try { if ( packet == null ) { packet = ( Object [ ] ) queue . take ( ) ; next = 0 ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } o = packet [ next ++ ] ; if ( next == packet . length ) { packet = null ; } if ( o instanceof UnsupportedTypeException ) { throw ( UnsupportedTypeException ) o ; } if ( o instanceof GarbageLineException ) { throw ( GarbageLineException ) o ; } if ( o instanceof IOException ) { throw ( IOException ) o ; } return ( Map < String , Object > ) o ; } private void start ( ) { if ( thread == null ) { thread = new Thread ( this ) ; thread . start ( ) ; } } public void run ( ) { int size = 100 ; Map < String , Object > map ; Object [ ] stuff = new Object [ size ] ; int i = 0 ; for ( ; ; ) { try { map = super . readLine ( ) ; } catch ( IOException e ) { stuff [ i ] = e ; try { queue . put ( stuff ) ; } catch ( InterruptedException e1 ) { throw new RuntimeException ( e1 ) ; } thread = null ; return ; } catch ( UnsupportedTypeException e ) { stuff [ i ] = e ; try { queue . put ( stuff ) ; } catch ( InterruptedException e1 ) { throw new RuntimeException ( e1 ) ; } thread = null ; return ; } catch ( GarbageLineException e ) { stuff [ i ] = e ; try { queue . put ( stuff ) ; } catch ( InterruptedException e1 ) { throw new RuntimeException ( e1 ) ; } thread = null ; return ; } stuff", "gt": "[ i ] = map ;", "prediction": "= new Object [ size ] ;\n", "label": 1}
{"id": 8003, "input": "<s> package org . ofbiz . entity . transaction ; import javax . transaction . xa . Xid ; import javax . transaction . xa . XAException ; import org . ofbiz . base . util . Debug ; public class DebugXaResource extends GenericXaResource { public static final String module = DebugXaResource . class . getName ( ) ; public Exception ex = null ; public DebugXaResource ( String info ) { this . ex = new Exception ( info ) ; } public DebugXaResource ( ) { this . ex = new Exception ( ) ; } @ Override public void commit ( Xid xid , boolean onePhase ) throws XAException { TransactionUtil . debugResMap . remove ( xid ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Xid : \" + xid . toString ( ) + \" cleared [commit]\" , module ) ; } @ Override public void rollback ( Xid xid ) throws XAException { TransactionUtil . debugResMap . remove ( xid ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Xid : \" + xid . toString ( ) + \"", "gt": "cleared [rollback]\" , module ) ;", "prediction": "cleared [rollback]\" , module ) ;\n", "label": 0}
{"id": 14644, "input": "<s> package br . org . archimedes . extend ; import static org . junit . Assert . assertEquals ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . junit . Test ; import br . org . archimedes . Tester ; import br . org . archimedes . arc . Arc ; import br . org . archimedes . circle . Circle ; import br . org . archimedes . dimension . Dimension ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . extend . interfaces . Extender ; import br . org . archimedes . infiniteline . InfiniteLine ; import br . org . archimedes . leader . Leader ; import br . org . archimedes . line . Line ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Point ; import br . org . archimedes . polyline . Polyline ; import br . org . archimedes . semiline . Semiline ; import br . org . archimedes . stub . StubElement ; import br . org . archimedes . text . Text ; public class ExtendManagerTest extends Tester { private static final Map < Class < ? extends Element > , Extender > EMPTY_MAP = Collections . emptyMap ( ) ; private static final Collection < Element > EMPTY_LIST = Collections . emptyList ( ) ; private ExtendManager manager ; @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; manager = new ExtendManager ( ) ; } @ Test public void dontModifyElementWithNoExtender ( ) throws Exception { MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( EMPTY_MAP ) ; ExtendManager manager = new ExtendManager ( extenderEPLoader ) ; Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; manager . extend ( line , EMPTY_LIST , new Point ( 0.0 , 0.0 ) ) ; assertEquals ( line , new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ) ; } @ Test ( expected = NullArgumentException . class ) public void callMockedExtenderForExistentExtender ( ) throws Exception { final Line line = new Line ( 1.0 , 0.0 , - 1.0 , 0.0 ) ; final Collection < Element > reference = EMPTY_LIST ; final Point point = new Point ( 0.0 , 0.0 ) ; Extender extenderMockado = new Extender ( ) { public Element extend ( Element element , Collection < Element > references , Point click ) throws NullArgumentException { assertEquals ( line , element ) ; assertEquals ( reference , references ) ; assertEquals ( point , click ) ; throw new NullArgumentException ( ) ; } public Collection < Element > getInfiniteExtensionElements ( Element element ) throws IllegalArgumentException { return null ; } } ; HashMap < Class < ? extends Element > , Extender > extenderMap = new HashMap < Class < ? extends Element > , Extender > ( ) ; extenderMap . put ( Line . class , extenderMockado ) ; MockExtenderEPLoader extenderEPLoader = new MockExtenderEPLoader ( extenderMap ) ; ExtendManager manager = new", "gt": "ExtendManager ( extenderEPLoader ) ;", "prediction": "ExtendManager ( extenderEPLoader ) ;\n", "label": 1}
{"id": 6194, "input": "<s> package com . sap . prd . mobile . ios . mios ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . maven . artifact . versioning . DefaultArtifactVersion ; import org . apache . maven . plugin . MojoExecutionException ; import org . apache . maven . plugin . MojoFailureException ; public class CheckPrerequisitesMojo extends AbstractXCodeMojo { public final static String MIN_XCODE_VERSION = \"4.4\" ; @ Override public void execute ( ) throws MojoExecutionException , MojoFailureException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PrintStream out = new PrintStream ( bos ) ; int exitCode = Forker . forkProcess ( out , new File ( \".\" ) , new String [ ] { \"xcodebuild\" , \"-version\" } ) ; if ( exitCode == 0 ) { String output = bos . toString ( ) ; DefaultArtifactVersion version = getVersion ( output ) ; String buildVersion = getBuildVersion ( output ) ; getLog ( ) . info ( \"Using Xcode \" + version + \" \" + buildVersion ) ; checkVersions ( version , buildVersion ) ; } else { throw new MojoExecutionException ( \"Could not get xcodebuild version (exit code = \" + exitCode + \")\" ) ; } } catch ( IOException e ) { throw new MojoExecutionException ( \"Could not get xcodebuild version\" , e ) ; } } private DefaultArtifactVersion getVersion ( String output ) throws MojoExecutionException { Pattern versionPattern = Pattern . compile ( \"Xcode (\\\\d+(\\\\.\\\\d+)+)\" , Pattern . CASE_INSENSITIVE ) ; Matcher versionMatcher = versionPattern . matcher ( output ) ; if ( versionMatcher . find ( ) ) { return new DefaultArtifactVersion ( versionMatcher . group ( 1 ) ) ; } throw new MojoExecutionException ( \"Could not get xcodebuild version\" ) ; } private String", "gt": "getBuildVersion ( String output ) throws MojoExecutionException", "prediction": "toString ( )\n", "label": 0}
{"id": 14690, "input": "<s> package com . google . code . microlog4android . config ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Properties ; import java . util . StringTokenizer ; import android . content . Context ; import android . content . res . AssetManager ; import android . content . res . Resources ; import android . content . res . Resources . NotFoundException ; import android . util . Log ; import com . google . code . microlog4android . Level ; import com . google . code . microlog4android . Logger ; import com . google . code . microlog4android . appender . Appender ; import com . google . code . microlog4android . format . Formatter ; import com . google . code . microlog4android . repository . DefaultLoggerRepository ; import com . google . code . microlog4android . repository . LoggerRepository ; public class PropertyConfigurator { private static final String TAG = \"Microlog.PropertyConfiguration\" ; public static String DEFAULT_PROPERTIES_FILENAME = \"microlog.properties\" ; public static final String ROOT_LOGGER_KEY = \"microlog.rootLogger\" ; public static final String MICROLOG_PREFIX = \"microlog\" ; public static final String LOGGER_PREFIX_KEY = \"microlog.logger\" ; public static final String FORMATTER_PREFIX_KEY = \"microlog.formatter\" ; public static final String PATTERN_LAYOUT_PREFIX_KEY = \"microlog.formatter.PatternFormatter.pattern\" ; public static final String APPENDER_PREFIX_KEY = \"microlog.appender\" ; public static final String FILE_APPENDER_FILE_NAME_KEY = \"microlog.appender.FileAppender.File\" ; public static final String FILE_APPENDER_APPEND_KEY = \"microlog.appender.FileAppender.Append\" ; public static final String LOG_LEVEL_PREFIX_KEY = \"microlog.level\" ; public static final String TAG_PREFIX_KEY = \"microlog.tag\" ; public static final String [ ] APPENDER_ALIASES = { \"LogCatAppender\" , \"FileAppender\" } ; public static final String [ ] APPENDER_CLASS_NAMES = { \"com.google.code.microlog4android.appender.LogCatAppender\" , \"com.google.code.microlog4android.appender.FileAppender\" } ; public static final String [ ] FORMATTER_ALIASES = { \"SimpleFormatter\" , \"PatternFormatter\" } ; public static final String [ ] FORMATTER_CLASS_NAMES = { \"com.google.code.microlog4android.format.SimpleFormatter\" , \"com.google.code.microlog4android.format.PatternFormatter\" } ; private static final HashMap < String , String > appenderAliases = new HashMap < String , String > ( 43 ) ; private static final HashMap < String , String > formatterAliases = new HashMap < String , String > ( 21 ) ; private Context context ; private LoggerRepository loggerRepository ; { for ( int index = 0 ; index < APPENDER_ALIASES . length ; index ++ ) { appenderAliases . put ( APPENDER_ALIASES [ index ] , APPENDER_CLASS_NAMES [ index ] ) ; } for ( int index = 0 ; index < FORMATTER_ALIASES . length ; index ++ ) { formatterAliases . put ( FORMATTER_ALIASES [ index ] , FORMATTER_CLASS_NAMES [ index ] ) ; } } ; private PropertyConfigurator ( Context context ) { this . context = context ; loggerRepository = DefaultLoggerRepository . INSTANCE ; } public static PropertyConfigurator getConfigurator ( Context context ) { if ( context == null ) { throw new IllegalArgumentException ( \"The context must not be null\" ) ; } return new PropertyConfigurator ( context ) ; } public void configure ( ) { configure ( DEFAULT_PROPERTIES_FILENAME ) ; } public void configure ( String filename ) { Resources resources = context . getResources ( ) ; AssetManager assetManager = resources . getAssets ( ) ; try { InputStream inputStream = assetManager . open ( filename ) ; Properties properties = loadProperties ( inputStream ) ; startConfiguration ( properties ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to open the microlog properties file. Hint: the file should be in the /assets directory \" + filename + \" \" + e ) ; } } public void configure ( int resId ) { Resources resources = context . getResources ( ) ; try { InputStream rawResource = resources . openRawResource ( resId ) ; Properties properties = loadProperties ( rawResource ) ; startConfiguration ( properties ) ; } catch ( NotFoundException e ) { Log . e ( TAG , \"Did not find the microlog properties resource. Hint: this should be in the /res/raw directory \" + e ) ; } catch ( IOException e ) { Log . e ( TAG , \"Failed to read the microlog properties resource.\" + e ) ; } } private Properties loadProperties ( InputStream inputStream ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( inputStream ) ; return properties ; } private void startConfiguration ( Properties properties ) { if ( properties . containsKey ( PropertyConfigurator . ROOT_LOGGER_KEY ) ) { Log . i ( TAG , \"Modern configuration not yet supported\" ) ; } else { Log . i ( TAG , \"Configure using the simple style (aka classic style)\" ) ; configureSimpleStyle ( properties ) ; } } private void configureSimpleStyle ( Properties properties ) { setLevel ( properties ) ; String appenderString = properties . getProperty ( PropertyConfigurator . APPENDER_PREFIX_KEY , \"LogCatAppender\" ) ; List < String > appenderList = parseAppenderString ( appenderString ) ; setAppenders ( appenderList , properties ) ; setFormatter ( properties ) ; } private void setLevel ( Properties properties ) { String levelString = ( String ) properties . get ( PropertyConfigurator . LOG_LEVEL_PREFIX_KEY ) ; Level level = stringToLevel ( levelString ) ; if ( level != null ) { loggerRepository . getRootLogger ( ) . setLevel ( level ) ; Log . i ( TAG , \"Root level: \" + loggerRepository . getRootLogger ( ) . getLevel ( ) ) ; } } private List < String > parseAppenderString ( String appenderString ) { StringTokenizer tokenizer = new StringTokenizer ( appenderString , \";,\" ) ; List < String > appenderList = new ArrayList < String > ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String appender = ( String ) tokenizer . nextElement ( ) ; appenderList . add ( appender ) ; } return appenderList ; } private void setAppenders ( List < String > appenderList , Properties properties ) { for ( String string : appenderList ) { addAppender", "gt": "( string , properties ) ;", "prediction": "( string ) ;\n", "label": 1}
{"id": 8650, "input": "<s> package com . sun . tools . javah ; public class InternalError extends Error { private static final long serialVersionUID = 8411861562497165022L ; InternalError ( String msg , Throwable cause ) { super (", "gt": "\"Internal error: \" + msg ) ;", "prediction": "msg , cause ) ;\n", "label": 0}
{"id": 14694, "input": "<s> package org . gatein . common . xml ; public class TooManyElementException extends RuntimeException { private static final long serialVersionUID = - 2381186243988987102L ; public TooManyElementException ( ) { } public TooManyElementException ( String message ) { super ( message ) ; } public TooManyElementException ( String message , Throwable cause ) {", "gt": "super ( message , cause ) ;", "prediction": "super ( cause ) ;\n", "label": 1}
{"id": 9872, "input": "<s> package org . ofbiz . manufacturing . bom ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . manufacturing . mrp . ProposedOrder ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; public class BOMNode { public static final String module = BOMNode . class . getName ( ) ; protected LocalDispatcher dispatcher = null ; protected Delegator delegator = null ; protected GenericValue userLogin = null ; private BOMTree tree ; private BOMNode parentNode ; private BOMNode substitutedNode ; private GenericValue ruleApplied ; private String productForRules ; private GenericValue product ; private GenericValue productAssoc ; private List < GenericValue > children ; private List < BOMNode > childrenNodes ; private BigDecimal quantityMultiplier ; private BigDecimal scrapFactor ; private int depth ; private BigDecimal quantity ; private String bomTypeId ; public BOMNode ( GenericValue product , LocalDispatcher dispatcher , GenericValue userLogin ) { this . product = product ; this . delegator = product . getDelegator ( ) ; this . dispatcher = dispatcher ; this . userLogin = userLogin ; children = FastList . newInstance ( ) ; childrenNodes = FastList . newInstance ( ) ; parentNode = null ; productForRules = null ; bomTypeId = null ; quantityMultiplier = BigDecimal . ONE ; scrapFactor = BigDecimal . ONE ; depth = 0 ; quantity = BigDecimal . ZERO ; } public BOMNode ( String productId , Delegator delegator , LocalDispatcher dispatcher , GenericValue userLogin ) throws GenericEntityException { this ( delegator . findOne ( \"Product\" , UtilMisc . toMap ( \"productId\" , productId ) , false ) , dispatcher , userLogin ) ; } protected void loadChildren ( String partBomTypeId , Date inDate , List < GenericValue > productFeatures , int type ) throws GenericEntityException { if ( product == null ) { throw new GenericEntityException ( \"product is null\" ) ; } if ( inDate == null ) inDate = new Date ( ) ; bomTypeId = partBomTypeId ; List < GenericValue > rows = delegator . findByAnd ( \"ProductAssoc\" , UtilMisc . toMap ( \"productId\" , product . get ( \"productId\" ) , \"productAssocTypeId\" , partBomTypeId ) , UtilMisc . toList ( \"sequenceNum\" , \"productIdTo ASC\" ) , false ) ; rows = EntityUtil . filterByDate ( rows , inDate ) ; if ( ( UtilValidate . isEmpty ( rows ) ) && substitutedNode != null ) { rows = delegator . findByAnd ( \"ProductAssoc\" , UtilMisc . toMap ( \"productId\" , substitutedNode . getProduct ( ) . get ( \"productId\" ) , \"productAssocTypeId\" , partBomTypeId ) , UtilMisc . toList ( \"sequenceNum\" ) , false ) ; rows = EntityUtil . filterByDate ( rows , inDate ) ; } children = FastList . newInstance ( ) ; children . addAll ( rows ) ; childrenNodes = FastList . newInstance ( ) ; BOMNode oneChildNode = null ; for ( GenericValue oneChild : children ) { oneChildNode = configurator ( oneChild , productFeatures , getRootNode ( ) . getProductForRules ( ) , inDate ) ; if ( oneChildNode != null ) { oneChildNode . setParentNode ( this ) ; switch ( type ) { case BOMTree . EXPLOSION : oneChildNode . loadChildren ( partBomTypeId , inDate , productFeatures , BOMTree . EXPLOSION ) ; break ; case BOMTree . EXPLOSION_MANUFACTURING : if ( ! oneChildNode . isWarehouseManaged ( null ) ) { oneChildNode . loadChildren ( partBomTypeId , inDate , productFeatures , type ) ; } break ; } } childrenNodes . add ( oneChildNode ) ; } } private BOMNode substituteNode ( BOMNode oneChildNode , List < GenericValue > productFeatures , List < GenericValue > productPartRules ) throws GenericEntityException { if ( productPartRules != null ) { GenericValue rule = null ; for ( int i = 0 ; i < productPartRules . size ( ) ; i ++ ) { rule = productPartRules . get ( i ) ; String ruleCondition = ( String ) rule . get ( \"productFeature\" ) ; String ruleOperator = ( String ) rule . get ( \"ruleOperator\" ) ; String newPart = ( String ) rule . get ( \"productIdInSubst\" ) ; BigDecimal ruleQuantity = BigDecimal . ZERO ; try { ruleQuantity = rule . getBigDecimal ( \"quantity\" ) ; } catch ( Exception exc ) { ruleQuantity = BigDecimal . ZERO ; } GenericValue feature = null ; boolean ruleSatisfied = false ; if ( ruleCondition == null || ruleCondition . equals ( \"\" ) ) { ruleSatisfied = true ; } else { if ( productFeatures != null ) { for ( int j = 0 ; j < productFeatures . size ( ) ; j ++ ) { feature = productFeatures . get ( j ) ; if ( ruleCondition . equals ( ( String ) feature . get ( \"productFeatureId\" ) ) ) { ruleSatisfied = true ; break ; } } } } if ( ruleSatisfied && ruleOperator . equals ( \"OR\" ) ) { BOMNode tmpNode = oneChildNode ; if ( newPart == null || newPart . equals ( \"\" ) ) { oneChildNode = null ; } else { BOMNode origNode = oneChildNode ; oneChildNode = new BOMNode ( newPart , delegator , dispatcher , userLogin ) ; oneChildNode . setTree ( tree ) ; oneChildNode . setSubstitutedNode ( tmpNode ) ; oneChildNode . setRuleApplied ( rule ) ; oneChildNode . setProductAssoc ( origNode . getProductAssoc ( ) ) ; oneChildNode . setScrapFactor ( origNode . getScrapFactor ( ) ) ; if ( ruleQuantity . compareTo ( BigDecimal .", "gt": "ZERO ) > 0 )", "prediction": "ZERO ) )\n", "label": 0}
{"id": 14717, "input": "<s> package org . apache . lucene . xmlparser ; public class ParserException extends Exception { public ParserException ( ) { super ( ) ; } public ParserException ( String message ) { super ( message ) ; } public ParserException ( String message , Throwable cause ) { super", "gt": "( message , cause ) ;", "prediction": "( cause ) ;\n", "label": 1}
{"id": 9156, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . ClassWriter ; import org . objectweb . asm . MethodVisitor ; import org . objectweb . asm . Type ; import static org . objectweb . asm . Opcodes . * ; import static org . parboiled . transform . Types . * ; class VarInitClassGenerator extends GroupClassGenerator { public VarInitClassGenerator ( boolean forceCodeBuilding ) { super ( forceCodeBuilding ) ; } public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( method , \"method\" ) ; return method . containsVars ( ) ; } @ Override protected boolean appliesTo ( InstructionGraphNode node ) { return", "gt": "node . isVarInitRoot ( ) ;", "prediction": "true ;\n", "label": 0}
{"id": 14723, "input": "<s> package com . emf4sw . owl . resource ; abstract public interface OWLWriter {", "gt": "Object write ( OWLResource resource , OWLFormats format ) ;", "prediction": "}\n", "label": 1}
{"id": 4538, "input": "<s> package ar . com . fdvs . dj . test ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . engine . JRDataSource ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JasperPrint ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . DynamicJasperHelper ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . SubReportBuilder ; import ar . com . fdvs . dj . domain . entities . Subreport ; public class MultiReportConcatenated { public static void main ( String [ ] args ) { Map params = new HashMap ( ) ; ClassicLayoutManager layoutManager = new ClassicLayoutManager ( ) ; DynamicReportBuilder drb = new DynamicReportBuilder ( ) ; drb . setTitle ( \"TEST\" ) ; drb . setSubtitle ( \"This is a report with many", "gt": "concatenated subreports which should start in a new page\" ) ;", "prediction": "columns\" ) ;\n", "label": 0}
{"id": 14724, "input": "<s> package org . eclipse . ui . internal . dialogs ; import java . util . Collection ; import java . util . HashSet ; import org . eclipse . jface . preference . IPreferenceNode ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; public class PreferenceNodeFilter extends ViewerFilter { Collection ids = new HashSet ( ) ; public PreferenceNodeFilter ( String [ ] filteredIds ) { super ( ) ; for ( int i = 0 ; i < filteredIds . length ; i ++ ) { ids . add ( filteredIds [ i ] ) ; } } public boolean select ( Viewer viewer , Object parentElement , Object element ) { return checkNodeAndChildren ( ( IPreferenceNode ) element ) ; } private boolean checkNodeAndChildren ( IPreferenceNode node ) { if ( ids . contains ( node . getId ( ) ) ) { return true ; } IPreferenceNode [ ] subNodes = node . getSubNodes ( ) ; for ( int i = 0 ; i < subNodes . length ; i ++ ) { if ( checkNodeAndChildren", "gt": "( subNodes [ i ] ) )", "prediction": "( subNodes [ i ] ) )\n", "label": 1}
{"id": 8006, "input": "<s> package org . ofbiz . product . store ; import java . math . BigDecimal ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import javax . servlet . ServletRequest ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . common . geo . GeoWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . party . contact . ContactMechWorker ; import org . ofbiz . product . catalog . CatalogWorker ; import org . ofbiz . product . config . ProductConfigWrapper ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; public class ProductStoreWorker { public static final String module = ProductStoreWorker . class . getName ( ) ; public static GenericValue getProductStore ( String productStoreId , Delegator delegator ) { if ( productStoreId == null || delegator == null ) { return null ; } GenericValue productStore = null ; try { productStore = delegator . findOne ( \"ProductStore\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , \"Problem getting ProductStore entity\" , module ) ; } return productStore ; } public static GenericValue getProductStore ( ServletRequest request ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; return ProductStoreWorker . getProductStore ( productStoreId , delegator ) ; } public static String getProductStoreId ( ServletRequest request ) { HttpServletRequest httpRequest = ( HttpServletRequest ) request ; HttpSession session = httpRequest . getSession ( false ) ; if ( session != null && session . getAttribute ( \"productStoreId\" ) != null ) { return ( String ) session . getAttribute ( \"productStoreId\" ) ; } else { GenericValue webSite = CatalogWorker . getWebSite ( request ) ; if ( webSite != null ) { String productStoreId = webSite . getString ( \"productStoreId\" ) ; return productStoreId ; } } return null ; } public static String getStoreCurrencyUomId ( HttpServletRequest request ) { GenericValue productStore = getProductStore ( request ) ; if ( UtilValidate . isEmpty ( productStore ) ) { Debug . logError ( \"No product store found in request, cannot set CurrencyUomId!\" , module ) ; return null ; } else { return UtilHttp . getCurrencyUom ( request . getSession ( ) , productStore . getString ( \"defaultCurrencyUomId\" ) ) ; } } public static Locale getStoreLocale ( HttpServletRequest request ) { GenericValue productStore = getProductStore ( request ) ; if ( UtilValidate . isEmpty ( productStore ) ) { Debug . logError ( \"No product store found in request, cannot set locale!\" , module ) ; return null ; } else { return UtilHttp . getLocale ( request , request . getSession ( ) , productStore . getString ( \"defaultLocaleString\" ) ) ; } } public static String determineSingleFacilityForStore ( Delegator delegator , String productStoreId ) { GenericValue productStore = null ; try { productStore = delegator . findOne ( \"ProductStore\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId ) , false ) ; } catch ( GenericEntityException e ) { Debug . logError ( e , module ) ; } if ( productStore != null ) { if ( \"Y\" . equalsIgnoreCase ( productStore . getString ( \"oneInventoryFacility\" ) ) ) { return productStore . getString ( \"inventoryFacilityId\" ) ; } } return null ; } public static boolean autoSaveCart ( Delegator delegator , String productStoreId ) { return autoSaveCart ( getProductStore ( productStoreId , delegator ) ) ; } public static boolean autoSaveCart ( GenericValue productStore ) { return productStore == null ? false : \"Y\" . equalsIgnoreCase ( productStore . getString ( \"autoSaveCart\" ) ) ; } public static String getProductStorePayToPartyId ( String productStoreId , Delegator delegator ) { return getProductStorePayToPartyId ( getProductStore ( productStoreId , delegator ) ) ; } public static String getProductStorePayToPartyId ( GenericValue productStore ) { String payToPartyId = \"Company\" ; if ( productStore != null && productStore . get ( \"payToPartyId\" ) != null ) { payToPartyId = productStore . getString ( \"payToPartyId\" ) ; } return payToPartyId ; } public static String getProductStorePaymentProperties ( ServletRequest request , String paymentMethodTypeId , String paymentServiceTypeEnumId , boolean anyServiceType ) { Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String productStoreId = ProductStoreWorker . getProductStoreId ( request ) ; return ProductStoreWorker . getProductStorePaymentProperties ( delegator , productStoreId , paymentMethodTypeId , paymentServiceTypeEnumId , anyServiceType ) ; } public static String getProductStorePaymentProperties ( Delegator delegator , String productStoreId , String paymentMethodTypeId , String paymentServiceTypeEnumId , boolean anyServiceType ) { GenericValue setting = ProductStoreWorker . getProductStorePaymentSetting ( delegator , productStoreId , paymentMethodTypeId , paymentServiceTypeEnumId , anyServiceType ) ; String payProps = \"payment.properties\" ; if ( setting != null && setting . get ( \"paymentPropertiesPath\" ) != null ) { payProps = setting . getString ( \"paymentPropertiesPath\" ) ; } return payProps ; } public static GenericValue getProductStorePaymentSetting ( Delegator delegator , String productStoreId , String paymentMethodTypeId , String paymentServiceTypeEnumId , boolean anyServiceType ) { GenericValue storePayment = null ; try { storePayment = delegator . findOne ( \"ProductStorePaymentSetting\" , UtilMisc . toMap ( \"productStoreId\" , productStoreId , \"paymentMethodTypeId\" , paymentMethodTypeId , \"paymentServiceTypeEnumId\" , paymentServiceTypeEnumId ) , true ) ; } catch ( GenericEntityException e ) { Debug . logError ( e", "gt": ", \"Problems looking up store payment settings\" , module ) ;", "prediction": ", module ) ;\n", "label": 0}
{"id": 14740, "input": "<s> package org . spliffy . server . web ; import org . spliffy . server . db . Organisation ; public interface RootFolder extends SpliffyCollectionResource { PrincipalResource findEntity", "gt": "( String name ) ;", "prediction": ";\n", "label": 1}
{"id": 7158, "input": "<s> import java . util . * ; import com . sun . tools . javac . util . List ; public class TList { public static void main ( String [ ] args ) { new TList ( ) . run ( ) ; } String [ ] [ ] data = { { } , { \"1\" } , { \"1\" , \"2\" } , { \"1\" , \"2\" } , { \"1\" , \"2\" , \"3\" , \"4\" , \"X\" , \"X\" , \"X\" , \"8\" , \"9\" , \"10\" } } ; Map < java . util . List < String > , List < String > > examples ; void run ( ) { examples = new LinkedHashMap < java . util . List < String > , List < String > > ( ) ; for ( String [ ] values : data ) examples . put ( Arrays . asList ( values ) , createList ( values ) ) ; test_AbstractList ( ) ; test_add_E ( ) ; test_add_int_E ( ) ; test_addAll_Collection ( ) ; test_addAll_int_Collection ( ) ; test_clear ( ) ; test_contains_Object ( ) ; test_contains_All ( ) ; test_equals_Object ( ) ; test_get_int ( ) ; test_hashCode ( ) ; test_indexOf_Object ( ) ; test_isEmpty ( ) ; test_iterator ( ) ; test_lastIndexOf_Object ( ) ; test_listIterator ( ) ; test_listIterator_int ( ) ; test_remove_int ( ) ; test_remove_Object ( ) ; test_removeAll_Collection ( ) ; test_retainAll_Collection ( ) ; test_set_int_E ( ) ; test_size ( ) ; test_subList_int_int ( ) ; test_toArray ( ) ; test_toArray_TArray ( ) ; test_prependList_List ( ) ; test_reverse ( ) ; } void test_AbstractList ( ) { System . err . println ( \"test AbstractList\" ) ; if ( AbstractList . class . isAssignableFrom ( List . class ) ) throw new AssertionError ( ) ; } void test_add_E ( ) { System . err . println ( \"test add(E)\" ) ; for ( List < String > l : examples . values ( ) ) { try { l . add ( \"test\" ) ; throw new AssertionError ( ) ; } catch ( UnsupportedOperationException ex ) { } } } void test_add_int_E ( ) { System . err . println ( \"test add(int,E)\" ) ; for ( List < String > l : examples . values ( ) ) { try { l . add ( 0 , \"test\" ) ; throw new AssertionError ( ) ; } catch ( UnsupportedOperationException ex ) { } } } void test_addAll_Collection ( ) { System . err . println ( \"test addAll(Collection)\" ) ; for ( List < String > l : examples . values ( ) ) { int l_size = l . size ( ) ; for ( java . util . List < String > arg : examples . keySet ( ) ) { try { boolean modified = l . addAll ( arg ) ; if ( modified ) throw new AssertionError ( ) ; } catch ( UnsupportedOperationException e ) { } if ( l . size ( ) != l_size ) throw new AssertionError ( ) ; } } } void test_addAll_int_Collection ( ) { System . err . println ( \"test addAll(int,Collection)\" ) ; for ( List < String > l : examples . values ( ) ) { int l_size = l . size ( ) ; for ( java . util . List < String > arg : examples . keySet ( ) ) { try { boolean modified = l . addAll ( 0 , arg ) ; if ( modified ) throw new AssertionError ( ) ; } catch ( UnsupportedOperationException e ) { } if ( l . size ( ) != l_size ) throw new AssertionError ( ) ; } } } void test_clear ( ) { System . err . println ( \"test clear()\" ) ; for ( List < String > l : examples . values ( ) ) { int l_size = l . size ( ) ; try { l . clear ( ) ; if ( l_size > 0 ) throw new AssertionError ( ) ; } catch ( UnsupportedOperationException e ) { } if ( l . size ( ) != l_size ) throw new AssertionError ( ) ; } } void test_contains_Object ( ) { System . err . println ( \"test contains(Object)\" ) ; for ( Map . Entry < java . util . List < String > , List < String > > e : examples . entrySet ( ) ) { java . util . List < String > ref = e . getKey ( ) ; List < String > l = e . getValue ( ) ; boolean expect = ref . contains ( \"1\" ) ; boolean found = l . contains ( \"1\" ) ; if ( expect != found ) throw new AssertionError ( ) ; } } void test_contains_All ( ) { System . err . println ( \"test containsAll()\" ) ; for ( Map . Entry < java . util . List < String > , List < String > > e : examples . entrySet ( ) ) { java . util . List < String > ref = e . getKey ( ) ; List < String > l = e . getValue ( ) ; for ( java . util . List < String > arg : examples . keySet ( ) ) { boolean expect = ref . containsAll ( arg ) ; boolean found = l . containsAll ( arg ) ; if ( expect != found ) throw new AssertionError ( ) ; } } } void test_equals_Object ( ) { System . err . println ( \"test equals(Object)\" ) ; for ( Map . Entry < java . util . List < String > , List < String > > e : examples . entrySet ( ) ) { java . util . List < String > ref = e . getKey ( ) ; List < String > l = e . getValue ( ) ; for ( java . util . List < String > arg : examples . keySet ( ) ) { boolean expect = ref . equals ( arg ) ; boolean found = l . equals ( arg ) ; if ( expect != found ) { System . err . println ( \"ref: \" + ref ) ; System . err . println ( \"l: \" + l ) ; System . err . println ( \"arg: \" + arg ) ; System . err . println ( \"expect: \" + expect + \", found: \" + found ) ; throw new AssertionError ( ) ; } } } } void test_get_int ( ) { System", "gt": ". err . println ( \"test get(int)\" ) ;", "prediction": ". err . println ( \"test getInt()\" ) ;\n", "label": 0}
{"id": 14747, "input": "<s> package org . fuzzydb . client ; import org . fuzzydb . core . exceptions . ArchException ; public interface Transaction extends DataOperations , Authority , Helper { void commit ( ) ; void dispose ( ) ;", "gt": "Store getStore ( ) ;", "prediction": "}\n", "label": 1}
{"id": 8126, "input": "<s> package org . ofbiz . oagis ; import java . io . IOException ; import java . sql . Timestamp ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . product . product . ProductWorker ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class OagisInventoryServices { public static final String module = OagisInventoryServices . class . getName ( ) ; public static final String resource = \"OagisUiLabels\" ; public static final Double doubleZero = new Double ( 0.0 ) ; public static final Double doubleOne = new Double ( 1.0 ) ; public static final String syncInventoryFacilityId = UtilProperties . getPropertyValue ( \"oagis.properties\" , \"Oagis.Warehouse.SyncInventoryFacilityId\" ) ; public static Map < String , Object > oagisReceiveSyncInventory ( DispatchContext ctx , Map < String , Object > context ) { Document doc = ( Document ) context . get ( \"document\" ) ; boolean isErrorRetry = Boolean . TRUE . equals ( context . get ( \"isErrorRetry\" ) ) ; Delegator delegator =", "gt": "ctx . getDelegator ( ) ;", "prediction": "null ;\n", "label": 0}
{"id": 14754, "input": "<s> package org . restlet . example . ext . jaxrs . employees ; public abstract class AbstractEmployee { private Integer staffNo ; private String firstname ; private String lastname ; public String getFirstname ( ) { return this . firstname ; } public String getLastname ( ) { return this . lastname ; } public Integer getStaffNo ( ) { return this . staffNo ; }", "gt": "public void setFirstname ( String firstname )", "prediction": "public String getFirstname ( )\n", "label": 1}
{"id": 956, "input": "<s> package com . gisgraphy . client . impl . resultparser ; import org . springframework . core . io . InputStreamSource ; public interface FullTextQueryResultParser { public Iterable < FullTextQueryResult > parse", "gt": "( InputStreamSource iss ) throws ParsingException ;", "prediction": "( InputStream source )\n", "label": 0}
{"id": 14769, "input": "<s> import java . util . * ; public class G { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int rH = in . nextInt ( ) ; int rV = in . nextInt ( ) ; int sH = in . nextInt ( ) ; int sV = in . nextInt ( ) ; Screen toBuild = new Screen ( rH , rV , sH , sV ) ; int screenCount = in . nextInt ( ) ; ArrayList < Screen > screens = new ArrayList < Screen > ( screenCount ) ; for ( int i = 0 ; i < screenCount ; ++ i ) { rH = in . nextInt ( ) ; rV = in . nextInt ( ) ; sH = in . nextInt ( ) ; sV = in . nextInt ( ) ; int price = in . nextInt ( ) ; screens . add ( new Screen ( rH , rV , sH , sV , price ) ) ; screens . add ( new Screen ( rV , rH , sV , sH , price ) ) ; } int minPrice = Integer . MAX_VALUE ; for ( Screen s : screens ) { int resV = NumScreens ( toBuild . rV , s . rV ) ; int sizeV = NumScreens ( toBuild . sV , s . sV ) ; int needV = Math . max ( resV , sizeV ) ; int resH = NumScreens ( toBuild . rH , s . rH ) ; int sizeH = NumScreens ( toBuild . sH , s . sH ) ; int needH = Math . max ( resH , sizeH ) ; int price = needH * needV * s . price ; minPrice = Math . min ( price , minPrice ) ; } System . out . println ( minPrice ) ; } static int NumScreens ( int buildS , int gS ) { int screens = ( buildS % gS == 0 ) ? ( buildS / gS ) : ( buildS / gS + 1 ) ; return screens ; } private static class Screen { public int rH ; public int rV ; public int sH ; public int sV ; public int price ; public Screen ( int rH , int rV , int sH , int sV ) { this . rH = rH ; this . rV = rV ; this . sH = sH ; this . sV = sV ; this . price = 0 ; } public Screen ( int rH , int rV , int sH , int sV , int price ) { this . rH = rH ;", "gt": "this . rV = rV ;", "prediction": "this . rV = rV ;\n", "label": 1}
{"id": 3901, "input": "<s> package com . redhat . ceylon . tools . help ; import org . tautua . markdownpapers . ast . Node ; import com . redhat . ceylon . common . tool . ArgumentModel ; import com . redhat . ceylon . common . tool . OptionModel ; import com . redhat . ceylon . common . tool . SubtoolModel ; import com . redhat . ceylon . common . tool . WordWrap ; import com . redhat . ceylon . common . tool . OptionModel . ArgumentType ; import com . redhat . ceylon . tools . help . model . DescribedSection ; import com . redhat . ceylon . tools . help . model . Doc ; import com . redhat . ceylon . tools . help . model . Option ; import com . redhat . ceylon . tools . help . model . OptionsSection ; import com . redhat . ceylon . tools . help . model . SynopsesSection ; import com . redhat . ceylon . tools . help . model . Synopsis ; import com . redhat . ceylon . tools . help . model . Synopsis . NameAndSubtool ; import com . redhat . ceylon . tools . help . model . Visitor ; public class PlainVisitor implements Visitor { private final WordWrap out ; private int numOptions ; private String ceylonName ; boolean hadFirstArgument = false ; private boolean hadOptions ; PlainVisitor ( WordWrap wrap ) { this . out = wrap ; } private void markdown ( Node doc ) { PlaintextMarkdownVisitor markdownVisitor = new PlaintextMarkdownVisitor ( out ) ; doc . accept ( markdownVisitor ) ; } @ Override public void start ( Doc doc ) { ceylonName = doc . getInvocation ( ) ; } @ Override public void end ( Doc doc ) { out . flush ( ) ; } @ Override public void visitAdditionalSection ( DescribedSection describedSection ) { describedSection ( describedSection ) ; } private void describedSection ( DescribedSection describedSection ) { markdown ( describedSection . getTitle ( ) ) ; markdown ( describedSection . getDescription ( ) ) ; out . setIndent ( 0 ) ; out . newline ( ) ; } @ Override public void startOptions ( OptionsSection optionsSection ) { out . append ( optionsSection . getTitle ( ) . toUpperCase ( ) ) . newline ( ) . newline ( ) ; out . setIndent ( 8 ) ; } @ Override public void visitOption ( Option option ) { String shortName = option . getShortName ( ) ; String longName = option . getLongName ( ) ; String argumentName = option . getArgumentName ( ) ; ArgumentType argumentType = option . getOption ( ) . getArgumentType ( ) ; numOptions ++ ; out . append ( longName ) ; if ( argumentType == ArgumentType . OPTIONAL ) { out . append ( \"[\" ) ; } if ( argumentType != ArgumentType . NOT_ALLOWED ) { out . append ( \"=<\" + argumentName + \">\" ) ; } if ( argumentType == ArgumentType . OPTIONAL ) { out . append ( \"]\" ) ; } if ( shortName != null ) { out . append ( \", \" ) ; out . append ( shortName ) ; if ( argumentType != ArgumentType . NOT_ALLOWED ) { out . append ( \" \" ) ; if ( argumentType == ArgumentType . OPTIONAL ) { out . append ( \"[\" ) ; } out . append ( \"<\" + argumentName + \">\" ) ; if ( argumentType == ArgumentType . OPTIONAL ) { out . append ( \"]\" ) ; } } } out . setIndent ( 12 ) ; out . newline ( ) ; markdown ( option . getDescription ( ) ) ; out . newline ( ) ; out . setIndent ( 8 ) ; } @ Override public void endOptions ( OptionsSection optionsSection ) { if ( numOptions == 0 ) { out . append ( ceylonName + \" has no options\" ) . newline ( ) ; } out . setIndent ( 0 ) ; out . newline ( ) ; } @ Override public void visitSummary ( DescribedSection summarySection ) { describedSection ( summarySection ) ; } @ Override public void startSynopses ( SynopsesSection synopsesSection ) { out . append ( synopsesSection . getTitle ( ) . toUpperCase ( ) ) . newline ( ) . newline ( ) ; out . setIndent ( 8 ) ; } private String multiplicity ( ArgumentModel < ? > argument , String name ) { name = \"<\" + name + \">\" ; if ( argument . getMultiplicity ( )", "gt": ". isMultivalued ( ) )", "prediction": "> 0 )\n", "label": 0}
{"id": 14770, "input": "<s> package org . apache . lucene . analysis . ru ; import org . apache . lucene . util . LuceneTestCase ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . util . ArrayList ; public class TestRussianStem extends LuceneTestCase { private ArrayList words = new ArrayList ( ) ; private ArrayList stems = new ArrayList ( ) ; public TestRussianStem ( String name ) { super ( name ) ; } protected void setUp ( ) throws Exception { super . setUp ( ) ; String str ; File dataDir = new File ( System . getProperty ( \"dataDir\" , \"./bin\" ) ) ; BufferedReader inWords = new BufferedReader ( new InputStreamReader ( new FileInputStream ( new File ( dataDir , \"/org/apache/lucene/analysis/ru/wordsUTF8.txt\" ) ) , \"UTF-8\" ) ) ; while ( ( str = inWords . readLine ( ) ) != null ) { words . add ( str ) ; } inWords . close ( ) ; BufferedReader inStems = new BufferedReader ( new InputStreamReader ( new FileInputStream ( new File ( dataDir , \"/org/apache/lucene/analysis/ru/stemsUTF8.txt\"", "gt": ") ) , \"UTF-8\" ) ) ;", "prediction": ") ) , \"UTF-8\" ) ) ;\n", "label": 1}
{"id": 27, "input": "<s> package org . ofbiz . product . test ; import java . math . BigDecimal ; import java . util . Map ; import javolution . util . FastMap ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . service . testtools . OFBizTestCase ; public class InventoryItemTransferTest extends OFBizTestCase { protected GenericValue userLogin = null ; protected static String inventoryTransferId = null ; protected BigDecimal transferQty = BigDecimal . ONE ; public InventoryItemTransferTest ( String name ) { super ( name ) ; } @ Override protected void setUp ( ) throws Exception { userLogin = delegator . findOne ( \"UserLogin\" , UtilMisc . toMap ( \"userLoginId\" , \"system\" ) , false ) ; } @ Override protected void tearDown ( ) throws Exception { } public void testCreateInventoryItemsTransfer ( ) throws Exception { Map < String , Object > ctx = FastMap . newInstance ( ) ; String statusId = \"IXF_REQUESTED\" ; String inventoryItemId = \"9005\" ; ctx . put ( \"inventoryItemId\" , inventoryItemId ) ; ctx . put ( \"statusId\" , statusId ) ; ctx . put ( \"facilityId\" , \"WebStoreWarehouse\" ) ; ctx . put ( \"facilityIdTo\" , \"WebStoreWarehouse\" ) ; ctx . put ( \"receiveDate\" , UtilDateTime . nowTimestamp ( ) ) ; ctx . put ( \"xferQty\" , transferQty ) ; ctx . put ( \"userLogin\" , userLogin ) ; Map < String , Object > resp = dispatcher . runSync ( \"createInventoryTransfer\" , ctx ) ; inventoryTransferId = ( String ) resp . get ( \"inventoryTransferId\" ) ; assertNotNull ( inventoryTransferId ) ; } public void testUpdateInventoryItemTransfer ( ) throws Exception { Map < String , Object > ctx = FastMap . newInstance ( ) ; String statusId = \"IXF_COMPLETE\" ; ctx . put ( \"inventoryTransferId\" , inventoryTransferId ) ; String inventoryItemId = delegator . findOne ( \"InventoryTransfer\" , UtilMisc . toMap ( \"inventoryTransferId\" , inventoryTransferId ) , false ) . getString ( \"inventoryItemId\" ) ; ctx . put ( \"inventoryItemId\" , inventoryItemId ) ; ctx . put ( \"statusId\" , statusId ) ; ctx . put", "gt": "( \"userLogin\" , userLogin ) ;", "prediction": "( \"facilityId\" , \"WebStoreWarehouse\" ) ;\n", "label": 0}
{"id": 14773, "input": "<s> package ru . spbstu . telematics . objectCatalog ; import java . io . IOException ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class DeleteFamilyServlet extends HttpServlet { ObjectCatalog catalog = new ObjectCatalog ( ) ; @ Override protected void doGet", "gt": "( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException", "prediction": "( )\n", "label": 1}
{"id": 808, "input": "<s> public class NestedFinallyReturn { public static void main ( String [ ] argv ) { try { Object o = new Object ( ) { public String toString ( ) { try { return \"Hi\" ; } finally { System . out . println ( \"nestedFinally\" ) ; } } } ; } finally { System", "gt": ". out . println ( \"outerFinally\" ) ;", "prediction": ". exit ( 0 ) ;\n", "label": 0}
{"id": 14785, "input": "<s> package org . eclipse . ui . internal . forms . widgets ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . eclipse . swt . SWT ; import org . eclipse . ui . forms . HyperlinkSettings ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class FormTextModel { public class ParseErrorHandler implements ErrorHandler { public void error ( SAXParseException arg0 ) throws SAXException { } public void fatalError ( SAXParseException arg0 ) throws SAXException { } public void warning ( SAXParseException arg0 ) throws SAXException { } } private static final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; private boolean whitespaceNormalized = true ; private Vector paragraphs ; private IFocusSelectable [ ] selectableSegments ; private int selectedSegmentIndex = - 1 ; private int savedSelectedLinkIndex = - 1 ; private HyperlinkSettings hyperlinkSettings ; public static final String BOLD_FONT_ID = \"f.____bold\" ; public FormTextModel ( ) { reset ( ) ; } public Paragraph [ ] getParagraphs ( ) { if ( paragraphs == null ) return new Paragraph [ 0 ] ; return ( Paragraph [ ] ) paragraphs . toArray ( new Paragraph [ paragraphs . size ( ) ] ) ; } public String getAccessibleText ( ) { if ( paragraphs == null ) return \"\" ; StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < paragraphs . size ( ) ; i ++ ) { Paragraph paragraph = ( Paragraph ) paragraphs . get ( i ) ; String text = paragraph . getAccessibleText ( ) ; sbuf . append ( text ) ; } return sbuf . toString ( ) ; } public void parseTaggedText ( String taggedText , boolean expandURLs ) { if ( taggedText == null ) { reset ( ) ; return ; } try { InputStream stream = new ByteArrayInputStream ( taggedText . getBytes ( \"UTF8\" ) ) ; parseInputStream ( stream , expandURLs ) ; } catch ( UnsupportedEncodingException e ) { SWT . error ( SWT . ERROR_UNSUPPORTED_FORMAT , e ) ; } } public void parseInputStream ( InputStream is , boolean expandURLs ) { documentBuilderFactory . setNamespaceAware ( true ) ; documentBuilderFactory . setIgnoringComments ( true ) ; reset ( ) ; try { DocumentBuilder parser = documentBuilderFactory . newDocumentBuilder ( ) ; parser . setErrorHandler ( new ParseErrorHandler ( ) ) ; InputSource source = new InputSource ( is ) ; Document doc = parser . parse ( source ) ; processDocument ( doc , expandURLs ) ; } catch ( ParserConfigurationException e ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT , e , \" \" + e . getMessage ( ) ) ; } catch ( SAXException e ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT , e , \" \" + e . getMessage ( ) ) ; } catch ( IOException e ) { SWT . error ( SWT . ERROR_IO , e ) ; } } private void processDocument ( Document doc , boolean expandURLs ) { Node root = doc . getDocumentElement ( ) ; NodeList children = root . getChildNodes ( ) ; processSubnodes ( paragraphs , children , expandURLs ) ; } private void processSubnodes ( Vector plist , NodeList children , boolean expandURLs ) { for", "gt": "( int i = 0 ;", "prediction": "( int i = 0 ;\n", "label": 1}
{"id": 2230, "input": "<s> package org . apache . giraph . examples ; import com . google . common . base . Preconditions ; import org . apache . giraph . graph . WorkerContext ; import com . google . common . collect . Maps ; import org . apache . giraph . graph . BasicVertex ; import org . apache . giraph . graph . BspUtils ; import org . apache . giraph . graph . GiraphJob ; import org . apache . giraph . graph . EdgeListVertex ; import org . apache . giraph . graph . Edge ; import org . apache . giraph . graph . VertexReader ; import org . apache . giraph . graph . VertexWriter ; import org . apache . giraph . lib . TextVertexInputFormat ; import org . apache . giraph . lib . TextVertexInputFormat . TextVertexReader ; import org . apache . giraph . lib . TextVertexOutputFormat ; import org . apache . giraph . lib . TextVertexOutputFormat . TextVertexWriter ; import org . apache . hadoop . conf . Configuration ; import org . apache . hadoop . fs . Path ; import org . apache . hadoop . io . DoubleWritable ; import org . apache . hadoop . io . FloatWritable ; import org . apache . hadoop . io . LongWritable ; import org . apache . hadoop . io . ArrayWritable ; import org . apache . hadoop . io . Writable ; import org . apache . giraph . examples . LongArrayWritable ; import org . apache . hadoop . io . Text ; import org . apache . hadoop . mapreduce . InputSplit ; import org . apache . hadoop . mapreduce . RecordReader ; import org . apache . hadoop . mapreduce . RecordWriter ; import org . apache . hadoop . mapreduce . TaskAttemptContext ; import org . apache . hadoop . mapreduce . lib . input . FileInputFormat ; import org . apache . hadoop . mapreduce . lib . output . FileOutputFormat ; import org . apache . hadoop . util . Tool ; import org . apache . hadoop . util . ToolRunner ; import org . apache . log4j . Logger ; import org . json . JSONArray ; import org . json . JSONException ; import java . io . IOException ; import java . util . Iterator ; import java . util . Map ; import java . util . List ; import java . util . ArrayList ; public class GlobalClusteringCoefficientVertex extends EdgeListVertex < LongWritable , DoubleWritable , FloatWritable , LongArrayWritable > implements Tool { private Configuration conf ; private static final Logger LOG = Logger . getLogger ( GlobalClusteringCoefficientVertex . class ) ; public static String SOURCE_ID = \"GlobalClusteringCoefficientVertex.sourceId\" ; public static long SOURCE_ID_DEFAULT = 1 ; private List < String > triangles = new ArrayList < String > ( ) ; private boolean isSource ( ) { return ( getVertexId ( ) . get ( ) == getContext ( ) . getConfiguration ( ) . getLong ( SOURCE_ID , SOURCE_ID_DEFAULT ) ) ; } @ Override public void compute ( Iterator < LongArrayWritable > msgIterator ) { DoubleSumAggregator trianglesum = ( DoubleSumAggregator ) getAggregator ( \"trianglesum\" ) ; DoubleSumAggregator triples = ( DoubleSumAggregator ) getAggregator ( \"triples\" ) ; if ( getSuperstep ( ) == 0 ) { List < LongWritable > verticesl = new ArrayList < LongWritable > ( ) ; verticesl . add ( getVertexId ( ) ) ; for ( LongWritable targetVertexId : this ) { if ( targetVertexId . get ( ) < getVertexId ( ) . get ( ) ) { verticesl . add ( targetVertexId ) ; } } LongWritable [ ] verticesa = verticesl . toArray ( new LongWritable [ 0 ] ) ; LongArrayWritable vertices = new LongArrayWritable ( verticesa ) ; for ( LongWritable targetVertexId : this ) { if ( targetVertexId . get ( ) > getVertexId ( ) . get ( ) ) { sendMsg ( targetVertexId , vertices ) ; } } } else if ( getSuperstep ( ) == 1 ) { while ( msgIterator . hasNext ( ) ) { LongArrayWritable law = msgIterator . next ( ) ; Writable [ ] vertices = law . get ( ) ; LongWritable source = ( LongWritable ) vertices [ 0 ] ; for ( int i = 1 ; i < vertices . length ; i ++ ) { if ( hasEdge ( ( LongWritable ) vertices [ i ] ) ) { double num = getVertexValue ( ) . get ( ) ; setVertexValue ( new DoubleWritable ( 1.0 + num ) ) ; LongWritable [ ] one = new LongWritable [ ] { new LongWritable ( 1 ) } ; LongArrayWritable inc = new LongArrayWritable ( one ) ; sendMsg", "gt": "( source , inc ) ;", "prediction": "( one , vertices ) ;\n", "label": 0}
{"id": 14788, "input": "<s> package org . eclipse . ui ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . window . IShellProvider ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Cursor ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . internal . InternalSaveable ; import org . eclipse . ui . internal . PartSite ; import org . eclipse . ui . progress . IJobRunnable ; public abstract class Saveable extends InternalSaveable implements IAdaptable { private Cursor waitCursor ; private Cursor originalCursor ; public boolean show ( IWorkbenchPage page ) { if ( page == null ) { } return false ; } public abstract String getName ( ) ; public abstract String getToolTipText ( ) ; public abstract ImageDescriptor getImageDescriptor ( ) ; public abstract void doSave ( IProgressMonitor monitor ) throws CoreException ; public abstract boolean isDirty ( ) ; public abstract boolean equals ( Object object ) ; public abstract int hashCode ( ) ; public IJobRunnable doSave ( IProgressMonitor monitor , IShellProvider shellProvider ) throws CoreException { doSave ( monitor ) ; return null ; } public void disableUI ( IWorkbenchPart [ ] parts , boolean closing ) { for ( int i = 0 ; i < parts . length ; i ++ ) { IWorkbenchPart workbenchPart = parts [ i ] ; Composite paneComposite = ( Composite ) ( ( PartSite ) workbenchPart . getSite ( ) ) . getPane ( ) . getControl ( ) ; Control [ ] paneChildren = paneComposite . getChildren ( ) ; Composite toDisable = ( ( Composite ) paneChildren [ 0 ] ) ; toDisable . setEnabled ( false ) ; if ( waitCursor == null ) { waitCursor = new Cursor ( workbenchPart . getSite ( ) . getWorkbenchWindow ( ) . getShell ( ) . getDisplay ( ) , SWT . CURSOR_WAIT ) ; } originalCursor = paneComposite . getCursor ( ) ; paneComposite . setCursor ( waitCursor ) ; } } public void enableUI ( IWorkbenchPart [ ] parts ) { for ( int i = 0 ; i < parts . length ; i ++ ) { IWorkbenchPart workbenchPart = parts [ i ] ; Composite paneComposite = ( Composite ) ( ( PartSite ) workbenchPart . getSite ( ) ) . getPane ( ) . getControl ( ) ; Control [ ] paneChildren = paneComposite . getChildren ( ) ; Composite toEnable = ( ( Composite ) paneChildren [ 0 ] ) ; paneComposite . setCursor ( originalCursor ) ; if ( waitCursor != null && ! waitCursor . isDisposed ( ) ) { waitCursor . dispose ( ) ; waitCursor = null ; } toEnable", "gt": ". setEnabled ( true ) ;", "prediction": ". setEnabled ( false ) ;\n", "label": 1}
{"id": 3484, "input": "<s> package org . ofbiz . birt . report . servlet ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . eclipse . birt . core . exception . BirtException ; import org . eclipse . birt . report . context . IContext ; import org . eclipse . birt . report . service . BirtReportServiceFactory ; import org . eclipse . birt . report . service . ReportEngineService ; import org . eclipse . birt . report . servlet . ViewerServlet ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . birt . BirtWorker ; import org . ofbiz . birt . report . context . OFBizBirtContext ; @ SuppressWarnings ( \"serial\" ) public class BirtViewerServlet extends ViewerServlet { public final static String module = BirtViewerServlet . class", "gt": ". getName ( ) ;", "prediction": ";\n", "label": 0}
{"id": 14792, "input": "<s> package groups ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . prefs . BackingStoreException ; import org . ini4j . InvalidFileFormatException ; import actors . Actor ; abstract public class ActorGroup < T extends Actor > extends ArrayList < T > { protected Inventory inventory = new Inventory ( ) ; abstract public void loadFromFile ( File file ) throws InvalidFileFormatException , IOException , BackingStoreException , FileNotFoundException ; public void setInventory ( Inventory i ) { inventory = i ; } public Inventory getInventory ( ) { return inventory ; } public int getAlive ( ) { int counter = 0 ; for ( T a : this ) if ( a . getAlive ( ) ) counter ++ ; return counter ; } public Actor [ ] getAliveMembers ( ) { List < Actor > alive = new ArrayList <", "gt": "Actor > ( ) ;", "prediction": "Actor > ( ) ;\n", "label": 1}
{"id": 4060, "input": "<s> package org . ofbiz . pos . device . impl ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . math . BigDecimal ; import java . net . URL ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . List ; import java . util . Map ; import javolution . util . FastMap ; import jpos . JposException ; import jpos . POSPrinter ; import jpos . POSPrinterConst ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilURL ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . pos . PosTransaction ; import org . ofbiz . pos . device . GenericDevice ; import org . ofbiz . pos . screen . DialogCallback ; import org . ofbiz . pos . screen . PosDialog ; import org . ofbiz . pos . screen . PosScreen ; public class Receipt extends GenericDevice implements DialogCallback { public static final String module = Receipt . class . getName ( ) ; protected static final String ESC = ( ( char ) 0x1b ) + \"\" ; protected static final String LF = ( ( char ) 0x0a ) + \"\" ; protected static final String ALIGN_CENTER = ESC + \"|cA\" ; protected static final String ALIGN_RIGHT = ESC + \"|rA\" ; protected static final String TEXT_DOUBLE_HEIGHT = ESC + \"|4C\" ; protected static final String TEXT_UNDERLINE = ESC + \"|uC\" ; protected static final String TEXT_BOLD = ESC + \"|bC\" ; protected static final String PAPER_CUT = ESC + \"|100fP\" ; protected SimpleDateFormat [ ] dateFormat = null ; protected String [ ] storeReceiptTmpl = null ; protected String [ ] custReceiptTmpl = null ; protected Map < String , Object > reportTmpl = FastMap . newInstance ( ) ; protected static final String [ ] dateFmtStr = { \"EEE, d MMM yyyy HH:mm:ss z\" , \"EEE, d MMM yyyy HH:mm:ss z\" , \"EEE, d MMM yyyy HH:mm:ss z\" } ; protected static final int [ ] priceLength = { 7 , 7 , 7 } ; protected static final int [ ] qtyLength = { 5 , 5 , 5 } ; protected static final int [ ] descLength = { 25 , 25 , 0 } ; public static final int [ ] pridLength = { 25 , 25 , 0 } ; protected static final int [ ] infoLength = { 34 , 34 , 0 } ; protected static final int [ ] configPaddingLength = { 2 , 2 , 2 } ; protected static final String [ ] configPadding = { \"  \" , \"  \" , \"  \" } ; protected PosTransaction lastTransaction = null ; public Receipt ( String deviceName , int timeout ) { super ( deviceName , timeout ) ; this . control = new jpos . POSPrinter ( ) ; } @ Override protected void initialize ( ) throws JposException { Debug . logInfo ( \"Receipt [\" + control . getPhysicalDeviceName ( ) + \"] Claimed : \" + control . getClaimed ( ) , module ) ; ( ( jpos . POSPrinter ) control ) . setMapMode ( POSPrinterConst . PTR_MM_METRIC ) ; } public void println ( ) { this . println ( \"\" ) ; } public void println ( String p ) { try { ( ( POSPrinter ) control ) . printNormal ( POSPrinterConst . PTR_S_RECEIPT , p + LF ) ; } catch ( jpos . JposException e ) { Debug . logError ( e , module ) ; } } public void printBarcode ( String barcode ) { try { ( ( POSPrinter ) control ) . printBarCode ( POSPrinterConst . PTR_S_RECEIPT , barcode , POSPrinterConst . PTR_BCS_Code39 , 10 * 100 , 60 * 100 , POSPrinterConst . PTR_BC_CENTER , POSPrinterConst . PTR_BC_TEXT_NONE ) ; } catch ( JposException e ) { Debug . logError ( e , module ) ; } } public synchronized void printReport ( PosTransaction trans , String resource , Map < String , String > context ) { try { ( ( POSPrinter ) control ) . transactionPrint ( POSPrinterConst . PTR_S_RECEIPT , POSPrinterConst . PTR_TP_TRANSACTION ) ; } catch ( JposException e ) { Debug . logError ( e , \"Exception while setting jpos.POSPrinter.transactionPrint to transaction mode \" , module ) ; } Debug . logInfo ( \"Print Report Requested\" , module ) ; String [ ] report = this . readReportTemplate ( resource ) ; if ( report != null ) { for ( int i = 0 ; i < report . length ; i ++ ) { if ( report [ i ] != null ) { this . printInfo ( report [ i ] , context , trans , 2 ) ; } } this . println ( ) ; this . println ( ) ; this . println ( PAPER_CUT ) ; } try { ( ( POSPrinter ) control ) . transactionPrint ( POSPrinterConst . PTR_S_RECEIPT , POSPrinterConst . PTR_TP_NORMAL ) ; } catch ( JposException e ) { Debug . logError ( e , \"Exception while setting jpos.POSPrinter.transactionPrint to normal mode \" , module ) ; } } public void reprintReceipt ( ) { this . reprintReceipt ( false ) ; } public void reprintReceipt ( boolean reprintStoreCopy ) { if ( lastTransaction != null ) { this . printReceipt ( lastTransaction , reprintStoreCopy ) ; } } public void printReceipt ( PosTransaction trans , boolean printStoreCopy ) { Debug . logInfo ( \"Print Receipt Requested : \" + trans . getTransactionId ( ) , module ) ; POSPrinter printer = ( POSPrinter ) control ; this . lastTransaction = trans ; try { if ( ! checkState ( printer ) ) { return ; } } catch ( JposException e ) { Debug . logError ( e , module ) ; } if ( printStoreCopy ) { String [ ] storeReceipt = this . readStoreTemplate ( ) ; int payments = trans . getNumberOfPayments ( ) ; for ( int i = 0 ; i < payments ; i ++ ) { Map < String , Object > info = trans . getPaymentInfo ( i ) ; if ( info", "gt": ". containsKey ( \"cardNumber\" ) )", "prediction": "!= null )\n", "label": 0}
{"id": 14795, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Mockito . mock ; import java . util . ArrayList ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . internal . widgets . ITableAdapter ; public class TableColumn_Test extends TestCase { private Display display ; private Shell shell ; public void testCreation ( ) { Table table = new Table ( shell , SWT . NONE ) ; TableColumn col1 = new TableColumn ( table , SWT . NONE ) ; assertEquals ( 1 , table . getColumnCount ( ) ) ; assertSame ( col1 , table . getColumn ( 0 ) ) ; TableColumn col0 = new TableColumn ( table , SWT . NONE , 0 ) ; assertEquals ( 2 , table . getColumnCount ( ) ) ; assertSame ( col0 , table . getColumn ( 0 ) ) ; try { new TableColumn ( table , SWT . NONE , table . getColumnCount ( ) + 8 ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testParent ( ) { Table table = new Table ( shell , SWT . NONE ) ; TableColumn column = new TableColumn ( table , SWT . NONE ) ; assertSame ( table , column . getParent ( ) ) ; try { new TableColumn ( null , SWT . NONE ) ; fail ( \"Must not allow to create TableColumn withh null-parent.\" ) ; } catch ( IllegalArgumentException iae ) { } } public void testDisplay ( ) { Table table = new Table ( shell , SWT . NONE ) ; TableColumn column = new TableColumn ( table , SWT . NONE ) ; assertSame ( display , column . getDisplay ( ) ) ; } public void testStyle ( ) { Table table = new Table ( shell , SWT . NONE ) ; TableColumn column = new TableColumn ( table , SWT . NONE ) ; assertTrue ( ( column . getStyle ( ) & SWT . LEFT ) != 0 ) ; column = new TableColumn ( table , SWT . LEFT | SWT . RIGHT | SWT . CENTER ) ; assertTrue ( ( column . getStyle ( ) & SWT . LEFT ) != 0 ) ; column = new TableColumn ( table , SWT . RIGHT ) ; assertTrue ( ( column . getStyle ( ) & SWT . RIGHT ) != 0 ) ; } public void testInitialValues ( ) { Table table = new Table ( shell , SWT . NONE ) ; TableColumn column = new TableColumn ( table , SWT . NONE ) ; assertEquals ( 0 , column . getWidth ( ) ) ; assertEquals ( \"\" , column", "gt": ". getText ( ) ) ;", "prediction": ". getHeight ( ) ) ;\n", "label": 1}
{"id": 6266, "input": "<s> package com . sun . mirror . declaration ; import java . util . Collection ; import com . sun . mirror . type . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface TypeParameterDeclaration extends Declaration {", "gt": "Collection < ReferenceType > getBounds ( ) ;", "prediction": "}\n", "label": 0}
{"id": 14800, "input": "<s> package org . restlet . test . service ; import junit . framework . Test ; import junit . framework . TestSuite ; public class ServiceTestSuite { public static Test suite ( ) { TestSuite suite = new TestSuite ( \"Service package\" ) ; suite . addTestSuite", "gt": "( ConnegServiceTestCase . class ) ;", "prediction": "( service ) ;\n", "label": 1}
{"id": 2167, "input": "<s> package jns . agent ; import jns . Simulator ; import jns . element . IPHandler ; import jns . element . IPPacket ; import jns . util . IPAddr ; import jns . util . Protocols ; import jns . util . Queue ; import java . util . Enumeration ; import java . util . Hashtable ; public class SimpleGoBackN implements CL_Agent { private Hashtable m_ports ; private CL_Agent m_ip ; public SimpleGoBackN ( ) { m_ports = new Hashtable ( ) ; } public SimpleGoBackNAgent createNewAgent ( int local_port ) { SimpleGoBackNAgent newagent = new SimpleGoBackNAgent ( local_port ) ; attach ( newagent , local_port ) ; return newagent ; } public void attach ( Agent higher_level , int unique_id ) { if ( ! ( higher_level instanceof SimpleGoBackNAgent ) ) Simulator . error ( \"SimpleGoBackN can only attach SimpleGoBackNAgent\" ) ; if ( m_ports . get ( new Integer ( unique_id ) ) != null ) Simulator . error ( \"SGN can only attach one agent per port\" ) ; higher_level . attach ( this ) ; m_ports . put ( new Integer ( unique_id ) , new AgentPort ( higher_level ) ) ; } public void attach ( Agent lower_level ) { if ( ! ( lower_level instanceof IPHandler ) ) { System . out . println ( lower_level ) ; Simulator . error ( \"SGN can only run on top of IP!\" ) ; } m_ip = ( CL_Agent ) lower_level ; } public void indicate ( int status , Object indicator ) { if ( status == Agent . READY_TO_SEND ) { for ( Enumeration e = m_ports . elements ( ) ; e . hasMoreElements ( ) ; ) ( ( AgentPort ) e . nextElement ( ) ) . agent . indicate ( Agent . READY_TO_SEND , this ) ; } else if ( status == Agent . PACKET_AVAILABLE ) { IPPacket ippacket = ( IPPacket ) ( ( IPHandler ) indicator ) . read ( Protocols . SGN ) ; if ( ! ( ippacket . data instanceof SimpleGoBackNPacket ) ) Simulator . warning ( \"IP packet passed to SGN with wrong packet content\" ) ; SimpleGoBackNPacket packet = ( SimpleGoBackNPacket ) ippacket . data ; AgentPort agentport = ( AgentPort ) m_ports . get ( new Integer ( packet . destination_port ) ) ; if ( agentport == null ) { Simulator . warning ( \"SGN Packet sent to port noone's listening to\" ) ; return ; } agentport . packets . pushFront ( ippacket ) ; agentport . agent . indicate ( Agent . PACKET_AVAILABLE , this ) ; } } public boolean", "gt": "canSend ( IPAddr destination , int length )", "prediction": "hasMoreElements ( )\n", "label": 0}
{"id": 14806, "input": "<s> package org . eclipse . ui . views ; import org . eclipse . core . runtime . IPath ; public interface IViewCategory {", "gt": "IViewDescriptor [ ] getViews ( ) ;", "prediction": "}\n", "label": 1}
{"id": 3376, "input": "<s> package jns . element ; public abstract class Link extends Element { public abstract void setStatus ( int status ) ; public abstract int getStatus ( ) ; public abstract int getBandwidth ( ) ; public abstract double getDelay ( ) ; public abstract Interface getIncomingInterface ( ) ; public", "gt": "abstract Interface getOutgoingInterface ( ) ;", "prediction": "abstract boolean isIncoming ( ) ;\n", "label": 0}
{"id": 14827, "input": "<s> package com . cloudera . sqoop . mapreduce ; import org . apache . avro . Schema ; import org . apache . hadoop . conf . Configuration ; public final class AvroJob { public static final String MAP_OUTPUT_SCHEMA = org . apache . sqoop . mapreduce . AvroJob . MAP_OUTPUT_SCHEMA ; private AvroJob ( ) { } public static void setMapOutputSchema ( Configuration job , Schema s ) { org . apache . sqoop . mapreduce . AvroJob . setMapOutputSchema ( job , s ) ; }", "gt": "public static Schema getMapOutputSchema ( Configuration job )", "prediction": "}\n", "label": 1}
{"id": 8896, "input": "<s> import java . util . ArrayList ; import java . util . List ; class T6304921 { void m1 ( int i ) { switch ( i ) { case 1 : i ++ ; default : } try { i ++ ; } finally { throw new Error ( ) ; } } void m2 ( ) { List < Integer > list =", "gt": "new ArrayList ( ) ;", "prediction": "new ArrayList < Integer > ( ) ;\n", "label": 0}
{"id": 14838, "input": "<s> package org . apache . lucene . queryParser ; import java . io . IOException ; import java . io . Reader ; import java . text . Collator ; import java . text . DateFormat ; import java . util . Arrays ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . HashSet ; import java . util . Locale ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . KeywordAnalyzer ; import org . apache . lucene . analysis . LowerCaseTokenizer ; import org . apache . lucene . analysis . SimpleAnalyzer ; import org . apache . lucene . analysis . StopAnalyzer ; import org . apache . lucene . analysis . StopFilter ; import org . apache . lucene . analysis . TokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceAnalyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . analysis . tokenattributes . OffsetAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . document . DateField ; import org . apache . lucene . document . DateTools ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . FuzzyQuery ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . PhraseQuery ; import org . apache . lucene . search . PrefixQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermRangeQuery ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . WildcardQuery ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . MockRAMDirectory ; import org . apache . lucene . util . LocalizedTestCase ; import org . apache . lucene . util . Version ; public class TestQueryParser extends LocalizedTestCase { public TestQueryParser ( String name ) { super ( name , new HashSet ( Arrays . asList ( new String [ ] { \"testLegacyDateRange\" , \"testDateRange\" , \"testCJK\" , \"testNumber\" , \"testFarsiRangeCollating\" , \"testLocalDateFormat\" } ) ) ) ; } public static Analyzer qpAnalyzer = new QPTestAnalyzer ( ) ; public static class QPTestFilter extends TokenFilter { TermAttribute termAtt ; OffsetAttribute offsetAtt ; public QPTestFilter ( TokenStream in ) { super ( in ) ; termAtt = ( TermAttribute ) addAttribute ( TermAttribute . class ) ; offsetAtt = ( OffsetAttribute ) addAttribute ( OffsetAttribute . class ) ; } boolean inPhrase = false ; int savedStart = 0 , savedEnd = 0 ; public boolean incrementToken ( ) throws IOException { if ( inPhrase ) { inPhrase = false ; clearAttributes ( ) ; termAtt . setTermBuffer ( \"phrase2\" ) ; offsetAtt . setOffset ( savedStart , savedEnd ) ; return true ; } else while ( input . incrementToken ( ) ) { if ( termAtt . term ( ) . equals ( \"phrase\" ) ) { inPhrase = true ; savedStart = offsetAtt . startOffset ( ) ; savedEnd = offsetAtt . endOffset ( ) ; termAtt . setTermBuffer ( \"phrase1\" ) ; offsetAtt . setOffset ( savedStart , savedEnd ) ; return true ; } else if ( ! termAtt . term ( ) . equals ( \"stop\" ) ) return true ; } return false ; } } public static class QPTestAnalyzer extends Analyzer { public final TokenStream tokenStream ( String fieldName , Reader reader ) { return new QPTestFilter ( new LowerCaseTokenizer ( reader ) ) ; } } public static class QPTestParser extends QueryParser { public QPTestParser ( String f , Analyzer a ) { super", "gt": "( f , a ) ;", "prediction": "( f , a ) ;\n", "label": 1}
{"id": 2901, "input": "<s> package org . parboiled . transform ; import org . parboiled . BaseParser ; import org . parboiled . Rule ; import org . parboiled . support . Var ; import org . parboiled . annotations . * ; import static java . lang . Integer . parseInt ; import static org . parboiled . common . StringUtils . isEmpty ; @ SuppressWarnings ( { \"UnusedDeclaration\" } ) @ BuildParseTree class TestParser extends BaseParser < Integer > { protected int integer ; private int privateInt ; public Rule RuleWithoutAction ( ) { return Sequence ( 'a' , 'b' ) ; } @ Label ( \"harry\" ) public Rule RuleWithNamedLabel ( ) { return Sequence ( 'a' , 'b' ) ; } @ SuppressNode public Rule RuleWithLeaf ( ) { return Sequence ( 'a' , 'b' ) ; } public Rule RuleWithDirectImplicitAction ( ) { return Sequence ( 'a' , integer == 0 , 'b' , 'c' ) ; } public Rule RuleWithIndirectImplicitAction ( ) { return Sequence ( 'a' , 'b' , action ( ) || integer == 5 ) ; } public Rule RuleWithDirectExplicitAction ( ) { return Sequence ( 'a' , ACTION ( action ( ) && integer > 0 ) , 'b' ) ; } public Rule RuleWithIndirectExplicitAction ( ) { return Sequence ( 'a' , 'b' , ACTION ( integer < 0 && action ( ) ) ) ; } public Rule RuleWithIndirectImplicitParamAction ( int param ) { return Sequence ( 'a' , 'b' , integer == param ) ; } public Rule RuleWithComplexActionSetup ( int param ) { int i = 26 , j = 18 ; Var < String > string = new Var < String > ( \"text\" ) ; i += param ; j -= i ; return Sequence ( 'a' + i , i > param + j , string , ACTION ( integer + param < string . get ( ) . length ( ) - i - j ) ) ; } public Rule BugIn0990 ( ) { Var < Integer > var = new Var < Integer > ( ) ; return FirstOf ( \"10\" , \"2\" ) ; } @ DontLabel public Rule RuleWith2Returns ( int param ) { if ( param == integer ) { return Sequence ( 'a' , ACTION ( action ( ) ) ) ; } else { return EOI ; } } @ DontLabel public Rule RuleWithSwitchAndAction ( int param ) { switch ( param ) { case 0 :", "gt": "return Sequence ( EMPTY , push ( 1 ) ) ;", "prediction": "return Sequence ( 'a' , action ( ) ) ;\n", "label": 0}
{"id": 14845, "input": "<s> package org . powerbot . game . api . wrappers . widget ; import java . awt . Point ; import java . awt . Rectangle ; import java . util . Arrays ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Identifiable ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSInterface ; import org . powerbot . game . client . RSInterfaceBase ; public class Widget implements Identifiable { private WidgetChild [ ] childCache = new WidgetChild [ 0 ] ; private final Object CACHE_LOCK = new Object ( ) ; private final int index ; public Widget ( final int index ) { this . index = index ; } public boolean validate ( ) { if ( getChildrenInternal ( ) == null ) { return false ; } final int idx = getIndex ( ) ; final Client client = Context . client ( ) ; final boolean [ ] validArray = client . getValidRSInterfaceArray ( ) ; if ( idx >= 0 && validArray != null && idx < validArray . length && validArray [ idx ] ) { final Object [ ] inters = client . getRSInterfaceCache ( ) ; if ( idx < inters . length && inters [ idx ] != null ) { final WidgetChild [ ] children = getChildren ( ) ; int count = 0 ; for ( final WidgetChild child : children ) { if ( child . getBoundsArrayIndex ( ) == - 1 ) { ++ count ; } } return count != children . length ; } } return false ; } public int getChildrenCount ( ) { final Object [ ] children = getChildrenInternal ( ) ; if ( children != null ) { return children . length ; } return 0 ; } public String getText ( ) { final StringBuilder sb = new StringBuilder ( ) ; final Object [ ] children = getChildrenInternal ( ) ; if ( children != null ) { for ( final Object child : children ) { String string ; if ( child != null && ( string = ( String ) ( ( RSInterface ) child ) . getText ( ) ) != null ) { sb . append ( string ) ; sb . append ( \"\\n\" ) ; } } } if ( sb . length ( ) > 1 ) { sb . setLength ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } public int getIndex ( ) { return index ; } public int getId ( ) { return index ; } public Point getLocation ( ) { final Client client = Context . client ( ) ; final Multipliers multipliers = Context . multipliers ( ) ; final Object [ ] children = getChildrenInternal ( ) ; if ( children != null ) { for ( final Object child : children ) { if ( child != null ) { final int index = ( ( RSInterface ) child ) . getBoundsArrayIndex ( ) * multipliers . INTERFACE_BOUNDSARRAYINDEX ; final Rectangle [ ] boundsArray = client . getRSInterfaceBoundsArray ( ) ; if ( index > 0 && index < boundsArray . length ) { return boundsArray [ index ] . getLocation ( ) ; } } } } return new Point ( - 1 , - 1 ) ; } public WidgetChild [ ] getChildren ( ) { synchronized ( CACHE_LOCK ) { final Object [ ] children = getChildrenInternal ( ) ; if ( children == null ) { return childCache . clone ( ) ; } else { if ( childCache . length < children . length ) { final int prevLen = childCache . length ; childCache = Arrays . copyOf ( childCache , children . length ) ; for ( int i = prevLen ; i < childCache . length ; i ++ ) { childCache [ i ] = new WidgetChild ( this , i ) ; } } return childCache . clone ( ) ; } } } public WidgetChild getChild ( final int index ) { synchronized ( CACHE_LOCK ) { final RSInterface [ ] children = getChildrenInternal ( ) ; final int ensureLen = Math . max ( children != null ? children . length : 0 , index + 1 ) ; if ( childCache . length < ensureLen ) { final int prevLen = childCache . length ; childCache =", "gt": "Arrays . copyOf ( childCache , ensureLen ) ;", "prediction": "Arrays . copyOf ( childCache , children . length ) ;\n", "label": 1}
{"id": 4139, "input": "<s> package tests ; import java . util . Collection ; import java . util . Collections ; class CompileTest2 { class Request < R extends Request < R , V > , V > { } class DeltaRequest extends Request < DeltaRequest , double [ ] > { } class RequestMap < V > { public < R extends Request < R , W > , W extends V > R test ( Collection < R > c ) { return null ; } } public void f ( ) { RequestMap < Object", "gt": "> m = new RequestMap < Object > ( ) ;", "prediction": "> c = new RequestMap < Object > ( ) ;\n", "label": 0}
{"id": 14857, "input": "<s> package org . apache . lucene . search . similar ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . util . Set ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . similar . MoreLikeThis ; public class MoreLikeThisQuery extends Query { private String likeText ; private String [ ] moreLikeFields ; private Analyzer analyzer ; float percentTermsToMatch = 0.3f ; int minTermFrequency = 1 ; int maxQueryTerms = 5 ; Set stopWords = null ; int minDocFreq = - 1 ; public MoreLikeThisQuery ( String likeText , String [ ] moreLikeFields , Analyzer analyzer ) { this . likeText = likeText ; this . moreLikeFields = moreLikeFields ; this . analyzer = analyzer ; } public Query rewrite ( IndexReader reader ) throws IOException { MoreLikeThis mlt = new MoreLikeThis ( reader ) ; mlt . setFieldNames ( moreLikeFields ) ; mlt . setAnalyzer ( analyzer ) ; mlt . setMinTermFreq ( minTermFrequency ) ; if ( minDocFreq >= 0 ) { mlt . setMinDocFreq ( minDocFreq ) ; } mlt . setMaxQueryTerms ( maxQueryTerms ) ; mlt . setStopWords ( stopWords ) ; BooleanQuery bq = ( BooleanQuery ) mlt . like ( new ByteArrayInputStream ( likeText . getBytes ( ) ) ) ; BooleanClause [ ] clauses = bq . getClauses ( ) ; bq . setMinimumNumberShouldMatch ( ( int ) ( clauses . length * percentTermsToMatch ) ) ; return bq ; } public String toString ( String field ) { return \"like:\" + likeText ; } public float getPercentTermsToMatch ( ) { return percentTermsToMatch ; } public void setPercentTermsToMatch ( float percentTermsToMatch ) { this . percentTermsToMatch = percentTermsToMatch ; } public Analyzer getAnalyzer ( ) { return analyzer ; } public void setAnalyzer ( Analyzer analyzer ) { this . analyzer = analyzer ; } public String getLikeText ( ) { return likeText ; } public void", "gt": "setLikeText ( String likeText )", "prediction": "setLikeText ( String likeText )\n", "label": 1}
{"id": 3453, "input": "<s> package P2 ; public class usePub extends P1 . pub { void bar ( ) { P1 . pubExposePriv pd = new P1 . pubExposePriv ( new P1 . pub ( ) ) ; P1 . pubExposePriv pe = new P1 . pubExposePriv ( new P1 . pub ( ) ) { } ; P1 . pubExposePriv pf = new P1 . pubExposePriv ( null ) { } ; P1 . pub", "gt": "p = new P1 . pub ( ) ;", "prediction": "ExposePriv pg = new P1 . pubExposePriv ( null )\n", "label": 0}
{"id": 14867, "input": "<s> package com . googlecode . veloeclipse . vaulttec . ui ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . net . URL ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; import java . util . StringTokenizer ; import org . eclipse . compare . CompareEditorInput ; import org . eclipse . compare . internal . Utilities ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . FileLocator ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . SWT ; import org . eclipse . swt . browser . Browser ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . plugin . AbstractUIPlugin ; import com . googlecode . veloeclipse . editor . compare . CompareDialog ; import com . googlecode . veloeclipse . preferences . GeneralPreferencePage ; import com . googlecode . veloeclipse . vaulttec . ui . editor . VelocityEditorEnvironment ; public class VelocityPlugin extends AbstractUIPlugin { private static final String STRICT40 = \"http://www.w3.org/TR/html4/strict.dtd\" ; private static final String LOOSE40 = \"http://www.w3.org/TR/html4/loose.dtd\" ; private static final String STRICTX = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\" ; public static final String PLUGIN_ID = \"com.googlecode.veloeclipse.vaulttec.ui\" ; private static VelocityPlugin fPlugin ; private static final String RESOURCE_NAME = PLUGIN_ID + \".messages\" ; private ResourceBundle fResourceBundle ; public boolean isAutoCompletionEnabled ( ) { return getDefault ( ) . getPreferenceStore ( ) . getBoolean ( GeneralPreferencePage . P_Completion ) ; } public boolean isUppercaseEnabled ( ) { return getDefault ( ) . getPreferenceStore ( ) . getBoolean ( GeneralPreferencePage . P_CASE ) ; } public VelocityPlugin ( ) { fPlugin = this ; try { fResourceBundle = ResourceBundle . getBundle ( RESOURCE_NAME ) ; } catch ( Exception e ) { log ( e ) ; fResourceBundle = null ; } } protected void initializeDefaultPluginPreferences ( ) { IPreferenceStore aStore = getPreferenceStore ( ) ; aStore . setDefault ( IPreferencesConstants . EDITOR_SHOW_SEGMENTS , false ) ; aStore . setDefault ( IPreferencesConstants . VELOCITY_COUNTER_NAME , \"velocityCount\" ) ; aStore . setDefault ( IPreferencesConstants . VELOCITY_USER_DIRECTIVES , \"\" ) ; VelocityColorProvider . initializeDefaults ( aStore ) ; } public void propertyChange ( PropertyChangeEvent anEvent ) { String prop = anEvent . getProperty ( ) ; VelocityEditorEnvironment . getColorProvider ( ) . handlePreferenceStoreChanged ( anEvent ) ; if ( prop . equals ( IPreferencesConstants . VELOCITY_USER_DIRECTIVES ) || prop . equals ( IPreferencesConstants . LIBRARY_LIST ) ) { VelocityEditorEnvironment . createVelocityParser ( ) ; } } public static List getVelocityUserDirectives ( ) { IPreferenceStore store = getDefault ( ) . getPreferenceStore ( ) ; String directives = store . getString ( IPreferencesConstants . VELOCITY_USER_DIRECTIVES ) ; StringTokenizer st = new StringTokenizer ( directives , \",\\n\\r\" ) ; ArrayList list = new ArrayList ( ) ; while ( st . hasMoreElements ( ) ) { list . add ( st . nextElement ( ) ) ; } return list ; } public static VelocityPlugin getDefault ( ) { return fPlugin ; } public static IWorkspace getWorkspace ( ) { return ResourcesPlugin . getWorkspace ( ) ; } public ResourceBundle getResourceBundle ( ) { return fResourceBundle ; } public static Shell getActiveWorkbenchShell ( ) {", "gt": "IWorkbenchWindow window = getActiveWorkbenchWindow ( ) ;", "prediction": "return Shell ;\n", "label": 1}
{"id": 8286, "input": "<s> package org . ofbiz . service . calendar ; public interface TemporalExpressionVisitor { void visit ( TemporalExpressions . DateRange expr ) ; void visit ( TemporalExpressions . DayInMonth expr ) ; void visit ( TemporalExpressions . DayOfMonthRange expr ) ; void visit ( TemporalExpressions . DayOfWeekRange expr ) ; void visit ( TemporalExpressions . Difference expr ) ; void visit ( TemporalExpressions . Frequency expr ) ; void visit ( TemporalExpressions . HourRange expr ) ; void visit (", "gt": "TemporalExpressions . Intersection expr ) ;", "prediction": "TemporalExpressions . MinuteRange expr ) ;\n", "label": 0}
{"id": 14873, "input": "<s> package org . nuxeo . ecm . platform . annotations . repository . service ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentRef ; import org . nuxeo . ecm . core . api . NuxeoPrincipal ; import org . nuxeo . ecm . core . api . event . DocumentEventTypes ; import org . nuxeo . ecm . core . api . facet . VersioningDocument ; import org . nuxeo . ecm . core . event . Event ; import org . nuxeo . ecm . core . event . EventContext ; import org . nuxeo . ecm . platform . annotations . api . Annotation ; import org . nuxeo . ecm . platform . annotations . api . AnnotationsConstants ; import org . nuxeo . ecm . platform . annotations . api . AnnotationsService ; import org . nuxeo . ecm . platform . annotations . repository . URNDocumentViewTranslator ; import org . nuxeo . ecm . platform . relations . api . Graph ; import org . nuxeo . ecm . platform . relations . api . Resource ; import org . nuxeo . ecm . platform . relations . api . Statement ; import org . nuxeo . ecm . platform . relations . api . impl . ResourceImpl ; import org . nuxeo . ecm . platform . relations . api . impl . StatementImpl ; import org . nuxeo . runtime . api . Framework ; import java . net . URI ; import java . security . Principal ; import java . util . ArrayList ; import java . util . List ; public class DocumentVersionnedGraphManager implements GraphManagerEventListener { private static final Log log = LogFactory . getLog ( DocumentVersionnedGraphManager . class ) ; private URNDocumentViewTranslator translator ; public void manage ( Event event ) { if ( translator == null ) { translator = new URNDocumentViewTranslator ( ) ; } EventContext context = event . getContext ( ) ; NuxeoPrincipal user = null ; Principal principal = context . getPrincipal ( ) ; if ( principal instanceof NuxeoPrincipal ) { user = ( NuxeoPrincipal ) principal ; } else { log . debug ( \"Discading event on a non NuxeoPrincipal user\" ) ; return ; } DocumentModel docModel = ( DocumentModel ) context . getArguments ( ) [ 0 ] ; String docId = docModel . getId ( ) ; String repo = docModel . getRepositoryName ( ) ; if ( DocumentEventTypes . DOCUMENT_CHECKEDIN . equals ( event . getName ( ) ) ) { DocumentRef versionRef = ( DocumentRef ) context . getProperty ( \"checkedInVersionRef\" ) ; copyGraphFor ( repo , docId , versionRef . toString ( ) , user ) ; } else if ( DocumentEventTypes . DOCUMENT_REMOVED . equals ( event . getName ( ) ) || DocumentEventTypes . VERSION_REMOVED . equals ( event . getName ( ) ) ) { removeGraphFor ( repo , docId , user ) ; } else if ( DocumentEventTypes . DOCUMENT_RESTORED . equals ( event . getName ( ) ) ) { String versionUUID = ( String ) context . getProperty ( VersioningDocument . RESTORED_VERSION_UUID_KEY ) ; restoreGraphFor ( repo , versionUUID , docId , user ) ; } } private void copyGraphFor ( String repositoryName , String fromId , String toId , NuxeoPrincipal principal ) { try { copyGraphFor ( translator . getNuxeoUrn ( repositoryName , fromId ) , translator . getNuxeoUrn ( repositoryName , toId ) , principal ) ; } catch ( Exception e ) { log . error ( e ) ; } } private static void copyGraphFor ( URI current , URI copied , NuxeoPrincipal user ) throws Exception { List < Statement > newStatements = new ArrayList < Statement > ( ) ; AnnotationsService service = Framework . getService ( AnnotationsService . class ) ; List < Annotation > annotations = service . queryAnnotations ( current , null , user ) ; log . debug ( \"Copying annotations graph from \" + current + \" to \" + copied + \" for \" + annotations . size ( ) + \" annotations.\" ) ; for ( Annotation annotation : annotations ) { List < Statement > statements = annotation . getStatements ( ) ; for ( Statement statement : statements ) { if ( statement . getPredicate ( ) . equals ( AnnotationsConstants . a_annotates ) ) { Resource resource = ( Resource ) statement . getObject ( ) ; if ( current . toString ( ) . equals ( resource . getUri ( ) ) ) { Statement newStatement = new StatementImpl ( statement . getSubject ( ) , statement . getPredicate ( ) , new ResourceImpl ( copied . toString ( ) ) ) ; newStatements . add ( newStatement ) ; } } } } Graph graph = service . getAnnotationGraph ( ) ; graph . add ( newStatements ) ; } private void removeGraphFor ( String repositoryName , String id , NuxeoPrincipal principal ) { try { removeGraphFor ( translator . getNuxeoUrn ( repositoryName , id ) , principal ) ; } catch ( Exception e ) { log . error ( e ) ; } } private static void removeGraphFor ( URI uri , NuxeoPrincipal user ) throws Exception { log . debug ( \"Removing annotations graph for \" + uri ) ; AnnotationsService service = Framework", "gt": ". getService ( AnnotationsService . class ) ;", "prediction": ". getService ( AnnotationsService . class ) ;\n", "label": 1}
{"id": 7670, "input": "<s> package pkg2 ; import pkg . * ; import java . util . * ; public class ClassUseTest3 < T extends ParamTest2 < List < ? extends Foo4 > > > { public ClassUseTest3 ( Set < Foo4 > p ) { } public < T extends ParamTest2 < List < ? extends Foo4 > > > ParamTest2 < List < ? extends Foo4 > > method ( T t ) { return null ; } public void method ( Set", "gt": "< Foo4 > p )", "prediction": "< Foo4 > p )\n", "label": 0}
{"id": 14881, "input": "<s> package fr . inria . zvtm . glyphs . projection ; import java . awt . Polygon ;", "gt": "public class BProjectedCoordsP extends BProjectedCoords", "prediction": "import java . awt . Point ;\n", "label": 1}
{"id": 5390, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Task ; import org . jjflyboy . tjpeditor . project . TaskPrefix ; public class TaskPrefixImpl extends IncludePropertiesAttributeImpl implements TaskPrefix { protected Task task ; protected TaskPrefixImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getTaskPrefix ( ) ; } public Task getTask ( ) { if ( task != null && task . eIsProxy ( ) ) { InternalEObject oldTask = ( InternalEObject ) task ; task = ( Task ) eResolveProxy ( oldTask ) ; if ( task != oldTask ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . TASK_PREFIX__TASK , oldTask , task ) ) ; } } return task ; } public Task basicGetTask ( ) { return task ; } public void setTask ( Task newTask ) { Task oldTask = task ; task = newTask ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage .", "gt": "TASK_PREFIX__TASK , oldTask , task ) ) ;", "prediction": "TASK_PREFIX__TASK , oldTask , task ) ) ;\n", "label": 0}
{"id": 14882, "input": "<s> package net . claribole . zgrviewer ; import java . awt . Graphics2D ; import java . awt . Color ; import java . awt . Cursor ; import java . awt . Font ; import java . awt . Point ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Vector ; import fr . inria . zvtm . engine . Camera ; import fr . inria . zvtm . engine . VCursor ; import fr . inria . zvtm . engine . View ; import fr . inria . zvtm . engine . ViewPanel ; import fr . inria . zvtm . engine . VirtualSpace ; import fr . inria . zvtm . glyphs . Glyph ; import fr . inria . zvtm . glyphs . DPath ; import fr . inria . zvtm . glyphs . VSegment ; import fr . inria . zvtm . glyphs . VImage ; import fr . inria . zvtm . glyphs . VText ; import fr . inria . zvtm . event . ViewListener ; import fr . inria . zvtm . engine . portals . Portal ; import fr . inria . zvtm . animation . Animation ; import fr . inria . zvtm . animation . interpolation . IdentityInterpolator ; import java . awt . event . KeyEvent ; import java . awt . event . MouseEvent ; import java . awt . event . MouseWheelEvent ; import com . mbeddr . zgrviewer . listener . GraphSelectionEvent ; import com . mbeddr . zgrviewer . listener . GraphSelectionListener ; public class ZgrvEvtHdlr extends BaseEventHandler implements ViewListener { protected ZGRViewer application ; private List graphSelectionListener = new LinkedList ( ) ; protected ZgrvEvtHdlr ( ZGRViewer app , GraphicsManager gm ) { this . application = app ; this . grMngr = gm ; } public void addGraphSelectionListener ( GraphSelectionListener listener ) { graphSelectionListener . add ( listener ) ; } public void removeGraphSelectionListener ( GraphSelectionListener listener ) { graphSelectionListener . remove ( listener ) ; } public void press1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { if ( toolPaletteIsActive ) { return ; } lastJPX = jpx ; lastJPY = jpy ; Glyph g = v . lastGlyphEntered ( ) ; if ( inZoomWindow ) { if ( grMngr . dmPortal . coordInsideBar ( jpx , jpy ) ) { draggingZoomWindow = true ; } else { draggingZoomWindowContent = true ; } } else if ( inMagWindow ) { v . getVCursor ( ) . stickGlyph ( grMngr . magWindow ) ; draggingMagWindow = true ; } else if ( grMngr . tp . isBringAndGoMode ( ) && g != null ) { grMngr . startBringAndGo ( g ) ; } else if ( grMngr . tp . isLinkSlidingMode ( ) ) { Point location = e . getComponent ( ) . getLocationOnScreen ( ) ; relative = e . getPoint ( ) ; LS_SX = v . getVCursor ( ) . getVSXCoordinate ( ) ; LS_SY = v . getVCursor ( ) . getVSYCoordinate ( ) ; grMngr . attemptLinkSliding ( LS_SX , LS_SY , location . x , location . y ) ; } else if ( grMngr . tp . isEditMode ( ) ) { pressInEditMode ( g , v . getVCursor ( ) , grMngr . mainCamera ) ; } else { grMngr . rememberLocation ( v . cams [ 0 ] . getLocation ( ) ) ; if ( mod == NO_MODIFIER || mod == SHIFT_MOD || mod == META_MOD || mod == META_SHIFT_MOD ) { manualLeftButtonMove = true ; lastJPX = jpx ; lastJPY = jpy ; v . getVCursor ( ) . setSensitivity ( false ) ; activeCam = grMngr . vsm . getActiveCamera ( ) ; } else if ( mod == ALT_MOD ) { zoomingInRegion = true ; x1 = v . getVCursor ( ) . getVSXCoordinate ( ) ; y1 = v . getVCursor ( ) . getVSYCoordinate ( ) ; v . setDrawRect ( true ) ; } } } public void release1 ( ViewPanel v , int mod , int jpx , int jpy , MouseEvent e ) { if ( ConfigManager . DYNASPOT && ! toolPaletteIsActive && ! v . getVCursor ( ) . getDynaPicker ( ) . isDynaSpotActivated ( ) ) { grMngr . activateDynaSpot ( true , false ) ; } if ( grMngr . isBringingAndGoing ) { grMngr . endBringAndGo ( v . lastGlyphEntered ( ) ) ; } else if ( grMngr . isLinkSliding ) { grMngr . endLinkSliding ( ) ; } if ( toolPaletteIsActive ) { return ; } draggingZoomWindow = false ; draggingZoomWindowContent = false ; if ( editingSpline || movingEdgeLabelOrBox ) { v . getVCursor ( ) . unstickLastGlyph ( ) ; editingSpline = movingEdgeLabelOrBox = false ; } else if ( movingNode ) { v . getVCursor ( ) . unstickLastGlyph ( ) ; grMngr . geom . unstickAll ( ) ; movingNode = false ; } if ( draggingMagWindow ) { draggingMagWindow = false ; v . getVCursor ( ) . unstickLastGlyph ( ) ; } else if ( manualLeftButtonMove ) { grMngr . mainCamera . setXspeed ( 0 ) ; grMngr . mainCamera . setYspeed ( 0 ) ; grMngr . mainCamera . setZspeed ( 0 ) ; v . hideFirstOrderPanWidget ( ) ; v . getVCursor ( ) . setSensitivity ( true ) ; if ( autoZooming ) { unzoom ( v ) ; } manualLeftButtonMove = false ; } } public void click1 ( ViewPanel v , int mod , int jpx , int jpy , int clickNumber , MouseEvent e ) { if ( toolPaletteIsActive ) { if (", "gt": "v . lastGlyphEntered ( ) != null )", "prediction": "toolPaletteIsActive )\n", "label": 1}
{"id": 1161, "input": "<s> package api . torrents . artist ; public class SimilarArtists { private Number artistId ; private String name ; private Number score ; private Number similarId ; public Number getArtistId ( ) { return this . artistId ; } public String getName ( ) { return this . name ; } public Number getScore ( ) { return this . score ; } public Number getSimilarId ( ) { return this . similarId ; } @ Override", "gt": "public String toString ( )", "prediction": "public String toString ( )\n", "label": 0}
{"id": 14906, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec4 . sub1 ; import org . restlet . Server ; import org . restlet . data . Protocol ; public class DynamicContentServer { public static void main ( String [", "gt": "] args ) throws Exception", "prediction": "] args )\n", "label": 1}
{"id": 779, "input": "<s> package org . parboiled . transform ; import static org . parboiled . common . Preconditions . * ; import org . objectweb . asm . * ; import org . objectweb . asm . tree . AbstractInsnNode ; import org . objectweb . asm . tree . FieldNode ; import org . objectweb . asm . tree . VarInsnNode ; import org . parboiled . common . Base64 ; import org . parboiled . common . StringUtils ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . ArrayList ; import java . util . List ; import static org . objectweb . asm . Opcodes . ALOAD ; class InstructionGroupPreparer implements RuleMethodProcessor { private static final Base64 CUSTOM_BASE64 = new Base64 ( \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy0123456789zzzz\" ) ; private RuleMethod method ; public boolean appliesTo ( ParserClassNode classNode , RuleMethod method ) { checkArgNotNull ( classNode , \"classNode\" ) ; checkArgNotNull ( method , \"method\" ) ; return method . containsExplicitActions ( ) || method . containsVars ( ) ; } public void process ( ParserClassNode classNode , RuleMethod method ) { this . method = checkArgNotNull ( method , \"method\" ) ; for ( InstructionGroup group : method . getGroups ( ) ) { extractInstructions ( group ) ; extractFields ( group ) ; name ( group , classNode ) ; } } private void extractInstructions ( InstructionGroup group ) { for ( InstructionGraphNode node : group . getNodes ( ) ) { if ( node != group . getRoot ( ) ) { AbstractInsnNode insn = node . getInstruction ( ) ; method . instructions . remove ( insn ) ; group . getInstructions ( ) . add ( insn ) ; } } } private void extractFields ( InstructionGroup group ) { List < FieldNode > fields = group . getFields ( ) ; for ( InstructionGraphNode node : group . getNodes ( ) ) { if ( node . isXLoad ( ) ) { VarInsnNode insn = ( VarInsnNode ) node . getInstruction ( ) ; int index ; for ( index = 0 ; index < fields . size ( ) ; index ++ ) { if ( fields . get ( index ) . access == insn . var ) break ; } if ( index == fields . size ( ) ) { Type type = node . getResultValue ( ) . getType ( ) ; fields . add ( new FieldNode ( insn . var , \"field$\" + index , type . getDescriptor ( ) , null , type ) ) ; } insn . var = index ; } } } private synchronized void name ( InstructionGroup group , ParserClassNode classNode ) { MD5Digester digester = new MD5Digester ( classNode . name ) ; group . getInstructions ( ) . accept ( digester ) ; for ( FieldNode field : group . getFields ( ) ) digester . visitField ( field ) ; byte [ ] hash = digester . getMD5Hash ( ) ; byte [ ] hash96 = new", "gt": "byte [ 12 ] ;", "prediction": "byte [ hash ] ;\n", "label": 0}
{"id": 14914, "input": "<s> package br . org . archimedes . controller ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import br . org . archimedes . Utils ; import br . org . archimedes . exceptions . IllegalActionException ; import br . org . archimedes . exceptions . NoActiveDrawingException ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . factories . CommandFactory ; import br . org . archimedes . factories . QuickMoveFactory ; import br . org . archimedes . interfaces . Command ; import br . org . archimedes . model . Drawing ; import br . org . archimedes . model . Element ; import br . org . archimedes . model . Layer ; import br . org . archimedes . model . Point ; import br . org . archimedes . model . Rectangle ; import br . org . archimedes . model . ReferencePoint ; import br . org . archimedes . model . Selection ; import br . org . archimedes . model . Vector ; public class Controller { private Drawing activeDrawing ; private static int defaultDrawingNumber = 1 ; public Controller ( ) { } public void openDrawing ( Drawing drawing ) { setActiveDrawing ( drawing ) ; } public boolean isThereActiveDrawing ( ) { return ( activeDrawing != null ) ; } public Drawing getActiveDrawing ( ) throws NoActiveDrawingException { if ( activeDrawing == null ) { throw new NoActiveDrawingException ( ) ; } return activeDrawing ; } public void setActiveDrawing ( Drawing drawing ) { activeDrawing = drawing ; if ( drawing != null ) { try { br . org . archimedes . Utils . getWorkspace ( ) . setViewport ( drawing . getViewportPosition ( ) , drawing . getZoom ( ) ) ; } catch ( NullArgumentException e ) { System . err . println ( \"NullArgumentException caught.\" ) ; e . printStackTrace ( ) ; } catch ( NoActiveDrawingException e ) { e . printStackTrace ( ) ; } } } public int fetchAndAddDrawingNumber ( ) { return defaultDrawingNumber ++ ; } public void execute ( List < Command > commands ) throws NoActiveDrawingException , IllegalActionException { Drawing drawing = getActiveDrawing ( ) ; drawing . execute ( commands ) ; } public void copyToClipboard ( Set < Element > selection ) { br . org . archimedes . Utils . getWorkspace ( ) . getClipboard ( ) . clear ( ) ; for ( Element element : selection ) { Element cloned = element . clone ( ) ; Layer layerClone = element . getLayer ( ) . clone ( ) ; cloned . setLayer ( layerClone ) ; br . org . archimedes . Utils . getWorkspace ( ) . getClipboard ( ) . add ( cloned ) ; } } public Element getElementUnder ( Point point , Class < ? > name ) throws NoActiveDrawingException { Collection < Element > elementsUnder = getElementsUnder ( point , name ) ; return getClosests ( elementsUnder , point ) ; } private Element getClosests ( Collection < Element > elements , Point point ) { double dist = Double . MAX_VALUE ; Element closest = null ; for ( Element element : elements ) { try { if ( element . contains ( point ) ) { return element ; } Point projection = element . getProjectionOf ( point ) ; Vector distanceVector = new Vector ( point , projection ) ; if ( dist > distanceVector . getNorm ( ) ) { dist = distanceVector . getNorm ( ) ; closest = element ; } } catch ( NullArgumentException e ) { System . err . println ( \"Couldnt calculate a distance for \" + element + \". Ignoring it as a closest element.\" ) ; e . printStackTrace ( ) ; } } return closest ; } public Collection < Element > getElementsUnder ( Point point , Class < ? > name ) throws NoActiveDrawingException { Collection < Element > elements = new ArrayList < Element > ( ) ; Drawing drawing = getActiveDrawing ( ) ; double delta = br . org . archimedes . Utils . getWorkspace ( ) . getSelectionSize ( ) / 2.0 ; delta = br . org . archimedes . Utils . getWorkspace ( ) . screenToModel ( delta ) ; Point a = new Point ( point . getX ( ) - delta , point . getY ( ) - delta ) ; Point b = new Point ( point . getX ( ) + delta , point . getY ( ) + delta ) ; Rectangle rect = new Rectangle ( a . getX ( ) , a . getY ( ) , b . getX ( ) , b . getY ( ) ) ; Set < Element > selected = null ; try { selected = drawing . getSelectionIntersection ( rect ) ; } catch ( NullArgumentException e ) { e . printStackTrace ( ) ; } if ( selected != null && ! selected . isEmpty ( ) ) { for ( Element element : selected ) { if ( Utils . isSubclassOf ( element , name ) || Utils . isInterfaceOf ( element , name ) ) { elements . add ( element ) ; } } } return elements ; } public boolean select ( Point point , boolean invertSelection ) throws NullArgumentException , NoActiveDrawingException { double delta = br . org . archimedes . Utils . getWorkspace ( ) . getSelectionSize ( ) / 2.0 ; delta = br . org . archimedes . Utils . getWorkspace ( ) . screenToModel ( delta ) ; Point a = new Point ( point . getX ( ) - delta , point . getY ( ) - delta ) ; Point b = new Point ( point . getX ( ) + delta , point . getY ( ) + delta ) ; Rectangle rect = new Rectangle ( a . getX ( ) , a . getY ( ) , b . getX ( ) , b . getY ( ) ) ; int selected = getCurrentSelectedElements ( ) . size ( ) ; select ( rect . getUpperRight ( ) , rect . getLowerLeft ( ) , invertSelection ) ; return ( selected != getCurrentSelectedElements ( ) . size ( ) ) ; } public boolean select ( Point p1 , Point p2 , boolean invertSelection ) throws NullArgumentException , NoActiveDrawingException { if ( p1 ==", "gt": "null || p2 == null )", "prediction": "null )\n", "label": 1}
{"id": 8679, "input": "<s> package org . ofbiz . service . engine ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . HttpClient ; import org . ofbiz . base . util . HttpClientException ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . serialize . XmlSerializer ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ModelService ; import org . ofbiz . service . ServiceDispatcher ; public class HttpEngine extends GenericAsyncEngine { public static final String module = HttpEngine . class . getName ( ) ; private static final boolean exportAll = false ; public HttpEngine ( ServiceDispatcher dispatcher ) { super ( dispatcher ) ; } @ Override public Map < String , Object > runSync ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { DispatchContext dctx = dispatcher . getLocalContext ( localName ) ; String xmlContext = null ; try { if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"Serializing Context --> \" + context , module ) ; xmlContext = XmlSerializer . serialize ( context ) ; } catch ( Exception e ) { throw new GenericServiceException ( \"Cannot serialize context.\" , e ) ; } Map < String , Object > parameters = FastMap . newInstance ( ) ; parameters . put ( \"serviceName\" , modelService . invoke ) ; if ( xmlContext != null ) parameters . put ( \"serviceContext\" , xmlContext ) ; HttpClient http = new HttpClient ( this . getLocation ( modelService ) , parameters ) ; String postResult = null ; try { postResult = http . post ( ) ; } catch ( HttpClientException e ) { throw new GenericServiceException ( \"Problems invoking HTTP request\" , e ) ; } Map < String , Object > result = null ; try { Object res = XmlSerializer . deserialize ( postResult , dctx . getDelegator ( ) ) ; if ( res instanceof Map < ? , ? > ) result = UtilGenerics . checkMap ( res ) ; else throw new GenericServiceException ( \"Result not an instance of Map.\" ) ; } catch ( Exception e ) { throw new GenericServiceException ( \"Problems deserializing result.\" , e ) ; } return result ; } @ Override public void runSyncIgnore ( String localName , ModelService modelService , Map < String , Object > context ) throws GenericServiceException { runSync ( localName , modelService , context ) ; } public static String httpEngine ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; Delegator delegator = ( Delegator ) request . getAttribute ( \"delegator\" ) ; String serviceName = request . getParameter ( \"serviceName\" ) ; String serviceMode = request . getParameter ( \"serviceMode\" ) ; String xmlContext = request . getParameter ( \"serviceContext\" ) ; Map < String , Object > result = FastMap . newInstance ( ) ; Map < String , Object > context = null ; if ( serviceName == null ) result . put ( ModelService . ERROR_MESSAGE , \"Cannot have null service name\" ) ; if ( serviceMode == null ) serviceMode = \"SYNC\" ; if ( ! result . containsKey ( ModelService . ERROR_MESSAGE ) ) { if ( xmlContext != null ) { try { Object o = XmlSerializer . deserialize ( xmlContext , delegator ) ; if ( o instanceof Map < ? , ? > ) context = UtilGenerics . checkMap ( o ) ; else { Debug . logError ( \"Context not an instance of Map error\" , module ) ; result . put ( ModelService . ERROR_MESSAGE , \"Context not an instance of Map\" ) ; } } catch ( Exception e ) { Debug . logError ( e , \"Deserialization error\" , module ) ; result . put ( ModelService . ERROR_MESSAGE , \"Error occurred deserializing context: \" + e . toString ( ) ) ; } } } if ( ! result . containsKey ( ModelService . ERROR_MESSAGE ) ) { try { ModelService model = dispatcher . getDispatchContext ( ) . getModelService ( serviceName ) ; if ( model . export || exportAll ) { if ( serviceMode . equals ( \"ASYNC\" ) ) { dispatcher . runAsync ( serviceName , context ) ; } else { result = dispatcher . runSync ( serviceName , context ) ; } } else { Debug . logWarning ( \"Attempt to invoke a non-exported service: \" + serviceName , module ) ; throw new GenericServiceException ( \"Cannot find requested service\" ) ; } } catch ( GenericServiceException e ) { Debug . logError ( e , \"Service invocation error\" , module ) ; result . put ( ModelService . ERROR_MESSAGE , \"Service invocation error: \" + e . toString ( ) ) ; } } StringBuilder errorMessage = new StringBuilder ( ) ; String resultString = null ; try { resultString = XmlSerializer . serialize ( result ) ; } catch ( Exception e ) { Debug . logError ( e , \"Cannot serialize result\" , module ) ; if ( result . containsKey ( ModelService . ERROR_MESSAGE ) ) errorMessage . append ( result . get ( ModelService . ERROR_MESSAGE ) ) ; errorMessage . append ( \"::\" ) ; errorMessage . append ( e ) ; } try { PrintWriter", "gt": "out = response . getWriter ( ) ;", "prediction": "writer = new PrintWriter ( ) ;\n", "label": 0}
{"id": 14915, "input": "<s> package org . apache . lucene . queryParser . surround . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermEnum ; import org . apache . lucene . index . IndexReader ; import java . io . IOException ; public class SrndPrefixQuery extends SimpleTerm { public SrndPrefixQuery ( String prefix , boolean quoted , char truncator ) { super ( quoted ) ; this . prefix = prefix ; this . truncator = truncator ; } private final String prefix ; public String getPrefix ( ) { return prefix ; } private final char truncator ; public char getSuffixOperator ( ) { return truncator ; } public Term getLucenePrefixTerm ( String fieldName ) { return new Term ( fieldName , getPrefix ( ) ) ; } public String toStringUnquoted ( ) { return getPrefix ( ) ; } protected void suffixToString ( StringBuffer r ) { r . append ( getSuffixOperator ( ) ) ; } public void visitMatchingTerms ( IndexReader reader , String fieldName", "gt": ", MatchingTermVisitor mtv ) throws IOException", "prediction": ")\n", "label": 1}
{"id": 6502, "input": "<s> package org . parboiled ; import org . parboiled . annotations . BuildParseTree ; import org . parboiled . test . TestNgParboiledTest ; import org . testng . annotations . Test ; public class SplitParserTest extends TestNgParboiledTest < Object > { @ BuildParseTree public static class Parser extends BaseParser < Object > { final Primitives primitives = Parboiled . createParser ( Primitives . class ) ; public Rule Clause ( ) { return Sequence ( primitives . Digit ( ) , primitives . Operator ( ) , primitives . Digit ( ) , EOI ) ; } } @ BuildParseTree public static class Primitives extends BaseParser < Object > { public Rule Operator ( ) { return FirstOf ( '+' , '-' ) ; } public Rule Digit ( ) { return CharRange ( '0' , '9' ) ; } } @ Test public void test ( ) { Parser parser = Parboiled", "gt": ". createParser ( Parser . class ) ;", "prediction": ". createParser ( Parser . class ) ;\n", "label": 0}
{"id": 14932, "input": "<s> package org . eclipse . core . tests . harness ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import junit . framework . Assert ; import org . eclipse . core . runtime . Platform ; import org . osgi . framework . Bundle ; import org . osgi . framework . BundleContext ; import org . osgi . framework . BundleException ; import org . osgi . framework . FrameworkEvent ; import org . osgi . framework . FrameworkListener ; import org . osgi . framework . ServiceReference ; import org . osgi . service . packageadmin . PackageAdmin ; public class BundleTestingHelper { public static Bundle [ ] getBundles ( BundleContext context , String symbolicName , String version ) { ServiceReference packageAdminReference = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; if ( packageAdminReference == null ) throw new IllegalStateException ( \"No package admin service found\" ) ; PackageAdmin packageAdmin = ( PackageAdmin ) context . getService ( packageAdminReference ) ; Bundle [ ] result = packageAdmin . getBundles ( symbolicName , version ) ; context . ungetService ( packageAdminReference ) ; return result ; } public static Bundle installBundle ( BundleContext context , String location ) throws BundleException , MalformedURLException , IOException { return installBundle ( \"\" , context , location ) ; } public static Bundle installBundle ( String tag , BundleContext context , String location ) throws BundleException , MalformedURLException , IOException { URL entry = context . getBundle ( ) . getEntry ( location ) ; if ( entry == null ) Assert . fail ( tag + \" entry \" + location + \" could not be found in \" + context . getBundle ( ) . getSymbolicName ( ) ) ; Bundle installed = context . installBundle ( Platform . asLocalURL ( entry ) . toExternalForm ( ) ) ; return installed ; } public static void refreshPackages ( BundleContext context , Bundle [ ] bundles ) { if ( bundles . length == 0 ) return ; ServiceReference packageAdminRef = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; PackageAdmin packageAdmin = null ; if ( packageAdminRef != null ) { packageAdmin = ( PackageAdmin ) context . getService ( packageAdminRef ) ; if ( packageAdmin == null ) return ; } final boolean [ ] flag = new boolean [ ] { false } ; FrameworkListener listener = new FrameworkListener ( ) { public void frameworkEvent ( FrameworkEvent event ) { if ( event . getType ( ) == FrameworkEvent . PACKAGES_REFRESHED ) synchronized ( flag ) { flag [ 0 ] = true ; flag . notifyAll ( ) ; } } } ; context . addFrameworkListener ( listener ) ; packageAdmin . refreshPackages ( bundles ) ; synchronized ( flag ) { while ( ! flag [ 0 ] ) { try { flag . wait ( ) ; } catch ( InterruptedException e ) { } } } context . removeFrameworkListener ( listener ) ; context . ungetService ( packageAdminRef ) ; } public static void resolveBundles ( BundleContext context , Bundle [ ] bundles ) { ServiceReference packageAdminRef = context . getServiceReference ( PackageAdmin . class . getName ( ) ) ; PackageAdmin packageAdmin = null ; if ( packageAdminRef != null ) { packageAdmin = ( PackageAdmin ) context . getService ( packageAdminRef ) ; if ( packageAdmin == null ) return ; } packageAdmin . resolveBundles ( bundles ) ; context . ungetService ( packageAdminRef ) ; } public static void runWithBundles ( String tag , Runnable runnable , BundleContext context , String [ ] locations , TestRegistryChangeListener listener ) { if ( listener != null ) listener . register ( ) ; try { Bundle [ ] installed = new Bundle [ locations . length ] ; for ( int i = 0 ; i < locations . length ; i ++ ) try { installed [ i ] = installBundle ( tag + \".setup.0\" ,", "gt": "context , locations [ i ] ) ;", "prediction": "locations [ i ] ) ;\n", "label": 1}
{"id": 2162, "input": "<s> public class T6294779a { interface A { A m ( ) ; } interface B extends A { B m ( ) ; } interface C extends A { C m ( ) ; } interface", "gt": "D extends B , C", "prediction": "D extends A\n", "label": 0}
{"id": 14958, "input": "<s> package org . eclipse . swt . graphics ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; public class FontMetrics_Test extends TestCase { public void testGetHeight ( ) { Display display = new Display ( ) ; GC gc = new GC ( display ) ; gc . setFont ( new Font ( display , \"Arial\" , 10 , SWT . NORMAL ) ) ; FontMetrics fontMetrics10 = gc . getFontMetrics ( ) ; int height10 = fontMetrics10 . getHeight ( ) ; gc . setFont ( new Font ( display , \"Arial\" , 30 , SWT . NORMAL ) ) ; FontMetrics fontMetrics30 = gc . getFontMetrics ( ) ; int height30 = fontMetrics30 . getHeight ( ) ; assertTrue ( height30 > height10 ) ; } public void testEquals ( ) { Display display = new Display ( ) ; GC gc = new GC ( display ) ; gc . setFont ( new Font ( display , \"Arial\" , 10 , SWT . NORMAL ) ) ; FontMetrics fontMetrics = gc . getFontMetrics ( ) ; FontMetrics equalFontMetrics = gc . getFontMetrics ( ) ; assertTrue ( equalFontMetrics . equals ( fontMetrics ) ) ; gc . setFont ( new Font ( display , \"Arial\" , 12 , SWT . NORMAL ) ) ; FontMetrics differentFontMetrics = gc . getFontMetrics ( ) ; assertFalse ( differentFontMetrics . equals ( fontMetrics ) ) ; }", "gt": "protected void setUp ( ) throws Exception", "prediction": "}\n", "label": 1}
{"id": 8758, "input": "<s> package com . redhat . ceylon . compiler . loader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import javax . lang . model . type . TypeKind ; import com . redhat . ceylon . cmr . api . ArtifactResult ; import com . redhat . ceylon . common . Versions ; import com . redhat . ceylon . compiler . java . codegen . Decl ; import com . redhat . ceylon . compiler . java . codegen . Naming ; import com . redhat . ceylon . compiler . java . util . Timer ; import com . redhat . ceylon . compiler . java . util . Util ; import com . redhat . ceylon . compiler . loader . mirror . AnnotatedMirror ; import com . redhat . ceylon . compiler . loader . mirror . AnnotationMirror ; import com . redhat . ceylon . compiler . loader . mirror . ClassMirror ; import com . redhat . ceylon . compiler . loader . mirror . FieldMirror ; import com . redhat . ceylon . compiler . loader . mirror . MethodMirror ; import com . redhat . ceylon . compiler . loader . mirror . PackageMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeMirror ; import com . redhat . ceylon . compiler . loader . mirror . TypeParameterMirror ; import com . redhat . ceylon . compiler . loader . mirror . VariableMirror ; import com . redhat . ceylon . compiler . loader . model . FieldValue ; import com . redhat . ceylon . compiler . loader . model . JavaBeanValue ; import com . redhat . ceylon . compiler . loader . model . JavaMethod ; import com . redhat . ceylon . compiler . loader . model . LazyClass ; import com . redhat . ceylon . compiler . loader . model . LazyClassAlias ; import com . redhat . ceylon . compiler . loader . model . LazyContainer ; import com . redhat . ceylon . compiler . loader . model . LazyElement ; import com . redhat . ceylon . compiler . loader . model . LazyInterface ; import com . redhat . ceylon . compiler . loader . model . LazyInterfaceAlias ; import com . redhat . ceylon . compiler . loader . model . LazyMethod ; import com . redhat . ceylon . compiler . loader . model . LazyModule ; import com . redhat . ceylon . compiler . loader . model . LazyPackage ; import com . redhat . ceylon . compiler . loader . model . LazyTypeAlias ; import com . redhat . ceylon . compiler . loader . model . LazyValue ; import com . redhat . ceylon . compiler . typechecker . analyzer . ModuleManager ; import com . redhat . ceylon . compiler . typechecker . model . Annotation ; import com . redhat . ceylon . compiler . typechecker . model . BottomType ; import com . redhat . ceylon . compiler . typechecker . model . Class ; import com . redhat . ceylon . compiler . typechecker . model . ClassOrInterface ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . Element ; import com . redhat . ceylon . compiler . typechecker . model . Functional ; import com . redhat . ceylon . compiler . typechecker . model . Interface ; import com . redhat . ceylon . compiler . typechecker . model . Method ; import com . redhat . ceylon . compiler . typechecker . model . MethodOrValue ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . ModuleImport ; import com . redhat . ceylon . compiler . typechecker . model . Modules ; import com . redhat . ceylon . compiler . typechecker . model . Package ; import com . redhat . ceylon . compiler . typechecker . model . Parameter ; import com . redhat . ceylon . compiler . typechecker . model . ParameterList ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . Scope ; import com . redhat . ceylon . compiler . typechecker . model . TypeAlias ; import com . redhat . ceylon . compiler . typechecker . model . TypeDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . TypeParameter ; import com . redhat . ceylon . compiler . typechecker . model . TypedDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . Unit ; import com . redhat . ceylon . compiler . typechecker . model . UnknownType ; import com . redhat . ceylon . compiler . typechecker . model . Value ; import com . redhat . ceylon . compiler . typechecker . model . ValueParameter ; public abstract class AbstractModelLoader implements ModelCompleter , ModelLoader { public static final String CEYLON_LANGUAGE = \"ceylon.language\" ; private static final String TIMER_MODEL_LOADER_CATEGORY = \"model loader\" ; public static final String ORACLE_JDK_MODULE = \"oracle\" ; public static final String JDK_MODULE = \"java\" ; public static final String JDK_MODULE_VERSION = \"7\" ; public static final String CEYLON_CEYLON_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Ceylon\" ; private static final String CEYLON_MODULE_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Module\" ; private static final String CEYLON_PACKAGE_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Package\" ; private static final String CEYLON_IGNORE_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Ignore\" ; private static final String CEYLON_CLASS_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Class\" ; public static final String CEYLON_NAME_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Name\" ; private static final String CEYLON_SEQUENCED_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Sequenced\" ; private static final String CEYLON_DEFAULTED_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Defaulted\" ; private static final String CEYLON_SATISFIED_TYPES_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.SatisfiedTypes\" ; private static final String CEYLON_CASE_TYPES_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.CaseTypes\" ; private static final String CEYLON_TYPE_PARAMETERS = \"com.redhat.ceylon.compiler.java.metadata.TypeParameters\" ; private static final String CEYLON_TYPE_INFO_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.TypeInfo\" ; public static final String CEYLON_ATTRIBUTE_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Attribute\" ; public static final String CEYLON_OBJECT_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Object\" ; public static final String CEYLON_METHOD_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Method\" ; public static final String CEYLON_CONTAINER_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Container\" ; private static final String CEYLON_MEMBERS_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Members\" ; private static final String CEYLON_ANNOTATIONS_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Annotations\" ; public static final String CEYLON_VALUETYPE_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.ValueType\" ; public static final String CEYLON_ALIAS_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.Alias\" ; public static final String CEYLON_TYPE_ALIAS_ANNOTATION = \"com.redhat.ceylon.compiler.java.metadata.TypeAlias\" ; private static final TypeMirror OBJECT_TYPE = simpleObjectType ( \"java.lang.Object\" ) ;", "gt": "private static final TypeMirror CEYLON_OBJECT_TYPE = simpleObjectType ( \"ceylon.language.Object\" ) ;", "prediction": "}\n", "label": 0}
{"id": 14959, "input": "<s> package org . modelgoon . packages . figures ; import org . eclipse . draw2d . AbstractBorder ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . draw2d . Graphics ; import org . eclipse . draw2d . IFigure ; import org . eclipse . draw2d . geometry . Insets ; public class RoundedBorder extends AbstractBorder { public Insets getInsets ( final IFigure figure ) { return new Insets ( 3 , 5 , 3 , 10 ) ; } public void paint ( final IFigure figure , final Graphics graphics , final Insets insets ) { AbstractBorder . tempRect . setBounds ( AbstractBorder .", "gt": "getPaintRectangle ( figure , insets ) ) ;", "prediction": "getBounds ( figure ) ) ;\n", "label": 1}
{"id": 3030, "input": "<s> package org . msl . simple . gmfmap . model . triggers . parent ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . emf . ecore . util . EcoreUtil ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . gmf . gmfgraph . ChildAccess ; import org . eclipse . gmf . gmfgraph . Compartment ; import org . eclipse . gmf . gmfgraph . Connection ; import org . eclipse . gmf . gmfgraph . DecorationFigure ; import org . eclipse . gmf . gmfgraph . DiagramElement ; import org . eclipse . gmf . gmfgraph . Figure ; import org . eclipse . gmf . gmfgraph . FigureDescriptor ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse . gmf . gmfgraph . PolylineConnection ; import org . eclipse . gmf . mappings . CompartmentMapping ; import org . eclipse . gmf . mappings . LabelMapping ; import org . eclipse . gmf . mappings . LinkMapping ; import org . eclipse . gmf . mappings . NodeMapping ; import org . eclipse . gmf . mappings . NodeReference ; import org . eclipse . gmf . tooldef . AbstractTool ; import org . msl . simple . gmfmap . model . triggers . AbstractTrigger ; import org . msl . simple . gmfmap . simplemappings . SimpleChildNode ; import org . msl . simple . gmfmap . simplemappings . SimpleChildReference ; import org . msl . simple . gmfmap . simplemappings . SimpleCompartment ; import org . msl . simple . gmfmap . simplemappings . SimpleLinkMapping ; import org . msl . simple . gmfmap . simplemappings . SimpleNode ; import org . msl . simple . gmfmap . simplemappings . SimpleSubNode ; public class RemoveChildNodeTrigger extends AbstractTrigger { private List < SimpleChildNode > removedNodes = new ArrayList < SimpleChildNode > ( ) ; public RemoveChildNodeTrigger ( TransactionalEditingDomain domain , SimpleChildNode removedNode ) { super ( domain ) ; this . removedNodes . add ( removedNode ) ; } public RemoveChildNodeTrigger ( TransactionalEditingDomain domain , List < SimpleChildNode > removedNodes ) { super ( domain ) ; this . removedNodes . addAll ( removedNodes ) ; } @ Override public void executeTrigger ( ) { for ( SimpleChildNode removedNode : removedNodes ) removeChildNode ( removedNode ) ; } private void removeChildNode ( SimpleChildNode removedNode ) { if ( removedNode instanceof SimpleChildReference ) removeSimpleChildReference ( ( SimpleChildReference ) removedNode ) ; if ( removedNode instanceof SimpleNode ) removeSimpleNode ( ( SimpleNode ) removedNode ) ; if ( removedNode instanceof SimpleCompartment ) removeCompartment ( ( SimpleCompartment ) removedNode ) ; if ( removedNode instanceof SimpleLinkMapping ) removeLinkMapping ( ( SimpleLinkMapping ) removedNode ) ; } private void removeSimpleNode ( SimpleNode removedNode ) { if ( removedNode instanceof SimpleSubNode ) for ( SimpleChildNode childNode : ( ( SimpleSubNode ) removedNode ) . getChildren ( ) ) removeChildNode ( childNode ) ; NodeReference nodeReferenceToRemove = removedNode . getNodeReference ( ) ; if ( nodeReferenceToRemove != null && nodeReferenceToRemove . eIsProxy ( ) ) nodeReferenceToRemove = ( NodeReference ) EcoreUtil . resolve ( nodeReferenceToRemove , getDomain ( ) . getResourceSet ( ) ) ; AbstractTool toolToRemove = null ; NodeMapping nodeMappingToRemove = null ; if ( nodeReferenceToRemove != null && nodeReferenceToRemove . getChild ( ) != null ) { nodeMappingToRemove = nodeReferenceToRemove . getChild ( ) ; toolToRemove = nodeMappingToRemove . getTool ( ) ; } List < DiagramElement > diagramElementsToRemove = collectDiagramElementsToRemove ( removedNode ) ; List < FigureDescriptor > figureDescToRemove = new ArrayList < FigureDescriptor > ( ) ; for ( DiagramElement diagramElement : diagramElementsToRemove ) if ( diagramElement . getFigure ( ) != null ) figureDescToRemove . add ( diagramElement . getFigure ( ) ) ; for ( FigureDescriptor figDesc : figureDescToRemove ) EcoreUtil . delete ( figDesc ) ; for ( DiagramElement diagramElement : diagramElementsToRemove ) EcoreUtil . delete ( diagramElement ) ; if ( toolToRemove != null && canRemove ( toolToRemove ) ) EcoreUtil . delete ( toolToRemove ) ; if ( nodeMappingToRemove != null ) EcoreUtil . delete ( nodeMappingToRemove ) ; if ( nodeReferenceToRemove != null ) EcoreUtil . delete ( nodeReferenceToRemove ) ; } private void removeSimpleChildReference ( SimpleChildReference removedNode ) { NodeReference nodeReferenceToRemove = removedNode . getNodeReference ( ) ; if ( nodeReferenceToRemove != null && nodeReferenceToRemove . eIsProxy ( ) ) nodeReferenceToRemove = ( NodeReference ) EcoreUtil . resolve ( nodeReferenceToRemove , getDomain ( ) . getResourceSet ( ) ) ; if ( nodeReferenceToRemove != null ) EcoreUtil . delete ( nodeReferenceToRemove ) ; } private List < DiagramElement > collectDiagramElementsToRemove ( SimpleNode removedNode ) { List < DiagramElement > diagramElementsToRemove = new ArrayList < DiagramElement > ( ) ; NodeReference nodeReferenceToRemove = removedNode . getNodeReference ( ) ; if ( nodeReferenceToRemove == null ) return diagramElementsToRemove ; if ( nodeReferenceToRemove . eIsProxy ( ) ) nodeReferenceToRemove = ( NodeReference ) EcoreUtil . resolve ( nodeReferenceToRemove , getDomain ( ) . getResourceSet ( ) ) ; NodeMapping nodeMapping = nodeReferenceToRemove . getChild ( ) ; if ( nodeMapping != null ) { Node nodeToRemove = nodeMapping . getDiagramNode ( ) ; if ( nodeToRemove != null && canRemove ( nodeToRemove ) ) diagramElementsToRemove . add ( nodeToRemove ) ; for ( LabelMapping labelMapping : nodeMapping . getLabelMappings ( ) ) if ( labelMapping . getDiagramLabel ( ) != null && canRemove ( labelMapping . getDiagramLabel ( ) ) ) diagramElementsToRemove . add ( labelMapping . getDiagramLabel ( ) ) ; } return diagramElementsToRemove ; } private List", "gt": "< DiagramElement > collectDiagramElementsToRemove ( SimpleLinkMapping removedLinkMapping )", "prediction": "< DiagramElement > collectDiagramElementsToRemove ( SimpleNode removedNode )\n", "label": 0}
{"id": 14960, "input": "<s> package org . eclipse . xtext . xdoc . xdoc . impl ; import java . util . Collection ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . EObjectContainmentEList ; import org . eclipse . emf . ecore . util . InternalEList ; import org . eclipse . xtext . xdoc . xdoc . Section2 ; import org . eclipse . xtext . xdoc . xdoc . Section3 ; import org . eclipse . xtext . xdoc . xdoc . XdocPackage ; public class Section2Impl extends AbstractSectionImpl implements Section2 { protected EList < Section3 > subSections ; protected Section2Impl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return XdocPackage . Literals . SECTION2 ; } public EList < Section3 > getSubSections ( ) { if ( subSections == null ) { subSections = new EObjectContainmentEList < Section3 > ( Section3 . class , this , XdocPackage . SECTION2__SUB_SECTIONS ) ; } return subSections ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case XdocPackage . SECTION2__SUB_SECTIONS : return ( ( InternalEList < ? > ) getSubSections ( ) ) . basicRemove ( otherEnd , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case XdocPackage", "gt": ". SECTION2__SUB_SECTIONS : return getSubSections ( ) ;", "prediction": ". SECTION2__SUB_SECTIONS : return ( ( InternalEList < ? > ) getSubSections ( ) ) . basicGet ( featureID , resolve , coreType ) ;\n", "label": 1}
{"id": 9017, "input": "<s> import java . io . * ; import java . util . * ; import javax . tools . * ; import javax . tools . JavaCompiler . CompilationTask ; import com . sun . source . util . * ; public class TestJavacTask_Multiple { public static void main ( String ... args ) throws Exception { new TestJavacTask_Multiple ( ) . run ( ) ; } final int MAX_TASKS = 3 ; enum TestKind { CALL { int test ( CompilationTask t ) { boolean ok = t . call ( ) ; if ( ! ok ) throw new Error ( \"compilation failed\" ) ; return 1 ; } } , PARSE { int test ( CompilationTask t ) { try { ( ( JavacTask ) t ) . parse ( ) ; return 1 ; } catch ( IOException ex ) { throw new Error ( ex ) ; } } } ; abstract int test ( CompilationTask t ) ; } int count ; void run ( ) throws Exception { JavaCompiler comp = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = comp . getStandardFileManager ( null , null , null ) ; for ( TestKind tk : TestKind . values ( ) ) { test ( comp , fm , tk ) ; } int expect = TestKind . values ( ) . length * MAX_TASKS ; if ( count != expect ) { throw new Exception ( \"Unexpected number of tests completed: \" + count + \", expected: \" + expect ) ; } } void test ( JavaCompiler comp , StandardJavaFileManager fm , TestKind tk ) { System . err . println ( \"test \" + tk ) ; File testSrc =", "gt": "new File ( System . getProperty ( \"test.src\" ) ) ;", "prediction": "new File ( ) ;\n", "label": 0}
{"id": 14970, "input": "<s> package org . apache . lucene . analysis . compound . hyphenation ; public class Hyphenation { private int [ ] hyphenPoints ; private int len ; Hyphenation ( int [ ] points ) { hyphenPoints = points ; } public int length ( ) { return hyphenPoints . length ; } public int", "gt": "[ ] getHyphenationPoints ( )", "prediction": "getLength ( )\n", "label": 1}
{"id": 4929, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface PurgeTask extends TaskAttribute { PurgeTaskAttribute getListAttribute ( ) ; void setListAttribute", "gt": "( PurgeTaskAttribute value ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 14978, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . textsize . MeasurementItem ; import org . eclipse . rap . rwt . internal . textsize . MeasurementOperator ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeResultStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeEstimation ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorageUtil ; import org . eclipse . rap . rwt . internal . textsize . TextSizeUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . widgets . Display ; public class TextSizeUtil_Test extends TestCase { private static final String TEST_STRING = \"test\" ; private static final FontData FONT_DATA = new FontData ( \"arial\" , 10 , SWT . NORMAL ) ; protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; new Display ( ) ; } protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testStringExtentAssignsUnknownStringsToTextSizeMeasuring ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getMeasurementItems ( ) . length ) ; assertEquals ( TEST_STRING , getMeasurementItems ( ) [ 0 ] . getTextToMeasure ( ) ) ; assertEquals ( FONT_DATA , getMeasurementItems ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentAssignsUnknownFontToFontProbing ( ) { TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals ( 1 , getProbes ( ) . length ) ; assertEquals ( FONT_DATA , getProbes ( ) [ 0 ] . getFontData ( ) ) ; } public void testStringExtentUsesEstimationForUnknownStrings ( ) { Point determined = TextSizeUtil . stringExtent ( getFont ( ) , TEST_STRING ) ; Point estimated = TextSizeEstimation . stringExtent ( getFont ( ) , TEST_STRING ) ; assertEquals", "gt": "( estimated , determined ) ;", "prediction": "( 0 , determined . length ) ;\n", "label": 1}
{"id": 2722, "input": "<s> package org . ofbiz . entity . model ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilTimer ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . entity . condition . EntityComparisonOperator ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionValue ; import org . ofbiz . entity . condition . EntityFieldValue ; import org . ofbiz . entity . condition . EntityFunction ; import org . ofbiz . entity . condition . EntityJoinOperator ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . jdbc . SqlJdbcUtil ; import org . w3c . dom . Element ; import org . w3c . dom . NodeList ; @ SuppressWarnings ( \"serial\" ) public class ModelViewEntity extends ModelEntity { public static final String module = ModelViewEntity . class . getName ( ) ; public static Map < String , String > functionPrefixMap = FastMap . newInstance ( ) ; static { functionPrefixMap . put ( \"min\" , \"MIN(\" ) ; functionPrefixMap . put ( \"max\" , \"MAX(\" ) ; functionPrefixMap . put ( \"sum\" , \"SUM(\" ) ; functionPrefixMap . put ( \"avg\" , \"AVG(\" ) ; functionPrefixMap . put ( \"count\" , \"COUNT(\" ) ; functionPrefixMap . put ( \"count-distinct\" , \"COUNT(DISTINCT \" ) ; functionPrefixMap . put ( \"upper\" , \"UPPER(\" ) ; functionPrefixMap . put ( \"lower\" , \"LOWER(\" ) ; } protected Map < String , ModelMemberEntity > memberModelMemberEntities = FastMap . newInstance ( ) ; protected List < ModelMemberEntity > allModelMemberEntities = FastList . newInstance ( ) ; protected Map < String , String > memberModelEntities = FastMap . newInstance ( ) ; protected List < ModelAliasAll > aliasAlls = FastList . newInstance ( ) ; protected List < ModelAlias > aliases = FastList . newInstance ( ) ; protected List < ModelViewLink > viewLinks = FastList . newInstance ( ) ; protected List < ModelField > groupBys = FastList . newInstance ( ) ; protected List < String > groupByFields = FastList . newInstance ( ) ; protected Map < String , ModelConversion [ ] > conversions = FastMap . newInstance ( ) ; protected ViewEntityCondition viewEntityCondition = null ; public ModelViewEntity ( ModelReader reader , Element entityElement , UtilTimer utilTimer , ModelInfo def ) { super ( reader , entityElement , def ) ; if ( utilTimer != null ) utilTimer . timerString ( \"  createModelViewEntity: before general/basic info\" ) ; this . populateBasicInfo ( entityElement ) ; if ( utilTimer != null ) utilTimer . timerString ( \"  createModelViewEntity: before \\\"member-entity\\\"s\" ) ; for ( Element memberEntityElement : UtilXml . childElementList ( entityElement , \"member-entity\" ) ) { String alias = UtilXml . checkEmpty ( memberEntityElement . getAttribute ( \"entity-alias\" ) ) . intern ( ) ; String name = UtilXml . checkEmpty ( memberEntityElement . getAttribute ( \"entity-name\" ) ) . intern ( ) ; if ( name . length ( ) <= 0 || alias . length ( ) <= 0 ) { Debug . logError ( \"[new ModelViewEntity]: entity-alias or entity-name missing on member-entity element of the view-entity \" + this . entityName , module ) ; } else { ModelMemberEntity modelMemberEntity = new ModelMemberEntity ( alias , name ) ; this . addMemberModelMemberEntity ( modelMemberEntity ) ; } } for ( Element aliasElement : UtilXml . childElementList ( entityElement , \"alias-all\" ) ) { ModelViewEntity . ModelAliasAll aliasAll = new ModelAliasAll ( aliasElement ) ; this . aliasAlls . add ( aliasAll ) ; } if ( utilTimer != null ) utilTimer .", "gt": "timerString ( \"  createModelViewEntity: before aliases\" ) ;", "prediction": "timerString ( \" createModelViewEntity: before general/basic info\" ) ;\n", "label": 0}
{"id": 15002, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec5 ; import org . restlet . Component ; import org . restlet . data . Protocol ; import org . restlet . example . book . restlet . ch07 . sec5 . webapi . server . MailApiApplication ; import org . restlet . example . book . restlet . ch07 . sec5 . website . MailSiteApplication ; public class MailServerComponent extends Component { public static void main ( String [ ] args ) throws Exception { new MailServerComponent ( ) . start ( ) ; } public MailServerComponent ( ) throws Exception { setName ( \"RESTful Mail Server component\" ) ; setDescription ( \"Example for 'Restlet in Action' book\" ) ; setOwner ( \"Restlet S.A.S.\" ) ; setAuthor ( \"The Restlet Team\" ) ; getClients ( )", "gt": ". add ( Protocol . CLAP ) ;", "prediction": ";\n", "label": 1}
{"id": 6762, "input": "<s> package org . gk . engine . client . build . menu ; import java . util . List ; import org . gk . engine . client . build . Builder ; import org . gk . engine . client . gen . UIGen ; import org . gk . ui . client . com . form . gkList ; import com . google . gwt . xml . client . Node ; public class MenuBarItemBuilder extends Builder { public MenuBarItemBuilder ( String processNodeName ) { super ( processNodeName ) ; } @ Override public void processNode ( List < UIGen > nodeList , Node node ) { List subNodes = new gkList ( ) ; super . parserNode ( subNodes , node . getChildNodes ( ) ) ; XMenuBarItem xMenuBarItem = new XMenuBarItem ( node , subNodes ) ; nodeList", "gt": ". add ( xMenuBarItem ) ;", "prediction": ". add ( xMenuBarItem ) ;\n", "label": 0}
{"id": 15007, "input": "<s> package com . optify . service . exception ; public class UnauthorizedException extends Exception { private static", "gt": "final long serialVersionUID = 1L ;", "prediction": "final long serialVersionUID = 1L ;\n", "label": 1}
{"id": 5376, "input": "<s> package model ; import static org . junit . Assert . * ; import org . junit . Test ; import exceptions . CatalogueException ; public class CatalogueJUnit { @ Test public void catalogueConstructorTest ( ) { Catalogue c = new Catalogue ( ) ; assertTrue ( c . size ( ) == 0 ) ; assertTrue ( c != null ) ; } @ Test public void addBookTest ( ) { Book b = new Book ( \"THISISAUNIQUESTRING1\" , \"THISISAUNIQUESTRING2\" , 1.10 , \"THISISAUNIQUESTRING3\" , 2309580 , \"THISISAUNIQUESTRING4\" , \"THISISAUNIQUESTRING5\" ) ; Catalogue c = new Catalogue ( ) ; assertFalse ( c . size ( ) > 0 ) ; c . add ( b ) ; assertTrue ( c . size ( ) > 0 ) ; } @ Test public void removeBookTest ( ) { Catalogue c = new Catalogue ( ) ; Book b = new Book ( \"THISISAUNIQUESTRING1\" , \"THISISAUNIQUESTRING2\" , 1.10 , \"THISISAUNIQUESTRING3\" , 2309580 , \"THISISAUNIQUESTRING4\" , \"THISISAUNIQUESTRING5\" ) ; assertTrue ( c . size ( ) == 0 ) ; c . add ( b ) ; assertTrue ( c .", "gt": "size ( ) > 0 ) ;", "prediction": "size ( ) > 0 ) ;\n", "label": 0}
{"id": 15025, "input": "<s> package org . restlet . routing ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . logging . Logger ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Reference ; import org . restlet . util . Resolver ; public class Template { public static final int MODE_EQUALS = 2 ; public static final int MODE_STARTS_WITH = 1 ; private static void appendClass ( StringBuilder pattern , String content , boolean required ) { pattern . append ( \"(\" ) ; if ( content . equals ( \".\" ) ) { pattern . append ( content ) ; } else { pattern . append ( \"[\" ) . append ( content ) . append ( ']' ) ; } if ( required ) { pattern . append ( \"+\" ) ; } else { pattern . append ( \"*\" ) ; } pattern . append ( \")\" ) ; } private static void appendGroup ( StringBuilder pattern , String content , boolean required ) { pattern . append ( \"((?:\" ) . append ( content ) . append ( ')' ) ; if ( required ) { pattern . append ( \"+\" ) ; } else { pattern . append ( \"*\" ) ; } pattern . append ( \")\" ) ; } private static String getVariableRegex ( Variable variable ) { String result = null ; if ( variable . isFixed ( ) ) { result = \"(\" + Pattern . quote ( variable . getDefaultValue ( ) ) + \")\" ; } else { final String ALL = \".\" ; final String ALPHA = \"a-zA-Z\" ; final String DIGIT = \"\\\\d\" ; final String ALPHA_DIGIT = ALPHA + DIGIT ; final String HEXA = DIGIT + \"ABCDEFabcdef\" ; final String URI_UNRESERVED = ALPHA_DIGIT + \"\\\\-\\\\.\\\\_\\\\~\" ; final String URI_GEN_DELIMS = \"\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@\" ; final String URI_SUB_DELIMS = \"\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=\" ; final String URI_RESERVED = URI_GEN_DELIMS + URI_SUB_DELIMS ; final String WORD = \"\\\\w\" ; final String CRLF = \"\\\\r\\\\n\" ; final String CTL = \"\\\\p{Cntrl}\" ; final String LWS = CRLF + \"\\\\ \\\\t\" ; final String SEPARATOR = \"\\\\(\\\\)\\\\<\\\\>\\\\@\\\\,\\\\;\\\\:\\\\[\\\\]\\\"\\\\/\\\\\\\\?\\\\=\\\\{\\\\}\\\\ \\\\t\" ; final String TOKEN = \"[^\" + SEPARATOR + \"]\" ; final String COMMENT = \"[^\" + CTL + \"]\" + \"[^\\\\(\\\\)]\" + LWS ; final String COMMENT_ATTRIBUTE = \"[^\\\\;\\\\(\\\\)]\" ; final String PCT_ENCODED = \"\\\\%[\" + HEXA + \"][\" + HEXA + \"]\" ; final String PCHAR = \"[\" + URI_UNRESERVED + URI_SUB_DELIMS + \"\\\\:\\\\@]|(?:\" + PCT_ENCODED + \")\" ; final String QUERY = PCHAR + \"|\\\\/|\\\\?\" ; final String FRAGMENT = QUERY ; final String URI_PATH = PCHAR + \"|\\\\/\" ; final String URI_ALL = \"[\" + URI_RESERVED + URI_UNRESERVED + \"]|(?:\" + PCT_ENCODED + \")\" ; final String QUERY_PARAM_DELIMS = \"\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\" ; final String QUERY_PARAM_CHAR = \"[\" + URI_UNRESERVED + QUERY_PARAM_DELIMS", "gt": "+ \"\\\\:\\\\@]|(?:\" + PCT_ENCODED + \")\" ;", "prediction": "+ \"\\\\:\\\\@]|(?:\" + QUERY_PARAM_CHAR + \")\" ;\n", "label": 1}
{"id": 7667, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . emf . common . util . EList ; import org . eclipse . emf . ecore . EAttribute ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . EReference ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . gmfgraph . Node ; import org . eclipse .", "gt": "gmf . mappings . NodeReference ;", "prediction": "gmf . gmfgraph . Point ;\n", "label": 0}
{"id": 15058, "input": "<s> package knowevo . myvizster . util ; import java . awt . event . ActionEvent ; import javax . swing . AbstractAction ; import knowevo . myvizster . Vizster ; import edu . berkeley . guir . prefuse . Display ; public class DebugInfoAction extends AbstractAction { private Vizster vizster ; public DebugInfoAction ( Vizster vizster ) {", "gt": "this . vizster = vizster ;", "prediction": "super ( vizster ) ;\n", "label": 1}
{"id": 8840, "input": "<s> package org . ofbiz . base . util . collections ; import java . util . Map ; import org . ofbiz . base . util . UtilObject ; public class ReadOnlyMapEntry < K , V > implements Map . Entry < K , V > { protected final K key ; protected final V value ; public ReadOnlyMapEntry ( K key , V value ) { this . key = key ; this . value = value ; } public K getKey ( ) { return key ; } public V getValue ( ) { return value ; } public V setValue ( V value ) { throw new UnsupportedOperationException ( ) ; } @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof Map . Entry < ? , ? > ) ) return false ; if ( this == o ) return true ; Map . Entry < ? , ? > other = ( Map . Entry <", "gt": "? , ? > ) o ;", "prediction": "? , ? > ) o ;\n", "label": 0}
{"id": 15064, "input": "<s> package org . eclipse . rap . rwt . internal . application ; import java . io . IOException ; import java . io . InputStream ; import java . text . MessageFormat ; import java . util . Map ; import org . eclipse . rap . rwt . Adaptable ; import org . eclipse . rap . rwt . application . Application ; import org . eclipse . rap . rwt . application . ApplicationConfiguration ; import org . eclipse . rap . rwt . internal . client . ClientProvider ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . internal . service . ServiceManager ; import org . eclipse . rap . rwt . internal . theme . Theme ; import org . eclipse . rap . rwt . internal . theme . ThemeManager ; import org . eclipse . rap . rwt . internal . theme . css . CssFileReader ; import org . eclipse . rap . rwt . internal . theme . css . StyleSheet ; import org . eclipse . rap . rwt . internal . util . ParamCheck ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . IEntryPointFactory ; import org . eclipse . rap . rwt . lifecycle . PhaseListener ; import org . eclipse . rap . rwt . resources . IResource ; import org . eclipse . rap . rwt . resources . ResourceLoader ; import org . eclipse . rap . rwt . service . IServiceHandler ; import org . eclipse . rap . rwt . service . ISettingStoreFactory ; import org . eclipse . swt . widgets . Widget ; public class ApplicationImpl implements Application , Adaptable { private final ApplicationContext applicationContext ; private final ApplicationConfiguration configuration ; static class ResourceLoaderImpl implements ResourceLoader { private final ClassLoader loader ; private ResourceLoaderImpl ( ClassLoader loader ) { this . loader = loader ; } public InputStream getResourceAsStream ( String resourceName ) throws IOException { return loader . getResourceAsStream ( resourceName ) ; } } public ApplicationImpl ( ApplicationContext applicationContext , ApplicationConfiguration configuration ) { this . applicationContext = applicationContext ; this . configuration = configuration ; } public void setOperationMode ( OperationMode operationMode ) { ParamCheck . notNull ( operationMode , \"operationMode\" ) ; switch ( operationMode ) { case JEE_COMPATIBILITY : break ; case SWT_COMPATIBILITY : applicationContext . getLifeCycleFactory ( ) . configure ( RWTLifeCycle . class ) ; break ; case SESSION_FAILOVER : new SessionFailoverConfigurator ( applicationContext ) . configure ( ) ; break ; default : throw new IllegalArgumentException ( \"Unsupported operation mode: \" + operationMode ) ; } } public void addPhaseListener ( PhaseListener phaseListener ) { ParamCheck . notNull ( phaseListener , \"phaseListener\" ) ; applicationContext . getPhaseListenerRegistry ( ) . add ( phaseListener ) ; } public void setSettingStoreFactory ( ISettingStoreFactory settingStoreFactory ) { ParamCheck . notNull ( settingStoreFactory , \"settingStoreFactory\" ) ; applicationContext . getSettingStoreManager ( ) . register ( settingStoreFactory ) ; } public void addEntryPoint ( String path , Class < ? extends IEntryPoint > entryPointType , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointType , \"entryPointType\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointType , properties ) ; } public void addEntryPoint ( String path , IEntryPointFactory entryPointFactory , Map < String , String > properties ) { ParamCheck . notNull ( path , \"path\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByPath ( path , entryPointFactory , properties ) ; } public void addEntryPointByParameter ( String parameter , Class < ? extends IEntryPoint > type ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( type , \"type\" ) ; applicationContext . getEntryPointManager ( ) . registerByName ( parameter , type ) ; } public void addEntryPointByParameter ( String parameter , IEntryPointFactory entryPointFactory ) { ParamCheck . notNull ( parameter , \"parameter\" ) ; ParamCheck . notNull ( entryPointFactory , \"entryPointFactory\" ) ; applicationContext . getEntryPointManager ( ) . registerByName", "gt": "( parameter , entryPointFactory ) ;", "prediction": "( parameter , type ) ;\n", "label": 1}
{"id": 3036, "input": "<s> public class InstanceOf2 { boolean m ( ) { return this . getClass", "gt": "( ) instanceof Class < InstanceOf2 > ;", "prediction": "( ) != null ;\n", "label": 0}
{"id": 15076, "input": "<s> package org . apache . lucene . analysis . payloads ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . WhitespaceTokenizer ; import org . apache . lucene . analysis . tokenattributes . PayloadAttribute ; import org . apache . lucene . analysis . tokenattributes . TermAttribute ; import org . apache . lucene . index . Payload ; import org . apache . lucene . util . LuceneTestCase ; import java . io . StringReader ; public class DelimitedPayloadTokenFilterTest extends LuceneTestCase { public void testPayloads ( ) throws Exception { String test = \"The quick|JJ red|JJ fox|NN jumped|VB over the lazy|JJ brown|JJ dogs|NN\" ; DelimitedPayloadTokenFilter filter = new DelimitedPayloadTokenFilter ( new WhitespaceTokenizer ( new StringReader ( test ) ) ) ; TermAttribute termAtt = ( TermAttribute ) filter . getAttribute ( TermAttribute . class ) ; PayloadAttribute payAtt = ( PayloadAttribute ) filter . getAttribute ( PayloadAttribute . class ) ; assertTermEquals ( \"The\" , filter , termAtt , payAtt , null ) ; assertTermEquals ( \"quick\" , filter , termAtt , payAtt , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"red\" , filter , termAtt , payAtt , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"fox\" , filter , termAtt , payAtt , \"NN\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"jumped\" , filter , termAtt , payAtt , \"VB\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"over\" , filter , termAtt , payAtt , null ) ; assertTermEquals ( \"the\" , filter , termAtt , payAtt , null ) ; assertTermEquals ( \"lazy\" , filter , termAtt , payAtt , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"brown\" , filter , termAtt , payAtt , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"dogs\" , filter , termAtt , payAtt , \"NN\" . getBytes ( \"UTF-8\" ) ) ; assertFalse ( filter . incrementToken ( ) ) ; } public void testNext ( ) throws Exception { String test = \"The quick|JJ red|JJ fox|NN jumped|VB over the lazy|JJ brown|JJ dogs|NN\" ; DelimitedPayloadTokenFilter filter = new DelimitedPayloadTokenFilter ( new WhitespaceTokenizer ( new StringReader ( test ) ) ) ; assertTermEquals ( \"The\" , filter , null ) ; assertTermEquals ( \"quick\" , filter , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"red\" , filter , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"fox\" , filter , \"NN\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"jumped\" , filter , \"VB\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"over\" , filter , null ) ; assertTermEquals ( \"the\" , filter , null ) ; assertTermEquals ( \"lazy\" , filter , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"brown\" , filter , \"JJ\" . getBytes ( \"UTF-8\" ) ) ; assertTermEquals ( \"dogs\" , filter , \"NN\" . getBytes ( \"UTF-8\" ) ) ; assertFalse ( filter . incrementToken ( ) ) ; } public void testFloatEncoding ( ) throws Exception { String test = \"The quick|1.0 red|2.0 fox|3.5 jumped|0.5 over the lazy|5 brown|99.3 dogs|83.7\" ; DelimitedPayloadTokenFilter filter = new DelimitedPayloadTokenFilter ( new WhitespaceTokenizer ( new StringReader ( test ) ) , '|' , new FloatEncoder ( ) ) ; TermAttribute termAtt = ( TermAttribute ) filter . getAttribute ( TermAttribute . class ) ; PayloadAttribute payAtt = ( PayloadAttribute ) filter . getAttribute ( PayloadAttribute . class ) ; assertTermEquals ( \"The\" , filter , termAtt , payAtt , null ) ; assertTermEquals ( \"quick\" , filter , termAtt , payAtt , PayloadHelper . encodeFloat ( 1.0f ) ) ; assertTermEquals ( \"red\" , filter , termAtt , payAtt , PayloadHelper . encodeFloat ( 2.0f ) ) ; assertTermEquals ( \"fox\" , filter , termAtt , payAtt , PayloadHelper . encodeFloat ( 3.5f ) ) ; assertTermEquals ( \"jumped\" , filter , termAtt", "gt": ", payAtt , PayloadHelper . encodeFloat ( 0.5f ) ) ;", "prediction": ", payAtt , PayloadHelper . encodeFloat ( 4.0f ) ) ;\n", "label": 1}
{"id": 3948, "input": "<s> import java . io . * ; import java . net . * ; import java . util . * ; import javax . tools . * ; import com . sun . source . util . * ; public class ExtraSemiTest { static class JavaSource extends SimpleJavaFileObject { final static String source = \"class C {\\n\" + \"    int x;;\\n\" + \"    class X { int i;; };\\n\" + \"}\" ; JavaSource ( ) { super ( URI . create ( \"myfo:/C.java\" ) , JavaFileObject . Kind . SOURCE ) ; } @ Override public CharSequence getCharContent ( boolean ignoreEncodingErrors ) { return source ; } } public static void main ( String ... args ) throws IOException { new ExtraSemiTest ( ) . run ( ) ; } void run ( ) throws IOException { File destDir = new File ( \"classes\" ) ; destDir . mkdir ( ) ; final JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; JavaSource source = new JavaSource ( ) ; JavacTask ct = ( JavacTask ) tool . getTask ( null , null , null , Arrays . asList ( \"-d\" , destDir . getPath ( ) , \"-XD-printsource\" ) , null , Arrays . asList ( source ) ) ; Boolean ok = ct . call ( ) ; if ( ! ok ) throw new AssertionError ( \"compilation failed\" ) ; String text = readFile ( new File ( destDir , \"C.java\" ) ) ; System . out . println ( text ) ; String canon = text . replaceAll ( \"\\\\s+\" , \" \" ) ; System . out . println ( \"canon: \" + canon ) ; if ( canon . contains ( \"{ }\" ) ) throw new AssertionError ( \"unexpected empty block found\" ) ; } String readFile ( File f ) throws IOException { int len = ( int ) f . length ( ) ; byte [ ] data = new byte [ len ] ; DataInputStream in = new DataInputStream ( new FileInputStream ( f ) ) ; try { in . readFully ( data ) ; return new String ( data ) ; } finally { in", "gt": ". close ( ) ;", "prediction": ". close ( ) ;\n", "label": 0}
{"id": 15084, "input": "<s> package org . nuxeo . ecm . automation . jsf . operations ; import org . jboss . seam . core . Events ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . automation . core . util . StringList ; import org . nuxeo . ecm . automation . jsf . OperationHelper ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . ui . web . api . NavigationContext ; import org . nuxeo . ecm . webapp . helpers . EventNames ; @ Operation ( id = RefreshUI . ID , category = Constants . CAT_UI , requires = Constants . SEAM_CONTEXT , label = \"Refresh\" , description = \"Refresh the UI cache. This is a void operation - the input object is returned back as the oputput\" ) public class RefreshUI { public static final String ID = \"Seam.Refresh\" ; @ Param ( name = \"additional list of seam events to raise\" , required = false ) protected StringList additionalSeamEvents ; @ OperationMethod public void run ( ) { OperationHelper . getContentViewActions ( ) . resetAllContent ( ) ; NavigationContext context = OperationHelper . getNavigationContext ( ) ; DocumentModel dm = context . getCurrentDocument ( ) ; if", "gt": "( dm != null )", "prediction": "( dm instanceof NavigationContext )\n", "label": 1}
{"id": 2417, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . platzverkauf ; import java . awt . Component ; import java . awt . Dimension ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import javax . swing . JComponent ; import javax . swing . JLabel ; import de . uni_hamburg . informatik . swt . se2 . kino . fachwerte . Platz ; class JPlatzplan extends JComponent { public static Dimension PLATZBUTTON_GROESSE = new Dimension ( 22 , 22 ) ; private JPlatzButton [ ] [ ] _buttons ; private ActionListener _buttonListener ; private Set < Platz > _ausgewaehltePlaetze ; private List < PlatzSelectionListener > _selectionListener ; public JPlatzplan ( ) { setLayout ( new GridBagLayout ( ) ) ; erzeugePlatzAuswahlListener ( ) ; _ausgewaehltePlaetze = new HashSet < Platz > ( ) ; _selectionListener = new ArrayList < PlatzSelectionListener > ( ) ; } private void erzeugePlatzAuswahlListener ( ) { _buttonListener = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JPlatzButton button = ( JPlatzButton ) e . getSource ( ) ; Platz platz = button . getPlatz ( ) ; if ( _ausgewaehltePlaetze . contains ( platz ) ) { _ausgewaehltePlaetze . remove ( platz ) ; button . setAusgewaehlt ( false ) ; informiereSelectionListener ( _ausgewaehltePlaetze ) ; } else { _ausgewaehltePlaetze . add ( platz ) ; button . setAusgewaehlt ( true ) ; informiereSelectionListener ( _ausgewaehltePlaetze ) ; } } } ; } public void addPlatzSelectionListener ( PlatzSelectionListener listener ) { _selectionListener . add ( listener ) ; } public void removePlatzSelectionListener ( PlatzSelectionListener listener ) { _selectionListener . remove ( listener ) ; } private void informiereSelectionListener ( Set < Platz > ausgewaehltePlaetze ) { PlatzSelectionEvent event = new PlatzSelectionEvent ( this , ausgewaehltePlaetze ) ; for ( PlatzSelectionListener listener : _selectionListener ) { listener . auswahlGeaendert ( event ) ; } } public void setAnzahlPlaetze ( int anzahlReihen , int anzahlSitzeProReihe ) { assert anzahlReihen >= 0 : \"Vorbedingung verletzt: anzahlReihen >= 0\" ; assert anzahlSitzeProReihe >= 0 : \"Vorbedingung verletzt: anzahlSitzeProReihe >= 0\" ; removeAll ( ) ; _buttons = new JPlatzButton [ anzahlReihen ] [ anzahlSitzeProReihe ] ; for ( int reihe = 0 ; reihe < anzahlReihen ; reihe ++ ) { JLabel label = new JLabel ( \"Reihe \" + ( reihe + 1 ) + \":\" ) ; imGitterEinfuegen ( label , 0 , reihe ) ; for ( int sitz = 0 ; sitz < anzahlSitzeProReihe ; sitz ++ ) { JPlatzButton button = new JPlatzButton ( new Platz ( reihe , sitz ) ) ; button . setMinimumSize ( PLATZBUTTON_GROESSE ) ; button . setPreferredSize ( PLATZBUTTON_GROESSE ) ; imGitterEinfuegen ( button , sitz + 1 , reihe ) ; button . addActionListener ( _buttonListener ) ; _buttons [ reihe ] [ sitz ] = button ; } } revalidate ( ) ; repaint ( ) ; _ausgewaehltePlaetze . clear ( ) ;", "gt": "informiereSelectionListener ( _ausgewaehltePlaetze ) ;", "prediction": "}\n", "label": 0}
{"id": 15104, "input": "<s> package org . eclipse . ui . internal . presentations . util ; import org . eclipse . swt . graphics . Rectangle ; public abstract class AbstractTabItem { public abstract Rectangle getBounds ( ) ; public abstract void setInfo ( PartInfo info ) ; public abstract void dispose ( ) ; public void", "gt": "setBusy ( boolean busy )", "prediction": "dispose ( ) ;\n", "label": 1}
{"id": 4856, "input": "<s> package org . msl . simple . gmfmap . diagram . core ; import org . eclipse . emf . transaction . TransactionalEditingDomain ; import org . eclipse . emf . workspace . WorkspaceEditingDomainFactory ; import org . eclipse . gmf . runtime . diagram . core . DiagramEditingDomainFactory ; import org . msl . simple . gmfmap . model . triggers . compartment . CompartmentTriggerListener ; import org . msl . simple . gmfmap . model . triggers . compartment . SimpleCompartmentTriggerListener ; import org . msl . simple . gmfmap . model . triggers . graph . FigureDescriptorTriggerListener ; import org . msl . simple . gmfmap . model . triggers . graph . RealFigureTriggerListener ; import org . msl . simple . gmfmap . model . triggers . link . SimpleLinkMappingTriggerListener ; import org . msl . simple . gmfmap . model . triggers . mapping . MappingEntryTriggerListener ; import org . msl . simple . gmfmap . model . triggers . parent . ParentNodeTriggerListener ; import org . msl . simple . gmfmap . model . triggers . references . SimpleChildReferenceTriggerListener ; public class SimpleMapDiagramEditingDomainFactory extends DiagramEditingDomainFactory { private static SimpleMapDiagramEditingDomainFactory instance = new SimpleMapDiagramEditingDomainFactory ( ) ; public static WorkspaceEditingDomainFactory getInstance ( ) { return instance ; } @ Override protected void configure ( TransactionalEditingDomain domain ) { super . configure ( domain ) ; domain . addResourceSetListener ( new SimpleCompartmentTriggerListener ( ) ) ; domain . addResourceSetListener (", "gt": "new ParentNodeTriggerListener ( ) ) ;", "prediction": "new SimpleLinkMappingTriggerListener ( ) ) ;\n", "label": 0}
{"id": 15109, "input": "<s> package org . nuxeo . ecm . automation . core . operations . execution ; import java . util . HashMap ; import java . util . Map ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . OperationContext ; import org . nuxeo . ecm . automation . core . Constants ; import org . nuxeo . ecm . automation . core . annotations . Context ; import org . nuxeo . ecm . automation . core . annotations . Operation ; import org . nuxeo . ecm . automation . core . annotations . OperationMethod ; import org . nuxeo . ecm . automation . core . annotations . Param ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . core . api . DocumentModelList ; import org . nuxeo . ecm . core . api . impl . DocumentModelListImpl ; @ Operation ( id = RunDocumentChain . ID , category = Constants . CAT_SUBCHAIN_EXECUTION , label = \"Run Document Chain\" , description = \"Run an operation chain which is returning a document in the current context. The input for the chain ro run is the current input of the operation. Return the output of the chain as a document.\" ) public class RunDocumentChain { public static final String ID = \"Context.RunDocumentOperation\" ; @ Context protected OperationContext ctx ; @ Context protected AutomationService service ; @ Param ( name = \"id\" ) protected String chainId ; @ Param ( name = \"isolate\" , required = false , values = \"false\" ) protected boolean isolate = false ; @ OperationMethod public DocumentModel run ( DocumentModel doc ) throws Exception { Map < String , Object > vars = isolate ? new HashMap < String , Object > ( ctx . getVars ( ) ) : ctx . getVars ( ) ; OperationContext subctx = new", "gt": "OperationContext ( ctx . getCoreSession ( ) , vars ) ;", "prediction": "OperationContext ( ctx ) ;\n", "label": 1}
{"id": 9126, "input": "<s> package org . ofbiz . entity . jdbc ; import java . sql . ResultSet ; import java . sql . SQLException ; public interface ExecQueryCallbackFunctionIF { public", "gt": "boolean processNextRow ( ResultSet rs ) throws SQLException ;", "prediction": "void execute ( ) ;\n", "label": 0}
{"id": 15112, "input": "<s> package br . org . archimedes . extend ; import java . util . Collection ; import br . org . archimedes . exceptions . NullArgumentException ; import br . org . archimedes . interfaces . ExtendManager ; import br . org . archimedes . model . Element ; import br .", "gt": "org . archimedes . model . Point ;", "prediction": "org . archimedes . model . Point ;\n", "label": 1}
{"id": 4748, "input": "<s> import java . util . * ; class CastTest { private interface DA < T > { } private interface DB < T > extends DA < T > { } private interface DC < T > extends DA < Integer > { } private < N extends Number , I extends Integer , R extends Runnable , S extends String > void disjointness ( ) { Object o ; o = ( DA < I > ) ( DA", "gt": "< ? extends Number > ) null ;", "prediction": "< Integer > ) o ;\n", "label": 0}
{"id": 15131, "input": "<s> package org . eclipse . ui . internal . presentations ; import org . eclipse . jface . action . ActionContributionItem ; public class UpdatingActionContributionItem extends ActionContributionItem { public UpdatingActionContributionItem ( ISelfUpdatingAction action ) { super ( action ) ; } public boolean isVisible ( ) { ISelfUpdatingAction action = ( ISelfUpdatingAction ) getAction ( ) ; return super . isVisible ( ) && action . shouldBeVisible ( ) ; } public void update ( String propertyName ) { ISelfUpdatingAction action", "gt": "= ( ISelfUpdatingAction ) getAction ( ) ;", "prediction": "= ( ISelfUpdatingAction ) getAction ( ) ;\n", "label": 1}
{"id": 2065, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Scheduled ; public class ScheduledImpl extends TaskAttributeImpl implements Scheduled { protected static final boolean SCHEDULED_EDEFAULT = false ; protected boolean scheduled = SCHEDULED_EDEFAULT ; protected ScheduledImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getScheduled ( ) ; } public boolean isScheduled ( ) { return scheduled ; } public void setScheduled ( boolean newScheduled ) { boolean oldScheduled = scheduled ; scheduled = newScheduled ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . SCHEDULED__SCHEDULED , oldScheduled , scheduled ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . SCHEDULED__SCHEDULED : return isScheduled ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . SCHEDULED__SCHEDULED : setScheduled", "gt": "( ( Boolean ) newValue ) ;", "prediction": "( newValue ) ;\n", "label": 0}
{"id": 15142, "input": "<s> package org . restlet . test . ext . jaxrs . services . resources ; import javax . ws . rs . GET ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . core . Context ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . PathSegment ; import javax . ws . rs . core . UriInfo ; import javax . ws . rs . ext . ContextResolver ; import javax . ws . rs . ext . Providers ; import org . restlet . test . ext . jaxrs . services . tests . ContextsTest ; @ Path ( \"contextTest\" ) public class ContextsTestService { @ Context Providers providers ; void setProviders ( Providers providers ) { this . contextResolver = providers . getContextResolver ( Integer . class , MediaType . WILDCARD_TYPE ) ; } ContextResolver < Integer > contextResolver ; @ Context UriInfo uriInfo ; @ GET @ Produces ( \"text/plain\" ) @ Path ( \"fields\" ) public String fieldsAvailable ( ) { final StringBuilder stb = new StringBuilder ( ) ; if ( this . providers != null ) { stb . append ( \"providers\\n\" ) ; } if ( this . contextResolver != null ) { stb . append ( \"contextResolver\\n\" ) ; } if ( this . uriInfo != null ) { stb . append ( \"uriInfo\\n\" ) ; } return stb . toString ( ) ; } @ GET @ Produces ( \"text/plain\" ) @ Path ( \"lastPathSegm\"", "gt": ") public String getPathSegm ( @ Context PathSegment lastPathSegment )", "prediction": ") public String lastPathSegm ( )\n", "label": 1}
{"id": 2482, "input": "<s> package p ; public class Base {", "gt": "public void m ( )", "prediction": "private static final long serialVersionUID = 1L ;\n", "label": 0}
{"id": 15151, "input": "<s> package org . vaadin . addon . vodatime . testbenchtests ; import org . eclipse . jetty . server . Server ; import org . junit . After ; import org . junit . Before ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . firefox . FirefoxDriver ; import org . vaadin . addon . vodatime . demoandtestapp . TestServer ; public class AbstractWebDriverCase { protected static final int TESTPORT = 5678 ; protected static final String BASEURL = \"http://localhost:\" + TESTPORT + \"/\" ; protected WebDriver driver ; private Server server ; public AbstractWebDriverCase ( ) { super ( ) ; } @ Before public void setUp ( ) { try { server = TestServer . startServer ( TESTPORT ) ; } catch ( Exception e ) { e", "gt": ". printStackTrace ( ) ;", "prediction": ". printStackTrace ( ) ;\n", "label": 1}
{"id": 7391, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . text . * ; public class LOCRecord extends Record { private static final long serialVersionUID = 9058224788126750409L ; private static NumberFormat w2 , w3 ; private long size , hPrecision , vPrecision ; private long latitude , longitude , altitude ; static { w2 = new DecimalFormat ( ) ; w2 . setMinimumIntegerDigits ( 2 ) ; w3 = new DecimalFormat ( ) ; w3 . setMinimumIntegerDigits ( 3 ) ; } LOCRecord ( ) { } Record getObject ( ) { return new LOCRecord ( ) ; } public LOCRecord ( Name name , int dclass , long ttl , double latitude , double longitude , double altitude , double size , double hPrecision , double vPrecision ) { super ( name , Type . LOC , dclass , ttl ) ; this . latitude = ( long ) ( latitude * 3600 * 1000 + ( 1L << 31 ) ) ; this . longitude = ( long ) ( longitude * 3600 * 1000 + ( 1L << 31 ) ) ; this . altitude = ( long ) ( ( altitude + 100000 ) * 100 ) ; this . size = ( long ) ( size * 100 ) ; this . hPrecision = ( long ) ( hPrecision * 100 ) ; this . vPrecision = ( long ) ( vPrecision * 100 ) ; } void rrFromWire ( DNSInput in ) throws IOException { int version ; version = in . readU8 ( ) ; if ( version != 0 ) throw new WireParseException ( \"Invalid LOC version\" ) ; size = parseLOCformat ( in . readU8 ( ) ) ; hPrecision = parseLOCformat ( in . readU8 ( ) ) ; vPrecision = parseLOCformat ( in . readU8 ( ) ) ; latitude = in . readU32 ( ) ; longitude = in . readU32 ( ) ; altitude = in . readU32 ( ) ; } private double parseFixedPoint ( String s ) { if ( s . matches ( \"^-?\\\\d+$\" ) ) return Integer . parseInt ( s ) ; else if ( s . matches ( \"^-?\\\\d+\\\\.\\\\d*$\" ) ) { String [ ] parts = s . split ( \"\\\\.\" ) ; double value = Integer . parseInt ( parts [ 0 ] ) ; double fraction = Integer . parseInt ( parts [ 1 ] ) ; if ( value < 0 ) fraction *= - 1 ; int digits = parts [ 1 ] . length ( ) ; return value + ( fraction / Math . pow ( 10 , digits ) ) ; } else throw new NumberFormatException ( ) ; } private long parsePosition ( Tokenizer st , String type ) throws IOException { boolean isLatitude = type . equals ( \"latitude\" ) ; int deg = 0 , min = 0 ; double sec = 0 ; long value ; String s ; deg = st . getUInt16 ( ) ; if ( deg > 180 || ( deg > 90 && isLatitude ) ) throw st . exception ( \"Invalid LOC \" + type + \" degrees\" ) ; s = st . getString ( ) ; try { min = Integer . parseInt ( s ) ; if ( min < 0 || min > 59 ) throw st . exception ( \"Invalid LOC \" + type + \" minutes\" ) ; s = st . getString ( ) ; sec = parseFixedPoint ( s ) ; if ( sec < 0 || sec >= 60 ) throw st . exception ( \"Invalid LOC \" + type + \" seconds\" ) ; s = st . getString ( ) ; } catch ( NumberFormatException e ) { } if ( s . length ( ) != 1 ) throw st . exception ( \"Invalid LOC \" + type ) ; value = ( long ) ( 1000 * ( sec + 60L * ( min + 60L * deg ) ) ) ; char c = Character . toUpperCase ( s . charAt ( 0 ) ) ; if ( ( isLatitude && c == 'S' ) || ( ! isLatitude && c == 'W'", "gt": ") ) value = - value ;", "prediction": ") )\n", "label": 0}
{"id": 15164, "input": "<s> package org . eclipse . ui . tests . decorators ; public class TableElement extends TestElement { int index ; public TableElement ( int newIndex ) { super ( ) ; index = newIndex ; name = \"Table Item \"", "gt": "+ String . valueOf ( index ) ;", "prediction": ";\n", "label": 1}
{"id": 545, "input": "<s> package Liza ; import org . bukkit . World ;", "gt": "public interface LizaWorld extends World", "prediction": "import org . bukkit . Widget ;\n", "label": 0}
{"id": 15166, "input": "<s> package org . restlet . engine . util ; import org . restlet . Request ; import org . restlet . data . Reference ; import org . restlet . engine . security . AuthenticatorUtils ; public class ReferenceUtils { public static Reference update ( Reference resourceRef , Request request ) { Reference result = resourceRef . isAbsolute ( ) ? resourceRef : resourceRef . getTargetRef ( ) ; result = AuthenticatorUtils . updateReference ( result , request . getChallengeResponse ( ) , request ) ; return result ; } public static String format ( Reference resourceRef , boolean isProxied , Request request ) { String result = null ; Reference requestRef = update ( resourceRef , request ) ; if ( isProxied ) { result = requestRef . getIdentifier ( ) ; } else { if ( requestRef", "gt": ". hasQuery ( ) )", "prediction": "== null )\n", "label": 1}
{"id": 313, "input": "<s> package org . remast . text ; import java . text . ParseException ; import java . text . ParsePosition ; import java . util . Date ; import com . google . common . base . Strings ; @ SuppressWarnings ( \"serial\" ) public class SmartTimeFormat extends TimeFormat { public final Date parse ( final String source , final ParsePosition pos ) { String time = source ; time = Strings . nullToEmpty ( time ) . trim ( ) ; if ( time . length ( ) == 0 ) { return super . parse ( time , pos ) ; } time = normalize ( time ) ; return super . parse ( time , pos ) ; } public static int [ ] parseToHourAndMinutes ( final String timeString ) throws ParseException { String time = timeString ; time = Strings . nullToEmpty ( time ) . trim ( ) ; if ( time . length ( ) == 0 ) { throw new ParseException ( \"String is empty\" , 1 ) ; } time = normalize ( time ) ; String [ ] splitted = time . split ( \":\" ) ; if ( splitted . length != 2 ) { throw new ParseException ( \"String '\" + timeString + \"' has an unsupported format\" , 1 ) ; } else { int [ ] result = new int [ 2 ] ; for ( int i = 0 ; i < 2 ; i ++ ) { result [ i ] = Integer . parseInt ( splitted [ i ] ) ; } return result ; } } private static String normalize ( final String timeString ) { String time = Strings . emptyToNull ( timeString ) ; time = time", "gt": ". replace ( \",,\" , \":\" ) ;", "prediction": "String ;\n", "label": 0}
{"id": 15172, "input": "<s> package org . eclipse . jface . viewers ; public interface IDoubleClickListener { public void", "gt": "doubleClick ( DoubleClickEvent event ) ;", "prediction": "setUp ( ) ;\n", "label": 1}
{"id": 3938, "input": "<s> package org . ofbiz . minilang . operation ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import org . w3c . dom . Element ; public abstract class MakeInStringOperation { public MakeInStringOperation ( Element element ) { } public abstract String exec ( Map < String , Object > inMap , List < Object > messages ,", "gt": "Locale locale , ClassLoader loader ) ;", "prediction": "Element element )\n", "label": 0}
{"id": 15185, "input": "<s> package org . apache . lucene . index ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . FieldSelector ; import org . apache . lucene . document . FieldSelectorResult ; import org . apache . lucene . document . Fieldable ; import org . apache . lucene . search . FieldCache ; import java . io . IOException ; import java . util . * ; public class ParallelReader extends IndexReader { private List readers = new ArrayList ( ) ; private List decrefOnClose = new ArrayList ( ) ; boolean incRefReaders = false ; private SortedMap fieldToReader = new TreeMap ( ) ; private Map readerToFields = new HashMap ( ) ; private List storedFieldReaders = new ArrayList ( ) ; private int maxDoc ; private int numDocs ; private boolean hasDeletions ; public ParallelReader ( ) throws IOException { this ( true ) ; } public ParallelReader ( boolean closeSubReaders ) throws IOException { super ( ) ; this . incRefReaders = ! closeSubReaders ; } public void add ( IndexReader reader ) throws IOException { ensureOpen ( ) ; add ( reader , false ) ; } public void add ( IndexReader reader , boolean ignoreStoredFields ) throws IOException { ensureOpen ( ) ; if ( readers . size ( ) == 0 ) { this . maxDoc = reader . maxDoc ( ) ; this . numDocs = reader . numDocs ( ) ; this . hasDeletions = reader . hasDeletions ( ) ; } if ( reader . maxDoc ( ) != maxDoc ) throw new IllegalArgumentException ( \"All readers must have same maxDoc: \" + maxDoc + \"!=\" + reader . maxDoc ( ) ) ; if ( reader . numDocs ( ) != numDocs ) throw new IllegalArgumentException ( \"All readers must have same numDocs: \" + numDocs + \"!=\" + reader . numDocs ( ) ) ; Collection fields = reader . getFieldNames ( IndexReader . FieldOption . ALL ) ; readerToFields . put ( reader , fields ) ; Iterator i = fields . iterator ( ) ; while ( i . hasNext ( ) ) { String field = ( String ) i . next ( ) ; if ( fieldToReader . get ( field ) == null ) fieldToReader . put ( field , reader ) ; } if ( ! ignoreStoredFields ) storedFieldReaders . add ( reader ) ; readers . add ( reader ) ; if ( incRefReaders ) { reader . incRef ( ) ; } decrefOnClose . add ( Boolean . valueOf ( incRefReaders ) ) ; } public synchronized Object clone ( ) { try { return doReopen ( true ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } public synchronized IndexReader reopen ( ) throws CorruptIndexException , IOException { return doReopen ( false ) ; } protected IndexReader doReopen ( boolean", "gt": "doClone ) throws CorruptIndexException , IOException", "prediction": "closed ) throws CorruptIndexException , IOException\n", "label": 1}
{"id": 9849, "input": "<s> package com . sun . source . tree ; import java . util . List ; public interface BlockTree extends StatementTree { boolean isStatic ( ) ;", "gt": "List < ? extends StatementTree > getStatements ( ) ;", "prediction": "boolean isDynamic ( ) ;\n", "label": 0}
{"id": 15190, "input": "<s> package org . eclipse . rap . rwt . internal . lifecycle ; import java . io . IOException ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . swt . widgets . Display ; abstract class PhaseExecutor { private final PhaseListenerManager phaseListenerManager ; private final IPhase [ ] phases ; PhaseExecutor ( PhaseListenerManager phaseListenerManager , IPhase [ ] phases ) { this . phaseListenerManager = phaseListenerManager ; this . phases = phases ; } final void execute ( PhaseId startPhaseId ) throws IOException { PhaseId currentPhaseId = startPhaseId ; while ( currentPhaseId != null ) { IPhase currentPhase = findPhase ( currentPhaseId ) ; CurrentPhase . set ( currentPhaseId ) ; phaseListenerManager", "gt": ". notifyBeforePhase ( currentPhaseId ) ;", "prediction": ". execute ( currentPhaseId ) ;\n", "label": 1}
{"id": 5902, "input": "<s> package org . dawb . workbench . plotting . tools . fitting ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStreamWriter ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import ncsa . hdf . object . Dataset ; import ncsa . hdf . object . Datatype ; import ncsa . hdf . object . h5 . H5Datatype ; import org . dawb . common . ui . image . IconUtils ; import org . dawb . common . ui . menu . CheckableActionGroup ; import org . dawb . common . ui . menu . MenuAction ; import org . dawb . common . ui . plot . annotation . AnnotationUtils ; import org . dawb . common . ui . plot . annotation . IAnnotation ; import org . dawb . common . ui . plot . region . IRegion ; import org . dawb . common . ui . plot . region . IRegion . RegionType ; import org . dawb . common . ui . plot . region . IRegionListener ; import org . dawb . common . ui . plot . region . RegionEvent ; import org . dawb . common . ui . plot . region . RegionUtils ; import org . dawb . common . ui . plot . tool . AbstractToolPage ; import org . dawb . common . ui . plot . tool . IDataReductionToolPage ; import org . dawb . common . ui . plot . tool . IToolPage ; import org . dawb . common . ui . plot . trace . ILineTrace ; import org . dawb . common . ui . plot . trace . ITrace ; import org . dawb . common . ui . plot . trace . ITraceListener ; import org . dawb . common . ui . plot . trace . TraceEvent ; import org . dawb . common . ui . plot . trace . TraceUtils ; import org . dawb . common . ui . util . EclipseUtils ; import org . dawb . gda . extensions . loaders . H5Utils ; import org . dawb . hdf5 . IHierarchicalDataFile ; import org . dawb . hdf5 . Nexus ; import org . dawb . hdf5 . nexus . NexusUtils ; import org . dawb . workbench . plotting . Activator ; import org . dawb . workbench . plotting . preference . FittingConstants ; import org . dawb . workbench . plotting . preference . FittingPreferencePage ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . draw2d . ColorConstants ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . MenuManager ; import org . eclipse . jface . action . Separator ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . jface . viewers . ColumnViewerToolTipSupport ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . TableViewerColumn ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse .", "gt": "jface . window . ToolTip ;", "prediction": "swt . SWT ;\n", "label": 0}
{"id": 15191, "input": "<s> package org . restlet . test . resource ; import org . restlet . data . Form ; import org . restlet . resource . ServerResource ; public class MyResource9 extends ServerResource { @ SIMethod ( \"form:html\" ) public String si1 ( Form form ) { return \"si-html+form\" ; } @ SIMethod ( \"txt:html\" ) public String si2 ( String txt ) { return \"si-html+txt\" ; } @ SIMethod ( \"txt\" ) public String si3 ( String txt ) { return \"si-string+\" + txt ; } @ SIMethod ( \"form:txt\" ) public String si4 ( Form form ) { return \"si-string+form\" ; } @ SNIMethod ( \"form:html\" ) public String sni1 ( Form form ) { return \"sni-html+form\" ; } @ SNIMethod ( \"txt:html\" ) public String sni2 ( String txt ) { return \"sni-html+txt\" ; } @ SNIMethod ( \"txt\" ) public String", "gt": "sni3 ( String txt )", "prediction": "sni3 ( String txt )\n", "label": 1}
{"id": 6782, "input": "<s> package org . remast . baralga . gui . model . report ; import java . util . Date ; import org . apache . commons . lang . builder . CompareToBuilder ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . joda . time . DateTime ; public class HoursByDay implements Comparable < HoursByDay > { private DateTime day ; private double hours ; public HoursByDay ( final DateTime day , final double hours ) { this . day = day ; this . hours = hours ; } public Date getDay ( ) { return day . toDate ( ) ; } public double getHours ( ) { return hours ; } @ Override public boolean equals ( final Object that ) { if ( this == that ) { return true ; } if ( ! ( that instanceof HoursByDay ) ) { return false ; } final HoursByDay accAct = ( HoursByDay ) that ; final EqualsBuilder equalsBuilder = new EqualsBuilder ( ) ; equalsBuilder . append ( day . getYear ( ) , accAct . day . getYear ( ) ) ; equalsBuilder . append ( day . getDayOfYear ( ) , accAct . day . getDayOfYear ( ) ) ; return equalsBuilder . isEquals ( ) ; } public void addHours ( final double additionalHours ) { this . hours += additionalHours ; } @ Override public int compareTo ( final HoursByDay that ) { if ( that == null ) { return 0 ; } if ( this . equals ( that ) ) { return 0 ; } final CompareToBuilder compareBuilder = new CompareToBuilder ( ) ; compareBuilder . append ( day . getYear ( ) , that . day . getYear ( ) ) ; compareBuilder . append ( day . getDayOfYear ( ) , that", "gt": ". day . getDayOfYear ( ) ) ;", "prediction": ". day . getDayOfYear ( ) ) ;\n", "label": 0}
{"id": 15202, "input": "<s> package org . nuxeo . ecm . platform . preview . adapter . factories ; import org . nuxeo . ecm . core . api . DocumentModel ; import org . nuxeo . ecm . platform . preview . adapter . PreviewAdapterFactory ; import org . nuxeo . ecm . platform . preview . adapter . base . ConverterBasedHtmlPreviewAdapter ; import org . nuxeo", "gt": ". ecm . platform . preview . api . HtmlPreviewAdapter ;", "prediction": ". ecm . platform . preview . adapter . base . ConverterBasedHtmlPreviewAdapterFactory ;\n", "label": 1}
{"id": 97, "input": "<s> package com . redhat . nitrate . command ; import com . redhat . nitrate . RequiredField ; import com . redhat . nitrate . TcmsArrayCommand ; import com . redhat . nitrate . TcmsHashCommand ; public class Build { public String milestone ; public String product ; public Integer product_id ; public Boolean is_active ; public String description ; public String name ; public Integer build_id ; public static class check_build extends TcmsArrayCommand { @ RequiredField public String name ; @ RequiredField public Integer productid ; } public static class create extends TcmsHashCommand { @ RequiredField public Integer product ; @ RequiredField public String name ; public String description ; public Boolean is_active ; } public static class get extends TcmsArrayCommand { @ RequiredField public Integer id ; } ; public static", "gt": "class get_caseruns extends Build . get", "prediction": "class set extends TcmsHashCommand\n", "label": 0}
{"id": 15212, "input": "<s> package org . seage . metaheuristic . tabusearch ; public interface ITabuSearch extends java . io . Serializable { public abstract void startSolving ( ) throws Exception ; public abstract void stopSolving ( ) ; public abstract boolean isSolving ( ) ; public abstract void addTabuSearchListener ( TabuSearchListener listener ) ; public abstract void removeTabuSearchListener ( TabuSearchListener listener ) ; public abstract void setObjectiveFunction ( ObjectiveFunction function ) throws Exception ; public abstract void setMoveManager ( MoveManager moveManager ) ; public abstract void setTabuList ( TabuList tabuList ) ; public abstract void setAspirationCriteria ( AspirationCriteria aspirationCriteria ) ; public abstract void setBestSolution ( Solution solution ) ; public abstract void setCurrentSolution ( Solution solution ) throws Exception ; public abstract void setIterationsToGo ( int iterations ) ; public abstract void setMaximizing ( boolean maximizing ) ; public abstract void setChooseFirstImprovingMove ( boolean choose ) ; public abstract boolean isChooseFirstImprovingMove ( ) ; public abstract ObjectiveFunction getObjectiveFunction ( ) ; public abstract MoveManager getMoveManager ( ) ; public abstract TabuList getTabuList ( ) ; public abstract AspirationCriteria getAspirationCriteria ( ) ; public abstract Solution getBestSolution ( ) ; public abstract Solution getCurrentSolution ( ) ; public abstract int getIterationsToGo ( ) ; public abstract", "gt": "int getIterationsCompleted ( ) ;", "prediction": "int getMaximizing ( ) ;\n", "label": 1}
{"id": 3390, "input": "<s> package org . ofbiz . webapp . event ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . DelegatorFactory ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceContainer ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . webapp . control . ConfigXMLReader . Event ; import org . ofbiz . webapp . control . ConfigXMLReader . RequestMap ; public class ServiceStreamHandler implements EventHandler { public static final String module = ServiceStreamHandler . class . getName ( ) ; protected LocalDispatcher dispatcher ; protected Delegator delegator ; public void init ( ServletContext context ) throws EventHandlerException { String delegatorName = context . getInitParameter ( \"entityDelegatorName\" ) ; this . delegator = DelegatorFactory . getDelegator ( delegatorName ) ; this . dispatcher = ServiceContainer . getLocalDispatcher ( this . delegator . getDelegatorName ( ) , delegator ) ; } public String invoke ( Event event , RequestMap requestMap , HttpServletRequest request , HttpServletResponse response ) throws EventHandlerException { InputStream in ; try { in = request . getInputStream ( ) ; } catch ( IOException e ) { throw new EventHandlerException ( e . getMessage ( ) , e ) ; } OutputStream out ; try { out = response . getOutputStream ( ) ; } catch ( IOException e ) { throw new EventHandlerException ( e . getMessage ( ) , e ) ; } Map < String , Object > context = FastMap . newInstance ( ) ; context . put ( \"inputStream\" , in ) ; context . put ( \"outputStream\" , out ) ; if ( Debug . infoOn ( ) ) Debug . logInfo ( \"Running service with context: \" + context , module ) ; Map < String , Object > resp ; try { resp = dispatcher . runSync ( event . invoke , context ) ; } catch ( GenericServiceException e ) { outputError ( out , e , \"Exception thrown in runSync()\" ) ; throw new EventHandlerException ( e . getMessage ( ) , e ) ; } Debug . logInfo ( \"Received respone: \" + resp , module ) ; if ( ServiceUtil . isError ( resp ) ) { outputError ( out , null , ServiceUtil . getErrorMessage ( resp ) ) ; throw new EventHandlerException ( ServiceUtil . getErrorMessage ( resp ) ) ; } String contentType = ( String )", "gt": "resp . get ( \"contentType\" ) ;", "prediction": "resp . getContentType ( ) ;\n", "label": 0}
{"id": 15219, "input": "<s> package org . eclipse . ui . internal . cheatsheets . registry ; import org . eclipse . core . runtime . * ; import org . eclipse . ui . internal . cheatsheets . * ; public abstract class RegistryReader { protected static final String TAG_DESCRIPTION = \"description\" ; RegistryReader ( ) { } String getDescription ( IConfigurationElement config ) { IConfigurationElement [ ] children = config . getChildren ( TAG_DESCRIPTION ) ; if ( children . length >= 1 ) { return children [ 0 ] . getValue ( ) ; } return ICheatSheetResource . EMPTY_STRING ; } private void logError ( IConfigurationElement element , String text ) { IExtension extension = element . getDeclaringExtension ( ) ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( \"Plugin \" + extension . getContributor ( ) . getName ( ) + \", extension \" + extension . getExtensionPointUniqueIdentifier ( ) ) ; buf . append ( \"\\n\" + text ) ; IStatus status = new Status ( IStatus . ERROR , ICheatSheetResource . CHEAT_SHEET_PLUGIN_ID , IStatus . OK , buf . toString ( ) , null ) ; CheatSheetPlugin . getPlugin ( ) . getLog ( ) . log ( status ) ; } void logMissingAttribute ( IConfigurationElement element , String attributeName ) { logError ( element , \"Required attribute '\" + attributeName + \"' not defined\" ) ; } private void logUnknownElement ( IConfigurationElement element ) { logError ( element , \"Unknown extension tag found: \" + element . getName ( ) ) ; } private IExtension [ ] orderExtensions ( IExtension [ ] extensions ) { Sorter sorter = new Sorter ( ) { public", "gt": "boolean compare ( Object extension1 , Object extension2 )", "prediction": "String toString ( )\n", "label": 1}
{"id": 9521, "input": "<s> package mage . tracker . repository ; import java . util . List ; import javax . persistence . EntityManager ; import javax . persistence . PersistenceContext ; import javax . persistence . TypedQuery ; import mage . tracker . domain . Expansion ; import org . springframework . stereotype . Repository ; @ Repository public class ExpansionRepository extends GenericRepository < Expansion > { @ PersistenceContext private EntityManager em ; public Expansion findByName ( String name ) { TypedQuery query = em . createNamedQuery ( Expansion . FIND_BY_NAME , Expansion . class ) ; query . setParameter ( \"name\" , name ) ; List < Expansion > resultList = query . getResultList ( ) ; if ( resultList . isEmpty ( ) ) { return null ; } else { return resultList . get ( 0 ) ; } } public Expansion findByCode ( String code ) { TypedQuery query = em . createNamedQuery ( Expansion . FIND_BY_CODE , Expansion . class ) ; query", "gt": ". setParameter ( \"code\" , code ) ;", "prediction": ". setParameter ( \"code\" , code ) ;\n", "label": 0}
{"id": 15242, "input": "<s> package br . com . learningjsf . managedbean ; import static br . com . learningjsf . util . Constants . CATEGORIA_VIEW ; import java . io . Serializable ; import java . util . Locale ; import java . util . Map ; import javax . enterprise . context . SessionScoped ; import javax . faces . context . FacesContext ; import javax . faces . event . ActionEvent ; import javax . inject . Named ; @ SessionScoped @ Named public class ApplicationInfo implements Serializable { private static final long serialVersionUID = 2626643946671596600L ; private Locale locale ; public String prepareCategoria ( ) { return CATEGORIA_VIEW ; } public void changeLocale ( ActionEvent evt ) { Map < String , String > params = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getRequestParameterMap ( ) ; String localeString = params . get ( \"locale\" ) ; Locale locale = new Locale ( localeString ) ; setLocale ( locale ) ; FacesContext . getCurrentInstance ( ) . getViewRoot (", "gt": ") . setLocale ( locale ) ;", "prediction": ") . setLocale ( locale ) ;\n", "label": 1}
{"id": 4864, "input": "<s> package org . gk . engine . client . event . attrib ; import com . extjs . gxt . ui . client . widget . BoxComponent ; import com . extjs . gxt . ui . client . widget . Component ; public class HeightAttribute implements IAttribute { @ Override public void setAttributeValue ( Component com , Object value ) { com . setHeight ( ( String ) value ) ; } @ Override public Object getAttributeValue ( Component com ) { Object value = null ; if ( com instanceof BoxComponent ) { BoxComponent bc = ( BoxComponent ) com ;", "gt": "value = bc . getHeight ( ) ;", "prediction": "if ( bc instanceof Rectangle )\n", "label": 0}
{"id": 15280, "input": "<s> package org . nuxeo . ecm . platform . annotations . gwt . client . view . listener ; import org . nuxeo . ecm . platform . annotations . gwt . client . AnnotationConstant ; import org . nuxeo . ecm . platform . annotations . gwt . client . controler . AnnotationController ; import org . nuxeo . ecm . platform . annotations . gwt . client . util . CSSClassManager ; import org . nuxeo . ecm . platform . annotations . gwt . client . view . annotater . Annotater ; import org . nuxeo . ecm . platform . annotations . gwt . client . view . annotater . ImageAnnotater ; import org . nuxeo . ecm . platform . annotations . gwt . client . view . annotater . TextAnnotater ; import com . google . gwt . dom . client . Element ; import com . google . gwt . user . client . Event ; import com . google . gwt . user . client . EventListener ; public class AnnotatedEventListener implements EventListener { private final Annotater imageAnnotater ; private final Annotater textAnnotater ; private final AnnotationController controller ; private Annotater lastUsedAnnotater ; public AnnotatedEventListener ( AnnotationController controller ) { this . imageAnnotater = new ImageAnnotater ( controller ) ; this . textAnnotater = new TextAnnotater ( controller ) ; this . controller = controller ; } public void onBrowserEvent ( Event event ) { if ( ! controller . canAnnotate ( ) ) { return ; } if ( event . getTarget ( ) == null ) { return ; } if ( event . getTypeInt ( ) == Event . ONMOUSEOUT ) { manageOnMouseOutEvent ( event ) ; return ; } if ( isOnImage ( event ) ) { annotateImage ( event ) ; } else if ( ! controller . isImageOnly ( ) ) { annotateText ( event ) ; } } private void manageOnMouseOutEvent ( Event event ) { if ( lastUsedAnnotater != null ) { lastUsedAnnotater . manageEvent ( event ) ; lastUsedAnnotater = null ; } } private boolean isOnImage ( Event event ) { Element element = event . getTarget ( ) ; if ( element . getNodeName ( ) . equalsIgnoreCase ( \"div\" ) ) { CSSClassManager cssManager = new CSSClassManager ( element ) ; if ( cssManager . isClassPresent ( AnnotationConstant . DECORATE_CLASS_NAME ) || cssManager . isClassPresent ( AnnotationConstant . DECORATE_NOT_CLASS_NAME", "gt": ") || cssManager . isClassPresent ( AnnotationConstant . DECORATE_AREA_CLASS_NAME ) )", "prediction": ") )\n", "label": 1}
{"id": 9856, "input": "<s> import java . util . * ; import dk . brics . automaton . * ; public class HashBenchmark { public static void main ( String [ ] args ) { Set < RunAutomaton > auts = new HashSet < RunAutomaton > ( ) ; RegExp re = new RegExp ( \"TEST\" ) ; Automaton a = re . toAutomaton ( ) ; RunAutomaton ra = new RunAutomaton ( a ) ; HashDispatcher . dispatch ( ra , 8 ) ; Runnable r = new Runnable ( ) { public void run ( ) { try { Thread . sleep ( 10000 ) ; } catch ( InterruptedException ie ) { } long tps = HashDispatcher . getKtps ( ) ; HashDispatcher . killAll ( ) ; System . out . println ( tps + \"", "gt": "kT/s over ~10 seconds.\" ) ;", "prediction": "\" + tps ) ;\n", "label": 0}
{"id": 15284, "input": "<s> package br . org . archimedes . io . svg ; import br . org . archimedes . Tester ; import br . org . archimedes . model . Point ; import org . junit . Test ; import static org .", "gt": "junit . Assert . assertEquals ;", "prediction": "junit . Assert ;\n", "label": 1}
{"id": 6253, "input": "<s> package ar . com . fdvs . dj . domain . constants ; public class LabelPosition extends BaseDomainConstant { private static final long serialVersionUID = 1L ; public static LabelPosition TOP = new LabelPosition ( ( byte ) 1 ) ; public static LabelPosition BOTTOM = new LabelPosition ( ( byte ) 3 ) ; public static LabelPosition LEFT = new LabelPosition ( ( byte ) 2 ) ; public static LabelPosition", "gt": "RIGHT = new LabelPosition ( ( byte ) 4 ) ;", "prediction": "RIGHT = new LabelPosition ( ( byte ) 1 ) ;\n", "label": 0}
{"id": 15291, "input": "<s> package br . org . archimedes . undo . internal ; import org . eclipse . osgi . util . NLS ; public class Messages extends NLS { private static final String BUNDLE_NAME = \"br.org.archimedes.undo.messages\" ; public static String notPerformed ; public static String UndoPerformed ; static { NLS . initializeMessages ( BUNDLE_NAME", "gt": ", Messages . class ) ;", "prediction": ") ;\n", "label": 1}
{"id": 4086, "input": "<s> package api . forum . thread ; import java . util . List ; public class Response { private Number currentPage ; private Number forumId ; private String forumName ; private boolean locked ; private Number pages ; private Poll poll ; private List < Posts > posts ; private boolean subscribed ; private Number threadId ; private String threadTitle ; private boolean sticky ; public Number getCurrentPage ( ) { return currentPage ; } public Number getForumId ( ) { return forumId ; } public String getForumName ( ) { return forumName ; } public boolean isLocked ( ) { return locked ; } public Number getPages ( ) { return pages ; } public Poll getPoll ( ) { return poll ; } public List < Posts > getPosts ( ) { return posts ; } public boolean isSubscribed ( ) { return subscribed ; } public Number getThreadId ( ) { return threadId ; } public String getThreadTitle ( ) { return threadTitle ; } public boolean isSticky ( ) { return sticky ; } @ Override public String toString ( ) { return \"Response [isSticky=\" + isSticky ( ) + \", isLocked=\" + isLocked ( ) + \", getCurrentPage=\" + getCurrentPage ( ) + \", getForumId=\" + getForumId ( ) + \", getForumName=\" + getForumName ( ) + \", getLocked=\" + isLocked ( ) + \", getPages=\" + getPages ( ) + \", getPoll=\" + getPoll ( ) + \", getPosts=\" + getPosts ( ) + \", isSubscribed=\" + isSubscribed ( ) + \", getThreadId=\" + getThreadId ( ) + \", getThreadTitle=\" +", "gt": "getThreadTitle ( ) + \"]\" ;", "prediction": "getThreadTitle ( ) + \", isSticky=\" + isSticky ( ) + \", isLocked=\" + isLocked ( ) + \", getPages=\" + getPages ( ) + \", getPoll=\" + getPoll ( ) + \", getPosts=\" + getPosts ( ) + \", isSubscribed=\" + isSubscribed ( ) + \", getThreadId=\" + getThreadId ( ) + \", getThreadTitle=\" + getThreadTitle ( ) + \", isSticky\n", "label": 0}
{"id": 15292, "input": "<s> package fr . inria . zvtm . animation ; public abstract class DefaultTimingHandler implements TimingHandler { public void begin ( Object subject , Animation . Dimension dim ) { } public void end ( Object subject , Animation . Dimension dim ) { } public void repeat (", "gt": "Object subject , Animation . Dimension dim )", "prediction": "Object subject , Animation . Dimension dim )\n", "label": 1}
{"id": 8282, "input": "<s> class T6521805c { static class Outer { T6521805c this$0 ( ) { return null ; } } public class Inner extends Outer {", "gt": "public void foo ( )", "prediction": "T6521805c this$1 ( )\n", "label": 0}
{"id": 15313, "input": "<s> package org . restlet . ext . odata ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; import org . restlet . Client ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . ChallengeResponse ; import org . restlet . data . CharacterSet ; import org . restlet . data . MediaType ; import org . restlet . data . Parameter ; import org . restlet . data . Preference ; import org . restlet . data . Protocol ; import org . restlet . data . Reference ; import org . restlet . data . Tag ; import org . restlet . engine . header . Header ; import org . restlet . engine . header . HeaderConstants ; import org . restlet . engine . header . HeaderReader ; import org . restlet . ext . atom . Content ; import org . restlet . ext . atom . Entry ; import org . restlet . ext . atom . Feed ; import org . restlet . ext . atom . Link ; import org . restlet . ext . atom . Relation ; import org . restlet . ext . odata . internal . EntryContentHandler ; import org . restlet . ext . odata . internal . edm . AssociationEnd ; import org . restlet . ext . odata . internal . edm . ComplexProperty ; import org . restlet . ext . odata . internal . edm . EntityContainer ; import org . restlet . ext . odata . internal . edm . EntityType ; import org . restlet . ext . odata . internal . edm . FunctionImport ; import org . restlet . ext . odata . internal . edm . Metadata ; import org . restlet . ext . odata . internal . edm . Property ; import org . restlet . ext . odata . internal . edm . TypeUtils ; import org . restlet . ext . odata . internal . reflect . ReflectUtils ; import org . restlet . ext . xml . DomRepresentation ; import org . restlet . ext . xml . SaxRepresentation ; import", "gt": "org . restlet . ext . xml . XmlWriter ;", "prediction": "org . restlet . ext . xml . StringRepresentation ;\n", "label": 1}
{"id": 2982, "input": "<s> package uk . ac . cam . cl . dtg . android . time . data . quadtree ; public class QuadTreeItem < E > implements Comparable < QuadTreeItem < E > > { @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( element == null ) ? 0 : element . hashCode ( ) ) ; result = prime * result + x ; result = prime * result + y ; return result ; } private E element ; private int x , y ; public QuadTreeItem ( E ele , int x , int y ) { element = ele ; this . x = x ; this . y = y ; } public E getElement ( ) { return element ; } public void setElement ( E element ) {", "gt": "this . element = element ;", "prediction": "this . element = element ;\n", "label": 0}
{"id": 15322, "input": "<s> package org . nuxeo . connect . client . status ; import java . util . ArrayList ; import java . util . List ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . connect . connector . http . ConnectUrlConfig ; import org . nuxeo . connect . data . DownloadablePackage ; import org . nuxeo . connect . data . SubscriptionStatusType ; import org . nuxeo . connect . identity . LogicalInstanceIdentifier ; import org . nuxeo . connect . identity . LogicalInstanceIdentifier . NoCLID ; import org . nuxeo . connect . packages . PackageManager ; import org . nuxeo . connect . update . PackageType ; import org . nuxeo . ecm . admin . runtime . PlatformVersionHelper ; import org . nuxeo . runtime . api . Framework ; public class ConnectUpdateStatusInfo { protected static final String UNREGISTERED = \"unregistered\" ; protected static final String ONLINE_REGISTERED = \"onlineregistered\" ; protected static final String CONNECT_UNREACHABLE = \"unreachable\" ; protected static final String EXPIRED = \"expired\" ; protected String type ; protected String bannerPath ; protected Integer availableUpdateCount ; protected String feedUrl ; protected boolean registered ; protected static Log log = LogFactory . getLog ( ConnectUpdateStatusInfo . class ) ; public static ConnectUpdateStatusInfo unregistered ( ) { ConnectUpdateStatusInfo status = new ConnectUpdateStatusInfo ( ) ; status . type = UNREGISTERED ; status . setBannerPath ( \"clientSideBanner\" ) ; status . feedUrl = buildFeedUrl ( false ) ; status . availableUpdateCount = 0 ; status . registered = false ; return status ; } public static ConnectUpdateStatusInfo ok ( ) { ConnectUpdateStatusInfo status = new ConnectUpdateStatusInfo ( ) ; status . type = ONLINE_REGISTERED ; status . registered = true ; return status ; } public static ConnectUpdateStatusInfo connectServerUnreachable ( ) { ConnectUpdateStatusInfo status = new ConnectUpdateStatusInfo ( ) ; status . type = CONNECT_UNREACHABLE ; status . setBannerPath ( \"clientSideBanner\" ) ; status . feedUrl = buildFeedUrl ( true ) ; status . availableUpdateCount = 0 ; status . registered = true ; return status ; } public static ConnectUpdateStatusInfo notValid ( ) { ConnectUpdateStatusInfo status = new ConnectUpdateStatusInfo ( ) ; status . type = EXPIRED ; status . setBannerPath ( \"serverSideBanner\" ) ; status . registered = true ; return status ; } protected static String buildFeedUrl ( boolean registred ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( Framework . getProperty ( \"org.nuxeo.connect.client.feedUrl\" , ConnectUrlConfig . getBaseUrl ( ) ) ) ; sb . append ( \"connect-gateway/jsonp/\" ) ; if ( registred ) { sb . append ( \"registered\" ) ; } else { sb . append ( \"unregistered\" ) ; } sb . append ( \"?product=\" ) ; sb . append ( PlatformVersionHelper . getPlatformFilter ( ) ) ; if ( registred ) { sb . append ( \"&instance=\" ) ; try { sb . append ( LogicalInstanceIdentifier . instance ( ) . getCLID1 ( ) ) ; } catch ( NoCLID e ) { log . error ( \"Error in ConnectUpdateStatusInfo generation : No CLID is defined ...\" ) ; } } sb . append ( \"&callback=displayConnectUpdateStatus\" ) ; return", "gt": "sb . toString ( ) ;", "prediction": "sb ;\n", "label": 1}
{"id": 7981, "input": "<s> package ar . com . fdvs . dj . domain . entities ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . commons . collections . list . UnmodifiableList ; import ar . com . fdvs . dj . domain . DJBaseElement ; import ar . com . fdvs . dj . domain . DJCrosstab ; import ar . com . fdvs . dj . domain . DJGroupLabel ; import ar . com . fdvs . dj . domain . DynamicReportOptions ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; public class DJGroup extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private PropertyColumn columnToGroupBy ; public PropertyColumn getColumnToGroupBy ( ) { return columnToGroupBy ; } public void setColumnToGroupBy ( PropertyColumn columnToGroupBy ) { this . columnToGroupBy = columnToGroupBy ; } private Map columnHeaderStyles = new HashMap ( ) ; private Style defaultColumnHeaederStyle ; private List headerVariables = new ArrayList ( ) ; private List footerVariables = new ArrayList ( ) ; private List variables = new ArrayList ( ) ; private boolean fitHeaderHeightToContent = true ; private boolean fitFooterHeightToContent = true ; private String name ; public boolean isFitHeaderHeightToContent ( ) { return fitHeaderHeightToContent ; } public void setFitHeaderHeightToContent ( boolean fitHeaderHeightToContent ) { this . fitHeaderHeightToContent = fitHeaderHeightToContent ; } public boolean isFitFooterHeightToContent ( ) { return fitFooterHeightToContent ; } public void setFitFooterHeightToContent ( boolean fitFooterHeightToContent ) { this . fitFooterHeightToContent = fitFooterHeightToContent ; } private Integer headerHeight = DynamicReportOptions . DEFAULT_HEADER_HEIGHT ; private Integer footerHeight = DynamicReportOptions . DEFAULT_FOOTER_VARIABLES_HEIGHT ; private Integer headerVariablesHeight = null ; private Integer footerVariablesHeight = null ; private GroupLayout layout = GroupLayout . DEFAULT ; private List footerSubreports = new ArrayList ( ) ; private List headerSubreports = new ArrayList ( ) ; private List headerCrosstabs = new ArrayList ( ) ; private List footerCrosstabs = new ArrayList ( ) ; private Boolean startInNewPage = Boolean . FALSE ; private Boolean startInNewColumn = Boolean . FALSE ; private Boolean reprintHeaderOnEachPage = Boolean . FALSE ; private DJGroupLabel footerLabel ; private boolean allowHeaderSplit = true ; private boolean allowFooterSplit = true ; private Style defaulFooterVariableStyle ; private Style defaulHeaderVariableStyle ; public Style getDefaulFooterVariableStyle ( ) { return defaulFooterVariableStyle ; } public void setDefaulFooterVariableStyle ( Style defaulFooterStyle ) { this . defaulFooterVariableStyle = defaulFooterStyle ; } public Style getDefaulHeaderVariableStyle ( ) { return defaulHeaderVariableStyle ; } public void setDefaulHeaderVariableStyle ( Style defaulHeaderStyle ) { this . defaulHeaderVariableStyle = defaulHeaderStyle ; } public List getFooterVariables ( ) { return UnmodifiableList . decorate ( footerVariables ) ; } public void setFooterVariables ( ArrayList footerVariables ) { this . footerVariables = footerVariables ; } public List getHeaderVariables ( ) { return UnmodifiableList . decorate ( headerVariables ) ; } public void setHeaderVariables ( ArrayList headerVariables ) { this . headerVariables = headerVariables ; } public List getVariables ( ) { return variables ; } public void setVariables ( ArrayList variables ) { this . variables = variables ; } public Integer getFooterHeight ( ) { return footerHeight ; } public void setFooterHeight ( Integer footerHeight ) { this . footerHeight = footerHeight ; } public Integer getHeaderHeight ( ) { return headerHeight ; } public void setHeaderHeight ( Integer headerHeight ) { this . headerHeight = headerHeight ; } public GroupLayout getLayout ( ) { return layout ; } public void setLayout ( GroupLayout layout ) { this . layout = layout ; } public List getFooterSubreports ( ) { return footerSubreports ; } public List getHeaderSubreports ( ) { return headerSubreports ; } public Boolean getStartInNewPage ( ) { return startInNewPage ; } public void setStartInNewPage ( Boolean startInNewPage ) { this . startInNewPage = startInNewPage ; } public Boolean getStartInNewColumn ( ) { return startInNewColumn ; } public void setStartInNewColumn ( Boolean startInNewColumn ) { this . startInNewColumn = startInNewColumn ; } public List getHeaderCrosstabs ( ) { return headerCrosstabs ; } public void setHeaderCrosstabs ( List headerCrosstabs ) { this . headerCrosstabs = headerCrosstabs ; } public List getFooterCrosstabs ( ) { return footerCrosstabs ; } public void setFooterCrosstabs ( List footerCrosstabs ) { this . footerCrosstabs = footerCrosstabs ; } public Map getColumnHeaderStyles ( ) { return columnHeaderStyles ; } public void setColumnHeaderStyles ( Map columnHeaderStyles ) { this . columnHeaderStyles = columnHeaderStyles ; } public void addColumHeaderStyle ( AbstractColumn col , Style style ) { columnHeaderStyles . put", "gt": "( col , style ) ;", "prediction": "( style ) ;\n", "label": 0}
{"id": 15334, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . jetty ; import org . eclipse . jetty . server . Server ; import org . eclipse . jetty . server . SessionIdManager ; import org . eclipse . jetty . server . SessionManager ; import org . eclipse . jetty . server . session . HashSessionIdManager ; import org . eclipse . jetty . server . session . HashSessionManager ; class SessionManagerProvider implements ISessionManagerProvider { public SessionManager createSessionManager ( Server server ) {", "gt": "HashSessionManager result = new HashSessionManager ( ) ;", "prediction": "super ( server ) ;\n", "label": 1}
{"id": 284, "input": "<s> package jns . agent ; public class SimpleGoBackNPacket { public final static int HEADER_SIZE = 16 ; public final static int SYN = 1 ; public final static int ACK = 2 ; public final static int FIN = 4 ; public int source_port ; public int destination_port ; public int sequence ; public int ack ; public int length ; public int flags ; public Object data ; public SimpleGoBackNPacket ( ) { source_port", "gt": "= destination_port = 0 ;", "prediction": "= 0 ;\n", "label": 0}
{"id": 15340, "input": "<s> package org . eclipse . ui . internal . activities ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import org . eclipse . core . expressions . Expression ; import org . eclipse . ui . internal . util . Util ; public final class ActivityDefinition implements Comparable { private final static int HASH_FACTOR = 89 ; private final static int HASH_INITIAL = ActivityDefinition . class . getName ( ) . hashCode ( ) ; static Map activityDefinitionsById ( Collection activityDefinitions , boolean allowNullIds ) { if ( activityDefinitions == null ) { throw new NullPointerException ( ) ; } Map map = new HashMap ( ) ; Iterator iterator = activityDefinitions . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; Util . assertInstance ( object , ActivityDefinition . class ) ; ActivityDefinition activityDefinition = ( ActivityDefinition ) object ; String id = activityDefinition . getId ( ) ; if ( allowNullIds || id != null ) { map . put ( id , activityDefinition ) ; } } return map ; } static Map activityDefinitionsByName ( Collection activityDefinitions , boolean allowNullNames ) { if ( activityDefinitions == null ) { throw new NullPointerException ( ) ; } Map map = new HashMap ( ) ; Iterator iterator = activityDefinitions . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; Util . assertInstance ( object , ActivityDefinition . class ) ; ActivityDefinition activityDefinition = ( ActivityDefinition ) object ; String name = activityDefinition . getName ( ) ; if ( allowNullNames || name != null ) { Collection activityDefinitions2 = ( Collection ) map . get ( name ) ; if ( activityDefinitions2 == null ) { activityDefinitions2 = new HashSet ( ) ; map . put ( name , activityDefinitions2 ) ; } activityDefinitions2 . add ( activityDefinition ) ; } } return map ; } private transient int hashCode = HASH_INITIAL ; private String id ; private String name ; private String sourceId ; private String description ; private transient String string ; private Expression enabledWhen ; public ActivityDefinition ( String id , String name , String sourceId , String description ) { this . id = id ; this . name = name ; this . sourceId = sourceId ; this . description = description ; } public int compareTo ( Object object ) { ActivityDefinition castedObject = ( ActivityDefinition ) object ; int compareTo = Util . compare ( id , castedObject . id ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( name , castedObject . name ) ; if ( compareTo == 0 ) { compareTo = Util . compare ( sourceId , castedObject . sourceId ) ; } } return compareTo ; } public boolean equals ( Object object ) { if ( ! ( object instanceof ActivityDefinition ) ) { return false ; } final ActivityDefinition castedObject = ( ActivityDefinition ) object ; if ( ! Util . equals ( id , castedObject . id ) ) { return false ; } if ( ! Util . equals ( name , castedObject . name ) ) { return false ; } return Util . equals ( sourceId , castedObject . sourceId ) ; } public String getId ( ) { return id ; } public String getName ( ) { return name ; } public String getSourceId ( ) { return sourceId ; } public int hashCode ( ) { if ( hashCode == HASH_INITIAL ) { hashCode = hashCode * HASH_FACTOR + Util . hashCode ( id ) ; hashCode = hashCode", "gt": "* HASH_FACTOR + Util . hashCode ( name ) ;", "prediction": "* HASH_INITIAL + Util . hashCode ( sourceId ) ;\n", "label": 1}
{"id": 2266, "input": "<s> package org . remast . baralga . model . filter ; import java . util . Locale ; import org . joda . time . Interval ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import org . remast . baralga . FormatUtils ; import org . remast . baralga . gui . BaralgaMain ; import org . remast . util . TextResourceBundle ; public abstract class FilterUtils { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( BaralgaMain . class ) ; private static final DateTimeFormatter dayFormatter = DateTimeFormat . forPattern ( DateTimeFormat . patternForStyle ( \"S-\" , Locale . getDefault ( ) ) + \" EEEEEEEEE\" ) ; private static final DateTimeFormatter weekOfYearFormatter = DateTimeFormat . forPattern ( \"ww\" ) ; private static final DateTimeFormatter monthFormatter = DateTimeFormat . forPattern ( \"MMMMMMMMMM yyyy\" ) ; private static final DateTimeFormatter yearFormatter = DateTimeFormat . forPattern ( \"yyyy\" ) ; public static String makeIntervalString ( final Filter filter ) { if ( filter == null ) { return \"\" ; } String intervalString = filter . getTimeInterval ( ) . toString ( ) ; switch ( filter . getSpanType ( ) ) { case Day : intervalString = dayFormatter . print ( filter . getTimeInterval ( ) . getStart ( ) ) ; break ; case Week : intervalString = \"(\" + textBundle . textFor ( \"ReportPanel.CWLabel\" ) + \" \" + weekOfYearFormatter . print ( filter . getTimeInterval ( ) . getStart ( ) ) + \") \" ; intervalString += FormatUtils . formatDate ( filter . getTimeInterval ( ) . getStart ( ) ) + \" - \" + FormatUtils . formatDate ( filter . getTimeInterval ( ) . getEnd ( ) . minusDays ( 1 ) ) ; break ; case Month : intervalString = monthFormatter . print ( filter . getTimeInterval ( ) . getStart ( ) ) ; break ; case Year : intervalString = yearFormatter . print ( filter . getTimeInterval ( ) . getStart ( ) ) ; break ; } return intervalString ; } public static void moveToPreviousInterval ( final Filter filter ) { if ( filter == null ) { return ; } Interval newTimeInterval = null ; final Interval timeInterval = filter . getTimeInterval ( ) ; switch ( filter . getSpanType ( ) ) { case Day : newTimeInterval = new Interval ( timeInterval . getStart ( ) . minusDays ( 1 ) , timeInterval . getEnd ( ) . minusDays ( 1 ) ) ; break ; case Week : newTimeInterval = new Interval ( timeInterval . getStart ( ) . minusWeeks ( 1 ) , timeInterval . getEnd ( ) . minusWeeks ( 1 ) ) ; break ; case Month : newTimeInterval = new Interval ( timeInterval . getStart ( ) . minusMonths ( 1 ) , timeInterval . getEnd ( ) . minusMonths ( 1 ) ) ; break ; case Year : newTimeInterval = new Interval ( timeInterval . getStart ( ) . minusYears ( 1 ) , timeInterval . getEnd ( ) . minusYears ( 1 ) ) ; break ; } filter . setTimeInterval ( newTimeInterval ) ; } public static void moveToNextInterval ( final Filter filter ) { if ( filter == null ) { return ; } Interval newTimeInterval = null ; final Interval timeInterval = filter . getTimeInterval ( ) ; switch ( filter . getSpanType ( ) ) { case Day : newTimeInterval = new Interval ( timeInterval . getStart ( ) . plusDays ( 1 ) , timeInterval . getEnd ( ) . plusDays ( 1 ) ) ; break ; case Week : newTimeInterval = new Interval ( timeInterval . getStart ( ) . plusWeeks ( 1 ) , timeInterval . getEnd ( ) . plusWeeks ( 1 ) ) ; break ; case Month : newTimeInterval = new Interval ( timeInterval . getStart ( ) . plusMonths ( 1 ) , timeInterval . getEnd ( ) . plusMonths ( 1 ) ) ; break ; case Year : newTimeInterval = new Interval ( timeInterval . getStart ( ) . plusYears ( 1 ) , timeInterval . getEnd", "gt": "( ) . plusYears ( 1 ) ) ;", "prediction": "( ) . plusYears ( 1 ) ) ;\n", "label": 0}
{"id": 15346, "input": "<s> package org . restlet . ext . oauth . internal ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import org . restlet . ext . oauth . AuthenticatedUser ; public class MemTokenGenerator extends TokenGenerator { private final Map < String , AuthenticatedUser > codeStore = new ConcurrentHashMap < String , AuthenticatedUser > ( ) ; private final Map < String , Token > tokenStore = new ConcurrentHashMap < String , Token > ( ) ; private final ScheduledThreadPoolExecutor timers ; public MemTokenGenerator ( ScheduledThreadPoolExecutor executor ) { timers = executor ; } @ Override public String generateCode ( AuthenticatedUser user ) { String code = super . generateCode ( user ) ; AuthenticatedUser oldValue = codeStore . put ( code , user ) ; if ( oldValue != null ) oldValue . setCode ( code ) ; return code ; } @ Override public Token generateToken ( AuthenticatedUser user , long expire ) { Token t = super . generateToken ( user , expire ) ; if ( expire != Token . UNLIMITED ) { ExpireToken et = ( ExpireToken ) t ; tokenStore . put ( et . getRefreshToken ( ) , et ) ; scheduleCleanup ( et , expire ) ; } tokenStore . put ( t . getToken ( ) , t ) ; return t ; } @ Override public Token exchangeForToken ( String code , long expire ) throws IllegalArgumentException { AuthenticatedUser user = codeStore . remove ( code ) ; if ( user == null ) throw new IllegalArgumentException ( \"Code not valid\" ) ; Token t = generateToken ( user , expire ) ; user . clearCode ( ) ; return t ; } @ Override public void revokeToken ( Token token ) { String id = token . getToken ( ) ; if ( id != null && tokenStore . containsKey ( id ) ) { tokenStore . remove ( token . getToken ( ) ) ; } } @ Override public void revokeExpireToken ( ExpireToken token ) { if ( tokenStore . containsKey", "gt": "( token . getRefreshToken ( ) ) )", "prediction": "( id ) )\n", "label": 1}
{"id": 3851, "input": "<s> import jns . Simulator ; import jns . trace . * ; import jns . element . * ; import jns . util . * ; import jns . command . * ; import java . io . IOException ; public class Test_LinkDown { public static void main ( String args [ ] ) { Simulator sim = Simulator . getInstance ( ) ; Trace trace = null ; try { trace = new JavisTrace ( \"test_linkdown.jvs\" ) ; } catch ( IOException e ) { System . out . println ( \"Could not create test_linkdown.jvs!\" ) ; System . exit ( 1 ) ; } Node src = new Node ( \"Source node\" ) ; Node router = new Node ( \"Router\" ) ; Node dest = new Node ( \"Destination node\" ) ; sim . attachWithTrace ( src , trace ) ; sim . attachWithTrace ( router , trace ) ; sim . attachWithTrace ( dest , trace ) ; Interface src_iface = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 10 ) ) ; src . attach ( src_iface ) ; src . addDefaultRoute ( src_iface ) ; Interface dest_iface = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 20 ) ) ; dest . attach ( dest_iface ) ; dest . addDefaultRoute ( dest_iface ) ; sim . attachWithTrace ( src_iface , trace ) ; sim . attachWithTrace ( dest_iface , trace ) ; Interface route_iface192 = new DuplexInterface ( new IPAddr ( 192 , 168 , 1 , 1 ) ) ; Interface route_iface128 = new DuplexInterface ( new IPAddr ( 128 , 116 , 11 , 1 ) ) ; router . attach ( route_iface192 ) ; router . attach ( route_iface128 ) ; router . addRoute ( new IPAddr ( 192 , 168 , 1 , 0 ) , new IPAddr ( 255 , 255 , 255", "gt": ", 0 ) , route_iface192 ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 15367, "input": "<s> package org . restlet . example . book . restlet . ch07 . sec5", "gt": ". webapi . common ;", "prediction": ";\n", "label": 1}
{"id": 981, "input": "<s> package models ; import java . util . List ; import javax . persistence . Entity ; import javax . persistence . Id ; import javax . persistence . Lob ; import play . db . ebean . Model ; @ SuppressWarnings ( \"serial\" ) @ Entity public class Background extends Model { @ Id public Long idbackground ; public Long idscrapbook ; public String typeB ; public String valeurB ; @ Lob public byte [ ] photo ; public static Finder < Long , Background > find = new Finder < Long , Background > ( Long . class , Background . class ) ; public static List < Background > all ( ) { return find . all ( ) ; } public static Background get ( Long id ) { return find . byId ( id ) ; } public static Background getScrapbookBackground ( Long id ) { return find . where ( ) . eq", "gt": "( \"idscrapbook\" , id ) . findUnique ( ) ;", "prediction": "( id ) ;\n", "label": 0}
{"id": 15375, "input": "<s> package org . apache . sqoop . manager ; import org . apache . hadoop . mapreduce . InputFormat ; import com . cloudera . sqoop . mapreduce . db . DataDrivenDBInputFormat ; import com . cloudera . sqoop . SqoopOptions ; import org . apache . hadoop . fs . Path ; public class ImportJobContext { private String tableName ; private String jarFile ; private SqoopOptions options ; private Class < ? extends InputFormat > inputFormatClass ; private Path destination ; private ConnManager manager ; public ImportJobContext ( final String table , final String jar , final SqoopOptions opts , final Path destination ) { this . tableName = table ; this . jarFile = jar ; this . options = opts ; this . inputFormatClass = DataDrivenDBInputFormat . class ; this . destination = destination ; } public String getTableName ( ) { return tableName ; } public String getJarFile ( ) { return jarFile ; } public SqoopOptions getOptions ( ) { return options ; } public void setInputFormat ( Class < ? extends InputFormat > ifClass ) { this . inputFormatClass = ifClass ; } public Class < ? extends InputFormat > getInputFormat ( ) { return this . inputFormatClass ; } public Path getDestination ( ) { return this . destination ; } public", "gt": "void setConnManager ( ConnManager mgr )", "prediction": "SqoopOptions getOptions ( )\n", "label": 1}
{"id": 2870, "input": "<s> public class Crash01 < A extends TestClass1 & IA > { public A value ; public void testit ( ) { value", "gt": ". testClass ( ) ;", "prediction": "= new TestClass1 ( ) ;\n", "label": 0}
{"id": 15376, "input": "<s> package org . restlet . engine ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import org . restlet . Connector ; import org . restlet . Context ; import org . restlet . data . Protocol ; public abstract class ConnectorHelper < T extends Connector > extends RestletHelper < T > { public static org . restlet . service . ConnectorService getConnectorService ( ) { org . restlet . service . ConnectorService result = null ; org . restlet . Application application = org . restlet . Application . getCurrent ( ) ; if ( application != null ) { result = application . getConnectorService ( ) ; } else { result = new org . restlet . service", "gt": ". ConnectorService ( ) ;", "prediction": ". ConnectorService ( ) ;\n", "label": 1}
{"id": 3129, "input": "<s> package org . parboiled . trees ; public interface BinaryTreeNode < T extends BinaryTreeNode < T >", "gt": "> extends TreeNode < T >", "prediction": ">\n", "label": 0}
{"id": 15389, "input": "<s> package org . apache . lucene . index ; import java . util . List ; import java . io . IOException ; public interface IndexDeletionPolicy { public void onInit", "gt": "( List commits ) throws IOException ;", "prediction": "( ) ;\n", "label": 1}
{"id": 6289, "input": "<s> package com . example . wordcount . jobflow . gateway ; import java . util . HashSet ; import java . util . Set ; import com . asakusafw . vocabulary . external . FileImporterDescription ; import com . example . wordcount . modelgen . dmdl . model . LogLine ; public class LogLineFromHdfs extends FileImporterDescription { @ Override public Class < ? > getModelType ( ) { return LogLine . class ; } @ Override public Set <", "gt": "String > getPaths ( )", "prediction": "? > getLogLine ( )\n", "label": 0}
{"id": 15393, "input": "<s> package org . restlet . data ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public final class ChallengeScheme { public static final ChallengeScheme CUSTOM = new ChallengeScheme ( \"CUSTOM\" , \"Custom\" , \"Custom authentication\" ) ; public static final ChallengeScheme FTP_PLAIN = new ChallengeScheme ( \"FTP_PLAIN\" , \"PLAIN\" , \"Plain FTP authentication\" ) ; public static final ChallengeScheme HTTP_AWS_IAM = new ChallengeScheme ( \"HTTP_AWS_IAM\" , \"AWS3\" , \"Amazon IAM-based authentication\" ) ; public static final ChallengeScheme HTTP_AWS_QUERY = new ChallengeScheme ( \"HTTP_AWS_QUERY\" , \"AWS_QUERY\" , \"Amazon Query String authentication\" ) ; public static final ChallengeScheme HTTP_AWS_S3 = new ChallengeScheme ( \"HTTP_AWS_S3\" , \"AWS\" , \"Amazon S3 HTTP authentication\" ) ; public static final ChallengeScheme HTTP_AZURE_SHAREDKEY = new ChallengeScheme ( \"HTTP_AZURE_SHAREDKEY\" , \"SharedKey\" , \"Microsoft Azure Shared Key authorization (authentication)\" ) ; public static final ChallengeScheme HTTP_AZURE_SHAREDKEY_LITE = new ChallengeScheme ( \"HTTP_AZURE_SHAREDKEY_LITE\" , \"SharedKeyLite\" , \"Microsoft Azure Shared Key lite authorization (authentication)\" ) ; public static final ChallengeScheme HTTP_BASIC = new ChallengeScheme ( \"HTTP_BASIC\" , \"Basic\" , \"Basic HTTP authentication\" ) ; public static final ChallengeScheme HTTP_COOKIE = new ChallengeScheme ( \"HTTP_Cookie\" , \"Cookie\" , \"Cookie HTTP authentication\" ) ; public static final ChallengeScheme HTTP_DIGEST = new ChallengeScheme ( \"HTTP_DIGEST\" , \"Digest\" , \"Digest HTTP authentication\" ) ; public static final ChallengeScheme HTTP_NTLM = new ChallengeScheme ( \"HTTP_NTLM\" , \"NTLM\" , \"Microsoft NTLM HTTP authentication\" ) ; public static final ChallengeScheme HTTP_OAUTH = new ChallengeScheme ( \"HTTP_OAuth\" , \"OAuth\" , \"Open protocol for API authentication\" ) ; public static final ChallengeScheme POP_BASIC = new ChallengeScheme ( \"POP_BASIC\" , \"Basic\" , \"Basic POP authentication (USER/PASS commands)\" ) ; public static final ChallengeScheme POP_DIGEST = new ChallengeScheme ( \"POP_DIGEST\" , \"Digest\" , \"Digest POP authentication (APOP command)\" ) ; private static Map < String , ChallengeScheme > SCHEMES ; public static final ChallengeScheme SDC = new ChallengeScheme ( \"SDC\" , \"SDC\" , \"Secure Data Connector authentication\" ) ; public static final ChallengeScheme SMTP_PLAIN = new ChallengeScheme ( \"SMTP_PLAIN\" , \"PLAIN\" , \"Plain SMTP authentication\" ) ; static { Map < String , ChallengeScheme > schemes = new HashMap < String , ChallengeScheme > ( ) ; schemes . put ( CUSTOM . getName ( ) . toLowerCase ( ) , CUSTOM ) ; schemes . put ( FTP_PLAIN . getName ( ) . toLowerCase ( ) , FTP_PLAIN ) ; schemes . put ( HTTP_AWS_S3 . getName ( ) . toLowerCase ( ) , HTTP_AWS_S3 ) ; schemes . put ( HTTP_AZURE_SHAREDKEY . getName ( ) . toLowerCase ( ) , HTTP_AZURE_SHAREDKEY ) ; schemes . put ( HTTP_AZURE_SHAREDKEY_LITE . getName ( ) . toLowerCase ( ) , HTTP_AZURE_SHAREDKEY_LITE ) ; schemes . put ( HTTP_BASIC . getName ( ) . toLowerCase ( ) , HTTP_BASIC ) ; schemes . put ( HTTP_COOKIE . getName ( ) . toLowerCase ( ) , HTTP_COOKIE ) ; schemes . put ( HTTP_DIGEST . getName ( ) . toLowerCase ( ) , HTTP_DIGEST ) ; schemes . put ( HTTP_NTLM . getName ( ) . toLowerCase ( ) , HTTP_NTLM ) ; schemes . put ( HTTP_OAUTH . getName ( ) . toLowerCase ( ) , HTTP_OAUTH ) ; schemes . put ( POP_BASIC . getName ( ) . toLowerCase ( ) , POP_BASIC ) ; schemes . put ( POP_DIGEST . getName ( ) . toLowerCase", "gt": "( ) , POP_DIGEST ) ;", "prediction": "( ) , POP_DIGEST ) ;\n", "label": 1}
{"id": 4337, "input": "<s> package Liza ; import java . util . List ; import org . bukkit . entity . PoweredMinecart ; public interface LizaPoweredMinecart extends PoweredMinecart { List < LizaEntity > getNearbyLizaEntities (", "gt": "double x , double y , double z ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15410, "input": "<s> package org . eclipse . ui . activities ; import java . util . Set ; public interface ITriggerPointAdvisor { Set allow", "gt": "( ITriggerPoint triggerPoint , IIdentifier identifier ) ;", "prediction": ";\n", "label": 1}
{"id": 7599, "input": "<s> import java . util . * ; class T6910550a { void m ( List < String > ls ) { } void m ( List < Integer > li ) { } { m ( Arrays", "gt": ". asList ( 12 ) ) ;", "prediction": ". asList ( ls ) ) ;\n", "label": 0}
{"id": 15411, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . internal . SWTEventListener ; public interface ModifyListener extends SWTEventListener {", "gt": "public void modifyText ( ModifyEvent event ) ;", "prediction": "}\n", "label": 1}
{"id": 6210, "input": "<s> package org . msl . simple . gmfmap . simplemapping . setting ; import org . eclipse . emf . ecore . EStructuralFeature ; import org . eclipse . emf . ecore . EStructuralFeature . Internal . SettingDelegate ; import org . eclipse . emf . ecore . EStructuralFeature . Internal . SettingDelegate . Factory ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . util . BasicSettingDelegate . Stateless ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsPackage ; public class SimpleMappingSettingDelegateFactory implements Factory { @ Override public SettingDelegate createSettingDelegate ( EStructuralFeature eStructuralFeature ) { if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals . SIMPLE_NODE ) return new SimpleNodeSettingDelegate ( eStructuralFeature ) ; if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals . SIMPLE_NODE_REFERENCE ) return new SimpleNodeReferenceSettingDelegate ( eStructuralFeature ) ; if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals . SIMPLE_CHILD_REFERENCE ) return new SimpleChildReferenceSettingDelegate ( eStructuralFeature ) ; if ( eStructuralFeature . getEContainingClass ( ) == SimplemappingsPackage . Literals .", "gt": "SIMPLE_COMPARTMENT ) return new SimpleCompartmentSettingDelegate ( eStructuralFeature ) ;", "prediction": "SIMPLE_CLASS_REFERENCE ) return new SimpleClassReferenceSettingDelegate ( eStructuralFeature ) ;\n", "label": 0}
{"id": 15416, "input": "<s> package org . eclipse . swt . internal . widgets . tableitemkit ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . preserveProperty ; import static org . eclipse . rap . rwt . lifecycle . WidgetLCAUtil . renderProperty ; import java . io . IOException ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . internal . protocol . IClientObject ; import org . eclipse . rap . rwt . lifecycle . * ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . widgets . * ; import org . eclipse . swt . widgets . * ; public final class TableItemLCA extends AbstractWidgetLCA { private static interface IRenderRunnable { void run ( ) throws IOException ; } private static final String TYPE = \"rwt.widgets.GridItem\" ; static final String PROP_TEXTS = \"texts\" ; static final String PROP_IMAGES = \"images\" ; static final String PROP_BACKGROUND = \"background\" ; static final String PROP_FOREGROUND = \"foreground\" ; static final String PROP_FONT = \"font\" ; static final String PROP_CELL_BACKGROUNDS = \"cellBackgrounds\" ; static final String PROP_CELL_FOREGROUNDS = \"cellForegrounds\" ; static final String PROP_CELL_FONTS = \"cellFonts\" ; static final String PROP_CHECKED = \"checked\" ; static final String PROP_GRAYED = \"grayed\" ; static final String PROP_CACHED = \"cached\" ; @ Override public void preserveValues ( Widget widget ) { TableItem item = ( TableItem ) widget ; if ( isCached ( item ) ) { preserveProperty ( item , PROP_TEXTS , getTexts ( item ) ) ; preserveProperty ( item , PROP_IMAGES , getImages ( item ) ) ; WidgetLCAUtil . preserveBackground ( item , getUserBackground ( item ) ) ; WidgetLCAUtil . preserveForeground ( item , getUserForeground ( item ) ) ; WidgetLCAUtil . preserveFont ( item , getUserFont ( item ) ) ; WidgetLCAUtil . preserveCustomVariant ( item ) ; preserveProperty ( item , PROP_CELL_BACKGROUNDS , getCellBackgrounds ( item ) ) ; preserveProperty ( item , PROP_CELL_FOREGROUNDS , getCellForegrounds ( item ) ) ; preserveProperty ( item , PROP_CELL_FONTS , getCellFonts ( item ) ) ; preserveProperty ( item , PROP_CHECKED , item . getChecked ( ) ) ; preserveProperty ( item , PROP_GRAYED , item . getGrayed ( ) ) ; } preserveProperty ( item , PROP_CACHED , isCached ( item ) ) ; } public void readData ( Widget widget ) { TableItem item = ( TableItem ) widget ; readChecked ( item ) ; } @ Override public void renderInitialization ( Widget widget ) throws IOException { TableItem item = ( TableItem ) widget ; Table parent = item . getParent ( ) ; int index =", "gt": "parent . indexOf ( item ) ;", "prediction": "0 ;\n", "label": 1}
{"id": 6002, "input": "<s> package org . ofbiz . entity . util ; import java . sql . Connection ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Statement ; import java . util . Hashtable ; import java . util . Map ; import javax . transaction . Transaction ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . entity . GenericDelegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . datasource . GenericHelperInfo ; import org . ofbiz . entity . jdbc . ConnectionFactory ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; public class SequenceUtil { public static final String module = SequenceUtil . class . getName ( ) ; private final Map < String , SequenceBank > sequences = new Hashtable < String , SequenceBank > ( ) ; private final GenericHelperInfo helperInfo ; private final long bankSize ; private final String tableName ; private final String nameColName ; private final String idColName ; private final boolean clustered ; public SequenceUtil ( GenericDelegator delegator , GenericHelperInfo helperInfo , ModelEntity seqEntity , String nameFieldName , String idFieldName ) { this . helperInfo = helperInfo ; if ( seqEntity == null ) { throw new IllegalArgumentException ( \"The sequence model entity was null but is required.\" ) ; } this . tableName = seqEntity . getTableName ( helperInfo . getHelperBaseName ( ) ) ; ModelField nameField = seqEntity . getField ( nameFieldName ) ; if ( nameField == null ) { throw new IllegalArgumentException ( \"Could not find the field definition for the sequence name field \" + nameFieldName ) ; } this . nameColName = nameField . getColName ( ) ; ModelField idField = seqEntity . getField ( idFieldName ) ; if ( idField == null ) { throw new IllegalArgumentException ( \"Could not find the field definition for the sequence id field \" + idFieldName ) ; } this . idColName = idField . getColName ( ) ; long bankSize = SequenceBank . defaultBankSize ; if ( seqEntity . getSequenceBankSize ( ) != null ) { bankSize = seqEntity . getSequenceBankSize ( ) . longValue ( ) ; } this . bankSize = bankSize ; clustered = delegator . useDistributedCacheClear ( ) || \"Y\" . equals ( UtilProperties . getPropertyValue ( \"general.properties\" , \"clustered\" ) ) ; } public Long getNextSeqId ( String seqName , long staggerMax , ModelEntity seqModelEntity ) { SequenceBank bank = this . getBank ( seqName , seqModelEntity ) ; return bank . getNextSeqId ( staggerMax ) ; } public void forceBankRefresh ( String seqName , long staggerMax ) { SequenceBank bank = sequences . get ( seqName ) ; if ( bank == null ) { return ; } bank . refresh ( staggerMax ) ; } private SequenceBank getBank ( String seqName , ModelEntity seqModelEntity ) { SequenceBank bank = sequences . get ( seqName ) ; if ( bank == null ) { synchronized ( this ) { bank = sequences . get ( seqName ) ; if ( bank == null ) { bank = new SequenceBank ( seqName ) ; sequences . put ( seqName , bank ) ; } } } return bank ; } private class SequenceBank { public static final long defaultBankSize = 10 ; public static final long maxBankSize = 5000 ; public static final long startSeqId = 10000 ; public static final long minWaitMillis = 5 ; public static final long maxWaitMillis = 50 ; public static final int maxTries = 5 ; private long curSeqId ; private long maxSeqId ; private final String seqName ; private SequenceBank ( String seqName ) { this . seqName = seqName ; curSeqId = 0 ; maxSeqId = 0 ; fillBank ( 1 ) ; } private synchronized Long getNextSeqId ( long staggerMax ) { long stagger = 1 ; if ( staggerMax > 1 ) { stagger = Math . round ( Math . random ( ) * staggerMax ) ; if ( stagger == 0 ) stagger = 1 ; } if ( ( curSeqId + stagger ) <= maxSeqId ) { Long retSeqId = Long . valueOf ( curSeqId ) ; curSeqId += stagger ; return retSeqId ; } else { fillBank ( stagger ) ; if ( ( curSeqId + stagger ) <= maxSeqId ) { Long retSeqId = Long . valueOf ( curSeqId ) ; curSeqId += stagger ; return retSeqId ; } else { Debug . logError ( \"[SequenceUtil.SequenceBank.getNextSeqId] Fill bank failed, returning null\" , module ) ; return null ; } } } private void refresh ( long staggerMax ) { this", "gt": ". curSeqId = this . maxSeqId ;", "prediction": ". bank = banks ;\n", "label": 0}
{"id": 15429, "input": "<s> package com . corundumstudio . socketio . parser ; public class DecoderException extends RuntimeException { private static final long", "gt": "serialVersionUID = - 312474299994609579L ;", "prediction": "serialVersionUID = 1L ;\n", "label": 1}
{"id": 10081, "input": "<s> package LizaCraft . Entity ; import java . util . List ; import java . util . UUID ; import org . bukkit . EntityEffect ; import org . bukkit . Location ; import org . bukkit . entity . EnderSignal ; import org . bukkit . entity . Entity ; import org . bukkit . event . entity . EntityDamageEvent ; import org . bukkit . event . player . PlayerTeleportEvent . TeleportCause ; import org . bukkit . util . Vector ; import Liza . LizaEnderSignal ; import Liza . LizaEntity ; import Liza . LizaServer ; import Liza . LizaWorld ; import LizaCraft . LizaCraftServer ; import LizaCraft . LizaCraftWorld ; public class LizaCraftEnderSignal implements LizaEnderSignal { private EnderSignal signal ; public LizaCraftEnderSignal ( EnderSignal signal ) { this . signal = signal ; } @ Override public boolean eject ( ) { return this . signal . eject ( ) ; } @ Override public int getEntityId ( ) { return this . signal . getEntityId ( ) ; } @ Override public float getFallDistance ( ) { return this . signal . getFallDistance ( ) ; } @ Override public int getFireTicks ( ) { return this . signal . getFireTicks ( ) ; } @ Override public EntityDamageEvent getLastDamageCause ( ) { return this . signal . getLastDamageCause ( ) ; } @ Override public Location getLocation ( ) { return this . signal . getLocation ( ) ; } @ Override public int getMaxFireTicks ( ) { return this . signal . getMaxFireTicks ( ) ; } @ Override @ Deprecated public List < Entity > getNearbyEntities ( double x , double y , double z ) { List < Entity > el = this . signal . getNearbyEntities ( x , y , z ) ; for ( Entity e : el ) { el . remove ( e ) ; LizaEntity le = new LizaCraftEntity ( e ) ; el . add ( le ) ; } return el ; } @ Override public LizaEntity getPassenger ( ) { return new LizaCraftEntity ( this . signal . getPassenger ( ) ) ; } @ Override public LizaServer getServer ( ) { return new LizaCraftServer ( this . signal . getServer ( ) ) ; } @ Override public int getTicksLived ( ) { return this . signal . getTicksLived ( ) ; } @ Override public UUID getUniqueId ( ) { return this . signal . getUniqueId ( ) ; } @ Override public Vector getVelocity ( ) { return this . signal", "gt": ". getVelocity ( ) ;", "prediction": ". getVelocity ( ) ;\n", "label": 0}
{"id": 15432, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . tomcat ; import java . io . File ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpSession ; import org . apache . catalina . Engine ; import org . apache . catalina . Session ; import org . apache . catalina . Wrapper ; import org . apache . catalina . core . StandardContext ; import org . apache . catalina . servlets . DefaultServlet ; import org . apache . catalina . session . ManagerBase ; import org . apache . catalina . session . StandardManager ; import org . apache . catalina . startup . Tomcat ; import org . eclipse . rap . rwt . cluster . testfixture . internal . server . RWTStartup ; import org . eclipse . rap . rwt . cluster . testfixture . internal . util . FileUtil ; import org . eclipse . rap . rwt . cluster . testfixture . internal . util . SocketUtil ; import org . eclipse . rap . rwt . cluster . testfixture . server . IServletEngine ; import org . eclipse . rap . rwt . engine . RWTServlet ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; public class TomcatEngine implements IServletEngine { static { TomcatLog . silence ( ) ; } private final Tomcat tomcat ; private final StandardContext context ; public TomcatEngine ( ) { this ( SocketUtil . getFreePort ( ) ) ; } public TomcatEngine ( int port ) { this . tomcat = new Tomcat ( ) ; configureTomcat ( port ) ; this . context = ( StandardContext ) tomcat . addContext ( \"/\" , tomcat . getHost ( ) . getAppBase ( ) ) ; } private void configureTomcat ( int port ) { tomcat . setSilent ( true ) ; tomcat . setPort ( port ) ; tomcat . setBaseDir ( getBaseDir ( ) . getAbsolutePath ( ) ) ; tomcat . getHost ( ) . setAppBase ( getWebAppsDir ( ) . getAbsolutePath ( ) ) ; tomcat . getEngine ( ) . setName ( \"Tomcat on port \" + port ) ; } public void start ( Class < ? extends IEntryPoint > entryPointClass ) throws Exception { prepareWebAppsDir ( ) ; configureContext ( entryPointClass ) ; tomcat . start ( ) ; configureSessionSweepInterval ( ) ; configureSessionPersistence ( ) ; } public void stop ( ) throws Exception { stop ( 0 ) ; } public void stop ( int timeout ) throws Exception { tomcat . getEngine ( ) . setCluster ( null ) ; tomcat . stop ( ) ; tomcat . destroy ( ) ; FileUtil . deleteDirectory ( getBaseDir ( ) ) ; } public int getPort ( ) { return tomcat . getConnector ( ) . getPort ( ) ; } public HttpSession [ ] getSessions ( ) { Session [ ] sessions = context . getManager ( ) . findSessions ( ) ; HttpSession [ ] result = new HttpSession [ sessions . length ] ; for ( int i = 0 ; i < sessions . length ; i ++ ) { result [ i ] = sessions [ i ] . getSession ( ) ; } return result ; } Engine getEngine ( ) { return tomcat . getEngine ( ) ; } private boolean prepareWebAppsDir ( ) { return new File ( tomcat . getHost ( ) . getAppBase ( ) ) . mkdirs ( ) ; } private void configureContext ( Class < ? extends IEntryPoint > entryPointClass ) { if ( tomcat . getEngine ( ) . getCluster ( ) != null ) { context . setDistributable ( true ) ; } context . setSessionTimeout ( - 1 ) ; context . setBackgroundProcessorDelay ( 1 ) ; Object listener = RWTStartup . createServletContextListener ( entryPointClass ) ; context . addApplicationLifecycleListener ( listener ) ; Wrapper rwtServlet = addServlet ( \"rwtServlet\" , new RWTServlet ( ) ) ; context . addServletMapping ( IServletEngine . SERVLET_PATH , rwtServlet . getName ( ) ) ; Wrapper defaultServlet = addServlet ( \"defaultServlet\" , new DefaultServlet ( ) ) ; context . addServletMapping ( \"/\" , defaultServlet . getName ( ) ) ; } private void configureSessionSweepInterval ( ) { ManagerBase manager = ( ManagerBase ) context . getManager ( ) ; manager . setProcessExpiresFrequency ( 1 ) ; } private void configureSessionPersistence ( ) { if ( context . getManager ( ) instanceof StandardManager ) { StandardManager standardManager = (", "gt": "StandardManager ) context . getManager ( ) ;", "prediction": "StandardManager ) context . getManager ( ) ;\n", "label": 1}
{"id": 5856, "input": "<s> package de . uni_hamburg . informatik . swt . se2 . kino . werkzeuge . platzverkauf ; import", "gt": "java . util . EventListener ;", "prediction": "java . io . IOException ;\n", "label": 0}
{"id": 15434, "input": "<s> package org . jscsi . target . scsi . inquiry ; import java . nio . ByteBuffer ; import org . jscsi . target . scsi . IResponseData ; import org . jscsi . target . scsi . cdb . ScsiOperationCode ; public final class StandardInquiryData implements IResponseData { private static final int SIZE = 36 ; private static final String VENDOR_ID = \"disyUKon\" ; private static final int VENDOR_ID_FIELD_POSITION = 8 ; private static final int VENDOR_ID_FIELD_LENGTH = 8 ; private static final String PRODUCT_ID = \"jSCSI Target\" ; private static final int PRODUCT_ID_FIELD_POSITION = 16 ; private static final int PRODUCT_ID_FIELD_LENGTH = 16 ; private static final String PRODUCT_REVISION_LEVEL = \"1.00\" ; private static final int PRODUCT_REVISION_LEVEL_FIELD_POSITION = 32 ; private static final int PRODUCT_REVISION_LEVEL_FIELD_LENGTH = 4 ; private static StandardInquiryData instance ; private StandardInquiryData ( ) { } public static StandardInquiryData getInstance ( ) { if ( instance == null ) instance = new StandardInquiryData ( ) ; return instance ; } public void serialize ( ByteBuffer byteBuffer , int index ) { byteBuffer . position ( index ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 0x05 ) ; byteBuffer . put ( ( byte ) 2 ) ; byteBuffer . put ( ( byte ) 31 ) ; byteBuffer . put ( ( byte ) 0 ) ; byteBuffer . put ( ( byte ) 128 ) ; byteBuffer . put (", "gt": "( byte ) 0 ) ;", "prediction": "( byte ) 128 ) ;\n", "label": 1}
{"id": 7790, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . javadoc . * ; import java . util . * ; import com . sun . tools . doclets . internal . toolkit . Configuration ; public class DeprecatedAPIListBuilder { public static final int NUM_TYPES = 12 ; public static final int PACKAGE = 0 ; public static final int INTERFACE = 1 ; public static final int CLASS = 2 ; public static final int ENUM = 3 ; public static final int EXCEPTION = 4 ; public static final int ERROR = 5 ; public static final int ANNOTATION_TYPE = 6 ; public static final int FIELD = 7 ; public static final int METHOD = 8 ; public static final int CONSTRUCTOR = 9 ; public static final int ENUM_CONSTANT = 10 ; public static final int ANNOTATION_TYPE_MEMBER = 11 ; private List < List < Doc > > deprecatedLists ; public DeprecatedAPIListBuilder ( Configuration configuration ) { deprecatedLists = new ArrayList < List < Doc > > ( ) ; for ( int i = 0 ; i < NUM_TYPES ; i ++ ) { deprecatedLists . add ( i , new ArrayList < Doc > ( ) ) ; } buildDeprecatedAPIInfo ( configuration ) ; } private void buildDeprecatedAPIInfo ( Configuration configuration ) { PackageDoc [ ] packages = configuration . packages ; PackageDoc pkg ; for ( int c = 0 ; c < packages . length ; c ++ ) { pkg = packages [ c ] ; if ( Util . isDeprecated ( pkg ) ) { getList ( PACKAGE ) . add ( pkg ) ; } } ClassDoc [ ] classes = configuration . root . classes ( ) ; for ( int i = 0 ; i < classes . length ; i ++ ) { ClassDoc cd = classes [ i ] ; if ( Util . isDeprecated ( cd ) ) { if ( cd . isOrdinaryClass ( ) ) { getList ( CLASS ) . add ( cd ) ; } else if ( cd . isInterface ( ) ) { getList ( INTERFACE ) . add ( cd ) ; } else if ( cd . isException ( ) ) { getList ( EXCEPTION ) . add ( cd ) ; } else if ( cd . isEnum ( ) ) { getList ( ENUM ) . add ( cd ) ; } else if ( cd . isError ( ) ) { getList ( ERROR ) . add ( cd ) ; } else if ( cd . isAnnotationType ( ) ) { getList ( ANNOTATION_TYPE ) . add ( cd ) ; } } composeDeprecatedList ( getList ( FIELD ) , cd . fields ( ) ) ; composeDeprecatedList ( getList ( METHOD ) , cd . methods ( ) ) ; composeDeprecatedList ( getList ( CONSTRUCTOR ) , cd . constructors ( ) ) ; if ( cd . isEnum ( ) ) { composeDeprecatedList ( getList ( ENUM_CONSTANT ) , cd . enumConstants ( ) ) ; } if ( cd . isAnnotationType ( ) ) { composeDeprecatedList ( getList ( ANNOTATION_TYPE_MEMBER ) , ( ( AnnotationTypeDoc ) cd )", "gt": ". elements ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15463, "input": "<s> package com . talis . hbase . rdf . layout . hybrid ; import com . talis . hbase . rdf . store . TableDesc ; public class TableDescHybridCommon extends TableDesc { protected static final String COL_FAMILY_NAME_STR = \"triples\" ; protected static final String CELL_VALUE_SEPARATOR = \"&&\" ; protected static final String TRIPLE_SEPARATOR = \"~~\" ; private final String _COL_FAMILY_NAME_STR ; public TableDescHybridCommon ( String tName ) { this ( tName , COL_FAMILY_NAME_STR ) ; } public TableDescHybridCommon ( String tableName , String colFamily ) { super", "gt": "( tableName , colFamily ) ;", "prediction": "( tableName , colFamily ) ;\n", "label": 1}
{"id": 698, "input": "<s> package exceptions ; public class NullUserException extends Exception { private static final long serialVersionUID = - 1648475327994729183L ; public", "gt": "NullUserException ( String message )", "prediction": "NullUserException ( )\n", "label": 0}
{"id": 15469, "input": "<s> package org . restlet . example . book . rest . ch2 ; import org . restlet . data . Reference ; import org . restlet . ext . xml . DomRepresentation ; import org . restlet . representation . Representation ; import org . restlet . resource . ClientResource ; import org . w3c . dom . Node ; public class Example2_1b { static final String BASE_URI = \"http://api.search.yahoo.com/WebSearchService/V1/webSearch\" ; public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( \"You need to pass a term to search\" ) ; } else { String term = Reference . encode ( args [ 0 ] ) ; String uri = BASE_URI + \"?appid=restbook&query=\" + term ; Representation entity = new ClientResource ( uri ) . get ( ) ;", "gt": "DomRepresentation document = new DomRepresentation ( entity ) ;", "prediction": "Entity entity = entity . getEntity ( ) ;\n", "label": 1}
{"id": 7989, "input": "<s> package com . atlassian . crowd . integration . soap ; @ SuppressWarnings ( \"serial\" ) public class SearchRestriction implements java . io . Serializable { private java . lang . String name ; private java . lang . String value ; public SearchRestriction ( ) { } public SearchRestriction ( java . lang . String name , java . lang . String value ) { this . name = name ; this . value = value ; } public java . lang . String getName ( ) { return name ; } public void setName ( java . lang . String name ) { this . name = name ; } public java . lang . String getValue ( ) { return value ; } public void setValue ( java . lang . String value ) { this . value = value ; } private java . lang . Object __equalsCalc = null ; public synchronized boolean equals ( java . lang . Object obj ) { if ( ! ( obj instanceof SearchRestriction ) ) return false ; SearchRestriction other = ( SearchRestriction ) obj ; if ( obj == null ) return false ; if ( this == obj ) return true ; if ( __equalsCalc != null ) { return ( __equalsCalc == obj ) ; } __equalsCalc = obj ; boolean _equals ; _equals = true && ( ( this . name == null && other . getName ( ) == null ) || ( this . name != null && this . name . equals ( other . getName ( ) ) ) ) && ( ( this . value == null && other . getValue ( ) == null ) || ( this . value != null && this . value . equals ( other . getValue ( ) ) ) ) ; __equalsCalc = null ; return _equals ; } private boolean __hashCodeCalc = false ; public synchronized int hashCode ( ) { if ( __hashCodeCalc ) { return 0 ; } __hashCodeCalc = true ; int _hashCode = 1 ; if ( getName ( ) != null ) { _hashCode += getName ( ) . hashCode ( ) ; } if ( getValue ( ) != null ) { _hashCode += getValue ( ) . hashCode ( ) ; } __hashCodeCalc = false ; return _hashCode ; } private static org . apache . axis . description . TypeDesc typeDesc = new org . apache . axis . description . TypeDesc ( SearchRestriction . class , true ) ; static { typeDesc . setXmlType ( new javax . xml . namespace . QName ( \"http://soap.integration.crowd.atlassian.com\" , \"SearchRestriction\" ) ) ; org . apache . axis . description . ElementDesc elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"name\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://soap.integration.crowd.atlassian.com\" , \"name\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://www.w3.org/2001/XMLSchema\" , \"string\" ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( true ) ; typeDesc . addFieldDesc ( elemField ) ; elemField = new org . apache . axis . description . ElementDesc ( ) ; elemField . setFieldName ( \"value\" ) ; elemField . setXmlName ( new javax . xml . namespace . QName ( \"http://soap.integration.crowd.atlassian.com\" , \"value\" ) ) ; elemField . setXmlType ( new javax . xml . namespace . QName ( \"http://www.w3.org/2001/XMLSchema\" , \"string\" ) ) ; elemField . setMinOccurs ( 0 ) ; elemField . setNillable ( true ) ; typeDesc . addFieldDesc ( elemField ) ; } public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; } public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class < ? > _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser", "gt": ". BeanSerializer ( _javaType , _xmlType , typeDesc ) ;", "prediction": "if ( mechType ) ;\n", "label": 0}
{"id": 15470, "input": "<s> package org . spliffy . server . web ; import org . spliffy . server . manager . PasswordManager ; import com . bradmcevoy . http . Auth ; import com . bradmcevoy . http . HttpManager ; import com . bradmcevoy . http . Request ; import com . bradmcevoy . http . Request . Method ; import com . bradmcevoy . http . Resource ; import com . bradmcevoy . http . http11 . auth . DigestResponse ; import com . ettrema . http . AccessControlledResource ; import com . ettrema . http . AccessControlledResource . Priviledge ; import java . util . List ; import org . hibernate . Session ; import org . spliffy . server . db . Organisation ; import org . spliffy . server . db . Profile ; import org . spliffy . server . db . utils . SessionManager ; import org . spliffy . server . db . utils . UserDao ; public class SpliffySecurityManager { private static org . apache . log4j . Logger log = org . apache . log4j . Logger . getLogger ( SpliffySecurityManager . class ) ; private String realm = \"spliffy\" ; private final UserDao userDao ; private final PasswordManager passwordManager ; public SpliffySecurityManager ( UserDao userDao , PasswordManager passwordManager ) { this . userDao = userDao ; this . passwordManager = passwordManager ; } public Profile getCurrentUser ( ) { return ( Profile ) HttpManager . request ( ) . getAttributes ( ) . get ( \"_current_user\" ) ; } public Profile authenticate ( Organisation org , String userName , String requestPassword ) { Session session = SessionManager . session ( ) ; Profile user = userDao . getProfile ( userName , org , session ) ; if ( user == null ) { return null ; } else { if ( passwordManager . verifyPassword ( user , requestPassword ) ) { HttpManager . request ( ) . getAttributes ( ) . put ( \"_current_user\" , user ) ; return user ; } else { return null ; } } } public Profile authenticate ( Organisation org , DigestResponse digest ) { log . info ( \"authenticate: \" + digest . getUser ( ) ) ; Session session = SessionManager . session ( ) ; Profile user = userDao . getProfile ( digest . getUser ( ) , org , session ) ; if ( user == null ) { log . warn ( \"user not found: \" + digest . getUser ( ) ) ; return null ; } if ( passwordManager . verifyDigest ( digest , user ) ) { log . warn ( \"digest auth ok: \" + user . getName ( ) ) ; return user ; } else { log . warn ( \"password verifuication failed\" ) ; return null ; } } public String getRealm ( ) { return realm ; } public boolean authorise ( Request req , Method method , Auth auth , Resource aThis ) { if ( aThis instanceof AccessControlledResource ) { AccessControlledResource acr = ( AccessControlledResource ) aThis ; List < Priviledge > privs = acr . getPriviledges ( auth ) ; boolean result ; if ( method . isWrite ) { result = SecurityUtils . hasWrite ( privs ) ; } else { result = SecurityUtils . hasRead ( privs ) ; } if ( ! result ) { log . info ( \"Denied access of: \" + auth + \" to resource: \" + aThis . getName ( ) + \" (\" + aThis . getClass ( ) + \") because of authorisation failure\" ) ; log . info ( \"Requires \" + ( method . isWrite ? \"writable\" : \"read\" ) + \"access\" ) ; log . info ( \"Allowed privs of current user are:\" ) ; for ( Priviledge p : privs ) { log . info ( \"   - \" + p ) ; } if ( log", "gt": ". isTraceEnabled ( ) )", "prediction": ". hasNext ( ) )\n", "label": 1}
{"id": 773, "input": "<s> package javax . lang . model . util ; import javax . lang . model . element . * ; import javax . annotation . processing . SupportedSourceVersion ; import static javax . lang . model . element . ElementKind . * ; import javax . lang . model . SourceVersion ; import static javax . lang . model . SourceVersion . * ; @ SupportedSourceVersion ( RELEASE_6 ) public class ElementScanner6 < R , P > extends AbstractElementVisitor6 < R , P > { protected final R DEFAULT_VALUE ; protected ElementScanner6 ( ) { DEFAULT_VALUE = null ; } protected ElementScanner6 ( R defaultValue ) { DEFAULT_VALUE = defaultValue ; } public final R scan ( Iterable < ? extends Element > iterable , P p ) { R result = DEFAULT_VALUE ; for ( Element e : iterable ) result = scan ( e , p ) ; return result ; } public R scan ( Element e , P p ) { return e . accept ( this , p ) ; } public final R scan ( Element e ) { return scan ( e , null ) ; } public R visitPackage ( PackageElement e , P p ) { return scan ( e . getEnclosedElements ( ) , p ) ; } public R visitType ( TypeElement e , P p ) { return scan ( e", "gt": ". getEnclosedElements ( ) , p ) ;", "prediction": ", null ) ;\n", "label": 0}
{"id": 15489, "input": "<s> package org . eclipse . swt . widgets ; import static org . mockito . Matchers . any ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyZeroInteractions ; import static org . mockito . Mockito . when ; import java . io . IOException ; import java . util . ArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . RWT ; import org . eclipse . rap . rwt . graphics . Graphics ; import org . eclipse . rap . rwt . internal . application . RWTFactory ; import org . eclipse . rap . rwt . internal . lifecycle . DisplayUtil ; import org . eclipse . rap . rwt . internal . lifecycle . EntryPointUtil ; import org . eclipse . rap . rwt . internal . lifecycle . IDisplayLifeCycleAdapter ; import org . eclipse . rap . rwt . internal . lifecycle . IUIThreadHolder ; import org . eclipse . rap . rwt . internal . lifecycle . LifeCycleUtil ; import org . eclipse . rap . rwt . internal . lifecycle . RWTLifeCycle ; import org . eclipse . rap . rwt . lifecycle . IEntryPoint ; import org . eclipse . rap . rwt . lifecycle . ILifeCycleAdapter ; import org . eclipse . rap . rwt . lifecycle . IWidgetAdapter ; import org . eclipse . rap . rwt . lifecycle . PhaseId ; import org . eclipse . rap . rwt . lifecycle . UICallBack ; import org . eclipse . rap . rwt . lifecycle . WidgetUtil ; import org . eclipse . rap . rwt . testfixture . Fixture ; import org . eclipse . rap . rwt . testfixture . internal . NoOpRunnable ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTError ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Cursor ; import org . eclipse . swt . graphics . Device ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . internal . widgets . IDisplayAdapter ; import org . eclipse . swt . layout . FillLayout ; import org . mockito . ArgumentCaptor ; public class Display_Test extends TestCase { @ Override protected void setUp ( ) throws Exception { Fixture . setUp ( ) ; Fixture . fakePhase ( PhaseId . PROCESS_ACTION ) ; } @ Override protected void tearDown ( ) throws Exception { Fixture . tearDown ( ) ; } public void testGetAdapterWithDisplayAdapter ( ) { Display display = new Display ( ) ; Object adapter = display . getAdapter ( IDisplayAdapter . class ) ; assertTrue ( adapter instanceof IDisplayAdapter ) ; } public void testGetAdapterWithWidgetAdapter ( ) { Display display = new Display ( ) ; Object", "gt": "adapter = display . getAdapter ( IWidgetAdapter . class ) ;", "prediction": "adapter = display . getAdapter ( IDisplayAdapter . class ) ;\n", "label": 1}
{"id": 6834, "input": "<s> package ar . com . fdvs . dj . test . subreport ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . view . JasperDesignViewer ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . core . DJConstants ; import ar . com . fdvs . dj . core . layout . ClassicLayoutManager ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . builders . FastReportBuilder ; import ar . com . fdvs . dj . domain . builders . SubReportBuilder ; import ar . com . fdvs . dj . domain . entities . Subreport ; import ar . com . fdvs . dj . test . BaseDjReportTest ; import ar . com . fdvs . dj . test . domain . Product ; public class SubReportBuilder2Test extends BaseDjReportTest { public DynamicReport buildReport ( ) throws Exception { FastReportBuilder drb = new FastReportBuilder ( ) ; drb . addColumn ( \"State\" , \"state\" , String . class . getName ( ) , 30 ) . addColumn ( \"Branch\" , \"branch\" , String . class . getName ( ) , 30 ) . addColumn ( \"Product Line\" , \"productLine\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item\" , \"item\" , String . class . getName ( ) , 50 ) . addColumn ( \"Item Code\" , \"id\" , Long . class . getName ( ) , 30 , true ) . addColumn ( \"Quantity\" , \"quantity\" , Long . class . getName ( ) , 60 , true ) . addColumn ( \"Amount\" , \"amount\" , Float . class . getName ( ) , 70 , true ) . addGroups ( 1 ) . setMargins ( 5 , 5 , 20 , 20 ) . setTitle ( \"November 2006 sales report\" ) . setSubtitle ( \"This report was generated at \" + new Date ( ) ) . setUseFullPageWidth ( true ) ; Subreport subreport = new SubReportBuilder ( ) . setDataSource ( DJConstants . DATA_SOURCE_ORIGIN_PARAMETER , DJConstants . DATA_SOURCE_TYPE_COLLECTION , \"statistics\" ) . setDynamicReport ( createFooterSubreport ( ) , new ClassicLayoutManager ( ) ) . setParameterMapPath ( \"subreportParameterMap\" ) . setSplitAllowed ( false ) . setStartInNewPage ( false ) . build ( ) ; drb . addSubreportInGroupFooter ( 1 , subreport ) ; params . put ( \"statistics\" , Product . statistics_ ) ; Map subreportParameterMap = new HashMap ( ) ; subreportParameterMap", "gt": ". put ( \"rightHeader\" , \"Sub report right header\" ) ;", "prediction": ". addAllowed ( true ) ;\n", "label": 0}
{"id": 15492, "input": "<s> package com . microsoft . schemas . sharepoint . soap ; import java . util . ArrayList ; import java . util . List ; import javax . xml . bind . annotation . XmlAccessType ; import javax . xml . bind . annotation . XmlAccessorType ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . bind . annotation . XmlElement ; import javax . xml . bind . annotation . XmlMixed ; import javax . xml . bind . annotation . XmlRootElement ; import javax . xml . bind . annotation . XmlType ; @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"getAttachmentCollectionResult\" } ) @ XmlRootElement ( name = \"GetAttachmentCollectionResponse\" ) public class GetAttachmentCollectionResponse { @ XmlElement ( name = \"GetAttachmentCollectionResult\" ) protected GetAttachmentCollectionResponse . GetAttachmentCollectionResult getAttachmentCollectionResult ; public GetAttachmentCollectionResponse . GetAttachmentCollectionResult getGetAttachmentCollectionResult ( ) { return getAttachmentCollectionResult ; } public void setGetAttachmentCollectionResult ( GetAttachmentCollectionResponse . GetAttachmentCollectionResult value ) { this . getAttachmentCollectionResult = value ; } @ XmlAccessorType ( XmlAccessType . FIELD ) @ XmlType ( name = \"\" , propOrder = { \"content\" } ) public static class GetAttachmentCollectionResult { @ XmlMixed @ XmlAnyElement ( lax = true ) protected List < Object > content ; public List", "gt": "< Object > getContent ( )", "prediction": "< Object > getContent ( )\n", "label": 1}
{"id": 35, "input": "<s> class Dummy { Dummy ( String s ) { System . out . println ( s ) ; } } class AnonymousNull { void method ( ) {", "gt": "new Dummy ( null )", "prediction": "return null ;\n", "label": 0}
{"id": 15495, "input": "<s> package com . northconcepts . eventbus . filter ; import com . northconcepts . eventbus . Event ; import com . northconcepts . eventbus . EventFilter ; public class AndFilter implements EventFilter { private final EventFilter [ ] filter ; public AndFilter ( EventFilter ... filter ) { this . filter = filter ; } @ Override public boolean allow ( Event < ? > event , Object listener ) { if ( filter ==", "gt": "null || filter . length == 0 )", "prediction": "null )\n", "label": 1}
{"id": 6432, "input": "<s> public class T6507024 < T > { < Z > void m ( T6507024 < Z > [ ] results ) { T6507024 < Z > [ ] r = results . getClass ( ) .", "gt": "cast ( null ) ;", "prediction": "getName ( ) ;\n", "label": 0}
{"id": 15516, "input": "<s> package org . eclipse . ui . part ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . IEditorSite ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . IPropertyListener ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . internal . EditorSite ; import org . eclipse . ui . internal . PartService ; import org . eclipse . ui . internal . PartSite ; import org . eclipse . ui . internal . WorkbenchPage ; public abstract class AbstractMultiEditor extends EditorPart { private int activeEditorIndex ; private IEditorPart innerEditors [ ] ; private IPartListener2 propagationListener ; public AbstractMultiEditor ( ) { super ( ) ; } protected void handlePropertyChange ( int propId ) { firePropertyChange ( propId ) ; } public void doSave ( IProgressMonitor monitor ) { for ( int i = 0 ; i < innerEditors . length ; i ++ ) { IEditorPart e = innerEditors [ i ] ; e . doSave ( monitor ) ; } } public void doSaveAs ( ) { } public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { init ( site , ( MultiEditorInput ) input ) ; } public void init ( IEditorSite site , MultiEditorInput input ) throws PartInitException { setInput ( input ) ; setSite ( site ) ; setPartName ( input . getName ( ) ) ; setTitleToolTip ( input . getToolTipText ( ) ) ; setupEvents ( ) ; } public boolean isDirty ( ) { for ( int i = 0 ; i < innerEditors . length ; i ++ ) { IEditorPart e = innerEditors [ i ] ; if ( e . isDirty ( ) ) { return true ; } } return false ; } public boolean isSaveAsAllowed ( ) { return false ; } public void setFocus ( ) { innerEditors [ activeEditorIndex ] . setFocus ( ) ; } public final IEditorPart getActiveEditor ( ) { return innerEditors [ activeEditorIndex ] ; } public final IEditorPart [ ] getInnerEditors ( ) { return innerEditors ; } public final void setChildren ( IEditorPart [ ] children ) { innerEditors = children ; activeEditorIndex = 0 ; for ( int i = 0 ; i < children . length ; i ++ ) { children [ i ] . addPropertyListener ( new IPropertyListener ( ) { public void propertyChanged ( Object source , int propId ) { handlePropertyChange ( propId ) ; } } ) ; } innerEditorsCreated ( ) ; } protected abstract void innerEditorsCreated ( ) ; public void activateEditor ( IEditorPart part ) { activeEditorIndex = getIndex ( part ) ; IEditorPart e = getActiveEditor ( ) ; EditorSite innerSite = ( EditorSite ) e . getEditorSite ( ) ; ( ( WorkbenchPage ) innerSite . getPage ( ) ) . requestActivation ( e ) ; } protected int getIndex ( IEditorPart editor ) { for ( int i = 0 ; i < innerEditors . length ; i ++ ) { if ( innerEditors [ i ] == editor ) { return i ; } } return - 1 ; } private void setupEvents ( ) { propagationListener = new IPartListener2 ( ) { public void partActivated ( IWorkbenchPartReference partRef ) { } public void partBroughtToTop ( IWorkbenchPartReference partRef ) { } public void partClosed ( IWorkbenchPartReference partRef ) { IWorkbenchPart part = partRef . getPart ( false ) ; if ( part == AbstractMultiEditor . this && innerEditors != null ) { PartService partService = ( ( WorkbenchPage ) getSite ( ) . getPage ( ) ) . getPartService ( ) ; for ( int i = 0 ; i < innerEditors . length ; i ++ ) { IEditorPart editor = innerEditors [ i ] ; IWorkbenchPartReference innerRef = ( ( PartSite ) editor . getSite (", "gt": ") ) . getPartReference ( ) ;", "prediction": ") ) ;\n", "label": 1}
{"id": 8665, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; import org . jjflyboy . tjpeditor . project . Task ; import org . jjflyboy . tjpeditor . project . TaskRoot ; public class TaskRootImpl extends ReportAttributeImpl implements TaskRoot { protected Task task ; protected TaskRootImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getTaskRoot ( ) ; } public Task getTask ( ) { if ( task != null && task . eIsProxy ( ) ) { InternalEObject oldTask = ( InternalEObject ) task ; task = ( Task ) eResolveProxy ( oldTask ) ; if ( task != oldTask ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . TASK_ROOT__TASK , oldTask , task ) ) ; } } return task ; } public Task basicGetTask ( ) { return task ; } public void setTask ( Task newTask ) { Task oldTask = task ; task = newTask ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage", "gt": ". TASK_ROOT__TASK , oldTask , task ) ) ;", "prediction": ". TASK_ROOT__TASK , oldTask , task ) ) ;\n", "label": 0}
{"id": 15534, "input": "<s> package org . eclipse . rap . rwt . internal . textsize ; import junit . framework . TestCase ; import org . eclipse . rap . rwt . internal . textsize . Probe ; import org . eclipse . rap . rwt . internal . textsize . ProbeStore ; import org . eclipse . rap . rwt . internal . textsize . TextSizeStorage ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; public class ProbeStore_Test extends TestCase { private static final FontData FONT_DATA = new FontData ( \"arial\" , 23 , SWT . BOLD ) ; private ProbeStore probeStore ; private TextSizeStorage textSizeStorage ; public void testInitialSize ( ) { assertEquals ( 0 , probeStore . getSize ( ) ) ; } public void testProbeCreation ( ) { Probe probe = createProbe ( ) ; assertEquals ( 1 , probeStore . getSize ( ) ) ; assertSame ( FONT_DATA , probe . getFontData ( ) ) ; } public void testGetProbe ( ) { Probe probe = createProbe ( ) ; assertSame ( probe , probeStore . getProbe ( FONT_DATA ) ) ; } public void testGetProbes ( ) { Probe probe = createProbe ( ) ; Probe", "gt": "[ ] probes = probeStore . getProbes ( ) ;", "prediction": "Store probeStore = new ProbeStore ( ) ;\n", "label": 1}
{"id": 8155, "input": "<s> import java . util . List ; import java . util . ArrayList ; public class CaptureInSubtype { static class SuperOfFlaw < S > { S s ; S get ( ) { return s ; } void put ( S a ) { s = a ; } SuperOfFlaw ( S a ) { s = a ; } } static class Flaw < T > extends SuperOfFlaw < List < T > > { List < T > fetch ( ) { return s ; } Flaw ( T t ) { super ( new ArrayList < T > ( ) ) ; s . add ( t ) ; } } static class SuperOfShowFlaw { SuperOfFlaw < List < ? > > m ( ) { return null ; } } public static class ShowFlaw extends SuperOfShowFlaw { static Flaw < Number > fn = new Flaw < Number > ( new Integer ( 3 ) ) ; Flaw < ? > m ( ) { return fn ; } } public static void main ( String [ ] args ) { SuperOfShowFlaw sosf = new ShowFlaw ( ) ; SuperOfFlaw < List < ? > > sof = sosf . m ( ) ; List < String > ls = new ArrayList < String > ( ) ; ls . add ( \"Smalltalk rules!\" ) ; sof . put ( ls ) ; Number n = ShowFlaw .", "gt": "fn . get ( ) . get ( 0 ) ;", "prediction": "next ( ) ;\n", "label": 0}
{"id": 15542, "input": "<s> package io . beancounter . platform ; public class ServiceException extends Exception { public ServiceException ( Exception e ) { super ( e ) ; } public ServiceException ( String message ) { super ( message ) ; } public ServiceException", "gt": "( String message , Exception e )", "prediction": "( String message )\n", "label": 1}
{"id": 8366, "input": "<s> import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import javax . tools . * ; public class TestTypeParameter < T > extends JavacTestingAbstractProcessor { int round = 0 ; public boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { if ( ++ round == 1 ) { int found = ( new Scanner ( ) ) . scan ( roundEnv . getRootElements ( ) , null ) ; if ( found == expect ) { note ( \"generic elements found and verified: \" + found ) ; } else { error ( \"unexpected number of results: expected \" + expect + \", found \" + found ) ; } } return true ; } class Scanner extends ElementScanner7 < Integer , Void > { @ Override public Integer visitExecutable ( ExecutableElement e , Void p ) { super . visitExecutable ( e , p ) ; found += check ( e , e . getTypeParameters ( ) ) ; return found ; } @ Override public Integer visitType ( TypeElement e , Void p ) { super . visitType ( e , p ) ; found += check ( e , e . getTypeParameters ( ) ) ; return found ; } int found ; } int check ( Element e , List < ? extends TypeParameterElement > typarams ) { note ( \"checking \" + e , e ) ; if ( typarams . isEmpty ( ) ) { note ( \"no type parameters found\" , e ) ; return 0 ; } for ( TypeParameterElement tpe : typarams ) { note ( \"checking type parameter \" + tpe , tpe ) ; if ( tpe", "gt": ". getEnclosingElement ( ) != e )", "prediction": ". isEmpty ( ) )\n", "label": 0}
{"id": 15559, "input": "<s> package org . modelgoon . core . editparts ; import org . eclipse . draw2d . ConnectionAnchor ; import org . eclipse . draw2d . IFigure ; import org . eclipse . gef . ConnectionEditPart ; import org . eclipse . gef . EditPolicy ; import org . eclipse . gef . Request ; import org . eclipse . gef . RequestConstants ; import org . eclipse . gef . commands . Command ; import org . modelgoon . core . Note ; import org . modelgoon . core . NoteFigure ; import org . modelgoon . core . ui . AbstractComponentEditPart ; public class NoteEditPart extends AbstractComponentEditPart < Note > { NoteFigure noteFigure ; @ Override protected void doCreateEditPolicies ( ) { installEditPolicy ( EditPolicy . GRAPHICAL_NODE_ROLE , null ) ; installEditPolicy ( EditPolicy . DIRECT_EDIT_ROLE , new NoteDirectEditPolicy ( ) ) ; setDeleteCommand ( new Command ( ) { @ Override public void execute ( ) { getModelElement ( ) . removeFromDiagram ( ) ; } } ) ; } private void performDirectEdit ( ) { new LogicLabelEditManager ( this , new LabelCellEditorLocator ( this . noteFigure ) ) . show ( ) ; } @ Override public void performRequest ( final Request request ) { if ( request . getType ( ) == RequestConstants . REQ_DIRECT_EDIT ) { performDirectEdit ( ) ; } } public ConnectionAnchor getSourceConnectionAnchor ( final ConnectionEditPart connection ) { return null ; } public ConnectionAnchor getTargetConnectionAnchor ( final ConnectionEditPart connection ) { return null ; } public ConnectionAnchor getSourceConnectionAnchor ( final Request request ) { return null ; } public ConnectionAnchor getTargetConnectionAnchor ( final Request request ) { return null ; } @ Override protected void doRefreshVisuals ( final Note model ) { this . noteFigure . setLocation ( model .", "gt": "getLocation ( ) ) ;", "prediction": "getLocation ( ) ) ;\n", "label": 1}
{"id": 2434, "input": "<s> package a ; public class First { First ( ) { } p . Gen1 x ; void m ( int i ) { class Local { Local ( ) { } } Runnable r", "gt": "= new Runnable ( )", "prediction": "= new Runnable ( ) ;\n", "label": 0}
{"id": 15573, "input": "<s> package org . restlet . test . ext . freemarker ; import java . io . File ; import java . io . FileWriter ; import java . util . Map ; import java . util . TreeMap ; import org . restlet . data . MediaType ; import org . restlet . engine . io . BioUtils ; import org . restlet . ext . freemarker . TemplateRepresentation ; import org . restlet . test . RestletTestCase ; import freemarker . template . Configuration ; public class FreeMarkerTestCase extends RestletTestCase { public void testTemplate ( ) throws Exception { final File testDir = new File ( System . getProperty ( \"java.io.tmpdir\" ) , \"FreeMarkerTestCase\" ) ; testDir . mkdir ( ) ; final File testFile = File . createTempFile ( \"test\" , \".ftl\" , testDir ) ; final FileWriter fw = new FileWriter ( testFile ) ; fw . write ( \"Value=${value}\" ) ; fw . close ( ) ; final Configuration fmc = new Configuration ( ) ; fmc . setDirectoryForTemplateLoading ( testDir ) ; final Map < String , Object > map = new TreeMap < String , Object > ( ) ; map . put ( \"value\" , \"myValue\" ) ; final String result = new TemplateRepresentation ( testFile . getName ( ) , fmc , map , MediaType . TEXT_PLAIN ) . getText ( ) ; assertEquals", "gt": "( \"Value=myValue\" , result ) ;", "prediction": "( result ) ;\n", "label": 1}
{"id": 552, "input": "<s> package com . redhat . ceylon . ceylondoc ; import java . io . File ; import java . text . BreakIterator ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import com . github . rjeschke . txtmark . BlockEmitter ; import com . github . rjeschke . txtmark . Configuration ; import com . github . rjeschke . txtmark . Processor ; import com . github . rjeschke . txtmark . SpanEmitter ; import com . redhat . ceylon . compiler . typechecker . context . PhasedUnit ; import com . redhat . ceylon . compiler . typechecker . model . Annotation ; import com . redhat . ceylon . compiler . typechecker . model . Class ; import com . redhat . ceylon . compiler . typechecker . model . Declaration ; import com . redhat . ceylon . compiler . typechecker . model . Module ; import com . redhat . ceylon . compiler . typechecker . model . Package ; import com . redhat . ceylon . compiler . typechecker . model . ProducedType ; import com . redhat . ceylon . compiler . typechecker . model . TypeDeclaration ; import com . redhat . ceylon . compiler . typechecker . model . Value ; public class Util { protected static String join ( String str , List < String > parts ) { StringBuilder stringBuilder = new StringBuilder ( ) ; Iterator < String > iterator = parts . iterator ( ) ; while ( iterator . hasNext ( ) ) { stringBuilder . append ( iterator . next ( ) ) ; if ( iterator . hasNext ( ) ) stringBuilder . append ( str ) ; } return stringBuilder . toString ( ) ; } private static final int FIRST_LINE_MAX_SIZE = 120 ; public static String getDoc ( Declaration decl , LinkRenderer linkRenderer ) { return wikiToHTML ( getRawDoc ( decl ) , linkRenderer . useScope ( decl ) ) ; } public static String getDoc ( Module module , LinkRenderer linkRenderer ) { return wikiToHTML ( getRawDoc ( module . getAnnotations ( ) ) , linkRenderer . useScope ( module ) ) ; } public static List < String > getAuthors ( List < Annotation > anns ) { ArrayList < String > moduleAuthors = new ArrayList < > ( ) ; for ( Annotation a : anns ) { if ( a . getPositionalArguments ( ) != null && ! a . getPositionalArguments ( ) . isEmpty ( ) && a . getName ( ) . equals ( \"by\" ) ) { for ( String author : a . getPositionalArguments ( ) ) { moduleAuthors . add ( unquote ( author ) ) ; } } } return moduleAuthors ; } public static List < String > getAuthors ( Module module ) { return getAuthors ( module . getAnnotations ( ) ) ; } public static List < String > getAuthors ( Package pkg ) { return getAuthors ( pkg . getAnnotations ( ) ) ; } public static String getDoc ( Package pkg , LinkRenderer linkRenderer ) { return wikiToHTML ( getRawDoc ( pkg . getAnnotations ( ) ) , linkRenderer . useScope ( pkg ) ) ; } public static String getDocFirstLine ( Declaration decl , LinkRenderer linkRenderer ) { return wikiToHTML ( getFirstLine ( getRawDoc ( decl ) ) , linkRenderer . useScope ( decl ) ) ; } public static String getDocFirstLine ( Package pkg , LinkRenderer linkRenderer ) { return wikiToHTML ( getFirstLine ( getRawDoc ( pkg . getAnnotations ( ) ) ) , linkRenderer . useScope ( pkg ) ) ; }", "gt": "public static String getDocFirstLine ( Module module , LinkRenderer linkRenderer )", "prediction": "public static String getDocFirstLine ( Package pkg , LinkRenderer linkRenderer )\n", "label": 0}
{"id": 15580, "input": "<s> package org . nuxeo . theme . editor ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . Set ; import java . util . regex . Matcher ; import javax . ws . rs . FormParam ; import javax . ws . rs . GET ; import javax . ws . rs . POST ; import javax . ws . rs . Path ; import javax . ws . rs . Produces ; import javax . ws . rs . QueryParam ; import javax . ws . rs . core . MediaType ; import javax . ws . rs . core . Response ; import javax . ws . rs . core . Response . ResponseBuilder ; import net . sf . json . JSONObject ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . nuxeo . ecm . platform . web . common . vh . VirtualHostHelper ; import org . nuxeo . ecm . webengine . WebEngine ; import org . nuxeo . ecm . webengine . model . Access ; import org . nuxeo . ecm . webengine . model . WebObject ; import org . nuxeo . ecm . webengine . model . impl . ModuleRoot ; import org . nuxeo . theme . Manager ; import org . nuxeo . theme . elements . Element ; import org . nuxeo . theme . elements . ElementFormatter ; import org . nuxeo . theme . elements . PageElement ; import org . nuxeo . theme . elements . ThemeElement ; import org . nuxeo . theme . formats . Format ; import org . nuxeo . theme . formats . FormatType ; import org . nuxeo . theme . formats . layouts . Layout ; import org . nuxeo . theme . formats . styles . Style ; import org . nuxeo . theme . formats . widgets . Widget ; import org . nuxeo . theme . fragments . Fragment ; import org . nuxeo . theme . fragments . FragmentType ; import org . nuxeo . theme . perspectives . PerspectiveManager ; import org . nuxeo . theme . perspectives . PerspectiveType ; import org . nuxeo . theme . presets . PresetManager ; import org . nuxeo . theme . presets . PresetType ; import org . nuxeo . theme . resources . ImageInfo ; import org . nuxeo . theme . resources . ResourceBank ; import org . nuxeo . theme . resources . SkinInfo ; import org . nuxeo . theme . themes . ThemeDescriptor ; import org . nuxeo . theme . themes . ThemeException ; import org . nuxeo . theme . themes . ThemeIOException ; import org . nuxeo . theme . themes . ThemeManager ; import org . nuxeo . theme . themes . ThemeSerializer ; import org . nuxeo . theme . types . TypeFamily ; import org . nuxeo . theme . views . ViewType ; @ Path ( \"/nxthemes-editor\" ) @ WebObject ( type = \"nxthemes-editor\" , administrator = Access . GRANT ) @ Produces ( MediaType . TEXT_HTML ) public class Main extends ModuleRoot { private static final Log log = LogFactory . getLog ( Main . class ) ; @ GET @ Path ( \"perspectiveSelector\" ) public Object renderPerspectiveSelector ( @ QueryParam ( \"org.nuxeo.theme.application.path\" ) String path , @ QueryParam ( \"org.nuxeo.theme.application.name\" ) String name ) { return getTemplate ( \"perspectiveSelector.ftl\" ) . arg ( \"perspectives\" , getPerspectives ( ) ) ; } @ GET @ Path ( \"themeSelector\" ) public Object renderThemeSelector ( @ QueryParam ( \"org.nuxeo.theme.application.path\" ) String path , @ QueryParam ( \"org.nuxeo.theme.application.name\" ) String name ) { return getTemplate ( \"themeSelector.ftl\" ) . arg ( \"current_theme_name\" , getCurrentThemeName ( path , name ) ) . arg ( \"themes\" , getWorkspaceThemes ( path , name ) ) ; } @ GET @ Path ( \"pageSelector\" ) public Object renderPageSelector ( @ QueryParam ( \"org.nuxeo.theme.application.path\" ) String path , @ QueryParam ( \"org.nuxeo.theme.application.name\" ) String name ) { return getTemplate ( \"pageSelector.ftl\" ) . arg ( \"current_theme_name\" , getCurrentThemeName ( path , name ) ) . arg ( \"pages\" , getPages ( path , name ) ) ; } @ GET @ Path ( \"canvasModeSelector\" ) public Object renderCanvasModeSelector ( @ QueryParam ( \"org.nuxeo.theme.application.path\" ) String path , @ QueryParam ( \"org.nuxeo.theme.application.name\" ) String name ) { return getTemplate ( \"canvasModeSelector.ftl\" ) ; } @ GET @ Path ( \"themeOptions\" ) public Object renderThemeOptions ( @ QueryParam ( \"org.nuxeo.theme.application.path\" ) String path , @ QueryParam ( \"org.nuxeo.theme.application.name\" ) String name ) { String currentThemeName = getCurrentThemeName ( path , name ) ; String templateEngine = getTemplateEngine ( path ) ; ThemeDescriptor currentThemeDef = ThemeManager . getThemeDescriptorByThemeName ( templateEngine , currentThemeName ) ; return getTemplate ( \"themeOptions.ftl\" ) .", "gt": "arg ( \"current_theme\" , currentThemeDef ) ;", "prediction": "arg ( \"themeOptions\" , getThemeOptions ( ) ) ;\n", "label": 1}
{"id": 8090, "input": "<s> package org . apache . tools . bzip2 ; final class CRC { static final int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; }", "gt": "void updateCRC ( int inCh )", "prediction": "}\n", "label": 0}
{"id": 15611, "input": "<s> package com . codeslap . persistence . pref ; import android . content . SharedPreferences ; import android . preference . * ; import android . text . InputType ; import android . widget . TextView ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class PersistencePreferenceActivity extends PreferenceActivity { private final Map < android . preference . Preference , String > mDependencies = new HashMap < android . preference . Preference , String > ( ) ; @ Override protected void onPostResume ( ) { super . onPostResume ( ) ; for ( android . preference . Preference preference : mDependencies . keySet ( ) ) { if ( preference . getDependency ( ) == null ) { preference . setDependency ( mDependencies . get ( preference ) ) ; } } } public void addPreferencesFrom ( Class < ? > ... classes ) { addPreferencesFrom ( null , classes ) ; } public void addPreferencesFrom ( PrefsFactory prefsFactory , Class < ? > ... classes ) { if ( getPreferenceScreen ( ) == null ) { PreferenceScreen preferenceScreen = getPreferenceManager ( ) . createPreferenceScreen ( this ) ; setPreferenceScreen ( preferenceScreen ) ; } Map < Integer , List < PrefMetadata > > fieldMap = new HashMap < Integer , List < PrefMetadata > > ( ) ; List < CategoryMetadata > categories = new ArrayList < CategoryMetadata > ( ) ; for ( Class < ? > theClass : classes ) { for ( Field field : theClass . getDeclaredFields ( ) ) { Preference annotation = field . getAnnotation ( Preference . class ) ; if ( annotation == null || annotation . ignore ( ) ) { continue ; } int title = annotation . title ( ) ; int summary = annotation . summary ( ) ; if ( title == 0 && summary == 0 ) { continue ; } Class < ? > type = field . getType ( ) ; if ( type != String . class && type != int . class && type != Integer . class && type != float . class && type != Float . class && type != double . class && type != Double . class && type != boolean . class && type != Boolean . class ) { continue ; } PrefMetadata prefMetaData = new PrefMetadata ( ) . setTitle ( title ) . setSummary ( summary ) . setOrder ( annotation . order ( ) ) . setType ( type ) . setDefaultValue ( annotation . defaultValue ( ) ) . setKey ( annotation . value ( ) ) . setDependency ( annotation . dependency ( ) ) . setEntries ( annotation . entries ( ) ) . setEntryValues ( annotation . entryValues ( ) ) . setDialogIcon ( annotation . dialogIcon ( ) ) . setDialogMessage ( annotation . dialogMessage ( ) ) . setDialogTitle ( annotation . dialogTitle ( ) ) ; if ( fieldMap . containsKey ( annotation", "gt": ". category ( ) ) )", "prediction": ") )\n", "label": 1}
{"id": 4741, "input": "<s> package objects ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . * ; import main . Application ; public class LoadingPane extends JPanel implements ActionListener { private Container contentPane ; private boolean inited ; JPasswordField pass ; public LoadingPane ( Container contentPane ) { this . contentPane = contentPane ; setLayout ( null ) ; } private void init ( ) { inited = true ; setBounds ( contentPane . getX ( ) , contentPane . getY ( ) , 100 , 25 ) ; setMaximumSize ( getSize ( ) ) ; setMinimumSize ( getSize ( ) ) ; } @ Override public void paintComponent ( Graphics gr ) { super . paintComponent ( gr ) ; if ( ! inited ) { init ( ) ; } Graphics2D g = ( Graphics2D ) gr ; AlphaComposite transparent = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , .7f ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setComposite ( transparent ) ; contentPane . paint ( gr ) ; Color bgColor = new Color ( 50 , 50 , 50 , 50 ) ; g . setColor ( bgColor ) ; g . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; AlphaComposite solid = AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 1f ) ; g . setComposite ( solid ) ; g . setColor ( Color . black ) ; g . drawString ( \"Glass pane string\" , 50 , 100 ) ; g . drawString ( \"which is drawn", "gt": "manually!\" , 50 , 120 ) ;", "prediction": "\" , 50 , 100 ) ;\n", "label": 0}
{"id": 15642, "input": "<s> package com . cloudera . sqoop . manager ; import java . io . IOException ; import java . sql . Connection ; import java . sql . SQLException ; import java . sql . PreparedStatement ; import java . util . Arrays ; import java . util . ArrayList ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . hadoop . conf . Configuration ; import com . cloudera . sqoop . TestExport ; import com . cloudera . sqoop . mapreduce . db . DBConfiguration ; public class PGBulkloadManagerManualTest extends TestExport { public static final Log LOG = LogFactory . getLog ( PGBulkloadManagerManualTest . class . getName ( ) ) ; private DBConfiguration dbConf ; public PGBulkloadManagerManualTest ( ) { Configuration conf = getConf ( ) ; DBConfiguration . configureDB ( conf , \"org.postgresql.Driver\" , getConnectString ( ) , getUserName ( ) , null , null ) ; dbConf = new DBConfiguration ( conf ) ; } @ Override protected boolean useHsqldbTestServer ( ) { return false ; } @ Override protected String getConnectString ( ) { return \"jdbc:postgresql://localhost:5432/sqooptest\" ; } protected String getUserName ( ) { return \"sqooptest\" ; } @ Override protected String getTablePrefix ( ) { return super . getTablePrefix ( ) . toLowerCase ( ) ; } @ Override protected String getTableName ( ) { return super . getTableName ( ) . toLowerCase ( ) ; } @ Override public String getStagingTableName ( ) { return super . getStagingTableName ( ) . toLowerCase ( ) ; } @ Override protected Connection getConnection ( ) { try { Connection conn = dbConf . getConnection ( ) ; conn . setAutoCommit ( false ) ; PreparedStatement stmt = conn . prepareStatement ( \"SET extra_float_digits TO 0\" ) ; stmt . executeUpdate ( ) ; conn . commit ( ) ; return conn ; } catch ( SQLException sqlE ) { LOG . error ( \"Could not get connection to test server: \" + sqlE ) ; return null ; } catch ( ClassNotFoundException cnfE ) { LOG . error ( \"Could not find driver class: \" + cnfE ) ; return null ; } } @ Override protected String getDropTableStatement ( String tableName ) { return \"DROP TABLE IF EXISTS \" + tableName ; } @ Override protected String [ ] getArgv ( boolean includeHadoopFlags , int rowsPerStatement , int statementsPerTx , String ... additionalArgv ) { ArrayList < String > args = new ArrayList < String > ( Arrays . asList ( additionalArgv ) ) ; args . add ( \"--username\" ) ; args . add ( getUserName ( ) ) ; args . add ( \"--connection-manager\" ) ; args . add ( \"org.apache.sqoop.manager.PGBulkloadManager\" ) ; args . add ( \"--staging-table\" ) ; args . add ( \"dummy\" ) ; args . add ( \"--clear-staging-table\" ) ; return super . getArgv ( includeHadoopFlags , rowsPerStatement , statementsPerTx , args . toArray ( new String [ 0 ] ) ) ; } @ Override protected String [ ] getCodeGenArgv ( String ... extraArgs ) { ArrayList < String > args = new ArrayList < String > ( Arrays . asList ( extraArgs ) ) ; args . add ( \"--username\" ) ; args . add ( getUserName ( ) ) ; return super . getCodeGenArgv ( args . toArray ( new String [ 0 ] ) ) ; } @ Override public void testColumnsExport ( ) throws IOException , SQLException { } public void testMultiReduceExport ( ) throws IOException , SQLException { String [ ] genericargs = newStrArray ( null , \"-Dmapred.reduce.tasks=2\" ) ; multiFileTestWithGenericArgs ( 2 , 10 , 2 , genericargs ) ; } public void testExportWithTablespace ( ) throws IOException , SQLException { String [ ] genericargs = newStrArray ( null , \"-Dpgbulkload.staging.tablespace=sqooptest\" ) ; multiFileTestWithGenericArgs ( 1 , 10 , 1 , genericargs ) ; } protected void multiFileTestWithGenericArgs ( int numFiles , int recordsPerMap , int numMaps , String [ ] genericargs , String ... argv ) throws IOException , SQLException { final int TOTAL_RECORDS = numFiles * recordsPerMap ; try { LOG . info ( \"Beginning test: numFiles=\" + numFiles + \"; recordsPerMap=\" + recordsPerMap + \"; numMaps=\" + numMaps ) ; LOG . info ( \"  with genericargs: \" ) ; for ( String arg : genericargs ) { LOG . info ( \"", "gt": "   \" + arg ) ;", "prediction": "\" + arg ) ;\n", "label": 1}
{"id": 9394, "input": "<s> package com . farpost . ldt ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Modifier ; public class TaskFactory { public static Task createTask ( String fqnClass ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { String methodName = null ; if ( fqnClass . contains ( \"#\" ) ) { String [ ] parts = fqnClass . split ( \"#\" , 2 ) ; fqnClass = parts [ 0 ] ; methodName = parts [ 1 ] ; } Class < ? > type = Class . forName ( fqnClass ) ; if ( isAbstract ( type ) ) { throw new IllegalArgumentException ( type . getName ( ) + \" should not be not abstract class nor interface\" ) ; } Object o = type . getConstructor ( ) . newInstance ( ) ; if ( Task . class . isAssignableFrom ( type ) && methodName == null ) { return ( Task ) o ; } else { return methodName == null ? new PojoTask < Object > ( o ) : new PojoTask < Object > (", "gt": "o , methodName ) ;", "prediction": "o ) ;\n", "label": 0}
{"id": 15645, "input": "<s> package org . restlet . ext . ssl ; import java . security . Principal ; import java . security . cert . Certificate ; import java . security . cert . X509Certificate ; import java . util . ArrayList ; import java . util . List ; import javax . security . auth . x500 . X500Principal ; import org . restlet . Context ; import org . restlet . Request ; import org . restlet . Response ; import org . restlet . data . Status ; import org . restlet . security . Authenticator ; import org . restlet . security . User ; public class CertificateAuthenticator extends Authenticator { public CertificateAuthenticator ( Context context ) { super ( context ) ; } protected List < Principal > getPrincipals ( List < Certificate > certificateChain ) { ArrayList < Principal > principals = null ; if ( ( certificateChain != null ) && ( certificateChain . size ( ) > 0 ) ) { Certificate userCert = certificateChain . get ( 0 ) ; if ( userCert instanceof X509Certificate ) { principals = new ArrayList < Principal > ( ) ; principals . add ( ( ( X509Certificate ) userCert ) . getSubjectX500Principal ( ) ) ; } return principals ; } else { return null ; } } protected User getUser ( Principal principal ) { if ( principal != null ) { return new User ( principal . getName ( ) ) ; } else { return null ; } } @ Override protected boolean authenticate ( Request request , Response response ) { List < Certificate > certchain = request . getClientInfo ( ) . getCertificates ( ) ; List < Principal > principals = getPrincipals ( certchain ) ; if ( ( principals != null ) && ( principals . size ( ) > 0 ) ) { request . getClientInfo ( ) . getPrincipals ( ) . addAll ( principals ) ; User user = getUser (", "gt": "principals . get ( 0 ) ) ;", "prediction": "principal ) ;\n", "label": 1}
{"id": 2518, "input": "<s> package org . ofbiz . base . util . collections ; import java . io . Serializable ; import java . util . Locale ; import java . util . Map ; import javax . el . PropertyNotFoundException ; import org . ofbiz . base . lang . IsEmpty ; import org . ofbiz . base . lang . SourceMonitored ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilObject ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . cache . UtilCache ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . base . util . string . UelUtil ; @ SourceMonitored @ SuppressWarnings ( \"serial\" ) public class FlexibleMapAccessor < T > implements Serializable , IsEmpty { public static final String module = FlexibleMapAccessor . class . getName ( ) ; protected static final UtilCache < String , FlexibleMapAccessor < ? > > fmaCache = UtilCache . createUtilCache ( \"flexibleMapAccessor.ExpressionCache\" ) ; @ SuppressWarnings ( \"unchecked\" ) protected static final FlexibleMapAccessor nullFma = new FlexibleMapAccessor ( \"\" ) ; protected final String original ; protected final String bracketedOriginal ; protected final FlexibleStringExpander fse ; protected boolean isAscending = true ; protected FlexibleMapAccessor ( String name ) { this . original = name ; FlexibleStringExpander fse = null ; String bracketedOriginal = null ; if ( UtilValidate . isNotEmpty ( name ) ) { if ( name . charAt ( 0 ) == '-' ) { this . isAscending = false ; name = name . substring ( 1 ) ; } else if ( name . charAt ( 0 ) == '+' ) { this . isAscending = true ; name = name . substring ( 1 ) ; } if ( name . contains ( FlexibleStringExpander . openBracket ) ) { fse = FlexibleStringExpander . getInstance ( name ) ; } else { bracketedOriginal = FlexibleStringExpander . openBracket . concat ( UelUtil . prepareExpression ( name ) . concat ( FlexibleStringExpander . closeBracket ) ) ; } } this . bracketedOriginal = bracketedOriginal ; this . fse = fse ; if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"FlexibleMapAccessor created, original = \" + this . original , module ) ; } } @ SuppressWarnings ( \"unchecked\" ) public static < T > FlexibleMapAccessor < T > getInstance ( String original ) { if ( UtilValidate . isEmpty ( original ) || \"null\" . equals ( original ) ) { return nullFma ; } FlexibleMapAccessor fma = fmaCache . get ( original ) ; if ( fma == null ) { fmaCache . put ( original , new FlexibleMapAccessor ( original ) ) ; fma = fmaCache . get ( original ) ; } return fma ; } public boolean containsNestedExpression ( ) { return fse != null ; } public String getOriginalName ( ) { return this . original ; } public boolean getIsAscending ( ) { return this . isAscending ; } public boolean isEmpty ( ) { return this . original . length ( ) == 0 ; } public T get ( Map < String , ? extends Object > base ) { return get ( base , null ) ; } public T get ( Map < String , ? extends Object > base , Locale locale ) { if ( base == null || this . isEmpty ( ) ) { return null ; } if ( ! base . containsKey ( UelUtil . localizedMapLocaleKey ) && locale != null ) { Map < String , Object > writableMap = UtilGenerics . cast ( base ) ; writableMap . put ( UelUtil . localizedMapLocaleKey , locale ) ; } Object obj = null ; try { obj = UelUtil . evaluate ( base , getExpression ( base ) ) ; } catch ( PropertyNotFoundException e ) { if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( \"UEL exception while getting value: \" + e + \", original = \" + this . original , module ) ; } } catch ( Exception e ) { Debug . logError ( \"UEL exception while getting value: \" + e + \", original = \" + this . original , module ) ; } return UtilGenerics . < T > cast ( obj ) ; } public void put ( Map < String , Object > base , T value ) { if ( this . isEmpty ( ) ) { return ; } if ( base == null ) { throw new IllegalArgumentException ( \"Cannot put a value in a null base Map\" ) ; } try { UelUtil . setValue ( base , getExpression ( base ) , value == null ? Object . class : value . getClass ( ) , value ) ; } catch ( Exception e ) { Debug . logError ( \"UEL exception while setting value: \" + e + \", original = \" + this . original , module ) ; } } public T remove ( Map < String , ? extends Object > base ) { if ( this . isEmpty ( ) ) { return null ; } T object = get ( base ) ; if ( object == null ) { return null ; } try { Map < String , Object > writableMap = UtilGenerics . cast ( base ) ; UelUtil . removeValue ( writableMap , getExpression ( base ) ) ; } catch ( Exception e ) { Debug . logError ( \"UEL exception while removing value: \" + e + \", original", "gt": "= \" + this . original , module ) ;", "prediction": "= \" + this . original , module ) ;\n", "label": 0}
{"id": 15660, "input": "<s> package net . claribole . zgrviewer . dot ; public class Spline { Point startingPoint = null ; Point endingPoint = null ; private Point [ ] controls ; public void addControls ( Point point ) { if ( this . controls == null ) { this . controls = new Point [ 1 ] ; this . controls [ 0 ] = point ; } else { Point [ ] tmp = new Point [ this . controls . length + 1 ] ; System . arraycopy ( this . controls , 0 , tmp , 0 , this . controls . length ) ; tmp [ tmp . length - 1 ] = point ; this . controls = tmp ; } } public Point [ ] getControls ( ) { return this . controls ; } public Spline ( ) { } public String toString ( ) { String s = \"\" ; s += printPoint ( \"e\" , this . endingPoint ) ; s += printPoint ( \"s\" , this . startingPoint ) ; s += printControls ( ) ; return s ; } private String printPoint ( String control , Point point ) { String o = \"\" ; if ( point != null ) { for ( int i = 0 ; i < point . coords . length ; i ++ ) { if ( i > 0 && i < point . coords . length ) o += \",\" ; o += point . coords [ i ] ; if ( i == point . coords . length - 1 ) o += ( point . change ? \"\" : \"!\" ) ; } return control + \",\" + o + \" \" ; } return \"\" ; } private String printControls ( ) { String o = \"\" ; for ( int i = 0 ; i < this . controls . length ; i ++ ) { if ( i > 0 && i < this . controls", "gt": ". length ) o += \" \" ;", "prediction": ". length - 1 ) o += \",\" ;\n", "label": 1}
{"id": 446, "input": "<s> import com . sun . source . tree . * ; import com . sun . source . util . * ; import java . io . * ; import java . util . * ; import javax . annotation . processing . * ; import javax . lang . model . * ; import javax . lang . model . element . * ; import javax . lang . model . util . * ; import javax . tools . * ; @ SupportedOptions ( \"scan\" ) @ SupportedAnnotationTypes ( \"*\" ) public class TestDocComments extends AbstractProcessor { enum CompileKind { API , CMD } ; enum ScanKind { TREE , ELEMENT } ; public static void main ( String ... args ) throws Exception { for ( CompileKind ck : CompileKind . values ( ) ) { for ( ScanKind sk : ScanKind . values ( ) ) { try { test ( ck , sk ) ; } catch ( IOException e ) { error ( e . toString ( ) ) ; } } } if ( errors > 0 ) throw new Exception ( errors + \" errors occurred\" ) ; } static void test ( CompileKind ck , ScanKind sk ) throws IOException { String testClasses = System . getProperty ( \"test.classes\" ) ; String testSrc = System . getProperty ( \"test.src\" ) ; File testDir = new File ( \"test.\" + ck + \".\" + sk ) ; testDir . mkdirs ( ) ; String [ ] opts = { \"-d\" , testDir . getPath ( ) , \"-implicit:none\" , \"-processor\" , TestDocComments . class . getName ( ) , \"-processorpath\" , testClasses , \"-Ascan=\" + sk } ; File [ ] files = { new File ( testSrc , \"a/First.java\" ) } ; if ( ck == CompileKind . API ) test_javac_api ( opts , files ) ; else test_javac_cmd ( opts , files ) ; } static void test_javac_api ( String [ ] opts , File [ ] files ) throws IOException { System . err . println ( \"test javac api: \" + Arrays . asList ( opts ) + \" \" + Arrays . asList ( files ) ) ; DiagnosticListener < JavaFileObject > dl = new DiagnosticListener < JavaFileObject > ( ) { public void report ( Diagnostic diagnostic ) { error ( diagnostic . toString ( ) ) ; } } ; JavaCompiler c = ToolProvider . getSystemJavaCompiler ( ) ; StandardJavaFileManager fm = c . getStandardFileManager ( null , null , null ) ; Iterable < ? extends JavaFileObject > units = fm . getJavaFileObjects ( files ) ; JavacTask t = ( JavacTask ) c . getTask ( null , fm , dl , Arrays . asList ( opts ) , null , units ) ; t . parse ( ) ; t . analyze ( ) ; } static void test_javac_cmd ( String [ ] opts , File [ ] files ) { System . err . println ( \"test javac cmd: \" + Arrays . asList ( opts ) + \" \" + Arrays . asList ( files ) ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; List < String > args = new ArrayList < String > ( Arrays . asList ( opts ) ) ; for ( File f : files ) args . add ( f", "gt": ". getPath ( ) ) ;", "prediction": ") ;\n", "label": 0}
{"id": 15666, "input": "<s> package ru . spbstu . telematics . objectCatalog ; import java . io . IOException ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class EditClassServlet extends HttpServlet { ObjectCatalog catalog = new ObjectCatalog ( ) ; @ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { String classId = req . getParameter ( \"classId\" ) ; String className = req . getParameter ( \"className\" ) ; String description = req . getParameter ( \"description\" ) ; boolean flag = false ; if ( className != null && description != null && ! className . equals ( \"\" ) && ! description . equals ( \"\" ) ) { catalog . editClass ( classId , className , description ) ; req . getRequestDispatcher ( \"/class/add_class.jsp\" ) . forward ( req , resp ) ; flag = true ; } else if ( classId != null && ! flag ) { TClass classObj = catalog . getClassObject ( classId ) ; req", "gt": ". setAttribute ( \"classObj\" , classObj ) ;", "prediction": ". getRequestDispatcher ( \"/class/add_class.jsp\" ) . forward ( req , resp ) ;\n", "label": 1}
{"id": 7800, "input": "<s> package org . kares . jruby ; import org . junit . Test ; import static org . junit . Assert . * ; public class WorkerThreadFactoryTest { private static Runnable DUMMY_RUNNABLE = new Runnable ( ) { public void run ( ) { return ; } } ; @ Test public void shouldCreateNewThreadsOnEachNewThreadCall ( ) { WorkerThreadFactory factory = new WorkerThreadFactory ( \"\" , 1 ) ; Runnable dummy = new Runnable ( ) { public void run ( ) { return ; } } ; Thread thread1 = factory . newThread ( dummy ) ; Thread thread2 = factory . newThread ( dummy ) ; Thread thread3 = factory . newThread ( dummy ) ; assertNotNull ( thread1 ) ; assertNotNull ( thread2 ) ; assertNotNull ( thread3 ) ; assertNotSame ( thread1 , thread2 ) ; assertNotSame ( thread2 , thread3 ) ; assertNotSame ( thread3 , thread1 ) ; } @ Test public void shouldCreateNewThreadsWithDifferentNames1 ( ) { WorkerThreadFactory factory = new WorkerThreadFactory ( \"xxx\" , 1 ) ; Runnable dummy = new Runnable ( ) { public void run ( ) { return ; } } ; Thread thread1 = factory . newThread ( dummy ) ; Thread thread2 = factory . newThread ( dummy ) ; Thread thread3 = factory . newThread ( dummy ) ; assertNotNull ( thread1 . getName ( ) ) ; assertNotNull ( thread2 . getName ( ) ) ; assertNotNull ( thread3 . getName ( ) ) ; assertFalse ( thread1 . getName ( ) . equals ( thread2 . getName ( ) ) ) ; assertFalse ( thread2 . getName ( ) . equals ( thread3 . getName ( ) ) ) ; assertFalse ( thread3 . getName ( ) . equals ( thread1 . getName ( ) ) ) ; } @ Test public void shouldCreateNewThreadsWithDifferentNames2 ( ) { WorkerThreadFactory factory = new WorkerThreadFactory ( null , 1 ) ; Runnable dummy = new Runnable ( ) { public void run ( ) { return ; } } ; Thread thread1 = factory . newThread ( dummy ) ; Thread thread2 = factory . newThread ( dummy ) ; Thread thread3 = factory . newThread ( dummy ) ; assertNotNull ( thread1 . getName ( ) ) ; assertNotNull ( thread2 . getName ( ) ) ; assertNotNull ( thread3 . getName ( ) ) ; assertFalse ( thread1 . getName ( ) . equals ( thread2 . getName ( ) ) ) ; assertFalse ( thread2 . getName ( ) . equals ( thread3 . getName ( ) ) ) ; assertFalse ( thread3 . getName ( ) . equals ( thread1 . getName ( ) ) ) ; } @ Test public void newThreadsShouldHaveTheGivenPriority ( ) { WorkerThreadFactory factory = new WorkerThreadFactory ( null , 2 ) ; Thread thread = factory . newThread ( DUMMY_RUNNABLE ) ; assertNotNull ( thread ) ; assertEquals ( 2 , thread", "gt": ". getPriority ( ) ) ;", "prediction": ". getPriority ( ) ) ;\n", "label": 0}
{"id": 15681, "input": "<s> package monbulk . shared . util ; public class MonbulkEnums { public enum ServiceNames { Methods , MetaData , Dictionary , User , } ; public enum viewTypes { DRAGDROP , DOCKABLE", "gt": ", FORM , WIDGET }", "prediction": ", }\n", "label": 1}
{"id": 5174, "input": "<s> package org . jjflyboy . tjpeditor . project ; public interface", "gt": "TaskReport extends Property , ReportAttribute", "prediction": "TestCase extends TestCase\n", "label": 0}
{"id": 15703, "input": "<s> package org . apache . lucene . analysis . tokenattributes ; import org . apache . lucene . util . Attribute ; public interface PositionIncrementAttribute extends Attribute { public", "gt": "void setPositionIncrement ( int positionIncrement ) ;", "prediction": "PositionIncrementAttribute ( )\n", "label": 1}
{"id": 5655, "input": "<s> public class C { class CInner extends example . B { public", "gt": "CInner ( Object o )", "prediction": "CInner ( )\n", "label": 0}
{"id": 15708, "input": "<s> package org . apache . lucene . store . db ; import com . sleepycat . db . EnvironmentConfig ; import com . sleepycat . db . Environment ; public class SanityLoadLibrary { public static void main ( String [ ] ignored ) throws Exception { EnvironmentConfig envConfig = EnvironmentConfig . DEFAULT ; envConfig . setAllowCreate ( false ) ;", "gt": "Environment env = new Environment ( null , envConfig ) ;", "prediction": "}\n", "label": 1}
{"id": 801, "input": "<s> package model ; import java . sql . SQLException ; import java . util . ArrayList ; import dbprocess . DatabaseProcess ; import exceptions . CartException ; public class User { public PaymentInfo paymentInfo ; public String username ; public ArrayList < Book > rentals ; public boolean isAdmin ; public String email ; public Cart cart ; public User ( String username , boolean isAdmin , String email , ArrayList < Book > rentals , PaymentInfo paymentInfo , Cart cart ) { this . username = username ; this . rentals = rentals ; this . paymentInfo = paymentInfo ; this . cart = cart ; this . isAdmin = isAdmin ; this . email = email ; } public String getEmail ( ) { return email ; } public void restoreCart ( ) throws SQLException , CartException { DatabaseProcess gdb = DatabaseProcess . getInstance ( ) ; this . cart = gdb . getUserCart ( this . getUserName ( ) ) ; } public void deleteCart ( ) { this . cart = new Cart ( ) ; } public void setRentals ( ) throws SQLException { this . rentals = DatabaseProcess . getInstance ( ) . getBooksBy ( DatabaseProcess . USERNAME , this . getUserName ( ) ) ; } public ArrayList < Book > getRentals ( ) { return this . rentals ; } public Cart getCart ( ) { return this . cart ; } public String getUserName ( ) { return username ; } public PaymentInfo getPaymentInfo ( ) { return this . paymentInfo ; } public", "gt": "void setPaymentInfo ( ) throws SQLException , CartException", "prediction": "String getEmail ( )\n", "label": 0}
{"id": 15722, "input": "<s> package org . eclipse . ui . internal ; import java . util . ArrayList ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . util . Geometry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IPageLayout ; import org . eclipse . ui . IViewReference ; import org . eclipse . ui . internal . dnd . SwtUtil ; public abstract class PartSashContainer extends LayoutPart implements ILayoutContainer { protected Composite parent ; protected ControlListener resizeListener ; protected LayoutTree root ; private Composite parentWidget ; private LayoutPart zoomedPart ; protected WorkbenchPage page ; boolean active = false ; boolean layoutDirty = false ; protected ArrayList children = new ArrayList ( ) ; protected static class RelationshipInfo { protected LayoutPart part ; protected LayoutPart relative ; protected int relationship ; protected int left ; protected int right ; public float getRatio ( ) { int total = left + right ; if ( total > 0 ) { return ( float ) left / ( float ) total ; } return 0.5f ; } } public PartSashContainer ( String id , final WorkbenchPage page , Composite parentWidget ) { super ( id ) ; this . page = page ; this . parentWidget = parentWidget ; resizeListener = new ControlAdapter ( ) { public void controlResized ( ControlEvent e ) { resizeSashes ( ) ; } } ; } public boolean childObscuredByZoom ( LayoutPart toTest ) { LayoutPart zoomPart = getZoomedPart ( ) ; if ( zoomPart != null && toTest != zoomPart ) { return true ; } return isObscuredByZoom ( ) ; } public void findSashes ( LayoutPart pane , PartPane . Sashes sashes ) { if ( root == null ) { return ; } LayoutTree part = root . find ( pane ) ; if ( part == null ) { return ; } part . findSashes ( sashes ) ; } public void add ( LayoutPart child ) { if ( child == null ) { return ; } addEnhanced ( child , SWT . RIGHT , 0.5f , findBottomRight ( ) ) ; } void addEnhanced ( LayoutPart child , int", "gt": "swtDirectionConstant , float ratioForNewPart , LayoutPart relative )", "prediction": "index )\n", "label": 1}
{"id": 2390, "input": "<s> package org . jboss . arquillian . android ; import org . jboss . arquillian . android . enricher . AndroidDeviceResourceProvider ; import org . jboss . arquillian . android . impl . AndroidBridgeConnector ; import org . jboss . arquillian . android . impl . AndroidDeviceSelector ; import org . jboss . arquillian . android . impl . AndroidExtensionConfigurator ; import org . jboss . arquillian . android . impl . EmulatorShutdown ; import org . jboss . arquillian . android . impl . EmulatorStartup ; import org . jboss . arquillian . core . spi . LoadableExtension ; import org . jboss . arquillian . test . spi . enricher . resource . ResourceProvider ; public class ArquillianAndroidExtension implements LoadableExtension { public void register ( ExtensionBuilder builder ) { builder . service ( ResourceProvider . class , AndroidDeviceResourceProvider . class ) ; builder . observer ( AndroidExtensionConfigurator . class ) ; builder .", "gt": "observer ( AndroidDeviceSelector . class ) ;", "prediction": "service ( EmulatorShutdown . class ) ;\n", "label": 0}
{"id": 15736, "input": "<s> package monbulk . MethodBuilder . client . event ; import com . google . gwt . event . shared . GwtEvent ; public class ChangeWindowEvent extends GwtEvent < ChangeWindowEventHandler > { public static Type < ChangeWindowEventHandler > TYPE = new Type < ChangeWindowEventHandler > ( ) ; private final String id ; private final String Change ; public ChangeWindowEvent ( String id , String Change ) { this . id = id ; this . Change = Change ; } public String getId ( ) { return id ; } public String getChange ( ) { return Change ; } @ Override public Type < ChangeWindowEventHandler > getAssociatedType ( ) { return TYPE ; } @ Override", "gt": "protected void dispatch ( ChangeWindowEventHandler handler )", "prediction": "public Type < ChangeWindowEventHandler > getChangedType ( )\n", "label": 1}
{"id": 688, "input": "<s> package objects ; import java . awt . Image ; import javax . swing . ImageIcon ; import javax . swing . table . DefaultTableCellRenderer ; public class AlbumArtRenderer extends DefaultTableCellRenderer { public AlbumArtRenderer ( ) { super ( ) ; setHorizontalTextPosition ( CENTER ) ; } @ Override public void setValue ( Object value ) { if ( value instanceof Image ) { setIcon ( new ImageIcon ( (", "gt": "( Image ) value ) ) ) ;", "prediction": "Image ) value ) ) ;\n", "label": 0}
{"id": 15737, "input": "<s> package org . nuxeo . ecm . automation . core ; import org . nuxeo . ecm . automation . AutomationService ; import org . nuxeo . ecm . automation . core . events . EventHandler ; import org . nuxeo . ecm . automation . core . events . EventHandlerRegistry ; import org . nuxeo . ecm . automation . core . events . operations . FireEvent ; import org . nuxeo . ecm . automation . core . impl . OperationServiceImpl ; import org . nuxeo . ecm . automation . core . operations . FetchContextBlob ; import org . nuxeo . ecm . automation . core . operations . FetchContextDocument ; import org . nuxeo . ecm . automation . core . operations . LogOperation ; import org . nuxeo . ecm . automation . core . operations . RestoreBlobInput ; import org . nuxeo . ecm . automation . core . operations . RestoreBlobInputFromScript ; import org . nuxeo . ecm . automation . core . operations . RestoreBlobsInput ; import org . nuxeo . ecm . automation . core . operations . RestoreBlobsInputFromScript ; import org . nuxeo . ecm . automation . core . operations . RestoreDocumentInput ; import org . nuxeo . ecm . automation . core . operations . RestoreDocumentInputFromScript ; import org . nuxeo . ecm . automation . core . operations . RestoreDocumentsInput ; import org . nuxeo . ecm . automation . core . operations . RestoreDocumentsInputFromScript ; import org . nuxeo . ecm . automation . core . operations . RunInputScript ; import org . nuxeo . ecm . automation . core . operations . RunScript ; import org . nuxeo . ecm . automation . core . operations . SetInputAsVar ; import org . nuxeo . ecm . automation . core . operations . SetVar ; import org . nuxeo . ecm . automation . core . operations . blob . AttachBlob ; import org . nuxeo . ecm . automation . core . operations . blob . BlobToFile ; import org . nuxeo . ecm . automation . core . operations . blob . BlobToPDF ; import org . nuxeo . ecm . automation . core . operations . blob . CreateBlob ; import org . nuxeo . ecm . automation . core . operations . blob . CreateZip ; import org . nuxeo . ecm . automation . core . operations . blob . GetAllDocumentBlobs ; import org . nuxeo . ecm . automation . core . operations . blob . GetDocumentBlob ; import org . nuxeo . ecm . automation . core . operations . blob . GetDocumentBlobs ; import org . nuxeo . ecm . automation . core . operations . blob . PostBlob ; import org . nuxeo . ecm . automation . core . operations . blob . SetBlobFileName ; import org . nuxeo . ecm . automation . core . operations . document . CheckInDocument ; import org . nuxeo . ecm . automation . core . operations . document . CheckOutDocument ; import org . nuxeo . ecm . automation . core . operations . document . CopyDocument ; import org . nuxeo . ecm . automation . core . operations . document . CreateDocument ; import org . nuxeo . ecm . automation . core . operations . document . CreateVersion ; import org . nuxeo . ecm . automation . core . operations . document . DeleteDocument ; import org . nuxeo . ecm . automation . core . operations . document . FetchByProperty ; import org . nuxeo . ecm . automation . core . operations . document . FetchDocument ; import org . nuxeo . ecm . automation . core . operations . document . FilterDocuments ; import org . nuxeo . ecm . automation . core . operations . document . GetDocumentChild ; import org . nuxeo . ecm . automation . core . operations . document . GetDocumentChildren ; import org . nuxeo . ecm . automation . core . operations . document . GetDocumentParent ; import org . nuxeo . ecm . automation . core . operations . document . LockDocument ; import org . nuxeo . ecm . automation . core . operations . document . MoveDocument ; import org . nuxeo . ecm . automation . core . operations . document . MultiPublishDocument ; import org . nuxeo . ecm . automation . core . operations . document . PublishDocument ; import org . nuxeo . ecm . automation . core . operations . document . Query ; import org . nuxeo . ecm . automation . core . operations . document . ReloadDocument ; import org . nuxeo . ecm . automation . core . operations . document . RemoveDocumentACL ; import org . nuxeo . ecm . automation . core . operations . document . RemoveDocumentBlob ; import org . nuxeo . ecm . automation . core . operations . document . RemoveProperty ; import org . nuxeo . ecm . automation . core . operations . document . SaveDocument ; import org . nuxeo . ecm . automation . core . operations . document . SetDocumentACE ; import org . nuxeo . ecm . automation . core . operations . document . SetDocumentBlob ; import org . nuxeo . ecm . automation . core . operations . document . SetDocumentLifeCycle ; import org . nuxeo . ecm . automation . core .", "gt": "operations . document . SetDocumentProperty ;", "prediction": "operations . document . SaveDocument ;\n", "label": 1}
{"id": 7095, "input": "<s> package org . ofbiz . product . category ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import javax . servlet . FilterChain ; import javax . servlet . RequestDispatcher ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . ServletRequest ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javolution . util . FastList ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . StringUtil . StringWrapper ; import org . ofbiz . common . UrlServletHelper ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . product . product . ProductContentWrapper ; import org . ofbiz . webapp . control . ContextFilter ; public class CatalogUrlFilter extends ContextFilter { public final static String module = CatalogUrlFilter . class . getName ( ) ; public static final String CONTROL_MOUNT_POINT = \"control\" ; public static final String PRODUCT_REQUEST = \"product\" ; public static final String CATEGORY_REQUEST = \"category\" ; protected static String defaultLocaleString = null ; protected static String redirectUrl = null ; @ Override public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { HttpServletRequest httpRequest = ( HttpServletRequest ) request ; HttpServletResponse httpResponse = ( HttpServletResponse ) response ; Delegator delegator = ( Delegator ) httpRequest . getSession ( ) . getServletContext ( ) . getAttribute ( \"delegator\" ) ; ServletContext servletContext = config . getServletContext ( ) ; UrlServletHelper . setRequestAttributes ( request , delegator , servletContext ) ; String initDefaultLocalesString = config . getInitParameter ( \"defaultLocaleString\" ) ; String initRedirectUrl = config . getInitParameter ( \"redirectUrl\" ) ; defaultLocaleString = UtilValidate . isNotEmpty ( initDefaultLocalesString ) ? initDefaultLocalesString : \"\" ; redirectUrl = UtilValidate . isNotEmpty ( initRedirectUrl ) ? initRedirectUrl : \"\" ; String pathInfo = httpRequest . getServletPath ( ) ; if ( UtilValidate . isNotEmpty ( pathInfo ) ) { List < String > pathElements = StringUtil . split ( pathInfo , \"/\" ) ; String alternativeUrl = pathElements . get ( 0 ) ; String productId = null ; String productCategoryId = null ; String urlContentId = null ; try { if ( alternativeUrl . endsWith ( \"-p\" ) ) { List < EntityCondition > productContentConds = FastList . newInstance ( ) ; productContentConds . add ( EntityCondition . makeCondition ( \"productContentTypeId\" , \"ALTERNATIVE_URL\" ) ) ; productContentConds . add ( EntityUtil . getFilterByDateExpr ( ) ) ; List < GenericValue > productContentInfos = delegator . findList ( \"ProductContentAndInfo\" , EntityCondition . makeCondition ( productContentConds ) , null , UtilMisc . toList ( \"-fromDate\" ) , null , true ) ; if ( UtilValidate . isNotEmpty ( productContentInfos ) ) { for ( GenericValue productContentInfo : productContentInfos ) { String contentId = ( String ) productContentInfo . get ( \"contentId\" ) ; List < GenericValue > ContentAssocDataResourceViewTos = delegator . findByAnd ( \"ContentAssocDataResourceViewTo\" , UtilMisc . toMap ( \"contentIdStart\" , contentId , \"caContentAssocTypeId\" , \"ALTERNATE_LOCALE\" , \"drDataResourceTypeId\" , \"ELECTRONIC_TEXT\" ) , null , true ) ; if ( UtilValidate . isNotEmpty ( ContentAssocDataResourceViewTos ) ) { for ( GenericValue ContentAssocDataResourceViewTo : ContentAssocDataResourceViewTos ) { GenericValue ElectronicText = ContentAssocDataResourceViewTo . getRelatedOne ( \"ElectronicText\" , true ) ; if ( UtilValidate . isNotEmpty ( ElectronicText ) ) { String textData = ( String ) ElectronicText . get ( \"textData\" ) ; textData = UrlServletHelper . invalidCharacter ( textData ) ; if ( alternativeUrl . matches ( textData + \".+$\" ) ) { String productIdStr = null ; productIdStr = alternativeUrl . replace ( textData + \"-\" , \"\" ) ; productIdStr = productIdStr . replace ( \"-p\" , \"\" ) ; String checkProductId = ( String ) productContentInfo . get ( \"productId\" ) ; if ( productIdStr . equalsIgnoreCase ( checkProductId ) ) { productId = checkProductId ; break ; } } } } } if ( UtilValidate . isEmpty ( productId ) ) { List < GenericValue > contentDataResourceViews = delegator . findByAnd ( \"ContentDataResourceView\" , UtilMisc . toMap ( \"contentId\" , contentId , \"drDataResourceTypeId\" , \"ELECTRONIC_TEXT\" ) , null , true ) ; for ( GenericValue contentDataResourceView : contentDataResourceViews ) { GenericValue ElectronicText = contentDataResourceView . getRelatedOne ( \"ElectronicText\" , true ) ; if ( UtilValidate . isNotEmpty ( ElectronicText ) ) { String textData = ( String ) ElectronicText . get ( \"textData\" ) ; if ( UtilValidate . isNotEmpty ( textData ) ) { textData = UrlServletHelper . invalidCharacter ( textData ) ; if ( alternativeUrl . matches ( textData + \".+$\" ) ) { String productIdStr = null ; productIdStr = alternativeUrl . replace ( textData + \"-\" , \"\" ) ; productIdStr = productIdStr . replace ( \"-p\" , \"\" ) ; String checkProductId = ( String ) productContentInfo . get ( \"productId\" ) ;", "gt": "if ( productIdStr . equalsIgnoreCase ( checkProductId ) )", "prediction": "if ( productIdStr . equalsIgnoreCase ( checkProductId ) )\n", "label": 0}
{"id": 15746, "input": "<s> package org . whiskcraft . ScheduledAnnouncer ; import java . io . File ; import java . util . List ; import java . util . logging . Logger ; import org . bukkit . plugin . java . JavaPlugin ; import org . bukkit . scheduler . BukkitScheduler ; public class AnnouncerPlugin extends JavaPlugin { private AUCore core ; protected List < String > announcementMessages ; protected String announcementPrefix ; protected long announcementInterval ; protected boolean enabled ; protected boolean random ; private AnnouncerThread announcerThread ; private Logger logger ; public AnnouncerPlugin ( ) { super ( ) ; announcerThread = new AnnouncerThread ( this ) ; } public void onEnable ( ) { logger = getServer ( ) . getLogger ( ) ; public void onEnable ( ) { core = new AUCore ( \"http://wiskr.net/scheduledannouncer/updates/index.html\" , log , \"[ScheduledAnnouncerAutoUpdater]\" ) ; } if ( ! new File ( getDataFolder ( ) , \"config.yml\" ) . exists ( ) ) { saveDefaultConfig ( ) ; } reloadConfiguration ( ) ; BukkitScheduler scheduler = getServer ( ) . getScheduler ( ) ; scheduler . scheduleSyncRepeatingTask ( this , announcerThread , announcementInterval * 20 , announcementInterval * 20 ) ; AnnouncerCommandExecutor announcerCommandExecutor = new AnnouncerCommandExecutor ( this ) ; getCommand ( \"announce\" ) . setExecutor ( announcerCommandExecutor ) ; getCommand ( \"announcer\" ) . setExecutor ( announcerCommandExecutor ) ; logger . info ( String . format ( \"%s is enabled!\\n\" , getDescription ( ) . getFullName ( ) ) ) ; } public void onDisable ( ) { logger . info ( String . format ( \"%s is disabled!\\n\" , getDescription ( ) . getFullName ( ) ) ) ; } public void announce ( ) { announcerThread . run ( ) ; } public void announce ( int index ) { announce ( announcementMessages . get ( index - 1 ) ) ; } public void announce ( String line ) { String [ ] messages = line . split ( \"&n\" ) ; for ( String message : messages ) { if ( message . startsWith ( \"/\" ) ) { getServer ( ) . dispatchCommand ( getServer ( ) . getConsoleSender ( ) , message . substring ( 1 ) ) ; } else if ( getServer ( ) . getOnlinePlayers ( ) . length > 0 ) { String messageToSend = ChatColorHelper . replaceColorCodes ( String . format ( \"%s%s\" , announcementPrefix , message ) ) ; getServer ( ) . broadcast ( messageToSend , AnnouncerPermissions . RECEIVER ) ; } } } public void saveConfiguration ( ) { getConfig ( ) . set ( \"announcement.messages\" , announcementMessages ) ; getConfig ( ) . set ( \"announcement.interval\" , announcementInterval ) ; getConfig ( ) . set ( \"announcement.prefix\" , announcementPrefix ) ; getConfig ( ) . set ( \"announcement.enabled\" , enabled ) ; getConfig ( ) . set ( \"announcement.random\" , random ) ; saveConfig ( ) ; } public void reloadConfiguration ( ) { reloadConfig ( ) ; announcementPrefix = getConfig ( ) . getString ( \"announcement.prefix\" , \"&c[Announcement] \" ) ; announcementMessages = getConfig ( ) . getStringList ( \"announcement.messages\" ) ; announcementInterval = getConfig ( ) . getInt ( \"announcement.interval\" , 1000 ) ; enabled = getConfig ( ) . getBoolean ( \"announcement.enabled\" , true ) ; random = getConfig ( ) . getBoolean ( \"announcement.random\" , false ) ; } public String getAnnouncementPrefix ( ) { return announcementPrefix ; } public void setAnnouncementPrefix ( String announcementPrefix ) { this . announcementPrefix = announcementPrefix ; saveConfig ( ) ; } public long getAnnouncementInterval ( ) { return announcementInterval ; } public void setAnnouncementInterval ( long announcementInterval ) { this . announcementInterval = announcementInterval ; saveConfiguration ( ) ; BukkitScheduler scheduler = getServer ( ) . getScheduler ( ) ; scheduler . cancelTasks ( this ) ; scheduler . scheduleSyncRepeatingTask ( this , announcerThread , announcementInterval * 20 , announcementInterval * 20 ) ; } public void addAnnouncement ( String message ) { announcementMessages . add ( message ) ; saveConfiguration ( ) ; } public String getAnnouncement ( int index ) { return announcementMessages . get ( index - 1 ) ; } public int numberOfAnnouncements ( ) { return announcementMessages . size ( ) ; } public void removeAnnouncements ( ) { announcementMessages . clear ( ) ; saveConfiguration ( ) ; } public void removeAnnouncement ( int index ) { announcementMessages . remove ( index - 1 ) ; saveConfiguration ( ) ; } public boolean isAnnouncerEnabled ( ) { return enabled ; } public void setAnnouncerEnabled ( boolean enabled ) { this . enabled = enabled ; saveConfiguration ( ) ; } public boolean isRandom ( ) { return random ; } public void", "gt": "setRandom ( boolean random )", "prediction": "setRandom ( boolean random )\n", "label": 1}
{"id": 8357, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . JournalMode ; import org . jjflyboy . tjpeditor . project . JournalModeValue ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class JournalModeImpl extends ReportAttributeImpl implements JournalMode { protected static final JournalModeValue MODE_EDEFAULT = JournalModeValue . JOURNAL ; protected JournalModeValue mode = MODE_EDEFAULT ; protected JournalModeImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getJournalMode ( ) ; } public JournalModeValue getMode ( ) { return mode ; } public void setMode ( JournalModeValue newMode ) { JournalModeValue oldMode = mode ; mode = newMode == null ? MODE_EDEFAULT : newMode ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . JOURNAL_MODE__MODE , oldMode , mode ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . JOURNAL_MODE__MODE : return getMode ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . JOURNAL_MODE__MODE : setMode ( ( JournalModeValue ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @ Override public void eUnset ( int featureID ) { switch ( featureID ) {", "gt": "case ProjectPackage . JOURNAL_MODE__MODE : setMode ( MODE_EDEFAULT ) ;", "prediction": "case ProjectPackage . JOURNAL_MODE__MODE : unsetMode ( ( JournalModeValue ) newValue ) ;\n", "label": 0}
{"id": 15754, "input": "<s> package org . apache . lucene . index ; abstract class InvertedDocEndConsumerPerThread { abstract void startDocument ( ) ; abstract InvertedDocEndConsumerPerField addField ( DocInverterPerField docInverterPerField , FieldInfo fieldInfo ) ; abstract", "gt": "void finishDocument ( ) ;", "prediction": "void endDocument ( ) ;\n", "label": 1}
{"id": 1401, "input": "<s> package com . deliciousdroid . widgets ; import android . content . Context ; import android . util . AttributeSet ; import android . widget . AutoCompleteTextView ; public class MultiWordAutoCompleteView extends AutoCompleteTextView { private static final String DEFAULT_SEPARATOR = \" \" ; private String mSeparator = DEFAULT_SEPARATOR ; public MultiWordAutoCompleteView ( Context context ) { super ( context ) ; } public MultiWordAutoCompleteView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; } public MultiWordAutoCompleteView ( Context context , AttributeSet attrs , int defStyle ) { super ( context , attrs , defStyle ) ; } public String getSeparator ( ) { return mSeparator ; } public void setSeparator ( String separator ) { mSeparator = separator ; } @ Override protected void performFiltering ( CharSequence text , int keyCode ) { String newText = text . toString ( ) ; if ( newText . indexOf ( mSeparator ) != - 1 ) { int lastIndex = newText . lastIndexOf ( mSeparator ) ; if ( lastIndex != newText . length ( ) - 1 ) { newText = newText . substring ( lastIndex + 1 ) . trim ( ) ; if", "gt": "( newText . length ( ) >= getThreshold ( ) )", "prediction": "( lastIndex != null )\n", "label": 0}
{"id": 15757, "input": "<s> package org . eclipse . jface . viewers ; import java . io . Serializable ; import org . eclipse . jface . util . Policy ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Widget ; public abstract class ViewerRow implements Cloneable , Serializable { public static final int ABOVE = 1 ; public static final int BELOW = 2 ; private static final String KEY_TEXT_LAYOUT = Policy . JFACE + \"styled_label_key_\" ; private static final String KEY_TEXT_LAYOUT_0 = Policy . JFACE + \"styled_label_key_0\" ; private static String [ ] cachedDataKeys ; public abstract Rectangle getBounds ( int columnIndex ) ; public abstract Rectangle getBounds ( ) ; public abstract Widget getItem ( ) ; public abstract int getColumnCount ( ) ; public abstract Image getImage ( int columnIndex ) ; public abstract void setImage ( int columnIndex , Image image ) ; public abstract String getText ( int columnIndex ) ; public abstract void setText ( int columnIndex , String text ) ; public abstract Color getBackground ( int columnIndex ) ; public abstract void setBackground ( int columnIndex , Color color ) ; public abstract Color getForeground ( int columnIndex ) ; public abstract void setForeground ( int columnIndex , Color color ) ; public abstract Font getFont ( int columnIndex ) ; public abstract void setFont ( int columnIndex , Font font ) ; public ViewerCell getCell ( Point point ) { int index = getColumnIndex ( point ) ; return getCell ( index ) ; } public int getColumnIndex ( Point point ) { int count = getColumnCount ( ) ; if ( count == 0 ) { return 0 ; } for ( int i = 0 ; i < count ; i ++ ) { if ( getBounds ( i ) . contains ( point ) ) { return i ; } } return - 1 ; } public ViewerCell getCell ( int column ) { if ( column >= 0 ) return new ViewerCell ( ( ViewerRow ) clone ( ) , column , getElement ( ) ) ; return null ; } public abstract Control getControl ( ) ; public abstract ViewerRow getNeighbor ( int direction , boolean sameLevel ) ; public abstract TreePath getTreePath ( ) ; public abstract Object clone ( ) ; public abstract Object getElement ( ) ; public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( getItem ( ) == null ) ? 0 : getItem ( ) . hashCode ( ) ) ; return result ; } public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; final ViewerRow other = ( ViewerRow ) obj ; if ( getItem ( ) == null ) { if ( other . getItem ( ) != null ) return false ; } else if ( ! getItem ( ) . equals ( other . getItem ( ) ) ) return false ; return true ; } ViewerCell getCellAtVisualIndex ( int visualIndex ) { return getCell ( getCreationIndex ( visualIndex ) ) ; } protected int getVisualIndex ( int creationIndex ) { return creationIndex ; } protected int getCreationIndex ( int visualIndex ) { return visualIndex ; } public Rectangle getTextBounds ( int index ) { return null ; } public Rectangle getImageBounds ( int index ) { return null ; }", "gt": "int getWidth ( int columnIndex )", "prediction": "public Rectangle getForegroundBounds ( int index )\n", "label": 1}
{"id": 583, "input": "<s> package ar . com . fdvs . dj . domain . entities . conditionalStyle ; import ar . com . fdvs . dj . domain . DJBaseElement ; import ar . com . fdvs . dj . domain . Style ; import ar . com . fdvs . dj . domain . entities . Entity ; public class ConditionalStyle extends DJBaseElement { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private ConditionStyleExpression condition ; private Style style ; private String name ; public ConditionalStyle ( ConditionStyleExpression condition , Style style ) {", "gt": "this . condition = condition ;", "prediction": "this . condition = condition ;\n", "label": 0}
{"id": 15765, "input": "<s> package com . emf4sw . rdf . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . eclipse . emf . ecore . util . EcoreUtil ; import com . emf4sw . rdf . Datatype ; import com . emf4sw . rdf . Literal ; import com . emf4sw . rdf . RDFGraph ; import com . emf4sw . rdf . RDFPackage ; public class LiteralImpl extends NodeImpl implements Literal { protected static final String LEXICAL_FORM_EDEFAULT = null ; protected String lexicalForm = LEXICAL_FORM_EDEFAULT ; protected static final String LANG_EDEFAULT = null ; protected String lang = LANG_EDEFAULT ; protected Datatype datatype ; protected LiteralImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return RDFPackage . Literals . LITERAL ; } public String getLexicalForm ( ) { return lexicalForm ; } public void setLexicalForm ( String newLexicalForm ) { String oldLexicalForm = lexicalForm ; lexicalForm = newLexicalForm ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LEXICAL_FORM , oldLexicalForm , lexicalForm ) ) ; } public String getLang ( ) { return lang ; } public void setLang ( String newLang ) { String oldLang = lang ; lang = newLang ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , RDFPackage . LITERAL__LANG , oldLang , lang ) ) ; } public Datatype getDatatype ( ) { if ( datatype != null && datatype . eIsProxy ( ) ) { InternalEObject oldDatatype = ( InternalEObject ) datatype ; datatype = ( Datatype ) eResolveProxy ( oldDatatype ) ; if ( datatype != oldDatatype ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ; } } return datatype ; } public Datatype basicGetDatatype ( ) { return datatype ; } public void setDatatype ( Datatype newDatatype ) { Datatype oldDatatype = datatype ; datatype = newDatatype ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET ,", "gt": "RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ;", "prediction": "RDFPackage . LITERAL__DATATYPE , oldDatatype , datatype ) ) ;\n", "label": 1}
{"id": 2062, "input": "<s> package com . shopzilla . api . client . model ; import com . shopzilla . services . catalog . CategoriesType ; import com . shopzilla . services . catalog . CategoryType ; import com . shopzilla . services . catalog . TaxonomyResponse ; import org . apache . commons . collections . CollectionUtils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class CategoryModelAdapter { protected CategoryModelAdapter ( ) { } public static List < Category > fromCatalogAPI ( TaxonomyResponse response ) { if ( response == null || response . getTaxonomy ( ) == null ) { return null ; } return convertChildren ( response . getTaxonomy ( ) . getCategories ( ) ) ; } private static List < Category > convertChildren ( CategoriesType children ) { if ( children == null || CollectionUtils . isEmpty ( children . getCategory ( ) ) ) { return Collections . emptyList ( ) ; } List < Category > toReturn = new ArrayList < Category > ( ) ; for ( CategoryType child : children . getCategory ( ) ) { toReturn . add ( convertCategory ( child ) ) ; } return toReturn ; } private static Category convertCategory ( CategoryType categoryType ) { Category category =", "gt": "new Category ( ) ;", "prediction": "new Category ( categoryType ) ;\n", "label": 0}
{"id": 15802, "input": "<s> package litil ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; public class AppTest extends TestCase { public AppTest ( String testName ) { super ( testName ) ; }", "gt": "public static Test suite ( )", "prediction": "}\n", "label": 1}
{"id": 3833, "input": "<s> package org . xbill . DNS ; import java . io . * ; import java . net . * ; import java . util . * ; public class ZoneTransferIn { private static final int INITIALSOA = 0 ; private static final int FIRSTDATA = 1 ; private static final int IXFR_DELSOA = 2 ; private static final int IXFR_DEL = 3 ; private static final int IXFR_ADDSOA = 4 ; private static final int IXFR_ADD = 5 ; private static final int AXFR = 6 ; private static final int END = 7 ; private Name zname ; private int qtype ; private int dclass ; private long ixfr_serial ; private boolean want_fallback ; private ZoneTransferHandler handler ; private SocketAddress localAddress ; private SocketAddress address ; private TCPClient client ; private TSIG tsig ; private TSIG . StreamVerifier verifier ; private long timeout = 900 * 1000 ; private int state ; private long end_serial ; private long current_serial ; private Record initialsoa ; private int rtype ; public static class Delta { public long start ; public long end ; public List adds ; public List deletes ; private Delta ( ) { adds = new ArrayList ( ) ; deletes = new ArrayList ( ) ; } } public static interface ZoneTransferHandler { public void startAXFR ( ) throws ZoneTransferException ; public void startIXFR ( ) throws ZoneTransferException ; public void startIXFRDeletes ( Record soa ) throws ZoneTransferException ; public void startIXFRAdds ( Record soa ) throws ZoneTransferException ; public void handleRecord ( Record r ) throws ZoneTransferException ; } ; private static class BasicHandler implements ZoneTransferHandler { private List axfr ; private List ixfr ; public void startAXFR ( ) { axfr = new ArrayList ( ) ; } public void startIXFR ( ) { ixfr = new ArrayList ( ) ; } public void startIXFRDeletes ( Record soa ) { Delta delta = new Delta ( ) ; delta . deletes . add ( soa ) ; delta . start = getSOASerial ( soa ) ; ixfr . add ( delta ) ; } public void startIXFRAdds ( Record soa ) { Delta delta = ( Delta ) ixfr . get ( ixfr . size ( ) - 1 ) ; delta . adds . add ( soa ) ; delta . end = getSOASerial ( soa ) ; } public void handleRecord ( Record r ) { List list ; if ( ixfr != null ) { Delta delta = ( Delta ) ixfr . get ( ixfr . size ( ) - 1 ) ; if ( delta . adds . size ( ) > 0 ) list = delta . adds ; else list = delta . deletes ; } else list = axfr ; list . add ( r ) ; } } ; private ZoneTransferIn ( ) { } private ZoneTransferIn ( Name zone , int xfrtype , long serial , boolean fallback , SocketAddress address , TSIG key ) { this . address = address ; this . tsig = key ; if ( zone . isAbsolute ( ) ) zname = zone ; else { try { zname = Name . concatenate ( zone , Name . root ) ; } catch ( NameTooLongException e ) { throw new IllegalArgumentException ( \"ZoneTransferIn: \" + \"name too long\" ) ; } } qtype = xfrtype ; dclass = DClass . IN ; ixfr_serial = serial ; want_fallback = fallback ; state = INITIALSOA ; } public static ZoneTransferIn newAXFR ( Name zone , SocketAddress address , TSIG key ) { return new ZoneTransferIn ( zone , Type . AXFR , 0 , false , address , key ) ; } public static ZoneTransferIn newAXFR ( Name zone , String host , int port , TSIG key ) throws UnknownHostException { if ( port == 0 ) port = SimpleResolver . DEFAULT_PORT ; return newAXFR ( zone , new InetSocketAddress ( host , port ) , key ) ; } public static ZoneTransferIn newAXFR ( Name zone , String host , TSIG key ) throws UnknownHostException { return newAXFR ( zone , host , 0 , key ) ; } public static ZoneTransferIn newIXFR ( Name zone , long serial , boolean fallback , SocketAddress address , TSIG key ) { return new ZoneTransferIn ( zone , Type . IXFR , serial , fallback , address , key ) ; } public static ZoneTransferIn newIXFR ( Name zone , long serial , boolean fallback , String host , int port , TSIG key ) throws UnknownHostException { if ( port == 0 ) port = SimpleResolver . DEFAULT_PORT ; return newIXFR ( zone , serial , fallback , new InetSocketAddress ( host , port ) , key ) ; } public static ZoneTransferIn newIXFR ( Name zone , long serial , boolean fallback , String host , TSIG key ) throws UnknownHostException { return newIXFR ( zone , serial , fallback , host , 0 , key ) ; } public Name getName ( ) { return zname ; } public int getType ( ) { return qtype ; } public void setTimeout ( int secs ) { if ( secs < 0 ) throw new IllegalArgumentException ( \"timeout cannot be \" + \"negative\" ) ; timeout = 1000L * secs ; } public void setDClass ( int dclass ) { DClass . check ( dclass ) ; this . dclass = dclass ; } public void setLocalAddress ( SocketAddress addr ) { this . localAddress = addr ; } private void openConnection ( ) throws IOException { long endTime = System . currentTimeMillis ( ) + timeout ; client = new TCPClient ( endTime ) ; if ( localAddress != null ) client . bind ( localAddress ) ; client . connect ( address ) ; } private void sendQuery ( ) throws IOException { Record question = Record . newRecord ( zname , qtype , dclass ) ; Message query = new Message ( ) ; query . getHeader ( ) . setOpcode ( Opcode . QUERY ) ; query . addRecord ( question , Section . QUESTION ) ; if ( qtype == Type . IXFR ) { Record soa = new SOARecord ( zname , dclass , 0 , Name . root , Name . root , ixfr_serial , 0 , 0 , 0 , 0 ) ; query . addRecord ( soa , Section . AUTHORITY ) ; } if ( tsig != null ) { tsig . apply ( query , null ) ; verifier = new TSIG . StreamVerifier (", "gt": "tsig , query . getTSIG ( ) ) ;", "prediction": "query ) ;\n", "label": 0}
{"id": 15812, "input": "<s> package monbulk . shared . Services ; import com . google . gwt . core . client . GWT ; import monbulk . shared . util . MonbulkEnums . * ; public abstract class UserService implements iService { public static UserService get ( ) { try { UserService service = ( UserService ) ServiceRegistry . getService ( ServiceNames . User ) ; return service ; } catch ( ServiceRegistry . ServiceNotFoundException e ) { GWT . log ( e . toString ( ) ) ; } return null ; } public interface GetUserHandler { public void onGetUser ( User user ) ; } public abstract void getUser ( String name , String domain , GetUserHandler handler ) ;", "gt": "public final ServiceNames getServiceType ( )", "prediction": "}\n", "label": 1}
{"id": 9768, "input": "<s> import com . sun . tools . javac . file . JavacFileManager ; public class TestName { public static void main ( String ... args ) { final boolean PACKAGE = true ; final boolean CLASS = true ; JavacFileManager . testName ( \"\" , PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \".\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \"java.lang.\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \".java.lang.\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \".java.lang\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \"java.lang\" , PACKAGE , CLASS ) ; JavacFileManager . testName ( \"java.lang.Foo Bar\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \"java.lang.Foo+Bar\" , ! PACKAGE , ! CLASS ) ; JavacFileManager . testName ( \"java.lang.Foo$Bar\" , PACKAGE , CLASS ) ; JavacFileManager", "gt": ". testName ( \"Peter.von.der.Ah\u00e9\" , PACKAGE , CLASS ) ;", "prediction": ". testName ( \"java.lang\" , PACKAGE , ! CLASS ) ;\n", "label": 0}
{"id": 15844, "input": "<s> package knowevo . myvizster . render ; import knowevo . myvizster . DecoratorItem ; import knowevo . myvizster . Vizster ; import edu . berkeley . guir . prefuse . AggregateItem ; import edu . berkeley . guir . prefuse . Display ; import edu . berkeley . guir . prefuse . EdgeItem ; import edu . berkeley . guir . prefuse . NodeItem ; import edu . berkeley . guir . prefuse . VisualItem ; import edu . berkeley . guir . prefuse . render . ImageFactory ; import edu . berkeley . guir . prefuse . render . PolygonRenderer ; import edu . berkeley . guir . prefuse . render . Renderer ; import edu . berkeley . guir . prefuse . render . RendererFactory ; import edu . berkeley . guir . prefuse . render . ShapeRenderer ; public class VizsterRendererFactory implements RendererFactory { private double scaleThreshold = 2 ; private Vizster vizster ; private Display display ; private VizsterImageRenderer imageRenderer ; private VizsterImageRenderer imageRenderer2 ; private VizsterImageRenderer compareRenderer ; private Renderer edgeRenderer ; private PolygonRenderer polyRenderer ; private AuraRenderer auraRenderer ; public VizsterRendererFactory ( Vizster vizster ) { this . vizster = vizster ; this . display = vizster . getDisplay ( ) ; imageRenderer2 = new VizsterImageRenderer ( ) ; imageRenderer2 . setMaxImageDimensions ( 150 , 150 ) ; imageRenderer2 . setImageSize ( 0.2 ) ; imageRenderer2 . setHorizontalPadding ( 2 ) ; imageRenderer = new VizsterImageRenderer ( ) ; ImageFactory bw1 = imageRenderer . getBlackAndWhiteImageFactory ( ) ; ImageFactory if2 = imageRenderer2 . getImageFactory ( ) ; ImageFactory bw2 = imageRenderer2 . getBlackAndWhiteImageFactory ( ) ; imageRenderer . setImageFactory ( new SharingImageFactory ( if2 , bw1 , bw2 ) ) ; imageRenderer . setMaxImageDimensions ( 30 , 30 ) ; imageRenderer . setHorizontalPadding ( 2 ) ; compareRenderer = new VizsterImageRenderer ( ) { public int getRenderType ( VisualItem item ) { int rt = super . getRenderType ( item ) ; if ( rt == RENDER_TYPE_NONE || rt == RENDER_TYPE_DRAW ) { rt = RENDER_TYPE_FILL ; } return rt ; } } ; compareRenderer . setDrawImages ( false ) ; compareRenderer . setRoundedCorner ( 8 , 8 ) ; compareRenderer . setHorizontalPadding ( 2 ) ; edgeRenderer = new VizsterEdgeRenderer ( ) ; polyRenderer = new PolygonRenderer ( PolygonRenderer . EDGE_CURVE ) ; auraRenderer = new AuraRenderer ( vizster ) ; } public void setScaleThreshold ( double scale ) { scaleThreshold = scale ; } public Renderer getRenderer ( VisualItem item ) { if ( item instanceof DecoratorItem ) { return auraRenderer ; } else if ( item instanceof AggregateItem ) { if ( vizster . isXRayMode ( ) ) { polyRenderer . setRenderType ( ShapeRenderer . RENDER_TYPE_DRAW ) ; } else { polyRenderer . setRenderType ( ShapeRenderer . RENDER_TYPE_DRAW_AND_FILL ) ; } return polyRenderer ; } else if ( item instanceof EdgeItem ) { return edgeRenderer ; } else if ( item instanceof NodeItem ) { if ( vizster . isXRayMode ( ) ) { return compareRenderer ; } else { double scale = display . getScale ( ) ; if ( scale >= scaleThreshold ) { return imageRenderer2 ; } else { return imageRenderer ; } } } else { return null ; } }", "gt": "public void setDrawImages ( boolean s )", "prediction": "}\n", "label": 1}
{"id": 4863, "input": "<s> package ar . com . fdvs . dj . domain . entities . columns ; import ar . com . fdvs . dj . domain . ColumnProperty ; import ar . com . fdvs . dj . domain . CustomExpression ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . entities . Entity ; public abstract class PropertyColumn extends AbstractColumn { private static final long serialVersionUID = Entity . SERIAL_VERSION_UID ; private ColumnProperty columnProperty ; private CustomExpression expressionToGroupBy ; private String fieldDescription ; public String getFieldDescription ( ) { return fieldDescription ; } public void setFieldDescription ( String fieldDescription ) { this . fieldDescription = fieldDescription ; } public ColumnProperty getColumnProperty ( ) { return columnProperty ; } public void setColumnProperty ( ColumnProperty columnProperty ) { this . columnProperty = columnProperty ; } public CustomExpression getExpressionToGroupBy ( ) { return expressionToGroupBy ; } public void setExpressionToGroupBy ( CustomExpression expressionToGroupBy ) { this . expressionToGroupBy = expressionToGroupBy ; } public String getGroupVariableName ( String type , String columnToGroupByProperty ) { return \"variable-\" + type + \"_\" + columnToGroupByProperty + \"_\" + getColumnProperty ( ) . getProperty ( ) ; } public String getVariableClassName ( DJCalculation op ) { if ( op == DJCalculation . COUNT || op == DJCalculation . DISTINCT_COUNT ) return Long . class . getName ( ) ; else return getColumnProperty ( ) . getValueClassName ( ) ; } public String getInitialExpression ( DJCalculation op ) { if ( op == DJCalculation . COUNT || op == DJCalculation . DISTINCT_COUNT ) return \"new java.lang.Long(\\\"0\\\")\" ; else if ( op == DJCalculation . SUM ) return \"new \" +", "gt": "getColumnProperty ( ) . getValueClassName ( ) + \"(\\\"0\\\")\" ;", "prediction": "getInitialExpression ( ) ;\n", "label": 0}
{"id": 15849, "input": "<s> package org . nuxeo . ecm . platform . tag . sql ; import java . io . Serializable ; import org . hibernate . dialect . Dialect ; public class Column implements Serializable { private static final long serialVersionUID = 1L ; private final String name ; private final int sqlType ; private boolean primary ; private boolean nullable = true ; private String defaultValue ; private int length = 255 ; private int precision = 19 ; private int scale = 2 ; public Column ( String name , int sqlType ) { if ( name == null ) { throw new IllegalArgumentException ( \"name cannot be null\" ) ; } this . sqlType = sqlType ; this . name = name ; } public String getName ( ) { return name ; } public String getQuotedName ( Dialect dialect ) { return dialect . openQuote ( ) + name + dialect . closeQuote ( ) ; } public int getSqlType ( ) { return sqlType ; } public void setPrimary ( boolean primary ) { this . primary = primary ; } public boolean isPrimary ( ) { return primary ; } public void setNullable ( boolean nullable ) { this . nullable = nullable ; } public boolean isNullable ( ) { return nullable ; } public String getDefaultValue ( ) { return defaultValue ; } public void setDefaultValue ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getSqlTypeString ( Dialect dialect ) { return dialect . getTypeName ( sqlType , length , precision , scale ) ; } @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) +", "gt": "'(' + name + ')' ;", "prediction": "getDefaultValue ( ) ;\n", "label": 1}
{"id": 3221, "input": "<s> public class InterfaceCast1 { public static void main ( String [ ] args ) throws Exception { } } interface Collection < E > { < T > T [ ] toArray ( T [ ] a ) ; } interface Set < E > extends Collection < E > { < T > T [ ] toArray ( T [ ] a ) ; } interface SortedSet", "gt": "< E > extends Set < E >", "prediction": "< E > extends Set < E >\n", "label": 0}
{"id": 15862, "input": "<s> package org . nuxeo . ecm . platform . rendering ; import java . io . InputStream ; import java . io . Serializable ; import org . nuxeo . runtime . model . Adaptable ; public interface", "gt": "RenderingResult extends Adaptable , Serializable", "prediction": "Adaptable\n", "label": 1}
{"id": 8441, "input": "<s> package org . msl . simple . gmfmap . simplemappings . diagram . edit . commands ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . emf . ecore . EObject ; import org . eclipse . gmf . runtime . common . core . command . CommandResult ; import org . eclipse . gmf . runtime . common . core . command . ICommand ; import org . eclipse . gmf . runtime . emf . type . core . IElementType ; import org . eclipse . gmf . runtime . emf . type . core . commands . EditElementCommand ; import org . eclipse . gmf . runtime . emf . type . core . requests . ConfigureRequest ; import org . eclipse . gmf . runtime . emf . type . core . requests . CreateElementRequest ; import org . eclipse . gmf . runtime . notation . View ; import org . msl . simple . gmfmap . simplemappings . SimpleLabelNode ; import org . msl . simple . gmfmap . simplemappings . SimpleParentNode ; import org . msl . simple . gmfmap . simplemappings . SimplemappingsFactory ; public class SimpleLabelNode3CreateCommand extends EditElementCommand { public SimpleLabelNode3CreateCommand ( CreateElementRequest req ) { super ( req . getLabel ( ) , null , req ) ; } protected EObject getElementToEdit ( ) { EObject container = ( ( CreateElementRequest ) getRequest ( ) ) . getContainer ( ) ; if ( container instanceof View ) { container = ( ( View ) container ) . getElement ( ) ; } return container ; } public boolean canExecute ( ) { return true ; } protected CommandResult doExecuteWithResult ( IProgressMonitor monitor , IAdaptable info ) throws ExecutionException { SimpleLabelNode newElement = SimplemappingsFactory . eINSTANCE . createSimpleLabelNode ( ) ; SimpleParentNode owner = ( SimpleParentNode ) getElementToEdit ( ) ; owner . getChildren ( ) .", "gt": "add ( newElement ) ;", "prediction": "add ( newElement ) ;\n", "label": 0}
{"id": 15868, "input": "<s> package com . corundumstudio . socketio . parser ; import java . util . Collections ; import java . util . List ; import org . jboss . netty . util . CharsetUtil ; public class Packet { public static final char DELIMITER = '\ufffd' ; public static final byte [ ] DELIMITER_BYTES = new String ( new char [ ] { DELIMITER } ) . getBytes ( CharsetUtil . UTF_8 ) ; public static final byte SEPARATOR = ':' ; public static final String ACK_DATA = \"data\" ; public static final Packet NULL_INSTANCE = new Packet ( null ) ; private final PacketType type ; private List < ? > args = Collections . emptyList ( ) ; private String qs ; private Object ack ; private Long ackId ; private String name ; private Long id ; private String endpoint ; private Object data ; private ErrorReason reason ; private ErrorAdvice advice ; public Packet ( PacketType type ) { super ( ) ; this . type = type ; } public PacketType getType ( ) { return type ; } public void setData ( Object data ) { this . data = data ; } public Object getData ( ) { return data ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getEndpoint ( ) { return endpoint ; } public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public void setAck ( Object ack ) { this . ack = ack ; } public Object getAck ( ) { return ack ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public List < ? > getArgs ( ) { return args ; } public void setArgs ( List < ? > args ) { this . args = args ; } public String getQs ( ) { return qs ; } public void setQs ( String qs ) { this . qs = qs ; } public Long getAckId ( ) { return ackId ; } public void setAckId ( Long ackId ) { this . ackId = ackId ; } public ErrorReason getReason ( ) { return reason ; } public void setReason ( ErrorReason reason ) { this . reason = reason ; } public ErrorAdvice getAdvice ( ) { return advice ; } public void", "gt": "setAdvice ( ErrorAdvice advice )", "prediction": "setAdvice ( ErrorAdvice advice )\n", "label": 1}
{"id": 1159, "input": "<s> package overrideOK ; abstract class A { abstract void f ( ) ; void g ( ) { } } class B extends A { @ Override void f ( ) { } @", "gt": "Override void g ( )", "prediction": "Override void g ( )\n", "label": 0}
{"id": 15869, "input": "<s> package com . talis . hbase . rdf . assembler ; import com . hp . hpl . jena . assembler . Assembler ; import com . hp . hpl . jena . assembler . assemblers . AssemblerGroup ; import com . hp . hpl . jena . rdf . model . Property ; import com . hp . hpl . jena . rdf . model . Resource ; import com . talis . hbase . rdf . HBaseRdf ; import com . talis . hbase . rdf . util . Vocab ; public class AssemblerVocab { private static final String NS = HBaseRdf . namespace ; public static String getURI ( ) { return NS ; } public static final Resource HBaseConnectionAssemblerType = Vocab . type ( NS , \"HBaseConnection\" ) ; public static final Resource StoreAssemblerType = Vocab . type ( NS , \"Store\" ) ; public static final Resource DatasetAssemblerType = Vocab . type ( NS , \"DatasetStore\" ) ; public static final Resource ModelType = Vocab . type ( NS , \"Model\" ) ; public static final Resource GraphType = Vocab . type ( NS , \"Graph\" ) ; public static final Property pStore = Vocab . property ( NS , \"store\" ) ; public static final Property pDataset = Vocab . property ( NS , \"dataset\" ) ; public static final Property pGraphData = Vocab . property ( NS , \"graph\" ) ; public static final Property pNamedGraph1 = Vocab . property ( NS , \"graphName\" ) ; public static final Property pNamedGraph2 = Vocab . property ( NS , \"namedGraph\" ) ; public static final Property pName = Vocab . property ( NS , \"name\" ) ; public static final Property pLayout = Vocab . property ( NS , \"layout\" ) ; public static final Property pConnection = Vocab . property ( NS , \"connection\" ) ; public static final Property pHBaseRdfConfiguration = Vocab . property ( NS , \"configuration\" ) ; public static final Resource QueryAssemblerType = Vocab . type ( NS , \"Query\" ) ; public static final Property pQuery = Vocab . property ( NS , \"query\" ) ; public static final Property pQueryFile = Vocab . property ( NS , \"queryFile\" ) ; public static final Property pQueryString = Vocab . property ( NS , \"queryString\" ) ; public static final Property pOutputFormat = Vocab . property ( NS , \"outputFormat\" ) ; private static boolean initialized = false ; static { init ( ) ; } static public void init ( ) { if ( initialized ) return ; register ( Assembler . general ) ; initialized = true ; } static public void register ( AssemblerGroup g ) { assemblerClass ( g , QueryAssemblerType , new QueryAssembler ( ) ) ; assemblerClass ( g , HBaseConnectionAssemblerType , new HBaseRdfConnectionDescAssembler ( ) ) ; assemblerClass ( g , StoreAssemblerType", "gt": ", new StoreDescAssembler ( ) ) ;", "prediction": ", new StoreAssembler ( ) ) ;\n", "label": 1}
{"id": 1823, "input": "<s> package org . ofbiz . content . content ; import java . sql . Timestamp ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import javolution . util . FastList ; import javolution . util . FastSet ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . common . KeywordSearchUtil ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityComparisonOperator ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . condition . EntityConditionList ; import org . ofbiz . entity . condition . EntityExpr ; import org . ofbiz . entity . condition . EntityOperator ; import org . ofbiz . entity . model . DynamicViewEntity ; import org . ofbiz . entity . model . ModelKeyMap ; import org . ofbiz . entity . model . ModelViewEntity . ComplexAlias ; import org . ofbiz . entity . model . ModelViewEntity . ComplexAliasField ; import org . ofbiz . entity . transaction . GenericTransactionException ; import org . ofbiz . entity . transaction . TransactionUtil ; import org . ofbiz . entity . util . EntityFindOptions ; import org . ofbiz . entity . util . EntityListIterator ; import org . ofbiz . entity . util . EntityUtil ; public class ContentSearch { public static final String module = ContentSearch . class . getName ( ) ; public static final String resource = \"ContentUiLabels\" ; public static ArrayList < String > searchContents ( List < ? extends ContentSearchConstraint > contentSearchConstraintList , ResultSortOrder resultSortOrder , Delegator delegator , String visitId ) { ContentSearchContext contentSearchContext = new ContentSearchContext ( delegator , visitId ) ; contentSearchContext . addContentSearchConstraints ( contentSearchConstraintList ) ; contentSearchContext . setResultSortOrder ( resultSortOrder ) ; ArrayList < String > contentIds = contentSearchContext . doSearch ( ) ; return contentIds ; } public static void getAllSubContentIds ( String contentId , Set < String > contentIdSet , Delegator delegator , Timestamp nowTimestamp ) { if ( nowTimestamp == null ) { nowTimestamp = UtilDateTime . nowTimestamp ( ) ; } contentIdSet . add ( contentId ) ; try { List < GenericValue > contentAssocList = delegator . findByAnd ( \"ContentAssoc\" , UtilMisc . toMap ( \"contentIdFrom\" , contentId ) , null , true ) ; for ( GenericValue contentAssoc : contentAssocList ) { String subContentId = contentAssoc . getString ( \"contentIdTo\" ) ; if ( contentIdSet . contains ( subContentId ) ) { continue ; } if ( EntityUtil . isValueActive ( contentAssoc , nowTimestamp ) ) { getAllSubContentIds ( subContentId , contentIdSet , delegator , nowTimestamp ) ; } } List < GenericValue > childContentList = delegator . findList ( \"Content\" , EntityCondition . makeCondition ( \"contentParentId\" , EntityComparisonOperator . EQUALS , contentId ) , UtilMisc . toSet ( \"contentId\" , \"contentParentId\" ) , null , null , true ) ; for ( GenericValue childContent : childContentList ) { String subContentId = childContent . getString ( \"contentId\" ) ; if ( contentIdSet . contains ( subContentId ) ) { continue ; } getAllSubContentIds ( subContentId , contentIdSet , delegator , nowTimestamp ) ; } } catch ( GenericEntityException e ) { Debug . logError ( e , \"Error finding sub-categories for content search\" , module ) ; } } public static class ContentSearchContext { public int index = 1 ; public List < EntityCondition > entityConditionList = FastList . newInstance ( ) ; public List < String > orderByList = FastList . newInstance ( ) ; public List < String > fieldsToSelect = UtilMisc . toList ( \"contentId\" ) ; public DynamicViewEntity dynamicViewEntity = new DynamicViewEntity ( ) ; public boolean contentIdGroupBy = false ; public boolean includedKeywordSearch = false ; public Timestamp nowTimestamp = UtilDateTime . nowTimestamp ( ) ; public List < Set < String > > keywordFixedOrSetAndList = FastList . newInstance ( ) ; public Set < String > orKeywordFixedSet = FastSet . newInstance ( ) ; public Set < String > andKeywordFixedSet = FastSet . newInstance ( ) ; public List < GenericValue > contentSearchConstraintList = FastList . newInstance ( ) ; public ResultSortOrder resultSortOrder = null ; public Integer resultOffset = null ; public Integer maxResults = null ; protected Delegator delegator = null ; protected String visitId = null ; protected Integer totalResults = null ; public ContentSearchContext ( Delegator delegator , String visitId ) { this . delegator = delegator ; this . visitId = visitId ; dynamicViewEntity . addMemberEntity ( \"CNT\" , \"Content\" ) ; } public Delegator getDelegator ( ) { return this . delegator ; } public void addContentSearchConstraints ( List < ? extends ContentSearchConstraint > contentSearchConstraintList ) { for ( ContentSearchConstraint constraint : contentSearchConstraintList ) { constraint . addConstraint ( this ) ; } } public void setResultSortOrder ( ResultSortOrder resultSortOrder ) { this . resultSortOrder = resultSortOrder ; } public void setResultOffset ( Integer resultOffset ) { this . resultOffset = resultOffset ; } public void setMaxResults ( Integer maxResults ) { this . maxResults = maxResults ; } public Integer getTotalResults ( ) { return this . totalResults ; } public ArrayList < String > doSearch ( ) { long startMillis = System . currentTimeMillis ( ) ; EntityListIterator eli = this . doQuery ( delegator ) ; ArrayList < String > contentIds =", "gt": "this . makeContentIdList ( eli ) ;", "prediction": "contentSearchContext . doSearch ( ) ;\n", "label": 0}
{"id": 15879, "input": "<s> package org . eclipse . swt . custom ; import org . eclipse . swt . internal . SWTEventListener ; public interface CTabFolder2Listener extends SWTEventListener { public void close ( CTabFolderEvent event ) ; public void minimize ( CTabFolderEvent event ) ; public void maximize ( CTabFolderEvent event ) ;", "gt": "public void restore ( CTabFolderEvent event ) ;", "prediction": "}\n", "label": 1}
{"id": 4611, "input": "<s> package org . ofbiz . content . data ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . StringWriter ; import java . io . Writer ; import java . net . URL ; import java . net . URLConnection ; import java . nio . ByteBuffer ; import java . util . Comparator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . TreeMap ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpSession ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . apache . commons . fileupload . FileItem ; import org . apache . commons . fileupload . FileUploadException ; import org . apache . commons . fileupload . disk . DiskFileItemFactory ; import org . apache . commons . fileupload . servlet . ServletFileUpload ; import org . apache . tika . Tika ; import org . ofbiz . base . location . FlexibleLocation ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . FileUtil ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilIO ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . StringUtil . StringWrapper ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . base . util . template . XslTransform ; import org . ofbiz . common . email . NotificationServices ; import org", "gt": ". ofbiz . content . content . UploadContentAndImage ;", "prediction": ". ofbiz . common . email . Message ;\n", "label": 0}
{"id": 15917, "input": "<s> package org . restlet . example . book . restlet . ch09 . client ; import java . util . ArrayList ; public class MailItems { private static final int NUM_ITEMS = 64 ; private static final int FRAGMENTS_PER_EMAIL = 10 ; private static final String [ ] senders = new String [ ] { \"markboland05\" , \"Hollie Voss\" , \"boticario\" , \"Emerson Milton\" , \"Healy Colette\" , \"Brigitte Cobb\" , \"Elba Lockhart\" , \"Claudio Engle\" , \"Dena Pacheco\" , \"Brasil s.p\" , \"Parker\" , \"derbvktqsr\" , \"qetlyxxogg\" , \"antenas.sul\" , \"Christina Blake\" , \"Gail Horton\" , \"Orville Daniel\" , \"PostMaster\" , \"Rae Childers\" , \"Buster misjenou\" , \"user31065\" , \"ftsgeolbx\" , \"aqlovikigd\" , \"user18411\" , \"Mildred Starnes\" , \"Candice Carson\" , \"Louise Kelchner\" , \"Emilio Hutchinson\" , \"Geneva Underwood\" , \"Residence Oper?\" , \"fpnztbwag\" , \"tiger\" , \"Heriberto Rush\" , \"bulrush Bouchard\" , \"Abigail Louis\" , \"Chad Andrews\" , \"bjjycpaa\" , \"Terry English\" , \"Bell Snedden\" , \"huang\" , \"hhh\" , \"(unknown sender)\" , \"Kent\" , \"Dirk Newman\" , \"Equipe Virtual Cards\" , \"wishesundmore\" , \"Benito Meeks\" } ; private static final String [ ] emails = new String [ ] { \"mark@example.com\" , \"hollie@example.com\" , \"boticario@example.com\" , \"emerson@example.com\" , \"healy@example.com\" , \"brigitte@example.com\" , \"elba@example.com\" , \"claudio@example.com\" , \"dena@example.com\" , \"brasilsp@example.com\" , \"parker@example.com\" , \"derbvktqsr@example.com\" , \"qetlyxxogg@example.com\" , \"antenas_sul@example.com\" , \"cblake@example.com\" , \"gailh@example.com\" , \"orville@example.com\" , \"post_master@example.com\" , \"rchilders@example.com\" , \"buster@example.com\" , \"user31065@example.com\" , \"ftsgeolbx@example.com\" , \"aqlovikigd@example.com\" , \"user18411@example.com\" , \"mildred@example.com\" , \"candice@example.com\" , \"louise_kelchner@example.com\" , \"emilio@example.com\" , \"geneva@example.com\" , \"residence_oper@example.com\" , \"fpnztbwag@example.com\" , \"tiger@example.com\" , \"heriberto@example.com\" , \"bulrush@example.com\" , \"abigail_louis@example.com\" , \"chada@example.com\" , \"bjjycpaa@example.com\" , \"terry@example.com\" , \"bell@example.com\" , \"huang@example.com\" , \"hhh@example.com\" , \"kent@example.com\" , \"newman@example.com\" , \"equipe_virtual@example.com\" , \"wishesundmore@example.com\" , \"benito@example.com\" } ; private static final String [ ] subjects = new String [ ] { \"URGENT -[Mon, 24 Apr 2006 02:17:27 +0000]\" , \"URGENT TRANSACTION -[Sun, 23 Apr 2006 13:10:03 +0000]\" , \"fw: Here it comes\" , \"voce ganho um vale presente Boticario\" , \"Read this ASAP\" , \"Hot Stock Talk\" , \"New Breed of Equity Trader\" , \"FWD: TopWeeks the wire special pr news release\" , \"[fwd] Read this ASAP\" , \"Renda Extra R$1.000,00-R$2.000,00/m?s\" , \"re: Make sure your special pr news released\" , \"Forbidden Knowledge Conference\" , \"decodificadores os menores pre?os\" , \"re: Our Pick\" , \"RE: The hottest pick Watcher\" , \"RE: St0kkMarrkett Picks Trade watch special pr news release\" , \"St0kkMarrkett Picks Watch special pr news release news\" , \"You are a Winner oskoxmshco\" , \"Encrypted E-mail System (VIRUS REMOVED)\" , \"Fw: Malcolm\" , \"Secure Message System (VIRUS REMOVED)\" , \"fwd: St0kkMarrkett Picks Watch special pr news releaser\" , \"FWD: Financial Market Traderr special pr news release\" , \"? s? uma dica r?pida !!!!! leia !!!\" , \"re: You have to heard this\" , \"fwd: Watcher TopNews\" , \"VACANZE alle Mauritius\" , \"funny\" , \"re: You need to review this\" , \"[re:] Our Pick\" , \"RE: Before the be11 special pr news release\" , \"[re:] Market TradePicks Trade watch news\" , \"No prescription needed\" , \"Seu novo site\" , \"[fwd] Financial Market Trader Picker\" , \"FWD: Top Financial Market Specialists Trader interest increases\" , \"Os cart?es mais animados da web!!\" , \"We will sale 4 you cebtdbwtcv\" ,", "gt": "\"RE: Best Top Financial Market Specialists Trader Picks\" }", "prediction": "}\n", "label": 1}
{"id": 6378, "input": "<s> import com . sun . javadoc . * ; import java . util . * ; import java . io . * ; public class AuthorDD { private static final String BUGID = \"4651598\" ; private static final String BUGNAME = \"AuthorDD\" ; private static final String FS = System . getProperty ( \"file.separator\" ) ; private static final String PS = System . getProperty ( \"path.separator\" ) ; private static final String NL = System . getProperty ( \"line.separator\" ) ; public static int subtestNum = 0 ; public static int numSubtestsPassed = 0 ; public static void main ( String [ ] args ) { String srcdir = System . getProperty ( \"test.src\" , \".\" ) ; runJavadoc ( new String [ ] { \"-d\" , BUGID , \"-author\" , \"-version\" , \"-sourcepath\" , srcdir , \"p1\" } ) ; runTestsOnHTML ( testArray ) ; printSummary ( ) ; } public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( AuthorDD . class . getClassLoader ( ) , javadocArgs ) != 0 ) { throw new Error ( \"Javadoc failed to execute\" ) ; } } private static final String [ ] [ ] testArray = { { \"<dt><span class=\\\"strong\\\">Since:</span></dt>\" + NL + \"  <dd>JDK 1.0</dd>\" , BUGID + FS + \"p1\" + FS + \"C1.html\" } , { \"<dt><span class=\\\"strong\\\">Author:</span></dt>\" + NL + \"  <dd>Doug Kramer, Jamie, Neal</dd>\" , BUGID + FS + \"p1\" + FS + \"C1.html\" } , } ; public static void runTestsOnHTML ( String [ ] [ ] testArray ) { for ( int i = 0 ; i < testArray . length ; i ++ ) { subtestNum += 1 ; String fileString = readFileToString ( testArray [ i ] [ 1 ] ) ; String stringToFind = testArray [ i ] [ 0 ] ; if ( findString ( fileString , stringToFind ) == - 1 ) { System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" for bug \" + BUGID + \" (\" + BUGNAME + \") FAILED\\n\" + \"when searching for:\\n\" + stringToFind ) ; } else { numSubtestsPassed += 1 ; System . out . println ( \"\\nSub-test \" + ( subtestNum ) + \" passed:\\n\" + stringToFind ) ; } } } public static void printSummary ( ) { if ( numSubtestsPassed == subtestNum ) { System . out . println ( \"\\nAll \" + numSubtestsPassed + \" subtests passed\" ) ; } else { throw new Error ( \"\\n\" + ( subtestNum - numSubtestsPassed ) + \" of \" + ( subtestNum ) + \" subtests failed for bug \" + BUGID + \" (\" + BUGNAME + \")\\n\" ) ; } } public static String readFileToString ( String filename ) { try { File file = new File ( filename ) ; if", "gt": "( ! file . exists ( ) )", "prediction": "( file != null )\n", "label": 0}
{"id": 15919, "input": "<s> package org . eclipse . jface . tests . viewers ; import org . eclipse . jface . viewers . ColumnLayoutData ; import org . eclipse . jface . viewers . ColumnWeightData ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TableLayout ; import org . eclipse . jface . viewers . TableViewer ; import org . eclipse . jface . viewers . ViewerComparator ; import org . eclipse . jface . viewers . ViewerSorter ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; public class TableViewerComparatorTest extends ViewerComparatorTest { public TableViewerComparatorTest ( String name ) { super ( name ) ; } protected StructuredViewer createViewer ( Composite parent ) { TableViewer viewer = new TableViewer ( parent ) ; viewer . setContentProvider ( new TeamModelContentProvider ( ) ) ; viewer . setLabelProvider ( new TeamModelLabelProvider ( ) ) ; viewer . getTable ( ) . setLinesVisible ( true ) ; TableLayout layout = new TableLayout ( ) ; viewer . getTable ( ) . setLayout ( layout ) ; viewer . getTable ( ) . setHeaderVisible ( true ) ; String headers [ ] = { \"column 1 header\" , \"column 2 header\" } ; ColumnLayoutData layouts [ ] = { new ColumnWeightData ( 100 ) , new ColumnWeightData ( 100 ) } ; final TableColumn columns [ ] = new TableColumn [ headers . length ] ; for ( int i = 0 ; i < headers . length ; i ++ ) { layout . addColumnData ( layouts [ i ] ) ; TableColumn tc = new TableColumn ( viewer . getTable ( ) , SWT . NONE , i ) ; tc . setResizable ( layouts [ i ] . resizable ) ; tc . setText ( headers", "gt": "[ i ] ) ;", "prediction": "[ i ] ) ;\n", "label": 1}
{"id": 7999, "input": "<s> package com . mobeelizer . mobile . android ; import java . util . Collection ; import java . util . Iterator ; import android . database . Cursor ; import android . database . sqlite . SQLiteDatabase ; import com . mobeelizer . java . sync . MobeelizerJsonEntity ; import com . mobeelizer . mobile . android . model . MobeelizerAndroidModel ; class MobeelizerSyncIterator implements Iterator < MobeelizerJsonEntity > { private final Iterator < MobeelizerAndroidModel > models ; private final SQLiteDatabase database ; private MobeelizerAndroidModel model ; private Cursor cursor ; public MobeelizerSyncIterator ( final SQLiteDatabase database , final Collection < MobeelizerAndroidModel > models ) { this . database = database ; this . models = models . iterator ( ) ; } @ Override public boolean hasNext ( ) { if ( model == null ) { if (", "gt": "models . hasNext ( ) )", "prediction": "cursor == null )\n", "label": 0}
{"id": 15922, "input": "<s> package monbulk . shared . Services ; import java . util . List ; import arc . mf . client . xml . * ; public class Metadata { public interface ModifiedHandler { public void onModified ( ) ; } private DocumentElement m_rootElement = new DocumentElement ( \"root\" , \"root\" , Element . ElementTypes . Document ) ; private ModifiedHandler m_modifiedHandler = null ; public Metadata ( String name , String description , String label ) { setName ( name ) ; setDescription ( description ) ; setLabel ( label ) ; m_rootElement . setMetadata ( this ) ; } public boolean getIsModified ( ) { return m_rootElement . getIsModified ( ) ; } public void setName ( String name ) { m_rootElement . setSetting ( \"name\" , name ) ; } public String getName ( ) { return m_rootElement . getName ( ) ; } public void setDescription ( String description ) { m_rootElement . setDescription ( description ) ; } public String getDescription ( ) { return m_rootElement . getDescription ( ) ; } public void setLabel ( String label ) { m_rootElement . setSetting ( \"label\" , label ) ; } public String getLabel ( ) { return m_rootElement . getSetting ( \"label\" , \"\" ) ; } public DocumentElement getRootElement ( ) { return m_rootElement ; } public void clearModified ( ) { m_rootElement . clearModified ( ) ; } public static Metadata create ( XmlElement element ) throws Exception { XmlElement type = element . element ( \"type\" ) ; Metadata metadata = new Metadata ( type . value ( \"@name\" ) , type . value ( \"description\" ) , type . value ( \"label\" ) ) ; parseMetadata ( metadata . getRootElement ( ) , type . elements ( \"definition/element\" ) , metadata ) ; metadata . clearModified ( ) ; return metadata ; } private static void parseMetadata ( DocumentElement parent , List < XmlElement > xmlElements , Metadata metadata ) throws Exception { if ( xmlElements == null ) { return ; } for ( XmlElement e : xmlElements ) {", "gt": "Element element = Element . createElement ( e ) ;", "prediction": "if ( e instanceof DocumentElement )\n", "label": 1}
{"id": 6811, "input": "<s> import org . parboiled . common . FileUtils ; import org . parboiled . common . ImmutableList ; import org . scalatest . testng . TestNGWrapperSuite ; import java . io . File ; import java . io . IOException ; import static scala . collection . JavaConversions . collectionAsScalaIterable ; @ SuppressWarnings ( \"unchecked\" ) public class JavaTestWrapper extends TestNGWrapperSuite { public JavaTestWrapper ( ) throws IOException { super ( collectionAsScalaIterable ( ImmutableList . of ( getSuiteFileName ( ) ) ) . toList ( ) ) ; } public static String getSuiteFileName ( ) throws IOException { File temp = File . createTempFile ( \"parboiled_testng_suite\" , \".xml\" ) ; temp . deleteOnExit ( ) ; String xml = \"\" + \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<!DOCTYPE suite SYSTEM \\\"http://testng.org/testng-1.0.dtd\\\">\\n\" + \"<suite name=\\\"parboiled-java\\\">\\n\" + \"  <test verbose=\\\"1\\\" name=\\\"parboiled-java\\\" annotations=\\\"JDK\\\">\\n\" + \"    <packages>\\n\" + \"      <package name=\\\"org.parboiled.*\\\" />\\n\" + \"    </packages>\\n\" + \"  </test>\\n\" + \"  <test verbose=\\\"1\\\" name=\\\"NoPackageParser\\\" annotations=\\\"JDK\\\">\\n\" + \"    <classes>\\n\" + \"      <class name=\\\"NoPackageParser\\\"/>\\n\" + \"  ", "gt": " </classes>\" + \"  </test>\\n\" + \"</suite>\" ;", "prediction": "<class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"/>\\n\" + \" <class name=\\\"NoPackageParser\\\"\n", "label": 0}
{"id": 15924, "input": "<s> package play . modules . cream . ocm ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . List ; import javax . jcr . Node ; import javax . jcr . NodeIterator ; import javax . jcr . RepositoryException ; import javax . jcr . Session ; import javax . jcr . version . Version ; import javax . jcr . version . VersionHistory ; import javax . jcr . version . VersionIterator ; import javax . jcr . version . VersionManager ; import org . jcrom . JcrMappingException ; import play . modules . cream . JCR ; public class JcrVersionMapper { public static < T > T getVersion ( Class < T > clazz , String path , String versionName ) { return getVersion ( clazz , path , versionName , \"*\" , - 1 ) ; } public static < T > T getVersion ( Class < T > clazz , String path , String versionName , String childNodeFilter , int maxDepth ) { try { return getVersion ( clazz , getSession ( ) . getRootNode ( ) . getNode ( JcrMapper . relativePath ( path ) ) , versionName , childNodeFilter , maxDepth ) ; } catch ( RepositoryException e ) { throw new JcrMappingException ( \"Could not get version\" , e ) ; } } public static < T > T getVersionByUUID ( Class < T > clazz , String uuid , String versionName ) { return getVersionByUUID ( clazz , uuid , versionName , \"*\" , - 1 ) ; } public static < T > T getVersionByUUID ( Class < T > clazz , String uuid , String versionName , String childNodeFilter , int maxDepth ) { try { return getVersion ( clazz , getSession ( ) . getNodeByIdentifier ( uuid ) , versionName , childNodeFilter , maxDepth ) ; } catch ( RepositoryException e ) { throw new JcrMappingException ( \"Could not get version\" , e ) ; } } public static < T > List < T > getVersionList ( Class < T > clazz , String path ) { try { return getVersionList ( clazz , getSession ( ) . getRootNode ( ) . getNode ( JcrMapper . relativePath ( path ) ) , \"*\" , - 1 ) ; } catch ( RepositoryException e ) { throw new JcrMappingException ( \"Could not get version list\" , e ) ; } } public static < T > List < T > getVersionList ( Class < T > clazz , String path , String childNameFilter , int maxDepth ) { try { return getVersionList ( clazz , getSession ( ) . getRootNode ( ) . getNode ( JcrMapper . relativePath ( path ) ) , childNameFilter , maxDepth ) ; } catch ( RepositoryException e ) { throw new JcrMappingException ( \"Could not get version list\" , e ) ; } } public static < T > List < T > getVersionList ( Class < T > clazz , String path , String childNameFilter , int maxDepth ,", "gt": "long startIndex , long resultSize )", "prediction": "String childNodeFilter )\n", "label": 1}
{"id": 7930, "input": "<s> package com . example . business . testing ; import com . asakusafw . runtime . value . DateTime ; import com . example . business . modelgen . table . model . Shipment ; public class ShipmentFactory { private ShipmentFactory ( ) { return ; } public static Shipment create ( DateTime shippedDate , long", "gt": "itemCode , int cost )", "prediction": "time )\n", "label": 0}
{"id": 15933, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . ui . internal . part . StatusPart ; import org . eclipse . ui . part . ViewPart ; public class ErrorViewPart extends ViewPart { private IStatus error ; public ErrorViewPart ( ) { } public ErrorViewPart ( IStatus error ) { this . error = error ; } public void createPartControl ( Composite parent ) { if ( error != null ) { new StatusPart ( parent , error ) ; } } public void setPartName ( String newName ) { super", "gt": ". setPartName ( newName ) ;", "prediction": ". setPartName ( newName ) ;\n", "label": 1}
{"id": 6146, "input": "<s> package com . sun . javadoc ; import java . io . File ; public interface SourcePosition { File file ( ) ;", "gt": "int line ( ) ;", "prediction": "}\n", "label": 0}
{"id": 15961, "input": "<s> package org . seage . metaheuristic . fireflies ; public interface Solution extends java . lang . Cloneable , java . io . Serializable { public abstract double [ ] getObjectiveValue ( ) ; public abstract void setObjectiveValue (", "gt": "double [ ] objValue ) ;", "prediction": ") ;\n", "label": 1}
{"id": 2929, "input": "<s> package org . jjflyboy . tjpeditor . project ; import org . eclipse", "gt": ". emf . ecore . EObject ;", "prediction": ". swt . SWT ;\n", "label": 0}
{"id": 15998, "input": "<s> package org . fuzzydb . attrs . util ; public class Point2D { public Point2D ( Comparable < Object > x , Comparable < Object > y ) { super ( ) ; this . x = x ;", "gt": "this . y = y ;", "prediction": "this . y = y ;\n", "label": 1}
{"id": 2502, "input": "<s> package com . b3rwynmobile . fayeclient ; import com . b3rwynmobile . fayeclient . models . FayeMessage ; public interface FayeListener { public void connectedToServer ( FayeClient faye ) ; public void", "gt": "disconnectedFromServer ( FayeClient faye ) ;", "prediction": "setUp ( ) ;\n", "label": 0}
{"id": 16004, "input": "<s> package org . eclipse . rap . rwt . cluster . testfixture . internal . tomcat ; import java . util . LinkedList ; import java . util . List ; import java . util . logging . Level ; import java . util . logging . Logger ; class TomcatLog { private static final List < Logger > loggerHolder = new LinkedList < Logger > ( ) ; static void silence ( ) { configureLogger ( \"org.apache.catalina.core.StandardEngine\" ) ; configureLogger ( \"org.apache.catalina.core.StandardWrapper\" ) ; configureLogger ( \"org.apache.catalina.ha.session.DeltaManager\" ) ; configureLogger ( \"org.apache.catalina.ha.tcp.SimpleTcpCluster\" ) ; configureLogger ( \"org.apache.catalina.ha.session.JvmRouteBinderValve\" ) ; configureLogger ( \"org.apache.catalina.realm.JAASRealm\" ) ;", "gt": "configureLogger ( \"org.apache.catalina.startup.DigesterFactory\" ) ;", "prediction": "}\n", "label": 1}
{"id": 4238, "input": "<s> package org . remast . baralga . gui . model ; @ SuppressWarnings ( \"serial\" ) public class ProjectActivityStateException extends Exception { public ProjectActivityStateException", "gt": "( final String message )", "prediction": "( )\n", "label": 0}
{"id": 16032, "input": "<s> package org . eclipse . swt . widgets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . graphics . * ; import org . eclipse . swt . internal . SerializableCompatibility ; import org . eclipse . swt . internal . widgets . * ; public class TreeItem extends Item { private final TreeItem parentItem ; final Tree parent ; TreeItem [ ] items ; int itemCount ; private transient ITreeItemAdapter treeItemAdapter ; int index ; private Data [ ] data ; private Font font ; private boolean expanded ; private boolean checked ; private Color background ; private Color foreground ; private boolean grayed ; int depth ; private boolean cached ; private int flatIndex ; public TreeItem ( Tree parent , int style ) { this ( parent , null , style , parent == null ? 0 : parent . getItemCount ( ) , true ) ; } public TreeItem ( Tree parent , int style , int index ) { this ( parent , null , style , index , true ) ; } public TreeItem ( TreeItem parentItem , int style ) { this ( parentItem == null ? null : parentItem . parent , parentItem , style , parentItem == null ? 0 : parentItem . itemCount , true ) ; } public TreeItem ( TreeItem parentItem , int style , int index ) { this ( parentItem == null ? null : parentItem . parent , parentItem , style , index , true ) ; } TreeItem ( Tree parent , TreeItem parentItem , int style , int index , boolean create ) { super ( parent , style ) ; this . parent = parent ; this . parentItem = parentItem ; this . index = index ; if ( parentItem != null ) { depth = parentItem . depth + 1 ; } parent . isFlatIndexValid = false ; setEmpty ( ) ; if ( create ) { int numberOfItems ; if ( parentItem != null ) { numberOfItems = parentItem . itemCount ; } else { numberOfItems = parent . getItemCount ( ) ; } if ( index < 0 || index > numberOfItems ) { error ( SWT . ERROR_INVALID_RANGE ) ; } if ( parentItem != null ) { parentItem . createItem ( this , index ) ; } else { parent . createItem ( this , index ) ; } parent . updateScrollBars ( ) ; } } private void setEmpty ( ) { items = new TreeItem [ 4 ] ; } private void createItem ( TreeItem item , int index ) { if ( itemCount == items . length ) { boolean small = isVisible ( ) ; int length = small ? items . length + 4 : Math . max ( 4 , items . length * 3 / 2 ) ; TreeItem [ ] newItems = new TreeItem [ length ] ; System . arraycopy ( items , 0 , newItems , 0 , items . length ) ; items = newItems ; } System . arraycopy ( items , index , items , index + 1 , itemCount - index ) ; items [ index ] = item ; itemCount ++ ; adjustItemIndices ( index ) ; } private void destroyItem ( TreeItem item , int index ) { itemCount -- ; if ( itemCount == 0 ) { setEmpty ( ) ; } else { System . arraycopy ( items , index + 1 , items , index , itemCount - index ) ; items [ itemCount ] = null ; } adjustItemIndices ( index ) ; } private void adjustItemIndices ( int start ) { for ( int i = start ; i < itemCount ; i ++ ) { if ( items [ i ] != null ) { items [ i ] . index = i ; } } } @ SuppressWarnings ( \"unchecked\" ) @ Override public < T > T getAdapter ( Class < T > adapter ) { T result ; if ( adapter == IItemHolderAdapter . class ) { result = ( T ) new CompositeItemHolder ( ) ; } else if ( adapter == IWidgetFontAdapter . class || adapter == IWidgetColorAdapter", "gt": ". class || adapter == ITreeItemAdapter . class )", "prediction": ". class )\n", "label": 1}
{"id": 1721, "input": "<s> package ar . com . fdvs . dj . core . registration ; import ar . com . fdvs . dj . core . CoreException ; public class EntitiesRegistrationException extends CoreException { private static final long serialVersionUID = - 2331402212995767633L ; public EntitiesRegistrationException ( String arg0 ) { super ( arg0 ) ; } public", "gt": "EntitiesRegistrationException ( String message , Throwable e )", "prediction": "void setUp ( )\n", "label": 0}
{"id": 16036, "input": "<s> package org . eclipse . ui . internal . presentations . defaultpresentation ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . internal . presentations . util . AbstractTabFolder ; import org . eclipse . ui . internal . presentations . util . AbstractTabItem ; import org . eclipse . ui . internal . presentations . util . EnhancedFillLayout ; import org . eclipse . ui . internal . presentations . util . PartInfo ; public class EmptyTabFolder extends AbstractTabFolder { private Composite control ; private Control childControl ; public EmptyTabFolder ( Composite parent , boolean showborder ) { control = new Composite ( parent , SWT . NONE ) ; EnhancedFillLayout layout = new EnhancedFillLayout ( ) ; control . setLayout ( layout ) ; if ( showborder ) { layout . xmargin = 1 ; layout . ymargin = 1 ; } } public Point computeSize ( int widthHint , int heightHint ) { if ( childControl != null ) { if ( childControl instanceof Composite ) { Composite composite = ( Composite ) childControl ; if ( composite . getChildren ( ) . length == 0 ) { EnhancedFillLayout layout = ( EnhancedFillLayout ) control . getLayout ( ) ; int w = widthHint == SWT . DEFAULT ? layout . xmargin * 2 : widthHint ; int h = heightHint == SWT . DEFAULT ? layout . ymargin * 2 : heightHint ; return new Point ( w , h ) ; } } return childControl . computeSize ( widthHint , heightHint ) ; } return new Point ( 0 , 0 ) ; } public AbstractTabItem add ( int index , int flags ) { return new EmptyTabItem ( ) ; } public Composite getContentParent ( ) { return control ; } public void setContent ( Control newContent ) { childControl = newContent ; } public AbstractTabItem [ ] getItems ( ) { return new AbstractTabItem [ 0 ] ; } public AbstractTabItem getSelection ( ) { return null ; } public void setSelection ( AbstractTabItem toSelect ) { } public void setToolbar ( Control toolbar ) { if ( toolbar != null ) { toolbar . setVisible ( false ) ; } } public void layout ( boolean flushCache ) { super . layout ( flushCache ) ; control . layout ( flushCache ) ; }", "gt": "public void setSelectedInfo ( PartInfo info )", "prediction": "}\n", "label": 1}
{"id": 3724, "input": "<s> class T7022054neg1 { static class A { A m ( String s ) { return null ; } } static class B extends A { < X extends String", "gt": "> A m ( X s )", "prediction": "> m ( String s )\n", "label": 0}
{"id": 16045, "input": "<s> package org . restlet . test . ext . odata . cafecustofeeds ; import java . util . List ; import org . restlet . test . ext . odata . cafecustofeeds . Contact ; import org . restlet . test . ext . odata . cafecustofeeds . Item ; public class Cafe { private String city ; private String companyName ; private String id ; private String name ; private int zipCode ; private Contact contact ; private List < Item > items ; public Cafe ( ) { super ( ) ; } public Cafe ( String id ) { this ( ) ; this . id = id ; } public String getCity ( ) { return city ; } public String getCompanyName ( ) { return companyName ; } public String getId ( ) { return id ; } public String getName ( ) { return name ; } public int getZipCode ( ) { return zipCode ; } public Contact getContact ( ) { return contact ; } public List < Item > getItems ( ) { return items ; } public void setCity ( String city ) { this . city = city ; } public void setCompanyName ( String companyName ) { this . companyName = companyName ; } public", "gt": "void setId ( String id )", "prediction": "void setId ( String id )\n", "label": 1}
{"id": 3917, "input": "<s> package com . gisgraphy . client . administrativedivision ; import org . apache . commons . lang . Validate ; import org . apache . commons . lang . builder . EqualsBuilder ; import org . apache . commons . lang . builder . HashCodeBuilder ; import org . apache . commons . lang . builder . ToStringBuilder ; import org . apache . commons . lang . builder . ToStringStyle ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import com . gisgraphy . client . commons . NamePart ; import com . gisgraphy . client . gisfeature . AdministrativeEntity ; import com . gisgraphy . client . gisfeature . AlternateGisFeatureName ; import com . gisgraphy . client . gisfeature . EfficientGisFeatureProvider ; import com . gisgraphy . client . gisfeature . GeonamesGisFeature ; import com . gisgraphy . client . gisfeature . GisFeature ; import com . gisgraphy . client . gisfeature . GisFeatureProvider ; import com . gisgraphy . client . gisfeature . GisFeatureType ; import com . gisgraphy . client . gisfeature . InMemoryGeonamesGisFeatureProvider ; import com . gisgraphy . client . language . Iso639Language ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . ibm . icu . util . Currency ; import com . vividsolutions . jts . geom . Point ; public final class AdministrativeDivision implements AdministrativeEntity , GisFeature , CurrencyProvider { public static class AdministrativeDivisionBuilder { private String name ; private String code ; private GisFeatureProvider gisFeatureProvider ; public AdministrativeDivisionBuilder ( String name ) { this . name = name ; } public AdministrativeDivisionBuilder withCode ( String code ) { this . code = code ; return this ; } public AdministrativeDivision andGisFeature ( GeonamesGisFeature gisFeature ) { this . gisFeatureProvider = new InMemoryGeonamesGisFeatureProvider ( gisFeature ) ; return build ( ) ; } public AdministrativeDivision andGisFeatureProvider ( GisFeatureProvider gisFeatureProvider ) { this . gisFeatureProvider = gisFeatureProvider ; return build ( ) ; } private AdministrativeDivision build ( ) { return new AdministrativeDivision ( this . name , this . code , this . gisFeatureProvider ) ; } } public static AdministrativeDivisionBuilder administrativeDivision ( String name ) { return new AdministrativeDivisionBuilder ( name ) ; } private String name ; private String code ; private GisFeatureProvider gisFeatureProvider ; private AdministrativeDivision ( String name , String code , GisFeatureProvider gisFeatureProvider ) { super ( ) ; Validate . notEmpty ( name ) ; Validate . notEmpty ( code ) ; Validate . notNull ( gisFeatureProvider . getGisFeatureId ( ) ) ; if ( EfficientGisFeatureProvider . class . isAssignableFrom ( gisFeatureProvider . getClass ( ) ) ) { Validate . notNull ( gisFeatureProvider . getGisFeature ( ) . getParentAdministrativeEntity ( ) ) ; } this . name = name ; this . code = code ; this . gisFeatureProvider = gisFeatureProvider ; } public String getName ( ) { return name ; } public String getCode ( ) { return code ; } public GisFeature getGisFeature ( ) { return gisFeature ( ) ; } private GisFeature gisFeature ( ) { return gisFeatureProvider . getGisFeature ( ) ; } public AdministrativeEntity getParentEntity ( ) { return gisFeature ( ) . getParentAdministrativeEntity ( ) ; } @ Override public String toString ( ) { return new ToStringBuilder ( this , ToStringStyle . SHORT_PREFIX_STYLE ) . append ( \"code\" , code ) . append ( \"name\" , name ) . append ( \"gisFeature\" , gisFeatureProvider ) . toString ( ) ; } @ Override public int hashCode ( ) { return gisFeatureProvider . gisFeatureHashCode ( ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; AdministrativeDivision other = ( AdministrativeDivision ) obj ; return gisFeatureProvider . gisFeatureEquals ( other . gisFeatureProvider ) ; } private AdministrativeEntityHierarchy administrativeEntityLevelProvider ( ) { return new AdministrativeEntityHierarchy ( new AdministrativeEntityHierarchy . AdministrativeEntityProvider ( ) { public AdministrativeEntity getParentAdministrativeEntity ( ) { return AdministrativeDivision . this . getParentAdministrativeEntity ( ) ; } public AdministrativeEntity getCurrentAdministrativeEntity ( ) { return AdministrativeDivision . this ; } } ) ; } public int getAdminitrativeDivisionLevel ( ) { return administrativeEntityLevelProvider ( ) . getAdminitrativeDivisionLevel ( ) ; } public AdministrativeEntity getParentAdministrativeEntity ( ) { return gisFeature ( ) . getParentAdministrativeEntity ( ) ; } public AdministrativeEntity getAdministrativeEntity ( int level ) { return administrativeEntityLevelProvider ( ) . getAdministrativeEntity ( level ) ; } public Long getGeonamesId ( ) { return gisFeature ( ) . getGeonamesId ( ) ; } public ImmutableSet < AlternateGisFeatureName > getGisFeatureAlternateNames ( ) { return gisFeature ( ) . getGisFeatureAlternateNames ( ) ; } public String getGisFeatureDefaultName ( ) { return gisFeature ( ) . getGisFeatureDefaultName ( ) ; } public String getGisFeaturePreferredName ( Iso639Language language ) { return gisFeature ( ) . getGisFeaturePreferredName ( language ) ; } public String getGisFeatureShortName ( Iso639Language language ) { return gisFeature ( ) . getGisFeatureShortName ( language ) ; } public Country getCountry ( ) { return getParentAdministrativeEntity ( ) . getCountry ( ) ; } public Long getElevation ( ) { return gisFeature ( ) . getElevation ( ) ; } public GisFeatureType getGisFeatureType ( ) { return gisFeature ( ) . getGisFeatureType ( ) ; } public Long getGtopo30AverageElevation ( ) { return gisFeature ( ) . getGtopo30AverageElevation ( ) ; } public DateTime getLastModificationDate ( ) { return gisFeature ( ) . getLastModificationDate ( ) ; } public double getLatitude ( ) { return gisFeature ( ) . getLatitude ( ) ; } public Point getLocation ( ) { return gisFeature ( ) . getLocation ( ) ; } public double getLongitude ( ) { return gisFeature ( ) . getLongitude ( ) ; } public Long getPopulation ( ) { return gisFeature ( ) . getPopulation ( ) ; } public DateTimeZone getTimeZone ( ) { return gisFeature ( ) . getTimeZone ( ) ; } public Currency getCurrency ( ) { return getCountry ( ) . getCurrency ( ) ; } public ImmutableList < NamePart > getFullyQualifiedNameParts ( ) { return ImmutableList . copyOf ( Iterables . concat ( getParentAdministrativeEntity ( ) . getFullyQualifiedNameParts ( ) , ImmutableList . of ( new NamePart ( getName ( ) , getFriendlyCode ( ) ) ) ) ) ; }", "gt": "public String getFriendlyCode ( )", "prediction": "}\n", "label": 0}
{"id": 16053, "input": "<s> package org . apache . lucene . search ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; class BooleanScorer2 extends Scorer { private final List requiredScorers ; private final List optionalScorers ; private final List prohibitedScorers ; private class Coordinator { float [ ] coordFactors = null ; int maxCoord = 0 ; int nrMatchers ; void init ( ) { coordFactors = new float [ maxCoord + 1 ] ; Similarity sim = getSimilarity ( ) ; for ( int i = 0 ; i <= maxCoord ; i ++ ) { coordFactors [ i ] = sim . coord ( i , maxCoord ) ; } } } private final Coordinator coordinator ; private final Scorer countingSumScorer ; private final int minNrShouldMatch ; private int doc = - 1 ; private int [ ] sorts = new int [ Scorer . numSort ] ; public BooleanScorer2 ( Similarity similarity , int minNrShouldMatch , List required , List prohibited , List optional ) throws IOException { super ( similarity ) ; if ( minNrShouldMatch < 0 ) { throw new IllegalArgumentException ( \"Minimum number of optional scorers should not be negative\" ) ; } coordinator = new Coordinator ( ) ; this . minNrShouldMatch = minNrShouldMatch ; optionalScorers = optional ; coordinator . maxCoord += optional . size ( ) ; requiredScorers = required ; coordinator . maxCoord += required . size ( ) ; prohibitedScorers = prohibited ; coordinator . init ( ) ; countingSumScorer = makeCountingSumScorer ( ) ; } private class SingleMatchScorer extends Scorer { private Scorer scorer ; private int lastScoredDoc = - 1 ; private float lastDocScore = Float . NaN ; SingleMatchScorer ( Scorer scorer ) { super ( scorer . getSimilarity ( ) ) ; this . scorer = scorer ; } public float score ( ) throws IOException { int doc = docID ( ) ; if ( doc >= lastScoredDoc ) { if ( doc > lastScoredDoc ) { lastDocScore = scorer . score ( ) ; lastScoredDoc = doc ; } coordinator . nrMatchers ++ ; } return lastDocScore ; } public int doc ( ) { return scorer . doc ( ) ; } public int docID ( ) { return scorer . docID ( ) ; } public boolean next ( ) throws IOException { return scorer . nextDoc ( ) != NO_MORE_DOCS ; } public int nextDoc ( ) throws IOException { return scorer . nextDoc ( ) ; } public boolean skipTo ( int docNr ) throws IOException { return scorer . advance ( docNr ) != NO_MORE_DOCS ; } public int advance ( int target ) throws IOException { return scorer . advance ( target ) ; } public Explanation explain ( int docNr ) throws IOException { return scorer . explain ( docNr ) ; } public int getSort ( int fieldNumber ) { return this . scorer . getSort ( fieldNumber ) ; } public int [ ] getSorts ( ) { return this . scorer . getSorts ( ) ; } } private Scorer countingDisjunctionSumScorer ( final List scorers , int minNrShouldMatch ) throws IOException { return new DisjunctionSumScorer ( scorers , minNrShouldMatch ) { private int lastScoredDoc = - 1 ; private float lastDocScore = Float . NaN ; public float score ( ) throws IOException { int doc = docID ( ) ; if ( doc >= lastScoredDoc ) { if ( doc > lastScoredDoc ) { lastDocScore = super . score ( ) ; lastScoredDoc = doc ; } coordinator . nrMatchers += super . nrMatchers ; } return lastDocScore ; } } ; } private static final Similarity defaultSimilarity = Similarity . getDefault ( ) ; private Scorer countingConjunctionSumScorer ( List requiredScorers ) throws IOException { final int requiredNrMatchers = requiredScorers . size ( ) ; return new ConjunctionScorer ( defaultSimilarity , requiredScorers ) { private int lastScoredDoc = - 1 ; private float lastDocScore = Float . NaN ; public float score ( ) throws IOException { int doc = docID ( ) ; if ( doc >= lastScoredDoc ) { if ( doc > lastScoredDoc ) { lastDocScore = super . score ( ) ; lastScoredDoc = doc ; } coordinator . nrMatchers += requiredNrMatchers ; } return lastDocScore ; } } ; } private Scorer dualConjunctionSumScorer ( Scorer req1 , Scorer req2 ) throws IOException { return new ConjunctionScorer ( defaultSimilarity , new Scorer [ ] { req1 , req2 } ) ; } private Scorer makeCountingSumScorer ( ) throws IOException { return ( requiredScorers . size ( ) == 0 ) ? makeCountingSumScorerNoReq ( ) : makeCountingSumScorerSomeReq ( ) ; } private Scorer makeCountingSumScorerNoReq ( ) throws IOException { int nrOptRequired = ( minNrShouldMatch < 1 ) ? 1 : minNrShouldMatch ; Scorer requiredCountingSumScorer ; if ( optionalScorers . size ( ) > nrOptRequired ) requiredCountingSumScorer = countingDisjunctionSumScorer ( optionalScorers , nrOptRequired ) ; else if ( optionalScorers . size ( ) == 1 ) requiredCountingSumScorer = new SingleMatchScorer ( ( Scorer ) optionalScorers . get ( 0 ) ) ; else requiredCountingSumScorer = countingConjunctionSumScorer ( optionalScorers ) ; return addProhibitedScorers ( requiredCountingSumScorer ) ; } private Scorer makeCountingSumScorerSomeReq ( ) throws IOException { if ( optionalScorers . size ( ) == minNrShouldMatch ) { ArrayList allReq = new ArrayList ( requiredScorers ) ; allReq . addAll ( optionalScorers ) ; return addProhibitedScorers ( countingConjunctionSumScorer ( allReq ) ) ; } else { Scorer requiredCountingSumScorer = requiredScorers . size ( ) == 1 ? new SingleMatchScorer ( ( Scorer ) requiredScorers . get ( 0 ) ) : countingConjunctionSumScorer ( requiredScorers ) ; if ( minNrShouldMatch > 0 ) { return addProhibitedScorers ( dualConjunctionSumScorer ( requiredCountingSumScorer , countingDisjunctionSumScorer ( optionalScorers , minNrShouldMatch ) ) ) ; } else { return new ReqOptSumScorer ( addProhibitedScorers ( requiredCountingSumScorer ) , optionalScorers . size ( ) == 1 ? new SingleMatchScorer ( ( Scorer ) optionalScorers . get ( 0 ) ) : countingDisjunctionSumScorer ( optionalScorers , 1 ) ) ; } } } private Scorer addProhibitedScorers ( Scorer requiredCountingSumScorer ) throws IOException { return ( prohibitedScorers . size ( ) == 0 ) ? requiredCountingSumScorer : new ReqExclScorer ( requiredCountingSumScorer , ( ( prohibitedScorers . size ( ) == 1 ) ? ( Scorer ) prohibitedScorers . get ( 0 ) : new DisjunctionSumScorer ( prohibitedScorers ) ) ) ; } public void score ( HitCollector hc ) throws IOException { score ( new HitCollectorWrapper ( hc ) ) ; } public void score ( Collector collector ) throws IOException { collector . setScorer ( this ) ; doc = countingSumScorer . nextDoc ( ) ; copySorts ( ) ; while ( doc != NO_MORE_DOCS ) { collector . collect ( doc ,", "gt": "countingSumScorer . getSorts ( ) ) ;", "prediction": "collector ) ;\n", "label": 1}
{"id": 4733, "input": "<s> package org . apache . felix . resolver ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . SortedSet ; import org . osgi . framework . resource . Capability ; import org . osgi . framework . resource . Requirement ; import org . osgi . framework . resource . Resource ; import org . osgi . framework . resource . Wire ; import org . osgi . service . resolver . Resolver ; public interface FelixResolver extends Resolver { Map < Resource , List < Wire > > resolve ( FelixEnvironment env , Collection < ? extends Resource > mandatoryRevisions , Collection < ? extends Resource > optionalRevisions", "gt": ", Collection < ? extends Resource > ondemandFragments ) ;", "prediction": ") ;\n", "label": 0}
{"id": 16060, "input": "<s> package org . seage . problem . qap . tabusearch ; import org . seage . metaheuristic . tabusearch . * ; public class QapMoveManager implements MoveManager { @ Override public Move [ ] getAllMoves ( Solution solution ) { Integer [ ] assign = ( ( QapSolution ) solution ) . _assign ; Move [ ] buffer = new Move [ assign . length * assign . length ] ; int nextBufferPos = 0 ; for ( int i = 1 ; i < assign . length ; i ++ ) for ( int j =", "gt": "- assign . length / 5 ;", "prediction": "0 ;\n", "label": 1}
{"id": 9782, "input": "<s> package com . sun . mirror . apt ; import java . util . Collection ; import java . util . Map ; import com . sun . mirror . declaration . * ; import com . sun . mirror . util . * ; @ Deprecated @ SuppressWarnings ( \"deprecation\" ) public interface AnnotationProcessorEnvironment { Map < String , String > getOptions ( ) ; Messager getMessager ( ) ; Filer getFiler ( ) ; Collection < TypeDeclaration > getSpecifiedTypeDeclarations ( ) ; PackageDeclaration getPackage ( String name ) ; TypeDeclaration getTypeDeclaration ( String name ) ; Collection", "gt": "< TypeDeclaration > getTypeDeclarations ( ) ;", "prediction": "< TypeDeclaration > getTypeDeclarationNames ( ) ;\n", "label": 0}
{"id": 16061, "input": "<s> package org . restlet . test . ext . rdf ; import org . restlet . data . MediaType ; import org . restlet . ext . rdf . RdfRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . test . RestletTestCase ; public class RdfTestCase extends RestletTestCase { public void testN3 ( ) throws Exception { Representation rep = new StringRepresentation ( \"@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\" + \"@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.\" + \"@prefix cfg: <http://www.w3.org/2000/10/swap/grammar/bnf#>.\" + \"@prefix : <http://www.w3.org/2000/10/swap/grammar/n3#>.\" + \"@prefix n3: <http://www.w3.org/2000/10/swap/grammar/n3#>.\" + \"@prefix list: <http://www.w3.org/2000/10/swap/list#>.\" + \"@prefix doc: <http://www.w3.org/2000/10/swap/pim/doc#>.\" + \"@prefix dc: <http://purl.org/dc/elements/1.1/>.\" + \"@prefix type: <http://www.w3.org/2001/XMLSchema/#>.\" + \"@keywords a, is, of.\" + \"@base    <tru   c>.\\n\" + \"#Directive base.\\n\" + \"@prefix prefix <http://www . \\nexample .com>.\\n\\n\" + \" _:x1 has <http://www.rdf.com> :x2. \" + \" :x3 has _:x4 <http://www.example.com>; _:x5 <http://www.examplewith;.com>, <http://www.examplewith,.com>. \" + \" _:x6 has <http://www.rdf.com/language> <http://www.deutsch.com>. \" + \" <http://www.rdf.com/language> = <http://www.language.com>. \" + \" <http://www.rdf.com/language> => <http://www.implies.com>. \" + \" <http://www.language.com> <= <http://www.rdf.com/language>. \" + \":x7 <http://rdf.com> \\\"string\\\". \" + \":x8 <http://www.multiline.com> \\\"\\\"\\\"str\\ning\\\"\\\"\\\". \" + \":x9 <= \\\"\\\"\\\"str\\ning\\\"\\\"\\\". \" + \":x10 @is <http://rdf.com> of <http://www.example.com>. \" + \":x11^:x12. \" + \":x13^:x14^:x15. \" + \":x16^:x17 :x18 :x19. \" + \":x20!:x21.\" + \":x22!:x23!:x24. \" + \"[] :x25 :x26.\" + \"[:x27 :x28].\" + \"(:x29 :x30) :x31 :x32.\" + \" _:x33 <http://www.rdf.com> \\\"12\\\"^^type:int. \" + \" _:x33 <http://www.rdf.com> 12. \" , MediaType . TEXT_RDF_N3 ) ;", "gt": "Representation n3Rep = new RdfRepresentation ( rep ) ;", "prediction": "}\n", "label": 1}
{"id": 9602, "input": "<s> package com . sun . tools . doclets . internal . toolkit . util ; import com . sun . javadoc . * ; public class CommentedMethodFinder extends MethodFinder { public boolean isCorrectMethod ( MethodDoc method ) { return", "gt": "method . inlineTags ( ) . length > 0 ;", "prediction": "true ;\n", "label": 0}
{"id": 16068, "input": "<s> package net . claribole . zgrviewer . dot ; class Shape { static final int NONE = 0 ; static final int NORMAL = 1 ; static final int INV = 2 ; static final int BOX = 3 ; static final int CROW = 4 ; static final int DIAMOND = 5 ; static final int DOT = 6 ; static final int TEE = 7 ; static final int VEE = 8 ; static final int BOTH = 9 ; static final int LEFT = 10 ; static final int RIGHT = 11 ; final static String [ ] attributeNames = { \"none\" , \"normal\" , \"inv\" , \"box\" , \"crow\" , \"diamond\" , \"dot\" , \"tee\" , \"vee\" , \"\" , \"l\" , \"r\" } ; int shape ; int side ; boolean fill ; public Shape ( int shape ) { this . shape = shape ; this . side = BOTH ; this . fill = true ; } private String printNamedOption ( int i ) {", "gt": "return Shape . attributeNames [ i ] ;", "prediction": "super ( i ) ;\n", "label": 1}
{"id": 1005, "input": "<s> package javax . lang . model . util ; import javax . lang . model . type . * ; public abstract class AbstractTypeVisitor7 < R , P > extends AbstractTypeVisitor6 < R , P > { protected AbstractTypeVisitor7 ( ) { super ( ) ; } public", "gt": "abstract R visitUnion ( UnionType t , P p ) ;", "prediction": "AbstractTypeVisitor7 ( )\n", "label": 0}
{"id": 16082, "input": "<s> package org . restlet . test . resource ; import org . restlet . resource . ClientResource ; import org . restlet . resource . Finder ; import org . restlet . test . RestletTestCase ; public class AnnotatedResource13TestCase extends RestletTestCase { private ClientResource clientResource ; private MyResource13 myResource ; protected void setUp ( ) throws Exception { super . setUp ( ) ; Finder finder = new Finder ( ) ; finder . setTargetClass ( MyServerResource13 . class ) ; this . clientResource = new ClientResource ( \"http://local\" ) ; this . clientResource . setNext ( finder ) ; this . myResource = clientResource . wrap ( MyResource13 . class ) ; } @ Override protected void tearDown ( ) throws Exception { clientResource = null ; myResource = null ; super . tearDown ( ) ; } public void testQuery ( ) {", "gt": "Contact contact = myResource . retrieve ( ) ;", "prediction": "try\n", "label": 1}
{"id": 1677, "input": "<s> import java . util . * ; class CastTest { private interface CA < T > { } private interface CB < T > extends CA < T > { } private interface CC < T > extends CA < T > { } private class CD < T > implements CB < T > { } private interface CE < T > extends CC < T > { } private interface CF < S > { } private interface CG < T > { } private class CH < S , T > implements CF < S > , CG < T > { } private interface CI < S > extends CF < S > { } private interface CJ < T > extends CG < T > { } private interface CK < S , T > extends CI <", "gt": "S > , CJ < T >", "prediction": "T >\n", "label": 0}
{"id": 16088, "input": "<s> package org . mitre . openid . connect . repository ; import java . util . Collection ; import org . mitre . openid . connect . model . ApprovedSite ; public interface ApprovedSiteRepository { public ApprovedSite getById ( Long id ) ; public Collection < ApprovedSite > getAll ( ) ; public ApprovedSite getByClientIdAndUserId ( String clientId , String userId ) ; public void remove ( ApprovedSite approvedSite ) ; public ApprovedSite save ( ApprovedSite approvedSite ) ; public Collection < ApprovedSite", "gt": "> getByUserId ( String userId ) ;", "prediction": "> getAll ( ) ;\n", "label": 1}
{"id": 4693, "input": "<s> package org . remast . baralga . gui . actions ; import java . awt . event . ActionEvent ; import java . awt . event . InputEvent ; import javax . swing . ImageIcon ; import javax . swing . KeyStroke ; import org . remast . baralga . gui . model . edit . EditStack ; import org . remast . util . TextResourceBundle ; @ SuppressWarnings ( \"serial\" ) public class UndoAction extends AbstractEditAction { private static final TextResourceBundle textBundle = TextResourceBundle . getBundle ( UndoAction . class ) ; public UndoAction ( final EditStack editStack ) { super ( editStack ) ; resetText ( ) ; putValue ( SMALL_ICON , new ImageIcon ( getClass ( ) . getResource ( \"/icons/gtk-undo-ltr.png\" ) ) ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( 'Z' , InputEvent . CTRL_MASK ) ) ; } @ Override public final void actionPerformed ( final ActionEvent e ) { undo ( ) ; } public void setText ( final String name ) { putValue", "gt": "( NAME , name ) ;", "prediction": "( SMALL_ICON , new ImageIcon ( getClass ( ) . getResource ( \"/icons/gtk-undo-ltr.png\" ) ) ) ;\n", "label": 0}
{"id": 16092, "input": "<s> package org . apache . lucene . index ; import java . io . Serializable ; public class TermVectorOffsetInfo implements Serializable { public transient static final TermVectorOffsetInfo [ ] EMPTY_OFFSET_INFO = new TermVectorOffsetInfo [ 0 ] ; private int startOffset ; private int endOffset ; public TermVectorOffsetInfo ( ) { } public TermVectorOffsetInfo ( int startOffset , int endOffset ) { this . endOffset = endOffset ; this . startOffset = startOffset ; } public int getEndOffset ( ) { return endOffset ; } public void setEndOffset ( int endOffset ) { this . endOffset = endOffset ; } public int getStartOffset ( ) { return startOffset ; } public void setStartOffset ( int startOffset ) { this . startOffset = startOffset ; } public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof TermVectorOffsetInfo", "gt": ") ) return false ;", "prediction": ") ) return false ;\n", "label": 1}
{"id": 7590, "input": "<s> package com . gisgraphy . client . nameformatters ; import static com . gisgraphy . client . commons . NameProviderObjectMother . losAngelesNameProvider ; import static com . gisgraphy . client . commons . NameProviderObjectMother . twoPartsNameProvider ; import org . junit . Assert ; import org . junit . Test ; public class ShortQualifiedNamesExtractorTest { @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowExtractingNamesWithLessThanThreeParts ( ) { new ShortQualifiedNamesExtractor ( ) . extractNames ( twoPartsNameProvider ( ) . getFullyQualifiedNameParts ( ) ) . toString ( ) ; } @ Test public void shouldExtractCountryAdm1AndCity ( ) { Assert . assertEquals ( \"[United States, California, Los Angeles]\" , new ShortQualifiedNamesExtractor ( ) . extractNames ( losAngelesNameProvider ( ) . getFullyQualifiedNameParts ( ) )", "gt": ". toString ( ) ) ;", "prediction": ". toString ( ) ) ;\n", "label": 0}
{"id": 16107, "input": "<s> package org . powerbot . game . api . methods ; import java . awt . Canvas ; import java . awt . Point ; import org . powerbot . game . api . methods . interactive . Players ; import org . powerbot . game . api . methods . widget . WidgetComposite ; import org . powerbot . game . api . util . internal . Multipliers ; import org . powerbot . game . api . wrappers . Locatable ; import org . powerbot . game . api . wrappers . RegionOffset ; import org . powerbot . game . api . wrappers . Tile ; import org . powerbot . game . api . wrappers . interactive . Player ; import org . powerbot . game . api . wrappers . widget . WidgetChild ; import org . powerbot . game . bot . Context ; import org . powerbot . game . client . Client ; import org . powerbot . game . client . RSGroundByts ; import org . powerbot . game . client . RSGroundInfo ; import org . powerbot . game . client . RSInfo ; import org . powerbot . game . client . TileData ; public class Calculations { public static class Toolkit { public float absoluteX , absoluteY ; public float xMultiplier , yMultiplier ; } public static class Viewport { public float xOff , xX , xY , xZ ; public float yOff , yX , yY , yZ ; public float zOff , zX , zY , zZ ; } public static final int [ ] SIN_TABLE = new int [ 0x4000 ] ; public static final int [ ] COS_TABLE = new int [ 0x4000 ] ; static { final double d = 0.00038349519697141029D ; for ( int i = 0 ; i < 0x4000 ; i ++ ) { Calculations . SIN_TABLE [ i ] = ( int ) ( 32768D * Math . sin ( i * d ) ) ; Calculations . COS_TABLE [ i ] = ( int ) ( 32768D * Math . cos ( i * d ) ) ; } } public static int calculateTileHeight ( final int x , final int y , int plane ) { final Client client = Context . client ( ) ; final int x1 = x > > 9 ; final int y1 = y > > 9 ; try { final byte [ ] [ ] [ ] settings = ( byte [ ] [ ] [ ] ) ( ( RSGroundByts ) ( ( RSInfo ) client . getRSGroundInfo ( ) ) . getGroundBytes ( ) ) . getBytes ( ) ; if ( settings != null && x1 >= 0 && x1 < 104 && y1 >= 0 && y1 < 104 ) { if ( plane <= 3 && ( settings [ 1 ] [ x1 ] [ y1 ] & 2 ) != 0 ) { ++ plane ; } final TileData [ ] planes = ( TileData [ ] ) ( ( RSGroundInfo ) ( ( RSInfo ) client . getRSGroundInfo ( ) ) . getRSGroundInfo ( ) ) . getTileData ( ) ; if ( planes != null && plane < planes . length && planes [ plane ] != null ) { final int [ ] [ ] heights = planes [ plane ] . getHeights ( ) ; if ( heights != null ) { final int x2 = x & 0x200 - 1 ; final int y2 = y & 0x200 - 1 ; final int start_h = heights [ x1 ] [ y1 ] * ( 0x200 - x2 ) + heights [ x1 + 1 ] [ y1", "gt": "] * x2 > > 9 ;", "prediction": "+ 1 ] [ y1 + 1 ] ;\n", "label": 1}
{"id": 6195, "input": "<s> package org . ofbiz . hhfacility ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import javax . servlet . ServletContext ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . LocalDispatcher ; import org . ofbiz . service . ServiceUtil ; import org . ofbiz . webapp . control . RequestHandler ; public class FacilitySession { public static final String module = FacilitySession . class . getName ( ) ; public static final String findProductsById ( HttpServletRequest request , HttpServletResponse response ) { String idValueStr = request . getParameter ( \"idValue\" ) ; String facilityIdStr = request . getParameter ( \"facilityId\" ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( \"dispatcher\" ) ; if ( UtilValidate . isEmpty ( idValueStr ) ) { return \"success\" ; } Map < String , Object > productsMap = null ; try { productsMap = dispatcher . runSync ( \"findProductsById\" , UtilMisc . toMap ( \"idValue\" , idValueStr , \"facilityId\" , facilityIdStr ) ) ; } catch ( GenericServiceException e ) { Debug . logError ( e , \"Problem in findProductsById\" , module ) ; return \"error\" ; } if ( ServiceUtil . isError ( productsMap ) ) { return \"error\" ; } List < GenericValue > productList = UtilGenerics . checkList ( productsMap . get ( \"productList\" ) , GenericValue . class ) ; if ( productList != null && productList . size ( ) == 1 ) { ServletContext ctx = ( ServletContext ) request . getAttribute ( \"servletContext\" ) ; RequestHandler rh = ( RequestHandler ) ctx . getAttribute ( \"_REQUEST_HANDLER_\" ) ; GenericValue product = EntityUtil . getFirst ( productList ) ; String requestName = \"/productstocktake?facilityId=\" + facilityIdStr + \"&productId=\" + product . getString ( \"productId\" ) ; String target = rh . makeLink ( request , response , requestName , false , false , false ) ; try { response . sendRedirect ( target ) ; return \"none\" ; }", "gt": "catch ( IOException e )", "prediction": "catch ( ServiceUtilException e )\n", "label": 0}
{"id": 16109, "input": "<s> package org . eclipse . ui ; import java . util . EventListener ; import org . eclipse . jface . viewers . ISelection ; public interface ISelectionListener extends EventListener { public void", "gt": "selectionChanged ( IWorkbenchPart part , ISelection selection ) ;", "prediction": "setUp ( ) ;\n", "label": 1}
{"id": 10111, "input": "<s> package jns . trace ; import jns . util . IPAddr ; import jns . util . Status ; import java . io . BufferedWriter ; import java . io . IOException ; import java . util . Hashtable ; public class JavisLinkHandler extends JavisHandler { public JavisLinkHandler ( ) { m_parameter = new Hashtable ( ) ; m_parameter . put ( \"Source Address\" , new Integer ( 0 ) ) ; m_parameter . put ( \"Destination Address\" , new Integer ( 1 ) ) ; m_parameter . put ( \"State\" , new Integer ( 2 ) ) ; } public void handleEvent ( Event e , BufferedWriter w ) throws IOException { int index = 0 ; w . write ( \"l -t \" + e . getTime ( ) ) ; EventParameter parameter = e . getParameter ( index ) ; while ( parameter != null ) { Integer id = ( Integer ) m_parameter . get ( parameter . name ) ; if ( id != null ) switch ( id . intValue ( ) ) { case 0 : w . write ( \" -s \" + translateIP ( ( IPAddr ) parameter . value ) ) ; break ; case 1 : w . write ( \" -d \" + translateIP ( ( IPAddr", "gt": ") parameter . value ) ) ;", "prediction": ") parameter . value ) ) ;\n", "label": 0}
{"id": 16110, "input": "<s> package org . restlet . ext . odata . internal . edm ; public class Mapping { private boolean attributeValue ; private String contentKind ; private String nsPrefix ; private String nsUri ; private String propertyPath ; private EntityType type ; private String valuePath ; public Mapping ( EntityType type , String nsPrefix , String nsUri , String propertyPath , String valuePath , String contentKind ) { super ( ) ; this . type = type ; this . nsPrefix = nsPrefix ; this . nsUri = nsUri ; this . propertyPath = propertyPath ; this . valuePath = valuePath ; this . contentKind = contentKind ; this . attributeValue = false ; if ( this . valuePath != null ) { int index = valuePath . lastIndexOf ( \"/\" ) ; if ( index != - 1 && valuePath . length ( ) > index ) { attributeValue = ( '@' == valuePath . charAt ( index + 1 ) ) ; } } } public String getContentKind ( ) { return contentKind ; } public String getNsPrefix ( ) { return nsPrefix ; } public String getNsUri ( ) { return nsUri ; } public String getPropertyPath ( ) { return propertyPath ; } public EntityType getType ( ) { return type ; } public String getValueAttributeName ( ) { String result = null ; if", "gt": "( isAttributeValue ( ) )", "prediction": "( valuePath != null )\n", "label": 1}
{"id": 3333, "input": "<s> package org . ofbiz . content . webapp . ftl ; import java . io . IOException ; import java . io . Writer ; import java . util . Locale ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . UtilHttp ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . template . FreeMarkerWorker ; import org . ofbiz . content . content . ContentWorker ; import org . ofbiz . entity . Delegator ; import org . ofbiz . service . LocalDispatcher ; import freemarker . core . Environment ; import freemarker . template . TemplateTransformModel ; public class RenderContentAndSubContent implements TemplateTransformModel { public static final String module = RenderContentAndSubContent . class . getName ( ) ; @ SuppressWarnings ( \"unchecked\" ) public Writer getWriter ( final Writer out , Map args ) { final Environment env = Environment . getCurrentEnvironment ( ) ; final LocalDispatcher dispatcher = FreeMarkerWorker . getWrappedObject ( \"dispatcher\" , env ) ; final Delegator delegator = FreeMarkerWorker . getWrappedObject ( \"delegator\" , env ) ; final HttpServletRequest request = FreeMarkerWorker . getWrappedObject ( \"request\" , env ) ; final Map < String , Object > envMap = FreeMarkerWorker . createEnvironmentMap ( env ) ; final MapStack < String > templateRoot = MapStack . create ( ) ; ( ( MapStack ) templateRoot ) . push ( envMap ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"in RenderContentAndSubContent, contentId(0):\" + templateRoot . get ( \"contentId\" ) , module ) ; FreeMarkerWorker . getSiteParameters ( request , templateRoot ) ; FreeMarkerWorker . overrideWithArgs ( templateRoot , args ) ; return new Writer ( out ) { @ Override public void write ( char cbuf [ ] , int off , int len ) { } @ Override public void flush ( ) throws IOException { out . flush ( ) ; } @ Override public void close ( ) throws IOException { renderSubContent ( ) ; } public void renderSubContent ( ) throws IOException { String mimeTypeId = ( String ) templateRoot . get ( \"mimeTypeId\" ) ; Object localeObject = templateRoot . get ( \"locale\" ) ; Locale locale = null ; if ( localeObject == null ) { locale = UtilHttp . getLocale ( request ) ; } else { locale = UtilMisc . ensureLocale ( localeObject ) ; } if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"in RenderContentAndSubContent, contentId(2):\" + templateRoot . get ( \"contentId\" ) , module ) ; if ( Debug . verboseOn ( ) ) Debug . logVerbose ( \"in RenderContentAndSubContent, subContentId(2):\" + templateRoot . get ( \"subContentId\" ) , module ) ; try { String contentId = ( String ) templateRoot . get ( \"contentId\" ) ; String mapKey = ( String ) templateRoot . get ( \"mapKey\" ) ; String contentAssocTypeId = ( String ) templateRoot . get ( \"contentAssocTypeId\" ) ; if ( UtilValidate . isNotEmpty ( mapKey ) || UtilValidate . isNotEmpty ( contentAssocTypeId ) ) { String txt = ContentWorker . renderSubContentAsText ( dispatcher , delegator , contentId , mapKey , templateRoot , locale , mimeTypeId , true ) ; out . write ( txt ) ; } else if ( contentId != null ) { ContentWorker . renderContentAsText ( dispatcher , delegator , contentId , out , templateRoot , locale ,", "gt": "mimeTypeId , null , null , true ) ;", "prediction": "txt ) ;\n", "label": 0}
{"id": 16111, "input": "<s> package org . eclipse . ui . tests . stress ; import junit . framework . Test ; import junit . framework . TestSuite ; public class OpenCloseTestSuite extends TestSuite { public static Test suite ( ) { return new OpenCloseTestSuite ( ) ; } public OpenCloseTestSuite ( ) { addTest ( new TestSuite ( OpenCloseTest", "gt": ". class ) ) ;", "prediction": "Suite . class ) ) ;\n", "label": 1}
{"id": 7648, "input": "<s> package ar . com . fdvs . dj . util ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class StreamUtils { public static final int DEFAULT_BUFFER_SIZE = 2048 ; public static void copy ( InputStream input , OutputStream output ) throws IOException { copy ( input , output , DEFAULT_BUFFER_SIZE ) ; } public static void copy ( InputStream input , OutputStream output , int bufferSize ) throws IOException { byte [ ] buf = new byte [ bufferSize ] ; int bytesRead = input . read ( buf ) ; while ( bytesRead != - 1 ) { output . write ( buf , 0 , bytesRead ) ; bytesRead = input . read ( buf ) ; } output . flush ( ) ; } public static void copyThenClose ( InputStream input , OutputStream output ) throws IOException { copy ( input , output ) ; input . close ( ) ; output . close ( ) ; } public static byte [ ] getBytes ( InputStream input ) throws IOException { ByteArrayOutputStream result =", "gt": "new ByteArrayOutputStream ( ) ;", "prediction": "new ByteArrayOutputStream ( ) ;\n", "label": 0}
{"id": 16119, "input": "<s> package org . eclipse . jface . tests . wizards ; import org . eclipse . jface . wizard . Wizard ; public class TheTestWizard extends Wizard { public TheTestWizardPage page1 ; public TheTestWizardPage page2 ; public TheTestWizardPage page3 ; public final String page1Name = \"PAGE1\" ; public final String page2Name = \"PAGE2\" ; public final String page3Name = \"PAGE3\" ; private boolean throwExceptionOnDispose ; public TheTestWizard ( ) { super ( ) ; setNeedsProgressMonitor ( true ) ; } public void addPages ( ) { page1 = new TheTestWizardPage ( page1Name ) ; addPage ( page1 ) ; page2 = new TheTestWizardPage ( page2Name ) ; addPage ( page2 ) ; page3 = new TheTestWizardPage ( page3Name ) ; addPage ( page3 ) ; } public boolean performFinish ( ) { WizardTest . DID_FINISH = true ; return true ; } public void setThrowExceptionOnDispose ( boolean throwExceptionOnDispose ) { this . throwExceptionOnDispose = throwExceptionOnDispose ; } public void dispose ( ) { super . dispose ( ) ;", "gt": "if ( throwExceptionOnDispose ) throw new NullPointerException ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6652, "input": "<s> package org . ofbiz . entity . jdbc ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Reader ; import java . nio . ByteBuffer ; import java . sql . Blob ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Timestamp ; import java . sql . Types ; import java . util . Map ; import javax . sql . rowset . serial . SerialBlob ; import javolution . util . FastMap ; import org . ofbiz . base . util . Debug ; public abstract class JdbcValueHandler < T > { public static final String module = JdbcValueHandler . class . getName ( ) ; private static final Map < String , JdbcValueHandler < ? > > JdbcValueHandlerMap = createJdbcValueHandlerMap ( ) ; private static final Map < String , Integer > SqlTypeMap = createSqlTypeMap ( ) ; private static Map < String , JdbcValueHandler < ? > > createJdbcValueHandlerMap ( ) { Map < String , JdbcValueHandler < ? > > result = FastMap . newInstance ( ) ; result . put ( \"byte[]\" , new ByteArrayJdbcValueHandler ( Types . LONGVARBINARY ) ) ; result . put ( \"java.lang.Boolean\" , new BooleanJdbcValueHandler ( Types . BOOLEAN ) ) ; result . put ( \"Boolean\" , new BooleanJdbcValueHandler ( Types . BOOLEAN ) ) ; result . put ( \"java.lang.Double\" , new DoubleJdbcValueHandler ( Types . DOUBLE ) ) ; result . put ( \"Double\" , new DoubleJdbcValueHandler ( Types . DOUBLE ) ) ; result . put ( \"java.lang.Float\" , new FloatJdbcValueHandler ( Types . FLOAT ) ) ; result . put ( \"Float\" , new FloatJdbcValueHandler ( Types . FLOAT ) ) ; result . put ( \"java.lang.Integer\" , new IntegerJdbcValueHandler ( Types . INTEGER ) ) ; result . put ( \"Integer\" , new IntegerJdbcValueHandler ( Types . INTEGER ) ) ; result . put ( \"java.lang.Long\" , new LongJdbcValueHandler ( Types . BIGINT ) ) ; result . put ( \"Long\" , new LongJdbcValueHandler ( Types . BIGINT ) ) ; result . put ( \"java.lang.Short\" , new ShortJdbcValueHandler ( Types . SMALLINT ) ) ; result . put ( \"Short\" , new ShortJdbcValueHandler ( Types . SMALLINT ) ) ; result . put ( \"java.lang.String\" , new StringJdbcValueHandler ( Types . CHAR ) ) ; result . put ( \"String\" , new StringJdbcValueHandler ( Types . CHAR ) ) ; result . put ( \"java.sql.Date\" , new DateJdbcValueHandler ( Types . DATE ) ) ; result . put ( \"Date\" , new DateJdbcValueHandler ( Types . DATE ) ) ; result . put ( \"java.sql.Time\" , new TimeJdbcValueHandler ( Types . TIME ) ) ; result . put ( \"Time\" , new TimeJdbcValueHandler ( Types . TIME ) ) ; result . put ( \"java.sql.Timestamp\" , new TimestampJdbcValueHandler ( Types . TIMESTAMP ) ) ; result . put ( \"Timestamp\" , new TimestampJdbcValueHandler ( Types . TIMESTAMP ) ) ; result . put ( \"java.math.BigDecimal\" , new BigDecimalJdbcValueHandler ( Types . DECIMAL ) ) ; result . put ( \"BigDecimal\" , new BigDecimalJdbcValueHandler ( Types . DECIMAL ) ) ; result . put ( \"java.sql.Blob\" , new BlobJdbcValueHandler ( Types . BLOB ) ) ; result . put ( \"Blob\" , new BlobJdbcValueHandler ( Types . BLOB ) ) ; result . put ( \"java.sql.Clob\" , new ClobJdbcValueHandler ( Types . CLOB ) ) ; result . put ( \"Clob\" , new ClobJdbcValueHandler ( Types . CLOB ) ) ; result . put ( \"java.lang.Object\" , new ObjectJdbcValueHandler ( Types . BLOB ) ) ; result . put ( \"Object\" , new ObjectJdbcValueHandler ( Types . BLOB ) ) ; return result ; } private static Map < String , Integer > createSqlTypeMap ( ) { Map < String , Integer > result = FastMap . newInstance ( ) ; result . put ( \"BIT\" , Types . BIT ) ;", "gt": "result . put ( \"BLOB\" , Types . BLOB ) ;", "prediction": "return result ;\n", "label": 0}
{"id": 16126, "input": "<s> package org . restlet . ext . slf4j ; import java . util . logging . Logger ; import org . restlet . engine . log . LoggerFacade ; import org . slf4j . LoggerFactory ; public class Slf4jLoggerFacade extends LoggerFacade { @ Override public Logger getAnonymousLogger ( ) { return new Slf4jLogger ( LoggerFactory . getLogger ( \"\" ) ) ; } @ Override public", "gt": "Logger getLogger ( String loggerName )", "prediction": "Logger getLoggerFactory ( )\n", "label": 1}
{"id": 973, "input": "<s> package org . msl . simple . gmfmap . simplemappings ; import org . eclipse . gmf . gmfgraph . Connection ; import org . eclipse . gmf . gmfgraph . DiagramLabel ; import org . eclipse . gmf . mappings . LinkMapping ; import org . eclipse . gmf . tooldef . AbstractTool ; public interface SimpleLinkMapping extends SimpleChildNode , SimpleParentNode , SimpleMappingElementWithFigure { String getName ( ) ; void setName ( String value ) ; LinkMapping getLinkMapping ( ) ; void setLinkMapping ( LinkMapping value ) ;", "gt": "Connection getDiagramLink ( ) ;", "prediction": "}\n", "label": 0}
{"id": 16137, "input": "<s> package org . fuzzydb . attrs . internal ; import org . fuzzydb . core . whirlwind . internal . IAttribute ; import org . fuzzydb . core . whirlwind . internal . IAttributeConstraint ; public abstract class Attribute < T extends Attribute < T > > extends BaseAttribute implements IAttribute , Cloneable { private static final long serialVersionUID = 371895097117898864L ; protected Attribute ( int attrId ) { super ( attrId ) ; } protected Attribute ( Attribute < ? > rhs ) { super ( rhs ) ; } @ Override public abstract T", "gt": "clone ( ) throws CloneNotSupportedException ;", "prediction": "getAttribute ( )\n", "label": 1}
{"id": 9649, "input": "<s> package org . ofbiz . pos . jpos . service ; import jpos . JposException ; import org . ofbiz . base . util . Debug ; public class NullPosPrinter extends BaseService implements jpos . services . POSPrinterService12 { protected static final String ESC = ( ( char ) 0x1b ) + \"\" ; protected static final String PAPER_CUT = ESC + \"|100fP\" ; private StringBuffer printerBuffer = new StringBuffer ( ) ; @ Override public int getDeviceServiceVersion ( ) throws JposException { return 1002000 ; } public int getCapCharacterSet ( ) throws JposException { return 0 ; } public boolean getCapConcurrentJrnRec ( ) throws JposException { return false ; } public boolean getCapConcurrentJrnSlp ( ) throws JposException { return false ; } public boolean getCapConcurrentRecSlp ( ) throws JposException { return false ; } public boolean getCapCoverSensor ( ) throws JposException { return false ; } public boolean getCapJrn2Color ( ) throws JposException { return false ; } public boolean getCapJrnBold ( ) throws JposException { return false ; } public boolean getCapJrnDhigh ( ) throws JposException { return false ; } public boolean getCapJrnDwide ( ) throws JposException { return false ; } public boolean getCapJrnDwideDhigh ( ) throws JposException { return false ; } public boolean getCapJrnEmptySensor ( ) throws JposException { return false ; } public boolean getCapJrnItalic ( ) throws JposException { return false ; } public boolean getCapJrnNearEndSensor ( ) throws JposException { return false ; } public boolean getCapJrnPresent ( ) throws JposException { return false ; } public boolean getCapJrnUnderline ( ) throws JposException { return false ; } public boolean getCapRec2Color ( ) throws JposException { return false ; } public boolean getCapRecBarCode ( ) throws JposException { return false ; } public boolean getCapRecBitmap ( ) throws JposException { return false ; } public boolean getCapRecBold ( ) throws JposException { return false ; } public boolean getCapRecDhigh ( ) throws JposException { return false ; } public boolean getCapRecDwide ( ) throws JposException { return false ; } public boolean getCapRecDwideDhigh ( ) throws JposException { return false ; } public boolean getCapRecEmptySensor ( ) throws JposException { return false ; } public boolean getCapRecItalic ( ) throws JposException { return false ; } public boolean getCapRecLeft90 ( ) throws JposException { return false ; } public boolean getCapRecNearEndSensor ( ) throws JposException { return false ; } public boolean getCapRecPapercut ( ) throws JposException { return false ; } public boolean getCapRecPresent ( ) throws JposException { return false ; } public boolean getCapRecRight90 ( ) throws JposException { return false ; } public boolean getCapRecRotate180 ( ) throws JposException { return false ; } public boolean getCapRecStamp ( ) throws JposException { return false ; } public boolean getCapRecUnderline ( ) throws JposException { return false ; } public boolean getCapSlp2Color ( ) throws JposException { return false ; } public boolean getCapSlpBarCode ( ) throws JposException { return false ; } public boolean getCapSlpBitmap ( ) throws JposException { return false ; } public boolean getCapSlpBold ( ) throws JposException { return false ; } public boolean getCapSlpDhigh ( ) throws JposException { return false ; } public boolean getCapSlpDwide ( ) throws JposException { return false ; } public boolean getCapSlpDwideDhigh ( ) throws JposException { return false ; } public boolean getCapSlpEmptySensor ( ) throws JposException { return false ; } public boolean getCapSlpFullslip ( ) throws JposException { return false ; } public boolean getCapSlpItalic ( ) throws JposException { return false ; } public boolean getCapSlpLeft90 ( ) throws JposException { return false ; } public boolean getCapSlpNearEndSensor ( ) throws JposException { return false ; } public boolean getCapSlpPresent ( ) throws JposException { return false ; } public boolean getCapSlpRight90 ( ) throws JposException { return false ; } public boolean getCapSlpRotate180 ( ) throws JposException { return false ; } public boolean getCapSlpUnderline ( ) throws JposException { return false ; } public boolean getCapTransaction ( ) throws JposException { return false ; } public boolean getAsyncMode ( ) throws JposException { return false ; } public void setAsyncMode ( boolean b ) throws JposException { } public int getCharacterSet ( ) throws JposException { return 0 ; } public void setCharacterSet ( int i ) throws JposException { } public String getCharacterSetList ( ) throws JposException { return null ; } public boolean getCoverOpen ( ) throws JposException { return false ; } public int getErrorLevel ( ) throws JposException { return 0 ; } public int getErrorStation ( ) throws JposException { return 0 ; } public String getErrorString ( ) throws JposException { return null ; } public boolean getFlagWhenIdle ( ) throws JposException { return false ; } public void setFlagWhenIdle ( boolean b ) throws JposException { } public String getFontTypefaceList ( ) throws JposException { return null ; } public boolean getJrnEmpty ( ) throws JposException { return false ; } public boolean getJrnLetterQuality ( ) throws JposException { return false ; } public void setJrnLetterQuality ( boolean b ) throws JposException { } public int getJrnLineChars ( ) throws JposException { return 0 ; } public void setJrnLineChars ( int i ) throws JposException { } public String getJrnLineCharsList ( ) throws JposException { return null ; } public int getJrnLineHeight ( ) throws JposException { return 0 ; } public void setJrnLineHeight ( int i ) throws JposException { } public int getJrnLineSpacing ( ) throws JposException { return 0 ; } public void setJrnLineSpacing ( int i ) throws JposException { } public int getJrnLineWidth ( ) throws JposException { return 0 ; } public boolean getJrnNearEnd ( ) throws JposException { return false ; } public int getMapMode ( ) throws JposException { return 0 ; } public void setMapMode ( int i ) throws JposException { } public int getOutputID ( ) throws JposException { return 0 ; } public String getRecBarCodeRotationList ( ) throws JposException { return null ; } public boolean getRecEmpty ( ) throws JposException { return false ; } public boolean getRecLetterQuality ( ) throws JposException { return false ; } public void setRecLetterQuality ( boolean b ) throws JposException { } public int getRecLineChars ( ) throws JposException { return 0 ; } public void setRecLineChars ( int i ) throws JposException { } public String", "gt": "getRecLineCharsList ( ) throws JposException", "prediction": "getJrnLineCharsList ( ) throws JposException\n", "label": 0}
{"id": 16151, "input": "<s> package litil . parser ; import litil . ast . Type ; import litil . lexer . BaseLexer ; import litil . lexer . LookaheadLexer ; import litil . lexer . LookaheadLexerWrapper ; import litil . lexer . Token ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class TDTypeParser extends BaseParser { public TDTypeParser ( LookaheadLexer lexer ) { super . lexer = lexer ; } public static void main ( String [ ] args ) throws Exception { Reader reader = new InputStreamReader ( LitilParser . class . getResourceAsStream ( \"test.types\" ) ) ; TDTypeParser p = new TDTypeParser ( new LookaheadLexerWrapper ( new BaseLexer ( reader ) ) ) ; p . debug = false ; p . types ( ) ; } private List < Type > types ( ) { List < Type > res = new ArrayList < Type > ( ) ; Type t = type ( ) ; res . add ( t ) ; System . err . println ( t ) ; while ( found ( Token . Type . NEWLINE ) ) { t = type ( ) ; res . add ( t ) ; System . err . println ( t + \"::\" + t . getClass ( ) ) ; } return res ; } private Type type ( ) { return funcType ( new HashMap < String , Type . Variable > ( ) ) ; } private Type type ( Map < String , Type . Variable > mappings ) { return funcType ( mappings ) ; } private Type funcType ( Map < String , Type . Variable > mappings ) { Type arg = prodType ( mappings ) ; if ( found ( Token . Type . SYM , \"->\" ) ) { Type res = funcType ( mappings ) ; return Type . Function ( arg , res ) ; } return arg ; } private Type prodType ( Map < String , Type . Variable > mappings ) { List < Type > args = new ArrayList < Type > ( ) ; args . add ( paramType ( mappings ) ) ; while ( found ( Token . Type . SYM , \"*\" ) ) { args . add ( paramType ( mappings ) ) ; } return args . size ( ) == 1 ? args . get ( 0 ) : Type . Product ( args ) ; } private Type paramType ( Map < String , Type . Variable > mappings ) { if ( found ( Token . Type . NAME ) ) { String name = token . text ; if ( Character . isLowerCase ( name . charAt ( 0 ) ) ) { Type . Variable res ; if ( mappings . containsKey ( name ) ) { res = mappings . get ( name ) ; } else { Type . Variable v = new Type . Variable ( ) ; mappings . put ( name , v ) ; res = v ; } if ( lookahead ( Token . Type . SYM , \"(\" ) || lookahead ( Token . Type . SYM , \"[\" ) || lookahead ( Token . Type . NAME ) ) { throw error ( \"Invalid type declaration: variables cannot be parameterized\" ) ; } else { return res ; } } else { List < Type > args = new ArrayList < Type > ( ) ; while ( lookahead ( Token . Type . SYM , \"(\" ) || lookahead ( Token . Type . SYM , \"[\" ) || lookahead ( Token . Type . NAME ) ) { args . add ( atomType ( mappings ) ) ; } if ( args . isEmpty ( ) ) { return typeFor ( name ) ; } else { return new Type . Oper ( name , args ) ; } } } else { return atomType ( mappings ) ; } } private Type atomType ( Map < String , Type . Variable > mappings ) { if ( found ( Token . Type . SYM , \"(\" ) ) { Type res = type ( mappings ) ; expect ( Token . Type . SYM , \")\" ) ; return res ; } else if ( found ( Token . Type . SYM , \"[\" ) ) { Type res = type ( mappings ) ; expect ( Token . Type . SYM , \"]\" ) ; return Type . List ( res ) ; } else if ( found ( Token . Type . NAME ) ) { String name = token . text ; if ( Character . isLowerCase ( name . charAt ( 0 ) ) ) { if (", "gt": "mappings . containsKey ( name ) )", "prediction": "mappings . containsKey ( name ) )\n", "label": 1}
{"id": 3421, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . Account ; import org . jjflyboy . tjpeditor . project . AccountPrefix ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class AccountPrefixImpl extends IncludePropertiesAttributeImpl implements AccountPrefix { protected Account account ; protected AccountPrefixImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getAccountPrefix ( ) ; } public Account getAccount ( ) { if ( account != null && account . eIsProxy ( ) ) { InternalEObject oldAccount = ( InternalEObject ) account ; account = ( Account ) eResolveProxy ( oldAccount ) ; if ( account != oldAccount ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProjectPackage . ACCOUNT_PREFIX__ACCOUNT , oldAccount , account ) ) ; } } return account ; } public Account basicGetAccount ( ) { return account ; } public void setAccount ( Account newAccount ) { Account oldAccount = account ; account = newAccount ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . ACCOUNT_PREFIX__ACCOUNT , oldAccount , account ) ) ; } @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProjectPackage . ACCOUNT_PREFIX__ACCOUNT : if ( resolve ) return getAccount ( ) ; return basicGetAccount ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; } @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProjectPackage . ACCOUNT_PREFIX__ACCOUNT : setAccount ( ( Account ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; } @", "gt": "Override public void eUnset ( int featureID )", "prediction": "Override public void eRemove ( int featureID , Object newValue )\n", "label": 0}
{"id": 16161, "input": "<s> package org . eclipse . ui . internal ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . preference . PreferenceDialog ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . actions . ActionFactory ; import org . eclipse . ui . dialogs . PreferencesUtil ; public class OpenPreferencesAction extends Action implements ActionFactory . IWorkbenchAction { private IWorkbenchWindow workbenchWindow ; public OpenPreferencesAction ( ) { this ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ) ; } public OpenPreferencesAction ( IWorkbenchWindow window ) { super ( WorkbenchMessages . get ( ) . OpenPreferences_text ) ; if ( window == null ) { throw new IllegalArgumentException ( ) ; } this . workbenchWindow = window ; setToolTipText ( WorkbenchMessages . get ( ) . OpenPreferences_toolTip ) ; window . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IWorkbenchHelpContextIds . OPEN_PREFERENCES_ACTION ) ; } public void run ( ) { if ( workbenchWindow == null ) { return ; } PreferenceDialog dialog = PreferencesUtil . createPreferenceDialogOn ( null", "gt": ", null , null , null ) ;", "prediction": ") ;\n", "label": 1}
{"id": 3732, "input": "<s> package org . ofbiz . widget . form ; import java . io . IOException ; import java . math . BigDecimal ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . NumberFormat ; import java . util . Date ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . TimeZone ; import javolution . util . FastList ; import javolution . util . FastMap ; import org . ofbiz . base . conversion . ConversionException ; import org . ofbiz . base . conversion . DateTimeConverters ; import org . ofbiz . base . conversion . DateTimeConverters . StringToTimestamp ; import org . ofbiz . base . util . BshUtil ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . GeneralException ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . StringUtil ; import org . ofbiz . base . util . UtilDateTime ; import org . ofbiz . base . util . UtilFormatOut ; import org . ofbiz . base . util . UtilGenerics ; import org . ofbiz . base . util . UtilMisc ; import org . ofbiz . base . util . UtilProperties ; import org . ofbiz . base . util . UtilValidate ; import org . ofbiz . base . util . UtilXml ; import org . ofbiz . base . util . collections . FlexibleMapAccessor ; import org . ofbiz . base . util . collections . MapStack ; import org . ofbiz . base . util . string . FlexibleStringExpander ; import org . ofbiz . entity . Delegator ; import org . ofbiz . entity . GenericEntity ; import org . ofbiz . entity . GenericEntityException ; import org . ofbiz . entity . GenericValue ; import org . ofbiz . entity . condition . EntityCondition ; import org . ofbiz . entity . finder . EntityFinderUtil ; import org . ofbiz . entity . model . ModelEntity ; import org . ofbiz . entity . model . ModelField ; import org . ofbiz . entity . model . ModelReader ; import org . ofbiz . entity . util . EntityUtil ; import org . ofbiz . service . DispatchContext ; import org . ofbiz . service . GenericServiceException ; import org . ofbiz . service . ModelParam ; import org . ofbiz . service . ModelService ; import org . ofbiz . widget . WidgetWorker ; import org . ofbiz . widget . form . ModelForm . UpdateArea ; import org . w3c . dom . Element ; import bsh . EvalError ; import bsh . Interpreter ; public class ModelFormField { public static final String module = ModelFormField . class . getName ( ) ; protected ModelForm modelForm ; protected String name ; protected FlexibleMapAccessor < Map < String , ? extends Object > > mapAcsr ; protected String entityName ; protected String serviceName ; protected FlexibleMapAccessor < Object > entryAcsr ; protected String parameterName ; protected String fieldName ; protected String attributeName ; protected FlexibleStringExpander title ; protected FlexibleStringExpander tooltip ; protected String titleAreaStyle ; protected String widgetAreaStyle ; protected String titleStyle ; protected String widgetStyle ; protected String tooltipStyle ; protected String requiredFieldStyle ; protected String sortFieldStyle ; protected String sortFieldAscStyle ; protected String sortFieldDescStyle ; protected Integer position = null ; protected String redWhen ; protected FlexibleStringExpander useWhen ; protected boolean encodeOutput = true ; protected String event ; protected FlexibleStringExpander action ; protected FieldInfo fieldInfo = null ; protected String idName ; protected boolean separateColumn = false ; protected Boolean requiredField = null ; protected Boolean sortField = null ; protected String headerLink ; protected String headerLinkStyle ; protected List < UpdateArea > onChangeUpdateAreas ; protected List < UpdateArea > onClickUpdateAreas ; public ModelFormField ( ModelForm modelForm ) { this . modelForm = modelForm ; } public", "gt": "ModelFormField ( Element fieldElement , ModelForm modelForm )", "prediction": "String getName ( )\n", "label": 0}
{"id": 16167, "input": "<s> package org . apache . lucene . benchmark . byTask . feeds ; import java . util . Date ; import java . util . Properties ; import org . apache . lucene . document . DateTools ; public class DocData { private String name ; private String body ; private String title ; private String date ; private Properties props ; public void clear ( ) { name = null ; body = null ; title = null ; date = null ; props = null ; } public String getBody ( ) { return body ; } public String getDate ( ) { return date ; } public String getName ( ) { return name ; } public Properties getProps ( ) { return props ; }", "gt": "public String getTitle ( )", "prediction": "}\n", "label": 1}
{"id": 8203, "input": "<s> package org . parboiled . support ; import org . testng . annotations . Test ; import static org . testng . Assert . assertEquals ; public class CharactersTest { @ Test public void testSimpleCharactersOps ( ) { assertEquals ( Characters . NONE . toString ( ) , \"[]\" ) ; assertEquals ( Characters . ALL . toString ( ) , \"![]\" ) ; assertEquals ( Characters . NONE . add ( 'A' ) . toString ( ) , \"[A]\" ) ; assertEquals ( Characters . ALL . add ( 'A' ) , Characters . ALL ) ; assertEquals ( Characters . NONE . remove ( 'A' ) , Characters . NONE ) ; assertEquals ( Characters . ALL . remove ( 'A' ) . toString ( ) , \"![A]\" ) ; assertEquals ( Characters . of ( 'A' ) . remove ( 'A' ) , Characters . NONE ) ; } @ Test public void testMultiCharactersOps ( ) { assertEquals ( Characters . NONE . add ( Characters . ALL ) , Characters . ALL ) ; assertEquals ( Characters . ALL . add ( Characters . NONE ) , Characters . ALL ) ; assertEquals ( Characters . NONE . remove ( Characters . ALL ) , Characters . NONE ) ; assertEquals ( Characters . ALL . remove ( Characters . NONE ) , Characters . ALL ) ; assertEquals ( Characters . ALL . remove ( Characters . of ( 'A' , 'B' ) ) . toString ( ) , \"![AB]\" ) ; assertEquals ( Characters . ALL . remove ( Characters . allBut ( 'A' , 'B' ) ) . toString ( ) , \"[AB]\" ) ; assertEquals ( Characters . of ( 'A' , 'B' ) . add ( Characters . of ( 'B' , 'C' ) ) , Characters . of ( 'A' , 'B' , 'C' ) ) ; assertEquals ( Characters . allBut ( 'A' , 'B' ) . add ( Characters . of ( 'B' , 'C' ) ) , Characters . allBut ( 'A' ) ) ; assertEquals ( Characters . of ( 'A' , 'B' ) . add ( Characters . allBut ( 'B' , 'C' ) ) , Characters . allBut ( 'C' ) ) ; assertEquals ( Characters . allBut ( 'A' , 'B' ) . add ( Characters . allBut ( 'B' , 'C' ) ) , Characters . allBut ( 'B' ) ) ; assertEquals ( Characters . of ( 'A' , 'B' ) . remove ( Characters . of ( 'B' , 'C' ) ) , Characters . of ( 'A' ) ) ; assertEquals ( Characters . allBut ( 'A' , 'B' ) . remove ( Characters . of ( 'B' , 'C' ) ) , Characters . allBut ( 'A' , 'B' , 'C' ) ) ; assertEquals ( Characters . of ( 'A' , 'B' ) . remove ( Characters . allBut ( 'B' , 'C' ) ) , Characters . of ( 'B' ) ) ; assertEquals ( Characters . allBut ( 'A' , 'B' ) . remove ( Characters . allBut ( 'B' , 'C' ) ) , Characters .", "gt": "of ( 'C' ) ) ;", "prediction": "allBut ( 'A' , 'B' , 'C' ) ) ;\n", "label": 0}
{"id": 16168, "input": "<s> package org . eclipse . swt . events ; import org . eclipse . swt . widgets . Event ; public final class DisposeEvent extends TypedEvent { private static final long serialVersionUID = 1L ; public DisposeEvent ( Event event ) {", "gt": "super ( event ) ;", "prediction": "super ( event ) ;\n", "label": 1}
{"id": 5489, "input": "<s> class AbstractOverride { static class Ex extends Exception { } static class A { void f ( ) throws Ex { } } static abstract class B extends A { abstract void f ( ) ; } static class C extends B { void f ( ) { } } public static void main ( String [ ] args ) { B b = new C ( ) ; b", "gt": ". f ( ) ;", "prediction": ". run ( ) ;\n", "label": 0}
{"id": 16179, "input": "<s> package org . eclipse . ui . dynamic ; import org . eclipse . jface . preference . IPreferencePageContainer ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPreferencePage ; public class DynamicPreferencePage implements IWorkbenchPreferencePage { public DynamicPreferencePage ( ) { super ( ) ; } public void init ( IWorkbench workbench ) { } public Point computeSize ( ) { return null ; } public boolean isValid ( ) { return false ; } public boolean okToLeave ( ) { return false ; } public boolean performCancel ( ) { return false ; } public boolean performOk ( ) { return false ; } public void setContainer ( IPreferencePageContainer preferencePageContainer ) { } public void setSize ( Point size ) { } public void createControl ( Composite parent ) { } public void dispose ( ) { } public Control getControl ( ) { return null ; } public String getDescription ( ) { return null ; } public String getErrorMessage ( ) { return null ; } public Image getImage ( ) { return null ; }", "gt": "public String getMessage ( )", "prediction": "}\n", "label": 1}
{"id": 3261, "input": "<s> import java . nio . * ; import java . io . * ; import java . nio . channels . * ; import com . sun . tools . javac . api . JavacTaskImpl ; import com . sun . tools . javac . jvm . ClassReader . BadClassFile ; import com . sun . tools . javac . main . JavaCompiler ; import javax . tools . ToolProvider ; public class T6330997 { public static void main ( String ... args ) { increaseMajor ( \"T1.class\" , 1 ) ; increaseMajor ( \"T2.class\" , 2 ) ; javax . tools . JavaCompiler tool = ToolProvider . getSystemJavaCompiler ( ) ; JavacTaskImpl task = ( JavacTaskImpl ) tool . getTask ( null , null , null , null , null , null ) ; JavaCompiler compiler = JavaCompiler . instance ( task . getContext ( ) ) ; try { compiler . resolveIdent ( \"T1\" ) . complete ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( \"Failed: unexpected exception while reading class T1\" ) ; } try { compiler . resolveIdent ( \"T2\" ) . complete ( ) ; } catch ( BadClassFile e ) { System . err . println ( \"Passed: expected completion failure \" + e . getClass ( ) . getName ( ) ) ; return ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new RuntimeException ( \"Failed: unexpected exception while reading class T2\" ) ; } throw new RuntimeException ( \"Failed: no error reported\" ) ; } static void increaseMajor ( String cfile , int delta ) { try { RandomAccessFile cls = new RandomAccessFile ( new File ( System . getProperty ( \"test.classes\" , \".\" ) , cfile ) , \"rw\" ) ; FileChannel fc = cls . getChannel ( ) ; ByteBuffer rbuf = ByteBuffer . allocate ( 2 ) ; fc . read ( rbuf , 6 ) ; ByteBuffer wbuf = ByteBuffer . allocate ( 2 ) ; wbuf . putShort ( 0 , ( short ) ( rbuf . getShort ( 0 ) + delta ) ) ; fc . write ( wbuf , 6 ) ; fc . force ( false ) ; cls . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ;", "gt": "throw new RuntimeException ( \"Failed: unexpected exception\" ) ;", "prediction": "throw new RuntimeException ( \"Failed: unexpected exception while reading class T3\" ) ;\n", "label": 0}
{"id": 16185, "input": "<s> package org . eclipse . jface . databinding . viewers ; import java . util . Iterator ; import java . util . Set ; import org . eclipse . core . databinding . observable . IObservableCollection ; import org . eclipse . core . databinding . observable . IObservablesListener ; import org . eclipse . core . databinding . observable . masterdetail . IObservableFactory ; import org . eclipse . core . databinding . observable . set . IObservableSet ; import org . eclipse . core . databinding . observable . set . ISetChangeListener ; import org . eclipse . core . databinding . observable . set . SetChangeEvent ; import org . eclipse . jface . internal . databinding . viewers . ObservableCollectionTreeContentProvider ; import org . eclipse . jface . internal . databinding . viewers . ViewerElementSet ; import org . eclipse . jface . viewers . AbstractTreeViewer ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; public class ObservableSetTreeContentProvider implements ITreeContentProvider { private final ObservableCollectionTreeContentProvider impl ; private static class Impl extends ObservableCollectionTreeContentProvider { Impl ( IObservableFactory setFactory , TreeStructureAdvisor structureAdvisor ) { super ( setFactory , structureAdvisor ) ; } private class SetChangeListener implements ISetChangeListener { final Object parentElement ; public SetChangeListener ( Object parentElement ) { this . parentElement = parentElement ; } public void handleSetChange ( SetChangeEvent event ) { if ( isViewerDisposed ( ) ) return ; Set localAdditions = event . diff . getAdditions ( ) ; Set localRemovals = event . diff . getRemovals ( ) ; Set knownElementAdditions = ViewerElementSet . withComparer ( comparer ) ; knownElementAdditions . addAll ( localAdditions ) ; knownElementAdditions . removeAll ( knownElements ) ; Set knownElementRemovals = findPendingRemovals ( parentElement , localRemovals ) ; knownElementRemovals . retainAll ( knownElements ) ; knownElements . addAll ( knownElementAdditions ) ; if ( realizedElements != null ) { realizedElements . removeAll ( knownElementRemovals ) ; } for ( Iterator iterator = localAdditions . iterator ( ) ; iterator . hasNext ( ) ; ) { Object child = iterator . next ( ) ; getOrCreateNode ( child ) . addParent ( parentElement ) ; } viewerUpdater . add ( parentElement , localAdditions . toArray ( ) ) ; viewerUpdater . remove ( parentElement , localRemovals . toArray ( ) ) ; for ( Iterator iterator = localRemovals . iterator ( ) ; iterator . hasNext ( ) ; ) { Object child = iterator . next ( ) ; TreeNode childNode = getExistingNode ( child ) ; if ( childNode != null ) childNode . removeParent ( parentElement ) ; } if ( realizedElements != null ) { realizedElements .", "gt": "addAll ( knownElementAdditions ) ;", "prediction": "removeAll ( realizedElements ) ;\n", "label": 1}
{"id": 1597, "input": "<s> package ar . com . fdvs . dj . test . domain . chart . builder ; import java . awt . Color ; import java . util . HashMap ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignPieDataset ; import net . sf . jasperreports . charts . design . JRDesignPiePlot ; import net . sf . jasperreports . engine . JRFont ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . view . JasperViewer ; import ar . com . fdvs . dj . domain . DJCalculation ; import ar . com . fdvs . dj . domain . DJHyperLink ; import ar . com . fdvs . dj . domain . DynamicJasperDesign ; import ar . com . fdvs . dj . domain . DynamicReport ; import ar . com . fdvs . dj . domain . StringExpression ; import ar . com . fdvs . dj . domain . builders . ColumnBuilder ; import ar . com . fdvs . dj . domain . builders . DynamicReportBuilder ; import ar . com . fdvs . dj . domain . builders . GroupBuilder ; import ar . com . fdvs . dj . domain . chart . DJChart ; import ar . com . fdvs . dj . domain . chart . DJChartOptions ; import ar . com . fdvs . dj . domain . chart . builder . DJPieChartBuilder ; import ar . com . fdvs . dj . domain . constants . Font ; import ar . com . fdvs . dj . domain . constants . GroupLayout ; import ar . com . fdvs . dj . domain . entities . DJGroup ; import ar . com . fdvs . dj . domain . entities . columns . AbstractColumn ; import ar . com . fdvs . dj . domain . entities . columns . PropertyColumn ; import ar . com . fdvs . dj . domain . hyperlink . LiteralExpression ; import ar . com . fdvs . dj . test . BaseDjReportTest ; public class PieChartBuilderTest extends BaseDjReportTest { private DynamicReportBuilder drb ; private JRDesignChart chart ; protected void setUp ( ) throws Exception { drb = new DynamicReportBuilder ( ) ; AbstractColumn columnState = ColumnBuilder . getNew ( ) . setColumnProperty ( \"state\" , String . class . getName ( ) ) . setTitle ( \"State\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnBranch = ColumnBuilder . getNew ( ) . setColumnProperty ( \"branch\" , String . class . getName ( ) ) . setTitle ( \"Branch\" ) . setWidth ( new Integer ( 85 ) ) . build ( ) ; AbstractColumn columnaQuantity = ColumnBuilder . getNew ( ) . setColumnProperty ( \"quantity\" , Long . class . getName ( ) ) . setTitle ( \"Quantity\" ) . setWidth ( new Integer ( 80 ) ) . build ( ) ; AbstractColumn columnAmount = ColumnBuilder . getNew ( ) . setColumnProperty ( \"amount\" , Float . class . getName ( ) ) . setTitle ( \"Amount\" ) . setWidth ( new Integer ( 90 ) ) . build ( ) ; drb . addColumn ( columnState ) ; drb . addColumn ( columnBranch ) ; drb . addColumn ( columnaQuantity ) ; drb . addColumn ( columnAmount ) ; GroupBuilder gb1 = new GroupBuilder ( ) ; DJGroup g1 = gb1 . setCriteriaColumn ( ( PropertyColumn ) columnState ) . addFooterVariable ( columnAmount , DJCalculation . SUM ) . addFooterVariable ( columnaQuantity , DJCalculation . SUM ) . addVariable ( \"group_state_name\" , columnState , DJCalculation . FIRST ) . setGroupLayout ( GroupLayout . VALUE_IN_HEADER_WITH_HEADERS ) . build ( ) ; drb . addGroup ( g1 ) ; drb . setUseFullPageWidth ( true ) ; DJChart djChart = new DJPieChartBuilder ( ) . setX ( 20 ) . setY ( 10 ) . setWidth ( 500 ) . setHeight ( 250 ) . setCentered ( false ) . setBackColor ( Color . LIGHT_GRAY ) . setShowLegend ( true ) . setPosition ( DJChartOptions . POSITION_FOOTER ) . setTitle ( new StringExpression ( ) { public Object evaluate ( Map fields , Map variables , Map parameters ) { return variables . get ( \"group_state_name\" ) ; } } ) . setTitleColor ( Color . DARK_GRAY ) . setTitleFont ( Font . ARIAL_BIG_BOLD ) . setSubtitle ( \"subtitle\" ) . setSubtitleColor ( Color . DARK_GRAY ) . setSubtitleFont ( Font . COURIER_NEW_BIG_BOLD ) . setLegendColor ( Color . DARK_GRAY ) . setLegendFont ( Font . COURIER_NEW_MEDIUM_BOLD ) . setLegendBackgroundColor ( Color . WHITE ) . setLegendPosition ( DJChartOptions . EDGE_BOTTOM ) . setTitlePosition ( DJChartOptions . EDGE_TOP ) . setLineStyle ( DJChartOptions . LINE_STYLE_DOTTED ) . setLineWidth ( 1 ) . setLineColor ( Color . DARK_GRAY ) . setPadding ( 5 ) . setKey ( ( PropertyColumn ) columnBranch ) . addSerie ( columnAmount ) . setCircular ( true ) . build ( ) ; drb . addChart ( djChart ) ; DJHyperLink djlink = new DJHyperLink ( ) ; djlink . setExpression ( new StringExpression ( ) { public Object evaluate ( Map fields , Map variables , Map parameters ) { return \"http://thisIsAURL?count=\" + variables . get ( \"REPORT_COUNT\" ) ; } } ) ; djlink . setTooltip ( new LiteralExpression ( \"I'm a literal tootltip\" ) ) ; djChart . setLink ( djlink ) ; HashMap vars = new HashMap ( ) ; vars . put ( columnaQuantity , new JRDesignVariable ( ) ) ; vars . put ( columnAmount , new JRDesignVariable ( ) ) ; JRDesignGroup group = new JRDesignGroup ( ) ; chart = djChart . transform ( new DynamicJasperDesign ( ) , \"\" , group , group , vars , 0 ) ; } public void testChart ( ) { assertEquals ( 20 , chart . getX ( ) ) ; assertEquals ( 10 , chart . getY ( ) ) ; assertEquals ( 500 , chart . getWidth ( ) ) ; assertEquals ( 250 , chart . getHeight ( ) ) ; assertEquals ( Color . LIGHT_GRAY , chart . getBackcolor ( ) ) ; assertEquals ( Boolean . TRUE , chart . getShowLegend ( ) ) ; assertNotNull ( chart . getTitleExpression (", "gt": ") . getText ( ) ) ;", "prediction": ") ) ;\n", "label": 0}
{"id": 16186, "input": "<s> package com . emf4sw . owl ; import org . eclipse . emf . ecore . EObject ; public interface DatatypeDefinition extends EObject { DataRange getDataRange ( ) ; void", "gt": "setDataRange ( DataRange value ) ;", "prediction": "setDataRange ( DataRange dataRange ) ;\n", "label": 1}
{"id": 4756, "input": "<s> public class TestInterface extends JavadocTester { private static final String BUG_ID = \"4682448-4947464-5029946\" ; private static final String [ ] ARGS = new String [ ] { \"-d\" , BUG_ID , \"-sourcepath\" , SRC_DIR , \"pkg\" } ; private static final String [ ] [ ] TEST = { { BUG_ID + FS + \"pkg\" + FS + \"Interface.html\" , \"<pre>int&nbsp;method()</pre>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Interface.html\" , \"<pre>static final&nbsp;int field</pre>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Interface.html\" , \"<dl>\" + NL + \"<dt>All Known Implementing Classes:</dt>\" + NL + \"<dd><a href=\\\"../pkg/Child.html\\\" title=\\\"class in pkg\\\">Child\" + \"</a>, <a href=\\\"../pkg/Parent.html\\\" title=\\\"class in pkg\\\">Parent\" + \"</a></dd>\" + NL + \"</dl>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Child.html\" , \"<dl>\" + NL + \"<dt>All Implemented Interfaces:</dt>\" + NL + \"<dd><a href=\\\"../pkg/Interface.html\\\" title=\\\"interface in pkg\\\">\" + \"Interface</a>&lt;T&gt;</dd>\" + NL + \"</dl>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Child.html\" , \"<ul class=\\\"inheritance\\\">\" + NL + \"<li>java.lang.Object</li>\" + NL + \"<li>\" + NL + \"<ul class=\\\"inheritance\\\">\" + NL + \"<li><a href=\\\"../pkg/Parent.html\\\" title=\\\"class in pkg\\\">\" + \"pkg.Parent</a>&lt;T&gt;</li>\" + NL + \"<li>\" + NL + \"<ul class=\\\"inheritance\\\">\" + NL + \"<li>pkg.Child&lt;T&gt;</li>\" + NL + \"</ul>\" + NL + \"</li>\" + NL + \"</ul>\" + NL + \"</li>\" + NL + \"</ul>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Parent.html\" , \"<dl>\" + NL + \"<dt>Direct Known Subclasses:</dt>\" + NL + \"<dd><a href=\\\"../pkg/Child.html\\\" title=\\\"class in pkg\\\">Child\" + \"</a></dd>\" + NL + \"</dl>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Child.html\" , \"<dt><strong>Specified by:</strong></dt>\" + NL + \"<dd><code><a href=\\\"../pkg/Interface.html#method()\\\">method</a>\" + \"</code>&nbsp;in interface&nbsp;<code>\" + \"<a href=\\\"../pkg/Interface.html\\\" title=\\\"interface in pkg\\\">\" + \"Interface</a>&lt;<a href=\\\"../pkg/Child.html\\\" title=\\\"type parameter in Child\\\">\" + \"T</a>&gt;</code></dd>\" } , { BUG_ID + FS + \"pkg\" + FS + \"Child.html\" , \"<dt><strong>Overrides:</strong></dt>\" + NL + \"<dd><code><a href=\\\"../pkg/Parent.html#method()\\\">method</a>\" + \"</code>&nbsp;in class&nbsp;<code><a href=\\\"../pkg/Parent.html\\\" \" + \"title=\\\"class in pkg\\\">Parent</a>&lt;<a href=\\\"../pkg/Child.html\\\" \" + \"title=\\\"type parameter in Child\\\">T</a>&gt;</code></dd>\" } , } ; private static final String [ ] [ ] NEGATED_TEST = { { BUG_ID + FS + \"pkg\" + FS + \"Interface.html\" , \"public int&nbsp;method()\" } , { BUG_ID + FS + \"pkg\" + FS + \"Interface.html\" , \"public static final&nbsp;int field\" } , } ; public static void main ( String [ ] args ) { TestInterface tester = new TestInterface ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; } public String getBugId ( ) { return BUG_ID ; } public String getBugName ( ) { return getClass", "gt": "( ) . getName ( ) ;", "prediction": "( ) ;\n", "label": 0}
{"id": 16200, "input": "<s> package com . digitalsanctum . idea . plugins . buildr . model ; public class BuildrTask { private String name ; private String description ; public BuildrTask ( String name , String description ) { this . name = name ; this . description = description ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } @ Override public String toString ( ) { return \"BuildrTask{\" + \"name='\" + name + '\\'' + \", description='\" +", "gt": "description + '\\'' + '}' ;", "prediction": "description + '\\'' + \"'}'\" ;\n", "label": 1}
{"id": 9985, "input": "<s> package inheritance . conflict3 ; class X1 < T > { int f ( T t ) { throw null ; }", "gt": "void f ( Object o )", "prediction": "}\n", "label": 0}
{"id": 16202, "input": "<s> package org . nuxeo . ecm . platform . pictures . tiles . restlets ; import java . util . Calendar ; import org . nuxeo . ecm . platform . pictures . tiles . api . adapter . PictureTilesAdapter ; public class PictureTilesCachedEntry { protected Calendar modified ; protected PictureTilesAdapter adapter ; protected long timeStamp ; protected String xpath ; public PictureTilesCachedEntry ( Calendar modified , PictureTilesAdapter adapter , String xpath ) { this . modified = modified ; this . adapter = adapter ; this . xpath = xpath ; if ( xpath == null ) this . xpath = \"\" ; timeStamp = System . currentTimeMillis ( ) ; } public Calendar getModified ( ) { return modified ; } public void setModified ( Calendar modified ) { this . modified = modified ; } public PictureTilesAdapter getAdapter ( ) { return adapter ; } public void setAdapter ( PictureTilesAdapter adapter ) { this . adapter = adapter ; }", "gt": "public long getTimeStamp ( )", "prediction": "}\n", "label": 1}
{"id": 3984, "input": "<s> package org . ofbiz . crowd . security ; import org . ofbiz . base . util . UtilProperties ; @ SuppressWarnings ( \"serial\" ) public class SecurityServerLocator extends org . apache . axis . client . Service implements org . ofbiz . crowd . security . SecurityServer { public SecurityServerLocator ( ) { } public SecurityServerLocator ( org . apache . axis . EngineConfiguration config ) { super ( config ) ; } public SecurityServerLocator ( java . lang . String wsdlLoc , javax . xml . namespace . QName sName ) throws javax . xml . rpc . ServiceException { super ( wsdlLoc , sName ) ; } private java . lang . String SecurityServerHttpPort_address = UtilProperties . getPropertyValue ( \"crowd.properties\" , \"crowd.server.address\" ) ; public java . lang . String getSecurityServerHttpPortAddress ( ) { return SecurityServerHttpPort_address ; } private java . lang . String SecurityServerHttpPortWSDDServiceName = \"SecurityServerHttpPort\" ; public java . lang . String getSecurityServerHttpPortWSDDServiceName ( ) { return SecurityServerHttpPortWSDDServiceName ; } public void setSecurityServerHttpPortWSDDServiceName ( java . lang . String name ) { SecurityServerHttpPortWSDDServiceName = name ; } public org . ofbiz . crowd . security . SecurityServerPortType getSecurityServerHttpPort ( ) throws javax . xml . rpc . ServiceException { java . net . URL endpoint ; try { endpoint = new java . net . URL ( SecurityServerHttpPort_address ) ; } catch ( java . net . MalformedURLException e ) { throw new javax . xml . rpc . ServiceException ( e ) ; } return getSecurityServerHttpPort ( endpoint ) ; } public org . ofbiz . crowd . security . SecurityServerPortType getSecurityServerHttpPort ( java . net . URL portAddress ) throws javax . xml . rpc . ServiceException { try { org . ofbiz . crowd . security . SecurityServerHttpBindingStub _stub = new org . ofbiz . crowd . security . SecurityServerHttpBindingStub ( portAddress , this ) ; _stub . setPortName ( getSecurityServerHttpPortWSDDServiceName ( ) ) ; return _stub ; } catch ( org . apache . axis . AxisFault e ) { return null ; } } public void setSecurityServerHttpPortEndpointAddress ( java . lang . String address ) { SecurityServerHttpPort_address = address ; } @ SuppressWarnings ( \"unchecked\" ) public java . rmi . Remote getPort ( Class serviceEndpointInterface ) throws javax . xml . rpc . ServiceException { try { if ( org . ofbiz . crowd . security . SecurityServerPortType . class . isAssignableFrom ( serviceEndpointInterface ) ) { org . ofbiz . crowd . security . SecurityServerHttpBindingStub _stub = new org . ofbiz . crowd . security . SecurityServerHttpBindingStub ( new java . net . URL ( SecurityServerHttpPort_address ) , this ) ; _stub . setPortName ( getSecurityServerHttpPortWSDDServiceName ( ) ) ; return _stub ; } } catch ( java . lang . Throwable t ) { throw new javax . xml . rpc . ServiceException ( t ) ; } throw new javax . xml . rpc . ServiceException ( \"There is no stub implementation for the interface:  \" + ( serviceEndpointInterface == null ? \"null\" : serviceEndpointInterface . getName ( ) ) ) ; } @ SuppressWarnings ( \"unchecked\" ) public java . rmi . Remote getPort ( javax . xml . namespace . QName portName , Class serviceEndpointInterface ) throws javax . xml . rpc . ServiceException { if ( portName == null ) { return getPort ( serviceEndpointInterface ) ; } java . lang . String inputPortName = portName . getLocalPart ( ) ; if (", "gt": "\"SecurityServerHttpPort\" . equals ( inputPortName ) )", "prediction": "inputPortName == null )\n", "label": 0}
{"id": 16204, "input": "<s> package tk . blackwolf12333 . grieflog . commands ; import java . util . Arrays ; import java . util . List ; import org . bukkit . ChatColor ; import org . bukkit . command . CommandSender ; import tk . blackwolf12333 . grieflog . utils . config . ConfigHandler ; public class GLogBp { String [ ] helpTxt = { ChatColor . RED + \"++++++++++ [GriefLog-BlockProtection] +++++++++++++\" , \"Commands:\" , ChatColor . GOLD + \"/glog bp help\" + ChatColor . DARK_GRAY + \"Gives this help text.\" , ChatColor . GOLD + \"/glog bp listfriends: \" + ChatColor . DARK_GRAY + \"This lists the friends on your friendslist.\" , ChatColor . GOLD + \"/glog bp addfriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This adds a friend to your friendslist so that he can break your blocks.\" , ChatColor . GOLD + \"/glog bp removefriend <friendsname>: \" + ChatColor . DARK_GRAY + \"This removes a friend from your friendslist.\" } ; public boolean onCommand ( CommandSender sender , String cmdLabel , String [ ] args ) { if ( args [ 1 ] . equalsIgnoreCase ( \"listfriends\" ) ) { List < String > friends = ConfigHandler . getFriends ( sender . getName ( ) ) ; sender . sendMessage ( ChatColor . AQUA + \"This are your current friends: \" ) ; for ( int i = 0 ; i < friends . size ( ) ; i ++ ) { sender . sendMessage ( ChatColor . AQUA + friends . get ( i ) ) ; } return true ; } if ( args [ 1 ] . equalsIgnoreCase ( \"addfriend\" ) ) { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . size ( ) == 0 ) { String [ ] list = new String [ ] { args [ 2 ] } ; ConfigHandler . friendsConfig . set ( sender . getName ( ) , Arrays . asList ( list ) ) ; } else { if ( ConfigHandler . getFriends ( sender . getName ( ) ) . contains ( args [ 2 ] ) ) { sender . sendMessage ( ChatColor . AQUA + \"[GriefLog] Player \" + args [ 2 ] + \" is allready on your friends list.\" ) ; } else { List < String > friends = ConfigHandler . friendsConfig . getStringList ( sender . getName ( ) ) ; friends . add ( args", "gt": "[ 0 ] ) ;", "prediction": "[ 2 ] ) ;\n", "label": 1}
{"id": 8425, "input": "<s> package com . example . wordcount . jobflow ; import com . asakusafw . vocabulary . flow . Export ; import com . asakusafw . vocabulary . flow . FlowDescription ; import com . asakusafw . vocabulary . flow . Import ; import com . asakusafw . vocabulary . flow . In ; import com . asakusafw . vocabulary . flow . JobFlow ; import com . asakusafw . vocabulary . flow . Out ; import com . example . wordcount . jobflow . gateway . LogLineFromHdfs ; import com . example . wordcount . jobflow . gateway . WordCountToHdfs ; import com . example . wordcount . modelgen . dmdl . model . LogLine ; import com . example . wordcount . modelgen . dmdl . model . WordCount ; import com . example . wordcount . operator . WordCountOperatorFactory ; @ JobFlow ( name = \"WordCountJob\" ) public class WordCountJob extends FlowDescription { WordCountOperatorFactory opeartor = new WordCountOperatorFactory ( ) ; In < LogLine > in ; Out < WordCount > out ; public WordCountJob ( @ Import ( name = \"in\" , description = LogLineFromHdfs . class ) In < LogLine > in , @ Export ( name = \"out\" , description = WordCountToHdfs . class ) Out < WordCount > out ) { this . in = in ; this . out = out ; } @ Override protected void describe ( ) { out . add ( opeartor . summlize ( opeartor . split", "gt": "( in ) . result ) . result ) ;", "prediction": "( \",\" ) ) ) ;\n", "label": 0}
{"id": 16209, "input": "<s> package com . poetry . model ; import java . util . Date ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . Id ; import javax . persistence . JoinColumn ; import javax . persistence . ManyToOne ; @ Entity public class Reply { @ Id protected String id ; @ Column ( nullable = false ) protected String targetId ; @ ManyToOne @ JoinColumn ( name = \"writer\" ) protected Poet writer ; protected String contents ; protected Date createdDate ; public Reply ( ) { } public Reply ( final String id ) { this . id = id ; } public Reply ( final String targetId , final Poet writer , final String contents ) { this . targetId = targetId ; this . writer = writer ; this . contents = contents ; } public Reply ( final String id , final String targetId , final Poet writer , final String contens ) { this . id = id ; this . targetId = targetId ; this . writer = writer ; this . contents = contens ; } public String getId ( ) { return id ; } public void setId ( String id ) { this . id = id ; } public String getTargetId ( ) { return targetId ; } public void setTargetId ( String targetId ) { this . targetId = targetId ; } public Poet getWriter ( ) { return writer ; } public", "gt": "void setWriter ( Poet writer )", "prediction": "void setWriter ( String writer )\n", "label": 1}
{"id": 8817, "input": "<s> package com . farpost . maven . plugins ; import com . farpost . ldt . formatter . AbstractPlainResultFormatter ; import com . farpost . ldt . formatter . ResultFormatter ; import org . apache . maven . plugin . logging . Log ; public class MavenLogFormatter extends AbstractPlainResultFormatter { private final Log out ; public MavenLogFormatter ( Log out ) {", "gt": "this . out = out ;", "prediction": "this . out = out ;\n", "label": 0}
{"id": 16215, "input": "<s> package org . eclipse . ui . internal . handlers ; import org . eclipse . core . commands . IHandler ; import org . eclipse . ui . commands . HandlerEvent ; import org . eclipse . ui . commands . IHandlerListener ; import org . eclipse . ui . internal . commands . ILegacyAttributeNames ; public final class LegacyHandlerListenerWrapper implements IHandlerListener { private final IHandler handler ; private final org . eclipse . core . commands . IHandlerListener listener ; public LegacyHandlerListenerWrapper ( final IHandler handler , final org . eclipse . core . commands . IHandlerListener listener ) { if ( handler == null ) { throw new NullPointerException ( \"A listener wrapper cannot be created on a null handler\" ) ; } if ( listener == null ) { throw new NullPointerException ( \"A listener wrapper", "gt": "cannot be created on a null listener\" ) ;", "prediction": "cannot be created on a null listener\" ) ;\n", "label": 1}
{"id": 4860, "input": "<s> package org . parboiled . annotations ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD }", "gt": ") public @ interface DontExtend", "prediction": ") @ RetentionPolicy (\n", "label": 0}
{"id": 16223, "input": "<s> package org . eclipse . swt . internal . widgets . toolitemkit ; import java . io . IOException ; import org . eclipse . rap . rwt . internal . protocol . ClientObjectFactory ; import org . eclipse . rap . rwt . lifecycle . AbstractWidgetLCA ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . ToolItem ; import org . eclipse . swt . widgets . Widget ; public final class ToolItemLCA extends AbstractWidgetLCA { private final static ToolItemDelegateLCA PUSH = new PushToolItemLCA ( ) ; private final static ToolItemDelegateLCA CHECK = new CheckToolItemLCA ( ) ; private final static ToolItemDelegateLCA RADIO = new RadioToolItemLCA ( ) ; private final static ToolItemDelegateLCA SEPERATOR = new SeparatorToolItemLCA ( ) ; private final static ToolItemDelegateLCA DROP_DOWN = new DropDownToolItemLCA ( ) ; public void preserveValues ( Widget widget ) { getLCADelegate ( widget ) . preserveValues ( ( ToolItem ) widget ) ; } public void readData ( Widget widget ) { getLCADelegate ( widget ) . readData ( ( ToolItem ) widget ) ; } public void renderInitialization ( Widget widget ) throws IOException { getLCADelegate ( widget ) . renderInitialization ( ( ToolItem ) widget ) ; } public void renderChanges ( Widget widget ) throws IOException { getLCADelegate ( widget ) . renderChanges ( ( ToolItem ) widget ) ; } public void renderDispose ( Widget widget ) throws IOException { ClientObjectFactory . getClientObject ( widget ) . destroy ( ) ; } private static ToolItemDelegateLCA getLCADelegate ( Widget widget ) { ToolItemDelegateLCA result ; int style = ( ( ToolItem ) widget ) . getStyle ( ) ; if ( ( style & SWT . CHECK ) != 0 ) { result = CHECK ; } else if ( ( style & SWT . PUSH ) != 0 ) { result = PUSH ; } else if ( ( style & SWT . SEPARATOR ) != 0 ) { result = SEPERATOR ; } else if ( ( style & SWT . DROP_DOWN ) != 0 ) { result = DROP_DOWN ; } else if ( ( style", "gt": "& SWT . RADIO ) != 0 )", "prediction": "& SWT . DROP_DOWN ) != 0 )\n", "label": 1}
{"id": 5761, "input": "<s> package ar . com . fdvs . dj . core . layout ; import java . awt . Color ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import net . sf . jasperreports . charts . design . JRDesignBarPlot ; import net . sf . jasperreports . engine . JRException ; import net . sf . jasperreports . engine . JRExpression ; import net . sf . jasperreports . engine . JRGroup ; import net . sf . jasperreports . engine . JRHyperlink ; import net . sf . jasperreports . engine . JRStyle ; import net . sf . jasperreports . engine . JRTextElement ; import net . sf . jasperreports . engine . JRTextField ; import net . sf . jasperreports . engine . base . JRBaseChartPlot ; import net . sf . jasperreports . engine . base . JRBaseVariable ; import net . sf . jasperreports . engine . design . JRDesignBand ; import net . sf . jasperreports . engine . design . JRDesignChart ; import net . sf . jasperreports . engine . design . JRDesignChartDataset ; import net . sf . jasperreports . engine . design . JRDesignConditionalStyle ; import net . sf . jasperreports . engine . design . JRDesignElement ; import net . sf . jasperreports . engine . design . JRDesignExpression ; import net . sf . jasperreports . engine . design . JRDesignGroup ; import net . sf . jasperreports . engine . design . JRDesignImage ; import net . sf . jasperreports . engine . design . JRDesignParameter ; import net . sf . jasperreports . engine . design . JRDesignStyle ; import net . sf . jasperreports . engine . design . JRDesignTextElement ; import net . sf . jasperreports . engine . design . JRDesignTextField ; import net . sf . jasperreports . engine . design . JRDesignVariable ; import net . sf . jasperreports . engine . design . JasperDesign ; import net . sf . jasperreports . engine . util . JRExpressionUtil ; import org . apache . commons . beanutils . BeanUtils ; import org . apache . commons . collections . CollectionUtils ; import org . apache .", "gt": "commons . collections . MultiHashMap ;", "prediction": "commons . util . Map ;\n", "label": 0}
{"id": 16229, "input": "<s> package org . eclipse . rap . rwt . internal . protocol ; import java . util . Map ; public interface IClientObject { void create ( String type ) ; void set ( String name , int value ) ; void set ( String name , double value ) ; void set ( String name , boolean value ) ; void set ( String name , String value ) ; void set ( String name , Object value ) ; void listen ( String eventType , boolean listen ) ; void call ( String method , Map < String", "gt": ", Object > properties ) ;", "prediction": ", Object > values ) ;\n", "label": 1}
{"id": 5469, "input": "<s> import com . sun . tools . javac . api . JavacTool ; import java . io . File ; import java . io . PrintWriter ; import java . util . Arrays ; import javax . tools . JavaFileManager ; import javax . tools . JavaFileObject ; import com . sun . source . tree . CompilationUnitTree ; import com . sun . source . tree . PrimitiveTypeTree ; import com . sun . source . util . JavacTask ; import com . sun . source . util . TreeScanner ; import javax . tools . StandardJavaFileManager ; public class T6345974 { public static void main ( String [ ] args ) throws Exception { PrintWriter out = new PrintWriter ( System . out , true ) ; JavacTool tool = JavacTool . create ( ) ; StandardJavaFileManager fm = tool . getStandardFileManager ( null , null , null ) ; File testSrc = new File ( System . getProperty ( \"test.src\" ) ) ; Iterable < ? extends JavaFileObject > f = fm . getJavaFileObjectsFromFiles ( Arrays . asList ( new File ( testSrc , \"T6345974.java\" ) ) ) ; JavacTask task = tool . getTask ( out , fm , null , null , null , f ) ; Iterable < ? extends CompilationUnitTree > trees = task", "gt": ". parse ( ) ;", "prediction": ". getTree ( ) ;\n", "label": 0}
{"id": 16264, "input": "<s> package org . eclipse . swt . internal . widgets ; import org . eclipse . swt . graphics . Point ; public interface IToolTipAdapter {", "gt": "Point getLocation ( ) ;", "prediction": "}\n", "label": 1}
{"id": 6102, "input": "<s> package org . ofbiz . webapp . taglib ; import javax . servlet . jsp . JspTagException ; import javax . servlet . jsp . tagext . TagSupport ; import org . ofbiz . base . util . Debug ; import org . ofbiz . base . util . ObjectType ; import org . ofbiz . base . util . UtilValidate ; @ SuppressWarnings ( \"serial\" ) public class ObjectTag extends TagSupport { public static final String module = ObjectTag . class . getName ( ) ; protected Object element = null ; protected String name = null ; protected String property = null ; protected Class < ? > type = null ; public void setName ( String name ) { this . name = name ; } public void setProperty ( String property ) { this . property = property ; } public void setType ( String type ) throws ClassNotFoundException { this . type = ObjectType . loadClass ( type ) ; } public String getName ( ) { return name ; } public String getProperty ( ) { return property ; } public Object getObject ( ) { return element ; } public String getType ( ) { return type . getName ( ) ; } @ Override public int doStartTag ( ) throws JspTagException { String realAttrName = property ; if ( UtilValidate . isEmpty ( realAttrName ) ) { realAttrName = name ; } element = pageContext . findAttribute ( realAttrName ) ; if ( element != null ) { pageContext . setAttribute ( name , element ) ; } else { Debug . logWarning ( \"Did not find element in property. (\" + property + \")\" , module ) ; } return EVAL_BODY_INCLUDE ; } @", "gt": "Override public int doEndTag ( )", "prediction": "Override public Object getType ( ) throws JspTagException\n", "label": 0}
{"id": 16292, "input": "<s> package org . restlet . engine . converter ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; import java . io . Serializable ; import java . nio . channels . ReadableByteChannel ; import java . util . List ; import org . restlet . data . Form ; import org . restlet . data . MediaType ; import org . restlet . data . Preference ; import org . restlet . engine . resource . VariantInfo ; import org . restlet . representation . EmptyRepresentation ; import org . restlet . representation . FileRepresentation ; import org . restlet . representation . InputRepresentation ; import org . restlet . representation . ObjectRepresentation ; import org . restlet . representation . ReaderRepresentation ; import org . restlet . representation . Representation ; import org . restlet . representation . StringRepresentation ; import org . restlet . representation . Variant ; import org . restlet . resource . Resource ; public class DefaultConverter extends ConverterHelper { private static final VariantInfo VARIANT_ALL = new VariantInfo ( MediaType . ALL ) ; private static final VariantInfo VARIANT_FORM = new VariantInfo ( MediaType . APPLICATION_WWW_FORM ) ; private static final VariantInfo VARIANT_OBJECT = new VariantInfo ( MediaType . APPLICATION_JAVA_OBJECT ) ; private static final VariantInfo VARIANT_OBJECT_XML = new VariantInfo ( MediaType . APPLICATION_JAVA_OBJECT_XML ) ; @ Override public List < Class < ? > > getObjectClasses ( Variant source ) { List < Class < ? > > result = null ; result = addObjectClass ( result , String . class ) ; result = addObjectClass ( result , InputStream . class ) ; result = addObjectClass ( result , Reader . class ) ; result = addObjectClass ( result , ReadableByteChannel . class ) ; if ( source . getMediaType ( ) != null ) { MediaType mediaType = source . getMediaType ( ) ; if ( MediaType . APPLICATION_JAVA_OBJECT . equals ( mediaType ) || MediaType . APPLICATION_JAVA_OBJECT_XML . equals ( mediaType ) ) { result = addObjectClass ( result , Object . class ) ; } else if ( MediaType . APPLICATION_WWW_FORM . equals ( mediaType ) ) { result = addObjectClass ( result , Form . class ) ; } } return result ; } @ Override public List < VariantInfo > getVariants ( Class < ? > source ) { List < VariantInfo > result = null ; if ( source != null ) { if ( String . class . isAssignableFrom ( source ) || StringRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( File . class . isAssignableFrom ( source ) || FileRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( InputStream . class . isAssignableFrom ( source ) || InputRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( Reader . class . isAssignableFrom ( source ) || ReaderRepresentation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( Representation . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_ALL ) ; } else if ( Form . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_FORM ) ; } else if ( Serializable . class . isAssignableFrom ( source ) ) { result = addVariant ( result , VARIANT_OBJECT ) ; result = addVariant ( result , VARIANT_OBJECT_XML ) ; } } return result ; } @ Override public float score ( Object source , Variant target , Resource resource ) { float result = - 1.0F ; if ( source instanceof String ) { result = 1.0F ; } else if ( source instanceof File ) { result = 1.0F ; } else if ( source instanceof Form ) { if ( ( target != null ) && MediaType . APPLICATION_WWW_FORM . isCompatible ( target . getMediaType ( ) ) ) { result = 1.0F ; } else { result = 0.6F ; } } else if ( source instanceof InputStream ) { result = 1.0F ; } else if ( source instanceof Reader ) { result = 1.0F ; } else if ( source instanceof Representation ) { result = 1.0F ; } else if ( source instanceof Serializable ) { if ( target != null ) { if ( MediaType . APPLICATION_JAVA_OBJECT . equals ( target . getMediaType ( ) ) ) { result = 1.0F ; } else if ( MediaType . APPLICATION_JAVA_OBJECT . isCompatible ( target . getMediaType ( ) ) ) { result = 0.6F ; } else if ( MediaType . APPLICATION_JAVA_OBJECT_XML . equals ( target . getMediaType ( ) ) ) { result = 1.0F ; } else if ( MediaType . APPLICATION_JAVA_OBJECT_XML . isCompatible ( target . getMediaType ( ) ) ) { result = 0.6F ; } } else { result = 0.5F ; } } return result ; } @ Override public < T > float score ( Representation source , Class < T > target , Resource resource ) { float result = - 1.0F ; if ( target != null ) { if ( target . isAssignableFrom ( source . getClass ( ) ) ) { result = 1.0F ; } else if ( String . class . isAssignableFrom ( target ) ) { result = 1.0F ; } else if ( StringRepresentation . class . isAssignableFrom ( target ) ) { result = 1.0F ; } else if ( EmptyRepresentation . class . isAssignableFrom ( target ) ) { result = 1.0F ; } else if ( File . class . isAssignableFrom ( target ) ) { if ( source instanceof FileRepresentation ) { result = 1.0F ; } } else if ( Form . class . isAssignableFrom ( target ) ) { if ( MediaType . APPLICATION_WWW_FORM . isCompatible (", "gt": "source . getMediaType ( ) ) )", "prediction": "target . getMediaType ( ) ) )\n", "label": 1}
{"id": 1878, "input": "<s> package org . jjflyboy . tjpeditor . project . impl ; import org . eclipse . emf . common . notify . Notification ; import org . eclipse . emf . common . notify . NotificationChain ; import org . eclipse . emf . ecore . EClass ; import org . eclipse . emf . ecore . InternalEObject ; import org . eclipse . emf . ecore . impl . ENotificationImpl ; import org . jjflyboy . tjpeditor . project . HideReport ; import org . jjflyboy . tjpeditor . project . LogicalExpression ; import org . jjflyboy . tjpeditor . project . ProjectPackage ; public class HideReportImpl extends NavigatorAttributeImpl implements HideReport { protected LogicalExpression expression ; protected HideReportImpl ( ) { super ( ) ; } @ Override protected EClass eStaticClass ( ) { return ProjectPackage . eINSTANCE . getHideReport ( ) ; } public LogicalExpression getExpression ( ) { return expression ; } public NotificationChain basicSetExpression ( LogicalExpression newExpression , NotificationChain msgs ) { LogicalExpression oldExpression = expression ; expression = newExpression ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProjectPackage . HIDE_REPORT__EXPRESSION , oldExpression , newExpression ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; } public void setExpression ( LogicalExpression newExpression ) { if ( newExpression != expression ) { NotificationChain msgs = null ; if ( expression != null ) msgs = ( ( InternalEObject ) expression ) . eInverseRemove ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . HIDE_REPORT__EXPRESSION , null , msgs ) ; if ( newExpression != null ) msgs = ( ( InternalEObject ) newExpression ) . eInverseAdd ( this , EOPPOSITE_FEATURE_BASE - ProjectPackage . HIDE_REPORT__EXPRESSION , null , msgs ) ; msgs = basicSetExpression ( newExpression , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProjectPackage . HIDE_REPORT__EXPRESSION , newExpression , newExpression ) ) ; } @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProjectPackage .", "gt": "HIDE_REPORT__EXPRESSION : return basicSetExpression ( null , msgs ) ;", "prediction": "HIDE_REPORT__EXPRESSION : return ;\n", "label": 0}
{"id": 16295, "input": "<s> package org . apache . lucene . analysis ; import java . util . Arrays ; import org . apache . lucene . util . LuceneTestCase ; public class TestCharArraySet extends LuceneTestCase { static final String [ ] TEST_STOP_WORDS = { \"a\" , \"an\" , \"and\" , \"are\" , \"as\" , \"at\" , \"be\" , \"but\" , \"by\" , \"for\" , \"if\" , \"in\" , \"into\" , \"is\" , \"it\" , \"no\" , \"not\" , \"of\" , \"on\" , \"or\" , \"such\" , \"that\" , \"the\" , \"their\" , \"then\" , \"there\" , \"these\" , \"they\" , \"this\" , \"to\" , \"was\" , \"will\" , \"with\" } ; public void testRehash ( ) throws Exception { CharArraySet cas = new CharArraySet ( 0 , true ) ; for ( int i = 0 ; i < TEST_STOP_WORDS . length ; i ++ ) cas . add ( TEST_STOP_WORDS [ i ] ) ; assertEquals ( TEST_STOP_WORDS . length , cas . size ( ) ) ; for ( int i = 0 ; i < TEST_STOP_WORDS . length ; i ++ ) assertTrue ( cas . contains ( TEST_STOP_WORDS [ i ] ) ) ; } public void testNonZeroOffset ( ) { String [ ] words = { \"Hello\" , \"World\" , \"this\" , \"is\" , \"a\" , \"test\" } ; char [ ] findme = \"xthisy\" . toCharArray ( ) ; CharArraySet set = new CharArraySet ( 10 , true ) ; set . addAll ( Arrays . asList ( words ) ) ; assertTrue ( set . contains ( findme , 1 , 4 ) ) ; assertTrue ( set . contains ( new String ( findme , 1 , 4 ) ) ) ; set = CharArraySet . unmodifiableSet ( set ) ; assertTrue ( set . contains ( findme , 1 , 4 ) ) ; assertTrue ( set . contains ( new String ( findme , 1 , 4 ) ) ) ; } public void testObjectContains ( ) { CharArraySet set = new CharArraySet ( 10 , true ) ; Integer val = new Integer ( 1 ) ; set . add ( val ) ; assertTrue ( set . contains ( val ) ) ; assertTrue ( set . contains ( new Integer ( 1 ) ) ) ; set = CharArraySet . unmodifiableSet ( set ) ; assertTrue ( set . contains ( val ) ) ; assertTrue ( set . contains ( new Integer ( 1 ) ) ) ; } public void testClear ( ) { CharArraySet set = new CharArraySet ( 10 , true ) ; set . addAll ( Arrays . asList ( TEST_STOP_WORDS ) ) ; assertEquals ( \"Not all words added\" , TEST_STOP_WORDS . length , set . size ( ) ) ; try { set . clear ( ) ; fail ( \"remove is not supported\" ) ; } catch ( UnsupportedOperationException e ) { assertEquals ( \"Not all words added\" , TEST_STOP_WORDS . length , set . size ( ) ) ; } } public void testModifyOnUnmodifiable ( ) { CharArraySet set = new CharArraySet ( 10 , true ) ; set . addAll ( Arrays . asList ( TEST_STOP_WORDS ) ) ; final int size = set . size ( ) ; set = CharArraySet . unmodifiableSet ( set ) ; assertEquals ( \"Set size changed due to unmodifiableSet call\" , size , set . size ( ) ) ; String NOT_IN_SET = \"SirGallahad\" ; assertFalse ( \"Test String already exists in set\" , set . contains ( NOT_IN_SET ) ) ; try { set . add ( NOT_IN_SET . toCharArray ( ) ) ; fail ( \"Modified unmodifiable set\" ) ; } catch ( UnsupportedOperationException e ) { assertFalse ( \"Test String has been added to", "gt": "unmodifiable set\" , set . contains ( NOT_IN_SET ) ) ;", "prediction": "set\" , set . contains ( NOT_IN_SET ) ) ;\n", "label": 1}
